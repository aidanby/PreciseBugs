{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic int\tbt_nofileread(buf_T *buf);\nstatic void\tno_write_message_buf(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp != NULL)\n\treturn;\n\n    aco_save_T\taco;\n\n    // Make sure the buffer is in a window.  If not then skip it.\n    aucmd_prepbuf(&aco, buf);\n    if (curbuf == buf)\n    {\n\tif (swap_exists_action != SEA_READONLY)\n\t    swap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags_arg)\t    // extra flags for readfile()\n{\n    int\t\tflags = flags_arg;\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    // A buffer without an actual file should not use the buffer name to read a\n    // file.\n    if (bt_nofileread(curbuf))\n\tflags |= READ_NOFILE;\n\n    // Read the file if there is one.\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n\tparse_cino(curbuf);\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened, make sure it is in a window.\n\t    // If not then skip it.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    if (curbuf == old_curbuf.br_buf)\n\t    {\n\t\tdo_modelines(0);\n\t\tcurbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t\tif ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\t    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL,\n\t\t\t\t\t\t       FALSE, curbuf, &retval);\n#else\n\t\t    apply_autocmds(EVENT_BUFWINENTER, NULL, NULL,\n\t\t\t\t\t\t\t\tFALSE, curbuf);\n#endif\n\n\t\t// restore curwin/curbuf and a few other things\n\t\taucmd_restbuf(&aco);\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key, \"create buffer\") == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi, \"close buffer\");\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n    {\n\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;\n\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n    }\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    // depending on how we get here b_nwindows may already be zero\n    if (bt_terminal(buf) && (buf->b_nwindows <= 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\n\t\t// A terminal buffer is wiped out when job has finished.\n\t\tdel_buf = TRUE;\n\t\tunload_buf = TRUE;\n\t\twipe_buf = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    if (del_buf || unload_buf)\n\t    {\n\t\t// A terminal buffer is wiped out if the job has finished.\n\t\t// We only do this when there's an intention to unload the\n\t\t// buffer. This way, :hide and other similar commands won't\n\t\t// wipe the buffer.\n\t\tdel_buf = TRUE;\n\t\tunload_buf = TRUE;\n\t\twipe_buf = TRUE;\n\t    }\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\t// Do not wipe out the buffer if it is used in a window.\n\tif (buf->b_nwindows > 0)\n\t    return FALSE;\n\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eof = FALSE;\n    buf->b_start_eof = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di, \"free buffer\");\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n#ifdef FEAT_PROP_POPUP\n    ga_clear_strings(&buf->b_textprop_text);\n#endif\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n    int\t\tsave_sea = swap_exists_action;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    if (swap_exists_action == SEA_NONE)\n\tswap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = save_sea;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) && !bt_terminal(buf))\n\treturn OK;\n#endif\n    if ((action == DOBUF_GOTO || action == DOBUF_SPLIT)\n\t\t\t\t\t\t  && (buf->b_flags & BF_DUMMY))\n    {\n\t// disallow navigating to the dummy buffer\n\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\treturn FAIL;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n# ifdef FEAT_TERMINAL\n\t\tif (term_job_running(buf->b_term))\n\t\t{\n\t\t    if (term_confirm_stop(buf) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n# endif\n\t\t{\n\t\t    dialog_changed(buf, FALSE);\n\t\t    if (!bufref_valid(&bufref))\n\t\t\t// Autocommand deleted buffer, oops!  It's not changed\n\t\t\t// now.\n\t\t\treturn FAIL;\n\t\t    // If it's still changed fail silently, the dialog already\n\t\t    // mentioned why it fails.\n\t\t    if (bufIsChanged(buf))\n\t\t\treturn FAIL;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\tno_write_message_buf(buf);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl || bt_quickfix(buf))\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n\t\t\t    && !bt_quickfix(buf))\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf && !bt_quickfix(buf))\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n# ifdef FEAT_TERMINAL\n\t    if (term_job_running(curbuf->b_term))\n\t    {\n\t\tif (term_confirm_stop(curbuf) == FAIL)\n\t\t    return FAIL;\n\t\t// Manually kill the terminal here because this command will\n\t\t// hide it otherwise.\n\t\tfree_terminal(curbuf);\n\t    }\n\t    else\n# endif\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tdialog_changed(curbuf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!\n\t\t    return FAIL;\n\n\t\tif (bufIsChanged(curbuf))\n\t\t{\n\t\t    no_write_message();\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t    && ((State & MODE_INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // when closing the current buffer stop Visual mode\n    if (VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    static void\nno_write_message_buf(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\tbuf->b_fnum);\n}\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n\t&& !bt_quickfix(curbuf)\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tbuf_freeall(buf, BFA_WIPE | BFA_DEL);\n\tif (buf != curbuf)   // autocommands deleted the buffer!\n\t    return NULL;\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc_id(aid_newbuf_bvars);\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n    clear_string_option(&buf->b_p_sua);\n    clear_string_option(&buf->b_p_ft);\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n    clear_string_option(&buf->b_p_lop);\n    clear_string_option(&buf->b_p_cinsd);\n    clear_string_option(&buf->b_p_cinw);\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n    clear_string_option(&buf->b_p_qe);\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    clear_string_option(&buf->b_p_lw);\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_or_buf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"rmp->regprog\" with file name \"name\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    // extra check for valid arguments\n    if (name != NULL && rmp->regprog != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (win != NULL)\n\twip->wi_changelistidx = win->w_changelistidx;\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n    if (wip != NULL)\n\tcurwin->w_changelistidx = wip->wi_changelistidx;\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (job_running)\n\t{\n\t    if (job_none_open)\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL)\n\treturn;\n\n    if (buf->b_sfname != buf->b_ffname)\n\tvim_free(buf->b_sfname);\n    vim_free(buf->b_ffname);\n    buf->b_ffname = vim_strsave(name);\n    buf->b_sfname = NULL;\n    // Allocate ffname and expand into full path.  Also resolves .lnk\n    // files on Win32.\n    fname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n    buf->b_fname = buf->b_sfname;\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED) && !bt_dontwrite(curbuf)\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW) && !bt_dontwrite(curbuf)\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf), p_titlestring,\n\t\t\t\t    (char_u *)\"titlestring\", 0,\n\t\t\t\t    0, maxlen, NULL, NULL);\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf), p_iconstring,\n\t\t\t\t (char_u *)\"iconstring\", 0, 0, 0, NULL, NULL);\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    char_u\t*opt_name,      // option name corresponding to \"fmt\"\n    int\t\topt_scope,\t// scope for \"opt_name\"\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    int\t\tuse_sandbox;\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_redraw_not_allowed = redraw_not_allowed;\n    int\t\tsave_KeyTyped = KeyTyped;\n    // TODO: find out why using called_emsg_before makes tests fail, does it\n    // matter?\n    // int\tcalled_emsg_before = called_emsg;\n    int\t\tdid_emsg_before = did_emsg;\n\n    // When inside update_screen() we do not want redrawing a statusline,\n    // ruler, title, etc. to trigger another redraw, it may cause an endless\n    // loop.\n    if (updating_screen)\n\tredraw_not_allowed = TRUE;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\n\t// Allocate one more, because the last element is used to indicate the\n\t// end of the list.\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n    }\n\n#ifdef FEAT_EVAL\n    // if \"fmt\" was set insecurely it needs to be evaluated in the sandbox\n    use_sandbox = was_set_insecurely(opt_name, opt_scope);\n\n    // When the format starts with \"%!\" then evaluate it as an expression and\n    // use the result as the actual format string.\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s != NUL; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    // Minus one for the leading '<' added above.\n\t\t    stl_items[l].stl_start -= n - 1;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = (State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t\t       ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)((State & MODE_INSERT) == 0\n\t\t\t       && empty_line ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_SHOWCMD:\n\t    if (p_sc && STRCMP(opt_name, p_sloc) == 0)\n\t\tstr = showcmd_buf;\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0\n\t\t       ? 0L : l + 1 + ((State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t? 0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (num >= 0 || (!itemisflag && str != NULL && *str != NUL))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\t\t\t\t\t    //\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    redraw_not_allowed = save_redraw_not_allowed;\n\n    // A user function may reset KeyTyped, restore it.\n    KeyTyped = save_KeyTyped;\n\n    // Check for an error.  If there is one the display will be messed up and\n    // might loop redrawing.  Avoid that by making the corresponding option\n    // empty.\n    // TODO: find out why using called_emsg_before makes tests fail, does it\n    // matter?\n    // if (called_emsg > called_emsg_before)\n    if (did_emsg > did_emsg_before)\n\tset_string_option_direct(opt_name, -1, (char_u *)\"\",\n\t\t\t\t\t      OPT_FREE | opt_scope, SID_ERROR);\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf UNUSED)\n{\n#ifdef FEAT_QUICKFIX\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf UNUSED)\n{\n#if defined(FEAT_TERMINAL)\n    return buf != NULL && buf->b_p_bt[0] == 't';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name may not be a file name, at least not for\n * writing the buffer.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"quickfix\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer is not to be read from a file.\n */\n    static int\nbt_nofileread(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'q'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\", \"prompt\", or\n * \"popup\" buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on == curbuf->b_p_bl)\n\treturn;\n\n    curbuf->b_p_bl = on;\n    if (on)\n\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n    else\n\tapply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // Set curwin/curbuf to buf and save a few things.\n    aucmd_prepbuf(&aco, newbuf);\n    if (curbuf != newbuf)\n    {\n\t// Failed to find a window for \"newbuf\".\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "\" Test 'statusline'\n\"\n\" Not tested yet:\n\"   %N\n\nsource view_util.vim\nsource check.vim\nsource screendump.vim\n\nfunc SetUp()\n  set laststatus=2\nendfunc\n\nfunc TearDown()\n  set laststatus&\nendfunc\n\nfunc s:get_statusline()\n  return ScreenLines(&lines - 1, &columns)[0]\nendfunc\n\nfunc StatuslineWithCaughtError()\n  let s:func_in_statusline_called = 1\n  try\n    call eval('unknown expression')\n  catch\n  endtry\n  return ''\nendfunc\n\nfunc StatuslineWithError()\n  let s:func_in_statusline_called = 1\n  call eval('unknown expression')\n  return ''\nendfunc\n\n\" Function used to display syntax group.\nfunc SyntaxItem()\n  call assert_equal(s:expected_curbuf, g:actual_curbuf)\n  call assert_equal(s:expected_curwin, g:actual_curwin)\n  return synIDattr(synID(line(\".\"), col(\".\"),1), \"name\")\nendfunc\n\nfunc Test_caught_error_in_statusline()\n  let s:func_in_statusline_called = 0\n  let statusline = '%{StatuslineWithCaughtError()}'\n  let &statusline = statusline\n  redrawstatus\n  call assert_true(s:func_in_statusline_called)\n  call assert_equal(statusline, &statusline)\n  set statusline=\nendfunc\n\nfunc Test_statusline_will_be_disabled_with_error()\n  let s:func_in_statusline_called = 0\n  let statusline = '%{StatuslineWithError()}'\n  try\n    let &statusline = statusline\n    redrawstatus\n  catch\n  endtry\n  call assert_true(s:func_in_statusline_called)\n  call assert_equal('', &statusline)\n  set statusline=\nendfunc\n\nfunc Test_statusline()\n  CheckFeature quickfix\n\n  \" %a: Argument list ({current} of {max})\n  set statusline=%a\n  call assert_match('^\\s*$', s:get_statusline())\n  arglocal a1 a2\n  rewind\n  call assert_match('^ (1 of 2)\\s*$', s:get_statusline())\n  next\n  call assert_match('^ (2 of 2)\\s*$', s:get_statusline())\n  e Xstatusline\n  call assert_match('^ ((2) of 2)\\s*$', s:get_statusline())\n\n  only\n  set splitbelow\n  call setline(1, range(1, 10000))\n\n  \" %b: Value of character under cursor.\n  \" %B: As above, in hexadecimal.\n  call cursor(9000, 1)\n  set statusline=%b,%B\n  call assert_match('^57,39\\s*$', s:get_statusline())\n\n  \" %o: Byte number in file of byte under cursor, first byte is 1.\n  \" %O: As above, in hexadecimal.\n  set statusline=%o,%O\n  set fileformat=dos\n  call assert_match('^52888,CE98\\s*$', s:get_statusline())\n  set fileformat=mac\n  call assert_match('^43889,AB71\\s*$', s:get_statusline())\n  set fileformat=unix\n  call assert_match('^43889,AB71\\s*$', s:get_statusline())\n  set fileformat&\n\n  \" %f: Path to the file in the buffer, as typed or relative to current dir.\n  set statusline=%f\n  call assert_match('^Xstatusline\\s*$', s:get_statusline())\n\n  \" %F: Full path to the file in the buffer.\n  set statusline=%F\n  call assert_match('/testdir/Xstatusline\\s*$', s:get_statusline())\n\n  \" Test for min and max width with %(. For some reason, if this test is moved\n  \" after the below test for the help buffer flag, then the code to truncate\n  \" the string is not executed.\n  set statusline=%015(%f%)\n  call assert_match('^    Xstatusline\\s*$', s:get_statusline())\n  set statusline=%.6(%f%)\n  call assert_match('^<sline\\s*$', s:get_statusline())\n  set statusline=%14f\n  call assert_match('^   Xstatusline\\s*$', s:get_statusline())\n  set statusline=%.4L\n  call assert_match('^10>3\\s*$', s:get_statusline())\n\n  \" %h: Help buffer flag, text is \"[help]\".\n  \" %H: Help buffer flag, text is \",HLP\".\n  set statusline=%h,%H\n  call assert_match('^,\\s*$', s:get_statusline())\n  help\n  call assert_match('^\\[Help\\],HLP\\s*$', s:get_statusline())\n  helpclose\n\n  \" %k: Value of \"b:keymap_name\" or 'keymap'\n  \"     when :lmap mappings are being used: <keymap>\"\n  set statusline=%k\n  if has('keymap')\n    set keymap=esperanto\n    call assert_match('^<Eo>\\s*$', s:get_statusline())\n    set keymap&\n  else\n    call assert_match('^\\s*$', s:get_statusline())\n  endif\n\n  \" %l: Line number.\n  \" %L: Number of line in buffer.\n  \" %c: Column number.\n  set statusline=%l/%L,%c\n  call assert_match('^9000/10000,1\\s*$', s:get_statusline())\n\n  \" %m: Modified flag, text is \"[+]\", \"[-]\" if 'modifiable' is off.\n  \" %M: Modified flag, text is \",+\" or \",-\".\n  set statusline=%m%M\n  call assert_match('^\\[+\\],+\\s*$', s:get_statusline())\n  set nomodifiable\n  call assert_match('^\\[+-\\],+-\\s*$', s:get_statusline())\n  write\n  call assert_match('^\\[-\\],-\\s*$', s:get_statusline())\n  set modifiable&\n  call assert_match('^\\s*$', s:get_statusline())\n\n  \" %n: Buffer number.\n  set statusline=%n\n  call assert_match('^'.bufnr('%').'\\s*$', s:get_statusline())\n\n  \" %p: Percentage through file in lines as in CTRL-G.\n  \" %P: Percentage through file of displayed window.\n  set statusline=%p,%P\n  0\n  call assert_match('^0,Top\\s*$', s:get_statusline())\n  norm G\n  call assert_match('^100,Bot\\s*$', s:get_statusline())\n  9000\n  \" Don't check the exact percentage as it depends on the window size\n  call assert_match('^90,\\(Top\\|Bot\\|\\d\\+%\\)\\s*$', s:get_statusline())\n\n  \" %q: \"[Quickfix List]\", \"[Location List]\" or empty.\n  set statusline=%q\n  call assert_match('^\\s*$', s:get_statusline())\n  copen\n  call assert_match('^\\[Quickfix List\\]\\s*$', s:get_statusline())\n  cclose\n  lexpr getline(1, 2)\n  lopen\n  call assert_match('^\\[Location List\\]\\s*$', s:get_statusline())\n  lclose\n\n  \" %r: Readonly flag, text is \"[RO]\".\n  \" %R: Readonly flag, text is \",RO\".\n  set statusline=%r,%R\n  call assert_match('^,\\s*$', s:get_statusline())\n  help\n  call assert_match('^\\[RO\\],RO\\s*$', s:get_statusline())\n  helpclose\n\n  \" %t: File name (tail) of file in the buffer.\n  set statusline=%t\n  call assert_match('^Xstatusline\\s*$', s:get_statusline())\n\n  \" %v: Virtual column number.\n  \" %V: Virtual column number as -{num}. Not displayed if equal to 'c'.\n  call cursor(9000, 2)\n  set statusline=%v,%V\n  call assert_match('^2,\\s*$', s:get_statusline())\n  set virtualedit=all\n  norm 10|\n  call assert_match('^10,-10\\s*$', s:get_statusline())\n  set list\n  call assert_match('^10,-10\\s*$', s:get_statusline())\n  set virtualedit&\n  exe \"norm A\\<Tab>\\<Tab>a\\<Esc>\"\n  \" In list mode a <Tab> is shown as \"^I\", which is 2-wide.\n  call assert_match('^9,-9\\s*$', s:get_statusline())\n  set list&\n  \" Now the second <Tab> ends at the 16th screen column.\n  call assert_match('^17,-17\\s*$', s:get_statusline())\n  undo\n\n  \" %w: Preview window flag, text is \"[Preview]\".\n  \" %W: Preview window flag, text is \",PRV\".\n  set statusline=%w%W\n  call assert_match('^\\s*$', s:get_statusline())\n  pedit\n  wincmd j\n  call assert_match('^\\[Preview\\],PRV\\s*$', s:get_statusline())\n  pclose\n\n  \" %y: Type of file in the buffer, e.g., \"[vim]\". See 'filetype'.\n  \" %Y: Type of file in the buffer, e.g., \",VIM\". See 'filetype'.\n  set statusline=%y\\ %Y\n  call assert_match('^\\s*$', s:get_statusline())\n  setfiletype vim\n  call assert_match('^\\[vim\\] VIM\\s*$', s:get_statusline())\n\n  \" %=: Separation point between left and right aligned items.\n  set statusline=foo%=bar\n  call assert_match('^foo\\s\\+bar\\s*$', s:get_statusline())\n\n  \" Test min/max width, leading zeroes, left/right justify.\n  set statusline=%04B\n  call cursor(9000, 1)\n  call assert_match('^0039\\s*$', s:get_statusline())\n  set statusline=#%4B#\n  call assert_match('^#  39#\\s*$', s:get_statusline())\n  set statusline=#%-4B#\n  call assert_match('^#39  #\\s*$', s:get_statusline())\n  set statusline=%.6f\n  call assert_match('^<sline\\s*$', s:get_statusline())\n\n  \" %<: Where to truncate.\n  \" First check with when %< should not truncate with many columns\n  exe 'set statusline=a%<b' . repeat('c', &columns - 3) . 'd'\n  call assert_match('^abc\\+d$', s:get_statusline())\n  exe 'set statusline=a' . repeat('b', &columns - 2) . '%<c'\n  call assert_match('^ab\\+c$', s:get_statusline())\n  \" Then check when %< should truncate when there with too few columns.\n  exe 'set statusline=a%<b' . repeat('c', &columns - 2) . 'd'\n  call assert_match('^a<c\\+d$', s:get_statusline())\n  exe 'set statusline=a' . repeat('b', &columns - 1) . '%<c'\n  call assert_match('^ab\\+>$', s:get_statusline())\n\n  \"%{: Evaluate expression between '%{' and '}' and substitute result.\n  syntax on\n  let s:expected_curbuf = string(bufnr(''))\n  let s:expected_curwin = string(win_getid())\n  set statusline=%{SyntaxItem()}\n  call assert_match('^vimNumber\\s*$', s:get_statusline())\n  s/^/\"/\n  call assert_match('^vimLineComment\\s*$', s:get_statusline())\n  syntax off\n\n  \"%{%expr%}: evaluates expressions present in result of expr\n  func! Inner_eval()\n    return '%n some other text'\n  endfunc\n  func! Outer_eval()\n    return 'some text %{%Inner_eval()%}'\n  endfunc\n  set statusline=%{%Outer_eval()%}\n  call assert_match('^some text ' . bufnr() . ' some other text\\s*$', s:get_statusline())\n  delfunc Inner_eval\n  delfunc Outer_eval\n\n  \"%{%expr%}: Doesn't get stuck in recursion\n  func! Recurse_eval()\n    return '%{%Recurse_eval()%}'\n  endfunc\n  set statusline=%{%Recurse_eval()%}\n  call assert_match('^%{%Recurse_eval()%}\\s*$', s:get_statusline())\n  delfunc Recurse_eval\n\n  \"%(: Start of item group.\n  set statusline=ab%(cd%q%)de\n  call assert_match('^abde\\s*$', s:get_statusline())\n  copen\n  call assert_match('^abcd\\[Quickfix List]de\\s*$', s:get_statusline())\n  cclose\n\n  \" %#: Set highlight group. The name must follow and then a # again.\n  set statusline=ab%#Todo#cd%#Error#ef\n  call assert_match('^abcdef\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  call assert_notequal(sa1, sa2)\n  call assert_notequal(sa1, sa3)\n  call assert_notequal(sa2, sa3)\n  call assert_equal(sa1, screenattr(&lines - 1, 2))\n  call assert_equal(sa2, screenattr(&lines - 1, 4))\n  call assert_equal(sa3, screenattr(&lines - 1, 6))\n  call assert_equal(sa3, screenattr(&lines - 1, 7))\n\n  \" %*: Set highlight group to User{N}\n  set statusline=a%1*b%0*c\n  call assert_match('^abc\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 2)\n  let sa3=screenattr(&lines - 1, 3)\n  call assert_equal(sa1, sa3)\n  call assert_notequal(sa1, sa2)\n\n  \" An empty group that contains highlight changes\n  let g:a = ''\n  set statusline=ab%(cd%1*%{g:a}%*%)de\n  call assert_match('^abde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 4)\n  call assert_equal(sa1, sa2)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 5)\n  let sa3=screenattr(&lines - 1, 7)\n  call assert_equal(sa1, sa3)\n  call assert_notequal(sa1, sa2)\n\n  let g:a = ''\n  set statusline=ab%1*%(cd%*%{g:a}%1*%)de\n  call assert_match('^abde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 4)\n  call assert_notequal(sa1, sa2)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  let sa4=screenattr(&lines - 1, 7)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa1, sa3)\n  call assert_equal(sa2, sa4)\n\n  \" An empty group that contains highlight changes and doesn't reset them\n  let g:a = ''\n  set statusline=ab%(cd%1*%{g:a}%)de\n  call assert_match('^abcdde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 5)\n  call assert_notequal(sa1, sa2)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 5)\n  let sa3=screenattr(&lines - 1, 7)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa2, sa3)\n\n  let g:a = ''\n  set statusline=ab%1*%(cd%*%{g:a}%)de\n  call assert_match('^abcdde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa1, sa3)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  let sa4=screenattr(&lines - 1, 7)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa1, sa3)\n  call assert_equal(sa1, sa4)\n\n  let g:a = ''\n  set statusline=%#Error#{%(\\ %{g:a}\\ %)}\n  call assert_match('^{}\\s*$', s:get_statusline())\n  let g:a = 'X'\n  call assert_match('^{ X }\\s*$', s:get_statusline())\n\n  \" %%: a percent sign.\n  set statusline=10%%\n  call assert_match('^10%\\s*$', s:get_statusline())\n\n  \" %!: evaluated expression is used as the option value\n  set statusline=%!2*3+1\n  call assert_match('7\\s*$', s:get_statusline())\n\n  func GetNested()\n    call assert_equal(string(win_getid()), g:actual_curwin)\n    call assert_equal(string(bufnr('')), g:actual_curbuf)\n    return 'nested'\n  endfunc\n  func GetStatusLine()\n    call assert_equal(win_getid(), g:statusline_winid)\n    return 'the %{GetNested()} line'\n  endfunc\n  set statusline=%!GetStatusLine()\n  call assert_match('the nested line', s:get_statusline())\n  call assert_false(exists('g:actual_curwin'))\n  call assert_false(exists('g:actual_curbuf'))\n  call assert_false(exists('g:statusline_winid'))\n  delfunc GetNested\n  delfunc GetStatusLine\n\n  \" Test statusline works with 80+ items\n  function! StatusLabel()\n    redrawstatus\n    return '[label]'\t\n  endfunc\n  let statusline = '%{StatusLabel()}'\n  for i in range(150)\n    let statusline .= '%#TabLine' . (i % 2 == 0 ? 'Fill' : 'Sel') . '#' . string(i)[0]\n  endfor\n  let &statusline = statusline\n  redrawstatus\n  set statusline&\n  delfunc StatusLabel\n\n\n  \" Check statusline in current and non-current window\n  \" with the 'fillchars' option.\n  set fillchars=stl:^,stlnc:=,vert:\\|,fold:-,diff:-\n  vsplit\n  set statusline=x%=y\n  call assert_match('^x^\\+y^x=\\+y$', s:get_statusline())\n  set fillchars&\n  close\n\n  %bw!\n  call delete('Xstatusline')\n  set statusline&\n  set splitbelow&\nendfunc\n\nfunc Test_statusline_visual()\n  func CallWordcount()\n    call wordcount()\n  endfunc\n  new x1\n  setl statusline=count=%{CallWordcount()}\n  \" buffer must not be empty\n  call setline(1, 'hello')\n\n  \" window with more lines than x1\n  new x2\n  call setline(1, range(10))\n  $\n  \" Visual mode in line below liast line in x1 should not give ml_get error\n  call feedkeys(\"\\<C-V>\", \"xt\")\n  redraw\n\n  delfunc CallWordcount\n  bwipe! x1\n  bwipe! x2\nendfunc\n\nfunc Test_statusline_removed_group()\n  CheckScreendump\n\n  let lines =<< trim END\n    scriptencoding utf-8\n    set laststatus=2\n    let &statusline = '%#StatColorHi2#%(\u2713%#StatColorHi2#%) Q\u2261'\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 10, 'cols': 50})\n  call VerifyScreenDump(buf, 'Test_statusline_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_statusline_using_mode()\n  CheckScreendump\n\n  let lines =<< trim END\n    setlocal statusline=-%{mode()}-\n    split\n    setlocal statusline=+%{mode()}+\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 7, 'cols': 50})\n  call VerifyScreenDump(buf, 'Test_statusline_mode_1', {})\n\n  call term_sendkeys(buf, \":\")\n  call VerifyScreenDump(buf, 'Test_statusline_mode_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"close\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_statusline_after_split_vsplit()\n  only\n\n  \" Make the status line of each window show the window number.\n  set ls=2 stl=%{winnr()}\n\n  split | redraw\n  vsplit | redraw\n\n  \" The status line of the third window should read '3' here.\n  call assert_equal('3', nr2char(screenchar(&lines - 1, 1)))\n\n  only\n  set ls& stl&\nendfunc\n\n\" Test using a multibyte character for 'stl' and 'stlnc' items in 'fillchars'\n\" with a custom 'statusline'\nfunc Test_statusline_mbyte_fillchar()\n  only\n  set fillchars=vert:\\|,fold:-,stl:\u2501,stlnc:\u2550\n  set statusline=a%=b\n  call assert_match('^a\\+\u2501\\+b$', s:get_statusline())\n  vnew\n  call assert_match('^a\\+\u2501\\+b\u2501a\\+\u2550\\+b$', s:get_statusline())\n  wincmd w\n  call assert_match('^a\\+\u2550\\+b\u2550a\\+\u2501\\+b$', s:get_statusline())\n  set statusline& fillchars&\n  %bw!\nendfunc\n\n\" Used to write beyond allocated memory.  This assumes MAXPATHL is 4096 bytes.\nfunc Test_statusline_verylong_filename()\n  let fname = repeat('x', 4090)\n  exe \"new \" .. fname\n  set buftype=help\n  set previewwindow\n  redraw\n  bwipe!\nendfunc\n\nfunc Test_statusline_highlight_truncate()\n  CheckScreendump\n\n  let lines =<< trim END\n    set laststatus=2\n    hi! link User1 Directory\n    hi! link User2 ErrorMsg\n    set statusline=%.5(%1*ABC%2*DEF%1*GHI%)\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 6})\n  call VerifyScreenDump(buf, 'Test_statusline_hl', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_statusline_showcmd()\n  CheckScreendump\n\n  let lines =<< trim END\n    set laststatus=2\n    set statusline=%S\n    set showcmdloc=statusline\n    call setline(1, ['a', 'b', 'c'])\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 6})\n  call feedkeys(\"\\<C-V>Gl\", \"xt\")\n  call VerifyScreenDump(buf, 'Test_statusline_showcmd_1', {})\n\n  call feedkeys(\"\\<Esc>1234\", \"xt\")\n  call VerifyScreenDump(buf, 'Test_statusline_showcmd_2', {})\n\n  call feedkeys(\"\\<Esc>:set statusline=\\<CR>:\\<CR>1234\", \"xt\")\n  call VerifyScreenDump(buf, 'Test_statusline_showcmd_3', {})\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * buffer.c: functions for dealing with the buffer structure\n */\n\n/*\n * The buffer list is a double linked list of all buffers.\n * Each buffer can be in one of these states:\n * never loaded: BF_NEVERLOADED is set, only the file name is valid\n *   not loaded: b_ml.ml_mfp == NULL, no memfile allocated\n *\t hidden: b_nwindows == 0, loaded but not displayed in a window\n *\t normal: loaded and displayed in a window\n *\n * Instead of storing file names all over the place, each file name is\n * stored in the buffer list. It can be referenced by a number.\n *\n * The current implementation remembers all file names ever used.\n */\n\n#include \"vim.h\"\n\n\n#ifdef FEAT_EVAL\n// Determines how deeply nested %{} blocks will be evaluated in statusline.\n# define MAX_STL_EVAL_DEPTH 100\n#endif\n\nstatic void\tenter_buffer(buf_T *buf);\nstatic void\tbuflist_getfpos(void);\nstatic char_u\t*buflist_match(regmatch_T *rmp, buf_T *buf, int ignore_case);\nstatic char_u\t*fname_match(regmatch_T *rmp, char_u *name, int ignore_case);\n#ifdef UNIX\nstatic buf_T\t*buflist_findname_stat(char_u *ffname, stat_T *st);\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname, stat_T *stp);\nstatic int\tbuf_same_ino(buf_T *buf, stat_T *stp);\n#else\nstatic int\totherfile_buf(buf_T *buf, char_u *ffname);\n#endif\nstatic int\tvalue_changed(char_u *str, char_u **last);\nstatic int\tappend_arg_number(win_T *wp, char_u *buf, int buflen, int add_file);\nstatic void\tfree_buffer(buf_T *);\nstatic void\tfree_buffer_stuff(buf_T *buf, int free_options);\nstatic int\tbt_nofileread(buf_T *buf);\nstatic void\tno_write_message_buf(buf_T *buf);\n\n#ifdef UNIX\n# define dev_T dev_t\n#else\n# define dev_T unsigned\n#endif\n\n#define FOR_ALL_BUFS_FROM_LAST(buf) \\\n    for ((buf) = lastbuf; (buf) != NULL; (buf) = (buf)->b_prev)\n\n#if defined(FEAT_QUICKFIX)\nstatic char *msg_loclist = N_(\"[Location List]\");\nstatic char *msg_qflist = N_(\"[Quickfix List]\");\n#endif\n\n// Number of times free_buffer() was called.\nstatic int\tbuf_free_count = 0;\n\nstatic int\ttop_file_num = 1;\t// highest file number\nstatic garray_T buf_reuse = GA_EMPTY;\t// file numbers to recycle\n\n/*\n * Return the highest possible buffer number.\n */\n    int\nget_highest_fnum(void)\n{\n    return top_file_num - 1;\n}\n\n/*\n * Read data from buffer for retrying.\n */\n    static int\nread_buffer(\n    int\t\tread_stdin,\t    // read file from stdin, otherwise fifo\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags)\t\t    // extra flags for readfile()\n{\n    int\t\tretval = OK;\n    linenr_T\tline_count;\n\n    // Read from the buffer which the text is already filled in and append at\n    // the end.  This makes it possible to retry when 'fileformat' or\n    // 'fileencoding' was guessed wrong.\n    line_count = curbuf->b_ml.ml_line_count;\n    retval = readfile(\n\t    read_stdin ? NULL : curbuf->b_ffname,\n\t    read_stdin ? NULL : curbuf->b_fname,\n\t    line_count, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t    flags | READ_BUFFER);\n    if (retval == OK)\n    {\n\t// Delete the binary lines.\n\twhile (--line_count >= 0)\n\t    ml_delete((linenr_T)1);\n    }\n    else\n    {\n\t// Delete the converted lines.\n\twhile (curbuf->b_ml.ml_line_count > line_count)\n\t    ml_delete(line_count);\n    }\n    // Put the cursor on the first line.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n\n    if (read_stdin)\n    {\n\t// Set or reset 'modified' before executing autocommands, so that\n\t// it can be changed there.\n\tif (!readonlymode && !BUFEMPTY())\n\t    changed();\n\telse if (retval == OK)\n\t    unchanged(curbuf, FALSE, TRUE);\n\n\tif (retval == OK)\n\t{\n#ifdef FEAT_EVAL\n\t    apply_autocmds_retval(EVENT_STDINREADPOST, NULL, NULL, FALSE,\n\t\t\t\t\t\t\t      curbuf, &retval);\n#else\n\t    apply_autocmds(EVENT_STDINREADPOST, NULL, NULL, FALSE, curbuf);\n#endif\n\t}\n    }\n    return retval;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Ensure buffer \"buf\" is loaded.  Does not trigger the swap-exists action.\n */\n    void\nbuffer_ensure_loaded(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp != NULL)\n\treturn;\n\n    aco_save_T\taco;\n\n    // Make sure the buffer is in a window.  If not then skip it.\n    aucmd_prepbuf(&aco, buf);\n    if (curbuf == buf)\n    {\n\tif (swap_exists_action != SEA_READONLY)\n\t    swap_exists_action = SEA_NONE;\n\topen_buffer(FALSE, NULL, 0);\n\taucmd_restbuf(&aco);\n    }\n}\n#endif\n\n/*\n * Open current buffer, that is: open the memfile and read the file into\n * memory.\n * Return FAIL for failure, OK otherwise.\n */\n    int\nopen_buffer(\n    int\t\tread_stdin,\t    // read file from stdin\n    exarg_T\t*eap,\t\t    // for forced 'ff' and 'fenc' or NULL\n    int\t\tflags_arg)\t    // extra flags for readfile()\n{\n    int\t\tflags = flags_arg;\n    int\t\tretval = OK;\n    bufref_T\told_curbuf;\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    int\t\tread_fifo = FALSE;\n\n    // The 'readonly' flag is only set when BF_NEVERLOADED is being reset.\n    // When re-entering the same buffer, it should not change, because the\n    // user may have reset the flag by hand.\n    if (readonlymode && curbuf->b_ffname != NULL\n\t\t\t\t\t&& (curbuf->b_flags & BF_NEVERLOADED))\n\tcurbuf->b_p_ro = TRUE;\n\n    if (ml_open(curbuf) == FAIL)\n    {\n\t// There MUST be a memfile, otherwise we can't do anything\n\t// If we can't create one for the current buffer, take another buffer\n\tclose_buffer(NULL, curbuf, 0, FALSE, FALSE);\n\tFOR_ALL_BUFFERS(curbuf)\n\t    if (curbuf->b_ml.ml_mfp != NULL)\n\t\tbreak;\n\t// If there is no memfile at all, exit.\n\t// This is OK, since there are no changes to lose.\n\tif (curbuf == NULL)\n\t{\n\t    emsg(_(e_cannot_allocate_any_buffer_exiting));\n\n\t    // Don't try to do any saving, with \"curbuf\" NULL almost nothing\n\t    // will work.\n\t    v_dying = 2;\n\t    getout(2);\n\t}\n\n\temsg(_(e_cannot_allocate_buffer_using_other_one));\n\tenter_buffer(curbuf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n\treturn FAIL;\n    }\n\n    // The autocommands in readfile() may change the buffer, but only AFTER\n    // reading the file.\n    set_bufref(&old_curbuf, curbuf);\n    modified_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    // A buffer without an actual file should not use the buffer name to read a\n    // file.\n    if (bt_nofileread(curbuf))\n\tflags |= READ_NOFILE;\n\n    // Read the file if there is one.\n    if (curbuf->b_ffname != NULL\n#ifdef FEAT_NETBEANS_INTG\n\t    && netbeansReadFile\n#endif\n       )\n    {\n\tint old_msg_silent = msg_silent;\n#ifdef UNIX\n\tint save_bin = curbuf->b_p_bin;\n\tint perm;\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\tint oldFire = netbeansFireChanges;\n\n\tnetbeansFireChanges = 0;\n#endif\n#ifdef UNIX\n\tperm = mch_getperm(curbuf->b_ffname);\n\tif (perm >= 0 && (S_ISFIFO(perm)\n\t\t      || S_ISSOCK(perm)\n# ifdef OPEN_CHR_FILES\n\t\t      || (S_ISCHR(perm) && is_dev_fd_file(curbuf->b_ffname))\n# endif\n\t\t    ))\n\t\tread_fifo = TRUE;\n\tif (read_fifo)\n\t    curbuf->b_p_bin = TRUE;\n#endif\n\tif (shortmess(SHM_FILEINFO))\n\t    msg_silent = 1;\n\tretval = readfile(curbuf->b_ffname, curbuf->b_fname,\n\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM, eap,\n\t\t  flags | READ_NEW | (read_fifo ? READ_FIFO : 0));\n#ifdef UNIX\n\tif (read_fifo)\n\t{\n\t    curbuf->b_p_bin = save_bin;\n\t    if (retval == OK)\n\t\tretval = read_buffer(FALSE, eap, flags);\n\t}\n#endif\n\tmsg_silent = old_msg_silent;\n#ifdef FEAT_NETBEANS_INTG\n\tnetbeansFireChanges = oldFire;\n#endif\n\t// Help buffer is filtered.\n\tif (bt_help(curbuf))\n\t    fix_help_buffer();\n    }\n    else if (read_stdin)\n    {\n\tint\tsave_bin = curbuf->b_p_bin;\n\n\t// First read the text in binary mode into the buffer.\n\t// Then read from that same buffer and append at the end.  This makes\n\t// it possible to retry when 'fileformat' or 'fileencoding' was\n\t// guessed wrong.\n\tcurbuf->b_p_bin = TRUE;\n\tretval = readfile(NULL, NULL, (linenr_T)0,\n\t\t  (linenr_T)0, (linenr_T)MAXLNUM, NULL,\n\t\t  flags | (READ_NEW + READ_STDIN));\n\tcurbuf->b_p_bin = save_bin;\n\tif (retval == OK)\n\t    retval = read_buffer(TRUE, eap, flags);\n    }\n\n    // if first time loading this buffer, init b_chartab[]\n    if (curbuf->b_flags & BF_NEVERLOADED)\n    {\n\t(void)buf_init_chartab(curbuf, FALSE);\n\tparse_cino(curbuf);\n    }\n\n    // Set/reset the Changed flag first, autocmds may change the buffer.\n    // Apply the automatic commands, before processing the modelines.\n    // So the modelines have priority over autocommands.\n    //\n    // When reading stdin, the buffer contents always needs writing, so set\n    // the changed flag.  Unless in readonly mode: \"ls | gview -\".\n    // When interrupted and 'cpoptions' contains 'i' set changed flag.\n    if ((got_int && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n\t\t|| modified_was_set\t// \":set modified\" used in autocmd\n#ifdef FEAT_EVAL\n\t\t|| (aborting() && vim_strchr(p_cpo, CPO_INTMOD) != NULL)\n#endif\n       )\n\tchanged();\n    else if (retval == OK && !read_stdin && !read_fifo)\n\tunchanged(curbuf, FALSE, TRUE);\n    save_file_ff(curbuf);\t\t// keep this fileformat\n\n    // Set last_changedtick to avoid triggering a TextChanged autocommand right\n    // after it was added.\n    curbuf->b_last_changedtick = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_i = CHANGEDTICK(curbuf);\n    curbuf->b_last_changedtick_pum = CHANGEDTICK(curbuf);\n\n    // require \"!\" to overwrite the file, because it wasn't read completely\n#ifdef FEAT_EVAL\n    if (aborting())\n#else\n    if (got_int)\n#endif\n\tcurbuf->b_flags |= BF_READERR;\n\n#ifdef FEAT_FOLDING\n    // Need to update automatic folding.  Do this before the autocommands,\n    // they may use the fold info.\n    foldUpdateAll(curwin);\n#endif\n\n    // need to set w_topline, unless some autocommand already did that.\n    if (!(curwin->w_valid & VALID_TOPLINE))\n    {\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n    }\n#ifdef FEAT_EVAL\n    apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf, &retval);\n#else\n    apply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n#endif\n\n    if (retval == OK)\n    {\n\t// The autocommands may have changed the current buffer.  Apply the\n\t// modelines to the correct buffer, if it still exists and is loaded.\n\tif (bufref_valid(&old_curbuf) && old_curbuf.br_buf->b_ml.ml_mfp != NULL)\n\t{\n\t    aco_save_T\taco;\n\n\t    // Go to the buffer that was opened, make sure it is in a window.\n\t    // If not then skip it.\n\t    aucmd_prepbuf(&aco, old_curbuf.br_buf);\n\t    if (curbuf == old_curbuf.br_buf)\n\t    {\n\t\tdo_modelines(0);\n\t\tcurbuf->b_flags &= ~(BF_CHECK_RO | BF_NEVERLOADED);\n\n\t\tif ((flags & READ_NOWINENTER) == 0)\n#ifdef FEAT_EVAL\n\t\t    apply_autocmds_retval(EVENT_BUFWINENTER, NULL, NULL,\n\t\t\t\t\t\t       FALSE, curbuf, &retval);\n#else\n\t\t    apply_autocmds(EVENT_BUFWINENTER, NULL, NULL,\n\t\t\t\t\t\t\t\tFALSE, curbuf);\n#endif\n\n\t\t// restore curwin/curbuf and a few other things\n\t\taucmd_restbuf(&aco);\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * Store \"buf\" in \"bufref\" and set the free count.\n */\n    void\nset_bufref(bufref_T *bufref, buf_T *buf)\n{\n    bufref->br_buf = buf;\n    bufref->br_fnum = buf == NULL ? 0 : buf->b_fnum;\n    bufref->br_buf_free_count = buf_free_count;\n}\n\n/*\n * Return TRUE if \"bufref->br_buf\" points to the same buffer as when\n * set_bufref() was called and it is a valid buffer.\n * Only goes through the buffer list if buf_free_count changed.\n * Also checks if b_fnum is still the same, a :bwipe followed by :new might get\n * the same allocated memory, but it's a different buffer.\n */\n    int\nbufref_valid(bufref_T *bufref)\n{\n    return bufref->br_buf_free_count == buf_free_count\n\t? TRUE : buf_valid(bufref->br_buf)\n\t\t\t\t  && bufref->br_fnum == bufref->br_buf->b_fnum;\n}\n\n/*\n * Return TRUE if \"buf\" points to a valid buffer (in the buffer list).\n * This can be slow if there are many buffers, prefer using bufref_valid().\n */\n    int\nbuf_valid(buf_T *buf)\n{\n    buf_T\t*bp;\n\n    // Assume that we more often have a recent buffer, start with the last\n    // one.\n    FOR_ALL_BUFS_FROM_LAST(bp)\n\tif (bp == buf)\n\t    return TRUE;\n    return FALSE;\n}\n\n/*\n * A hash table used to quickly lookup a buffer by its number.\n */\nstatic hashtab_T buf_hashtab;\n\n    static void\nbuf_hashtab_add(buf_T *buf)\n{\n    sprintf((char *)buf->b_key, \"%x\", buf->b_fnum);\n    if (hash_add(&buf_hashtab, buf->b_key, \"create buffer\") == FAIL)\n\temsg(_(e_buffer_cannot_be_registered));\n}\n\n    static void\nbuf_hashtab_remove(buf_T *buf)\n{\n    hashitem_T *hi = hash_find(&buf_hashtab, buf->b_key);\n\n    if (!HASHITEM_EMPTY(hi))\n\thash_remove(&buf_hashtab, hi, \"close buffer\");\n}\n\n/*\n * Return TRUE when buffer \"buf\" can be unloaded.\n * Give an error message and return FALSE when the buffer is locked or the\n * screen is being redrawn and the buffer is in a window.\n */\n    static int\ncan_unload_buffer(buf_T *buf)\n{\n    int\t    can_unload = !buf->b_locked;\n\n    if (can_unload && updating_screen)\n    {\n\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n    {\n\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;\n\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n    }\n    return can_unload;\n}\n\n/*\n * Close the link to a buffer.\n * \"action\" is used when there is no longer a window for the buffer.\n * It can be:\n * 0\t\t\tbuffer becomes hidden\n * DOBUF_UNLOAD\t\tbuffer is unloaded\n * DOBUF_DELETE\t\tbuffer is unloaded and removed from buffer list\n * DOBUF_WIPE\t\tbuffer is unloaded and really deleted\n * DOBUF_WIPE_REUSE\tidem, and add to buf_reuse list\n * When doing all but the first one on the current buffer, the caller should\n * get a new buffer very soon!\n *\n * The 'bufhidden' option can force freeing and deleting.\n *\n * When \"abort_if_last\" is TRUE then do not close the buffer if autocommands\n * cause there to be only one window with this buffer.  e.g. when \":quit\" is\n * supposed to close the window but autocommands close all other windows.\n *\n * When \"ignore_abort\" is TRUE don't abort even when aborting() returns TRUE.\n *\n * Return TRUE when we got to the end and b_nwindows was decremented.\n */\n    int\nclose_buffer(\n    win_T\t*win,\t\t// if not NULL, set b_last_cursor\n    buf_T\t*buf,\n    int\t\taction,\n    int\t\tabort_if_last,\n    int\t\tignore_abort)\n{\n    int\t\tis_curbuf;\n    int\t\tnwindows;\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n    int\t\tunload_buf = (action != 0);\n    int\t\twipe_buf = (action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n    int\t\tdel_buf = (action == DOBUF_DEL || wipe_buf);\n\n    CHECK_CURBUF;\n\n    // Force unloading or deleting when 'bufhidden' says so.\n    // The caller must take care of NOT deleting/freeing when 'bufhidden' is\n    // \"hide\" (otherwise we could never free or delete a buffer).\n    if (buf->b_p_bh[0] == 'd')\t\t// 'bufhidden' == \"delete\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'w')\t// 'bufhidden' == \"wipe\"\n    {\n\tdel_buf = TRUE;\n\tunload_buf = TRUE;\n\twipe_buf = TRUE;\n    }\n    else if (buf->b_p_bh[0] == 'u')\t// 'bufhidden' == \"unload\"\n\tunload_buf = TRUE;\n\n#ifdef FEAT_TERMINAL\n    // depending on how we get here b_nwindows may already be zero\n    if (bt_terminal(buf) && (buf->b_nwindows <= 1 || del_buf))\n    {\n\tCHECK_CURBUF;\n\tif (term_job_running(buf->b_term))\n\t{\n\t    if (wipe_buf || unload_buf)\n\t    {\n\t\tif (!can_unload_buffer(buf))\n\t\t    return FALSE;\n\n\t\t// Wiping out or unloading a terminal buffer kills the job.\n\t\tfree_terminal(buf);\n\n\t\t// A terminal buffer is wiped out when job has finished.\n\t\tdel_buf = TRUE;\n\t\tunload_buf = TRUE;\n\t\twipe_buf = TRUE;\n\t    }\n\t    else\n\t    {\n\t\t// The job keeps running, hide the buffer.\n\t\tdel_buf = FALSE;\n\t\tunload_buf = FALSE;\n\t    }\n\t}\n\telse if (buf->b_p_bh[0] == 'h' && !del_buf)\n\t{\n\t    // Hide a terminal buffer.\n\t    unload_buf = FALSE;\n\t}\n\telse\n\t{\n\t    if (del_buf || unload_buf)\n\t    {\n\t\t// A terminal buffer is wiped out if the job has finished.\n\t\t// We only do this when there's an intention to unload the\n\t\t// buffer. This way, :hide and other similar commands won't\n\t\t// wipe the buffer.\n\t\tdel_buf = TRUE;\n\t\tunload_buf = TRUE;\n\t\twipe_buf = TRUE;\n\t    }\n\t}\n\tCHECK_CURBUF;\n    }\n#endif\n\n    // Disallow deleting the buffer when it is locked (already being closed or\n    // halfway a command that relies on it). Unloading is allowed.\n    if ((del_buf || wipe_buf) && !can_unload_buffer(buf))\n\treturn FALSE;\n\n    // check no autocommands closed the window\n    if (win != NULL && win_valid_any_tab(win))\n    {\n\t// Set b_last_cursor when closing the last window for the buffer.\n\t// Remember the last cursor position and window options of the buffer.\n\t// This used to be only for the current window, but then options like\n\t// 'foldmethod' may be lost with a \":only\" command.\n\tif (buf->b_nwindows == 1)\n\t    set_last_cursor(win);\n\tbuflist_setfpos(buf, win,\n\t\t    win->w_cursor.lnum == 1 ? 0 : win->w_cursor.lnum,\n\t\t    win->w_cursor.col, TRUE);\n    }\n\n    set_bufref(&bufref, buf);\n\n    // When the buffer is no longer in a window, trigger BufWinLeave\n    if (buf->b_nwindows == 1)\n    {\n\t++buf->b_locked;\n\t++buf->b_locked_split;\n\tif (apply_autocmds(EVENT_BUFWINLEAVE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t{\n\t    // Autocommands deleted the buffer.\naucmd_abort:\n\t    emsg(_(e_autocommands_caused_command_to_abort));\n\t    return FALSE;\n\t}\n\t--buf->b_locked;\n\t--buf->b_locked_split;\n\tif (abort_if_last && one_window())\n\t    // Autocommands made this the only window.\n\t    goto aucmd_abort;\n\n\t// When the buffer becomes hidden, but is not unloaded, trigger\n\t// BufHidden\n\tif (!unload_buf)\n\t{\n\t    ++buf->b_locked;\n\t    ++buf->b_locked_split;\n\t    if (apply_autocmds(EVENT_BUFHIDDEN, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\t// Autocommands deleted the buffer.\n\t\tgoto aucmd_abort;\n\t    --buf->b_locked;\n\t    --buf->b_locked_split;\n\t    if (abort_if_last && one_window())\n\t\t// Autocommands made this the only window.\n\t\tgoto aucmd_abort;\n\t}\n#ifdef FEAT_EVAL\n\t// autocmds may abort script processing\n\tif (!ignore_abort && aborting())\n\t    return FALSE;\n#endif\n    }\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n    nwindows = buf->b_nwindows;\n\n    // decrease the link count from windows (unless not in any window)\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n#ifdef FEAT_DIFF\n    if (diffopt_hiddenoff() && !unload_buf && buf->b_nwindows == 0)\n\tdiff_buf_delete(buf);\t// Clear 'diff' for hidden buffer.\n#endif\n\n    // Return when a window is displaying the buffer or when it's not\n    // unloaded.\n    if (buf->b_nwindows > 0 || !unload_buf)\n\treturn FALSE;\n\n    // Always remove the buffer when there is no file name.\n    if (buf->b_ffname == NULL)\n\tdel_buf = TRUE;\n\n    // When closing the current buffer stop Visual mode before freeing\n    // anything.\n    if (buf == curbuf && VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Free all things allocated for this buffer.\n    // Also calls the \"BufDelete\" autocommands when del_buf is TRUE.\n    //\n    // Remember if we are closing the current buffer.  Restore the number of\n    // windows, so that autocommands in buf_freeall() don't get confused.\n    is_curbuf = (buf == curbuf);\n    buf->b_nwindows = nwindows;\n\n    buf_freeall(buf, (del_buf ? BFA_DEL : 0)\n\t\t   + (wipe_buf ? BFA_WIPE : 0)\n\t\t   + (ignore_abort ? BFA_IGNORE_ABORT : 0));\n\n    // Autocommands may have deleted the buffer.\n    if (!bufref_valid(&bufref))\n\treturn FALSE;\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if (!ignore_abort && aborting())\n\treturn FALSE;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause the previous curbuf to be deleted unexpectedly.  But\n    // in some cases it's OK to delete the curbuf, because a new one is\n    // obtained anyway.  Therefore only return if curbuf changed to the\n    // deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn FALSE;\n\n    if (win_valid_any_tab(win) && win->w_buffer == buf)\n\twin->w_buffer = NULL;  // make sure we don't use the buffer now\n\n    // Autocommands may have opened or closed windows for this buffer.\n    // Decrement the count for the close we do here.\n    if (buf->b_nwindows > 0)\n\t--buf->b_nwindows;\n\n    /*\n     * Remove the buffer from the list.\n     */\n    if (wipe_buf)\n    {\n\t// Do not wipe out the buffer if it is used in a window.\n\tif (buf->b_nwindows > 0)\n\t    return FALSE;\n\n\tif (action == DOBUF_WIPE_REUSE)\n\t{\n\t    // we can re-use this buffer number, store it\n\t    if (buf_reuse.ga_itemsize == 0)\n\t\tga_init2(&buf_reuse, sizeof(int), 50);\n\t    if (ga_grow(&buf_reuse, 1) == OK)\n\t\t((int *)buf_reuse.ga_data)[buf_reuse.ga_len++] = buf->b_fnum;\n\t}\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf->b_prev == NULL)\n\t    firstbuf = buf->b_next;\n\telse\n\t    buf->b_prev->b_next = buf->b_next;\n\tif (buf->b_next == NULL)\n\t    lastbuf = buf->b_prev;\n\telse\n\t    buf->b_next->b_prev = buf->b_prev;\n\tfree_buffer(buf);\n    }\n    else\n    {\n\tif (del_buf)\n\t{\n\t    // Free all internal variables and reset option values, to make\n\t    // \":bdel\" compatible with Vim 5.7.\n\t    free_buffer_stuff(buf, TRUE);\n\n\t    // Make it look like a new buffer.\n\t    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n\n\t    // Init the options when loaded again.\n\t    buf->b_p_initialized = FALSE;\n\t}\n\tbuf_clear_file(buf);\n\tif (del_buf)\n\t    buf->b_p_bl = FALSE;\n    }\n    // NOTE: at this point \"curbuf\" may be invalid!\n    return TRUE;\n}\n\n/*\n * Make buffer not contain a file.\n */\n    void\nbuf_clear_file(buf_T *buf)\n{\n    buf->b_ml.ml_line_count = 1;\n    unchanged(buf, TRUE, TRUE);\n    buf->b_shortname = FALSE;\n    buf->b_p_eof = FALSE;\n    buf->b_start_eof = FALSE;\n    buf->b_p_eol = TRUE;\n    buf->b_start_eol = TRUE;\n    buf->b_p_bomb = FALSE;\n    buf->b_start_bomb = FALSE;\n    buf->b_ml.ml_mfp = NULL;\n    buf->b_ml.ml_flags = ML_EMPTY;\t\t// empty buffer\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_deleted_all_lines(buf);\n#endif\n}\n\n/*\n * buf_freeall() - free all things allocated for a buffer that are related to\n * the file.  Careful: get here with \"curwin\" NULL when exiting.\n * flags:\n * BFA_DEL\t     buffer is going to be deleted\n * BFA_WIPE\t     buffer is going to be wiped out\n * BFA_KEEP_UNDO     do not free undo information\n * BFA_IGNORE_ABORT  don't abort even when aborting() returns TRUE\n */\n    void\nbuf_freeall(buf_T *buf, int flags)\n{\n    int\t\tis_curbuf = (buf == curbuf);\n    bufref_T\tbufref;\n    int\t\tis_curwin = (curwin != NULL && curwin->w_buffer == buf);\n    win_T\t*the_curwin = curwin;\n    tabpage_T\t*the_curtab = curtab;\n\n    // Make sure the buffer isn't closed by autocommands.\n    ++buf->b_locked;\n    ++buf->b_locked_split;\n    set_bufref(&bufref, buf);\n    if (buf->b_ml.ml_mfp != NULL)\n    {\n\tif (apply_autocmds(EVENT_BUFUNLOAD, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if ((flags & BFA_DEL) && buf->b_p_bl)\n    {\n\tif (apply_autocmds(EVENT_BUFDELETE, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t   FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    if (flags & BFA_WIPE)\n    {\n\tif (apply_autocmds(EVENT_BUFWIPEOUT, buf->b_fname, buf->b_fname,\n\t\t\t\t\t\t\t\t  FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    // autocommands deleted the buffer\n\t    return;\n    }\n    --buf->b_locked;\n    --buf->b_locked_split;\n\n    // If the buffer was in curwin and the window has changed, go back to that\n    // window, if it still exists.  This avoids that \":edit x\" triggering a\n    // \"tabnext\" BufUnload autocmd leaves a window behind without a buffer.\n    if (is_curwin && curwin != the_curwin &&  win_valid_any_tab(the_curwin))\n    {\n\tblock_autocmds();\n\tgoto_tabpage_win(the_curtab, the_curwin);\n\tunblock_autocmds();\n    }\n\n#ifdef FEAT_EVAL\n    // autocmds may abort script processing\n    if ((flags & BFA_IGNORE_ABORT) == 0 && aborting())\n\treturn;\n#endif\n\n    // It's possible that autocommands change curbuf to the one being deleted.\n    // This might cause curbuf to be deleted unexpectedly.  But in some cases\n    // it's OK to delete the curbuf, because a new one is obtained anyway.\n    // Therefore only return if curbuf changed to the deleted buffer.\n    if (buf == curbuf && !is_curbuf)\n\treturn;\n#ifdef FEAT_DIFF\n    diff_buf_delete(buf);\t    // Can't use 'diff' for unloaded buffer.\n#endif\n#ifdef FEAT_SYN_HL\n    // Remove any ownsyntax, unless exiting.\n    if (curwin != NULL && curwin->w_buffer == buf)\n\treset_synblock(curwin);\n#endif\n\n#ifdef FEAT_FOLDING\n    // No folds in an empty buffer.\n    {\n\twin_T\t\t*win;\n\ttabpage_T\t*tp;\n\n\tFOR_ALL_TAB_WINDOWS(tp, win)\n\t    if (win->w_buffer == buf)\n\t\tclearFolding(win);\n    }\n#endif\n\n#ifdef FEAT_TCL\n    tcl_buffer_free(buf);\n#endif\n    ml_close(buf, TRUE);\t    // close and delete the memline/memfile\n    buf->b_ml.ml_line_count = 0;    // no lines in buffer\n    if ((flags & BFA_KEEP_UNDO) == 0)\n    {\n\tu_blockfree(buf);\t    // free the memory allocated for undo\n\tu_clearall(buf);\t    // reset all undo information\n    }\n#ifdef FEAT_SYN_HL\n    syntax_clear(&buf->b_s);\t    // reset syntax info\n#endif\n#ifdef FEAT_PROP_POPUP\n    clear_buf_prop_types(buf);\n#endif\n    buf->b_flags &= ~BF_READERR;    // a read error is no longer relevant\n}\n\n/*\n * Free a buffer structure and the things it contains related to the buffer\n * itself (not the file, that must have been done already).\n */\n    static void\nfree_buffer(buf_T *buf)\n{\n    ++buf_free_count;\n    free_buffer_stuff(buf, TRUE);\n#ifdef FEAT_EVAL\n    // b:changedtick uses an item in buf_T, remove it now\n    dictitem_remove(buf->b_vars, (dictitem_T *)&buf->b_ct_di, \"free buffer\");\n    unref_var_dict(buf->b_vars);\n    remove_listeners(buf);\n#endif\n#ifdef FEAT_LUA\n    lua_buffer_free(buf);\n#endif\n#ifdef FEAT_MZSCHEME\n    mzscheme_buffer_free(buf);\n#endif\n#ifdef FEAT_PERL\n    perl_buf_free(buf);\n#endif\n#ifdef FEAT_PYTHON\n    python_buffer_free(buf);\n#endif\n#ifdef FEAT_PYTHON3\n    python3_buffer_free(buf);\n#endif\n#ifdef FEAT_RUBY\n    ruby_buffer_free(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    channel_buffer_free(buf);\n#endif\n#ifdef FEAT_TERMINAL\n    free_terminal(buf);\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    vim_free(buf->b_prompt_text);\n    free_callback(&buf->b_prompt_callback);\n    free_callback(&buf->b_prompt_interrupt);\n#endif\n\n    buf_hashtab_remove(buf);\n\n    aubuflocal_remove(buf);\n\n    if (autocmd_busy)\n    {\n\t// Do not free the buffer structure while autocommands are executing,\n\t// it's still needed. Free it when autocmd_busy is reset.\n\tbuf->b_next = au_pending_free_buf;\n\tau_pending_free_buf = buf;\n    }\n    else\n    {\n\tvim_free(buf);\n\tif (curbuf == buf)\n\t    curbuf = NULL;  // make clear it's not to be used\n    }\n}\n\n/*\n * Initializes b:changedtick.\n */\n    static void\ninit_changedtick(buf_T *buf)\n{\n    dictitem_T *di = (dictitem_T *)&buf->b_ct_di;\n\n    di->di_flags = DI_FLAGS_FIX | DI_FLAGS_RO;\n    di->di_tv.v_type = VAR_NUMBER;\n    di->di_tv.v_lock = VAR_FIXED;\n    di->di_tv.vval.v_number = 0;\n\n#ifdef FEAT_EVAL\n    STRCPY(buf->b_ct_di.di_key, \"changedtick\");\n    (void)dict_add(buf->b_vars, di);\n#endif\n}\n\n/*\n * Free the b_wininfo list for buffer \"buf\".\n */\n    static void\nclear_wininfo(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    while (buf->b_wininfo != NULL)\n    {\n\twip = buf->b_wininfo;\n\tbuf->b_wininfo = wip->wi_next;\n\tfree_wininfo(wip);\n    }\n}\n\n/*\n * Free stuff in the buffer for \":bdel\" and when wiping out the buffer.\n */\n    static void\nfree_buffer_stuff(\n    buf_T\t*buf,\n    int\t\tfree_options)\t\t// free options as well\n{\n    if (free_options)\n    {\n\tclear_wininfo(buf);\t\t// including window-local options\n\tfree_buf_options(buf, TRUE);\n#ifdef FEAT_SPELL\n\tga_clear(&buf->b_s.b_langp);\n#endif\n    }\n#ifdef FEAT_EVAL\n    {\n\tvarnumber_T tick = CHANGEDTICK(buf);\n\n\tvars_clear(&buf->b_vars->dv_hashtab); // free all buffer variables\n\thash_init(&buf->b_vars->dv_hashtab);\n\tinit_changedtick(buf);\n\tCHANGEDTICK(buf) = tick;\n\tremove_listeners(buf);\n    }\n#endif\n    uc_clear(&buf->b_ucmds);\t\t// clear local user commands\n#ifdef FEAT_SIGNS\n    buf_delete_signs(buf, (char_u *)\"*\");\t// delete any signs\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    netbeans_file_killed(buf);\n#endif\n#ifdef FEAT_PROP_POPUP\n    ga_clear_strings(&buf->b_textprop_text);\n#endif\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, FALSE);  // clear local mappings\n    map_clear_mode(buf, MAP_ALL_MODES, TRUE, TRUE);   // clear local abbrevs\n    VIM_CLEAR(buf->b_start_fenc);\n}\n\n/*\n * Free one wininfo_T.\n */\n    void\nfree_wininfo(wininfo_T *wip)\n{\n    if (wip->wi_optset)\n    {\n\tclear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\tdeleteFoldRecurse(&wip->wi_folds);\n#endif\n    }\n    vim_free(wip);\n}\n\n/*\n * Go to another buffer.  Handles the result of the ATTENTION dialog.\n */\n    void\ngoto_buffer(\n    exarg_T\t*eap,\n    int\t\tstart,\n    int\t\tdir,\n    int\t\tcount)\n{\n    bufref_T\told_curbuf;\n    int\t\tsave_sea = swap_exists_action;\n\n    set_bufref(&old_curbuf, curbuf);\n\n    if (swap_exists_action == SEA_NONE)\n\tswap_exists_action = SEA_DIALOG;\n    (void)do_buffer(*eap->cmd == 's' ? DOBUF_SPLIT : DOBUF_GOTO,\n\t\t\t\t\t     start, dir, count, eap->forceit);\n    if (swap_exists_action == SEA_QUIT && *eap->cmd == 's')\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a window.\n\tenter_cleanup(&cs);\n#endif\n\n\t// Quitting means closing the split window, nothing else.\n\twin_close(curwin, TRUE);\n\tswap_exists_action = save_sea;\n\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else\n\thandle_swap_exists(&old_curbuf);\n}\n\n/*\n * Handle the situation of swap_exists_action being set.\n * It is allowed for \"old_curbuf\" to be NULL or invalid.\n */\n    void\nhandle_swap_exists(bufref_T *old_curbuf)\n{\n#if defined(FEAT_EVAL)\n    cleanup_T\tcs;\n#endif\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    buf_T\t*buf;\n\n    if (swap_exists_action == SEA_QUIT)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Quit at ATTENTION prompt.  Go back to previous\n\t// buffer.  If that buffer is gone or the same as the current one,\n\t// open a new, empty buffer.\n\tswap_exists_action = SEA_NONE;\t// don't want it again\n\tswap_exists_did_quit = TRUE;\n\tclose_buffer(curwin, curbuf, DOBUF_UNLOAD, FALSE, FALSE);\n\tif (old_curbuf == NULL || !bufref_valid(old_curbuf)\n\t\t\t\t\t      || old_curbuf->br_buf == curbuf)\n\t{\n\t    // Block autocommands here because curwin->w_buffer is NULL.\n\t    block_autocmds();\n\t    buf = buflist_new(NULL, NULL, 1L, BLN_CURBUF | BLN_LISTED);\n\t    unblock_autocmds();\n\t}\n\telse\n\t    buf = old_curbuf->br_buf;\n\tif (buf != NULL)\n\t{\n\t    int old_msg_silent = msg_silent;\n\n\t    if (shortmess(SHM_FILEINFO))\n\t\tmsg_silent = 1;  // prevent fileinfo message\n\t    enter_buffer(buf);\n\t    // restore msg_silent, so that the command line will be shown\n\t    msg_silent = old_msg_silent;\n\n#ifdef FEAT_SYN_HL\n\t    if (old_tw != curbuf->b_p_tw)\n\t\tcheck_colorcolumn(curwin);\n#endif\n\t}\n\t// If \"old_curbuf\" is NULL we are in big trouble here...\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    else if (swap_exists_action == SEA_RECOVER)\n    {\n#if defined(FEAT_EVAL)\n\t// Reset the error/interrupt/exception state here so that\n\t// aborting() returns FALSE when closing a buffer.\n\tenter_cleanup(&cs);\n#endif\n\n\t// User selected Recover at ATTENTION prompt.\n\tmsg_scroll = TRUE;\n\tml_recover(FALSE);\n\tmsg_puts(\"\\n\");\t// don't overwrite the last message\n\tcmdline_row = msg_row;\n\tdo_modelines(0);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n    }\n    swap_exists_action = SEA_NONE;\n}\n\n/*\n * Make the current buffer empty.\n * Used when it is wiped out and it's the last buffer.\n */\n    static int\nempty_curbuf(\n    int close_others,\n    int forceit,\n    int action)\n{\n    int\t    retval;\n    buf_T   *buf = curbuf;\n    bufref_T bufref;\n\n    if (action == DOBUF_UNLOAD)\n    {\n\temsg(_(e_cannot_unload_last_buffer));\n\treturn FAIL;\n    }\n\n    set_bufref(&bufref, buf);\n    if (close_others)\n\t// Close any other windows on this buffer, then make it empty.\n\tclose_windows(buf, TRUE);\n\n    setpcmark();\n    retval = do_ecmd(0, NULL, NULL, NULL, ECMD_ONE,\n\t\t\t\t\t  forceit ? ECMD_FORCEIT : 0, curwin);\n\n    // do_ecmd() may create a new buffer, then we have to delete\n    // the old one.  But do_ecmd() may have done that already, check\n    // if the buffer still exists.\n    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows == 0)\n\tclose_buffer(NULL, buf, action, FALSE, FALSE);\n    if (!close_others)\n\tneed_fileinfo = FALSE;\n    return retval;\n}\n\n/*\n * Implementation of the commands for the buffer list.\n *\n * action == DOBUF_GOTO\t    go to specified buffer\n * action == DOBUF_SPLIT    split window and go to specified buffer\n * action == DOBUF_UNLOAD   unload specified buffer(s)\n * action == DOBUF_DEL\t    delete specified buffer(s) from buffer list\n * action == DOBUF_WIPE\t    delete specified buffer(s) really\n * action == DOBUF_WIPE_REUSE idem, and add number to \"buf_reuse\"\n *\n * start == DOBUF_CURRENT   go to \"count\" buffer from current buffer\n * start == DOBUF_FIRST\t    go to \"count\" buffer from first buffer\n * start == DOBUF_LAST\t    go to \"count\" buffer from last buffer\n * start == DOBUF_MOD\t    go to \"count\" modified buffer from current buffer\n *\n * Return FAIL or OK.\n */\n    static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf) && !bt_terminal(buf))\n\treturn OK;\n#endif\n    if ((action == DOBUF_GOTO || action == DOBUF_SPLIT)\n\t\t\t\t\t\t  && (buf->b_flags & BF_DUMMY))\n    {\n\t// disallow navigating to the dummy buffer\n\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\treturn FAIL;\n    }\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n# ifdef FEAT_TERMINAL\n\t\tif (term_job_running(buf->b_term))\n\t\t{\n\t\t    if (term_confirm_stop(buf) == FAIL)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n# endif\n\t\t{\n\t\t    dialog_changed(buf, FALSE);\n\t\t    if (!bufref_valid(&bufref))\n\t\t\t// Autocommand deleted buffer, oops!  It's not changed\n\t\t\t// now.\n\t\t\treturn FAIL;\n\t\t    // If it's still changed fail silently, the dialog already\n\t\t    // mentioned why it fails.\n\t\t    if (bufIsChanged(buf))\n\t\t\treturn FAIL;\n\t\t}\n\t    }\n\t    else\n#endif\n\t    {\n\t\tno_write_message_buf(buf);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl || bt_quickfix(buf))\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n\t\t\t    && !bt_quickfix(buf))\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf && !bt_quickfix(buf))\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n# ifdef FEAT_TERMINAL\n\t    if (term_job_running(curbuf->b_term))\n\t    {\n\t\tif (term_confirm_stop(curbuf) == FAIL)\n\t\t    return FAIL;\n\t\t// Manually kill the terminal here because this command will\n\t\t// hide it otherwise.\n\t\tfree_terminal(curbuf);\n\t    }\n\t    else\n# endif\n\t    {\n\t\tbufref_T bufref;\n\n\t\tset_bufref(&bufref, buf);\n\t\tdialog_changed(curbuf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!\n\t\t    return FAIL;\n\n\t\tif (bufIsChanged(curbuf))\n\t\t{\n\t\t    no_write_message();\n\t\t    return FAIL;\n\t\t}\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}\n\n    int\ndo_buffer(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tforceit)\t// TRUE when using !\n{\n    return do_buffer_ext(action, start, dir, count,\n\t\t\t\t\t\t  forceit ? DOBUF_FORCEIT : 0);\n}\n\n/*\n * do_bufdel() - delete or unload buffer(s)\n *\n * addr_count == 0: \":bdel\" - delete current buffer\n * addr_count == 1: \":N bdel\" or \":bdel N [N ..]\" - first delete\n *\t\t    buffer \"end_bnr\", then any other arguments.\n * addr_count == 2: \":N,N bdel\" - delete buffers in range\n *\n * command can be DOBUF_UNLOAD (\":bunload\"), DOBUF_WIPE (\":bwipeout\") or\n * DOBUF_DEL (\":bdel\")\n *\n * Returns error message or NULL\n */\n    char *\ndo_bufdel(\n    int\t\tcommand,\n    char_u\t*arg,\t\t// pointer to extra arguments\n    int\t\taddr_count,\n    int\t\tstart_bnr,\t// first buffer number in a range\n    int\t\tend_bnr,\t// buffer nr or last buffer nr in a range\n    int\t\tforceit)\n{\n    int\t\tdo_current = 0;\t// delete current buffer?\n    int\t\tdeleted = 0;\t// number of buffers deleted\n    char\t*errormsg = NULL; // return value\n    int\t\tbnr;\t\t// buffer number\n    char_u\t*p;\n\n    if (addr_count == 0)\n    {\n\t(void)do_buffer(command, DOBUF_CURRENT, FORWARD, 0, forceit);\n    }\n    else\n    {\n\tif (addr_count == 2)\n\t{\n\t    if (*arg)\t\t// both range and argument is not allowed\n\t\treturn ex_errmsg(e_trailing_characters_str, arg);\n\t    bnr = start_bnr;\n\t}\n\telse\t// addr_count == 1\n\t    bnr = end_bnr;\n\n\tfor ( ;!got_int; ui_breakcheck())\n\t{\n\t    // Delete the current buffer last, otherwise when the\n\t    // current buffer is deleted, the next buffer becomes\n\t    // the current one and will be loaded, which may then\n\t    // also be deleted, etc.\n\t    if (bnr == curbuf->b_fnum)\n\t\tdo_current = bnr;\n\t    else if (do_buffer_ext(command, DOBUF_FIRST, FORWARD, bnr,\n\t\t\t  DOBUF_NOPOPUP | (forceit ? DOBUF_FORCEIT : 0)) == OK)\n\t\t++deleted;\n\n\t    // find next buffer number to delete/unload\n\t    if (addr_count == 2)\n\t    {\n\t\tif (++bnr > end_bnr)\n\t\t    break;\n\t    }\n\t    else    // addr_count == 1\n\t    {\n\t\targ = skipwhite(arg);\n\t\tif (*arg == NUL)\n\t\t    break;\n\t\tif (!VIM_ISDIGIT(*arg))\n\t\t{\n\t\t    p = skiptowhite_esc(arg);\n\t\t    bnr = buflist_findpat(arg, p,\n\t\t\t  command == DOBUF_WIPE || command == DOBUF_WIPE_REUSE,\n\t\t\t\t\t\t\t\tFALSE, FALSE);\n\t\t    if (bnr < 0)\t    // failed\n\t\t\tbreak;\n\t\t    arg = p;\n\t\t}\n\t\telse\n\t\t    bnr = getdigits(&arg);\n\t    }\n\t}\n\tif (!got_int && do_current && do_buffer(command, DOBUF_FIRST,\n\t\t\t\t\t  FORWARD, do_current, forceit) == OK)\n\t    ++deleted;\n\n\tif (deleted == 0)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_unloaded));\n\t    else if (command == DOBUF_DEL)\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_deleted));\n\t    else\n\t\tSTRCPY(IObuff, _(e_no_buffers_were_wiped_out));\n\t    errormsg = (char *)IObuff;\n\t}\n\telse if (deleted >= p_report)\n\t{\n\t    if (command == DOBUF_UNLOAD)\n\t\tsmsg(NGETTEXT(\"%d buffer unloaded\",\n\t\t\t    \"%d buffers unloaded\", deleted), deleted);\n\t    else if (command == DOBUF_DEL)\n\t\tsmsg(NGETTEXT(\"%d buffer deleted\",\n\t\t\t    \"%d buffers deleted\", deleted), deleted);\n\t    else\n\t\tsmsg(NGETTEXT(\"%d buffer wiped out\",\n\t\t\t    \"%d buffers wiped out\", deleted), deleted);\n\t}\n    }\n\n\n    return errormsg;\n}\n\n/*\n * Set current buffer to \"buf\".  Executes autocommands and closes current\n * buffer.  \"action\" tells how to close the current buffer:\n * DOBUF_GOTO\t    free or hide it\n * DOBUF_SPLIT\t    nothing\n * DOBUF_UNLOAD\t    unload it\n * DOBUF_DEL\t    delete it\n * DOBUF_WIPE\t    wipe it out\n * DOBUF_WIPE_REUSE wipe it out and add to \"buf_reuse\"\n */\n    void\nset_curbuf(buf_T *buf, int action)\n{\n    buf_T\t*prevbuf;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n#ifdef FEAT_SYN_HL\n    long\told_tw = curbuf->b_p_tw;\n#endif\n    bufref_T\tnewbufref;\n    bufref_T\tprevbufref;\n    int\t\tvalid;\n\n    setpcmark();\n    if ((cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = curbuf->b_fnum; // remember alternate file\n    buflist_altfpos(curwin);\t\t\t // remember curpos\n\n    // Don't restart Select mode after switching to another buffer.\n    VIsual_reselect = FALSE;\n\n    // close_windows() or apply_autocmds() may change curbuf and wipe out \"buf\"\n    prevbuf = curbuf;\n    set_bufref(&prevbufref, prevbuf);\n    set_bufref(&newbufref, buf);\n\n    // Autocommands may delete the current buffer and/or the buffer we want to\n    // go to.  In those cases don't close the buffer.\n    if (!apply_autocmds(EVENT_BUFLEAVE, NULL, NULL, FALSE, curbuf)\n\t    || (bufref_valid(&prevbufref)\n\t\t&& bufref_valid(&newbufref)\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t       ))\n    {\n#ifdef FEAT_SYN_HL\n\tif (prevbuf == curwin->w_buffer)\n\t    reset_synblock(curwin);\n#endif\n\tif (unload)\n\t    close_windows(prevbuf, FALSE);\n#if defined(FEAT_EVAL)\n\tif (bufref_valid(&prevbufref) && !aborting())\n#else\n\tif (bufref_valid(&prevbufref))\n#endif\n\t{\n\t    win_T  *previouswin = curwin;\n\n\t    // Do not sync when in Insert mode and the buffer is open in\n\t    // another window, might be a timer doing something in another\n\t    // window.\n\t    if (prevbuf == curbuf\n\t\t    && ((State & MODE_INSERT) == 0 || curbuf->b_nwindows <= 1))\n\t\tu_sync(FALSE);\n\t    close_buffer(prevbuf == curwin->w_buffer ? curwin : NULL, prevbuf,\n\t\t    unload ? action : (action == DOBUF_GOTO\n\t\t\t&& !buf_hide(prevbuf)\n\t\t\t&& !bufIsChanged(prevbuf)) ? DOBUF_UNLOAD : 0,\n\t\t    FALSE, FALSE);\n\t    if (curwin != previouswin && win_valid(previouswin))\n\t      // autocommands changed curwin, Grr!\n\t      curwin = previouswin;\n\t}\n    }\n    // An autocommand may have deleted \"buf\", already entered it (e.g., when\n    // it did \":bunload\") or aborted the script processing.\n    // If curwin->w_buffer is null, enter_buffer() will make it valid again\n    valid = buf_valid(buf);\n    if ((valid && buf != curbuf\n#ifdef FEAT_EVAL\n\t\t&& !aborting()\n#endif\n\t) || curwin->w_buffer == NULL)\n    {\n\t// If the buffer is not valid but curwin->w_buffer is NULL we must\n\t// enter some buffer.  Using the last one is hopefully OK.\n\tif (!valid)\n\t    enter_buffer(lastbuf);\n\telse\n\t    enter_buffer(buf);\n#ifdef FEAT_SYN_HL\n\tif (old_tw != curbuf->b_p_tw)\n\t    check_colorcolumn(curwin);\n#endif\n    }\n}\n\n/*\n * Enter a new current buffer.\n * Old curbuf must have been abandoned already!  This also means \"curbuf\" may\n * be pointing to freed memory.\n */\n    static void\nenter_buffer(buf_T *buf)\n{\n    // when closing the current buffer stop Visual mode\n    if (VIsual_active\n#if defined(EXITFREE)\n\t    && !entered_free_all_mem\n#endif\n\t    )\n\tend_visual_mode();\n\n    // Get the buffer in the current window.\n    curwin->w_buffer = buf;\n    curbuf = buf;\n    ++curbuf->b_nwindows;\n\n    // Copy buffer and window local option values.  Not for a help buffer.\n    buf_copy_options(buf, BCO_ENTER | BCO_NOHELP);\n    if (!buf->b_help)\n\tget_winopts(buf);\n#ifdef FEAT_FOLDING\n    else\n\t// Remove all folds in the window.\n\tclearFolding(curwin);\n    foldUpdateAll(curwin);\t// update folds (later).\n#endif\n\n#ifdef FEAT_DIFF\n    if (curwin->w_p_diff)\n\tdiff_buf_add(curbuf);\n#endif\n\n#ifdef FEAT_SYN_HL\n    curwin->w_s = &(curbuf->b_s);\n#endif\n\n    // Cursor on first line by default.\n    curwin->w_cursor.lnum = 1;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_set_curswant = TRUE;\n    curwin->w_topline_was_set = FALSE;\n\n    // mark cursor position as being invalid\n    curwin->w_valid = 0;\n\n    buflist_setfpos(curbuf, curwin, curbuf->b_last_cursor.lnum,\n\t\t\t\t\t      curbuf->b_last_cursor.col, TRUE);\n\n    // Make sure the buffer is loaded.\n    if (curbuf->b_ml.ml_mfp == NULL)\t// need to load the file\n    {\n\t// If there is no filetype, allow for detecting one.  Esp. useful for\n\t// \":ball\" used in an autocommand.  If there already is a filetype we\n\t// might prefer to keep it.\n\tif (*curbuf->b_p_ft == NUL)\n\t    did_filetype = FALSE;\n\n\topen_buffer(FALSE, NULL, 0);\n    }\n    else\n    {\n\tif (!msg_silent && !shortmess(SHM_FILEINFO))\n\t    need_fileinfo = TRUE;\t// display file info after redraw\n\n\t// check if file changed\n\t(void)buf_check_timestamp(curbuf, FALSE);\n\n\tcurwin->w_topline = 1;\n#ifdef FEAT_DIFF\n\tcurwin->w_topfill = 0;\n#endif\n\tapply_autocmds(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, NULL, NULL, FALSE, curbuf);\n    }\n\n    // If autocommands did not change the cursor position, restore cursor lnum\n    // and possibly cursor col.\n    if (curwin->w_cursor.lnum == 1 && inindent(0))\n\tbuflist_getfpos();\n\n    check_arg_idx(curwin);\t\t// check for valid arg_idx\n    maketitle();\n\t// when autocmds didn't change it\n    if (curwin->w_topline == 1 && !curwin->w_topline_was_set)\n\tscroll_cursor_halfway(FALSE);\t// redisplay at correct position\n\n#ifdef FEAT_NETBEANS_INTG\n    // Send fileOpened event because we've changed buffers.\n    netbeans_file_activated(curbuf);\n#endif\n\n    // Change directories when the 'acd' option is set.\n    DO_AUTOCHDIR;\n\n#ifdef FEAT_KEYMAP\n    if (curbuf->b_kmap_state & KEYMAP_INIT)\n\t(void)keymap_init();\n#endif\n#ifdef FEAT_SPELL\n    // May need to set the spell language.  Can only do this after the buffer\n    // has been properly setup.\n    if (!curbuf->b_help && curwin->w_p_spell && *curwin->w_s->b_p_spl != NUL)\n\t(void)did_set_spelllang(curwin);\n#endif\n#ifdef FEAT_VIMINFO\n    curbuf->b_last_used = vim_time();\n#endif\n\n    redraw_later(UPD_NOT_VALID);\n}\n\n#if defined(FEAT_AUTOCHDIR) || defined(PROTO)\n/*\n * Change to the directory of the current buffer.\n * Don't do this while still starting up.\n */\n    void\ndo_autochdir(void)\n{\n    if ((starting == 0 || test_autochdir)\n\t    && curbuf->b_ffname != NULL\n\t    && vim_chdirfile(curbuf->b_ffname, \"auto\") == OK)\n    {\n\tshorten_fnames(TRUE);\n\tlast_chdir_reason = \"autochdir\";\n    }\n}\n#endif\n\n    static void\nno_write_message_buf(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\tbuf->b_fnum);\n}\n\n    void\nno_write_message(void)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(curbuf->b_term))\n\temsg(_(e_job_still_running_add_bang_to_end_the_job));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change_add_bang_to_override));\n}\n\n    void\nno_write_message_nobang(buf_T *buf UNUSED)\n{\n#ifdef FEAT_TERMINAL\n    if (term_job_running(buf->b_term))\n\temsg(_(e_job_still_running));\n    else\n#endif\n\temsg(_(e_no_write_since_last_change));\n}\n\n/*\n * functions for dealing with the buffer list\n */\n\n/*\n * Return TRUE if the current buffer is empty, unnamed, unmodified and used in\n * only one window.  That means it can be re-used.\n */\n    int\ncurbuf_reusable(void)\n{\n    return (curbuf != NULL\n\t&& curbuf->b_ffname == NULL\n\t&& curbuf->b_nwindows <= 1\n\t&& (curbuf->b_ml.ml_mfp == NULL || BUFEMPTY())\n\t&& !bt_quickfix(curbuf)\n\t&& !curbufIsChanged());\n}\n\n/*\n * Add a file name to the buffer list.  Return a pointer to the buffer.\n * If the same file name already exists return a pointer to that buffer.\n * If it does not exist, or if fname == NULL, a new entry is created.\n * If (flags & BLN_CURBUF) is TRUE, may use current buffer.\n * If (flags & BLN_LISTED) is TRUE, add new buffer to buffer list.\n * If (flags & BLN_DUMMY) is TRUE, don't count it as a real buffer.\n * If (flags & BLN_NEW) is TRUE, don't use an existing buffer.\n * If (flags & BLN_NOOPT) is TRUE, don't copy options from the current buffer\n *\t\t\t\t    if the buffer already exists.\n * If (flags & BLN_REUSE) is TRUE, may use buffer number from \"buf_reuse\".\n * This is the ONLY way to create a new buffer.\n */\n    buf_T *\nbuflist_new(\n    char_u\t*ffname_arg,\t// full path of fname or relative\n    char_u\t*sfname_arg,\t// short fname or NULL\n    linenr_T\tlnum,\t\t// preferred cursor line\n    int\t\tflags)\t\t// BLN_ defines\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*buf;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (top_file_num == 1)\n\thash_init(&buf_hashtab);\n\n    fname_expand(curbuf, &ffname, &sfname);\t// will allocate ffname\n\n    /*\n     * If the file name already exists in the list, update the entry.\n     */\n#ifdef UNIX\n    // On Unix we can use inode numbers when the file exists.  Works better\n    // for hard links.\n    if (sfname == NULL || mch_stat((char *)sfname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n#endif\n    if (ffname != NULL && !(flags & (BLN_DUMMY | BLN_NEW)) && (buf =\n#ifdef UNIX\n\t\tbuflist_findname_stat(ffname, &st)\n#else\n\t\tbuflist_findname(ffname)\n#endif\n\t\t) != NULL)\n    {\n\tvim_free(ffname);\n\tif (lnum != 0)\n\t    buflist_setfpos(buf, (flags & BLN_NOCURWIN) ? NULL : curwin,\n\t\t\t\t\t\t      lnum, (colnr_T)0, FALSE);\n\n\tif ((flags & BLN_NOOPT) == 0)\n\t    // copy the options now, if 'cpo' doesn't have 's' and not done\n\t    // already\n\t    buf_copy_options(buf, 0);\n\n\tif ((flags & BLN_LISTED) && !buf->b_p_bl)\n\t{\n\t    bufref_T bufref;\n\n\t    buf->b_p_bl = TRUE;\n\t    set_bufref(&bufref, buf);\n\t    if (!(flags & BLN_DUMMY))\n\t    {\n\t\tif (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t\t&& !bufref_valid(&bufref))\n\t\t    return NULL;\n\t    }\n\t}\n\treturn buf;\n    }\n\n    /*\n     * If the current buffer has no name and no contents, use the current\n     * buffer.\tOtherwise: Need to allocate a new buffer structure.\n     *\n     * This is the ONLY place where a new buffer structure is allocated!\n     * (A spell file buffer is allocated in spell.c, but that's not a normal\n     * buffer.)\n     */\n    buf = NULL;\n    if ((flags & BLN_CURBUF) && curbuf_reusable())\n    {\n\tbuf = curbuf;\n\t// It's like this buffer is deleted.  Watch out for autocommands that\n\t// change curbuf!  If that happens, allocate a new buffer anyway.\n\tbuf_freeall(buf, BFA_WIPE | BFA_DEL);\n\tif (buf != curbuf)   // autocommands deleted the buffer!\n\t    return NULL;\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#endif\n    }\n    if (buf != curbuf || curbuf == NULL)\n    {\n\tbuf = ALLOC_CLEAR_ONE(buf_T);\n\tif (buf == NULL)\n\t{\n\t    vim_free(ffname);\n\t    return NULL;\n\t}\n#ifdef FEAT_EVAL\n\t// init b: variables\n\tbuf->b_vars = dict_alloc_id(aid_newbuf_bvars);\n\tif (buf->b_vars == NULL)\n\t{\n\t    vim_free(ffname);\n\t    vim_free(buf);\n\t    return NULL;\n\t}\n\tinit_var_dict(buf->b_vars, &buf->b_bufvar, VAR_SCOPE);\n#endif\n\tinit_changedtick(buf);\n    }\n\n    if (ffname != NULL)\n    {\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = vim_strsave(sfname);\n    }\n\n    clear_wininfo(buf);\n    buf->b_wininfo = ALLOC_CLEAR_ONE(wininfo_T);\n\n    if ((ffname != NULL && (buf->b_ffname == NULL || buf->b_sfname == NULL))\n\t    || buf->b_wininfo == NULL)\n    {\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n\tif (buf != curbuf)\n\t    free_buffer(buf);\n\treturn NULL;\n    }\n\n    if (buf == curbuf)\n    {\n\tfree_buffer_stuff(buf, FALSE);\t// delete local variables et al.\n\n\t// Init the options.\n\tbuf->b_p_initialized = FALSE;\n\tbuf_copy_options(buf, BCO_ENTER);\n\n#ifdef FEAT_KEYMAP\n\t// need to reload lmaps and set b:keymap_name\n\tcurbuf->b_kmap_state |= KEYMAP_INIT;\n#endif\n    }\n    else\n    {\n\t// put the new buffer at the end of the buffer list\n\tbuf->b_next = NULL;\n\tif (firstbuf == NULL)\t\t// buffer list is empty\n\t{\n\t    buf->b_prev = NULL;\n\t    firstbuf = buf;\n\t}\n\telse\t\t\t\t// append new buffer at end of list\n\t{\n\t    lastbuf->b_next = buf;\n\t    buf->b_prev = lastbuf;\n\t}\n\tlastbuf = buf;\n\n\tif ((flags & BLN_REUSE) && buf_reuse.ga_len > 0)\n\t{\n\t    // Recycle a previously used buffer number.  Used for buffers which\n\t    // are normally hidden, e.g. in a popup window.  Avoids that the\n\t    // buffer number grows rapidly.\n\t    --buf_reuse.ga_len;\n\t    buf->b_fnum = ((int *)buf_reuse.ga_data)[buf_reuse.ga_len];\n\n\t    // Move buffer to the right place in the buffer list.\n\t    while (buf->b_prev != NULL && buf->b_fnum < buf->b_prev->b_fnum)\n\t    {\n\t\tbuf_T\t*prev = buf->b_prev;\n\n\t\tprev->b_next = buf->b_next;\n\t\tif (prev->b_next != NULL)\n\t\t    prev->b_next->b_prev = prev;\n\t\tbuf->b_next = prev;\n\t\tbuf->b_prev = prev->b_prev;\n\t\tif (buf->b_prev != NULL)\n\t\t    buf->b_prev->b_next = buf;\n\t\tprev->b_prev = buf;\n\t\tif (lastbuf == buf)\n\t\t    lastbuf = prev;\n\t\tif (firstbuf == prev)\n\t\t    firstbuf = buf;\n\t    }\n\t}\n\telse\n\t    buf->b_fnum = top_file_num++;\n\tif (top_file_num < 0)\t\t// wrap around (may cause duplicates)\n\t{\n\t    emsg(_(\"W14: Warning: List of file names overflow\"));\n\t    if (emsg_silent == 0 && !in_assert_fails)\n\t    {\n\t\tout_flush();\n\t\tui_delay(3001L, TRUE);\t// make sure it is noticed\n\t    }\n\t    top_file_num = 1;\n\t}\n\tbuf_hashtab_add(buf);\n\n\t// Always copy the options from the current buffer.\n\tbuf_copy_options(buf, BCO_ALWAYS);\n    }\n\n    buf->b_wininfo->wi_fpos.lnum = lnum;\n    buf->b_wininfo->wi_win = curwin;\n\n#ifdef FEAT_SYN_HL\n    hash_init(&buf->b_s.b_keywtab);\n    hash_init(&buf->b_s.b_keywtab_ic);\n#endif\n\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n    buf->b_u_synced = TRUE;\n    buf->b_flags = BF_CHECK_RO | BF_NEVERLOADED;\n    if (flags & BLN_DUMMY)\n\tbuf->b_flags |= BF_DUMMY;\n    buf_clear_file(buf);\n    clrallmarks(buf);\t\t\t// clear marks\n    fmarks_check_names(buf);\t\t// check file marks for this file\n    buf->b_p_bl = (flags & BLN_LISTED) ? TRUE : FALSE;\t// init 'buflisted'\n    if (!(flags & BLN_DUMMY))\n    {\n\tbufref_T bufref;\n\n\t// Tricky: these autocommands may change the buffer list.  They could\n\t// also split the window with re-using the one empty buffer. This may\n\t// result in unexpectedly losing the empty buffer.\n\tset_bufref(&bufref, buf);\n\tif (apply_autocmds(EVENT_BUFNEW, NULL, NULL, FALSE, buf)\n\t\t&& !bufref_valid(&bufref))\n\t    return NULL;\n\tif (flags & BLN_LISTED)\n\t{\n\t    if (apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, buf)\n\t\t    && !bufref_valid(&bufref))\n\t\treturn NULL;\n\t}\n#ifdef FEAT_EVAL\n\tif (aborting())\t\t// autocmds may abort script processing\n\t    return NULL;\n#endif\n    }\n\n    return buf;\n}\n\n/*\n * Free the memory for the options of a buffer.\n * If \"free_p_ff\" is TRUE also free 'fileformat', 'buftype' and\n * 'fileencoding'.\n */\n    void\nfree_buf_options(\n    buf_T\t*buf,\n    int\t\tfree_p_ff)\n{\n    if (free_p_ff)\n    {\n\tclear_string_option(&buf->b_p_fenc);\n\tclear_string_option(&buf->b_p_ff);\n\tclear_string_option(&buf->b_p_bh);\n\tclear_string_option(&buf->b_p_bt);\n    }\n#ifdef FEAT_FIND_ID\n    clear_string_option(&buf->b_p_def);\n    clear_string_option(&buf->b_p_inc);\n# ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_inex);\n# endif\n#endif\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_inde);\n    clear_string_option(&buf->b_p_indk);\n#endif\n#if defined(FEAT_BEVAL) && defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_bexpr);\n#endif\n#if defined(FEAT_CRYPT)\n    clear_string_option(&buf->b_p_cm);\n#endif\n    clear_string_option(&buf->b_p_fp);\n#if defined(FEAT_EVAL)\n    clear_string_option(&buf->b_p_fex);\n#endif\n#ifdef FEAT_CRYPT\n# ifdef FEAT_SODIUM\n    if ((buf->b_p_key != NULL) && (*buf->b_p_key != NUL) &&\n\t\t\t\t(crypt_get_method_nr(buf) == CRYPT_M_SOD))\n\tcrypt_sodium_munlock(buf->b_p_key, STRLEN(buf->b_p_key));\n# endif\n    clear_string_option(&buf->b_p_key);\n#endif\n    clear_string_option(&buf->b_p_kp);\n    clear_string_option(&buf->b_p_mps);\n    clear_string_option(&buf->b_p_fo);\n    clear_string_option(&buf->b_p_flp);\n    clear_string_option(&buf->b_p_isk);\n#ifdef FEAT_VARTABS\n    clear_string_option(&buf->b_p_vsts);\n    vim_free(buf->b_p_vsts_nopaste);\n    buf->b_p_vsts_nopaste = NULL;\n    VIM_CLEAR(buf->b_p_vsts_array);\n    clear_string_option(&buf->b_p_vts);\n    VIM_CLEAR(buf->b_p_vts_array);\n#endif\n#ifdef FEAT_KEYMAP\n    clear_string_option(&buf->b_p_keymap);\n    keymap_clear(&buf->b_kmap_ga);\n    ga_clear(&buf->b_kmap_ga);\n#endif\n    clear_string_option(&buf->b_p_com);\n#ifdef FEAT_FOLDING\n    clear_string_option(&buf->b_p_cms);\n#endif\n    clear_string_option(&buf->b_p_nf);\n#ifdef FEAT_SYN_HL\n    clear_string_option(&buf->b_p_syn);\n    clear_string_option(&buf->b_s.b_syn_isk);\n#endif\n#ifdef FEAT_SPELL\n    clear_string_option(&buf->b_s.b_p_spc);\n    clear_string_option(&buf->b_s.b_p_spf);\n    vim_regfree(buf->b_s.b_cap_prog);\n    buf->b_s.b_cap_prog = NULL;\n    clear_string_option(&buf->b_s.b_p_spl);\n    clear_string_option(&buf->b_s.b_p_spo);\n#endif\n    clear_string_option(&buf->b_p_sua);\n    clear_string_option(&buf->b_p_ft);\n    clear_string_option(&buf->b_p_cink);\n    clear_string_option(&buf->b_p_cino);\n    clear_string_option(&buf->b_p_lop);\n    clear_string_option(&buf->b_p_cinsd);\n    clear_string_option(&buf->b_p_cinw);\n    clear_string_option(&buf->b_p_cpt);\n#ifdef FEAT_COMPL_FUNC\n    clear_string_option(&buf->b_p_cfu);\n    free_callback(&buf->b_cfu_cb);\n    clear_string_option(&buf->b_p_ofu);\n    free_callback(&buf->b_ofu_cb);\n    clear_string_option(&buf->b_p_tsrfu);\n    free_callback(&buf->b_tsrfu_cb);\n#endif\n#ifdef FEAT_QUICKFIX\n    clear_string_option(&buf->b_p_gp);\n    clear_string_option(&buf->b_p_mp);\n    clear_string_option(&buf->b_p_efm);\n#endif\n    clear_string_option(&buf->b_p_ep);\n    clear_string_option(&buf->b_p_path);\n    clear_string_option(&buf->b_p_tags);\n    clear_string_option(&buf->b_p_tc);\n#ifdef FEAT_EVAL\n    clear_string_option(&buf->b_p_tfu);\n    free_callback(&buf->b_tfu_cb);\n#endif\n    clear_string_option(&buf->b_p_dict);\n    clear_string_option(&buf->b_p_tsr);\n    clear_string_option(&buf->b_p_qe);\n    buf->b_p_ar = -1;\n    buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n    clear_string_option(&buf->b_p_lw);\n    clear_string_option(&buf->b_p_bkc);\n    clear_string_option(&buf->b_p_menc);\n}\n\n/*\n * Get alternate file \"n\".\n * Set linenr to \"lnum\" or altfpos.lnum if \"lnum\" == 0.\n *\tAlso set cursor column to altfpos.col if 'startofline' is not set.\n * if (options & GETF_SETMARK) call setpcmark()\n * if (options & GETF_ALT) we are jumping to an alternate file.\n * if (options & GETF_SWITCH) respect 'switchbuf' settings when jumping\n *\n * Return FAIL for failure, OK for success.\n */\n    int\nbuflist_getfile(\n    int\t\tn,\n    linenr_T\tlnum,\n    int\t\toptions,\n    int\t\tforceit)\n{\n    buf_T\t*buf;\n    win_T\t*wp = NULL;\n    pos_T\t*fpos;\n    colnr_T\tcol;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n    {\n\tif ((options & GETF_ALT) && n == 0)\n\t    emsg(_(e_no_alternate_file));\n\telse\n\t    semsg(_(e_buffer_nr_not_found), n);\n\treturn FAIL;\n    }\n\n    // if alternate file is the current buffer, nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    if (text_or_buf_locked())\n\treturn FAIL;\n\n    // altfpos may be changed by getfile(), get it now\n    if (lnum == 0)\n    {\n\tfpos = buflist_findfpos(buf);\n\tlnum = fpos->lnum;\n\tcol = fpos->col;\n    }\n    else\n\tcol = 0;\n\n    if (options & GETF_SWITCH)\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif (swb_flags & SWB_USEOPEN)\n\t    wp = buf_jump_open_win(buf);\n\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif (wp == NULL && (swb_flags & SWB_USETAB))\n\t    wp = buf_jump_open_tab(buf);\n\n\t// If 'switchbuf' contains \"split\", \"vsplit\" or \"newtab\" and the\n\t// current buffer isn't empty: open new tab or window\n\tif (wp == NULL && (swb_flags & (SWB_VSPLIT | SWB_SPLIT | SWB_NEWTAB))\n\t\t\t\t\t\t\t       && !BUFEMPTY())\n\t{\n\t    if (swb_flags & SWB_NEWTAB)\n\t\ttabpage_new();\n\t    else if (win_split(0, (swb_flags & SWB_VSPLIT) ? WSP_VERT : 0)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t    RESET_BINDING(curwin);\n\t}\n    }\n\n    ++RedrawingDisabled;\n    if (GETFILE_SUCCESS(getfile(buf->b_fnum, NULL, NULL,\n\t\t\t\t     (options & GETF_SETMARK), lnum, forceit)))\n    {\n\t--RedrawingDisabled;\n\n\t// cursor is at to BOL and w_cursor.lnum is checked due to getfile()\n\tif (!p_sol && col != 0)\n\t{\n\t    curwin->w_cursor.col = col;\n\t    check_cursor_col();\n\t    curwin->w_cursor.coladd = 0;\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\treturn OK;\n    }\n    --RedrawingDisabled;\n    return FAIL;\n}\n\n/*\n * go to the last know line number for the current buffer\n */\n    static void\nbuflist_getfpos(void)\n{\n    pos_T\t*fpos;\n\n    fpos = buflist_findfpos(curbuf);\n\n    curwin->w_cursor.lnum = fpos->lnum;\n    check_cursor_lnum();\n\n    if (p_sol)\n\tcurwin->w_cursor.col = 0;\n    else\n    {\n\tcurwin->w_cursor.col = fpos->col;\n\tcheck_cursor_col();\n\tcurwin->w_cursor.coladd = 0;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n#if defined(FEAT_QUICKFIX) || defined(FEAT_EVAL) || defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname_exp(char_u *fname)\n{\n    char_u\t*ffname;\n    buf_T\t*buf = NULL;\n\n    // First make the name into a full path name\n    ffname = FullName_save(fname,\n#ifdef UNIX\n\t    TRUE\t    // force expansion, get rid of symbolic links\n#else\n\t    FALSE\n#endif\n\t    );\n    if (ffname != NULL)\n    {\n\tbuf = buflist_findname(ffname);\n\tvim_free(ffname);\n    }\n    return buf;\n}\n#endif\n\n/*\n * Find file in buffer list by name (it has to be for the current window).\n * \"ffname\" must have a full path.\n * Skips dummy buffers.\n * Returns NULL if not found.\n */\n    buf_T *\nbuflist_findname(char_u *ffname)\n{\n#ifdef UNIX\n    stat_T\tst;\n\n    if (mch_stat((char *)ffname, &st) < 0)\n\tst.st_dev = (dev_T)-1;\n    return buflist_findname_stat(ffname, &st);\n}\n\n/*\n * Same as buflist_findname(), but pass the stat structure to avoid getting it\n * twice for the same file.\n * Returns NULL if not found.\n */\n    static buf_T *\nbuflist_findname_stat(\n    char_u\t*ffname,\n    stat_T\t*stp)\n{\n#endif\n    buf_T\t*buf;\n\n    // Start at the last buffer, expect to find a match sooner.\n    FOR_ALL_BUFS_FROM_LAST(buf)\n\tif ((buf->b_flags & BF_DUMMY) == 0 && !otherfile_buf(buf, ffname\n#ifdef UNIX\n\t\t    , stp\n#endif\n\t\t    ))\n\t    return buf;\n    return NULL;\n}\n\n/*\n * Find file in buffer list by a regexp pattern.\n * Return fnum of the found buffer.\n * Return < 0 for error.\n */\n    int\nbuflist_findpat(\n    char_u\t*pattern,\n    char_u\t*pattern_end,\t// pointer to first char after pattern\n    int\t\tunlisted,\t// find unlisted buffers\n    int\t\tdiffmode UNUSED, // find diff-mode buffers only\n    int\t\tcurtab_only)\t// find buffers in current tab only\n{\n    buf_T\t*buf;\n    int\t\tmatch = -1;\n    int\t\tfind_listed;\n    char_u\t*pat;\n    char_u\t*patend;\n    int\t\tattempt;\n    char_u\t*p;\n    int\t\ttoggledollar;\n\n    // \"%\" is current file, \"%%\" or \"#\" is alternate file\n    if ((pattern_end == pattern + 1 && (*pattern == '%' || *pattern == '#'))\n\t    || (in_vim9script() && pattern_end == pattern + 2\n\t\t\t\t    && pattern[0] == '%' && pattern[1] == '%'))\n    {\n\tif (*pattern == '#' || pattern_end == pattern + 2)\n\t    match = curwin->w_alt_fnum;\n\telse\n\t    match = curbuf->b_fnum;\n#ifdef FEAT_DIFF\n\tif (diffmode && !diff_mode_buf(buflist_findnr(match)))\n\t    match = -1;\n#endif\n    }\n\n    /*\n     * Try four ways of matching a listed buffer:\n     * attempt == 0: without '^' or '$' (at any position)\n     * attempt == 1: with '^' at start (only at position 0)\n     * attempt == 2: with '$' at end (only match at end)\n     * attempt == 3: with '^' at start and '$' at end (only full match)\n     * Repeat this for finding an unlisted buffer if there was no matching\n     * listed buffer.\n     */\n    else\n    {\n\tpat = file_pat_to_reg_pat(pattern, pattern_end, NULL, FALSE);\n\tif (pat == NULL)\n\t    return -1;\n\tpatend = pat + STRLEN(pat) - 1;\n\ttoggledollar = (patend > pat && *patend == '$');\n\n\t// First try finding a listed buffer.  If not found and \"unlisted\"\n\t// is TRUE, try finding an unlisted buffer.\n\tfind_listed = TRUE;\n\tfor (;;)\n\t{\n\t    for (attempt = 0; attempt <= 3; ++attempt)\n\t    {\n\t\tregmatch_T\tregmatch;\n\n\t\t// may add '^' and '$'\n\t\tif (toggledollar)\n\t\t    *patend = (attempt < 2) ? NUL : '$'; // add/remove '$'\n\t\tp = pat;\n\t\tif (*p == '^' && !(attempt & 1))\t // add/remove '^'\n\t\t    ++p;\n\t\tregmatch.regprog = vim_regcomp(p, magic_isset() ? RE_MAGIC : 0);\n\n\t\tFOR_ALL_BUFS_FROM_LAST(buf)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after switching engine\n\t\t\tvim_free(pat);\n\t\t\treturn -1;\n\t\t    }\n\t\t    if (buf->b_p_bl == find_listed\n#ifdef FEAT_DIFF\n\t\t\t    && (!diffmode || diff_mode_buf(buf))\n#endif\n\t\t\t    && buflist_match(&regmatch, buf, FALSE) != NULL)\n\t\t    {\n\t\t\tif (curtab_only)\n\t\t\t{\n\t\t\t    // Ignore the match if the buffer is not open in\n\t\t\t    // the current tab.\n\t\t\t    win_T\t*wp;\n\n\t\t\t    FOR_ALL_WINDOWS(wp)\n\t\t\t\tif (wp->w_buffer == buf)\n\t\t\t\t    break;\n\t\t\t    if (wp == NULL)\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (match >= 0)\t\t// already found a match\n\t\t\t{\n\t\t\t    match = -2;\n\t\t\t    break;\n\t\t\t}\n\t\t\tmatch = buf->b_fnum;\t// remember first match\n\t\t    }\n\t\t}\n\n\t\tvim_regfree(regmatch.regprog);\n\t\tif (match >= 0)\t\t\t// found one match\n\t\t    break;\n\t    }\n\n\t    // Only search for unlisted buffers if there was no match with\n\t    // a listed buffer.\n\t    if (!unlisted || !find_listed || match != -1)\n\t\tbreak;\n\t    find_listed = FALSE;\n\t}\n\n\tvim_free(pat);\n    }\n\n    if (match == -2)\n\tsemsg(_(e_more_than_one_match_for_str), pattern);\n    else if (match < 0)\n\tsemsg(_(e_no_matching_buffer_for_str), pattern);\n    return match;\n}\n\n#ifdef FEAT_VIMINFO\ntypedef struct {\n    buf_T   *buf;\n    char_u  *match;\n} bufmatch_T;\n#endif\n\n/*\n * Find all buffer names that match.\n * For command line expansion of \":buf\" and \":sbuf\".\n * Return OK if matches found, FAIL otherwise.\n */\n    int\nExpandBufnames(\n    char_u\t*pat,\n    int\t\t*num_file,\n    char_u\t***file,\n    int\t\toptions)\n{\n    int\t\tcount = 0;\n    buf_T\t*buf;\n    int\t\tround;\n    char_u\t*p;\n    int\t\tattempt;\n    char_u\t*patc = NULL;\n#ifdef FEAT_VIMINFO\n    bufmatch_T\t*matches = NULL;\n#endif\n    int\t\tfuzzy;\n    fuzmatch_str_T  *fuzmatch = NULL;\n\n    *num_file = 0;\t\t    // return values in case of FAIL\n    *file = NULL;\n\n#ifdef FEAT_DIFF\n    if ((options & BUF_DIFF_FILTER) && !curwin->w_p_diff)\n\treturn FAIL;\n#endif\n\n    fuzzy = cmdline_fuzzy_complete(pat);\n\n    // Make a copy of \"pat\" and change \"^\" to \"\\(^\\|[\\/]\\)\" (if doing regular\n    // expression matching)\n    if (!fuzzy)\n    {\n\tif (*pat == '^')\n\t{\n\t    patc = alloc(STRLEN(pat) + 11);\n\t    if (patc == NULL)\n\t\treturn FAIL;\n\t    STRCPY(patc, \"\\\\(^\\\\|[\\\\/]\\\\)\");\n\t    STRCPY(patc + 11, pat + 1);\n\t}\n\telse\n\t    patc = pat;\n    }\n\n    // attempt == 0: try match with    '\\<', match at start of word\n    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)\n\t\t\t    p = buf->b_ffname;\n\t\t    }\n\t\t}\n\n\t\tif (p == NULL)\n\t\t    continue;\n\n\t\tif (round == 1)\n\t\t{\n\t\t    ++count;\n\t\t    continue;\n\t\t}\n\n\t\tif (options & WILD_HOME_REPLACE)\n\t\t    p = home_replace_save(buf, p);\n\t\telse\n\t\t    p = vim_strsave(p);\n\n\t\tif (!fuzzy)\n\t\t{\n#ifdef FEAT_VIMINFO\n\t\t    if (matches != NULL)\n\t\t    {\n\t\t\tmatches[count].buf = buf;\n\t\t\tmatches[count].match = p;\n\t\t\tcount++;\n\t\t    }\n\t\t    else\n#endif\n\t\t\t(*file)[count++] = p;\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch[count].idx = count;\n\t\t    fuzmatch[count].str = p;\n\t\t    fuzmatch[count].score = score;\n\t\t    count++;\n\t\t}\n\t    }\n\t    if (count == 0)\t// no match found, break here\n\t\tbreak;\n\t    if (round == 1)\n\t    {\n\t\tif (!fuzzy)\n\t\t{\n\t\t    *file = ALLOC_MULT(char_u *, count);\n\t\t    if (*file == NULL)\n\t\t    {\n\t\t\tvim_regfree(regmatch.regprog);\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n#ifdef FEAT_VIMINFO\n\t\t    if (options & WILD_BUFLASTUSED)\n\t\t\tmatches = ALLOC_MULT(bufmatch_T, count);\n#endif\n\t\t}\n\t\telse\n\t\t{\n\t\t    fuzmatch = ALLOC_MULT(fuzmatch_str_T, count);\n\t\t    if (fuzmatch == NULL)\n\t\t    {\n\t\t\t*num_file = 0;\n\t\t\t*file = NULL;\n\t\t\treturn FAIL;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tif (!fuzzy)\n\t{\n\t    vim_regfree(regmatch.regprog);\n\t    if (count)\t\t// match(es) found, break here\n\t\tbreak;\n\t}\n    }\n\n    if (!fuzzy && patc != pat)\n\tvim_free(patc);\n\n#ifdef FEAT_VIMINFO\n    if (!fuzzy)\n    {\n\tif (matches != NULL)\n\t{\n\t    int i;\n\t    if (count > 1)\n\t\tqsort(matches, count, sizeof(bufmatch_T), buf_compare);\n\t    // if the current buffer is first in the list, place it at the end\n\t    if (matches[0].buf == curbuf)\n\t    {\n\t\tfor (i = 1; i < count; i++)\n\t\t    (*file)[i-1] = matches[i].match;\n\t\t(*file)[count-1] = matches[0].match;\n\t    }\n\t    else\n\t    {\n\t\tfor (i = 0; i < count; i++)\n\t\t    (*file)[i] = matches[i].match;\n\t    }\n\t    vim_free(matches);\n\t}\n    }\n    else\n    {\n\tif (fuzzymatches_to_strmatches(fuzmatch, file, count, FALSE) == FAIL)\n\t    return FAIL;\n    }\n#endif\n\n    *num_file = count;\n    return (count == 0 ? FAIL : OK);\n}\n\n/*\n * Check for a match on the file name for buffer \"buf\" with regprog \"prog\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n */\n    static char_u *\nbuflist_match(\n    regmatch_T\t*rmp,\n    buf_T\t*buf,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match;\n\n    // First try the short file name, then the long file name.\n    match = fname_match(rmp, buf->b_sfname, ignore_case);\n    if (match == NULL && rmp->regprog != NULL)\n\tmatch = fname_match(rmp, buf->b_ffname, ignore_case);\n\n    return match;\n}\n\n/*\n * Try matching the regexp in \"rmp->regprog\" with file name \"name\".\n * Note that rmp->regprog may become NULL when switching regexp engine.\n * Return \"name\" when there is a match, NULL when not.\n */\n    static char_u *\nfname_match(\n    regmatch_T\t*rmp,\n    char_u\t*name,\n    int\t\tignore_case)  // when TRUE ignore case, when FALSE use 'fic'\n{\n    char_u\t*match = NULL;\n    char_u\t*p;\n\n    // extra check for valid arguments\n    if (name != NULL && rmp->regprog != NULL)\n    {\n\t// Ignore case when 'fileignorecase' or the argument is set.\n\trmp->rm_ic = p_fic || ignore_case;\n\tif (vim_regexec(rmp, name, (colnr_T)0))\n\t    match = name;\n\telse if (rmp->regprog != NULL)\n\t{\n\t    // Replace $(HOME) with '~' and try matching again.\n\t    p = home_replace_save(NULL, name);\n\t    if (p != NULL && vim_regexec(rmp, p, (colnr_T)0))\n\t\tmatch = name;\n\t    vim_free(p);\n\t}\n    }\n\n    return match;\n}\n\n/*\n * Find a file in the buffer list by buffer number.\n */\n    buf_T *\nbuflist_findnr(int nr)\n{\n    char_u\tkey[VIM_SIZEOF_INT * 2 + 1];\n    hashitem_T\t*hi;\n\n    if (nr == 0)\n\tnr = curwin->w_alt_fnum;\n    sprintf((char *)key, \"%x\", nr);\n    hi = hash_find(&buf_hashtab, key);\n\n    if (!HASHITEM_EMPTY(hi))\n\treturn (buf_T *)(hi->hi_key\n\t\t\t     - ((unsigned)(curbuf->b_key - (char_u *)curbuf)));\n    return NULL;\n}\n\n/*\n * Get name of file 'n' in the buffer list.\n * When the file has no name an empty string is returned.\n * home_replace() is used to shorten the file name (used for marks).\n * Returns a pointer to allocated memory, of NULL when failed.\n */\n    char_u *\nbuflist_nr2name(\n    int\t\tn,\n    int\t\tfullname,\n    int\t\thelptail)\t// for help buffers return tail only\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(n);\n    if (buf == NULL)\n\treturn NULL;\n    return home_replace_save(helptail ? buf : NULL,\n\t\t\t\t     fullname ? buf->b_ffname : buf->b_fname);\n}\n\n/*\n * Set the \"lnum\" and \"col\" for the buffer \"buf\" and the current window.\n * When \"copy_options\" is TRUE save the local window option values.\n * When \"lnum\" is 0 only do the options.\n */\n    void\nbuflist_setfpos(\n    buf_T\t*buf,\n    win_T\t*win,\t\t// may be NULL when using :badd\n    linenr_T\tlnum,\n    colnr_T\tcol,\n    int\t\tcopy_options)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == win)\n\t    break;\n    if (wip == NULL)\n    {\n\t// allocate a new entry\n\twip = ALLOC_CLEAR_ONE(wininfo_T);\n\tif (wip == NULL)\n\t    return;\n\twip->wi_win = win;\n\tif (lnum == 0)\t\t// set lnum even when it's 0\n\t    lnum = 1;\n    }\n    else\n    {\n\t// remove the entry from the list\n\tif (wip->wi_prev)\n\t    wip->wi_prev->wi_next = wip->wi_next;\n\telse\n\t    buf->b_wininfo = wip->wi_next;\n\tif (wip->wi_next)\n\t    wip->wi_next->wi_prev = wip->wi_prev;\n\tif (copy_options && wip->wi_optset)\n\t{\n\t    clear_winopt(&wip->wi_opt);\n#ifdef FEAT_FOLDING\n\t    deleteFoldRecurse(&wip->wi_folds);\n#endif\n\t}\n    }\n    if (lnum != 0)\n    {\n\twip->wi_fpos.lnum = lnum;\n\twip->wi_fpos.col = col;\n    }\n    if (win != NULL)\n\twip->wi_changelistidx = win->w_changelistidx;\n    if (copy_options && win != NULL)\n    {\n\t// Save the window-specific option values.\n\tcopy_winopt(&win->w_onebuf_opt, &wip->wi_opt);\n#ifdef FEAT_FOLDING\n\twip->wi_fold_manual = win->w_fold_manual;\n\tcloneFoldGrowArray(&win->w_folds, &wip->wi_folds);\n#endif\n\twip->wi_optset = TRUE;\n    }\n\n    // insert the entry in front of the list\n    wip->wi_next = buf->b_wininfo;\n    buf->b_wininfo = wip;\n    wip->wi_prev = NULL;\n    if (wip->wi_next)\n\twip->wi_next->wi_prev = wip;\n}\n\n#ifdef FEAT_DIFF\n/*\n * Return TRUE when \"wip\" has 'diff' set and the diff is only for another tab\n * page.  That's because a diff is local to a tab page.\n */\n    static int\nwininfo_other_tab_diff(wininfo_T *wip)\n{\n    win_T\t*wp;\n\n    if (wip->wi_opt.wo_diff)\n    {\n\tFOR_ALL_WINDOWS(wp)\n\t    // return FALSE when it's a window in the current tab page, thus\n\t    // the buffer was in diff mode here\n\t    if (wip->wi_win == wp)\n\t\treturn FALSE;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n#endif\n\n/*\n * Find info for the current window in buffer \"buf\".\n * If not found, return the info for the most recently used window.\n * When \"need_options\" is TRUE skip entries where wi_optset is FALSE.\n * When \"skip_diff_buffer\" is TRUE avoid windows with 'diff' set that is in\n * another tab page.\n * Returns NULL when there isn't any info.\n */\n    static wininfo_T *\nfind_wininfo(\n    buf_T\t*buf,\n    int\t\tneed_options,\n    int\t\tskip_diff_buffer UNUSED)\n{\n    wininfo_T\t*wip;\n\n    FOR_ALL_BUF_WININFO(buf, wip)\n\tif (wip->wi_win == curwin\n#ifdef FEAT_DIFF\n\t\t&& (!skip_diff_buffer || !wininfo_other_tab_diff(wip))\n#endif\n\n\t\t&& (!need_options || wip->wi_optset))\n\t    break;\n\n    // If no wininfo for curwin, use the first in the list (that doesn't have\n    // 'diff' set and is in another tab page).\n    // If \"need_options\" is TRUE skip entries that don't have options set,\n    // unless the window is editing \"buf\", so we can copy from the window\n    // itself.\n    if (wip == NULL)\n    {\n#ifdef FEAT_DIFF\n\tif (skip_diff_buffer)\n\t{\n\t    FOR_ALL_BUF_WININFO(buf, wip)\n\t\tif (!wininfo_other_tab_diff(wip)\n\t\t\t&& (!need_options || wip->wi_optset\n\t\t\t    || (wip->wi_win != NULL\n\t\t\t\t\t     && wip->wi_win->w_buffer == buf)))\n\t\t    break;\n\t}\n\telse\n#endif\n\t    wip = buf->b_wininfo;\n    }\n    return wip;\n}\n\n/*\n * Reset the local window options to the values last used in this window.\n * If the buffer wasn't used in this window before, use the values from\n * the most recently used window.  If the values were never set, use the\n * global values for the window.\n */\n    void\nget_winopts(buf_T *buf)\n{\n    wininfo_T\t*wip;\n\n    clear_winopt(&curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n    clearFolding(curwin);\n#endif\n\n    wip = find_wininfo(buf, TRUE, TRUE);\n    if (wip != NULL && wip->wi_win != NULL\n\t    && wip->wi_win != curwin && wip->wi_win->w_buffer == buf)\n    {\n\t// The buffer is currently displayed in the window: use the actual\n\t// option values instead of the saved (possibly outdated) values.\n\twin_T *wp = wip->wi_win;\n\n\tcopy_winopt(&wp->w_onebuf_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wp->w_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wp->w_folds, &curwin->w_folds);\n#endif\n    }\n    else if (wip != NULL && wip->wi_optset)\n    {\n\t// the buffer was displayed in the current window earlier\n\tcopy_winopt(&wip->wi_opt, &curwin->w_onebuf_opt);\n#ifdef FEAT_FOLDING\n\tcurwin->w_fold_manual = wip->wi_fold_manual;\n\tcurwin->w_foldinvalid = TRUE;\n\tcloneFoldGrowArray(&wip->wi_folds, &curwin->w_folds);\n#endif\n    }\n    else\n\tcopy_winopt(&curwin->w_allbuf_opt, &curwin->w_onebuf_opt);\n    if (wip != NULL)\n\tcurwin->w_changelistidx = wip->wi_changelistidx;\n\n#ifdef FEAT_FOLDING\n    // Set 'foldlevel' to 'foldlevelstart' if it's not negative.\n    if (p_fdls >= 0)\n\tcurwin->w_p_fdl = p_fdls;\n#endif\n    after_copy_winopt(curwin);\n}\n\n/*\n * Find the position (lnum and col) for the buffer 'buf' for the current\n * window.\n * Returns a pointer to no_position if no position is found.\n */\n    pos_T *\nbuflist_findfpos(buf_T *buf)\n{\n    wininfo_T\t*wip;\n    static pos_T no_position = {1, 0, 0};\n\n    wip = find_wininfo(buf, FALSE, FALSE);\n    if (wip != NULL)\n\treturn &(wip->wi_fpos);\n    else\n\treturn &no_position;\n}\n\n/*\n * Find the lnum for the buffer 'buf' for the current window.\n */\n    linenr_T\nbuflist_findlnum(buf_T *buf)\n{\n    return buflist_findfpos(buf)->lnum;\n}\n\n/*\n * List all known file names (for :files and :buffers command).\n */\n    void\nbuflist_list(exarg_T *eap)\n{\n    buf_T\t*buf = firstbuf;\n    int\t\tlen;\n    int\t\ti;\n    int\t\tro_char;\n    int\t\tchanged_char;\n#ifdef FEAT_TERMINAL\n    int\t\tjob_running;\n    int\t\tjob_none_open;\n#endif\n\n#ifdef FEAT_VIMINFO\n    garray_T\tbuflist;\n    buf_T\t**buflist_data = NULL, **p;\n\n    if (vim_strchr(eap->arg, 't'))\n    {\n\tga_init2(&buflist, sizeof(buf_T *), 50);\n\tFOR_ALL_BUFFERS(buf)\n\t{\n\t    if (ga_grow(&buflist, 1) == OK)\n\t\t((buf_T **)buflist.ga_data)[buflist.ga_len++] = buf;\n\t}\n\n\tqsort(buflist.ga_data, (size_t)buflist.ga_len,\n\t\tsizeof(buf_T *), buf_compare);\n\n\tbuflist_data = (buf_T **)buflist.ga_data;\n\tbuf = *buflist_data;\n    }\n    p = buflist_data;\n\n    for (; buf != NULL && !got_int; buf = buflist_data != NULL\n\t    ? (++p < buflist_data + buflist.ga_len ? *p : NULL)\n\t    : buf->b_next)\n#else\n    for (buf = firstbuf; buf != NULL && !got_int; buf = buf->b_next)\n#endif\n    {\n#ifdef FEAT_TERMINAL\n\tjob_running = term_job_running(buf->b_term);\n\tjob_none_open = term_none_open(buf->b_term);\n#endif\n\t// skip unlisted buffers, unless ! was used\n\tif ((!buf->b_p_bl && !eap->forceit && !vim_strchr(eap->arg, 'u'))\n\t\t|| (vim_strchr(eap->arg, 'u') && buf->b_p_bl)\n\t\t|| (vim_strchr(eap->arg, '+')\n\t\t\t&& ((buf->b_flags & BF_READERR) || !bufIsChanged(buf)))\n\t\t|| (vim_strchr(eap->arg, 'a')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows == 0))\n\t\t|| (vim_strchr(eap->arg, 'h')\n\t\t\t&& (buf->b_ml.ml_mfp == NULL || buf->b_nwindows != 0))\n#ifdef FEAT_TERMINAL\n\t\t|| (vim_strchr(eap->arg, 'R')\n\t\t\t&& (!job_running || (job_running && job_none_open)))\n\t\t|| (vim_strchr(eap->arg, '?')\n\t\t\t&& (!job_running || (job_running && !job_none_open)))\n\t\t|| (vim_strchr(eap->arg, 'F')\n\t\t\t&& (job_running || buf->b_term == NULL))\n#endif\n\t\t|| (vim_strchr(eap->arg, '-') && buf->b_p_ma)\n\t\t|| (vim_strchr(eap->arg, '=') && !buf->b_p_ro)\n\t\t|| (vim_strchr(eap->arg, 'x') && !(buf->b_flags & BF_READERR))\n\t\t|| (vim_strchr(eap->arg, '%') && buf != curbuf)\n\t\t|| (vim_strchr(eap->arg, '#')\n\t\t      && (buf == curbuf || curwin->w_alt_fnum != buf->b_fnum)))\n\t    continue;\n\tif (buf_spname(buf) != NULL)\n\t    vim_strncpy(NameBuff, buf_spname(buf), MAXPATHL - 1);\n\telse\n\t    home_replace(buf, buf->b_fname, NameBuff, MAXPATHL, TRUE);\n\tif (message_filtered(NameBuff))\n\t    continue;\n\n\tchanged_char = (buf->b_flags & BF_READERR) ? 'x'\n\t\t\t\t\t     : (bufIsChanged(buf) ? '+' : ' ');\n#ifdef FEAT_TERMINAL\n\tif (job_running)\n\t{\n\t    if (job_none_open)\n\t\tro_char = '?';\n\t    else\n\t\tro_char = 'R';\n\t    changed_char = ' ';  // bufIsChanged() returns TRUE to avoid\n\t\t\t\t // closing, but it's not actually changed.\n\t}\n\telse if (buf->b_term != NULL)\n\t    ro_char = 'F';\n\telse\n#endif\n\t    ro_char = !buf->b_p_ma ? '-' : (buf->b_p_ro ? '=' : ' ');\n\n\tmsg_putchar('\\n');\n\tlen = vim_snprintf((char *)IObuff, IOSIZE - 20, \"%3d%c%c%c%c%c \\\"%s\\\"\",\n\t\tbuf->b_fnum,\n\t\tbuf->b_p_bl ? ' ' : 'u',\n\t\tbuf == curbuf ? '%' :\n\t\t\t(curwin->w_alt_fnum == buf->b_fnum ? '#' : ' '),\n\t\tbuf->b_ml.ml_mfp == NULL ? ' ' :\n\t\t\t(buf->b_nwindows == 0 ? 'h' : 'a'),\n\t\tro_char,\n\t\tchanged_char,\n\t\tNameBuff);\n\tif (len > IOSIZE - 20)\n\t    len = IOSIZE - 20;\n\n\t// put \"line 999\" in column 40 or after the file name\n\ti = 40 - vim_strsize(IObuff);\n\tdo\n\t    IObuff[len++] = ' ';\n\twhile (--i > 0 && len < IOSIZE - 18);\n#ifdef FEAT_VIMINFO\n\tif (vim_strchr(eap->arg, 't') && buf->b_last_used)\n\t    add_time(IObuff + len, (size_t)(IOSIZE - len), buf->b_last_used);\n\telse\n#endif\n\t    vim_snprintf((char *)IObuff + len, (size_t)(IOSIZE - len),\n\t\t    _(\"line %ld\"), buf == curbuf ? curwin->w_cursor.lnum\n\t\t\t\t\t       : (long)buflist_findlnum(buf));\n\tmsg_outtrans(IObuff);\n\tout_flush();\t    // output one line at a time\n\tui_breakcheck();\n    }\n\n#ifdef FEAT_VIMINFO\n    if (buflist_data)\n\tga_clear(&buflist);\n#endif\n}\n\n/*\n * Get file name and line number for file 'fnum'.\n * Used by DoOneCmd() for translating '%' and '#'.\n * Used by insert_reg() and cmdline_paste() for '#' register.\n * Return FAIL if not found, OK for success.\n */\n    int\nbuflist_name_nr(\n    int\t\tfnum,\n    char_u\t**fname,\n    linenr_T\t*lnum)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL || buf->b_fname == NULL)\n\treturn FAIL;\n\n    *fname = buf->b_fname;\n    *lnum = buflist_findlnum(buf);\n\n    return OK;\n}\n\n/*\n * Set the file name for \"buf\"' to \"ffname_arg\", short file name to\n * \"sfname_arg\".\n * The file name with the full path is also remembered, for when :cd is used.\n * Returns FAIL for failure (file name already in use by other buffer)\n *\tOK otherwise.\n */\n    int\nsetfname(\n    buf_T\t*buf,\n    char_u\t*ffname_arg,\n    char_u\t*sfname_arg,\n    int\t\tmessage)\t// give message when buffer already exists\n{\n    char_u\t*ffname = ffname_arg;\n    char_u\t*sfname = sfname_arg;\n    buf_T\t*obuf = NULL;\n#ifdef UNIX\n    stat_T\tst;\n#endif\n\n    if (ffname == NULL || *ffname == NUL)\n    {\n\t// Removing the name.\n\tif (buf->b_sfname != buf->b_ffname)\n\t    VIM_CLEAR(buf->b_sfname);\n\telse\n\t    buf->b_sfname = NULL;\n\tVIM_CLEAR(buf->b_ffname);\n#ifdef UNIX\n\tst.st_dev = (dev_T)-1;\n#endif\n    }\n    else\n    {\n\tfname_expand(buf, &ffname, &sfname); // will allocate ffname\n\tif (ffname == NULL)\t\t    // out of memory\n\t    return FAIL;\n\n\t/*\n\t * If the file name is already used in another buffer:\n\t * - if the buffer is loaded, fail\n\t * - if the buffer is not loaded, delete it from the list\n\t */\n#ifdef UNIX\n\tif (mch_stat((char *)ffname, &st) < 0)\n\t    st.st_dev = (dev_T)-1;\n#endif\n\tif (!(buf->b_flags & BF_DUMMY))\n#ifdef UNIX\n\t    obuf = buflist_findname_stat(ffname, &st);\n#else\n\t    obuf = buflist_findname(ffname);\n#endif\n\tif (obuf != NULL && obuf != buf)\n\t{\n\t    win_T\t*win;\n\t    tabpage_T   *tab;\n\t    int\t\tin_use = FALSE;\n\n\t    // during startup a window may use a buffer that is not loaded yet\n\t    FOR_ALL_TAB_WINDOWS(tab, win)\n\t\tif (win->w_buffer == obuf)\n\t\t    in_use = TRUE;\n\n\t    // it's loaded or used in a window, fail\n\t    if (obuf->b_ml.ml_mfp != NULL || in_use)\n\t    {\n\t\tif (message)\n\t\t    emsg(_(e_buffer_with_this_name_already_exists));\n\t\tvim_free(ffname);\n\t\treturn FAIL;\n\t    }\n\t    // delete from the list\n\t    close_buffer(NULL, obuf, DOBUF_WIPE, FALSE, FALSE);\n\t}\n\tsfname = vim_strsave(sfname);\n\tif (ffname == NULL || sfname == NULL)\n\t{\n\t    vim_free(sfname);\n\t    vim_free(ffname);\n\t    return FAIL;\n\t}\n#ifdef USE_FNAME_CASE\n\tfname_case(sfname, 0);    // set correct case for short file name\n#endif\n\tif (buf->b_sfname != buf->b_ffname)\n\t    vim_free(buf->b_sfname);\n\tvim_free(buf->b_ffname);\n\tbuf->b_ffname = ffname;\n\tbuf->b_sfname = sfname;\n    }\n    buf->b_fname = buf->b_sfname;\n#ifdef UNIX\n    if (st.st_dev == (dev_T)-1)\n\tbuf->b_dev_valid = FALSE;\n    else\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n#endif\n\n    buf->b_shortname = FALSE;\n\n    buf_name_changed(buf);\n    return OK;\n}\n\n/*\n * Crude way of changing the name of a buffer.  Use with care!\n * The name should be relative to the current directory.\n */\n    void\nbuf_set_name(int fnum, char_u *name)\n{\n    buf_T\t*buf;\n\n    buf = buflist_findnr(fnum);\n    if (buf == NULL)\n\treturn;\n\n    if (buf->b_sfname != buf->b_ffname)\n\tvim_free(buf->b_sfname);\n    vim_free(buf->b_ffname);\n    buf->b_ffname = vim_strsave(name);\n    buf->b_sfname = NULL;\n    // Allocate ffname and expand into full path.  Also resolves .lnk\n    // files on Win32.\n    fname_expand(buf, &buf->b_ffname, &buf->b_sfname);\n    buf->b_fname = buf->b_sfname;\n}\n\n/*\n * Take care of what needs to be done when the name of buffer \"buf\" has\n * changed.\n */\n    void\nbuf_name_changed(buf_T *buf)\n{\n    /*\n     * If the file name changed, also change the name of the swapfile\n     */\n    if (buf->b_ml.ml_mfp != NULL)\n\tml_setname(buf);\n\n#ifdef FEAT_TERMINAL\n    if (buf->b_term != NULL)\n\tterm_clear_status_text(buf->b_term);\n#endif\n\n    if (curwin->w_buffer == buf)\n\tcheck_arg_idx(curwin);\t// check file name for arg list\n    maketitle();\t\t// set window title\n    status_redraw_all();\t// status lines need to be redrawn\n    fmarks_check_names(buf);\t// check named file marks\n    ml_timestamp(buf);\t\t// reset timestamp\n}\n\n/*\n * set alternate file name for current window\n *\n * Used by do_one_cmd(), do_write() and do_ecmd().\n * Return the buffer.\n */\n    buf_T *\nsetaltfname(\n    char_u\t*ffname,\n    char_u\t*sfname,\n    linenr_T\tlnum)\n{\n    buf_T\t*buf;\n\n    // Create a buffer.  'buflisted' is not set if it's a new buffer\n    buf = buflist_new(ffname, sfname, lnum, 0);\n    if (buf != NULL && (cmdmod.cmod_flags & CMOD_KEEPALT) == 0)\n\tcurwin->w_alt_fnum = buf->b_fnum;\n    return buf;\n}\n\n/*\n * Get alternate file name for current window.\n * Return NULL if there isn't any, and give error message if requested.\n */\n    char_u  *\ngetaltfname(\n    int\t\terrmsg)\t\t// give error message\n{\n    char_u\t*fname;\n    linenr_T\tdummy;\n\n    if (buflist_name_nr(0, &fname, &dummy) == FAIL)\n    {\n\tif (errmsg)\n\t    emsg(_(e_no_alternate_file));\n\treturn NULL;\n    }\n    return fname;\n}\n\n/*\n * Add a file name to the buflist and return its number.\n * Uses same flags as buflist_new(), except BLN_DUMMY.\n *\n * used by qf_init(), main() and doarglist()\n */\n    int\nbuflist_add(char_u *fname, int flags)\n{\n    buf_T\t*buf;\n\n    buf = buflist_new(fname, NULL, (linenr_T)0, flags);\n    if (buf != NULL)\n\treturn buf->b_fnum;\n    return 0;\n}\n\n#if defined(BACKSLASH_IN_FILENAME) || defined(PROTO)\n/*\n * Adjust slashes in file names.  Called after 'shellslash' was set.\n */\n    void\nbuflist_slash_adjust(void)\n{\n    buf_T\t*bp;\n\n    FOR_ALL_BUFFERS(bp)\n    {\n\tif (bp->b_ffname != NULL)\n\t    slash_adjust(bp->b_ffname);\n\tif (bp->b_sfname != NULL)\n\t    slash_adjust(bp->b_sfname);\n    }\n}\n#endif\n\n/*\n * Set alternate cursor position for the current buffer and window \"win\".\n * Also save the local window option values.\n */\n    void\nbuflist_altfpos(win_T *win)\n{\n    buflist_setfpos(curbuf, win, win->w_cursor.lnum, win->w_cursor.col, TRUE);\n}\n\n/*\n * Return TRUE if 'ffname' is not the same file as current file.\n * Fname must have a full path (expanded by mch_FullName()).\n */\n    int\notherfile(char_u *ffname)\n{\n    return otherfile_buf(curbuf, ffname\n#ifdef UNIX\n\t    , NULL\n#endif\n\t    );\n}\n\n    static int\notherfile_buf(\n    buf_T\t\t*buf,\n    char_u\t\t*ffname\n#ifdef UNIX\n    , stat_T\t\t*stp\n#endif\n    )\n{\n    // no name is different\n    if (ffname == NULL || *ffname == NUL || buf->b_ffname == NULL)\n\treturn TRUE;\n    if (fnamecmp(ffname, buf->b_ffname) == 0)\n\treturn FALSE;\n#ifdef UNIX\n    {\n\tstat_T\t    st;\n\n\t// If no stat_T given, get it now\n\tif (stp == NULL)\n\t{\n\t    if (!buf->b_dev_valid || mch_stat((char *)ffname, &st) < 0)\n\t\tst.st_dev = (dev_T)-1;\n\t    stp = &st;\n\t}\n\t// Use dev/ino to check if the files are the same, even when the names\n\t// are different (possible with links).  Still need to compare the\n\t// name above, for when the file doesn't exist yet.\n\t// Problem: The dev/ino changes when a file is deleted (and created\n\t// again) and remains the same when renamed/moved.  We don't want to\n\t// mch_stat() each buffer each time, that would be too slow.  Get the\n\t// dev/ino again when they appear to match, but not when they appear\n\t// to be different: Could skip a buffer when it's actually the same\n\t// file.\n\tif (buf_same_ino(buf, stp))\n\t{\n\t    buf_setino(buf);\n\t    if (buf_same_ino(buf, stp))\n\t\treturn FALSE;\n\t}\n    }\n#endif\n    return TRUE;\n}\n\n#if defined(UNIX) || defined(PROTO)\n/*\n * Set inode and device number for a buffer.\n * Must always be called when b_fname is changed!.\n */\n    void\nbuf_setino(buf_T *buf)\n{\n    stat_T\tst;\n\n    if (buf->b_fname != NULL && mch_stat((char *)buf->b_fname, &st) >= 0)\n    {\n\tbuf->b_dev_valid = TRUE;\n\tbuf->b_dev = st.st_dev;\n\tbuf->b_ino = st.st_ino;\n    }\n    else\n\tbuf->b_dev_valid = FALSE;\n}\n\n/*\n * Return TRUE if dev/ino in buffer \"buf\" matches with \"stp\".\n */\n    static int\nbuf_same_ino(\n    buf_T\t*buf,\n    stat_T\t*stp)\n{\n    return (buf->b_dev_valid\n\t    && stp->st_dev == buf->b_dev\n\t    && stp->st_ino == buf->b_ino);\n}\n#endif\n\n/*\n * Print info about the current buffer.\n */\n    void\nfileinfo(\n    int fullname,\t    // when non-zero print full path\n    int shorthelp,\n    int\tdont_truncate)\n{\n    char_u\t*name;\n    int\t\tn;\n    char\t*p;\n    char\t*buffer;\n    size_t\tlen;\n\n    buffer = alloc(IOSIZE);\n    if (buffer == NULL)\n\treturn;\n\n    if (fullname > 1)\t    // 2 CTRL-G: include buffer number\n    {\n\tvim_snprintf(buffer, IOSIZE, \"buf %d: \", curbuf->b_fnum);\n\tp = buffer + STRLEN(buffer);\n    }\n    else\n\tp = buffer;\n\n    *p++ = '\"';\n    if (buf_spname(curbuf) != NULL)\n\tvim_strncpy((char_u *)p, buf_spname(curbuf), IOSIZE - (p - buffer) - 1);\n    else\n    {\n\tif (!fullname && curbuf->b_fname != NULL)\n\t    name = curbuf->b_fname;\n\telse\n\t    name = curbuf->b_ffname;\n\thome_replace(shorthelp ? curbuf : NULL, name, (char_u *)p,\n\t\t\t\t\t  (int)(IOSIZE - (p - buffer)), TRUE);\n    }\n\n    vim_snprintf_add(buffer, IOSIZE, \"\\\"%s%s%s%s%s%s\",\n\t    curbufIsChanged() ? (shortmess(SHM_MOD)\n\t\t\t\t\t  ?  \" [+]\" : _(\" [Modified]\")) : \" \",\n\t    (curbuf->b_flags & BF_NOTEDITED) && !bt_dontwrite(curbuf)\n\t\t\t\t\t? _(\"[Not edited]\") : \"\",\n\t    (curbuf->b_flags & BF_NEW) && !bt_dontwrite(curbuf)\n\t\t\t\t\t   ? new_file_message() : \"\",\n\t    (curbuf->b_flags & BF_READERR) ? _(\"[Read errors]\") : \"\",\n\t    curbuf->b_p_ro ? (shortmess(SHM_RO) ? _(\"[RO]\")\n\t\t\t\t\t\t      : _(\"[readonly]\")) : \"\",\n\t    (curbufIsChanged() || (curbuf->b_flags & BF_WRITE_MASK)\n\t\t\t\t\t\t\t  || curbuf->b_p_ro) ?\n\t\t\t\t\t\t\t\t    \" \" : \"\");\n    // With 32 bit longs and more than 21,474,836 lines multiplying by 100\n    // causes an overflow, thus for large numbers divide instead.\n    if (curwin->w_cursor.lnum > 1000000L)\n\tn = (int)(((long)curwin->w_cursor.lnum) /\n\t\t\t\t   ((long)curbuf->b_ml.ml_line_count / 100L));\n    else\n\tn = (int)(((long)curwin->w_cursor.lnum * 100L) /\n\t\t\t\t\t    (long)curbuf->b_ml.ml_line_count);\n    if (curbuf->b_ml.ml_flags & ML_EMPTY)\n\tvim_snprintf_add(buffer, IOSIZE, \"%s\", _(no_lines_msg));\n    else if (p_ru)\n\t// Current line and column are already on the screen -- webb\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\tNGETTEXT(\"%ld line --%d%%--\", \"%ld lines --%d%%--\",\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count),\n\t\t(long)curbuf->b_ml.ml_line_count, n);\n    else\n    {\n\tvim_snprintf_add(buffer, IOSIZE,\n\t\t_(\"line %ld of %ld --%d%%-- col \"),\n\t\t(long)curwin->w_cursor.lnum,\n\t\t(long)curbuf->b_ml.ml_line_count,\n\t\tn);\n\tvalidate_virtcol();\n\tlen = STRLEN(buffer);\n\tcol_print((char_u *)buffer + len, IOSIZE - len,\n\t\t   (int)curwin->w_cursor.col + 1, (int)curwin->w_virtcol + 1);\n    }\n\n    (void)append_arg_number(curwin, (char_u *)buffer, IOSIZE,\n\t\t\t\t\t\t\t !shortmess(SHM_FILE));\n\n    if (dont_truncate)\n    {\n\t// Temporarily set msg_scroll to avoid the message being truncated.\n\t// First call msg_start() to get the message in the right place.\n\tmsg_start();\n\tn = msg_scroll;\n\tmsg_scroll = TRUE;\n\tmsg(buffer);\n\tmsg_scroll = n;\n    }\n    else\n    {\n\tp = msg_trunc_attr(buffer, FALSE, 0);\n\tif (restart_edit != 0 || (msg_scrolled && !need_wait_return))\n\t    // Need to repeat the message after redrawing when:\n\t    // - When restart_edit is set (otherwise there will be a delay\n\t    //   before redrawing).\n\t    // - When the screen was scrolled but there is no wait-return\n\t    //   prompt.\n\t    set_keep_msg((char_u *)p, 0);\n    }\n\n    vim_free(buffer);\n}\n\n    void\ncol_print(\n    char_u  *buf,\n    size_t  buflen,\n    int\t    col,\n    int\t    vcol)\n{\n    if (col == vcol)\n\tvim_snprintf((char *)buf, buflen, \"%d\", col);\n    else\n\tvim_snprintf((char *)buf, buflen, \"%d-%d\", col, vcol);\n}\n\nstatic char_u *lasttitle = NULL;\nstatic char_u *lasticon = NULL;\n\n/*\n * Put the file name in the title bar and icon of the window.\n */\n    void\nmaketitle(void)\n{\n    char_u\t*p;\n    char_u\t*title_str = NULL;\n    char_u\t*icon_str = NULL;\n    int\t\tmaxlen = 0;\n    int\t\tlen;\n    int\t\tmustset;\n    char_u\tbuf[IOSIZE];\n    int\t\toff;\n\n    if (!redrawing())\n    {\n\t// Postpone updating the title when 'lazyredraw' is set.\n\tneed_maketitle = TRUE;\n\treturn;\n    }\n\n    need_maketitle = FALSE;\n    if (!p_title && !p_icon && lasttitle == NULL && lasticon == NULL)\n\treturn;  // nothing to do\n\n    if (p_title)\n    {\n\tif (p_titlelen > 0)\n\t{\n\t    maxlen = p_titlelen * Columns / 100;\n\t    if (maxlen < 10)\n\t\tmaxlen = 10;\n\t}\n\n\ttitle_str = buf;\n\tif (*p_titlestring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_TITLE)\n\t\tbuild_stl_str_hl(curwin, title_str, sizeof(buf), p_titlestring,\n\t\t\t\t    (char_u *)\"titlestring\", 0,\n\t\t\t\t    0, maxlen, NULL, NULL);\n\t    else\n#endif\n\t\ttitle_str = p_titlestring;\n\t}\n\telse\n\t{\n\t    // format: \"fname + (path) (1 of 2) - VIM\"\n\n#define SPACE_FOR_FNAME (IOSIZE - 100)\n#define SPACE_FOR_DIR   (IOSIZE - 20)\n#define SPACE_FOR_ARGNR (IOSIZE - 10)  // at least room for \" - VIM\"\n\t    if (curbuf->b_fname == NULL)\n\t\tvim_strncpy(buf, (char_u *)_(\"[No Name]\"), SPACE_FOR_FNAME);\n#ifdef FEAT_TERMINAL\n\t    else if (curbuf->b_term != NULL)\n\t    {\n\t\tvim_strncpy(buf, term_get_status_text(curbuf->b_term),\n\t\t\t\t\t\t\t      SPACE_FOR_FNAME);\n\t    }\n#endif\n\t    else\n\t    {\n\t\tp = transstr(gettail(curbuf->b_fname));\n\t\tvim_strncpy(buf, p, SPACE_FOR_FNAME);\n\t\tvim_free(p);\n\t    }\n\n#ifdef FEAT_TERMINAL\n\t    if (curbuf->b_term == NULL)\n#endif\n\t\tswitch (bufIsChanged(curbuf)\n\t\t\t+ (curbuf->b_p_ro * 2)\n\t\t\t+ (!curbuf->b_p_ma * 4))\n\t\t{\n\t\t    case 1: STRCAT(buf, \" +\"); break;\n\t\t    case 2: STRCAT(buf, \" =\"); break;\n\t\t    case 3: STRCAT(buf, \" =+\"); break;\n\t\t    case 4:\n\t\t    case 6: STRCAT(buf, \" -\"); break;\n\t\t    case 5:\n\t\t    case 7: STRCAT(buf, \" -+\"); break;\n\t\t}\n\n\t    if (curbuf->b_fname != NULL\n#ifdef FEAT_TERMINAL\n\t\t    && curbuf->b_term == NULL\n#endif\n\t\t    )\n\t    {\n\t\t// Get path of file, replace home dir with ~\n\t\toff = (int)STRLEN(buf);\n\t\tbuf[off++] = ' ';\n\t\tbuf[off++] = '(';\n\t\thome_replace(curbuf, curbuf->b_ffname,\n\t\t\t\t\tbuf + off, SPACE_FOR_DIR - off, TRUE);\n#ifdef BACKSLASH_IN_FILENAME\n\t\t// avoid \"c:/name\" to be reduced to \"c\"\n\t\tif (isalpha(buf[off]) && buf[off + 1] == ':')\n\t\t    off += 2;\n#endif\n\t\t// remove the file name\n\t\tp = gettail_sep(buf + off);\n\t\tif (p == buf + off)\n\t\t{\n\t\t    // must be a help buffer\n\t\t    vim_strncpy(buf + off, (char_u *)_(\"help\"),\n\t\t\t\t\t   (size_t)(SPACE_FOR_DIR - off - 1));\n\t\t}\n\t\telse\n\t\t    *p = NUL;\n\n\t\t// Translate unprintable chars and concatenate.  Keep some\n\t\t// room for the server name.  When there is no room (very long\n\t\t// file name) use (...).\n\t\tif (off < SPACE_FOR_DIR)\n\t\t{\n\t\t    p = transstr(buf + off);\n\t\t    vim_strncpy(buf + off, p, (size_t)(SPACE_FOR_DIR - off));\n\t\t    vim_free(p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    vim_strncpy(buf + off, (char_u *)\"...\",\n\t\t\t\t\t     (size_t)(SPACE_FOR_ARGNR - off));\n\t\t}\n\t\tSTRCAT(buf, \")\");\n\t    }\n\n\t    append_arg_number(curwin, buf, SPACE_FOR_ARGNR, FALSE);\n\n#if defined(FEAT_CLIENTSERVER)\n\t    if (serverName != NULL)\n\t    {\n\t\tSTRCAT(buf, \" - \");\n\t\tvim_strcat(buf, serverName, IOSIZE);\n\t    }\n\t    else\n#endif\n\t\tSTRCAT(buf, \" - VIM\");\n\n\t    if (maxlen > 0)\n\t    {\n\t\t// make it shorter by removing a bit in the middle\n\t\tif (vim_strsize(buf) > maxlen)\n\t\t    trunc_string(buf, buf, maxlen, IOSIZE);\n\t    }\n\t}\n    }\n    mustset = value_changed(title_str, &lasttitle);\n\n    if (p_icon)\n    {\n\ticon_str = buf;\n\tif (*p_iconstring != NUL)\n\t{\n#ifdef FEAT_STL_OPT\n\t    if (stl_syntax & STL_IN_ICON)\n\t\tbuild_stl_str_hl(curwin, icon_str, sizeof(buf), p_iconstring,\n\t\t\t\t (char_u *)\"iconstring\", 0, 0, 0, NULL, NULL);\n\t    else\n#endif\n\t\ticon_str = p_iconstring;\n\t}\n\telse\n\t{\n\t    if (buf_spname(curbuf) != NULL)\n\t\tp = buf_spname(curbuf);\n\t    else\t\t    // use file name only in icon\n\t\tp = gettail(curbuf->b_ffname);\n\t    *icon_str = NUL;\n\t    // Truncate name at 100 bytes.\n\t    len = (int)STRLEN(p);\n\t    if (len > 100)\n\t    {\n\t\tlen -= 100;\n\t\tif (has_mbyte)\n\t\t    len += (*mb_tail_off)(p, p + len) + 1;\n\t\tp += len;\n\t    }\n\t    STRCPY(icon_str, p);\n\t    trans_characters(icon_str, IOSIZE);\n\t}\n    }\n\n    mustset |= value_changed(icon_str, &lasticon);\n\n    if (mustset)\n\tresettitle();\n}\n\n/*\n * Used for title and icon: Check if \"str\" differs from \"*last\".  Set \"*last\"\n * from \"str\" if it does.\n * Return TRUE if resettitle() is to be called.\n */\n    static int\nvalue_changed(char_u *str, char_u **last)\n{\n    if ((str == NULL) != (*last == NULL)\n\t    || (str != NULL && *last != NULL && STRCMP(str, *last) != 0))\n    {\n\tvim_free(*last);\n\tif (str == NULL)\n\t{\n\t    *last = NULL;\n\t    mch_restore_title(\n\t\t  last == &lasttitle ? SAVE_RESTORE_TITLE : SAVE_RESTORE_ICON);\n\t}\n\telse\n\t{\n\t    *last = vim_strsave(str);\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * Put current window title back (used after calling a shell)\n */\n    void\nresettitle(void)\n{\n    mch_settitle(lasttitle, lasticon);\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_titles(void)\n{\n    vim_free(lasttitle);\n    vim_free(lasticon);\n}\n# endif\n\n\n#if defined(FEAT_STL_OPT) || defined(FEAT_GUI_TABLINE) || defined(PROTO)\n\n/*\n * Used for building in the status line.\n */\ntypedef struct\n{\n    char_u\t*stl_start;\n    int\t\tstl_minwid;\n    int\t\tstl_maxwid;\n    enum {\n\tNormal,\n\tEmpty,\n\tGroup,\n\tMiddle,\n\tHighlight,\n\tTabPage,\n\tTrunc\n    }\t\tstl_type;\n} stl_item_T;\n\nstatic size_t\t\tstl_items_len = 20; // Initial value, grows as needed.\nstatic stl_item_T      *stl_items = NULL;\nstatic int\t       *stl_groupitem = NULL;\nstatic stl_hlrec_T     *stl_hltab = NULL;\nstatic stl_hlrec_T     *stl_tabtab = NULL;\n\n/*\n * Build a string from the status line items in \"fmt\".\n * Return length of string in screen cells.\n *\n * Normally works for window \"wp\", except when working for 'tabline' then it\n * is \"curwin\".\n *\n * Items are drawn interspersed with the text that surrounds it\n * Specials: %-<wid>(xxx%) => group, %= => middle marker, %< => truncation\n * Item: %-<minwid>.<maxwid><itemch> All but <itemch> are optional\n *\n * If maxwidth is not zero, the string will be filled at any middle marker\n * or truncated if too long, fillchar is used for all whitespace.\n */\n    int\nbuild_stl_str_hl(\n    win_T\t*wp,\n    char_u\t*out,\t\t// buffer to write into != NameBuff\n    size_t\toutlen,\t\t// length of out[]\n    char_u\t*fmt,\n    char_u\t*opt_name,      // option name corresponding to \"fmt\"\n    int\t\topt_scope,\t// scope for \"opt_name\"\n    int\t\tfillchar,\n    int\t\tmaxwidth,\n    stl_hlrec_T **hltab,\t// return: HL attributes (can be NULL)\n    stl_hlrec_T **tabtab)\t// return: tab page nrs (can be NULL)\n{\n    linenr_T\tlnum;\n    size_t\tlen;\n    char_u\t*p;\n    char_u\t*s;\n    char_u\t*t;\n    int\t\tbyteval;\n#ifdef FEAT_EVAL\n    int\t\tuse_sandbox;\n    win_T\t*save_curwin;\n    buf_T\t*save_curbuf;\n    int\t\tsave_VIsual_active;\n#endif\n    int\t\tempty_line;\n    colnr_T\tvirtcol;\n    long\tl;\n    long\tn;\n    int\t\tprevchar_isflag;\n    int\t\tprevchar_isitem;\n    int\t\titemisflag;\n    int\t\tfillable;\n    char_u\t*str;\n    long\tnum;\n    int\t\twidth;\n    int\t\titemcnt;\n    int\t\tcuritem;\n    int\t\tgroup_end_userhl;\n    int\t\tgroup_start_userhl;\n    int\t\tgroupdepth;\n#ifdef FEAT_EVAL\n    int\t\tevaldepth;\n#endif\n    int\t\tminwid;\n    int\t\tmaxwid;\n    int\t\tzeropad;\n    char_u\tbase;\n    char_u\topt;\n#define TMPLEN 70\n    char_u\tbuf_tmp[TMPLEN];\n    char_u\twin_tmp[TMPLEN];\n    char_u\t*usefmt = fmt;\n    stl_hlrec_T *sp;\n    int\t\tsave_redraw_not_allowed = redraw_not_allowed;\n    int\t\tsave_KeyTyped = KeyTyped;\n    // TODO: find out why using called_emsg_before makes tests fail, does it\n    // matter?\n    // int\tcalled_emsg_before = called_emsg;\n    int\t\tdid_emsg_before = did_emsg;\n\n    // When inside update_screen() we do not want redrawing a statusline,\n    // ruler, title, etc. to trigger another redraw, it may cause an endless\n    // loop.\n    if (updating_screen)\n\tredraw_not_allowed = TRUE;\n\n    if (stl_items == NULL)\n    {\n\tstl_items = ALLOC_MULT(stl_item_T, stl_items_len);\n\tstl_groupitem = ALLOC_MULT(int, stl_items_len);\n\n\t// Allocate one more, because the last element is used to indicate the\n\t// end of the list.\n\tstl_hltab  = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n\tstl_tabtab = ALLOC_MULT(stl_hlrec_T, stl_items_len + 1);\n    }\n\n#ifdef FEAT_EVAL\n    // if \"fmt\" was set insecurely it needs to be evaluated in the sandbox\n    use_sandbox = was_set_insecurely(opt_name, opt_scope);\n\n    // When the format starts with \"%!\" then evaluate it as an expression and\n    // use the result as the actual format string.\n    if (fmt[0] == '%' && fmt[1] == '!')\n    {\n\ttypval_T\ttv;\n\n\ttv.v_type = VAR_NUMBER;\n\ttv.vval.v_number = wp->w_id;\n\tset_var((char_u *)\"g:statusline_winid\", &tv, FALSE);\n\n\tusefmt = eval_to_string_safe(fmt + 2, use_sandbox, FALSE, FALSE);\n\tif (usefmt == NULL)\n\t    usefmt = fmt;\n\n\tdo_unlet((char_u *)\"g:statusline_winid\", TRUE);\n    }\n#endif\n\n    if (fillchar == 0)\n\tfillchar = ' ';\n\n    // The cursor in windows other than the current one isn't always\n    // up-to-date, esp. because of autocommands and timers.\n    lnum = wp->w_cursor.lnum;\n    if (lnum > wp->w_buffer->b_ml.ml_line_count)\n    {\n\tlnum = wp->w_buffer->b_ml.ml_line_count;\n\twp->w_cursor.lnum = lnum;\n    }\n\n    // Get line & check if empty (cursorpos will show \"0-1\").  Note that\n    // p will become invalid when getting another buffer line.\n    p = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    empty_line = (*p == NUL);\n\n    // Get the byte value now, in case we need it below. This is more efficient\n    // than making a copy of the line.\n    len = STRLEN(p);\n    if (wp->w_cursor.col > (colnr_T)len)\n    {\n\t// Line may have changed since checking the cursor column, or the lnum\n\t// was adjusted above.\n\twp->w_cursor.col = (colnr_T)len;\n\twp->w_cursor.coladd = 0;\n\tbyteval = 0;\n    }\n    else\n\tbyteval = (*mb_ptr2char)(p + wp->w_cursor.col);\n\n    groupdepth = 0;\n#ifdef FEAT_EVAL\n    evaldepth = 0;\n#endif\n    p = out;\n    curitem = 0;\n    prevchar_isflag = TRUE;\n    prevchar_isitem = FALSE;\n    for (s = usefmt; *s != NUL; )\n    {\n\tif (curitem == (int)stl_items_len)\n\t{\n\t    size_t\tnew_len = stl_items_len * 3 / 2;\n\t    stl_item_T\t*new_items;\n\t    int\t\t*new_groupitem;\n\t    stl_hlrec_T\t*new_hlrec;\n\n\t    new_items = vim_realloc(stl_items, sizeof(stl_item_T) * new_len);\n\t    if (new_items == NULL)\n\t\tbreak;\n\t    stl_items = new_items;\n\t    new_groupitem = vim_realloc(stl_groupitem, sizeof(int) * new_len);\n\t    if (new_groupitem == NULL)\n\t\tbreak;\n\t    stl_groupitem = new_groupitem;\n\t    new_hlrec = vim_realloc(stl_hltab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_hltab = new_hlrec;\n\t    new_hlrec = vim_realloc(stl_tabtab,\n\t\t\t\t\t  sizeof(stl_hlrec_T) * (new_len + 1));\n\t    if (new_hlrec == NULL)\n\t\tbreak;\n\t    stl_tabtab = new_hlrec;\n\t    stl_items_len = new_len;\n\t}\n\n\tif (*s != '%')\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\n\t/*\n\t * Handle up to the next '%' or the end.\n\t */\n\twhile (*s != NUL && *s != '%' && p + 1 < out + outlen)\n\t    *p++ = *s++;\n\tif (*s == NUL || p + 1 >= out + outlen)\n\t    break;\n\n\t/*\n\t * Handle one '%' item.\n\t */\n\ts++;\n\tif (*s == NUL)  // ignore trailing %\n\t    break;\n\tif (*s == '%')\n\t{\n\t    if (p + 1 >= out + outlen)\n\t\tbreak;\n\t    *p++ = *s++;\n\t    prevchar_isflag = prevchar_isitem = FALSE;\n\t    continue;\n\t}\n\tif (*s == STL_MIDDLEMARK)\n\t{\n\t    s++;\n\t    if (groupdepth > 0)\n\t\tcontinue;\n\t    stl_items[curitem].stl_type = Middle;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == STL_TRUNCMARK)\n\t{\n\t    s++;\n\t    stl_items[curitem].stl_type = Trunc;\n\t    stl_items[curitem++].stl_start = p;\n\t    continue;\n\t}\n\tif (*s == ')')\n\t{\n\t    s++;\n\t    if (groupdepth < 1)\n\t\tcontinue;\n\t    groupdepth--;\n\n\t    t = stl_items[stl_groupitem[groupdepth]].stl_start;\n\t    *p = NUL;\n\t    l = vim_strsize(t);\n\t    if (curitem > stl_groupitem[groupdepth] + 1\n\t\t    && stl_items[stl_groupitem[groupdepth]].stl_minwid == 0)\n\t    {\n\t\t// remove group if all items are empty and highlight group\n\t\t// doesn't change\n\t\tgroup_start_userhl = group_end_userhl = 0;\n\t\tfor (n = stl_groupitem[groupdepth] - 1; n >= 0; n--)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t    {\n\t\t\tgroup_start_userhl = group_end_userhl =\n\t\t\t\t\t\t       stl_items[n].stl_minwid;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tfor (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t{\n\t\t    if (stl_items[n].stl_type == Normal)\n\t\t\tbreak;\n\t\t    if (stl_items[n].stl_type == Highlight)\n\t\t\tgroup_end_userhl = stl_items[n].stl_minwid;\n\t\t}\n\t\tif (n == curitem && group_start_userhl == group_end_userhl)\n\t\t{\n\t\t    // empty group\n\t\t    p = t;\n\t\t    l = 0;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t    {\n\t\t\t// do not use the highlighting from the removed group\n\t\t\tif (stl_items[n].stl_type == Highlight)\n\t\t\t    stl_items[n].stl_type = Empty;\n\t\t\t// adjust the start position of TabPage to the next\n\t\t\t// item position\n\t\t\tif (stl_items[n].stl_type == TabPage)\n\t\t\t    stl_items[n].stl_start = p;\n\t\t    }\n\t\t}\n\t    }\n\t    if (l > stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t    {\n\t\t// truncate, remove n bytes of text at the start\n\t\tif (has_mbyte)\n\t\t{\n\t\t    // Find the first character that should be included.\n\t\t    n = 0;\n\t\t    while (l >= stl_items[stl_groupitem[groupdepth]].stl_maxwid)\n\t\t    {\n\t\t\tl -= ptr2cells(t + n);\n\t\t\tn += (*mb_ptr2len)(t + n);\n\t\t    }\n\t\t}\n\t\telse\n\t\t    n = (long)(p - t) - stl_items[stl_groupitem[groupdepth]]\n\t\t\t\t\t\t\t       .stl_maxwid + 1;\n\n\t\t*t = '<';\n\t\tmch_memmove(t + 1, t + n, (size_t)(p - (t + n)));\n\t\tp = p - n + 1;\n\n\t\t// Fill up space left over by half a double-wide char.\n\t\twhile (++l < stl_items[stl_groupitem[groupdepth]].stl_minwid)\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\n\t\t// correct the start of the items for the truncation\n\t\tfor (l = stl_groupitem[groupdepth] + 1; l < curitem; l++)\n\t\t{\n\t\t    // Minus one for the leading '<' added above.\n\t\t    stl_items[l].stl_start -= n - 1;\n\t\t    if (stl_items[l].stl_start < t)\n\t\t\tstl_items[l].stl_start = t;\n\t\t}\n\t    }\n\t    else if (abs(stl_items[stl_groupitem[groupdepth]].stl_minwid) > l)\n\t    {\n\t\t// fill\n\t\tn = stl_items[stl_groupitem[groupdepth]].stl_minwid;\n\t\tif (n < 0)\n\t\t{\n\t\t    // fill by appending characters\n\t\t    n = 0 - n;\n\t\t    while (l++ < n && p + 1 < out + outlen)\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // fill by inserting characters\n\t\t    l = (n - l) * MB_CHAR2LEN(fillchar);\n\t\t    mch_memmove(t + l, t, (size_t)(p - t));\n\t\t    if (p + l >= out + outlen)\n\t\t\tl = (long)((out + outlen) - p - 1);\n\t\t    p += l;\n\t\t    for (n = stl_groupitem[groupdepth] + 1; n < curitem; n++)\n\t\t\tstl_items[n].stl_start += l;\n\t\t    for ( ; l > 0; l--)\n\t\t\tMB_CHAR2BYTES(fillchar, t);\n\t\t}\n\t    }\n\t    continue;\n\t}\n\tminwid = 0;\n\tmaxwid = 9999;\n\tzeropad = FALSE;\n\tl = 1;\n\tif (*s == '0')\n\t{\n\t    s++;\n\t    zeropad = TRUE;\n\t}\n\tif (*s == '-')\n\t{\n\t    s++;\n\t    l = -1;\n\t}\n\tif (VIM_ISDIGIT(*s))\n\t{\n\t    minwid = (int)getdigits(&s);\n\t    if (minwid < 0)\t// overflow\n\t\tminwid = 0;\n\t}\n\tif (*s == STL_USER_HL)\n\t{\n\t    stl_items[curitem].stl_type = Highlight;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid > 9 ? 1 : minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == STL_TABPAGENR || *s == STL_TABCLOSENR)\n\t{\n\t    if (*s == STL_TABCLOSENR)\n\t    {\n\t\tif (minwid == 0)\n\t\t{\n\t\t    // %X ends the close label, go back to the previously\n\t\t    // define tab label nr.\n\t\t    for (n = curitem - 1; n >= 0; --n)\n\t\t\tif (stl_items[n].stl_type == TabPage\n\t\t\t\t\t       && stl_items[n].stl_minwid >= 0)\n\t\t\t{\n\t\t\t    minwid = stl_items[n].stl_minwid;\n\t\t\t    break;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t    // close nrs are stored as negative values\n\t\t    minwid = - minwid;\n\t    }\n\t    stl_items[curitem].stl_type = TabPage;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n\tif (*s == '.')\n\t{\n\t    s++;\n\t    if (VIM_ISDIGIT(*s))\n\t    {\n\t\tmaxwid = (int)getdigits(&s);\n\t\tif (maxwid <= 0)\t// overflow\n\t\t    maxwid = 50;\n\t    }\n\t}\n\tminwid = (minwid > 50 ? 50 : minwid) * l;\n\tif (*s == '(')\n\t{\n\t    stl_groupitem[groupdepth++] = curitem;\n\t    stl_items[curitem].stl_type = Group;\n\t    stl_items[curitem].stl_start = p;\n\t    stl_items[curitem].stl_minwid = minwid;\n\t    stl_items[curitem].stl_maxwid = maxwid;\n\t    s++;\n\t    curitem++;\n\t    continue;\n\t}\n#ifdef FEAT_EVAL\n\t// Denotes end of expanded %{} block\n\tif (*s == '}' && evaldepth > 0)\n\t{\n\t    s++;\n\t    evaldepth--;\n\t    continue;\n\t}\n#endif\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    if (*s == NUL)  // can happen with \"%0\"\n\t\tbreak;\n\t    s++;\n\t    continue;\n\t}\n\topt = *s++;\n\n\t// OK - now for the real work\n\tbase = 'D';\n\titemisflag = FALSE;\n\tfillable = TRUE;\n\tnum = -1;\n\tstr = NULL;\n\tswitch (opt)\n\t{\n\tcase STL_FILEPATH:\n\tcase STL_FULLPATH:\n\tcase STL_FILENAME:\n\t    fillable = FALSE;\t// don't change ' ' to fillchar\n\t    if (buf_spname(wp->w_buffer) != NULL)\n\t\tvim_strncpy(NameBuff, buf_spname(wp->w_buffer), MAXPATHL - 1);\n\t    else\n\t    {\n\t\tt = (opt == STL_FULLPATH) ? wp->w_buffer->b_ffname\n\t\t\t\t\t  : wp->w_buffer->b_fname;\n\t\thome_replace(wp->w_buffer, t, NameBuff, MAXPATHL, TRUE);\n\t    }\n\t    trans_characters(NameBuff, MAXPATHL);\n\t    if (opt != STL_FILENAME)\n\t\tstr = NameBuff;\n\t    else\n\t\tstr = gettail(NameBuff);\n\t    break;\n\n\tcase STL_VIM_EXPR: // '{'\n\t{\n#ifdef FEAT_EVAL\n\t    char_u *block_start = s - 1;\n#endif\n\t    int reevaluate = (*s == '%');\n\n\t    if (reevaluate)\n\t\ts++;\n\t    itemisflag = TRUE;\n\t    t = p;\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%'))\n\t\t\t\t\t  && *s != NUL && p + 1 < out + outlen)\n\t\t*p++ = *s++;\n\t    if (*s != '}')\t// missing '}' or out of space\n\t\tbreak;\n\t    s++;\n\t    if (reevaluate)\n\t\tp[-1] = 0; // remove the % at the end of %{% expr %}\n\t    else\n\t\t*p = 0;\n\t    p = t;\n#ifdef FEAT_EVAL\n\t    vim_snprintf((char *)buf_tmp, sizeof(buf_tmp),\n\t\t\t\t\t\t\t \"%d\", curbuf->b_fnum);\n\t    set_internal_string_var((char_u *)\"g:actual_curbuf\", buf_tmp);\n\t    vim_snprintf((char *)win_tmp, sizeof(win_tmp), \"%d\", curwin->w_id);\n\t    set_internal_string_var((char_u *)\"g:actual_curwin\", win_tmp);\n\n\t    save_curbuf = curbuf;\n\t    save_curwin = curwin;\n\t    save_VIsual_active = VIsual_active;\n\t    curwin = wp;\n\t    curbuf = wp->w_buffer;\n\t    // Visual mode is only valid in the current window.\n\t    if (curwin != save_curwin)\n\t\tVIsual_active = FALSE;\n\n\t    str = eval_to_string_safe(p, use_sandbox, FALSE, FALSE);\n\n\t    curwin = save_curwin;\n\t    curbuf = save_curbuf;\n\t    VIsual_active = save_VIsual_active;\n\t    do_unlet((char_u *)\"g:actual_curbuf\", TRUE);\n\t    do_unlet((char_u *)\"g:actual_curwin\", TRUE);\n\n\t    if (str != NULL && *str != 0)\n\t    {\n\t\tif (*skipdigits(str) == NUL)\n\t\t{\n\t\t    num = atoi((char *)str);\n\t\t    VIM_CLEAR(str);\n\t\t    itemisflag = FALSE;\n\t\t}\n\t    }\n\n\t    // If the output of the expression needs to be evaluated\n\t    // replace the %{} block with the result of evaluation\n\t    if (reevaluate && str != NULL && *str != 0\n\t\t    && strchr((const char *)str, '%') != NULL\n\t\t    && evaldepth < MAX_STL_EVAL_DEPTH)\n\t    {\n\t\tsize_t parsed_usefmt = (size_t)(block_start - usefmt);\n\t\tsize_t str_length = strlen((const char *)str);\n\t\tsize_t fmt_length = strlen((const char *)s);\n\t\tsize_t new_fmt_len = parsed_usefmt\n\t\t\t\t\t\t + str_length + fmt_length + 3;\n\t\tchar_u *new_fmt = (char_u *)alloc(new_fmt_len * sizeof(char_u));\n\t\tchar_u *new_fmt_p = new_fmt;\n\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, usefmt, parsed_usefmt)\n\t\t\t\t\t\t\t       + parsed_usefmt;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , str, str_length)\n\t\t\t\t\t\t\t\t  + str_length;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p, \"%}\", 2) + 2;\n\t\tnew_fmt_p = (char_u *)memcpy(new_fmt_p , s, fmt_length)\n\t\t\t\t\t\t\t\t  + fmt_length;\n\t\t*new_fmt_p = 0;\n\t\tnew_fmt_p = NULL;\n\n\t\tif (usefmt != fmt)\n\t\t    vim_free(usefmt);\n\t\tVIM_CLEAR(str);\n\t\tusefmt = new_fmt;\n\t\ts = usefmt + parsed_usefmt;\n\t\tevaldepth++;\n\t\tcontinue;\n\t    }\n#endif\n\t    break;\n\t}\n\tcase STL_LINE:\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY)\n\t\t  ? 0L : (long)(wp->w_cursor.lnum);\n\t    break;\n\n\tcase STL_NUMLINES:\n\t    num = wp->w_buffer->b_ml.ml_line_count;\n\t    break;\n\n\tcase STL_COLUMN:\n\t    num = (State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t\t       ? 0 : (int)wp->w_cursor.col + 1;\n\t    break;\n\n\tcase STL_VIRTCOL:\n\tcase STL_VIRTCOL_ALT:\n\t    virtcol = wp->w_virtcol + 1;\n\t    // Don't display %V if it's the same as %c.\n\t    if (opt == STL_VIRTCOL_ALT\n\t\t    && (virtcol == (colnr_T)((State & MODE_INSERT) == 0\n\t\t\t       && empty_line ? 0 : (int)wp->w_cursor.col + 1)))\n\t\tbreak;\n\t    num = (long)virtcol;\n\t    break;\n\n\tcase STL_PERCENTAGE:\n\t    num = (int)(((long)wp->w_cursor.lnum * 100L) /\n\t\t\t(long)wp->w_buffer->b_ml.ml_line_count);\n\t    break;\n\n\tcase STL_ALTPERCENT:\n\t    str = buf_tmp;\n\t    get_rel_pos(wp, str, TMPLEN);\n\t    break;\n\n\tcase STL_SHOWCMD:\n\t    if (p_sc && STRCMP(opt_name, p_sloc) == 0)\n\t\tstr = showcmd_buf;\n\t    break;\n\n\tcase STL_ARGLISTSTAT:\n\t    fillable = FALSE;\n\t    buf_tmp[0] = 0;\n\t    if (append_arg_number(wp, buf_tmp, (int)sizeof(buf_tmp), FALSE))\n\t\tstr = buf_tmp;\n\t    break;\n\n\tcase STL_KEYMAP:\n\t    fillable = FALSE;\n\t    if (get_keymap_str(wp, (char_u *)\"<%s>\", buf_tmp, TMPLEN))\n\t\tstr = buf_tmp;\n\t    break;\n\tcase STL_PAGENUM:\n#if defined(FEAT_PRINTER) || defined(FEAT_GUI_TABLINE)\n\t    num = printer_page_num;\n#else\n\t    num = 0;\n#endif\n\t    break;\n\n\tcase STL_BUFNO:\n\t    num = wp->w_buffer->b_fnum;\n\t    break;\n\n\tcase STL_OFFSET_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_OFFSET:\n#ifdef FEAT_BYTEOFF\n\t    l = ml_find_line_or_offset(wp->w_buffer, wp->w_cursor.lnum, NULL);\n\t    num = (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) || l < 0\n\t\t       ? 0L : l + 1 + ((State & MODE_INSERT) == 0 && empty_line\n\t\t\t\t? 0 : (int)wp->w_cursor.col);\n#endif\n\t    break;\n\n\tcase STL_BYTEVAL_X:\n\t    base = 'X';\n\t    // FALLTHROUGH\n\tcase STL_BYTEVAL:\n\t    num = byteval;\n\t    if (num == NL)\n\t\tnum = 0;\n\t    else if (num == CAR && get_fileformat(wp->w_buffer) == EOL_MAC)\n\t\tnum = NL;\n\t    break;\n\n\tcase STL_ROFLAG:\n\tcase STL_ROFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_p_ro)\n\t\tstr = (char_u *)((opt == STL_ROFLAG_ALT) ? \",RO\" : _(\"[RO]\"));\n\t    break;\n\n\tcase STL_HELPFLAG:\n\tcase STL_HELPFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_buffer->b_help)\n\t\tstr = (char_u *)((opt == STL_HELPFLAG_ALT) ? \",HLP\"\n\t\t\t\t\t\t\t       : _(\"[Help]\"));\n\t    break;\n\n\tcase STL_FILETYPE:\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 3)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \"[%s]\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n\tcase STL_FILETYPE_ALT:\n\t    itemisflag = TRUE;\n\t    if (*wp->w_buffer->b_p_ft != NUL\n\t\t    && STRLEN(wp->w_buffer->b_p_ft) < TMPLEN - 2)\n\t    {\n\t\tvim_snprintf((char *)buf_tmp, sizeof(buf_tmp), \",%s\",\n\t\t\t\t\t\t\twp->w_buffer->b_p_ft);\n\t\tfor (t = buf_tmp; *t != 0; t++)\n\t\t    *t = TOUPPER_LOC(*t);\n\t\tstr = buf_tmp;\n\t    }\n\t    break;\n\n#if defined(FEAT_QUICKFIX)\n\tcase STL_PREVIEWFLAG:\n\tcase STL_PREVIEWFLAG_ALT:\n\t    itemisflag = TRUE;\n\t    if (wp->w_p_pvw)\n\t\tstr = (char_u *)((opt == STL_PREVIEWFLAG_ALT) ? \",PRV\"\n\t\t\t\t\t\t\t    : _(\"[Preview]\"));\n\t    break;\n\n\tcase STL_QUICKFIX:\n\t    if (bt_quickfix(wp->w_buffer))\n\t\tstr = (char_u *)(wp->w_llist_ref\n\t\t\t    ? _(msg_loclist)\n\t\t\t    : _(msg_qflist));\n\t    break;\n#endif\n\n\tcase STL_MODIFIED:\n\tcase STL_MODIFIED_ALT:\n\t    itemisflag = TRUE;\n\t    switch ((opt == STL_MODIFIED_ALT)\n\t\t    + bufIsChanged(wp->w_buffer) * 2\n\t\t    + (!wp->w_buffer->b_p_ma) * 4)\n\t    {\n\t\tcase 2: str = (char_u *)\"[+]\"; break;\n\t\tcase 3: str = (char_u *)\",+\"; break;\n\t\tcase 4: str = (char_u *)\"[-]\"; break;\n\t\tcase 5: str = (char_u *)\",-\"; break;\n\t\tcase 6: str = (char_u *)\"[+-]\"; break;\n\t\tcase 7: str = (char_u *)\",+-\"; break;\n\t    }\n\t    break;\n\n\tcase STL_HIGHLIGHT:\n\t    t = s;\n\t    while (*s != '#' && *s != NUL)\n\t\t++s;\n\t    if (*s == '#')\n\t    {\n\t\tstl_items[curitem].stl_type = Highlight;\n\t\tstl_items[curitem].stl_start = p;\n\t\tstl_items[curitem].stl_minwid = -syn_namen2id(t, (int)(s - t));\n\t\tcuritem++;\n\t    }\n\t    if (*s != NUL)\n\t\t++s;\n\t    continue;\n\t}\n\n\tstl_items[curitem].stl_start = p;\n\tstl_items[curitem].stl_type = Normal;\n\tif (str != NULL && *str)\n\t{\n\t    t = str;\n\t    if (itemisflag)\n\t    {\n\t\tif ((t[0] && t[1])\n\t\t\t&& ((!prevchar_isitem && *t == ',')\n\t\t\t      || (prevchar_isflag && *t == ' ')))\n\t\t    t++;\n\t\tprevchar_isflag = TRUE;\n\t    }\n\t    l = vim_strsize(t);\n\t    if (l > 0)\n\t\tprevchar_isitem = TRUE;\n\t    if (l > maxwid)\n\t    {\n\t\twhile (l >= maxwid)\n\t\t    if (has_mbyte)\n\t\t    {\n\t\t\tl -= ptr2cells(t);\n\t\t\tt += (*mb_ptr2len)(t);\n\t\t    }\n\t\t    else\n\t\t\tl -= byte2cells(*t++);\n\t\tif (p + 1 >= out + outlen)\n\t\t    break;\n\t\t*p++ = '<';\n\t    }\n\t    if (minwid > 0)\n\t    {\n\t\tfor (; l < minwid && p + 1 < out + outlen; l++)\n\t\t{\n\t\t    // Don't put a \"-\" in front of a digit.\n\t\t    if (l + 1 == minwid && fillchar == '-' && VIM_ISDIGIT(*t))\n\t\t\t*p++ = ' ';\n\t\t    else\n\t\t\tMB_CHAR2BYTES(fillchar, p);\n\t\t}\n\t\tminwid = 0;\n\t    }\n\t    else\n\t\tminwid *= -1;\n\t    for (; *t && p + 1 < out + outlen; t++)\n\t    {\n\t\t// Change a space by fillchar, unless fillchar is '-' and a\n\t\t// digit follows.\n\t\tif (fillable && *t == ' '\n\t\t\t\t&& (!VIM_ISDIGIT(*(t + 1)) || fillchar != '-'))\n\t\t    MB_CHAR2BYTES(fillchar, p);\n\t\telse\n\t\t    *p++ = *t;\n\t    }\n\t    for (; l < minwid && p + 1 < out + outlen; l++)\n\t\tMB_CHAR2BYTES(fillchar, p);\n\t}\n\telse if (num >= 0)\n\t{\n\t    int nbase = (base == 'D' ? 10 : (base == 'O' ? 8 : 16));\n\t    char_u nstr[20];\n\n\t    if (p + 20 >= out + outlen)\n\t\tbreak;\t\t// not sufficient space\n\t    prevchar_isitem = TRUE;\n\t    t = nstr;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t    {\n\t\t*t++ = '-';\n\t\tminwid--;\n\t    }\n\t    *t++ = '%';\n\t    if (zeropad)\n\t\t*t++ = '0';\n\t    *t++ = '*';\n\t    *t++ = nbase == 16 ? base : (char_u)(nbase == 8 ? 'o' : 'd');\n\t    *t = 0;\n\n\t    for (n = num, l = 1; n >= nbase; n /= nbase)\n\t\tl++;\n\t    if (opt == STL_VIRTCOL_ALT)\n\t\tl++;\n\t    if (l > maxwid)\n\t    {\n\t\tl += 2;\n\t\tn = l - maxwid;\n\t\twhile (l-- > maxwid)\n\t\t    num /= nbase;\n\t\t*t++ = '>';\n\t\t*t++ = '%';\n\t\t*t = t[-3];\n\t\t*++t = 0;\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t   0, num, n);\n\t    }\n\t    else\n\t\tvim_snprintf((char *)p, outlen - (p - out), (char *)nstr,\n\t\t\t\t\t\t\t\t minwid, num);\n\t    p += STRLEN(p);\n\t}\n\telse\n\t    stl_items[curitem].stl_type = Empty;\n\n\tif (num >= 0 || (!itemisflag && str != NULL && *str != NUL))\n\t    prevchar_isflag = FALSE;\t    // Item not NULL, but not a flag\n\t\t\t\t\t    //\n\tif (opt == STL_VIM_EXPR)\n\t    vim_free(str);\n\tcuritem++;\n    }\n    *p = NUL;\n    itemcnt = curitem;\n\n#ifdef FEAT_EVAL\n    if (usefmt != fmt)\n\tvim_free(usefmt);\n#endif\n\n    width = vim_strsize(out);\n    if (maxwidth > 0 && width > maxwidth)\n    {\n\t// Result is too long, must truncate somewhere.\n\tl = 0;\n\tif (itemcnt == 0)\n\t    s = out;\n\telse\n\t{\n\t    for ( ; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_type == Trunc)\n\t\t{\n\t\t    // Truncate at %< item.\n\t\t    s = stl_items[l].stl_start;\n\t\t    break;\n\t\t}\n\t    if (l == itemcnt)\n\t    {\n\t\t// No %< item, truncate first item.\n\t\ts = stl_items[0].stl_start;\n\t\tl = 0;\n\t    }\n\t}\n\n\tif (width - vim_strsize(s) >= maxwidth)\n\t{\n\t    // Truncation mark is beyond max length\n\t    if (has_mbyte)\n\t    {\n\t\ts = out;\n\t\twidth = 0;\n\t\tfor (;;)\n\t\t{\n\t\t    width += ptr2cells(s);\n\t\t    if (width >= maxwidth)\n\t\t\tbreak;\n\t\t    s += (*mb_ptr2len)(s);\n\t\t}\n\t\t// Fill up for half a double-wide character.\n\t\twhile (++width < maxwidth)\n\t\t    MB_CHAR2BYTES(fillchar, s);\n\t    }\n\t    else\n\t\ts = out + maxwidth - 1;\n\t    for (l = 0; l < itemcnt; l++)\n\t\tif (stl_items[l].stl_start > s)\n\t\t    break;\n\t    itemcnt = l;\n\t    *s++ = '>';\n\t    *s = 0;\n\t}\n\telse\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tn = 0;\n\t\twhile (width >= maxwidth)\n\t\t{\n\t\t    width -= ptr2cells(s + n);\n\t\t    n += (*mb_ptr2len)(s + n);\n\t\t}\n\t    }\n\t    else\n\t\tn = width - maxwidth + 1;\n\t    p = s + n;\n\t    STRMOVE(s + 1, p);\n\t    *s = '<';\n\n\t    // Fill up for half a double-wide character.\n\t    while (++width < maxwidth)\n\t    {\n\t\ts = s + STRLEN(s);\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t\t*s = NUL;\n\t    }\n\n\t    --n;\t// count the '<'\n\t    for (; l < itemcnt; l++)\n\t    {\n\t\tif (stl_items[l].stl_start - n >= s)\n\t\t    stl_items[l].stl_start -= n;\n\t\telse\n\t\t    stl_items[l].stl_start = s;\n\t    }\n\t}\n\twidth = maxwidth;\n    }\n    else if (width < maxwidth && STRLEN(out) + maxwidth - width + 1 < outlen)\n    {\n\t// Apply STL_MIDDLE if any\n\tfor (l = 0; l < itemcnt; l++)\n\t    if (stl_items[l].stl_type == Middle)\n\t\tbreak;\n\tif (l < itemcnt)\n\t{\n\t    int middlelength = (maxwidth - width) * MB_CHAR2LEN(fillchar);\n\t    p = stl_items[l].stl_start + middlelength;\n\t    STRMOVE(p, stl_items[l].stl_start);\n\t    for (s = stl_items[l].stl_start; s < p;)\n\t\tMB_CHAR2BYTES(fillchar, s);\n\t    for (l++; l < itemcnt; l++)\n\t\tstl_items[l].stl_start += middlelength;\n\t    width = maxwidth;\n\t}\n    }\n\n    // Store the info about highlighting.\n    if (hltab != NULL)\n    {\n\t*hltab = stl_hltab;\n\tsp = stl_hltab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == Highlight)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    // Store the info about tab pages labels.\n    if (tabtab != NULL)\n    {\n\t*tabtab = stl_tabtab;\n\tsp = stl_tabtab;\n\tfor (l = 0; l < itemcnt; l++)\n\t{\n\t    if (stl_items[l].stl_type == TabPage)\n\t    {\n\t\tsp->start = stl_items[l].stl_start;\n\t\tsp->userhl = stl_items[l].stl_minwid;\n\t\tsp++;\n\t    }\n\t}\n\tsp->start = NULL;\n\tsp->userhl = 0;\n    }\n\n    redraw_not_allowed = save_redraw_not_allowed;\n\n    // A user function may reset KeyTyped, restore it.\n    KeyTyped = save_KeyTyped;\n\n    // Check for an error.  If there is one the display will be messed up and\n    // might loop redrawing.  Avoid that by making the corresponding option\n    // empty.\n    // TODO: find out why using called_emsg_before makes tests fail, does it\n    // matter?\n    // if (called_emsg > called_emsg_before)\n    if (did_emsg > did_emsg_before)\n\tset_string_option_direct(opt_name, -1, (char_u *)\"\",\n\t\t\t\t\t      OPT_FREE | opt_scope, SID_ERROR);\n\n    return width;\n}\n#endif // FEAT_STL_OPT\n\n/*\n * Get relative cursor position in window into \"buf[buflen]\", in the form 99%,\n * using \"Top\", \"Bot\" or \"All\" when appropriate.\n */\n    void\nget_rel_pos(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen)\n{\n    long\tabove; // number of lines above window\n    long\tbelow; // number of lines below window\n\n    if (buflen < 3) // need at least 3 chars for writing\n\treturn;\n    above = wp->w_topline - 1;\n#ifdef FEAT_DIFF\n    above += diff_check_fill(wp, wp->w_topline) - wp->w_topfill;\n    if (wp->w_topline == 1 && wp->w_topfill >= 1)\n\tabove = 0;  // All buffer lines are displayed and there is an\n\t\t    // indication of filler lines, that can be considered\n\t\t    // seeing all lines.\n#endif\n    below = wp->w_buffer->b_ml.ml_line_count - wp->w_botline + 1;\n    if (below <= 0)\n\tvim_strncpy(buf, (char_u *)(above == 0 ? _(\"All\") : _(\"Bot\")),\n\t\t\t\t\t\t\t(size_t)(buflen - 1));\n    else if (above <= 0)\n\tvim_strncpy(buf, (char_u *)_(\"Top\"), (size_t)(buflen - 1));\n    else\n\tvim_snprintf((char *)buf, (size_t)buflen, \"%2d%%\", above > 1000000L\n\t\t\t\t    ? (int)(above / ((above + below) / 100L))\n\t\t\t\t    : (int)(above * 100L / (above + below)));\n}\n\n/*\n * Append (file 2 of 8) to \"buf[buflen]\", if editing more than one file.\n * Return TRUE if it was appended.\n */\n    static int\nappend_arg_number(\n    win_T\t*wp,\n    char_u\t*buf,\n    int\t\tbuflen,\n    int\t\tadd_file)\t// Add \"file\" before the arg number\n{\n    char_u\t*p;\n\n    if (ARGCOUNT <= 1)\t\t// nothing to do\n\treturn FALSE;\n\n    p = buf + STRLEN(buf);\t// go to the end of the buffer\n    if (p - buf + 35 >= buflen)\t// getting too long\n\treturn FALSE;\n    *p++ = ' ';\n    *p++ = '(';\n    if (add_file)\n    {\n\tSTRCPY(p, \"file \");\n\tp += 5;\n    }\n    vim_snprintf((char *)p, (size_t)(buflen - (p - buf)),\n\t\twp->w_arg_idx_invalid ? \"(%d) of %d)\"\n\t\t\t\t  : \"%d of %d)\", wp->w_arg_idx + 1, ARGCOUNT);\n    return TRUE;\n}\n\n/*\n * If fname is not a full path, make it a full path.\n * Returns pointer to allocated memory (NULL for failure).\n */\n    char_u  *\nfix_fname(char_u  *fname)\n{\n    /*\n     * Force expanding the path always for Unix, because symbolic links may\n     * mess up the full path name, even though it starts with a '/'.\n     * Also expand when there is \"..\" in the file name, try to remove it,\n     * because \"c:/src/../README\" is equal to \"c:/README\".\n     * Similarly \"c:/src//file\" is equal to \"c:/src/file\".\n     * For MS-Windows also expand names like \"longna~1\" to \"longname\".\n     */\n#ifdef UNIX\n    return FullName_save(fname, TRUE);\n#else\n    if (!vim_isAbsName(fname)\n\t    || strstr((char *)fname, \"..\") != NULL\n\t    || strstr((char *)fname, \"//\") != NULL\n# ifdef BACKSLASH_IN_FILENAME\n\t    || strstr((char *)fname, \"\\\\\\\\\") != NULL\n# endif\n# if defined(MSWIN)\n\t    || vim_strchr(fname, '~') != NULL\n# endif\n\t    )\n\treturn FullName_save(fname, FALSE);\n\n    fname = vim_strsave(fname);\n\n# ifdef USE_FNAME_CASE\n    if (fname != NULL)\n\tfname_case(fname, 0);\t// set correct case for file name\n# endif\n\n    return fname;\n#endif\n}\n\n/*\n * Make \"*ffname\" a full file name, set \"*sfname\" to \"*ffname\" if not NULL.\n * \"*ffname\" becomes a pointer to allocated memory (or NULL).\n * When resolving a link both \"*sfname\" and \"*ffname\" will point to the same\n * allocated memory.\n * The \"*ffname\" and \"*sfname\" pointer values on call will not be freed.\n * Note that the resulting \"*ffname\" pointer should be considered not allocated.\n */\n    void\nfname_expand(\n    buf_T\t*buf UNUSED,\n    char_u\t**ffname,\n    char_u\t**sfname)\n{\n    if (*ffname == NULL)\t    // no file name given, nothing to do\n\treturn;\n    if (*sfname == NULL)\t    // no short file name given, use ffname\n\t*sfname = *ffname;\n    *ffname = fix_fname(*ffname);   // expand to full path\n\n#ifdef FEAT_SHORTCUT\n    if (!buf->b_p_bin)\n    {\n\tchar_u  *rfname;\n\n\t// If the file name is a shortcut file, use the file it links to.\n\trfname = mch_resolve_path(*ffname, FALSE);\n\tif (rfname != NULL)\n\t{\n\t    vim_free(*ffname);\n\t    *ffname = rfname;\n\t    *sfname = rfname;\n\t}\n    }\n#endif\n}\n\n/*\n * Open a window for a number of buffers.\n */\n    void\nex_buffer_all(exarg_T *eap)\n{\n    buf_T\t*buf;\n    win_T\t*wp, *wpnext;\n    int\t\tsplit_ret = OK;\n    int\t\tp_ea_save;\n    int\t\topen_wins = 0;\n    int\t\tr;\n    int\t\tcount;\t\t// Maximum number of windows to open.\n    int\t\tall;\t\t// When TRUE also load inactive buffers.\n    int\t\thad_tab = cmdmod.cmod_tab;\n    tabpage_T\t*tpnext;\n\n    if (eap->addr_count == 0)\t// make as many windows as possible\n\tcount = 9999;\n    else\n\tcount = eap->line2;\t// make as many windows as specified\n    if (eap->cmdidx == CMD_unhide || eap->cmdidx == CMD_sunhide)\n\tall = FALSE;\n    else\n\tall = TRUE;\n\n    setpcmark();\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * Close superfluous windows (two windows for the same buffer).\n     * Also close windows that are not full-width.\n     */\n    if (had_tab > 0)\n\tgoto_tabpage_tp(first_tabpage, TRUE, TRUE);\n    for (;;)\n    {\n\ttpnext = curtab->tp_next;\n\tfor (wp = firstwin; wp != NULL; wp = wpnext)\n\t{\n\t    wpnext = wp->w_next;\n\t    if ((wp->w_buffer->b_nwindows > 1\n\t\t\t|| ((cmdmod.cmod_split & WSP_VERT)\n\t\t\t    ? wp->w_height + wp->w_status_height < Rows - p_ch\n\t\t\t\t\t\t\t     - tabline_height()\n\t\t\t    : wp->w_width != Columns)\n\t\t\t|| (had_tab > 0 && wp != firstwin))\n\t\t    && !ONE_WINDOW\n\t\t    && !(wp->w_closing || wp->w_buffer->b_locked > 0)\n\t\t    && !win_unlisted(wp))\n\t    {\n\t\tif (win_close(wp, FALSE) == FAIL)\n\t\t    break;\n\t\t// Just in case an autocommand does something strange with\n\t\t// windows: start all over...\n\t\twpnext = firstwin;\n\t\ttpnext = first_tabpage;\n\t\topen_wins = 0;\n\t    }\n\t    else\n\t\t++open_wins;\n\t}\n\n\t// Without the \":tab\" modifier only do the current tab page.\n\tif (had_tab == 0 || tpnext == NULL)\n\t    break;\n\tgoto_tabpage_tp(tpnext, TRUE, TRUE);\n    }\n\n    /*\n     * Go through the buffer list.  When a buffer doesn't have a window yet,\n     * open one.  Otherwise move the window to the right position.\n     * Watch out for autocommands that delete buffers or windows!\n     */\n    // Don't execute Win/Buf Enter/Leave autocommands here.\n    ++autocmd_no_enter;\n    win_enter(lastwin, FALSE);\n    ++autocmd_no_leave;\n    for (buf = firstbuf; buf != NULL && open_wins < count; buf = buf->b_next)\n    {\n\t// Check if this buffer needs a window\n\tif ((!all && buf->b_ml.ml_mfp == NULL) || !buf->b_p_bl)\n\t    continue;\n\n\tif (had_tab != 0)\n\t{\n\t    // With the \":tab\" modifier don't move the window.\n\t    if (buf->b_nwindows > 0)\n\t\twp = lastwin;\t    // buffer has a window, skip it\n\t    else\n\t\twp = NULL;\n\t}\n\telse\n\t{\n\t    // Check if this buffer already has a window\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t    break;\n\t    // If the buffer already has a window, move it\n\t    if (wp != NULL)\n\t\twin_move_after(wp, curwin);\n\t}\n\n\tif (wp == NULL && split_ret == OK)\n\t{\n\t    bufref_T\tbufref;\n\n\t    set_bufref(&bufref, buf);\n\n\t    // Split the window and put the buffer in it\n\t    p_ea_save = p_ea;\n\t    p_ea = TRUE;\t\t// use space from all windows\n\t    split_ret = win_split(0, WSP_ROOM | WSP_BELOW);\n\t    ++open_wins;\n\t    p_ea = p_ea_save;\n\t    if (split_ret == FAIL)\n\t\tcontinue;\n\n\t    // Open the buffer in this window.\n\t    swap_exists_action = SEA_DIALOG;\n\t    set_curbuf(buf, DOBUF_GOTO);\n\t    if (!bufref_valid(&bufref))\n\t    {\n\t\t// autocommands deleted the buffer!!!\n\t\tswap_exists_action = SEA_NONE;\n\t\tbreak;\n\t    }\n\t    if (swap_exists_action == SEA_QUIT)\n\t    {\n#if defined(FEAT_EVAL)\n\t\tcleanup_T   cs;\n\n\t\t// Reset the error/interrupt/exception state here so that\n\t\t// aborting() returns FALSE when closing a window.\n\t\tenter_cleanup(&cs);\n#endif\n\n\t\t// User selected Quit at ATTENTION prompt; close this window.\n\t\twin_close(curwin, TRUE);\n\t\t--open_wins;\n\t\tswap_exists_action = SEA_NONE;\n\t\tswap_exists_did_quit = TRUE;\n\n#if defined(FEAT_EVAL)\n\t\t// Restore the error/interrupt/exception state if not\n\t\t// discarded by a new aborting error, interrupt, or uncaught\n\t\t// exception.\n\t\tleave_cleanup(&cs);\n#endif\n\t    }\n\t    else\n\t\thandle_swap_exists(NULL);\n\t}\n\n\tui_breakcheck();\n\tif (got_int)\n\t{\n\t    (void)vgetc();\t// only break the file loading, not the rest\n\t    break;\n\t}\n#ifdef FEAT_EVAL\n\t// Autocommands deleted the buffer or aborted script processing!!!\n\tif (aborting())\n\t    break;\n#endif\n\t// When \":tab\" was used open a new tab for a new window repeatedly.\n\tif (had_tab > 0 && tabpage_index(NULL) <= p_tpm)\n\t    cmdmod.cmod_tab = 9999;\n    }\n    --autocmd_no_enter;\n    win_enter(firstwin, FALSE);\t\t// back to first window\n    --autocmd_no_leave;\n\n    /*\n     * Close superfluous windows.\n     */\n    for (wp = lastwin; open_wins > count; )\n    {\n\tr = (buf_hide(wp->w_buffer) || !bufIsChanged(wp->w_buffer)\n\t\t\t\t     || autowrite(wp->w_buffer, FALSE) == OK);\n\tif (!win_valid(wp))\n\t{\n\t    // BufWrite Autocommands made the window invalid, start over\n\t    wp = lastwin;\n\t}\n\telse if (r)\n\t{\n\t    win_close(wp, !buf_hide(wp->w_buffer));\n\t    --open_wins;\n\t    wp = lastwin;\n\t}\n\telse\n\t{\n\t    wp = wp->w_prev;\n\t    if (wp == NULL)\n\t\tbreak;\n\t}\n    }\n}\n\n\nstatic int  chk_modeline(linenr_T, int);\n\n/*\n * do_modelines() - process mode lines for the current file\n *\n * \"flags\" can be:\n * OPT_WINONLY\t    only set options local to window\n * OPT_NOWIN\t    don't set options local to window\n *\n * Returns immediately if the \"ml\" option isn't set.\n */\n    void\ndo_modelines(int flags)\n{\n    linenr_T\tlnum;\n    int\t\tnmlines;\n    static int\tentered = 0;\n\n    if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)\n\treturn;\n\n    // Disallow recursive entry here.  Can happen when executing a modeline\n    // triggers an autocommand, which reloads modelines with a \":do\".\n    if (entered)\n\treturn;\n\n    ++entered;\n    for (lnum = 1; curbuf->b_p_ml && lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines;\n\t\t\t\t\t\t\t\t       ++lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n\n    for (lnum = curbuf->b_ml.ml_line_count; curbuf->b_p_ml && lnum > 0 && lnum > nmlines\n\t\t       && lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)\n\tif (chk_modeline(lnum, flags) == FAIL)\n\t    nmlines = 0;\n    --entered;\n}\n\n#include \"version.h\"\t\t// for version number\n\n/*\n * chk_modeline() - check a single line for a mode string\n * Return FAIL if an error encountered.\n */\n    static int\nchk_modeline(\n    linenr_T\tlnum,\n    int\t\tflags)\t\t// Same as for do_modelines().\n{\n    char_u\t*s;\n    char_u\t*e;\n    char_u\t*linecopy;\t\t// local copy of any modeline found\n    int\t\tprev;\n    int\t\tvers;\n    int\t\tend;\n    int\t\tretval = OK;\n    sctx_T\tsave_current_sctx;\n\n    ESTACK_CHECK_DECLARATION\n\n    prev = -1;\n    for (s = ml_get(lnum); *s != NUL; ++s)\n    {\n\tif (prev == -1 || vim_isspace(prev))\n\t{\n\t    if ((prev != -1 && STRNCMP(s, \"ex:\", (size_t)3) == 0)\n\t\t    || STRNCMP(s, \"vi:\", (size_t)3) == 0)\n\t\tbreak;\n\t    // Accept both \"vim\" and \"Vim\".\n\t    if ((s[0] == 'v' || s[0] == 'V') && s[1] == 'i' && s[2] == 'm')\n\t    {\n\t\tif (s[3] == '<' || s[3] == '=' || s[3] == '>')\n\t\t    e = s + 4;\n\t\telse\n\t\t    e = s + 3;\n\t\tvers = getdigits(&e);\n\t\tif (*e == ':'\n\t\t\t&& (s[0] != 'V'\n\t\t\t\t  || STRNCMP(skipwhite(e + 1), \"set\", 3) == 0)\n\t\t\t&& (s[3] == ':'\n\t\t\t    || (VIM_VERSION_100 >= vers && isdigit(s[3]))\n\t\t\t    || (VIM_VERSION_100 < vers && s[3] == '<')\n\t\t\t    || (VIM_VERSION_100 > vers && s[3] == '>')\n\t\t\t    || (VIM_VERSION_100 == vers && s[3] == '=')))\n\t\t    break;\n\t    }\n\t}\n\tprev = *s;\n    }\n\n    if (*s)\n    {\n\tdo\t\t\t\t// skip over \"ex:\", \"vi:\" or \"vim:\"\n\t    ++s;\n\twhile (s[-1] != ':');\n\n\ts = linecopy = vim_strsave(s);\t// copy the line, it will change\n\tif (linecopy == NULL)\n\t    return FAIL;\n\n\t// prepare for emsg()\n\testack_push(ETYPE_MODELINE, (char_u *)\"modelines\", lnum);\n\tESTACK_CHECK_SETUP\n\n\tend = FALSE;\n\twhile (end == FALSE)\n\t{\n\t    s = skipwhite(s);\n\t    if (*s == NUL)\n\t\tbreak;\n\n\t    /*\n\t     * Find end of set command: ':' or end of line.\n\t     * Skip over \"\\:\", replacing it with \":\".\n\t     */\n\t    for (e = s; *e != ':' && *e != NUL; ++e)\n\t\tif (e[0] == '\\\\' && e[1] == ':')\n\t\t    STRMOVE(e, e + 1);\n\t    if (*e == NUL)\n\t\tend = TRUE;\n\n\t    /*\n\t     * If there is a \"set\" command, require a terminating ':' and\n\t     * ignore the stuff after the ':'.\n\t     * \"vi:set opt opt opt: foo\" -- foo not interpreted\n\t     * \"vi:opt opt opt: foo\" -- foo interpreted\n\t     * Accept \"se\" for compatibility with Elvis.\n\t     */\n\t    if (STRNCMP(s, \"set \", (size_t)4) == 0\n\t\t    || STRNCMP(s, \"se \", (size_t)3) == 0)\n\t    {\n\t\tif (*e != ':')\t\t// no terminating ':'?\n\t\t    break;\n\t\tend = TRUE;\n\t\ts = vim_strchr(s, ' ') + 1;\n\t    }\n\t    *e = NUL;\t\t\t// truncate the set command\n\n\t    if (*s != NUL)\t\t// skip over an empty \"::\"\n\t    {\n\t\tint secure_save = secure;\n\n\t\tsave_current_sctx = current_sctx;\n\t\tcurrent_sctx.sc_version = 1;\n#ifdef FEAT_EVAL\n\t\tcurrent_sctx.sc_sid = SID_MODELINE;\n\t\tcurrent_sctx.sc_seq = 0;\n\t\tcurrent_sctx.sc_lnum = lnum;\n#endif\n\n\t\t// Make sure no risky things are executed as a side effect.\n\t\tsecure = 1;\n\n\t\tretval = do_set(s, OPT_MODELINE | OPT_LOCAL | flags);\n\n\t\tsecure = secure_save;\n\t\tcurrent_sctx = save_current_sctx;\n\t\tif (retval == FAIL)\t\t// stop if error found\n\t\t    break;\n\t    }\n\t    s = e + 1;\t\t\t// advance to next part\n\t}\n\n\tESTACK_CHECK_NOW\n\testack_pop();\n\tvim_free(linecopy);\n    }\n    return retval;\n}\n\n/*\n * Return TRUE if \"buf\" is a normal buffer, 'buftype' is empty.\n */\n    int\nbt_normal(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == NUL;\n}\n\n/*\n * Return TRUE if \"buf\" is the quickfix buffer.\n */\n    int\nbt_quickfix(buf_T *buf UNUSED)\n{\n#ifdef FEAT_QUICKFIX\n    return buf != NULL && buf->b_p_bt[0] == 'q';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a terminal buffer.\n */\n    int\nbt_terminal(buf_T *buf UNUSED)\n{\n#if defined(FEAT_TERMINAL)\n    return buf != NULL && buf->b_p_bt[0] == 't';\n#else\n    return FALSE;\n#endif\n}\n\n/*\n * Return TRUE if \"buf\" is a help buffer.\n */\n    int\nbt_help(buf_T *buf)\n{\n    return buf != NULL && buf->b_help;\n}\n\n/*\n * Return TRUE if \"buf\" is a prompt buffer.\n */\n    int\nbt_prompt(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'r';\n}\n\n#if defined(FEAT_PROP_POPUP) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" is a buffer for a popup window.\n */\n    int\nbt_popup(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt != NULL\n\t&& buf->b_p_bt[0] == 'p' && buf->b_p_bt[1] == 'o';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"acwrite\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer name may not be a file name, at least not for\n * writing the buffer.\n */\n    int\nbt_nofilename(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 'a'\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n/*\n * Return TRUE if \"buf\" is a \"nofile\", \"quickfix\", \"terminal\" or \"prompt\"\n * buffer.  This means the buffer is not to be read from a file.\n */\n    static int\nbt_nofileread(buf_T *buf)\n{\n    return buf != NULL && ((buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f')\n\t    || buf->b_p_bt[0] == 't'\n\t    || buf->b_p_bt[0] == 'q'\n\t    || buf->b_p_bt[0] == 'p');\n}\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n/*\n * Return TRUE if \"buf\" has 'buftype' set to \"nofile\".\n */\n    int\nbt_nofile(buf_T *buf)\n{\n    return buf != NULL && buf->b_p_bt[0] == 'n' && buf->b_p_bt[2] == 'f';\n}\n#endif\n\n/*\n * Return TRUE if \"buf\" is a \"nowrite\", \"nofile\", \"terminal\", \"prompt\", or\n * \"popup\" buffer.\n */\n    int\nbt_dontwrite(buf_T *buf)\n{\n    return buf != NULL && (buf->b_p_bt[0] == 'n'\n\t\t || buf->b_p_bt[0] == 't'\n\t\t || buf->b_p_bt[0] == 'p');\n}\n\n    int\nbt_dontwrite_msg(buf_T *buf)\n{\n    if (bt_dontwrite(buf))\n    {\n\temsg(_(e_cannot_write_buftype_option_is_set));\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Return TRUE if the buffer should be hidden, according to 'hidden', \":hide\"\n * and 'bufhidden'.\n */\n    int\nbuf_hide(buf_T *buf)\n{\n    // 'bufhidden' overrules 'hidden' and \":hide\", check it first\n    switch (buf->b_p_bh[0])\n    {\n\tcase 'u':\t\t    // \"unload\"\n\tcase 'w':\t\t    // \"wipe\"\n\tcase 'd': return FALSE;\t    // \"delete\"\n\tcase 'h': return TRUE;\t    // \"hide\"\n    }\n    return (p_hid || (cmdmod.cmod_flags & CMOD_HIDE));\n}\n\n/*\n * Return special buffer name.\n * Returns NULL when the buffer has a normal file name.\n */\n    char_u *\nbuf_spname(buf_T *buf)\n{\n#if defined(FEAT_QUICKFIX)\n    if (bt_quickfix(buf))\n    {\n\t/*\n\t * Differentiate between the quickfix and location list buffers using\n\t * the buffer number stored in the global quickfix stack.\n\t */\n\tif (buf->b_fnum == qf_stack_get_bufnr())\n\t    return (char_u *)_(msg_qflist);\n\telse\n\t    return (char_u *)_(msg_loclist);\n    }\n#endif\n\n    // There is no _file_ when 'buftype' is \"nofile\", b_sfname\n    // contains the name as specified by the user.\n    if (bt_nofilename(buf))\n    {\n#ifdef FEAT_TERMINAL\n\tif (buf->b_term != NULL)\n\t    return term_get_status_text(buf->b_term);\n#endif\n\tif (buf->b_fname != NULL)\n\t    return buf->b_fname;\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(buf))\n\t    return (char_u *)_(\"[Prompt]\");\n#endif\n#ifdef FEAT_PROP_POPUP\n\tif (bt_popup(buf))\n\t    return (char_u *)_(\"[Popup]\");\n#endif\n\treturn (char_u *)_(\"[Scratch]\");\n    }\n\n    if (buf->b_fname == NULL)\n\treturn buf_get_fname(buf);\n    return NULL;\n}\n\n/*\n * Get \"buf->b_fname\", use \"[No Name]\" if it is NULL.\n */\n    char_u *\nbuf_get_fname(buf_T *buf)\n{\n    if (buf->b_fname == NULL)\n\treturn (char_u *)_(\"[No Name]\");\n    return buf->b_fname;\n}\n\n/*\n * Set 'buflisted' for curbuf to \"on\" and trigger autocommands if it changed.\n */\n    void\nset_buflisted(int on)\n{\n    if (on == curbuf->b_p_bl)\n\treturn;\n\n    curbuf->b_p_bl = on;\n    if (on)\n\tapply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, curbuf);\n    else\n\tapply_autocmds(EVENT_BUFDELETE, NULL, NULL, FALSE, curbuf);\n}\n\n/*\n * Read the file for \"buf\" again and check if the contents changed.\n * Return TRUE if it changed or this could not be checked.\n */\n    int\nbuf_contents_changed(buf_T *buf)\n{\n    buf_T\t*newbuf;\n    int\t\tdiffer = TRUE;\n    linenr_T\tlnum;\n    aco_save_T\taco;\n    exarg_T\tea;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn TRUE;\n\n    // Force the 'fileencoding' and 'fileformat' to be equal.\n    if (prep_exarg(&ea, buf) == FAIL)\n    {\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    // Set curwin/curbuf to buf and save a few things.\n    aucmd_prepbuf(&aco, newbuf);\n    if (curbuf != newbuf)\n    {\n\t// Failed to find a window for \"newbuf\".\n\twipe_buffer(newbuf, FALSE);\n\treturn TRUE;\n    }\n\n    if (ml_open(curbuf) == OK\n\t    && readfile(buf->b_ffname, buf->b_fname,\n\t\t\t\t  (linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\t\t\t    &ea, READ_NEW | READ_DUMMY) == OK)\n    {\n\t// compare the two files line by line\n\tif (buf->b_ml.ml_line_count == curbuf->b_ml.ml_line_count)\n\t{\n\t    differ = FALSE;\n\t    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum)\n\t\tif (STRCMP(ml_get_buf(buf, lnum, FALSE), ml_get(lnum)) != 0)\n\t\t{\n\t\t    differ = TRUE;\n\t\t    break;\n\t\t}\n\t}\n    }\n    vim_free(ea.cmd);\n\n    // restore curwin/curbuf and a few other things\n    aucmd_restbuf(&aco);\n\n    if (curbuf != newbuf)\t// safety check\n\twipe_buffer(newbuf, FALSE);\n\n    return differ;\n}\n\n/*\n * Wipe out a buffer and decrement the last buffer number if it was used for\n * this buffer.  Call this to wipe out a temp buffer that does not contain any\n * marks.\n */\n    void\nwipe_buffer(\n    buf_T\t*buf,\n    int\t\taucmd)\t    // When TRUE trigger autocommands.\n{\n    if (buf->b_fnum == top_file_num - 1)\n\t--top_file_num;\n\n    if (!aucmd)\t\t    // Don't trigger BufDelete autocommands here.\n\tblock_autocmds();\n\n    close_buffer(NULL, buf, DOBUF_WIPE, FALSE, TRUE);\n\n    if (!aucmd)\n\tunblock_autocmds();\n}\n", "\" Test 'statusline'\n\"\n\" Not tested yet:\n\"   %N\n\nsource view_util.vim\nsource check.vim\nsource screendump.vim\n\nfunc SetUp()\n  set laststatus=2\nendfunc\n\nfunc TearDown()\n  set laststatus&\nendfunc\n\nfunc s:get_statusline()\n  return ScreenLines(&lines - 1, &columns)[0]\nendfunc\n\nfunc StatuslineWithCaughtError()\n  let s:func_in_statusline_called = 1\n  try\n    call eval('unknown expression')\n  catch\n  endtry\n  return ''\nendfunc\n\nfunc StatuslineWithError()\n  let s:func_in_statusline_called = 1\n  call eval('unknown expression')\n  return ''\nendfunc\n\n\" Function used to display syntax group.\nfunc SyntaxItem()\n  call assert_equal(s:expected_curbuf, g:actual_curbuf)\n  call assert_equal(s:expected_curwin, g:actual_curwin)\n  return synIDattr(synID(line(\".\"), col(\".\"),1), \"name\")\nendfunc\n\nfunc Test_caught_error_in_statusline()\n  let s:func_in_statusline_called = 0\n  let statusline = '%{StatuslineWithCaughtError()}'\n  let &statusline = statusline\n  redrawstatus\n  call assert_true(s:func_in_statusline_called)\n  call assert_equal(statusline, &statusline)\n  set statusline=\nendfunc\n\nfunc Test_statusline_will_be_disabled_with_error()\n  let s:func_in_statusline_called = 0\n  let statusline = '%{StatuslineWithError()}'\n  try\n    let &statusline = statusline\n    redrawstatus\n  catch\n  endtry\n  call assert_true(s:func_in_statusline_called)\n  call assert_equal('', &statusline)\n  set statusline=\nendfunc\n\nfunc Test_statusline()\n  CheckFeature quickfix\n\n  \" %a: Argument list ({current} of {max})\n  set statusline=%a\n  call assert_match('^\\s*$', s:get_statusline())\n  arglocal a1 a2\n  rewind\n  call assert_match('^ (1 of 2)\\s*$', s:get_statusline())\n  next\n  call assert_match('^ (2 of 2)\\s*$', s:get_statusline())\n  e Xstatusline\n  call assert_match('^ ((2) of 2)\\s*$', s:get_statusline())\n\n  only\n  set splitbelow\n  call setline(1, range(1, 10000))\n\n  \" %b: Value of character under cursor.\n  \" %B: As above, in hexadecimal.\n  call cursor(9000, 1)\n  set statusline=%b,%B\n  call assert_match('^57,39\\s*$', s:get_statusline())\n\n  \" %o: Byte number in file of byte under cursor, first byte is 1.\n  \" %O: As above, in hexadecimal.\n  set statusline=%o,%O\n  set fileformat=dos\n  call assert_match('^52888,CE98\\s*$', s:get_statusline())\n  set fileformat=mac\n  call assert_match('^43889,AB71\\s*$', s:get_statusline())\n  set fileformat=unix\n  call assert_match('^43889,AB71\\s*$', s:get_statusline())\n  set fileformat&\n\n  \" %f: Path to the file in the buffer, as typed or relative to current dir.\n  set statusline=%f\n  call assert_match('^Xstatusline\\s*$', s:get_statusline())\n\n  \" %F: Full path to the file in the buffer.\n  set statusline=%F\n  call assert_match('/testdir/Xstatusline\\s*$', s:get_statusline())\n\n  \" Test for min and max width with %(. For some reason, if this test is moved\n  \" after the below test for the help buffer flag, then the code to truncate\n  \" the string is not executed.\n  set statusline=%015(%f%)\n  call assert_match('^    Xstatusline\\s*$', s:get_statusline())\n  set statusline=%.6(%f%)\n  call assert_match('^<sline\\s*$', s:get_statusline())\n  set statusline=%14f\n  call assert_match('^   Xstatusline\\s*$', s:get_statusline())\n  set statusline=%.4L\n  call assert_match('^10>3\\s*$', s:get_statusline())\n\n  \" %h: Help buffer flag, text is \"[help]\".\n  \" %H: Help buffer flag, text is \",HLP\".\n  set statusline=%h,%H\n  call assert_match('^,\\s*$', s:get_statusline())\n  help\n  call assert_match('^\\[Help\\],HLP\\s*$', s:get_statusline())\n  helpclose\n\n  \" %k: Value of \"b:keymap_name\" or 'keymap'\n  \"     when :lmap mappings are being used: <keymap>\"\n  set statusline=%k\n  if has('keymap')\n    set keymap=esperanto\n    call assert_match('^<Eo>\\s*$', s:get_statusline())\n    set keymap&\n  else\n    call assert_match('^\\s*$', s:get_statusline())\n  endif\n\n  \" %l: Line number.\n  \" %L: Number of line in buffer.\n  \" %c: Column number.\n  set statusline=%l/%L,%c\n  call assert_match('^9000/10000,1\\s*$', s:get_statusline())\n\n  \" %m: Modified flag, text is \"[+]\", \"[-]\" if 'modifiable' is off.\n  \" %M: Modified flag, text is \",+\" or \",-\".\n  set statusline=%m%M\n  call assert_match('^\\[+\\],+\\s*$', s:get_statusline())\n  set nomodifiable\n  call assert_match('^\\[+-\\],+-\\s*$', s:get_statusline())\n  write\n  call assert_match('^\\[-\\],-\\s*$', s:get_statusline())\n  set modifiable&\n  call assert_match('^\\s*$', s:get_statusline())\n\n  \" %n: Buffer number.\n  set statusline=%n\n  call assert_match('^'.bufnr('%').'\\s*$', s:get_statusline())\n\n  \" %p: Percentage through file in lines as in CTRL-G.\n  \" %P: Percentage through file of displayed window.\n  set statusline=%p,%P\n  0\n  call assert_match('^0,Top\\s*$', s:get_statusline())\n  norm G\n  call assert_match('^100,Bot\\s*$', s:get_statusline())\n  9000\n  \" Don't check the exact percentage as it depends on the window size\n  call assert_match('^90,\\(Top\\|Bot\\|\\d\\+%\\)\\s*$', s:get_statusline())\n\n  \" %q: \"[Quickfix List]\", \"[Location List]\" or empty.\n  set statusline=%q\n  call assert_match('^\\s*$', s:get_statusline())\n  copen\n  call assert_match('^\\[Quickfix List\\]\\s*$', s:get_statusline())\n  cclose\n  lexpr getline(1, 2)\n  lopen\n  call assert_match('^\\[Location List\\]\\s*$', s:get_statusline())\n  lclose\n\n  \" %r: Readonly flag, text is \"[RO]\".\n  \" %R: Readonly flag, text is \",RO\".\n  set statusline=%r,%R\n  call assert_match('^,\\s*$', s:get_statusline())\n  help\n  call assert_match('^\\[RO\\],RO\\s*$', s:get_statusline())\n  helpclose\n\n  \" %t: File name (tail) of file in the buffer.\n  set statusline=%t\n  call assert_match('^Xstatusline\\s*$', s:get_statusline())\n\n  \" %v: Virtual column number.\n  \" %V: Virtual column number as -{num}. Not displayed if equal to 'c'.\n  call cursor(9000, 2)\n  set statusline=%v,%V\n  call assert_match('^2,\\s*$', s:get_statusline())\n  set virtualedit=all\n  norm 10|\n  call assert_match('^10,-10\\s*$', s:get_statusline())\n  set list\n  call assert_match('^10,-10\\s*$', s:get_statusline())\n  set virtualedit&\n  exe \"norm A\\<Tab>\\<Tab>a\\<Esc>\"\n  \" In list mode a <Tab> is shown as \"^I\", which is 2-wide.\n  call assert_match('^9,-9\\s*$', s:get_statusline())\n  set list&\n  \" Now the second <Tab> ends at the 16th screen column.\n  call assert_match('^17,-17\\s*$', s:get_statusline())\n  undo\n\n  \" %w: Preview window flag, text is \"[Preview]\".\n  \" %W: Preview window flag, text is \",PRV\".\n  set statusline=%w%W\n  call assert_match('^\\s*$', s:get_statusline())\n  pedit\n  wincmd j\n  call assert_match('^\\[Preview\\],PRV\\s*$', s:get_statusline())\n  pclose\n\n  \" %y: Type of file in the buffer, e.g., \"[vim]\". See 'filetype'.\n  \" %Y: Type of file in the buffer, e.g., \",VIM\". See 'filetype'.\n  set statusline=%y\\ %Y\n  call assert_match('^\\s*$', s:get_statusline())\n  setfiletype vim\n  call assert_match('^\\[vim\\] VIM\\s*$', s:get_statusline())\n\n  \" %=: Separation point between left and right aligned items.\n  set statusline=foo%=bar\n  call assert_match('^foo\\s\\+bar\\s*$', s:get_statusline())\n\n  \" Test min/max width, leading zeroes, left/right justify.\n  set statusline=%04B\n  call cursor(9000, 1)\n  call assert_match('^0039\\s*$', s:get_statusline())\n  set statusline=#%4B#\n  call assert_match('^#  39#\\s*$', s:get_statusline())\n  set statusline=#%-4B#\n  call assert_match('^#39  #\\s*$', s:get_statusline())\n  set statusline=%.6f\n  call assert_match('^<sline\\s*$', s:get_statusline())\n\n  \" %<: Where to truncate.\n  \" First check with when %< should not truncate with many columns\n  exe 'set statusline=a%<b' . repeat('c', &columns - 3) . 'd'\n  call assert_match('^abc\\+d$', s:get_statusline())\n  exe 'set statusline=a' . repeat('b', &columns - 2) . '%<c'\n  call assert_match('^ab\\+c$', s:get_statusline())\n  \" Then check when %< should truncate when there with too few columns.\n  exe 'set statusline=a%<b' . repeat('c', &columns - 2) . 'd'\n  call assert_match('^a<c\\+d$', s:get_statusline())\n  exe 'set statusline=a' . repeat('b', &columns - 1) . '%<c'\n  call assert_match('^ab\\+>$', s:get_statusline())\n\n  \"%{: Evaluate expression between '%{' and '}' and substitute result.\n  syntax on\n  let s:expected_curbuf = string(bufnr(''))\n  let s:expected_curwin = string(win_getid())\n  set statusline=%{SyntaxItem()}\n  call assert_match('^vimNumber\\s*$', s:get_statusline())\n  s/^/\"/\n  call assert_match('^vimLineComment\\s*$', s:get_statusline())\n  syntax off\n\n  \"%{%expr%}: evaluates expressions present in result of expr\n  func! Inner_eval()\n    return '%n some other text'\n  endfunc\n  func! Outer_eval()\n    return 'some text %{%Inner_eval()%}'\n  endfunc\n  set statusline=%{%Outer_eval()%}\n  call assert_match('^some text ' . bufnr() . ' some other text\\s*$', s:get_statusline())\n  delfunc Inner_eval\n  delfunc Outer_eval\n\n  \"%{%expr%}: Doesn't get stuck in recursion\n  func! Recurse_eval()\n    return '%{%Recurse_eval()%}'\n  endfunc\n  set statusline=%{%Recurse_eval()%}\n  call assert_match('^%{%Recurse_eval()%}\\s*$', s:get_statusline())\n  delfunc Recurse_eval\n\n  \"%(: Start of item group.\n  set statusline=ab%(cd%q%)de\n  call assert_match('^abde\\s*$', s:get_statusline())\n  copen\n  call assert_match('^abcd\\[Quickfix List]de\\s*$', s:get_statusline())\n  cclose\n\n  \" %#: Set highlight group. The name must follow and then a # again.\n  set statusline=ab%#Todo#cd%#Error#ef\n  call assert_match('^abcdef\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  call assert_notequal(sa1, sa2)\n  call assert_notequal(sa1, sa3)\n  call assert_notequal(sa2, sa3)\n  call assert_equal(sa1, screenattr(&lines - 1, 2))\n  call assert_equal(sa2, screenattr(&lines - 1, 4))\n  call assert_equal(sa3, screenattr(&lines - 1, 6))\n  call assert_equal(sa3, screenattr(&lines - 1, 7))\n\n  \" %*: Set highlight group to User{N}\n  set statusline=a%1*b%0*c\n  call assert_match('^abc\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 2)\n  let sa3=screenattr(&lines - 1, 3)\n  call assert_equal(sa1, sa3)\n  call assert_notequal(sa1, sa2)\n\n  \" An empty group that contains highlight changes\n  let g:a = ''\n  set statusline=ab%(cd%1*%{g:a}%*%)de\n  call assert_match('^abde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 4)\n  call assert_equal(sa1, sa2)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 5)\n  let sa3=screenattr(&lines - 1, 7)\n  call assert_equal(sa1, sa3)\n  call assert_notequal(sa1, sa2)\n\n  let g:a = ''\n  set statusline=ab%1*%(cd%*%{g:a}%1*%)de\n  call assert_match('^abde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 4)\n  call assert_notequal(sa1, sa2)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  let sa4=screenattr(&lines - 1, 7)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa1, sa3)\n  call assert_equal(sa2, sa4)\n\n  \" An empty group that contains highlight changes and doesn't reset them\n  let g:a = ''\n  set statusline=ab%(cd%1*%{g:a}%)de\n  call assert_match('^abcdde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 5)\n  call assert_notequal(sa1, sa2)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 5)\n  let sa3=screenattr(&lines - 1, 7)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa2, sa3)\n\n  let g:a = ''\n  set statusline=ab%1*%(cd%*%{g:a}%)de\n  call assert_match('^abcdde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa1, sa3)\n  let g:a = 'X'\n  call assert_match('^abcdXde\\s*$', s:get_statusline())\n  let sa1=screenattr(&lines - 1, 1)\n  let sa2=screenattr(&lines - 1, 3)\n  let sa3=screenattr(&lines - 1, 5)\n  let sa4=screenattr(&lines - 1, 7)\n  call assert_notequal(sa1, sa2)\n  call assert_equal(sa1, sa3)\n  call assert_equal(sa1, sa4)\n\n  let g:a = ''\n  set statusline=%#Error#{%(\\ %{g:a}\\ %)}\n  call assert_match('^{}\\s*$', s:get_statusline())\n  let g:a = 'X'\n  call assert_match('^{ X }\\s*$', s:get_statusline())\n\n  \" %%: a percent sign.\n  set statusline=10%%\n  call assert_match('^10%\\s*$', s:get_statusline())\n\n  \" %!: evaluated expression is used as the option value\n  set statusline=%!2*3+1\n  call assert_match('7\\s*$', s:get_statusline())\n\n  func GetNested()\n    call assert_equal(string(win_getid()), g:actual_curwin)\n    call assert_equal(string(bufnr('')), g:actual_curbuf)\n    return 'nested'\n  endfunc\n  func GetStatusLine()\n    call assert_equal(win_getid(), g:statusline_winid)\n    return 'the %{GetNested()} line'\n  endfunc\n  set statusline=%!GetStatusLine()\n  call assert_match('the nested line', s:get_statusline())\n  call assert_false(exists('g:actual_curwin'))\n  call assert_false(exists('g:actual_curbuf'))\n  call assert_false(exists('g:statusline_winid'))\n  delfunc GetNested\n  delfunc GetStatusLine\n\n  \" Test statusline works with 80+ items\n  function! StatusLabel()\n    redrawstatus\n    return '[label]'\t\n  endfunc\n  let statusline = '%{StatusLabel()}'\n  for i in range(150)\n    let statusline .= '%#TabLine' . (i % 2 == 0 ? 'Fill' : 'Sel') . '#' . string(i)[0]\n  endfor\n  let &statusline = statusline\n  redrawstatus\n  set statusline&\n  delfunc StatusLabel\n\n\n  \" Check statusline in current and non-current window\n  \" with the 'fillchars' option.\n  set fillchars=stl:^,stlnc:=,vert:\\|,fold:-,diff:-\n  vsplit\n  set statusline=x%=y\n  call assert_match('^x^\\+y^x=\\+y$', s:get_statusline())\n  set fillchars&\n  close\n\n  %bw!\n  call delete('Xstatusline')\n  set statusline&\n  set splitbelow&\nendfunc\n\nfunc Test_statusline_trailing_percent_zero()\n  \" this was causing illegal memory access\n  set laststatus=2 stl=%!%0\n  call assert_fails('redraw', 'E15: Invalid expression: \"%0\"')\n  set laststatus& stl&\nendfunc\n\nfunc Test_statusline_visual()\n  func CallWordcount()\n    call wordcount()\n  endfunc\n  new x1\n  setl statusline=count=%{CallWordcount()}\n  \" buffer must not be empty\n  call setline(1, 'hello')\n\n  \" window with more lines than x1\n  new x2\n  call setline(1, range(10))\n  $\n  \" Visual mode in line below liast line in x1 should not give ml_get error\n  call feedkeys(\"\\<C-V>\", \"xt\")\n  redraw\n\n  delfunc CallWordcount\n  bwipe! x1\n  bwipe! x2\nendfunc\n\nfunc Test_statusline_removed_group()\n  CheckScreendump\n\n  let lines =<< trim END\n    scriptencoding utf-8\n    set laststatus=2\n    let &statusline = '%#StatColorHi2#%(\u2713%#StatColorHi2#%) Q\u2261'\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 10, 'cols': 50})\n  call VerifyScreenDump(buf, 'Test_statusline_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_statusline_using_mode()\n  CheckScreendump\n\n  let lines =<< trim END\n    setlocal statusline=-%{mode()}-\n    split\n    setlocal statusline=+%{mode()}+\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 7, 'cols': 50})\n  call VerifyScreenDump(buf, 'Test_statusline_mode_1', {})\n\n  call term_sendkeys(buf, \":\")\n  call VerifyScreenDump(buf, 'Test_statusline_mode_2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"close\\<CR>\")\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_statusline_after_split_vsplit()\n  only\n\n  \" Make the status line of each window show the window number.\n  set ls=2 stl=%{winnr()}\n\n  split | redraw\n  vsplit | redraw\n\n  \" The status line of the third window should read '3' here.\n  call assert_equal('3', nr2char(screenchar(&lines - 1, 1)))\n\n  only\n  set ls& stl&\nendfunc\n\n\" Test using a multibyte character for 'stl' and 'stlnc' items in 'fillchars'\n\" with a custom 'statusline'\nfunc Test_statusline_mbyte_fillchar()\n  only\n  set fillchars=vert:\\|,fold:-,stl:\u2501,stlnc:\u2550\n  set statusline=a%=b\n  call assert_match('^a\\+\u2501\\+b$', s:get_statusline())\n  vnew\n  call assert_match('^a\\+\u2501\\+b\u2501a\\+\u2550\\+b$', s:get_statusline())\n  wincmd w\n  call assert_match('^a\\+\u2550\\+b\u2550a\\+\u2501\\+b$', s:get_statusline())\n  set statusline& fillchars&\n  %bw!\nendfunc\n\n\" Used to write beyond allocated memory.  This assumes MAXPATHL is 4096 bytes.\nfunc Test_statusline_verylong_filename()\n  let fname = repeat('x', 4090)\n  exe \"new \" .. fname\n  set buftype=help\n  set previewwindow\n  redraw\n  bwipe!\nendfunc\n\nfunc Test_statusline_highlight_truncate()\n  CheckScreendump\n\n  let lines =<< trim END\n    set laststatus=2\n    hi! link User1 Directory\n    hi! link User2 ErrorMsg\n    set statusline=%.5(%1*ABC%2*DEF%1*GHI%)\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 6})\n  call VerifyScreenDump(buf, 'Test_statusline_hl', {})\n\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_statusline_showcmd()\n  CheckScreendump\n\n  let lines =<< trim END\n    set laststatus=2\n    set statusline=%S\n    set showcmdloc=statusline\n    call setline(1, ['a', 'b', 'c'])\n  END\n  call writefile(lines, 'XTest_statusline', 'D')\n\n  let buf = RunVimInTerminal('-S XTest_statusline', {'rows': 6})\n  call feedkeys(\"\\<C-V>Gl\", \"xt\")\n  call VerifyScreenDump(buf, 'Test_statusline_showcmd_1', {})\n\n  call feedkeys(\"\\<Esc>1234\", \"xt\")\n  call VerifyScreenDump(buf, 'Test_statusline_showcmd_2', {})\n\n  call feedkeys(\"\\<Esc>:set statusline=\\<CR>:\\<CR>1234\", \"xt\")\n  call VerifyScreenDump(buf, 'Test_statusline_showcmd_3', {})\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/buffer.c", "src/testdir/test_statusline.vim", "src/version.c"], "buggy_code_start_loc": [4619, 442, 697], "buggy_code_end_loc": [4619, 442, 697], "fixing_code_start_loc": [4620, 443, 698], "fixing_code_end_loc": [4622, 450, 700], "type": "CWE-125", "message": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.1143.", "other": {"cve": {"id": "CVE-2023-0049", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-04T16:15:09.047", "lastModified": "2023-05-03T12:16:43.490", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Out-of-bounds Read in GitHub repository vim/vim prior to 9.0.1143."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.3, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1143", "matchCriteriaId": "FF2F5C04-F7F7-43E5-97E8-687E740139C1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2023/Mar/17", "source": "security@huntr.dev"}, {"url": "https://github.com/vim/vim/commit/7b17eb4b063a234376c1ec909ee293e42cff290c", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/5e6f325c-ba54-4bf0-b050-dca048fd3fd9", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3Y752EAVACVC5XY2TMGGOAIU25VQRPDW/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/T33LLWHLH63XDCO5OME7NWN63RA4U5HF/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202305-16", "source": "security@huntr.dev"}, {"url": "https://support.apple.com/kb/HT213670", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/7b17eb4b063a234376c1ec909ee293e42cff290c"}}