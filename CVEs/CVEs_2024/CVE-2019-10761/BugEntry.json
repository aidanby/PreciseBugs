{"buggy_code": ["/* global host */\n/* eslint-disable block-spacing, no-multi-spaces, brace-style, no-array-constructor, new-cap, no-use-before-define */\n\n'use strict';\n\n// eslint-disable-next-line no-invalid-this, no-shadow\nconst global = this;\n\nconst local = host.Object.create(null);\nlocal.Object = Object;\nlocal.Array = Array;\nlocal.Reflect = host.Object.create(null);\nlocal.Reflect.ownKeys = Reflect.ownKeys;\nlocal.Reflect.enumerable = Reflect.enumerate;\nlocal.Reflect.getPrototypeOf = Reflect.getPrototypeOf;\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nObject.setPrototypeOf(global, Object.prototype);\n\nObject.defineProperties(global, {\n\tglobal: {value: global},\n\tGLOBAL: {value: global},\n\troot: {value: global},\n\tisVM: {value: true}\n});\n\nconst DEBUG = false;\nconst OPNA = 'Operation not allowed on contextified object.';\nconst captureStackTrace = Error.captureStackTrace;\n\nconst FROZEN_TRAPS = host.Object.create(null);\nFROZEN_TRAPS.set = (target, key) => false;\nFROZEN_TRAPS.setPrototypeOf = (target, key) => false;\nFROZEN_TRAPS.defineProperty = (target, key) => false;\nFROZEN_TRAPS.deleteProperty = (target, key) => false;\nFROZEN_TRAPS.isExtensible = (target, key) => false;\nFROZEN_TRAPS.preventExtensions = (target) => false;\n\n// Map of contextified objects to original objects\nconst Contextified = new host.WeakMap();\nconst Decontextified = new host.WeakMap();\n\n// Fake setters make sure we use correctly scoped definer for getter/setter definition\nfunction fakeDefineGetter(receiver, useLocalDefiner) {\n\treturn function __defineGetter__(key, value) {\n\t\t(useLocalDefiner ? local.Object : host.Object).defineProperty(receiver, key, {get: value, enumerable: true, configurable: true});\n\t};\n}\n\nfunction fakeDefineSetter(receiver, useLocalDefiner) {\n\treturn function __defineSetter__(key, value) {\n\t\t(useLocalDefiner ? local.Object : host.Object).defineProperty(receiver, key, {set: value, enumerable: true, configurable: true});\n\t};\n}\n\nfunction fakeLookupGetter(receiver, useLocalLookup) {\n\treturn function __lookupGetter__(key, value) {\n\t\tconst descriptor = (useLocalLookup ? local.Object : host.Object).getOwnPropertyDescriptor(receiver, key);\n\t\treturn descriptor && descriptor.get;\n\t};\n}\n\nfunction fakeLookupSetter(receiver, useLocalLookup) {\n\treturn function __lookupSetter__(key, value) {\n\t\tconst descriptor = (useLocalLookup ? local.Object : host.Object).getOwnPropertyDescriptor(receiver, key);\n\t\treturn descriptor && descriptor.set;\n\t};\n}\n\n// We can't use host's hasInstance method\nconst hasInstance = local.Object[Symbol.hasInstance];\nfunction instanceOf(value, construct) {\n\ttry {\n\t\treturn host.Reflect.apply(hasInstance, construct, [value]);\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through!\n\t\tthrow new VMError('Unable to perform instanceOf check.');\n\t\t// This exception actually never get to the user. It only instructs the caller to return null bacause we wasn't able to perform instanceOf check.\n\t}\n}\n\n/**\n * VMError definition.\n */\n\nclass VMError extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\t\tthis.code = code;\n\n\t\tcaptureStackTrace(this, this.constructor);\n\t}\n}\n\nglobal.VMError = VMError;\n\n/**\n * Decontextify.\n */\n\nconst Decontextify = host.Object.create(null);\nDecontextify.proxies = new host.WeakMap();\n\nDecontextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new host.Array();\n\n\ttry {\n\t\tconst arr = new host.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Decontextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled expcetion through!\n\t\treturn new host.Array();\n\t}\n};\nDecontextify.instance = (instance, klass, deepTraps, flags) => {\n\tif (typeof instance === 'function') return Decontextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (key === 'constructor') return klass;\n\t\tif (key === '__proto__') return klass.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Decontextify.object(instance, base, deepTraps, flags);\n};\nDecontextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Contextify.value(context);\n\n\t\t// Set context of all arguments to vm's context.\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return host.Function;\n\t\tif (key === '__proto__') return host.Function.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Function.prototype;\n\t};\n\n\tproxy = Decontextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nDecontextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return host.Object;\n\t\tif (key === '__proto__') return host.Object.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tvalue = Contextify.value(value);\n\n\t\ttry {\n\t\t\tobject[key] = value;\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\treturn {\n\t\t\t\tget: Decontextify.value(def.get) || undefined,\n\t\t\t\tset: Decontextify.value(def.set) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: Decontextify.value(def.value),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextyfing local objects.\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Contextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Contextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Contextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\treturn host.Object.defineProperty(target, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new host.Error(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn key in object;\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Object.isExtensible(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\ttry {\n\t\t\tlocal.Object.preventExtensions(object);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(object, host.Object.assign(base, traps, deepTraps));\n\tDecontextify.proxies.set(object, proxy);\n\tDecontextified.set(proxy, object);\n\treturn proxy;\n};\nDecontextify.value = (value, traps, deepTraps, flags, mock) => {\n\tif (Contextified.has(value)) {\n\t\t// Contextified object has returned back from vm\n\t\treturn Contextified.get(value);\n\t} else if (Decontextify.proxies.has(value)) {\n\t\t// Decontextified proxy already exists, reuse\n\t\treturn Decontextify.proxies.get(value);\n\t}\n\n\ttry {\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, Number))         { return host.Number(value);\n\t\t\t\t} else if (instanceOf(value, String))         { return host.String(value);\n\t\t\t\t} else if (instanceOf(value, Boolean))        { return host.Boolean(value);\n\t\t\t\t} else if (instanceOf(value, Date))           { return Decontextify.instance(value, host.Date, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, RangeError))     { return Decontextify.instance(value, host.RangeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, ReferenceError)) { return Decontextify.instance(value, host.ReferenceError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, SyntaxError))    { return Decontextify.instance(value, host.SyntaxError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, TypeError))      { return Decontextify.instance(value, host.TypeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, VMError))        { return Decontextify.instance(value, host.VMError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, EvalError))      { return Decontextify.instance(value, host.EvalError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, URIError))       { return Decontextify.instance(value, host.URIError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Error))          { return Decontextify.instance(value, host.Error, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Array))          { return Decontextify.instance(value, host.Array, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, RegExp))         { return Decontextify.instance(value, host.RegExp, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Map))            { return Decontextify.instance(value, host.Map, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, WeakMap))        { return Decontextify.instance(value, host.WeakMap, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Set))            { return Decontextify.instance(value, host.Set, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, WeakSet))        { return Decontextify.instance(value, host.WeakSet, deepTraps, flags);\n\t\t\t\t} else if (Promise && instanceOf(value, Promise)) { return Decontextify.instance(value, host.Promise, deepTraps, flags);\n\t\t\t\t} else if (local.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Decontextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Decontextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Decontextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\n\n/**\n * Contextify.\n */\n\nconst Contextify = host.Object.create(null);\nContextify.proxies = new host.WeakMap();\n\nContextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new local.Array();\n\n\ttry {\n\t\tconst arr = new local.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Contextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled expcetion through!\n\t\treturn new local.Array();\n\t}\n};\nContextify.instance = (instance, klass, deepTraps, flags) => {\n\tif (typeof instance === 'function') return Contextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (key === 'constructor') return klass;\n\t\tif (key === '__proto__') return klass.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver, true);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver, true);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver, true);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver, true);\n\n\t\ttry {\n\t\t\treturn Contextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Contextify.object(instance, base, deepTraps, flags);\n};\nContextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Decontextify.value(context);\n\n\t\t// Set context of all arguments to host's context.\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new Array(args[0]).fill(0);\n\t\t}\n\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return Function;\n\t\tif (key === '__proto__') return Function.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver, true);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver, true);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver, true);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver, true);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn Function.prototype;\n\t};\n\n\tproxy = Contextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nContextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return Object;\n\t\tif (key === '__proto__') return Object.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver, true);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver, true);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver, true);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver, true);\n\n\t\ttry {\n\t\t\treturn Contextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tif (flags && flags.protected && typeof value === 'function') return false;\n\n\t\tvalue = Decontextify.value(value);\n\n\t\ttry {\n\t\t\tobject[key] = value;\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\treturn {\n\t\t\t\tget: Contextify.value(def.get, null, deepTraps, flags) || undefined,\n\t\t\t\tset: Contextify.value(def.set, null, deepTraps, flags) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: Contextify.value(def.value, null, deepTraps, flags),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextyfing local objects.\n\n\t\tif (flags && flags.protected) {\n\t\t\tif (descriptor.get || descriptor.set || typeof descriptor.value === 'function') return false;\n\t\t}\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Decontextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Decontextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Decontextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\treturn host.Object.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn local.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new VMError(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn key in object;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Object.isExtensible(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\ttry {\n\t\t\thost.Object.preventExtensions(object);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(object, host.Object.assign(base, traps, deepTraps));\n\tContextify.proxies.set(object, proxy);\n\tContextified.set(proxy, object);\n\treturn proxy;\n};\nContextify.value = (value, traps, deepTraps, flags, mock) => {\n\tif (Decontextified.has(value)) {\n\t\t// Decontextified object has returned back to vm\n\t\treturn Decontextified.get(value);\n\t} else if (Contextify.proxies.has(value)) {\n\t\t// Contextified proxy already exists, reuse\n\t\treturn Contextify.proxies.get(value);\n\t}\n\n\ttry {\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, host.Number))         { return host.Number(value);\n\t\t\t\t} else if (instanceOf(value, host.String))         { return host.String(value);\n\t\t\t\t} else if (instanceOf(value, host.Boolean))        { return host.Boolean(value);\n\t\t\t\t} else if (instanceOf(value, host.Date))           { return Contextify.instance(value, Date, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.RangeError))     { return Contextify.instance(value, RangeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.ReferenceError)) { return Contextify.instance(value, ReferenceError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.SyntaxError))    { return Contextify.instance(value, SyntaxError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.TypeError))      { return Contextify.instance(value, TypeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.VMError))        { return Contextify.instance(value, VMError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.EvalError))      { return Contextify.instance(value, EvalError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.URIError))       { return Contextify.instance(value, URIError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Error))          { return Contextify.instance(value, Error, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Array))          { return Contextify.instance(value, Array, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.RegExp))         { return Contextify.instance(value, RegExp, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Map))            { return Contextify.instance(value, Map, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.WeakMap))        { return Contextify.instance(value, WeakMap, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Set))            { return Contextify.instance(value, Set, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.WeakSet))        { return Contextify.instance(value, WeakSet, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Promise))        { return Contextify.instance(value, Promise, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Buffer))         { return Contextify.instance(value, LocalBuffer, deepTraps, flags);\n\t\t\t\t} else if (host.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Contextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Contextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Contextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\nContextify.globalValue = (value, name) => {\n\treturn (global[name] = Contextify.value(value));\n};\nContextify.readonly = (value, mock) => {\n\treturn Contextify.value(value, null, FROZEN_TRAPS, null, mock);\n};\nContextify.protected = (value, mock) => {\n\treturn Contextify.value(value, null, null, {protected: true}, mock);\n};\n\nconst LocalBuffer = global.Buffer = Contextify.readonly(host.Buffer, {\n\tallocUnsafe: function allocUnsafe(size) {\n\t\treturn this.alloc(size);\n\t},\n\tallocUnsafeSlow: function allocUnsafeSlow(size) {\n\t\treturn this.alloc(size);\n\t}\n});\n\nreturn {\n\tContextify,\n\tDecontextify,\n\tBuffer: LocalBuffer\n};\n"], "fixing_code": ["/* global host */\n/* eslint-disable block-spacing, no-multi-spaces, brace-style, no-array-constructor, new-cap, no-use-before-define */\n\n'use strict';\n\n// eslint-disable-next-line no-invalid-this, no-shadow\nconst global = this;\n\nconst local = host.Object.create(null);\nlocal.Object = Object;\nlocal.Array = Array;\nlocal.Reflect = host.Object.create(null);\nlocal.Reflect.ownKeys = Reflect.ownKeys;\nlocal.Reflect.enumerable = Reflect.enumerate;\nlocal.Reflect.getPrototypeOf = Reflect.getPrototypeOf;\n\n// global is originally prototype of host.Object so it can be used to climb up from the sandbox.\nObject.setPrototypeOf(global, Object.prototype);\n\nObject.defineProperties(global, {\n\tglobal: {value: global},\n\tGLOBAL: {value: global},\n\troot: {value: global},\n\tisVM: {value: true}\n});\n\nconst DEBUG = false;\nconst OPNA = 'Operation not allowed on contextified object.';\nconst captureStackTrace = Error.captureStackTrace;\n\nconst FROZEN_TRAPS = host.Object.create(null);\nFROZEN_TRAPS.set = (target, key) => false;\nFROZEN_TRAPS.setPrototypeOf = (target, key) => false;\nFROZEN_TRAPS.defineProperty = (target, key) => false;\nFROZEN_TRAPS.deleteProperty = (target, key) => false;\nFROZEN_TRAPS.isExtensible = (target, key) => false;\nFROZEN_TRAPS.preventExtensions = (target) => false;\n\n// Map of contextified objects to original objects\nconst Contextified = new host.WeakMap();\nconst Decontextified = new host.WeakMap();\n\n// Fake setters make sure we use correctly scoped definer for getter/setter definition\nfunction fakeDefineGetter(receiver, useLocalDefiner) {\n\treturn function __defineGetter__(key, value) {\n\t\t(useLocalDefiner ? local.Object : host.Object).defineProperty(receiver, key, {get: value, enumerable: true, configurable: true});\n\t};\n}\n\nfunction fakeDefineSetter(receiver, useLocalDefiner) {\n\treturn function __defineSetter__(key, value) {\n\t\t(useLocalDefiner ? local.Object : host.Object).defineProperty(receiver, key, {set: value, enumerable: true, configurable: true});\n\t};\n}\n\nfunction fakeLookupGetter(receiver, useLocalLookup) {\n\treturn function __lookupGetter__(key, value) {\n\t\tconst descriptor = (useLocalLookup ? local.Object : host.Object).getOwnPropertyDescriptor(receiver, key);\n\t\treturn descriptor && descriptor.get;\n\t};\n}\n\nfunction fakeLookupSetter(receiver, useLocalLookup) {\n\treturn function __lookupSetter__(key, value) {\n\t\tconst descriptor = (useLocalLookup ? local.Object : host.Object).getOwnPropertyDescriptor(receiver, key);\n\t\treturn descriptor && descriptor.set;\n\t};\n}\n\n// We can't use host's hasInstance method\nconst hasInstance = local.Object[Symbol.hasInstance];\nfunction instanceOf(value, construct) {\n\ttry {\n\t\treturn host.Reflect.apply(hasInstance, construct, [value]);\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through!\n\t\tthrow new VMError('Unable to perform instanceOf check.');\n\t\t// This exception actually never get to the user. It only instructs the caller to return null bacause we wasn't able to perform instanceOf check.\n\t}\n}\n\n/**\n * VMError definition.\n */\n\nclass VMError extends Error {\n\tconstructor(message, code) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\t\tthis.code = code;\n\n\t\tcaptureStackTrace(this, this.constructor);\n\t}\n}\n\nglobal.VMError = VMError;\n\n/**\n * Decontextify.\n */\n\nconst Decontextify = host.Object.create(null);\nDecontextify.proxies = new host.WeakMap();\n\nDecontextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new host.Array();\n\n\ttry {\n\t\tconst arr = new host.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Decontextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled expcetion through!\n\t\treturn new host.Array();\n\t}\n};\nDecontextify.instance = (instance, klass, deepTraps, flags) => {\n\tif (typeof instance === 'function') return Decontextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (key === 'constructor') return klass;\n\t\tif (key === '__proto__') return klass.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Decontextify.object(instance, base, deepTraps, flags);\n};\nDecontextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Contextify.value(context);\n\n\t\t// Set context of all arguments to vm's context.\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\targs = Contextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Decontextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return host.Function;\n\t\tif (key === '__proto__') return host.Function.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Function.prototype;\n\t};\n\n\tproxy = Decontextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nDecontextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return host.Object;\n\t\tif (key === '__proto__') return host.Object.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver);\n\n\t\ttry {\n\t\t\treturn Decontextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tvalue = Contextify.value(value);\n\n\t\ttry {\n\t\t\tobject[key] = value;\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\treturn {\n\t\t\t\tget: Decontextify.value(def.get) || undefined,\n\t\t\t\tset: Decontextify.value(def.set) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: Decontextify.value(def.value),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextyfing local objects.\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Contextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Contextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Contextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\treturn host.Object.defineProperty(target, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn host.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new host.Error(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn key in object;\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Object.isExtensible(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\ttry {\n\t\t\tlocal.Object.preventExtensions(object);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Decontextify.value(local.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Decontextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(object, host.Object.assign(base, traps, deepTraps));\n\tDecontextify.proxies.set(object, proxy);\n\tDecontextified.set(proxy, object);\n\treturn proxy;\n};\nDecontextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Contextified.has(value)) {\n\t\t\t// Contextified object has returned back from vm\n\t\t\treturn Contextified.get(value);\n\t\t} else if (Decontextify.proxies.has(value)) {\n\t\t\t// Decontextified proxy already exists, reuse\n\t\t\treturn Decontextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, Number))         { return host.Number(value);\n\t\t\t\t} else if (instanceOf(value, String))         { return host.String(value);\n\t\t\t\t} else if (instanceOf(value, Boolean))        { return host.Boolean(value);\n\t\t\t\t} else if (instanceOf(value, Date))           { return Decontextify.instance(value, host.Date, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, RangeError))     { return Decontextify.instance(value, host.RangeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, ReferenceError)) { return Decontextify.instance(value, host.ReferenceError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, SyntaxError))    { return Decontextify.instance(value, host.SyntaxError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, TypeError))      { return Decontextify.instance(value, host.TypeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, VMError))        { return Decontextify.instance(value, host.VMError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, EvalError))      { return Decontextify.instance(value, host.EvalError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, URIError))       { return Decontextify.instance(value, host.URIError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Error))          { return Decontextify.instance(value, host.Error, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Array))          { return Decontextify.instance(value, host.Array, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, RegExp))         { return Decontextify.instance(value, host.RegExp, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Map))            { return Decontextify.instance(value, host.Map, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, WeakMap))        { return Decontextify.instance(value, host.WeakMap, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, Set))            { return Decontextify.instance(value, host.Set, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, WeakSet))        { return Decontextify.instance(value, host.WeakSet, deepTraps, flags);\n\t\t\t\t} else if (Promise && instanceOf(value, Promise)) { return Decontextify.instance(value, host.Promise, deepTraps, flags);\n\t\t\t\t} else if (local.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Decontextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Decontextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Decontextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\n\n/**\n * Contextify.\n */\n\nconst Contextify = host.Object.create(null);\nContextify.proxies = new host.WeakMap();\n\nContextify.arguments = args => {\n\tif (!host.Array.isArray(args)) return new local.Array();\n\n\ttry {\n\t\tconst arr = new local.Array();\n\t\tfor (let i = 0, l = args.length; i < l; i++) arr[i] = Contextify.value(args[i]);\n\t\treturn arr;\n\t} catch (e) {\n\t\t// Never pass the handled expcetion through!\n\t\treturn new local.Array();\n\t}\n};\nContextify.instance = (instance, klass, deepTraps, flags) => {\n\tif (typeof instance === 'function') return Contextify.function(instance);\n\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return instance;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (key === 'constructor') return klass;\n\t\tif (key === '__proto__') return klass.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver, true);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver, true);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver, true);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver, true);\n\n\t\ttry {\n\t\t\treturn Contextify.value(instance[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn klass && klass.prototype;\n\t};\n\n\treturn Contextify.object(instance, base, deepTraps, flags);\n};\nContextify.function = (fnc, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\tlet proxy;\n\n\tbase.apply = (target, context, args) => {\n\t\tcontext = Decontextify.value(context);\n\n\t\t// Set context of all arguments to host's context.\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc.apply(context, args));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.construct = (target, args, newTarget) => {\n\t\t// Fixes buffer unsafe allocation for node v6/7\n\t\tif (host.version < 8 && fnc === host.Buffer && 'number' === typeof args[0]) {\n\t\t\targs[0] = new Array(args[0]).fill(0);\n\t\t}\n\n\t\targs = Decontextify.arguments(args);\n\n\t\ttry {\n\t\t\treturn Contextify.instance(new fnc(...args), proxy, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return fnc;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return Function;\n\t\tif (key === '__proto__') return Function.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver, true);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver, true);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver, true);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver, true);\n\n\t\ttry {\n\t\t\treturn Contextify.value(fnc[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn Function.prototype;\n\t};\n\n\tproxy = Contextify.object(fnc, host.Object.assign(base, traps), deepTraps);\n\treturn proxy;\n};\nContextify.object = (object, traps, deepTraps, flags, mock) => {\n\t// We must not use normal object because there's a chance object already contains malicious code in the prototype\n\tconst base = host.Object.create(null);\n\n\tbase.get = (target, key, receiver) => {\n\t\tif (key === 'vmProxyTarget' && DEBUG) return object;\n\t\tif (key === 'isVMProxy') return true;\n\t\tif (mock && host.Object.prototype.hasOwnProperty.call(mock, key)) return mock[key];\n\t\tif (key === 'constructor') return Object;\n\t\tif (key === '__proto__') return Object.prototype;\n\t\tif (key === '__defineGetter__') return fakeDefineGetter(receiver, true);\n\t\tif (key === '__defineSetter__') return fakeDefineSetter(receiver, true);\n\t\tif (key === '__lookupGetter__') return fakeLookupGetter(receiver, true);\n\t\tif (key === '__lookupSetter__') return fakeLookupSetter(receiver, true);\n\n\t\ttry {\n\t\t\treturn Contextify.value(object[key], null, deepTraps, flags);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.set = (target, key, value, receiver) => {\n\t\tif (flags && flags.protected && typeof value === 'function') return false;\n\n\t\tvalue = Decontextify.value(value);\n\n\t\ttry {\n\t\t\tobject[key] = value;\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getOwnPropertyDescriptor = (target, prop) => {\n\t\tlet def;\n\n\t\ttry {\n\t\t\tdef = host.Object.getOwnPropertyDescriptor(object, prop);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\n\t\t// Following code prevents V8 to throw\n\t\t// TypeError: 'getOwnPropertyDescriptor' on proxy: trap reported non-configurability for property '<prop>'\n\t\t// which is either non-existant or configurable in the proxy target\n\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t} else if (def.get || def.set) {\n\t\t\treturn {\n\t\t\t\tget: Contextify.value(def.get, null, deepTraps, flags) || undefined,\n\t\t\t\tset: Contextify.value(def.set, null, deepTraps, flags) || undefined,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tvalue: Contextify.value(def.value, null, deepTraps, flags),\n\t\t\t\twritable: def.writable === true,\n\t\t\t\tenumerable: def.enumerable === true,\n\t\t\t\tconfigurable: def.configurable === true\n\t\t\t};\n\t\t}\n\t};\n\tbase.defineProperty = (target, key, descriptor) => {\n\t\t// There's a chance accessing a property throws an error so we must not access them\n\t\t// in try catch to prevent contextyfing local objects.\n\n\t\tif (flags && flags.protected) {\n\t\t\tif (descriptor.get || descriptor.set || typeof descriptor.value === 'function') return false;\n\t\t}\n\n\t\tconst propertyDescriptor = host.Object.create(null);\n\t\tif (descriptor.get || descriptor.set) {\n\t\t\tpropertyDescriptor.get = Decontextify.value(descriptor.get, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.set = Decontextify.value(descriptor.set, null, deepTraps, flags) || undefined;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t} else {\n\t\t\tpropertyDescriptor.value = Decontextify.value(descriptor.value, null, deepTraps, flags);\n\t\t\tpropertyDescriptor.writable = descriptor.writable === true;\n\t\t\tpropertyDescriptor.enumerable = descriptor.enumerable === true;\n\t\t\tpropertyDescriptor.configurable = descriptor.configurable === true;\n\t\t}\n\n\t\ttry {\n\t\t\treturn host.Object.defineProperty(object, key, propertyDescriptor);\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.getPrototypeOf = (target) => {\n\t\treturn local.Object.prototype;\n\t};\n\tbase.setPrototypeOf = (target) => {\n\t\tthrow new VMError(OPNA);\n\t};\n\tbase.has = (target, key) => {\n\t\ttry {\n\t\t\treturn key in object;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.isExtensible = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Object.isExtensible(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.ownKeys = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.ownKeys(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.preventExtensions = target => {\n\t\ttry {\n\t\t\thost.Object.preventExtensions(object);\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\tbase.enumerate = target => {\n\t\ttry {\n\t\t\treturn Contextify.value(host.Reflect.enumerate(object));\n\t\t} catch (e) {\n\t\t\tthrow Contextify.value(e);\n\t\t}\n\t};\n\n\tconst proxy = new host.Proxy(object, host.Object.assign(base, traps, deepTraps));\n\tContextify.proxies.set(object, proxy);\n\tContextified.set(proxy, object);\n\treturn proxy;\n};\nContextify.value = (value, traps, deepTraps, flags, mock) => {\n\ttry {\n\t\tif (Decontextified.has(value)) {\n\t\t\t// Decontextified object has returned back to vm\n\t\t\treturn Decontextified.get(value);\n\t\t} else if (Contextify.proxies.has(value)) {\n\t\t\t// Contextified proxy already exists, reuse\n\t\t\treturn Contextify.proxies.get(value);\n\t\t}\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (instanceOf(value, host.Number))         { return host.Number(value);\n\t\t\t\t} else if (instanceOf(value, host.String))         { return host.String(value);\n\t\t\t\t} else if (instanceOf(value, host.Boolean))        { return host.Boolean(value);\n\t\t\t\t} else if (instanceOf(value, host.Date))           { return Contextify.instance(value, Date, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.RangeError))     { return Contextify.instance(value, RangeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.ReferenceError)) { return Contextify.instance(value, ReferenceError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.SyntaxError))    { return Contextify.instance(value, SyntaxError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.TypeError))      { return Contextify.instance(value, TypeError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.VMError))        { return Contextify.instance(value, VMError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.EvalError))      { return Contextify.instance(value, EvalError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.URIError))       { return Contextify.instance(value, URIError, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Error))          { return Contextify.instance(value, Error, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Array))          { return Contextify.instance(value, Array, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.RegExp))         { return Contextify.instance(value, RegExp, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Map))            { return Contextify.instance(value, Map, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.WeakMap))        { return Contextify.instance(value, WeakMap, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Set))            { return Contextify.instance(value, Set, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.WeakSet))        { return Contextify.instance(value, WeakSet, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Promise))        { return Contextify.instance(value, Promise, deepTraps, flags);\n\t\t\t\t} else if (instanceOf(value, host.Buffer))         { return Contextify.instance(value, LocalBuffer, deepTraps, flags);\n\t\t\t\t} else if (host.Reflect.getPrototypeOf(value) === null) {\n\t\t\t\t\treturn Contextify.instance(value, null, deepTraps, flags);\n\t\t\t\t} else {\n\t\t\t\t\treturn Contextify.object(value, traps, deepTraps, flags, mock);\n\t\t\t\t}\n\t\t\tcase 'function':\n\t\t\t\treturn Contextify.function(value, traps, deepTraps, flags, mock);\n\n\t\t\tcase 'undefined':\n\t\t\t\treturn undefined;\n\n\t\t\tdefault: // string, number, boolean, symbol\n\t\t\t\treturn value;\n\t\t}\n\t} catch (ex) {\n\t\t// Never pass the handled expcetion through! This block can't throw an exception under normal conditions.\n\t\treturn null;\n\t}\n};\nContextify.globalValue = (value, name) => {\n\treturn (global[name] = Contextify.value(value));\n};\nContextify.readonly = (value, mock) => {\n\treturn Contextify.value(value, null, FROZEN_TRAPS, null, mock);\n};\nContextify.protected = (value, mock) => {\n\treturn Contextify.value(value, null, null, {protected: true}, mock);\n};\n\nconst LocalBuffer = global.Buffer = Contextify.readonly(host.Buffer, {\n\tallocUnsafe: function allocUnsafe(size) {\n\t\treturn this.alloc(size);\n\t},\n\tallocUnsafeSlow: function allocUnsafeSlow(size) {\n\t\treturn this.alloc(size);\n\t}\n});\n\nreturn {\n\tContextify,\n\tDecontextify,\n\tBuffer: LocalBuffer\n};\n"], "filenames": ["lib/contextify.js"], "buggy_code_start_loc": [330], "buggy_code_end_loc": [632], "fixing_code_start_loc": [329], "fixing_code_end_loc": [633], "type": "CWE-674", "message": "This affects the package vm2 before 3.6.11. It is possible to trigger a RangeError exception from the host rather than the \"sandboxed\" context by reaching the stack call limit with an infinite recursion. The returned object is then used to reference the mainModule property of the host code running the script allowing it to spawn a child_process and execute arbitrary code.", "other": {"cve": {"id": "CVE-2019-10761", "sourceIdentifier": "report@snyk.io", "published": "2022-07-13T09:15:08.213", "lastModified": "2022-07-21T10:38:40.383", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "This affects the package vm2 before 3.6.11. It is possible to trigger a RangeError exception from the host rather than the \"sandboxed\" context by reaching the stack call limit with an infinite recursion. The returned object is then used to reference the mainModule property of the host code running the script allowing it to spawn a child_process and execute arbitrary code."}, {"lang": "es", "value": "Esto afecta al paquete vm2 versiones anteriores a 3.6.11. Es posible desencadenar una excepci\u00f3n RangeError desde el host y no desde el contexto \"sandboxed\" alcanzando el l\u00edmite de llamadas de la pila con una recursi\u00f3n infinita. El objeto devuelto se usa entonces para referenciar la propiedad mainModule del c\u00f3digo del host que ejecuta el script permiti\u00e9ndole generar un child_process y ejecutar c\u00f3digo arbitrario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 8.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vm2_project:vm2:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.6.11", "matchCriteriaId": "E1C137CC-088D-4998-BB3A-DD81B2CCCE79"}]}]}], "references": [{"url": "https://github.com/patriksimek/vm2/commit/4b22d704e4794af63a5a2d633385fd20948f6f90", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/patriksimek/vm2/issues/197", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-VM2-473188", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/patriksimek/vm2/commit/4b22d704e4794af63a5a2d633385fd20948f6f90"}}