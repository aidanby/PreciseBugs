{"buggy_code": ["\npackage LedgerSMB::Middleware::AuthenticateSession;\n\n=head1 NAME\n\nLedgerSMB::Middleware::AuthenticateSession - Authentication and sessions\n\n=head1 SYNOPSIS\n\n builder {\n   enable \"+LedgerSMB::Middleware::AuthenticateSession\";\n   $app;\n }\n\n=head1 DESCRIPTION\n\nLedgerSMB::Middleware::AuthenticateSession makes sure a user has been\nauthenticated and a session has been established in all cases the\nworkflow scripts require it.\n\nThis module implements the C<Plack::Middleware> protocol and depends\non the request having been handled by\nLedgerSMB::Middleware::DynamicLoadWorkflow to enhance the C<$env> hash.\n\n\nThe authentication can deal with a number of situations (authentication\nconfigurations):\n\n=over\n\n=item Regular unauthenticated\n\nThe route explicitly requests not to authenticate at all.\n\nThis type of authentication misses the PSGI environment key 'lsmb.want_db'.\n\n=item Regular authenticated\n\nThe route does not specify authentication options, meaning\nfull authentication required. This means a session cookie is available\nwith a database name and auth parameters are available for db connection\nand the session is validated against sessions in the database.\n\nThis type of authentication has the PSGI environment key 'lsmb.want_db'\nbut misses the key 'lsmb.dbonly'.\n\nIn case the company name is missing, the default company configured in\nledgersmb.conf will be used.\n\n=item Database only\n\nThe route explicitly requests not to be handled through a session cookie,\ninstead to authenticate against a database (named as a query or POST parameter)\nwith auth parameters available.\n\nThis type of authentication has both the 'lsmb.want_db' and 'lsmb.dbonly'\nPSGI environment keys.\n\n=back\n\nBoth regular unauthenticated and database only entry points may request\nclearing/ disregarding session cookie information by specifying the\n'lsmb.want_cleared_session' PSGI environment key.\n\n\n\n=cut\n\nuse strict;\nuse warnings;\nuse parent qw ( Plack::Middleware );\n\nuse DBI;\nuse Plack::Request;\nuse Plack::Util;\nuse Plack::Util::Accessor qw( domain );\n\nuse LedgerSMB;\nuse LedgerSMB::Auth;\nuse LedgerSMB::App_State;\nuse LedgerSMB::DBH;\nuse LedgerSMB::PSGI::Util;\nuse LedgerSMB::Sysconfig;\n\n=head1 METHODS\n\n=head2 $self->call($env)\n\nImplements C<Plack::Middleware->call()>.\n\n=cut\n\n\n\nsub call {\n    my $self = shift;\n    my ($env) = @_;\n    my $req = Plack::Request->new($env);\n\n    if (not $env->{'lsmb.want_db'}) {\n        $env->{'lsmb.company'} =\n            $req->parameters->get('database');\n        $env->{'lsmb.auth'} =  LedgerSMB::Auth::factory($env);\n        $env->{'lsmb.auth'}->get_credentials($self->domain,\n                                             $env->{'lsmb.company'});\n        return $self->app->($env)\n    }\n\n    my $cookie_name = LedgerSMB::Sysconfig::cookie_name;\n    my $session_cookie =\n        $env->{'lsmb.want_cleared_session'} ? ''\n        : $req->cookies->{$cookie_name};\n\n    my ($unused_token, $cookie_company);\n    ($env->{'lsmb.session_id'}, $unused_token, $cookie_company) =\n        split(/:/, $session_cookie // '', 3);\n    if (! $env->{'lsmb.dbonly'}\n        && $cookie_company && $cookie_company ne 'Login') {\n        $env->{'lsmb.company'} = $cookie_company;\n    }\n    elsif ($env->{'lsmb.dbonly'}) {\n        $env->{'lsmb.company'} ||=\n            $req->parameters->get('company') ||\n            # temporarily accept a 'database' parameter too,\n            # while we cut over 'setup.pl' in a later commit.\n            $req->parameters->get('database') ||\n            # we fall back to what the cookie has to offer before\n            # falling back to using the default database, because\n            # login.pl::logout() does not require a valid session\n            # and is therefor marked 'dbonly'; it does however require\n            # a session cookie in order to be able to delete the\n            # session from the database indicated by the cookie.\n            $cookie_company ||\n            ###TODO: falling back generally seems like a good idea,\n            # but in case of login.pl::logout() it would seem better\n            # just to report an error...\n            LedgerSMB::Sysconfig::default_db;\n    }\n    return LedgerSMB::PSGI::Util::unauthorized()\n        unless $env->{'lsmb.company'};\n\n    $env->{'lsmb.auth'} = LedgerSMB::Auth::factory($env);\n    my $creds = $env->{'lsmb.auth'}->get_credentials(\n        $self->domain,\n        $env->{'lsmb.company'});\n    return LedgerSMB::PSGI::Util::unauthorized()\n        unless $creds->{login} && $creds->{password};\n    my $dbh = $env->{'lsmb.db'} =\n        LedgerSMB::DBH->connect($env->{'lsmb.company'},\n                                $creds->{login},\n                                $creds->{password});\n\n    if (! defined $dbh) {\n        $env->{'psgix.logger'}->(\n            {\n                level => 'error',\n                msg => q|Unable to create database connection: | . DBI->errstr\n            });\n        return LedgerSMB::PSGI::Util::unauthorized();\n    }\n\n    my $extended_cookie = '';\n    if (! $env->{'lsmb.dbonly'}) {\n        my $version;\n        LedgerSMB::App_State::run_with_state sub {\n            $version = LedgerSMB::DBH->require_version($LedgerSMB::VERSION);\n        }, DBH => $dbh;\n        if ($version) {\n            return LedgerSMB::PSGI::Util::incompatible_database(\n                $LedgerSMB::VERSION, $version);\n        }\n\n        $extended_cookie = _verify_session($env->{'lsmb.db'},\n                                           $env->{'lsmb.company'},\n                                           $session_cookie);\n        if (! $extended_cookie) {\n            $dbh->commit;  # potentially log something\n            $dbh->disconnect;\n\n            return LedgerSMB::PSGI::Util::session_timed_out();\n        }\n\n        # create a session invalidation callback here.\n        $env->{'lsmb.invalidate_session_cb'} = sub {\n            $extended_cookie = _delete_session($dbh, $extended_cookie);\n\n            return $extended_cookie;\n        };\n    }\n    else {\n        # we don't have a session, but the route may want to create one\n        $env->{'lsmb.create_session_cb'} = sub {\n            $extended_cookie =\n                _create_session($dbh, $env->{'lsmb.company'});\n\n            return $extended_cookie;\n        };\n        # we don't have a validated session, but the route may want\n        # to invalidate one if we have one anyway.\n        # create a session invalidation callback here.\n        $env->{'lsmb.invalidate_session_cb'} = sub {\n            $extended_cookie = _delete_session($dbh, $session_cookie);\n\n            return $extended_cookie;\n        };\n    }\n\n    my $res = $self->app->($env);\n    $dbh->rollback;\n    $dbh->disconnect;\n\n    my $secure = ($env->{SERVER_PROTOCOL} eq 'https') ? '; Secure' : '';\n    my $path = LedgerSMB::PSGI::Util::cookie_path($env->{SCRIPT_NAME});\n    return Plack::Util::response_cb(\n        $res, sub {\n            my $res = shift;\n\n            # Set the new cookie (with the extended life-time on response\n            Plack::Util::header_push(\n                $res->[1], 'Set-Cookie',\n                qq|$cookie_name=$extended_cookie; Path=$path$secure; SameSite=Strict|)\n                if $extended_cookie;\n        });\n}\n\n\nsub _verify_session {\n    my ($dbh, $company, $cookie) = @_;\n    my ($session_id, $token, $cookie_company) = split(/:/, $cookie, 3);\n    my ($extended_session) = $dbh->selectall_array(\n        q{SELECT * FROM session_check(?, ?)}, { Slice => {} },\n        $session_id, $token) or die $dbh->errstr;\n    $dbh->commit if $extended_session->{session_id};\n\n    return _session_to_cookie_value($extended_session, $company);\n}\n\nsub _create_session {\n    my ($dbh, $company) = @_;\n\n    my ($created_session) = $dbh->selectall_array(\n        q{SELECT * FROM session_create();}, { Slice => {} },\n        ) or die $dbh->errstr;\n    $dbh->commit if $created_session->{session_id};\n\n    return _session_to_cookie_value($created_session, $company);\n}\n\nsub _delete_session {\n    my ($dbh, $cookie) = @_;\n    my ($session_id, $token, $cookie_company) = split(/:/, $cookie, 3);\n\n    $dbh->selectall_array(q{SELECT session_delete(?)}, {}, $session_id)\n        or die $dbh->errstr;\n\n    return 'Login';\n}\n\nsub _session_to_cookie_value {\n    my ($session, $company) = @_;\n\n    return $session->{session_id} ?\n        join(':', $session->{session_id}, $session->{token}, $company) : '';\n}\n\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2017 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n"], "fixing_code": ["\npackage LedgerSMB::Middleware::AuthenticateSession;\n\n=head1 NAME\n\nLedgerSMB::Middleware::AuthenticateSession - Authentication and sessions\n\n=head1 SYNOPSIS\n\n builder {\n   enable \"+LedgerSMB::Middleware::AuthenticateSession\";\n   $app;\n }\n\n=head1 DESCRIPTION\n\nLedgerSMB::Middleware::AuthenticateSession makes sure a user has been\nauthenticated and a session has been established in all cases the\nworkflow scripts require it.\n\nThis module implements the C<Plack::Middleware> protocol and depends\non the request having been handled by\nLedgerSMB::Middleware::DynamicLoadWorkflow to enhance the C<$env> hash.\n\n\nThe authentication can deal with a number of situations (authentication\nconfigurations):\n\n=over\n\n=item Regular unauthenticated\n\nThe route explicitly requests not to authenticate at all.\n\nThis type of authentication misses the PSGI environment key 'lsmb.want_db'.\n\n=item Regular authenticated\n\nThe route does not specify authentication options, meaning\nfull authentication required. This means a session cookie is available\nwith a database name and auth parameters are available for db connection\nand the session is validated against sessions in the database.\n\nThis type of authentication has the PSGI environment key 'lsmb.want_db'\nbut misses the key 'lsmb.dbonly'.\n\nIn case the company name is missing, the default company configured in\nledgersmb.conf will be used.\n\n=item Database only\n\nThe route explicitly requests not to be handled through a session cookie,\ninstead to authenticate against a database (named as a query or POST parameter)\nwith auth parameters available.\n\nThis type of authentication has both the 'lsmb.want_db' and 'lsmb.dbonly'\nPSGI environment keys.\n\n=back\n\nBoth regular unauthenticated and database only entry points may request\nclearing/ disregarding session cookie information by specifying the\n'lsmb.want_cleared_session' PSGI environment key.\n\n\n\n=cut\n\nuse strict;\nuse warnings;\nuse parent qw ( Plack::Middleware );\n\nuse DBI;\nuse Plack::Request;\nuse Plack::Util;\nuse Plack::Util::Accessor qw( domain );\n\nuse LedgerSMB;\nuse LedgerSMB::Auth;\nuse LedgerSMB::App_State;\nuse LedgerSMB::DBH;\nuse LedgerSMB::PSGI::Util;\nuse LedgerSMB::Sysconfig;\n\n=head1 METHODS\n\n=head2 $self->call($env)\n\nImplements C<Plack::Middleware->call()>.\n\n=cut\n\n\n\nsub call {\n    my $self = shift;\n    my ($env) = @_;\n    my $req = Plack::Request->new($env);\n\n    if (not $env->{'lsmb.want_db'}) {\n        $env->{'lsmb.company'} =\n            $req->parameters->get('database');\n        $env->{'lsmb.auth'} =  LedgerSMB::Auth::factory($env);\n        $env->{'lsmb.auth'}->get_credentials($self->domain,\n                                             $env->{'lsmb.company'});\n        return $self->app->($env)\n    }\n\n    my $cookie_name = LedgerSMB::Sysconfig::cookie_name;\n    my $session_cookie =\n        $env->{'lsmb.want_cleared_session'} ? ''\n        : $req->cookies->{$cookie_name};\n\n    my ($unused_token, $cookie_company);\n    ($env->{'lsmb.session_id'}, $unused_token, $cookie_company) =\n        split(/:/, $session_cookie // '', 3);\n    if (! $env->{'lsmb.dbonly'}\n        && $cookie_company && $cookie_company ne 'Login') {\n        $env->{'lsmb.company'} = $cookie_company;\n    }\n    elsif ($env->{'lsmb.dbonly'}) {\n        $env->{'lsmb.company'} ||=\n            $req->parameters->get('company') ||\n            # temporarily accept a 'database' parameter too,\n            # while we cut over 'setup.pl' in a later commit.\n            $req->parameters->get('database') ||\n            # we fall back to what the cookie has to offer before\n            # falling back to using the default database, because\n            # login.pl::logout() does not require a valid session\n            # and is therefor marked 'dbonly'; it does however require\n            # a session cookie in order to be able to delete the\n            # session from the database indicated by the cookie.\n            $cookie_company ||\n            ###TODO: falling back generally seems like a good idea,\n            # but in case of login.pl::logout() it would seem better\n            # just to report an error...\n            LedgerSMB::Sysconfig::default_db;\n    }\n    return LedgerSMB::PSGI::Util::unauthorized()\n        unless $env->{'lsmb.company'};\n\n    $env->{'lsmb.auth'} = LedgerSMB::Auth::factory($env);\n    my $creds = $env->{'lsmb.auth'}->get_credentials(\n        $self->domain,\n        $env->{'lsmb.company'});\n    return LedgerSMB::PSGI::Util::unauthorized()\n        unless $creds->{login} && $creds->{password};\n    my $dbh = $env->{'lsmb.db'} =\n        LedgerSMB::DBH->connect($env->{'lsmb.company'},\n                                $creds->{login},\n                                $creds->{password});\n\n    if (! defined $dbh) {\n        $env->{'psgix.logger'}->(\n            {\n                level => 'error',\n                msg => q|Unable to create database connection: | . DBI->errstr\n            });\n        return LedgerSMB::PSGI::Util::unauthorized();\n    }\n\n    my $extended_cookie = '';\n    if (! $env->{'lsmb.dbonly'}) {\n        my $version;\n        LedgerSMB::App_State::run_with_state sub {\n            $version = LedgerSMB::DBH->require_version($LedgerSMB::VERSION);\n        }, DBH => $dbh;\n        if ($version) {\n            return LedgerSMB::PSGI::Util::incompatible_database(\n                $LedgerSMB::VERSION, $version);\n        }\n\n        $extended_cookie = _verify_session($env->{'lsmb.db'},\n                                           $env->{'lsmb.company'},\n                                           $session_cookie);\n        if (! $extended_cookie) {\n            $dbh->commit;  # potentially log something\n            $dbh->disconnect;\n\n            return LedgerSMB::PSGI::Util::session_timed_out();\n        }\n\n        # create a session invalidation callback here.\n        $env->{'lsmb.invalidate_session_cb'} = sub {\n            $extended_cookie = _delete_session($dbh, $extended_cookie);\n\n            return $extended_cookie;\n        };\n    }\n    else {\n        # we don't have a session, but the route may want to create one\n        $env->{'lsmb.create_session_cb'} = sub {\n            $extended_cookie =\n                _create_session($dbh, $env->{'lsmb.company'});\n\n            return $extended_cookie;\n        };\n        # we don't have a validated session, but the route may want\n        # to invalidate one if we have one anyway.\n        # create a session invalidation callback here.\n        $env->{'lsmb.invalidate_session_cb'} = sub {\n            $extended_cookie = _delete_session($dbh, $session_cookie);\n\n            return $extended_cookie;\n        };\n    }\n\n    my $res = $self->app->($env);\n    $dbh->rollback;\n    $dbh->disconnect;\n\n    my $secure = ($env->{HTTPS} eq 'ON') ? '; Secure' : '';\n    my $path = LedgerSMB::PSGI::Util::cookie_path($env->{SCRIPT_NAME});\n    return Plack::Util::response_cb(\n        $res, sub {\n            my $res = shift;\n\n            # Set the new cookie (with the extended life-time on response\n            Plack::Util::header_push(\n                $res->[1], 'Set-Cookie',\n                qq|$cookie_name=$extended_cookie; Path=$path$secure; SameSite=Strict|)\n                if $extended_cookie;\n        });\n}\n\n\nsub _verify_session {\n    my ($dbh, $company, $cookie) = @_;\n    my ($session_id, $token, $cookie_company) = split(/:/, $cookie, 3);\n    my ($extended_session) = $dbh->selectall_array(\n        q{SELECT * FROM session_check(?, ?)}, { Slice => {} },\n        $session_id, $token) or die $dbh->errstr;\n    $dbh->commit if $extended_session->{session_id};\n\n    return _session_to_cookie_value($extended_session, $company);\n}\n\nsub _create_session {\n    my ($dbh, $company) = @_;\n\n    my ($created_session) = $dbh->selectall_array(\n        q{SELECT * FROM session_create();}, { Slice => {} },\n        ) or die $dbh->errstr;\n    $dbh->commit if $created_session->{session_id};\n\n    return _session_to_cookie_value($created_session, $company);\n}\n\nsub _delete_session {\n    my ($dbh, $cookie) = @_;\n    my ($session_id, $token, $cookie_company) = split(/:/, $cookie, 3);\n\n    $dbh->selectall_array(q{SELECT session_delete(?)}, {}, $session_id)\n        or die $dbh->errstr;\n\n    return 'Login';\n}\n\nsub _session_to_cookie_value {\n    my ($session, $company) = @_;\n\n    return $session->{session_id} ?\n        join(':', $session->{session_id}, $session->{token}, $company) : '';\n}\n\n\n=head1 LICENSE AND COPYRIGHT\n\nCopyright (C) 2017 The LedgerSMB Core Team\n\nThis file is licensed under the GNU General Public License version 2, or at your\noption any later version.  A copy of the license should have been included with\nyour software.\n\n=cut\n\n\n1;\n"], "filenames": ["lib/LedgerSMB/Middleware/AuthenticateSession.pm"], "buggy_code_start_loc": [212], "buggy_code_end_loc": [213], "fixing_code_start_loc": [212], "fixing_code_end_loc": [213], "type": "CWE-311", "message": "LedgerSMB does not set the 'Secure' attribute on the session authorization cookie when the client uses HTTPS and the LedgerSMB server is behind a reverse proxy. By tricking a user to use an unencrypted connection (HTTP), an attacker may be able to obtain the authentication data by capturing network traffic. LedgerSMB 1.8 and newer switched from Basic authentication to using cookie authentication with encrypted cookies. Although an attacker can't access the information inside the cookie, nor the password of the user, possession of the cookie is enough to access the application as the user from which the cookie has been obtained. In order for the attacker to obtain the cookie, first of all the server must be configured to respond to unencrypted requests, the attacker must be suitably positioned to eavesdrop on the network traffic between the client and the server *and* the user must be tricked into using unencrypted HTTP traffic. Proper audit control and separation of duties limit Integrity impact of the attack vector. Users of LedgerSMB 1.8 are urged to upgrade to known-fixed versions. Users of LedgerSMB 1.7 or 1.9 are unaffected by this vulnerability and don't need to take action. As a workaround, users may configure their Apache or Nginx reverse proxy to add the Secure attribute at the network boundary instead of relying on LedgerSMB. For Apache, please refer to the 'Header always edit' configuration command in the mod_headers module. For Nginx, please refer to the 'proxy_cookie_flags' configuration command.", "other": {"cve": {"id": "CVE-2021-3882", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-14T09:15:08.427", "lastModified": "2022-10-27T13:04:07.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LedgerSMB does not set the 'Secure' attribute on the session authorization cookie when the client uses HTTPS and the LedgerSMB server is behind a reverse proxy. By tricking a user to use an unencrypted connection (HTTP), an attacker may be able to obtain the authentication data by capturing network traffic. LedgerSMB 1.8 and newer switched from Basic authentication to using cookie authentication with encrypted cookies. Although an attacker can't access the information inside the cookie, nor the password of the user, possession of the cookie is enough to access the application as the user from which the cookie has been obtained. In order for the attacker to obtain the cookie, first of all the server must be configured to respond to unencrypted requests, the attacker must be suitably positioned to eavesdrop on the network traffic between the client and the server *and* the user must be tricked into using unencrypted HTTP traffic. Proper audit control and separation of duties limit Integrity impact of the attack vector. Users of LedgerSMB 1.8 are urged to upgrade to known-fixed versions. Users of LedgerSMB 1.7 or 1.9 are unaffected by this vulnerability and don't need to take action. As a workaround, users may configure their Apache or Nginx reverse proxy to add the Secure attribute at the network boundary instead of relying on LedgerSMB. For Apache, please refer to the 'Header always edit' configuration command in the mod_headers module. For Nginx, please refer to the 'proxy_cookie_flags' configuration command."}, {"lang": "es", "value": "LedgerSMB no establece el atributo \"Secure\" en la cookie de autorizaci\u00f3n de sesi\u00f3n cuando el cliente usa HTTPS y el servidor LedgerSMB est\u00e1 detr\u00e1s de un proxy inverso. Al enga\u00f1ar a un usuario para que use una conexi\u00f3n no cifrada (HTTP), un atacante puede ser capaz de obtener los datos de autenticaci\u00f3n capturando el tr\u00e1fico de la red. LedgerSMB versiones 1.8 y m\u00e1s recientes, cambiaron de la autenticaci\u00f3n B\u00e1sica a un uso de la autenticaci\u00f3n con cookies cifradas. Aunque un atacante no puede acceder a la informaci\u00f3n dentro de la cookie, ni a la contrase\u00f1a del usuario, la posesi\u00f3n de la cookie es suficiente para acceder a la aplicaci\u00f3n como el usuario del que se ha obtenido la cookie. Para que el atacante obtenga la cookie, en primer lugar el servidor debe estar configurado para responder a peticiones no cifradas, el atacante debe estar convenientemente posicionado para espiar el tr\u00e1fico de red entre el cliente y el servidor *y* el usuario debe ser enga\u00f1ado para usar tr\u00e1fico HTTP no cifrado. Un control de auditor\u00eda apropiado y la separaci\u00f3n de funciones limitan el impacto de la integridad del vector de ataque. Se insta a usuarios de LedgerSMB 1.8 a que se actualicen a las versiones corregidas conocidas. Los usuarios de LedgerSMB versiones 1.7 o 1.9 no est\u00e1n afectados por esta vulnerabilidad y no necesitan tomar medidas. Como soluci\u00f3n, los usuarios pueden configurar su proxy inverso Apache o Nginx para a\u00f1adir el atributo Secure en el l\u00edmite de la red en lugar de confiar en LedgerSMB. Para Apache, consulte el comando de configuraci\u00f3n \"Header always edit\" en el m\u00f3dulo mod_headers. Para Nginx, consulte el comando de configuraci\u00f3n \"proxy_cookie_flags\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 4.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-311"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-614"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ledgersmb:ledgersmb:1.8.0:-:*:*:*:*:*:*", "matchCriteriaId": "A2CC6F62-AA97-4E51-A8AD-39EA265C0067"}]}]}], "references": [{"url": "https://github.com/ledgersmb/ledgersmb/commit/c242f5a2abf4b99b0da205473cbba034f306bfe2", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7061d97a-98a5-495a-8ba0-3a4c66091e9d", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://ledgersmb.org/cve-2021-3882-sensitive-non-secure-cookie", "source": "security@huntr.dev", "tags": ["Broken Link"]}]}, "github_commit_url": "https://github.com/ledgersmb/ledgersmb/commit/c242f5a2abf4b99b0da205473cbba034f306bfe2"}}