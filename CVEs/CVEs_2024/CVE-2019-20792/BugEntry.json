{"buggy_code": ["/*\n * card-coolkey.c: Support for Coolkey\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005,2006,2007,2008,2009,2010 Douglas E. Engert <deengert@anl.gov>\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <thomas.harning@identityalliance.com>\n * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>\n * Copyright (C) 2016, Red Hat, Inc.\n *\n * Coolkey driver author: Robert Relyea <rrelyea@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#include <sys/types.h>\n\n#ifdef ENABLE_OPENSSL\n\t/* openssl only needed for card administration */\n#include <openssl/evp.h>\n#include <openssl/bio.h>\n#include <openssl/pem.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#endif /* ENABLE_OPENSSL */\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#ifdef ENABLE_ZLIB\n#include \"compression.h\"\n#endif\n#include \"iso7816.h\"\n#include \"gp.h\"\n#include \"../pkcs11/pkcs11.h\"\n\n\n\n#define COOLKEY_MAX_SIZE 4096\t\t/* arbitrary, just needs to be 'large enough' */\n\n/*\n *  COOLKEY hardware and APDU constants\n */\n#define COOLKEY_MAX_CHUNK_SIZE 240 /* must be less than 255-8 */\n\n/* ISO 7816 CLA values used by COOLKEY */\n#define ISO7816_CLASS           0x00\n#define COOLKEY_CLASS           0xb0\n\n/* ISO 71816 INS values used by COOLKEY */\n#define ISO7816_INS_SELECT_FILE 0xa4\n\n/* COOLKEY specific INS values (public) */\n#define COOLKEY_INS_GET_LIFE_CYCLE             0xf2\n#define COOLKEY_INS_GET_STATUS                 0x3c\n#define COOLKEY_INS_VERIFY_PIN                 0x42\n#define COOLKEY_INS_LIST_OBJECTS               0x58\n\n/* COOLKEY specific INS values (require nonce) */\n#define COOLKEY_INS_COMPUTE_CRYPT              0x36\n#define COOLKEY_INS_COMPUTE_ECC_KEY_AGREEMENT  0x37\n#define COOLKEY_INS_COMPUTE_ECC_SIGNATURE      0x38\n#define COOLKEY_INS_GET_RANDOM                 0x72\n#define COOLKEY_INS_READ_OBJECT                0x56\n#define COOLKEY_INS_WRITE_OBJECT               0x54\n#define COOLKEY_INS_LOGOUT                     0x61\n\n/* COMPUTE_CRYPT and COMPUT_ECC parameters */\n#define COOLKEY_CRYPT_INIT     1\n#define COOLKEY_CRYPT_PROCESS  2\n#define COOLKEY_CRYPT_FINAL    3\n#define COOLKEY_CRYPT_ONE_STEP 4\n\n#define COOLKEY_CRYPT_MODE_RSA_NO_PAD    0x00\n#define COOLKEY_CRYPT_LOCATION_APDU      0x01\n#define COOLKEY_CRYPT_LOCATION_DL_OBJECT 0x02\n#define COOLKEY_CRYPT_DIRECTION_ENCRYPT  0x03\n\n/* List Objects parameters */\n#define COOLKEY_LIST_RESET 0x00\n#define COOLKEY_LIST_NEXT  0x01\n\n/* Special object identifiers */\n#define COOLKEY_DL_OBJECT_ID       0xffffffff\n#define COOLKEY_COMBINED_OBJECT_ID 0x7a300000 /* 'z0\\0\\0' */\n#define COOLKEY_INVALID_KEY        0xff00\n#define COOLKEY_KEY_CLASS\t\t\t'k'\n#define COOLKEY_NONCE_SIZE  8\n\n/* returned from the coolkey extended life cycle apdu */\ntypedef struct coolkey_life_cycle {\n\tu8 life_cycle;\n\tu8 pin_count;\n\tu8 protocol_version_major;\n\tu8 protocol_version_minor;\n} coolkey_life_cycle_t;\n\n/* return by the coolkey status apdu */\ntypedef struct coolkey_status {\n\tu8 protocol_version_major;\n\tu8 protocol_version_minor;\n\tu8 applet_major_version;\n\tu8 applet_minor_version;\n\tu8 total_object_memory[4];\n\tu8 free_object_memory[4];\n\tu8 pin_count;\n\tu8 key_count;\n\tu8 logged_in_identities[2];\n} coolkey_status_t;\n\n/* format of the coolkey_cuid, either constructed from cplc data or read from the combined object */\ntypedef struct coolkey_cuid {\n\tu8 ic_fabricator[2];\n\tu8 ic_type[2];\n\tu8 ic_batch[2];\n\tu8 ic_serial_number[4];\n} coolkey_cuid_t;\n\n/* parameter for list objects apdu */\ntypedef struct coolkey_object_info {\n\tu8 object_id[4];\n\tu8 object_length[4];\n\tu8 read_acl[2];\n\tu8 write_acl[2];\n\tu8 delete_acl[2];\n} coolkey_object_info_t;\n\n/* parameter for the read object apdu */\ntypedef struct coolkey_read_object_param {\n\tu8 object_id[4];\n\tu8 offset[4];\n\tu8 length;\n} coolkey_read_object_param_t;\n\n/* parameter for the write object apdu */\ntypedef struct coolkey_write_object_param {\n\tcoolkey_read_object_param_t head;\n\tu8 buf[COOLKEY_MAX_CHUNK_SIZE];\n} coolkey_write_object_param_t;\n\n/* coolkey uses muscle like objects, but when coolkey is managed by the TPS system\n * it creates a single object and encodes the individual objects inside the\n * common single object. This allows more efficient reading of all the objects\n * (because we can use a single apdu call and we can compress all the objects\n * together and take advantage of the fact that many of the certs share the same subject and issue). */\ntypedef struct coolkey_combined_header {\n\tu8\tformat_version[2];\n\tu8\tobject_version[2];\n\tcoolkey_cuid_t cuid;\n\tu8\tcompression_type[2];\n\tu8\tcompression_length[2];\n\tu8\tcompression_offset[2];\n} coolkey_combined_header_t;\n\n#define COOLKEY_COMPRESSION_NONE 0\n#define COOLKEY_COMPRESSION_ZLIB 1\n\n/*\n * This is the header of the decompressed portion of the combined object\n */\ntypedef struct coolkey_decompressed_header {\n\tu8 object_offset[2];\n\tu8 object_count[2];\n\tu8 token_name_length;\n\tu8 token_name[255];      /* arbitrary size up to token_name_length */\n} coolkey_decompressed_header_t;\n\n/*\n * header for an object. There are 2 types of object headers, v1 and v0.\n * v1 is the most common, and is always found in a combined object, so\n * we only specify the v0 in the name of the structure.\n */\n\ntypedef struct coolkey_v0_object_header {\n\tu8 record_type;\t\t\t\t /* version 0 or version 1 */\n\tu8 object_id[4]; \t\t\t /*  coolkey object id  */\n\tu8 attribute_data_len[2];    /* the length in bytes of the next block of\n\t\t\t\t\t\t\t\t  * attribute records */\n\t/* followed by the first attribute record */\n} coolkey_v0_object_header_t;\n\ntypedef struct coolkey_v0_attribute_header {\n\tu8 attribute_attr_type[4];\t/* CKA_ATTRIBUTE_TYPE */\n\tu8 attribute_data_len[2];\t/* Length of the attribute */\n\t/* followed by the actual attribute data */\n} coolkey_v0_attribute_header_t;\n\n/* combined objects are v1 objects without the record_type indicator */\ntypedef struct coolkey_combined_object_header {\n\tu8 object_id[4]; \t\t\t /*  coolkey object id  */\n\tu8 fixed_attributes_values[4]; /* compressed fixed attributes */\n\tu8 attribute_count[2];\t\t/* the number of attribute records that follow */\n\t/* followed by the first attribute */\n} coolkey_combined_object_header_t;\n\ntypedef struct coolkey_object_header {\n\tu8 record_type;\t\t\t\t/* version 0 or version 1 */\n\tu8 object_id[4]; \t\t\t /*  coolkey object id  */\n\tu8 fixed_attributes_values[4]; /* compressed fixed attributes */\n\tu8 attribute_count[2];\t\t/* the number of attribute records that follow */\n\t/* followed by the first attribute */\n} coolkey_object_header_t;\n\n#define COOLKEY_V0_OBJECT 0\n#define COOLKEY_V1_OBJECT 1\n\n/* vi attribute header */\ntypedef struct coolkey_attribute_header {\n\tu8 attribute_attr_type[4]; /* CKA_ATTRIBUTE_TYPE */\n\tu8 attribute_data_type;    /* the Type of data stored */\n\t/* optional attribute data, or attribute len+data, depending on the value of data_type */\n} coolkey_attribute_header_t;\n\n/* values for attribute_data_type */\n#define COOLKEY_ATTR_TYPE_STRING      0\n#define COOLKEY_ATTR_TYPE_INTEGER     1\n#define COOLKEY_ATTR_TYPE_BOOL_FALSE  2\n#define COOLKEY_ATTR_TYPE_BOOL_TRUE   3\n\n/*\n * format of the fix_attribute values. These are stored as a big endian uint32_t with the below bit field\n * Definitions:\n *\nstruct coolkey_fixed_attributes_values {\n\tuint32_t  cka_id:4;\n\tuint32_t  cka_class:3;\n\tuint32_t  cka_token:1;\n\tuint32_t  cka_private:1;\n\tuint32_t  cka_modifiable:1;\n\tuint32_t  cka_derive:1;\n\tuint32_t  cka_local:1;\n\tuint32_t  cka_encrypt:1;\n\tuint32_t  cka_decrypt:1;\n\tuint32_t  cka_wrap:1;\n\tuint32_t  cka_unwrap:1;\n\tuint32_t  cka_sign:1;\n\tuint32_t  cka_sign_recover:1;\n\tuint32_t  cka_verify:1;\n\tuint32_t  cka_verify_recover:1;\n\tuint32_t  cka_sensitive:1;\n\tuint32_t  cka_always_sensitive:1;\n\tuint32_t  cka_extractable:1;\n\tuint32_t  cka_never_extractable:1;\n\tuint32_t  reserved:8;\n};\n\n *  cka_class is used to determine which booleans are valid. Any attributes in the full attribute list\n *  takes precedence over the fixed attributes. That is if there is a CKA_ID in the full attribute list,\n *  The cka_id in the fixed_attributes is ignored. When determining which boolean attribute is valid, the\n *  cka_class in the fixed attributes are used, even if it is overridden by the  full attribute list.\n * valid cka_class values and their corresponding valid bools are as follows:\n *\n *     0 CKO_DATA                          cka_private, cka_modifiable, cka_token\n *     1 CKO_CERTIFICATE                   cka_private, cka_modifiable, cka_token\n *     2 CKO_PUBLIC_KEY                    cka_private, cka_modifiable, cka_token\n *                                         cka_derive, cka_local, cka_encrypt, cka_wrap\n *                                         cka_verify, cka_verify_recover\n *     3 CKO_PRIVATE_KEY                   cka_private, cka_modifiable, cka_token\n *                                         cka_derive, cka_local, cka_decrypt, cka_unwrap\n *                                         cka_sign, cka_sign_recover, cka_sensitive,\n *                                         cka_always_sensitive, cka_extractable,\n *                                         cka_never_extractable\n *     4 CKO_SECRET_KEY                    cka_private, cka_modifiable, cka_token\n *                                         cka_derive, cka_local, cka_encrypt, cka_decrypt,\n *                                         cka_wrap, cka_unwrap, cka_sign, cka_verify,\n *                                         cka_sensitive, cka_always_sensitive,\n *                                         cka_extractable, cka_never_extractable\n *     5-7 RESERVED                        none\n *\n */\n\n/*\n * Coolkey attribute record handling functions.\n */\n\n/* get the length of the attribute from a V1 attribute header. If encoded_len == true, then return the length of\n * the attribute data field (including any explicit length values, If encoded_len = false return the length of\n * the actual attribute data.\n */\nstatic int\ncoolkey_v1_get_attribute_len(const u8 *attr, size_t buf_len, size_t *len, int encoded_len)\n{\n\tcoolkey_attribute_header_t *attribute_head = (coolkey_attribute_header_t *)attr;\n\n\t*len = 0;\n\t/* don't reference beyond our buffer */\n\tif (buf_len < sizeof(coolkey_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tswitch (attribute_head->attribute_data_type) {\n\tcase COOLKEY_ATTR_TYPE_STRING:\n\t\tif (buf_len < (sizeof(coolkey_attribute_header_t) +2)) {\n\t\t\tbreak;\n\t\t}\n\t\t*len = bebytes2ushort(attr + sizeof(coolkey_attribute_header_t));\n\t\tif (encoded_len) {\n\t\t\t*len += 2;\n\t\t}\n\t\treturn SC_SUCCESS;\n\tcase COOLKEY_ATTR_TYPE_BOOL_FALSE:\n\tcase COOLKEY_ATTR_TYPE_BOOL_TRUE:\n\t\t/* NOTE: there is no encoded data from TYPE_BOOL_XXX, so we return length 0, but the length\n\t\t * of the attribute is actually 1 byte, so if encoded_len == false, return 1 */\n\t\t*len = encoded_len ? 0: 1;\n\t\treturn SC_SUCCESS;\n\t\tbreak;\n\tcase COOLKEY_ATTR_TYPE_INTEGER:\n\t\t*len = 4; /* length is 4 in both encoded length and attribute length */\n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn SC_ERROR_CORRUPTED_DATA;\n}\n\n/* length of the attribute data is stored in the header of the v0 record */\nstatic int\ncoolkey_v0_get_attribute_len(const u8 *attr, size_t buf_len, size_t *len)\n{\n\tcoolkey_v0_attribute_header_t *attribute_head = (coolkey_v0_attribute_header_t *)attr;\n\t/* don't reference beyond our buffer */\n\tif (buf_len < sizeof(coolkey_v0_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\t*len = bebytes2ushort(attribute_head->attribute_data_len);\n\treturn SC_SUCCESS;\n}\n\n/* these next 3 functions gets the length of the full attribute record, including\n * the attribute header */\nstatic size_t\ncoolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; /* skip to the end, ignore the rest of the record */\n\t}\n\n\treturn MIN(buf_len,attribute_len+len);\n}\n\n\nstatic size_t\ncoolkey_v0_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_v0_attribute_header_t);\n\tsize_t len;\n\tint r;\n\n\tr = coolkey_v0_get_attribute_len(attr, buf_len, &len);\n\tif (r < 0) {\n\t\treturn buf_len; /* skip to the end, ignore the rest of the record */\n\t}\n\treturn MIN(buf_len,attribute_len+len);\n}\n\nstatic size_t\ncoolkey_get_attribute_record_len(const u8 *attr, u8 obj_record_type, size_t buf_len)\n{\n\tif (obj_record_type ==  COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_record_len(attr, buf_len);\n\t}\n\tif (obj_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn buf_len; /* skip to the end */\n\t}\n\treturn coolkey_v1_get_attribute_record_len(attr, buf_len);\n}\n\n/*\n * Attribute type shows up in the same place in all attribute record types. Carry record_type in case\n * this changes in the future.\n */\nstatic CK_ATTRIBUTE_TYPE\ncoolkey_get_attribute_type(const u8 *attr, u8 obj_record_type, size_t buf_len)\n{\n\tcoolkey_attribute_header_t *attribute_header = (coolkey_attribute_header_t *) attr;\n\n\treturn bebytes2ulong(attribute_header->attribute_attr_type);\n}\n\n/*\n * return the start of the attribute section based on the record type\n */\nstatic const u8 *\ncoolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}\n\n/*\n * We don't have the count in the header for v0 attributes,\n * Count them.\n */\nstatic int\ncoolkey_v0_get_attribute_count(const u8 *obj, size_t buf_len)\n{\n\tcoolkey_v0_object_header_t *object_head = (coolkey_v0_object_header_t *)obj;\n\tconst u8 *attr;\n\tint count = 0;\n\tsize_t attribute_data_len;\n\n\t/* make sure we have enough of the object to read the record_type */\n\tif (buf_len <= sizeof(coolkey_v0_object_header_t)) {\n\t\treturn 0;\n\t}\n\t/*\n\t * now loop through all the attributes in the list. first find the start of the list\n\t */\n\tattr = coolkey_attribute_start(obj, COOLKEY_V0_OBJECT, buf_len);\n\tif (attr == NULL) {\n\t\treturn 0;\n\t}\n\n\tbuf_len -= (attr-obj);\n\tattribute_data_len = bebytes2ushort(object_head->attribute_data_len);\n\tif (buf_len < attribute_data_len) {\n\t\treturn 0;\n\t}\n\n\twhile (attribute_data_len) {\n\t\tsize_t len = coolkey_v0_get_attribute_record_len(attr, buf_len);\n\n\t\tif (len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/*  This is an error in the token data, don't parse the last attribute */\n\t\tif (len > attribute_data_len) {\n\t\t\tbreak;\n\t\t}\n\t\t/* we know that coolkey_v0_get_attribute_record_len never\n\t\t * \treturns more than buf_len, so we can safely assert that.\n\t\t * \tIf the assert is true, you can easily see that the loop\n\t\t * \twill eventually break with len == 0, even if attribute_data_len\n\t\t * \twas invalid */\n\t\tassert(len <= buf_len);\n\t\tcount++;\n\t\tattr += len;\n\t\tbuf_len -= len;\n\t\tattribute_data_len -= len;\n\t}\n\treturn count;\n}\n\nstatic int\ncoolkey_v1_get_attribute_count(const u8 *obj, size_t buf_len)\n{\n\tcoolkey_object_header_t *object_head = (coolkey_object_header_t *)obj;\n\n\tif (buf_len <= sizeof(coolkey_object_header_t)) {\n\t\treturn 0;\n\t}\n\treturn bebytes2ushort(object_head->attribute_count);\n}\n\nstatic int\ncoolkey_get_attribute_count(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tif (object_record_type == COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_count(obj, buf_len);\n\t}\n\tif (object_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn 0;\n\t}\n\treturn coolkey_v1_get_attribute_count(obj, buf_len);\n}\n\n/*\n * The next three functions return a parsed attribute value from an attribute record.\n */\nstatic int\ncoolkey_v0_get_attribute_data(const u8 *attr, size_t buf_len, sc_cardctl_coolkey_attribute_t *attr_out)\n{\n\t/* we need to manually detect types CK_ULONG */\n\tCK_ATTRIBUTE_TYPE attr_type = coolkey_get_attribute_type(attr, COOLKEY_V0_OBJECT, buf_len);\n\tint r;\n\tsize_t len;\n\n\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_STRING;\n\tattr_out->attribute_length = 0;\n\tattr_out->attribute_value = NULL;\n\n\tr = coolkey_v0_get_attribute_len(attr, buf_len, &len);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tif ((attr_type == CKA_CLASS) || (attr_type == CKA_CERTIFICATE_TYPE)\n\t\t\t\t\t\t\t\t\t || (attr_type == CKA_KEY_TYPE)) {\n\t\tif (len != 4) {\n\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t}\n\t/* return the length and the data */\n\tattr_out->attribute_length = len;\n\tattr_out->attribute_value = attr+sizeof(coolkey_v0_attribute_header_t);\n\treturn SC_SUCCESS;\n}\n\nstatic u8 coolkey_static_false = CK_FALSE;\nstatic u8 coolkey_static_true = CK_TRUE;\n\nstatic int\ncoolkey_v1_get_attribute_data(const u8 *attr, size_t buf_len, sc_cardctl_coolkey_attribute_t *attr_out)\n{\n\tint r;\n\tsize_t len;\n\tcoolkey_attribute_header_t *attribute_head = (coolkey_attribute_header_t *)attr;\n\n\tif (buf_len < sizeof(coolkey_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\n\t/* we must have type V1. Process according to data type */\n\tswitch (attribute_head->attribute_data_type) {\n\t/* ULONG has implied length of 4 */\n\tcase COOLKEY_ATTR_TYPE_INTEGER:\n\t\tif (buf_len < (sizeof(coolkey_attribute_header_t) + 4)) {\n\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = attr + sizeof(coolkey_attribute_header_t);\n\t\treturn SC_SUCCESS;\n\t/* BOOL_FALSE and BOOL_TRUE have implied length and data */\n\t/* return type STRING for BOOLS */\n\tcase COOLKEY_ATTR_TYPE_BOOL_FALSE:\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value =  &coolkey_static_false;\n\t\treturn SC_SUCCESS;\n\tcase COOLKEY_ATTR_TYPE_BOOL_TRUE:\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value =  &coolkey_static_true;\n\t\treturn SC_SUCCESS;\n\t/* string type has encoded length */\n\tcase COOLKEY_ATTR_TYPE_STRING:\n\t\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 0);\n\t\tif (r < SC_SUCCESS) {\n\t\t\treturn r;\n\t\t}\n\t\tif (buf_len < (len + sizeof(coolkey_attribute_header_t) + 2)) {\n\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\tattr_out->attribute_value = attr+sizeof(coolkey_attribute_header_t)+2;\n\t\tattr_out->attribute_length = len;\n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn SC_ERROR_CORRUPTED_DATA;\n}\n\nint\ncoolkey_get_attribute_data(const u8 *attr, u8 object_record_type, size_t buf_len, sc_cardctl_coolkey_attribute_t *attr_out)\n{\n\t/* handle the V0 objects first */\n\tif (object_record_type == COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_data(attr, buf_len, attr_out);\n\t}\n\n\t/* don't crash if we encounter some new or corrupted coolkey device */\n\tif (object_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn SC_ERROR_NO_CARD_SUPPORT;\n\t}\n\n\treturn coolkey_v1_get_attribute_data(attr, buf_len, attr_out);\n\n}\n\n/* convert an attribute type into a  bit in the fixed attribute uint32_t  */\nstatic unsigned long\ncoolkey_get_fixed_boolean_bit(CK_ATTRIBUTE_TYPE type)\n{\n\tswitch(type) {\n\tcase CKA_TOKEN:               return 0x00000080;\n\tcase CKA_PRIVATE:             return 0x00000100;\n\tcase CKA_MODIFIABLE:          return 0x00000200;\n\tcase CKA_DERIVE:              return 0x00000400;\n\tcase CKA_LOCAL:               return 0x00000800;\n\tcase CKA_ENCRYPT:             return 0x00001000;\n\tcase CKA_DECRYPT:             return 0x00002000;\n\tcase CKA_WRAP:                return 0x00004000;\n\tcase CKA_UNWRAP:              return 0x00008000;\n\tcase CKA_SIGN:                return 0x00010000;\n\tcase CKA_SIGN_RECOVER:        return 0x00020000;\n\tcase CKA_VERIFY:              return 0x00040000;\n\tcase CKA_VERIFY_RECOVER:      return 0x00080000;\n\tcase CKA_SENSITIVE:           return 0x00100000;\n\tcase CKA_ALWAYS_SENSITIVE:    return 0x00200000;\n\tcase CKA_EXTRACTABLE:         return 0x00400000;\n\tcase CKA_NEVER_EXTRACTABLE:   return 0x00800000;\n\tdefault: break;\n\t}\n\treturn 0; /* return no bits */\n}\n/* This table lets us return a pointer to the CKA_ID value without allocating data or\n * creating a changeable static that could cause thread issues */\nstatic const u8 coolkey_static_cka_id[16] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n};\n\n/* This table provides the following:\n *     1) a mapping from a 3 bit cka_class to a full 32 bit CKA_CLASS_TYPE value we can return.\n *     2) the mask of valid boolean attributes in the fixed attributes.\n */\nstruct coolkey_fixed_class {\n\tu8 class_value[4];\n\tunsigned long boolean_mask;\n};\n\nstatic const struct coolkey_fixed_class coolkey_static_cka_class[8] = {\n\t{ { 0, 0, 0, 0}, 0x00000380 }, /* DATA */\n\t{ { 0, 0, 0, 1}, 0x00000380 }, /* CERTIFICATE */\n\t{ { 0, 0, 0, 2}, 0x000c5f80 }, /* PUBLIC_KEY */\n\t{ { 0, 0, 0, 3}, 0x00f3af80 }, /* PRIVATE_KEY */\n\t{ { 0, 0, 0, 4}, 0x00f5ff80 }, /* SECRET_KEY */\n\t{ { 0, 0, 0, 5}, 0x00000000 },\n\t{ { 0, 0, 0, 6}, 0x00000000 },\n\t{ { 0, 0, 0, 7}, 0x00000000 }\n};\n\n/*\n * handle fixed attributes (V1 only)\n */\nstatic int\ncoolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\t/* If it matched, it must be one of the booleans */\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\t/* attribute isn't in the list */\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}\n\n\n\nstatic int\ncoolkey_v1_get_object_length(u8 *obj, size_t buf_len)\n{\n\tcoolkey_combined_object_header_t *object_head = (coolkey_combined_object_header_t *) obj;\n\tint attribute_count;\n\tu8 *current_attribute;\n\tint j;\n\tsize_t len;\n\n\tlen = sizeof(coolkey_combined_object_header_t);\n\tif (buf_len <= len) {\n\t\treturn buf_len;\n\t}\n\tattribute_count = bebytes2ushort(object_head->attribute_count);\n\tbuf_len -= len;\n\n\tfor (current_attribute = obj + len, j = 0; j < attribute_count; j++) {\n\t\tsize_t attribute_len = coolkey_v1_get_attribute_record_len(current_attribute, buf_len);\n\n\t\tlen += attribute_len;\n\t\tcurrent_attribute += attribute_len;\n\t\tbuf_len -= attribute_len;\n\t}\n\treturn len;\n}\n\n/*\n * COOLKEY private data per card state\n */\ntypedef struct coolkey_private_data {\n\tu8 protocol_version_major;\n\tu8 protocol_version_minor;\n\tu8 format_version_major;\n\tu8 format_version_minor;\n\tunsigned short object_version;\n\tu8 life_cycle;\n\tu8 pin_count;\n\tu8 *token_name;\t\t\t\t/* our token name read from the token */\n\tsize_t token_name_length;\t\t/* length of our token name */\n\tu8 nonce[COOLKEY_NONCE_SIZE];\t\t/* nonce returned from login */\n\tint nonce_valid;\n\tcoolkey_cuid_t cuid;\t\t\t/* card unique ID from the CCC */\n\tsc_cardctl_coolkey_object_t *obj;\t/* pointer to the current selected object */\n\tlist_t objects_list;\t\t\t/* list of objects on the token */\n\tunsigned short key_id;\t\t\t/* key id set by select */\n\tint\talgorithm;\t\t\t/* saved from set_security_env */\n\tint operation;\t\t\t\t/* saved from set_security_env */\n} coolkey_private_data_t;\n\n#define COOLKEY_DATA(card) ((coolkey_private_data_t*)card->drv_data)\n\nint\ncoolkey_compare_id(const void * a, const void *b)\n{\n\tif (a == NULL || b == NULL)\n\t\treturn 1;\n\treturn ((sc_cardctl_coolkey_object_t *)a)->id\n\t    != ((sc_cardctl_coolkey_object_t *)b)->id;\n}\n\n/* For SimCList autocopy, we need to know the size of the data elements */\nsize_t coolkey_list_meter(const void *el) {\n\treturn sizeof(sc_cardctl_coolkey_object_t);\n}\n\nstatic void coolkey_free_private_data(coolkey_private_data_t *priv);\n\nstatic coolkey_private_data_t *coolkey_new_private_data(void)\n{\n\tcoolkey_private_data_t *priv;\n\n\t/* allocate priv and zero all the fields */\n\tpriv = calloc(1, sizeof(coolkey_private_data_t));\n\tif (!priv)\n\t\treturn NULL;\n\n\t/* set other fields as appropriate */\n\tpriv->key_id = COOLKEY_INVALID_KEY;\n\tif (list_init(&priv->objects_list) != 0 ||\n\t    list_attributes_comparator(&priv->objects_list, coolkey_compare_id) != 0 ||\n\t    list_attributes_copy(&priv->objects_list, coolkey_list_meter, 1) != 0) {\n\t\tcoolkey_free_private_data(priv);\n\t\treturn NULL;\n\t}\n\n\treturn priv;\n}\n\nstatic void coolkey_free_private_data(coolkey_private_data_t *priv)\n{\n\tlist_t *l = &priv->objects_list;\n\tsc_cardctl_coolkey_object_t *o;\n\n\t/* Clean up the allocated memory in the items */\n\tlist_iterator_start(l);\n\twhile (list_iterator_hasnext(l)) {\n\t\to = (sc_cardctl_coolkey_object_t *)list_iterator_next(l);\n\t\tfree(o->data);\n\t\to->data = NULL;\n\t}\n\tlist_iterator_stop(l);\n\n\tlist_destroy(&priv->objects_list);\n\tif (priv->token_name) {\n\t\tfree(priv->token_name);\n\t}\n\tfree(priv);\n\treturn;\n}\n\n/*\n * Object list operations\n */\nstatic int coolkey_add_object_to_list(list_t *list, const sc_cardctl_coolkey_object_t *object)\n{\n\tif (list_append(list, object) < 0)\n\t\treturn SC_ERROR_UNKNOWN;\n\treturn SC_SUCCESS;\n}\n\n#define COOLKEY_AID \"\\xA0\\x00\\x00\\x01\\x16\"\nstatic sc_cardctl_coolkey_object_t *\ncoolkey_find_object_by_id(list_t *list, unsigned long object_id)\n{\n\tint pos;\n\tstatic sc_cardctl_coolkey_object_t cmp = {{\n\t\t\"\", 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ COOLKEY_AID, sizeof(COOLKEY_AID)-1 }\n\t}, 0, 0, NULL};\n\n\tcmp.id = object_id;\n\tif ((pos = list_locate(list, &cmp)) < 0)\n\t\treturn NULL;\n\n\treturn list_get_at(list, pos);\n}\n\n\nstatic const sc_path_t coolkey_template_path = {\n\t\"\", 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t{ COOLKEY_AID, sizeof(COOLKEY_AID)-1 }\n};\n\nstruct coolkey_error_codes_st {\n\tint sc_error;\n\tchar *description;\n};\n\nstatic const struct coolkey_error_codes_st coolkey_error_codes[]= {\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c00\" },\n\t{SC_ERROR_NOT_ENOUGH_MEMORY,             \"No memory left on card\" },\n\t{SC_ERROR_PIN_CODE_INCORRECT,            \"Authentication failed\" },\n\t{SC_ERROR_NOT_ALLOWED,                   \"Operation not allowed\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c04\" },\n\t{SC_ERROR_NO_CARD_SUPPORT,               \"Unsupported feature\" },\n\t{SC_ERROR_SECURITY_STATUS_NOT_SATISFIED, \"Not authorized\" },\n\t{SC_ERROR_DATA_OBJECT_NOT_FOUND,         \"Object not found\" },\n\t{SC_ERROR_FILE_ALREADY_EXISTS,           \"Object exists\" },\n\t{SC_ERROR_NO_CARD_SUPPORT,               \"Incorrect Algorithm\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c0a\" },\n\t{SC_ERROR_SM_INVALID_CHECKSUM,           \"Signature invalid\" },\n\t{SC_ERROR_AUTH_METHOD_BLOCKED,           \"Identity blocked\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c0d\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c0e\" },\n\t{SC_ERROR_INCORRECT_PARAMETERS,          \"Invalid parameter\" },\n\t{SC_ERROR_INCORRECT_PARAMETERS,          \"Incorrect P1\" },\n\t{SC_ERROR_INCORRECT_PARAMETERS,          \"Incorrect P2\" },\n\t{SC_ERROR_FILE_END_REACHED,              \"Sequence End\" },\n};\n\nstatic const unsigned int\ncoolkey_number_of_error_codes = sizeof(coolkey_error_codes)/sizeof(coolkey_error_codes[0]);\n\nstatic int coolkey_check_sw(sc_card_t *card, unsigned int sw1, unsigned int sw2)\n{\n\tsc_log(card->ctx, \n\t\t\"sw1 = 0x%02x, sw2 = 0x%02x\\n\", sw1, sw2);\n\n\tif (sw1 == 0x90 && sw2 == 0x00)\n\t\treturn SC_SUCCESS;\n\n\tif (sw1 == 0x9c) {\n\t\tif (sw2 == 0xff) {\n\t\t\t/* shouldn't happen on a production applet, 0x9cff is a debugging error code */\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tif (sw2 >= coolkey_number_of_error_codes) {\n\t\t\treturn SC_ERROR_UNKNOWN;\n\t\t}\n\t\treturn coolkey_error_codes[sw2].sc_error;\n\t}\n\n\t/* iso error */\n        return sc_get_iso7816_driver()->ops->check_sw(card, sw1, sw2);\n}\n\n/*\n * Send a command and receive data.\n *\n * A caller may provide a buffer, and length to read. If not provided,\n * an internal 4096 byte buffer is used, and a copy is returned to the\n * caller. that need to be freed by the caller.\n *\n * modelled after a similar function in card-piv.c. The coolkey version\n * adds the coolkey nonce to user authenticated operations.\n */\n\nstatic int coolkey_apdu_io(sc_card_t *card, int cla, int ins, int p1, int p2,\n\tconst u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf, size_t * recvbuflen,\n\tconst u8 *nonce, size_t nonce_len)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\tu8 rbufinitbuf[COOLKEY_MAX_SIZE];\n\tu8 rsendbuf[COOLKEY_MAX_SIZE];\n\tu8 *rbuf;\n\tsize_t rbuflen;\n\tint cse = 0;\n\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_log(card->ctx, \n\t\t \"%02x %02x %02x %\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t ins, p1, p2, sendbuflen, card->max_send_size,\n\t\t card->max_recv_size);\n\n\trbuf = rbufinitbuf;\n\trbuflen = sizeof(rbufinitbuf);\n\n\t/* if caller provided a buffer and length */\n\tif (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {\n\t\trbuf = *recvbuf;\n\t\trbuflen = *recvbuflen;\n\t}\n\n\tif (sendbuf || nonce) {\n\t\tif (recvbuf) {\n\t\t\tcse = SC_APDU_CASE_4_SHORT;\n\t\t} else {\n\t\t\tcse = SC_APDU_CASE_3_SHORT;\n\t\t}\n\t} else {\n\t\tif (recvbuf) {\n\t\t\tcse = SC_APDU_CASE_2_SHORT;\n\t\t} else {\n\t\t\tcse = SC_APDU_CASE_1;\n\t\t}\n\t}\n\n\t/* append the nonce if we have it. Coolkey just blindly puts this at the end\n\t * of the APDU (while adjusting lc). This converts case 1 to case 3. coolkey\n\t * also always drops le in case 4 (which happens when proto = T0). nonces are\n\t * never used on case 2 commands, so we can simply append the nonce to the data\n\t * and we should be fine */\n\tif (nonce) {\n\t\tu8 *buf = rsendbuf;\n\t\tif (sendbuf) {\n\t\t\tsendbuflen = MIN(sendbuflen,sizeof(rsendbuf)-nonce_len);\n\t\t\tmemcpy(rsendbuf, sendbuf, sendbuflen);\n\t\t\tbuf += sendbuflen;\n\t\t}\n\t\tmemcpy(buf, nonce, nonce_len);\n\t\tsendbuflen += nonce_len;\n\t\tsendbuf =rsendbuf;\n\t}\n\n\tsc_format_apdu(card, &apdu, cse, ins, p1, p2);\n\n\tapdu.lc = sendbuflen;\n\tapdu.datalen = sendbuflen;\n\tapdu.data = sendbuf;\n\n\n\t/* coolkey uses non-standard classes */\n\tapdu.cla = cla;\n\n\tif (recvbuf) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.le = (rbuflen > 255) ? 255 : rbuflen;\n\t\tapdu.resplen = rbuflen;\n\t} else {\n\t\t apdu.resp =  rbuf;\n\t\t apdu.le = 0;\n\t\t apdu.resplen = 0;\n\t}\n\n\tsc_log(card->ctx, \n\t\t \"calling sc_transmit_apdu flags=%lx le=%\"SC_FORMAT_LEN_SIZE_T\"u, resplen=%\"SC_FORMAT_LEN_SIZE_T\"u, resp=%p\",\n\t\t apdu.flags, apdu.le, apdu.resplen, apdu.resp);\n\n\t/* with new adpu.c and chaining, this actually reads the whole object */\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tsc_log(card->ctx, \n\t\t \"result r=%d apdu.resplen=%\"SC_FORMAT_LEN_SIZE_T\"u sw1=%02x sw2=%02x\",\n\t\t r, apdu.resplen, apdu.sw1, apdu.sw2);\n\n\tif (r < 0) {\n\t\tsc_log(card->ctx, \"Transmit failed\");\n\t\tgoto err;\n\t}\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r < 0) {\n\t\tsc_log(card->ctx, \"Transmit failed\");\n\t\tgoto err;\n\t}\n\n\tif (recvbuflen) {\n\t\tif (recvbuf && *recvbuf == NULL) {\n\t\t\t*recvbuf =  malloc(apdu.resplen);\n\t\t\tif (*recvbuf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmemcpy(*recvbuf, rbuf, apdu.resplen);\n\t\t}\n\t\t*recvbuflen =  apdu.resplen;\n\t\tr = *recvbuflen;\n\t}\n\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/*\n * Helpers to handle coolkey commands\n */\nstatic int\ncoolkey_get_life_cycle(sc_card_t *card, coolkey_life_cycle_t *life_cycle)\n{\n\tcoolkey_status_t status;\n\tu8 *receive_buf;\n\tsize_t receive_len;\n\tint len;\n\n\treceive_len = sizeof(*life_cycle);\n\treceive_buf = (u8 *)life_cycle;\n\tlen = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_LIFE_CYCLE, 0, 0,\n\t\t\tNULL, 0, &receive_buf, &receive_len, NULL, 0);\n\tif (len == sizeof(*life_cycle)) {\n\t\treturn SC_SUCCESS;\n\t}\n\n\treceive_len = 1;\n\treceive_buf = &life_cycle->life_cycle;\n\tlen = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_LIFE_CYCLE, 0, 0,\n\t\t\tNULL, 0, &receive_buf, &receive_len, NULL, 0);\n\tif (len < 0) { /* Error from the trasmittion */\n\t\treturn len;\n\t}\n\tif (len != 1) { /* The returned data is invalid */\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\treceive_len = sizeof(status);\n\treceive_buf = (u8 *)&status;\n\tlen = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_STATUS, 0, 0,\n\t\t\tNULL, 0, &receive_buf, &receive_len, NULL, 0);\n\tif (len < 0) { /* Error from the trasmittion */\n\t\treturn len;\n\t}\n\tif (len != sizeof(status)) { /* The returned data is invalid */\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tlife_cycle->protocol_version_major = status.protocol_version_major;\n\tlife_cycle->protocol_version_minor = status.protocol_version_minor;\n\tlife_cycle->pin_count = status.pin_count;\n\treturn SC_SUCCESS;\n}\n\n/* select the coolkey applet */\nstatic int coolkey_select_applet(sc_card_t *card)\n{\n\tu8 aid[] = { 0x62, 0x76, 0x01, 0xff, 0x00, 0x00, 0x00 };\n\treturn coolkey_apdu_io(card, ISO7816_CLASS, ISO7816_INS_SELECT_FILE, 4, 0,\n\t\t\t&aid[0], sizeof(aid), NULL, NULL,  NULL, 0);\n}\n\nstatic void\ncoolkey_make_cuid_from_cplc(coolkey_cuid_t *cuid, global_platform_cplc_data_t *cplc_data)\n{\n\tcuid->ic_fabricator[0]    = cplc_data->ic_fabricator[0];\n\tcuid->ic_fabricator[1]    = cplc_data->ic_fabricator[1];\n\tcuid->ic_type[0]          = cplc_data->ic_type[0];\n\tcuid->ic_type[1]          = cplc_data->ic_type[1];\n\tcuid->ic_batch[0]         = cplc_data->ic_batch[0];\n\tcuid->ic_batch[1]         = cplc_data->ic_batch[1];\n\tcuid->ic_serial_number[0] = cplc_data->ic_serial_number[0];\n\tcuid->ic_serial_number[1] = cplc_data->ic_serial_number[1];\n\tcuid->ic_serial_number[2] = cplc_data->ic_serial_number[2];\n\tcuid->ic_serial_number[3] = cplc_data->ic_serial_number[3];\n}\n\n/*\n * Read a COOLKEY coolkey object.\n */\nstatic int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\n\tulong2bebytes(&params.object_id[0], object_id);\n\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\t/* sanity check to make sure we don't overflow left */\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\n\treturn out_len;\n\nfail:\n\treturn r;\n}\n\n/*\n * Write a COOLKEY coolkey object.\n */\nstatic int coolkey_write_object(sc_card_t *card, unsigned long object_id,\n\t\t\tsize_t offset, const u8 *buf, size_t buf_len, const u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_write_object_param_t params;\n\tsize_t operation_len;\n\tsize_t left = buf_len;\n\tint r;\n\tsize_t max_operation_len;\n\n\t/* set limit for the card's maximum send size and short write */\n\tmax_operation_len = MIN(COOLKEY_MAX_CHUNK_SIZE, (card->max_send_size - sizeof(coolkey_read_object_param_t) - nonce_size));\n\n\tulong2bebytes(&params.head.object_id[0], object_id);\n\n\tdo {\n\t\tulong2bebytes(&params.head.offset[0], offset);\n\t\toperation_len = MIN(left, max_operation_len);\n\t\tparams.head.length = operation_len;\n\t\tmemcpy(params.buf, buf, operation_len);\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_WRITE_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params.head)+operation_len, NULL, 0, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tbuf += operation_len;\n\t\toffset += operation_len;\n\t\tleft -= operation_len;\n\t} while (left != 0);\n\n\treturn buf_len - left;\n\nfail:\n\treturn r;\n}\n\n/*\n * coolkey_read_binary will read a coolkey object off the card. That object is selected\n * by select file. If we've already read the object, we'll return the data from the cache.\n * coolkey objects are encoded PKCS #11 entries, not pkcs #15 data. pkcs15-coolkey will\n * translate the objects into their PKCS #15 equivalent data structures.\n */\nstatic int coolkey_read_binary(sc_card_t *card, unsigned int idx,\n\t\tu8 *buf, size_t count, unsigned long flags)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint r = 0, len;\n\tu8 *data = NULL;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (idx > priv->obj->length) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t}\n\n\t/* if we've already read the data, just return it */\n\tif (priv->obj->data) {\n\t\tsc_log(card->ctx, \n\t\t\t \"returning cached value idx=%u count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t idx, count);\n\t\tlen = MIN(count, priv->obj->length-idx);\n\t\tmemcpy(buf, &priv->obj->data[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t \"clearing cache idx=%u count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t idx, count);\n\n\tdata = malloc(priv->obj->length);\n\tif (data == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto done;\n\t}\n\n\n\tr = coolkey_read_object(card, priv->obj->id, 0, data, priv->obj->length,\n\t\t\t\t\t\t\t\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\tif (r < 0)\n\t\tgoto done;\n\n\tif ((size_t) r != priv->obj->length) {\n\t\tpriv->obj->length = r;\n\t}\n\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tlen = MIN(count, priv->obj->length-idx);\n\tmemcpy(buf, &data[idx], len);\n\tr = len;\n\t/* cache the data in the object */\n\tpriv->obj->data=data;\n\tdata = NULL;\n\ndone:\n\tif (data)\n\t\tfree(data);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* COOLKEY driver is read only. NOTE: The applet supports w/r operations, so it's perfectly\n * reasonable to try to create new objects, but currently TPS does not create applets\n * That allow user created objects, so this is a nice 2.0 feature. */\nstatic int coolkey_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\n/* initialize getting a list and return the number of elements in the list */\nstatic int coolkey_get_init_and_get_count(list_t *list, int *countp)\n{\n\t*countp = list_size(list);\n\tlist_iterator_start(list);\n\treturn SC_SUCCESS;\n}\n\n/* fill in the obj_info for the current object on the list and advance to the next object */\nstatic int coolkey_fetch_object(list_t *list, sc_cardctl_coolkey_object_t *coolkey_obj)\n{\n\tsc_cardctl_coolkey_object_t *ptr;\n\tif (!list_iterator_hasnext(list)) {\n\t\treturn SC_ERROR_FILE_END_REACHED;\n\t}\n\n\tptr = list_iterator_next(list);\n\t*coolkey_obj = *ptr;\n\treturn SC_SUCCESS;\n}\n\n/* Finalize iterator */\nstatic int coolkey_final_iterator(list_t *list)\n{\n\tlist_iterator_stop(list);\n\treturn SC_SUCCESS;\n}\n\nstatic char * coolkey_cuid_to_string(coolkey_cuid_t *cuid)\n{\n\tchar *buf;\n\tsize_t len = sizeof(coolkey_cuid_t)*2 + 1;\n\tbuf = malloc(len);\n\tif (buf == NULL) {\n\t\treturn NULL;\n\t}\n\tsc_bin_to_hex((u8 *)cuid, sizeof(*cuid), buf, len, 0);\n\treturn buf;\n}\n\nstatic const struct manufacturer_list_st {\n\tunsigned short id;\n\tchar *string;\n} manufacturer_list[] = {\n\t{ 0x2050, \"%04x Oberthur\" },\n\t{ 0x4090, \"%04x GemAlto (Infineon)\" },\n\t{ 0x4780, \"%04x STMicroElectronics\" },\n\t{ 0x4780, \"%04x RSA\" },\n\t{ 0x534e, \"%04x SafeNet\" },\n};\n\nint manufacturer_list_count = sizeof(manufacturer_list)/sizeof(manufacturer_list[0]);\n\nstatic char * coolkey_get_manufacturer(coolkey_cuid_t *cuid)\n{\n\tunsigned short fabricator = bebytes2ushort(cuid->ic_fabricator);\n\tint i;\n\tchar *buf;\n\tconst char *manufacturer_string = \"%04x Unknown\";\n\tsize_t len;\n\tint r;\n\n\tfor (i=0; i < manufacturer_list_count; i++) {\n\t\tif (manufacturer_list[i].id == fabricator) {\n\t\t\tmanufacturer_string = manufacturer_list[i].string;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen = strlen(manufacturer_string)+1;\n\tbuf= malloc(len);\n\tif (buf == NULL) {\n\t\treturn NULL;\n\t}\n\tr = snprintf(buf, len, manufacturer_string, fabricator);\n\tif (r < 0) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n\nstatic int coolkey_get_token_info(sc_card_t *card, sc_pkcs15_tokeninfo_t * token_info)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tchar *label = NULL;\n\tchar *manufacturer_id = NULL;\n\tchar *serial_number = NULL;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tlabel = strdup((char *)priv->token_name);\n\tmanufacturer_id = coolkey_get_manufacturer(&priv->cuid);\n\tserial_number = coolkey_cuid_to_string(&priv->cuid);\n\n\tif (label && manufacturer_id && serial_number) {\n\t\ttoken_info->label = label;\n\t\ttoken_info->manufacturer_id = manufacturer_id;\n\t\ttoken_info->serial_number = serial_number;\n\t\treturn SC_SUCCESS;\n\t}\n\tfree(label);\n\tfree(manufacturer_id);\n\tfree(serial_number);\n\treturn SC_ERROR_OUT_OF_MEMORY;\n}\n\nstatic int coolkey_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tmemcpy(serial->value, &priv->cuid, sizeof(priv->cuid));\n\tserial->len = sizeof(priv->cuid);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nint\ncoolkey_fill_object(sc_card_t *card, sc_cardctl_coolkey_object_t *obj)\n{\n\tint r;\n\tsize_t buf_len = obj->length;\n\tu8 *new_obj_data = NULL;\n\tsc_cardctl_coolkey_object_t *obj_entry;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tif (obj->data != NULL) {\n\t\treturn SC_SUCCESS;\n\t}\n\tnew_obj_data = malloc(buf_len);\n\tif (new_obj_data == NULL) {\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tr = coolkey_read_object(card, obj->id, 0, new_obj_data, buf_len,\n\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\tif (r != (int)buf_len) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tobj_entry = coolkey_find_object_by_id(&priv->objects_list, obj->id);\n\tif (obj_entry == NULL) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_INTERNAL; /* shouldn't happen */\n\t}\n\tif (obj_entry->data != NULL) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_INTERNAL; /* shouldn't happen */\n\t}\n\t/* Make sure we will not go over the allocated limits in the other\n\t * objects if they somehow got different lengths in matching objects */\n\tif (obj_entry->length != obj->length) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_INTERNAL; /* shouldn't happen */\n\t}\n\tobj_entry->data = new_obj_data;\n\tobj->data = new_obj_data;\n\treturn SC_SUCCESS;\n}\n\n/*\n * return a parsed record for the attribute which includes value, type, and length.\n * Handled both v1 and v0 record types. determine record type from the object.\n *  make sure we don't overrun the buffer if the token gives us bad data.\n */\nstatic int\ncoolkey_find_attribute(sc_card_t *card, sc_cardctl_coolkey_attribute_t *attribute)\n{\n\tu8 object_record_type;\n\tCK_ATTRIBUTE_TYPE attr_type = attribute->attribute_type;\n\tconst u8 *obj = attribute->object->data;\n\tconst u8 *attr = NULL;\n\tsize_t buf_len = attribute->object->length;\n\tcoolkey_object_header_t *object_head;\n\tint attribute_count,i;\n\tattribute->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_STRING;\n\tattribute->attribute_length = 0;\n\tattribute->attribute_value = NULL;\n\n\tif (obj == NULL) {\n\t\t/* cast away const so we can cache the data value */\n\t\tint r = coolkey_fill_object(card, (sc_cardctl_coolkey_object_t *)attribute->object);\n\t\tif (r < 0) {\n\t\t\treturn r;\n\t\t}\n\t\tobj = attribute->object->data;\n\t\tif (obj == NULL) {\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t}\n\n\t/* should be a static assert so we catch this at compile time */\n\tassert(sizeof(coolkey_object_header_t) >= sizeof(coolkey_v0_object_header_t));\n\t/* make sure we have enough of the object to read the record_type */\n\tif (buf_len <= sizeof(coolkey_v0_object_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tobject_head = (coolkey_object_header_t *)obj;\n\tobject_record_type = object_head->record_type;\n\t/* make sure it's a type we recognize */\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\n\n\t/*\n\t * now loop through all the attributes in the list. first find the start of the list\n\t */\n\tattr = coolkey_attribute_start(obj, object_record_type, buf_len);\n\tif (attr == NULL) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tbuf_len -= (attr-obj);\n\n\t/* now get the count */\n\tattribute_count = coolkey_get_attribute_count(obj, object_record_type, buf_len);\n\tfor (i=0; i < attribute_count; i++) {\n\t\tsize_t record_len = coolkey_get_attribute_record_len(attr, object_record_type, buf_len);\n\t\t/* make sure we have the complete record */\n\t\tif (buf_len < record_len || record_len < 4) {\n\t\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\t/* does the attribute match the one we are looking for */\n\t\tif (attr_type == coolkey_get_attribute_type(attr, object_record_type, record_len)) {\n\t\t\t/* yup, return it */\n\t\t\treturn coolkey_get_attribute_data(attr, object_record_type, record_len, attribute);\n\t\t}\n\t\t/* go to the next attribute on the list */\n\t\tbuf_len -= record_len;\n\t\tattr += record_len;\n\t}\n\t/* not find in attribute list, check the fixed attribute record */\n\tif (object_record_type == COOLKEY_V1_OBJECT) {\n\t\tunsigned long fixed_attributes = bebytes2ulong(object_head->fixed_attributes_values);\n\n\t\treturn coolkey_get_attribute_data_fixed(attr_type, fixed_attributes, attribute);\n\t}\n\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n}\n\n/*\n * pkcs 15 needs to find the cert matching the keys to fill in some of the fields that wasn't stored\n * with the key. To do this we need to look for the cert matching the key's CKA_ID. For flexibility,\n * We simply search using a pkcs #11 style template using the cardctl_coolkey_attribute_t structure */\nsc_cardctl_coolkey_object_t *\ncoolkey_find_object_by_template(sc_card_t *card, sc_cardctl_coolkey_attribute_t *template, int count)\n{\n\tlist_t *list;\n\tsc_cardctl_coolkey_object_t *current, *rv = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint i, r;\n\tunsigned int tmp_pos = (unsigned int) -1;\n\n\tlist = &priv->objects_list;\n\tif (list->iter_active) {\n\t\t/* workaround missing functionality of second iterator */\n\t\ttmp_pos = list->iter_pos;\n\t\tlist_iterator_stop(list);\n\t}\n\n\tlist_iterator_start(list);\n\twhile (list_iterator_hasnext(list)) {\n\t\tsc_cardctl_coolkey_attribute_t attribute;\n\t\tcurrent = list_iterator_next(list);\n\t\tattribute.object = current;\n\n\t\tfor (i=0; i < count; i++) {\n\t\t\tattribute.attribute_type = template[i].attribute_type;\n\t\t\tr = coolkey_find_attribute(card, &attribute);\n\t\t\tif (r < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (template[i].attribute_data_type != attribute.attribute_data_type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (template[i].attribute_length != attribute.attribute_length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (memcmp(attribute.attribute_value, template[i].attribute_value,\n\t\t\t\t\t\t\tattribute.attribute_length) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* just return the first one */\n\t\tif (i == count) {\n\t\t\trv = current;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_iterator_stop(list);\n\tif (tmp_pos != (unsigned int)-1) {\n\t\t/* workaround missing functionality of second iterator */\n\t\tlist_iterator_start(list);\n\t\twhile (list_iterator_hasnext(list) && list->iter_pos < tmp_pos)\n\t\t\t(void) list_iterator_next(list);\n\t}\n\treturn rv;\n}\n\nstatic int\ncoolkey_find_object(sc_card_t *card, sc_cardctl_coolkey_find_object_t *fobj)\n{\n\tsc_cardctl_coolkey_object_t *obj = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint r;\n\n\tswitch (fobj->type) {\n\tcase SC_CARDCTL_COOLKEY_FIND_BY_ID:\n\t\tobj = coolkey_find_object_by_id(&priv->objects_list, fobj->find_id);\n\t\tbreak;\n\tcase SC_CARDCTL_COOLKEY_FIND_BY_TEMPLATE:\n\t\tobj = coolkey_find_object_by_template(card, fobj->coolkey_template, fobj->template_count);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (obj == NULL) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tif (obj->data == NULL) {\n\t\tr = coolkey_fill_object(card, obj);\n\t\tif (r < 0) {\n\t\t\treturn r;\n\t\t}\n\t}\n\tfobj->obj = obj;\n\treturn SC_SUCCESS;\n}\n\nstatic int coolkey_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_log(card->ctx, \"cmd=%ld ptr=%p\", cmd, ptr);\n\n\tif (priv == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t}\n\tswitch(cmd) {\n\t\tcase SC_CARDCTL_GET_SERIALNR:\n\t\t\treturn coolkey_get_serial_nr_from_CUID(card, (sc_serial_number_t *) ptr);\n\t\tcase SC_CARDCTL_COOLKEY_GET_TOKEN_INFO:\n\t\t\treturn coolkey_get_token_info(card, (sc_pkcs15_tokeninfo_t *) ptr);\n\t\tcase SC_CARDCTL_COOLKEY_FIND_OBJECT:\n\t\t\treturn coolkey_find_object(card, (sc_cardctl_coolkey_find_object_t *)ptr);\n\t\tcase SC_CARDCTL_COOLKEY_INIT_GET_OBJECTS:\n\t\t\treturn coolkey_get_init_and_get_count(&priv->objects_list, (int *)ptr);\n\t\tcase SC_CARDCTL_COOLKEY_GET_NEXT_OBJECT:\n\t\t\treturn coolkey_fetch_object(&priv->objects_list, (sc_cardctl_coolkey_object_t *)ptr);\n\t\tcase SC_CARDCTL_COOLKEY_FINAL_GET_OBJECTS:\n\t\t\treturn coolkey_final_iterator(&priv->objects_list);\n\t\tcase SC_CARDCTL_COOLKEY_GET_ATTRIBUTE:\n\t\t\treturn coolkey_find_attribute(card,(sc_cardctl_coolkey_attribute_t *)ptr);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\nstatic int coolkey_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (len > COOLKEY_MAX_CHUNK_SIZE)\n\t\tlen = COOLKEY_MAX_CHUNK_SIZE;\n\n\tLOG_TEST_RET(card->ctx,\n\t\t\tcoolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_RANDOM, 0, 0,\n\t\t\t\tNULL, 0, &rnd, &len,  NULL, 0),\n\t\t\t\"Could not get challenge\");\n\n\tLOG_FUNC_RETURN(card->ctx, (int) len);\n}\n\nstatic int coolkey_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)\n{\n\tint r = SC_SUCCESS;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_log(card->ctx, \n\t\t \"flags=%08lx op=%d alg=%d algf=%08x algr=%08x kr0=%02x, krfl=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t env->flags, env->operation, env->algorithm,\n\t\t env->algorithm_flags, env->algorithm_ref, env->key_ref[0],\n\t\t env->key_ref_len);\n\n\tif ((env->algorithm != SC_ALGORITHM_RSA) && (env->algorithm != SC_ALGORITHM_EC)) {\n\t\t r = SC_ERROR_NO_CARD_SUPPORT;\n\t}\n\tpriv->algorithm = env->algorithm;\n\tpriv->operation = env->operation;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n\nstatic int coolkey_restore_security_env(sc_card_t *card, int se_num)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n#define MAX_COMPUTE_BUF 200\ntypedef struct coolkey_compute_crypt_init_params {\n\tu8 mode;\n\tu8 direction;\n\tu8 location;\n\tu8 buf_len[2];\n} coolkey_compute_crypt_init_params_t;\n\ntypedef struct coolkey_compute_crypt_params {\n    coolkey_compute_crypt_init_params_t init;\n\tu8 buf[MAX_COMPUTE_BUF];\n} coolkey_compute_crypt_params_t;\n\ntypedef struct coolkey_compute_ecc_params {\n\tu8 location;\n\tu8 buf_len[2];\n\tu8 buf[MAX_COMPUTE_BUF];\n} coolkey_compute_ecc_params_t;\n\nstatic int coolkey_rsa_op(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t max_out_len)\n{\n\tint r;\n\tconst u8 *crypt_in;\n\tu8 **crypt_out_p;\n\tsize_t crypt_in_len, *crypt_out_len_p;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tcoolkey_compute_crypt_params_t params;\n\tu8 key_number;\n\tsize_t params_len;\n\tsize_t buf_len;\n\tu8 buf[MAX_COMPUTE_BUF+2];\n\tu8 *buf_out;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx, \n\t\t \"datalen=%\"SC_FORMAT_LEN_SIZE_T\"u outlen=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t datalen, max_out_len);\n\n\tcrypt_in = data;\n\tcrypt_in_len = datalen;\n\n\tbuf_out = &buf[0];\n\tcrypt_out_p = &buf_out;\n\tbuf_len = sizeof(buf);\n\tcrypt_out_len_p = &buf_len;\n\tkey_number = priv->key_id;\n\tparams.init.mode = COOLKEY_CRYPT_MODE_RSA_NO_PAD;\n\tparams.init.location = COOLKEY_CRYPT_LOCATION_APDU;\n\tparams.init.direction = COOLKEY_CRYPT_DIRECTION_ENCRYPT; /* for no pad, direction is irrelevant */\n\n\tif (priv->key_id > 0xff) {\n\t\tr = SC_ERROR_NO_DEFAULT_KEY;\n\t\tgoto done;\n\t}\n\n\tparams_len = sizeof(params.init) + crypt_in_len;\n\n\t/* send the data to the card if necessary */\n\tif (crypt_in_len > MAX_COMPUTE_BUF) {\n\t\tu8 len_buf[2];\n\t\tparams.init.location = COOLKEY_CRYPT_LOCATION_DL_OBJECT;\n\t\tparams_len = sizeof(params.init);\n\t\tcrypt_in = NULL;\n\t\tcrypt_in_len = 0;\n\t\t*crypt_out_p = NULL;\n\t\t*crypt_out_len_p = 0;\n\n\t\tushort2bebytes(len_buf, datalen);\n\n\t\tr = coolkey_write_object(card, COOLKEY_DL_OBJECT_ID, 0, len_buf, sizeof(len_buf),\n\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tr = coolkey_write_object(card, COOLKEY_DL_OBJECT_ID, 2, data, datalen, priv->nonce,\n\t\t\t\t\t\tsizeof(priv->nonce));\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t}\n\tushort2bebytes(params.init.buf_len, crypt_in_len);\n\tif (crypt_in_len) {\n\t\tmemcpy(params.buf, crypt_in, crypt_in_len);\n\t}\n\n\n\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_COMPUTE_CRYPT,\n\t\t\tkey_number, COOLKEY_CRYPT_ONE_STEP, (u8 *)&params, params_len,\n\t\t\tcrypt_out_p, crypt_out_len_p, priv->nonce, sizeof(priv->nonce));\n\n\tif (r < 0) {\n\t\tgoto done;\n\t}\n\tif (datalen > MAX_COMPUTE_BUF) {\n\t\tu8 len_buf[2];\n\t\tsize_t out_length;\n\n\t\tr = coolkey_read_object(card, COOLKEY_DL_OBJECT_ID, 0, len_buf, sizeof(len_buf),\n\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tout_length = bebytes2ushort(len_buf);\n\t\tout_length = MIN(out_length,max_out_len);\n\n\t\tr = coolkey_read_object(card, COOLKEY_DL_OBJECT_ID, sizeof(len_buf), out, out_length,\n\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\n\t} else {\n\t\tsize_t out_length = bebytes2ushort(buf);\n\t\tout_length = MIN(out_length, max_out_len);\n\t\tmemcpy(out, buf+2, out_length);\n\t\tr = out_length;\n\t}\n\ndone:\n\treturn r;\n}\n\nstatic int coolkey_ecc_op(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tconst u8 *crypt_in;\n\tu8  **crypt_out_p;\n\tu8  ins = 0;\n\tsize_t crypt_in_len, *crypt_out_len_p;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tcoolkey_compute_ecc_params_t params;\n\tsize_t params_len;\n\tu8 key_number;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx, \n\t\t \"datalen=%\"SC_FORMAT_LEN_SIZE_T\"u outlen=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t datalen, outlen);\n\n\tcrypt_in = data;\n\tcrypt_in_len = datalen;\n\n\tcrypt_out_p = &out;\n\tcrypt_out_len_p = &outlen;\n\tkey_number = priv->key_id;\n\tparams.location = COOLKEY_CRYPT_LOCATION_APDU;\n\n\tif (priv->key_id > 0xff) {\n\t\tr = SC_ERROR_NO_DEFAULT_KEY;\n\t\tgoto done;\n\t}\n\n\tswitch (priv->operation) {\n\tcase SC_SEC_OPERATION_DERIVE:\n\t\tins = COOLKEY_INS_COMPUTE_ECC_KEY_AGREEMENT;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tins = COOLKEY_INS_COMPUTE_ECC_SIGNATURE;\n\t\tbreak;\n\tdefault:\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n\t\tgoto done;\n\t}\n\n\tparams_len = (sizeof(params) - sizeof(params.buf))  + crypt_in_len;\n\n\tushort2bebytes(params.buf_len, crypt_in_len);\n\tif (crypt_in_len) {\n\t\tmemcpy(params.buf, crypt_in, crypt_in_len);\n\t}\n\n\n\tr = coolkey_apdu_io(card, COOLKEY_CLASS, ins,\n\t\t\tkey_number, COOLKEY_CRYPT_ONE_STEP, (u8 *)&params, params_len,\n\t\t\tcrypt_out_p, crypt_out_len_p, priv->nonce, sizeof(priv->nonce));\n\ndone:\n\treturn r;\n}\n\n\nstatic int coolkey_compute_crypt(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tswitch (priv->algorithm) {\n\tcase SC_ALGORITHM_RSA:\n\t\tr = coolkey_rsa_op(card, data, datalen, out, outlen);\n\t\tbreak;\n\tcase SC_ALGORITHM_EC:\n\t\tr = coolkey_ecc_op(card, data, datalen, out, outlen);\n\t\tbreak;\n\tdefault:\n\t\tr = SC_ERROR_NO_CARD_SUPPORT;\n\t\tbreak;\n\t}\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n\nstatic u8 coolkey_class(unsigned long object_id) {\n\treturn (object_id >> 24) & 0xff;\n}\n\nstatic unsigned short coolkey_get_key_id(unsigned long object_id) {\n\tchar char_index = (object_id >> 16) & 0xff;\n\tif (char_index >= '0' && char_index <= '9') {\n\t\treturn (u8)(char_index - '0');\n\t}\n\tif (char_index >= 'A' && char_index <= 'Z') {\n\t\treturn (u8)(char_index - 'A' + 10);\n\t}\n\tif (char_index >= 'a' && char_index <= 'z') {\n\t\treturn (u8)(char_index - 'a' + 26 + 10);\n\t}\n\treturn COOLKEY_INVALID_KEY;\n}\n\n/*\n * COOLKEY cards don't select objects in the applet, objects are selected by a parameter\n * to the APDU. We create paths for the object in which the path value is the object_id\n * and the path type is SC_PATH_SELECT_FILE_ID (so we could cache at the PKCS #15 level if\n * we wanted to.\n *\n * This select simply records what object was selected so that read knows how to access it.\n */\nstatic int coolkey_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\tint r;\n\tstruct sc_file *file = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tunsigned long object_id;\n\n\tassert(card != NULL && in_path != NULL);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (in_path->len != 4) {\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\t}\n\tr = coolkey_select_applet(card);\n\tif (r != SC_SUCCESS) {\n\t\treturn r;\n\t}\n\tobject_id = bebytes2ulong(in_path->value);\n\tpriv->obj = coolkey_find_object_by_id(&priv->objects_list, object_id);\n\tif (priv->obj == NULL) {\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\t}\n\n\tpriv->key_id = COOLKEY_INVALID_KEY;\n\tif (coolkey_class(object_id) == COOLKEY_KEY_CLASS) {\n\t\tpriv->key_id = coolkey_get_key_id(object_id);\n\t}\n\tif (file_out) {\n\t\tfile = sc_file_new();\n\t\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tfile->path = *in_path;\n\t\t/* this could be like the FCI */\n\t\tfile->type =  SC_PATH_TYPE_FILE_ID;\n\t\tfile->shareable = 0;\n\t\tfile->ef_structure = 0;\n\t\tfile->size = priv->obj->length;\n\t\t*file_out = file;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int coolkey_finish(sc_card_t *card)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (priv) {\n\t\tcoolkey_free_private_data(priv);\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int\ncoolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\t/* if we didn't successfully put the object on the list,\n\t\t * the data space didn't get adopted. free it before we return */\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}\n\n\nstatic int\ncoolkey_process_combined_object(sc_card_t *card, coolkey_private_data_t *priv, u8 *object, size_t object_length)\n{\n\tcoolkey_combined_header_t *header = (coolkey_combined_header_t *)object;\n\tunsigned short compressed_offset;\n\tunsigned short compressed_length;\n\tunsigned short compressed_type;\n\tunsigned short object_offset;\n\tunsigned short object_count;\n\tcoolkey_decompressed_header_t *decompressed_header;\n\tu8 *decompressed_object = NULL;\n\tsize_t decompressed_object_len = 0;\n\tint free_decompressed = 0;\n\tint i, r;\n\n\tif (object_length < sizeof(coolkey_combined_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tcompressed_offset = bebytes2ushort(header->compression_offset);\n\tcompressed_length = bebytes2ushort(header->compression_length);\n\tcompressed_type   = bebytes2ushort(header->compression_type);\n\n\tif ((((size_t)compressed_offset) + (size_t)compressed_length) >  object_length) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\n\t/* store the CUID */\n\tmemcpy(&priv->cuid, &header->cuid, sizeof(priv->cuid));\n\n\tif (compressed_type == COOLKEY_COMPRESSION_ZLIB) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&decompressed_object, &decompressed_object_len, &object[compressed_offset], compressed_length, COMPRESSION_AUTO);\n\t\tif (r)\n\t\t\tgoto done;\n\t\tfree_decompressed = 1;\n#else\n\t\tsc_log(card->ctx, \"Coolkey compression not supported, no zlib\");\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n#endif\n\t}  else {\n\t\tdecompressed_object =&object[compressed_offset];\n\t\tdecompressed_object_len = (size_t) compressed_length;\n\t}\n\n\tdecompressed_header = (coolkey_decompressed_header_t *)decompressed_object;\n\n\tif (decompressed_object_len < sizeof(coolkey_decompressed_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tobject_offset = bebytes2ushort(decompressed_header->object_offset);\n\tobject_count = bebytes2ushort(decompressed_header->object_count);\n\n\n\t/*\n\t * using 2 different tests here so we can log different errors if logging is\n\t * turned on.\n\t */\n\t/* make sure token_name doesn't overrun the buffer */\n\tif (decompressed_header->token_name_length +\n\t\toffsetof(coolkey_decompressed_header_t,token_name) > decompressed_object_len) {\n\t\tr = SC_ERROR_CORRUPTED_DATA;\n\t\tgoto done;\n\t}\n\t/* make sure it doesn't overlap the object space */\n\tif (decompressed_header->token_name_length +\n\t\toffsetof(coolkey_decompressed_header_t,token_name) > object_offset) {\n\t\tr = SC_ERROR_CORRUPTED_DATA;\n\t\tgoto done;\n\t}\n\n\t/* store the token name in the priv structure so the emulator can set it */\n\tpriv->token_name = malloc(decompressed_header->token_name_length+1);\n\tif (priv->token_name == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto done;\n\t}\n\tmemcpy(priv->token_name, &decompressed_header->token_name[0],\n\t\t\t\t\t\t\tdecompressed_header->token_name_length);\n\tpriv->token_name[decompressed_header->token_name_length] = 0;\n\tpriv->token_name_length = decompressed_header->token_name_length;\n\n\n\tfor (i=0; i < object_count && object_offset < decompressed_object_len; i++ ) {\n\t\tu8 *current_object = &decompressed_object[object_offset];\n\t\tcoolkey_combined_object_header_t *object_header =\n\t\t\t\t(coolkey_combined_object_header_t *)current_object;\n\t\tunsigned long object_id = bebytes2ulong(object_header->object_id);\n\t\tint current_object_len;\n\n\t\t/* figure out how big it is */\n\t\tr = coolkey_v1_get_object_length(current_object, decompressed_object_len-object_offset);\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\t\tif ((size_t)r + object_offset > decompressed_object_len) {\n\t\t\tr = SC_ERROR_CORRUPTED_DATA;\n\t\t\tgoto done;\n\t\t}\n\t\tcurrent_object_len = r;\n\t\tobject_offset += current_object_len;\n\n\t\t/* record this object */\n\t\tr = coolkey_add_object(priv, object_id, current_object, current_object_len, 1);\n\t\tif (r) {\n\t\t\tgoto done;\n\t\t}\n\n\t}\n\tr = SC_SUCCESS;\n\ndone:\n\tif (free_decompressed) {\n\t\tfree(decompressed_object);\n\t}\n\treturn r;\n}\n\nstatic int\ncoolkey_list_object(sc_card_t *card, u8 seq, coolkey_object_info_t *object_info)\n{\n\tu8 *rbuf = (u8 *) object_info;\n\tsize_t rbuflen = sizeof(*object_info);\n\n\treturn coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_LIST_OBJECTS, seq, 0,\n\t\t\tNULL, 0, &rbuf, &rbuflen, NULL, 0);\n\n}\n\n/*\n * Initialize the Coolkey data structures.\n */\nstatic int coolkey_initialize(sc_card_t *card)\n{\n\tint r;\n\tcoolkey_private_data_t *priv = NULL;\n\tcoolkey_life_cycle_t life_cycle;\n\tcoolkey_object_info_t object_info;\n\tint combined_processed = 0;\n\n\t/* already found? */\n\tif (card->drv_data) {\n\t\treturn SC_SUCCESS;\n\t}\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"Coolkey Applet found\");\n\n\tpriv = coolkey_new_private_data();\n\tif (priv == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto cleanup;\n\t}\n\tr = coolkey_get_life_cycle(card, &life_cycle);\n\tif (r < 0) {\n\t\tgoto cleanup;\n\t}\n\n\t/* Select a coolkey read the coolkey objects out */\n\tr = coolkey_select_applet(card);\n\tif (r < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tpriv->protocol_version_major = life_cycle.protocol_version_major;\n\tpriv->protocol_version_minor = life_cycle.protocol_version_minor;\n\tpriv->pin_count = life_cycle.pin_count;\n\tpriv->life_cycle = life_cycle.life_cycle;\n\n\t/* walk down the list of objects and read them off the token */\n\tr = coolkey_list_object(card, COOLKEY_LIST_RESET, &object_info);\n\twhile (r >= 0) {\n\t\tunsigned long object_id;\n\t\tunsigned short object_len;\n\n\t\t/* The card did not return what we expected: Lets try other objects */\n\t\tif ((size_t)r < (sizeof(object_info)))\n\t\t\tbreak;\n\n\t\t/* TODO also look at the ACL... */\n\n\t\tobject_id = bebytes2ulong(object_info.object_id);\n\t\tobject_len = bebytes2ulong(object_info.object_length);\n\n\n\t\t/* the combined object is a single object that can store the other objects.\n\t\t * most coolkeys provisioned by TPS has a single combined object that is\n\t\t * compressed greatly increasing the effectiveness of compress (since lots\n\t\t * of certs on the token share the same Subject and Issuer DN's). We now\n\t\t * process it separately so that we can have both combined objects managed\n\t\t * by TPS and user managed certs on the same token */\n\t\tif (object_id == COOLKEY_COMBINED_OBJECT_ID) {\n\t\t\tu8 *object = malloc(object_len);\n\t\t\tif (object == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = coolkey_read_object(card, COOLKEY_COMBINED_OBJECT_ID, 0, object, object_len,\n\t\t\t\t\t\t\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\t\t\tif (r < 0) {\n\t\t\t\tfree(object);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = coolkey_process_combined_object(card, priv, object, r);\n\t\t\tfree(object);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcombined_processed = 1;\n\t\t} else {\n\t\t\tr = coolkey_add_object(priv, object_id, NULL, object_len, 0);\n\t\t\tif (r != SC_SUCCESS)\n\t\t\t\tsc_log(card->ctx, \"coolkey_add_object() returned %d\", r);\n\t\t}\n\n\t\t/* Read next object: error is handled on the cycle condition and below after cycle */\n\t\tr = coolkey_list_object(card, COOLKEY_LIST_NEXT, &object_info);\n\t}\n\tif (r != SC_ERROR_FILE_END_REACHED) {\n\t\t/* This means the card does not cooperate at all: bail out */\n\t\tif (r >= 0) {\n\t\t\tr = SC_ERROR_INVALID_CARD;\n\t\t}\n\t\tgoto cleanup;\n\t}\n\t/* if we didn't pull the cuid from the combined object, then grab it now */\n\tif (!combined_processed) {\n\t\tglobal_platform_cplc_data_t cplc_data;\n\t\t/* select the card manager, because a card with applet only will have\n\t\t   already selected the coolkey applet */\n\n\t\tr = gp_select_card_manager(card);\n\t\tif (r < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tr = gp_get_cplc_data(card, &cplc_data);\n\t\tif (r < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcoolkey_make_cuid_from_cplc(&priv->cuid, &cplc_data);\n\t\tpriv->token_name = (u8 *)strdup(\"COOLKEY\");\n\t\tif (priv->token_name == NULL) {\n\t\t\tr= SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpriv->token_name_length = sizeof(\"COOLKEY\")-1;\n\t}\n\tcard->drv_data = priv;\n\treturn SC_SUCCESS;\n\ncleanup:\n\tif (priv) {\n\t\tcoolkey_free_private_data(priv);\n\t}\n\treturn r;\n}\n\n\n/* NOTE: returns a bool, 1 card matches, 0 it does not */\nstatic int coolkey_match_card(sc_card_t *card)\n{\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it may be in dirty memory */\n\tcard->ops->logout = NULL;\n\n\tr = coolkey_select_applet(card);\n\tif (r == SC_SUCCESS) {\n\t\tsc_apdu_t apdu;\n\n\t\t/* The GET STATUS INS with P1 = 1 returns invalid instruction (0x6D00)\n\t\t * on Coolkey applet (reserved for GetMemory function),\n\t\t * while incorrect P1 (0x9C10) on Muscle applets\n\t\t */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, COOLKEY_INS_GET_STATUS, 0x01, 0x00);\n\t\tapdu.cla = COOLKEY_CLASS;\n\t\tapdu.le = 0x00;\n\t\tapdu.resplen = 0;\n\t\tapdu.resp = NULL;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r == SC_SUCCESS && apdu.sw1 == 0x6d && apdu.sw2 == 0x00) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n\nstatic int coolkey_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\tunsigned long ext_flags;\n\tcoolkey_private_data_t * priv;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = coolkey_initialize(card);\n\tif (r < 0) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\n\tcard->type = SC_CARD_TYPE_COOLKEY_GENERIC;\n\n\t/* set Token Major/minor version */\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tflags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ECDSA_HASH_NONE;\n\text_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;\n\n\t_sc_card_add_ec_alg(card, 256, flags, ext_flags, NULL);\n\t_sc_card_add_ec_alg(card, 384, flags, ext_flags, NULL);\n\t_sc_card_add_ec_alg(card, 521, flags, ext_flags, NULL);\n\n\n\tpriv = COOLKEY_DATA(card);\n\tif (priv->pin_count != 0) {\n\t\tcard->caps |= SC_CARD_CAP_ISO7816_PIN_INFO;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\ncoolkey_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tint r;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tsize_t rbuflen;\n\tu8 *rbuf;\n\n\t/* COOLKEY uses a separate pin from the card pin, managed by the applet.\n\t * if we successfully log into coolkey, we will get a nonce, which we append\n\t * to our APDUs to authenticate the apdu to the card. This allows coolkey to\n\t * maintain separate per application login states without the application\n\t * having to cache the pin */\n\tswitch (data->cmd) {\n\tcase SC_PIN_CMD_GET_INFO:\n\t\tif (priv->nonce_valid) {\n\t\t\tdata->pin1.logged_in = SC_PIN_STATE_LOGGED_IN;\n\t\t} else {\n\t\t\tdata->pin1.logged_in = SC_PIN_STATE_LOGGED_OUT;\n\t\t\t/* coolkey retries is 100. It's unlikely the pin is block.\n\t\t\t * instead, coolkey slows down the login command exponentially\n\t\t\t */\n\t\t\tdata->pin1.tries_left = 0xf;\n\t\t}\n\t\tif (tries_left) {\n\t\t\t*tries_left = data->pin1.tries_left;\n\t\t}\n\t\tr = SC_SUCCESS;\n\t\tbreak;\n\n\tcase SC_PIN_CMD_UNBLOCK:\n\tcase SC_PIN_CMD_CHANGE:\n\t\t/* these 2 commands are currently reserved for TPS */\n\tdefault:\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase SC_PIN_CMD_VERIFY:\n\t\t/* coolkey applet supports multiple pins, but TPS currently only uses one.\n\t\t * just support the one pin for now (we need an array of nonces to handle\n\t\t * multiple pins) */\n\t\t/* coolkey only supports unpadded ascii pins, so no need to format the pin */\n\t\trbuflen = sizeof(priv->nonce);\n\t\trbuf = &priv->nonce[0];\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_VERIFY_PIN,\n\t\t\tdata->pin_reference, 0, data->pin1.data, data->pin1.len,\n\t\t\t&rbuf, &rbuflen, NULL, 0);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tpriv->nonce_valid = 1;\n\t\tr = SC_SUCCESS;\n\t}\n\treturn r;\n}\n\n\nstatic int\ncoolkey_logout(sc_card_t *card)\n{\n\t/* when we add multi pin support here, how do we know which pin to logout? */\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tu8 pin_ref = 0;\n\n\t(void) coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_LOGOUT, pin_ref, 0, NULL, 0, NULL, NULL,\n\t\tpriv->nonce, sizeof(priv->nonce));\n\t/* even if logout failed on the card, flush the nonce and clear the nonce_valid and we are effectively\n\t * logged out... needing to login again to get a nonce back */\n\tmemset(priv->nonce, 0, sizeof(priv->nonce));\n\tpriv->nonce_valid = 0;\n\treturn SC_SUCCESS;\n}\n\n\nstatic int coolkey_card_reader_lock_obtained(sc_card_t *card, int was_reset)\n{\n\tint r = SC_SUCCESS;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (was_reset > 0) {\n\t\tr = coolkey_select_applet(card);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic struct sc_card_operations coolkey_ops;\n\nstatic struct sc_card_driver coolkey_drv = {\n\t\"COOLKEY\",\n\t\"coolkey\",\n\t&coolkey_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tcoolkey_ops = *iso_drv->ops;\n\tcoolkey_ops.match_card = coolkey_match_card;\n\tcoolkey_ops.init = coolkey_init;\n\tcoolkey_ops.finish = coolkey_finish;\n\n\tcoolkey_ops.select_file =  coolkey_select_file; /* need to record object type */\n\tcoolkey_ops.get_challenge = coolkey_get_challenge;\n\tcoolkey_ops.read_binary = coolkey_read_binary;\n\tcoolkey_ops.write_binary = coolkey_write_binary;\n\tcoolkey_ops.set_security_env = coolkey_set_security_env;\n\tcoolkey_ops.restore_security_env = coolkey_restore_security_env;\n\tcoolkey_ops.compute_signature = coolkey_compute_crypt;\n\tcoolkey_ops.decipher =  coolkey_compute_crypt;\n\tcoolkey_ops.card_ctl = coolkey_card_ctl;\n\tcoolkey_ops.check_sw = coolkey_check_sw;\n\tcoolkey_ops.pin_cmd = coolkey_pin_cmd;\n\tcoolkey_ops.logout = coolkey_logout;\n\tcoolkey_ops.card_reader_lock_obtained = coolkey_card_reader_lock_obtained;\n\n\treturn &coolkey_drv;\n}\n\n\nstruct sc_card_driver * sc_get_coolkey_driver(void)\n{\n\treturn sc_get_driver();\n}\n\n"], "fixing_code": ["/*\n * card-coolkey.c: Support for Coolkey\n *\n * Copyright (C) 2001, 2002  Juha Yrj\u00f6l\u00e4 <juha.yrjola@iki.fi>\n * Copyright (C) 2005,2006,2007,2008,2009,2010 Douglas E. Engert <deengert@anl.gov>\n * Copyright (C) 2006, Identity Alliance, Thomas Harning <thomas.harning@identityalliance.com>\n * Copyright (C) 2007, EMC, Russell Larner <rlarner@rsa.com>\n * Copyright (C) 2016, Red Hat, Inc.\n *\n * Coolkey driver author: Robert Relyea <rrelyea@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n#if HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifdef _WIN32\n#include <io.h>\n#else\n#include <unistd.h>\n#endif\n\n#include <sys/types.h>\n\n#ifdef ENABLE_OPENSSL\n\t/* openssl only needed for card administration */\n#include <openssl/evp.h>\n#include <openssl/bio.h>\n#include <openssl/pem.h>\n#include <openssl/rand.h>\n#include <openssl/rsa.h>\n#endif /* ENABLE_OPENSSL */\n\n#include \"internal.h\"\n#include \"asn1.h\"\n#include \"cardctl.h\"\n#ifdef ENABLE_ZLIB\n#include \"compression.h\"\n#endif\n#include \"iso7816.h\"\n#include \"gp.h\"\n#include \"../pkcs11/pkcs11.h\"\n\n\n\n#define COOLKEY_MAX_SIZE 4096\t\t/* arbitrary, just needs to be 'large enough' */\n\n/*\n *  COOLKEY hardware and APDU constants\n */\n#define COOLKEY_MAX_CHUNK_SIZE 240 /* must be less than 255-8 */\n\n/* ISO 7816 CLA values used by COOLKEY */\n#define ISO7816_CLASS           0x00\n#define COOLKEY_CLASS           0xb0\n\n/* ISO 71816 INS values used by COOLKEY */\n#define ISO7816_INS_SELECT_FILE 0xa4\n\n/* COOLKEY specific INS values (public) */\n#define COOLKEY_INS_GET_LIFE_CYCLE             0xf2\n#define COOLKEY_INS_GET_STATUS                 0x3c\n#define COOLKEY_INS_VERIFY_PIN                 0x42\n#define COOLKEY_INS_LIST_OBJECTS               0x58\n\n/* COOLKEY specific INS values (require nonce) */\n#define COOLKEY_INS_COMPUTE_CRYPT              0x36\n#define COOLKEY_INS_COMPUTE_ECC_KEY_AGREEMENT  0x37\n#define COOLKEY_INS_COMPUTE_ECC_SIGNATURE      0x38\n#define COOLKEY_INS_GET_RANDOM                 0x72\n#define COOLKEY_INS_READ_OBJECT                0x56\n#define COOLKEY_INS_WRITE_OBJECT               0x54\n#define COOLKEY_INS_LOGOUT                     0x61\n\n/* COMPUTE_CRYPT and COMPUT_ECC parameters */\n#define COOLKEY_CRYPT_INIT     1\n#define COOLKEY_CRYPT_PROCESS  2\n#define COOLKEY_CRYPT_FINAL    3\n#define COOLKEY_CRYPT_ONE_STEP 4\n\n#define COOLKEY_CRYPT_MODE_RSA_NO_PAD    0x00\n#define COOLKEY_CRYPT_LOCATION_APDU      0x01\n#define COOLKEY_CRYPT_LOCATION_DL_OBJECT 0x02\n#define COOLKEY_CRYPT_DIRECTION_ENCRYPT  0x03\n\n/* List Objects parameters */\n#define COOLKEY_LIST_RESET 0x00\n#define COOLKEY_LIST_NEXT  0x01\n\n/* Special object identifiers */\n#define COOLKEY_DL_OBJECT_ID       0xffffffff\n#define COOLKEY_COMBINED_OBJECT_ID 0x7a300000 /* 'z0\\0\\0' */\n#define COOLKEY_INVALID_KEY        0xff00\n#define COOLKEY_KEY_CLASS\t\t\t'k'\n#define COOLKEY_NONCE_SIZE  8\n\n/* returned from the coolkey extended life cycle apdu */\ntypedef struct coolkey_life_cycle {\n\tu8 life_cycle;\n\tu8 pin_count;\n\tu8 protocol_version_major;\n\tu8 protocol_version_minor;\n} coolkey_life_cycle_t;\n\n/* return by the coolkey status apdu */\ntypedef struct coolkey_status {\n\tu8 protocol_version_major;\n\tu8 protocol_version_minor;\n\tu8 applet_major_version;\n\tu8 applet_minor_version;\n\tu8 total_object_memory[4];\n\tu8 free_object_memory[4];\n\tu8 pin_count;\n\tu8 key_count;\n\tu8 logged_in_identities[2];\n} coolkey_status_t;\n\n/* format of the coolkey_cuid, either constructed from cplc data or read from the combined object */\ntypedef struct coolkey_cuid {\n\tu8 ic_fabricator[2];\n\tu8 ic_type[2];\n\tu8 ic_batch[2];\n\tu8 ic_serial_number[4];\n} coolkey_cuid_t;\n\n/* parameter for list objects apdu */\ntypedef struct coolkey_object_info {\n\tu8 object_id[4];\n\tu8 object_length[4];\n\tu8 read_acl[2];\n\tu8 write_acl[2];\n\tu8 delete_acl[2];\n} coolkey_object_info_t;\n\n/* parameter for the read object apdu */\ntypedef struct coolkey_read_object_param {\n\tu8 object_id[4];\n\tu8 offset[4];\n\tu8 length;\n} coolkey_read_object_param_t;\n\n/* parameter for the write object apdu */\ntypedef struct coolkey_write_object_param {\n\tcoolkey_read_object_param_t head;\n\tu8 buf[COOLKEY_MAX_CHUNK_SIZE];\n} coolkey_write_object_param_t;\n\n/* coolkey uses muscle like objects, but when coolkey is managed by the TPS system\n * it creates a single object and encodes the individual objects inside the\n * common single object. This allows more efficient reading of all the objects\n * (because we can use a single apdu call and we can compress all the objects\n * together and take advantage of the fact that many of the certs share the same subject and issue). */\ntypedef struct coolkey_combined_header {\n\tu8\tformat_version[2];\n\tu8\tobject_version[2];\n\tcoolkey_cuid_t cuid;\n\tu8\tcompression_type[2];\n\tu8\tcompression_length[2];\n\tu8\tcompression_offset[2];\n} coolkey_combined_header_t;\n\n#define COOLKEY_COMPRESSION_NONE 0\n#define COOLKEY_COMPRESSION_ZLIB 1\n\n/*\n * This is the header of the decompressed portion of the combined object\n */\ntypedef struct coolkey_decompressed_header {\n\tu8 object_offset[2];\n\tu8 object_count[2];\n\tu8 token_name_length;\n\tu8 token_name[255];      /* arbitrary size up to token_name_length */\n} coolkey_decompressed_header_t;\n\n/*\n * header for an object. There are 2 types of object headers, v1 and v0.\n * v1 is the most common, and is always found in a combined object, so\n * we only specify the v0 in the name of the structure.\n */\n\ntypedef struct coolkey_v0_object_header {\n\tu8 record_type;\t\t\t\t /* version 0 or version 1 */\n\tu8 object_id[4]; \t\t\t /*  coolkey object id  */\n\tu8 attribute_data_len[2];    /* the length in bytes of the next block of\n\t\t\t\t\t\t\t\t  * attribute records */\n\t/* followed by the first attribute record */\n} coolkey_v0_object_header_t;\n\ntypedef struct coolkey_v0_attribute_header {\n\tu8 attribute_attr_type[4];\t/* CKA_ATTRIBUTE_TYPE */\n\tu8 attribute_data_len[2];\t/* Length of the attribute */\n\t/* followed by the actual attribute data */\n} coolkey_v0_attribute_header_t;\n\n/* combined objects are v1 objects without the record_type indicator */\ntypedef struct coolkey_combined_object_header {\n\tu8 object_id[4]; \t\t\t /*  coolkey object id  */\n\tu8 fixed_attributes_values[4]; /* compressed fixed attributes */\n\tu8 attribute_count[2];\t\t/* the number of attribute records that follow */\n\t/* followed by the first attribute */\n} coolkey_combined_object_header_t;\n\ntypedef struct coolkey_object_header {\n\tu8 record_type;\t\t\t\t/* version 0 or version 1 */\n\tu8 object_id[4]; \t\t\t /*  coolkey object id  */\n\tu8 fixed_attributes_values[4]; /* compressed fixed attributes */\n\tu8 attribute_count[2];\t\t/* the number of attribute records that follow */\n\t/* followed by the first attribute */\n} coolkey_object_header_t;\n\n#define COOLKEY_V0_OBJECT 0\n#define COOLKEY_V1_OBJECT 1\n\n/* vi attribute header */\ntypedef struct coolkey_attribute_header {\n\tu8 attribute_attr_type[4]; /* CKA_ATTRIBUTE_TYPE */\n\tu8 attribute_data_type;    /* the Type of data stored */\n\t/* optional attribute data, or attribute len+data, depending on the value of data_type */\n} coolkey_attribute_header_t;\n\n/* values for attribute_data_type */\n#define COOLKEY_ATTR_TYPE_STRING      0\n#define COOLKEY_ATTR_TYPE_INTEGER     1\n#define COOLKEY_ATTR_TYPE_BOOL_FALSE  2\n#define COOLKEY_ATTR_TYPE_BOOL_TRUE   3\n\n/*\n * format of the fix_attribute values. These are stored as a big endian uint32_t with the below bit field\n * Definitions:\n *\nstruct coolkey_fixed_attributes_values {\n\tuint32_t  cka_id:4;\n\tuint32_t  cka_class:3;\n\tuint32_t  cka_token:1;\n\tuint32_t  cka_private:1;\n\tuint32_t  cka_modifiable:1;\n\tuint32_t  cka_derive:1;\n\tuint32_t  cka_local:1;\n\tuint32_t  cka_encrypt:1;\n\tuint32_t  cka_decrypt:1;\n\tuint32_t  cka_wrap:1;\n\tuint32_t  cka_unwrap:1;\n\tuint32_t  cka_sign:1;\n\tuint32_t  cka_sign_recover:1;\n\tuint32_t  cka_verify:1;\n\tuint32_t  cka_verify_recover:1;\n\tuint32_t  cka_sensitive:1;\n\tuint32_t  cka_always_sensitive:1;\n\tuint32_t  cka_extractable:1;\n\tuint32_t  cka_never_extractable:1;\n\tuint32_t  reserved:8;\n};\n\n *  cka_class is used to determine which booleans are valid. Any attributes in the full attribute list\n *  takes precedence over the fixed attributes. That is if there is a CKA_ID in the full attribute list,\n *  The cka_id in the fixed_attributes is ignored. When determining which boolean attribute is valid, the\n *  cka_class in the fixed attributes are used, even if it is overridden by the  full attribute list.\n * valid cka_class values and their corresponding valid bools are as follows:\n *\n *     0 CKO_DATA                          cka_private, cka_modifiable, cka_token\n *     1 CKO_CERTIFICATE                   cka_private, cka_modifiable, cka_token\n *     2 CKO_PUBLIC_KEY                    cka_private, cka_modifiable, cka_token\n *                                         cka_derive, cka_local, cka_encrypt, cka_wrap\n *                                         cka_verify, cka_verify_recover\n *     3 CKO_PRIVATE_KEY                   cka_private, cka_modifiable, cka_token\n *                                         cka_derive, cka_local, cka_decrypt, cka_unwrap\n *                                         cka_sign, cka_sign_recover, cka_sensitive,\n *                                         cka_always_sensitive, cka_extractable,\n *                                         cka_never_extractable\n *     4 CKO_SECRET_KEY                    cka_private, cka_modifiable, cka_token\n *                                         cka_derive, cka_local, cka_encrypt, cka_decrypt,\n *                                         cka_wrap, cka_unwrap, cka_sign, cka_verify,\n *                                         cka_sensitive, cka_always_sensitive,\n *                                         cka_extractable, cka_never_extractable\n *     5-7 RESERVED                        none\n *\n */\n\n/*\n * Coolkey attribute record handling functions.\n */\n\n/* get the length of the attribute from a V1 attribute header. If encoded_len == true, then return the length of\n * the attribute data field (including any explicit length values, If encoded_len = false return the length of\n * the actual attribute data.\n */\nstatic int\ncoolkey_v1_get_attribute_len(const u8 *attr, size_t buf_len, size_t *len, int encoded_len)\n{\n\tcoolkey_attribute_header_t *attribute_head = (coolkey_attribute_header_t *)attr;\n\n\t*len = 0;\n\t/* don't reference beyond our buffer */\n\tif (buf_len < sizeof(coolkey_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tswitch (attribute_head->attribute_data_type) {\n\tcase COOLKEY_ATTR_TYPE_STRING:\n\t\tif (buf_len < (sizeof(coolkey_attribute_header_t) +2)) {\n\t\t\tbreak;\n\t\t}\n\t\t*len = bebytes2ushort(attr + sizeof(coolkey_attribute_header_t));\n\t\tif (encoded_len) {\n\t\t\t*len += 2;\n\t\t}\n\t\treturn SC_SUCCESS;\n\tcase COOLKEY_ATTR_TYPE_BOOL_FALSE:\n\tcase COOLKEY_ATTR_TYPE_BOOL_TRUE:\n\t\t/* NOTE: there is no encoded data from TYPE_BOOL_XXX, so we return length 0, but the length\n\t\t * of the attribute is actually 1 byte, so if encoded_len == false, return 1 */\n\t\t*len = encoded_len ? 0: 1;\n\t\treturn SC_SUCCESS;\n\t\tbreak;\n\tcase COOLKEY_ATTR_TYPE_INTEGER:\n\t\t*len = 4; /* length is 4 in both encoded length and attribute length */\n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn SC_ERROR_CORRUPTED_DATA;\n}\n\n/* length of the attribute data is stored in the header of the v0 record */\nstatic int\ncoolkey_v0_get_attribute_len(const u8 *attr, size_t buf_len, size_t *len)\n{\n\tcoolkey_v0_attribute_header_t *attribute_head = (coolkey_v0_attribute_header_t *)attr;\n\t/* don't reference beyond our buffer */\n\tif (buf_len < sizeof(coolkey_v0_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\t*len = bebytes2ushort(attribute_head->attribute_data_len);\n\treturn SC_SUCCESS;\n}\n\n/* these next 3 functions gets the length of the full attribute record, including\n * the attribute header */\nstatic size_t\ncoolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_attribute_header_t);\n\tsize_t len = 0;\n\tint r;\n\n\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);\n\tif (r < 0) {\n\t\treturn buf_len; /* skip to the end, ignore the rest of the record */\n\t}\n\n\treturn MIN(buf_len,attribute_len+len);\n}\n\n\nstatic size_t\ncoolkey_v0_get_attribute_record_len(const u8 *attr, size_t buf_len)\n{\n\tsize_t attribute_len = sizeof(coolkey_v0_attribute_header_t);\n\tsize_t len;\n\tint r;\n\n\tr = coolkey_v0_get_attribute_len(attr, buf_len, &len);\n\tif (r < 0) {\n\t\treturn buf_len; /* skip to the end, ignore the rest of the record */\n\t}\n\treturn MIN(buf_len,attribute_len+len);\n}\n\nstatic size_t\ncoolkey_get_attribute_record_len(const u8 *attr, u8 obj_record_type, size_t buf_len)\n{\n\tif (obj_record_type ==  COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_record_len(attr, buf_len);\n\t}\n\tif (obj_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn buf_len; /* skip to the end */\n\t}\n\treturn coolkey_v1_get_attribute_record_len(attr, buf_len);\n}\n\n/*\n * Attribute type shows up in the same place in all attribute record types. Carry record_type in case\n * this changes in the future.\n */\nstatic CK_ATTRIBUTE_TYPE\ncoolkey_get_attribute_type(const u8 *attr, u8 obj_record_type, size_t buf_len)\n{\n\tcoolkey_attribute_header_t *attribute_header = (coolkey_attribute_header_t *) attr;\n\n\treturn bebytes2ulong(attribute_header->attribute_attr_type);\n}\n\n/*\n * return the start of the attribute section based on the record type\n */\nstatic const u8 *\ncoolkey_attribute_start(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tsize_t offset = object_record_type == COOLKEY_V1_OBJECT ? sizeof(coolkey_object_header_t) :\n\t\t\tsizeof(coolkey_v0_object_header_t);\n\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn NULL;\n\t}\n\tif (offset > buf_len) {\n\t\treturn NULL;\n\t}\n\treturn obj + offset;\n}\n\n/*\n * We don't have the count in the header for v0 attributes,\n * Count them.\n */\nstatic int\ncoolkey_v0_get_attribute_count(const u8 *obj, size_t buf_len)\n{\n\tcoolkey_v0_object_header_t *object_head = (coolkey_v0_object_header_t *)obj;\n\tconst u8 *attr;\n\tint count = 0;\n\tsize_t attribute_data_len;\n\n\t/* make sure we have enough of the object to read the record_type */\n\tif (buf_len <= sizeof(coolkey_v0_object_header_t)) {\n\t\treturn 0;\n\t}\n\t/*\n\t * now loop through all the attributes in the list. first find the start of the list\n\t */\n\tattr = coolkey_attribute_start(obj, COOLKEY_V0_OBJECT, buf_len);\n\tif (attr == NULL) {\n\t\treturn 0;\n\t}\n\n\tbuf_len -= (attr-obj);\n\tattribute_data_len = bebytes2ushort(object_head->attribute_data_len);\n\tif (buf_len < attribute_data_len) {\n\t\treturn 0;\n\t}\n\n\twhile (attribute_data_len) {\n\t\tsize_t len = coolkey_v0_get_attribute_record_len(attr, buf_len);\n\n\t\tif (len == 0) {\n\t\t\tbreak;\n\t\t}\n\t\t/*  This is an error in the token data, don't parse the last attribute */\n\t\tif (len > attribute_data_len) {\n\t\t\tbreak;\n\t\t}\n\t\t/* we know that coolkey_v0_get_attribute_record_len never\n\t\t * \treturns more than buf_len, so we can safely assert that.\n\t\t * \tIf the assert is true, you can easily see that the loop\n\t\t * \twill eventually break with len == 0, even if attribute_data_len\n\t\t * \twas invalid */\n\t\tassert(len <= buf_len);\n\t\tcount++;\n\t\tattr += len;\n\t\tbuf_len -= len;\n\t\tattribute_data_len -= len;\n\t}\n\treturn count;\n}\n\nstatic int\ncoolkey_v1_get_attribute_count(const u8 *obj, size_t buf_len)\n{\n\tcoolkey_object_header_t *object_head = (coolkey_object_header_t *)obj;\n\n\tif (buf_len <= sizeof(coolkey_object_header_t)) {\n\t\treturn 0;\n\t}\n\treturn bebytes2ushort(object_head->attribute_count);\n}\n\nstatic int\ncoolkey_get_attribute_count(const u8 *obj, u8 object_record_type, size_t buf_len)\n{\n\tif (object_record_type == COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_count(obj, buf_len);\n\t}\n\tif (object_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn 0;\n\t}\n\treturn coolkey_v1_get_attribute_count(obj, buf_len);\n}\n\n/*\n * The next three functions return a parsed attribute value from an attribute record.\n */\nstatic int\ncoolkey_v0_get_attribute_data(const u8 *attr, size_t buf_len, sc_cardctl_coolkey_attribute_t *attr_out)\n{\n\t/* we need to manually detect types CK_ULONG */\n\tCK_ATTRIBUTE_TYPE attr_type = coolkey_get_attribute_type(attr, COOLKEY_V0_OBJECT, buf_len);\n\tint r;\n\tsize_t len;\n\n\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_STRING;\n\tattr_out->attribute_length = 0;\n\tattr_out->attribute_value = NULL;\n\n\tr = coolkey_v0_get_attribute_len(attr, buf_len, &len);\n\tif (r < 0) {\n\t\treturn r;\n\t}\n\tif ((attr_type == CKA_CLASS) || (attr_type == CKA_CERTIFICATE_TYPE)\n\t\t\t\t\t\t\t\t\t || (attr_type == CKA_KEY_TYPE)) {\n\t\tif (len != 4) {\n\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t}\n\t/* return the length and the data */\n\tattr_out->attribute_length = len;\n\tattr_out->attribute_value = attr+sizeof(coolkey_v0_attribute_header_t);\n\treturn SC_SUCCESS;\n}\n\nstatic u8 coolkey_static_false = CK_FALSE;\nstatic u8 coolkey_static_true = CK_TRUE;\n\nstatic int\ncoolkey_v1_get_attribute_data(const u8 *attr, size_t buf_len, sc_cardctl_coolkey_attribute_t *attr_out)\n{\n\tint r;\n\tsize_t len;\n\tcoolkey_attribute_header_t *attribute_head = (coolkey_attribute_header_t *)attr;\n\n\tif (buf_len < sizeof(coolkey_attribute_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\n\t/* we must have type V1. Process according to data type */\n\tswitch (attribute_head->attribute_data_type) {\n\t/* ULONG has implied length of 4 */\n\tcase COOLKEY_ATTR_TYPE_INTEGER:\n\t\tif (buf_len < (sizeof(coolkey_attribute_header_t) + 4)) {\n\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = attr + sizeof(coolkey_attribute_header_t);\n\t\treturn SC_SUCCESS;\n\t/* BOOL_FALSE and BOOL_TRUE have implied length and data */\n\t/* return type STRING for BOOLS */\n\tcase COOLKEY_ATTR_TYPE_BOOL_FALSE:\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value =  &coolkey_static_false;\n\t\treturn SC_SUCCESS;\n\tcase COOLKEY_ATTR_TYPE_BOOL_TRUE:\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value =  &coolkey_static_true;\n\t\treturn SC_SUCCESS;\n\t/* string type has encoded length */\n\tcase COOLKEY_ATTR_TYPE_STRING:\n\t\tr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 0);\n\t\tif (r < SC_SUCCESS) {\n\t\t\treturn r;\n\t\t}\n\t\tif (buf_len < (len + sizeof(coolkey_attribute_header_t) + 2)) {\n\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\tattr_out->attribute_value = attr+sizeof(coolkey_attribute_header_t)+2;\n\t\tattr_out->attribute_length = len;\n\t\treturn SC_SUCCESS;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn SC_ERROR_CORRUPTED_DATA;\n}\n\nint\ncoolkey_get_attribute_data(const u8 *attr, u8 object_record_type, size_t buf_len, sc_cardctl_coolkey_attribute_t *attr_out)\n{\n\t/* handle the V0 objects first */\n\tif (object_record_type == COOLKEY_V0_OBJECT) {\n\t\treturn coolkey_v0_get_attribute_data(attr, buf_len, attr_out);\n\t}\n\n\t/* don't crash if we encounter some new or corrupted coolkey device */\n\tif (object_record_type != COOLKEY_V1_OBJECT) {\n\t\treturn SC_ERROR_NO_CARD_SUPPORT;\n\t}\n\n\treturn coolkey_v1_get_attribute_data(attr, buf_len, attr_out);\n\n}\n\n/* convert an attribute type into a  bit in the fixed attribute uint32_t  */\nstatic unsigned long\ncoolkey_get_fixed_boolean_bit(CK_ATTRIBUTE_TYPE type)\n{\n\tswitch(type) {\n\tcase CKA_TOKEN:               return 0x00000080;\n\tcase CKA_PRIVATE:             return 0x00000100;\n\tcase CKA_MODIFIABLE:          return 0x00000200;\n\tcase CKA_DERIVE:              return 0x00000400;\n\tcase CKA_LOCAL:               return 0x00000800;\n\tcase CKA_ENCRYPT:             return 0x00001000;\n\tcase CKA_DECRYPT:             return 0x00002000;\n\tcase CKA_WRAP:                return 0x00004000;\n\tcase CKA_UNWRAP:              return 0x00008000;\n\tcase CKA_SIGN:                return 0x00010000;\n\tcase CKA_SIGN_RECOVER:        return 0x00020000;\n\tcase CKA_VERIFY:              return 0x00040000;\n\tcase CKA_VERIFY_RECOVER:      return 0x00080000;\n\tcase CKA_SENSITIVE:           return 0x00100000;\n\tcase CKA_ALWAYS_SENSITIVE:    return 0x00200000;\n\tcase CKA_EXTRACTABLE:         return 0x00400000;\n\tcase CKA_NEVER_EXTRACTABLE:   return 0x00800000;\n\tdefault: break;\n\t}\n\treturn 0; /* return no bits */\n}\n/* This table lets us return a pointer to the CKA_ID value without allocating data or\n * creating a changeable static that could cause thread issues */\nstatic const u8 coolkey_static_cka_id[16] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n};\n\n/* This table provides the following:\n *     1) a mapping from a 3 bit cka_class to a full 32 bit CKA_CLASS_TYPE value we can return.\n *     2) the mask of valid boolean attributes in the fixed attributes.\n */\nstruct coolkey_fixed_class {\n\tu8 class_value[4];\n\tunsigned long boolean_mask;\n};\n\nstatic const struct coolkey_fixed_class coolkey_static_cka_class[8] = {\n\t{ { 0, 0, 0, 0}, 0x00000380 }, /* DATA */\n\t{ { 0, 0, 0, 1}, 0x00000380 }, /* CERTIFICATE */\n\t{ { 0, 0, 0, 2}, 0x000c5f80 }, /* PUBLIC_KEY */\n\t{ { 0, 0, 0, 3}, 0x00f3af80 }, /* PRIVATE_KEY */\n\t{ { 0, 0, 0, 4}, 0x00f5ff80 }, /* SECRET_KEY */\n\t{ { 0, 0, 0, 5}, 0x00000000 },\n\t{ { 0, 0, 0, 6}, 0x00000000 },\n\t{ { 0, 0, 0, 7}, 0x00000000 }\n};\n\n/*\n * handle fixed attributes (V1 only)\n */\nstatic int\ncoolkey_get_attribute_data_fixed(CK_ATTRIBUTE_TYPE attr_type, unsigned long fixed_attributes,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsc_cardctl_coolkey_attribute_t *attr_out) {\n\tunsigned long cka_id = fixed_attributes & 0xf;\n\tunsigned long cka_class = ((fixed_attributes) >> 4) & 0x7;\n\tunsigned long mask, bit;\n\n\tif (attr_type == CKA_ID) {\n\t\tattr_out->attribute_length = 1;\n\t\tattr_out->attribute_value= &coolkey_static_cka_id[cka_id];\n\t\treturn SC_SUCCESS;\n\t}\n\tif (attr_type == CKA_CLASS) {\n\t\tattr_out->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_ULONG;\n\t\tattr_out->attribute_length = 4;\n\t\tattr_out->attribute_value = coolkey_static_cka_class[cka_class].class_value;\n\t\treturn SC_SUCCESS;\n\t}\n\t/* If it matched, it must be one of the booleans */\n\tmask = coolkey_static_cka_class[cka_class].boolean_mask;\n\tbit = coolkey_get_fixed_boolean_bit(attr_type);\n\t/* attribute isn't in the list */\n\tif ((bit & mask) == 0) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tattr_out->attribute_length = 1;\n\tattr_out->attribute_value = bit & fixed_attributes ? &coolkey_static_true : &coolkey_static_false;\n\treturn SC_SUCCESS;\n}\n\n\n\nstatic int\ncoolkey_v1_get_object_length(u8 *obj, size_t buf_len)\n{\n\tcoolkey_combined_object_header_t *object_head = (coolkey_combined_object_header_t *) obj;\n\tint attribute_count;\n\tu8 *current_attribute;\n\tint j;\n\tsize_t len;\n\n\tlen = sizeof(coolkey_combined_object_header_t);\n\tif (buf_len <= len) {\n\t\treturn buf_len;\n\t}\n\tattribute_count = bebytes2ushort(object_head->attribute_count);\n\tbuf_len -= len;\n\n\tfor (current_attribute = obj + len, j = 0; j < attribute_count; j++) {\n\t\tsize_t attribute_len = coolkey_v1_get_attribute_record_len(current_attribute, buf_len);\n\n\t\tlen += attribute_len;\n\t\tcurrent_attribute += attribute_len;\n\t\tbuf_len -= attribute_len;\n\t}\n\treturn len;\n}\n\n/*\n * COOLKEY private data per card state\n */\ntypedef struct coolkey_private_data {\n\tu8 protocol_version_major;\n\tu8 protocol_version_minor;\n\tu8 format_version_major;\n\tu8 format_version_minor;\n\tunsigned short object_version;\n\tu8 life_cycle;\n\tu8 pin_count;\n\tu8 *token_name;\t\t\t\t/* our token name read from the token */\n\tsize_t token_name_length;\t\t/* length of our token name */\n\tu8 nonce[COOLKEY_NONCE_SIZE];\t\t/* nonce returned from login */\n\tint nonce_valid;\n\tcoolkey_cuid_t cuid;\t\t\t/* card unique ID from the CCC */\n\tsc_cardctl_coolkey_object_t *obj;\t/* pointer to the current selected object */\n\tlist_t objects_list;\t\t\t/* list of objects on the token */\n\tunsigned short key_id;\t\t\t/* key id set by select */\n\tint\talgorithm;\t\t\t/* saved from set_security_env */\n\tint operation;\t\t\t\t/* saved from set_security_env */\n} coolkey_private_data_t;\n\n#define COOLKEY_DATA(card) ((coolkey_private_data_t*)card->drv_data)\n\nint\ncoolkey_compare_id(const void * a, const void *b)\n{\n\tif (a == NULL || b == NULL)\n\t\treturn 1;\n\treturn ((sc_cardctl_coolkey_object_t *)a)->id\n\t    != ((sc_cardctl_coolkey_object_t *)b)->id;\n}\n\n/* For SimCList autocopy, we need to know the size of the data elements */\nsize_t coolkey_list_meter(const void *el) {\n\treturn sizeof(sc_cardctl_coolkey_object_t);\n}\n\nstatic void coolkey_free_private_data(coolkey_private_data_t *priv);\n\nstatic coolkey_private_data_t *coolkey_new_private_data(void)\n{\n\tcoolkey_private_data_t *priv;\n\n\t/* allocate priv and zero all the fields */\n\tpriv = calloc(1, sizeof(coolkey_private_data_t));\n\tif (!priv)\n\t\treturn NULL;\n\n\t/* set other fields as appropriate */\n\tpriv->key_id = COOLKEY_INVALID_KEY;\n\tif (list_init(&priv->objects_list) != 0 ||\n\t    list_attributes_comparator(&priv->objects_list, coolkey_compare_id) != 0 ||\n\t    list_attributes_copy(&priv->objects_list, coolkey_list_meter, 1) != 0) {\n\t\tcoolkey_free_private_data(priv);\n\t\treturn NULL;\n\t}\n\n\treturn priv;\n}\n\nstatic void coolkey_free_private_data(coolkey_private_data_t *priv)\n{\n\tlist_t *l = &priv->objects_list;\n\tsc_cardctl_coolkey_object_t *o;\n\n\t/* Clean up the allocated memory in the items */\n\tlist_iterator_start(l);\n\twhile (list_iterator_hasnext(l)) {\n\t\to = (sc_cardctl_coolkey_object_t *)list_iterator_next(l);\n\t\tfree(o->data);\n\t\to->data = NULL;\n\t}\n\tlist_iterator_stop(l);\n\n\tlist_destroy(&priv->objects_list);\n\tif (priv->token_name) {\n\t\tfree(priv->token_name);\n\t}\n\tfree(priv);\n\treturn;\n}\n\n/*\n * Object list operations\n */\nstatic int coolkey_add_object_to_list(list_t *list, const sc_cardctl_coolkey_object_t *object)\n{\n\tif (list_append(list, object) < 0)\n\t\treturn SC_ERROR_UNKNOWN;\n\treturn SC_SUCCESS;\n}\n\n#define COOLKEY_AID \"\\xA0\\x00\\x00\\x01\\x16\"\nstatic sc_cardctl_coolkey_object_t *\ncoolkey_find_object_by_id(list_t *list, unsigned long object_id)\n{\n\tint pos;\n\tstatic sc_cardctl_coolkey_object_t cmp = {{\n\t\t\"\", 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t\t{ COOLKEY_AID, sizeof(COOLKEY_AID)-1 }\n\t}, 0, 0, NULL};\n\n\tcmp.id = object_id;\n\tif ((pos = list_locate(list, &cmp)) < 0)\n\t\treturn NULL;\n\n\treturn list_get_at(list, pos);\n}\n\n\nstatic const sc_path_t coolkey_template_path = {\n\t\"\", 0, 0, 0, SC_PATH_TYPE_DF_NAME,\n\t{ COOLKEY_AID, sizeof(COOLKEY_AID)-1 }\n};\n\nstruct coolkey_error_codes_st {\n\tint sc_error;\n\tchar *description;\n};\n\nstatic const struct coolkey_error_codes_st coolkey_error_codes[]= {\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c00\" },\n\t{SC_ERROR_NOT_ENOUGH_MEMORY,             \"No memory left on card\" },\n\t{SC_ERROR_PIN_CODE_INCORRECT,            \"Authentication failed\" },\n\t{SC_ERROR_NOT_ALLOWED,                   \"Operation not allowed\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c04\" },\n\t{SC_ERROR_NO_CARD_SUPPORT,               \"Unsupported feature\" },\n\t{SC_ERROR_SECURITY_STATUS_NOT_SATISFIED, \"Not authorized\" },\n\t{SC_ERROR_DATA_OBJECT_NOT_FOUND,         \"Object not found\" },\n\t{SC_ERROR_FILE_ALREADY_EXISTS,           \"Object exists\" },\n\t{SC_ERROR_NO_CARD_SUPPORT,               \"Incorrect Algorithm\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c0a\" },\n\t{SC_ERROR_SM_INVALID_CHECKSUM,           \"Signature invalid\" },\n\t{SC_ERROR_AUTH_METHOD_BLOCKED,           \"Identity blocked\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c0d\" },\n\t{SC_ERROR_UNKNOWN,                       \"Reserved 0x9c0e\" },\n\t{SC_ERROR_INCORRECT_PARAMETERS,          \"Invalid parameter\" },\n\t{SC_ERROR_INCORRECT_PARAMETERS,          \"Incorrect P1\" },\n\t{SC_ERROR_INCORRECT_PARAMETERS,          \"Incorrect P2\" },\n\t{SC_ERROR_FILE_END_REACHED,              \"Sequence End\" },\n};\n\nstatic const unsigned int\ncoolkey_number_of_error_codes = sizeof(coolkey_error_codes)/sizeof(coolkey_error_codes[0]);\n\nstatic int coolkey_check_sw(sc_card_t *card, unsigned int sw1, unsigned int sw2)\n{\n\tsc_log(card->ctx, \n\t\t\"sw1 = 0x%02x, sw2 = 0x%02x\\n\", sw1, sw2);\n\n\tif (sw1 == 0x90 && sw2 == 0x00)\n\t\treturn SC_SUCCESS;\n\n\tif (sw1 == 0x9c) {\n\t\tif (sw2 == 0xff) {\n\t\t\t/* shouldn't happen on a production applet, 0x9cff is a debugging error code */\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tif (sw2 >= coolkey_number_of_error_codes) {\n\t\t\treturn SC_ERROR_UNKNOWN;\n\t\t}\n\t\treturn coolkey_error_codes[sw2].sc_error;\n\t}\n\n\t/* iso error */\n        return sc_get_iso7816_driver()->ops->check_sw(card, sw1, sw2);\n}\n\n/*\n * Send a command and receive data.\n *\n * A caller may provide a buffer, and length to read. If not provided,\n * an internal 4096 byte buffer is used, and a copy is returned to the\n * caller. that need to be freed by the caller.\n *\n * modelled after a similar function in card-piv.c. The coolkey version\n * adds the coolkey nonce to user authenticated operations.\n */\n\nstatic int coolkey_apdu_io(sc_card_t *card, int cla, int ins, int p1, int p2,\n\tconst u8 * sendbuf, size_t sendbuflen, u8 ** recvbuf, size_t * recvbuflen,\n\tconst u8 *nonce, size_t nonce_len)\n{\n\tint r;\n\tsc_apdu_t apdu;\n\tu8 rbufinitbuf[COOLKEY_MAX_SIZE];\n\tu8 rsendbuf[COOLKEY_MAX_SIZE];\n\tu8 *rbuf;\n\tsize_t rbuflen;\n\tint cse = 0;\n\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_log(card->ctx, \n\t\t \"%02x %02x %02x %\"SC_FORMAT_LEN_SIZE_T\"u : %\"SC_FORMAT_LEN_SIZE_T\"u %\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t ins, p1, p2, sendbuflen, card->max_send_size,\n\t\t card->max_recv_size);\n\n\trbuf = rbufinitbuf;\n\trbuflen = sizeof(rbufinitbuf);\n\n\t/* if caller provided a buffer and length */\n\tif (recvbuf && *recvbuf && recvbuflen && *recvbuflen) {\n\t\trbuf = *recvbuf;\n\t\trbuflen = *recvbuflen;\n\t}\n\n\tif (sendbuf || nonce) {\n\t\tif (recvbuf) {\n\t\t\tcse = SC_APDU_CASE_4_SHORT;\n\t\t} else {\n\t\t\tcse = SC_APDU_CASE_3_SHORT;\n\t\t}\n\t} else {\n\t\tif (recvbuf) {\n\t\t\tcse = SC_APDU_CASE_2_SHORT;\n\t\t} else {\n\t\t\tcse = SC_APDU_CASE_1;\n\t\t}\n\t}\n\n\t/* append the nonce if we have it. Coolkey just blindly puts this at the end\n\t * of the APDU (while adjusting lc). This converts case 1 to case 3. coolkey\n\t * also always drops le in case 4 (which happens when proto = T0). nonces are\n\t * never used on case 2 commands, so we can simply append the nonce to the data\n\t * and we should be fine */\n\tif (nonce) {\n\t\tu8 *buf = rsendbuf;\n\t\tif (sendbuf) {\n\t\t\tsendbuflen = MIN(sendbuflen,sizeof(rsendbuf)-nonce_len);\n\t\t\tmemcpy(rsendbuf, sendbuf, sendbuflen);\n\t\t\tbuf += sendbuflen;\n\t\t}\n\t\tmemcpy(buf, nonce, nonce_len);\n\t\tsendbuflen += nonce_len;\n\t\tsendbuf =rsendbuf;\n\t}\n\n\tsc_format_apdu(card, &apdu, cse, ins, p1, p2);\n\n\tapdu.lc = sendbuflen;\n\tapdu.datalen = sendbuflen;\n\tapdu.data = sendbuf;\n\n\n\t/* coolkey uses non-standard classes */\n\tapdu.cla = cla;\n\n\tif (recvbuf) {\n\t\tapdu.resp = rbuf;\n\t\tapdu.le = (rbuflen > 255) ? 255 : rbuflen;\n\t\tapdu.resplen = rbuflen;\n\t} else {\n\t\t apdu.resp =  rbuf;\n\t\t apdu.le = 0;\n\t\t apdu.resplen = 0;\n\t}\n\n\tsc_log(card->ctx, \n\t\t \"calling sc_transmit_apdu flags=%lx le=%\"SC_FORMAT_LEN_SIZE_T\"u, resplen=%\"SC_FORMAT_LEN_SIZE_T\"u, resp=%p\",\n\t\t apdu.flags, apdu.le, apdu.resplen, apdu.resp);\n\n\t/* with new adpu.c and chaining, this actually reads the whole object */\n\tr = sc_transmit_apdu(card, &apdu);\n\n\tsc_log(card->ctx, \n\t\t \"result r=%d apdu.resplen=%\"SC_FORMAT_LEN_SIZE_T\"u sw1=%02x sw2=%02x\",\n\t\t r, apdu.resplen, apdu.sw1, apdu.sw2);\n\n\tif (r < 0) {\n\t\tsc_log(card->ctx, \"Transmit failed\");\n\t\tgoto err;\n\t}\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r < 0) {\n\t\tsc_log(card->ctx, \"Transmit failed\");\n\t\tgoto err;\n\t}\n\n\tif (recvbuflen) {\n\t\tif (recvbuf && *recvbuf == NULL) {\n\t\t\t*recvbuf =  malloc(apdu.resplen);\n\t\t\tif (*recvbuf == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tmemcpy(*recvbuf, rbuf, apdu.resplen);\n\t\t}\n\t\t*recvbuflen =  apdu.resplen;\n\t\tr = *recvbuflen;\n\t}\n\nerr:\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/*\n * Helpers to handle coolkey commands\n */\nstatic int\ncoolkey_get_life_cycle(sc_card_t *card, coolkey_life_cycle_t *life_cycle)\n{\n\tcoolkey_status_t status;\n\tu8 *receive_buf;\n\tsize_t receive_len;\n\tint len;\n\n\treceive_len = sizeof(*life_cycle);\n\treceive_buf = (u8 *)life_cycle;\n\tlen = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_LIFE_CYCLE, 0, 0,\n\t\t\tNULL, 0, &receive_buf, &receive_len, NULL, 0);\n\tif (len == sizeof(*life_cycle)) {\n\t\treturn SC_SUCCESS;\n\t}\n\n\treceive_len = 1;\n\treceive_buf = &life_cycle->life_cycle;\n\tlen = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_LIFE_CYCLE, 0, 0,\n\t\t\tNULL, 0, &receive_buf, &receive_len, NULL, 0);\n\tif (len < 0) { /* Error from the trasmittion */\n\t\treturn len;\n\t}\n\tif (len != 1) { /* The returned data is invalid */\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\treceive_len = sizeof(status);\n\treceive_buf = (u8 *)&status;\n\tlen = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_STATUS, 0, 0,\n\t\t\tNULL, 0, &receive_buf, &receive_len, NULL, 0);\n\tif (len < 0) { /* Error from the trasmittion */\n\t\treturn len;\n\t}\n\tif (len != sizeof(status)) { /* The returned data is invalid */\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\tlife_cycle->protocol_version_major = status.protocol_version_major;\n\tlife_cycle->protocol_version_minor = status.protocol_version_minor;\n\tlife_cycle->pin_count = status.pin_count;\n\treturn SC_SUCCESS;\n}\n\n/* select the coolkey applet */\nstatic int coolkey_select_applet(sc_card_t *card)\n{\n\tu8 aid[] = { 0x62, 0x76, 0x01, 0xff, 0x00, 0x00, 0x00 };\n\treturn coolkey_apdu_io(card, ISO7816_CLASS, ISO7816_INS_SELECT_FILE, 4, 0,\n\t\t\t&aid[0], sizeof(aid), NULL, NULL,  NULL, 0);\n}\n\nstatic void\ncoolkey_make_cuid_from_cplc(coolkey_cuid_t *cuid, global_platform_cplc_data_t *cplc_data)\n{\n\tcuid->ic_fabricator[0]    = cplc_data->ic_fabricator[0];\n\tcuid->ic_fabricator[1]    = cplc_data->ic_fabricator[1];\n\tcuid->ic_type[0]          = cplc_data->ic_type[0];\n\tcuid->ic_type[1]          = cplc_data->ic_type[1];\n\tcuid->ic_batch[0]         = cplc_data->ic_batch[0];\n\tcuid->ic_batch[1]         = cplc_data->ic_batch[1];\n\tcuid->ic_serial_number[0] = cplc_data->ic_serial_number[0];\n\tcuid->ic_serial_number[1] = cplc_data->ic_serial_number[1];\n\tcuid->ic_serial_number[2] = cplc_data->ic_serial_number[2];\n\tcuid->ic_serial_number[3] = cplc_data->ic_serial_number[3];\n}\n\n/*\n * Read a COOLKEY coolkey object.\n */\nstatic int coolkey_read_object(sc_card_t *card, unsigned long object_id, size_t offset,\n\t\t\tu8 *out_buf, size_t out_len, u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_read_object_param_t params;\n\tu8 *out_ptr;\n\tsize_t left = 0;\n\tsize_t len;\n\tint r;\n\n\tulong2bebytes(&params.object_id[0], object_id);\n\n\tout_ptr = out_buf;\n\tleft = out_len;\n\tdo {\n\t\tulong2bebytes(&params.offset[0], offset);\n\t\tparams.length = MIN(left, COOLKEY_MAX_CHUNK_SIZE);\n\t\tlen = left;\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_READ_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params), &out_ptr, &len, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\t/* sanity check to make sure we don't overflow left */\n\t\tif ((left < len) || (len == 0)) {\n\t\t\tr = SC_ERROR_INTERNAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tout_ptr += len;\n\t\toffset += len;\n\t\tleft -= len;\n\t} while (left != 0);\n\n\treturn out_len;\n\nfail:\n\treturn r;\n}\n\n/*\n * Write a COOLKEY coolkey object.\n */\nstatic int coolkey_write_object(sc_card_t *card, unsigned long object_id,\n\t\t\tsize_t offset, const u8 *buf, size_t buf_len, const u8 *nonce, size_t nonce_size)\n{\n\tcoolkey_write_object_param_t params;\n\tsize_t operation_len;\n\tsize_t left = buf_len;\n\tint r;\n\tsize_t max_operation_len;\n\n\t/* set limit for the card's maximum send size and short write */\n\tmax_operation_len = MIN(COOLKEY_MAX_CHUNK_SIZE, (card->max_send_size - sizeof(coolkey_read_object_param_t) - nonce_size));\n\n\tulong2bebytes(&params.head.object_id[0], object_id);\n\n\tdo {\n\t\tulong2bebytes(&params.head.offset[0], offset);\n\t\toperation_len = MIN(left, max_operation_len);\n\t\tparams.head.length = operation_len;\n\t\tmemcpy(params.buf, buf, operation_len);\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_WRITE_OBJECT, 0, 0,\n\t\t\t(u8 *)&params, sizeof(params.head)+operation_len, NULL, 0, nonce, nonce_size);\n\t\tif (r < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\tbuf += operation_len;\n\t\toffset += operation_len;\n\t\tleft -= operation_len;\n\t} while (left != 0);\n\n\treturn buf_len - left;\n\nfail:\n\treturn r;\n}\n\n/*\n * coolkey_read_binary will read a coolkey object off the card. That object is selected\n * by select file. If we've already read the object, we'll return the data from the cache.\n * coolkey objects are encoded PKCS #11 entries, not pkcs #15 data. pkcs15-coolkey will\n * translate the objects into their PKCS #15 equivalent data structures.\n */\nstatic int coolkey_read_binary(sc_card_t *card, unsigned int idx,\n\t\tu8 *buf, size_t count, unsigned long flags)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint r = 0, len;\n\tu8 *data = NULL;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (idx > priv->obj->length) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_FILE_END_REACHED);\n\t}\n\n\t/* if we've already read the data, just return it */\n\tif (priv->obj->data) {\n\t\tsc_log(card->ctx, \n\t\t\t \"returning cached value idx=%u count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t idx, count);\n\t\tlen = MIN(count, priv->obj->length-idx);\n\t\tmemcpy(buf, &priv->obj->data[idx], len);\n\t\tLOG_FUNC_RETURN(card->ctx, len);\n\t}\n\n\tsc_log(card->ctx, \n\t\t \"clearing cache idx=%u count=%\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t idx, count);\n\n\tdata = malloc(priv->obj->length);\n\tif (data == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto done;\n\t}\n\n\n\tr = coolkey_read_object(card, priv->obj->id, 0, data, priv->obj->length,\n\t\t\t\t\t\t\t\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\tif (r < 0)\n\t\tgoto done;\n\n\tif ((size_t) r != priv->obj->length) {\n\t\tpriv->obj->length = r;\n\t}\n\n\n\t/* OK we've read the data, now copy the required portion out to the callers buffer */\n\tlen = MIN(count, priv->obj->length-idx);\n\tmemcpy(buf, &data[idx], len);\n\tr = len;\n\t/* cache the data in the object */\n\tpriv->obj->data=data;\n\tdata = NULL;\n\ndone:\n\tif (data)\n\t\tfree(data);\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\n/* COOLKEY driver is read only. NOTE: The applet supports w/r operations, so it's perfectly\n * reasonable to try to create new objects, but currently TPS does not create applets\n * That allow user created objects, so this is a nice 2.0 feature. */\nstatic int coolkey_write_binary(sc_card_t *card, unsigned int idx,\n\t\tconst u8 *buf, size_t count, unsigned long flags)\n{\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\n/* initialize getting a list and return the number of elements in the list */\nstatic int coolkey_get_init_and_get_count(list_t *list, int *countp)\n{\n\t*countp = list_size(list);\n\tlist_iterator_start(list);\n\treturn SC_SUCCESS;\n}\n\n/* fill in the obj_info for the current object on the list and advance to the next object */\nstatic int coolkey_fetch_object(list_t *list, sc_cardctl_coolkey_object_t *coolkey_obj)\n{\n\tsc_cardctl_coolkey_object_t *ptr;\n\tif (!list_iterator_hasnext(list)) {\n\t\treturn SC_ERROR_FILE_END_REACHED;\n\t}\n\n\tptr = list_iterator_next(list);\n\t*coolkey_obj = *ptr;\n\treturn SC_SUCCESS;\n}\n\n/* Finalize iterator */\nstatic int coolkey_final_iterator(list_t *list)\n{\n\tlist_iterator_stop(list);\n\treturn SC_SUCCESS;\n}\n\nstatic char * coolkey_cuid_to_string(coolkey_cuid_t *cuid)\n{\n\tchar *buf;\n\tsize_t len = sizeof(coolkey_cuid_t)*2 + 1;\n\tbuf = malloc(len);\n\tif (buf == NULL) {\n\t\treturn NULL;\n\t}\n\tsc_bin_to_hex((u8 *)cuid, sizeof(*cuid), buf, len, 0);\n\treturn buf;\n}\n\nstatic const struct manufacturer_list_st {\n\tunsigned short id;\n\tchar *string;\n} manufacturer_list[] = {\n\t{ 0x2050, \"%04x Oberthur\" },\n\t{ 0x4090, \"%04x GemAlto (Infineon)\" },\n\t{ 0x4780, \"%04x STMicroElectronics\" },\n\t{ 0x4780, \"%04x RSA\" },\n\t{ 0x534e, \"%04x SafeNet\" },\n};\n\nint manufacturer_list_count = sizeof(manufacturer_list)/sizeof(manufacturer_list[0]);\n\nstatic char * coolkey_get_manufacturer(coolkey_cuid_t *cuid)\n{\n\tunsigned short fabricator = bebytes2ushort(cuid->ic_fabricator);\n\tint i;\n\tchar *buf;\n\tconst char *manufacturer_string = \"%04x Unknown\";\n\tsize_t len;\n\tint r;\n\n\tfor (i=0; i < manufacturer_list_count; i++) {\n\t\tif (manufacturer_list[i].id == fabricator) {\n\t\t\tmanufacturer_string = manufacturer_list[i].string;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlen = strlen(manufacturer_string)+1;\n\tbuf= malloc(len);\n\tif (buf == NULL) {\n\t\treturn NULL;\n\t}\n\tr = snprintf(buf, len, manufacturer_string, fabricator);\n\tif (r < 0) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\treturn buf;\n}\n\n\nstatic int coolkey_get_token_info(sc_card_t *card, sc_pkcs15_tokeninfo_t * token_info)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tchar *label = NULL;\n\tchar *manufacturer_id = NULL;\n\tchar *serial_number = NULL;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tlabel = strdup((char *)priv->token_name);\n\tmanufacturer_id = coolkey_get_manufacturer(&priv->cuid);\n\tserial_number = coolkey_cuid_to_string(&priv->cuid);\n\n\tif (label && manufacturer_id && serial_number) {\n\t\ttoken_info->label = label;\n\t\ttoken_info->manufacturer_id = manufacturer_id;\n\t\ttoken_info->serial_number = serial_number;\n\t\treturn SC_SUCCESS;\n\t}\n\tfree(label);\n\tfree(manufacturer_id);\n\tfree(serial_number);\n\treturn SC_ERROR_OUT_OF_MEMORY;\n}\n\nstatic int coolkey_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tmemcpy(serial->value, &priv->cuid, sizeof(priv->cuid));\n\tserial->len = sizeof(priv->cuid);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\nint\ncoolkey_fill_object(sc_card_t *card, sc_cardctl_coolkey_object_t *obj)\n{\n\tint r;\n\tsize_t buf_len = obj->length;\n\tu8 *new_obj_data = NULL;\n\tsc_cardctl_coolkey_object_t *obj_entry;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tif (obj->data != NULL) {\n\t\treturn SC_SUCCESS;\n\t}\n\tnew_obj_data = malloc(buf_len);\n\tif (new_obj_data == NULL) {\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tr = coolkey_read_object(card, obj->id, 0, new_obj_data, buf_len,\n\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\tif (r != (int)buf_len) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tobj_entry = coolkey_find_object_by_id(&priv->objects_list, obj->id);\n\tif (obj_entry == NULL) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_INTERNAL; /* shouldn't happen */\n\t}\n\tif (obj_entry->data != NULL) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_INTERNAL; /* shouldn't happen */\n\t}\n\t/* Make sure we will not go over the allocated limits in the other\n\t * objects if they somehow got different lengths in matching objects */\n\tif (obj_entry->length != obj->length) {\n\t\tfree(new_obj_data);\n\t\treturn SC_ERROR_INTERNAL; /* shouldn't happen */\n\t}\n\tobj_entry->data = new_obj_data;\n\tobj->data = new_obj_data;\n\treturn SC_SUCCESS;\n}\n\n/*\n * return a parsed record for the attribute which includes value, type, and length.\n * Handled both v1 and v0 record types. determine record type from the object.\n *  make sure we don't overrun the buffer if the token gives us bad data.\n */\nstatic int\ncoolkey_find_attribute(sc_card_t *card, sc_cardctl_coolkey_attribute_t *attribute)\n{\n\tu8 object_record_type;\n\tCK_ATTRIBUTE_TYPE attr_type = attribute->attribute_type;\n\tconst u8 *obj = attribute->object->data;\n\tconst u8 *attr = NULL;\n\tsize_t buf_len = attribute->object->length;\n\tcoolkey_object_header_t *object_head;\n\tint attribute_count,i;\n\tattribute->attribute_data_type = SC_CARDCTL_COOLKEY_ATTR_TYPE_STRING;\n\tattribute->attribute_length = 0;\n\tattribute->attribute_value = NULL;\n\n\tif (obj == NULL) {\n\t\t/* cast away const so we can cache the data value */\n\t\tint r = coolkey_fill_object(card, (sc_cardctl_coolkey_object_t *)attribute->object);\n\t\tif (r < 0) {\n\t\t\treturn r;\n\t\t}\n\t\tobj = attribute->object->data;\n\t\tif (obj == NULL) {\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t}\n\n\t/* should be a static assert so we catch this at compile time */\n\tassert(sizeof(coolkey_object_header_t) >= sizeof(coolkey_v0_object_header_t));\n\t/* make sure we have enough of the object to read the record_type */\n\tif (buf_len <= sizeof(coolkey_v0_object_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tobject_head = (coolkey_object_header_t *)obj;\n\tobject_record_type = object_head->record_type;\n\t/* make sure it's a type we recognize */\n\tif ((object_record_type != COOLKEY_V1_OBJECT) && (object_record_type != COOLKEY_V0_OBJECT)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\n\n\t/*\n\t * now loop through all the attributes in the list. first find the start of the list\n\t */\n\tattr = coolkey_attribute_start(obj, object_record_type, buf_len);\n\tif (attr == NULL) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tbuf_len -= (attr-obj);\n\n\t/* now get the count */\n\tattribute_count = coolkey_get_attribute_count(obj, object_record_type, buf_len);\n\tfor (i=0; i < attribute_count; i++) {\n\t\tsize_t record_len = coolkey_get_attribute_record_len(attr, object_record_type, buf_len);\n\t\t/* make sure we have the complete record */\n\t\tif (buf_len < record_len || record_len < 4) {\n\t\t\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t\t}\n\t\t/* does the attribute match the one we are looking for */\n\t\tif (attr_type == coolkey_get_attribute_type(attr, object_record_type, record_len)) {\n\t\t\t/* yup, return it */\n\t\t\treturn coolkey_get_attribute_data(attr, object_record_type, record_len, attribute);\n\t\t}\n\t\t/* go to the next attribute on the list */\n\t\tbuf_len -= record_len;\n\t\tattr += record_len;\n\t}\n\t/* not find in attribute list, check the fixed attribute record */\n\tif (object_record_type == COOLKEY_V1_OBJECT) {\n\t\tunsigned long fixed_attributes = bebytes2ulong(object_head->fixed_attributes_values);\n\n\t\treturn coolkey_get_attribute_data_fixed(attr_type, fixed_attributes, attribute);\n\t}\n\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n}\n\n/*\n * pkcs 15 needs to find the cert matching the keys to fill in some of the fields that wasn't stored\n * with the key. To do this we need to look for the cert matching the key's CKA_ID. For flexibility,\n * We simply search using a pkcs #11 style template using the cardctl_coolkey_attribute_t structure */\nsc_cardctl_coolkey_object_t *\ncoolkey_find_object_by_template(sc_card_t *card, sc_cardctl_coolkey_attribute_t *template, int count)\n{\n\tlist_t *list;\n\tsc_cardctl_coolkey_object_t *current, *rv = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint i, r;\n\tunsigned int tmp_pos = (unsigned int) -1;\n\n\tlist = &priv->objects_list;\n\tif (list->iter_active) {\n\t\t/* workaround missing functionality of second iterator */\n\t\ttmp_pos = list->iter_pos;\n\t\tlist_iterator_stop(list);\n\t}\n\n\tlist_iterator_start(list);\n\twhile (list_iterator_hasnext(list)) {\n\t\tsc_cardctl_coolkey_attribute_t attribute;\n\t\tcurrent = list_iterator_next(list);\n\t\tattribute.object = current;\n\n\t\tfor (i=0; i < count; i++) {\n\t\t\tattribute.attribute_type = template[i].attribute_type;\n\t\t\tr = coolkey_find_attribute(card, &attribute);\n\t\t\tif (r < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (template[i].attribute_data_type != attribute.attribute_data_type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (template[i].attribute_length != attribute.attribute_length) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (memcmp(attribute.attribute_value, template[i].attribute_value,\n\t\t\t\t\t\t\tattribute.attribute_length) != 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* just return the first one */\n\t\tif (i == count) {\n\t\t\trv = current;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlist_iterator_stop(list);\n\tif (tmp_pos != (unsigned int)-1) {\n\t\t/* workaround missing functionality of second iterator */\n\t\tlist_iterator_start(list);\n\t\twhile (list_iterator_hasnext(list) && list->iter_pos < tmp_pos)\n\t\t\t(void) list_iterator_next(list);\n\t}\n\treturn rv;\n}\n\nstatic int\ncoolkey_find_object(sc_card_t *card, sc_cardctl_coolkey_find_object_t *fobj)\n{\n\tsc_cardctl_coolkey_object_t *obj = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint r;\n\n\tswitch (fobj->type) {\n\tcase SC_CARDCTL_COOLKEY_FIND_BY_ID:\n\t\tobj = coolkey_find_object_by_id(&priv->objects_list, fobj->find_id);\n\t\tbreak;\n\tcase SC_CARDCTL_COOLKEY_FIND_BY_TEMPLATE:\n\t\tobj = coolkey_find_object_by_template(card, fobj->coolkey_template, fobj->template_count);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (obj == NULL) {\n\t\treturn SC_ERROR_DATA_OBJECT_NOT_FOUND;\n\t}\n\tif (obj->data == NULL) {\n\t\tr = coolkey_fill_object(card, obj);\n\t\tif (r < 0) {\n\t\t\treturn r;\n\t\t}\n\t}\n\tfobj->obj = obj;\n\treturn SC_SUCCESS;\n}\n\nstatic int coolkey_card_ctl(sc_card_t *card, unsigned long cmd, void *ptr)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tLOG_FUNC_CALLED(card->ctx);\n\tsc_log(card->ctx, \"cmd=%ld ptr=%p\", cmd, ptr);\n\n\tif (priv == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INTERNAL);\n\t}\n\tswitch(cmd) {\n\t\tcase SC_CARDCTL_GET_SERIALNR:\n\t\t\treturn coolkey_get_serial_nr_from_CUID(card, (sc_serial_number_t *) ptr);\n\t\tcase SC_CARDCTL_COOLKEY_GET_TOKEN_INFO:\n\t\t\treturn coolkey_get_token_info(card, (sc_pkcs15_tokeninfo_t *) ptr);\n\t\tcase SC_CARDCTL_COOLKEY_FIND_OBJECT:\n\t\t\treturn coolkey_find_object(card, (sc_cardctl_coolkey_find_object_t *)ptr);\n\t\tcase SC_CARDCTL_COOLKEY_INIT_GET_OBJECTS:\n\t\t\treturn coolkey_get_init_and_get_count(&priv->objects_list, (int *)ptr);\n\t\tcase SC_CARDCTL_COOLKEY_GET_NEXT_OBJECT:\n\t\t\treturn coolkey_fetch_object(&priv->objects_list, (sc_cardctl_coolkey_object_t *)ptr);\n\t\tcase SC_CARDCTL_COOLKEY_FINAL_GET_OBJECTS:\n\t\t\treturn coolkey_final_iterator(&priv->objects_list);\n\t\tcase SC_CARDCTL_COOLKEY_GET_ATTRIBUTE:\n\t\t\treturn coolkey_find_attribute(card,(sc_cardctl_coolkey_attribute_t *)ptr);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n}\n\nstatic int coolkey_get_challenge(sc_card_t *card, u8 *rnd, size_t len)\n{\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (len > COOLKEY_MAX_CHUNK_SIZE)\n\t\tlen = COOLKEY_MAX_CHUNK_SIZE;\n\n\tLOG_TEST_RET(card->ctx,\n\t\t\tcoolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_GET_RANDOM, 0, 0,\n\t\t\t\tNULL, 0, &rnd, &len,  NULL, 0),\n\t\t\t\"Could not get challenge\");\n\n\tLOG_FUNC_RETURN(card->ctx, (int) len);\n}\n\nstatic int coolkey_set_security_env(sc_card_t *card, const sc_security_env_t *env, int se_num)\n{\n\tint r = SC_SUCCESS;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tsc_log(card->ctx, \n\t\t \"flags=%08lx op=%d alg=%d algf=%08x algr=%08x kr0=%02x, krfl=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t env->flags, env->operation, env->algorithm,\n\t\t env->algorithm_flags, env->algorithm_ref, env->key_ref[0],\n\t\t env->key_ref_len);\n\n\tif ((env->algorithm != SC_ALGORITHM_RSA) && (env->algorithm != SC_ALGORITHM_EC)) {\n\t\t r = SC_ERROR_NO_CARD_SUPPORT;\n\t}\n\tpriv->algorithm = env->algorithm;\n\tpriv->operation = env->operation;\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n\nstatic int coolkey_restore_security_env(sc_card_t *card, int se_num)\n{\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n#define MAX_COMPUTE_BUF 200\ntypedef struct coolkey_compute_crypt_init_params {\n\tu8 mode;\n\tu8 direction;\n\tu8 location;\n\tu8 buf_len[2];\n} coolkey_compute_crypt_init_params_t;\n\ntypedef struct coolkey_compute_crypt_params {\n    coolkey_compute_crypt_init_params_t init;\n\tu8 buf[MAX_COMPUTE_BUF];\n} coolkey_compute_crypt_params_t;\n\ntypedef struct coolkey_compute_ecc_params {\n\tu8 location;\n\tu8 buf_len[2];\n\tu8 buf[MAX_COMPUTE_BUF];\n} coolkey_compute_ecc_params_t;\n\nstatic int coolkey_rsa_op(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t max_out_len)\n{\n\tint r;\n\tconst u8 *crypt_in;\n\tu8 **crypt_out_p;\n\tsize_t crypt_in_len, *crypt_out_len_p;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tcoolkey_compute_crypt_params_t params;\n\tu8 key_number;\n\tsize_t params_len;\n\tsize_t buf_len;\n\tu8 buf[MAX_COMPUTE_BUF+2];\n\tu8 *buf_out;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx, \n\t\t \"datalen=%\"SC_FORMAT_LEN_SIZE_T\"u outlen=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t datalen, max_out_len);\n\n\tcrypt_in = data;\n\tcrypt_in_len = datalen;\n\n\tbuf_out = &buf[0];\n\tcrypt_out_p = &buf_out;\n\tbuf_len = sizeof(buf);\n\tcrypt_out_len_p = &buf_len;\n\tkey_number = priv->key_id;\n\tparams.init.mode = COOLKEY_CRYPT_MODE_RSA_NO_PAD;\n\tparams.init.location = COOLKEY_CRYPT_LOCATION_APDU;\n\tparams.init.direction = COOLKEY_CRYPT_DIRECTION_ENCRYPT; /* for no pad, direction is irrelevant */\n\n\tif (priv->key_id > 0xff) {\n\t\tr = SC_ERROR_NO_DEFAULT_KEY;\n\t\tgoto done;\n\t}\n\n\tparams_len = sizeof(params.init) + crypt_in_len;\n\n\t/* send the data to the card if necessary */\n\tif (crypt_in_len > MAX_COMPUTE_BUF) {\n\t\tu8 len_buf[2];\n\t\tparams.init.location = COOLKEY_CRYPT_LOCATION_DL_OBJECT;\n\t\tparams_len = sizeof(params.init);\n\t\tcrypt_in = NULL;\n\t\tcrypt_in_len = 0;\n\t\t*crypt_out_p = NULL;\n\t\t*crypt_out_len_p = 0;\n\n\t\tushort2bebytes(len_buf, datalen);\n\n\t\tr = coolkey_write_object(card, COOLKEY_DL_OBJECT_ID, 0, len_buf, sizeof(len_buf),\n\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tr = coolkey_write_object(card, COOLKEY_DL_OBJECT_ID, 2, data, datalen, priv->nonce,\n\t\t\t\t\t\tsizeof(priv->nonce));\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t}\n\tushort2bebytes(params.init.buf_len, crypt_in_len);\n\tif (crypt_in_len) {\n\t\tmemcpy(params.buf, crypt_in, crypt_in_len);\n\t}\n\n\n\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_COMPUTE_CRYPT,\n\t\t\tkey_number, COOLKEY_CRYPT_ONE_STEP, (u8 *)&params, params_len,\n\t\t\tcrypt_out_p, crypt_out_len_p, priv->nonce, sizeof(priv->nonce));\n\n\tif (r < 0) {\n\t\tgoto done;\n\t}\n\tif (datalen > MAX_COMPUTE_BUF) {\n\t\tu8 len_buf[2];\n\t\tsize_t out_length;\n\n\t\tr = coolkey_read_object(card, COOLKEY_DL_OBJECT_ID, 0, len_buf, sizeof(len_buf),\n\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\n\t\tout_length = bebytes2ushort(len_buf);\n\t\tout_length = MIN(out_length,max_out_len);\n\n\t\tr = coolkey_read_object(card, COOLKEY_DL_OBJECT_ID, sizeof(len_buf), out, out_length,\n\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\n\t} else {\n\t\tsize_t out_length = bebytes2ushort(buf);\n\t\tout_length = MIN(out_length, max_out_len);\n\t\tmemcpy(out, buf+2, out_length);\n\t\tr = out_length;\n\t}\n\ndone:\n\treturn r;\n}\n\nstatic int coolkey_ecc_op(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tint r;\n\tconst u8 *crypt_in;\n\tu8  **crypt_out_p;\n\tu8  ins = 0;\n\tsize_t crypt_in_len, *crypt_out_len_p;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tcoolkey_compute_ecc_params_t params;\n\tsize_t params_len;\n\tu8 key_number;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tsc_log(card->ctx, \n\t\t \"datalen=%\"SC_FORMAT_LEN_SIZE_T\"u outlen=%\"SC_FORMAT_LEN_SIZE_T\"u\\n\",\n\t\t datalen, outlen);\n\n\tcrypt_in = data;\n\tcrypt_in_len = datalen;\n\n\tcrypt_out_p = &out;\n\tcrypt_out_len_p = &outlen;\n\tkey_number = priv->key_id;\n\tparams.location = COOLKEY_CRYPT_LOCATION_APDU;\n\n\tif (priv->key_id > 0xff) {\n\t\tr = SC_ERROR_NO_DEFAULT_KEY;\n\t\tgoto done;\n\t}\n\n\tswitch (priv->operation) {\n\tcase SC_SEC_OPERATION_DERIVE:\n\t\tins = COOLKEY_INS_COMPUTE_ECC_KEY_AGREEMENT;\n\t\tbreak;\n\tcase SC_SEC_OPERATION_SIGN:\n\t\tins = COOLKEY_INS_COMPUTE_ECC_SIGNATURE;\n\t\tbreak;\n\tdefault:\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n\t\tgoto done;\n\t}\n\n\tparams_len = (sizeof(params) - sizeof(params.buf))  + crypt_in_len;\n\n\tushort2bebytes(params.buf_len, crypt_in_len);\n\tif (crypt_in_len) {\n\t\tmemcpy(params.buf, crypt_in, crypt_in_len);\n\t}\n\n\n\tr = coolkey_apdu_io(card, COOLKEY_CLASS, ins,\n\t\t\tkey_number, COOLKEY_CRYPT_ONE_STEP, (u8 *)&params, params_len,\n\t\t\tcrypt_out_p, crypt_out_len_p, priv->nonce, sizeof(priv->nonce));\n\ndone:\n\treturn r;\n}\n\n\nstatic int coolkey_compute_crypt(sc_card_t *card,\n\t\t\t\t\tconst u8 * data, size_t datalen,\n\t\t\t\t\tu8 * out, size_t outlen)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tint r;\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tswitch (priv->algorithm) {\n\tcase SC_ALGORITHM_RSA:\n\t\tr = coolkey_rsa_op(card, data, datalen, out, outlen);\n\t\tbreak;\n\tcase SC_ALGORITHM_EC:\n\t\tr = coolkey_ecc_op(card, data, datalen, out, outlen);\n\t\tbreak;\n\tdefault:\n\t\tr = SC_ERROR_NO_CARD_SUPPORT;\n\t\tbreak;\n\t}\n\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);\n}\n\n\nstatic u8 coolkey_class(unsigned long object_id) {\n\treturn (object_id >> 24) & 0xff;\n}\n\nstatic unsigned short coolkey_get_key_id(unsigned long object_id) {\n\tchar char_index = (object_id >> 16) & 0xff;\n\tif (char_index >= '0' && char_index <= '9') {\n\t\treturn (u8)(char_index - '0');\n\t}\n\tif (char_index >= 'A' && char_index <= 'Z') {\n\t\treturn (u8)(char_index - 'A' + 10);\n\t}\n\tif (char_index >= 'a' && char_index <= 'z') {\n\t\treturn (u8)(char_index - 'a' + 26 + 10);\n\t}\n\treturn COOLKEY_INVALID_KEY;\n}\n\n/*\n * COOLKEY cards don't select objects in the applet, objects are selected by a parameter\n * to the APDU. We create paths for the object in which the path value is the object_id\n * and the path type is SC_PATH_SELECT_FILE_ID (so we could cache at the PKCS #15 level if\n * we wanted to.\n *\n * This select simply records what object was selected so that read knows how to access it.\n */\nstatic int coolkey_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out)\n{\n\tint r;\n\tstruct sc_file *file = NULL;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tunsigned long object_id;\n\n\tassert(card != NULL && in_path != NULL);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (in_path->len != 4) {\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\t}\n\tr = coolkey_select_applet(card);\n\tif (r != SC_SUCCESS) {\n\t\treturn r;\n\t}\n\tobject_id = bebytes2ulong(in_path->value);\n\tpriv->obj = coolkey_find_object_by_id(&priv->objects_list, object_id);\n\tif (priv->obj == NULL) {\n\t\treturn SC_ERROR_OBJECT_NOT_FOUND;\n\t}\n\n\tpriv->key_id = COOLKEY_INVALID_KEY;\n\tif (coolkey_class(object_id) == COOLKEY_KEY_CLASS) {\n\t\tpriv->key_id = coolkey_get_key_id(object_id);\n\t}\n\tif (file_out) {\n\t\tfile = sc_file_new();\n\t\tif (file == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t\tfile->path = *in_path;\n\t\t/* this could be like the FCI */\n\t\tfile->type =  SC_PATH_TYPE_FILE_ID;\n\t\tfile->shareable = 0;\n\t\tfile->ef_structure = 0;\n\t\tfile->size = priv->obj->length;\n\t\t*file_out = file;\n\t}\n\n\treturn SC_SUCCESS;\n}\n\nstatic int coolkey_finish(sc_card_t *card)\n{\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\tif (priv) {\n\t\tcoolkey_free_private_data(priv);\n\t}\n\treturn SC_SUCCESS;\n}\n\nstatic int\ncoolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\n\t/* The object ID needs to be unique */\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\t/* if we didn't successfully put the object on the list,\n\t\t * the data space didn't get adopted. free it before we return */\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}\n\n\nstatic int\ncoolkey_process_combined_object(sc_card_t *card, coolkey_private_data_t *priv, u8 *object, size_t object_length)\n{\n\tcoolkey_combined_header_t *header = (coolkey_combined_header_t *)object;\n\tunsigned short compressed_offset;\n\tunsigned short compressed_length;\n\tunsigned short compressed_type;\n\tunsigned short object_offset;\n\tunsigned short object_count;\n\tcoolkey_decompressed_header_t *decompressed_header;\n\tu8 *decompressed_object = NULL;\n\tsize_t decompressed_object_len = 0;\n\tint free_decompressed = 0;\n\tint i, r;\n\n\tif (object_length < sizeof(coolkey_combined_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tcompressed_offset = bebytes2ushort(header->compression_offset);\n\tcompressed_length = bebytes2ushort(header->compression_length);\n\tcompressed_type   = bebytes2ushort(header->compression_type);\n\n\tif ((((size_t)compressed_offset) + (size_t)compressed_length) >  object_length) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\n\t/* store the CUID */\n\tmemcpy(&priv->cuid, &header->cuid, sizeof(priv->cuid));\n\n\tif (compressed_type == COOLKEY_COMPRESSION_ZLIB) {\n#ifdef ENABLE_ZLIB\n\t\tr = sc_decompress_alloc(&decompressed_object, &decompressed_object_len, &object[compressed_offset], compressed_length, COMPRESSION_AUTO);\n\t\tif (r)\n\t\t\tgoto done;\n\t\tfree_decompressed = 1;\n#else\n\t\tsc_log(card->ctx, \"Coolkey compression not supported, no zlib\");\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n#endif\n\t}  else {\n\t\tdecompressed_object =&object[compressed_offset];\n\t\tdecompressed_object_len = (size_t) compressed_length;\n\t}\n\n\tdecompressed_header = (coolkey_decompressed_header_t *)decompressed_object;\n\n\tif (decompressed_object_len < sizeof(coolkey_decompressed_header_t)) {\n\t\treturn SC_ERROR_CORRUPTED_DATA;\n\t}\n\tobject_offset = bebytes2ushort(decompressed_header->object_offset);\n\tobject_count = bebytes2ushort(decompressed_header->object_count);\n\n\n\t/*\n\t * using 2 different tests here so we can log different errors if logging is\n\t * turned on.\n\t */\n\t/* make sure token_name doesn't overrun the buffer */\n\tif (decompressed_header->token_name_length +\n\t\toffsetof(coolkey_decompressed_header_t,token_name) > decompressed_object_len) {\n\t\tr = SC_ERROR_CORRUPTED_DATA;\n\t\tgoto done;\n\t}\n\t/* make sure it doesn't overlap the object space */\n\tif (decompressed_header->token_name_length +\n\t\toffsetof(coolkey_decompressed_header_t,token_name) > object_offset) {\n\t\tr = SC_ERROR_CORRUPTED_DATA;\n\t\tgoto done;\n\t}\n\n\t/* store the token name in the priv structure so the emulator can set it */\n\tpriv->token_name = malloc(decompressed_header->token_name_length+1);\n\tif (priv->token_name == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto done;\n\t}\n\tmemcpy(priv->token_name, &decompressed_header->token_name[0],\n\t\t\t\t\t\t\tdecompressed_header->token_name_length);\n\tpriv->token_name[decompressed_header->token_name_length] = 0;\n\tpriv->token_name_length = decompressed_header->token_name_length;\n\n\n\tfor (i=0; i < object_count && object_offset < decompressed_object_len; i++ ) {\n\t\tu8 *current_object = &decompressed_object[object_offset];\n\t\tcoolkey_combined_object_header_t *object_header =\n\t\t\t\t(coolkey_combined_object_header_t *)current_object;\n\t\tunsigned long object_id = bebytes2ulong(object_header->object_id);\n\t\tint current_object_len;\n\n\t\t/* figure out how big it is */\n\t\tr = coolkey_v1_get_object_length(current_object, decompressed_object_len-object_offset);\n\t\tif (r < 0) {\n\t\t\tgoto done;\n\t\t}\n\t\tif ((size_t)r + object_offset > decompressed_object_len) {\n\t\t\tr = SC_ERROR_CORRUPTED_DATA;\n\t\t\tgoto done;\n\t\t}\n\t\tcurrent_object_len = r;\n\t\tobject_offset += current_object_len;\n\n\t\t/* record this object */\n\t\tr = coolkey_add_object(priv, object_id, current_object, current_object_len, 1);\n\t\tif (r) {\n\t\t\tgoto done;\n\t\t}\n\n\t}\n\tr = SC_SUCCESS;\n\ndone:\n\tif (free_decompressed) {\n\t\tfree(decompressed_object);\n\t}\n\treturn r;\n}\n\nstatic int\ncoolkey_list_object(sc_card_t *card, u8 seq, coolkey_object_info_t *object_info)\n{\n\tu8 *rbuf = (u8 *) object_info;\n\tsize_t rbuflen = sizeof(*object_info);\n\n\treturn coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_LIST_OBJECTS, seq, 0,\n\t\t\tNULL, 0, &rbuf, &rbuflen, NULL, 0);\n\n}\n\n/*\n * Initialize the Coolkey data structures.\n */\nstatic int coolkey_initialize(sc_card_t *card)\n{\n\tint r;\n\tcoolkey_private_data_t *priv = NULL;\n\tcoolkey_life_cycle_t life_cycle;\n\tcoolkey_object_info_t object_info;\n\tint combined_processed = 0;\n\n\t/* already found? */\n\tif (card->drv_data) {\n\t\treturn SC_SUCCESS;\n\t}\n\tsc_debug(card->ctx, SC_LOG_DEBUG_VERBOSE,\"Coolkey Applet found\");\n\n\tpriv = coolkey_new_private_data();\n\tif (priv == NULL) {\n\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\tgoto cleanup;\n\t}\n\tr = coolkey_get_life_cycle(card, &life_cycle);\n\tif (r < 0) {\n\t\tgoto cleanup;\n\t}\n\n\t/* Select a coolkey read the coolkey objects out */\n\tr = coolkey_select_applet(card);\n\tif (r < 0) {\n\t\tgoto cleanup;\n\t}\n\n\tpriv->protocol_version_major = life_cycle.protocol_version_major;\n\tpriv->protocol_version_minor = life_cycle.protocol_version_minor;\n\tpriv->pin_count = life_cycle.pin_count;\n\tpriv->life_cycle = life_cycle.life_cycle;\n\n\t/* walk down the list of objects and read them off the token */\n\tr = coolkey_list_object(card, COOLKEY_LIST_RESET, &object_info);\n\twhile (r >= 0) {\n\t\tunsigned long object_id;\n\t\tunsigned short object_len;\n\n\t\t/* The card did not return what we expected: Lets try other objects */\n\t\tif ((size_t)r < (sizeof(object_info)))\n\t\t\tbreak;\n\n\t\t/* TODO also look at the ACL... */\n\n\t\tobject_id = bebytes2ulong(object_info.object_id);\n\t\tobject_len = bebytes2ulong(object_info.object_length);\n\n\n\t\t/* the combined object is a single object that can store the other objects.\n\t\t * most coolkeys provisioned by TPS has a single combined object that is\n\t\t * compressed greatly increasing the effectiveness of compress (since lots\n\t\t * of certs on the token share the same Subject and Issuer DN's). We now\n\t\t * process it separately so that we can have both combined objects managed\n\t\t * by TPS and user managed certs on the same token */\n\t\tif (object_id == COOLKEY_COMBINED_OBJECT_ID) {\n\t\t\tu8 *object = malloc(object_len);\n\t\t\tif (object == NULL) {\n\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = coolkey_read_object(card, COOLKEY_COMBINED_OBJECT_ID, 0, object, object_len,\n\t\t\t\t\t\t\t\t\t\t\tpriv->nonce, sizeof(priv->nonce));\n\t\t\tif (r < 0) {\n\t\t\t\tfree(object);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr = coolkey_process_combined_object(card, priv, object, r);\n\t\t\tfree(object);\n\t\t\tif (r != SC_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcombined_processed = 1;\n\t\t} else {\n\t\t\tr = coolkey_add_object(priv, object_id, NULL, object_len, 0);\n\t\t\tif (r != SC_SUCCESS)\n\t\t\t\tsc_log(card->ctx, \"coolkey_add_object() returned %d\", r);\n\t\t}\n\n\t\t/* Read next object: error is handled on the cycle condition and below after cycle */\n\t\tr = coolkey_list_object(card, COOLKEY_LIST_NEXT, &object_info);\n\t}\n\tif (r != SC_ERROR_FILE_END_REACHED) {\n\t\t/* This means the card does not cooperate at all: bail out */\n\t\tif (r >= 0) {\n\t\t\tr = SC_ERROR_INVALID_CARD;\n\t\t}\n\t\tgoto cleanup;\n\t}\n\t/* if we didn't pull the cuid from the combined object, then grab it now */\n\tif (!combined_processed) {\n\t\tglobal_platform_cplc_data_t cplc_data;\n\t\t/* select the card manager, because a card with applet only will have\n\t\t   already selected the coolkey applet */\n\n\t\tr = gp_select_card_manager(card);\n\t\tif (r < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tr = gp_get_cplc_data(card, &cplc_data);\n\t\tif (r < 0) {\n\t\t\tgoto cleanup;\n\t\t}\n\t\tcoolkey_make_cuid_from_cplc(&priv->cuid, &cplc_data);\n\t\tpriv->token_name = (u8 *)strdup(\"COOLKEY\");\n\t\tif (priv->token_name == NULL) {\n\t\t\tr= SC_ERROR_OUT_OF_MEMORY;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tpriv->token_name_length = sizeof(\"COOLKEY\")-1;\n\t}\n\tcard->drv_data = priv;\n\treturn SC_SUCCESS;\n\ncleanup:\n\tif (priv) {\n\t\tcoolkey_free_private_data(priv);\n\t}\n\treturn r;\n}\n\n\n/* NOTE: returns a bool, 1 card matches, 0 it does not */\nstatic int coolkey_match_card(sc_card_t *card)\n{\n\tint r;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\t/* Since we send an APDU, the card's logout function may be called...\n\t * however it may be in dirty memory */\n\tcard->ops->logout = NULL;\n\n\tr = coolkey_select_applet(card);\n\tif (r == SC_SUCCESS) {\n\t\tsc_apdu_t apdu;\n\n\t\t/* The GET STATUS INS with P1 = 1 returns invalid instruction (0x6D00)\n\t\t * on Coolkey applet (reserved for GetMemory function),\n\t\t * while incorrect P1 (0x9C10) on Muscle applets\n\t\t */\n\t\tsc_format_apdu(card, &apdu, SC_APDU_CASE_1, COOLKEY_INS_GET_STATUS, 0x01, 0x00);\n\t\tapdu.cla = COOLKEY_CLASS;\n\t\tapdu.le = 0x00;\n\t\tapdu.resplen = 0;\n\t\tapdu.resp = NULL;\n\t\tr = sc_transmit_apdu(card, &apdu);\n\t\tif (r == SC_SUCCESS && apdu.sw1 == 0x6d && apdu.sw2 == 0x00) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\n\nstatic int coolkey_init(sc_card_t *card)\n{\n\tint r;\n\tunsigned long flags;\n\tunsigned long ext_flags;\n\tcoolkey_private_data_t * priv;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tr = coolkey_initialize(card);\n\tif (r < 0) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_CARD);\n\t}\n\n\tcard->type = SC_CARD_TYPE_COOLKEY_GENERIC;\n\n\t/* set Token Major/minor version */\n\tflags = SC_ALGORITHM_RSA_RAW;\n\n\t_sc_card_add_rsa_alg(card, 1024, flags, 0); /* mandatory */\n\t_sc_card_add_rsa_alg(card, 2048, flags, 0); /* optional */\n\t_sc_card_add_rsa_alg(card, 3072, flags, 0); /* optional */\n\n\tflags = SC_ALGORITHM_ECDSA_RAW | SC_ALGORITHM_ECDH_CDH_RAW | SC_ALGORITHM_ECDSA_HASH_NONE;\n\text_flags = SC_ALGORITHM_EXT_EC_NAMEDCURVE | SC_ALGORITHM_EXT_EC_UNCOMPRESES;\n\n\t_sc_card_add_ec_alg(card, 256, flags, ext_flags, NULL);\n\t_sc_card_add_ec_alg(card, 384, flags, ext_flags, NULL);\n\t_sc_card_add_ec_alg(card, 521, flags, ext_flags, NULL);\n\n\n\tpriv = COOLKEY_DATA(card);\n\tif (priv->pin_count != 0) {\n\t\tcard->caps |= SC_CARD_CAP_ISO7816_PIN_INFO;\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n\n\nstatic int\ncoolkey_pin_cmd(sc_card_t *card, struct sc_pin_cmd_data *data, int *tries_left)\n{\n\tint r;\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tsize_t rbuflen;\n\tu8 *rbuf;\n\n\t/* COOLKEY uses a separate pin from the card pin, managed by the applet.\n\t * if we successfully log into coolkey, we will get a nonce, which we append\n\t * to our APDUs to authenticate the apdu to the card. This allows coolkey to\n\t * maintain separate per application login states without the application\n\t * having to cache the pin */\n\tswitch (data->cmd) {\n\tcase SC_PIN_CMD_GET_INFO:\n\t\tif (priv->nonce_valid) {\n\t\t\tdata->pin1.logged_in = SC_PIN_STATE_LOGGED_IN;\n\t\t} else {\n\t\t\tdata->pin1.logged_in = SC_PIN_STATE_LOGGED_OUT;\n\t\t\t/* coolkey retries is 100. It's unlikely the pin is block.\n\t\t\t * instead, coolkey slows down the login command exponentially\n\t\t\t */\n\t\t\tdata->pin1.tries_left = 0xf;\n\t\t}\n\t\tif (tries_left) {\n\t\t\t*tries_left = data->pin1.tries_left;\n\t\t}\n\t\tr = SC_SUCCESS;\n\t\tbreak;\n\n\tcase SC_PIN_CMD_UNBLOCK:\n\tcase SC_PIN_CMD_CHANGE:\n\t\t/* these 2 commands are currently reserved for TPS */\n\tdefault:\n\t\tr = SC_ERROR_NOT_SUPPORTED;\n\t\tbreak;\n\tcase SC_PIN_CMD_VERIFY:\n\t\t/* coolkey applet supports multiple pins, but TPS currently only uses one.\n\t\t * just support the one pin for now (we need an array of nonces to handle\n\t\t * multiple pins) */\n\t\t/* coolkey only supports unpadded ascii pins, so no need to format the pin */\n\t\trbuflen = sizeof(priv->nonce);\n\t\trbuf = &priv->nonce[0];\n\t\tr = coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_VERIFY_PIN,\n\t\t\tdata->pin_reference, 0, data->pin1.data, data->pin1.len,\n\t\t\t&rbuf, &rbuflen, NULL, 0);\n\t\tif (r < 0) {\n\t\t\tbreak;\n\t\t}\n\t\tpriv->nonce_valid = 1;\n\t\tr = SC_SUCCESS;\n\t}\n\treturn r;\n}\n\n\nstatic int\ncoolkey_logout(sc_card_t *card)\n{\n\t/* when we add multi pin support here, how do we know which pin to logout? */\n\tcoolkey_private_data_t * priv = COOLKEY_DATA(card);\n\tu8 pin_ref = 0;\n\n\t(void) coolkey_apdu_io(card, COOLKEY_CLASS, COOLKEY_INS_LOGOUT, pin_ref, 0, NULL, 0, NULL, NULL,\n\t\tpriv->nonce, sizeof(priv->nonce));\n\t/* even if logout failed on the card, flush the nonce and clear the nonce_valid and we are effectively\n\t * logged out... needing to login again to get a nonce back */\n\tmemset(priv->nonce, 0, sizeof(priv->nonce));\n\tpriv->nonce_valid = 0;\n\treturn SC_SUCCESS;\n}\n\n\nstatic int coolkey_card_reader_lock_obtained(sc_card_t *card, int was_reset)\n{\n\tint r = SC_SUCCESS;\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);\n\n\tif (was_reset > 0) {\n\t\tr = coolkey_select_applet(card);\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, r);\n}\n\nstatic struct sc_card_operations coolkey_ops;\n\nstatic struct sc_card_driver coolkey_drv = {\n\t\"COOLKEY\",\n\t\"coolkey\",\n\t&coolkey_ops,\n\tNULL, 0, NULL\n};\n\nstatic struct sc_card_driver * sc_get_driver(void)\n{\n\tstruct sc_card_driver *iso_drv = sc_get_iso7816_driver();\n\n\tcoolkey_ops = *iso_drv->ops;\n\tcoolkey_ops.match_card = coolkey_match_card;\n\tcoolkey_ops.init = coolkey_init;\n\tcoolkey_ops.finish = coolkey_finish;\n\n\tcoolkey_ops.select_file =  coolkey_select_file; /* need to record object type */\n\tcoolkey_ops.get_challenge = coolkey_get_challenge;\n\tcoolkey_ops.read_binary = coolkey_read_binary;\n\tcoolkey_ops.write_binary = coolkey_write_binary;\n\tcoolkey_ops.set_security_env = coolkey_set_security_env;\n\tcoolkey_ops.restore_security_env = coolkey_restore_security_env;\n\tcoolkey_ops.compute_signature = coolkey_compute_crypt;\n\tcoolkey_ops.decipher =  coolkey_compute_crypt;\n\tcoolkey_ops.card_ctl = coolkey_card_ctl;\n\tcoolkey_ops.check_sw = coolkey_check_sw;\n\tcoolkey_ops.pin_cmd = coolkey_pin_cmd;\n\tcoolkey_ops.logout = coolkey_logout;\n\tcoolkey_ops.card_reader_lock_obtained = coolkey_card_reader_lock_obtained;\n\n\treturn &coolkey_drv;\n}\n\n\nstruct sc_card_driver * sc_get_coolkey_driver(void)\n{\n\treturn sc_get_driver();\n}\n\n"], "filenames": ["src/libopensc/card-coolkey.c"], "buggy_code_start_loc": [1946], "buggy_code_end_loc": [1946], "fixing_code_start_loc": [1947], "fixing_code_end_loc": [1952], "type": "CWE-415", "message": "OpenSC before 0.20.0 has a double free in coolkey_free_private_data because coolkey_add_object in libopensc/card-coolkey.c lacks a uniqueness check.", "other": {"cve": {"id": "CVE-2019-20792", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-29T04:15:17.170", "lastModified": "2020-05-26T16:51:15.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenSC before 0.20.0 has a double free in coolkey_free_private_data because coolkey_add_object in libopensc/card-coolkey.c lacks a uniqueness check."}, {"lang": "es", "value": "OpenSC versiones anteriores a 0.20.0, tiene una vulnerabilidad de doble liberaci\u00f3n en la funci\u00f3n coolkey_free_private_data porque la funci\u00f3n coolkey_add_object en el archivo libopensc/card-coolkey.c carece de una comprobaci\u00f3n de unicidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensc_project:opensc:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.20.0", "matchCriteriaId": "475A43FD-C1DB-4084-9D09-9DA5DBC024EB"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=19208", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/commit/c246f6f69a749d4f68626b40795a4f69168008f4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenSC/OpenSC/compare/0.19.0...0.20.0", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenSC/OpenSC/commit/c246f6f69a749d4f68626b40795a4f69168008f4"}}