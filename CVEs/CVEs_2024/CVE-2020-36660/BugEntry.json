{"buggy_code": ["from __future__ import absolute_import\nfrom flask import url_for, redirect, abort, request, Blueprint, current_app\nfrom flask_login import login_required, current_user\nimport six\nfrom six.moves import filter, map\nfrom sqlalchemy.orm.exc import NoResultFound\nfrom itertools import chain\n\nfrom .. import ships, systems, db\nfrom ..models import Request, ActionType\nfrom ..auth import PermissionType\nfrom ..auth.models import Division, User, Group, Pilot, Entity\nfrom .requests import PermissionRequestListing, PersonalRequests\nfrom ..util import jsonify, classproperty\n\n\napi = Blueprint('api', __name__)\n\n\nfilters = Blueprint('filters', __name__)\n\n\n@api.route('/entities/')\n@login_required\ndef list_entities():\n    \"\"\"Return a JSON object with a list of all of the specified entity type.\n\n    Example output::\n        {\n          entities: [\n            {name: 'Bar', id: 1, source: 'Auth Source', type: 'User'},\n            {name: 'Foo', id: 0, source: 'Another Auth Source', type: 'Group'},\n            {name: 'Baz', id: 20, source: 'Auth Source', type: 'Group'}\n          ]\n        }\n\n    This method is only accesible to administrators.\n\n    :param str entity_type: Either ``'user'`` or ``'group'``.\n    \"\"\"\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin):\n        abort(403)\n    user_query = db.session.query(User.id, User.name, User.authmethod)\n    group_query = db.session.query(Group.id, Group.name, Group.authmethod)\n    users = map(lambda e: {\n            u'id': e.id,\n            u'name': e.name,\n            u'type': u'User',\n            u'source': e.authmethod}, user_query)\n    groups = map(lambda e: {\n            u'id': e.id,\n            u'name': e.name,\n            u'type': u'Group',\n            u'source': e.authmethod}, group_query)\n    return jsonify(entities=chain(users, groups))\n\n\n@api.route('/user/<int:user_id>/')\ndef user_detail(user_id):\n    user = User.query.get_or_404(user_id)\n    # Set up divisions\n    submit = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.submit,\n                user.permissions))\n    review = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.review,\n                user.permissions))\n    pay = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.pay,\n                user.permissions))\n    resp = {\n        u'name': user.name,\n        u'groups': list(user.groups),\n        u'divisions': {\n            u'submit': list(set(submit)),\n            u'review': list(set(review)),\n            u'pay': list(set(pay)),\n        },\n        u'admin': user.admin,\n        u'requests': user.requests,\n    }\n    return jsonify(**resp)\n\n\n@api.route('/group/<int:group_id>/')\ndef group_detail(group_id):\n    group = Group.query.get_or_404(group_id)\n    submit = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.submit,\n                group.permissions))\n    review = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.review,\n                group.permissions))\n    pay = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.pay,\n                group.permissions))\n    resp = {\n        u'name': group.name,\n        u'users': list(group.users),\n        u'divisions': {\n            u'submit': list(set(submit)),\n            u'review': list(set(review)),\n            u'pay': list(set(pay)),\n        },\n    }\n    return jsonify(**resp)\n\n\n@api.route('/division/')\n@login_required\ndef list_divisions():\n    \"\"\"List all divisions.\n    \"\"\"\n    if not current_user.admin:\n        abort(403)\n    divisions = db.session.query(Division.id, Division.name)\n    return jsonify(divisions=divisions)\n\n\n@api.route('/division/<int:division_id>/')\n@login_required\ndef division_detail(division_id):\n    \"\"\"Get the details of a division.\n\n    :param int division_id: The ID of the division\n    \"\"\"\n    division = Division.query.get_or_404(division_id)\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin, division):\n        abort(403)\n    permissions = {}\n    for perm in PermissionType.all:\n        key = perm.name + '_href'\n        permissions[key] = url_for('.division_permissions',\n                division_id=division_id,\n                permission=perm.name)\n    return jsonify(\n            name=division.name,\n            requests=division.requests,\n            permissions=permissions)\n\n\n@api.route('/division/<int:division_id>/<permission>/')\n@login_required\ndef division_permissions(division_id, permission):\n    division = Division.query.get_or_404(division_id)\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin, division):\n        abort(403)\n    permission = PermissionType.from_string(permission)\n    # Can't use normal Entity JSON encoder as it doesn't include the\n    # authentication source or their type (explicitly. Ain't nobody got time\n    # for parsing the entity type out of the href).\n    entities = []\n    for entity in map(lambda p: p.entity, division.permissions[permission]):\n        entity_info = {\n            u'name': entity.name,\n            u'id': entity.id,\n            u'source': str(entity.authmethod),\n        }\n        if hasattr(entity, u'users'):\n            entity_info[u'type'] = u'Group'\n            entity_info[u'length'] = len(entity.users)\n        else:\n            entity_info[u'type'] = u'User'\n        entities.append(entity_info)\n    return jsonify(\n        entities=entities,\n        name=permission.name,\n        description=permission.description)\n\n\n@api.route('/ships/')\n@login_required\ndef ship_list():\n    \"\"\"Get an array of objects corresponding to every ship type.\n\n    The objects have two keys, ``id`` is the integer typeID, and ``name`` is\n    the name of the ship. This method is only accessible for logged in users to\n    try to keep possible misuse to a minimum.\n    \"\"\"\n    ship_objs = list(map(lambda s: {u'name': s[1], u'id': s[0]},\n            ships.ships.items()))\n    return jsonify(ships=ship_objs)\n\n\nclass FiltersRequestListing(object):\n    @classproperty\n    def _load_options(self):\n        \"\"\"Returns a sequence of\n        :py:class:`~sqlalchemy.orm.strategy_options.Load` objects specifying\n        which attributes to load.\n        \"\"\"\n        return (\n                db.Load(Request).load_only(\n                    'id',\n                    'pilot_id',\n                    'corporation',\n                    'alliance',\n                    'ship_type',\n                    'status',\n                    'base_payout',\n                    'kill_timestamp',\n                    'timestamp',\n                    'division_id',\n                    'submitter_id',\n                    'system',\n                ),\n                db.Load(Division).joinedload('name'),\n                db.Load(Pilot).joinedload('name'),\n                db.Load(User).joinedload('id')\n        )\n\n\n    def dispatch_request(self, filters='', **kwargs):\n        def request_dict(request):\n            payout = request.payout\n            return {\n                u'id': request.id,\n                u'href': url_for('requests.get_request_details',\n                    request_id=request.id),\n                u'pilot': request.pilot.name,\n                u'corporation': request.corporation,\n                u'alliance': request.alliance,\n                u'ship': request.ship_type,\n                u'status': request.status.name,\n                u'payout': payout.currency(),\n                u'kill_timestamp': request.kill_timestamp,\n                u'submit_timestamp': request.timestamp,\n                u'division': request.division.name,\n                u'submitter_id': request.submitter.id,\n                u'system': request.system,\n                u'constellation': request.constellation,\n                u'region': request.region,\n            }\n\n        return jsonify(requests=map(request_dict, self.requests({})))\n\n\nclass APIRequestListing(FiltersRequestListing, PermissionRequestListing): pass\n\n\nclass APIPersonalRequests(FiltersRequestListing, PersonalRequests): pass\n\n\n@filters.record\ndef register_request_lists(state):\n    # Create the views\n    all_requests = APIRequestListing.as_view('filter_requests_all',\n            PermissionType.all, ActionType.statuses)\n    user_requests = APIPersonalRequests.as_view('filter_requests_own')\n    pending_requests = APIRequestListing.as_view('filter_requests_pending',\n            (PermissionType.review,), ActionType.pending)\n    pay_requests = APIRequestListing.as_view('filter_requests_pay',\n            (PermissionType.pay,), (ActionType.approved,))\n    completed_requests = APIRequestListing.as_view('filter_requests_completed',\n            PermissionType.elevated, ActionType.finalized)\n    # Attach the views to paths\n    for prefix in state.app.request_prefixes:\n        state.add_url_rule(prefix + '/', view_func=all_requests)\n        state.add_url_rule(prefix + '/<path:filters>/',\n                view_func=all_requests)\n        state.add_url_rule(prefix + '/personal/', view_func=user_requests)\n        state.add_url_rule(prefix + '/personal/<path:filters>/',\n                view_func=user_requests)\n        state.add_url_rule(prefix + '/pending/', view_func=pending_requests)\n        state.add_url_rule(prefix + '/pending/<path:filters>/',\n                view_func=pending_requests)\n        state.add_url_rule(prefix + '/pay/', view_func=pay_requests)\n        state.add_url_rule(prefix + '/pay/<path:filters>/',\n                view_func=pay_requests)\n        state.add_url_rule(prefix + '/completed/',\n                view_func=completed_requests)\n        state.add_url_rule(prefix + '/completed/<path:filters>/',\n                view_func=completed_requests)\n\n\ndef _first(o):\n    return o[0]\n\n\n@filters.route('/ship/')\n@login_required\ndef filter_ships():\n    ships = db.session.query(Request.ship_type).distinct()\n    return jsonify(key=u'ship', ship=map(_first, ships))\n\n\n@filters.route('/system/')\n@login_required\ndef filter_systems():\n    systems = db.session.query(Request.system).distinct()\n    return jsonify(key=u'system', system=map(_first, systems))\n\n\n@filters.route('/constellation/')\n@login_required\ndef filter_constellations():\n    constellations = db.session.query(Request.constellation).distinct()\n    return jsonify(key=u'constellation',\n            constellation=map(_first, constellations))\n\n\n@filters.route('/region/')\n@login_required\ndef filter_regions():\n    regions = db.session.query(Request.region).distinct()\n    return jsonify(key=u'region', region=map(_first, regions))\n\n\n@filters.route('/details/<path:query>')\n@login_required\ndef query_details(query):\n    requests = db.session.query(Request.id)\\\n            .filter(Request.details.match(query))\n    return jsonify(ids=map(_first, requests))\n\n\n@filters.route('/pilot/')\n@login_required\ndef filter_pilots():\n    pilots = db.session.query(Pilot.name)\n    return jsonify(key=u'pilot', pilot=map(_first, pilots))\n\n\n@filters.route('/corporation/')\n@login_required\ndef filter_corps():\n    corps = db.session.query(Request.corporation).distinct()\n    return jsonify(key=u'corporation', corporation=map(_first, corps))\n\n\n@filters.route('/alliance/')\n@login_required\ndef filter_alliances():\n    alliances = db.session.query(Request.alliance)\\\n            .filter(Request.alliance != None)\\\n            .distinct()\n    return jsonify(key=u'alliance', alliance=map(_first, alliances))\n\n\n@filters.route('/division/')\n@login_required\ndef filter_divisions():\n    div_names = db.session.query(Division.name)\n    return jsonify(key=u'division', division=map(_first, div_names))\n"], "fixing_code": ["from __future__ import absolute_import\nfrom flask import url_for, redirect, abort, request, Blueprint, current_app\nfrom flask_login import login_required, current_user\nimport six\nfrom six.moves import filter, map\nfrom sqlalchemy.orm.exc import NoResultFound\nfrom itertools import chain\n\nfrom .. import ships, systems, db\nfrom ..models import Request, ActionType\nfrom ..auth import PermissionType\nfrom ..auth.models import Division, User, Group, Pilot, Entity\nfrom .requests import PermissionRequestListing, PersonalRequests\nfrom ..util import jsonify, classproperty\n\n\napi = Blueprint('api', __name__)\n\n\nfilters = Blueprint('filters', __name__)\n\n\n@api.route('/entities/')\n@login_required\ndef list_entities():\n    \"\"\"Return a JSON object with a list of all of the specified entity type.\n\n    Example output::\n        {\n          entities: [\n            {name: 'Bar', id: 1, source: 'Auth Source', type: 'User'},\n            {name: 'Foo', id: 0, source: 'Another Auth Source', type: 'Group'},\n            {name: 'Baz', id: 20, source: 'Auth Source', type: 'Group'}\n          ]\n        }\n\n    This method is only accesible to administrators.\n\n    :param str entity_type: Either ``'user'`` or ``'group'``.\n    \"\"\"\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin):\n        abort(403)\n    user_query = db.session.query(User.id, User.name, User.authmethod)\n    group_query = db.session.query(Group.id, Group.name, Group.authmethod)\n    users = map(lambda e: {\n            u'id': e.id,\n            u'name': e.name,\n            u'type': u'User',\n            u'source': e.authmethod}, user_query)\n    groups = map(lambda e: {\n            u'id': e.id,\n            u'name': e.name,\n            u'type': u'Group',\n            u'source': e.authmethod}, group_query)\n    return jsonify(entities=chain(users, groups))\n\n\n@api.route('/user/<int:user_id>/')\n@login_required\ndef user_detail(user_id):\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin):\n        abort(403)\n    user = User.query.get_or_404(user_id)\n    # Set up divisions\n    submit = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.submit,\n                user.permissions))\n    review = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.review,\n                user.permissions))\n    pay = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.pay,\n                user.permissions))\n    resp = {\n        u'name': user.name,\n        u'groups': list(user.groups),\n        u'divisions': {\n            u'submit': list(set(submit)),\n            u'review': list(set(review)),\n            u'pay': list(set(pay)),\n        },\n        u'admin': user.admin,\n        u'requests': user.requests,\n    }\n    return jsonify(**resp)\n\n\n@api.route('/group/<int:group_id>/')\n@login_required\ndef group_detail(group_id):\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin):\n        abort(403)\n    group = Group.query.get_or_404(group_id)\n    submit = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.submit,\n                group.permissions))\n    review = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.review,\n                group.permissions))\n    pay = map(lambda p: p.division,\n            filter(lambda p: p.permission == PermissionType.pay,\n                group.permissions))\n    resp = {\n        u'name': group.name,\n        u'users': list(group.users),\n        u'divisions': {\n            u'submit': list(set(submit)),\n            u'review': list(set(review)),\n            u'pay': list(set(pay)),\n        },\n    }\n    return jsonify(**resp)\n\n\n@api.route('/division/')\n@login_required\ndef list_divisions():\n    \"\"\"List all divisions.\n    \"\"\"\n    if not current_user.admin:\n        abort(403)\n    divisions = db.session.query(Division.id, Division.name)\n    return jsonify(divisions=divisions)\n\n\n@api.route('/division/<int:division_id>/')\n@login_required\ndef division_detail(division_id):\n    \"\"\"Get the details of a division.\n\n    :param int division_id: The ID of the division\n    \"\"\"\n    division = Division.query.get_or_404(division_id)\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin, division):\n        abort(403)\n    permissions = {}\n    for perm in PermissionType.all:\n        key = perm.name + '_href'\n        permissions[key] = url_for('.division_permissions',\n                division_id=division_id,\n                permission=perm.name)\n    return jsonify(\n            name=division.name,\n            requests=division.requests,\n            permissions=permissions)\n\n\n@api.route('/division/<int:division_id>/<permission>/')\n@login_required\ndef division_permissions(division_id, permission):\n    division = Division.query.get_or_404(division_id)\n    if not current_user.admin and not \\\n            current_user.has_permission(PermissionType.admin, division):\n        abort(403)\n    permission = PermissionType.from_string(permission)\n    # Can't use normal Entity JSON encoder as it doesn't include the\n    # authentication source or their type (explicitly. Ain't nobody got time\n    # for parsing the entity type out of the href).\n    entities = []\n    for entity in map(lambda p: p.entity, division.permissions[permission]):\n        entity_info = {\n            u'name': entity.name,\n            u'id': entity.id,\n            u'source': str(entity.authmethod),\n        }\n        if hasattr(entity, u'users'):\n            entity_info[u'type'] = u'Group'\n            entity_info[u'length'] = len(entity.users)\n        else:\n            entity_info[u'type'] = u'User'\n        entities.append(entity_info)\n    return jsonify(\n        entities=entities,\n        name=permission.name,\n        description=permission.description)\n\n\n@api.route('/ships/')\n@login_required\ndef ship_list():\n    \"\"\"Get an array of objects corresponding to every ship type.\n\n    The objects have two keys, ``id`` is the integer typeID, and ``name`` is\n    the name of the ship. This method is only accessible for logged in users to\n    try to keep possible misuse to a minimum.\n    \"\"\"\n    ship_objs = list(map(lambda s: {u'name': s[1], u'id': s[0]},\n            ships.ships.items()))\n    return jsonify(ships=ship_objs)\n\n\nclass FiltersRequestListing(object):\n    @classproperty\n    def _load_options(self):\n        \"\"\"Returns a sequence of\n        :py:class:`~sqlalchemy.orm.strategy_options.Load` objects specifying\n        which attributes to load.\n        \"\"\"\n        return (\n                db.Load(Request).load_only(\n                    'id',\n                    'pilot_id',\n                    'corporation',\n                    'alliance',\n                    'ship_type',\n                    'status',\n                    'base_payout',\n                    'kill_timestamp',\n                    'timestamp',\n                    'division_id',\n                    'submitter_id',\n                    'system',\n                ),\n                db.Load(Division).joinedload('name'),\n                db.Load(Pilot).joinedload('name'),\n                db.Load(User).joinedload('id')\n        )\n\n\n    def dispatch_request(self, filters='', **kwargs):\n        def request_dict(request):\n            payout = request.payout\n            return {\n                u'id': request.id,\n                u'href': url_for('requests.get_request_details',\n                    request_id=request.id),\n                u'pilot': request.pilot.name,\n                u'corporation': request.corporation,\n                u'alliance': request.alliance,\n                u'ship': request.ship_type,\n                u'status': request.status.name,\n                u'payout': payout.currency(),\n                u'kill_timestamp': request.kill_timestamp,\n                u'submit_timestamp': request.timestamp,\n                u'division': request.division.name,\n                u'submitter_id': request.submitter.id,\n                u'system': request.system,\n                u'constellation': request.constellation,\n                u'region': request.region,\n            }\n\n        return jsonify(requests=map(request_dict, self.requests({})))\n\n\nclass APIRequestListing(FiltersRequestListing, PermissionRequestListing): pass\n\n\nclass APIPersonalRequests(FiltersRequestListing, PersonalRequests): pass\n\n\n@filters.record\ndef register_request_lists(state):\n    # Create the views\n    all_requests = APIRequestListing.as_view('filter_requests_all',\n            PermissionType.all, ActionType.statuses)\n    user_requests = APIPersonalRequests.as_view('filter_requests_own')\n    pending_requests = APIRequestListing.as_view('filter_requests_pending',\n            (PermissionType.review,), ActionType.pending)\n    pay_requests = APIRequestListing.as_view('filter_requests_pay',\n            (PermissionType.pay,), (ActionType.approved,))\n    completed_requests = APIRequestListing.as_view('filter_requests_completed',\n            PermissionType.elevated, ActionType.finalized)\n    # Attach the views to paths\n    for prefix in state.app.request_prefixes:\n        state.add_url_rule(prefix + '/', view_func=all_requests)\n        state.add_url_rule(prefix + '/<path:filters>/',\n                view_func=all_requests)\n        state.add_url_rule(prefix + '/personal/', view_func=user_requests)\n        state.add_url_rule(prefix + '/personal/<path:filters>/',\n                view_func=user_requests)\n        state.add_url_rule(prefix + '/pending/', view_func=pending_requests)\n        state.add_url_rule(prefix + '/pending/<path:filters>/',\n                view_func=pending_requests)\n        state.add_url_rule(prefix + '/pay/', view_func=pay_requests)\n        state.add_url_rule(prefix + '/pay/<path:filters>/',\n                view_func=pay_requests)\n        state.add_url_rule(prefix + '/completed/',\n                view_func=completed_requests)\n        state.add_url_rule(prefix + '/completed/<path:filters>/',\n                view_func=completed_requests)\n\n\ndef _first(o):\n    return o[0]\n\n\n@filters.route('/ship/')\n@login_required\ndef filter_ships():\n    ships = db.session.query(Request.ship_type).distinct()\n    return jsonify(key=u'ship', ship=map(_first, ships))\n\n\n@filters.route('/system/')\n@login_required\ndef filter_systems():\n    systems = db.session.query(Request.system).distinct()\n    return jsonify(key=u'system', system=map(_first, systems))\n\n\n@filters.route('/constellation/')\n@login_required\ndef filter_constellations():\n    constellations = db.session.query(Request.constellation).distinct()\n    return jsonify(key=u'constellation',\n            constellation=map(_first, constellations))\n\n\n@filters.route('/region/')\n@login_required\ndef filter_regions():\n    regions = db.session.query(Request.region).distinct()\n    return jsonify(key=u'region', region=map(_first, regions))\n\n\n@filters.route('/details/<path:query>')\n@login_required\ndef query_details(query):\n    requests = db.session.query(Request.id)\\\n            .filter(Request.details.match(query))\n    return jsonify(ids=map(_first, requests))\n\n\n@filters.route('/pilot/')\n@login_required\ndef filter_pilots():\n    pilots = db.session.query(Pilot.name)\n    return jsonify(key=u'pilot', pilot=map(_first, pilots))\n\n\n@filters.route('/corporation/')\n@login_required\ndef filter_corps():\n    corps = db.session.query(Request.corporation).distinct()\n    return jsonify(key=u'corporation', corporation=map(_first, corps))\n\n\n@filters.route('/alliance/')\n@login_required\ndef filter_alliances():\n    alliances = db.session.query(Request.alliance)\\\n            .filter(Request.alliance != None)\\\n            .distinct()\n    return jsonify(key=u'alliance', alliance=map(_first, alliances))\n\n\n@filters.route('/division/')\n@login_required\ndef filter_divisions():\n    div_names = db.session.query(Division.name)\n    return jsonify(key=u'division', division=map(_first, div_names))\n"], "filenames": ["src/evesrp/views/api.py"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [87], "fixing_code_start_loc": [60], "fixing_code_end_loc": [96], "type": "NVD-CWE-noinfo", "message": "A vulnerability was found in paxswill EVE Ship Replacement Program 0.12.11. It has been rated as problematic. This issue affects some unknown processing of the file src/evesrp/views/api.py of the component User Information Handler. The manipulation leads to information disclosure. The attack may be initiated remotely. Upgrading to version 0.12.12 is able to address this issue. The name of the patch is 9e03f68e46e85ca9c9694a6971859b3ee66f0240. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220211.", "other": {"cve": {"id": "CVE-2020-36660", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-06T17:15:09.437", "lastModified": "2023-02-14T22:47:33.603", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in paxswill EVE Ship Replacement Program 0.12.11. It has been rated as problematic. This issue affects some unknown processing of the file src/evesrp/views/api.py of the component User Information Handler. The manipulation leads to information disclosure. The attack may be initiated remotely. Upgrading to version 0.12.12 is able to address this issue. The name of the patch is 9e03f68e46e85ca9c9694a6971859b3ee66f0240. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220211."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eve_ship_replacement_program_project:eve_ship_replacement_program:0.12.11:*:*:*:*:*:*:*", "matchCriteriaId": "D97ADDBA-C973-4BC8-89FB-DAA9414561A6"}]}]}], "references": [{"url": "https://github.com/paxswill/evesrp/commit/9e03f68e46e85ca9c9694a6971859b3ee66f0240", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/paxswill/evesrp/releases/tag/v0.12.12", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.220211", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.220211", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/paxswill/evesrp/commit/9e03f68e46e85ca9c9694a6971859b3ee66f0240"}}