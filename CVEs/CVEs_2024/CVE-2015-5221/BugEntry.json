{"buggy_code": ["/*\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_string.h\"\n#include \"jasper/jas_malloc.h\"\n\n#include \"mif_cod.h\"\n\n/******************************************************************************\\\n* Local types.\n\\******************************************************************************/\n\ntypedef enum {\n\tMIF_END = 0,\n\tMIF_CMPT\n} mif_tagid2_t;\n\ntypedef enum {\n\tMIF_TLX = 0,\n\tMIF_TLY,\n\tMIF_WIDTH,\n\tMIF_HEIGHT,\n\tMIF_HSAMP,\n\tMIF_VSAMP,\n\tMIF_PREC,\n\tMIF_SGND,\n\tMIF_DATA\n} mif_tagid_t;\n\n/******************************************************************************\\\n* Local functions.\n\\******************************************************************************/\n\nstatic mif_hdr_t *mif_hdr_create(int maxcmpts);\nstatic void mif_hdr_destroy(mif_hdr_t *hdr);\nstatic int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts);\nstatic mif_hdr_t *mif_hdr_get(jas_stream_t *in);\nstatic int mif_process_cmpt(mif_hdr_t *hdr, char *buf);\nstatic int mif_hdr_put(mif_hdr_t *hdr, jas_stream_t *out);\nstatic int mif_hdr_addcmpt(mif_hdr_t *hdr, int cmptno, mif_cmpt_t *cmpt);\nstatic mif_cmpt_t *mif_cmpt_create(void);\nstatic void mif_cmpt_destroy(mif_cmpt_t *cmpt);\nstatic char *mif_getline(jas_stream_t *jas_stream, char *buf, int bufsize);\nstatic int mif_getc(jas_stream_t *in);\nstatic mif_hdr_t *mif_makehdrfromimage(jas_image_t *image);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njas_taginfo_t mif_tags2[] = {\n\t{MIF_CMPT, \"component\"},\n\t{MIF_END, \"end\"},\n\t{-1, 0}\n};\n\njas_taginfo_t mif_tags[] = {\n\t{MIF_TLX, \"tlx\"},\n\t{MIF_TLY, \"tly\"},\n\t{MIF_WIDTH, \"width\"},\n\t{MIF_HEIGHT, \"height\"},\n\t{MIF_HSAMP, \"sampperx\"},\n\t{MIF_VSAMP, \"samppery\"},\n\t{MIF_PREC, \"prec\"},\n\t{MIF_SGND, \"sgnd\"},\n\t{MIF_DATA, \"data\"},\n\t{-1, 0}\n};\n\n/******************************************************************************\\\n* Code for load operation.\n\\******************************************************************************/\n\n/* Load an image from a stream in the MIF format. */\n\njas_image_t *mif_decode(jas_stream_t *in, char *optstr)\n{\n\tmif_hdr_t *hdr;\n\tjas_image_t *image;\n\tjas_image_t *tmpimage;\n\tjas_stream_t *tmpstream;\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_seq2d_t *data;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\tint bias;\n\n\t/* Avoid warnings about unused parameters. */\n\toptstr = 0;\n\n\thdr = 0;\n\timage = 0;\n\ttmpimage = 0;\n\ttmpstream = 0;\n\tdata = 0;\n\n\tif (!(hdr = mif_hdr_get(in))) {\n\t\tgoto error;\n\t}\n\n\tif (!(image = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\ttmpstream = cmpt->data ? jas_stream_fopen(cmpt->data, \"rb\") : in;\n\t\tif (!tmpstream) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(tmpimage = jas_image_decode(tmpstream, -1, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (tmpstream != in) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\ttmpstream = 0;\n\t\t}\n\t\tif (!cmpt->width) {\n\t\t\tcmpt->width = jas_image_cmptwidth(tmpimage, 0);\n\t\t}\n\t\tif (!cmpt->height) {\n\t\t\tcmpt->height = jas_image_cmptwidth(tmpimage, 0);\n\t\t}\n\t\tif (!cmpt->prec) {\n\t\t\tcmpt->prec = jas_image_cmptprec(tmpimage, 0);\n\t\t}\n\t\tif (cmpt->sgnd < 0) {\n\t\t\tcmpt->sgnd = jas_image_cmptsgnd(tmpimage, 0);\n\t\t}\n\t\tcmptparm.tlx = cmpt->tlx;\n\t\tcmptparm.tly = cmpt->tly;\n\t\tcmptparm.hstep = cmpt->sampperx;\n\t\tcmptparm.vstep = cmpt->samppery;\n\t\tcmptparm.width = cmpt->width;\n\t\tcmptparm.height = cmpt->height;\n\t\tcmptparm.prec = cmpt->prec;\n\t\tcmptparm.sgnd = cmpt->sgnd;\n\t\tif (jas_image_addcmpt(image, jas_image_numcmpts(image), &cmptparm)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(data = jas_seq2d_create(0, 0, cmpt->width, cmpt->height))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_image_readcmpt(tmpimage, 0, 0, 0, cmpt->width, cmpt->height,\n\t\t  data)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cmpt->sgnd) {\n\t\t\tbias = 1 << (cmpt->prec - 1);\n\t\t\tfor (y = 0; y < cmpt->height; ++y) {\n\t\t\t\tfor (x = 0; x < cmpt->width; ++x) {\n\t\t\t\t\t*jas_seq2d_getref(data, x, y) -= bias;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (jas_image_writecmpt(image, jas_image_numcmpts(image) - 1, 0, 0,\n\t\t  cmpt->width, cmpt->height, data)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_seq2d_destroy(data);\n\t\tdata = 0;\n\t\tjas_image_destroy(tmpimage);\n\t\ttmpimage = 0;\n\t}\n\n\tmif_hdr_destroy(hdr);\n\thdr = 0;\n\treturn image;\n\nerror:\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\tif (tmpstream && tmpstream != in) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\tif (tmpimage) {\n\t\tjas_image_destroy(tmpimage);\n\t}\n\tif (data) {\n\t\tjas_seq2d_destroy(data);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for save operation.\n\\******************************************************************************/\n\n/* Save an image to a stream in the the MIF format. */\n\nint mif_encode(jas_image_t *image, jas_stream_t *out, char *optstr)\n{\n\tmif_hdr_t *hdr;\n\tjas_image_t *tmpimage;\n\tint fmt;\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_seq2d_t *data;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\tint bias;\n\n\thdr = 0;\n\ttmpimage = 0;\n\tdata = 0;\n\n\tif (optstr && *optstr != '\\0') {\n\t\tjas_eprintf(\"warning: ignoring unsupported options\\n\");\n\t}\n\n\tif ((fmt = jas_image_strtofmt(\"pnm\")) < 0) {\n\t\tjas_eprintf(\"error: PNM support required\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(hdr = mif_makehdrfromimage(image))) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_put(hdr, out)) {\n\t\tgoto error;\n\t}\n\n\t/* Output component data. */\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tif (!cmpt->data) {\n\t\t\tif (!(tmpimage = jas_image_create0())) {\n\t\t\t\tgoto error;\n\t\t\t}\t\n\t\t\tcmptparm.tlx = 0;\n\t\t\tcmptparm.tly = 0;\n\t\t\tcmptparm.hstep = cmpt->sampperx;\n\t\t\tcmptparm.vstep = cmpt->samppery;\n\t\t\tcmptparm.width = cmpt->width;\n\t\t\tcmptparm.height = cmpt->height;\n\t\t\tcmptparm.prec = cmpt->prec;\n\t\t\tcmptparm.sgnd = false;\n\t\t\tif (jas_image_addcmpt(tmpimage, jas_image_numcmpts(tmpimage), &cmptparm)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (!(data = jas_seq2d_create(0, 0, cmpt->width, cmpt->height))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (jas_image_readcmpt(image, cmptno, 0, 0, cmpt->width, cmpt->height,\n\t\t\t  data)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (cmpt->sgnd) {\n\t\t\t\tbias = 1 << (cmpt->prec - 1);\n\t\t\t\tfor (y = 0; y < cmpt->height; ++y) {\n\t\t\t\t\tfor (x = 0; x < cmpt->width; ++x) {\n\t\t\t\t\t\t*jas_seq2d_getref(data, x, y) += bias;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jas_image_writecmpt(tmpimage, 0, 0, 0, cmpt->width, cmpt->height,\n\t\t\t  data)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_seq2d_destroy(data);\n\t\t\tdata = 0;\n\t\t\tif (jas_image_encode(tmpimage, out, fmt, 0)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_destroy(tmpimage);\n\t\t\ttmpimage = 0;\n\t\t}\n\t}\n\n\tmif_hdr_destroy(hdr);\n\n\treturn 0;\n\nerror:\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\tif (tmpimage) {\n\t\tjas_image_destroy(tmpimage);\n\t}\n\tif (data) {\n\t\tjas_seq2d_destroy(data);\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Code for validate operation.\n\\******************************************************************************/\n\nint mif_validate(jas_stream_t *in)\n{\n\tuchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for MIF header class.\n\\******************************************************************************/\n\nstatic mif_hdr_t *mif_hdr_create(int maxcmpts)\n{\n\tmif_hdr_t *hdr;\n\tif (!(hdr = jas_malloc(sizeof(mif_hdr_t)))) {\n\t\treturn 0;\n\t}\n\thdr->numcmpts = 0;\n\thdr->maxcmpts = 0;\n\thdr->cmpts = 0;\n\tif (mif_hdr_growcmpts(hdr, maxcmpts)) {\n\t\tmif_hdr_destroy(hdr);\n\t\treturn 0;\n\t}\n\treturn hdr;\n}\n\nstatic void mif_hdr_destroy(mif_hdr_t *hdr)\n{\n\tint cmptno;\n\tif (hdr->cmpts) {\n\t\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\t\tmif_cmpt_destroy(hdr->cmpts[cmptno]);\n\t\t}\n\t\tjas_free(hdr->cmpts);\n\t}\n\tjas_free(hdr);\n}\n\nstatic int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)\n{\n\tint cmptno;\n\tmif_cmpt_t **newcmpts;\n\tassert(maxcmpts >= hdr->numcmpts);\n\tnewcmpts = (!hdr->cmpts) ? jas_malloc(maxcmpts * sizeof(mif_cmpt_t *)) :\n\t  jas_realloc(hdr->cmpts, maxcmpts * sizeof(mif_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\thdr->maxcmpts = maxcmpts;\n\thdr->cmpts = newcmpts;\n\tfor (cmptno = hdr->numcmpts; cmptno < hdr->maxcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = 0;\n\t}\n\treturn 0;\n}\n\nstatic mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tuchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {\n\t\tgoto error;\n\t}\n\tif (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &\n\t  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=\n\t  (MIF_MAGIC & 0xff)) {\n\t\tjas_eprintf(\"error: bad signature\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(hdr = mif_hdr_create(0))) {\n\t\tgoto error;\n\t}\n\n\tdone = false;\n\tdo {\n\t\tif (!mif_getline(in, buf, sizeof(buf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (buf[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_tvparser_next(tvp)) {\n\t\t\tabort();\n\t\t}\n\t\tid = jas_taginfo_nonull(jas_taginfos_lookup(mif_tags2, jas_tvparser_gettag(tvp)))->id;\n\t\tjas_tvparser_destroy(tvp);\n\t\tswitch (id) {\n\t\tcase MIF_CMPT:\n\t\t\tmif_process_cmpt(hdr, buf);\n\t\t\tbreak;\n\t\tcase MIF_END:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!done);\n\n\treturn hdr;\n\nerror:\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\treturn 0;\n}\n\nstatic int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tjas_tvparser_destroy(tvp);\n\tif (!cmpt->sampperx || !cmpt->samppery) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}\n\nstatic int mif_hdr_put(mif_hdr_t *hdr, jas_stream_t *out)\n{\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\n\t/* Output signature. */\n\tjas_stream_putc(out, (MIF_MAGIC >> 24) & 0xff);\n\tjas_stream_putc(out, (MIF_MAGIC >> 16) & 0xff);\n\tjas_stream_putc(out, (MIF_MAGIC >> 8) & 0xff);\n\tjas_stream_putc(out, MIF_MAGIC & 0xff);\n\n\t/* Output component information. */\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tjas_stream_printf(out, \"component tlx=%ld tly=%ld \"\n\t\t  \"sampperx=%ld samppery=%ld width=%ld height=%ld prec=%d sgnd=%d\",\n\t\t  cmpt->tlx, cmpt->tly, cmpt->sampperx, cmpt->samppery, cmpt->width,\n\t\t  cmpt->height, cmpt->prec, cmpt->sgnd);\n\t\tif (cmpt->data) {\n\t\t\tjas_stream_printf(out, \" data=%s\", cmpt->data);\n\t\t}\n\t\tjas_stream_printf(out, \"\\n\");\n\t}\n\n\t/* Output end of header indicator. */\n\tjas_stream_printf(out, \"end\\n\");\n\n\treturn 0;\n}\n\nstatic int mif_hdr_addcmpt(mif_hdr_t *hdr, int cmptno, mif_cmpt_t *cmpt)\n{\n\tassert(cmptno >= hdr->numcmpts);\n\tif (hdr->numcmpts >= hdr->maxcmpts) {\n\t\tif (mif_hdr_growcmpts(hdr, hdr->numcmpts + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\thdr->cmpts[hdr->numcmpts] = cmpt;\n\t++hdr->numcmpts;\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for MIF component class.\n\\******************************************************************************/\n\nstatic mif_cmpt_t *mif_cmpt_create()\n{\n\tmif_cmpt_t *cmpt;\n\tif (!(cmpt = jas_malloc(sizeof(mif_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(cmpt, 0, sizeof(mif_cmpt_t));\n\treturn cmpt;\n}\n\nstatic void mif_cmpt_destroy(mif_cmpt_t *cmpt)\n{\n\tif (cmpt->data) {\n\t\tjas_free(cmpt->data);\n\t}\n\tjas_free(cmpt);\n}\n\n/******************************************************************************\\\n* MIF parsing code.\n\\******************************************************************************/\n\nstatic char *mif_getline(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = mif_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\tif (!(bufptr = strchr(buf, '\\n'))) {\n\t\treturn 0;\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nstatic int mif_getc(jas_stream_t *in)\n{\n\tint c;\n\tbool done;\n\n\tdone = false;\n\tdo {\n\t\tswitch (c = jas_stream_getc(in)) {\n\t\tcase EOF:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tfor (;;) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif (jas_stream_peekc(in) == '\\n') {\n\t\t\t\tjas_stream_getc(in);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!done);\n\n\treturn c;\n}\n\n/******************************************************************************\\\n* Miscellaneous functions.\n\\******************************************************************************/\n\nstatic mif_hdr_t *mif_makehdrfromimage(jas_image_t *image)\n{\n\tmif_hdr_t *hdr;\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\n\tif (!(hdr = mif_hdr_create(jas_image_numcmpts(image)))) {\n\t\treturn 0;\n\t}\n\thdr->magic = MIF_MAGIC;\n\thdr->numcmpts = jas_image_numcmpts(image);\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = jas_malloc(sizeof(mif_cmpt_t));\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tcmpt->tlx = jas_image_cmpttlx(image, cmptno);\n\t\tcmpt->tly = jas_image_cmpttly(image, cmptno);\n\t\tcmpt->width = jas_image_cmptwidth(image, cmptno);\n\t\tcmpt->height = jas_image_cmptheight(image, cmptno);\n\t\tcmpt->sampperx = jas_image_cmpthstep(image, cmptno);\n\t\tcmpt->samppery = jas_image_cmptvstep(image, cmptno);\n\t\tcmpt->prec = jas_image_cmptprec(image, cmptno);\n\t\tcmpt->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tcmpt->data = 0;\n\t}\n\treturn hdr;\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2001-2002 Michael David Adams.\n * All rights reserved.\n */\n\n/* __START_OF_JASPER_LICENSE__\n * \n * JasPer License Version 2.0\n * \n * Copyright (c) 2001-2006 Michael David Adams\n * Copyright (c) 1999-2000 Image Power, Inc.\n * Copyright (c) 1999-2000 The University of British Columbia\n * \n * All rights reserved.\n * \n * Permission is hereby granted, free of charge, to any person (the\n * \"User\") obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n * \n * 1.  The above copyright notices and this permission notice (which\n * includes the disclaimer below) shall be included in all copies or\n * substantial portions of the Software.\n * \n * 2.  The name of a copyright holder shall not be used to endorse or\n * promote products derived from the Software without specific prior\n * written permission.\n * \n * THIS DISCLAIMER OF WARRANTY CONSTITUTES AN ESSENTIAL PART OF THIS\n * LICENSE.  NO USE OF THE SOFTWARE IS AUTHORIZED HEREUNDER EXCEPT UNDER\n * THIS DISCLAIMER.  THE SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n * \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n * BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n * PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.  IN NO\n * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL\n * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING\n * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\n * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\n * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  NO ASSURANCES ARE\n * PROVIDED BY THE COPYRIGHT HOLDERS THAT THE SOFTWARE DOES NOT INFRINGE\n * THE PATENT OR OTHER INTELLECTUAL PROPERTY RIGHTS OF ANY OTHER ENTITY.\n * EACH COPYRIGHT HOLDER DISCLAIMS ANY LIABILITY TO THE USER FOR CLAIMS\n * BROUGHT BY ANY OTHER ENTITY BASED ON INFRINGEMENT OF INTELLECTUAL\n * PROPERTY RIGHTS OR OTHERWISE.  AS A CONDITION TO EXERCISING THE RIGHTS\n * GRANTED HEREUNDER, EACH USER HEREBY ASSUMES SOLE RESPONSIBILITY TO SECURE\n * ANY OTHER INTELLECTUAL PROPERTY RIGHTS NEEDED, IF ANY.  THE SOFTWARE\n * IS NOT FAULT-TOLERANT AND IS NOT INTENDED FOR USE IN MISSION-CRITICAL\n * SYSTEMS, SUCH AS THOSE USED IN THE OPERATION OF NUCLEAR FACILITIES,\n * AIRCRAFT NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL\n * SYSTEMS, DIRECT LIFE SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH\n * THE FAILURE OF THE SOFTWARE OR SYSTEM COULD LEAD DIRECTLY TO DEATH,\n * PERSONAL INJURY, OR SEVERE PHYSICAL OR ENVIRONMENTAL DAMAGE (\"HIGH\n * RISK ACTIVITIES\").  THE COPYRIGHT HOLDERS SPECIFICALLY DISCLAIM ANY\n * EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR HIGH RISK ACTIVITIES.\n * \n * __END_OF_JASPER_LICENSE__\n */\n\n/******************************************************************************\\\n* Includes.\n\\******************************************************************************/\n\n#include <assert.h>\n\n#include \"jasper/jas_tvp.h\"\n#include \"jasper/jas_stream.h\"\n#include \"jasper/jas_image.h\"\n#include \"jasper/jas_string.h\"\n#include \"jasper/jas_malloc.h\"\n\n#include \"mif_cod.h\"\n\n/******************************************************************************\\\n* Local types.\n\\******************************************************************************/\n\ntypedef enum {\n\tMIF_END = 0,\n\tMIF_CMPT\n} mif_tagid2_t;\n\ntypedef enum {\n\tMIF_TLX = 0,\n\tMIF_TLY,\n\tMIF_WIDTH,\n\tMIF_HEIGHT,\n\tMIF_HSAMP,\n\tMIF_VSAMP,\n\tMIF_PREC,\n\tMIF_SGND,\n\tMIF_DATA\n} mif_tagid_t;\n\n/******************************************************************************\\\n* Local functions.\n\\******************************************************************************/\n\nstatic mif_hdr_t *mif_hdr_create(int maxcmpts);\nstatic void mif_hdr_destroy(mif_hdr_t *hdr);\nstatic int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts);\nstatic mif_hdr_t *mif_hdr_get(jas_stream_t *in);\nstatic int mif_process_cmpt(mif_hdr_t *hdr, char *buf);\nstatic int mif_hdr_put(mif_hdr_t *hdr, jas_stream_t *out);\nstatic int mif_hdr_addcmpt(mif_hdr_t *hdr, int cmptno, mif_cmpt_t *cmpt);\nstatic mif_cmpt_t *mif_cmpt_create(void);\nstatic void mif_cmpt_destroy(mif_cmpt_t *cmpt);\nstatic char *mif_getline(jas_stream_t *jas_stream, char *buf, int bufsize);\nstatic int mif_getc(jas_stream_t *in);\nstatic mif_hdr_t *mif_makehdrfromimage(jas_image_t *image);\n\n/******************************************************************************\\\n* Local data.\n\\******************************************************************************/\n\njas_taginfo_t mif_tags2[] = {\n\t{MIF_CMPT, \"component\"},\n\t{MIF_END, \"end\"},\n\t{-1, 0}\n};\n\njas_taginfo_t mif_tags[] = {\n\t{MIF_TLX, \"tlx\"},\n\t{MIF_TLY, \"tly\"},\n\t{MIF_WIDTH, \"width\"},\n\t{MIF_HEIGHT, \"height\"},\n\t{MIF_HSAMP, \"sampperx\"},\n\t{MIF_VSAMP, \"samppery\"},\n\t{MIF_PREC, \"prec\"},\n\t{MIF_SGND, \"sgnd\"},\n\t{MIF_DATA, \"data\"},\n\t{-1, 0}\n};\n\n/******************************************************************************\\\n* Code for load operation.\n\\******************************************************************************/\n\n/* Load an image from a stream in the MIF format. */\n\njas_image_t *mif_decode(jas_stream_t *in, char *optstr)\n{\n\tmif_hdr_t *hdr;\n\tjas_image_t *image;\n\tjas_image_t *tmpimage;\n\tjas_stream_t *tmpstream;\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_seq2d_t *data;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\tint bias;\n\n\t/* Avoid warnings about unused parameters. */\n\toptstr = 0;\n\n\thdr = 0;\n\timage = 0;\n\ttmpimage = 0;\n\ttmpstream = 0;\n\tdata = 0;\n\n\tif (!(hdr = mif_hdr_get(in))) {\n\t\tgoto error;\n\t}\n\n\tif (!(image = jas_image_create0())) {\n\t\tgoto error;\n\t}\n\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\ttmpstream = cmpt->data ? jas_stream_fopen(cmpt->data, \"rb\") : in;\n\t\tif (!tmpstream) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(tmpimage = jas_image_decode(tmpstream, -1, 0))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (tmpstream != in) {\n\t\t\tjas_stream_close(tmpstream);\n\t\t\ttmpstream = 0;\n\t\t}\n\t\tif (!cmpt->width) {\n\t\t\tcmpt->width = jas_image_cmptwidth(tmpimage, 0);\n\t\t}\n\t\tif (!cmpt->height) {\n\t\t\tcmpt->height = jas_image_cmptwidth(tmpimage, 0);\n\t\t}\n\t\tif (!cmpt->prec) {\n\t\t\tcmpt->prec = jas_image_cmptprec(tmpimage, 0);\n\t\t}\n\t\tif (cmpt->sgnd < 0) {\n\t\t\tcmpt->sgnd = jas_image_cmptsgnd(tmpimage, 0);\n\t\t}\n\t\tcmptparm.tlx = cmpt->tlx;\n\t\tcmptparm.tly = cmpt->tly;\n\t\tcmptparm.hstep = cmpt->sampperx;\n\t\tcmptparm.vstep = cmpt->samppery;\n\t\tcmptparm.width = cmpt->width;\n\t\tcmptparm.height = cmpt->height;\n\t\tcmptparm.prec = cmpt->prec;\n\t\tcmptparm.sgnd = cmpt->sgnd;\n\t\tif (jas_image_addcmpt(image, jas_image_numcmpts(image), &cmptparm)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (!(data = jas_seq2d_create(0, 0, cmpt->width, cmpt->height))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_image_readcmpt(tmpimage, 0, 0, 0, cmpt->width, cmpt->height,\n\t\t  data)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (cmpt->sgnd) {\n\t\t\tbias = 1 << (cmpt->prec - 1);\n\t\t\tfor (y = 0; y < cmpt->height; ++y) {\n\t\t\t\tfor (x = 0; x < cmpt->width; ++x) {\n\t\t\t\t\t*jas_seq2d_getref(data, x, y) -= bias;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (jas_image_writecmpt(image, jas_image_numcmpts(image) - 1, 0, 0,\n\t\t  cmpt->width, cmpt->height, data)) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_seq2d_destroy(data);\n\t\tdata = 0;\n\t\tjas_image_destroy(tmpimage);\n\t\ttmpimage = 0;\n\t}\n\n\tmif_hdr_destroy(hdr);\n\thdr = 0;\n\treturn image;\n\nerror:\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\tif (tmpstream && tmpstream != in) {\n\t\tjas_stream_close(tmpstream);\n\t}\n\tif (tmpimage) {\n\t\tjas_image_destroy(tmpimage);\n\t}\n\tif (data) {\n\t\tjas_seq2d_destroy(data);\n\t}\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for save operation.\n\\******************************************************************************/\n\n/* Save an image to a stream in the the MIF format. */\n\nint mif_encode(jas_image_t *image, jas_stream_t *out, char *optstr)\n{\n\tmif_hdr_t *hdr;\n\tjas_image_t *tmpimage;\n\tint fmt;\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\tjas_image_cmptparm_t cmptparm;\n\tjas_seq2d_t *data;\n\tint_fast32_t x;\n\tint_fast32_t y;\n\tint bias;\n\n\thdr = 0;\n\ttmpimage = 0;\n\tdata = 0;\n\n\tif (optstr && *optstr != '\\0') {\n\t\tjas_eprintf(\"warning: ignoring unsupported options\\n\");\n\t}\n\n\tif ((fmt = jas_image_strtofmt(\"pnm\")) < 0) {\n\t\tjas_eprintf(\"error: PNM support required\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(hdr = mif_makehdrfromimage(image))) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_put(hdr, out)) {\n\t\tgoto error;\n\t}\n\n\t/* Output component data. */\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tif (!cmpt->data) {\n\t\t\tif (!(tmpimage = jas_image_create0())) {\n\t\t\t\tgoto error;\n\t\t\t}\t\n\t\t\tcmptparm.tlx = 0;\n\t\t\tcmptparm.tly = 0;\n\t\t\tcmptparm.hstep = cmpt->sampperx;\n\t\t\tcmptparm.vstep = cmpt->samppery;\n\t\t\tcmptparm.width = cmpt->width;\n\t\t\tcmptparm.height = cmpt->height;\n\t\t\tcmptparm.prec = cmpt->prec;\n\t\t\tcmptparm.sgnd = false;\n\t\t\tif (jas_image_addcmpt(tmpimage, jas_image_numcmpts(tmpimage), &cmptparm)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (!(data = jas_seq2d_create(0, 0, cmpt->width, cmpt->height))) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (jas_image_readcmpt(image, cmptno, 0, 0, cmpt->width, cmpt->height,\n\t\t\t  data)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (cmpt->sgnd) {\n\t\t\t\tbias = 1 << (cmpt->prec - 1);\n\t\t\t\tfor (y = 0; y < cmpt->height; ++y) {\n\t\t\t\t\tfor (x = 0; x < cmpt->width; ++x) {\n\t\t\t\t\t\t*jas_seq2d_getref(data, x, y) += bias;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jas_image_writecmpt(tmpimage, 0, 0, 0, cmpt->width, cmpt->height,\n\t\t\t  data)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_seq2d_destroy(data);\n\t\t\tdata = 0;\n\t\t\tif (jas_image_encode(tmpimage, out, fmt, 0)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tjas_image_destroy(tmpimage);\n\t\t\ttmpimage = 0;\n\t\t}\n\t}\n\n\tmif_hdr_destroy(hdr);\n\n\treturn 0;\n\nerror:\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\tif (tmpimage) {\n\t\tjas_image_destroy(tmpimage);\n\t}\n\tif (data) {\n\t\tjas_seq2d_destroy(data);\n\t}\n\treturn -1;\n}\n\n/******************************************************************************\\\n* Code for validate operation.\n\\******************************************************************************/\n\nint mif_validate(jas_stream_t *in)\n{\n\tuchar buf[MIF_MAGICLEN];\n\tuint_fast32_t magic;\n\tint i;\n\tint n;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {\n\t\treturn -1;\n\t}\n\n\t/* Put the validation data back onto the stream, so that the\n\t  stream position will not be changed. */\n\tfor (i = n - 1; i >= 0; --i) {\n\t\tif (jas_stream_ungetc(in, buf[i]) == EOF) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t/* Was enough data read? */\n\tif (n < MIF_MAGICLEN) {\n\t\treturn -1;\n\t}\n\n\t/* Compute the signature value. */\n\tmagic = (buf[0] << 24) | (buf[1] << 16) | (buf[2] << 8) | buf[3];\n\n\t/* Ensure that the signature is correct for this format. */\n\tif (magic != MIF_MAGIC) {\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for MIF header class.\n\\******************************************************************************/\n\nstatic mif_hdr_t *mif_hdr_create(int maxcmpts)\n{\n\tmif_hdr_t *hdr;\n\tif (!(hdr = jas_malloc(sizeof(mif_hdr_t)))) {\n\t\treturn 0;\n\t}\n\thdr->numcmpts = 0;\n\thdr->maxcmpts = 0;\n\thdr->cmpts = 0;\n\tif (mif_hdr_growcmpts(hdr, maxcmpts)) {\n\t\tmif_hdr_destroy(hdr);\n\t\treturn 0;\n\t}\n\treturn hdr;\n}\n\nstatic void mif_hdr_destroy(mif_hdr_t *hdr)\n{\n\tint cmptno;\n\tif (hdr->cmpts) {\n\t\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\t\tmif_cmpt_destroy(hdr->cmpts[cmptno]);\n\t\t}\n\t\tjas_free(hdr->cmpts);\n\t}\n\tjas_free(hdr);\n}\n\nstatic int mif_hdr_growcmpts(mif_hdr_t *hdr, int maxcmpts)\n{\n\tint cmptno;\n\tmif_cmpt_t **newcmpts;\n\tassert(maxcmpts >= hdr->numcmpts);\n\tnewcmpts = (!hdr->cmpts) ? jas_malloc(maxcmpts * sizeof(mif_cmpt_t *)) :\n\t  jas_realloc(hdr->cmpts, maxcmpts * sizeof(mif_cmpt_t *));\n\tif (!newcmpts) {\n\t\treturn -1;\n\t}\n\thdr->maxcmpts = maxcmpts;\n\thdr->cmpts = newcmpts;\n\tfor (cmptno = hdr->numcmpts; cmptno < hdr->maxcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = 0;\n\t}\n\treturn 0;\n}\n\nstatic mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tuchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {\n\t\tgoto error;\n\t}\n\tif (magicbuf[0] != (MIF_MAGIC >> 24) || magicbuf[1] != ((MIF_MAGIC >> 16) &\n\t  0xff) || magicbuf[2] != ((MIF_MAGIC >> 8) & 0xff) || magicbuf[3] !=\n\t  (MIF_MAGIC & 0xff)) {\n\t\tjas_eprintf(\"error: bad signature\\n\");\n\t\tgoto error;\n\t}\n\n\tif (!(hdr = mif_hdr_create(0))) {\n\t\tgoto error;\n\t}\n\n\tdone = false;\n\tdo {\n\t\tif (!mif_getline(in, buf, sizeof(buf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (buf[0] == '\\0') {\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (jas_tvparser_next(tvp)) {\n\t\t\tabort();\n\t\t}\n\t\tid = jas_taginfo_nonull(jas_taginfos_lookup(mif_tags2, jas_tvparser_gettag(tvp)))->id;\n\t\tjas_tvparser_destroy(tvp);\n\t\tswitch (id) {\n\t\tcase MIF_CMPT:\n\t\t\tmif_process_cmpt(hdr, buf);\n\t\t\tbreak;\n\t\tcase MIF_END:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!done);\n\n\treturn hdr;\n\nerror:\n\tif (hdr) {\n\t\tmif_hdr_destroy(hdr);\n\t}\n\treturn 0;\n}\n\nstatic int mif_process_cmpt(mif_hdr_t *hdr, char *buf)\n{\n\tjas_tvparser_t *tvp;\n\tmif_cmpt_t *cmpt;\n\tint id;\n\n\tcmpt = 0;\n\ttvp = 0;\n\n\tif (!(cmpt = mif_cmpt_create())) {\n\t\tgoto error;\n\t}\n\tcmpt->tlx = 0;\n\tcmpt->tly = 0;\n\tcmpt->sampperx = 0;\n\tcmpt->samppery = 0;\n\tcmpt->width = 0;\n\tcmpt->height = 0;\n\tcmpt->prec = 0;\n\tcmpt->sgnd = -1;\n\tcmpt->data = 0;\n\n\tif (!(tvp = jas_tvparser_create(buf))) {\n\t\tgoto error;\n\t}\n\twhile (!(id = jas_tvparser_next(tvp))) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(mif_tags,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase MIF_TLX:\n\t\t\tcmpt->tlx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_TLY:\n\t\t\tcmpt->tly = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_WIDTH:\n\t\t\tcmpt->width = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HEIGHT:\n\t\t\tcmpt->height = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_HSAMP:\n\t\t\tcmpt->sampperx = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_VSAMP:\n\t\t\tcmpt->samppery = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_PREC:\n\t\t\tcmpt->prec = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_SGND:\n\t\t\tcmpt->sgnd = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tcase MIF_DATA:\n\t\t\tif (!(cmpt->data = jas_strdup(jas_tvparser_getval(tvp)))) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!cmpt->sampperx || !cmpt->samppery) {\n\t\tgoto error;\n\t}\n\tif (mif_hdr_addcmpt(hdr, hdr->numcmpts, cmpt)) {\n\t\tgoto error;\n\t}\n\tjas_tvparser_destroy(tvp);\n\treturn 0;\n\nerror:\n\tif (cmpt) {\n\t\tmif_cmpt_destroy(cmpt);\n\t}\n\tif (tvp) {\n\t\tjas_tvparser_destroy(tvp);\n\t}\n\treturn -1;\n}\n\nstatic int mif_hdr_put(mif_hdr_t *hdr, jas_stream_t *out)\n{\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\n\t/* Output signature. */\n\tjas_stream_putc(out, (MIF_MAGIC >> 24) & 0xff);\n\tjas_stream_putc(out, (MIF_MAGIC >> 16) & 0xff);\n\tjas_stream_putc(out, (MIF_MAGIC >> 8) & 0xff);\n\tjas_stream_putc(out, MIF_MAGIC & 0xff);\n\n\t/* Output component information. */\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tjas_stream_printf(out, \"component tlx=%ld tly=%ld \"\n\t\t  \"sampperx=%ld samppery=%ld width=%ld height=%ld prec=%d sgnd=%d\",\n\t\t  cmpt->tlx, cmpt->tly, cmpt->sampperx, cmpt->samppery, cmpt->width,\n\t\t  cmpt->height, cmpt->prec, cmpt->sgnd);\n\t\tif (cmpt->data) {\n\t\t\tjas_stream_printf(out, \" data=%s\", cmpt->data);\n\t\t}\n\t\tjas_stream_printf(out, \"\\n\");\n\t}\n\n\t/* Output end of header indicator. */\n\tjas_stream_printf(out, \"end\\n\");\n\n\treturn 0;\n}\n\nstatic int mif_hdr_addcmpt(mif_hdr_t *hdr, int cmptno, mif_cmpt_t *cmpt)\n{\n\tassert(cmptno >= hdr->numcmpts);\n\tif (hdr->numcmpts >= hdr->maxcmpts) {\n\t\tif (mif_hdr_growcmpts(hdr, hdr->numcmpts + 128)) {\n\t\t\treturn -1;\n\t\t}\n\t}\n\thdr->cmpts[hdr->numcmpts] = cmpt;\n\t++hdr->numcmpts;\n\treturn 0;\n}\n\n/******************************************************************************\\\n* Code for MIF component class.\n\\******************************************************************************/\n\nstatic mif_cmpt_t *mif_cmpt_create()\n{\n\tmif_cmpt_t *cmpt;\n\tif (!(cmpt = jas_malloc(sizeof(mif_cmpt_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(cmpt, 0, sizeof(mif_cmpt_t));\n\treturn cmpt;\n}\n\nstatic void mif_cmpt_destroy(mif_cmpt_t *cmpt)\n{\n\tif (cmpt->data) {\n\t\tjas_free(cmpt->data);\n\t}\n\tjas_free(cmpt);\n}\n\n/******************************************************************************\\\n* MIF parsing code.\n\\******************************************************************************/\n\nstatic char *mif_getline(jas_stream_t *stream, char *buf, int bufsize)\n{\n\tint c;\n\tchar *bufptr;\n\tassert(bufsize > 0);\n\n\tbufptr = buf;\n\twhile (bufsize > 1) {\n\t\tif ((c = mif_getc(stream)) == EOF) {\n\t\t\tbreak;\n\t\t}\n\t\t*bufptr++ = c;\n\t\t--bufsize;\n\t\tif (c == '\\n') {\n\t\t\tbreak;\n\t\t}\n\t}\n\t*bufptr = '\\0';\n\tif (!(bufptr = strchr(buf, '\\n'))) {\n\t\treturn 0;\n\t}\n\t*bufptr = '\\0';\n\treturn buf;\n}\n\nstatic int mif_getc(jas_stream_t *in)\n{\n\tint c;\n\tbool done;\n\n\tdone = false;\n\tdo {\n\t\tswitch (c = jas_stream_getc(in)) {\n\t\tcase EOF:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\tcase '#':\n\t\t\tfor (;;) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\n\t\t\t\tif (c == '\\n') {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tif (jas_stream_peekc(in) == '\\n') {\n\t\t\t\tjas_stream_getc(in);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdone = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!done);\n\n\treturn c;\n}\n\n/******************************************************************************\\\n* Miscellaneous functions.\n\\******************************************************************************/\n\nstatic mif_hdr_t *mif_makehdrfromimage(jas_image_t *image)\n{\n\tmif_hdr_t *hdr;\n\tint cmptno;\n\tmif_cmpt_t *cmpt;\n\n\tif (!(hdr = mif_hdr_create(jas_image_numcmpts(image)))) {\n\t\treturn 0;\n\t}\n\thdr->magic = MIF_MAGIC;\n\thdr->numcmpts = jas_image_numcmpts(image);\n\tfor (cmptno = 0; cmptno < hdr->numcmpts; ++cmptno) {\n\t\thdr->cmpts[cmptno] = jas_malloc(sizeof(mif_cmpt_t));\n\t\tcmpt = hdr->cmpts[cmptno];\n\t\tcmpt->tlx = jas_image_cmpttlx(image, cmptno);\n\t\tcmpt->tly = jas_image_cmpttly(image, cmptno);\n\t\tcmpt->width = jas_image_cmptwidth(image, cmptno);\n\t\tcmpt->height = jas_image_cmptheight(image, cmptno);\n\t\tcmpt->sampperx = jas_image_cmpthstep(image, cmptno);\n\t\tcmpt->samppery = jas_image_cmptvstep(image, cmptno);\n\t\tcmpt->prec = jas_image_cmptprec(image, cmptno);\n\t\tcmpt->sgnd = jas_image_cmptsgnd(image, cmptno);\n\t\tcmpt->data = 0;\n\t}\n\treturn hdr;\n}\n"], "filenames": ["src/libjasper/mif/mif_cod.c"], "buggy_code_start_loc": [572], "buggy_code_end_loc": [580], "fixing_code_start_loc": [573], "fixing_code_end_loc": [579], "type": "CWE-416", "message": "Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file.", "other": {"cve": {"id": "CVE-2015-5221", "sourceIdentifier": "secalert@redhat.com", "published": "2017-07-25T18:29:00.727", "lastModified": "2018-11-22T11:29:00.947", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in the mif_process_cmpt function in libjasper/mif/mif_cod.c in the JasPer JPEG-2000 library before 1.900.2 allows remote attackers to cause a denial of service (crash) via a crafted JPEG 2000 image file."}, {"lang": "es", "value": "La vulnerabilidad de uso despu\u00e9s liberada (Use-after-free) en la funci\u00f3n mif_process_cmpt en el archivo libjasper/mif/mif_cod.c en la biblioteca JPEG-2000 de JasPer anterior a versi\u00f3n 1.900.2, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (bloqueo) por medio de un archivo de imagen JPEG 2000 creado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:23:*:*:*:*:*:*:*", "matchCriteriaId": "E79AB8DD-C907-4038-A931-1A5A4CFB6A5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:24:*:*:*:*:*:*:*", "matchCriteriaId": "C729D5D1-ED95-443A-9F53-5D7C2FD9B80C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.2:*:*:*:*:*:*:*", "matchCriteriaId": "1EA337A3-B9A3-4962-B8BD-8E0C7C5B28EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse_project:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "CF605E46-ADCE-45B3-BBBA-E593D3CEE2A6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jasper_project:jasper:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.900.1", "matchCriteriaId": "D6B12933-EE92-4DF3-9D6A-296E0FC49395"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2016-11/msg00010.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-11/msg00018.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-11/msg00064.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2015/08/20/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1208", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1255710", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/11/msg00023.html", "source": "secalert@redhat.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/3QIZNTZDXOJR5BTRZKCS3GVHVZV2PWHH/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AXWV22WGSQFDRPE7G6ECGP3QXS2V2A2M/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UNLVBZWDEXZCFWOBZ3YVEQINMRBRX5QV/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3693-1/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/mdadams/jasper/commit/df5d2867e8004e51e18b89865bc4aa69229227b3"}}