{"buggy_code": ["/*\n * Copyright (c) 2008, Christoph Hellwig\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_vnodeops.h\"\n#include \"xfs_trace.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n\n\n/*\n * Locking scheme:\n *  - all ACL updates are protected by inode->i_mutex, which is taken before\n *    calling into this file.\n */\n\nSTATIC struct posix_acl *\nxfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tace->ae_id = cpu_to_be32(acl_e->e_id);\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}\n\nstruct posix_acl *\nxfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl;\n\tstruct xfs_acl *xfs_acl;\n\tint len = sizeof(struct xfs_acl);\n\tunsigned char *ea_name;\n\tint error;\n\n\tacl = get_cached_acl(inode, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn acl;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\n\txfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = -xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient and\n\t\t * leave the cache entry as ACL_NOT_CACHED.\n\t\t */\n\t\tif (error == -ENOATTR) {\n\t\t\tacl = NULL;\n\t\t\tgoto out_update_cache;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tacl = xfs_acl_from_disk(xfs_acl);\n\tif (IS_ERR(acl))\n\t\tgoto out;\n\n out_update_cache:\n\tset_cached_acl(inode, type, acl);\n out:\n\tkfree(xfs_acl);\n\treturn acl;\n}\n\nSTATIC int\nxfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len;\n\n\t\txfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\t\tlen = sizeof(struct xfs_acl) -\n\t\t\t(sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES - acl->a_count));\n\n\t\terror = -xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkfree(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = -xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nstatic int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = -xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}\n\nstatic int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = sizeof(struct xfs_acl);\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}\n\nint\nposix_acl_access_exists(struct inode *inode)\n{\n\treturn xfs_acl_exists(inode, SGI_ACL_FILE);\n}\n\nint\nposix_acl_default_exists(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\treturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\n}\n\n/*\n * No need for i_mutex because the inode is not yet exposed to the VFS.\n */\nint\nxfs_inherit_acl(struct inode *inode, struct posix_acl *acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error = 0, inherit = 0;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = xfs_set_acl(inode, ACL_TYPE_DEFAULT, acl);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = posix_acl_create(&acl, GFP_KERNEL, &mode);\n\tif (error < 0)\n\t\treturn error;\n\n\t/*\n\t * If posix_acl_create returns a positive value we need to\n\t * inherit a permission that can't be represented using the Unix\n\t * mode bits and we actually need to set an ACL.\n\t */\n\tif (error > 0)\n\t\tinherit = 1;\n\n\terror = xfs_set_mode(inode, mode);\n\tif (error)\n\t\tgoto out;\n\n\tif (inherit)\n\t\terror = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);\n\nout:\n\tposix_acl_release(acl);\n\treturn error;\n}\n\nint\nxfs_acl_chmod(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = xfs_get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl) || !acl)\n\t\treturn PTR_ERR(acl);\n\n\terror = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);\n\tposix_acl_release(acl);\n\treturn error;\n}\n\nstatic int\nxfs_xattr_acl_get(struct dentry *dentry, const char *name,\n\t\tvoid *value, size_t size, int type)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tacl = xfs_get_acl(dentry->d_inode, type);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nstatic int\nxfs_xattr_acl_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct posix_acl *acl = NULL;\n\tint error = 0;\n\n\tif (flags & XATTR_CREATE)\n\t\treturn -EINVAL;\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn value ? -EACCES : 0;\n\tif ((current_fsuid() != inode->i_uid) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (!value)\n\t\tgoto set_acl;\n\n\tacl = posix_acl_from_xattr(value, size);\n\tif (!acl) {\n\t\t/*\n\t\t * acl_set_file(3) may request that we set default ACLs with\n\t\t * zero length -- defend (gracefully) against that here.\n\t\t */\n\t\tgoto out;\n\t}\n\tif (IS_ERR(acl)) {\n\t\terror = PTR_ERR(acl);\n\t\tgoto out;\n\t}\n\n\terror = posix_acl_valid(acl);\n\tif (error)\n\t\tgoto out_release;\n\n\terror = -EINVAL;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES)\n\t\tgoto out_release;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t}\n\n set_acl:\n\terror = xfs_set_acl(inode, type, acl);\n out_release:\n\tposix_acl_release(acl);\n out:\n\treturn error;\n}\n\nconst struct xattr_handler xfs_xattr_acl_access_handler = {\n\t.prefix\t= POSIX_ACL_XATTR_ACCESS,\n\t.flags\t= ACL_TYPE_ACCESS,\n\t.get\t= xfs_xattr_acl_get,\n\t.set\t= xfs_xattr_acl_set,\n};\n\nconst struct xattr_handler xfs_xattr_acl_default_handler = {\n\t.prefix\t= POSIX_ACL_XATTR_DEFAULT,\n\t.flags\t= ACL_TYPE_DEFAULT,\n\t.get\t= xfs_xattr_acl_get,\n\t.set\t= xfs_xattr_acl_set,\n};\n"], "fixing_code": ["/*\n * Copyright (c) 2008, Christoph Hellwig\n * All Rights Reserved.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it would be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write the Free Software Foundation,\n * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n#include \"xfs.h\"\n#include \"xfs_acl.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_vnodeops.h\"\n#include \"xfs_trace.h\"\n#include <linux/slab.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n\n\n/*\n * Locking scheme:\n *  - all ACL updates are protected by inode->i_mutex, which is taken before\n *    calling into this file.\n */\n\nSTATIC struct posix_acl *\nxfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\t\tacl_e = &acl->a_entries[i];\n\t\tace = &aclp->acl_entry[i];\n\n\t\t/*\n\t\t * The tag is 32 bits on disk and 16 bits in core.\n\t\t *\n\t\t * Because every access to it goes through the core\n\t\t * format first this is not a problem.\n\t\t */\n\t\tacl_e->e_tag = be32_to_cpu(ace->ae_tag);\n\t\tacl_e->e_perm = be16_to_cpu(ace->ae_perm);\n\n\t\tswitch (acl_e->e_tag) {\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tacl_e->e_id = be32_to_cpu(ace->ae_id);\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tacl_e->e_id = ACL_UNDEFINED_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn acl;\n\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}\n\nSTATIC void\nxfs_acl_to_disk(struct xfs_acl *aclp, const struct posix_acl *acl)\n{\n\tconst struct posix_acl_entry *acl_e;\n\tstruct xfs_acl_entry *ace;\n\tint i;\n\n\taclp->acl_cnt = cpu_to_be32(acl->a_count);\n\tfor (i = 0; i < acl->a_count; i++) {\n\t\tace = &aclp->acl_entry[i];\n\t\tacl_e = &acl->a_entries[i];\n\n\t\tace->ae_tag = cpu_to_be32(acl_e->e_tag);\n\t\tace->ae_id = cpu_to_be32(acl_e->e_id);\n\t\tace->ae_perm = cpu_to_be16(acl_e->e_perm);\n\t}\n}\n\nstruct posix_acl *\nxfs_get_acl(struct inode *inode, int type)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tstruct posix_acl *acl;\n\tstruct xfs_acl *xfs_acl;\n\tint len = sizeof(struct xfs_acl);\n\tunsigned char *ea_name;\n\tint error;\n\n\tacl = get_cached_acl(inode, type);\n\tif (acl != ACL_NOT_CACHED)\n\t\treturn acl;\n\n\ttrace_xfs_get_acl(ip);\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t/*\n\t * If we have a cached ACLs value just return it, not need to\n\t * go out to the disk.\n\t */\n\n\txfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\n\tif (!xfs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terror = -xfs_attr_get(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\t\t\t\t&len, ATTR_ROOT);\n\tif (error) {\n\t\t/*\n\t\t * If the attribute doesn't exist make sure we have a negative\n\t\t * cache entry, for any other error assume it is transient and\n\t\t * leave the cache entry as ACL_NOT_CACHED.\n\t\t */\n\t\tif (error == -ENOATTR) {\n\t\t\tacl = NULL;\n\t\t\tgoto out_update_cache;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tacl = xfs_acl_from_disk(xfs_acl);\n\tif (IS_ERR(acl))\n\t\tgoto out;\n\n out_update_cache:\n\tset_cached_acl(inode, type, acl);\n out:\n\tkfree(xfs_acl);\n\treturn acl;\n}\n\nSTATIC int\nxfs_set_acl(struct inode *inode, int type, struct posix_acl *acl)\n{\n\tstruct xfs_inode *ip = XFS_I(inode);\n\tunsigned char *ea_name;\n\tint error;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = SGI_ACL_FILE;\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tea_name = SGI_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tstruct xfs_acl *xfs_acl;\n\t\tint len;\n\n\t\txfs_acl = kzalloc(sizeof(struct xfs_acl), GFP_KERNEL);\n\t\tif (!xfs_acl)\n\t\t\treturn -ENOMEM;\n\n\t\txfs_acl_to_disk(xfs_acl, acl);\n\t\tlen = sizeof(struct xfs_acl) -\n\t\t\t(sizeof(struct xfs_acl_entry) *\n\t\t\t (XFS_ACL_MAX_ENTRIES - acl->a_count));\n\n\t\terror = -xfs_attr_set(ip, ea_name, (unsigned char *)xfs_acl,\n\t\t\t\tlen, ATTR_ROOT);\n\n\t\tkfree(xfs_acl);\n\t} else {\n\t\t/*\n\t\t * A NULL ACL argument means we want to remove the ACL.\n\t\t */\n\t\terror = -xfs_attr_remove(ip, ea_name, ATTR_ROOT);\n\n\t\t/*\n\t\t * If the attribute didn't exist to start with that's fine.\n\t\t */\n\t\tif (error == -ENOATTR)\n\t\t\terror = 0;\n\t}\n\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\treturn error;\n}\n\nstatic int\nxfs_set_mode(struct inode *inode, umode_t mode)\n{\n\tint error = 0;\n\n\tif (mode != inode->i_mode) {\n\t\tstruct iattr iattr;\n\n\t\tiattr.ia_valid = ATTR_MODE | ATTR_CTIME;\n\t\tiattr.ia_mode = mode;\n\t\tiattr.ia_ctime = current_fs_time(inode->i_sb);\n\n\t\terror = -xfs_setattr_nonsize(XFS_I(inode), &iattr, XFS_ATTR_NOACL);\n\t}\n\n\treturn error;\n}\n\nstatic int\nxfs_acl_exists(struct inode *inode, unsigned char *name)\n{\n\tint len = sizeof(struct xfs_acl);\n\n\treturn (xfs_attr_get(XFS_I(inode), name, NULL, &len,\n\t\t\t    ATTR_ROOT|ATTR_KERNOVAL) == 0);\n}\n\nint\nposix_acl_access_exists(struct inode *inode)\n{\n\treturn xfs_acl_exists(inode, SGI_ACL_FILE);\n}\n\nint\nposix_acl_default_exists(struct inode *inode)\n{\n\tif (!S_ISDIR(inode->i_mode))\n\t\treturn 0;\n\treturn xfs_acl_exists(inode, SGI_ACL_DEFAULT);\n}\n\n/*\n * No need for i_mutex because the inode is not yet exposed to the VFS.\n */\nint\nxfs_inherit_acl(struct inode *inode, struct posix_acl *acl)\n{\n\tumode_t mode = inode->i_mode;\n\tint error = 0, inherit = 0;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\terror = xfs_set_acl(inode, ACL_TYPE_DEFAULT, acl);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\terror = posix_acl_create(&acl, GFP_KERNEL, &mode);\n\tif (error < 0)\n\t\treturn error;\n\n\t/*\n\t * If posix_acl_create returns a positive value we need to\n\t * inherit a permission that can't be represented using the Unix\n\t * mode bits and we actually need to set an ACL.\n\t */\n\tif (error > 0)\n\t\tinherit = 1;\n\n\terror = xfs_set_mode(inode, mode);\n\tif (error)\n\t\tgoto out;\n\n\tif (inherit)\n\t\terror = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);\n\nout:\n\tposix_acl_release(acl);\n\treturn error;\n}\n\nint\nxfs_acl_chmod(struct inode *inode)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\tacl = xfs_get_acl(inode, ACL_TYPE_ACCESS);\n\tif (IS_ERR(acl) || !acl)\n\t\treturn PTR_ERR(acl);\n\n\terror = posix_acl_chmod(&acl, GFP_KERNEL, inode->i_mode);\n\tif (error)\n\t\treturn error;\n\n\terror = xfs_set_acl(inode, ACL_TYPE_ACCESS, acl);\n\tposix_acl_release(acl);\n\treturn error;\n}\n\nstatic int\nxfs_xattr_acl_get(struct dentry *dentry, const char *name,\n\t\tvoid *value, size_t size, int type)\n{\n\tstruct posix_acl *acl;\n\tint error;\n\n\tacl = xfs_get_acl(dentry->d_inode, type);\n\tif (IS_ERR(acl))\n\t\treturn PTR_ERR(acl);\n\tif (acl == NULL)\n\t\treturn -ENODATA;\n\n\terror = posix_acl_to_xattr(acl, value, size);\n\tposix_acl_release(acl);\n\n\treturn error;\n}\n\nstatic int\nxfs_xattr_acl_set(struct dentry *dentry, const char *name,\n\t\tconst void *value, size_t size, int flags, int type)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct posix_acl *acl = NULL;\n\tint error = 0;\n\n\tif (flags & XATTR_CREATE)\n\t\treturn -EINVAL;\n\tif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\n\t\treturn value ? -EACCES : 0;\n\tif ((current_fsuid() != inode->i_uid) && !capable(CAP_FOWNER))\n\t\treturn -EPERM;\n\n\tif (!value)\n\t\tgoto set_acl;\n\n\tacl = posix_acl_from_xattr(value, size);\n\tif (!acl) {\n\t\t/*\n\t\t * acl_set_file(3) may request that we set default ACLs with\n\t\t * zero length -- defend (gracefully) against that here.\n\t\t */\n\t\tgoto out;\n\t}\n\tif (IS_ERR(acl)) {\n\t\terror = PTR_ERR(acl);\n\t\tgoto out;\n\t}\n\n\terror = posix_acl_valid(acl);\n\tif (error)\n\t\tgoto out_release;\n\n\terror = -EINVAL;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES)\n\t\tgoto out_release;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tposix_acl_release(acl);\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\tgoto out_release;\n\t}\n\n set_acl:\n\terror = xfs_set_acl(inode, type, acl);\n out_release:\n\tposix_acl_release(acl);\n out:\n\treturn error;\n}\n\nconst struct xattr_handler xfs_xattr_acl_access_handler = {\n\t.prefix\t= POSIX_ACL_XATTR_ACCESS,\n\t.flags\t= ACL_TYPE_ACCESS,\n\t.get\t= xfs_xattr_acl_get,\n\t.set\t= xfs_xattr_acl_set,\n};\n\nconst struct xattr_handler xfs_xattr_acl_default_handler = {\n\t.prefix\t= POSIX_ACL_XATTR_DEFAULT,\n\t.flags\t= ACL_TYPE_DEFAULT,\n\t.get\t= xfs_xattr_acl_get,\n\t.set\t= xfs_xattr_acl_set,\n};\n"], "filenames": ["fs/xfs/xfs_acl.c"], "buggy_code_start_loc": [42], "buggy_code_end_loc": [43], "fixing_code_start_loc": [42], "fixing_code_end_loc": [43], "type": "CWE-190", "message": "Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow.", "other": {"cve": {"id": "CVE-2012-0038", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:35.820", "lastModified": "2023-02-13T03:24:13.327", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Integer overflow in the xfs_acl_from_disk function in fs/xfs/xfs_acl.c in the Linux kernel before 3.1.9 allows local users to cause a denial of service (panic) via a filesystem with a malformed ACL, leading to a heap-based buffer overflow."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n xfs_acl_from_disk en fs/xfs/xfs_acl.c en el n\u00facleo de Linux anterior a v3.1.9 que permite a usuarios locales causar una denegaci\u00f3n de servicio (panic) a trav\u00e9s del sistema de ficheros con una lista ACL mal construida, dando lugar a un desbordamiento de b\u00fafer basado en heap."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.9", "matchCriteriaId": "08C8D736-17F1-4164-80A1-A5FED77C0129"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "source": "secalert@redhat.com"}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1.9", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/01/10/11", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=773280", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/093019cf1b18dd31b2c3b77acce4e000e2cbc9ce", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/fa8b18edd752a8b4e9d1ee2cd615b82c93cf8bba", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/093019cf1b18dd31b2c3b77acce4e000e2cbc9ce"}}