{"buggy_code": ["def try_get_cached(domain, dict):\n    title = dict[\"title\"]\n    singer = dict[\"singer\"]\n    album = dict[\"album\"]\n\n    import requests, json\n\n    api = f'http://{domain}:7873/Y2hlY2tfY2FjaGVkX2ZpbGVz'\n\n    headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}\n    payload = json.dumps({\"title\": title, \"singer\": singer, \"album\": album})\n    response = requests.post(api, data=payload, headers=headers)\n\n    status = eval(response.text)\n\n    return status\n\n\ndef get(image_file, domain, title, singer, album):\n    import base64\n    import json    \n    import ast               \n\n    import requests\n\n    api = f'http://{domain}:7873/bGVhdmVfcmlnaHRfbm93'\n\n    with open(image_file, \"rb\") as f:\n        im_bytes = f.read()        \n    im_b64 = base64.b64encode(im_bytes).decode(\"utf8\")\n\n    headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}\n\n    status = try_get_cached(domain, {\"title\": title, \"singer\": singer, \"album\": album})\n    status = ast.literal_eval(str(status))\n\n    if status == None:\n        print(\"Cached version not found. Uploading image with song metadata.\")\n        payload = json.dumps({\"image\": im_b64, \"title\": title, \"singer\": singer, \"album\": album})\n        response = requests.post(api, data=payload, headers=headers)\n\n        data = response.text[\"data\"]\n    else:\n        data = status\n\n    # data = [{\"title\": title, \"singer\": singer, \"album\": album}, file_name, file_ending]\n\n    return data\n\n#print(get(\"sample_image.jpg\", \"localhost\", \"title\", \"artist\", \"album\"))\n\n#try_get_cached(\"localhost\", {\"title\": \"title\", \"singer\": \"singer\", \"album\": \"album\"})\n\n#print(get(\"sample_image.png\", \"localhost\", \"not_title\", \"singer\", \"album\"))", "import io                 \nimport base64                  \nimport logging\nimport random\nimport ast\nfrom PIL import Image\n\nfrom flask import Flask, request, jsonify, abort\n\napp = Flask(__name__)          \napp.logger.setLevel(logging.DEBUG)\n\n@app.route(\"/\")\ndef index():\n    return \"<h1>401 - Unauthorised</h1>\"\n\n@app.errorhandler(404)\ndef errorhandle(e):\n    return abort(401)\n\n@app.route(\"/Y2hlY2tfY2FjaGVkX2ZpbGVz\", methods=['POST'])\ndef check_cache():\n    f = open(\"all_files\", \"r\")\n    db = ast.literal_eval(f.read())\n    f.close()\n\n    tmp = request.json\n    x = str({\"title\": tmp[\"title\"], \"singer\": tmp[\"singer\"], \"album\": tmp[\"album\"]})\n    data = ast.literal_eval(x)\n\n    if data[\"title\"][:9] == \"[PAUSED] \":\n        data[\"title\"] = data[\"title\"][9::]\n\n    del tmp\n\n    if type(data) != dict:\n        typeprov = type(data)\n        print(\"Not provided a dict, instead a \"+str(typeprov)+\" was provided. Returning NoneType.\")\n        return \"None\"\n\n    for key in db:\n        print(f\"Analysing data {data} against item(s) {key[0]}.\")\n        if data == key[0]:\n            print(\"Found match for \" + str(data) + \" in database.\")\n            print(\"Returning dictionary: \" + str(key))\n            return str(key)\n\n    print(\"No match found. Returning NoneType.\")\n    return \"None\"\n\n@app.route(\"/bGVhdmVfcmlnaHRfbm93\", methods=['POST'])\ndef uploadimage():\n    #print(request.json)   \n    if not request.json or 'image' not in request.json:\n        print(\"No data sent or no image provided. Aborting with 400.\")\n        abort(400)\n             \n    im_b64 = request.json['image']\n    img_bytes = base64.b64decode(im_b64.encode('utf-8'))\n    img = Image.open(io.BytesIO(img_bytes))\n\n    file_ending = img.format\n    print(f\"File has filetype {file_ending}.\")\n\n    if file_ending == \"JPEG\":\n        file_ending = \".jpg\"\n    else:\n        file_ending = \".png\"\n\n    one_hundred_million = 100000000\n    lots_of_nine = 999999999\n\n    file_name = None\n\n    f = open(\"all_files\", \"r\")\n    all_files = ast.literal_eval(f.read())\n    f.close()\n\n    attempt = 0\n\n    while file_name == None or file_name in all_files:\n        if attempt <= 1000:\n            file_name = random.randint(one_hundred_million, lots_of_nine)\n\n            file_name = base64.b64encode(str(file_name).encode(\"utf-8\")).decode(\"utf-8\")\n\n            print(f\"Trying new file name: {file_name}\")\n        else:\n            attempt = 0\n            one_hundred_million += 100000\n            lots_of_nine += 1000000\n\n            while one_hundred_million >= lots_of_nine:\n                one_hundred_million -= 10000\n\n            one_hundred_million -= 10000\n\n    print(f\"Successful file name: {file_name}\")\n\n    title = request.json[\"title\"]\n    print(\"First 9 chars of title: \"+str(title[:9]))\n    print(\"Title from 10th char: \"+str(title[9::]))\n    if title[:9] == \"[PAUSED] \":\n        title = title[9::]\n\n    singer = request.json[\"singer\"]\n    album = request.json[\"album\"]\n    \n    file_db_entry = [{\"title\": title, \"singer\": singer, \"album\": album}, file_name, file_ending]\n    print(f\"New db entry: {file_db_entry}\")\n\n    all_files.append(file_db_entry)\n\n    f = open(\"all_files\", \"w\")\n    f.write(str(all_files))\n    f.close()\n\n    file_name = file_name + file_ending\n\n    image = img.save(file_name)\n    print(f\"Saved {file_name} from {file_db_entry}.\")\n    print(f\"Returning {file_db_entry}.\")\n    return {\"entry\": file_db_entry}\n  \n  \ndef run_server_api():\n    app.run(host='0.0.0.0', port=7873)\n  \n  \nif __name__ == \"__main__\":     \n    run_server_api()\n"], "fixing_code": ["def try_get_cached(domain, dict):\n    title = dict[\"title\"]\n    singer = dict[\"singer\"]\n    album = dict[\"album\"]\n\n    import requests, json\n\n    api = f'http://{domain}:7873/Y2hlY2tfY2FjaGVkX2ZpbGVz'\n\n    headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}\n    payload = json.dumps({\"title\": title, \"singer\": singer, \"album\": album})\n    response = requests.post(api, data=payload, headers=headers)\n\n    status = eval(response.text)\n\n    return status\n\n\ndef get(image_file, domain, title, singer, album):\n    import base64\n    import json    \n    import ast\n    from html import unescape         \n\n    import requests\n\n    api = f'http://{domain}:7873/bGVhdmVfcmlnaHRfbm93'\n\n    with open(image_file, \"rb\") as f:\n        im_bytes = f.read()        \n    im_b64 = base64.b64encode(im_bytes).decode(\"utf8\")\n\n    headers = {'Content-type': 'application/json', 'Accept': 'text/plain'}\n\n    status = try_get_cached(domain, {\"title\": title, \"singer\": singer, \"album\": album})\n    status = ast.literal_eval(str(status))\n\n    if status == None:\n        print(\"Cached version not found. Uploading image with song metadata.\")\n        payload = json.dumps({\"image\": im_b64, \"title\": title, \"singer\": singer, \"album\": album})\n        response = requests.post(api, data=payload, headers=headers)\n\n        data = unescape(response.text[\"entry\"])\n    else:\n        data = status\n\n    # data = [{\"title\": title, \"singer\": singer, \"album\": album}, file_name, file_ending]\n\n    return data\n\n#print(get(\"sample_image.jpg\", \"localhost\", \"title\", \"artist\", \"album\"))\n\n#try_get_cached(\"localhost\", {\"title\": \"title\", \"singer\": \"singer\", \"album\": \"album\"})\n\n#print(get(\"sample_image.png\", \"localhost\", \"not_title\", \"singer\", \"album\"))", "import io                 \nimport base64                  \nimport logging\nimport random\nimport ast\nfrom PIL import Image\n\nfrom flask import Flask, request, abort\nfrom html import escape\n\napp = Flask(__name__)          \napp.logger.setLevel(logging.DEBUG)\n\n@app.route(\"/\")\ndef index():\n    return \"<h1>401 - Unauthorised</h1>\"\n\n@app.errorhandler(404)\ndef errorhandle(e):\n    return abort(401)\n\n@app.route(\"/Y2hlY2tfY2FjaGVkX2ZpbGVz\", methods=['POST'])\ndef check_cache():\n    f = open(\"all_files\", \"r\")\n    db = ast.literal_eval(f.read())\n    f.close()\n\n    tmp = request.json\n    x = str({\"title\": tmp[\"title\"], \"singer\": tmp[\"singer\"], \"album\": tmp[\"album\"]})\n    data = ast.literal_eval(x)\n\n    if data[\"title\"][:9] == \"[PAUSED] \":\n        data[\"title\"] = data[\"title\"][9::]\n\n    del tmp\n\n    if type(data) != dict:\n        typeprov = type(data)\n        print(\"Not provided a dict, instead a \"+str(typeprov)+\" was provided. Returning NoneType.\")\n        return \"None\"\n\n    for key in db:\n        print(f\"Analysing data {data} against item(s) {key[0]}.\")\n        if data == key[0]:\n            print(\"Found match for \" + str(data) + \" in database.\")\n            print(\"Returning dictionary: \" + str(key))\n            return str(key)\n\n    print(\"No match found. Returning NoneType.\")\n    return \"None\"\n\n@app.route(\"/bGVhdmVfcmlnaHRfbm93\", methods=['POST'])\ndef uploadimage():\n    #print(request.json)   \n    if not request.json or 'image' not in request.json:\n        print(\"No data sent or no image provided. Aborting with 400.\")\n        abort(400)\n             \n    im_b64 = request.json['image']\n    img_bytes = base64.b64decode(im_b64.encode('utf-8'))\n    img = Image.open(io.BytesIO(img_bytes))\n\n    file_ending = img.format\n    print(f\"File has filetype {file_ending}.\")\n\n    if file_ending == \"JPEG\":\n        file_ending = \".jpg\"\n    else:\n        file_ending = \".png\"\n\n    one_hundred_million = 100000000\n    lots_of_nine = 999999999\n\n    file_name = None\n\n    f = open(\"all_files\", \"r\")\n    all_files = ast.literal_eval(f.read())\n    f.close()\n\n    attempt = 0\n\n    while file_name == None or file_name in all_files:\n        if attempt <= 1000:\n            file_name = random.randint(one_hundred_million, lots_of_nine)\n\n            file_name = base64.b64encode(str(file_name).encode(\"utf-8\")).decode(\"utf-8\")\n\n            print(f\"Trying new file name: {file_name}\")\n        else:\n            attempt = 0\n            one_hundred_million += 100000\n            lots_of_nine += 1000000\n\n            while one_hundred_million >= lots_of_nine:\n                one_hundred_million -= 10000\n\n            one_hundred_million -= 10000\n\n    print(f\"Successful file name: {file_name}\")\n\n    title = request.json[\"title\"]\n    print(\"First 9 chars of title: \"+str(title[:9]))\n    print(\"Title from 10th char: \"+str(title[9::]))\n    if title[:9] == \"[PAUSED] \":\n        title = title[9::]\n\n    singer = request.json[\"singer\"]\n    album = request.json[\"album\"]\n    \n    file_db_entry = [{\"title\": title, \"singer\": singer, \"album\": album}, file_name, file_ending]\n    print(f\"New db entry: {file_db_entry}\")\n\n    all_files.append(file_db_entry)\n\n    f = open(\"all_files\", \"w\")\n    f.write(str(all_files))\n    f.close()\n\n    file_name = file_name + file_ending\n\n    image = img.save(file_name)\n    print(f\"Saved {file_name} from {file_db_entry}.\")\n    print(f\"Returning {file_db_entry}.\")\n    return escape({\"entry\": file_db_entry})\n  \n  \ndef run_server_api():\n    app.run(host='0.0.0.0', port=7873)\n  \n  \nif __name__ == \"__main__\":     \n    run_server_api()\n"], "filenames": ["module/connect_to_server.py", "upload/server.py"], "buggy_code_start_loc": [22, 8], "buggy_code_end_loc": [43, 124], "fixing_code_start_loc": [22, 8], "fixing_code_end_loc": [44, 125], "type": "CWE-79", "message": "iTunesRPC-Remastered is a discord rich presence application for use with iTunes & Apple Music. In code before commit 24f43aa user input is not properly sanitized and code injection is possible. Users are advised to upgrade as soon as is possible. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23603", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-01T11:15:11.493", "lastModified": "2022-02-07T20:06:15.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "iTunesRPC-Remastered is a discord rich presence application for use with iTunes & Apple Music. In code before commit 24f43aa user input is not properly sanitized and code injection is possible. Users are advised to upgrade as soon as is possible. There are no known workarounds for this issue."}, {"lang": "es", "value": "iTunesRPC-Remastered es una aplicaci\u00f3n de mucha presencia en discord para su uso con iTunes y Apple Music. En el c\u00f3digo anterior al commit 24f43aa la entrada del usuario no es saneada apropiadamente y es posible una inyecci\u00f3n de c\u00f3digo. Se recomienda a usuarios que actualicen lo antes posible. No se conocen medidas de mitigaci\u00f3n adicionales para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:itunesrpc-remastered_project:itunesrpc-remastered:-:*:*:*:*:*:*:*", "matchCriteriaId": "C6C22451-4974-430A-85CC-E266A4A5FB19"}]}]}], "references": [{"url": "https://github.com/bildsben/iTunesRPC-Remastered/commit/24f43aac0f4116b3d89fdbe973ba92c6cfb0d998", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bildsben/iTunesRPC-Remastered/commit/54b02d9f3a94de94e4fb471908b8cf798e62e411", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/bildsben/iTunesRPC-Remastered/security/advisories/GHSA-3xpp-rhqx-cw96", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bildsben/iTunesRPC-Remastered/commit/24f43aac0f4116b3d89fdbe973ba92c6cfb0d998"}}