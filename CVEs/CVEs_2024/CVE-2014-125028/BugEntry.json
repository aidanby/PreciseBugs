{"buggy_code": ["from flask import Flask, render_template, request, session, redirect\nimport os, sys\nimport requests\nimport jwt\n\nCLIENT_ID = 'valtech.idp.testclient.local'\nCLIENT_SECRET = os.environ.get('CLIENT_SECRET')\n\nif CLIENT_SECRET is None:\n  print 'CLIENT_SECRET missing. Start using \"CLIENT_SECRET=very_secret_secret python main.py\"'\n  sys.exit(-1)\n\napp = Flask(__name__, static_url_path='')\n\n@app.route('/')\ndef index():\n  signed_in = session.get('signed_in') != None\n  header = 'Not signed in'\n  text = 'Click the button below to sign in.'\n\n  if signed_in:\n    header = 'Welcome!'\n    text = 'Signed in as %s.' % session['email']\n\n  return render_template('index.html', header=header, text=text)\n\n@app.route('/sign-in')\ndef sign_in():\n  if session.get('signed_in') != None: return redirect('/')\n  authorize_url = 'https://stage-id.valtech.com/oauth2/authorize?response_type=%s&client_id=%s&scope=%s' % ('code', CLIENT_ID, 'email openid')\n  return redirect(authorize_url)\n\n@app.route('/sign-in/callback')\ndef sign_in_callback():\n  code = request.args.get('code')\n\n  # as both scope openid and email was requested on authorize request above, the client\n  # will receive both an access_token (according to OAuth 2) AND an id_token (according to OpenID Connect)\n  tokens = exchange_code_for_tokens(code)\n\n  # if the client only need authentication (and not authorization), the access token can be ignored\n  # (but it is still possible to use it if client wants to, and is left here for documentation)\n  #user_info = fetch_user_info(tokens['access_token'])\n\n  # as this example app is only interested in who logged in, we will parse the id_token.\n  # currently, IDP does not sign id_tokens, but as IDP uses https this is no problem\n  # (but the id_token should not be passed around in plaintext where it can be modified by a man-in-the-middle)\n  user_info = jwt.decode(tokens[\"id_token\"], verify=False)\n\n  session['signed_in'] = True\n  session['email'] = user_info['email']\n  \n  return redirect('/')\n\n@app.route('/sign-out')\ndef sign_out():\n  session.clear()\n  return redirect('https://stage-id.valtech.com/oidc/end-session?client_id=%s' % CLIENT_ID)\n\ndef exchange_code_for_tokens(code):\n  data = {\n    'grant_type': 'authorization_code',\n    'code': code,\n    'client_id': CLIENT_ID,\n    'client_secret': CLIENT_SECRET\n  }\n\n  res = requests.post('https://stage-id.valtech.com/oauth2/token', data=data)\n  return res.json()\n\ndef fetch_user_info(access_token):\n  res = requests.get('https://stage-id.valtech.com/api/users/me', headers={ 'Authorization': 'Bearer %s' % access_token })\n  return res.json()\n\nif __name__ == '__main__':\n  app.secret_key = 'someverysecretkey'\n  app.run(host='0.0.0.0', debug=True)\n"], "fixing_code": ["from flask import Flask, render_template, request, session, redirect, make_response\nimport os, sys\nimport requests\nimport jwt\nimport uuid\n\nCLIENT_ID = 'valtech.idp.testclient.local'\nCLIENT_SECRET = os.environ.get('CLIENT_SECRET')\n\nif CLIENT_SECRET is None:\n  print 'CLIENT_SECRET missing. Start using \"CLIENT_SECRET=very_secret_secret python main.py\"'\n  sys.exit(-1)\n\napp = Flask(__name__, static_url_path='')\n\n@app.route('/')\ndef index():\n  signed_in = session.get('signed_in') != None\n  header = 'Not signed in'\n  text = 'Click the button below to sign in.'\n\n  if signed_in:\n    header = 'Welcome!'\n    text = 'Signed in as %s.' % session['email']\n\n  return render_template('index.html', header=header, text=text)\n\n@app.route('/sign-in')\ndef sign_in():\n  if session.get('signed_in') != None: return redirect('/')\n\n  # state is used for CSRF protection. the client generates a value and stores it\n  # for the user somewhere (in a cookie or in a session). it then passes the same value\n  # in the state parameter in the authorize request. IDP will mirror the state value\n  # to the redirect URI. the client should then make sure the state value it has stored\n  # matches what it receives in the callback\n  state = str(uuid.uuid4())\n\n  authorize_url = 'https://stage-id.valtech.com/oauth2/authorize?response_type=%s&client_id=%s&scope=%s&state=%s' % ('code', CLIENT_ID, 'email openid', state)\n\n  resp = make_response(redirect(authorize_url))\n  resp.set_cookie('python-flask-csrf', state)\n  return resp\n\n@app.route('/sign-in/callback')\ndef sign_in_callback():\n  code = request.args.get('code')\n  state = request.args.get('state')\n\n  if state != request.cookies.get('python-flask-csrf'):\n    raise Exception(\"Possible CSRF detected (state does not match stored state)\")\n\n  # as both scope openid and email was requested on authorize request above, the client\n  # will receive both an access_token (according to OAuth 2) AND an id_token (according to OpenID Connect)\n  tokens = exchange_code_for_tokens(code)\n\n  # if the client only need authentication (and not authorization), the access token can be ignored\n  # (but it is still possible to use it if client wants to, and is left here for documentation)\n  #user_info = fetch_user_info(tokens['access_token'])\n\n  # as this example app is only interested in who logged in, we will parse the id_token.\n  # currently, IDP does not sign id_tokens, but as IDP uses https this is no problem\n  # (but the id_token should not be passed around in plaintext where it can be modified by a man-in-the-middle)\n  user_info = jwt.decode(tokens[\"id_token\"], verify=False)\n\n  session['signed_in'] = True\n  session['email'] = user_info['email']\n\n  resp = make_response(redirect('/'))\n  resp.set_cookie('python-flask-csrf', '', expires=0)\n  return resp\n\n@app.route('/sign-out')\ndef sign_out():\n  session.clear()\n  return redirect('https://stage-id.valtech.com/oidc/end-session?client_id=%s' % CLIENT_ID)\n\ndef exchange_code_for_tokens(code):\n  data = {\n    'grant_type': 'authorization_code',\n    'code': code,\n    'client_id': CLIENT_ID,\n    'client_secret': CLIENT_SECRET\n  }\n\n  res = requests.post('https://stage-id.valtech.com/oauth2/token', data=data)\n  return res.json()\n\ndef fetch_user_info(access_token):\n  res = requests.get('https://stage-id.valtech.com/api/users/me', headers={ 'Authorization': 'Bearer %s' % access_token })\n  return res.json()\n\nif __name__ == '__main__':\n  app.secret_key = 'someverysecretkey'\n  app.run(host='0.0.0.0', debug=True)\n"], "filenames": ["python-flask/main.py"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [54], "fixing_code_start_loc": [1], "fixing_code_end_loc": [72], "type": "CWE-352", "message": "A vulnerability was found in valtech IDP Test Client and classified as problematic. Affected by this issue is some unknown functionality of the file python-flask/main.py. The manipulation leads to cross-site request forgery. The attack may be launched remotely. The name of the patch is f1e7b3d431c8681ec46445557125890c14fa295f. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217148.", "other": {"cve": {"id": "CVE-2014-125028", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-31T20:15:08.507", "lastModified": "2023-01-06T21:48:53.423", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in valtech IDP Test Client and classified as problematic. Affected by this issue is some unknown functionality of the file python-flask/main.py. The manipulation leads to cross-site request forgery. The attack may be launched remotely. The name of the patch is f1e7b3d431c8681ec46445557125890c14fa295f. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-217148."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:valtech:idp_test_clients:*:*:*:*:*:*:*:*", "versionEndExcluding": "2014-09-25", "matchCriteriaId": "79DEDE51-41A2-477B-971E-80442CAA99EB"}]}]}], "references": [{"url": "https://github.com/valtech/valtech-idp-test-clients/commit/f1e7b3d431c8681ec46445557125890c14fa295f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217148", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217148", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/valtech/valtech-idp-test-clients/commit/f1e7b3d431c8681ec46445557125890c14fa295f"}}