{"buggy_code": ["#include <config.h>\n\n#include \"ftpd.h\"\n#include \"ls_p.h\"\n#include \"bsd-glob.h\"\n#include \"messages.h\"\n#include \"dynamic.h\"\n#include \"ftpwho-update.h\"\n#include \"globals.h\"\n#include \"safe_rw.h\"\n#ifdef WITH_TLS\n# include \"tls.h\"\n#endif\n\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nstatic void wrstr(const int f, void * const tls_fd, const char *s)\n{\n    static char outbuf[CONF_TCP_SO_SNDBUF];\n    static size_t outcnt;\n    size_t l;\n\n    if (s == NULL) {\n        if (outcnt > (size_t) 0U) {\n#ifdef WITH_TLS\n            if (tls_fd != NULL) {\n                if (secure_safe_write(tls_fd, outbuf, outcnt) !=\n                    (ssize_t) outcnt) {\n                    return;\n                }\n            } else\n#endif\n            {\n                (void) tls_fd;\n                if (safe_write(f, outbuf, outcnt, -1) != (ssize_t) outcnt) {\n                    return;\n                }\n            }\n        }\n        outcnt = (size_t) 0U;\n        return;\n    }\n    if ((l = strlen(s)) <= (size_t) 0U) {\n        return;\n    }\n    if (l <= (sizeof outbuf - outcnt)) {\n        memcpy(outbuf + outcnt, s, l); /* secure, see above */\n        outcnt += l;\n        return;\n    }\n    if (outcnt < sizeof outbuf) {\n        const size_t rest = sizeof outbuf - outcnt;\n\n        memcpy(outbuf + outcnt, s, rest);   /* secure, see above */\n        s += rest;\n        l -= rest;\n    }\n#ifdef WITH_TLS\n    if (tls_fd != NULL) {\n        if (secure_safe_write(tls_fd, outbuf, sizeof outbuf) !=\n            (ssize_t) sizeof outbuf) {\n            return;\n        }\n    } else\n#endif\n    {\n        if (safe_write(f, outbuf, sizeof outbuf, -1) !=\n            (ssize_t) sizeof outbuf) {\n            return;\n        }\n    }\n#ifdef WITH_TLS\n    if (tls_fd != NULL) {\n        while (l > sizeof outbuf) {\n            if (secure_safe_write(tls_fd, s, sizeof outbuf) !=\n                (ssize_t) sizeof outbuf) {\n                return;\n            }\n            s += sizeof outbuf;\n            l -= sizeof outbuf;\n        }\n    } else\n#endif\n    {\n        while (l > sizeof outbuf) {\n            if (safe_write(f, s, sizeof outbuf, -1) !=\n                (ssize_t) sizeof outbuf) {\n                return;\n            }\n            s += sizeof outbuf;\n            l -= sizeof outbuf;\n        }\n    }\n    if (l > (size_t) 0U) {\n        memcpy(outbuf, s, l);          /* safe, l <= sizeof outbuf */\n        outcnt = l;\n    }\n}\n\n#ifdef NO_FTP_USERS\nconst char *getname(const uid_t uid)\n{\n    static char number[11];\n\n    snprintf(number, sizeof number, \"%-10d\", uid);\n    return number;\n}\n\nconst char *getgroup(const gid_t gid)\n{\n    static char number[11];\n\n    snprintf(number, sizeof number, \"%-10d\", gid);\n    return number;\n}\n#else\n\nconst char *getname(const uid_t uid)\n{\n    struct userid *p;\n    struct passwd *pwd = NULL;\n\n    for (p = user_head; p; p = p->next) {\n        if (p->uid == uid) {\n            return p->name;\n        }\n    }\n    if (\n# ifndef ALWAYS_RESOLVE_IDS\n        chrooted == 0 &&\n# endif\n        authresult.slow_tilde_expansion == 0) {\n        pwd = getpwuid(uid);\n    }\n    if ((p = malloc(sizeof *p)) == NULL) {\n        die_mem();\n    }\n    p->uid = uid;\n    if ((p->name = malloc((size_t) 11U)) == NULL) {\n        die_mem();\n    }\n    if (pwd != NULL) {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U,\n                             \"%-10.10s\", pwd->pw_name), (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    } else {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U, \"%-10d\", uid),\n                    (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n    p->next = user_head;\n    user_head = p;\n\n    return p->name;\n}\n\n/* eeeehm... sorry for names, ya know copy&paste :))) */\nconst char *getgroup(const gid_t gid)\n{\n    struct groupid *p;\n    struct group *pwd = NULL;\n\n    for (p = group_head; p; p = p->next) {\n        if (p->gid == gid) {\n            return p->name;\n        }\n    }\n# ifndef ALWAYS_RESOLVE_IDS\n    if (chrooted == 0)\n# endif\n    {\n        pwd = getgrgid(gid);\n    }\n    if ((p = malloc(sizeof *p)) == NULL) {\n        die_mem();\n    }\n    p->gid = gid;\n    if ((p->name = malloc((size_t) 11U)) == NULL) {\n        die_mem();\n    }\n    if (pwd != NULL) {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U, \"%-10.10s\",\n                             pwd->gr_name), (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    } else {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U, \"%-10d\", gid),\n                    (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n    p->next = group_head;\n    group_head = p;\n\n    return p->name;\n}\n#endif\n\nstatic void addfile(const char *name, const char *suffix)\n{\n    struct filename *p;\n    unsigned int l;\n\n    if (!name || !suffix) {\n        return;\n    }\n    if (matches >= max_ls_files) {\n        return;\n    }\n    matches++;\n    l = (unsigned int) (strlen(name) + strlen(suffix));\n    if (l > colwidth) {\n        colwidth = l;\n    }\n    if ((p = malloc(offsetof(struct filename, line) + l + 1U)) == NULL) {\n        return;\n    }\n    if (SNCHECK(snprintf(p->line, l + 1U, \"%s%s\", name, suffix), l + 1U)) {\n        _EXIT(EXIT_FAILURE);\n    }\n    if (tail != NULL) {\n        tail->down = p;\n    } else {\n        head = p;\n    }\n    tail = p;\n    filenames++;\n}\n\n/* listfile returns non-zero if the file is a directory */\nstatic int listfile(const PureFileInfo * const fi, const char *name)\n{\n    int rval = 0;\n    struct stat st;\n    struct tm *t;\n    char suffix[2] = { 0, 0 };\n    char m[PATH_MAX + 1U];\n    const char *format;\n\n    if (fi == NULL) {\n        if (lstat(name, &st) < 0) {\n            return 0;\n        }\n    } else {\n        st.st_size = fi->size;\n        st.st_mtime = fi->mtime;\n        st.st_mode = fi->mode;\n        st.st_nlink = fi->nlink;\n        st.st_uid = fi->uid;\n        st.st_gid = fi->gid;\n        name = FI_NAME(fi);\n    }\n#if defined(WITH_VIRTUAL_CHROOT) && defined(S_IFLNK) && defined(S_IFDIR)\n    if (S_ISLNK(st.st_mode) && name[0] == '.' &&\n        name[1] == '.' && name[2] == 0) {\n        st.st_mode &= ~S_IFLNK;\n        st.st_mode |= S_IFDIR;\n    }  /* Hack to please some Windows clients that dislike ../ -> ../ */\n#endif\n#if !defined(MINIMAL) && !defined(ALWAYS_SHOW_SYMLINKS_AS_SYMLINKS)\n    if (\n# ifndef ALWAYS_SHOW_RESOLVED_SYMLINKS\n        broken_client_compat != 0 &&\n# endif\n        S_ISLNK(st.st_mode)) {\n        struct stat sts;\n\n        if (stat(name, &sts) == 0 && !S_ISLNK(sts.st_mode)) {\n            st = sts;\n        }\n    } /* Show non-dangling symlinks as files/directories */\n#endif\n#ifdef DISPLAY_FILES_IN_UTC_TIME\n    t = gmtime((time_t *) &st.st_mtime);\n#else\n    t = localtime((time_t *) &st.st_mtime);\n#endif\n    if (t == NULL) {\n        logfile(LOG_ERR, \"{gm,local}gtime() for [%s]\", name);\n        return 0;\n    }\n    if (opt_F) {\n        if (S_ISLNK(st.st_mode))\n            suffix[0] = '@';\n        else if (S_ISDIR(st.st_mode)) {\n            suffix[0] = '/';\n            rval = 1;\n        } else if (st.st_mode & 010101) {\n            suffix[0] = '*';\n        }\n    }\n    if (opt_l) {\n        strncpy(m, \" ---------\", (sizeof m) - (size_t) 1U);\n        m[(sizeof m) - (size_t) 1U] = 0;\n        switch (st.st_mode & S_IFMT) {\n        case S_IFREG:\n            m[0] = '-';\n            break;\n        case S_IFLNK:\n            m[0] = 'l';\n            break;            /* readlink() here? */\n        case S_IFDIR:\n            m[0] = 'd';\n            rval = 1;\n            break;\n        }\n        if (m[0] != ' ') {\n            char *alloca_nameline;\n            const size_t sizeof_nameline = PATH_MAX + PATH_MAX + 128U;\n            char timeline[6U];\n\n            if (st.st_mode & 0400) {\n                m[1] = 'r';\n            }\n            if (st.st_mode & 0200) {\n                m[2] = 'w';\n            }\n            if (st.st_mode & 0100) {\n                m[3] = (char) (st.st_mode & 04000 ? 's' : 'x');\n            } else if (st.st_mode & 04000) {\n                m[3] = 'S';\n            }\n            if (st.st_mode & 040) {\n                m[4] = 'r';\n            }\n            if (st.st_mode & 020) {\n                m[5] = 'w';\n            }\n            if (st.st_mode & 010) {\n                m[6] = (char) (st.st_mode & 02000 ? 's' : 'x');\n            } else if (st.st_mode & 02000) {\n                m[6] = 'S';\n            }\n            if (st.st_mode & 04) {\n                m[7] = 'r';\n            }\n            if (st.st_mode & 02) {\n                m[8] = 'w';\n            }\n            if (st.st_mode & 01) {\n                m[9] = (char) (st.st_mode & 01000 ? 't' : 'x');\n            } else if (st.st_mode & 01000) {\n                m[9] = 'T';\n            }\n            if (time(NULL) - st.st_mtime > 180 * 24 * 60 * 60) {\n                if (SNCHECK(snprintf(timeline, sizeof timeline, \"%5d\",\n                                     t->tm_year + 1900), sizeof timeline)) {\n                    _EXIT(EXIT_FAILURE);\n                }\n            } else {\n                if (SNCHECK(snprintf(timeline, sizeof timeline, \"%02d:%02d\",\n                                     t->tm_hour, t->tm_min), sizeof timeline)) {\n                    _EXIT(EXIT_FAILURE);\n                }\n            }\n            if ((alloca_nameline = ALLOCA(sizeof_nameline)) == NULL) {\n                return 0;\n            }\n            if (st.st_size < 10000000000U) {\n                format = \"%s %4u %s %s %10llu %s %2d %s %s\";\n            } else {\n                format = \"%s %4u %s %s %18llu %s %2d %s %s\";\n            }\n            if (SNCHECK(snprintf(alloca_nameline, sizeof_nameline,\n                                 format,\n                                 m, (unsigned int) st.st_nlink,\n                                 getname(st.st_uid),\n                                 getgroup(st.st_gid),\n                                 (unsigned long long) st.st_size,\n                                 months[t->tm_mon],\n                                 t->tm_mday, timeline, name),\n                        sizeof_nameline)) {\n                ALLOCA_FREE(alloca_nameline);\n                _EXIT(EXIT_FAILURE);\n            }\n            if (S_ISLNK(st.st_mode)) {\n                char *p = alloca_nameline + strlen(alloca_nameline);\n                {\n                    ssize_t sx;\n\n                    if ((sx = readlink(name, m, sizeof m - 1U)) > 0) {\n                        m[sx] = 0;\n                    } else {\n                        m[0] = m[1] = '.';\n                        m[2] = 0;\n                    }\n                }\n                suffix[0] = 0;\n                if (opt_F && stat(name, &st) == 0) {\n                    if (S_ISLNK(st.st_mode)) {\n                        suffix[0] = '@';\n                    } else if (S_ISDIR(st.st_mode)) {\n                        suffix[0] = '/';\n                    } else if (st.st_mode & 010101) {\n                        suffix[0] = '*';\n                    }\n                }\n                /* 2 * PATH_MAX + gap should be enough, but be paranoid... */\n                if (SNCHECK\n                    (snprintf(p, (sizeof_nameline) - strlen(alloca_nameline),\n                              \" -> %s\", m),\n                     (sizeof_nameline) - strlen(alloca_nameline))) {\n                    ALLOCA_FREE(alloca_nameline);\n                    _EXIT(EXIT_FAILURE);\n                }\n            }\n            addfile(alloca_nameline, suffix);\n            ALLOCA_FREE(alloca_nameline);\n        }                    /* hide non-downloadable files */\n    } else {\n        if (S_ISREG(st.st_mode) ||\n            S_ISDIR(st.st_mode) || S_ISLNK(st.st_mode)) {\n            addfile(name, suffix);\n        }\n    }\n    return rval;\n}\n\nstatic void outputfiles(int f, void * const tls_fd)\n{\n    unsigned int n;\n    struct filename *p;\n    struct filename *q;\n\n    if (!head) {\n        return;\n    }\n    tail->down = NULL;\n    tail = NULL;\n    colwidth = (colwidth | 7U) + 1U;\n    if (opt_l != 0 || opt_C == 0) {\n        colwidth = 75U;\n    }\n    /* set up first column */\n    p = head;\n    p->top = 1;\n    if (colwidth > 75U) {\n        n = filenames;\n    } else {\n        n = (filenames + (75U / colwidth) - 1U) / (75U / colwidth);\n    }\n    while (n && p) {\n        p = p->down;\n        if (p != NULL) {\n            p->top = 0;\n        }\n        n--;\n    }\n\n    /* while there's a neighbour to the right, point at it */\n    q = head;\n    while (p) {\n        p->top = q->top;\n        q->right = p;\n        q = q->down;\n        p = p->down;\n    }\n\n    /* some are at the right end */\n    while (q) {\n        q->right = NULL;\n        q = q->down;\n    }\n\n    /* don't want wraparound, do we? */\n    p = head;\n    while (p && p->down && !p->down->top) {\n        p = p->down;\n    }\n    if (p && p->down) {\n        p->down = NULL;\n    }\n\n    /* print each line, which consists of each column */\n    p = head;\n    while (p) {\n        q = p;\n        p = p->down;\n        while (q) {\n            char pad[6];\n            char *tmp = (char *) q;\n\n            if (q->right) {\n                memset(pad, '\\t', sizeof pad - 1U);\n                pad[(sizeof pad) - 1] = 0;\n                pad[(colwidth + 7U - strlen(q->line)) / 8] = 0;\n            } else {\n                pad[0] = '\\r';\n                pad[1] = '\\n';\n                pad[2] = 0;\n            }\n            wrstr(f, tls_fd, q->line);\n            wrstr(f, tls_fd, pad);\n            q = q->right;\n            free(tmp);\n            tmp = NULL;\n        }\n    }\n\n    /* reset variables for next time */\n    head = tail = NULL;\n    colwidth = 0U;\n    filenames = 0U;\n}\n\n/* functions to to sort for qsort() */\nstatic int cmp(const void * const a, const void * const b)\n{\n    return strcmp(FI_NAME((const PureFileInfo *) a),\n                  FI_NAME((const PureFileInfo *) b));\n}\n\nstatic int cmp_r(const void * const a, const void * const b)\n{\n    return strcmp(FI_NAME((const PureFileInfo *) b),\n                  FI_NAME((const PureFileInfo *) a));\n}\n\nstatic int cmp_t(const void * const a, const void * const b)\n{\n    if (((const PureFileInfo *) a)->mtime < ((const PureFileInfo *) b)->mtime) {\n        return 1;\n    }\n    if (((const PureFileInfo *) a)->mtime > ((const PureFileInfo *) b)->mtime) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int cmp_rt(const void * const a, const void * const b)\n{\n    return cmp_t(b, a);\n}\n\nstatic int cmp_S(const void * const a, const void * const b)\n{\n    if (((const PureFileInfo *) a)->size < ((const PureFileInfo *) b)->size) {\n        return 1;\n    }\n    if (((const PureFileInfo *) a)->size > ((const PureFileInfo *) b)->size) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int cmp_rS(const void * const a, const void * const b)\n{\n    return cmp_S(b, a);\n}\n\nstatic PureFileInfo *sreaddir(char **names_pnt)\n{\n    struct stat st;\n    DIR *d;\n    struct dirent *de;\n    PureFileInfo *files_info;\n    PureFileInfo *file_info;\n    size_t files_info_size;\n    size_t files_info_counter = (size_t) 0U;\n    char *names;\n    size_t names_size;\n    size_t names_counter = (size_t) 0U;\n    size_t name_len;\n    int (*cmp_func)(const void * const, const void * const);\n\n    if ((d = opendir(\".\")) == NULL) {\n        return NULL;\n    }\n    names_size = CHUNK_SIZE;\n    if ((names = malloc(names_size)) == NULL) {\n        closedir(d);\n        return NULL;\n    }\n    files_info_size = CHUNK_SIZE / sizeof *files_info;\n    if ((files_info = malloc(files_info_size * sizeof *files_info)) == NULL) {\n        closedir(d);\n        free(names);\n        return NULL;\n    }\n    while ((de = readdir(d)) != NULL) {\n        if (checkprintable(de->d_name) != 0 || lstat(de->d_name, &st) < 0) {\n            continue;\n        }\n        name_len = strlen(de->d_name) + (size_t) 1U;\n        while (names_counter + name_len >= names_size) {\n            char *new_names;\n\n            if (name_len >= CHUNK_SIZE) {\n                names_size += name_len + CHUNK_SIZE;\n            } else {\n                names_size += CHUNK_SIZE;\n            }\n            if ((new_names = realloc(names, names_size)) == NULL) {\n                nomem:\n                closedir(d);\n                free(names);\n                free(files_info);\n                return NULL;\n            }\n            names = new_names;\n        }\n        while ((files_info_counter + (size_t) 1U) >= files_info_size) {\n            PureFileInfo *new_files_info;\n\n            files_info_size += (CHUNK_SIZE / sizeof *files_info);\n            if ((new_files_info = realloc(files_info,\n                                          files_info_size * sizeof *files_info)) == NULL) {\n                goto nomem;\n            }\n            files_info = new_files_info;\n        }\n        memcpy(&names[names_counter], de->d_name, name_len);   /* safe */\n        names[names_counter + name_len - 1] = 0;\n        file_info = &files_info[files_info_counter];\n        file_info->names_pnt = names_pnt;\n        file_info->name_offset = names_counter;\n        file_info->size = st.st_size;\n        file_info->mtime = st.st_mtime;\n        file_info->mode = st.st_mode;\n        file_info->nlink = st.st_nlink;\n        file_info->uid = st.st_uid;\n        file_info->gid = st.st_gid;\n        names_counter += name_len;\n        files_info_counter++;\n    }\n    closedir(d);\n    files_info[files_info_counter].name_offset = (size_t) -1;\n    *names_pnt = names;\n\n    if (opt_t) {\n        if (opt_r) {\n            cmp_func = cmp_rt;\n        } else {\n            cmp_func = cmp_t;\n        }\n    } else if (opt_S) {\n        if (opt_r) {\n            cmp_func = cmp_rS;\n        } else {\n            cmp_func = cmp_S;\n        }\n    } else if (opt_r) {\n        cmp_func = cmp_r;\n    } else {\n        cmp_func = cmp;\n    }\n    qsort(files_info, files_info_counter, sizeof files_info[0], cmp_func);\n\n    return files_info;\n}\n\n/* have to change to the directory first (speed hack for -R) */\nstatic void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    int d;\n\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            char *alloca_subdir;\n            const size_t sizeof_subdir = PATH_MAX + 1U;\n\n            if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n                goto toomany;\n            }\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n            nolist:\n            ALLOCA_FREE(alloca_subdir);\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    /* defensive in the extreme... */\n                if (chdir(wd) || chdir(name)) {    /* someone rmdir()'d it? */\n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    free(names);\n    free(dir);\n    names = NULL;\n}\n\nstatic char *unescape_and_return_next_file(char * const str) {\n    char *pnt = str;\n    signed char seen_backslash = 0;\n\n    while (*pnt != 0) {\n        if (seen_backslash == 0) {\n            if (*pnt == '\\\\') {\n                seen_backslash = 1;\n            } else if (*pnt == ' ') {\n                *pnt++ = 0;\n                if (*pnt != 0) {\n                    return pnt;\n                }\n                break;\n            }\n            pnt++;\n        } else {\n            seen_backslash = 0;\n            if (*pnt == ' ' || *pnt == '\\\\' || *pnt == '{' || *pnt == '}') {\n                memmove(pnt - 1, pnt, strlen(pnt) + (size_t) 1U);\n            }\n        }\n    }\n    return NULL;\n}\n\nvoid dolist(char *arg, const int on_ctrl_conn)\n{\n    int c;\n    void *tls_fd = NULL;\n\n    matches = 0U;\n\n    opt_a = opt_C = opt_d = opt_F = opt_R = opt_r = opt_t = opt_S = 0;\n    opt_l = 1;\n    if (force_ls_a != 0) {\n        opt_a = 1;\n    }\n    if (arg != NULL) {\n        while (isspace((unsigned char) *arg)) {\n            arg++;\n        }\n        while (*arg == '-') {\n            while (arg++ && isalnum((unsigned char) *arg)) {\n                switch (*arg) {\n                case 'a':\n                    opt_a = 1;\n                    break;\n                case 'l':\n                    opt_l = 1;\n                    opt_C = 0;\n                    break;\n                case '1':\n                    opt_l = opt_C = 0;\n                    break;\n                case 'C':\n                    opt_l = 0;\n                    opt_C = 1;\n                    break;\n                case 'F':\n                    opt_F = 1;\n                    break;\n                case 'R':\n                    opt_R = 1;\n                    break;\n                case 'd':\n                    opt_d = 1;\n                    break;\n                case 'r':\n                    opt_r = 1;\n                    break;\n                case 't':\n                    opt_t = 1;\n                    opt_S = 0;\n                    break;\n                case 'S':\n                    opt_S = 1;\n                    opt_t = 0;\n                    break;\n                }\n            }\n            while (isspace((unsigned char) *arg)) {\n                arg++;\n            }\n        }\n    }\n    if (on_ctrl_conn == 0) {\n        opendata();\n        if ((c = xferfd) == -1) {\n            return;\n        }\n        doreply();\n#ifdef WITH_TLS\n        if (data_protection_level == CPL_PRIVATE) {\n            tls_init_data_session(xferfd, passive);\n            tls_fd = tls_data_cnx;\n        }\n#endif\n    } else {                           /* STAT command */\n        c = clientfd;\n#ifdef WITH_TLS\n        if (tls_cnx != NULL) {\n            secure_safe_write(tls_cnx, \"213-STAT\" CRLF,\n                              sizeof \"213-STAT\" CRLF - 1U);\n            tls_fd = tls_cnx;\n        }\n        else\n#endif\n        {\n            safe_write(c, \"213-STAT\" CRLF, sizeof \"213-STAT\" CRLF - 1U, -1);\n        }\n    }\n    if (arg != NULL && *arg != 0) {\n        int justone;\n\n        justone = 1;            /* just one argument, so don't print dir name */\n\n        do {\n            glob_t g;\n            int a;\n            char *endarg;\n\n            if ((endarg = unescape_and_return_next_file(arg)) != NULL) {\n                justone = 0;\n            }\n\n            /* Expand ~ here if needed */\n\n            alarm(GLOB_TIMEOUT);\n            memset(&g, 0, sizeof g);\n            a = sglob(arg,\n                      opt_a ? (GLOB_PERIOD | GLOB_LIMIT) : GLOB_LIMIT,\n                      NULL, &g, max_ls_files + 2, max_ls_depth * 2);\n            alarm(0);\n            if (a == 0) {\n                char **path;\n\n                if (g.gl_pathc <= 0) {\n                    path = NULL;\n                } else {\n                    path = g.gl_pathv;\n                }\n                if (path != NULL && path[0] != NULL && path[1] != NULL) {\n                    justone = 0;\n                }\n                while (path != NULL && *path != NULL) {\n                    struct stat st;\n\n                    if (stat(*path, &st) == 0) {\n                        if (opt_d || !(S_ISDIR(st.st_mode))) {\n                            listfile(NULL, *path);\n                            **path = 0;\n                        }\n                    } else {\n                        **path = 0;\n                    }\n                    path++;\n                }\n                outputfiles(c, tls_fd);    /* in case of opt_C */\n                path = g.gl_pathv;\n                while (path != NULL && *path != NULL) {\n                    if (matches >= max_ls_files) {\n                        break;\n                    }\n                    if (**path != 0) {\n                        if (!justone) {\n                            wrstr(c, tls_fd, \"\\r\\n\\r\\n\");\n                            wrstr(c, tls_fd, *path);\n                            wrstr(c, tls_fd, \":\\r\\n\\r\\n\");\n                        }\n                        if (!chdir(*path)) {\n                            listdir(0U, c, tls_fd, *path);\n                            if (chdir(wd)) {\n                                die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                            }\n                        }\n                    }\n                    path++;\n                }\n            } else {\n                if (a == GLOB_NOSPACE) {\n                    addreply(226, MSG_GLOB_NO_MEMORY, arg);\n                    addreply_noformat(0, MSG_PROBABLY_DENIED);\n                } else if (a == GLOB_ABEND) {\n                    addreply(226, MSG_GLOB_READ_ERROR, arg);\n                } else if (a != GLOB_NOMATCH) {\n                    addreply(226, MSG_GLOB_READ_ERROR, arg);\n                    addreply_noformat(0, MSG_PROBABLY_DENIED);\n                }\n            }\n            globfree(&g);\n            arg = endarg;\n        } while (arg != NULL);\n    } else {\n        if (opt_d) {\n            listfile(NULL, \".\");\n        } else {\n            listdir(0U, c, tls_fd, \".\");\n        }\n        outputfiles(c, tls_fd);\n    }\n    wrstr(c, tls_fd, NULL);\n    if (on_ctrl_conn == 0) {\n#ifdef WITH_TLS\n        closedata();\n#endif\n        close(c);\n    } else {\n        addreply_noformat(213, \"End.\");\n        goto end;\n    }\n    if (opt_a || opt_C || opt_d || opt_F || opt_l || opt_r || opt_R ||\n        opt_t || opt_S)\n        addreply(0, \"Options: %s%s%s%s%s%s%s%s%s\",\n                 opt_a ? \"-a \" : \"\",\n                 opt_C ? \"-C \" : \"\",\n                 opt_d ? \"-d \" : \"\",\n                 opt_F ? \"-F \" : \"\",\n                 opt_l ? \"-l \" : \"\",\n                 opt_r ? \"-r \" : \"\",\n                 opt_R ? \"-R \" : \"\", opt_S ? \"-S \" : \"\",\n                 opt_t ? \"-t\" : \"\");\n    if (matches >= max_ls_files) {\n        addreply(226, MSG_LS_TRUNCATED, matches);\n    } else {\n        addreply(226, MSG_LS_SUCCESS, matches);\n    }\nend:\n    if (chdir(wd)) {\n        die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n    }\n}\n\nvoid donlst(const char *base)\n{\n    char           line[PATH_MAX + 3U];\n    DIR           *dir;\n    void          *tls_fd = NULL;\n    struct dirent *de;\n    size_t         name_len;\n    unsigned int   matches = 0;\n    int            c;\n    int            base_has_trailing_slash = 0;\n\n    if (*base != 0 && chdir(base) != 0) {\n        if (*base++ == '-') {\n            while (!isspace((unsigned char) *base++));\n            while (isspace((unsigned char) *base++));\n            if (*base != 0 && chdir(base) != 0) {\n                addreply_noformat(550, MSG_STAT_FAILURE2);\n                return;\n            }\n        } else {\n            addreply_noformat(550, MSG_STAT_FAILURE2);\n            return;\n        }\n    }\n    if (*base !=0 && base[strlen(base) - 1U] == '/') {\n        base_has_trailing_slash = 1;\n    }\n    if ((dir = opendir(\".\")) == NULL) {\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n        goto bye;\n    }\n    opendata();\n    if ((c = xferfd) == -1) {\n        goto bye;\n    }\n    doreply();\n#ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n        tls_fd = tls_data_cnx;\n    }\n#endif\n    while ((de = readdir(dir)) != NULL) {\n        if (checkprintable(de->d_name) != 0) {\n            continue;\n        }\n        name_len = strlen(de->d_name);\n        if (name_len > sizeof line - 3U) {\n            continue;\n        }\n        memcpy(line, de->d_name, name_len);\n        line[name_len] = '\\r';\n        line[name_len + 1] = '\\n';\n        line[name_len + 2] = 0;\n        if (*base) {\n            wrstr(c, tls_fd, base);\n            if (base_has_trailing_slash == 0) {\n                wrstr(c, tls_fd, \"/\");\n            }\n        }\n        wrstr(c, tls_fd, line);\n        matches++;\n        if (matches >= max_ls_files) {\n            break;\n        }\n    }\n    closedir(dir);\n    wrstr(c, tls_fd, NULL);\n    closedata();\n    if (matches >= max_ls_files) {\n        addreply(226, MSG_LS_TRUNCATED, matches);\n    } else {\n        addreply(226, MSG_LS_SUCCESS, matches);\n    }\nbye:\n    if (chdir(wd) != 0) {\n        die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n    }\n}\n\nvoid domlsd(const char *base)\n{\n    char           line[PATH_MAX + 1];\n    DIR           *dir = NULL;\n    void          *tls_fd = NULL;\n    struct dirent *de;\n    unsigned int   matches = 0;\n    int            c;\n\n    if (*base != 0 && chdir(base) != 0) {\n        if (*base++ == '-') {\n            while (!isspace((unsigned char) *base++));\n            while (isspace((unsigned char) *base++));\n            if (*base != 0 && chdir(base) != 0) {\n                addreply_noformat(550, MSG_STAT_FAILURE2);\n                return;\n            }\n        } else {\n            addreply_noformat(550, MSG_STAT_FAILURE2);\n            return;\n        }\n    }\n    if ((dir = opendir(\".\")) == NULL) {\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n        goto bye;\n    }\n    opendata();\n    if ((c = xferfd) == -1) {\n        goto bye;\n    }\n    doreply();\n#ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n        tls_fd = tls_data_cnx;\n    }\n#endif\n    while ((de = readdir(dir)) != NULL) {\n        if (checkprintable(de->d_name) != 0 ||\n            modernformat(de->d_name, line, sizeof line, \"\") < 0) {\n            continue;\n        }\n        wrstr(c, tls_fd, line);\n        wrstr(c, tls_fd, \"\\r\\n\");\n        matches++;\n        if (matches >= max_ls_files) {\n            break;\n        }\n    }\n    wrstr(c, tls_fd, NULL);\n    closedata();\n    if (matches >= max_ls_files) {\n        addreply(226, MSG_LS_TRUNCATED, matches);\n    } else {\n        addreply(226, MSG_LS_SUCCESS, matches);\n    }\nbye:\n    if (dir != NULL) {\n        closedir(dir);\n    }\n    if (chdir(wd) != 0) {\n        die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n    }\n}\n"], "fixing_code": ["#include <config.h>\n\n#include \"ftpd.h\"\n#include \"ls_p.h\"\n#include \"bsd-glob.h\"\n#include \"messages.h\"\n#include \"dynamic.h\"\n#include \"ftpwho-update.h\"\n#include \"globals.h\"\n#include \"safe_rw.h\"\n#ifdef WITH_TLS\n# include \"tls.h\"\n#endif\n\n#ifdef WITH_DMALLOC\n# include <dmalloc.h>\n#endif\n\nstatic void wrstr(const int f, void * const tls_fd, const char *s)\n{\n    static char outbuf[CONF_TCP_SO_SNDBUF];\n    static size_t outcnt;\n    size_t l;\n\n    if (s == NULL) {\n        if (outcnt > (size_t) 0U) {\n#ifdef WITH_TLS\n            if (tls_fd != NULL) {\n                if (secure_safe_write(tls_fd, outbuf, outcnt) !=\n                    (ssize_t) outcnt) {\n                    return;\n                }\n            } else\n#endif\n            {\n                (void) tls_fd;\n                if (safe_write(f, outbuf, outcnt, -1) != (ssize_t) outcnt) {\n                    return;\n                }\n            }\n        }\n        outcnt = (size_t) 0U;\n        return;\n    }\n    if ((l = strlen(s)) <= (size_t) 0U) {\n        return;\n    }\n    if (l <= (sizeof outbuf - outcnt)) {\n        memcpy(outbuf + outcnt, s, l); /* secure, see above */\n        outcnt += l;\n        return;\n    }\n    if (outcnt < sizeof outbuf) {\n        const size_t rest = sizeof outbuf - outcnt;\n\n        memcpy(outbuf + outcnt, s, rest);   /* secure, see above */\n        s += rest;\n        l -= rest;\n    }\n#ifdef WITH_TLS\n    if (tls_fd != NULL) {\n        if (secure_safe_write(tls_fd, outbuf, sizeof outbuf) !=\n            (ssize_t) sizeof outbuf) {\n            return;\n        }\n    } else\n#endif\n    {\n        if (safe_write(f, outbuf, sizeof outbuf, -1) !=\n            (ssize_t) sizeof outbuf) {\n            return;\n        }\n    }\n#ifdef WITH_TLS\n    if (tls_fd != NULL) {\n        while (l > sizeof outbuf) {\n            if (secure_safe_write(tls_fd, s, sizeof outbuf) !=\n                (ssize_t) sizeof outbuf) {\n                return;\n            }\n            s += sizeof outbuf;\n            l -= sizeof outbuf;\n        }\n    } else\n#endif\n    {\n        while (l > sizeof outbuf) {\n            if (safe_write(f, s, sizeof outbuf, -1) !=\n                (ssize_t) sizeof outbuf) {\n                return;\n            }\n            s += sizeof outbuf;\n            l -= sizeof outbuf;\n        }\n    }\n    if (l > (size_t) 0U) {\n        memcpy(outbuf, s, l);          /* safe, l <= sizeof outbuf */\n        outcnt = l;\n    }\n}\n\n#ifdef NO_FTP_USERS\nconst char *getname(const uid_t uid)\n{\n    static char number[11];\n\n    snprintf(number, sizeof number, \"%-10d\", uid);\n    return number;\n}\n\nconst char *getgroup(const gid_t gid)\n{\n    static char number[11];\n\n    snprintf(number, sizeof number, \"%-10d\", gid);\n    return number;\n}\n#else\n\nconst char *getname(const uid_t uid)\n{\n    struct userid *p;\n    struct passwd *pwd = NULL;\n\n    for (p = user_head; p; p = p->next) {\n        if (p->uid == uid) {\n            return p->name;\n        }\n    }\n    if (\n# ifndef ALWAYS_RESOLVE_IDS\n        chrooted == 0 &&\n# endif\n        authresult.slow_tilde_expansion == 0) {\n        pwd = getpwuid(uid);\n    }\n    if ((p = malloc(sizeof *p)) == NULL) {\n        die_mem();\n    }\n    p->uid = uid;\n    if ((p->name = malloc((size_t) 11U)) == NULL) {\n        die_mem();\n    }\n    if (pwd != NULL) {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U,\n                             \"%-10.10s\", pwd->pw_name), (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    } else {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U, \"%-10d\", uid),\n                    (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n    p->next = user_head;\n    user_head = p;\n\n    return p->name;\n}\n\n/* eeeehm... sorry for names, ya know copy&paste :))) */\nconst char *getgroup(const gid_t gid)\n{\n    struct groupid *p;\n    struct group *pwd = NULL;\n\n    for (p = group_head; p; p = p->next) {\n        if (p->gid == gid) {\n            return p->name;\n        }\n    }\n# ifndef ALWAYS_RESOLVE_IDS\n    if (chrooted == 0)\n# endif\n    {\n        pwd = getgrgid(gid);\n    }\n    if ((p = malloc(sizeof *p)) == NULL) {\n        die_mem();\n    }\n    p->gid = gid;\n    if ((p->name = malloc((size_t) 11U)) == NULL) {\n        die_mem();\n    }\n    if (pwd != NULL) {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U, \"%-10.10s\",\n                             pwd->gr_name), (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    } else {\n        if (SNCHECK(snprintf(p->name, (size_t) 11U, \"%-10d\", gid),\n                    (size_t) 11U)) {\n            _EXIT(EXIT_FAILURE);\n        }\n    }\n    p->next = group_head;\n    group_head = p;\n\n    return p->name;\n}\n#endif\n\nstatic void addfile(const char *name, const char *suffix)\n{\n    struct filename *p;\n    unsigned int l;\n\n    if (!name || !suffix) {\n        return;\n    }\n    if (matches >= max_ls_files) {\n        return;\n    }\n    matches++;\n    l = (unsigned int) (strlen(name) + strlen(suffix));\n    if (l > colwidth) {\n        colwidth = l;\n    }\n    if ((p = malloc(offsetof(struct filename, line) + l + 1U)) == NULL) {\n        return;\n    }\n    if (SNCHECK(snprintf(p->line, l + 1U, \"%s%s\", name, suffix), l + 1U)) {\n        _EXIT(EXIT_FAILURE);\n    }\n    if (tail != NULL) {\n        tail->down = p;\n    } else {\n        head = p;\n    }\n    tail = p;\n    filenames++;\n}\n\n/* listfile returns non-zero if the file is a directory */\nstatic int listfile(const PureFileInfo * const fi, const char *name)\n{\n    int rval = 0;\n    struct stat st;\n    struct tm *t;\n    char suffix[2] = { 0, 0 };\n    char m[PATH_MAX + 1U];\n    const char *format;\n\n    if (fi == NULL) {\n        if (lstat(name, &st) < 0) {\n            return 0;\n        }\n    } else {\n        st.st_size = fi->size;\n        st.st_mtime = fi->mtime;\n        st.st_mode = fi->mode;\n        st.st_nlink = fi->nlink;\n        st.st_uid = fi->uid;\n        st.st_gid = fi->gid;\n        name = FI_NAME(fi);\n    }\n#if defined(WITH_VIRTUAL_CHROOT) && defined(S_IFLNK) && defined(S_IFDIR)\n    if (S_ISLNK(st.st_mode) && name[0] == '.' &&\n        name[1] == '.' && name[2] == 0) {\n        st.st_mode &= ~S_IFLNK;\n        st.st_mode |= S_IFDIR;\n    }  /* Hack to please some Windows clients that dislike ../ -> ../ */\n#endif\n#if !defined(MINIMAL) && !defined(ALWAYS_SHOW_SYMLINKS_AS_SYMLINKS)\n    if (\n# ifndef ALWAYS_SHOW_RESOLVED_SYMLINKS\n        broken_client_compat != 0 &&\n# endif\n        S_ISLNK(st.st_mode)) {\n        struct stat sts;\n\n        if (stat(name, &sts) == 0 && !S_ISLNK(sts.st_mode)) {\n            st = sts;\n        }\n    } /* Show non-dangling symlinks as files/directories */\n#endif\n#ifdef DISPLAY_FILES_IN_UTC_TIME\n    t = gmtime((time_t *) &st.st_mtime);\n#else\n    t = localtime((time_t *) &st.st_mtime);\n#endif\n    if (t == NULL) {\n        logfile(LOG_ERR, \"{gm,local}gtime() for [%s]\", name);\n        return 0;\n    }\n    if (opt_F) {\n        if (S_ISLNK(st.st_mode))\n            suffix[0] = '@';\n        else if (S_ISDIR(st.st_mode)) {\n            suffix[0] = '/';\n            rval = 1;\n        } else if (st.st_mode & 010101) {\n            suffix[0] = '*';\n        }\n    }\n    if (opt_l) {\n        strncpy(m, \" ---------\", (sizeof m) - (size_t) 1U);\n        m[(sizeof m) - (size_t) 1U] = 0;\n        switch (st.st_mode & S_IFMT) {\n        case S_IFREG:\n            m[0] = '-';\n            break;\n        case S_IFLNK:\n            m[0] = 'l';\n            break;            /* readlink() here? */\n        case S_IFDIR:\n            m[0] = 'd';\n            rval = 1;\n            break;\n        }\n        if (m[0] != ' ') {\n            char *alloca_nameline;\n            const size_t sizeof_nameline = PATH_MAX + PATH_MAX + 128U;\n            char timeline[6U];\n\n            if (st.st_mode & 0400) {\n                m[1] = 'r';\n            }\n            if (st.st_mode & 0200) {\n                m[2] = 'w';\n            }\n            if (st.st_mode & 0100) {\n                m[3] = (char) (st.st_mode & 04000 ? 's' : 'x');\n            } else if (st.st_mode & 04000) {\n                m[3] = 'S';\n            }\n            if (st.st_mode & 040) {\n                m[4] = 'r';\n            }\n            if (st.st_mode & 020) {\n                m[5] = 'w';\n            }\n            if (st.st_mode & 010) {\n                m[6] = (char) (st.st_mode & 02000 ? 's' : 'x');\n            } else if (st.st_mode & 02000) {\n                m[6] = 'S';\n            }\n            if (st.st_mode & 04) {\n                m[7] = 'r';\n            }\n            if (st.st_mode & 02) {\n                m[8] = 'w';\n            }\n            if (st.st_mode & 01) {\n                m[9] = (char) (st.st_mode & 01000 ? 't' : 'x');\n            } else if (st.st_mode & 01000) {\n                m[9] = 'T';\n            }\n            if (time(NULL) - st.st_mtime > 180 * 24 * 60 * 60) {\n                if (SNCHECK(snprintf(timeline, sizeof timeline, \"%5d\",\n                                     t->tm_year + 1900), sizeof timeline)) {\n                    _EXIT(EXIT_FAILURE);\n                }\n            } else {\n                if (SNCHECK(snprintf(timeline, sizeof timeline, \"%02d:%02d\",\n                                     t->tm_hour, t->tm_min), sizeof timeline)) {\n                    _EXIT(EXIT_FAILURE);\n                }\n            }\n            if ((alloca_nameline = ALLOCA(sizeof_nameline)) == NULL) {\n                return 0;\n            }\n            if (st.st_size < 10000000000U) {\n                format = \"%s %4u %s %s %10llu %s %2d %s %s\";\n            } else {\n                format = \"%s %4u %s %s %18llu %s %2d %s %s\";\n            }\n            if (SNCHECK(snprintf(alloca_nameline, sizeof_nameline,\n                                 format,\n                                 m, (unsigned int) st.st_nlink,\n                                 getname(st.st_uid),\n                                 getgroup(st.st_gid),\n                                 (unsigned long long) st.st_size,\n                                 months[t->tm_mon],\n                                 t->tm_mday, timeline, name),\n                        sizeof_nameline)) {\n                ALLOCA_FREE(alloca_nameline);\n                _EXIT(EXIT_FAILURE);\n            }\n            if (S_ISLNK(st.st_mode)) {\n                char *p = alloca_nameline + strlen(alloca_nameline);\n                {\n                    ssize_t sx;\n\n                    if ((sx = readlink(name, m, sizeof m - 1U)) > 0) {\n                        m[sx] = 0;\n                    } else {\n                        m[0] = m[1] = '.';\n                        m[2] = 0;\n                    }\n                }\n                suffix[0] = 0;\n                if (opt_F && stat(name, &st) == 0) {\n                    if (S_ISLNK(st.st_mode)) {\n                        suffix[0] = '@';\n                    } else if (S_ISDIR(st.st_mode)) {\n                        suffix[0] = '/';\n                    } else if (st.st_mode & 010101) {\n                        suffix[0] = '*';\n                    }\n                }\n                /* 2 * PATH_MAX + gap should be enough, but be paranoid... */\n                if (SNCHECK\n                    (snprintf(p, (sizeof_nameline) - strlen(alloca_nameline),\n                              \" -> %s\", m),\n                     (sizeof_nameline) - strlen(alloca_nameline))) {\n                    ALLOCA_FREE(alloca_nameline);\n                    _EXIT(EXIT_FAILURE);\n                }\n            }\n            addfile(alloca_nameline, suffix);\n            ALLOCA_FREE(alloca_nameline);\n        }                    /* hide non-downloadable files */\n    } else {\n        if (S_ISREG(st.st_mode) ||\n            S_ISDIR(st.st_mode) || S_ISLNK(st.st_mode)) {\n            addfile(name, suffix);\n        }\n    }\n    return rval;\n}\n\nstatic void outputfiles(int f, void * const tls_fd)\n{\n    unsigned int n;\n    struct filename *p;\n    struct filename *q;\n\n    if (!head) {\n        return;\n    }\n    tail->down = NULL;\n    tail = NULL;\n    colwidth = (colwidth | 7U) + 1U;\n    if (opt_l != 0 || opt_C == 0) {\n        colwidth = 75U;\n    }\n    /* set up first column */\n    p = head;\n    p->top = 1;\n    if (colwidth > 75U) {\n        n = filenames;\n    } else {\n        n = (filenames + (75U / colwidth) - 1U) / (75U / colwidth);\n    }\n    while (n && p) {\n        p = p->down;\n        if (p != NULL) {\n            p->top = 0;\n        }\n        n--;\n    }\n\n    /* while there's a neighbour to the right, point at it */\n    q = head;\n    while (p) {\n        p->top = q->top;\n        q->right = p;\n        q = q->down;\n        p = p->down;\n    }\n\n    /* some are at the right end */\n    while (q) {\n        q->right = NULL;\n        q = q->down;\n    }\n\n    /* don't want wraparound, do we? */\n    p = head;\n    while (p && p->down && !p->down->top) {\n        p = p->down;\n    }\n    if (p && p->down) {\n        p->down = NULL;\n    }\n\n    /* print each line, which consists of each column */\n    p = head;\n    while (p) {\n        q = p;\n        p = p->down;\n        while (q) {\n            char pad[6];\n            char *tmp = (char *) q;\n\n            if (q->right) {\n                memset(pad, '\\t', sizeof pad - 1U);\n                pad[(sizeof pad) - 1] = 0;\n                pad[(colwidth + 7U - strlen(q->line)) / 8] = 0;\n            } else {\n                pad[0] = '\\r';\n                pad[1] = '\\n';\n                pad[2] = 0;\n            }\n            wrstr(f, tls_fd, q->line);\n            wrstr(f, tls_fd, pad);\n            q = q->right;\n            free(tmp);\n            tmp = NULL;\n        }\n    }\n\n    /* reset variables for next time */\n    head = tail = NULL;\n    colwidth = 0U;\n    filenames = 0U;\n}\n\n/* functions to to sort for qsort() */\nstatic int cmp(const void * const a, const void * const b)\n{\n    return strcmp(FI_NAME((const PureFileInfo *) a),\n                  FI_NAME((const PureFileInfo *) b));\n}\n\nstatic int cmp_r(const void * const a, const void * const b)\n{\n    return strcmp(FI_NAME((const PureFileInfo *) b),\n                  FI_NAME((const PureFileInfo *) a));\n}\n\nstatic int cmp_t(const void * const a, const void * const b)\n{\n    if (((const PureFileInfo *) a)->mtime < ((const PureFileInfo *) b)->mtime) {\n        return 1;\n    }\n    if (((const PureFileInfo *) a)->mtime > ((const PureFileInfo *) b)->mtime) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int cmp_rt(const void * const a, const void * const b)\n{\n    return cmp_t(b, a);\n}\n\nstatic int cmp_S(const void * const a, const void * const b)\n{\n    if (((const PureFileInfo *) a)->size < ((const PureFileInfo *) b)->size) {\n        return 1;\n    }\n    if (((const PureFileInfo *) a)->size > ((const PureFileInfo *) b)->size) {\n        return -1;\n    }\n    return 0;\n}\n\nstatic int cmp_rS(const void * const a, const void * const b)\n{\n    return cmp_S(b, a);\n}\n\nstatic PureFileInfo *sreaddir(char **names_pnt)\n{\n    struct stat st;\n    DIR *d;\n    struct dirent *de;\n    PureFileInfo *files_info;\n    PureFileInfo *file_info;\n    size_t files_info_size;\n    size_t files_info_counter = (size_t) 0U;\n    char *names;\n    size_t names_size;\n    size_t names_counter = (size_t) 0U;\n    size_t name_len;\n    int (*cmp_func)(const void * const, const void * const);\n\n    if ((d = opendir(\".\")) == NULL) {\n        return NULL;\n    }\n    names_size = CHUNK_SIZE;\n    if ((names = malloc(names_size)) == NULL) {\n        closedir(d);\n        return NULL;\n    }\n    files_info_size = CHUNK_SIZE / sizeof *files_info;\n    if ((files_info = malloc(files_info_size * sizeof *files_info)) == NULL) {\n        closedir(d);\n        free(names);\n        return NULL;\n    }\n    while ((de = readdir(d)) != NULL) {\n        if (checkprintable(de->d_name) != 0 || lstat(de->d_name, &st) < 0) {\n            continue;\n        }\n        name_len = strlen(de->d_name) + (size_t) 1U;\n        while (names_counter + name_len >= names_size) {\n            char *new_names;\n\n            if (name_len >= CHUNK_SIZE) {\n                names_size += name_len + CHUNK_SIZE;\n            } else {\n                names_size += CHUNK_SIZE;\n            }\n            if ((new_names = realloc(names, names_size)) == NULL) {\n                nomem:\n                closedir(d);\n                free(names);\n                free(files_info);\n                return NULL;\n            }\n            names = new_names;\n        }\n        while ((files_info_counter + (size_t) 1U) >= files_info_size) {\n            PureFileInfo *new_files_info;\n\n            files_info_size += (CHUNK_SIZE / sizeof *files_info);\n            if ((new_files_info = realloc(files_info,\n                                          files_info_size * sizeof *files_info)) == NULL) {\n                goto nomem;\n            }\n            files_info = new_files_info;\n        }\n        memcpy(&names[names_counter], de->d_name, name_len);   /* safe */\n        names[names_counter + name_len - 1] = 0;\n        file_info = &files_info[files_info_counter];\n        file_info->names_pnt = names_pnt;\n        file_info->name_offset = names_counter;\n        file_info->size = st.st_size;\n        file_info->mtime = st.st_mtime;\n        file_info->mode = st.st_mode;\n        file_info->nlink = st.st_nlink;\n        file_info->uid = st.st_uid;\n        file_info->gid = st.st_gid;\n        names_counter += name_len;\n        files_info_counter++;\n    }\n    closedir(d);\n    files_info[files_info_counter].name_offset = (size_t) -1;\n    *names_pnt = names;\n\n    if (opt_t) {\n        if (opt_r) {\n            cmp_func = cmp_rt;\n        } else {\n            cmp_func = cmp_t;\n        }\n    } else if (opt_S) {\n        if (opt_r) {\n            cmp_func = cmp_rS;\n        } else {\n            cmp_func = cmp_S;\n        }\n    } else if (opt_r) {\n        cmp_func = cmp_r;\n    } else {\n        cmp_func = cmp;\n    }\n    qsort(files_info, files_info_counter, sizeof files_info[0], cmp_func);\n\n    return files_info;\n}\n\n/* have to change to the directory first (speed hack for -R) */\nstatic void listdir(unsigned int depth, int f, void * const tls_fd,\n                    const char *name)\n{\n    PureFileInfo *dir;\n    char *names;\n    PureFileInfo *s;\n    PureFileInfo *r;\n    char *alloca_subdir;\n    size_t sizeof_subdir;\n    int d;\n\n    if (depth >= max_ls_depth || matches >= max_ls_files) {\n        return;\n    }\n    if ((dir = sreaddir(&names)) == NULL) {\n        addreply(226, MSG_CANT_READ_FILE, name);\n        return;\n    }\n    s = dir;\n    while (s->name_offset != (size_t) -1) {\n        d = 0;\n        if (FI_NAME(s)[0] != '.') {\n            d = listfile(s, NULL);\n        } else if (opt_a) {\n            if (FI_NAME(s)[1] == 0 ||\n                (FI_NAME(s)[1] == '.' && FI_NAME(s)[2] == 0)) {\n                listfile(s, NULL);\n            } else {\n                d = listfile(s, NULL);\n            }\n        }\n        if (!d) {\n            s->name_offset = (size_t) -1;\n        }\n        s++;\n    }\n    outputfiles(f, tls_fd);\n    r = dir;\n    sizeof_subdir = PATH_MAX + 1U;\n    if ((alloca_subdir = ALLOCA(sizeof_subdir)) == NULL) {\n        goto toomany;\n    }\n    while (opt_R && r != s) {\n        if (r->name_offset != (size_t) -1 && !chdir(FI_NAME(r))) {\n            if (SNCHECK(snprintf(alloca_subdir, sizeof_subdir, \"%s/%s\",\n                                 name, FI_NAME(r)), sizeof_subdir)) {\n                goto nolist;\n            }\n            wrstr(f, tls_fd, \"\\r\\n\\r\\n\");\n            wrstr(f, tls_fd, alloca_subdir);\n            wrstr(f, tls_fd, \":\\r\\n\\r\\n\");\n            listdir(depth + 1U, f, tls_fd, alloca_subdir);\n\n            nolist:\n            if (matches >= max_ls_files) {\n                goto toomany;\n            }\n            if (chdir(\"..\")) {    /* defensive in the extreme... */\n                if (chdir(wd) || chdir(name)) {    /* someone rmdir()'d it? */\n                    die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                }\n            }\n        }\n        r++;\n    }\n    toomany:\n    ALLOCA_FREE(alloca_subdir);\n    free(names);\n    free(dir);\n    names = NULL;\n}\n\nstatic char *unescape_and_return_next_file(char * const str) {\n    char *pnt = str;\n    signed char seen_backslash = 0;\n\n    while (*pnt != 0) {\n        if (seen_backslash == 0) {\n            if (*pnt == '\\\\') {\n                seen_backslash = 1;\n            } else if (*pnt == ' ') {\n                *pnt++ = 0;\n                if (*pnt != 0) {\n                    return pnt;\n                }\n                break;\n            }\n            pnt++;\n        } else {\n            seen_backslash = 0;\n            if (*pnt == ' ' || *pnt == '\\\\' || *pnt == '{' || *pnt == '}') {\n                memmove(pnt - 1, pnt, strlen(pnt) + (size_t) 1U);\n            }\n        }\n    }\n    return NULL;\n}\n\nvoid dolist(char *arg, const int on_ctrl_conn)\n{\n    int c;\n    void *tls_fd = NULL;\n\n    matches = 0U;\n\n    opt_a = opt_C = opt_d = opt_F = opt_R = opt_r = opt_t = opt_S = 0;\n    opt_l = 1;\n    if (force_ls_a != 0) {\n        opt_a = 1;\n    }\n    if (arg != NULL) {\n        while (isspace((unsigned char) *arg)) {\n            arg++;\n        }\n        while (*arg == '-') {\n            while (arg++ && isalnum((unsigned char) *arg)) {\n                switch (*arg) {\n                case 'a':\n                    opt_a = 1;\n                    break;\n                case 'l':\n                    opt_l = 1;\n                    opt_C = 0;\n                    break;\n                case '1':\n                    opt_l = opt_C = 0;\n                    break;\n                case 'C':\n                    opt_l = 0;\n                    opt_C = 1;\n                    break;\n                case 'F':\n                    opt_F = 1;\n                    break;\n                case 'R':\n                    opt_R = 1;\n                    break;\n                case 'd':\n                    opt_d = 1;\n                    break;\n                case 'r':\n                    opt_r = 1;\n                    break;\n                case 't':\n                    opt_t = 1;\n                    opt_S = 0;\n                    break;\n                case 'S':\n                    opt_S = 1;\n                    opt_t = 0;\n                    break;\n                }\n            }\n            while (isspace((unsigned char) *arg)) {\n                arg++;\n            }\n        }\n    }\n    if (on_ctrl_conn == 0) {\n        opendata();\n        if ((c = xferfd) == -1) {\n            return;\n        }\n        doreply();\n#ifdef WITH_TLS\n        if (data_protection_level == CPL_PRIVATE) {\n            tls_init_data_session(xferfd, passive);\n            tls_fd = tls_data_cnx;\n        }\n#endif\n    } else {                           /* STAT command */\n        c = clientfd;\n#ifdef WITH_TLS\n        if (tls_cnx != NULL) {\n            secure_safe_write(tls_cnx, \"213-STAT\" CRLF,\n                              sizeof \"213-STAT\" CRLF - 1U);\n            tls_fd = tls_cnx;\n        }\n        else\n#endif\n        {\n            safe_write(c, \"213-STAT\" CRLF, sizeof \"213-STAT\" CRLF - 1U, -1);\n        }\n    }\n    if (arg != NULL && *arg != 0) {\n        int justone;\n\n        justone = 1;            /* just one argument, so don't print dir name */\n\n        do {\n            glob_t g;\n            int a;\n            char *endarg;\n\n            if ((endarg = unescape_and_return_next_file(arg)) != NULL) {\n                justone = 0;\n            }\n\n            /* Expand ~ here if needed */\n\n            alarm(GLOB_TIMEOUT);\n            memset(&g, 0, sizeof g);\n            a = sglob(arg,\n                      opt_a ? (GLOB_PERIOD | GLOB_LIMIT) : GLOB_LIMIT,\n                      NULL, &g, max_ls_files + 2, max_ls_depth * 2);\n            alarm(0);\n            if (a == 0) {\n                char **path;\n\n                if (g.gl_pathc <= 0) {\n                    path = NULL;\n                } else {\n                    path = g.gl_pathv;\n                }\n                if (path != NULL && path[0] != NULL && path[1] != NULL) {\n                    justone = 0;\n                }\n                while (path != NULL && *path != NULL) {\n                    struct stat st;\n\n                    if (stat(*path, &st) == 0) {\n                        if (opt_d || !(S_ISDIR(st.st_mode))) {\n                            listfile(NULL, *path);\n                            **path = 0;\n                        }\n                    } else {\n                        **path = 0;\n                    }\n                    path++;\n                }\n                outputfiles(c, tls_fd);    /* in case of opt_C */\n                path = g.gl_pathv;\n                while (path != NULL && *path != NULL) {\n                    if (matches >= max_ls_files) {\n                        break;\n                    }\n                    if (**path != 0) {\n                        if (!justone) {\n                            wrstr(c, tls_fd, \"\\r\\n\\r\\n\");\n                            wrstr(c, tls_fd, *path);\n                            wrstr(c, tls_fd, \":\\r\\n\\r\\n\");\n                        }\n                        if (!chdir(*path)) {\n                            listdir(0U, c, tls_fd, *path);\n                            if (chdir(wd)) {\n                                die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n                            }\n                        }\n                    }\n                    path++;\n                }\n            } else {\n                if (a == GLOB_NOSPACE) {\n                    addreply(226, MSG_GLOB_NO_MEMORY, arg);\n                    addreply_noformat(0, MSG_PROBABLY_DENIED);\n                } else if (a == GLOB_ABEND) {\n                    addreply(226, MSG_GLOB_READ_ERROR, arg);\n                } else if (a != GLOB_NOMATCH) {\n                    addreply(226, MSG_GLOB_READ_ERROR, arg);\n                    addreply_noformat(0, MSG_PROBABLY_DENIED);\n                }\n            }\n            globfree(&g);\n            arg = endarg;\n        } while (arg != NULL);\n    } else {\n        if (opt_d) {\n            listfile(NULL, \".\");\n        } else {\n            listdir(0U, c, tls_fd, \".\");\n        }\n        outputfiles(c, tls_fd);\n    }\n    wrstr(c, tls_fd, NULL);\n    if (on_ctrl_conn == 0) {\n#ifdef WITH_TLS\n        closedata();\n#endif\n        close(c);\n    } else {\n        addreply_noformat(213, \"End.\");\n        goto end;\n    }\n    if (opt_a || opt_C || opt_d || opt_F || opt_l || opt_r || opt_R ||\n        opt_t || opt_S)\n        addreply(0, \"Options: %s%s%s%s%s%s%s%s%s\",\n                 opt_a ? \"-a \" : \"\",\n                 opt_C ? \"-C \" : \"\",\n                 opt_d ? \"-d \" : \"\",\n                 opt_F ? \"-F \" : \"\",\n                 opt_l ? \"-l \" : \"\",\n                 opt_r ? \"-r \" : \"\",\n                 opt_R ? \"-R \" : \"\", opt_S ? \"-S \" : \"\",\n                 opt_t ? \"-t\" : \"\");\n    if (matches >= max_ls_files) {\n        addreply(226, MSG_LS_TRUNCATED, matches);\n    } else {\n        addreply(226, MSG_LS_SUCCESS, matches);\n    }\nend:\n    if (chdir(wd)) {\n        die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n    }\n}\n\nvoid donlst(const char *base)\n{\n    char           line[PATH_MAX + 3U];\n    DIR           *dir;\n    void          *tls_fd = NULL;\n    struct dirent *de;\n    size_t         name_len;\n    unsigned int   matches = 0;\n    int            c;\n    int            base_has_trailing_slash = 0;\n\n    if (*base != 0 && chdir(base) != 0) {\n        if (*base++ == '-') {\n            while (!isspace((unsigned char) *base++));\n            while (isspace((unsigned char) *base++));\n            if (*base != 0 && chdir(base) != 0) {\n                addreply_noformat(550, MSG_STAT_FAILURE2);\n                return;\n            }\n        } else {\n            addreply_noformat(550, MSG_STAT_FAILURE2);\n            return;\n        }\n    }\n    if (*base !=0 && base[strlen(base) - 1U] == '/') {\n        base_has_trailing_slash = 1;\n    }\n    if ((dir = opendir(\".\")) == NULL) {\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n        goto bye;\n    }\n    opendata();\n    if ((c = xferfd) == -1) {\n        goto bye;\n    }\n    doreply();\n#ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n        tls_fd = tls_data_cnx;\n    }\n#endif\n    while ((de = readdir(dir)) != NULL) {\n        if (checkprintable(de->d_name) != 0) {\n            continue;\n        }\n        name_len = strlen(de->d_name);\n        if (name_len > sizeof line - 3U) {\n            continue;\n        }\n        memcpy(line, de->d_name, name_len);\n        line[name_len] = '\\r';\n        line[name_len + 1] = '\\n';\n        line[name_len + 2] = 0;\n        if (*base) {\n            wrstr(c, tls_fd, base);\n            if (base_has_trailing_slash == 0) {\n                wrstr(c, tls_fd, \"/\");\n            }\n        }\n        wrstr(c, tls_fd, line);\n        matches++;\n        if (matches >= max_ls_files) {\n            break;\n        }\n    }\n    closedir(dir);\n    wrstr(c, tls_fd, NULL);\n    closedata();\n    if (matches >= max_ls_files) {\n        addreply(226, MSG_LS_TRUNCATED, matches);\n    } else {\n        addreply(226, MSG_LS_SUCCESS, matches);\n    }\nbye:\n    if (chdir(wd) != 0) {\n        die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n    }\n}\n\nvoid domlsd(const char *base)\n{\n    char           line[PATH_MAX + 1];\n    DIR           *dir = NULL;\n    void          *tls_fd = NULL;\n    struct dirent *de;\n    unsigned int   matches = 0;\n    int            c;\n\n    if (*base != 0 && chdir(base) != 0) {\n        if (*base++ == '-') {\n            while (!isspace((unsigned char) *base++));\n            while (isspace((unsigned char) *base++));\n            if (*base != 0 && chdir(base) != 0) {\n                addreply_noformat(550, MSG_STAT_FAILURE2);\n                return;\n            }\n        } else {\n            addreply_noformat(550, MSG_STAT_FAILURE2);\n            return;\n        }\n    }\n    if ((dir = opendir(\".\")) == NULL) {\n        addreply_noformat(550, MSG_STAT_FAILURE2);\n        goto bye;\n    }\n    opendata();\n    if ((c = xferfd) == -1) {\n        goto bye;\n    }\n    doreply();\n#ifdef WITH_TLS\n    if (data_protection_level == CPL_PRIVATE) {\n        tls_init_data_session(xferfd, passive);\n        tls_fd = tls_data_cnx;\n    }\n#endif\n    while ((de = readdir(dir)) != NULL) {\n        if (checkprintable(de->d_name) != 0 ||\n            modernformat(de->d_name, line, sizeof line, \"\") < 0) {\n            continue;\n        }\n        wrstr(c, tls_fd, line);\n        wrstr(c, tls_fd, \"\\r\\n\");\n        matches++;\n        if (matches >= max_ls_files) {\n            break;\n        }\n    }\n    wrstr(c, tls_fd, NULL);\n    closedata();\n    if (matches >= max_ls_files) {\n        addreply(226, MSG_LS_TRUNCATED, matches);\n    } else {\n        addreply(226, MSG_LS_SUCCESS, matches);\n    }\nbye:\n    if (dir != NULL) {\n        closedir(dir);\n    }\n    if (chdir(wd) != 0) {\n        die(421, LOG_ERR, \"chdir: %s\", strerror(errno));\n    }\n}\n"], "filenames": ["src/ls.c"], "buggy_code_start_loc": [663], "buggy_code_end_loc": [722], "fixing_code_start_loc": [664], "fixing_code_end_loc": [724], "type": "CWE-400", "message": "In Pure-FTPd 1.0.49, a stack exhaustion issue was discovered in the listdir function in ls.c.", "other": {"cve": {"id": "CVE-2019-20176", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-31T15:15:11.223", "lastModified": "2023-01-20T20:43:40.457", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Pure-FTPd 1.0.49, a stack exhaustion issue was discovered in the listdir function in ls.c."}, {"lang": "es", "value": "En Pure-FTPd versi\u00f3n 1.0.49, Se descubri\u00f3 un problema de agotamiento de la pila en la funci\u00f3n listdir en el archivo ls.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pureftpd:pure-ftpd:1.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "E3D4D55C-F61A-4B98-BB70-D459F7195CD6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}], "references": [{"url": "https://github.com/jedisct1/pure-ftpd/commit/aea56f4bcb9948d456f3fae4d044fd3fa2e19706", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AHZG5FPCRMCB6Z3L7FPICC6BZ5ZATFTO/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PICL3U2J4EPGBLOE555Y5RAZTQL3WBBV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jedisct1/pure-ftpd/commit/aea56f4bcb9948d456f3fae4d044fd3fa2e19706"}}