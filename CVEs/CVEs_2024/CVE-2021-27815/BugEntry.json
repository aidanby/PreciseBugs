{"buggy_code": ["/* actions.c\n *\n * Copyright (c) 2002-2008 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details. \n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include \"config.h\"\n#include \"actions.h\"\n#include \"exif-i18n.h\"\n#include \"libjpeg/jpeg-data.h\"\n#include \"utils.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <libexif/exif-ifd.h>\n\n#define CN(s) ((s) ? (s) : \"(NULL)\")\n\n#define TAG_VALUE_BUF 1024\n\n#define SEP \" \"\n\nstatic void\nconvert_arg_to_entry (const char *set_value, ExifEntry *e, ExifByteOrder o, ExifLog *log)\n{\n\tunsigned int i, numcomponents;\n\tchar *value_p, *buf;\n\n\t /*\n\t * ASCII strings are handled separately,\n\t * since they don't require any conversion.\n\t */\n        if (e->format == EXIF_FORMAT_ASCII ||\n\t    e->tag == EXIF_TAG_USER_COMMENT) {\n\t\tif (e->data) free (e->data);\n\t\te->components = strlen (set_value) + 1;\n\t\tif (e->tag == EXIF_TAG_USER_COMMENT)\n\t\t\te->components += 8 - 1;\n\t\te->size = sizeof (char) * e->components;\n\t\te->data = malloc (e->size);\n                if (!e->data) {\n                        fprintf (stderr, _(\"Not enough memory.\"));\n                        fputc ('\\n', stderr);\n                        exit (1);\n                }\n\t\tif (e->tag == EXIF_TAG_USER_COMMENT) {\n\t\t\t/* assume ASCII charset */\n\t\t\t/* TODO: get this from the current locale */\n\t\t\tmemcpy ((char *) e->data, \"ASCII\\0\\0\\0\", 8);\n\t\t\tmemcpy ((char *) e->data + 8, set_value, \n\t\t\t\tstrlen (set_value));\n\t\t} else\n\t\t\tstrcpy ((char *) e->data, set_value);\n                return;\n\t}\n\n\t/*\n\t * Make sure we can handle this entry\n\t */\n\tif ((e->components == 0) && *set_value) {\n\t\tfprintf (stderr, _(\"Setting a value for this tag \"\n\t\t\t\t   \"is unsupported!\"));\n\t\tfputc ('\\n', stderr);\n\t\texit (1);\n\t}\n\n\t/* Copy the string so we can modify it */\n\tbuf = strdup(set_value);\n\tif (!buf) exit(1);\n\tvalue_p = strtok(buf, SEP);\n\tnumcomponents = e->components;\n\tfor (i = 0; i < numcomponents; ++i) {\n\t\tunsigned char s;\n\n\t\tif (!value_p) {\n\t\t\t\tfprintf (stderr, _(\"Too few components specified \"\n\t\t\t\t\t  \"(need %d, found %d)\\n\"), numcomponents, i);\n\t\t\t\texit (1);\n\t\t}\n\t\tif (!isdigit(*value_p) && (*value_p != '+') && (*value_p != '-')) {\n\t\t\t\tfprintf (stderr, _(\"Numeric value expected\\n\"));\n\t\t\t\texit (1);\n\t\t}\n\n\t\ts = exif_format_get_size (e->format);\n\t\tswitch (e->format) {\n\t\tcase EXIF_FORMAT_ASCII:\n\t\t\texif_log (log, -1, \"exif\", _(\"Internal error. \"\n\t\t\t\t\"Please contact <%s>.\"), PACKAGE_BUGREPORT);\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_SHORT:\n\t\t\texif_set_short (e->data + (s * i), o, atoi (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_SSHORT:\n\t\t\texif_set_sshort (e->data + (s * i), o, atoi (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_RATIONAL:\n\t\t\t/*\n\t\t\t * Hack to simplify the loop for rational numbers.\n\t\t\t * Should really be using exif_set_rational instead\n\t\t\t */\n\t\t\tif (i == 0) numcomponents *= 2;\n\t\t\ts /= 2;\n\t\t\t/* Fall through to LONG handler */\n\t\tcase EXIF_FORMAT_LONG:\n\t\t\texif_set_long (e->data + (s * i), o, atol (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_SRATIONAL:\n\t\t\t/*\n\t\t\t * Hack to simplify the loop for rational numbers.\n\t\t\t * Should really be using exif_set_srational instead\n\t\t\t */\n\t\t\tif (i == 0) numcomponents *= 2;\n\t\t\ts /= 2;\n\t\t\t/* Fall through to SLONG handler */\n\t\tcase EXIF_FORMAT_SLONG:\n\t\t\texif_set_slong (e->data + (s * i), o, atol (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_BYTE:\n\t\tcase EXIF_FORMAT_SBYTE:\n\t\tcase EXIF_FORMAT_UNDEFINED: /* treat as byte array */\n\t\t\te->data[s * i] = atoi (value_p);\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_FLOAT:\n\t\tcase EXIF_FORMAT_DOUBLE:\n\t\tdefault:\n\t\t\tfprintf (stderr, _(\"Not yet implemented!\"));\n\t\t\tfputc ('\\n', stderr);\n\t\t\texit (1);\n\t\t}\n\t\tvalue_p = strtok(NULL, SEP);\n\t}\n\tfree(buf);\n\tif (value_p) {\n\t\tfprintf (stderr, _(\"Warning; Too many components specified!\"));\n\t\tfputc ('\\n', stderr);\n\t}\n}\n\nvoid\naction_save (ExifData *ed, ExifLog *log, ExifParams p, const char *fout)\n{\n\tJPEGData *jdata;\n\tunsigned char *d = NULL;\n\tunsigned int ds;\n\n\t/* Parse the JPEG file. */\n\tjdata = jpeg_data_new ();\n\tjpeg_data_log (jdata, log);\n\tjpeg_data_load_file (jdata, p.fin);\n\n\t/* Make sure the EXIF data is not too big. */\n\texif_data_save_data (ed, &d, &ds);\n\tif (ds) {\n\t\tfree (d);\n\t\tif (ds > 0xffff)\n\t\t\texif_log (log, -1, \"exif\", _(\"Too much EXIF data \"\n\t\t\t\t\"(%i bytes). Only %i bytes are allowed.\"),\n\t\t\t\tds, 0xffff);\n\t};\n\n\tjpeg_data_set_exif_data (jdata, ed);\n\n\t/* Save the modified image. */\n\tif (jpeg_data_save_file (jdata, fout) == 0)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not write \"\n\t\t\t\t\"'%s' (%s).\"), fout, strerror (errno));\n\tjpeg_data_unref (jdata);\n\n\tfprintf (stdout, _(\"Wrote file '%s'.\"), fout);\n\tfprintf (stdout, \"\\n\");\n}\n\nstatic void\nshow_entry (ExifEntry *entry, unsigned int machine_readable)\n{\n\tExifIfd ifd = exif_entry_get_ifd (entry);\n\n\tif (machine_readable) {\n\t\tchar b[TAG_VALUE_BUF];\n\n\t\tfprintf (stdout, \"%s\\n\", C(exif_entry_get_value (entry, b, sizeof (b))));\n\t\treturn;\n\t}\n\n\t/*\n\t * The C() macro can point to a static buffer so these printfs\n\t * cannot be combined.\n\t */\n\tprintf (_(\"EXIF entry '%s' \"),\n\t\tC(exif_tag_get_title_in_ifd (entry->tag, ifd)));\n\tprintf (_(\"(0x%x, '%s') \"),\n\t\tentry->tag,\n\t\tC(exif_tag_get_name_in_ifd (entry->tag, ifd)));\n\tprintf (_(\"exists in IFD '%s':\\n\"),\n\t\tC(exif_ifd_get_name (ifd)));\n\n\texif_entry_dump (entry, 0);\n}\n\n/*! If the entry doesn't exist, create it. */\nExifEntry *\naction_create_value (ExifData *ed, ExifLog *log, ExifTag tag, ExifIfd ifd)\n{\n\tExifEntry *e;\n\n\tif (!((e = exif_content_get_entry (ed->ifd[ifd], tag)))) {\n\t    exif_log (log, EXIF_LOG_CODE_DEBUG, \"exif\", _(\"Adding entry...\"));\n\t    e = exif_entry_new ();\n\t    exif_content_add_entry (ed->ifd[ifd], e);\n\t    exif_entry_initialize (e, tag);\n\t    /* The entry has been added to the IFD, so we can unref it */\n\t    exif_entry_unref(e);\n\t}\n\treturn e;\n}\n\nvoid\naction_set_value (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\t/* If the entry doesn't exist, create it. */\n\tExifEntry *e = action_create_value(ed, log, p.tag, p.ifd);\n\n\t/* Now set the value and save the data. */\n\tconvert_arg_to_entry (p.set_value, e, exif_data_get_byte_order (ed), log);\n}\n\nvoid\naction_remove_tag (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\tExifIfd ifd;\n\tExifEntry *e;\n\n\t/* We do have 2 optional parameters: ifd and tag */\n\tif (p.tag == EXIF_INVALID_TAG && (p.ifd < EXIF_IFD_0 || p.ifd >= EXIF_IFD_COUNT))\n\t\tfor (ifd = EXIF_IFD_0; ifd < EXIF_IFD_COUNT; ifd++)\n\t\t\twhile (ed->ifd[ifd] && ed->ifd[ifd]->count)\n\t\t\t\texif_content_remove_entry (ed->ifd[ifd],\n\t\t\t\t\ted->ifd[ifd]->entries[0]);\n\telse if (p.tag == EXIF_INVALID_TAG)\n\t\twhile (ed->ifd[p.ifd] && ed->ifd[p.ifd]->count)\n\t\t\texif_content_remove_entry (ed->ifd[p.ifd],\n\t\t\t\ted->ifd[p.ifd]->entries[0]);\n\telse if (p.ifd < EXIF_IFD_0 || p.ifd >= EXIF_IFD_COUNT)\n\t\twhile ((e = exif_data_get_entry (ed, p.tag)))\n\t\t\texif_content_remove_entry (e->parent, e);\n\telse if (!((e = exif_content_get_entry (ed->ifd[p.ifd], p.tag))))\n\t\texif_log (log, -1, \"exif\", _(\"IFD '%s' does not contain a \"\n\t\t\t\"tag '%s'!\"), exif_ifd_get_name (p.ifd),\n\t\t\texif_tag_get_name_in_ifd (p.tag, p.ifd));\n\telse\n\t\texif_content_remove_entry (ed->ifd[p.ifd], e);\n}\n\nvoid\naction_remove_thumb (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\t(void) log;  /* unused */\n\t(void) p;  /* unused */\n\tif (ed->data) {\n\t\tfree (ed->data);\n\t\ted->data = NULL;\n\t}\n\ted->size = 0;\n}\n\nvoid\naction_insert_thumb (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\tFILE *f;\n\n\tif (!ed) return;\n\n\t/* Get rid of the thumbnail */\n\taction_remove_thumb (ed, log, p);\n\n\t/* Insert new thumbnail */\n\tf = fopen (p.set_thumb, \"rb\");\n\tif (!f) {\n\t\texif_log (log, -1, \"exif\", _(\"Could not open \"\n\t\t\t\"'%s' (%s)!\"), p.set_thumb, strerror (errno));\n\t} else {\n\t\tlong fsize;\n\t\tif (fseek (f, 0, SEEK_END) < 0) {\n\t\t\tfclose(f);\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not determine size of \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\t\treturn;\n\t\t}\n\t\tfsize = ftell (f);\n\t\tif (fsize < 0) {\n\t\t\tfclose(f);\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not determine size of \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\t\treturn;\n\t\t}\n\t\ted->size = fsize;\n\t\ted->data = malloc (sizeof (char) * ed->size);\n\t\tif (ed->size && !ed->data) {\n\t\t\tEXIF_LOG_NO_MEMORY (log, \"exif\", sizeof (char) * ed->size);\n\t\t\texit (1);\n\t\t}\n\t\tif (fseek (f, 0, SEEK_SET) < 0) {\n\t\t\tfclose(f);\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not determine size of \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\t\treturn;\n\t\t}\n\t\tif (fread (ed->data, sizeof (char), ed->size, f) != ed->size)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not read \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\tif (fclose (f) < 0)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not read \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t}\n}\n\nvoid\naction_show_tag (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\tExifEntry *e;\n\tunsigned int i;\n\n\tif (!ed) return;\n\n\t/* We have one optional parameter: ifd */\n\tif ((p.ifd >= EXIF_IFD_0) && (p.ifd < EXIF_IFD_COUNT)) {\n\t\tif ((e = exif_content_get_entry (ed->ifd[p.ifd], p.tag)))\n\t\t\tshow_entry (e, p.machine_readable);\n\t\telse\n\t\t\texif_log (log, -1, \"exif\", _(\"IFD '%s' \"\n\t\t\t\t\"does not contain tag '%s'.\"),\n\t\t\t\t\texif_ifd_get_name (p.ifd),\n\t\t\t\t\texif_tag_get_name (p.tag));\n\t} else {\n\t\tif (!exif_data_get_entry (ed, p.tag))\n\t\t\texif_log (log, -1, \"exif\", _(\"'%s' does not contain \"\n\t\t\t\t\"tag '%s'.\"), p.fin,\n\t\t\t\texif_tag_get_name (p.tag));\n\t\telse for (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\t\tif ((e = exif_content_get_entry (ed->ifd[i], p.tag)))\n\t\t\t\tshow_entry (e, p.machine_readable);\n\t}\n}\n\nvoid\naction_save_thumb (ExifData *ed, ExifLog *log, ExifParams p, const char *fout)\n{\n\tFILE *f;\n\n\tif (!ed) return;\n\n\t/* No thumbnail? Exit. */\n\tif (!ed->data) {\n\t\texif_log (log, -1, \"exif\", _(\"'%s' does not \"\n\t\t\t\"contain a thumbnail!\"), p.fin);\n\t\treturn;\n\t}\n\n\t/* Save the thumbnail */\n\tf = fopen (fout, \"wb\");\n\tif (!f)\n\t\texif_log (log, -1, \"exif\", _(\"Could not open '%s' for \"\n\t\t\t\"writing (%s)!\"), fout, strerror (errno));\n\telse {\n\t\tif (fwrite (ed->data, 1, ed->size, f) != ed->size) {\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not write '%s' (%s).\"),\n\t\t\t\tfout, strerror (errno));\n\t\t};\n\t\tif (fclose (f) == EOF)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not write '%s' (%s).\"),\n\t\t\t\tfout, strerror (errno));\n\t\tfprintf (stdout, _(\"Wrote file '%s'.\"), fout);\n\t\tfprintf (stdout, \"\\n\");\n\t}\n}\n\nvoid\naction_tag_table (ExifData *ed, ExifParams p)\n{\n\tunsigned int tag;\n\tconst char *name;\n\tchar txt[TAG_VALUE_BUF];\n\tExifIfd i;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n#define ENTRY_FOUND     \"   *   \"\n#define ENTRY_NOT_FOUND \"   -   \"\n\n\tsnprintf (txt, sizeof (txt) - 1, _(\"EXIF tags in '%s':\"), p.fin);\n\tfieldwidth = width = p.width - 36;\n\tbytes = exif_mbstrlen(txt, &width);\n\tprintf (\"%.*s%*s\", bytes, txt, fieldwidth-(int)width, \"\");\n\n\tfor (i = (ExifIfd)0; i < EXIF_IFD_COUNT; i++) {\n\t\tint space;\n\t\tfieldwidth = width = 7;\n\t\tbytes = exif_mbstrlen(exif_ifd_get_name (i), &width);\n\t\tspace = fieldwidth-width;\n\t\tprintf (\"%*s%.*s%*s\", space/2, \"\", bytes, exif_ifd_get_name (i),\n\t\t\tspace - space/2, \"\");\n\t}\n\tfputc ('\\n', stdout);\n\n\tfor (tag = 0; tag < 0xffff; tag++) {\n\t\t/*\n\t\t * Display the name of the first tag of this number found.\n\t\t * Since there is some overlap (e.g. with GPS tags), this\n\t\t * name could sometimes be incorrect for the specific tags\n\t\t * found in this file.\n\t\t */\n\t\tname = exif_tag_get_title(tag);\n\t\tif (!name)\n\t\t\tcontinue;\n\n\t\tfieldwidth = width = p.width - 43;\n\t\tbytes = exif_mbstrlen(C(name), &width);\n\t\tprintf (\"0x%04x %.*s%*s\",\n\t\t\ttag, bytes, C(name), fieldwidth-(int)width, \"\");\n\t\tfor (i = (ExifIfd)0; i < EXIF_IFD_COUNT; i++)\n\t\t\tif (exif_content_get_entry (ed->ifd[i], tag))\n\t\t\t\tprintf (ENTRY_FOUND);\n\t\t\telse\n\t\t\t\tprintf (ENTRY_NOT_FOUND);\n\t\tfputc ('\\n', stdout);\n\t}\n}\n\nstatic void\nshow_entry_list (ExifEntry *e, void *data)\n{\n\tconst ExifParams *p = data;\n\tchar v[TAG_VALUE_BUF];\n\tExifIfd ifd = exif_entry_get_ifd (e);\n\tconst char *str;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n\tif (p->use_ids)\n\t\tprintf(\"0x%04x\", e->tag);\n\telse {\n\t\tstr = C(exif_tag_get_title_in_ifd (e->tag, ifd));\n\t\tfieldwidth = width = 20;\n\t\tbytes = exif_mbstrlen(str, &width);\n\t\tprintf (\"%.*s%*s\", bytes, str, fieldwidth-(int)width, \"\");\n\t}\n\tprintf (\"|\");\n\n\tfieldwidth = width = p->use_ids ? p->width-8 : p->width-22;\n\tstr = C(exif_entry_get_value (e, v, sizeof(v)));\n\tbytes = exif_mbstrlen(str, &width);\n\tprintf(\"%.*s\", bytes, str);\n\tfputc ('\\n', stdout);\n}\n\nstatic void\nshow_ifd (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, show_entry_list, data);\n}\n\nstatic void\nprint_hline (unsigned int ids, unsigned int screenwidth)\n{\n        unsigned int i, width;\n\n        width = ids ? 6 : 20; \n        for (i = 0; i < width; i++)\n\t\tfputc ('-', stdout);\n        fputc ('+', stdout);\n        for (i = 0; i < screenwidth - 2 - width; i++)\n\t\tfputc ('-', stdout);\n\tfputc ('\\n', stdout);\n}\n\nvoid\naction_mnote_list (ExifData *ed, ExifParams p)\n{\n\tchar b[TAG_VALUE_BUF], b1[TAG_VALUE_BUF], b2[TAG_VALUE_BUF];\n\tunsigned int i, c, id;\n\tExifMnoteData *n;\n\tconst char *s;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n\tn = exif_data_get_mnote_data (ed);\n\tif (!n) {\n\t\tprintf (_(\"Unknown format or nonexistent MakerNote.\\n\"));\n\t\treturn;\n\t}\n\n\tc = exif_mnote_data_count (n);\n\tif (!p.machine_readable) {\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tprintf (_(\"MakerNote does not contain any value.\\n\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (ngettext(\"MakerNote contains %i value:\\n\",\n\t\t\t\t\t \"MakerNote contains %i values:\\n\",\n\t\t\t\t\t c), c);\n\t\t}\n\t}\n\tfor (i = 0; i < c; i++) {\n\t        if (p.use_ids) {\n\t\t\tid = exif_mnote_data_get_id  (n,i);\n\t\t\tsprintf(b1,\"0x%04x\",id);\n\t\t} else {\n\t\t\ts = C (exif_mnote_data_get_title (n, i));\n\t\t\tstrncpy (b1, s && *s ? s : _(\"Unknown Tag\"), TAG_VALUE_BUF);\n\t\t\tb1[sizeof(b1)-1] = 0;\n\t\t}\n\t\tif (p.machine_readable) {\n\t\t\tprintf (\"%s\\t\", b1);\n\t\t} else {\n\t\t\tfieldwidth = width = p.use_ids ? 6 : 20;\n\t\t\tbytes = exif_mbstrlen(b1, &width);\n\t\t\tprintf (\"%.*s%*s|\", bytes, b1, fieldwidth-(int)width, \"\");\n\t\t}\n\n\t\ts = C (exif_mnote_data_get_value (n, i, b, TAG_VALUE_BUF));\n\t\tstrncpy (b2, s ? s : _(\"Unknown value\"), TAG_VALUE_BUF);\n\t\tb2[sizeof(b2)-1] = 0;\n        \tif (p.use_ids) {\n\t\t\tfputs (b2, stdout);\n        \t} else {\n\t\t\tfieldwidth = width = p.width-22;\n\t\t\tbytes = exif_mbstrlen(b2, &width);\n\t\t\tprintf (\"%.*s\", bytes, b2);\n\t\t}\n        \tfputc ('\\n', stdout);\n\t}\n}\n\nvoid\naction_tag_list (ExifData *ed, ExifParams p)\n{\n\tExifByteOrder order;\n\tconst char *s;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n\tif (!ed)\n\t\treturn;\n\n\torder = exif_data_get_byte_order (ed);\n\tprintf (_(\"EXIF tags in '%s' ('%s' byte order):\"), p.fin,\n\t\texif_byte_order_get_name (order));\n\tfputc ('\\n', stdout);\n\tprint_hline (p.use_ids, p.width);\n\n\tfieldwidth = width = p.use_ids ? 6 : 20;\n\ts = _(\"Tag\");\n\tbytes = exif_mbstrlen(s, &width);\n\tprintf (\"%.*s%*s\", bytes, s, fieldwidth-(int)width, \"\");\n\tfputc ('|', stdout);\n\n\tfieldwidth = width = p.use_ids ? p.width-8 : p.width-22;\n\ts = _(\"Value\");\n\tbytes = exif_mbstrlen(s, &width);\n\tprintf (\"%.*s\", bytes, s);\n        fputc ('\\n', stdout);\n        print_hline (p.use_ids, p.width);\n\n\tif (p.ifd < EXIF_IFD_COUNT)\n\t\t/* Show only a single IFD */\n\t\tshow_ifd(ed->ifd[p.ifd], &p);\n\telse\n\t\t/* Show contents of all IFDs */\n\t\texif_data_foreach_content (ed, show_ifd, &p);\n\n        print_hline (p.use_ids, p.width);\n        if (ed->size) {\n                printf (_(\"EXIF data contains a thumbnail \"\n\t\t\t  \"(%i bytes).\"), ed->size);\n                fputc ('\\n', stdout);\n        }\n}\n\nstatic void\nshow_entry_machine (ExifEntry *e, void *data)\n{\n\tunsigned int *ids = data;\n\tchar v[TAG_VALUE_BUF];\n\tExifIfd ifd = exif_entry_get_ifd (e);\n\n\tif (*ids) {\n\t\tfprintf (stdout, \"0x%04x\", e->tag);\n\t} else {\n\t\tfputs (CN (exif_tag_get_title_in_ifd (e->tag, ifd)), stdout);\n\t}\n\tfputc ('\\t', stdout);\n\tfputs (CN (exif_entry_get_value (e, v, sizeof (v))), stdout);\n\tfputc ('\\n', stdout);\n}\n\nstatic void\nshow_ifd_machine (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, show_entry_machine, data);\n}\n\nvoid\naction_tag_list_machine (ExifData *ed, ExifParams p)\n{\n\tif (!ed) return;\n\n\tif (p.ifd < EXIF_IFD_COUNT)\n\t\t/* Show only a single IFD */\n\t\tshow_ifd_machine(ed->ifd[p.ifd], &p.use_ids);\n\telse\n\t\t/* Show contents of all IFDs */\n\t\texif_data_foreach_content (ed, show_ifd_machine, &p.use_ids);\n\n\tif (ed->size)\n\t\tfprintf (stdout, _(\"ThumbnailSize\\t%i\\n\"), ed->size);\n}\n\n/*!\n * Replace characters which are invalid in an XML tag with safe characters\n * in place.\n */\nstatic inline void\nremove_bad_chars(char *s)\n{\n\twhile (*s) {\n\t\tif ((*s == '(') || (*s == ')') || (*s == ' '))\n\t\t\t*s = '_';\n\t\t++s;\n\t}\n}\n\n/*!\n * Escape any special XML characters in the text and return a new static string\n * buffer.\n */\nstatic const char *\nescape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\n\tif (!strlen(text)) return \"empty string\";\n\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\t/* Make sure there's plenty of room for a quoted character */\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t/* avoid leaking memory */\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\t/* Error string is cleverly chosen to fail XML validation */\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  /* NUL terminate the string */\n\treturn escaped;\n}\n\nstatic void\nshow_entry_xml (ExifEntry *e, void *data)\n{\n\tunsigned char *ids = data;\n\tchar v[TAG_VALUE_BUF], t[TAG_VALUE_BUF];\n\n\tif (*ids) {\n\t\tfprintf (stdout, \"<x%04x>\", e->tag);\n\t\tfprintf (stdout, \"%s\", escape_xml(exif_entry_get_value (e, v, sizeof (v))));\n\t\tfprintf (stdout, \"</x%04x>\", e->tag);\n\t} else {\n\t\tstrncpy (t, exif_tag_get_title_in_ifd(e->tag, exif_entry_get_ifd(e)), sizeof (t));\n\t\tt[sizeof(t)-1] = 0;\n\n\t\t/* Remove invalid characters from tag eg. (, ), space */\n\t\tremove_bad_chars(t);\n\n\t\tfprintf (stdout, \"\\t<%s>\", t);\n\t\tfprintf (stdout, \"%s\", escape_xml(exif_entry_get_value (e, v, sizeof (v))));\n\t\tfprintf (stdout, \"</%s>\\n\", t);\n\t}\n}\n\nstatic void\nshow_xml (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, show_entry_xml, data);\n}\n\nvoid\naction_tag_list_xml (ExifData *ed, ExifParams p)\n{\n\tif (!ed) return;\n\n\tfprintf(stdout, \"<exif>\\n\");\n\tif (p.ifd < EXIF_IFD_COUNT)\n\t\t/* Show only a single IFD */\n\t\tshow_xml(ed->ifd[p.ifd], &p.use_ids);\n\telse\n\t\t/* Show contents of all IFDs */\n\t\texif_data_foreach_content (ed, show_xml, &p.use_ids);\n\tfprintf(stdout, \"</exif>\\n\");\n}\n"], "fixing_code": ["/* actions.c\n *\n * Copyright (c) 2002-2008 Lutz Mueller <lutz@users.sourceforge.net>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, \n * but WITHOUT ANY WARRANTY; without even the implied warranty of \n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details. \n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n * Boston, MA  02110-1301  USA.\n */\n\n#include \"config.h\"\n#include \"actions.h\"\n#include \"exif-i18n.h\"\n#include \"libjpeg/jpeg-data.h\"\n#include \"utils.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <libexif/exif-ifd.h>\n\n#define CN(s) ((s) ? (s) : \"(NULL)\")\n\n#define TAG_VALUE_BUF 1024\n\n#define SEP \" \"\n\nstatic void\nconvert_arg_to_entry (const char *set_value, ExifEntry *e, ExifByteOrder o, ExifLog *log)\n{\n\tunsigned int i, numcomponents;\n\tchar *value_p, *buf;\n\n\t /*\n\t * ASCII strings are handled separately,\n\t * since they don't require any conversion.\n\t */\n        if (e->format == EXIF_FORMAT_ASCII ||\n\t    e->tag == EXIF_TAG_USER_COMMENT) {\n\t\tif (e->data) free (e->data);\n\t\te->components = strlen (set_value) + 1;\n\t\tif (e->tag == EXIF_TAG_USER_COMMENT)\n\t\t\te->components += 8 - 1;\n\t\te->size = sizeof (char) * e->components;\n\t\te->data = malloc (e->size);\n                if (!e->data) {\n                        fprintf (stderr, _(\"Not enough memory.\"));\n                        fputc ('\\n', stderr);\n                        exit (1);\n                }\n\t\tif (e->tag == EXIF_TAG_USER_COMMENT) {\n\t\t\t/* assume ASCII charset */\n\t\t\t/* TODO: get this from the current locale */\n\t\t\tmemcpy ((char *) e->data, \"ASCII\\0\\0\\0\", 8);\n\t\t\tmemcpy ((char *) e->data + 8, set_value, \n\t\t\t\tstrlen (set_value));\n\t\t} else\n\t\t\tstrcpy ((char *) e->data, set_value);\n                return;\n\t}\n\n\t/*\n\t * Make sure we can handle this entry\n\t */\n\tif ((e->components == 0) && *set_value) {\n\t\tfprintf (stderr, _(\"Setting a value for this tag \"\n\t\t\t\t   \"is unsupported!\"));\n\t\tfputc ('\\n', stderr);\n\t\texit (1);\n\t}\n\n\t/* Copy the string so we can modify it */\n\tbuf = strdup(set_value);\n\tif (!buf) exit(1);\n\tvalue_p = strtok(buf, SEP);\n\tnumcomponents = e->components;\n\tfor (i = 0; i < numcomponents; ++i) {\n\t\tunsigned char s;\n\n\t\tif (!value_p) {\n\t\t\t\tfprintf (stderr, _(\"Too few components specified \"\n\t\t\t\t\t  \"(need %d, found %d)\\n\"), numcomponents, i);\n\t\t\t\texit (1);\n\t\t}\n\t\tif (!isdigit(*value_p) && (*value_p != '+') && (*value_p != '-')) {\n\t\t\t\tfprintf (stderr, _(\"Numeric value expected\\n\"));\n\t\t\t\texit (1);\n\t\t}\n\n\t\ts = exif_format_get_size (e->format);\n\t\tswitch (e->format) {\n\t\tcase EXIF_FORMAT_ASCII:\n\t\t\texif_log (log, -1, \"exif\", _(\"Internal error. \"\n\t\t\t\t\"Please contact <%s>.\"), PACKAGE_BUGREPORT);\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_SHORT:\n\t\t\texif_set_short (e->data + (s * i), o, atoi (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_SSHORT:\n\t\t\texif_set_sshort (e->data + (s * i), o, atoi (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_RATIONAL:\n\t\t\t/*\n\t\t\t * Hack to simplify the loop for rational numbers.\n\t\t\t * Should really be using exif_set_rational instead\n\t\t\t */\n\t\t\tif (i == 0) numcomponents *= 2;\n\t\t\ts /= 2;\n\t\t\t/* Fall through to LONG handler */\n\t\tcase EXIF_FORMAT_LONG:\n\t\t\texif_set_long (e->data + (s * i), o, atol (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_SRATIONAL:\n\t\t\t/*\n\t\t\t * Hack to simplify the loop for rational numbers.\n\t\t\t * Should really be using exif_set_srational instead\n\t\t\t */\n\t\t\tif (i == 0) numcomponents *= 2;\n\t\t\ts /= 2;\n\t\t\t/* Fall through to SLONG handler */\n\t\tcase EXIF_FORMAT_SLONG:\n\t\t\texif_set_slong (e->data + (s * i), o, atol (value_p));\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_BYTE:\n\t\tcase EXIF_FORMAT_SBYTE:\n\t\tcase EXIF_FORMAT_UNDEFINED: /* treat as byte array */\n\t\t\te->data[s * i] = atoi (value_p);\n\t\t\tbreak;\n\t\tcase EXIF_FORMAT_FLOAT:\n\t\tcase EXIF_FORMAT_DOUBLE:\n\t\tdefault:\n\t\t\tfprintf (stderr, _(\"Not yet implemented!\"));\n\t\t\tfputc ('\\n', stderr);\n\t\t\texit (1);\n\t\t}\n\t\tvalue_p = strtok(NULL, SEP);\n\t}\n\tfree(buf);\n\tif (value_p) {\n\t\tfprintf (stderr, _(\"Warning; Too many components specified!\"));\n\t\tfputc ('\\n', stderr);\n\t}\n}\n\nvoid\naction_save (ExifData *ed, ExifLog *log, ExifParams p, const char *fout)\n{\n\tJPEGData *jdata;\n\tunsigned char *d = NULL;\n\tunsigned int ds;\n\n\t/* Parse the JPEG file. */\n\tjdata = jpeg_data_new ();\n\tjpeg_data_log (jdata, log);\n\tjpeg_data_load_file (jdata, p.fin);\n\n\t/* Make sure the EXIF data is not too big. */\n\texif_data_save_data (ed, &d, &ds);\n\tif (ds) {\n\t\tfree (d);\n\t\tif (ds > 0xffff)\n\t\t\texif_log (log, -1, \"exif\", _(\"Too much EXIF data \"\n\t\t\t\t\"(%i bytes). Only %i bytes are allowed.\"),\n\t\t\t\tds, 0xffff);\n\t};\n\n\tjpeg_data_set_exif_data (jdata, ed);\n\n\t/* Save the modified image. */\n\tif (jpeg_data_save_file (jdata, fout) == 0)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not write \"\n\t\t\t\t\"'%s' (%s).\"), fout, strerror (errno));\n\tjpeg_data_unref (jdata);\n\n\tfprintf (stdout, _(\"Wrote file '%s'.\"), fout);\n\tfprintf (stdout, \"\\n\");\n}\n\nstatic void\nshow_entry (ExifEntry *entry, unsigned int machine_readable)\n{\n\tExifIfd ifd = exif_entry_get_ifd (entry);\n\n\tif (machine_readable) {\n\t\tchar b[TAG_VALUE_BUF];\n\n\t\tfprintf (stdout, \"%s\\n\", C(exif_entry_get_value (entry, b, sizeof (b))));\n\t\treturn;\n\t}\n\n\t/*\n\t * The C() macro can point to a static buffer so these printfs\n\t * cannot be combined.\n\t */\n\tprintf (_(\"EXIF entry '%s' \"),\n\t\tC(exif_tag_get_title_in_ifd (entry->tag, ifd)));\n\tprintf (_(\"(0x%x, '%s') \"),\n\t\tentry->tag,\n\t\tC(exif_tag_get_name_in_ifd (entry->tag, ifd)));\n\tprintf (_(\"exists in IFD '%s':\\n\"),\n\t\tC(exif_ifd_get_name (ifd)));\n\n\texif_entry_dump (entry, 0);\n}\n\n/*! If the entry doesn't exist, create it. */\nExifEntry *\naction_create_value (ExifData *ed, ExifLog *log, ExifTag tag, ExifIfd ifd)\n{\n\tExifEntry *e;\n\n\tif (!((e = exif_content_get_entry (ed->ifd[ifd], tag)))) {\n\t    exif_log (log, EXIF_LOG_CODE_DEBUG, \"exif\", _(\"Adding entry...\"));\n\t    e = exif_entry_new ();\n\t    exif_content_add_entry (ed->ifd[ifd], e);\n\t    exif_entry_initialize (e, tag);\n\t    /* The entry has been added to the IFD, so we can unref it */\n\t    exif_entry_unref(e);\n\t}\n\treturn e;\n}\n\nvoid\naction_set_value (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\t/* If the entry doesn't exist, create it. */\n\tExifEntry *e = action_create_value(ed, log, p.tag, p.ifd);\n\n\t/* Now set the value and save the data. */\n\tconvert_arg_to_entry (p.set_value, e, exif_data_get_byte_order (ed), log);\n}\n\nvoid\naction_remove_tag (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\tExifIfd ifd;\n\tExifEntry *e;\n\n\t/* We do have 2 optional parameters: ifd and tag */\n\tif (p.tag == EXIF_INVALID_TAG && (p.ifd < EXIF_IFD_0 || p.ifd >= EXIF_IFD_COUNT))\n\t\tfor (ifd = EXIF_IFD_0; ifd < EXIF_IFD_COUNT; ifd++)\n\t\t\twhile (ed->ifd[ifd] && ed->ifd[ifd]->count)\n\t\t\t\texif_content_remove_entry (ed->ifd[ifd],\n\t\t\t\t\ted->ifd[ifd]->entries[0]);\n\telse if (p.tag == EXIF_INVALID_TAG)\n\t\twhile (ed->ifd[p.ifd] && ed->ifd[p.ifd]->count)\n\t\t\texif_content_remove_entry (ed->ifd[p.ifd],\n\t\t\t\ted->ifd[p.ifd]->entries[0]);\n\telse if (p.ifd < EXIF_IFD_0 || p.ifd >= EXIF_IFD_COUNT)\n\t\twhile ((e = exif_data_get_entry (ed, p.tag)))\n\t\t\texif_content_remove_entry (e->parent, e);\n\telse if (!((e = exif_content_get_entry (ed->ifd[p.ifd], p.tag))))\n\t\texif_log (log, -1, \"exif\", _(\"IFD '%s' does not contain a \"\n\t\t\t\"tag '%s'!\"), exif_ifd_get_name (p.ifd),\n\t\t\texif_tag_get_name_in_ifd (p.tag, p.ifd));\n\telse\n\t\texif_content_remove_entry (ed->ifd[p.ifd], e);\n}\n\nvoid\naction_remove_thumb (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\t(void) log;  /* unused */\n\t(void) p;  /* unused */\n\tif (ed->data) {\n\t\tfree (ed->data);\n\t\ted->data = NULL;\n\t}\n\ted->size = 0;\n}\n\nvoid\naction_insert_thumb (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\tFILE *f;\n\n\tif (!ed) return;\n\n\t/* Get rid of the thumbnail */\n\taction_remove_thumb (ed, log, p);\n\n\t/* Insert new thumbnail */\n\tf = fopen (p.set_thumb, \"rb\");\n\tif (!f) {\n\t\texif_log (log, -1, \"exif\", _(\"Could not open \"\n\t\t\t\"'%s' (%s)!\"), p.set_thumb, strerror (errno));\n\t} else {\n\t\tlong fsize;\n\t\tif (fseek (f, 0, SEEK_END) < 0) {\n\t\t\tfclose(f);\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not determine size of \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\t\treturn;\n\t\t}\n\t\tfsize = ftell (f);\n\t\tif (fsize < 0) {\n\t\t\tfclose(f);\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not determine size of \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\t\treturn;\n\t\t}\n\t\ted->size = fsize;\n\t\ted->data = malloc (sizeof (char) * ed->size);\n\t\tif (ed->size && !ed->data) {\n\t\t\tEXIF_LOG_NO_MEMORY (log, \"exif\", sizeof (char) * ed->size);\n\t\t\texit (1);\n\t\t}\n\t\tif (fseek (f, 0, SEEK_SET) < 0) {\n\t\t\tfclose(f);\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not determine size of \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\t\treturn;\n\t\t}\n\t\tif (fread (ed->data, sizeof (char), ed->size, f) != ed->size)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not read \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t\tif (fclose (f) < 0)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not read \"\n\t\t\t\t\"'%s' (%s).\"), p.set_thumb, strerror (errno));\n\t}\n}\n\nvoid\naction_show_tag (ExifData *ed, ExifLog *log, ExifParams p)\n{\n\tExifEntry *e;\n\tunsigned int i;\n\n\tif (!ed) return;\n\n\t/* We have one optional parameter: ifd */\n\tif ((p.ifd >= EXIF_IFD_0) && (p.ifd < EXIF_IFD_COUNT)) {\n\t\tif ((e = exif_content_get_entry (ed->ifd[p.ifd], p.tag)))\n\t\t\tshow_entry (e, p.machine_readable);\n\t\telse\n\t\t\texif_log (log, -1, \"exif\", _(\"IFD '%s' \"\n\t\t\t\t\"does not contain tag '%s'.\"),\n\t\t\t\t\texif_ifd_get_name (p.ifd),\n\t\t\t\t\texif_tag_get_name (p.tag));\n\t} else {\n\t\tif (!exif_data_get_entry (ed, p.tag))\n\t\t\texif_log (log, -1, \"exif\", _(\"'%s' does not contain \"\n\t\t\t\t\"tag '%s'.\"), p.fin,\n\t\t\t\texif_tag_get_name (p.tag));\n\t\telse for (i = 0; i < EXIF_IFD_COUNT; i++)\n\t\t\tif ((e = exif_content_get_entry (ed->ifd[i], p.tag)))\n\t\t\t\tshow_entry (e, p.machine_readable);\n\t}\n}\n\nvoid\naction_save_thumb (ExifData *ed, ExifLog *log, ExifParams p, const char *fout)\n{\n\tFILE *f;\n\n\tif (!ed) return;\n\n\t/* No thumbnail? Exit. */\n\tif (!ed->data) {\n\t\texif_log (log, -1, \"exif\", _(\"'%s' does not \"\n\t\t\t\"contain a thumbnail!\"), p.fin);\n\t\treturn;\n\t}\n\n\t/* Save the thumbnail */\n\tf = fopen (fout, \"wb\");\n\tif (!f)\n\t\texif_log (log, -1, \"exif\", _(\"Could not open '%s' for \"\n\t\t\t\"writing (%s)!\"), fout, strerror (errno));\n\telse {\n\t\tif (fwrite (ed->data, 1, ed->size, f) != ed->size) {\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not write '%s' (%s).\"),\n\t\t\t\tfout, strerror (errno));\n\t\t};\n\t\tif (fclose (f) == EOF)\n\t\t\texif_log (log, -1, \"exif\", _(\"Could not write '%s' (%s).\"),\n\t\t\t\tfout, strerror (errno));\n\t\tfprintf (stdout, _(\"Wrote file '%s'.\"), fout);\n\t\tfprintf (stdout, \"\\n\");\n\t}\n}\n\nvoid\naction_tag_table (ExifData *ed, ExifParams p)\n{\n\tunsigned int tag;\n\tconst char *name;\n\tchar txt[TAG_VALUE_BUF];\n\tExifIfd i;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n#define ENTRY_FOUND     \"   *   \"\n#define ENTRY_NOT_FOUND \"   -   \"\n\n\tsnprintf (txt, sizeof (txt) - 1, _(\"EXIF tags in '%s':\"), p.fin);\n\tfieldwidth = width = p.width - 36;\n\tbytes = exif_mbstrlen(txt, &width);\n\tprintf (\"%.*s%*s\", bytes, txt, fieldwidth-(int)width, \"\");\n\n\tfor (i = (ExifIfd)0; i < EXIF_IFD_COUNT; i++) {\n\t\tint space;\n\t\tfieldwidth = width = 7;\n\t\tbytes = exif_mbstrlen(exif_ifd_get_name (i), &width);\n\t\tspace = fieldwidth-width;\n\t\tprintf (\"%*s%.*s%*s\", space/2, \"\", bytes, exif_ifd_get_name (i),\n\t\t\tspace - space/2, \"\");\n\t}\n\tfputc ('\\n', stdout);\n\n\tfor (tag = 0; tag < 0xffff; tag++) {\n\t\t/*\n\t\t * Display the name of the first tag of this number found.\n\t\t * Since there is some overlap (e.g. with GPS tags), this\n\t\t * name could sometimes be incorrect for the specific tags\n\t\t * found in this file.\n\t\t */\n\t\tname = exif_tag_get_title(tag);\n\t\tif (!name)\n\t\t\tcontinue;\n\n\t\tfieldwidth = width = p.width - 43;\n\t\tbytes = exif_mbstrlen(C(name), &width);\n\t\tprintf (\"0x%04x %.*s%*s\",\n\t\t\ttag, bytes, C(name), fieldwidth-(int)width, \"\");\n\t\tfor (i = (ExifIfd)0; i < EXIF_IFD_COUNT; i++)\n\t\t\tif (exif_content_get_entry (ed->ifd[i], tag))\n\t\t\t\tprintf (ENTRY_FOUND);\n\t\t\telse\n\t\t\t\tprintf (ENTRY_NOT_FOUND);\n\t\tfputc ('\\n', stdout);\n\t}\n}\n\nstatic void\nshow_entry_list (ExifEntry *e, void *data)\n{\n\tconst ExifParams *p = data;\n\tchar v[TAG_VALUE_BUF];\n\tExifIfd ifd = exif_entry_get_ifd (e);\n\tconst char *str;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n\tif (p->use_ids)\n\t\tprintf(\"0x%04x\", e->tag);\n\telse {\n\t\tstr = C(exif_tag_get_title_in_ifd (e->tag, ifd));\n\t\tfieldwidth = width = 20;\n\t\tbytes = exif_mbstrlen(str, &width);\n\t\tprintf (\"%.*s%*s\", bytes, str, fieldwidth-(int)width, \"\");\n\t}\n\tprintf (\"|\");\n\n\tfieldwidth = width = p->use_ids ? p->width-8 : p->width-22;\n\tstr = C(exif_entry_get_value (e, v, sizeof(v)));\n\tbytes = exif_mbstrlen(str, &width);\n\tprintf(\"%.*s\", bytes, str);\n\tfputc ('\\n', stdout);\n}\n\nstatic void\nshow_ifd (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, show_entry_list, data);\n}\n\nstatic void\nprint_hline (unsigned int ids, unsigned int screenwidth)\n{\n        unsigned int i, width;\n\n        width = ids ? 6 : 20; \n        for (i = 0; i < width; i++)\n\t\tfputc ('-', stdout);\n        fputc ('+', stdout);\n        for (i = 0; i < screenwidth - 2 - width; i++)\n\t\tfputc ('-', stdout);\n\tfputc ('\\n', stdout);\n}\n\nvoid\naction_mnote_list (ExifData *ed, ExifParams p)\n{\n\tchar b[TAG_VALUE_BUF], b1[TAG_VALUE_BUF], b2[TAG_VALUE_BUF];\n\tunsigned int i, c, id;\n\tExifMnoteData *n;\n\tconst char *s;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n\tn = exif_data_get_mnote_data (ed);\n\tif (!n) {\n\t\tprintf (_(\"Unknown format or nonexistent MakerNote.\\n\"));\n\t\treturn;\n\t}\n\n\tc = exif_mnote_data_count (n);\n\tif (!p.machine_readable) {\n\t\tswitch (c) {\n\t\tcase 0:\n\t\t\tprintf (_(\"MakerNote does not contain any value.\\n\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf (ngettext(\"MakerNote contains %i value:\\n\",\n\t\t\t\t\t \"MakerNote contains %i values:\\n\",\n\t\t\t\t\t c), c);\n\t\t}\n\t}\n\tfor (i = 0; i < c; i++) {\n\t        if (p.use_ids) {\n\t\t\tid = exif_mnote_data_get_id  (n,i);\n\t\t\tsprintf(b1,\"0x%04x\",id);\n\t\t} else {\n\t\t\ts = C (exif_mnote_data_get_title (n, i));\n\t\t\tstrncpy (b1, s && *s ? s : _(\"Unknown Tag\"), TAG_VALUE_BUF);\n\t\t\tb1[sizeof(b1)-1] = 0;\n\t\t}\n\t\tif (p.machine_readable) {\n\t\t\tprintf (\"%s\\t\", b1);\n\t\t} else {\n\t\t\tfieldwidth = width = p.use_ids ? 6 : 20;\n\t\t\tbytes = exif_mbstrlen(b1, &width);\n\t\t\tprintf (\"%.*s%*s|\", bytes, b1, fieldwidth-(int)width, \"\");\n\t\t}\n\n\t\ts = C (exif_mnote_data_get_value (n, i, b, TAG_VALUE_BUF));\n\t\tstrncpy (b2, s ? s : _(\"Unknown value\"), TAG_VALUE_BUF);\n\t\tb2[sizeof(b2)-1] = 0;\n        \tif (p.use_ids) {\n\t\t\tfputs (b2, stdout);\n        \t} else {\n\t\t\tfieldwidth = width = p.width-22;\n\t\t\tbytes = exif_mbstrlen(b2, &width);\n\t\t\tprintf (\"%.*s\", bytes, b2);\n\t\t}\n        \tfputc ('\\n', stdout);\n\t}\n}\n\nvoid\naction_tag_list (ExifData *ed, ExifParams p)\n{\n\tExifByteOrder order;\n\tconst char *s;\n\tint fieldwidth, bytes;\n\tsize_t width;\n\n\tif (!ed)\n\t\treturn;\n\n\torder = exif_data_get_byte_order (ed);\n\tprintf (_(\"EXIF tags in '%s' ('%s' byte order):\"), p.fin,\n\t\texif_byte_order_get_name (order));\n\tfputc ('\\n', stdout);\n\tprint_hline (p.use_ids, p.width);\n\n\tfieldwidth = width = p.use_ids ? 6 : 20;\n\ts = _(\"Tag\");\n\tbytes = exif_mbstrlen(s, &width);\n\tprintf (\"%.*s%*s\", bytes, s, fieldwidth-(int)width, \"\");\n\tfputc ('|', stdout);\n\n\tfieldwidth = width = p.use_ids ? p.width-8 : p.width-22;\n\ts = _(\"Value\");\n\tbytes = exif_mbstrlen(s, &width);\n\tprintf (\"%.*s\", bytes, s);\n        fputc ('\\n', stdout);\n        print_hline (p.use_ids, p.width);\n\n\tif (p.ifd < EXIF_IFD_COUNT)\n\t\t/* Show only a single IFD */\n\t\tshow_ifd(ed->ifd[p.ifd], &p);\n\telse\n\t\t/* Show contents of all IFDs */\n\t\texif_data_foreach_content (ed, show_ifd, &p);\n\n        print_hline (p.use_ids, p.width);\n        if (ed->size) {\n                printf (_(\"EXIF data contains a thumbnail \"\n\t\t\t  \"(%i bytes).\"), ed->size);\n                fputc ('\\n', stdout);\n        }\n}\n\nstatic void\nshow_entry_machine (ExifEntry *e, void *data)\n{\n\tunsigned int *ids = data;\n\tchar v[TAG_VALUE_BUF];\n\tExifIfd ifd = exif_entry_get_ifd (e);\n\n\tif (*ids) {\n\t\tfprintf (stdout, \"0x%04x\", e->tag);\n\t} else {\n\t\tfputs (CN (exif_tag_get_title_in_ifd (e->tag, ifd)), stdout);\n\t}\n\tfputc ('\\t', stdout);\n\tfputs (CN (exif_entry_get_value (e, v, sizeof (v))), stdout);\n\tfputc ('\\n', stdout);\n}\n\nstatic void\nshow_ifd_machine (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, show_entry_machine, data);\n}\n\nvoid\naction_tag_list_machine (ExifData *ed, ExifParams p)\n{\n\tif (!ed) return;\n\n\tif (p.ifd < EXIF_IFD_COUNT)\n\t\t/* Show only a single IFD */\n\t\tshow_ifd_machine(ed->ifd[p.ifd], &p.use_ids);\n\telse\n\t\t/* Show contents of all IFDs */\n\t\texif_data_foreach_content (ed, show_ifd_machine, &p.use_ids);\n\n\tif (ed->size)\n\t\tfprintf (stdout, _(\"ThumbnailSize\\t%i\\n\"), ed->size);\n}\n\n/*!\n * Replace characters which are invalid in an XML tag with safe characters\n * in place.\n */\nstatic inline void\nremove_bad_chars(char *s)\n{\n\twhile (*s) {\n\t\tif ((*s == '(') || (*s == ')') || (*s == ' '))\n\t\t\t*s = '_';\n\t\t++s;\n\t}\n}\n\n/*!\n * Escape any special XML characters in the text and return a new static string\n * buffer.\n */\nstatic const char *\nescape_xml(const char *text)\n{\n\tstatic char *escaped;\n\tstatic size_t escaped_size;\n\tchar *out;\n\tsize_t len;\n\n\tif (!strlen(text)) return \"\";\n\n\tfor (out=escaped, len=0; *text; ++len, ++out, ++text) {\n\t\t/* Make sure there's plenty of room for a quoted character */\n\t\tif ((len + 8) > escaped_size) {\n\t\t\tchar *bigger_escaped;\n\t\t\tescaped_size += 128;\n\t\t\tbigger_escaped = realloc(escaped, escaped_size);\n\t\t\tif (!bigger_escaped) {\n\t\t\t\tfree(escaped);\t/* avoid leaking memory */\n\t\t\t\tescaped = NULL;\n\t\t\t\tescaped_size = 0;\n\t\t\t\t/* Error string is cleverly chosen to fail XML validation */\n\t\t\t\treturn \">>> out of memory <<<\";\n\t\t\t}\n\t\t\tout = bigger_escaped + len;\n\t\t\tescaped = bigger_escaped;\n\t\t}\n\t\tswitch (*text) {\n\t\t\tcase '&':\n\t\t\t\tstrcpy(out, \"&amp;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '<':\n\t\t\t\tstrcpy(out, \"&lt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tcase '>':\n\t\t\t\tstrcpy(out, \"&gt;\");\n\t\t\t\tlen += strlen(out) - 1;\n\t\t\t\tout = escaped + len;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t*out = *text;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t*out = '\\x0';  /* NUL terminate the string */\n\treturn escaped;\n}\n\nstatic void\nshow_entry_xml (ExifEntry *e, void *data)\n{\n\tunsigned char *ids = data;\n\tchar v[TAG_VALUE_BUF], t[TAG_VALUE_BUF];\n\n\tif (*ids) {\n\t\tfprintf (stdout, \"<x%04x>\", e->tag);\n\t\tfprintf (stdout, \"%s\", escape_xml(exif_entry_get_value (e, v, sizeof (v))));\n\t\tfprintf (stdout, \"</x%04x>\", e->tag);\n\t} else {\n\t\tstrncpy (t, exif_tag_get_title_in_ifd(e->tag, exif_entry_get_ifd(e)), sizeof (t));\n\t\tt[sizeof(t)-1] = 0;\n\n\t\t/* Remove invalid characters from tag eg. (, ), space */\n\t\tremove_bad_chars(t);\n\n\t\tfprintf (stdout, \"\\t<%s>\", t);\n\t\tfprintf (stdout, \"%s\", escape_xml(exif_entry_get_value (e, v, sizeof (v))));\n\t\tfprintf (stdout, \"</%s>\\n\", t);\n\t}\n}\n\nstatic void\nshow_xml (ExifContent *content, void *data)\n{\n\texif_content_foreach_entry (content, show_entry_xml, data);\n}\n\nvoid\naction_tag_list_xml (ExifData *ed, ExifParams p)\n{\n\tif (!ed) return;\n\n\tfprintf(stdout, \"<exif>\\n\");\n\tif (p.ifd < EXIF_IFD_COUNT)\n\t\t/* Show only a single IFD */\n\t\tshow_xml(ed->ifd[p.ifd], &p.use_ids);\n\telse\n\t\t/* Show contents of all IFDs */\n\t\texif_data_foreach_content (ed, show_xml, &p.use_ids);\n\tfprintf(stdout, \"</exif>\\n\");\n}\n"], "filenames": ["exif/actions.c"], "buggy_code_start_loc": [664], "buggy_code_end_loc": [665], "fixing_code_start_loc": [664], "fixing_code_end_loc": [665], "type": "CWE-476", "message": "NULL Pointer Deference in the exif command line tool, when printing out XML formatted EXIF data, in exif v0.6.22 and earlier allows attackers to cause a Denial of Service (DoS) by uploading a malicious JPEG file, causing the application to crash.", "other": {"cve": {"id": "CVE-2021-27815", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-14T14:15:13.787", "lastModified": "2022-11-04T15:24:53.003", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NULL Pointer Deference in the exif command line tool, when printing out XML formatted EXIF data, in exif v0.6.22 and earlier allows attackers to cause a Denial of Service (DoS) by uploading a malicious JPEG file, causing the application to crash."}, {"lang": "es", "value": "Una desreferencia de puntero NULL en la herramienta de l\u00ednea de comandos exif, al imprimir datos EXIF con formato XML, en exif versi\u00f3n v0.6.22 y anteriores permite a atacantes causar una Denegaci\u00f3n de Servicio (DoS) al cargar un archivo JPEG malicioso, causando que la aplicaci\u00f3n se bloquee"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libexif_project:exif:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.6.22", "matchCriteriaId": "F50641F5-B6E2-440C-8737-9E153C8BB3DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}], "references": [{"url": "https://github.com/libexif/exif/commit/eb84b0e3c5f2a86013b6fcfb800d187896a648fa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libexif/exif/commit/f6334d9d32437ef13dc902f0a88a2be0063d9d1c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/libexif/exif/issues/4", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JSWAXZVNXYLV3E4R6YQTEGRGMGWEAR76/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/QMC6OTXZRPCUD3LOSWO4ISR7CH7NJQDT/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YZQ3L45F7S7PQPG5HEHXOCGNOO64MJOS/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-28", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libexif/exif/commit/eb84b0e3c5f2a86013b6fcfb800d187896a648fa"}}