{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.skinx.internal;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.utils.URLEncodedUtils;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.url.filesystem.FilesystemExportContext;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.model.LegacySpaceResolver;\nimport com.xpn.xwiki.web.ExportURLFactoryActionHandler;\nimport com.xpn.xwiki.web.sx.Extension;\nimport com.xpn.xwiki.web.sx.SxDocumentSource;\nimport com.xpn.xwiki.web.sx.SxResourceSource;\nimport com.xpn.xwiki.web.sx.SxSource;\n\n/**\n * Handles SX URL rewriting, by extracting and rendering the SX content in a file on disk and generating a URL\n * pointing to it.\n *\n * @version $Id$\n * @since 6.2RC1\n */\npublic abstract class AbstractSxExportURLFactoryActionHandler implements ExportURLFactoryActionHandler\n{\n    /** If the user passes this parameter in the URL, we will look for the script in the jar files. */\n    private static final String JAR_RESOURCE_REQUEST_PARAMETER = \"resource\";\n\n    private static final char URL_PATH_SEPARATOR = '/';\n\n    @Inject\n    private LegacySpaceResolver legacySpaceResolve;\n\n    @Inject\n    private ContextualAuthorizationManager authorizationManager;\n\n    protected abstract String getSxPrefix();\n\n    protected abstract String getFileSuffix();\n\n    /**\n     * Get the type of extension, depends on the type of action.\n     *\n     * @return a new object which extends Extension.\n     */\n    public abstract Extension getExtensionType();\n\n    @Override\n    public URL createURL(String spaces, String name, String queryString, String anchor, String wikiId,\n        XWikiContext context, FilesystemExportContext exportContext) throws Exception\n    {\n        // Check if the current user has the right to view the SX file. We do this since this is what would happen\n        // in XE when a SX action is called (check done in XWikiAction).\n        // Note that we cannot just open an HTTP connection to the SX action here since we wouldn't be authenticated...\n        // Thus we have to simulate the same behavior as the SX action...\n\n        List<String> spaceNames = this.legacySpaceResolve.resolve(spaces);\n        DocumentReference sxDocumentReference = new DocumentReference(wikiId, spaceNames, name);\n        this.authorizationManager.checkAccess(Right.VIEW, sxDocumentReference);\n\n        // Set the SX document as the current document in the XWiki Context since unfortunately the SxSource code\n        // uses the current document in the context instead of accepting it as a parameter...\n        XWikiDocument sxDocument = context.getWiki().getDocument(sxDocumentReference, context);\n\n        Map<String, Object> backup = new HashMap<>();\n        XWikiDocument.backupContext(backup, context);\n        try {\n            sxDocument.setAsContextDoc(context);\n            return processSx(spaceNames, name, queryString, context, exportContext);\n        } finally {\n            XWikiDocument.restoreContext(backup, context);\n        }\n    }\n\n    private URL processSx(List<String> spaceNames, String name, String queryString, XWikiContext context,\n        FilesystemExportContext exportContext) throws Exception\n    {\n        SxSource sxSource = null;\n\n        // Check if we have the JAR_RESOURCE_REQUEST_PARAMETER parameter in the query string\n        List<NameValuePair> params = URLEncodedUtils.parse(queryString, StandardCharsets.UTF_8);\n        for (NameValuePair param : params) {\n            if (param.getName().equals(JAR_RESOURCE_REQUEST_PARAMETER)) {\n                sxSource = new SxResourceSource(param.getValue());\n                break;\n            }\n        }\n\n        if (sxSource == null) {\n            sxSource = new SxDocumentSource(context, getExtensionType());\n        }\n\n        String content = getContent(sxSource, exportContext);\n\n        // Write the content to file\n        // We need a unique name for that SSX content\n        String targetPath = String.format(\"%s/%s/%s\", getSxPrefix(), StringUtils.join(spaceNames, '/'), name);\n        File targetDirectory = new File(exportContext.getExportDir(), targetPath);\n        if (!targetDirectory.exists()) {\n            targetDirectory.mkdirs();\n        }\n        File targetLocation = File.createTempFile(getSxPrefix(), \".\" + getFileSuffix(), targetDirectory);\n        FileUtils.writeStringToFile(targetLocation, content);\n\n        // Rewrite the URL\n        StringBuilder path = new StringBuilder(\"file://\");\n\n        // Adjust based on current document's location. We need to account for the fact that the current document\n        // is stored in subdirectories inside the top level \"pages\" directory. Since the SX files are also in top\n        // subdirectories, we need to compute the path to them.\n        path.append(StringUtils.repeat(\"../\", exportContext.getDocParentLevel()));\n\n        path.append(getSxPrefix());\n        path.append(URL_PATH_SEPARATOR);\n        for (String spaceName : spaceNames) {\n            path.append(encodeURLPart(spaceName));\n            path.append(URL_PATH_SEPARATOR);\n        }\n        path.append(encodeURLPart(name));\n        path.append(URL_PATH_SEPARATOR);\n        path.append(encodeURLPart(targetLocation.getName()));\n\n        return new URL(path.toString());\n    }\n\n    protected String getContent(SxSource sxSource, FilesystemExportContext exportContext)\n    {\n        String content;\n\n        // We know we're inside a SX file located at \"<S|J>sx/<Space>/<Page>/<s|j>sx<NNN>.<css|js>\". Inside this CSS\n        // there can be URLs and we need to ensure that the prefix for these URLs lead to the root of the path, i.e.\n        // 3 levels up (\"../../../\").\n        // To make this happen we reuse the Doc Parent Level from FileSystemExportContext to a fixed value of 3.\n        // We also make sure to put back the original value\n        int originalDocParentLevel = exportContext.getDocParentLevel();\n        try {\n            exportContext.setDocParentLevels(3);\n            content = sxSource.getContent();\n        } finally {\n            exportContext.setDocParentLevels(originalDocParentLevel);\n        }\n\n        return content;\n    }\n\n    private String encodeURLPart(String part) throws IOException\n    {\n        return URLEncoder.encode(part, \"UTF-8\");\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.skinx.internal;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.inject.Inject;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.utils.URLEncodedUtils;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.security.authorization.ContextualAuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.url.filesystem.FilesystemExportContext;\n\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.internal.model.LegacySpaceResolver;\nimport com.xpn.xwiki.web.ExportURLFactoryActionHandler;\nimport com.xpn.xwiki.web.sx.Extension;\nimport com.xpn.xwiki.web.sx.SxDocumentSource;\nimport com.xpn.xwiki.web.sx.SxResourceSource;\nimport com.xpn.xwiki.web.sx.SxSource;\n\n/**\n * Handles SX URL rewriting, by extracting and rendering the SX content in a file on disk and generating a URL\n * pointing to it.\n *\n * @version $Id$\n * @since 6.2RC1\n */\npublic abstract class AbstractSxExportURLFactoryActionHandler implements ExportURLFactoryActionHandler\n{\n    /** If the user passes this parameter in the URL, we will look for the script in the jar files. */\n    private static final String JAR_RESOURCE_REQUEST_PARAMETER = \"resource\";\n\n    private static final char URL_PATH_SEPARATOR = '/';\n\n    @Inject\n    private LegacySpaceResolver legacySpaceResolve;\n\n    @Inject\n    private ContextualAuthorizationManager authorizationManager;\n\n    protected abstract String getSxPrefix();\n\n    protected abstract String getFileSuffix();\n\n    /**\n     * Get the type of extension, depends on the type of action.\n     *\n     * @return a new object which extends Extension.\n     */\n    public abstract Extension getExtensionType();\n\n    @Override\n    public URL createURL(String spaces, String name, String queryString, String anchor, String wikiId,\n        XWikiContext context, FilesystemExportContext exportContext) throws Exception\n    {\n        // Check if the current user has the right to view the SX file. We do this since this is what would happen\n        // in XE when a SX action is called (check done in XWikiAction).\n        // Note that we cannot just open an HTTP connection to the SX action here since we wouldn't be authenticated...\n        // Thus we have to simulate the same behavior as the SX action...\n\n        List<String> spaceNames = this.legacySpaceResolve.resolve(spaces);\n        DocumentReference sxDocumentReference = new DocumentReference(wikiId, spaceNames, name);\n        this.authorizationManager.checkAccess(Right.VIEW, sxDocumentReference);\n\n        // Set the SX document as the current document in the XWiki Context since unfortunately the SxSource code\n        // uses the current document in the context instead of accepting it as a parameter...\n        XWikiDocument sxDocument = context.getWiki().getDocument(sxDocumentReference, context);\n\n        Map<String, Object> backup = new HashMap<>();\n        XWikiDocument.backupContext(backup, context);\n        try {\n            sxDocument.setAsContextDoc(context);\n            return processSx(sxDocument.getId(), queryString, context, exportContext);\n        } finally {\n            XWikiDocument.restoreContext(backup, context);\n        }\n    }\n\n    private URL processSx(long id, String queryString, XWikiContext context,\n        FilesystemExportContext exportContext) throws Exception\n    {\n        SxSource sxSource = null;\n\n        // Check if we have the JAR_RESOURCE_REQUEST_PARAMETER parameter in the query string\n        List<NameValuePair> params = URLEncodedUtils.parse(queryString, StandardCharsets.UTF_8);\n        for (NameValuePair param : params) {\n            if (param.getName().equals(JAR_RESOURCE_REQUEST_PARAMETER)) {\n                sxSource = new SxResourceSource(param.getValue());\n                break;\n            }\n        }\n\n        if (sxSource == null) {\n            sxSource = new SxDocumentSource(context, getExtensionType());\n        }\n\n        String content = getContent(sxSource, exportContext);\n\n        // Write the content to file\n        // We need a unique name for that SSX content\n        String targetPath = String.format(\"%s/%s\", getSxPrefix(), id);\n        File targetDirectory = new File(exportContext.getExportDir(), targetPath);\n        if (!targetDirectory.exists()) {\n            targetDirectory.mkdirs();\n        }\n        File targetLocation = File.createTempFile(getSxPrefix(), \".\" + getFileSuffix(), targetDirectory);\n        FileUtils.writeStringToFile(targetLocation, content);\n\n        // Rewrite the URL\n        StringBuilder path = new StringBuilder(\"file://\");\n\n        // Adjust based on current document's location. We need to account for the fact that the current document\n        // is stored in subdirectories inside the top level \"pages\" directory. Since the SX files are also in top\n        // subdirectories, we need to compute the path to them.\n        path.append(StringUtils.repeat(\"../\", exportContext.getDocParentLevel()));\n\n        path.append(getSxPrefix());\n        path.append(URL_PATH_SEPARATOR);\n        path.append(id);\n        path.append(URL_PATH_SEPARATOR);\n        path.append(encodeURLPart(targetLocation.getName()));\n\n        return new URL(path.toString());\n    }\n\n    protected String getContent(SxSource sxSource, FilesystemExportContext exportContext)\n    {\n        String content;\n\n        // We know we're inside a SX file located at \"<S|J>sx/<id>/<s|j>sx<NNN>.<css|js>\". Inside this CSS\n        // there can be URLs and we need to ensure that the prefix for these URLs lead to the root of the path, i.e.\n        // 3 levels up (\"../../\").\n        // To make this happen we reuse the Doc Parent Level from FileSystemExportContext to a fixed value of 3.\n        // We also make sure to put back the original value\n        int originalDocParentLevel = exportContext.getDocParentLevel();\n        try {\n            exportContext.setDocParentLevels(2);\n            content = sxSource.getContent();\n        } finally {\n            exportContext.setDocParentLevels(originalDocParentLevel);\n        }\n\n        return content;\n    }\n\n    private String encodeURLPart(String part) throws IOException\n    {\n        return URLEncoder.encode(part, \"UTF-8\");\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-skin/xwiki-platform-skin-skinx/src/main/java/org/xwiki/skinx/internal/AbstractSxExportURLFactoryActionHandler.java"], "buggy_code_start_loc": [103], "buggy_code_end_loc": [172], "fixing_code_start_loc": [103], "fixing_code_end_loc": [168], "type": "CWE-22", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions AbstractSxExportURLFactoryActionHandler#processSx does not escape anything from SSX document references when serializing it on filesystem, it is possible to for the HTML export process to contain reference elements containing filesystem syntax like \"../\", \"./\". or \"/\" in general. The referenced elements are not properly escaped. This issue has been resolved in version 13.6-rc-1. This issue can be worked around by limiting or disabling document export.", "other": {"cve": {"id": "CVE-2022-23620", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-09T22:15:07.420", "lastModified": "2022-02-16T15:15:51.783", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. In affected versions AbstractSxExportURLFactoryActionHandler#processSx does not escape anything from SSX document references when serializing it on filesystem, it is possible to for the HTML export process to contain reference elements containing filesystem syntax like \"../\", \"./\". or \"/\" in general. The referenced elements are not properly escaped. This issue has been resolved in version 13.6-rc-1. This issue can be worked around by limiting or disabling document export."}, {"lang": "es", "value": "XWiki Platform es una plataforma wiki gen\u00e9rica que ofrece servicios de tiempo de ejecuci\u00f3n para las aplicaciones construidas sobre ella. En las versiones afectadas AbstractSxExportURLFactoryActionHandler#processSx no escapa nada de las referencias de los documentos SSX cuando los serializa en el sistema de ficheros, es posible que el proceso de exportaci\u00f3n HTML contenga elementos de referencia que contengan sintaxis del sistema de ficheros como \"../\", \"./\". o \"/\" en general. Los elementos referenciados no son escapados apropiadamente. Este problema ha sido resuelto en versi\u00f3n 13.6-rc-1. Este problema puede mitigarse limitando o deshabilitando la exportaci\u00f3n de documentos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:C/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.0, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionEndIncluding": "13.6", "matchCriteriaId": "768B0583-1A6C-4E1D-9061-9B39BBBF67AB"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/ab778254fb8f71c774e1c1239368c44fe3b6bba5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-7ph6-5cmq-xgjq", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-18819", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/ab778254fb8f71c774e1c1239368c44fe3b6bba5"}}