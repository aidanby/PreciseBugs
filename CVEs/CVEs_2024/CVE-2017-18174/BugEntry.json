{"buggy_code": ["/*\n * GPIO driver for AMD\n *\n * Copyright (c) 2014,2015 AMD Corporation.\n * Authors: Ken Xue <Ken.Xue@amd.com>\n *      Wu, Jeff <Jeff.Wu@amd.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n */\n\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n#include <linux/gpio.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/acpi.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n\n#include \"pinctrl-utils.h\"\n#include \"pinctrl-amd.h\"\n\nstatic int amd_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tunsigned long flags;\n\tu32 pin_reg;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\t/*\n\t * Suppose BIOS or Bootloader sets specific debounce for the\n\t * GPIO. if not, set debounce to be  2.75ms and remove glitch.\n\t*/\n\tif ((pin_reg & DB_TMR_OUT_MASK) == 0) {\n\t\tpin_reg |= 0xf;\n\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t}\n\n\tpin_reg &= ~BIT(OUTPUT_ENABLE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\tint value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tpin_reg |= BIT(OUTPUT_ENABLE_OFF);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn !!(pin_reg & BIT(PIN_STS_OFF));\n}\n\nstatic void amd_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_set_debounce(struct gpio_chip *gc, unsigned offset,\n\t\tunsigned debounce)\n{\n\tu32 time;\n\tu32 pin_reg;\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\n\tif (debounce) {\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t/*\n\t\tDebounce\tDebounce\tTimer\tMax\n\t\tTmrLarge\tTmrOutUnit\tUnit\tDebounce\n\t\t\t\t\t\t\tTime\n\t\t0\t0\t61 usec (2 RtcClk)\t976 usec\n\t\t0\t1\t244 usec (8 RtcClk)\t3.9 msec\n\t\t1\t0\t15.6 msec (512 RtcClk)\t250 msec\n\t\t1\t1\t62.5 msec (2048 RtcClk)\t1 sec\n\t\t*/\n\n\t\tif (debounce < 61) {\n\t\t\tpin_reg |= 1;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 976) {\n\t\t\ttime = debounce / 61;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 3900) {\n\t\t\ttime = debounce / 244;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 250000) {\n\t\t\ttime = debounce / 15600;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 1000000) {\n\t\t\ttime = debounce / 62500;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else {\n\t\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t}\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void amd_gpio_dbg_show(struct seq_file *s, struct gpio_chip *gc)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tunsigned int bank, i, pin_num;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tchar *level_trig;\n\tchar *active_level;\n\tchar *interrupt_enable;\n\tchar *interrupt_mask;\n\tchar *wake_cntrl0;\n\tchar *wake_cntrl1;\n\tchar *wake_cntrl2;\n\tchar *pin_sts;\n\tchar *pull_up_sel;\n\tchar *pull_up_enable;\n\tchar *pull_down_enable;\n\tchar *output_value;\n\tchar *output_enable;\n\n\tfor (bank = 0; bank < AMD_GPIO_TOTAL_BANKS; bank++) {\n\t\tseq_printf(s, \"GPIO bank%d\\t\", bank);\n\n\t\tswitch (bank) {\n\t\tcase 0:\n\t\t\ti = 0;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti = 64;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK1 + i;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ti = 128;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK2 + i;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (; i < pin_num; i++) {\n\t\t\tseq_printf(s, \"pin%d\\t\", i);\n\t\t\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\t\t\tpin_reg = readl(gpio_dev->base + i * 4);\n\t\t\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\t\t\tif (pin_reg & BIT(INTERRUPT_ENABLE_OFF)) {\n\t\t\t\tinterrupt_enable = \"interrupt is enabled|\";\n\n\t\t\t\tif (!(pin_reg & BIT(ACTIVE_LEVEL_OFF))\n\t\t\t\t&& !(pin_reg & BIT(ACTIVE_LEVEL_OFF+1)))\n\t\t\t\t\tactive_level = \"Active low|\";\n\t\t\t\telse if (pin_reg & BIT(ACTIVE_LEVEL_OFF)\n\t\t\t\t&& !(pin_reg & BIT(ACTIVE_LEVEL_OFF+1)))\n\t\t\t\t\tactive_level = \"Active high|\";\n\t\t\t\telse if (!(pin_reg & BIT(ACTIVE_LEVEL_OFF))\n\t\t\t\t\t&& pin_reg & BIT(ACTIVE_LEVEL_OFF+1))\n\t\t\t\t\tactive_level = \"Active on both|\";\n\t\t\t\telse\n\t\t\t\t\tactive_level = \"Unknow Active level|\";\n\n\t\t\t\tif (pin_reg & BIT(LEVEL_TRIG_OFF))\n\t\t\t\t\tlevel_trig = \"Level trigger|\";\n\t\t\t\telse\n\t\t\t\t\tlevel_trig = \"Edge trigger|\";\n\n\t\t\t} else {\n\t\t\t\tinterrupt_enable =\n\t\t\t\t\t\"interrupt is disabled|\";\n\t\t\t\tactive_level = \" \";\n\t\t\t\tlevel_trig = \" \";\n\t\t\t}\n\n\t\t\tif (pin_reg & BIT(INTERRUPT_MASK_OFF))\n\t\t\t\tinterrupt_mask =\n\t\t\t\t\t\"interrupt is unmasked|\";\n\t\t\telse\n\t\t\t\tinterrupt_mask =\n\t\t\t\t\t\"interrupt is masked|\";\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF))\n\t\t\t\twake_cntrl0 = \"enable wakeup in S0i3 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl0 = \"disable wakeup in S0i3 state|\";\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF))\n\t\t\t\twake_cntrl1 = \"enable wakeup in S3 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl1 = \"disable wakeup in S3 state|\";\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF))\n\t\t\t\twake_cntrl2 = \"enable wakeup in S4/S5 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl2 = \"disable wakeup in S4/S5 state|\";\n\n\t\t\tif (pin_reg & BIT(PULL_UP_ENABLE_OFF)) {\n\t\t\t\tpull_up_enable = \"pull-up is enabled|\";\n\t\t\t\tif (pin_reg & BIT(PULL_UP_SEL_OFF))\n\t\t\t\t\tpull_up_sel = \"8k pull-up|\";\n\t\t\t\telse\n\t\t\t\t\tpull_up_sel = \"4k pull-up|\";\n\t\t\t} else {\n\t\t\t\tpull_up_enable = \"pull-up is disabled|\";\n\t\t\t\tpull_up_sel = \" \";\n\t\t\t}\n\n\t\t\tif (pin_reg & BIT(PULL_DOWN_ENABLE_OFF))\n\t\t\t\tpull_down_enable = \"pull-down is enabled|\";\n\t\t\telse\n\t\t\t\tpull_down_enable = \"Pull-down is disabled|\";\n\n\t\t\tif (pin_reg & BIT(OUTPUT_ENABLE_OFF)) {\n\t\t\t\tpin_sts = \" \";\n\t\t\t\toutput_enable = \"output is enabled|\";\n\t\t\t\tif (pin_reg & BIT(OUTPUT_VALUE_OFF))\n\t\t\t\t\toutput_value = \"output is high|\";\n\t\t\t\telse\n\t\t\t\t\toutput_value = \"output is low|\";\n\t\t\t} else {\n\t\t\t\toutput_enable = \"output is disabled|\";\n\t\t\t\toutput_value = \" \";\n\n\t\t\t\tif (pin_reg & BIT(PIN_STS_OFF))\n\t\t\t\t\tpin_sts = \"input is high|\";\n\t\t\t\telse\n\t\t\t\t\tpin_sts = \"input is low|\";\n\t\t\t}\n\n\t\t\tseq_printf(s, \"%s %s %s %s %s %s\\n\"\n\t\t\t\t\" %s %s %s %s %s %s %s 0x%x\\n\",\n\t\t\t\tlevel_trig, active_level, interrupt_enable,\n\t\t\t\tinterrupt_mask, wake_cntrl0, wake_cntrl1,\n\t\t\t\twake_cntrl2, pin_sts, pull_up_sel,\n\t\t\t\tpull_up_enable, pull_down_enable,\n\t\t\t\toutput_value, output_enable, pin_reg);\n\t\t}\n\t}\n}\n#else\n#define amd_gpio_dbg_show NULL\n#endif\n\nstatic void amd_gpio_irq_enable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\t/*\n\t\tSuppose BIOS or Bootloader sets specific debounce for the\n\t\tGPIO. if not, set debounce to be  2.75ms.\n\t*/\n\tif ((pin_reg & DB_TMR_OUT_MASK) == 0) {\n\t\tpin_reg |= 0xf;\n\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t}\n\tpin_reg |= BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg |= BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_disable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_mask(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_unmask(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg |= BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_eoi(struct irq_data *d)\n{\n\tu32 reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\treg |= EOI_MASK;\n\twritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= BOTH_EADGE << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\tpin_reg |= DB_TYPE_PRESERVE_LOW_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\tpin_reg |= DB_TYPE_PRESERVE_HIGH_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_NONE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&gpio_dev->pdev->dev, \"Invalid type value\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tpin_reg |= CLR_INTR_STAT << INTERRUPT_STS_OFF;\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic void amd_irq_ack(struct irq_data *d)\n{\n\t/*\n\t * based on HW design,there is no need to ack HW\n\t * before handle current irq. But this routine is\n\t * necessary for handle_edge_irq\n\t*/\n}\n\nstatic struct irq_chip amd_gpio_irqchip = {\n\t.name         = \"amd_gpio\",\n\t.irq_ack      = amd_irq_ack,\n\t.irq_enable   = amd_gpio_irq_enable,\n\t.irq_disable  = amd_gpio_irq_disable,\n\t.irq_mask     = amd_gpio_irq_mask,\n\t.irq_unmask   = amd_gpio_irq_unmask,\n\t.irq_eoi      = amd_gpio_irq_eoi,\n\t.irq_set_type = amd_gpio_irq_set_type,\n};\n\nstatic void amd_gpio_irq_handler(struct irq_desc *desc)\n{\n\tu32 i;\n\tu32 off;\n\tu32 reg;\n\tu32 pin_reg;\n\tu64 reg64;\n\tint handled = 0;\n\tunsigned int irq;\n\tunsigned long flags;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tchained_irq_enter(chip, desc);\n\t/*enable GPIO interrupt again*/\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_STATUS_REG1);\n\treg64 = reg;\n\treg64 = reg64 << 32;\n\n\treg = readl(gpio_dev->base + WAKE_INT_STATUS_REG0);\n\treg64 |= reg;\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\t/*\n\t * first 46 bits indicates interrupt status.\n\t * one bit represents four interrupt sources.\n\t*/\n\tfor (off = 0; off < 46 ; off++) {\n\t\tif (reg64 & BIT(off)) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tpin_reg = readl(gpio_dev->base +\n\t\t\t\t\t\t(off * 4 + i) * 4);\n\t\t\t\tif ((pin_reg & BIT(INTERRUPT_STS_OFF)) ||\n\t\t\t\t\t(pin_reg & BIT(WAKE_STS_OFF))) {\n\t\t\t\t\tirq = irq_find_mapping(gc->irqdomain,\n\t\t\t\t\t\t\t\toff * 4 + i);\n\t\t\t\t\tgeneric_handle_irq(irq);\n\t\t\t\t\twritel(pin_reg,\n\t\t\t\t\t\tgpio_dev->base\n\t\t\t\t\t\t+ (off * 4 + i) * 4);\n\t\t\t\t\thandled++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (handled == 0)\n\t\thandle_bad_irq(desc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\treg |= EOI_MASK;\n\twritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int amd_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn gpio_dev->ngroups;\n}\n\nstatic const char *amd_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn gpio_dev->groups[group].name;\n}\n\nstatic int amd_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned group,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *num_pins)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = gpio_dev->groups[group].pins;\n\t*num_pins = gpio_dev->groups[group].npins;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops amd_pinctrl_ops = {\n\t.get_groups_count\t= amd_get_groups_count,\n\t.get_group_name\t\t= amd_get_group_name,\n\t.get_group_pins\t\t= amd_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n#endif\n};\n\nstatic int amd_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned int pin,\n\t\t\t  unsigned long *config)\n{\n\tu32 pin_reg;\n\tunsigned arg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + pin*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\targ = pin_reg & DB_TMR_OUT_MASK;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\targ = (pin_reg >> PULL_DOWN_ENABLE_OFF) & BIT(0);\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\targ = (pin_reg >> PULL_UP_SEL_OFF) & (BIT(0) | BIT(1));\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = (pin_reg >> DRV_STRENGTH_SEL_OFF) & DRV_STRENGTH_SEL_MASK;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&gpio_dev->pdev->dev, \"Invalid config param %04x\\n\",\n\t\t\tparam);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int amd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned num_configs)\n{\n\tint i;\n\tu32 arg;\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tenum pin_config_param param;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\t\tpin_reg = readl(gpio_dev->base + pin*4);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= arg & DB_TMR_OUT_MASK;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tpin_reg &= ~BIT(PULL_DOWN_ENABLE_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_DOWN_ENABLE_OFF;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpin_reg &= ~BIT(PULL_UP_SEL_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_UP_SEL_OFF;\n\t\t\tpin_reg &= ~BIT(PULL_UP_ENABLE_OFF);\n\t\t\tpin_reg |= ((arg>>1) & BIT(0)) << PULL_UP_ENABLE_OFF;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tpin_reg &= ~(DRV_STRENGTH_SEL_MASK\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF);\n\t\t\tpin_reg |= (arg & DRV_STRENGTH_SEL_MASK)\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&gpio_dev->pdev->dev,\n\t\t\t\t\"Invalid config param %04x\\n\", param);\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\n\t\twritel(pin_reg, gpio_dev->base + pin*4);\n\t}\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int amd_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *config)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint ret;\n\n\tret = amd_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tif (amd_pinconf_get(pctldev, pins[0], config))\n\t\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic int amd_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned group, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint i, ret;\n\n\tret = amd_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < npins; i++) {\n\t\tif (amd_pinconf_set(pctldev, pins[i], configs, num_configs))\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic const struct pinconf_ops amd_pinconf_ops = {\n\t.pin_config_get\t\t= amd_pinconf_get,\n\t.pin_config_set\t\t= amd_pinconf_set,\n\t.pin_config_group_get = amd_pinconf_group_get,\n\t.pin_config_group_set = amd_pinconf_group_set,\n};\n\nstatic struct pinctrl_desc amd_pinctrl_desc = {\n\t.pins\t= kerncz_pins,\n\t.npins = ARRAY_SIZE(kerncz_pins),\n\t.pctlops = &amd_pinctrl_ops,\n\t.confops = &amd_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&gpio_dev->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t\t= 0;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= TOTAL_NUMBER_OF_PINS;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\n\tgpio_dev->groups = kerncz_groups;\n\tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n\n\tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,\n\t\t\t\t\t&pdev->dev, gpio_dev);\n\tif (IS_ERR(gpio_dev->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(gpio_dev->pctrl);\n\t}\n\n\tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n\tif (ret)\n\t\tgoto out1;\n\n\tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n\t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\nout2:\n\tgpiochip_remove(&gpio_dev->gc);\n\nout1:\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn ret;\n}\n\nstatic int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id amd_gpio_acpi_match[] = {\n\t{ \"AMD0030\", 0 },\n\t{ \"AMDI0030\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, amd_gpio_acpi_match);\n\nstatic struct platform_driver amd_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"amd_gpio\",\n\t\t.acpi_match_table = ACPI_PTR(amd_gpio_acpi_match),\n\t},\n\t.probe\t\t= amd_gpio_probe,\n\t.remove\t\t= amd_gpio_remove,\n};\n\nmodule_platform_driver(amd_gpio_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Ken Xue <Ken.Xue@amd.com>, Jeff Wu <Jeff.Wu@amd.com>\");\nMODULE_DESCRIPTION(\"AMD GPIO pinctrl driver\");\n"], "fixing_code": ["/*\n * GPIO driver for AMD\n *\n * Copyright (c) 2014,2015 AMD Corporation.\n * Authors: Ken Xue <Ken.Xue@amd.com>\n *      Wu, Jeff <Jeff.Wu@amd.com>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n */\n\n#include <linux/err.h>\n#include <linux/bug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/compiler.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/log2.h>\n#include <linux/io.h>\n#include <linux/gpio.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/mutex.h>\n#include <linux/acpi.h>\n#include <linux/seq_file.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/bitops.h>\n#include <linux/pinctrl/pinconf.h>\n#include <linux/pinctrl/pinconf-generic.h>\n\n#include \"pinctrl-utils.h\"\n#include \"pinctrl-amd.h\"\n\nstatic int amd_gpio_direction_input(struct gpio_chip *gc, unsigned offset)\n{\n\tunsigned long flags;\n\tu32 pin_reg;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\t/*\n\t * Suppose BIOS or Bootloader sets specific debounce for the\n\t * GPIO. if not, set debounce to be  2.75ms and remove glitch.\n\t*/\n\tif ((pin_reg & DB_TMR_OUT_MASK) == 0) {\n\t\tpin_reg |= 0xf;\n\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t}\n\n\tpin_reg &= ~BIT(OUTPUT_ENABLE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_direction_output(struct gpio_chip *gc, unsigned offset,\n\t\tint value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tpin_reg |= BIT(OUTPUT_ENABLE_OFF);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int amd_gpio_get_value(struct gpio_chip *gc, unsigned offset)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn !!(pin_reg & BIT(PIN_STS_OFF));\n}\n\nstatic void amd_gpio_set_value(struct gpio_chip *gc, unsigned offset, int value)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\tif (value)\n\t\tpin_reg |= BIT(OUTPUT_VALUE_OFF);\n\telse\n\t\tpin_reg &= ~BIT(OUTPUT_VALUE_OFF);\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_set_debounce(struct gpio_chip *gc, unsigned offset,\n\t\tunsigned debounce)\n{\n\tu32 time;\n\tu32 pin_reg;\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + offset * 4);\n\n\tif (debounce) {\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t/*\n\t\tDebounce\tDebounce\tTimer\tMax\n\t\tTmrLarge\tTmrOutUnit\tUnit\tDebounce\n\t\t\t\t\t\t\tTime\n\t\t0\t0\t61 usec (2 RtcClk)\t976 usec\n\t\t0\t1\t244 usec (8 RtcClk)\t3.9 msec\n\t\t1\t0\t15.6 msec (512 RtcClk)\t250 msec\n\t\t1\t1\t62.5 msec (2048 RtcClk)\t1 sec\n\t\t*/\n\n\t\tif (debounce < 61) {\n\t\t\tpin_reg |= 1;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 976) {\n\t\t\ttime = debounce / 61;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 3900) {\n\t\t\ttime = debounce / 244;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 250000) {\n\t\t\ttime = debounce / 15600;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else if (debounce < 1000000) {\n\t\t\ttime = debounce / 62500;\n\t\t\tpin_reg |= time & DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\t\tpin_reg |= BIT(DB_TMR_LARGE_OFF);\n\t\t} else {\n\t\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tpin_reg &= ~BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\tpin_reg &= ~DB_CNTRl_MASK;\n\t}\n\twritel(pin_reg, gpio_dev->base + offset * 4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_DEBUG_FS\nstatic void amd_gpio_dbg_show(struct seq_file *s, struct gpio_chip *gc)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tunsigned int bank, i, pin_num;\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tchar *level_trig;\n\tchar *active_level;\n\tchar *interrupt_enable;\n\tchar *interrupt_mask;\n\tchar *wake_cntrl0;\n\tchar *wake_cntrl1;\n\tchar *wake_cntrl2;\n\tchar *pin_sts;\n\tchar *pull_up_sel;\n\tchar *pull_up_enable;\n\tchar *pull_down_enable;\n\tchar *output_value;\n\tchar *output_enable;\n\n\tfor (bank = 0; bank < AMD_GPIO_TOTAL_BANKS; bank++) {\n\t\tseq_printf(s, \"GPIO bank%d\\t\", bank);\n\n\t\tswitch (bank) {\n\t\tcase 0:\n\t\t\ti = 0;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ti = 64;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK1 + i;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ti = 128;\n\t\t\tpin_num = AMD_GPIO_PINS_BANK2 + i;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (; i < pin_num; i++) {\n\t\t\tseq_printf(s, \"pin%d\\t\", i);\n\t\t\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\t\t\tpin_reg = readl(gpio_dev->base + i * 4);\n\t\t\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\t\t\tif (pin_reg & BIT(INTERRUPT_ENABLE_OFF)) {\n\t\t\t\tinterrupt_enable = \"interrupt is enabled|\";\n\n\t\t\t\tif (!(pin_reg & BIT(ACTIVE_LEVEL_OFF))\n\t\t\t\t&& !(pin_reg & BIT(ACTIVE_LEVEL_OFF+1)))\n\t\t\t\t\tactive_level = \"Active low|\";\n\t\t\t\telse if (pin_reg & BIT(ACTIVE_LEVEL_OFF)\n\t\t\t\t&& !(pin_reg & BIT(ACTIVE_LEVEL_OFF+1)))\n\t\t\t\t\tactive_level = \"Active high|\";\n\t\t\t\telse if (!(pin_reg & BIT(ACTIVE_LEVEL_OFF))\n\t\t\t\t\t&& pin_reg & BIT(ACTIVE_LEVEL_OFF+1))\n\t\t\t\t\tactive_level = \"Active on both|\";\n\t\t\t\telse\n\t\t\t\t\tactive_level = \"Unknow Active level|\";\n\n\t\t\t\tif (pin_reg & BIT(LEVEL_TRIG_OFF))\n\t\t\t\t\tlevel_trig = \"Level trigger|\";\n\t\t\t\telse\n\t\t\t\t\tlevel_trig = \"Edge trigger|\";\n\n\t\t\t} else {\n\t\t\t\tinterrupt_enable =\n\t\t\t\t\t\"interrupt is disabled|\";\n\t\t\t\tactive_level = \" \";\n\t\t\t\tlevel_trig = \" \";\n\t\t\t}\n\n\t\t\tif (pin_reg & BIT(INTERRUPT_MASK_OFF))\n\t\t\t\tinterrupt_mask =\n\t\t\t\t\t\"interrupt is unmasked|\";\n\t\t\telse\n\t\t\t\tinterrupt_mask =\n\t\t\t\t\t\"interrupt is masked|\";\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF))\n\t\t\t\twake_cntrl0 = \"enable wakeup in S0i3 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl0 = \"disable wakeup in S0i3 state|\";\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF))\n\t\t\t\twake_cntrl1 = \"enable wakeup in S3 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl1 = \"disable wakeup in S3 state|\";\n\n\t\t\tif (pin_reg & BIT(WAKE_CNTRL_OFF))\n\t\t\t\twake_cntrl2 = \"enable wakeup in S4/S5 state|\";\n\t\t\telse\n\t\t\t\twake_cntrl2 = \"disable wakeup in S4/S5 state|\";\n\n\t\t\tif (pin_reg & BIT(PULL_UP_ENABLE_OFF)) {\n\t\t\t\tpull_up_enable = \"pull-up is enabled|\";\n\t\t\t\tif (pin_reg & BIT(PULL_UP_SEL_OFF))\n\t\t\t\t\tpull_up_sel = \"8k pull-up|\";\n\t\t\t\telse\n\t\t\t\t\tpull_up_sel = \"4k pull-up|\";\n\t\t\t} else {\n\t\t\t\tpull_up_enable = \"pull-up is disabled|\";\n\t\t\t\tpull_up_sel = \" \";\n\t\t\t}\n\n\t\t\tif (pin_reg & BIT(PULL_DOWN_ENABLE_OFF))\n\t\t\t\tpull_down_enable = \"pull-down is enabled|\";\n\t\t\telse\n\t\t\t\tpull_down_enable = \"Pull-down is disabled|\";\n\n\t\t\tif (pin_reg & BIT(OUTPUT_ENABLE_OFF)) {\n\t\t\t\tpin_sts = \" \";\n\t\t\t\toutput_enable = \"output is enabled|\";\n\t\t\t\tif (pin_reg & BIT(OUTPUT_VALUE_OFF))\n\t\t\t\t\toutput_value = \"output is high|\";\n\t\t\t\telse\n\t\t\t\t\toutput_value = \"output is low|\";\n\t\t\t} else {\n\t\t\t\toutput_enable = \"output is disabled|\";\n\t\t\t\toutput_value = \" \";\n\n\t\t\t\tif (pin_reg & BIT(PIN_STS_OFF))\n\t\t\t\t\tpin_sts = \"input is high|\";\n\t\t\t\telse\n\t\t\t\t\tpin_sts = \"input is low|\";\n\t\t\t}\n\n\t\t\tseq_printf(s, \"%s %s %s %s %s %s\\n\"\n\t\t\t\t\" %s %s %s %s %s %s %s 0x%x\\n\",\n\t\t\t\tlevel_trig, active_level, interrupt_enable,\n\t\t\t\tinterrupt_mask, wake_cntrl0, wake_cntrl1,\n\t\t\t\twake_cntrl2, pin_sts, pull_up_sel,\n\t\t\t\tpull_up_enable, pull_down_enable,\n\t\t\t\toutput_value, output_enable, pin_reg);\n\t\t}\n\t}\n}\n#else\n#define amd_gpio_dbg_show NULL\n#endif\n\nstatic void amd_gpio_irq_enable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\t/*\n\t\tSuppose BIOS or Bootloader sets specific debounce for the\n\t\tGPIO. if not, set debounce to be  2.75ms.\n\t*/\n\tif ((pin_reg & DB_TMR_OUT_MASK) == 0) {\n\t\tpin_reg |= 0xf;\n\t\tpin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);\n\t\tpin_reg &= ~BIT(DB_TMR_LARGE_OFF);\n\t}\n\tpin_reg |= BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg |= BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_disable(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_ENABLE_OFF);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_mask(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg &= ~BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_unmask(struct irq_data *d)\n{\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\tpin_reg |= BIT(INTERRUPT_MASK_OFF);\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic void amd_gpio_irq_eoi(struct irq_data *d)\n{\n\tu32 reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\treg |= EOI_MASK;\n\twritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n}\n\nstatic int amd_gpio_irq_set_type(struct irq_data *d, unsigned int type)\n{\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + (d->hwirq)*4);\n\n\tswitch (type & IRQ_TYPE_SENSE_MASK) {\n\tcase IRQ_TYPE_EDGE_RISING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_FALLING:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_EDGE_BOTH:\n\t\tpin_reg &= ~BIT(LEVEL_TRIG_OFF);\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= BOTH_EADGE << ACTIVE_LEVEL_OFF;\n\t\tpin_reg |= DB_TYPE_REMOVE_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_edge_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_HIGH:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_HIGH << ACTIVE_LEVEL_OFF;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\tpin_reg |= DB_TYPE_PRESERVE_LOW_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_LEVEL_LOW:\n\t\tpin_reg |= LEVEL_TRIGGER << LEVEL_TRIG_OFF;\n\t\tpin_reg &= ~(ACTIVE_LEVEL_MASK << ACTIVE_LEVEL_OFF);\n\t\tpin_reg |= ACTIVE_LOW << ACTIVE_LEVEL_OFF;\n\t\tpin_reg &= ~(DB_CNTRl_MASK << DB_CNTRL_OFF);\n\t\tpin_reg |= DB_TYPE_PRESERVE_HIGH_GLITCH << DB_CNTRL_OFF;\n\t\tirq_set_handler_locked(d, handle_level_irq);\n\t\tbreak;\n\n\tcase IRQ_TYPE_NONE:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&gpio_dev->pdev->dev, \"Invalid type value\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tpin_reg |= CLR_INTR_STAT << INTERRUPT_STS_OFF;\n\twritel(pin_reg, gpio_dev->base + (d->hwirq)*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic void amd_irq_ack(struct irq_data *d)\n{\n\t/*\n\t * based on HW design,there is no need to ack HW\n\t * before handle current irq. But this routine is\n\t * necessary for handle_edge_irq\n\t*/\n}\n\nstatic struct irq_chip amd_gpio_irqchip = {\n\t.name         = \"amd_gpio\",\n\t.irq_ack      = amd_irq_ack,\n\t.irq_enable   = amd_gpio_irq_enable,\n\t.irq_disable  = amd_gpio_irq_disable,\n\t.irq_mask     = amd_gpio_irq_mask,\n\t.irq_unmask   = amd_gpio_irq_unmask,\n\t.irq_eoi      = amd_gpio_irq_eoi,\n\t.irq_set_type = amd_gpio_irq_set_type,\n};\n\nstatic void amd_gpio_irq_handler(struct irq_desc *desc)\n{\n\tu32 i;\n\tu32 off;\n\tu32 reg;\n\tu32 pin_reg;\n\tu64 reg64;\n\tint handled = 0;\n\tunsigned int irq;\n\tunsigned long flags;\n\tstruct irq_chip *chip = irq_desc_get_chip(desc);\n\tstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\n\tstruct amd_gpio *gpio_dev = gpiochip_get_data(gc);\n\n\tchained_irq_enter(chip, desc);\n\t/*enable GPIO interrupt again*/\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_STATUS_REG1);\n\treg64 = reg;\n\treg64 = reg64 << 32;\n\n\treg = readl(gpio_dev->base + WAKE_INT_STATUS_REG0);\n\treg64 |= reg;\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\t/*\n\t * first 46 bits indicates interrupt status.\n\t * one bit represents four interrupt sources.\n\t*/\n\tfor (off = 0; off < 46 ; off++) {\n\t\tif (reg64 & BIT(off)) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tpin_reg = readl(gpio_dev->base +\n\t\t\t\t\t\t(off * 4 + i) * 4);\n\t\t\t\tif ((pin_reg & BIT(INTERRUPT_STS_OFF)) ||\n\t\t\t\t\t(pin_reg & BIT(WAKE_STS_OFF))) {\n\t\t\t\t\tirq = irq_find_mapping(gc->irqdomain,\n\t\t\t\t\t\t\t\toff * 4 + i);\n\t\t\t\t\tgeneric_handle_irq(irq);\n\t\t\t\t\twritel(pin_reg,\n\t\t\t\t\t\tgpio_dev->base\n\t\t\t\t\t\t+ (off * 4 + i) * 4);\n\t\t\t\t\thandled++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (handled == 0)\n\t\thandle_bad_irq(desc);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\treg = readl(gpio_dev->base + WAKE_INT_MASTER_REG);\n\treg |= EOI_MASK;\n\twritel(reg, gpio_dev->base + WAKE_INT_MASTER_REG);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\tchained_irq_exit(chip, desc);\n}\n\nstatic int amd_get_groups_count(struct pinctrl_dev *pctldev)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn gpio_dev->ngroups;\n}\n\nstatic const char *amd_get_group_name(struct pinctrl_dev *pctldev,\n\t\t\t\t      unsigned group)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\treturn gpio_dev->groups[group].name;\n}\n\nstatic int amd_get_group_pins(struct pinctrl_dev *pctldev,\n\t\t\t      unsigned group,\n\t\t\t      const unsigned **pins,\n\t\t\t      unsigned *num_pins)\n{\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\t*pins = gpio_dev->groups[group].pins;\n\t*num_pins = gpio_dev->groups[group].npins;\n\treturn 0;\n}\n\nstatic const struct pinctrl_ops amd_pinctrl_ops = {\n\t.get_groups_count\t= amd_get_groups_count,\n\t.get_group_name\t\t= amd_get_group_name,\n\t.get_group_pins\t\t= amd_get_group_pins,\n#ifdef CONFIG_OF\n\t.dt_node_to_map\t\t= pinconf_generic_dt_node_to_map_group,\n\t.dt_free_map\t\t= pinctrl_utils_free_map,\n#endif\n};\n\nstatic int amd_pinconf_get(struct pinctrl_dev *pctldev,\n\t\t\t  unsigned int pin,\n\t\t\t  unsigned long *config)\n{\n\tu32 pin_reg;\n\tunsigned arg;\n\tunsigned long flags;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\tenum pin_config_param param = pinconf_to_config_param(*config);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tpin_reg = readl(gpio_dev->base + pin*4);\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\tswitch (param) {\n\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\targ = pin_reg & DB_TMR_OUT_MASK;\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\targ = (pin_reg >> PULL_DOWN_ENABLE_OFF) & BIT(0);\n\t\tbreak;\n\n\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\targ = (pin_reg >> PULL_UP_SEL_OFF) & (BIT(0) | BIT(1));\n\t\tbreak;\n\n\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\targ = (pin_reg >> DRV_STRENGTH_SEL_OFF) & DRV_STRENGTH_SEL_MASK;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&gpio_dev->pdev->dev, \"Invalid config param %04x\\n\",\n\t\t\tparam);\n\t\treturn -ENOTSUPP;\n\t}\n\n\t*config = pinconf_to_config_packed(param, arg);\n\n\treturn 0;\n}\n\nstatic int amd_pinconf_set(struct pinctrl_dev *pctldev, unsigned int pin,\n\t\t\t\tunsigned long *configs, unsigned num_configs)\n{\n\tint i;\n\tu32 arg;\n\tint ret = 0;\n\tu32 pin_reg;\n\tunsigned long flags;\n\tenum pin_config_param param;\n\tstruct amd_gpio *gpio_dev = pinctrl_dev_get_drvdata(pctldev);\n\n\tspin_lock_irqsave(&gpio_dev->lock, flags);\n\tfor (i = 0; i < num_configs; i++) {\n\t\tparam = pinconf_to_config_param(configs[i]);\n\t\targ = pinconf_to_config_argument(configs[i]);\n\t\tpin_reg = readl(gpio_dev->base + pin*4);\n\n\t\tswitch (param) {\n\t\tcase PIN_CONFIG_INPUT_DEBOUNCE:\n\t\t\tpin_reg &= ~DB_TMR_OUT_MASK;\n\t\t\tpin_reg |= arg & DB_TMR_OUT_MASK;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_DOWN:\n\t\t\tpin_reg &= ~BIT(PULL_DOWN_ENABLE_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_DOWN_ENABLE_OFF;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_BIAS_PULL_UP:\n\t\t\tpin_reg &= ~BIT(PULL_UP_SEL_OFF);\n\t\t\tpin_reg |= (arg & BIT(0)) << PULL_UP_SEL_OFF;\n\t\t\tpin_reg &= ~BIT(PULL_UP_ENABLE_OFF);\n\t\t\tpin_reg |= ((arg>>1) & BIT(0)) << PULL_UP_ENABLE_OFF;\n\t\t\tbreak;\n\n\t\tcase PIN_CONFIG_DRIVE_STRENGTH:\n\t\t\tpin_reg &= ~(DRV_STRENGTH_SEL_MASK\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF);\n\t\t\tpin_reg |= (arg & DRV_STRENGTH_SEL_MASK)\n\t\t\t\t\t<< DRV_STRENGTH_SEL_OFF;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_err(&gpio_dev->pdev->dev,\n\t\t\t\t\"Invalid config param %04x\\n\", param);\n\t\t\tret = -ENOTSUPP;\n\t\t}\n\n\t\twritel(pin_reg, gpio_dev->base + pin*4);\n\t}\n\tspin_unlock_irqrestore(&gpio_dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int amd_pinconf_group_get(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned int group,\n\t\t\t\tunsigned long *config)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint ret;\n\n\tret = amd_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\n\tif (amd_pinconf_get(pctldev, pins[0], config))\n\t\t\treturn -ENOTSUPP;\n\n\treturn 0;\n}\n\nstatic int amd_pinconf_group_set(struct pinctrl_dev *pctldev,\n\t\t\t\tunsigned group, unsigned long *configs,\n\t\t\t\tunsigned num_configs)\n{\n\tconst unsigned *pins;\n\tunsigned npins;\n\tint i, ret;\n\n\tret = amd_get_group_pins(pctldev, group, &pins, &npins);\n\tif (ret)\n\t\treturn ret;\n\tfor (i = 0; i < npins; i++) {\n\t\tif (amd_pinconf_set(pctldev, pins[i], configs, num_configs))\n\t\t\treturn -ENOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic const struct pinconf_ops amd_pinconf_ops = {\n\t.pin_config_get\t\t= amd_pinconf_get,\n\t.pin_config_set\t\t= amd_pinconf_set,\n\t.pin_config_group_get = amd_pinconf_group_get,\n\t.pin_config_group_set = amd_pinconf_group_set,\n};\n\nstatic struct pinctrl_desc amd_pinctrl_desc = {\n\t.pins\t= kerncz_pins,\n\t.npins = ARRAY_SIZE(kerncz_pins),\n\t.pctlops = &amd_pinctrl_ops,\n\t.confops = &amd_pinconf_ops,\n\t.owner = THIS_MODULE,\n};\n\nstatic int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&gpio_dev->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t\t= 0;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= TOTAL_NUMBER_OF_PINS;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\n\tgpio_dev->groups = kerncz_groups;\n\tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n\n\tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n\t\t\t\t\t\tgpio_dev);\n\tif (IS_ERR(gpio_dev->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(gpio_dev->pctrl);\n\t}\n\n\tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n\t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\nout2:\n\tgpiochip_remove(&gpio_dev->gc);\n\n\treturn ret;\n}\n\nstatic int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\n\treturn 0;\n}\n\nstatic const struct acpi_device_id amd_gpio_acpi_match[] = {\n\t{ \"AMD0030\", 0 },\n\t{ \"AMDI0030\", 0},\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, amd_gpio_acpi_match);\n\nstatic struct platform_driver amd_gpio_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"amd_gpio\",\n\t\t.acpi_match_table = ACPI_PTR(amd_gpio_acpi_match),\n\t},\n\t.probe\t\t= amd_gpio_probe,\n\t.remove\t\t= amd_gpio_remove,\n};\n\nmodule_platform_driver(amd_gpio_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Ken Xue <Ken.Xue@amd.com>, Jeff Wu <Jeff.Wu@amd.com>\");\nMODULE_DESCRIPTION(\"AMD GPIO pinctrl driver\");\n"], "filenames": ["drivers/pinctrl/pinctrl-amd.c"], "buggy_code_start_loc": [786], "buggy_code_end_loc": [841], "fixing_code_start_loc": [786], "fixing_code_end_loc": [837], "type": "CWE-415", "message": "In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free.", "other": {"cve": {"id": "CVE-2017-18174", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-11T18:29:00.227", "lastModified": "2018-12-21T11:29:02.967", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free."}, {"lang": "es", "value": "En el kernel de Linux, en versiones anteriores a la 4.7, la funci\u00f3n amd_gpio_remove en drivers/pinctrl/pinctrl-amd.c llama a la funci\u00f3n pinctrl_unregister, lo que conduce a una doble liberaci\u00f3n (double free)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.7", "matchCriteriaId": "5F952CED-2EA6-447E-BE5D-84CEEF065E4C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=251e22abde21833b3d29577e4d8c7aaccd650eee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8dca4a41f1ad65043a78c2338d9725f859c8d2c3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/251e22abde21833b3d29577e4d8c7aaccd650eee", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/8dca4a41f1ad65043a78c2338d9725f859c8d2c3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3848-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3848-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/251e22abde21833b3d29577e4d8c7aaccd650eee"}}