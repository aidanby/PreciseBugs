{"buggy_code": ["<?php\n\n/**\n * This file is part of the Latte (https://latte.nette.org)\n * Copyright (c) 2008 David Grudl (https://davidgrudl.com)\n */\n\ndeclare(strict_types=1);\n\nnamespace Latte;\n\n\n/**\n * PHP code generator helpers.\n */\nclass PhpWriter\n{\n\tuse Strict;\n\n\t/** @var MacroTokens */\n\tprivate $tokens;\n\n\t/** @var string */\n\tprivate $modifiers;\n\n\t/** @var array{string, mixed}|null */\n\tprivate $context;\n\n\t/** @var Policy|null */\n\tprivate $policy;\n\n\t/** @var string[] */\n\tprivate $functions = [];\n\n\t/** @var int|null */\n\tprivate $line;\n\n\n\tpublic static function using(MacroNode $node, ?Compiler $compiler = null): self\n\t{\n\t\t$me = new static($node->tokenizer, null, $node->context);\n\t\t$me->modifiers = &$node->modifiers;\n\t\t$me->functions = $compiler ? $compiler->getFunctions() : [];\n\t\t$me->policy = $compiler ? $compiler->getPolicy() : null;\n\t\t$me->line = $node->startLine;\n\t\treturn $me;\n\t}\n\n\n\t/**\n\t * @param  array{string, mixed}|null  $context\n\t */\n\tpublic function __construct(MacroTokens $tokens, ?string $modifiers = null, ?array $context = null)\n\t{\n\t\t$this->tokens = $tokens;\n\t\t$this->modifiers = $modifiers;\n\t\t$this->context = $context;\n\t}\n\n\n\t/**\n\t * Expands %node.word, %node.array, %node.args, %node.line, %escape(), %modify(), %var, %raw, %word in code.\n\t * @param  mixed  ...$args\n\t */\n\tpublic function write(string $mask, ...$args): string\n\t{\n\t\t$mask = preg_replace('#%(node|\\d+)\\.#', '%$1_', $mask);\n\t\t$mask = preg_replace_callback('#%escape(\\(([^()]*+|(?1))+\\))#', function ($m) {\n\t\t\treturn $this->escapePass(new MacroTokens(substr($m[1], 1, -1)))->joinAll();\n\t\t}, $mask);\n\t\t$mask = preg_replace_callback('#%modify(Content)?(\\(([^()]*+|(?2))+\\))#', function ($m) {\n\t\t\treturn $this->formatModifiers(substr($m[2], 1, -1), (bool) $m[1]);\n\t\t}, $mask);\n\n\t\t$pos = $this->tokens->position;\n\t\t$word = null;\n\t\tif (strpos($mask, '%node_word') !== false) {\n\t\t\t$word = $this->tokens->fetchWord();\n\t\t\tif ($word === null) {\n\t\t\t\tthrow new CompileException('Invalid content of tag');\n\t\t\t}\n\t\t}\n\n\t\t$code = preg_replace_callback(\n\t\t\t'#([,+]?\\s*)?%(node_|\\d+_|)(word|var|raw|array|args|line)(\\?)?(\\s*\\+\\s*)?()#',\n\t\t\tfunction ($m) use ($word, &$args) {\n\t\t\t\t[, $l, $source, $format, $cond, $r] = $m;\n\n\t\t\t\tswitch ($source) {\n\t\t\t\t\tcase 'node_':\n\t\t\t\t\t\t$arg = $word; break;\n\t\t\t\t\tcase '':\n\t\t\t\t\t\t$arg = current($args); next($args); break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$arg = $args[(int) $source]; break;\n\t\t\t\t}\n\n\t\t\t\tswitch ($format) {\n\t\t\t\t\tcase 'word':\n\t\t\t\t\t\t$code = $this->formatWord($arg); break;\n\t\t\t\t\tcase 'args':\n\t\t\t\t\t\t$code = $this->formatArgs(); break;\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t$code = $this->formatArray();\n\t\t\t\t\t\t$code = $cond && $code === '[]' ? '' : $code; break;\n\t\t\t\t\tcase 'var':\n\t\t\t\t\t\t$code = PhpHelpers::dump($arg); break;\n\t\t\t\t\tcase 'raw':\n\t\t\t\t\t\t$code = (string) $arg; break;\n\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t$l = trim($l);\n\t\t\t\t\t\t$code = $this->line ? \" /* line $this->line */\" : ''; break;\n\t\t\t\t}\n\n\t\t\t\tif ($cond && $code === '') {\n\t\t\t\t\treturn $r ? $l : $r;\n\t\t\t\t} else {\n\t\t\t\t\treturn $l . $code . $r;\n\t\t\t\t}\n\t\t\t},\n\t\t\t$mask\n\t\t);\n\n\t\t$this->tokens->position = $pos;\n\t\treturn $code;\n\t}\n\n\n\t/**\n\t * Formats modifiers calling.\n\t */\n\tpublic function formatModifiers(string $var, bool $isContent = false): string\n\t{\n\t\tstatic $uniq;\n\t\t$uniq = $uniq ?? '$' . bin2hex(random_bytes(5));\n\t\t$tokens = new MacroTokens(ltrim($this->modifiers, '|'));\n\t\t$tokens = $this->preprocess($tokens);\n\t\t$tokens = $this->modifierPass($tokens, $uniq, $isContent);\n\t\t$tokens = $this->quotingPass($tokens);\n\t\t$this->validateKeywords($tokens);\n\t\treturn str_replace($uniq, $var, $tokens->joinAll());\n\t}\n\n\n\t/**\n\t * Formats macro arguments to PHP code. (It advances tokenizer to the end as a side effect.)\n\t */\n\tpublic function formatArgs(?MacroTokens $tokens = null): string\n\t{\n\t\t$tokens = $this->preprocess($tokens);\n\t\t$tokens = $this->quotingPass($tokens);\n\t\t$this->validateKeywords($tokens);\n\t\treturn $tokens->joinAll();\n\t}\n\n\n\t/**\n\t * Formats macro arguments to PHP array. (It advances tokenizer to the end as a side effect.)\n\t */\n\tpublic function formatArray(?MacroTokens $tokens = null): string\n\t{\n\t\t$tokens = $this->preprocess($tokens);\n\t\t$tokens = $this->namedArgumentsPass($tokens);\n\t\t$tokens = $this->expandCastPass($tokens);\n\t\t$tokens = $this->quotingPass($tokens);\n\t\t$this->validateKeywords($tokens);\n\t\treturn $tokens->joinAll();\n\t}\n\n\n\t/**\n\t * Formats parameter to PHP string.\n\t */\n\tpublic function formatWord(string $s): string\n\t{\n\t\tif (is_numeric($s)\n\t\t\t|| preg_match('#^[$([]|[\\'\"\\ ]|^(true|TRUE)$|^(false|FALSE)$|^(null|NULL)$|^[\\w\\\\\\\\]{3,}::[A-Z0-9_]{2,}$#D', $s)\n\t\t) {\n\t\t\t$s = preg_match('#\\s#', $s) ? \"($s)\" : $s;\n\t\t\treturn $this->formatArgs(new MacroTokens($s));\n\t\t}\n\n\t\treturn '\"' . $s . '\"';\n\t}\n\n\n\t/**\n\t * Preprocessor for tokens. (It advances tokenizer to the end as a side effect.)\n\t */\n\tpublic function preprocess(?MacroTokens $tokens = null): MacroTokens\n\t{\n\t\t$tokens = $tokens ?? $this->tokens;\n\t\t$this->validateTokens($tokens);\n\t\t$tokens = $this->removeCommentsPass($tokens);\n\t\t$tokens = $this->optionalChainingPass($tokens);\n\t\t$tokens = $this->shortTernaryPass($tokens);\n\t\t$tokens = $this->inOperatorPass($tokens);\n\t\t$tokens = $this->sandboxPass($tokens);\n\t\t$tokens = $this->replaceFunctionsPass($tokens);\n\t\t$tokens = $this->inlineModifierPass($tokens);\n\t\t$tokens = $this->modernArraySyntax($tokens);\n\t\treturn $tokens;\n\t}\n\n\n\t/** @throws CompileException */\n\tpublic function validateTokens(MacroTokens $tokens): void\n\t{\n\t\t$brackets = [];\n\t\t$pos = $tokens->position;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$tokenValue = $tokens->currentValue();\n\t\t\tif ($tokens->isCurrent('?>') || $tokens->isCurrent('#')) {\n\t\t\t\tthrow new CompileException(\"Forbidden $tokenValue inside tag\");\n\n\t\t\t} elseif ($tokens->isCurrent('/') && $tokens->isNext('/')) {\n\t\t\t\tthrow new CompileException('Forbidden // inside tag');\n\n\t\t\t} elseif ($tokens->isCurrent('(', '[', '{')) {\n\t\t\t\tstatic $counterpart = ['(' => ')', '[' => ']', '{' => '}'];\n\t\t\t\t$brackets[] = $counterpart[$tokenValue];\n\n\t\t\t} elseif ($tokens->isCurrent(')', ']', '}') && $tokenValue !== array_pop($brackets)) {\n\t\t\t\tthrow new CompileException('Unexpected ' . $tokenValue);\n\n\t\t\t} elseif ($tokens->isCurrent('`')) {\n\t\t\t\tthrow new CompileException('Backtick operator is forbidden in Latte.');\n\n\t\t\t} elseif (\n\t\t\t\tHelpers::startsWith($tokenValue, '$\u029f_')\n\t\t\t\t|| ($this->policy && $tokens->isCurrent('$this'))\n\t\t\t) {\n\t\t\t\tthrow new CompileException(\"Forbidden variable {$tokenValue}.\");\n\t\t\t}\n\t\t}\n\n\t\tif ($brackets) {\n\t\t\tthrow new CompileException('Missing ' . array_pop($brackets));\n\t\t}\n\n\t\t$tokens->position = $pos;\n\t}\n\n\n\t/** @throws CompileException */\n\tpublic function validateKeywords(MacroTokens $tokens): void\n\t{\n\t\t$pos = $tokens->position;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif (\n\t\t\t\t!$tokens->isPrev('::', '->', '?->', '??->')\n\t\t\t\t&& (\n\t\t\t\t\t$tokens->isCurrent('__halt_compiler', 'declare', 'die', 'eval', 'exit', 'include', 'include_once', 'require', 'require_once')\n\t\t\t\t\t|| ($this->policy && $tokens->isCurrent(\n\t\t\t\t\t\t...['break', 'case', 'catch', 'continue', 'do', 'echo', 'else', 'elseif', 'endfor',\n\t\t\t\t\t\t\t'endforeach', 'endswitch', 'endwhile', 'finally', 'for', 'foreach', 'if', 'new', 'print', 'switch', 'throw', 'try', 'while', ]\n\t\t\t\t\t))\n\t\t\t\t\t|| (($this->policy || !$tokens->depth) && $tokens->isCurrent('return', 'yield'))\n\t\t\t\t\t|| (!$tokens->isNext('(') && $tokens->isCurrent('function', 'use'))\n\t\t\t\t\t|| ($tokens->isCurrent(\n\t\t\t\t\t\t...['abstract', 'class', 'const', 'enddeclare', 'extends', 'final', 'global', 'goto', 'implements',\n\t\t\t\t\t\t\t'insteadof', 'interface', 'namespace', 'private', 'protected', 'public', 'static', 'trait', 'var', ]\n\t\t\t\t\t))\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new CompileException(\"Forbidden keyword '{$tokens->currentValue()}' inside tag.\");\n\t\t\t}\n\t\t}\n\n\t\t$tokens->position = $pos;\n\t}\n\n\n\t/**\n\t * Removes PHP comments.\n\t */\n\tpublic function removeCommentsPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$res->append($tokens->isCurrent($tokens::T_COMMENT) ? ' ' : $tokens->currentToken());\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Replace global functions with custom ones.\n\t */\n\tpublic function replaceFunctionsPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$name = $tokens->currentValue();\n\t\t\tif (\n\t\t\t\t$tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& ($orig = $this->functions[strtolower($name)] ?? null)\n\t\t\t\t&& $tokens->isNext('(')\n\t\t\t\t&& !$tokens->isPrev('::', '->', '?->', '??->', '\\\\')\n\t\t\t) {\n\t\t\t\tif ($name !== $orig) {\n\t\t\t\t\ttrigger_error(\"Case mismatch on function name '$name', correct name is '$orig'.\", E_USER_WARNING);\n\t\t\t\t}\n\n\t\t\t\t$res->append('($this->global->fn->' . $orig . ')');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Simplified ternary expressions without third part.\n\t */\n\tpublic function shortTernaryPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\t$inTernary = [];\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif (\n\t\t\t\t$tokens->isCurrent('?')\n\t\t\t\t&& $tokens->isNext(...$tokens::SIGNIFICANT)\n\t\t\t\t&& !$tokens->isNext(',', ')', ']', '|', '[')\n\t\t\t) {\n\t\t\t\t$inTernary[] = $tokens->depth;\n\n\t\t\t} elseif ($tokens->isCurrent(':')) {\n\t\t\t\tarray_pop($inTernary);\n\n\t\t\t} elseif (\n\t\t\t\t$tokens->isCurrent(',', ')', ']', '|')\n\t\t\t\t&& end($inTernary) === $tokens->depth + $tokens->isCurrent(')', ']')\n\t\t\t) {\n\t\t\t\t$res->append(' : null');\n\t\t\t\tarray_pop($inTernary);\n\t\t\t}\n\n\t\t\t$res->append($tokens->currentToken());\n\t\t}\n\n\t\tif ($inTernary) {\n\t\t\t$res->append(' : null');\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Nullsafe operator $var?->prop?->elem[1]?->call()?->item\n\t * Null-coalescing-safe operator $var??->prop??->elem[1]??->call()??->item\n\t */\n\tpublic function optionalChainingPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$startDepth = $tokens->depth;\n\t\t$res = new MacroTokens;\n\n\t\twhile ($tokens->depth >= $startDepth && $tokens->nextToken()) {\n\t\t\tif (!$tokens->isCurrent($tokens::T_VARIABLE) || $tokens->isPrev('::', '$')) {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$addBraces = '';\n\t\t\t$expr = new MacroTokens([$tokens->currentToken()]);\n\t\t\t$var = $tokens->currentValue();\n\n\t\t\tdo {\n\t\t\t\tif ($tokens->nextToken('?')) {\n\t\t\t\t\tif ( // is it ternary operator?\n\t\t\t\t\t\t$tokens->isNext(...$tokens::SIGNIFICANT)\n\t\t\t\t\t\t&& (\n\t\t\t\t\t\t\t!$tokens->isNext($tokens::T_CHAR)\n\t\t\t\t\t\t\t|| $tokens->isNext('(', '[', '{', ':', '!', '@', '\\\\')\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\t$expr->append($addBraces . ' ?');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!$tokens->isNext('::')) {\n\t\t\t\t\t\t$expr->prepend('(');\n\t\t\t\t\t\t$expr->append(' ?? null)' . $addBraces);\n\t\t\t\t\t\ttrigger_error(\"Syntax '$var?' is deprecated, use '$var ?? null' instead.\", E_USER_DEPRECATED);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttrigger_error(\"Syntax '$var?::' is deprecated.\", E_USER_DEPRECATED);\n\t\t\t\t\t$expr->prepend('(($\u029f_tmp = ');\n\t\t\t\t\t$expr->append(' ?? null) === null ? null : ');\n\t\t\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t\t\t\t$expr = new MacroTokens('$\u029f_tmp');\n\t\t\t\t\t$addBraces .= ')';\n\n\t\t\t\t} elseif ($tokens->nextToken('?->')) {\n\t\t\t\t\tif (PHP_VERSION_ID >= 80000) {\n\t\t\t\t\t\t$expr->append($tokens->currentToken());\n\t\t\t\t\t\t$expr->append($tokens->nextToken());\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->prepend('(($\u029f_tmp = ');\n\t\t\t\t\t$expr->append(') === null ? null : ');\n\t\t\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t\t\t\t$addBraces .= ')';\n\t\t\t\t\t$expr = new MacroTokens('$\u029f_tmp->');\n\t\t\t\t\tif (!$tokens->nextToken($tokens::T_SYMBOL, $tokens::T_VARIABLE)) {\n\t\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\n\t\t\t\t} elseif ($tokens->nextToken('??->')) {\n\t\t\t\t\t$expr->prepend('(($\u029f_tmp = ');\n\t\t\t\t\t$expr->append(' ?? null) === null ? null : ');\n\t\t\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t\t\t\t$addBraces .= ')';\n\t\t\t\t\t$expr = new MacroTokens('$\u029f_tmp->');\n\t\t\t\t\tif (!$tokens->nextToken($tokens::T_SYMBOL, $tokens::T_VARIABLE)) {\n\t\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\n\t\t\t\t} elseif ($tokens->nextToken('->', '::')) {\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\t\t\t\t\tif (!$tokens->nextToken($tokens::T_SYMBOL, $tokens::T_VARIABLE)) {\n\t\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\n\t\t\t\t} elseif ($tokens->nextToken('[', '(')) {\n\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, [$tokens->currentToken()], $this->optionalChainingPass($tokens)->tokens);\n\n\t\t\t\t} else {\n\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\n\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Pseudocast (expand).\n\t */\n\tpublic function expandCastPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens('[');\n\t\t$expand = null;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('(expand)') && $tokens->depth === 0) {\n\t\t\t\t$expand = true;\n\t\t\t\t$res->append('],');\n\t\t\t} elseif ($expand && $tokens->isCurrent(',') && !$tokens->depth) {\n\t\t\t\t$expand = false;\n\t\t\t\t$res->append(', [');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\tif ($expand === null) {\n\t\t\t$res->append(']');\n\t\t} else {\n\t\t\t$res->prepend('array_merge(')->append($expand ? ', [])' : '])');\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Quotes symbols to strings.\n\t */\n\tpublic function quotingPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$res->append(\n\t\t\t\t$tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& (!$tokens->isPrev(...$tokens::SIGNIFICANT) || $tokens->isPrev(',', '(', '[', '=>', ':', '?', '.', '<', '>', '<=', '>=', '===', '!==', '==', '!=', '<>', '&&', '||', '=', 'and', 'or', 'xor', '??'))\n\t\t\t\t&& (!$tokens->isNext(...$tokens::SIGNIFICANT) || $tokens->isNext(',', ';', ')', ']', '=>', ':', '?', '.', '<', '>', '<=', '>=', '===', '!==', '==', '!=', '<>', '&&', '||', 'and', 'or', 'xor', '??'))\n\t\t\t\t&& !((!$tokens->isPrev(...$tokens::SIGNIFICANT) || $tokens->isPrev('(', ',')) && $tokens->isNext(':'))\n\t\t\t\t&& !preg_match('#^[A-Z_][A-Z0-9_]{2,}$#', $tokens->currentValue())\n\t\t\t\t&& !($tokens->isCurrent('default') && $tokens->isNext('=>'))\n\t\t\t\t\t? \"'\" . $tokens->currentValue() . \"'\"\n\t\t\t\t\t: $tokens->currentToken()\n\t\t\t);\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Converts named arguments name: value to 'name' => value\n\t */\n\tpublic function namedArgumentsPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif (\n\t\t\t\t$tokens->depth === 0\n\t\t\t\t&& $tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& (!$tokens->isPrev(...$tokens::SIGNIFICANT) || $tokens->isPrev(','))\n\t\t\t\t&& $tokens->isNext(':')\n\t\t\t) {\n\t\t\t\t$res->append(\"'\" . $tokens->currentValue() . \"' =>\");\n\t\t\t\t$tokens->nextToken(':');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Converts [name: value] to ['name' => value]\n\t */\n\tpublic function modernArraySyntax(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\t$brackets = [];\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('[', '(', '{')) {\n\t\t\t\t$brackets[] = $tokens->currentValue();\n\t\t\t} elseif ($tokens->isCurrent(']', ')', '}')) {\n\t\t\t\tarray_pop($brackets);\n\t\t\t}\n\n\t\t\tif (end($brackets) === '['\n\t\t\t\t&& $tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& ($tokens->isPrev('[', ','))\n\t\t\t\t&& $tokens->isNext(':')\n\t\t\t) {\n\t\t\t\t$res->append(\"'\" . $tokens->currentValue() . \"' =>\");\n\t\t\t\t$tokens->nextToken(':');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Syntax $entry in [item1, item2].\n\t */\n\tpublic function inOperatorPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent($tokens::T_VARIABLE)) {\n\t\t\t\t$start = $tokens->position;\n\t\t\t\t$depth = $tokens->depth;\n\t\t\t\t$expr = $arr = [];\n\n\t\t\t\t$expr[] = $tokens->currentToken();\n\t\t\t\twhile ($tokens->isNext($tokens::T_VARIABLE, $tokens::T_SYMBOL, $tokens::T_NUMBER, $tokens::T_STRING, '[', ']', '(', ')', '->', '?->')\n\t\t\t\t\t&& !$tokens->isNext('in')) {\n\t\t\t\t\t$expr[] = $tokens->nextToken();\n\t\t\t\t}\n\n\t\t\t\tif ($depth === $tokens->depth && $tokens->nextValue('in') && ($arr[] = $tokens->nextToken('['))) {\n\t\t\t\t\twhile ($tokens->isNext(...$tokens::SIGNIFICANT)) {\n\t\t\t\t\t\t$arr[] = $tokens->nextToken();\n\t\t\t\t\t\tif ($tokens->isCurrent(']') && $tokens->depth === $depth) {\n\t\t\t\t\t\t\t$new = array_merge($tokens->parse('in_array('), $expr, $tokens->parse(', '), $arr, $tokens->parse(', true)'));\n\t\t\t\t\t\t\tarray_splice($tokens->tokens, $start, $tokens->position - $start + 1, $new);\n\t\t\t\t\t\t\t$tokens->position = $start + count($new) - 1;\n\t\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$tokens->position = $start;\n\t\t\t}\n\t\t}\n\n\t\treturn $tokens->reset();\n\t}\n\n\n\t/**\n\t * Applies sandbox policy.\n\t */\n\tpublic function sandboxPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\tstatic $keywords = [\n\t\t\t'array' => 1, 'catch' => 1, 'clone' => 1, 'empty' => 1, 'for' => 1,\n\t\t\t'foreach' => 1, 'function' => 1, 'if' => 1, 'elseif', 'isset' => 1, 'list' => 1, 'unset' => 1,\n\t\t];\n\n\t\tif (!$this->policy) {\n\t\t\treturn $tokens;\n\t\t}\n\n\t\t$startDepth = $tokens->depth;\n\t\t$res = new MacroTokens;\n\n\t\twhile ($tokens->depth >= $startDepth && $tokens->nextToken()) {\n\t\t\t$static = false;\n\t\t\tif ($tokens->isCurrent('[', '(')) { // starts with expression\n\t\t\t\t$expr = new MacroTokens(array_merge([$tokens->currentToken()], $this->sandboxPass($tokens)->tokens));\n\n\t\t\t} elseif ( // function or class name\n\t\t\t\t$tokens->isCurrent($tokens::T_SYMBOL, '\\\\')\n\t\t\t\t&& empty($keywords[$tokens->currentValue()])\n\t\t\t) {\n\t\t\t\t$expr = new MacroTokens(array_merge([$tokens->currentToken()], $tokens->nextAll($tokens::T_SYMBOL, '\\\\')));\n\t\t\t\t$static = true;\n\n\t\t\t} elseif ($tokens->isCurrent('$')) { // $$$var or ${...}\n\t\t\t\tthrow new CompileException('Forbidden variable variables.');\n\n\t\t\t} elseif ($tokens->isCurrent($tokens::T_VARIABLE, $tokens::T_STRING)) {  // $var or 'func'\n\t\t\t\t$expr = new MacroTokens([$tokens->currentToken()]);\n\n\t\t\t} else { // not a begin\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tif ($tokens->nextToken('(')) { // call\n\t\t\t\t\tif ($static) { // global function\n\t\t\t\t\t\t$name = $expr->joinAll();\n\t\t\t\t\t\tif (!$this->policy->isFunctionAllowed($name)) {\n\t\t\t\t\t\t\tthrow new SecurityViolationException(\"Function $name() is not allowed.\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$static = false;\n\t\t\t\t\t\t$expr->append('(');\n\t\t\t\t\t} else { // any calling\n\t\t\t\t\t\t$expr->prepend('$this->call(');\n\t\t\t\t\t\t$expr->append(')(');\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, $this->sandboxPass($tokens)->tokens);\n\n\t\t\t\t} elseif ($tokens->nextToken('->', '?->', '::')) { // property, method or constant\n\t\t\t\t\t$op = $tokens->currentValue();\n\t\t\t\t\tif ($op === '::' && $tokens->nextToken($tokens::T_SYMBOL)) { // is constant?\n\t\t\t\t\t\tif ($tokens->isNext('(')) { // go back, it was not\n\t\t\t\t\t\t\t$tokens->position--;\n\t\t\t\t\t\t} else { // it is\n\t\t\t\t\t\t\t$expr->append('::');\n\t\t\t\t\t\t\t$expr->append($tokens->currentValue());\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($static) { // class name\n\t\t\t\t\t\t$expr->append('::class');\n\t\t\t\t\t\t$static = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append(', ');\n\n\t\t\t\t\tif ($tokens->nextToken($tokens::T_SYMBOL)) { // $obj->member or $obj::member\n\t\t\t\t\t\t$member = [$tokens->currentToken()];\n\t\t\t\t\t\t$expr->append(PhpHelpers::dump($tokens->currentValue()));\n\n\t\t\t\t\t} elseif ($tokens->nextToken($tokens::T_VARIABLE)) { // $obj->$var or $obj::$var\n\t\t\t\t\t\t$member = [$tokens->currentToken()];\n\t\t\t\t\t\tif ($op === '::' && !$tokens->isNext('(')) {\n\t\t\t\t\t\t\t$expr->append(PhpHelpers::dump(substr($tokens->currentValue(), 1)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$expr->append($tokens->currentValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ($tokens->nextToken('{')) { // $obj->{...}\n\t\t\t\t\t\t$member = array_merge([$tokens->currentToken()], $this->sandboxPass($tokens)->tokens);\n\t\t\t\t\t\t$expr->append('(string) ');\n\t\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, array_slice($member, 1, -1));\n\n\t\t\t\t\t} else { // $obj->$$$var or $obj::$$$var\n\t\t\t\t\t\t$member = $tokens->nextAll($tokens::T_VARIABLE, '$');\n\t\t\t\t\t\t$expr->tokens = $op === '::' && !$tokens->isNext('(')\n\t\t\t\t\t\t\t? array_merge($expr->tokens, array_slice($member, 1))\n\t\t\t\t\t\t\t: array_merge($expr->tokens, $member);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($tokens->nextToken('(')) {\n\t\t\t\t\t\t$expr->prepend('$this->call([');\n\t\t\t\t\t\t$expr->append('])(');\n\t\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, $this->sandboxPass($tokens)->tokens);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$expr->prepend('$this->prop(');\n\t\t\t\t\t\t$expr->append(')' . $op);\n\t\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, $member);\n\t\t\t\t\t}\n\t\t\t\t} elseif ($tokens->nextToken('[', '{')) { // array access\n\t\t\t\t\t$static = false;\n\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, [$tokens->currentToken()], $this->sandboxPass($tokens)->tokens);\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\n\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Process inline filters ($var|filter)\n\t */\n\tpublic function inlineModifierPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$result = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('(', '[')) {\n\t\t\t\t$result->tokens = array_merge($result->tokens, $this->inlineModifierInner($tokens));\n\t\t\t} else {\n\t\t\t\t$result->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\n\t/**\n\t * @return array<array{string, int, int}>\n\t */\n\tprivate function inlineModifierInner(MacroTokens $tokens): array\n\t{\n\t\t$isFunctionOrArray = $tokens->isPrev($tokens::T_VARIABLE, $tokens::T_SYMBOL, ')') || $tokens->isCurrent('[');\n\t\t$result = new MacroTokens;\n\t\t$args = new MacroTokens;\n\t\t$modifiers = new MacroTokens;\n\t\t$current = $args;\n\t\t$anyModifier = false;\n\t\t$result->append($tokens->currentToken());\n\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('(', '[')) {\n\t\t\t\t$current->tokens = array_merge($current->tokens, $this->inlineModifierInner($tokens));\n\n\t\t\t} elseif ($current !== $modifiers && $tokens->isCurrent('|')) {\n\t\t\t\t$anyModifier = true;\n\t\t\t\t$current = $modifiers;\n\n\t\t\t} elseif ($tokens->isCurrent(')', ']') || ($isFunctionOrArray && $tokens->isCurrent(','))) {\n\t\t\t\t$partTokens = count($modifiers->tokens)\n\t\t\t\t\t? $this->modifierPass($modifiers, $args->tokens)->tokens\n\t\t\t\t\t: $args->tokens;\n\t\t\t\t$result->tokens = array_merge($result->tokens, $partTokens);\n\t\t\t\tif ($tokens->isCurrent(',')) {\n\t\t\t\t\t$result->append($tokens->currentToken());\n\t\t\t\t\t$args = new MacroTokens;\n\t\t\t\t\t$modifiers = new MacroTokens;\n\t\t\t\t\t$current = $args;\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif ($isFunctionOrArray || !$anyModifier) {\n\t\t\t\t\t$result->append($tokens->currentToken());\n\t\t\t\t} else {\n\t\t\t\t\tarray_shift($result->tokens);\n\t\t\t\t}\n\n\t\t\t\treturn $result->tokens;\n\n\t\t\t} else {\n\t\t\t\t$current->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\tthrow new CompileException('Unbalanced brackets.');\n\t}\n\n\n\t/**\n\t * Formats modifiers calling.\n\t * @param  string|array<array{string, int, int}>  $var\n\t * @throws CompileException\n\t */\n\tpublic function modifierPass(MacroTokens $tokens, $var, bool $isContent = false): MacroTokens\n\t{\n\t\t$inside = false;\n\t\t$res = new MacroTokens($var);\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent($tokens::T_WHITESPACE)) {\n\t\t\t\t$res->append(' ');\n\n\t\t\t} elseif ($inside) {\n\t\t\t\tif ($tokens->isCurrent(':', ',') && !$tokens->depth) {\n\t\t\t\t\t$res->append(', ');\n\t\t\t\t\t$tokens->nextAll($tokens::T_WHITESPACE);\n\n\t\t\t\t} elseif ($tokens->isCurrent('|') && !$tokens->depth) {\n\t\t\t\t\t$res->append(')');\n\t\t\t\t\t$inside = false;\n\n\t\t\t\t} elseif (\n\t\t\t\t\t!$tokens->depth\n\t\t\t\t\t&& $tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t\t&& $tokens->isPrev(',', ':')\n\t\t\t\t\t&& $tokens->isNext(':')\n\t\t\t\t) {\n\t\t\t\t\t$hint = (clone $tokens)->reset()->joinAll();\n\t\t\t\t\ttrigger_error(\"Colon as argument separator is deprecated, use comma in '$hint'.\", E_USER_DEPRECATED);\n\t\t\t\t\t$res->append($tokens->currentToken());\n\n\t\t\t\t} else {\n\t\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t\t}\n\t\t\t} elseif ($tokens->isCurrent($tokens::T_SYMBOL)) {\n\t\t\t\tif ($tokens->isCurrent('escape')) {\n\t\t\t\t\tif ($isContent) {\n\t\t\t\t\t\t$res->prepend('LR\\Filters::convertTo($\u029f_fi, ' . PhpHelpers::dump(implode($this->context)) . ', ')\n\t\t\t\t\t\t\t->append(')');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$res = $this->escapePass($res);\n\t\t\t\t\t}\n\n\t\t\t\t\t$tokens->nextToken('|');\n\t\t\t\t} elseif (!strcasecmp($tokens->currentValue(), 'checkurl')) {\n\t\t\t\t\t$res->prepend('LR\\Filters::safeUrl(');\n\t\t\t\t\t$inside = true;\n\t\t\t\t} elseif (\n\t\t\t\t\t!strcasecmp($tokens->currentValue(), 'noescape')\n\t\t\t\t\t|| !strcasecmp($tokens->currentValue(), 'nocheck')\n\t\t\t\t) {\n\t\t\t\t\tthrow new SecurityViolationException(\"Filter |{$tokens->currentValue()} is not expected here.\");\n\t\t\t\t} else {\n\t\t\t\t\t$name = $tokens->currentValue();\n\t\t\t\t\tif ($this->policy && !$this->policy->isFilterAllowed($name)) {\n\t\t\t\t\t\tthrow new SecurityViolationException(\"Filter |$name is not allowed.\");\n\t\t\t\t\t}\n\n\t\t\t\t\t$name = strtolower($name);\n\t\t\t\t\t$res->prepend(\n\t\t\t\t\t\t$isContent\n\t\t\t\t\t\t\t? '$this->filters->filterContent(' . PhpHelpers::dump($name) . ', $\u029f_fi, '\n\t\t\t\t\t\t\t: '($this->filters->' . $name . ')('\n\t\t\t\t\t);\n\t\t\t\t\t$inside = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new CompileException(\"Filter name must be alphanumeric string, '{$tokens->currentValue()}' given.\");\n\t\t\t}\n\t\t}\n\n\t\tif ($inside) {\n\t\t\t$res->append(')');\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Escapes expression in tokens.\n\t */\n\tpublic function escapePass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$tokens = clone $tokens;\n\t\t[$contentType, $context] = $this->context;\n\t\tswitch ($contentType) {\n\t\t\tcase Compiler::CONTENT_XHTML:\n\t\t\tcase Compiler::CONTENT_HTML:\n\t\t\t\tswitch ($context) {\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_TEXT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlText(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_TAG:\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_UNQUOTED_URL:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttrUnquoted(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE:\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_URL:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttr(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_JS:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttr(LR\\Filters::escapeJs(')->append('))');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_CSS:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttr(LR\\Filters::escapeCss(')->append('))');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlComment(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_BOGUS_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtml(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_JS:\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_CSS:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escape' . ucfirst($context) . '(')->append(')');\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new CompileException(\"Unknown context $contentType, $context.\");\n\t\t\t\t}\n\t\t\t\t// break omitted\n\t\t\tcase Compiler::CONTENT_XML:\n\t\t\t\tswitch ($context) {\n\t\t\t\t\tcase Compiler::CONTEXT_XML_TEXT:\n\t\t\t\t\tcase Compiler::CONTEXT_XML_ATTRIBUTE:\n\t\t\t\t\tcase Compiler::CONTEXT_XML_BOGUS_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeXml(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_XML_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlComment(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_XML_TAG:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeXmlAttrUnquoted(')->append(')');\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new CompileException(\"Unknown context $contentType, $context.\");\n\t\t\t\t}\n\t\t\t\t// break omitted\n\t\t\tcase Compiler::CONTENT_JS:\n\t\t\tcase Compiler::CONTENT_CSS:\n\t\t\tcase Compiler::CONTENT_ICAL:\n\t\t\t\treturn $tokens->prepend('LR\\Filters::escape' . ucfirst($contentType) . '(')->append(')');\n\t\t\tcase Compiler::CONTENT_TEXT:\n\t\t\t\treturn $tokens;\n\t\t\tcase null:\n\t\t\t\treturn $tokens->prepend('($this->filters->escape)(')->append(')');\n\t\t\tdefault:\n\t\t\t\tthrow new CompileException(\"Unknown context $contentType.\");\n\t\t}\n\t}\n}\n", "<?php\n\ndeclare(strict_types=1);\n\nuse Tester\\Assert;\n\n\nrequire __DIR__ . '/../bootstrap.php';\n\n\nclass Test\n{\n\tpublic function __call($nm, $arg)\n\t{\n\t}\n}\n\n\n$latte = new Latte\\Engine;\n$latte->setLoader(new Latte\\Loaders\\StringLoader);\n$latte->setPolicy((new Latte\\Sandbox\\SecurityPolicy)->allowMacros(['=', 'do']));\n$latte->setSandboxMode();\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{var $abc}');\n}, Latte\\CompileException::class, 'Tag {var} is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('<span n:class=\"\"></span>');\n}, Latte\\CompileException::class, 'Tag n:class is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$abc|upper}');\n}, Latte\\CompileException::class, 'Filter |upper is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$abc|noescape}');\n}, Latte\\CompileException::class, 'Filter |noescape is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('<a href=\"{$abc|nocheck}\">');\n}, Latte\\CompileException::class, 'Filter |nocheck is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('<a href=\"{$abc|datastream}\">');\n}, Latte\\CompileException::class, 'Filter |datastream is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{trim(123)}');\n}, Latte\\CompileException::class, 'Function trim() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=\"trim\"(123)}');\n}, Latte\\SecurityViolationException::class, 'Calling trim() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->error(123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj?->error(123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj??->error(123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=[$obj, \"error\"](123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->error}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj?->error}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj??->error}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->$prop}', ['obj' => new Test, 'prop' => 'error']);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj::$prop}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'prop' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->method()}', ['obj' => 1]);\n}, Latte\\SecurityViolationException::class, 'Invalid callable.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->$prop}', ['obj' => new Test, 'prop' => 1]);\n}, Latte\\SecurityViolationException::class, \"Access to '1' property on a Test object is not allowed.\");\n\nAssert::error(function () use ($latte) {\n\t$latte->renderToString('{=$obj->$prop}', ['obj' => 1, 'prop' => 1]);\n}, PHP_VERSION_ID < 80000 ? E_NOTICE : E_WARNING, '%a% property %a%');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$this->filters}');\n}, Latte\\CompileException::class, 'Forbidden variable $this.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{${\"this\"}}');\n}, Latte\\CompileException::class, 'Forbidden variable variables.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$$x}}');\n}, Latte\\CompileException::class, 'Forbidden variable variables.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do echo 123}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'echo' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do return 123}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'return' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do yield 123}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'yield' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do new stdClass}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'new' inside tag.\");\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of the Latte (https://latte.nette.org)\n * Copyright (c) 2008 David Grudl (https://davidgrudl.com)\n */\n\ndeclare(strict_types=1);\n\nnamespace Latte;\n\n\n/**\n * PHP code generator helpers.\n */\nclass PhpWriter\n{\n\tuse Strict;\n\n\t/** @var MacroTokens */\n\tprivate $tokens;\n\n\t/** @var string */\n\tprivate $modifiers;\n\n\t/** @var array{string, mixed}|null */\n\tprivate $context;\n\n\t/** @var Policy|null */\n\tprivate $policy;\n\n\t/** @var string[] */\n\tprivate $functions = [];\n\n\t/** @var int|null */\n\tprivate $line;\n\n\n\tpublic static function using(MacroNode $node, ?Compiler $compiler = null): self\n\t{\n\t\t$me = new static($node->tokenizer, null, $node->context);\n\t\t$me->modifiers = &$node->modifiers;\n\t\t$me->functions = $compiler ? $compiler->getFunctions() : [];\n\t\t$me->policy = $compiler ? $compiler->getPolicy() : null;\n\t\t$me->line = $node->startLine;\n\t\treturn $me;\n\t}\n\n\n\t/**\n\t * @param  array{string, mixed}|null  $context\n\t */\n\tpublic function __construct(MacroTokens $tokens, ?string $modifiers = null, ?array $context = null)\n\t{\n\t\t$this->tokens = $tokens;\n\t\t$this->modifiers = $modifiers;\n\t\t$this->context = $context;\n\t}\n\n\n\t/**\n\t * Expands %node.word, %node.array, %node.args, %node.line, %escape(), %modify(), %var, %raw, %word in code.\n\t * @param  mixed  ...$args\n\t */\n\tpublic function write(string $mask, ...$args): string\n\t{\n\t\t$mask = preg_replace('#%(node|\\d+)\\.#', '%$1_', $mask);\n\t\t$mask = preg_replace_callback('#%escape(\\(([^()]*+|(?1))+\\))#', function ($m) {\n\t\t\treturn $this->escapePass(new MacroTokens(substr($m[1], 1, -1)))->joinAll();\n\t\t}, $mask);\n\t\t$mask = preg_replace_callback('#%modify(Content)?(\\(([^()]*+|(?2))+\\))#', function ($m) {\n\t\t\treturn $this->formatModifiers(substr($m[2], 1, -1), (bool) $m[1]);\n\t\t}, $mask);\n\n\t\t$pos = $this->tokens->position;\n\t\t$word = null;\n\t\tif (strpos($mask, '%node_word') !== false) {\n\t\t\t$word = $this->tokens->fetchWord();\n\t\t\tif ($word === null) {\n\t\t\t\tthrow new CompileException('Invalid content of tag');\n\t\t\t}\n\t\t}\n\n\t\t$code = preg_replace_callback(\n\t\t\t'#([,+]?\\s*)?%(node_|\\d+_|)(word|var|raw|array|args|line)(\\?)?(\\s*\\+\\s*)?()#',\n\t\t\tfunction ($m) use ($word, &$args) {\n\t\t\t\t[, $l, $source, $format, $cond, $r] = $m;\n\n\t\t\t\tswitch ($source) {\n\t\t\t\t\tcase 'node_':\n\t\t\t\t\t\t$arg = $word; break;\n\t\t\t\t\tcase '':\n\t\t\t\t\t\t$arg = current($args); next($args); break;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t$arg = $args[(int) $source]; break;\n\t\t\t\t}\n\n\t\t\t\tswitch ($format) {\n\t\t\t\t\tcase 'word':\n\t\t\t\t\t\t$code = $this->formatWord($arg); break;\n\t\t\t\t\tcase 'args':\n\t\t\t\t\t\t$code = $this->formatArgs(); break;\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\t$code = $this->formatArray();\n\t\t\t\t\t\t$code = $cond && $code === '[]' ? '' : $code; break;\n\t\t\t\t\tcase 'var':\n\t\t\t\t\t\t$code = PhpHelpers::dump($arg); break;\n\t\t\t\t\tcase 'raw':\n\t\t\t\t\t\t$code = (string) $arg; break;\n\t\t\t\t\tcase 'line':\n\t\t\t\t\t\t$l = trim($l);\n\t\t\t\t\t\t$code = $this->line ? \" /* line $this->line */\" : ''; break;\n\t\t\t\t}\n\n\t\t\t\tif ($cond && $code === '') {\n\t\t\t\t\treturn $r ? $l : $r;\n\t\t\t\t} else {\n\t\t\t\t\treturn $l . $code . $r;\n\t\t\t\t}\n\t\t\t},\n\t\t\t$mask\n\t\t);\n\n\t\t$this->tokens->position = $pos;\n\t\treturn $code;\n\t}\n\n\n\t/**\n\t * Formats modifiers calling.\n\t */\n\tpublic function formatModifiers(string $var, bool $isContent = false): string\n\t{\n\t\tstatic $uniq;\n\t\t$uniq = $uniq ?? '$' . bin2hex(random_bytes(5));\n\t\t$tokens = new MacroTokens(ltrim($this->modifiers, '|'));\n\t\t$tokens = $this->preprocess($tokens);\n\t\t$tokens = $this->modifierPass($tokens, $uniq, $isContent);\n\t\t$tokens = $this->quotingPass($tokens);\n\t\t$this->validateKeywords($tokens);\n\t\treturn str_replace($uniq, $var, $tokens->joinAll());\n\t}\n\n\n\t/**\n\t * Formats macro arguments to PHP code. (It advances tokenizer to the end as a side effect.)\n\t */\n\tpublic function formatArgs(?MacroTokens $tokens = null): string\n\t{\n\t\t$tokens = $this->preprocess($tokens);\n\t\t$tokens = $this->quotingPass($tokens);\n\t\t$this->validateKeywords($tokens);\n\t\treturn $tokens->joinAll();\n\t}\n\n\n\t/**\n\t * Formats macro arguments to PHP array. (It advances tokenizer to the end as a side effect.)\n\t */\n\tpublic function formatArray(?MacroTokens $tokens = null): string\n\t{\n\t\t$tokens = $this->preprocess($tokens);\n\t\t$tokens = $this->namedArgumentsPass($tokens);\n\t\t$tokens = $this->expandCastPass($tokens);\n\t\t$tokens = $this->quotingPass($tokens);\n\t\t$this->validateKeywords($tokens);\n\t\treturn $tokens->joinAll();\n\t}\n\n\n\t/**\n\t * Formats parameter to PHP string.\n\t */\n\tpublic function formatWord(string $s): string\n\t{\n\t\tif (is_numeric($s)\n\t\t\t|| preg_match('#^[$([]|[\\'\"\\ ]|^(true|TRUE)$|^(false|FALSE)$|^(null|NULL)$|^[\\w\\\\\\\\]{3,}::[A-Z0-9_]{2,}$#D', $s)\n\t\t) {\n\t\t\t$s = preg_match('#\\s#', $s) ? \"($s)\" : $s;\n\t\t\treturn $this->formatArgs(new MacroTokens($s));\n\t\t}\n\n\t\treturn '\"' . $s . '\"';\n\t}\n\n\n\t/**\n\t * Preprocessor for tokens. (It advances tokenizer to the end as a side effect.)\n\t */\n\tpublic function preprocess(?MacroTokens $tokens = null): MacroTokens\n\t{\n\t\t$tokens = $tokens ?? $this->tokens;\n\t\t$this->validateTokens($tokens);\n\t\t$tokens = $this->removeCommentsPass($tokens);\n\t\t$tokens = $this->optionalChainingPass($tokens);\n\t\t$tokens = $this->shortTernaryPass($tokens);\n\t\t$tokens = $this->inOperatorPass($tokens);\n\t\t$tokens = $this->sandboxPass($tokens);\n\t\t$tokens = $this->replaceFunctionsPass($tokens);\n\t\t$tokens = $this->inlineModifierPass($tokens);\n\t\t$tokens = $this->modernArraySyntax($tokens);\n\t\treturn $tokens;\n\t}\n\n\n\t/** @throws CompileException */\n\tpublic function validateTokens(MacroTokens $tokens): void\n\t{\n\t\t$brackets = [];\n\t\t$pos = $tokens->position;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$tokenValue = $tokens->currentValue();\n\t\t\tif ($tokens->isCurrent('?>') || $tokens->isCurrent('#')) {\n\t\t\t\tthrow new CompileException(\"Forbidden $tokenValue inside tag\");\n\n\t\t\t} elseif ($tokens->isCurrent('/') && $tokens->isNext('/')) {\n\t\t\t\tthrow new CompileException('Forbidden // inside tag');\n\n\t\t\t} elseif ($tokens->isCurrent('(', '[', '{')) {\n\t\t\t\tstatic $counterpart = ['(' => ')', '[' => ']', '{' => '}'];\n\t\t\t\t$brackets[] = $counterpart[$tokenValue];\n\n\t\t\t} elseif ($tokens->isCurrent(')', ']', '}') && $tokenValue !== array_pop($brackets)) {\n\t\t\t\tthrow new CompileException('Unexpected ' . $tokenValue);\n\n\t\t\t} elseif ($tokens->isCurrent('`')) {\n\t\t\t\tthrow new CompileException('Backtick operator is forbidden in Latte.');\n\n\t\t\t} elseif (\n\t\t\t\t$this->policy\n\t\t\t\t&& $tokens->isCurrent($tokens::T_STRING)\n\t\t\t\t&& $tokenValue[0] === '\"'\n\t\t\t\t&& (strpos($tokenValue, '{$') !== false || strpos($tokenValue, '${') !== false)\n\t\t\t) {\n\t\t\t\tthrow new CompileException('Forbidden complex expressions in strings.');\n\n\t\t\t} elseif (\n\t\t\t\tHelpers::startsWith($tokenValue, '$\u029f_')\n\t\t\t\t|| ($this->policy && $tokens->isCurrent('$this'))\n\t\t\t) {\n\t\t\t\tthrow new CompileException(\"Forbidden variable {$tokenValue}.\");\n\t\t\t}\n\t\t}\n\n\t\tif ($brackets) {\n\t\t\tthrow new CompileException('Missing ' . array_pop($brackets));\n\t\t}\n\n\t\t$tokens->position = $pos;\n\t}\n\n\n\t/** @throws CompileException */\n\tpublic function validateKeywords(MacroTokens $tokens): void\n\t{\n\t\t$pos = $tokens->position;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif (\n\t\t\t\t!$tokens->isPrev('::', '->', '?->', '??->')\n\t\t\t\t&& (\n\t\t\t\t\t$tokens->isCurrent('__halt_compiler', 'declare', 'die', 'eval', 'exit', 'include', 'include_once', 'require', 'require_once')\n\t\t\t\t\t|| ($this->policy && $tokens->isCurrent(\n\t\t\t\t\t\t...['break', 'case', 'catch', 'continue', 'do', 'echo', 'else', 'elseif', 'endfor',\n\t\t\t\t\t\t\t'endforeach', 'endswitch', 'endwhile', 'finally', 'for', 'foreach', 'if', 'new', 'print', 'switch', 'throw', 'try', 'while', ]\n\t\t\t\t\t))\n\t\t\t\t\t|| (($this->policy || !$tokens->depth) && $tokens->isCurrent('return', 'yield'))\n\t\t\t\t\t|| (!$tokens->isNext('(') && $tokens->isCurrent('function', 'use'))\n\t\t\t\t\t|| ($tokens->isCurrent(\n\t\t\t\t\t\t...['abstract', 'class', 'const', 'enddeclare', 'extends', 'final', 'global', 'goto', 'implements',\n\t\t\t\t\t\t\t'insteadof', 'interface', 'namespace', 'private', 'protected', 'public', 'static', 'trait', 'var', ]\n\t\t\t\t\t))\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthrow new CompileException(\"Forbidden keyword '{$tokens->currentValue()}' inside tag.\");\n\t\t\t}\n\t\t}\n\n\t\t$tokens->position = $pos;\n\t}\n\n\n\t/**\n\t * Removes PHP comments.\n\t */\n\tpublic function removeCommentsPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$res->append($tokens->isCurrent($tokens::T_COMMENT) ? ' ' : $tokens->currentToken());\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Replace global functions with custom ones.\n\t */\n\tpublic function replaceFunctionsPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$name = $tokens->currentValue();\n\t\t\tif (\n\t\t\t\t$tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& ($orig = $this->functions[strtolower($name)] ?? null)\n\t\t\t\t&& $tokens->isNext('(')\n\t\t\t\t&& !$tokens->isPrev('::', '->', '?->', '??->', '\\\\')\n\t\t\t) {\n\t\t\t\tif ($name !== $orig) {\n\t\t\t\t\ttrigger_error(\"Case mismatch on function name '$name', correct name is '$orig'.\", E_USER_WARNING);\n\t\t\t\t}\n\n\t\t\t\t$res->append('($this->global->fn->' . $orig . ')');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Simplified ternary expressions without third part.\n\t */\n\tpublic function shortTernaryPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\t$inTernary = [];\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif (\n\t\t\t\t$tokens->isCurrent('?')\n\t\t\t\t&& $tokens->isNext(...$tokens::SIGNIFICANT)\n\t\t\t\t&& !$tokens->isNext(',', ')', ']', '|', '[')\n\t\t\t) {\n\t\t\t\t$inTernary[] = $tokens->depth;\n\n\t\t\t} elseif ($tokens->isCurrent(':')) {\n\t\t\t\tarray_pop($inTernary);\n\n\t\t\t} elseif (\n\t\t\t\t$tokens->isCurrent(',', ')', ']', '|')\n\t\t\t\t&& end($inTernary) === $tokens->depth + $tokens->isCurrent(')', ']')\n\t\t\t) {\n\t\t\t\t$res->append(' : null');\n\t\t\t\tarray_pop($inTernary);\n\t\t\t}\n\n\t\t\t$res->append($tokens->currentToken());\n\t\t}\n\n\t\tif ($inTernary) {\n\t\t\t$res->append(' : null');\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Nullsafe operator $var?->prop?->elem[1]?->call()?->item\n\t * Null-coalescing-safe operator $var??->prop??->elem[1]??->call()??->item\n\t */\n\tpublic function optionalChainingPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$startDepth = $tokens->depth;\n\t\t$res = new MacroTokens;\n\n\t\twhile ($tokens->depth >= $startDepth && $tokens->nextToken()) {\n\t\t\tif (!$tokens->isCurrent($tokens::T_VARIABLE) || $tokens->isPrev('::', '$')) {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t$addBraces = '';\n\t\t\t$expr = new MacroTokens([$tokens->currentToken()]);\n\t\t\t$var = $tokens->currentValue();\n\n\t\t\tdo {\n\t\t\t\tif ($tokens->nextToken('?')) {\n\t\t\t\t\tif ( // is it ternary operator?\n\t\t\t\t\t\t$tokens->isNext(...$tokens::SIGNIFICANT)\n\t\t\t\t\t\t&& (\n\t\t\t\t\t\t\t!$tokens->isNext($tokens::T_CHAR)\n\t\t\t\t\t\t\t|| $tokens->isNext('(', '[', '{', ':', '!', '@', '\\\\')\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\t$expr->append($addBraces . ' ?');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!$tokens->isNext('::')) {\n\t\t\t\t\t\t$expr->prepend('(');\n\t\t\t\t\t\t$expr->append(' ?? null)' . $addBraces);\n\t\t\t\t\t\ttrigger_error(\"Syntax '$var?' is deprecated, use '$var ?? null' instead.\", E_USER_DEPRECATED);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\ttrigger_error(\"Syntax '$var?::' is deprecated.\", E_USER_DEPRECATED);\n\t\t\t\t\t$expr->prepend('(($\u029f_tmp = ');\n\t\t\t\t\t$expr->append(' ?? null) === null ? null : ');\n\t\t\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t\t\t\t$expr = new MacroTokens('$\u029f_tmp');\n\t\t\t\t\t$addBraces .= ')';\n\n\t\t\t\t} elseif ($tokens->nextToken('?->')) {\n\t\t\t\t\tif (PHP_VERSION_ID >= 80000) {\n\t\t\t\t\t\t$expr->append($tokens->currentToken());\n\t\t\t\t\t\t$expr->append($tokens->nextToken());\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->prepend('(($\u029f_tmp = ');\n\t\t\t\t\t$expr->append(') === null ? null : ');\n\t\t\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t\t\t\t$addBraces .= ')';\n\t\t\t\t\t$expr = new MacroTokens('$\u029f_tmp->');\n\t\t\t\t\tif (!$tokens->nextToken($tokens::T_SYMBOL, $tokens::T_VARIABLE)) {\n\t\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\n\t\t\t\t} elseif ($tokens->nextToken('??->')) {\n\t\t\t\t\t$expr->prepend('(($\u029f_tmp = ');\n\t\t\t\t\t$expr->append(' ?? null) === null ? null : ');\n\t\t\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t\t\t\t$addBraces .= ')';\n\t\t\t\t\t$expr = new MacroTokens('$\u029f_tmp->');\n\t\t\t\t\tif (!$tokens->nextToken($tokens::T_SYMBOL, $tokens::T_VARIABLE)) {\n\t\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\n\t\t\t\t} elseif ($tokens->nextToken('->', '::')) {\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\t\t\t\t\tif (!$tokens->nextToken($tokens::T_SYMBOL, $tokens::T_VARIABLE)) {\n\t\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append($tokens->currentToken());\n\n\t\t\t\t} elseif ($tokens->nextToken('[', '(')) {\n\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, [$tokens->currentToken()], $this->optionalChainingPass($tokens)->tokens);\n\n\t\t\t\t} else {\n\t\t\t\t\t$expr->append($addBraces);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\n\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Pseudocast (expand).\n\t */\n\tpublic function expandCastPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens('[');\n\t\t$expand = null;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('(expand)') && $tokens->depth === 0) {\n\t\t\t\t$expand = true;\n\t\t\t\t$res->append('],');\n\t\t\t} elseif ($expand && $tokens->isCurrent(',') && !$tokens->depth) {\n\t\t\t\t$expand = false;\n\t\t\t\t$res->append(', [');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\tif ($expand === null) {\n\t\t\t$res->append(']');\n\t\t} else {\n\t\t\t$res->prepend('array_merge(')->append($expand ? ', [])' : '])');\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Quotes symbols to strings.\n\t */\n\tpublic function quotingPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\t$res->append(\n\t\t\t\t$tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& (!$tokens->isPrev(...$tokens::SIGNIFICANT) || $tokens->isPrev(',', '(', '[', '=>', ':', '?', '.', '<', '>', '<=', '>=', '===', '!==', '==', '!=', '<>', '&&', '||', '=', 'and', 'or', 'xor', '??'))\n\t\t\t\t&& (!$tokens->isNext(...$tokens::SIGNIFICANT) || $tokens->isNext(',', ';', ')', ']', '=>', ':', '?', '.', '<', '>', '<=', '>=', '===', '!==', '==', '!=', '<>', '&&', '||', 'and', 'or', 'xor', '??'))\n\t\t\t\t&& !((!$tokens->isPrev(...$tokens::SIGNIFICANT) || $tokens->isPrev('(', ',')) && $tokens->isNext(':'))\n\t\t\t\t&& !preg_match('#^[A-Z_][A-Z0-9_]{2,}$#', $tokens->currentValue())\n\t\t\t\t&& !($tokens->isCurrent('default') && $tokens->isNext('=>'))\n\t\t\t\t\t? \"'\" . $tokens->currentValue() . \"'\"\n\t\t\t\t\t: $tokens->currentToken()\n\t\t\t);\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Converts named arguments name: value to 'name' => value\n\t */\n\tpublic function namedArgumentsPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif (\n\t\t\t\t$tokens->depth === 0\n\t\t\t\t&& $tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& (!$tokens->isPrev(...$tokens::SIGNIFICANT) || $tokens->isPrev(','))\n\t\t\t\t&& $tokens->isNext(':')\n\t\t\t) {\n\t\t\t\t$res->append(\"'\" . $tokens->currentValue() . \"' =>\");\n\t\t\t\t$tokens->nextToken(':');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Converts [name: value] to ['name' => value]\n\t */\n\tpublic function modernArraySyntax(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$res = new MacroTokens;\n\t\t$brackets = [];\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('[', '(', '{')) {\n\t\t\t\t$brackets[] = $tokens->currentValue();\n\t\t\t} elseif ($tokens->isCurrent(']', ')', '}')) {\n\t\t\t\tarray_pop($brackets);\n\t\t\t}\n\n\t\t\tif (end($brackets) === '['\n\t\t\t\t&& $tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t&& ($tokens->isPrev('[', ','))\n\t\t\t\t&& $tokens->isNext(':')\n\t\t\t) {\n\t\t\t\t$res->append(\"'\" . $tokens->currentValue() . \"' =>\");\n\t\t\t\t$tokens->nextToken(':');\n\t\t\t} else {\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Syntax $entry in [item1, item2].\n\t */\n\tpublic function inOperatorPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent($tokens::T_VARIABLE)) {\n\t\t\t\t$start = $tokens->position;\n\t\t\t\t$depth = $tokens->depth;\n\t\t\t\t$expr = $arr = [];\n\n\t\t\t\t$expr[] = $tokens->currentToken();\n\t\t\t\twhile ($tokens->isNext($tokens::T_VARIABLE, $tokens::T_SYMBOL, $tokens::T_NUMBER, $tokens::T_STRING, '[', ']', '(', ')', '->', '?->')\n\t\t\t\t\t&& !$tokens->isNext('in')) {\n\t\t\t\t\t$expr[] = $tokens->nextToken();\n\t\t\t\t}\n\n\t\t\t\tif ($depth === $tokens->depth && $tokens->nextValue('in') && ($arr[] = $tokens->nextToken('['))) {\n\t\t\t\t\twhile ($tokens->isNext(...$tokens::SIGNIFICANT)) {\n\t\t\t\t\t\t$arr[] = $tokens->nextToken();\n\t\t\t\t\t\tif ($tokens->isCurrent(']') && $tokens->depth === $depth) {\n\t\t\t\t\t\t\t$new = array_merge($tokens->parse('in_array('), $expr, $tokens->parse(', '), $arr, $tokens->parse(', true)'));\n\t\t\t\t\t\t\tarray_splice($tokens->tokens, $start, $tokens->position - $start + 1, $new);\n\t\t\t\t\t\t\t$tokens->position = $start + count($new) - 1;\n\t\t\t\t\t\t\tcontinue 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t$tokens->position = $start;\n\t\t\t}\n\t\t}\n\n\t\treturn $tokens->reset();\n\t}\n\n\n\t/**\n\t * Applies sandbox policy.\n\t */\n\tpublic function sandboxPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\tstatic $keywords = [\n\t\t\t'array' => 1, 'catch' => 1, 'clone' => 1, 'empty' => 1, 'for' => 1,\n\t\t\t'foreach' => 1, 'function' => 1, 'if' => 1, 'elseif', 'isset' => 1, 'list' => 1, 'unset' => 1,\n\t\t];\n\n\t\tif (!$this->policy) {\n\t\t\treturn $tokens;\n\t\t}\n\n\t\t$startDepth = $tokens->depth;\n\t\t$res = new MacroTokens;\n\n\t\twhile ($tokens->depth >= $startDepth && $tokens->nextToken()) {\n\t\t\t$static = false;\n\t\t\tif ($tokens->isCurrent('[', '(')) { // starts with expression\n\t\t\t\t$expr = new MacroTokens(array_merge([$tokens->currentToken()], $this->sandboxPass($tokens)->tokens));\n\n\t\t\t} elseif ( // function or class name\n\t\t\t\t$tokens->isCurrent($tokens::T_SYMBOL, '\\\\')\n\t\t\t\t&& empty($keywords[$tokens->currentValue()])\n\t\t\t) {\n\t\t\t\t$expr = new MacroTokens(array_merge([$tokens->currentToken()], $tokens->nextAll($tokens::T_SYMBOL, '\\\\')));\n\t\t\t\t$static = true;\n\n\t\t\t} elseif ($tokens->isCurrent('$')) { // $$$var or ${...}\n\t\t\t\tthrow new CompileException('Forbidden variable variables.');\n\n\t\t\t} elseif ($tokens->isCurrent($tokens::T_VARIABLE, $tokens::T_STRING)) {  // $var or 'func'\n\t\t\t\t$expr = new MacroTokens([$tokens->currentToken()]);\n\n\t\t\t} else { // not a begin\n\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tif ($tokens->nextToken('(')) { // call\n\t\t\t\t\tif ($static) { // global function\n\t\t\t\t\t\t$name = $expr->joinAll();\n\t\t\t\t\t\tif (!$this->policy->isFunctionAllowed($name)) {\n\t\t\t\t\t\t\tthrow new SecurityViolationException(\"Function $name() is not allowed.\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$static = false;\n\t\t\t\t\t\t$expr->append('(');\n\t\t\t\t\t} else { // any calling\n\t\t\t\t\t\t$expr->prepend('$this->call(');\n\t\t\t\t\t\t$expr->append(')(');\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, $this->sandboxPass($tokens)->tokens);\n\n\t\t\t\t} elseif ($tokens->nextToken('->', '?->', '::')) { // property, method or constant\n\t\t\t\t\t$op = $tokens->currentValue();\n\t\t\t\t\tif ($op === '::' && $tokens->nextToken($tokens::T_SYMBOL)) { // is constant?\n\t\t\t\t\t\tif ($tokens->isNext('(')) { // go back, it was not\n\t\t\t\t\t\t\t$tokens->position--;\n\t\t\t\t\t\t} else { // it is\n\t\t\t\t\t\t\t$expr->append('::');\n\t\t\t\t\t\t\t$expr->append($tokens->currentValue());\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($static) { // class name\n\t\t\t\t\t\t$expr->append('::class');\n\t\t\t\t\t\t$static = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t$expr->append(', ');\n\n\t\t\t\t\tif ($tokens->nextToken($tokens::T_SYMBOL)) { // $obj->member or $obj::member\n\t\t\t\t\t\t$member = [$tokens->currentToken()];\n\t\t\t\t\t\t$expr->append(PhpHelpers::dump($tokens->currentValue()));\n\n\t\t\t\t\t} elseif ($tokens->nextToken($tokens::T_VARIABLE)) { // $obj->$var or $obj::$var\n\t\t\t\t\t\t$member = [$tokens->currentToken()];\n\t\t\t\t\t\tif ($op === '::' && !$tokens->isNext('(')) {\n\t\t\t\t\t\t\t$expr->append(PhpHelpers::dump(substr($tokens->currentValue(), 1)));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$expr->append($tokens->currentValue());\n\t\t\t\t\t\t}\n\t\t\t\t\t} elseif ($tokens->nextToken('{')) { // $obj->{...}\n\t\t\t\t\t\t$member = array_merge([$tokens->currentToken()], $this->sandboxPass($tokens)->tokens);\n\t\t\t\t\t\t$expr->append('(string) ');\n\t\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, array_slice($member, 1, -1));\n\n\t\t\t\t\t} else { // $obj->$$$var or $obj::$$$var\n\t\t\t\t\t\t$member = $tokens->nextAll($tokens::T_VARIABLE, '$');\n\t\t\t\t\t\t$expr->tokens = $op === '::' && !$tokens->isNext('(')\n\t\t\t\t\t\t\t? array_merge($expr->tokens, array_slice($member, 1))\n\t\t\t\t\t\t\t: array_merge($expr->tokens, $member);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ($tokens->nextToken('(')) {\n\t\t\t\t\t\t$expr->prepend('$this->call([');\n\t\t\t\t\t\t$expr->append('])(');\n\t\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, $this->sandboxPass($tokens)->tokens);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$expr->prepend('$this->prop(');\n\t\t\t\t\t\t$expr->append(')' . $op);\n\t\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, $member);\n\t\t\t\t\t}\n\t\t\t\t} elseif ($tokens->nextToken('[', '{')) { // array access\n\t\t\t\t\t$static = false;\n\t\t\t\t\t$expr->tokens = array_merge($expr->tokens, [$tokens->currentToken()], $this->sandboxPass($tokens)->tokens);\n\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (true);\n\n\t\t\t$res->tokens = array_merge($res->tokens, $expr->tokens);\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Process inline filters ($var|filter)\n\t */\n\tpublic function inlineModifierPass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$result = new MacroTokens;\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('(', '[')) {\n\t\t\t\t$result->tokens = array_merge($result->tokens, $this->inlineModifierInner($tokens));\n\t\t\t} else {\n\t\t\t\t$result->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\n\t/**\n\t * @return array<array{string, int, int}>\n\t */\n\tprivate function inlineModifierInner(MacroTokens $tokens): array\n\t{\n\t\t$isFunctionOrArray = $tokens->isPrev($tokens::T_VARIABLE, $tokens::T_SYMBOL, ')') || $tokens->isCurrent('[');\n\t\t$result = new MacroTokens;\n\t\t$args = new MacroTokens;\n\t\t$modifiers = new MacroTokens;\n\t\t$current = $args;\n\t\t$anyModifier = false;\n\t\t$result->append($tokens->currentToken());\n\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent('(', '[')) {\n\t\t\t\t$current->tokens = array_merge($current->tokens, $this->inlineModifierInner($tokens));\n\n\t\t\t} elseif ($current !== $modifiers && $tokens->isCurrent('|')) {\n\t\t\t\t$anyModifier = true;\n\t\t\t\t$current = $modifiers;\n\n\t\t\t} elseif ($tokens->isCurrent(')', ']') || ($isFunctionOrArray && $tokens->isCurrent(','))) {\n\t\t\t\t$partTokens = count($modifiers->tokens)\n\t\t\t\t\t? $this->modifierPass($modifiers, $args->tokens)->tokens\n\t\t\t\t\t: $args->tokens;\n\t\t\t\t$result->tokens = array_merge($result->tokens, $partTokens);\n\t\t\t\tif ($tokens->isCurrent(',')) {\n\t\t\t\t\t$result->append($tokens->currentToken());\n\t\t\t\t\t$args = new MacroTokens;\n\t\t\t\t\t$modifiers = new MacroTokens;\n\t\t\t\t\t$current = $args;\n\t\t\t\t\tcontinue;\n\t\t\t\t} elseif ($isFunctionOrArray || !$anyModifier) {\n\t\t\t\t\t$result->append($tokens->currentToken());\n\t\t\t\t} else {\n\t\t\t\t\tarray_shift($result->tokens);\n\t\t\t\t}\n\n\t\t\t\treturn $result->tokens;\n\n\t\t\t} else {\n\t\t\t\t$current->append($tokens->currentToken());\n\t\t\t}\n\t\t}\n\n\t\tthrow new CompileException('Unbalanced brackets.');\n\t}\n\n\n\t/**\n\t * Formats modifiers calling.\n\t * @param  string|array<array{string, int, int}>  $var\n\t * @throws CompileException\n\t */\n\tpublic function modifierPass(MacroTokens $tokens, $var, bool $isContent = false): MacroTokens\n\t{\n\t\t$inside = false;\n\t\t$res = new MacroTokens($var);\n\t\twhile ($tokens->nextToken()) {\n\t\t\tif ($tokens->isCurrent($tokens::T_WHITESPACE)) {\n\t\t\t\t$res->append(' ');\n\n\t\t\t} elseif ($inside) {\n\t\t\t\tif ($tokens->isCurrent(':', ',') && !$tokens->depth) {\n\t\t\t\t\t$res->append(', ');\n\t\t\t\t\t$tokens->nextAll($tokens::T_WHITESPACE);\n\n\t\t\t\t} elseif ($tokens->isCurrent('|') && !$tokens->depth) {\n\t\t\t\t\t$res->append(')');\n\t\t\t\t\t$inside = false;\n\n\t\t\t\t} elseif (\n\t\t\t\t\t!$tokens->depth\n\t\t\t\t\t&& $tokens->isCurrent($tokens::T_SYMBOL)\n\t\t\t\t\t&& $tokens->isPrev(',', ':')\n\t\t\t\t\t&& $tokens->isNext(':')\n\t\t\t\t) {\n\t\t\t\t\t$hint = (clone $tokens)->reset()->joinAll();\n\t\t\t\t\ttrigger_error(\"Colon as argument separator is deprecated, use comma in '$hint'.\", E_USER_DEPRECATED);\n\t\t\t\t\t$res->append($tokens->currentToken());\n\n\t\t\t\t} else {\n\t\t\t\t\t$res->append($tokens->currentToken());\n\t\t\t\t}\n\t\t\t} elseif ($tokens->isCurrent($tokens::T_SYMBOL)) {\n\t\t\t\tif ($tokens->isCurrent('escape')) {\n\t\t\t\t\tif ($isContent) {\n\t\t\t\t\t\t$res->prepend('LR\\Filters::convertTo($\u029f_fi, ' . PhpHelpers::dump(implode($this->context)) . ', ')\n\t\t\t\t\t\t\t->append(')');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$res = $this->escapePass($res);\n\t\t\t\t\t}\n\n\t\t\t\t\t$tokens->nextToken('|');\n\t\t\t\t} elseif (!strcasecmp($tokens->currentValue(), 'checkurl')) {\n\t\t\t\t\t$res->prepend('LR\\Filters::safeUrl(');\n\t\t\t\t\t$inside = true;\n\t\t\t\t} elseif (\n\t\t\t\t\t!strcasecmp($tokens->currentValue(), 'noescape')\n\t\t\t\t\t|| !strcasecmp($tokens->currentValue(), 'nocheck')\n\t\t\t\t) {\n\t\t\t\t\tthrow new SecurityViolationException(\"Filter |{$tokens->currentValue()} is not expected here.\");\n\t\t\t\t} else {\n\t\t\t\t\t$name = $tokens->currentValue();\n\t\t\t\t\tif ($this->policy && !$this->policy->isFilterAllowed($name)) {\n\t\t\t\t\t\tthrow new SecurityViolationException(\"Filter |$name is not allowed.\");\n\t\t\t\t\t}\n\n\t\t\t\t\t$name = strtolower($name);\n\t\t\t\t\t$res->prepend(\n\t\t\t\t\t\t$isContent\n\t\t\t\t\t\t\t? '$this->filters->filterContent(' . PhpHelpers::dump($name) . ', $\u029f_fi, '\n\t\t\t\t\t\t\t: '($this->filters->' . $name . ')('\n\t\t\t\t\t);\n\t\t\t\t\t$inside = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new CompileException(\"Filter name must be alphanumeric string, '{$tokens->currentValue()}' given.\");\n\t\t\t}\n\t\t}\n\n\t\tif ($inside) {\n\t\t\t$res->append(')');\n\t\t}\n\n\t\treturn $res;\n\t}\n\n\n\t/**\n\t * Escapes expression in tokens.\n\t */\n\tpublic function escapePass(MacroTokens $tokens): MacroTokens\n\t{\n\t\t$tokens = clone $tokens;\n\t\t[$contentType, $context] = $this->context;\n\t\tswitch ($contentType) {\n\t\t\tcase Compiler::CONTENT_XHTML:\n\t\t\tcase Compiler::CONTENT_HTML:\n\t\t\t\tswitch ($context) {\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_TEXT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlText(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_TAG:\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_UNQUOTED_URL:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttrUnquoted(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE:\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_URL:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttr(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_JS:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttr(LR\\Filters::escapeJs(')->append('))');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_ATTRIBUTE_CSS:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlAttr(LR\\Filters::escapeCss(')->append('))');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlComment(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_BOGUS_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtml(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_JS:\n\t\t\t\t\tcase Compiler::CONTEXT_HTML_CSS:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escape' . ucfirst($context) . '(')->append(')');\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new CompileException(\"Unknown context $contentType, $context.\");\n\t\t\t\t}\n\t\t\t\t// break omitted\n\t\t\tcase Compiler::CONTENT_XML:\n\t\t\t\tswitch ($context) {\n\t\t\t\t\tcase Compiler::CONTEXT_XML_TEXT:\n\t\t\t\t\tcase Compiler::CONTEXT_XML_ATTRIBUTE:\n\t\t\t\t\tcase Compiler::CONTEXT_XML_BOGUS_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeXml(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_XML_COMMENT:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeHtmlComment(')->append(')');\n\t\t\t\t\tcase Compiler::CONTEXT_XML_TAG:\n\t\t\t\t\t\treturn $tokens->prepend('LR\\Filters::escapeXmlAttrUnquoted(')->append(')');\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new CompileException(\"Unknown context $contentType, $context.\");\n\t\t\t\t}\n\t\t\t\t// break omitted\n\t\t\tcase Compiler::CONTENT_JS:\n\t\t\tcase Compiler::CONTENT_CSS:\n\t\t\tcase Compiler::CONTENT_ICAL:\n\t\t\t\treturn $tokens->prepend('LR\\Filters::escape' . ucfirst($contentType) . '(')->append(')');\n\t\t\tcase Compiler::CONTENT_TEXT:\n\t\t\t\treturn $tokens;\n\t\t\tcase null:\n\t\t\t\treturn $tokens->prepend('($this->filters->escape)(')->append(')');\n\t\t\tdefault:\n\t\t\t\tthrow new CompileException(\"Unknown context $contentType.\");\n\t\t}\n\t}\n}\n", "<?php\n\ndeclare(strict_types=1);\n\nuse Tester\\Assert;\n\n\nrequire __DIR__ . '/../bootstrap.php';\n\n\nclass Test\n{\n\tpublic function __call($nm, $arg)\n\t{\n\t}\n}\n\n\n$latte = new Latte\\Engine;\n$latte->setLoader(new Latte\\Loaders\\StringLoader);\n$latte->setPolicy((new Latte\\Sandbox\\SecurityPolicy)->allowMacros(['=', 'do']));\n$latte->setSandboxMode();\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{var $abc}');\n}, Latte\\CompileException::class, 'Tag {var} is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('<span n:class=\"\"></span>');\n}, Latte\\CompileException::class, 'Tag n:class is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$abc|upper}');\n}, Latte\\CompileException::class, 'Filter |upper is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$abc|noescape}');\n}, Latte\\CompileException::class, 'Filter |noescape is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('<a href=\"{$abc|nocheck}\">');\n}, Latte\\CompileException::class, 'Filter |nocheck is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('<a href=\"{$abc|datastream}\">');\n}, Latte\\CompileException::class, 'Filter |datastream is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{trim(123)}');\n}, Latte\\CompileException::class, 'Function trim() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=\"trim\"(123)}');\n}, Latte\\SecurityViolationException::class, 'Calling trim() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->error(123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj?->error(123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj??->error(123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=[$obj, \"error\"](123)}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, 'Calling Test::error() is not allowed.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->error}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj?->error}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj??->error}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->$prop}', ['obj' => new Test, 'prop' => 'error']);\n}, Latte\\SecurityViolationException::class, \"Access to 'error' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj::$prop}', ['obj' => new Test]);\n}, Latte\\SecurityViolationException::class, \"Access to 'prop' property on a Test object is not allowed.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->method()}', ['obj' => 1]);\n}, Latte\\SecurityViolationException::class, 'Invalid callable.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->renderToString('{=$obj->$prop}', ['obj' => new Test, 'prop' => 1]);\n}, Latte\\SecurityViolationException::class, \"Access to '1' property on a Test object is not allowed.\");\n\nAssert::error(function () use ($latte) {\n\t$latte->renderToString('{=$obj->$prop}', ['obj' => 1, 'prop' => 1]);\n}, PHP_VERSION_ID < 80000 ? E_NOTICE : E_WARNING, '%a% property %a%');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$this->filters}');\n}, Latte\\CompileException::class, 'Forbidden variable $this.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{${\"this\"}}');\n}, Latte\\CompileException::class, 'Forbidden variable variables.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{$$x}}');\n}, Latte\\CompileException::class, 'Forbidden variable variables.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do echo 123}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'echo' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do return 123}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'return' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do yield 123}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'yield' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{do new stdClass}');\n}, Latte\\CompileException::class, \"Forbidden keyword 'new' inside tag.\");\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{=\"{$var}\"}');\n}, Latte\\CompileException::class, 'Forbidden complex expressions in strings.');\n\nAssert::exception(function () use ($latte) {\n\t$latte->compile('{=\"${var}\"}');\n}, Latte\\CompileException::class, 'Forbidden complex expressions in strings.');\n\nAssert::noError(function () use ($latte) {\n\t$latte->compile('{=\\'${var}\\'}');\n});\n"], "filenames": ["src/Latte/Compiler/PhpWriter.php", "tests/Latte/Policy.violations.phpt"], "buggy_code_start_loc": [227, 130], "buggy_code_end_loc": [227, 130], "fixing_code_start_loc": [228, 131], "fixing_code_end_loc": [236, 143], "type": "CWE-79", "message": "Latte is an open source template engine for PHP. Versions since 2.8.0 Latte has included a template sandbox and in affected versions it has been found that a sandbox escape exists allowing for injection into web pages generated from Latte. This may lead to XSS attacks. The issue is fixed in the versions 2.8.8, 2.9.6 and 2.10.8. Users unable to upgrade should not accept template input from untrusted sources.", "other": {"cve": {"id": "CVE-2022-21648", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-04T20:15:08.003", "lastModified": "2022-01-13T17:59:35.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Latte is an open source template engine for PHP. Versions since 2.8.0 Latte has included a template sandbox and in affected versions it has been found that a sandbox escape exists allowing for injection into web pages generated from Latte. This may lead to XSS attacks. The issue is fixed in the versions 2.8.8, 2.9.6 and 2.10.8. Users unable to upgrade should not accept template input from untrusted sources."}, {"lang": "es", "value": "Latte es un motor de plantillas de c\u00f3digo abierto para PHP. Desde la versi\u00f3n 2.8.0, Latte ha incluido un sandbox de plantillas y en las versiones afectadas se ha encontrado que se presenta un escape del sandbox que permite una inyecci\u00f3n en p\u00e1ginas web generadas desde Latte. Esto puede conllevar ataques de tipo XSS. El problema se ha corregido en las versiones 2.8.8, 2.9.6 y 2.10.8. Los usuarios que no puedan actualizar no deben aceptar entradas de plantillas de fuentes no confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nette:latte:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.8", "matchCriteriaId": "3515691E-5081-4D39-957B-892A8C71E590"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nette:latte:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.6", "matchCriteriaId": "D8113EB3-73D5-4895-A62F-6CE6533D5D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nette:latte:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.10.0", "versionEndExcluding": "2.10.8", "matchCriteriaId": "B49D54CC-60AE-48FE-B01A-7CFFD42C7F0A"}]}]}], "references": [{"url": "https://github.com/nette/latte/commit/9e1b4f7d70f7a9c3fa6753ffa7d7e450a3d4abb0", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nette/latte/security/advisories/GHSA-36m2-8rhx-f36j", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nette/latte/commit/9e1b4f7d70f7a9c3fa6753ffa7d7e450a3d4abb0"}}