{"buggy_code": ["import { platform, arch } from 'os'\nimport { platformArchTriples } from '@napi-rs/triples'\nimport Log from '../output/log'\n\nconst ArchName = arch()\nconst PlatformName = platform()\nconst triples = platformArchTriples[PlatformName][ArchName] || []\n\nasync function loadBindings() {\n  return (await loadWasm()) || loadNative()\n}\n\nasync function loadWasm() {\n  // Try to load wasm bindings\n  for (let specifier of ['@next/swc-wasm-web', '@next/swc-wasm-nodejs']) {\n    try {\n      let bindings = await import(specifier)\n      if (specifier === '@next/swc-wasm-web') {\n        bindings = await bindings.default()\n      }\n      return {\n        isWasm: true,\n        transform(src, options) {\n          return Promise.resolve(\n            bindings.transformSync(src.toString(), options)\n          )\n        },\n        minify(src, options) {\n          return Promise.resolve(bindings.minifySync(src.toString(), options))\n        },\n      }\n    } catch (e) {}\n  }\n}\n\nfunction loadNative() {\n  let bindings\n  let loadError\n\n  for (const triple of triples) {\n    try {\n      bindings = require(`@next/swc/native/next-swc.${triple.platformArchABI}.node`)\n      Log.info('Using locally built binary of @next/swc')\n      break\n    } catch (e) {\n      if (e?.code !== 'MODULE_NOT_FOUND') {\n        loadError = e\n      }\n    }\n  }\n\n  if (!bindings) {\n    for (const triple of triples) {\n      try {\n        bindings = require(`@next/swc-${triple.platformArchABI}`)\n        break\n      } catch (e) {\n        if (e?.code !== 'MODULE_NOT_FOUND') {\n          loadError = e\n        }\n      }\n    }\n  }\n\n  if (bindings) {\n    return {\n      isWasm: false,\n      transform(src, options) {\n        const isModule =\n          typeof src !== undefined &&\n          typeof src !== 'string' &&\n          !Buffer.isBuffer(src)\n        options = options || {}\n\n        if (options?.jsc?.parser) {\n          options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript'\n        }\n\n        return bindings.transform(\n          isModule ? JSON.stringify(src) : src,\n          isModule,\n          toBuffer(options)\n        )\n      },\n\n      transformSync(src, options) {\n        if (typeof src === undefined) {\n          throw new Error(\n            \"transformSync doesn't implement reading the file from filesystem\"\n          )\n        } else if (Buffer.isBuffer(src)) {\n          throw new Error(\n            \"transformSync doesn't implement taking the source code as Buffer\"\n          )\n        }\n        const isModule = typeof src !== 'string'\n        options = options || {}\n\n        if (options?.jsc?.parser) {\n          options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript'\n        }\n\n        return bindings.transformSync(\n          isModule ? JSON.stringify(src) : src,\n          isModule,\n          toBuffer(options)\n        )\n      },\n\n      minify(src, options) {\n        return bindings.minify(toBuffer(src), toBuffer(options ?? {}))\n      },\n\n      minifySync(src, options) {\n        return bindings.minifySync(toBuffer(src), toBuffer(options ?? {}))\n      },\n\n      bundle(options) {\n        return bindings.bundle(toBuffer(options))\n      },\n    }\n  }\n\n  if (loadError) {\n    console.error(loadError)\n  }\n\n  Log.error(\n    `Failed to load SWC binary, see more info here: https://nextjs.org/docs/messages/failed-loading-swc`\n  )\n  process.exit(1)\n}\n\nfunction toBuffer(t) {\n  return Buffer.from(JSON.stringify(t))\n}\n\nexport async function isWasm() {\n  let bindings = await loadBindings()\n  return bindings.isWasm\n}\n\nexport async function transform(src, options) {\n  let bindings = await loadBindings()\n  return bindings.transform(src, options)\n}\n\nexport function transformSync(src, options) {\n  let bindings = loadNative()\n  return bindings.transformSync(src, options)\n}\n\nexport async function minify(src, options) {\n  let bindings = await loadBindings()\n  return bindings.minify(src, options)\n}\n\nexport function minifySync(src, options) {\n  let bindings = loadNative()\n  return bindings.minifySync(src, options)\n}\n\nexport async function bundle(options) {\n  let bindings = loadNative()\n  return bindings.bundle(toBuffer(options))\n}\n", "import type { __ApiPreviewProps } from './api-utils'\nimport type { CustomRoutes, Header } from '../lib/load-custom-routes'\nimport type { DomainLocale } from './config'\nimport type { DynamicRoutes, PageChecker, Params, Route } from './router'\nimport type { FetchEventResult } from './web/types'\nimport type { FontManifest } from './font-utils'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { LoadComponentsReturnType } from './load-components'\nimport type { MiddlewareManifest } from '../build/webpack/plugins/middleware-plugin'\nimport type { NextApiRequest, NextApiResponse } from '../shared/lib/utils'\nimport type { NextConfigComplete } from './config-shared'\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'\nimport type { ParsedNextUrl } from '../shared/lib/router/utils/parse-next-url'\nimport type { ParsedUrl } from '../shared/lib/router/utils/parse-url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PrerenderManifest } from '../build'\nimport type { Redirect, Rewrite, RouteType } from '../lib/load-custom-routes'\nimport type { RenderOpts, RenderOptsPartial } from './render'\nimport type { ResponseCacheEntry, ResponseCacheValue } from './response-cache'\nimport type { UrlWithParsedQuery } from 'url'\n\nimport compression from 'next/dist/compiled/compression'\nimport fs from 'fs'\nimport Proxy from 'next/dist/compiled/http-proxy'\nimport { join, relative, resolve, sep } from 'path'\nimport { parse as parseQs, stringify as stringifyQs } from 'querystring'\nimport { format as formatUrl, parse as parseUrl } from 'url'\nimport { getRedirectStatus, modifyRouteRegex } from '../lib/load-custom-routes'\nimport {\n  BUILD_ID_FILE,\n  CLIENT_PUBLIC_FILES_PATH,\n  CLIENT_STATIC_FILES_PATH,\n  CLIENT_STATIC_FILES_RUNTIME,\n  PAGES_MANIFEST,\n  PERMANENT_REDIRECT_STATUS,\n  PRERENDER_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVERLESS_DIRECTORY,\n  SERVER_DIRECTORY,\n  STATIC_STATUS_PAGES,\n  TEMPORARY_REDIRECT_STATUS,\n  MIDDLEWARE_MANIFEST,\n} from '../shared/lib/constants'\nimport {\n  getRouteMatcher,\n  getRouteRegex,\n  getSortedRoutes,\n  isDynamicRoute,\n  getMiddlewareRegex,\n} from '../shared/lib/router/utils'\nimport * as envConfig from '../shared/lib/runtime-config'\nimport {\n  DecodeError,\n  isResSent,\n  normalizeRepeatedSlashes,\n} from '../shared/lib/utils'\nimport {\n  apiResolver,\n  setLazyProp,\n  getCookieParser,\n  tryGetPreviewData,\n} from './api-utils'\nimport { isTargetLikeServerless } from './config'\nimport pathMatch from '../shared/lib/router/utils/path-match'\nimport { recursiveReadDirSync } from './lib/recursive-readdir-sync'\nimport { loadComponents } from './load-components'\nimport { normalizePagePath } from './normalize-page-path'\nimport { renderToHTML } from './render'\nimport { getPagePath, requireFontManifest } from './require'\nimport Router, { replaceBasePath, route } from './router'\nimport {\n  compileNonPath,\n  prepareDestination,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { sendRenderResult, setRevalidateHeaders } from './send-payload'\nimport { serveStatic } from './serve-static'\nimport { IncrementalCache } from './incremental-cache'\nimport { execOnce } from '../shared/lib/utils'\nimport { isBlockedPage, isBot } from './utils'\nimport RenderResult from './render-result'\nimport { loadEnvConfig } from '@next/env'\nimport './node-polyfill-fetch'\nimport { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport { removePathTrailingSlash } from '../client/normalize-trailing-slash'\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\nimport { denormalizePagePath } from './denormalize-page-path'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport * as Log from '../build/output/log'\nimport { detectDomainLocale } from '../shared/lib/i18n/detect-domain-locale'\nimport escapePathDelimiters from '../shared/lib/router/utils/escape-path-delimiters'\nimport { getUtils } from '../build/webpack/loaders/next-serverless-loader/utils'\nimport { PreviewData } from 'next/types'\nimport ResponseCache from './response-cache'\nimport { parseNextUrl } from '../shared/lib/router/utils/parse-next-url'\nimport isError from '../lib/is-error'\nimport { getMiddlewareInfo } from './require'\nimport { MIDDLEWARE_ROUTE } from '../lib/constants'\nimport { run } from './web/sandbox'\nimport { addRequestMeta, getRequestMeta } from './request-meta'\nimport { toNodeHeaders } from './web/utils'\nimport { relativizeURL } from '../shared/lib/router/utils/relativize-url'\n\nconst getCustomRouteMatcher = pathMatch(true)\n\ntype ExpressMiddleware = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  next: (err?: Error) => void\n) => void\n\nexport type FindComponentsResult = {\n  components: LoadComponentsReturnType\n  query: NextParsedUrlQuery\n}\n\ninterface RoutingItem {\n  page: string\n  match: ReturnType<typeof getRouteMatcher>\n  ssr?: boolean\n}\n\nexport interface Options {\n  /**\n   * Object containing the configuration next.config.js\n   */\n  conf: NextConfigComplete\n  /**\n   * Set to false when the server was created by Next.js\n   */\n  customServer?: boolean\n  /**\n   * Tells if Next.js is running in dev mode\n   */\n  dev?: boolean\n  /**\n   * Where the Next project is located\n   */\n  dir?: string\n  /**\n   * Tells if Next.js is running in a Serverless platform\n   */\n  minimalMode?: boolean\n  /**\n   * Hide error messages containing server information\n   */\n  quiet?: boolean\n  /**\n   * The hostname the server is running behind\n   */\n  hostname?: string\n  /**\n   * The port the server is running behind\n   */\n  port?: number\n}\n\nexport interface RequestHandler {\n  (\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery | undefined\n  ): Promise<void>\n}\n\ntype RequestContext = {\n  req: IncomingMessage\n  res: ServerResponse\n  pathname: string\n  query: NextParsedUrlQuery\n  renderOpts: RenderOptsPartial\n}\n\nexport default class Server {\n  protected dir: string\n  protected quiet: boolean\n  protected nextConfig: NextConfigComplete\n  protected distDir: string\n  protected pagesDir?: string\n  protected publicDir: string\n  protected hasStaticDir: boolean\n  protected serverBuildDir: string\n  protected pagesManifest?: PagesManifest\n  protected buildId: string\n  protected minimalMode: boolean\n  protected renderOpts: {\n    poweredByHeader: boolean\n    buildId: string\n    generateEtags: boolean\n    runtimeConfig?: { [key: string]: any }\n    assetPrefix?: string\n    canonicalBase: string\n    dev?: boolean\n    previewProps: __ApiPreviewProps\n    customServer?: boolean\n    ampOptimizerConfig?: { [key: string]: any }\n    basePath: string\n    optimizeFonts: boolean\n    images: string\n    fontManifest: FontManifest\n    optimizeImages: boolean\n    disableOptimizedLoading?: boolean\n    optimizeCss: any\n    locale?: string\n    locales?: string[]\n    defaultLocale?: string\n    domainLocales?: DomainLocale[]\n    distDir: string\n    concurrentFeatures?: boolean\n    crossOrigin?: string\n  }\n  private compression?: ExpressMiddleware\n  private incrementalCache: IncrementalCache\n  private responseCache: ResponseCache\n  protected router: Router\n  protected dynamicRoutes?: DynamicRoutes\n  protected customRoutes: CustomRoutes\n  protected middlewareManifest?: MiddlewareManifest\n  protected middleware?: RoutingItem[]\n  public readonly hostname?: string\n  public readonly port?: number\n\n  public constructor({\n    dir = '.',\n    quiet = false,\n    conf,\n    dev = false,\n    minimalMode = false,\n    customServer = true,\n    hostname,\n    port,\n  }: Options) {\n    this.dir = resolve(dir)\n    this.quiet = quiet\n    loadEnvConfig(this.dir, dev, Log)\n\n    this.nextConfig = conf\n    this.hostname = hostname\n    this.port = port\n\n    this.distDir = join(this.dir, this.nextConfig.distDir)\n    this.publicDir = join(this.dir, CLIENT_PUBLIC_FILES_PATH)\n    this.hasStaticDir = !minimalMode && fs.existsSync(join(this.dir, 'static'))\n\n    // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n      compress,\n    } = this.nextConfig\n\n    this.buildId = this.readBuildId()\n    this.minimalMode = minimalMode\n\n    this.renderOpts = {\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase || '',\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPreviewProps(),\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: JSON.stringify(this.nextConfig.images),\n      optimizeFonts: !!this.nextConfig.optimizeFonts && !dev,\n      fontManifest:\n        this.nextConfig.optimizeFonts && !dev\n          ? requireFontManifest(this.distDir, this._isLikeServerless)\n          : null,\n      optimizeImages: !!this.nextConfig.experimental.optimizeImages,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      disableOptimizedLoading:\n        this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: this.nextConfig.i18n?.domains,\n      distDir: this.distDir,\n      concurrentFeatures: this.nextConfig.experimental.concurrentFeatures,\n      crossOrigin: this.nextConfig.crossOrigin\n        ? this.nextConfig.crossOrigin\n        : undefined,\n    }\n\n    // Only the `publicRuntimeConfig` key is exposed to the client side\n    // It'll be rendered as part of __NEXT_DATA__ on the client side\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n      this.renderOpts.runtimeConfig = publicRuntimeConfig\n    }\n\n    if (compress && this.nextConfig.target === 'server') {\n      this.compression = compression() as ExpressMiddleware\n    }\n\n    // Initialize next/config with the environment configuration\n    envConfig.setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig,\n    })\n\n    this.serverBuildDir = join(\n      this.distDir,\n      this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY\n    )\n    const pagesManifestPath = join(this.serverBuildDir, PAGES_MANIFEST)\n    const middlewareManifestPath = join(\n      join(this.distDir, SERVER_DIRECTORY),\n      MIDDLEWARE_MANIFEST\n    )\n\n    if (!dev) {\n      this.pagesManifest = require(pagesManifestPath)\n      if (!this.minimalMode) {\n        this.middlewareManifest = require(middlewareManifestPath)\n      }\n    }\n\n    this.customRoutes = this.getCustomRoutes()\n    this.router = new Router(this.generateRoutes())\n    this.setAssetPrefix(assetPrefix)\n\n    this.incrementalCache = new IncrementalCache({\n      dev,\n      distDir: this.distDir,\n      pagesDir: join(\n        this.distDir,\n        this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY,\n        'pages'\n      ),\n      locales: this.nextConfig.i18n?.locales,\n      max: this.nextConfig.experimental.isrMemoryCacheSize,\n      flushToDisk: !minimalMode && this.nextConfig.experimental.isrFlushToDisk,\n    })\n    this.responseCache = new ResponseCache(this.incrementalCache)\n\n    /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targeting both serverless and SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_IMAGES`.\n     * TODO(atcastle@): Remove this when experimental.optimizeImages are being cleaned up.\n     */\n    if (this.renderOpts.optimizeFonts) {\n      process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeImages) {\n      process.env.__NEXT_OPTIMIZE_IMAGES = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true)\n    }\n  }\n\n  public logError(err: Error): void {\n    if (this.quiet) return\n    console.error(err)\n  }\n\n  private async handleRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    const urlParts = (req.url || '').split('?')\n    const urlNoQuery = urlParts[0]\n\n    if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n      const cleanUrl = normalizeRepeatedSlashes(req.url!)\n      res.setHeader('Location', cleanUrl)\n      res.setHeader('Refresh', `0;url=${cleanUrl}`)\n      res.statusCode = 308\n      res.end(cleanUrl)\n      return\n    }\n\n    setLazyProp({ req: req as any }, 'cookies', getCookieParser(req.headers))\n\n    // Parse url if parsedUrl not provided\n    if (!parsedUrl || typeof parsedUrl !== 'object') {\n      parsedUrl = parseUrl(req.url!, true)\n    }\n\n    // Parse the querystring ourselves if the user doesn't handle querystring parsing\n    if (typeof parsedUrl.query === 'string') {\n      parsedUrl.query = parseQs(parsedUrl.query)\n    }\n\n    // When there are hostname and port we build an absolute URL\n    const initUrl =\n      this.hostname && this.port\n        ? `http://${this.hostname}:${this.port}${req.url}`\n        : req.url\n\n    addRequestMeta(req, '__NEXT_INIT_URL', initUrl)\n    addRequestMeta(req, '__NEXT_INIT_QUERY', { ...parsedUrl.query })\n\n    const url = parseNextUrl({\n      headers: req.headers,\n      nextConfig: this.nextConfig,\n      url: req.url?.replace(/^\\/+/, '/'),\n    })\n\n    if (url.basePath) {\n      req.url = replaceBasePath(req.url!, this.nextConfig.basePath)\n      addRequestMeta(req, '_nextHadBasePath', true)\n    }\n\n    if (\n      this.minimalMode &&\n      req.headers['x-matched-path'] &&\n      typeof req.headers['x-matched-path'] === 'string'\n    ) {\n      const reqUrlIsDataUrl = req.url?.includes('/_next/data')\n      const matchedPathIsDataUrl =\n        req.headers['x-matched-path']?.includes('/_next/data')\n      const isDataUrl = reqUrlIsDataUrl || matchedPathIsDataUrl\n\n      let parsedPath = parseUrl(\n        isDataUrl ? req.url! : (req.headers['x-matched-path'] as string),\n        true\n      )\n\n      let matchedPathname = parsedPath.pathname!\n\n      let matchedPathnameNoExt = isDataUrl\n        ? matchedPathname.replace(/\\.json$/, '')\n        : matchedPathname\n\n      if (this.nextConfig.i18n) {\n        const localePathResult = normalizeLocalePath(\n          matchedPathname || '/',\n          this.nextConfig.i18n.locales\n        )\n\n        if (localePathResult.detectedLocale) {\n          parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n        }\n      }\n\n      if (isDataUrl) {\n        matchedPathname = denormalizePagePath(matchedPathname)\n        matchedPathnameNoExt = denormalizePagePath(matchedPathnameNoExt)\n      }\n\n      const pageIsDynamic = isDynamicRoute(matchedPathnameNoExt)\n      const combinedRewrites: Rewrite[] = []\n\n      combinedRewrites.push(...this.customRoutes.rewrites.beforeFiles)\n      combinedRewrites.push(...this.customRoutes.rewrites.afterFiles)\n      combinedRewrites.push(...this.customRoutes.rewrites.fallback)\n\n      const utils = getUtils({\n        pageIsDynamic,\n        page: matchedPathnameNoExt,\n        i18n: this.nextConfig.i18n,\n        basePath: this.nextConfig.basePath,\n        rewrites: combinedRewrites,\n      })\n\n      try {\n        // ensure parsedUrl.pathname includes URL before processing\n        // rewrites or they won't match correctly\n        if (this.nextConfig.i18n && !url.locale?.path.detectedLocale) {\n          parsedUrl.pathname = `/${url.locale?.locale}${parsedUrl.pathname}`\n        }\n        utils.handleRewrites(req, parsedUrl)\n\n        // interpolate dynamic params and normalize URL if needed\n        if (pageIsDynamic) {\n          let params: ParsedUrlQuery | false = {}\n\n          Object.assign(parsedUrl.query, parsedPath.query)\n          const paramsResult = utils.normalizeDynamicRouteParams(\n            parsedUrl.query\n          )\n\n          if (paramsResult.hasValidParams) {\n            params = paramsResult.params\n          } else if (req.headers['x-now-route-matches']) {\n            const opts: Record<string, string> = {}\n            params = utils.getParamsFromRouteMatches(\n              req,\n              opts,\n              parsedUrl.query.__nextLocale || ''\n            )\n\n            if (opts.locale) {\n              parsedUrl.query.__nextLocale = opts.locale\n            }\n          } else {\n            params = utils.dynamicRouteMatcher!(matchedPathnameNoExt)\n          }\n\n          if (params) {\n            params = utils.normalizeDynamicRouteParams(params).params\n\n            matchedPathname = utils.interpolateDynamicPath(\n              matchedPathname,\n              params\n            )\n            req.url = utils.interpolateDynamicPath(req.url!, params)\n          }\n\n          if (reqUrlIsDataUrl && matchedPathIsDataUrl) {\n            req.url = formatUrl({\n              ...parsedPath,\n              pathname: matchedPathname,\n            })\n          }\n\n          Object.assign(parsedUrl.query, params)\n          utils.normalizeVercelUrl(req, true)\n        }\n      } catch (err) {\n        if (err instanceof DecodeError) {\n          res.statusCode = 400\n          return this.renderError(null, req, res, '/_error', {})\n        }\n        throw err\n      }\n\n      parsedUrl.pathname = `${this.nextConfig.basePath || ''}${\n        matchedPathname === '/' && this.nextConfig.basePath\n          ? ''\n          : matchedPathname\n      }`\n      url.pathname = parsedUrl.pathname\n    }\n\n    addRequestMeta(req, '__nextHadTrailingSlash', url.locale?.trailingSlash)\n    if (url.locale?.domain) {\n      addRequestMeta(req, '__nextIsLocaleDomain', true)\n    }\n\n    if (url.locale?.path.detectedLocale) {\n      req.url = formatUrl(url)\n      addRequestMeta(req, '__nextStrippedLocale', true)\n      if (url.pathname === '/api' || url.pathname.startsWith('/api/')) {\n        return this.render404(req, res, parsedUrl)\n      }\n    }\n\n    if (!this.minimalMode || !parsedUrl.query.__nextLocale) {\n      if (url?.locale?.locale) {\n        parsedUrl.query.__nextLocale = url.locale.locale\n      }\n    }\n\n    if (url?.locale?.defaultLocale) {\n      parsedUrl.query.__nextDefaultLocale = url.locale.defaultLocale\n    }\n\n    if (url.locale?.redirect) {\n      res.setHeader('Location', url.locale.redirect)\n      res.statusCode = TEMPORARY_REDIRECT_STATUS\n      res.end()\n      return\n    }\n\n    res.statusCode = 200\n    try {\n      return await this.run(req, res, parsedUrl)\n    } catch (err) {\n      if (this.minimalMode || this.renderOpts.dev) {\n        throw err\n      }\n      this.logError(isError(err) ? err : new Error(err + ''))\n      res.statusCode = 500\n      res.end('Internal Server Error')\n    }\n  }\n\n  public getRequestHandler(): RequestHandler {\n    return this.handleRequest.bind(this)\n  }\n\n  public setAssetPrefix(prefix?: string): void {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  // Backwards compatibility\n  public async prepare(): Promise<void> {}\n\n  // Backwards compatibility\n  protected async close(): Promise<void> {}\n\n  protected setImmutableAssetCacheControl(res: ServerResponse): void {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable')\n  }\n\n  protected getCustomRoutes(): CustomRoutes {\n    const customRoutes = require(join(this.distDir, ROUTES_MANIFEST))\n    let rewrites: CustomRoutes['rewrites']\n\n    // rewrites can be stored as an array when an array is\n    // returned in next.config.js so massage them into\n    // the expected object format\n    if (Array.isArray(customRoutes.rewrites)) {\n      rewrites = {\n        beforeFiles: [],\n        afterFiles: customRoutes.rewrites,\n        fallback: [],\n      }\n    } else {\n      rewrites = customRoutes.rewrites\n    }\n    return Object.assign(customRoutes, { rewrites })\n  }\n\n  private _cachedPreviewManifest: PrerenderManifest | undefined\n  protected getPrerenderManifest(): PrerenderManifest {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest\n    }\n    const manifest = require(join(this.distDir, PRERENDER_MANIFEST))\n    return (this._cachedPreviewManifest = manifest)\n  }\n\n  protected getPreviewProps(): __ApiPreviewProps {\n    return this.getPrerenderManifest().preview\n  }\n\n  protected getMiddleware() {\n    const middleware = this.middlewareManifest?.middleware || {}\n    return (\n      this.middlewareManifest?.sortedMiddleware.map((page) => ({\n        match: getRouteMatcher(\n          getMiddlewareRegex(page, MIDDLEWARE_ROUTE.test(middleware[page].name))\n        ),\n        page,\n      })) || []\n    )\n  }\n\n  protected async hasMiddleware(\n    pathname: string,\n    _isSSR?: boolean\n  ): Promise<boolean> {\n    try {\n      return (\n        getMiddlewareInfo({\n          dev: this.renderOpts.dev,\n          distDir: this.distDir,\n          page: pathname,\n          serverless: this._isLikeServerless,\n        }).paths.length > 0\n      )\n    } catch (_) {}\n\n    return false\n  }\n\n  protected async ensureMiddleware(_pathname: string, _isSSR?: boolean) {}\n\n  private middlewareBetaWarning = execOnce(() => {\n    Log.warn(\n      `using beta Middleware (not covered by semver) - https://nextjs.org/docs/messages/beta-middleware`\n    )\n  })\n\n  protected async runMiddleware(params: {\n    request: IncomingMessage\n    response: ServerResponse\n    parsedUrl: ParsedNextUrl\n    parsed: UrlWithParsedQuery\n    onWarning?: (warning: Error) => void\n  }): Promise<FetchEventResult | null> {\n    this.middlewareBetaWarning()\n\n    // For middleware to \"fetch\" we must always provide an absolute URL\n    const url = getRequestMeta(params.request, '__NEXT_INIT_URL')!\n    if (!url.startsWith('http')) {\n      throw new Error(\n        'To use middleware you must provide a `hostname` and `port` to the Next.js Server'\n      )\n    }\n\n    const page: { name?: string; params?: { [key: string]: string } } = {}\n    if (await this.hasPage(params.parsedUrl.pathname)) {\n      page.name = params.parsedUrl.pathname\n    } else if (this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        const matchParams = dynamicRoute.match(params.parsedUrl.pathname)\n        if (matchParams) {\n          page.name = dynamicRoute.page\n          page.params = matchParams\n          break\n        }\n      }\n    }\n\n    const allHeaders = new Headers()\n    let result: FetchEventResult | null = null\n\n    for (const middleware of this.middleware || []) {\n      if (middleware.match(params.parsedUrl.pathname)) {\n        if (!(await this.hasMiddleware(middleware.page, middleware.ssr))) {\n          console.warn(`The Edge Function for ${middleware.page} was not found`)\n          continue\n        }\n\n        await this.ensureMiddleware(middleware.page, middleware.ssr)\n\n        const middlewareInfo = getMiddlewareInfo({\n          dev: this.renderOpts.dev,\n          distDir: this.distDir,\n          page: middleware.page,\n          serverless: this._isLikeServerless,\n        })\n\n        result = await run({\n          name: middlewareInfo.name,\n          paths: middlewareInfo.paths,\n          request: {\n            headers: params.request.headers,\n            method: params.request.method || 'GET',\n            nextConfig: {\n              basePath: this.nextConfig.basePath,\n              i18n: this.nextConfig.i18n,\n              trailingSlash: this.nextConfig.trailingSlash,\n            },\n            url: url,\n            page: page,\n          },\n          useCache: !this.nextConfig.experimental.concurrentFeatures,\n          onWarning: (warning: Error) => {\n            if (params.onWarning) {\n              warning.message += ` \"./${middlewareInfo.name}\"`\n              params.onWarning(warning)\n            }\n          },\n        })\n\n        for (let [key, value] of result.response.headers) {\n          if (key !== 'x-middleware-next') {\n            allHeaders.append(key, value)\n          }\n        }\n\n        if (!this.renderOpts.dev) {\n          result.waitUntil.catch((error) => {\n            console.error(`Uncaught: middleware waitUntil errored`, error)\n          })\n        }\n\n        if (!result.response.headers.has('x-middleware-next')) {\n          break\n        }\n      }\n    }\n\n    if (!result) {\n      this.render404(params.request, params.response, params.parsed)\n    } else {\n      for (let [key, value] of allHeaders) {\n        result.response.headers.set(key, value)\n      }\n    }\n\n    return result\n  }\n\n  protected generateRoutes(): {\n    basePath: string\n    headers: Route[]\n    rewrites: {\n      beforeFiles: Route[]\n      afterFiles: Route[]\n      fallback: Route[]\n    }\n    fsRoutes: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    catchAllMiddleware?: Route\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n    dynamicRoutes: DynamicRoutes | undefined\n    locales: string[]\n  } {\n    const server: Server = this\n    const publicRoutes = fs.existsSync(this.publicDir)\n      ? this.generatePublicRoutes()\n      : []\n\n    const staticFilesRoute = this.hasStaticDir\n      ? [\n          {\n            // It's very important to keep this route's param optional.\n            // (but it should support as many params as needed, separated by '/')\n            // Otherwise this will lead to a pretty simple DOS attack.\n            // See more: https://github.com/vercel/next.js/issues/2617\n            match: route('/static/:path*'),\n            name: 'static catchall',\n            fn: async (req, res, params, parsedUrl) => {\n              const p = join(this.dir, 'static', ...params.path)\n              await this.serveStatic(req, res, p, parsedUrl)\n              return {\n                finished: true,\n              }\n            },\n          } as Route,\n        ]\n      : []\n\n    const fsRoutes: Route[] = [\n      {\n        match: route('/_next/static/:path*'),\n        type: 'route',\n        name: '_next/static catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          // make sure to 404 for /_next/static itself\n          if (!params.path) {\n            await this.render404(req, res, parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          if (\n            params.path[0] === CLIENT_STATIC_FILES_RUNTIME ||\n            params.path[0] === 'chunks' ||\n            params.path[0] === 'css' ||\n            params.path[0] === 'image' ||\n            params.path[0] === 'media' ||\n            params.path[0] === this.buildId ||\n            params.path[0] === 'pages' ||\n            params.path[1] === 'pages'\n          ) {\n            this.setImmutableAssetCacheControl(res)\n          }\n          const p = join(\n            this.distDir,\n            CLIENT_STATIC_FILES_PATH,\n            ...(params.path || [])\n          )\n          await this.serveStatic(req, res, p, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/data/:path*'),\n        type: 'route',\n        name: '_next/data catchall',\n        fn: async (req, res, params, _parsedUrl) => {\n          // Make sure to 404 for /_next/data/ itself and\n          // we also want to 404 if the buildId isn't correct\n          if (!params.path || params.path[0] !== this.buildId) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n          // remove buildId from URL\n          params.path.shift()\n\n          const lastParam = params.path[params.path.length - 1]\n\n          // show 404 if it doesn't end with .json\n          if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          // re-create page's pathname\n          let pathname = `/${params.path.join('/')}`\n          pathname = getRouteFromAssetPath(pathname, '.json')\n\n          if (this.nextConfig.i18n) {\n            const { host } = req?.headers || {}\n            // remove port from host and remove port if present\n            const hostname = host?.split(':')[0].toLowerCase()\n            const localePathResult = normalizeLocalePath(\n              pathname,\n              this.nextConfig.i18n.locales\n            )\n            const { defaultLocale } =\n              detectDomainLocale(this.nextConfig.i18n.domains, hostname) || {}\n\n            let detectedLocale = ''\n\n            if (localePathResult.detectedLocale) {\n              pathname = localePathResult.pathname\n              detectedLocale = localePathResult.detectedLocale\n            }\n\n            _parsedUrl.query.__nextLocale = detectedLocale\n            _parsedUrl.query.__nextDefaultLocale =\n              defaultLocale || this.nextConfig.i18n.defaultLocale\n\n            if (!detectedLocale) {\n              _parsedUrl.query.__nextLocale =\n                _parsedUrl.query.__nextDefaultLocale\n              await this.render404(req, res, _parsedUrl)\n              return { finished: true }\n            }\n          }\n\n          const parsedUrl = parseUrl(pathname, true)\n\n          await this.render(\n            req,\n            res,\n            pathname,\n            { ..._parsedUrl.query, _nextDataReq: '1' },\n            parsedUrl\n          )\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/image'),\n        type: 'route',\n        name: '_next/image catchall',\n        fn: (req, res, _params, parsedUrl) => {\n          if (this.minimalMode) {\n            res.statusCode = 400\n            res.end('Bad Request')\n            return {\n              finished: true,\n            }\n          }\n          const { imageOptimizer } =\n            require('./image-optimizer') as typeof import('./image-optimizer')\n\n          return imageOptimizer(\n            server,\n            req,\n            res,\n            parsedUrl,\n            server.nextConfig,\n            server.distDir,\n            this.renderOpts.dev\n          )\n        },\n      },\n      {\n        match: route('/_next/:path*'),\n        type: 'route',\n        name: '_next catchall',\n        // This path is needed because `render()` does a check for `/_next` and the calls the routing again\n        fn: async (req, res, _params, parsedUrl) => {\n          await this.render404(req, res, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      ...publicRoutes,\n      ...staticFilesRoute,\n    ]\n\n    const restrictedRedirectPaths = ['/_next'].map((p) =>\n      this.nextConfig.basePath ? `${this.nextConfig.basePath}${p}` : p\n    )\n\n    const getCustomRoute = (\n      r: Rewrite | Redirect | Header,\n      type: RouteType\n    ) => {\n      const match = getCustomRouteMatcher(\n        r.source,\n        !(r as any).internal\n          ? (regex: string) =>\n              modifyRouteRegex(\n                regex,\n                type === 'redirect' ? restrictedRedirectPaths : undefined\n              )\n          : undefined\n      )\n\n      return {\n        ...r,\n        type,\n        match,\n        name: type,\n        fn: async (_req, _res, _params, _parsedUrl) => ({ finished: false }),\n      } as Route & Rewrite & Header\n    }\n\n    // Headers come very first\n    const headers = this.minimalMode\n      ? []\n      : this.customRoutes.headers.map((r) => {\n          const headerRoute = getCustomRoute(r, 'header')\n          return {\n            match: headerRoute.match,\n            has: headerRoute.has,\n            type: headerRoute.type,\n            name: `${headerRoute.type} ${headerRoute.source} header route`,\n            fn: async (_req, res, params, _parsedUrl) => {\n              const hasParams = Object.keys(params).length > 0\n\n              for (const header of (headerRoute as Header).headers) {\n                let { key, value } = header\n                if (hasParams) {\n                  key = compileNonPath(key, params)\n                  value = compileNonPath(value, params)\n                }\n                res.setHeader(key, value)\n              }\n              return { finished: false }\n            },\n          } as Route\n        })\n\n    // since initial query values are decoded by querystring.parse\n    // we need to re-encode them here but still allow passing through\n    // values from rewrites/redirects\n    const stringifyQuery = (req: IncomingMessage, query: ParsedUrlQuery) => {\n      const initialQueryValues = Object.values(\n        getRequestMeta(req, '__NEXT_INIT_QUERY') || {}\n      )\n\n      return stringifyQs(query, undefined, undefined, {\n        encodeURIComponent(value) {\n          if (initialQueryValues.some((val) => val === value)) {\n            return encodeURIComponent(value)\n          }\n          return value\n        },\n      })\n    }\n\n    const proxyRequest = async (\n      req: IncomingMessage,\n      res: ServerResponse,\n      parsedUrl: ParsedUrl\n    ) => {\n      const { query } = parsedUrl\n      delete (parsedUrl as any).query\n      parsedUrl.search = stringifyQuery(req, query)\n\n      const target = formatUrl(parsedUrl)\n      const proxy = new Proxy({\n        target,\n        changeOrigin: true,\n        ignorePath: true,\n        xfwd: true,\n        proxyTimeout: 30_000, // limit proxying to 30 seconds\n      })\n\n      await new Promise((proxyResolve, proxyReject) => {\n        let finished = false\n\n        proxy.on('proxyReq', (proxyReq) => {\n          proxyReq.on('close', () => {\n            if (!finished) {\n              finished = true\n              proxyResolve(true)\n            }\n          })\n        })\n        proxy.on('error', (err) => {\n          if (!finished) {\n            finished = true\n            proxyReject(err)\n          }\n        })\n        proxy.web(req, res)\n      })\n\n      return {\n        finished: true,\n      }\n    }\n\n    const redirects = this.minimalMode\n      ? []\n      : this.customRoutes.redirects.map((redirect) => {\n          const redirectRoute = getCustomRoute(redirect, 'redirect')\n          return {\n            internal: redirectRoute.internal,\n            type: redirectRoute.type,\n            match: redirectRoute.match,\n            has: redirectRoute.has,\n            statusCode: redirectRoute.statusCode,\n            name: `Redirect route ${redirectRoute.source}`,\n            fn: async (req, res, params, parsedUrl) => {\n              const { parsedDestination } = prepareDestination({\n                appendParamsToQuery: false,\n                destination: redirectRoute.destination,\n                params: params,\n                query: parsedUrl.query,\n              })\n\n              const { query } = parsedDestination\n              delete (parsedDestination as any).query\n\n              parsedDestination.search = stringifyQuery(req, query)\n\n              let updatedDestination = formatUrl(parsedDestination)\n\n              if (updatedDestination.startsWith('/')) {\n                updatedDestination =\n                  normalizeRepeatedSlashes(updatedDestination)\n              }\n\n              res.setHeader('Location', updatedDestination)\n              res.statusCode = getRedirectStatus(redirectRoute as Redirect)\n\n              // Since IE11 doesn't support the 308 header add backwards\n              // compatibility using refresh header\n              if (res.statusCode === 308) {\n                res.setHeader('Refresh', `0;url=${updatedDestination}`)\n              }\n\n              res.end(updatedDestination)\n              return {\n                finished: true,\n              }\n            },\n          } as Route\n        })\n\n    const buildRewrite = (rewrite: Rewrite, check = true) => {\n      const rewriteRoute = getCustomRoute(rewrite, 'rewrite')\n      return {\n        ...rewriteRoute,\n        check,\n        type: rewriteRoute.type,\n        name: `Rewrite route ${rewriteRoute.source}`,\n        match: rewriteRoute.match,\n        fn: async (req, res, params, parsedUrl) => {\n          const { newUrl, parsedDestination } = prepareDestination({\n            appendParamsToQuery: true,\n            destination: rewriteRoute.destination,\n            params: params,\n            query: parsedUrl.query,\n          })\n\n          // external rewrite, proxy it\n          if (parsedDestination.protocol) {\n            return proxyRequest(req, res, parsedDestination)\n          }\n\n          addRequestMeta(req, '_nextRewroteUrl', newUrl)\n          addRequestMeta(req, '_nextDidRewrite', newUrl !== req.url)\n\n          return {\n            finished: false,\n            pathname: newUrl,\n            query: parsedDestination.query,\n          }\n        },\n      } as Route\n    }\n\n    let beforeFiles: Route[] = []\n    let afterFiles: Route[] = []\n    let fallback: Route[] = []\n\n    if (!this.minimalMode) {\n      if (Array.isArray(this.customRoutes.rewrites)) {\n        afterFiles = this.customRoutes.rewrites.map((r) => buildRewrite(r))\n      } else {\n        beforeFiles = this.customRoutes.rewrites.beforeFiles.map((r) =>\n          buildRewrite(r, false)\n        )\n        afterFiles = this.customRoutes.rewrites.afterFiles.map((r) =>\n          buildRewrite(r)\n        )\n        fallback = this.customRoutes.rewrites.fallback.map((r) =>\n          buildRewrite(r)\n        )\n      }\n    }\n\n    let catchAllMiddleware: Route | undefined\n\n    if (!this.minimalMode) {\n      catchAllMiddleware = {\n        match: route('/:path*'),\n        type: 'route',\n        name: 'middleware catchall',\n        fn: async (req, res, _params, parsed) => {\n          if (!this.middleware?.length) {\n            return { finished: false }\n          }\n\n          const initUrl = getRequestMeta(req, '__NEXT_INIT_URL')!\n          const parsedUrl = parseNextUrl({\n            url: initUrl,\n            headers: req.headers,\n            nextConfig: {\n              basePath: this.nextConfig.basePath,\n              i18n: this.nextConfig.i18n,\n              trailingSlash: this.nextConfig.trailingSlash,\n            },\n          })\n\n          if (!this.middleware?.some((m) => m.match(parsedUrl.pathname))) {\n            return { finished: false }\n          }\n\n          let result: FetchEventResult | null = null\n\n          try {\n            result = await this.runMiddleware({\n              request: req,\n              response: res,\n              parsedUrl: parsedUrl,\n              parsed: parsed,\n            })\n          } catch (err) {\n            if (isError(err) && err.code === 'ENOENT') {\n              await this.render404(req, res, parsed)\n              return { finished: true }\n            }\n\n            const error = isError(err) ? err : new Error(err + '')\n            console.error(error)\n            res.statusCode = 500\n            this.renderError(error, req, res, parsed.pathname || '')\n            return { finished: true }\n          }\n\n          if (result === null) {\n            return { finished: true }\n          }\n\n          if (result.response.headers.has('x-middleware-rewrite')) {\n            const value = result.response.headers.get('x-middleware-rewrite')!\n            const rel = relativizeURL(value, initUrl)\n            result.response.headers.set('x-middleware-rewrite', rel)\n          }\n\n          if (result.response.headers.has('Location')) {\n            const value = result.response.headers.get('Location')!\n            const rel = relativizeURL(value, initUrl)\n            result.response.headers.set('Location', rel)\n          }\n\n          if (\n            !result.response.headers.has('x-middleware-rewrite') &&\n            !result.response.headers.has('x-middleware-next') &&\n            !result.response.headers.has('Location')\n          ) {\n            result.response.headers.set('x-middleware-refresh', '1')\n          }\n\n          result.response.headers.delete('x-middleware-next')\n\n          for (const [key, value] of Object.entries(\n            toNodeHeaders(result.response.headers)\n          )) {\n            if (key !== 'content-encoding' && value !== undefined) {\n              res.setHeader(key, value)\n            }\n          }\n\n          const preflight =\n            req.method === 'HEAD' && req.headers['x-middleware-preflight']\n\n          if (preflight) {\n            res.writeHead(200)\n            res.end()\n            return {\n              finished: true,\n            }\n          }\n\n          res.statusCode = result.response.status\n          res.statusMessage = result.response.statusText\n\n          const location = result.response.headers.get('Location')\n          if (location) {\n            res.statusCode = result.response.status\n            if (res.statusCode === 308) {\n              res.setHeader('Refresh', `0;url=${location}`)\n            }\n\n            res.end()\n            return {\n              finished: true,\n            }\n          }\n\n          if (result.response.headers.has('x-middleware-rewrite')) {\n            const { newUrl, parsedDestination } = prepareDestination({\n              appendParamsToQuery: true,\n              destination: result.response.headers.get('x-middleware-rewrite')!,\n              params: _params,\n              query: parsedUrl.query,\n            })\n\n            if (\n              parsedDestination.protocol &&\n              (parsedDestination.port\n                ? `${parsedDestination.hostname}:${parsedDestination.port}`\n                : parsedDestination.hostname) !== req.headers.host\n            ) {\n              return proxyRequest(req, res, parsedDestination)\n            }\n\n            if (this.nextConfig.i18n) {\n              const localePathResult = normalizeLocalePath(\n                newUrl,\n                this.nextConfig.i18n.locales\n              )\n              if (localePathResult.detectedLocale) {\n                parsedDestination.query.__nextLocale =\n                  localePathResult.detectedLocale\n              }\n            }\n\n            addRequestMeta(req, '_nextRewroteUrl', newUrl)\n            addRequestMeta(req, '_nextDidRewrite', newUrl !== req.url)\n\n            return {\n              finished: false,\n              pathname: newUrl,\n              query: parsedDestination.query,\n            }\n          }\n\n          if (result.response.headers.has('x-middleware-refresh')) {\n            res.writeHead(result.response.status)\n            for await (const chunk of result.response.body || []) {\n              res.write(chunk)\n            }\n            res.end()\n            return {\n              finished: true,\n            }\n          }\n\n          return {\n            finished: false,\n          }\n        },\n      }\n    }\n\n    const catchAllRoute: Route = {\n      match: route('/:path*'),\n      type: 'route',\n      name: 'Catchall render',\n      fn: async (req, res, _params, parsedUrl) => {\n        let { pathname, query } = parsedUrl\n        if (!pathname) {\n          throw new Error('pathname is undefined')\n        }\n\n        // next.js core assumes page path without trailing slash\n        pathname = removePathTrailingSlash(pathname)\n\n        if (this.nextConfig.i18n) {\n          const localePathResult = normalizeLocalePath(\n            pathname,\n            this.nextConfig.i18n?.locales\n          )\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n          }\n        }\n        const bubbleNoFallback = !!query._nextBubbleNoFallback\n\n        if (pathname.match(MIDDLEWARE_ROUTE)) {\n          await this.render404(req, res, parsedUrl)\n          return {\n            finished: true,\n          }\n        }\n\n        if (pathname === '/api' || pathname.startsWith('/api/')) {\n          delete query._nextBubbleNoFallback\n\n          const handled = await this.handleApiRequest(\n            req as NextApiRequest,\n            res as NextApiResponse,\n            pathname,\n            query\n          )\n          if (handled) {\n            return { finished: true }\n          }\n        }\n\n        try {\n          await this.render(req, res, pathname, query, parsedUrl)\n\n          return {\n            finished: true,\n          }\n        } catch (err) {\n          if (err instanceof NoFallbackError && bubbleNoFallback) {\n            return {\n              finished: false,\n            }\n          }\n          throw err\n        }\n      },\n    }\n\n    const { useFileSystemPublicRoutes } = this.nextConfig\n\n    if (useFileSystemPublicRoutes) {\n      this.dynamicRoutes = this.getDynamicRoutes()\n      if (!this.minimalMode) {\n        this.middleware = this.getMiddleware()\n      }\n    }\n\n    return {\n      headers,\n      fsRoutes,\n      rewrites: {\n        beforeFiles,\n        afterFiles,\n        fallback,\n      },\n      redirects,\n      catchAllRoute,\n      catchAllMiddleware,\n      useFileSystemPublicRoutes,\n      dynamicRoutes: this.dynamicRoutes,\n      basePath: this.nextConfig.basePath,\n      pageChecker: this.hasPage.bind(this),\n      locales: this.nextConfig.i18n?.locales || [],\n    }\n  }\n\n  private async getPagePath(\n    pathname: string,\n    locales?: string[]\n  ): Promise<string> {\n    return getPagePath(\n      pathname,\n      this.distDir,\n      this._isLikeServerless,\n      this.renderOpts.dev,\n      locales\n    )\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let found = false\n    try {\n      found = !!(await this.getPagePath(\n        pathname,\n        this.nextConfig.i18n?.locales\n      ))\n    } catch (_) {}\n\n    return found\n  }\n\n  protected async _beforeCatchAllRender(\n    _req: IncomingMessage,\n    _res: ServerResponse,\n    _params: Params,\n    _parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    return false\n  }\n\n  // Used to build API page in development\n  protected async ensureApiPage(_pathname: string): Promise<void> {}\n\n  /**\n   * Resolves `API` request, in development builds on demand\n   * @param req http request\n   * @param res http response\n   * @param pathname path of request\n   */\n  private async handleApiRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery\n  ): Promise<boolean> {\n    let page = pathname\n    let params: Params | boolean = false\n    let pageFound = await this.hasPage(page)\n\n    if (!pageFound && this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        params = dynamicRoute.match(pathname)\n        if (dynamicRoute.page.startsWith('/api') && params) {\n          page = dynamicRoute.page\n          pageFound = true\n          break\n        }\n      }\n    }\n\n    if (!pageFound) {\n      return false\n    }\n    // Make sure the page is built before getting the path\n    // or else it won't be in the manifest yet\n    await this.ensureApiPage(page)\n\n    let builtPagePath\n    try {\n      builtPagePath = await this.getPagePath(page)\n    } catch (err) {\n      if (isError(err) && err.code === 'ENOENT') {\n        return false\n      }\n      throw err\n    }\n\n    const pageModule = await require(builtPagePath)\n    query = { ...query, ...params }\n\n    delete query.__nextLocale\n    delete query.__nextDefaultLocale\n\n    if (!this.renderOpts.dev && this._isLikeServerless) {\n      if (typeof pageModule.default === 'function') {\n        prepareServerlessUrl(req, query)\n        await pageModule.default(req, res)\n        return true\n      }\n    }\n\n    await apiResolver(\n      req,\n      res,\n      query,\n      pageModule,\n      this.renderOpts.previewProps,\n      this.minimalMode,\n      this.renderOpts.dev,\n      page\n    )\n    return true\n  }\n\n  protected generatePublicRoutes(): Route[] {\n    const publicFiles = new Set(\n      recursiveReadDirSync(this.publicDir).map((p) =>\n        encodeURI(p.replace(/\\\\/g, '/'))\n      )\n    )\n\n    return [\n      {\n        match: route('/:path*'),\n        name: 'public folder catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          const pathParts: string[] = params.path || []\n          const { basePath } = this.nextConfig\n\n          // if basePath is defined require it be present\n          if (basePath) {\n            const basePathParts = basePath.split('/')\n            // remove first empty value\n            basePathParts.shift()\n\n            if (\n              !basePathParts.every((part: string, idx: number) => {\n                return part === pathParts[idx]\n              })\n            ) {\n              return { finished: false }\n            }\n\n            pathParts.splice(0, basePathParts.length)\n          }\n\n          let path = `/${pathParts.join('/')}`\n\n          if (!publicFiles.has(path)) {\n            // In `next-dev-server.ts`, we ensure encoded paths match\n            // decoded paths on the filesystem. So we need do the\n            // opposite here: make sure decoded paths match encoded.\n            path = encodeURI(path)\n          }\n\n          if (publicFiles.has(path)) {\n            await this.serveStatic(\n              req,\n              res,\n              join(this.publicDir, ...pathParts),\n              parsedUrl\n            )\n            return {\n              finished: true,\n            }\n          }\n          return {\n            finished: false,\n          }\n        },\n      } as Route,\n    ]\n  }\n\n  protected getDynamicRoutes(): Array<RoutingItem> {\n    const addedPages = new Set<string>()\n\n    return getSortedRoutes(\n      Object.keys(this.pagesManifest!).map(\n        (page) =>\n          normalizeLocalePath(page, this.nextConfig.i18n?.locales).pathname\n      )\n    )\n      .map((page) => {\n        if (addedPages.has(page) || !isDynamicRoute(page)) return null\n        addedPages.add(page)\n        return {\n          page,\n          match: getRouteMatcher(getRouteRegex(page)),\n        }\n      })\n      .filter((item): item is RoutingItem => Boolean(item))\n  }\n\n  private handleCompression(req: IncomingMessage, res: ServerResponse): void {\n    if (this.compression) {\n      this.compression(req, res, () => {})\n    }\n  }\n\n  protected async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    this.handleCompression(req, res)\n\n    try {\n      const matched = await this.router.execute(req, res, parsedUrl)\n      if (matched) {\n        return\n      }\n    } catch (err) {\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n      throw err\n    }\n\n    await this.render404(req, res, parsedUrl)\n  }\n\n  private async pipe(\n    fn: (ctx: RequestContext) => Promise<ResponsePayload | null>,\n    partialContext: {\n      req: IncomingMessage\n      res: ServerResponse\n      pathname: string\n      query: NextParsedUrlQuery\n    }\n  ): Promise<void> {\n    const userAgent = partialContext.req.headers['user-agent']\n    const ctx = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicHTML: userAgent ? !isBot(userAgent) : false,\n      },\n    } as const\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return\n    }\n    const { req, res } = ctx\n    const { body, type, revalidateOptions } = payload\n    if (!isResSent(res)) {\n      const { generateEtags, poweredByHeader, dev } = this.renderOpts\n      if (dev) {\n        // In dev, we should not cache pages for any reason.\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n      return sendRenderResult({\n        req,\n        res,\n        result: body,\n        type,\n        generateEtags,\n        poweredByHeader,\n        options: revalidateOptions,\n      })\n    }\n  }\n\n  private async getStaticHTML(\n    fn: (ctx: RequestContext) => Promise<ResponsePayload | null>,\n    partialContext: {\n      req: IncomingMessage\n      res: ServerResponse\n      pathname: string\n      query: ParsedUrlQuery\n    }\n  ): Promise<string | null> {\n    const payload = await fn({\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicHTML: false,\n      },\n    })\n    if (payload === null) {\n      return null\n    }\n    return payload.body.toUnchunkedString()\n  }\n\n  public async render(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.renderOpts.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !this.minimalMode &&\n      !query._nextDataReq &&\n      (req.url?.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && req.url!.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    // Custom server users can run `app.render()` which needs compression.\n    if (this.renderOpts.customServer) {\n      this.handleCompression(req, res)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    return this.pipe((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async findPageComponents(\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    params: Params | null = null\n  ): Promise<FindComponentsResult | null> {\n    let paths = [\n      // try serving a static AMP version first\n      query.amp ? normalizePagePath(pathname) + '.amp' : null,\n      pathname,\n    ].filter(Boolean)\n\n    if (query.__nextLocale) {\n      paths = [\n        ...paths.map(\n          (path) => `/${query.__nextLocale}${path === '/' ? '' : path}`\n        ),\n        ...paths,\n      ]\n    }\n\n    for (const pagePath of paths) {\n      try {\n        const components = await loadComponents(\n          this.distDir,\n          pagePath!,\n          !this.renderOpts.dev && this._isLikeServerless\n        )\n\n        if (\n          query.__nextLocale &&\n          typeof components.Component === 'string' &&\n          !pagePath?.startsWith(`/${query.__nextLocale}`)\n        ) {\n          // if loading an static HTML file the locale is required\n          // to be present since all HTML files are output under their locale\n          continue\n        }\n\n        return {\n          components,\n          query: {\n            ...(components.getStaticProps\n              ? ({\n                  amp: query.amp,\n                  _nextDataReq: query._nextDataReq,\n                  __nextLocale: query.__nextLocale,\n                  __nextDefaultLocale: query.__nextDefaultLocale,\n                } as NextParsedUrlQuery)\n              : query),\n            ...(params || {}),\n          },\n        }\n      } catch (err) {\n        if (isError(err) && err.code !== 'ENOENT') throw err\n      }\n    }\n    return null\n  }\n\n  protected async getStaticPaths(pathname: string): Promise<{\n    staticPaths: string[] | undefined\n    fallbackMode: 'static' | 'blocking' | false\n  }> {\n    // `staticPaths` is intentionally set to `undefined` as it should've\n    // been caught when checking disk data.\n    const staticPaths = undefined\n\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField =\n      this.getPrerenderManifest().dynamicRoutes[pathname].fallback\n\n    return {\n      staticPaths,\n      fallbackMode:\n        typeof fallbackField === 'string'\n          ? 'static'\n          : fallbackField === null\n          ? 'blocking'\n          : false,\n    }\n  }\n\n  private async renderToResponseWithComponents(\n    { req, res, pathname, renderOpts: opts }: RequestContext,\n    { components, query }: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    const is404Page = pathname === '/404'\n    const is500Page = pathname === '/500'\n\n    const isLikeServerless =\n      typeof components.ComponentMod === 'object' &&\n      typeof (components.ComponentMod as any).renderReqToHTML === 'function'\n    const isSSG = !!components.getStaticProps\n    const hasServerProps = !!components.getServerSideProps\n    const hasStaticPaths = !!components.getStaticPaths\n    const hasGetInitialProps = !!(components.Component as any).getInitialProps\n\n    // Toggle whether or not this is a Data request\n    const isDataReq = !!query._nextDataReq && (isSSG || hasServerProps)\n    delete query._nextDataReq\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isDataReq) {\n      res.statusCode = 404\n    }\n\n    // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n    if (STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.substr(1), 10)\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return {\n        type: 'html',\n        // TODO: Static pages should be serialized as RenderResult\n        body: RenderResult.fromStatic(components.Component),\n      }\n    }\n\n    if (!query.amp) {\n      delete query.amp\n    }\n\n    if (opts.supportsDynamicHTML === true) {\n      // Disable dynamic HTML in cases that we know it won't be generated,\n      // so that we can continue generating a cache key when possible.\n      opts.supportsDynamicHTML =\n        !isSSG &&\n        !isLikeServerless &&\n        !query.amp &&\n        !this.minimalMode &&\n        typeof components.Document?.getInitialProps !== 'function'\n    }\n\n    const defaultLocale = isSSG\n      ? this.nextConfig.i18n?.defaultLocale\n      : query.__nextDefaultLocale\n\n    const locale = query.__nextLocale\n    const locales = this.nextConfig.i18n?.locales\n\n    let previewData: PreviewData\n    let isPreviewMode = false\n\n    if (hasServerProps || isSSG) {\n      previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps)\n      isPreviewMode = previewData !== false\n    }\n\n    // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname =\n      getRequestMeta(req, '_nextRewroteUrl') || urlPathname\n\n    urlPathname = removePathTrailingSlash(urlPathname)\n    resolvedUrlPathname = normalizeLocalePath(\n      removePathTrailingSlash(resolvedUrlPathname),\n      this.nextConfig.i18n?.locales\n    ).pathname\n\n    const stripNextDataPath = (path: string) => {\n      if (path.includes(this.buildId)) {\n        const splitPath = path.substring(\n          path.indexOf(this.buildId) + this.buildId.length\n        )\n\n        path = denormalizePagePath(splitPath.replace(/\\.json$/, ''))\n      }\n\n      if (this.nextConfig.i18n) {\n        return normalizeLocalePath(path, locales).pathname\n      }\n      return path\n    }\n\n    const handleRedirect = (pageData: any) => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n      }\n      const statusCode = getRedirectStatus(redirect)\n      const { basePath } = this.nextConfig\n\n      if (\n        basePath &&\n        redirect.basePath !== false &&\n        redirect.destination.startsWith('/')\n      ) {\n        redirect.destination = `${basePath}${redirect.destination}`\n      }\n\n      if (redirect.destination.startsWith('/')) {\n        redirect.destination = normalizeRepeatedSlashes(redirect.destination)\n      }\n\n      if (statusCode === PERMANENT_REDIRECT_STATUS) {\n        res.setHeader('Refresh', `0;url=${redirect.destination}`)\n      }\n\n      res.statusCode = statusCode\n      res.setHeader('Location', redirect.destination)\n      res.end()\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isDataReq) {\n      resolvedUrlPathname = stripNextDataPath(resolvedUrlPathname)\n      urlPathname = stripNextDataPath(urlPathname)\n    }\n\n    let ssgCacheKey =\n      isPreviewMode || !isSSG || this.minimalMode || opts.supportsDynamicHTML\n        ? null // Preview mode bypasses the cache\n        : `${locale ? `/${locale}` : ''}${\n            (pathname === '/' || resolvedUrlPathname === '/') && locale\n              ? ''\n              : resolvedUrlPathname\n          }${query.amp ? '.amp' : ''}`\n\n    if ((is404Page || is500Page) && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n        query.amp ? '.amp' : ''\n      }`\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey\n        .split('/')\n        .map((seg) => {\n          try {\n            seg = escapePathDelimiters(decodeURIComponent(seg), true)\n          } catch (_) {\n            // An improperly encoded URL was provided\n            throw new DecodeError('failed to decode param')\n          }\n          return seg\n        })\n        .join('/')\n    }\n\n    const doRender: () => Promise<ResponseCacheEntry | null> = async () => {\n      let pageData: any\n      let body: RenderResult | null\n      let sprRevalidate: number | false\n      let isNotFound: boolean | undefined\n      let isRedirect: boolean | undefined\n\n      // handle serverless\n      if (isLikeServerless) {\n        const renderResult = await (\n          components.ComponentMod as any\n        ).renderReqToHTML(req, res, 'passthrough', {\n          locale,\n          locales,\n          defaultLocale,\n          optimizeCss: this.renderOpts.optimizeCss,\n          distDir: this.distDir,\n          fontManifest: this.renderOpts.fontManifest,\n          domainLocales: this.renderOpts.domainLocales,\n        })\n\n        body = renderResult.html\n        pageData = renderResult.renderOpts.pageData\n        sprRevalidate = renderResult.renderOpts.revalidate\n        isNotFound = renderResult.renderOpts.isNotFound\n        isRedirect = renderResult.renderOpts.isRedirect\n      } else {\n        const origQuery = parseUrl(req.url || '', true).query\n        const hadTrailingSlash =\n          urlPathname !== '/' && this.nextConfig.trailingSlash\n\n        const resolvedUrl = formatUrl({\n          pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n          // make sure to only add query values from original URL\n          query: origQuery,\n        })\n\n        const renderOpts: RenderOpts = {\n          ...components,\n          ...opts,\n          isDataReq,\n          resolvedUrl,\n          locale,\n          locales,\n          defaultLocale,\n          // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n          // and not the resolved URL to prevent a hydration mismatch on\n          // asPath\n          resolvedAsPath:\n            hasServerProps || hasGetInitialProps\n              ? formatUrl({\n                  // we use the original URL pathname less the _next/data prefix if\n                  // present\n                  pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                  query: origQuery,\n                })\n              : resolvedUrl,\n        }\n\n        const renderResult = await renderToHTML(\n          req,\n          res,\n          pathname,\n          query,\n          renderOpts\n        )\n\n        body = renderResult\n        // TODO: change this to a different passing mechanism\n        pageData = (renderOpts as any).pageData\n        sprRevalidate = (renderOpts as any).revalidate\n        isNotFound = (renderOpts as any).isNotFound\n        isRedirect = (renderOpts as any).isRedirect\n      }\n\n      let value: ResponseCacheValue | null\n      if (isNotFound) {\n        value = null\n      } else if (isRedirect) {\n        value = { kind: 'REDIRECT', props: pageData }\n      } else {\n        if (!body) {\n          return null\n        }\n        value = { kind: 'PAGE', html: body, pageData }\n      }\n      return { revalidate: sprRevalidate, value }\n    }\n\n    const cacheEntry = await this.responseCache.get(\n      ssgCacheKey,\n      async (hasResolved) => {\n        const isProduction = !this.renderOpts.dev\n        const isDynamicPathname = isDynamicRoute(pathname)\n        const didRespond = hasResolved || isResSent(res)\n\n        let { staticPaths, fallbackMode } = hasStaticPaths\n          ? await this.getStaticPaths(pathname)\n          : { staticPaths: undefined, fallbackMode: false }\n\n        if (\n          fallbackMode === 'static' &&\n          isBot(req.headers['user-agent'] || '')\n        ) {\n          fallbackMode = 'blocking'\n        }\n\n        // When we did not respond from cache, we need to choose to block on\n        // rendering or return a skeleton.\n        //\n        // * Data requests always block.\n        //\n        // * Blocking mode fallback always blocks.\n        //\n        // * Preview mode toggles all pages to be resolved in a blocking manner.\n        //\n        // * Non-dynamic pages should block (though this is an impossible\n        //   case in production).\n        //\n        // * Dynamic pages should return their skeleton if not defined in\n        //   getStaticPaths, then finish the data request on the client-side.\n        //\n        if (\n          this.minimalMode !== true &&\n          fallbackMode !== 'blocking' &&\n          ssgCacheKey &&\n          !didRespond &&\n          !isPreviewMode &&\n          isDynamicPathname &&\n          // Development should trigger fallback when the path is not in\n          // `getStaticPaths`\n          (isProduction ||\n            !staticPaths ||\n            !staticPaths.includes(\n              // we use ssgCacheKey here as it is normalized to match the\n              // encoding from getStaticPaths along with including the locale\n              query.amp ? ssgCacheKey.replace(/\\.amp$/, '') : ssgCacheKey\n            ))\n        ) {\n          if (\n            // In development, fall through to render to handle missing\n            // getStaticPaths.\n            (isProduction || staticPaths) &&\n            // When fallback isn't present, abort this render so we 404\n            fallbackMode !== 'static'\n          ) {\n            throw new NoFallbackError()\n          }\n\n          if (!isDataReq) {\n            // Production already emitted the fallback as static HTML.\n            if (isProduction) {\n              const html = await this.incrementalCache.getFallback(\n                locale ? `/${locale}${pathname}` : pathname\n              )\n              return {\n                value: {\n                  kind: 'PAGE',\n                  html: RenderResult.fromStatic(html),\n                  pageData: {},\n                },\n              }\n            }\n            // We need to generate the fallback on-demand for development.\n            else {\n              query.__nextFallback = 'true'\n              if (isLikeServerless) {\n                prepareServerlessUrl(req, query)\n              }\n              const result = await doRender()\n              if (!result) {\n                return null\n              }\n              // Prevent caching this result\n              delete result.revalidate\n              return result\n            }\n          }\n        }\n\n        const result = await doRender()\n        if (!result) {\n          return null\n        }\n        return {\n          ...result,\n          revalidate:\n            result.revalidate !== undefined\n              ? result.revalidate\n              : /* default to minimum revalidate (this should be an invariant) */ 1,\n        }\n      }\n    )\n\n    if (!cacheEntry) {\n      if (ssgCacheKey) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n      return null\n    }\n\n    const { revalidate, value: cachedData } = cacheEntry\n    const revalidateOptions: any =\n      typeof revalidate !== 'undefined' &&\n      (!this.renderOpts.dev || (hasServerProps && !isDataReq))\n        ? {\n            // When the page is 404 cache-control should not be added unless\n            // we are rendering the 404 page for notFound: true which should\n            // cache according to revalidate correctly\n            private: isPreviewMode || (is404Page && cachedData),\n            stateful: !isSSG,\n            revalidate,\n          }\n        : undefined\n\n    if (!cachedData) {\n      if (revalidateOptions) {\n        setRevalidateHeaders(res, revalidateOptions)\n      }\n      if (isDataReq) {\n        res.statusCode = 404\n        res.end('{\"notFound\":true}')\n        return null\n      } else {\n        await this.render404(\n          req,\n          res,\n          {\n            pathname,\n            query,\n          } as UrlWithParsedQuery,\n          false\n        )\n        return null\n      }\n    } else if (cachedData.kind === 'REDIRECT') {\n      if (isDataReq) {\n        return {\n          type: 'json',\n          body: RenderResult.fromStatic(JSON.stringify(cachedData.props)),\n          revalidateOptions,\n        }\n      } else {\n        await handleRedirect(cachedData.props)\n        return null\n      }\n    } else {\n      return {\n        type: isDataReq ? 'json' : 'html',\n        body: isDataReq\n          ? RenderResult.fromStatic(JSON.stringify(cachedData.pageData))\n          : cachedData.html,\n        revalidateOptions,\n      }\n    }\n  }\n\n  private async renderToResponse(\n    ctx: RequestContext\n  ): Promise<ResponsePayload | null> {\n    const { res, query, pathname } = ctx\n    let page = pathname\n    const bubbleNoFallback = !!query._nextBubbleNoFallback\n    delete query._nextBubbleNoFallback\n\n    try {\n      const result = await this.findPageComponents(pathname, query)\n      if (result) {\n        try {\n          return await this.renderToResponseWithComponents(ctx, result)\n        } catch (err) {\n          const isNoFallbackError = err instanceof NoFallbackError\n\n          if (!isNoFallbackError || (isNoFallbackError && bubbleNoFallback)) {\n            throw err\n          }\n        }\n      }\n\n      if (this.dynamicRoutes) {\n        for (const dynamicRoute of this.dynamicRoutes) {\n          const params = dynamicRoute.match(pathname)\n          if (!params) {\n            continue\n          }\n\n          const dynamicRouteResult = await this.findPageComponents(\n            dynamicRoute.page,\n            query,\n            params\n          )\n          if (dynamicRouteResult) {\n            try {\n              page = dynamicRoute.page\n              return await this.renderToResponseWithComponents(\n                {\n                  ...ctx,\n                  pathname: dynamicRoute.page,\n                  renderOpts: {\n                    ...ctx.renderOpts,\n                    params,\n                  },\n                },\n                dynamicRouteResult\n              )\n            } catch (err) {\n              const isNoFallbackError = err instanceof NoFallbackError\n\n              if (\n                !isNoFallbackError ||\n                (isNoFallbackError && bubbleNoFallback)\n              ) {\n                throw err\n              }\n            }\n          }\n        }\n      }\n    } catch (error) {\n      const err = isError(error) ? error : error ? new Error(error + '') : null\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err\n      }\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        return await this.renderErrorToResponse(ctx, err)\n      }\n\n      res.statusCode = 500\n      const isWrappedError = err instanceof WrappedBuildError\n      const response = await this.renderErrorToResponse(\n        ctx,\n        isWrappedError ? (err as WrappedBuildError).innerError : err\n      )\n\n      if (!isWrappedError) {\n        if (this.minimalMode || this.renderOpts.dev) {\n          if (isError(err)) err.page = page\n          throw err\n        }\n        this.logError(err || new Error(error + ''))\n      }\n      return response\n    }\n    res.statusCode = 404\n    return this.renderErrorToResponse(ctx, null)\n  }\n\n  public async renderToHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    return this.pipe(\n      async (ctx) => {\n        const response = await this.renderErrorToResponse(ctx, err)\n        if (this.minimalMode && res.statusCode === 500) {\n          throw err\n        }\n        return response\n      },\n      { req, res, pathname, query }\n    )\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    Log.warn(\n      `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`\n    )\n  })\n\n  private async renderErrorToResponse(\n    ctx: RequestContext,\n    _err: Error | null\n  ): Promise<ResponsePayload | null> {\n    const { res, query } = ctx\n    let err = _err\n    if (this.renderOpts.dev && !err && res.statusCode === 500) {\n      err = new Error(\n        'An undefined error was thrown sometime during render... ' +\n          'See https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n    try {\n      let result: null | FindComponentsResult = null\n\n      const is404 = res.statusCode === 404\n      let using404Page = false\n\n      // use static 404 page if available and is 404 response\n      if (is404) {\n        result = await this.findPageComponents('/404', query)\n        using404Page = result !== null\n      }\n      let statusPage = `/${res.statusCode}`\n\n      if (!result && STATIC_STATUS_PAGES.includes(statusPage)) {\n        result = await this.findPageComponents(statusPage, query)\n      }\n\n      if (!result) {\n        result = await this.findPageComponents('/_error', query)\n        statusPage = '/_error'\n      }\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !using404Page &&\n        (await this.hasPage('/_error')) &&\n        !(await this.hasPage('/404'))\n      ) {\n        this.customErrorNo404Warn()\n      }\n\n      try {\n        return await this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: statusPage,\n            renderOpts: {\n              ...ctx.renderOpts,\n              err,\n            },\n          },\n          result!\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (error) {\n      const renderToHtmlError = isError(error)\n        ? error\n        : error\n        ? new Error(error + '')\n        : null\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError || new Error(error + ''))\n      }\n      res.statusCode = 500\n      const fallbackComponents = await this.getFallbackErrorComponents()\n\n      if (fallbackComponents) {\n        return this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: '/_error',\n            renderOpts: {\n              ...ctx.renderOpts,\n              // We render `renderToHtmlError` here because `err` is\n              // already captured in the stacktrace.\n              err: isWrappedError\n                ? renderToHtmlError.innerError\n                : renderToHtmlError,\n            },\n          },\n          {\n            query,\n            components: fallbackComponents,\n          }\n        )\n      }\n      return {\n        type: 'html',\n        body: RenderResult.fromStatic('Internal Server Error'),\n      }\n    }\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async getFallbackErrorComponents(): Promise<LoadComponentsReturnType | null> {\n    // The development server will provide an implementation for this\n    return null\n  }\n\n  public async render404(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery,\n    setHeaders = true\n  ): Promise<void> {\n    const { pathname, query }: NextUrlWithParsedQuery = parsedUrl\n      ? parsedUrl\n      : parseUrl(req.url!, true)\n\n    if (this.nextConfig.i18n) {\n      query.__nextLocale =\n        query.__nextLocale || this.nextConfig.i18n.defaultLocale\n      query.__nextDefaultLocale =\n        query.__nextDefaultLocale || this.nextConfig.i18n.defaultLocale\n    }\n\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n\n  public async serveStatic(\n    req: IncomingMessage,\n    res: ServerResponse,\n    path: string,\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    if (!this.isServeableUrl(path)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    if (!(req.method === 'GET' || req.method === 'HEAD')) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      return this.renderError(null, req, res, path)\n    }\n\n    try {\n      await serveStatic(req, res, path)\n    } catch (error) {\n      if (!isError(error)) throw error\n      const err = error as Error & { code?: string; statusCode?: number }\n      if (err.code === 'ENOENT' || err.statusCode === 404) {\n        this.render404(req, res, parsedUrl)\n      } else if (err.statusCode === 412) {\n        res.statusCode = 412\n        return this.renderError(err, req, res, path)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  private _validFilesystemPathSet: Set<string> | null = null\n  private getFilesystemPaths(): Set<string> {\n    if (this._validFilesystemPathSet) {\n      return this._validFilesystemPathSet\n    }\n\n    const pathUserFilesStatic = join(this.dir, 'static')\n    let userFilesStatic: string[] = []\n    if (this.hasStaticDir && fs.existsSync(pathUserFilesStatic)) {\n      userFilesStatic = recursiveReadDirSync(pathUserFilesStatic).map((f) =>\n        join('.', 'static', f)\n      )\n    }\n\n    let userFilesPublic: string[] = []\n    if (this.publicDir && fs.existsSync(this.publicDir)) {\n      userFilesPublic = recursiveReadDirSync(this.publicDir).map((f) =>\n        join('.', 'public', f)\n      )\n    }\n\n    let nextFilesStatic: string[] = []\n\n    nextFilesStatic =\n      !this.minimalMode && fs.existsSync(join(this.distDir, 'static'))\n        ? recursiveReadDirSync(join(this.distDir, 'static')).map((f) =>\n            join('.', relative(this.dir, this.distDir), 'static', f)\n          )\n        : []\n\n    return (this._validFilesystemPathSet = new Set<string>([\n      ...nextFilesStatic,\n      ...userFilesPublic,\n      ...userFilesStatic,\n    ]))\n  }\n\n  protected isServeableUrl(untrustedFileUrl: string): boolean {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n\n    let decodedUntrustedFilePath: string\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl)\n    } catch {\n      return false\n    }\n\n    // (2) Resolve \"up paths\" to determine real request\n    const untrustedFilePath = resolve(decodedUntrustedFilePath)\n\n    // don't allow null bytes anywhere in the file path\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false\n    }\n\n    // Check if .next/static, static and public are in the path.\n    // If not the path is not available.\n    if (\n      (untrustedFilePath.startsWith(join(this.distDir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'public') + sep)) === false\n    ) {\n      return false\n    }\n\n    // Check against the real filesystem paths\n    const filesystemUrls = this.getFilesystemPaths()\n    const resolved = relative(this.dir, untrustedFilePath)\n    return filesystemUrls.has(resolved)\n  }\n\n  protected readBuildId(): string {\n    const buildIdFile = join(this.distDir, BUILD_ID_FILE)\n    try {\n      return fs.readFileSync(buildIdFile, 'utf8').trim()\n    } catch (err) {\n      if (!fs.existsSync(buildIdFile)) {\n        throw new Error(\n          `Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`\n        )\n      }\n\n      throw err\n    }\n  }\n\n  protected get _isLikeServerless(): boolean {\n    return isTargetLikeServerless(this.nextConfig.target)\n  }\n}\n\nfunction prepareServerlessUrl(\n  req: IncomingMessage,\n  query: ParsedUrlQuery\n): void {\n  const curUrl = parseUrl(req.url!, true)\n  req.url = formatUrl({\n    ...curUrl,\n    search: undefined,\n    query: {\n      ...curUrl.query,\n      ...query,\n    },\n  })\n}\n\nclass NoFallbackError extends Error {}\n\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n  innerError: Error\n\n  constructor(innerError: Error) {\n    super()\n    this.innerError = innerError\n  }\n}\n\ntype ResponsePayload = {\n  type: 'html' | 'json'\n  body: RenderResult\n  revalidateOptions?: any\n}\n", "/* eslint-env jest */\n/* global browserName */\nimport webdriver from 'next-webdriver'\nimport { readFileSync } from 'fs'\nimport url from 'url'\nimport { join } from 'path'\nimport {\n  renderViaHTTP,\n  getBrowserBodyText,\n  waitFor,\n  fetchViaHTTP,\n} from 'next-test-utils'\nimport { recursiveReadDir } from 'next/dist/lib/recursive-readdir'\nimport { homedir } from 'os'\n\n// Does the same evaluation checking for INJECTED for 5 seconds after hydration, triggering every 500ms\nasync function checkInjected(browser) {\n  const start = Date.now()\n  while (Date.now() - start < 5000) {\n    const bodyText = await getBrowserBodyText(browser)\n    if (/INJECTED/.test(bodyText)) {\n      throw new Error('Vulnerable to XSS attacks')\n    }\n    await waitFor(500)\n  }\n}\n\nmodule.exports = (context) => {\n  describe('With Security Related Issues', () => {\n    it('should only access files inside .next directory', async () => {\n      const buildId = readFileSync(join(__dirname, '../.next/BUILD_ID'), 'utf8')\n\n      const pathsToCheck = [\n        `/_next/${buildId}/page/../../../info`,\n        `/_next/${buildId}/page/../../../info.js`,\n        `/_next/${buildId}/page/../../../info.json`,\n        `/_next/:buildId/webpack/chunks/../../../info.json`,\n        `/_next/:buildId/webpack/../../../info.json`,\n        `/_next/../../../info.json`,\n        `/static/../../../info.json`,\n        `/static/../info.json`,\n        `/../../../info.json`,\n        `/../../info.json`,\n        `/../info.json`,\n        `/info.json`,\n      ]\n\n      for (const path of pathsToCheck) {\n        const data = await renderViaHTTP(context.appPort, path)\n        expect(data.includes('cool-version')).toBeFalsy()\n      }\n    })\n\n    it('should not allow accessing files outside .next/static directory', async () => {\n      const pathsToCheck = [\n        `/_next/static/../server/pages-manifest.json`,\n        `/_next/static/../server/build-manifest.json`,\n        `/_next/static/../BUILD_ID`,\n        `/_next/static/../routes-manifest.json`,\n      ]\n      for (const path of pathsToCheck) {\n        const res = await fetchViaHTTP(context.appPort, path)\n        const text = await res.text()\n        try {\n          expect(res.status).toBe(404)\n          expect(text).toMatch(/This page could not be found/)\n        } catch (err) {\n          throw new Error(`Path ${path} accessible from the browser`)\n        }\n      }\n    })\n\n    it(\"should not leak the user's home directory into the build\", async () => {\n      const buildId = readFileSync(join(__dirname, '../.next/BUILD_ID'), 'utf8')\n\n      const readPath = join(__dirname, `../.next/static/${buildId}`)\n      const buildFiles = await recursiveReadDir(readPath, /\\.js$/)\n\n      if (buildFiles.length < 1) {\n        throw new Error('Could not locate any build files')\n      }\n\n      const homeDir = homedir()\n      buildFiles.forEach((buildFile) => {\n        const content = readFileSync(join(readPath, buildFile), 'utf8')\n        if (content.includes(homeDir)) {\n          throw new Error(\n            `Found the user's home directory in: ${buildFile}, ${homeDir}\\n\\n${content}`\n          )\n        }\n        // TODO: this checks the monorepo's path currently, we should check\n        // the Next.js apps directory instead once using isolated next\n        const checkPathProject = join(__dirname, ...Array(4).fill('..'))\n        if (\n          content.includes(checkPathProject) ||\n          (process.platform.match(/win/) &&\n            content.includes(checkPathProject.replace(/\\\\/g, '\\\\\\\\')))\n        ) {\n          throw new Error(\n            `Found the project path in: ${buildFile}, ${checkPathProject}\\n\\n${content}`\n          )\n        }\n      })\n    })\n\n    it('should prevent URI based XSS attacks', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        '/\\',document.body.innerHTML=\"INJECTED\",\\''\n      )\n      await checkInjected(browser)\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using single quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/'-(document.body.innerHTML='INJECTED')-'`\n      )\n      await checkInjected(browser)\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using double quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/\"-(document.body.innerHTML='INJECTED')-\"`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using semicolons and double quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/;\"-(document.body.innerHTML='INJECTED')-\"`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using semicolons and single quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/;'-(document.body.innerHTML='INJECTED')-'`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using src', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/javascript:(document.body.innerHTML='INJECTED')`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using querystring', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/?javascript=(document.body.innerHTML='INJECTED')`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using querystring and quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/?javascript=\"(document.body.innerHTML='INJECTED')\"`\n      )\n      await checkInjected(browser)\n      await browser.close()\n    })\n\n    it('should handle encoded value in the pathname correctly \\\\', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect/me/to-about/' + encodeURI('\\\\google.com'),\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe(encodeURI('/\\\\google.com/about'))\n      expect(hostname).toBe('localhost')\n    })\n\n    it('should handle encoded value in the pathname correctly %', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect/me/to-about/%25google.com',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe('/%25google.com/about')\n      expect(hostname).toBe('localhost')\n    })\n\n    it('should handle encoded value in the query correctly', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/trailing-redirect/?url=https%3A%2F%2Fgoogle.com%2Fimage%3Fcrop%3Dfocalpoint%26w%3D24&w=1200&q=100',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname, query } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(308)\n      expect(pathname).toBe('/trailing-redirect')\n      expect(hostname).toBe('localhost')\n      expect(query).toBe(\n        'url=https%3A%2F%2Fgoogle.com%2Fimage%3Fcrop%3Dfocalpoint%26w%3D24&w=1200&q=100'\n      )\n    })\n\n    it('should handle encoded value in the pathname correctly /', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect/me/to-about/%2fgoogle.com',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe('/%2fgoogle.com/about')\n      expect(hostname).not.toBe('google.com')\n    })\n\n    it('should handle encoded value in the pathname to query correctly (/)', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect-query-test/%2Fgoogle.com',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname, query } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe('/about')\n      expect(query).toBe('foo=%2Fgoogle.com')\n      expect(hostname).not.toBe('google.com')\n      expect(hostname).not.toMatch(/google/)\n    })\n\n    it('should handle encoded / value for trailing slash correctly', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/%2fexample.com/',\n        undefined,\n        { redirect: 'manual' }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(308)\n      expect(pathname).toBe('/%2fexample.com')\n      expect(hostname).not.toBe('example.com')\n    })\n\n    if (browserName !== 'internet explorer') {\n      it('should not execute script embedded inside svg image', async () => {\n        let browser\n        try {\n          browser = await webdriver(context.appPort, '/svg-image')\n          await browser.eval(`document.getElementById(\"img\").scrollIntoView()`)\n          expect(\n            await browser.elementById('img').getAttribute('src')\n          ).toContain('xss.svg')\n          expect(await browser.elementById('msg').text()).toBe('safe')\n          browser = await webdriver(\n            context.appPort,\n            '/_next/image?url=%2Fxss.svg&w=256&q=75'\n          )\n          expect(await browser.elementById('msg').text()).toBe('safe')\n        } finally {\n          if (browser) await browser.close()\n        }\n      })\n    }\n  })\n}\n"], "fixing_code": ["import { platform, arch } from 'os'\nimport { platformArchTriples } from '@napi-rs/triples'\nimport * as Log from '../output/log'\n\nconst ArchName = arch()\nconst PlatformName = platform()\nconst triples = platformArchTriples[PlatformName][ArchName] || []\n\nasync function loadBindings() {\n  return (await loadWasm()) || loadNative()\n}\n\nasync function loadWasm() {\n  // Try to load wasm bindings\n  for (let specifier of ['@next/swc-wasm-web', '@next/swc-wasm-nodejs']) {\n    try {\n      let bindings = await import(specifier)\n      if (specifier === '@next/swc-wasm-web') {\n        bindings = await bindings.default()\n      }\n      return {\n        isWasm: true,\n        transform(src, options) {\n          return Promise.resolve(\n            bindings.transformSync(src.toString(), options)\n          )\n        },\n        minify(src, options) {\n          return Promise.resolve(bindings.minifySync(src.toString(), options))\n        },\n      }\n    } catch (e) {}\n  }\n}\n\nfunction loadNative() {\n  let bindings\n  let loadError\n\n  for (const triple of triples) {\n    try {\n      bindings = require(`@next/swc/native/next-swc.${triple.platformArchABI}.node`)\n      Log.info('Using locally built binary of @next/swc')\n      break\n    } catch (e) {\n      if (e?.code !== 'MODULE_NOT_FOUND') {\n        loadError = e\n      }\n    }\n  }\n\n  if (!bindings) {\n    for (const triple of triples) {\n      try {\n        bindings = require(`@next/swc-${triple.platformArchABI}`)\n        break\n      } catch (e) {\n        if (e?.code !== 'MODULE_NOT_FOUND') {\n          loadError = e\n        }\n      }\n    }\n  }\n\n  if (bindings) {\n    return {\n      isWasm: false,\n      transform(src, options) {\n        const isModule =\n          typeof src !== undefined &&\n          typeof src !== 'string' &&\n          !Buffer.isBuffer(src)\n        options = options || {}\n\n        if (options?.jsc?.parser) {\n          options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript'\n        }\n\n        return bindings.transform(\n          isModule ? JSON.stringify(src) : src,\n          isModule,\n          toBuffer(options)\n        )\n      },\n\n      transformSync(src, options) {\n        if (typeof src === undefined) {\n          throw new Error(\n            \"transformSync doesn't implement reading the file from filesystem\"\n          )\n        } else if (Buffer.isBuffer(src)) {\n          throw new Error(\n            \"transformSync doesn't implement taking the source code as Buffer\"\n          )\n        }\n        const isModule = typeof src !== 'string'\n        options = options || {}\n\n        if (options?.jsc?.parser) {\n          options.jsc.parser.syntax = options.jsc.parser.syntax ?? 'ecmascript'\n        }\n\n        return bindings.transformSync(\n          isModule ? JSON.stringify(src) : src,\n          isModule,\n          toBuffer(options)\n        )\n      },\n\n      minify(src, options) {\n        return bindings.minify(toBuffer(src), toBuffer(options ?? {}))\n      },\n\n      minifySync(src, options) {\n        return bindings.minifySync(toBuffer(src), toBuffer(options ?? {}))\n      },\n\n      bundle(options) {\n        return bindings.bundle(toBuffer(options))\n      },\n    }\n  }\n\n  if (loadError) {\n    console.error(loadError)\n  }\n\n  Log.error(\n    `Failed to load SWC binary, see more info here: https://nextjs.org/docs/messages/failed-loading-swc`\n  )\n  process.exit(1)\n}\n\nfunction toBuffer(t) {\n  return Buffer.from(JSON.stringify(t))\n}\n\nexport async function isWasm() {\n  let bindings = await loadBindings()\n  return bindings.isWasm\n}\n\nexport async function transform(src, options) {\n  let bindings = await loadBindings()\n  return bindings.transform(src, options)\n}\n\nexport function transformSync(src, options) {\n  let bindings = loadNative()\n  return bindings.transformSync(src, options)\n}\n\nexport async function minify(src, options) {\n  let bindings = await loadBindings()\n  return bindings.minify(src, options)\n}\n\nexport function minifySync(src, options) {\n  let bindings = loadNative()\n  return bindings.minifySync(src, options)\n}\n\nexport async function bundle(options) {\n  let bindings = loadNative()\n  return bindings.bundle(toBuffer(options))\n}\n", "import type { __ApiPreviewProps } from './api-utils'\nimport type { CustomRoutes, Header } from '../lib/load-custom-routes'\nimport type { DomainLocale } from './config'\nimport type { DynamicRoutes, PageChecker, Params, Route } from './router'\nimport type { FetchEventResult } from './web/types'\nimport type { FontManifest } from './font-utils'\nimport type { IncomingMessage, ServerResponse } from 'http'\nimport type { LoadComponentsReturnType } from './load-components'\nimport type { MiddlewareManifest } from '../build/webpack/plugins/middleware-plugin'\nimport type { NextApiRequest, NextApiResponse } from '../shared/lib/utils'\nimport type { NextConfigComplete } from './config-shared'\nimport type { NextParsedUrlQuery, NextUrlWithParsedQuery } from './request-meta'\nimport type { ParsedNextUrl } from '../shared/lib/router/utils/parse-next-url'\nimport type { ParsedUrl } from '../shared/lib/router/utils/parse-url'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { PrerenderManifest } from '../build'\nimport type { Redirect, Rewrite, RouteType } from '../lib/load-custom-routes'\nimport type { RenderOpts, RenderOptsPartial } from './render'\nimport type { ResponseCacheEntry, ResponseCacheValue } from './response-cache'\nimport type { UrlWithParsedQuery } from 'url'\n\nimport compression from 'next/dist/compiled/compression'\nimport fs from 'fs'\nimport Proxy from 'next/dist/compiled/http-proxy'\nimport { join, relative, resolve, sep } from 'path'\nimport { parse as parseQs, stringify as stringifyQs } from 'querystring'\nimport { format as formatUrl, parse as parseUrl } from 'url'\nimport { getRedirectStatus, modifyRouteRegex } from '../lib/load-custom-routes'\nimport {\n  BUILD_ID_FILE,\n  CLIENT_PUBLIC_FILES_PATH,\n  CLIENT_STATIC_FILES_PATH,\n  CLIENT_STATIC_FILES_RUNTIME,\n  PAGES_MANIFEST,\n  PERMANENT_REDIRECT_STATUS,\n  PRERENDER_MANIFEST,\n  ROUTES_MANIFEST,\n  SERVERLESS_DIRECTORY,\n  SERVER_DIRECTORY,\n  STATIC_STATUS_PAGES,\n  TEMPORARY_REDIRECT_STATUS,\n  MIDDLEWARE_MANIFEST,\n} from '../shared/lib/constants'\nimport {\n  getRouteMatcher,\n  getRouteRegex,\n  getSortedRoutes,\n  isDynamicRoute,\n  getMiddlewareRegex,\n} from '../shared/lib/router/utils'\nimport * as envConfig from '../shared/lib/runtime-config'\nimport {\n  DecodeError,\n  isResSent,\n  normalizeRepeatedSlashes,\n} from '../shared/lib/utils'\nimport {\n  apiResolver,\n  setLazyProp,\n  getCookieParser,\n  tryGetPreviewData,\n} from './api-utils'\nimport { isTargetLikeServerless } from './config'\nimport pathMatch from '../shared/lib/router/utils/path-match'\nimport { recursiveReadDirSync } from './lib/recursive-readdir-sync'\nimport { loadComponents } from './load-components'\nimport { normalizePagePath } from './normalize-page-path'\nimport { renderToHTML } from './render'\nimport { getPagePath, requireFontManifest } from './require'\nimport Router, { replaceBasePath, route } from './router'\nimport {\n  compileNonPath,\n  prepareDestination,\n} from '../shared/lib/router/utils/prepare-destination'\nimport { sendRenderResult, setRevalidateHeaders } from './send-payload'\nimport { serveStatic } from './serve-static'\nimport { IncrementalCache } from './incremental-cache'\nimport { execOnce } from '../shared/lib/utils'\nimport { isBlockedPage, isBot } from './utils'\nimport RenderResult from './render-result'\nimport { loadEnvConfig } from '@next/env'\nimport './node-polyfill-fetch'\nimport { PagesManifest } from '../build/webpack/plugins/pages-manifest-plugin'\nimport { removePathTrailingSlash } from '../client/normalize-trailing-slash'\nimport getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\nimport { denormalizePagePath } from './denormalize-page-path'\nimport { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\nimport * as Log from '../build/output/log'\nimport { detectDomainLocale } from '../shared/lib/i18n/detect-domain-locale'\nimport escapePathDelimiters from '../shared/lib/router/utils/escape-path-delimiters'\nimport { getUtils } from '../build/webpack/loaders/next-serverless-loader/utils'\nimport { PreviewData } from 'next/types'\nimport ResponseCache from './response-cache'\nimport { parseNextUrl } from '../shared/lib/router/utils/parse-next-url'\nimport isError from '../lib/is-error'\nimport { getMiddlewareInfo } from './require'\nimport { MIDDLEWARE_ROUTE } from '../lib/constants'\nimport { run } from './web/sandbox'\nimport { addRequestMeta, getRequestMeta } from './request-meta'\nimport { toNodeHeaders } from './web/utils'\nimport { relativizeURL } from '../shared/lib/router/utils/relativize-url'\n\nconst getCustomRouteMatcher = pathMatch(true)\n\ntype ExpressMiddleware = (\n  req: IncomingMessage,\n  res: ServerResponse,\n  next: (err?: Error) => void\n) => void\n\nexport type FindComponentsResult = {\n  components: LoadComponentsReturnType\n  query: NextParsedUrlQuery\n}\n\ninterface RoutingItem {\n  page: string\n  match: ReturnType<typeof getRouteMatcher>\n  ssr?: boolean\n}\n\nexport interface Options {\n  /**\n   * Object containing the configuration next.config.js\n   */\n  conf: NextConfigComplete\n  /**\n   * Set to false when the server was created by Next.js\n   */\n  customServer?: boolean\n  /**\n   * Tells if Next.js is running in dev mode\n   */\n  dev?: boolean\n  /**\n   * Where the Next project is located\n   */\n  dir?: string\n  /**\n   * Tells if Next.js is running in a Serverless platform\n   */\n  minimalMode?: boolean\n  /**\n   * Hide error messages containing server information\n   */\n  quiet?: boolean\n  /**\n   * The hostname the server is running behind\n   */\n  hostname?: string\n  /**\n   * The port the server is running behind\n   */\n  port?: number\n}\n\nexport interface RequestHandler {\n  (\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery | undefined\n  ): Promise<void>\n}\n\ntype RequestContext = {\n  req: IncomingMessage\n  res: ServerResponse\n  pathname: string\n  query: NextParsedUrlQuery\n  renderOpts: RenderOptsPartial\n}\n\nexport default class Server {\n  protected dir: string\n  protected quiet: boolean\n  protected nextConfig: NextConfigComplete\n  protected distDir: string\n  protected pagesDir?: string\n  protected publicDir: string\n  protected hasStaticDir: boolean\n  protected serverBuildDir: string\n  protected pagesManifest?: PagesManifest\n  protected buildId: string\n  protected minimalMode: boolean\n  protected renderOpts: {\n    poweredByHeader: boolean\n    buildId: string\n    generateEtags: boolean\n    runtimeConfig?: { [key: string]: any }\n    assetPrefix?: string\n    canonicalBase: string\n    dev?: boolean\n    previewProps: __ApiPreviewProps\n    customServer?: boolean\n    ampOptimizerConfig?: { [key: string]: any }\n    basePath: string\n    optimizeFonts: boolean\n    images: string\n    fontManifest: FontManifest\n    optimizeImages: boolean\n    disableOptimizedLoading?: boolean\n    optimizeCss: any\n    locale?: string\n    locales?: string[]\n    defaultLocale?: string\n    domainLocales?: DomainLocale[]\n    distDir: string\n    concurrentFeatures?: boolean\n    crossOrigin?: string\n  }\n  private compression?: ExpressMiddleware\n  private incrementalCache: IncrementalCache\n  private responseCache: ResponseCache\n  protected router: Router\n  protected dynamicRoutes?: DynamicRoutes\n  protected customRoutes: CustomRoutes\n  protected middlewareManifest?: MiddlewareManifest\n  protected middleware?: RoutingItem[]\n  public readonly hostname?: string\n  public readonly port?: number\n\n  public constructor({\n    dir = '.',\n    quiet = false,\n    conf,\n    dev = false,\n    minimalMode = false,\n    customServer = true,\n    hostname,\n    port,\n  }: Options) {\n    this.dir = resolve(dir)\n    this.quiet = quiet\n    loadEnvConfig(this.dir, dev, Log)\n\n    this.nextConfig = conf\n    this.hostname = hostname\n    this.port = port\n\n    this.distDir = join(this.dir, this.nextConfig.distDir)\n    this.publicDir = join(this.dir, CLIENT_PUBLIC_FILES_PATH)\n    this.hasStaticDir = !minimalMode && fs.existsSync(join(this.dir, 'static'))\n\n    // Only serverRuntimeConfig needs the default\n    // publicRuntimeConfig gets it's default in client/index.js\n    const {\n      serverRuntimeConfig = {},\n      publicRuntimeConfig,\n      assetPrefix,\n      generateEtags,\n      compress,\n    } = this.nextConfig\n\n    this.buildId = this.readBuildId()\n    this.minimalMode = minimalMode\n\n    this.renderOpts = {\n      poweredByHeader: this.nextConfig.poweredByHeader,\n      canonicalBase: this.nextConfig.amp.canonicalBase || '',\n      buildId: this.buildId,\n      generateEtags,\n      previewProps: this.getPreviewProps(),\n      customServer: customServer === true ? true : undefined,\n      ampOptimizerConfig: this.nextConfig.experimental.amp?.optimizer,\n      basePath: this.nextConfig.basePath,\n      images: JSON.stringify(this.nextConfig.images),\n      optimizeFonts: !!this.nextConfig.optimizeFonts && !dev,\n      fontManifest:\n        this.nextConfig.optimizeFonts && !dev\n          ? requireFontManifest(this.distDir, this._isLikeServerless)\n          : null,\n      optimizeImages: !!this.nextConfig.experimental.optimizeImages,\n      optimizeCss: this.nextConfig.experimental.optimizeCss,\n      disableOptimizedLoading:\n        this.nextConfig.experimental.disableOptimizedLoading,\n      domainLocales: this.nextConfig.i18n?.domains,\n      distDir: this.distDir,\n      concurrentFeatures: this.nextConfig.experimental.concurrentFeatures,\n      crossOrigin: this.nextConfig.crossOrigin\n        ? this.nextConfig.crossOrigin\n        : undefined,\n    }\n\n    // Only the `publicRuntimeConfig` key is exposed to the client side\n    // It'll be rendered as part of __NEXT_DATA__ on the client side\n    if (Object.keys(publicRuntimeConfig).length > 0) {\n      this.renderOpts.runtimeConfig = publicRuntimeConfig\n    }\n\n    if (compress && this.nextConfig.target === 'server') {\n      this.compression = compression() as ExpressMiddleware\n    }\n\n    // Initialize next/config with the environment configuration\n    envConfig.setConfig({\n      serverRuntimeConfig,\n      publicRuntimeConfig,\n    })\n\n    this.serverBuildDir = join(\n      this.distDir,\n      this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY\n    )\n    const pagesManifestPath = join(this.serverBuildDir, PAGES_MANIFEST)\n    const middlewareManifestPath = join(\n      join(this.distDir, SERVER_DIRECTORY),\n      MIDDLEWARE_MANIFEST\n    )\n\n    if (!dev) {\n      this.pagesManifest = require(pagesManifestPath)\n      if (!this.minimalMode) {\n        this.middlewareManifest = require(middlewareManifestPath)\n      }\n    }\n\n    this.customRoutes = this.getCustomRoutes()\n    this.router = new Router(this.generateRoutes())\n    this.setAssetPrefix(assetPrefix)\n\n    this.incrementalCache = new IncrementalCache({\n      dev,\n      distDir: this.distDir,\n      pagesDir: join(\n        this.distDir,\n        this._isLikeServerless ? SERVERLESS_DIRECTORY : SERVER_DIRECTORY,\n        'pages'\n      ),\n      locales: this.nextConfig.i18n?.locales,\n      max: this.nextConfig.experimental.isrMemoryCacheSize,\n      flushToDisk: !minimalMode && this.nextConfig.experimental.isrFlushToDisk,\n    })\n    this.responseCache = new ResponseCache(this.incrementalCache)\n\n    /**\n     * This sets environment variable to be used at the time of SSR by head.tsx.\n     * Using this from process.env allows targeting both serverless and SSR by calling\n     * `process.env.__NEXT_OPTIMIZE_IMAGES`.\n     * TODO(atcastle@): Remove this when experimental.optimizeImages are being cleaned up.\n     */\n    if (this.renderOpts.optimizeFonts) {\n      process.env.__NEXT_OPTIMIZE_FONTS = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeImages) {\n      process.env.__NEXT_OPTIMIZE_IMAGES = JSON.stringify(true)\n    }\n    if (this.renderOpts.optimizeCss) {\n      process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true)\n    }\n  }\n\n  public logError(err: Error): void {\n    if (this.quiet) return\n    console.error(err)\n  }\n\n  private async handleRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    try {\n      const urlParts = (req.url || '').split('?')\n      const urlNoQuery = urlParts[0]\n\n      if (urlNoQuery?.match(/(\\\\|\\/\\/)/)) {\n        const cleanUrl = normalizeRepeatedSlashes(req.url!)\n        res.setHeader('Location', cleanUrl)\n        res.setHeader('Refresh', `0;url=${cleanUrl}`)\n        res.statusCode = 308\n        res.end(cleanUrl)\n        return\n      }\n\n      setLazyProp({ req: req as any }, 'cookies', getCookieParser(req.headers))\n\n      // Parse url if parsedUrl not provided\n      if (!parsedUrl || typeof parsedUrl !== 'object') {\n        parsedUrl = parseUrl(req.url!, true)\n      }\n\n      // Parse the querystring ourselves if the user doesn't handle querystring parsing\n      if (typeof parsedUrl.query === 'string') {\n        parsedUrl.query = parseQs(parsedUrl.query)\n      }\n\n      // When there are hostname and port we build an absolute URL\n      const initUrl =\n        this.hostname && this.port\n          ? `http://${this.hostname}:${this.port}${req.url}`\n          : req.url\n\n      addRequestMeta(req, '__NEXT_INIT_URL', initUrl)\n      addRequestMeta(req, '__NEXT_INIT_QUERY', { ...parsedUrl.query })\n\n      const url = parseNextUrl({\n        headers: req.headers,\n        nextConfig: this.nextConfig,\n        url: req.url?.replace(/^\\/+/, '/'),\n      })\n\n      if (url.basePath) {\n        req.url = replaceBasePath(req.url!, this.nextConfig.basePath)\n        addRequestMeta(req, '_nextHadBasePath', true)\n      }\n\n      if (\n        this.minimalMode &&\n        req.headers['x-matched-path'] &&\n        typeof req.headers['x-matched-path'] === 'string'\n      ) {\n        const reqUrlIsDataUrl = req.url?.includes('/_next/data')\n        const matchedPathIsDataUrl =\n          req.headers['x-matched-path']?.includes('/_next/data')\n        const isDataUrl = reqUrlIsDataUrl || matchedPathIsDataUrl\n\n        let parsedPath = parseUrl(\n          isDataUrl ? req.url! : (req.headers['x-matched-path'] as string),\n          true\n        )\n\n        let matchedPathname = parsedPath.pathname!\n\n        let matchedPathnameNoExt = isDataUrl\n          ? matchedPathname.replace(/\\.json$/, '')\n          : matchedPathname\n\n        if (this.nextConfig.i18n) {\n          const localePathResult = normalizeLocalePath(\n            matchedPathname || '/',\n            this.nextConfig.i18n.locales\n          )\n\n          if (localePathResult.detectedLocale) {\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n          }\n        }\n\n        if (isDataUrl) {\n          matchedPathname = denormalizePagePath(matchedPathname)\n          matchedPathnameNoExt = denormalizePagePath(matchedPathnameNoExt)\n        }\n\n        const pageIsDynamic = isDynamicRoute(matchedPathnameNoExt)\n        const combinedRewrites: Rewrite[] = []\n\n        combinedRewrites.push(...this.customRoutes.rewrites.beforeFiles)\n        combinedRewrites.push(...this.customRoutes.rewrites.afterFiles)\n        combinedRewrites.push(...this.customRoutes.rewrites.fallback)\n\n        const utils = getUtils({\n          pageIsDynamic,\n          page: matchedPathnameNoExt,\n          i18n: this.nextConfig.i18n,\n          basePath: this.nextConfig.basePath,\n          rewrites: combinedRewrites,\n        })\n\n        try {\n          // ensure parsedUrl.pathname includes URL before processing\n          // rewrites or they won't match correctly\n          if (this.nextConfig.i18n && !url.locale?.path.detectedLocale) {\n            parsedUrl.pathname = `/${url.locale?.locale}${parsedUrl.pathname}`\n          }\n          utils.handleRewrites(req, parsedUrl)\n\n          // interpolate dynamic params and normalize URL if needed\n          if (pageIsDynamic) {\n            let params: ParsedUrlQuery | false = {}\n\n            Object.assign(parsedUrl.query, parsedPath.query)\n            const paramsResult = utils.normalizeDynamicRouteParams(\n              parsedUrl.query\n            )\n\n            if (paramsResult.hasValidParams) {\n              params = paramsResult.params\n            } else if (req.headers['x-now-route-matches']) {\n              const opts: Record<string, string> = {}\n              params = utils.getParamsFromRouteMatches(\n                req,\n                opts,\n                parsedUrl.query.__nextLocale || ''\n              )\n\n              if (opts.locale) {\n                parsedUrl.query.__nextLocale = opts.locale\n              }\n            } else {\n              params = utils.dynamicRouteMatcher!(matchedPathnameNoExt)\n            }\n\n            if (params) {\n              params = utils.normalizeDynamicRouteParams(params).params\n\n              matchedPathname = utils.interpolateDynamicPath(\n                matchedPathname,\n                params\n              )\n              req.url = utils.interpolateDynamicPath(req.url!, params)\n            }\n\n            if (reqUrlIsDataUrl && matchedPathIsDataUrl) {\n              req.url = formatUrl({\n                ...parsedPath,\n                pathname: matchedPathname,\n              })\n            }\n\n            Object.assign(parsedUrl.query, params)\n            utils.normalizeVercelUrl(req, true)\n          }\n        } catch (err) {\n          if (err instanceof DecodeError) {\n            res.statusCode = 400\n            return this.renderError(null, req, res, '/_error', {})\n          }\n          throw err\n        }\n\n        parsedUrl.pathname = `${this.nextConfig.basePath || ''}${\n          matchedPathname === '/' && this.nextConfig.basePath\n            ? ''\n            : matchedPathname\n        }`\n        url.pathname = parsedUrl.pathname\n      }\n\n      addRequestMeta(req, '__nextHadTrailingSlash', url.locale?.trailingSlash)\n      if (url.locale?.domain) {\n        addRequestMeta(req, '__nextIsLocaleDomain', true)\n      }\n\n      if (url.locale?.path.detectedLocale) {\n        req.url = formatUrl(url)\n        addRequestMeta(req, '__nextStrippedLocale', true)\n        if (url.pathname === '/api' || url.pathname.startsWith('/api/')) {\n          return this.render404(req, res, parsedUrl)\n        }\n      }\n\n      if (!this.minimalMode || !parsedUrl.query.__nextLocale) {\n        if (url?.locale?.locale) {\n          parsedUrl.query.__nextLocale = url.locale.locale\n        }\n      }\n\n      if (url?.locale?.defaultLocale) {\n        parsedUrl.query.__nextDefaultLocale = url.locale.defaultLocale\n      }\n\n      if (url.locale?.redirect) {\n        res.setHeader('Location', url.locale.redirect)\n        res.statusCode = TEMPORARY_REDIRECT_STATUS\n        res.end()\n        return\n      }\n\n      res.statusCode = 200\n      return await this.run(req, res, parsedUrl)\n    } catch (err: any) {\n      if (\n        (err && typeof err === 'object' && err.code === 'ERR_INVALID_URL') ||\n        err instanceof DecodeError\n      ) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n\n      if (this.minimalMode || this.renderOpts.dev) {\n        throw err\n      }\n      this.logError(isError(err) ? err : new Error(err + ''))\n      res.statusCode = 500\n      res.end('Internal Server Error')\n    }\n  }\n\n  public getRequestHandler(): RequestHandler {\n    return this.handleRequest.bind(this)\n  }\n\n  public setAssetPrefix(prefix?: string): void {\n    this.renderOpts.assetPrefix = prefix ? prefix.replace(/\\/$/, '') : ''\n  }\n\n  // Backwards compatibility\n  public async prepare(): Promise<void> {}\n\n  // Backwards compatibility\n  protected async close(): Promise<void> {}\n\n  protected setImmutableAssetCacheControl(res: ServerResponse): void {\n    res.setHeader('Cache-Control', 'public, max-age=31536000, immutable')\n  }\n\n  protected getCustomRoutes(): CustomRoutes {\n    const customRoutes = require(join(this.distDir, ROUTES_MANIFEST))\n    let rewrites: CustomRoutes['rewrites']\n\n    // rewrites can be stored as an array when an array is\n    // returned in next.config.js so massage them into\n    // the expected object format\n    if (Array.isArray(customRoutes.rewrites)) {\n      rewrites = {\n        beforeFiles: [],\n        afterFiles: customRoutes.rewrites,\n        fallback: [],\n      }\n    } else {\n      rewrites = customRoutes.rewrites\n    }\n    return Object.assign(customRoutes, { rewrites })\n  }\n\n  private _cachedPreviewManifest: PrerenderManifest | undefined\n  protected getPrerenderManifest(): PrerenderManifest {\n    if (this._cachedPreviewManifest) {\n      return this._cachedPreviewManifest\n    }\n    const manifest = require(join(this.distDir, PRERENDER_MANIFEST))\n    return (this._cachedPreviewManifest = manifest)\n  }\n\n  protected getPreviewProps(): __ApiPreviewProps {\n    return this.getPrerenderManifest().preview\n  }\n\n  protected getMiddleware() {\n    const middleware = this.middlewareManifest?.middleware || {}\n    return (\n      this.middlewareManifest?.sortedMiddleware.map((page) => ({\n        match: getRouteMatcher(\n          getMiddlewareRegex(page, MIDDLEWARE_ROUTE.test(middleware[page].name))\n        ),\n        page,\n      })) || []\n    )\n  }\n\n  protected async hasMiddleware(\n    pathname: string,\n    _isSSR?: boolean\n  ): Promise<boolean> {\n    try {\n      return (\n        getMiddlewareInfo({\n          dev: this.renderOpts.dev,\n          distDir: this.distDir,\n          page: pathname,\n          serverless: this._isLikeServerless,\n        }).paths.length > 0\n      )\n    } catch (_) {}\n\n    return false\n  }\n\n  protected async ensureMiddleware(_pathname: string, _isSSR?: boolean) {}\n\n  private middlewareBetaWarning = execOnce(() => {\n    Log.warn(\n      `using beta Middleware (not covered by semver) - https://nextjs.org/docs/messages/beta-middleware`\n    )\n  })\n\n  protected async runMiddleware(params: {\n    request: IncomingMessage\n    response: ServerResponse\n    parsedUrl: ParsedNextUrl\n    parsed: UrlWithParsedQuery\n    onWarning?: (warning: Error) => void\n  }): Promise<FetchEventResult | null> {\n    this.middlewareBetaWarning()\n\n    // For middleware to \"fetch\" we must always provide an absolute URL\n    const url = getRequestMeta(params.request, '__NEXT_INIT_URL')!\n    if (!url.startsWith('http')) {\n      throw new Error(\n        'To use middleware you must provide a `hostname` and `port` to the Next.js Server'\n      )\n    }\n\n    const page: { name?: string; params?: { [key: string]: string } } = {}\n    if (await this.hasPage(params.parsedUrl.pathname)) {\n      page.name = params.parsedUrl.pathname\n    } else if (this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        const matchParams = dynamicRoute.match(params.parsedUrl.pathname)\n        if (matchParams) {\n          page.name = dynamicRoute.page\n          page.params = matchParams\n          break\n        }\n      }\n    }\n\n    const allHeaders = new Headers()\n    let result: FetchEventResult | null = null\n\n    for (const middleware of this.middleware || []) {\n      if (middleware.match(params.parsedUrl.pathname)) {\n        if (!(await this.hasMiddleware(middleware.page, middleware.ssr))) {\n          console.warn(`The Edge Function for ${middleware.page} was not found`)\n          continue\n        }\n\n        await this.ensureMiddleware(middleware.page, middleware.ssr)\n\n        const middlewareInfo = getMiddlewareInfo({\n          dev: this.renderOpts.dev,\n          distDir: this.distDir,\n          page: middleware.page,\n          serverless: this._isLikeServerless,\n        })\n\n        result = await run({\n          name: middlewareInfo.name,\n          paths: middlewareInfo.paths,\n          request: {\n            headers: params.request.headers,\n            method: params.request.method || 'GET',\n            nextConfig: {\n              basePath: this.nextConfig.basePath,\n              i18n: this.nextConfig.i18n,\n              trailingSlash: this.nextConfig.trailingSlash,\n            },\n            url: url,\n            page: page,\n          },\n          useCache: !this.nextConfig.experimental.concurrentFeatures,\n          onWarning: (warning: Error) => {\n            if (params.onWarning) {\n              warning.message += ` \"./${middlewareInfo.name}\"`\n              params.onWarning(warning)\n            }\n          },\n        })\n\n        for (let [key, value] of result.response.headers) {\n          if (key !== 'x-middleware-next') {\n            allHeaders.append(key, value)\n          }\n        }\n\n        if (!this.renderOpts.dev) {\n          result.waitUntil.catch((error) => {\n            console.error(`Uncaught: middleware waitUntil errored`, error)\n          })\n        }\n\n        if (!result.response.headers.has('x-middleware-next')) {\n          break\n        }\n      }\n    }\n\n    if (!result) {\n      this.render404(params.request, params.response, params.parsed)\n    } else {\n      for (let [key, value] of allHeaders) {\n        result.response.headers.set(key, value)\n      }\n    }\n\n    return result\n  }\n\n  protected generateRoutes(): {\n    basePath: string\n    headers: Route[]\n    rewrites: {\n      beforeFiles: Route[]\n      afterFiles: Route[]\n      fallback: Route[]\n    }\n    fsRoutes: Route[]\n    redirects: Route[]\n    catchAllRoute: Route\n    catchAllMiddleware?: Route\n    pageChecker: PageChecker\n    useFileSystemPublicRoutes: boolean\n    dynamicRoutes: DynamicRoutes | undefined\n    locales: string[]\n  } {\n    const server: Server = this\n    const publicRoutes = fs.existsSync(this.publicDir)\n      ? this.generatePublicRoutes()\n      : []\n\n    const staticFilesRoute = this.hasStaticDir\n      ? [\n          {\n            // It's very important to keep this route's param optional.\n            // (but it should support as many params as needed, separated by '/')\n            // Otherwise this will lead to a pretty simple DOS attack.\n            // See more: https://github.com/vercel/next.js/issues/2617\n            match: route('/static/:path*'),\n            name: 'static catchall',\n            fn: async (req, res, params, parsedUrl) => {\n              const p = join(this.dir, 'static', ...params.path)\n              await this.serveStatic(req, res, p, parsedUrl)\n              return {\n                finished: true,\n              }\n            },\n          } as Route,\n        ]\n      : []\n\n    const fsRoutes: Route[] = [\n      {\n        match: route('/_next/static/:path*'),\n        type: 'route',\n        name: '_next/static catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          // make sure to 404 for /_next/static itself\n          if (!params.path) {\n            await this.render404(req, res, parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          if (\n            params.path[0] === CLIENT_STATIC_FILES_RUNTIME ||\n            params.path[0] === 'chunks' ||\n            params.path[0] === 'css' ||\n            params.path[0] === 'image' ||\n            params.path[0] === 'media' ||\n            params.path[0] === this.buildId ||\n            params.path[0] === 'pages' ||\n            params.path[1] === 'pages'\n          ) {\n            this.setImmutableAssetCacheControl(res)\n          }\n          const p = join(\n            this.distDir,\n            CLIENT_STATIC_FILES_PATH,\n            ...(params.path || [])\n          )\n          await this.serveStatic(req, res, p, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/data/:path*'),\n        type: 'route',\n        name: '_next/data catchall',\n        fn: async (req, res, params, _parsedUrl) => {\n          // Make sure to 404 for /_next/data/ itself and\n          // we also want to 404 if the buildId isn't correct\n          if (!params.path || params.path[0] !== this.buildId) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n          // remove buildId from URL\n          params.path.shift()\n\n          const lastParam = params.path[params.path.length - 1]\n\n          // show 404 if it doesn't end with .json\n          if (typeof lastParam !== 'string' || !lastParam.endsWith('.json')) {\n            await this.render404(req, res, _parsedUrl)\n            return {\n              finished: true,\n            }\n          }\n\n          // re-create page's pathname\n          let pathname = `/${params.path.join('/')}`\n          pathname = getRouteFromAssetPath(pathname, '.json')\n\n          if (this.nextConfig.i18n) {\n            const { host } = req?.headers || {}\n            // remove port from host and remove port if present\n            const hostname = host?.split(':')[0].toLowerCase()\n            const localePathResult = normalizeLocalePath(\n              pathname,\n              this.nextConfig.i18n.locales\n            )\n            const { defaultLocale } =\n              detectDomainLocale(this.nextConfig.i18n.domains, hostname) || {}\n\n            let detectedLocale = ''\n\n            if (localePathResult.detectedLocale) {\n              pathname = localePathResult.pathname\n              detectedLocale = localePathResult.detectedLocale\n            }\n\n            _parsedUrl.query.__nextLocale = detectedLocale\n            _parsedUrl.query.__nextDefaultLocale =\n              defaultLocale || this.nextConfig.i18n.defaultLocale\n\n            if (!detectedLocale) {\n              _parsedUrl.query.__nextLocale =\n                _parsedUrl.query.__nextDefaultLocale\n              await this.render404(req, res, _parsedUrl)\n              return { finished: true }\n            }\n          }\n\n          const parsedUrl = parseUrl(pathname, true)\n\n          await this.render(\n            req,\n            res,\n            pathname,\n            { ..._parsedUrl.query, _nextDataReq: '1' },\n            parsedUrl\n          )\n          return {\n            finished: true,\n          }\n        },\n      },\n      {\n        match: route('/_next/image'),\n        type: 'route',\n        name: '_next/image catchall',\n        fn: (req, res, _params, parsedUrl) => {\n          if (this.minimalMode) {\n            res.statusCode = 400\n            res.end('Bad Request')\n            return {\n              finished: true,\n            }\n          }\n          const { imageOptimizer } =\n            require('./image-optimizer') as typeof import('./image-optimizer')\n\n          return imageOptimizer(\n            server,\n            req,\n            res,\n            parsedUrl,\n            server.nextConfig,\n            server.distDir,\n            this.renderOpts.dev\n          )\n        },\n      },\n      {\n        match: route('/_next/:path*'),\n        type: 'route',\n        name: '_next catchall',\n        // This path is needed because `render()` does a check for `/_next` and the calls the routing again\n        fn: async (req, res, _params, parsedUrl) => {\n          await this.render404(req, res, parsedUrl)\n          return {\n            finished: true,\n          }\n        },\n      },\n      ...publicRoutes,\n      ...staticFilesRoute,\n    ]\n\n    const restrictedRedirectPaths = ['/_next'].map((p) =>\n      this.nextConfig.basePath ? `${this.nextConfig.basePath}${p}` : p\n    )\n\n    const getCustomRoute = (\n      r: Rewrite | Redirect | Header,\n      type: RouteType\n    ) => {\n      const match = getCustomRouteMatcher(\n        r.source,\n        !(r as any).internal\n          ? (regex: string) =>\n              modifyRouteRegex(\n                regex,\n                type === 'redirect' ? restrictedRedirectPaths : undefined\n              )\n          : undefined\n      )\n\n      return {\n        ...r,\n        type,\n        match,\n        name: type,\n        fn: async (_req, _res, _params, _parsedUrl) => ({ finished: false }),\n      } as Route & Rewrite & Header\n    }\n\n    // Headers come very first\n    const headers = this.minimalMode\n      ? []\n      : this.customRoutes.headers.map((r) => {\n          const headerRoute = getCustomRoute(r, 'header')\n          return {\n            match: headerRoute.match,\n            has: headerRoute.has,\n            type: headerRoute.type,\n            name: `${headerRoute.type} ${headerRoute.source} header route`,\n            fn: async (_req, res, params, _parsedUrl) => {\n              const hasParams = Object.keys(params).length > 0\n\n              for (const header of (headerRoute as Header).headers) {\n                let { key, value } = header\n                if (hasParams) {\n                  key = compileNonPath(key, params)\n                  value = compileNonPath(value, params)\n                }\n                res.setHeader(key, value)\n              }\n              return { finished: false }\n            },\n          } as Route\n        })\n\n    // since initial query values are decoded by querystring.parse\n    // we need to re-encode them here but still allow passing through\n    // values from rewrites/redirects\n    const stringifyQuery = (req: IncomingMessage, query: ParsedUrlQuery) => {\n      const initialQueryValues = Object.values(\n        getRequestMeta(req, '__NEXT_INIT_QUERY') || {}\n      )\n\n      return stringifyQs(query, undefined, undefined, {\n        encodeURIComponent(value) {\n          if (initialQueryValues.some((val) => val === value)) {\n            return encodeURIComponent(value)\n          }\n          return value\n        },\n      })\n    }\n\n    const proxyRequest = async (\n      req: IncomingMessage,\n      res: ServerResponse,\n      parsedUrl: ParsedUrl\n    ) => {\n      const { query } = parsedUrl\n      delete (parsedUrl as any).query\n      parsedUrl.search = stringifyQuery(req, query)\n\n      const target = formatUrl(parsedUrl)\n      const proxy = new Proxy({\n        target,\n        changeOrigin: true,\n        ignorePath: true,\n        xfwd: true,\n        proxyTimeout: 30_000, // limit proxying to 30 seconds\n      })\n\n      await new Promise((proxyResolve, proxyReject) => {\n        let finished = false\n\n        proxy.on('proxyReq', (proxyReq) => {\n          proxyReq.on('close', () => {\n            if (!finished) {\n              finished = true\n              proxyResolve(true)\n            }\n          })\n        })\n        proxy.on('error', (err) => {\n          if (!finished) {\n            finished = true\n            proxyReject(err)\n          }\n        })\n        proxy.web(req, res)\n      })\n\n      return {\n        finished: true,\n      }\n    }\n\n    const redirects = this.minimalMode\n      ? []\n      : this.customRoutes.redirects.map((redirect) => {\n          const redirectRoute = getCustomRoute(redirect, 'redirect')\n          return {\n            internal: redirectRoute.internal,\n            type: redirectRoute.type,\n            match: redirectRoute.match,\n            has: redirectRoute.has,\n            statusCode: redirectRoute.statusCode,\n            name: `Redirect route ${redirectRoute.source}`,\n            fn: async (req, res, params, parsedUrl) => {\n              const { parsedDestination } = prepareDestination({\n                appendParamsToQuery: false,\n                destination: redirectRoute.destination,\n                params: params,\n                query: parsedUrl.query,\n              })\n\n              const { query } = parsedDestination\n              delete (parsedDestination as any).query\n\n              parsedDestination.search = stringifyQuery(req, query)\n\n              let updatedDestination = formatUrl(parsedDestination)\n\n              if (updatedDestination.startsWith('/')) {\n                updatedDestination =\n                  normalizeRepeatedSlashes(updatedDestination)\n              }\n\n              res.setHeader('Location', updatedDestination)\n              res.statusCode = getRedirectStatus(redirectRoute as Redirect)\n\n              // Since IE11 doesn't support the 308 header add backwards\n              // compatibility using refresh header\n              if (res.statusCode === 308) {\n                res.setHeader('Refresh', `0;url=${updatedDestination}`)\n              }\n\n              res.end(updatedDestination)\n              return {\n                finished: true,\n              }\n            },\n          } as Route\n        })\n\n    const buildRewrite = (rewrite: Rewrite, check = true) => {\n      const rewriteRoute = getCustomRoute(rewrite, 'rewrite')\n      return {\n        ...rewriteRoute,\n        check,\n        type: rewriteRoute.type,\n        name: `Rewrite route ${rewriteRoute.source}`,\n        match: rewriteRoute.match,\n        fn: async (req, res, params, parsedUrl) => {\n          const { newUrl, parsedDestination } = prepareDestination({\n            appendParamsToQuery: true,\n            destination: rewriteRoute.destination,\n            params: params,\n            query: parsedUrl.query,\n          })\n\n          // external rewrite, proxy it\n          if (parsedDestination.protocol) {\n            return proxyRequest(req, res, parsedDestination)\n          }\n\n          addRequestMeta(req, '_nextRewroteUrl', newUrl)\n          addRequestMeta(req, '_nextDidRewrite', newUrl !== req.url)\n\n          return {\n            finished: false,\n            pathname: newUrl,\n            query: parsedDestination.query,\n          }\n        },\n      } as Route\n    }\n\n    let beforeFiles: Route[] = []\n    let afterFiles: Route[] = []\n    let fallback: Route[] = []\n\n    if (!this.minimalMode) {\n      if (Array.isArray(this.customRoutes.rewrites)) {\n        afterFiles = this.customRoutes.rewrites.map((r) => buildRewrite(r))\n      } else {\n        beforeFiles = this.customRoutes.rewrites.beforeFiles.map((r) =>\n          buildRewrite(r, false)\n        )\n        afterFiles = this.customRoutes.rewrites.afterFiles.map((r) =>\n          buildRewrite(r)\n        )\n        fallback = this.customRoutes.rewrites.fallback.map((r) =>\n          buildRewrite(r)\n        )\n      }\n    }\n\n    let catchAllMiddleware: Route | undefined\n\n    if (!this.minimalMode) {\n      catchAllMiddleware = {\n        match: route('/:path*'),\n        type: 'route',\n        name: 'middleware catchall',\n        fn: async (req, res, _params, parsed) => {\n          if (!this.middleware?.length) {\n            return { finished: false }\n          }\n\n          const initUrl = getRequestMeta(req, '__NEXT_INIT_URL')!\n          const parsedUrl = parseNextUrl({\n            url: initUrl,\n            headers: req.headers,\n            nextConfig: {\n              basePath: this.nextConfig.basePath,\n              i18n: this.nextConfig.i18n,\n              trailingSlash: this.nextConfig.trailingSlash,\n            },\n          })\n\n          if (!this.middleware?.some((m) => m.match(parsedUrl.pathname))) {\n            return { finished: false }\n          }\n\n          let result: FetchEventResult | null = null\n\n          try {\n            result = await this.runMiddleware({\n              request: req,\n              response: res,\n              parsedUrl: parsedUrl,\n              parsed: parsed,\n            })\n          } catch (err) {\n            if (isError(err) && err.code === 'ENOENT') {\n              await this.render404(req, res, parsed)\n              return { finished: true }\n            }\n\n            const error = isError(err) ? err : new Error(err + '')\n            console.error(error)\n            res.statusCode = 500\n            this.renderError(error, req, res, parsed.pathname || '')\n            return { finished: true }\n          }\n\n          if (result === null) {\n            return { finished: true }\n          }\n\n          if (result.response.headers.has('x-middleware-rewrite')) {\n            const value = result.response.headers.get('x-middleware-rewrite')!\n            const rel = relativizeURL(value, initUrl)\n            result.response.headers.set('x-middleware-rewrite', rel)\n          }\n\n          if (result.response.headers.has('Location')) {\n            const value = result.response.headers.get('Location')!\n            const rel = relativizeURL(value, initUrl)\n            result.response.headers.set('Location', rel)\n          }\n\n          if (\n            !result.response.headers.has('x-middleware-rewrite') &&\n            !result.response.headers.has('x-middleware-next') &&\n            !result.response.headers.has('Location')\n          ) {\n            result.response.headers.set('x-middleware-refresh', '1')\n          }\n\n          result.response.headers.delete('x-middleware-next')\n\n          for (const [key, value] of Object.entries(\n            toNodeHeaders(result.response.headers)\n          )) {\n            if (key !== 'content-encoding' && value !== undefined) {\n              res.setHeader(key, value)\n            }\n          }\n\n          const preflight =\n            req.method === 'HEAD' && req.headers['x-middleware-preflight']\n\n          if (preflight) {\n            res.writeHead(200)\n            res.end()\n            return {\n              finished: true,\n            }\n          }\n\n          res.statusCode = result.response.status\n          res.statusMessage = result.response.statusText\n\n          const location = result.response.headers.get('Location')\n          if (location) {\n            res.statusCode = result.response.status\n            if (res.statusCode === 308) {\n              res.setHeader('Refresh', `0;url=${location}`)\n            }\n\n            res.end()\n            return {\n              finished: true,\n            }\n          }\n\n          if (result.response.headers.has('x-middleware-rewrite')) {\n            const { newUrl, parsedDestination } = prepareDestination({\n              appendParamsToQuery: true,\n              destination: result.response.headers.get('x-middleware-rewrite')!,\n              params: _params,\n              query: parsedUrl.query,\n            })\n\n            if (\n              parsedDestination.protocol &&\n              (parsedDestination.port\n                ? `${parsedDestination.hostname}:${parsedDestination.port}`\n                : parsedDestination.hostname) !== req.headers.host\n            ) {\n              return proxyRequest(req, res, parsedDestination)\n            }\n\n            if (this.nextConfig.i18n) {\n              const localePathResult = normalizeLocalePath(\n                newUrl,\n                this.nextConfig.i18n.locales\n              )\n              if (localePathResult.detectedLocale) {\n                parsedDestination.query.__nextLocale =\n                  localePathResult.detectedLocale\n              }\n            }\n\n            addRequestMeta(req, '_nextRewroteUrl', newUrl)\n            addRequestMeta(req, '_nextDidRewrite', newUrl !== req.url)\n\n            return {\n              finished: false,\n              pathname: newUrl,\n              query: parsedDestination.query,\n            }\n          }\n\n          if (result.response.headers.has('x-middleware-refresh')) {\n            res.writeHead(result.response.status)\n            for await (const chunk of result.response.body || []) {\n              res.write(chunk)\n            }\n            res.end()\n            return {\n              finished: true,\n            }\n          }\n\n          return {\n            finished: false,\n          }\n        },\n      }\n    }\n\n    const catchAllRoute: Route = {\n      match: route('/:path*'),\n      type: 'route',\n      name: 'Catchall render',\n      fn: async (req, res, _params, parsedUrl) => {\n        let { pathname, query } = parsedUrl\n        if (!pathname) {\n          throw new Error('pathname is undefined')\n        }\n\n        // next.js core assumes page path without trailing slash\n        pathname = removePathTrailingSlash(pathname)\n\n        if (this.nextConfig.i18n) {\n          const localePathResult = normalizeLocalePath(\n            pathname,\n            this.nextConfig.i18n?.locales\n          )\n\n          if (localePathResult.detectedLocale) {\n            pathname = localePathResult.pathname\n            parsedUrl.query.__nextLocale = localePathResult.detectedLocale\n          }\n        }\n        const bubbleNoFallback = !!query._nextBubbleNoFallback\n\n        if (pathname.match(MIDDLEWARE_ROUTE)) {\n          await this.render404(req, res, parsedUrl)\n          return {\n            finished: true,\n          }\n        }\n\n        if (pathname === '/api' || pathname.startsWith('/api/')) {\n          delete query._nextBubbleNoFallback\n\n          const handled = await this.handleApiRequest(\n            req as NextApiRequest,\n            res as NextApiResponse,\n            pathname,\n            query\n          )\n          if (handled) {\n            return { finished: true }\n          }\n        }\n\n        try {\n          await this.render(req, res, pathname, query, parsedUrl)\n\n          return {\n            finished: true,\n          }\n        } catch (err) {\n          if (err instanceof NoFallbackError && bubbleNoFallback) {\n            return {\n              finished: false,\n            }\n          }\n          throw err\n        }\n      },\n    }\n\n    const { useFileSystemPublicRoutes } = this.nextConfig\n\n    if (useFileSystemPublicRoutes) {\n      this.dynamicRoutes = this.getDynamicRoutes()\n      if (!this.minimalMode) {\n        this.middleware = this.getMiddleware()\n      }\n    }\n\n    return {\n      headers,\n      fsRoutes,\n      rewrites: {\n        beforeFiles,\n        afterFiles,\n        fallback,\n      },\n      redirects,\n      catchAllRoute,\n      catchAllMiddleware,\n      useFileSystemPublicRoutes,\n      dynamicRoutes: this.dynamicRoutes,\n      basePath: this.nextConfig.basePath,\n      pageChecker: this.hasPage.bind(this),\n      locales: this.nextConfig.i18n?.locales || [],\n    }\n  }\n\n  private async getPagePath(\n    pathname: string,\n    locales?: string[]\n  ): Promise<string> {\n    return getPagePath(\n      pathname,\n      this.distDir,\n      this._isLikeServerless,\n      this.renderOpts.dev,\n      locales\n    )\n  }\n\n  protected async hasPage(pathname: string): Promise<boolean> {\n    let found = false\n    try {\n      found = !!(await this.getPagePath(\n        pathname,\n        this.nextConfig.i18n?.locales\n      ))\n    } catch (_) {}\n\n    return found\n  }\n\n  protected async _beforeCatchAllRender(\n    _req: IncomingMessage,\n    _res: ServerResponse,\n    _params: Params,\n    _parsedUrl: UrlWithParsedQuery\n  ): Promise<boolean> {\n    return false\n  }\n\n  // Used to build API page in development\n  protected async ensureApiPage(_pathname: string): Promise<void> {}\n\n  /**\n   * Resolves `API` request, in development builds on demand\n   * @param req http request\n   * @param res http response\n   * @param pathname path of request\n   */\n  private async handleApiRequest(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery\n  ): Promise<boolean> {\n    let page = pathname\n    let params: Params | boolean = false\n    let pageFound = await this.hasPage(page)\n\n    if (!pageFound && this.dynamicRoutes) {\n      for (const dynamicRoute of this.dynamicRoutes) {\n        params = dynamicRoute.match(pathname)\n        if (dynamicRoute.page.startsWith('/api') && params) {\n          page = dynamicRoute.page\n          pageFound = true\n          break\n        }\n      }\n    }\n\n    if (!pageFound) {\n      return false\n    }\n    // Make sure the page is built before getting the path\n    // or else it won't be in the manifest yet\n    await this.ensureApiPage(page)\n\n    let builtPagePath\n    try {\n      builtPagePath = await this.getPagePath(page)\n    } catch (err) {\n      if (isError(err) && err.code === 'ENOENT') {\n        return false\n      }\n      throw err\n    }\n\n    const pageModule = await require(builtPagePath)\n    query = { ...query, ...params }\n\n    delete query.__nextLocale\n    delete query.__nextDefaultLocale\n\n    if (!this.renderOpts.dev && this._isLikeServerless) {\n      if (typeof pageModule.default === 'function') {\n        prepareServerlessUrl(req, query)\n        await pageModule.default(req, res)\n        return true\n      }\n    }\n\n    await apiResolver(\n      req,\n      res,\n      query,\n      pageModule,\n      this.renderOpts.previewProps,\n      this.minimalMode,\n      this.renderOpts.dev,\n      page\n    )\n    return true\n  }\n\n  protected generatePublicRoutes(): Route[] {\n    const publicFiles = new Set(\n      recursiveReadDirSync(this.publicDir).map((p) =>\n        encodeURI(p.replace(/\\\\/g, '/'))\n      )\n    )\n\n    return [\n      {\n        match: route('/:path*'),\n        name: 'public folder catchall',\n        fn: async (req, res, params, parsedUrl) => {\n          const pathParts: string[] = params.path || []\n          const { basePath } = this.nextConfig\n\n          // if basePath is defined require it be present\n          if (basePath) {\n            const basePathParts = basePath.split('/')\n            // remove first empty value\n            basePathParts.shift()\n\n            if (\n              !basePathParts.every((part: string, idx: number) => {\n                return part === pathParts[idx]\n              })\n            ) {\n              return { finished: false }\n            }\n\n            pathParts.splice(0, basePathParts.length)\n          }\n\n          let path = `/${pathParts.join('/')}`\n\n          if (!publicFiles.has(path)) {\n            // In `next-dev-server.ts`, we ensure encoded paths match\n            // decoded paths on the filesystem. So we need do the\n            // opposite here: make sure decoded paths match encoded.\n            path = encodeURI(path)\n          }\n\n          if (publicFiles.has(path)) {\n            await this.serveStatic(\n              req,\n              res,\n              join(this.publicDir, ...pathParts),\n              parsedUrl\n            )\n            return {\n              finished: true,\n            }\n          }\n          return {\n            finished: false,\n          }\n        },\n      } as Route,\n    ]\n  }\n\n  protected getDynamicRoutes(): Array<RoutingItem> {\n    const addedPages = new Set<string>()\n\n    return getSortedRoutes(\n      Object.keys(this.pagesManifest!).map(\n        (page) =>\n          normalizeLocalePath(page, this.nextConfig.i18n?.locales).pathname\n      )\n    )\n      .map((page) => {\n        if (addedPages.has(page) || !isDynamicRoute(page)) return null\n        addedPages.add(page)\n        return {\n          page,\n          match: getRouteMatcher(getRouteRegex(page)),\n        }\n      })\n      .filter((item): item is RoutingItem => Boolean(item))\n  }\n\n  private handleCompression(req: IncomingMessage, res: ServerResponse): void {\n    if (this.compression) {\n      this.compression(req, res, () => {})\n    }\n  }\n\n  protected async run(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl: UrlWithParsedQuery\n  ): Promise<void> {\n    this.handleCompression(req, res)\n\n    try {\n      const matched = await this.router.execute(req, res, parsedUrl)\n      if (matched) {\n        return\n      }\n    } catch (err) {\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        return this.renderError(null, req, res, '/_error', {})\n      }\n      throw err\n    }\n\n    await this.render404(req, res, parsedUrl)\n  }\n\n  private async pipe(\n    fn: (ctx: RequestContext) => Promise<ResponsePayload | null>,\n    partialContext: {\n      req: IncomingMessage\n      res: ServerResponse\n      pathname: string\n      query: NextParsedUrlQuery\n    }\n  ): Promise<void> {\n    const userAgent = partialContext.req.headers['user-agent']\n    const ctx = {\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicHTML: userAgent ? !isBot(userAgent) : false,\n      },\n    } as const\n    const payload = await fn(ctx)\n    if (payload === null) {\n      return\n    }\n    const { req, res } = ctx\n    const { body, type, revalidateOptions } = payload\n    if (!isResSent(res)) {\n      const { generateEtags, poweredByHeader, dev } = this.renderOpts\n      if (dev) {\n        // In dev, we should not cache pages for any reason.\n        res.setHeader('Cache-Control', 'no-store, must-revalidate')\n      }\n      return sendRenderResult({\n        req,\n        res,\n        result: body,\n        type,\n        generateEtags,\n        poweredByHeader,\n        options: revalidateOptions,\n      })\n    }\n  }\n\n  private async getStaticHTML(\n    fn: (ctx: RequestContext) => Promise<ResponsePayload | null>,\n    partialContext: {\n      req: IncomingMessage\n      res: ServerResponse\n      pathname: string\n      query: ParsedUrlQuery\n    }\n  ): Promise<string | null> {\n    const payload = await fn({\n      ...partialContext,\n      renderOpts: {\n        ...this.renderOpts,\n        supportsDynamicHTML: false,\n      },\n    })\n    if (payload === null) {\n      return null\n    }\n    return payload.body.toUnchunkedString()\n  }\n\n  public async render(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    parsedUrl?: NextUrlWithParsedQuery\n  ): Promise<void> {\n    if (!pathname.startsWith('/')) {\n      console.warn(\n        `Cannot render page with path \"${pathname}\", did you mean \"/${pathname}\"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`\n      )\n    }\n\n    if (\n      this.renderOpts.customServer &&\n      pathname === '/index' &&\n      !(await this.hasPage('/index'))\n    ) {\n      // maintain backwards compatibility for custom server\n      // (see custom-server integration tests)\n      pathname = '/'\n    }\n\n    // we allow custom servers to call render for all URLs\n    // so check if we need to serve a static _next file or not.\n    // we don't modify the URL for _next/data request but still\n    // call render so we special case this to prevent an infinite loop\n    if (\n      !this.minimalMode &&\n      !query._nextDataReq &&\n      (req.url?.match(/^\\/_next\\//) ||\n        (this.hasStaticDir && req.url!.match(/^\\/static\\//)))\n    ) {\n      return this.handleRequest(req, res, parsedUrl)\n    }\n\n    // Custom server users can run `app.render()` which needs compression.\n    if (this.renderOpts.customServer) {\n      this.handleCompression(req, res)\n    }\n\n    if (isBlockedPage(pathname)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    return this.pipe((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async findPageComponents(\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    params: Params | null = null\n  ): Promise<FindComponentsResult | null> {\n    let paths = [\n      // try serving a static AMP version first\n      query.amp ? normalizePagePath(pathname) + '.amp' : null,\n      pathname,\n    ].filter(Boolean)\n\n    if (query.__nextLocale) {\n      paths = [\n        ...paths.map(\n          (path) => `/${query.__nextLocale}${path === '/' ? '' : path}`\n        ),\n        ...paths,\n      ]\n    }\n\n    for (const pagePath of paths) {\n      try {\n        const components = await loadComponents(\n          this.distDir,\n          pagePath!,\n          !this.renderOpts.dev && this._isLikeServerless\n        )\n\n        if (\n          query.__nextLocale &&\n          typeof components.Component === 'string' &&\n          !pagePath?.startsWith(`/${query.__nextLocale}`)\n        ) {\n          // if loading an static HTML file the locale is required\n          // to be present since all HTML files are output under their locale\n          continue\n        }\n\n        return {\n          components,\n          query: {\n            ...(components.getStaticProps\n              ? ({\n                  amp: query.amp,\n                  _nextDataReq: query._nextDataReq,\n                  __nextLocale: query.__nextLocale,\n                  __nextDefaultLocale: query.__nextDefaultLocale,\n                } as NextParsedUrlQuery)\n              : query),\n            ...(params || {}),\n          },\n        }\n      } catch (err) {\n        if (isError(err) && err.code !== 'ENOENT') throw err\n      }\n    }\n    return null\n  }\n\n  protected async getStaticPaths(pathname: string): Promise<{\n    staticPaths: string[] | undefined\n    fallbackMode: 'static' | 'blocking' | false\n  }> {\n    // `staticPaths` is intentionally set to `undefined` as it should've\n    // been caught when checking disk data.\n    const staticPaths = undefined\n\n    // Read whether or not fallback should exist from the manifest.\n    const fallbackField =\n      this.getPrerenderManifest().dynamicRoutes[pathname].fallback\n\n    return {\n      staticPaths,\n      fallbackMode:\n        typeof fallbackField === 'string'\n          ? 'static'\n          : fallbackField === null\n          ? 'blocking'\n          : false,\n    }\n  }\n\n  private async renderToResponseWithComponents(\n    { req, res, pathname, renderOpts: opts }: RequestContext,\n    { components, query }: FindComponentsResult\n  ): Promise<ResponsePayload | null> {\n    const is404Page = pathname === '/404'\n    const is500Page = pathname === '/500'\n\n    const isLikeServerless =\n      typeof components.ComponentMod === 'object' &&\n      typeof (components.ComponentMod as any).renderReqToHTML === 'function'\n    const isSSG = !!components.getStaticProps\n    const hasServerProps = !!components.getServerSideProps\n    const hasStaticPaths = !!components.getStaticPaths\n    const hasGetInitialProps = !!(components.Component as any).getInitialProps\n\n    // Toggle whether or not this is a Data request\n    const isDataReq = !!query._nextDataReq && (isSSG || hasServerProps)\n    delete query._nextDataReq\n\n    // we need to ensure the status code if /404 is visited directly\n    if (is404Page && !isDataReq) {\n      res.statusCode = 404\n    }\n\n    // ensure correct status is set when visiting a status page\n    // directly e.g. /500\n    if (STATIC_STATUS_PAGES.includes(pathname)) {\n      res.statusCode = parseInt(pathname.substr(1), 10)\n    }\n\n    // handle static page\n    if (typeof components.Component === 'string') {\n      return {\n        type: 'html',\n        // TODO: Static pages should be serialized as RenderResult\n        body: RenderResult.fromStatic(components.Component),\n      }\n    }\n\n    if (!query.amp) {\n      delete query.amp\n    }\n\n    if (opts.supportsDynamicHTML === true) {\n      // Disable dynamic HTML in cases that we know it won't be generated,\n      // so that we can continue generating a cache key when possible.\n      opts.supportsDynamicHTML =\n        !isSSG &&\n        !isLikeServerless &&\n        !query.amp &&\n        !this.minimalMode &&\n        typeof components.Document?.getInitialProps !== 'function'\n    }\n\n    const defaultLocale = isSSG\n      ? this.nextConfig.i18n?.defaultLocale\n      : query.__nextDefaultLocale\n\n    const locale = query.__nextLocale\n    const locales = this.nextConfig.i18n?.locales\n\n    let previewData: PreviewData\n    let isPreviewMode = false\n\n    if (hasServerProps || isSSG) {\n      previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps)\n      isPreviewMode = previewData !== false\n    }\n\n    // Compute the iSSG cache key. We use the rewroteUrl since\n    // pages with fallback: false are allowed to be rewritten to\n    // and we need to look up the path by the rewritten path\n    let urlPathname = parseUrl(req.url || '').pathname || '/'\n\n    let resolvedUrlPathname =\n      getRequestMeta(req, '_nextRewroteUrl') || urlPathname\n\n    urlPathname = removePathTrailingSlash(urlPathname)\n    resolvedUrlPathname = normalizeLocalePath(\n      removePathTrailingSlash(resolvedUrlPathname),\n      this.nextConfig.i18n?.locales\n    ).pathname\n\n    const stripNextDataPath = (path: string) => {\n      if (path.includes(this.buildId)) {\n        const splitPath = path.substring(\n          path.indexOf(this.buildId) + this.buildId.length\n        )\n\n        path = denormalizePagePath(splitPath.replace(/\\.json$/, ''))\n      }\n\n      if (this.nextConfig.i18n) {\n        return normalizeLocalePath(path, locales).pathname\n      }\n      return path\n    }\n\n    const handleRedirect = (pageData: any) => {\n      const redirect = {\n        destination: pageData.pageProps.__N_REDIRECT,\n        statusCode: pageData.pageProps.__N_REDIRECT_STATUS,\n        basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH,\n      }\n      const statusCode = getRedirectStatus(redirect)\n      const { basePath } = this.nextConfig\n\n      if (\n        basePath &&\n        redirect.basePath !== false &&\n        redirect.destination.startsWith('/')\n      ) {\n        redirect.destination = `${basePath}${redirect.destination}`\n      }\n\n      if (redirect.destination.startsWith('/')) {\n        redirect.destination = normalizeRepeatedSlashes(redirect.destination)\n      }\n\n      if (statusCode === PERMANENT_REDIRECT_STATUS) {\n        res.setHeader('Refresh', `0;url=${redirect.destination}`)\n      }\n\n      res.statusCode = statusCode\n      res.setHeader('Location', redirect.destination)\n      res.end()\n    }\n\n    // remove /_next/data prefix from urlPathname so it matches\n    // for direct page visit and /_next/data visit\n    if (isDataReq) {\n      resolvedUrlPathname = stripNextDataPath(resolvedUrlPathname)\n      urlPathname = stripNextDataPath(urlPathname)\n    }\n\n    let ssgCacheKey =\n      isPreviewMode || !isSSG || this.minimalMode || opts.supportsDynamicHTML\n        ? null // Preview mode bypasses the cache\n        : `${locale ? `/${locale}` : ''}${\n            (pathname === '/' || resolvedUrlPathname === '/') && locale\n              ? ''\n              : resolvedUrlPathname\n          }${query.amp ? '.amp' : ''}`\n\n    if ((is404Page || is500Page) && isSSG) {\n      ssgCacheKey = `${locale ? `/${locale}` : ''}${pathname}${\n        query.amp ? '.amp' : ''\n      }`\n    }\n\n    if (ssgCacheKey) {\n      // we only encode path delimiters for path segments from\n      // getStaticPaths so we need to attempt decoding the URL\n      // to match against and only escape the path delimiters\n      // this allows non-ascii values to be handled e.g. Japanese characters\n\n      // TODO: investigate adding this handling for non-SSG pages so\n      // non-ascii names work there also\n      ssgCacheKey = ssgCacheKey\n        .split('/')\n        .map((seg) => {\n          try {\n            seg = escapePathDelimiters(decodeURIComponent(seg), true)\n          } catch (_) {\n            // An improperly encoded URL was provided\n            throw new DecodeError('failed to decode param')\n          }\n          return seg\n        })\n        .join('/')\n    }\n\n    const doRender: () => Promise<ResponseCacheEntry | null> = async () => {\n      let pageData: any\n      let body: RenderResult | null\n      let sprRevalidate: number | false\n      let isNotFound: boolean | undefined\n      let isRedirect: boolean | undefined\n\n      // handle serverless\n      if (isLikeServerless) {\n        const renderResult = await (\n          components.ComponentMod as any\n        ).renderReqToHTML(req, res, 'passthrough', {\n          locale,\n          locales,\n          defaultLocale,\n          optimizeCss: this.renderOpts.optimizeCss,\n          distDir: this.distDir,\n          fontManifest: this.renderOpts.fontManifest,\n          domainLocales: this.renderOpts.domainLocales,\n        })\n\n        body = renderResult.html\n        pageData = renderResult.renderOpts.pageData\n        sprRevalidate = renderResult.renderOpts.revalidate\n        isNotFound = renderResult.renderOpts.isNotFound\n        isRedirect = renderResult.renderOpts.isRedirect\n      } else {\n        const origQuery = parseUrl(req.url || '', true).query\n        const hadTrailingSlash =\n          urlPathname !== '/' && this.nextConfig.trailingSlash\n\n        const resolvedUrl = formatUrl({\n          pathname: `${resolvedUrlPathname}${hadTrailingSlash ? '/' : ''}`,\n          // make sure to only add query values from original URL\n          query: origQuery,\n        })\n\n        const renderOpts: RenderOpts = {\n          ...components,\n          ...opts,\n          isDataReq,\n          resolvedUrl,\n          locale,\n          locales,\n          defaultLocale,\n          // For getServerSideProps and getInitialProps we need to ensure we use the original URL\n          // and not the resolved URL to prevent a hydration mismatch on\n          // asPath\n          resolvedAsPath:\n            hasServerProps || hasGetInitialProps\n              ? formatUrl({\n                  // we use the original URL pathname less the _next/data prefix if\n                  // present\n                  pathname: `${urlPathname}${hadTrailingSlash ? '/' : ''}`,\n                  query: origQuery,\n                })\n              : resolvedUrl,\n        }\n\n        const renderResult = await renderToHTML(\n          req,\n          res,\n          pathname,\n          query,\n          renderOpts\n        )\n\n        body = renderResult\n        // TODO: change this to a different passing mechanism\n        pageData = (renderOpts as any).pageData\n        sprRevalidate = (renderOpts as any).revalidate\n        isNotFound = (renderOpts as any).isNotFound\n        isRedirect = (renderOpts as any).isRedirect\n      }\n\n      let value: ResponseCacheValue | null\n      if (isNotFound) {\n        value = null\n      } else if (isRedirect) {\n        value = { kind: 'REDIRECT', props: pageData }\n      } else {\n        if (!body) {\n          return null\n        }\n        value = { kind: 'PAGE', html: body, pageData }\n      }\n      return { revalidate: sprRevalidate, value }\n    }\n\n    const cacheEntry = await this.responseCache.get(\n      ssgCacheKey,\n      async (hasResolved) => {\n        const isProduction = !this.renderOpts.dev\n        const isDynamicPathname = isDynamicRoute(pathname)\n        const didRespond = hasResolved || isResSent(res)\n\n        let { staticPaths, fallbackMode } = hasStaticPaths\n          ? await this.getStaticPaths(pathname)\n          : { staticPaths: undefined, fallbackMode: false }\n\n        if (\n          fallbackMode === 'static' &&\n          isBot(req.headers['user-agent'] || '')\n        ) {\n          fallbackMode = 'blocking'\n        }\n\n        // When we did not respond from cache, we need to choose to block on\n        // rendering or return a skeleton.\n        //\n        // * Data requests always block.\n        //\n        // * Blocking mode fallback always blocks.\n        //\n        // * Preview mode toggles all pages to be resolved in a blocking manner.\n        //\n        // * Non-dynamic pages should block (though this is an impossible\n        //   case in production).\n        //\n        // * Dynamic pages should return their skeleton if not defined in\n        //   getStaticPaths, then finish the data request on the client-side.\n        //\n        if (\n          this.minimalMode !== true &&\n          fallbackMode !== 'blocking' &&\n          ssgCacheKey &&\n          !didRespond &&\n          !isPreviewMode &&\n          isDynamicPathname &&\n          // Development should trigger fallback when the path is not in\n          // `getStaticPaths`\n          (isProduction ||\n            !staticPaths ||\n            !staticPaths.includes(\n              // we use ssgCacheKey here as it is normalized to match the\n              // encoding from getStaticPaths along with including the locale\n              query.amp ? ssgCacheKey.replace(/\\.amp$/, '') : ssgCacheKey\n            ))\n        ) {\n          if (\n            // In development, fall through to render to handle missing\n            // getStaticPaths.\n            (isProduction || staticPaths) &&\n            // When fallback isn't present, abort this render so we 404\n            fallbackMode !== 'static'\n          ) {\n            throw new NoFallbackError()\n          }\n\n          if (!isDataReq) {\n            // Production already emitted the fallback as static HTML.\n            if (isProduction) {\n              const html = await this.incrementalCache.getFallback(\n                locale ? `/${locale}${pathname}` : pathname\n              )\n              return {\n                value: {\n                  kind: 'PAGE',\n                  html: RenderResult.fromStatic(html),\n                  pageData: {},\n                },\n              }\n            }\n            // We need to generate the fallback on-demand for development.\n            else {\n              query.__nextFallback = 'true'\n              if (isLikeServerless) {\n                prepareServerlessUrl(req, query)\n              }\n              const result = await doRender()\n              if (!result) {\n                return null\n              }\n              // Prevent caching this result\n              delete result.revalidate\n              return result\n            }\n          }\n        }\n\n        const result = await doRender()\n        if (!result) {\n          return null\n        }\n        return {\n          ...result,\n          revalidate:\n            result.revalidate !== undefined\n              ? result.revalidate\n              : /* default to minimum revalidate (this should be an invariant) */ 1,\n        }\n      }\n    )\n\n    if (!cacheEntry) {\n      if (ssgCacheKey) {\n        // A cache entry might not be generated if a response is written\n        // in `getInitialProps` or `getServerSideProps`, but those shouldn't\n        // have a cache key. If we do have a cache key but we don't end up\n        // with a cache entry, then either Next.js or the application has a\n        // bug that needs fixing.\n        throw new Error('invariant: cache entry required but not generated')\n      }\n      return null\n    }\n\n    const { revalidate, value: cachedData } = cacheEntry\n    const revalidateOptions: any =\n      typeof revalidate !== 'undefined' &&\n      (!this.renderOpts.dev || (hasServerProps && !isDataReq))\n        ? {\n            // When the page is 404 cache-control should not be added unless\n            // we are rendering the 404 page for notFound: true which should\n            // cache according to revalidate correctly\n            private: isPreviewMode || (is404Page && cachedData),\n            stateful: !isSSG,\n            revalidate,\n          }\n        : undefined\n\n    if (!cachedData) {\n      if (revalidateOptions) {\n        setRevalidateHeaders(res, revalidateOptions)\n      }\n      if (isDataReq) {\n        res.statusCode = 404\n        res.end('{\"notFound\":true}')\n        return null\n      } else {\n        await this.render404(\n          req,\n          res,\n          {\n            pathname,\n            query,\n          } as UrlWithParsedQuery,\n          false\n        )\n        return null\n      }\n    } else if (cachedData.kind === 'REDIRECT') {\n      if (isDataReq) {\n        return {\n          type: 'json',\n          body: RenderResult.fromStatic(JSON.stringify(cachedData.props)),\n          revalidateOptions,\n        }\n      } else {\n        await handleRedirect(cachedData.props)\n        return null\n      }\n    } else {\n      return {\n        type: isDataReq ? 'json' : 'html',\n        body: isDataReq\n          ? RenderResult.fromStatic(JSON.stringify(cachedData.pageData))\n          : cachedData.html,\n        revalidateOptions,\n      }\n    }\n  }\n\n  private async renderToResponse(\n    ctx: RequestContext\n  ): Promise<ResponsePayload | null> {\n    const { res, query, pathname } = ctx\n    let page = pathname\n    const bubbleNoFallback = !!query._nextBubbleNoFallback\n    delete query._nextBubbleNoFallback\n\n    try {\n      const result = await this.findPageComponents(pathname, query)\n      if (result) {\n        try {\n          return await this.renderToResponseWithComponents(ctx, result)\n        } catch (err) {\n          const isNoFallbackError = err instanceof NoFallbackError\n\n          if (!isNoFallbackError || (isNoFallbackError && bubbleNoFallback)) {\n            throw err\n          }\n        }\n      }\n\n      if (this.dynamicRoutes) {\n        for (const dynamicRoute of this.dynamicRoutes) {\n          const params = dynamicRoute.match(pathname)\n          if (!params) {\n            continue\n          }\n\n          const dynamicRouteResult = await this.findPageComponents(\n            dynamicRoute.page,\n            query,\n            params\n          )\n          if (dynamicRouteResult) {\n            try {\n              page = dynamicRoute.page\n              return await this.renderToResponseWithComponents(\n                {\n                  ...ctx,\n                  pathname: dynamicRoute.page,\n                  renderOpts: {\n                    ...ctx.renderOpts,\n                    params,\n                  },\n                },\n                dynamicRouteResult\n              )\n            } catch (err) {\n              const isNoFallbackError = err instanceof NoFallbackError\n\n              if (\n                !isNoFallbackError ||\n                (isNoFallbackError && bubbleNoFallback)\n              ) {\n                throw err\n              }\n            }\n          }\n        }\n      }\n    } catch (error) {\n      const err = isError(error) ? error : error ? new Error(error + '') : null\n      if (err instanceof NoFallbackError && bubbleNoFallback) {\n        throw err\n      }\n      if (err instanceof DecodeError) {\n        res.statusCode = 400\n        return await this.renderErrorToResponse(ctx, err)\n      }\n\n      res.statusCode = 500\n      const isWrappedError = err instanceof WrappedBuildError\n      const response = await this.renderErrorToResponse(\n        ctx,\n        isWrappedError ? (err as WrappedBuildError).innerError : err\n      )\n\n      if (!isWrappedError) {\n        if (this.minimalMode || this.renderOpts.dev) {\n          if (isError(err)) err.page = page\n          throw err\n        }\n        this.logError(err || new Error(error + ''))\n      }\n      return response\n    }\n    res.statusCode = 404\n    return this.renderErrorToResponse(ctx, null)\n  }\n\n  public async renderToHTML(\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  public async renderError(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: NextParsedUrlQuery = {},\n    setHeaders = true\n  ): Promise<void> {\n    if (setHeaders) {\n      res.setHeader(\n        'Cache-Control',\n        'no-cache, no-store, max-age=0, must-revalidate'\n      )\n    }\n\n    return this.pipe(\n      async (ctx) => {\n        const response = await this.renderErrorToResponse(ctx, err)\n        if (this.minimalMode && res.statusCode === 500) {\n          throw err\n        }\n        return response\n      },\n      { req, res, pathname, query }\n    )\n  }\n\n  private customErrorNo404Warn = execOnce(() => {\n    Log.warn(\n      `You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.\\nSee here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`\n    )\n  })\n\n  private async renderErrorToResponse(\n    ctx: RequestContext,\n    _err: Error | null\n  ): Promise<ResponsePayload | null> {\n    const { res, query } = ctx\n    let err = _err\n    if (this.renderOpts.dev && !err && res.statusCode === 500) {\n      err = new Error(\n        'An undefined error was thrown sometime during render... ' +\n          'See https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n    try {\n      let result: null | FindComponentsResult = null\n\n      const is404 = res.statusCode === 404\n      let using404Page = false\n\n      // use static 404 page if available and is 404 response\n      if (is404) {\n        result = await this.findPageComponents('/404', query)\n        using404Page = result !== null\n      }\n      let statusPage = `/${res.statusCode}`\n\n      if (!result && STATIC_STATUS_PAGES.includes(statusPage)) {\n        result = await this.findPageComponents(statusPage, query)\n      }\n\n      if (!result) {\n        result = await this.findPageComponents('/_error', query)\n        statusPage = '/_error'\n      }\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        !using404Page &&\n        (await this.hasPage('/_error')) &&\n        !(await this.hasPage('/404'))\n      ) {\n        this.customErrorNo404Warn()\n      }\n\n      try {\n        return await this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: statusPage,\n            renderOpts: {\n              ...ctx.renderOpts,\n              err,\n            },\n          },\n          result!\n        )\n      } catch (maybeFallbackError) {\n        if (maybeFallbackError instanceof NoFallbackError) {\n          throw new Error('invariant: failed to render error page')\n        }\n        throw maybeFallbackError\n      }\n    } catch (error) {\n      const renderToHtmlError = isError(error)\n        ? error\n        : error\n        ? new Error(error + '')\n        : null\n      const isWrappedError = renderToHtmlError instanceof WrappedBuildError\n      if (!isWrappedError) {\n        this.logError(renderToHtmlError || new Error(error + ''))\n      }\n      res.statusCode = 500\n      const fallbackComponents = await this.getFallbackErrorComponents()\n\n      if (fallbackComponents) {\n        return this.renderToResponseWithComponents(\n          {\n            ...ctx,\n            pathname: '/_error',\n            renderOpts: {\n              ...ctx.renderOpts,\n              // We render `renderToHtmlError` here because `err` is\n              // already captured in the stacktrace.\n              err: isWrappedError\n                ? renderToHtmlError.innerError\n                : renderToHtmlError,\n            },\n          },\n          {\n            query,\n            components: fallbackComponents,\n          }\n        )\n      }\n      return {\n        type: 'html',\n        body: RenderResult.fromStatic('Internal Server Error'),\n      }\n    }\n  }\n\n  public async renderErrorToHTML(\n    err: Error | null,\n    req: IncomingMessage,\n    res: ServerResponse,\n    pathname: string,\n    query: ParsedUrlQuery = {}\n  ): Promise<string | null> {\n    return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {\n      req,\n      res,\n      pathname,\n      query,\n    })\n  }\n\n  protected async getFallbackErrorComponents(): Promise<LoadComponentsReturnType | null> {\n    // The development server will provide an implementation for this\n    return null\n  }\n\n  public async render404(\n    req: IncomingMessage,\n    res: ServerResponse,\n    parsedUrl?: NextUrlWithParsedQuery,\n    setHeaders = true\n  ): Promise<void> {\n    const { pathname, query }: NextUrlWithParsedQuery = parsedUrl\n      ? parsedUrl\n      : parseUrl(req.url!, true)\n\n    if (this.nextConfig.i18n) {\n      query.__nextLocale =\n        query.__nextLocale || this.nextConfig.i18n.defaultLocale\n      query.__nextDefaultLocale =\n        query.__nextDefaultLocale || this.nextConfig.i18n.defaultLocale\n    }\n\n    res.statusCode = 404\n    return this.renderError(null, req, res, pathname!, query, setHeaders)\n  }\n\n  public async serveStatic(\n    req: IncomingMessage,\n    res: ServerResponse,\n    path: string,\n    parsedUrl?: UrlWithParsedQuery\n  ): Promise<void> {\n    if (!this.isServeableUrl(path)) {\n      return this.render404(req, res, parsedUrl)\n    }\n\n    if (!(req.method === 'GET' || req.method === 'HEAD')) {\n      res.statusCode = 405\n      res.setHeader('Allow', ['GET', 'HEAD'])\n      return this.renderError(null, req, res, path)\n    }\n\n    try {\n      await serveStatic(req, res, path)\n    } catch (error) {\n      if (!isError(error)) throw error\n      const err = error as Error & { code?: string; statusCode?: number }\n      if (err.code === 'ENOENT' || err.statusCode === 404) {\n        this.render404(req, res, parsedUrl)\n      } else if (err.statusCode === 412) {\n        res.statusCode = 412\n        return this.renderError(err, req, res, path)\n      } else {\n        throw err\n      }\n    }\n  }\n\n  private _validFilesystemPathSet: Set<string> | null = null\n  private getFilesystemPaths(): Set<string> {\n    if (this._validFilesystemPathSet) {\n      return this._validFilesystemPathSet\n    }\n\n    const pathUserFilesStatic = join(this.dir, 'static')\n    let userFilesStatic: string[] = []\n    if (this.hasStaticDir && fs.existsSync(pathUserFilesStatic)) {\n      userFilesStatic = recursiveReadDirSync(pathUserFilesStatic).map((f) =>\n        join('.', 'static', f)\n      )\n    }\n\n    let userFilesPublic: string[] = []\n    if (this.publicDir && fs.existsSync(this.publicDir)) {\n      userFilesPublic = recursiveReadDirSync(this.publicDir).map((f) =>\n        join('.', 'public', f)\n      )\n    }\n\n    let nextFilesStatic: string[] = []\n\n    nextFilesStatic =\n      !this.minimalMode && fs.existsSync(join(this.distDir, 'static'))\n        ? recursiveReadDirSync(join(this.distDir, 'static')).map((f) =>\n            join('.', relative(this.dir, this.distDir), 'static', f)\n          )\n        : []\n\n    return (this._validFilesystemPathSet = new Set<string>([\n      ...nextFilesStatic,\n      ...userFilesPublic,\n      ...userFilesStatic,\n    ]))\n  }\n\n  protected isServeableUrl(untrustedFileUrl: string): boolean {\n    // This method mimics what the version of `send` we use does:\n    // 1. decodeURIComponent:\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L989\n    //    https://github.com/pillarjs/send/blob/0.17.1/index.js#L518-L522\n    // 2. resolve:\n    //    https://github.com/pillarjs/send/blob/de073ed3237ade9ff71c61673a34474b30e5d45b/index.js#L561\n\n    let decodedUntrustedFilePath: string\n    try {\n      // (1) Decode the URL so we have the proper file name\n      decodedUntrustedFilePath = decodeURIComponent(untrustedFileUrl)\n    } catch {\n      return false\n    }\n\n    // (2) Resolve \"up paths\" to determine real request\n    const untrustedFilePath = resolve(decodedUntrustedFilePath)\n\n    // don't allow null bytes anywhere in the file path\n    if (untrustedFilePath.indexOf('\\0') !== -1) {\n      return false\n    }\n\n    // Check if .next/static, static and public are in the path.\n    // If not the path is not available.\n    if (\n      (untrustedFilePath.startsWith(join(this.distDir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'static') + sep) ||\n        untrustedFilePath.startsWith(join(this.dir, 'public') + sep)) === false\n    ) {\n      return false\n    }\n\n    // Check against the real filesystem paths\n    const filesystemUrls = this.getFilesystemPaths()\n    const resolved = relative(this.dir, untrustedFilePath)\n    return filesystemUrls.has(resolved)\n  }\n\n  protected readBuildId(): string {\n    const buildIdFile = join(this.distDir, BUILD_ID_FILE)\n    try {\n      return fs.readFileSync(buildIdFile, 'utf8').trim()\n    } catch (err) {\n      if (!fs.existsSync(buildIdFile)) {\n        throw new Error(\n          `Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`\n        )\n      }\n\n      throw err\n    }\n  }\n\n  protected get _isLikeServerless(): boolean {\n    return isTargetLikeServerless(this.nextConfig.target)\n  }\n}\n\nfunction prepareServerlessUrl(\n  req: IncomingMessage,\n  query: ParsedUrlQuery\n): void {\n  const curUrl = parseUrl(req.url!, true)\n  req.url = formatUrl({\n    ...curUrl,\n    search: undefined,\n    query: {\n      ...curUrl.query,\n      ...query,\n    },\n  })\n}\n\nclass NoFallbackError extends Error {}\n\n// Internal wrapper around build errors at development\n// time, to prevent us from propagating or logging them\nexport class WrappedBuildError extends Error {\n  innerError: Error\n\n  constructor(innerError: Error) {\n    super()\n    this.innerError = innerError\n  }\n}\n\ntype ResponsePayload = {\n  type: 'html' | 'json'\n  body: RenderResult\n  revalidateOptions?: any\n}\n", "/* eslint-env jest */\n/* global browserName */\nimport webdriver from 'next-webdriver'\nimport { readFileSync } from 'fs'\nimport http from 'http'\nimport url from 'url'\nimport { join } from 'path'\nimport {\n  renderViaHTTP,\n  getBrowserBodyText,\n  waitFor,\n  fetchViaHTTP,\n} from 'next-test-utils'\nimport { recursiveReadDir } from 'next/dist/lib/recursive-readdir'\nimport { homedir } from 'os'\n\n// Does the same evaluation checking for INJECTED for 5 seconds after hydration, triggering every 500ms\nasync function checkInjected(browser) {\n  const start = Date.now()\n  while (Date.now() - start < 5000) {\n    const bodyText = await getBrowserBodyText(browser)\n    if (/INJECTED/.test(bodyText)) {\n      throw new Error('Vulnerable to XSS attacks')\n    }\n    await waitFor(500)\n  }\n}\n\nmodule.exports = (context) => {\n  describe('With Security Related Issues', () => {\n    it('should handle invalid URL properly', async () => {\n      async function invalidRequest() {\n        return new Promise((resolve, reject) => {\n          const request = http.request(\n            {\n              hostname: `localhost`,\n              port: context.appPort,\n              path: `*`,\n            },\n            (response) => {\n              resolve(response.statusCode)\n            }\n          )\n          request.on('error', (err) => reject(err))\n          request.end()\n        })\n      }\n      try {\n        expect(await invalidRequest()).toBe(400)\n        expect(await invalidRequest()).toBe(400)\n      } catch (err) {\n        // eslint-disable-next-line\n        expect(err.code).toBe('ECONNREFUSED')\n      }\n    })\n\n    it('should only access files inside .next directory', async () => {\n      const buildId = readFileSync(join(__dirname, '../.next/BUILD_ID'), 'utf8')\n\n      const pathsToCheck = [\n        `/_next/${buildId}/page/../../../info`,\n        `/_next/${buildId}/page/../../../info.js`,\n        `/_next/${buildId}/page/../../../info.json`,\n        `/_next/:buildId/webpack/chunks/../../../info.json`,\n        `/_next/:buildId/webpack/../../../info.json`,\n        `/_next/../../../info.json`,\n        `/static/../../../info.json`,\n        `/static/../info.json`,\n        `/../../../info.json`,\n        `/../../info.json`,\n        `/../info.json`,\n        `/info.json`,\n      ]\n\n      for (const path of pathsToCheck) {\n        const data = await renderViaHTTP(context.appPort, path)\n        expect(data.includes('cool-version')).toBeFalsy()\n      }\n    })\n\n    it('should not allow accessing files outside .next/static directory', async () => {\n      const pathsToCheck = [\n        `/_next/static/../server/pages-manifest.json`,\n        `/_next/static/../server/build-manifest.json`,\n        `/_next/static/../BUILD_ID`,\n        `/_next/static/../routes-manifest.json`,\n      ]\n      for (const path of pathsToCheck) {\n        const res = await fetchViaHTTP(context.appPort, path)\n        const text = await res.text()\n        try {\n          expect(res.status).toBe(404)\n          expect(text).toMatch(/This page could not be found/)\n        } catch (err) {\n          throw new Error(`Path ${path} accessible from the browser`)\n        }\n      }\n    })\n\n    it(\"should not leak the user's home directory into the build\", async () => {\n      const buildId = readFileSync(join(__dirname, '../.next/BUILD_ID'), 'utf8')\n\n      const readPath = join(__dirname, `../.next/static/${buildId}`)\n      const buildFiles = await recursiveReadDir(readPath, /\\.js$/)\n\n      if (buildFiles.length < 1) {\n        throw new Error('Could not locate any build files')\n      }\n\n      const homeDir = homedir()\n      buildFiles.forEach((buildFile) => {\n        const content = readFileSync(join(readPath, buildFile), 'utf8')\n        if (content.includes(homeDir)) {\n          throw new Error(\n            `Found the user's home directory in: ${buildFile}, ${homeDir}\\n\\n${content}`\n          )\n        }\n        // TODO: this checks the monorepo's path currently, we should check\n        // the Next.js apps directory instead once using isolated next\n        const checkPathProject = join(__dirname, ...Array(4).fill('..'))\n        if (\n          content.includes(checkPathProject) ||\n          (process.platform.match(/win/) &&\n            content.includes(checkPathProject.replace(/\\\\/g, '\\\\\\\\')))\n        ) {\n          throw new Error(\n            `Found the project path in: ${buildFile}, ${checkPathProject}\\n\\n${content}`\n          )\n        }\n      })\n    })\n\n    it('should prevent URI based XSS attacks', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        '/\\',document.body.innerHTML=\"INJECTED\",\\''\n      )\n      await checkInjected(browser)\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using single quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/'-(document.body.innerHTML='INJECTED')-'`\n      )\n      await checkInjected(browser)\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using double quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/\"-(document.body.innerHTML='INJECTED')-\"`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using semicolons and double quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/;\"-(document.body.innerHTML='INJECTED')-\"`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using semicolons and single quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/;'-(document.body.innerHTML='INJECTED')-'`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using src', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/javascript:(document.body.innerHTML='INJECTED')`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using querystring', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/?javascript=(document.body.innerHTML='INJECTED')`\n      )\n      await checkInjected(browser)\n\n      await browser.close()\n    })\n\n    it('should prevent URI based XSS attacks using querystring and quotes', async () => {\n      const browser = await webdriver(\n        context.appPort,\n        `/?javascript=\"(document.body.innerHTML='INJECTED')\"`\n      )\n      await checkInjected(browser)\n      await browser.close()\n    })\n\n    it('should handle encoded value in the pathname correctly \\\\', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect/me/to-about/' + encodeURI('\\\\google.com'),\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe(encodeURI('/\\\\google.com/about'))\n      expect(hostname).toBe('localhost')\n    })\n\n    it('should handle encoded value in the pathname correctly %', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect/me/to-about/%25google.com',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe('/%25google.com/about')\n      expect(hostname).toBe('localhost')\n    })\n\n    it('should handle encoded value in the query correctly', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/trailing-redirect/?url=https%3A%2F%2Fgoogle.com%2Fimage%3Fcrop%3Dfocalpoint%26w%3D24&w=1200&q=100',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname, query } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(308)\n      expect(pathname).toBe('/trailing-redirect')\n      expect(hostname).toBe('localhost')\n      expect(query).toBe(\n        'url=https%3A%2F%2Fgoogle.com%2Fimage%3Fcrop%3Dfocalpoint%26w%3D24&w=1200&q=100'\n      )\n    })\n\n    it('should handle encoded value in the pathname correctly /', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect/me/to-about/%2fgoogle.com',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe('/%2fgoogle.com/about')\n      expect(hostname).not.toBe('google.com')\n    })\n\n    it('should handle encoded value in the pathname to query correctly (/)', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/redirect-query-test/%2Fgoogle.com',\n        undefined,\n        {\n          redirect: 'manual',\n        }\n      )\n\n      const { pathname, hostname, query } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(307)\n      expect(pathname).toBe('/about')\n      expect(query).toBe('foo=%2Fgoogle.com')\n      expect(hostname).not.toBe('google.com')\n      expect(hostname).not.toMatch(/google/)\n    })\n\n    it('should handle encoded / value for trailing slash correctly', async () => {\n      const res = await fetchViaHTTP(\n        context.appPort,\n        '/%2fexample.com/',\n        undefined,\n        { redirect: 'manual' }\n      )\n\n      const { pathname, hostname } = url.parse(\n        res.headers.get('location') || ''\n      )\n      expect(res.status).toBe(308)\n      expect(pathname).toBe('/%2fexample.com')\n      expect(hostname).not.toBe('example.com')\n    })\n\n    if (browserName !== 'internet explorer') {\n      it('should not execute script embedded inside svg image', async () => {\n        let browser\n        try {\n          browser = await webdriver(context.appPort, '/svg-image')\n          await browser.eval(`document.getElementById(\"img\").scrollIntoView()`)\n          expect(\n            await browser.elementById('img').getAttribute('src')\n          ).toContain('xss.svg')\n          expect(await browser.elementById('msg').text()).toBe('safe')\n          browser = await webdriver(\n            context.appPort,\n            '/_next/image?url=%2Fxss.svg&w=256&q=75'\n          )\n          expect(await browser.elementById('msg').text()).toBe('safe')\n        } finally {\n          if (browser) await browser.close()\n        }\n      })\n    }\n  })\n}\n"], "filenames": ["packages/next/build/swc/index.js", "packages/next/server/next-server.ts", "test/integration/production/test/security.js"], "buggy_code_start_loc": [3, 362, 4], "buggy_code_end_loc": [4, 562, 29], "fixing_code_start_loc": [3, 362, 5], "fixing_code_end_loc": [4, 570, 57], "type": "NVD-CWE-noinfo", "message": "Next.js is a React framework. In versions of Next.js prior to 12.0.5 or 11.1.3, invalid or malformed URLs could lead to a server crash. In order to be affected by this issue, the deployment must use Next.js versions above 11.1.0 and below 12.0.5, Node.js above 15.0.0, and next start or a custom server. Deployments on Vercel are not affected, along with similar environments where invalid requests are filtered before reaching Next.js. Versions 12.0.5 and 11.1.3 contain patches for this issue.", "other": {"cve": {"id": "CVE-2021-43803", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-10T00:15:11.827", "lastModified": "2022-02-17T15:55:14.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Next.js is a React framework. In versions of Next.js prior to 12.0.5 or 11.1.3, invalid or malformed URLs could lead to a server crash. In order to be affected by this issue, the deployment must use Next.js versions above 11.1.0 and below 12.0.5, Node.js above 15.0.0, and next start or a custom server. Deployments on Vercel are not affected, along with similar environments where invalid requests are filtered before reaching Next.js. Versions 12.0.5 and 11.1.3 contain patches for this issue."}, {"lang": "es", "value": "Next.js es un framework de React. En las versiones de Next.js anteriores a 12.0.5 o 11.1.3, las direcciones URL no v\u00e1lidas o malformadas podr\u00edan conllevar a un bloqueo del servidor. Para verse afectado por este problema, el despliegue debe usar versiones de Next.js superiores a 11.1.0 y anteriores a 12.0.5, Node.js versiones posteriores a 15.0.0, y el siguiente inicio o un servidor personalizado. Los despliegues en Vercel no est\u00e1n afectados, junto con entornos similares en los que las peticiones no v\u00e1lidas son filtradas antes de llegar a Next.js. Las versiones 12.0.5 y 11.1.3 contienen parches para este problema"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "AND", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:-:*:*:*", "versionStartIncluding": "15.0.0", "matchCriteriaId": "996A6068-7CAE-416C-AF03-DB2A94F813D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vercel:next.js:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "11.1.0", "versionEndExcluding": "11.1.3", "matchCriteriaId": "D413EFEB-941C-4FDD-BA04-32B7902BCFE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:vercel:next.js:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "12.0.0", "versionEndExcluding": "12.0.5", "matchCriteriaId": "C1457A80-9287-4C15-9AF3-8CE57500C4AA"}]}]}], "references": [{"url": "https://github.com/vercel/next.js/commit/6d98b4fb4315dec1badecf0e9bdc212a4272b264", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vercel/next.js/pull/32080", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vercel/next.js/releases/tag/v11.1.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vercel/next.js/releases/v12.0.5", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/vercel/next.js/security/advisories/GHSA-25mp-g6fv-mqxx", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vercel/next.js/commit/6d98b4fb4315dec1badecf0e9bdc212a4272b264"}}