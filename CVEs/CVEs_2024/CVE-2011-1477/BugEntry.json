{"buggy_code": ["/*\n * sound/oss/opl3.c\n *\n * A low level driver for Yamaha YM3812 and OPL-3 -chips\n *\n *\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n *\n *\n * Changes\n *\tThomas Sailer   \tioctl code reworked (vmalloc/vfree removed)\n *\tAlan Cox\t\tmodularisation, fixed sound_mem allocs.\n *\tChristoph Hellwig\tAdapted to module_init/module_exit\n *\tArnaldo C. de Melo\tget rid of check_region, use request_region for\n *\t\t\t\tOPL4, release it on exit, some cleanups.\n *\n * Status\n *\tBelieved to work. Badly needs rewriting a bit to support multiple\n *\tOPL3 devices.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\n/*\n * Major improvements to the FM handling 30AUG92 by Rob Hooft,\n * hooft@chem.ruu.nl\n */\n\n#include \"sound_config.h\"\n\n#include \"opl3_hw.h\"\n\n#define MAX_VOICE\t18\n#define OFFS_4OP\t11\n\nstruct voice_info\n{\n\tunsigned char   keyon_byte;\n\tlong            bender;\n\tlong            bender_range;\n\tunsigned long   orig_freq;\n\tunsigned long   current_freq;\n\tint             volume;\n\tint             mode;\n\tint             panning;\t/* 0xffff means not set */\n};\n\ntypedef struct opl_devinfo\n{\n\tint             base;\n\tint             left_io, right_io;\n\tint             nr_voice;\n\tint             lv_map[MAX_VOICE];\n\n\tstruct voice_info voc[MAX_VOICE];\n\tstruct voice_alloc_info *v_alloc;\n\tstruct channel_info *chn_info;\n\n\tstruct sbi_instrument i_map[SBFM_MAXINSTR];\n\tstruct sbi_instrument *act_i[MAX_VOICE];\n\n\tstruct synth_info fm_info;\n\n\tint             busy;\n\tint             model;\n\tunsigned char   cmask;\n\n\tint             is_opl4;\n} opl_devinfo;\n\nstatic struct opl_devinfo *devc = NULL;\n\nstatic int      detected_model;\n\nstatic int      store_instr(int instr_no, struct sbi_instrument *instr);\nstatic void     freq_to_fnum(int freq, int *block, int *fnum);\nstatic void     opl3_command(int io_addr, unsigned int addr, unsigned int val);\nstatic int      opl3_kill_note(int dev, int voice, int note, int velocity);\n\nstatic void enter_4op_mode(void)\n{\n\tint i;\n\tstatic int v4op[MAX_VOICE] = {\n\t\t0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17\n\t};\n\n\tdevc->cmask = 0x3f;\t/* Connect all possible 4 OP voice operators */\n\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x3f);\n\n\tfor (i = 0; i < 3; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 3; i < 6; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 9; i < 12; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 12; i < 15; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 0; i < 12; i++)\n\t\tdevc->lv_map[i] = v4op[i];\n\tdevc->v_alloc->max_voice = devc->nr_voice = 12;\n}\n\nstatic int opl3_ioctl(int dev, unsigned int cmd, void __user * arg)\n{\n\tstruct sbi_instrument ins;\n\t\n\tswitch (cmd) {\n\t\tcase SNDCTL_FM_LOAD_INSTR:\n\t\t\tprintk(KERN_WARNING \"Warning: Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. Fix the program.\\n\");\n\t\t\tif (copy_from_user(&ins, arg, sizeof(ins)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR) {\n\t\t\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn store_instr(ins.channel, &ins);\n\n\t\tcase SNDCTL_SYNTH_INFO:\n\t\t\tdevc->fm_info.nr_voices = (devc->nr_voice == 12) ? 6 : devc->nr_voice;\n\t\t\tif (copy_to_user(arg, &devc->fm_info, sizeof(devc->fm_info)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\treturn 0x7fffffff;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\tif (devc->model == 2)\n\t\t\t\tenter_4op_mode();\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic int opl3_detect(int ioaddr)\n{\n\t/*\n\t * This function returns 1 if the FM chip is present at the given I/O port\n\t * The detection algorithm plays with the timer built in the FM chip and\n\t * looks for a change in the status register.\n\t *\n\t * Note! The timers of the FM chip are not connected to AdLib (and compatible)\n\t * boards.\n\t *\n\t * Note2! The chip is initialized if detected.\n\t */\n\n\tunsigned char stat1, signature;\n\tint i;\n\n\tif (devc != NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Only one OPL3 supported.\\n\");\n\t\treturn 0;\n\t}\n\n\tdevc = kzalloc(sizeof(*devc), GFP_KERNEL);\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Can't allocate memory for the device control \"\n\t\t\t\"structure \\n \");\n\t\treturn 0;\n\t}\n\n\tstrcpy(devc->fm_info.name, \"OPL2\");\n\n\tif (!request_region(ioaddr, 4, devc->fm_info.name)) {\n\t\tprintk(KERN_WARNING \"opl3: I/O port 0x%x already in use\\n\", ioaddr);\n\t\tgoto cleanup_devc;\n\t}\n\n\tdevc->base = ioaddr;\n\n\t/* Reset timers 1 and 2 */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, TIMER1_MASK | TIMER2_MASK);\n\n\t/* Reset the IRQ of the FM chip */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, IRQ_RESET);\n\n\tsignature = stat1 = inb(ioaddr);\t/* Status register */\n\n\tif (signature != 0x00 && signature != 0x06 && signature != 0x02 &&\n\t\tsignature != 0x0f)\n\t{\n\t\tMDB(printk(KERN_INFO \"OPL3 not detected %x\\n\", signature));\n\t\tgoto cleanup_region;\n\t}\n\n\tif (signature == 0x06)\t\t/* OPL2 */\n\t{\n\t\tdetected_model = 2;\n\t}\n\telse if (signature == 0x00 || signature == 0x0f)\t/* OPL3 or OPL4 */\n\t{\n\t\tunsigned char tmp;\n\n\t\tdetected_model = 3;\n\n\t\t/*\n\t\t * Detect availability of OPL4 (_experimental_). Works probably\n\t\t * only after a cold boot. In addition the OPL4 port\n\t\t * of the chip may not be connected to the PC bus at all.\n\t\t */\n\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0x00);\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, OPL3_ENABLE | OPL4_ENABLE);\n\n\t\tif ((tmp = inb(ioaddr)) == 0x02)\t/* Have a OPL4 */\n\t\t{\n\t\t\tdetected_model = 4;\n\t\t}\n\n\t\tif (request_region(ioaddr - 8, 2, \"OPL4\"))\t/* OPL4 port was free */\n\t\t{\n\t\t\tint tmp;\n\n\t\t\toutb((0x02), ioaddr - 8);\t/* Select OPL4 ID register */\n\t\t\tudelay(10);\n\t\t\ttmp = inb(ioaddr - 7);\t\t/* Read it */\n\t\t\tudelay(10);\n\n\t\t\tif (tmp == 0x20)\t/* OPL4 should return 0x20 here */\n\t\t\t{\n\t\t\t\tdetected_model = 4;\n\t\t\t\toutb((0xF8), ioaddr - 8);\t/* Select OPL4 FM mixer control */\n\t\t\t\tudelay(10);\n\t\t\t\toutb((0x1B), ioaddr - 7);\t/* Write value */\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t\telse\n\t\t\t{ /* release OPL4 port */\n\t\t\t\trelease_region(ioaddr - 8, 2);\n\t\t\t\tdetected_model = 3;\n\t\t\t}\n\t\t}\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0);\n\t}\n\tfor (i = 0; i < 9; i++)\n\t\topl3_command(ioaddr, KEYON_BLOCK + i, 0);\t/*\n\t\t\t\t\t\t\t\t * Note off\n\t\t\t\t\t\t\t\t */\n\n\topl3_command(ioaddr, TEST_REGISTER, ENABLE_WAVE_SELECT);\n\topl3_command(ioaddr, PERCOSSION_REGISTER, 0x00);\t/*\n\t\t\t\t\t\t\t\t * Melodic mode.\n\t\t\t\t\t\t\t\t */\n\treturn 1;\ncleanup_region:\n\trelease_region(ioaddr, 4);\ncleanup_devc:\n\tkfree(devc);\n\tdevc = NULL;\n\treturn 0;\n}\n\nstatic int opl3_kill_note  (int devno, int voice, int note, int velocity)\n{\n\t struct physical_voice_info *map;\n\n\t if (voice < 0 || voice >= devc->nr_voice)\n\t\t return 0;\n\n\t devc->v_alloc->map[voice] = 0;\n\n\t map = &pv_map[devc->lv_map[voice]];\n\t DEB(printk(\"Kill note %d\\n\", voice));\n\n\t if (map->voice_mode == 0)\n\t\t return 0;\n\n\t opl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, devc->voc[voice].keyon_byte & ~0x20);\n\t devc->voc[voice].keyon_byte = 0;\n\t devc->voc[voice].bender = 0;\n\t devc->voc[voice].volume = 64;\n\t devc->voc[voice].panning = 0xffff;\t/* Not set */\n\t devc->voc[voice].bender_range = 200;\n\t devc->voc[voice].orig_freq = 0;\n\t devc->voc[voice].current_freq = 0;\n\t devc->voc[voice].mode = 0;\n\t return 0;\n}\n\n#define HIHAT\t\t\t0\n#define CYMBAL\t\t\t1\n#define TOMTOM\t\t\t2\n#define SNARE\t\t\t3\n#define BDRUM\t\t\t4\n#define UNDEFINED\t\tTOMTOM\n#define DEFAULT\t\t\tTOMTOM\n\nstatic int store_instr(int instr_no, struct sbi_instrument *instr)\n{\n\tif (instr->key != FM_PATCH && (instr->key != OPL3_PATCH || devc->model != 2))\n\t\tprintk(KERN_WARNING \"FM warning: Invalid patch format field (key) 0x%x\\n\", instr->key);\n\tmemcpy((char *) &(devc->i_map[instr_no]), (char *) instr, sizeof(*instr));\n\treturn 0;\n}\n\nstatic int opl3_set_instr  (int dev, int voice, int instr_no)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\tif (instr_no < 0 || instr_no >= SBFM_MAXINSTR)\n\t\tinstr_no = 0;\t/* Acoustic piano (usually) */\n\n\tdevc->act_i[voice] = &devc->i_map[instr_no];\n\treturn 0;\n}\n\n/*\n * The next table looks magical, but it certainly is not. Its values have\n * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception\n * for i=0. This log-table converts a linear volume-scaling (0..127) to a\n * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume\n * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative\n * volume -8 it was implemented as a table because it is only 128 bytes and\n * it saves a lot of log() calculations. (RH)\n */\n\nstatic char fm_volume_table[128] =\n{\n\t-64, -48, -40, -35, -32, -29, -27, -26,\n\t-24, -23, -21, -20, -19, -18, -18, -17,\n\t-16, -15, -15, -14, -13, -13, -12, -12,\n\t-11, -11, -10, -10, -10, -9, -9, -8,\n\t-8, -8, -7, -7, -7, -6, -6, -6,\n\t-5, -5, -5, -5, -4, -4, -4, -4,\n\t-3, -3, -3, -3, -2, -2, -2, -2,\n\t-2, -1, -1, -1, -1, 0, 0, 0,\n\t0, 0, 0, 1, 1, 1, 1, 1,\n\t1, 2, 2, 2, 2, 2, 2, 2,\n\t3, 3, 3, 3, 3, 3, 3, 4,\n\t4, 4, 4, 4, 4, 4, 4, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 7, 7, 7, 7, 7, 7, 7,\n\t7, 7, 7, 8, 8, 8, 8, 8\n};\n\nstatic void calc_vol(unsigned char *regbyte, int volume, int main_vol)\n{\n\tint level = (~*regbyte & 0x3f);\n\n\tif (main_vol > 127)\n\t\tmain_vol = 127;\n\tvolume = (volume * main_vol) / 127;\n\n\tif (level)\n\t\tlevel += fm_volume_table[volume];\n\n\tif (level > 0x3f)\n\t\tlevel = 0x3f;\n\tif (level < 0)\n\t\tlevel = 0;\n\n\t*regbyte = (*regbyte & 0xc0) | (~level & 0x3f);\n}\n\nstatic void set_voice_volume(int voice, int volume, int main_vol)\n{\n\tunsigned char vol1, vol2, vol3, vol4;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 2)\n\t{\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tif ((instr->operators[10] & 0x01))\n\t\t{\n\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t}\n\telse\n\t{\t/*\n\t\t * 4 OP voice\n\t\t */\n\t\tint connection;\n\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tvol3 = instr->operators[OFFS_4OP + 2];\n\t\tvol4 = instr->operators[OFFS_4OP + 3];\n\n\t\t/*\n\t\t * The connection method for 4 OP devc->voc is defined by the rightmost\n\t\t * bits at the offsets 10 and 10+OFFS_4OP\n\t\t */\n\n\t\tconnection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol3, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], vol3);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], vol4);\n\t}\n}\n\nstatic int opl3_start_note (int dev, int voice, int note, int volume)\n{\n\tunsigned char data, fpc;\n\tint block, fnum, freq, voice_mode, pan;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tpan = devc->voc[voice].panning;\n\n\tif (map->voice_mode == 0)\n\t\treturn 0;\n\n\tif (note == 255)\t/*\n\t\t\t\t * Just change the volume\n\t\t\t\t */\n\t{\n\t\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Kill previous note before playing\n\t */\n\t\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Carrier\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t * min\n\t\t\t\t\t\t\t\t\t */\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Modulator\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t */\n\n\tif (map->voice_mode == 4)\n\t{\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], 0xff);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], 0xff);\n\t}\n\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, 0x00);\t/*\n\t\t\t\t\t\t\t\t\t * Note\n\t\t\t\t\t\t\t\t\t * off\n\t\t\t\t\t\t\t\t\t */\n\n\tinstr = devc->act_i[voice];\n\t\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Initializing voice %d with undefined instrument\\n\", voice);\n\t\treturn 0;\n\t}\n\n\tif (map->voice_mode == 2 && instr->key == OPL3_PATCH)\n\t\treturn 0;\t/*\n\t\t\t\t * Cannot play\n\t\t\t\t */\n\n\tvoice_mode = map->voice_mode;\n\n\tif (voice_mode == 4)\n\t{\n\t\tint voice_shift;\n\n\t\tvoice_shift = (map->ioaddr == devc->left_io) ? 0 : 3;\n\t\tvoice_shift += map->voice_num;\n\n\t\tif (instr->key != OPL3_PATCH)\t/*\n\t\t\t\t\t\t * Just 2 OP patch\n\t\t\t\t\t\t */\n\t\t{\n\t\t\tvoice_mode = 2;\n\t\t\tdevc->cmask &= ~(1 << voice_shift);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevc->cmask |= (1 << voice_shift);\n\t\t}\n\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\t}\n\n\t/*\n\t * Set Sound Characteristics\n\t */\n\t\n\topl3_command(map->ioaddr, AM_VIB + map->op[0], instr->operators[0]);\n\topl3_command(map->ioaddr, AM_VIB + map->op[1], instr->operators[1]);\n\n\t/*\n\t * Set Attack/Decay\n\t */\n\t\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[0], instr->operators[4]);\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[1], instr->operators[5]);\n\n\t/*\n\t * Set Sustain/Release\n\t */\n\t\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[0], instr->operators[6]);\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[1], instr->operators[7]);\n\n\t/*\n\t * Set Wave Select\n\t */\n\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[0], instr->operators[8]);\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[1], instr->operators[9]);\n\n\t/*\n\t * Set Feedback/Connection\n\t */\n\t\n\tfpc = instr->operators[10];\n\n\tif (pan != 0xffff)\n\t{\n\t\tfpc &= ~STEREO_BITS;\n\t\tif (pan < -64)\n\t\t\tfpc |= VOICE_TO_LEFT;\n\t\telse\n\t\t\tif (pan > 64)\n\t\t\t\tfpc |= VOICE_TO_RIGHT;\n\t\t\telse\n\t\t\t\tfpc |= (VOICE_TO_LEFT | VOICE_TO_RIGHT);\n\t}\n\n\tif (!(fpc & 0x30))\n\t\tfpc |= 0x30;\t/*\n\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t */\n\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num, fpc);\n\n\t/*\n\t * If the voice is a 4 OP one, initialize the operators 3 and 4 also\n\t */\n\n\tif (voice_mode == 4)\n\t{\n\t\t/*\n\t\t * Set Sound Characteristics\n\t\t */\n\t\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[2], instr->operators[OFFS_4OP + 0]);\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[3], instr->operators[OFFS_4OP + 1]);\n\n\t\t/*\n\t\t * Set Attack/Decay\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[2], instr->operators[OFFS_4OP + 4]);\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[3], instr->operators[OFFS_4OP + 5]);\n\n\t\t/*\n\t\t * Set Sustain/Release\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[2], instr->operators[OFFS_4OP + 6]);\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[3], instr->operators[OFFS_4OP + 7]);\n\n\t\t/*\n\t\t * Set Wave Select\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[2], instr->operators[OFFS_4OP + 8]);\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[3], instr->operators[OFFS_4OP + 9]);\n\n\t\t/*\n\t\t * Set Feedback/Connection\n\t\t */\n\t\t\n\t\tfpc = instr->operators[OFFS_4OP + 10];\n\t\tif (!(fpc & 0x30))\n\t\t\t fpc |= 0x30;\t/*\n\t\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t\t */\n\t\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num + 3, fpc);\n\t}\n\n\tdevc->voc[voice].mode = voice_mode;\n\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\n\tfreq = devc->voc[voice].orig_freq = note_to_freq(note) / 1000;\n\n\t/*\n\t * Since the pitch bender may have been set before playing the note, we\n\t * have to calculate the bending now.\n\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\t/*\n\t * Play note\n\t */\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\t\t devc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n\tif (voice_mode == 4)\n\t\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num + 3, data);\n\n\treturn 0;\n}\n\nstatic void freq_to_fnum    (int freq, int *block, int *fnum)\n{\n\tint f, octave;\n\n\t/*\n\t * Converts the note frequency to block and fnum values for the FM chip\n\t */\n\t/*\n\t * First try to compute the block -value (octave) where the note belongs\n\t */\n\n\tf = freq;\n\n\toctave = 5;\n\n\tif (f == 0)\n\t\toctave = 0;\n\telse if (f < 261)\n\t{\n\t\twhile (f < 261)\n\t\t{\n\t\t\toctave--;\n\t\t\tf <<= 1;\n\t\t}\n\t}\n\telse if (f > 493)\n\t{\n\t\twhile (f > 493)\n\t\t{\n\t\t\t octave++;\n\t\t\t f >>= 1;\n\t\t}\n\t}\n\n\tif (octave > 7)\n\t\toctave = 7;\n\n\t*fnum = freq * (1 << (20 - octave)) / 49716;\n\t*block = octave;\n}\n\nstatic void opl3_command    (int io_addr, unsigned int addr, unsigned int val)\n{\n\t int i;\n\n\t/*\n\t * The original 2-OP synth requires a quite long delay after writing to a\n\t * register. The OPL-3 survives with just two INBs\n\t */\n\n\toutb(((unsigned char) (addr & 0xff)), io_addr);\n\n\tif (devc->model != 2)\n\t\tudelay(10);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n\n\toutb(((unsigned char) (val & 0xff)), io_addr + 1);\n\n\tif (devc->model != 2)\n\t\tudelay(30);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n}\n\nstatic void opl3_reset(int devno)\n{\n\tint i;\n\n\tfor (i = 0; i < 18; i++)\n\t\tdevc->lv_map[i] = i;\n\n\tfor (i = 0; i < devc->nr_voice; i++)\n\t{\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[0], 0xff);\n\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[1], 0xff);\n\n\t\tif (pv_map[devc->lv_map[i]].voice_mode == 4)\n\t\t{\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[2], 0xff);\n\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[3], 0xff);\n\t\t}\n\n\t\topl3_kill_note(devno, i, 0, 64);\n\t}\n\n\tif (devc->model == 2)\n\t{\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].voice_mode = 2;\n\n\t}\n}\n\nstatic int opl3_open(int dev, int mode)\n{\n\tint i;\n\n\tif (devc->busy)\n\t\treturn -EBUSY;\n\tdevc->busy = 1;\n\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\tdevc->v_alloc->timestamp = 0;\n\n\tfor (i = 0; i < 18; i++)\n\t{\n\t\tdevc->v_alloc->map[i] = 0;\n\t\tdevc->v_alloc->alloc_times[i] = 0;\n\t}\n\n\tdevc->cmask = 0x00;\t/*\n\t\t\t\t * Just 2 OP mode\n\t\t\t\t */\n\tif (devc->model == 2)\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\treturn 0;\n}\n\nstatic void opl3_close(int dev)\n{\n\tdevc->busy = 0;\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.perc_mode = 0;\n\n\topl3_reset(dev);\n}\n\nstatic void opl3_hw_control(int dev, unsigned char *event)\n{\n}\n\nstatic int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ins, addr, sizeof(ins)))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}\n\nstatic void opl3_panning(int dev, int voice, int value)\n{\n\tdevc->voc[voice].panning = value;\n}\n\nstatic void opl3_volume_method(int dev, int mode)\n{\n}\n\n#define SET_VIBRATO(cell) { \\\n\ttmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \\\n\tif (pressure > 110) \\\n\t\ttmp |= 0x40;\t\t/* Vibrato on */ \\\n\topl3_command (map->ioaddr, AM_VIB + map->op[cell-1], tmp);}\n\nstatic void opl3_aftertouch(int dev, int voice, int pressure)\n{\n\tint tmp;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tDEB(printk(\"Aftertouch %d\\n\", voice));\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\t/*\n\t * Adjust the amount of vibrato depending the pressure\n\t */\n\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (devc->voc[voice].mode == 4)\n\t{\n\t\tint connection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tSET_VIBRATO(2);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(3);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t}\n\t\t/*\n\t\t * Not implemented yet\n\t\t */\n\t}\n\telse\n\t{\n\t\tSET_VIBRATO(1);\n\n\t\tif ((instr->operators[10] & 0x01))\t/*\n\t\t\t\t\t\t\t * Additive synthesis\n\t\t\t\t\t\t\t */\n\t\t\tSET_VIBRATO(2);\n\t}\n}\n\n#undef SET_VIBRATO\n\nstatic void bend_pitch(int dev, int voice, int value)\n{\n\tunsigned char data;\n\tint block, fnum, freq;\n\tstruct physical_voice_info *map;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\tdevc->voc[voice].bender = value;\n\tif (!value)\n\t\treturn;\n\tif (!(devc->voc[voice].keyon_byte & 0x20))\n\t\treturn;\t/*\n\t\t\t * Not keyed on\n\t\t\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\tdevc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n}\n\nstatic void opl3_controller (int dev, int voice, int ctrl_num, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tswitch (ctrl_num)\n\t{\n\t\tcase CTRL_PITCH_BENDER:\n\t\t\tbend_pitch(dev, voice, value);\n\t\t\tbreak;\n\n\t\tcase CTRL_PITCH_BENDER_RANGE:\n\t\t\tdevc->voc[voice].bender_range = value;\n\t\t\tbreak;\n\n\t\tcase CTL_MAIN_VOLUME:\n\t\t\tdevc->voc[voice].volume = value / 128;\n\t\t\tbreak;\n\n\t\tcase CTL_PAN:\n\t\t\tdevc->voc[voice].panning = (value * 2) - 128;\n\t\t\tbreak;\n\t}\n}\n\nstatic void opl3_bender(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tbend_pitch(dev, voice, value - 8192);\n}\n\nstatic int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info *alloc)\n{\n\tint i, p, best, first, avail, best_time = 0x7fffffff;\n\tstruct sbi_instrument *instr;\n\tint is4op;\n\tint instr_no;\n\n\tif (chn < 0 || chn > 15)\n\t\tinstr_no = 0;\n\telse\n\t\tinstr_no = devc->chn_info[chn].pgm_num;\n\n\tinstr = &devc->i_map[instr_no];\n\tif (instr->channel < 0 ||\t/* Instrument not loaded */\n\t\tdevc->nr_voice != 12)\t/* Not in 4 OP mode */\n\t\tis4op = 0;\n\telse if (devc->nr_voice == 12)\t/* 4 OP mode */\n\t\tis4op = (instr->key == OPL3_PATCH);\n\telse\n\t\tis4op = 0;\n\n\tif (is4op)\n\t{\n\t\tfirst = p = 0;\n\t\tavail = 6;\n\t}\n\telse\n\t{\n\t\tif (devc->nr_voice == 12)\t/* 4 OP mode. Use the '2 OP only' operators first */\n\t\t\tfirst = p = 6;\n\t\telse\n\t\t\tfirst = p = 0;\n\t\tavail = devc->nr_voice;\n\t}\n\n\t/*\n\t *    Now try to find a free voice\n\t */\n\tbest = first;\n\n\tfor (i = 0; i < avail; i++)\n\t{\n\t\tif (alloc->map[p] == 0)\n\t\t{\n\t\t\treturn p;\n\t\t}\n\t\tif (alloc->alloc_times[p] < best_time)\t\t/* Find oldest playing note */\n\t\t{\n\t\t\tbest_time = alloc->alloc_times[p];\n\t\t\tbest = p;\n\t\t}\n\t\tp = (p + 1) % avail;\n\t}\n\n\t/*\n\t *    Insert some kind of priority mechanism here.\n\t */\n\n\tif (best < 0)\n\t\tbest = 0;\n\tif (best > devc->nr_voice)\n\t\tbest -= devc->nr_voice;\n\n\treturn best;\t/* All devc->voc in use. Select the first one. */\n}\n\nstatic void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info =\n\t&synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}\n\nstatic struct synth_operations opl3_operations =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.id\t\t= \"OPL\",\n\t.info\t\t= NULL,\n\t.midi_dev\t= 0,\n\t.synth_type\t= SYNTH_TYPE_FM,\n\t.synth_subtype\t= FM_TYPE_ADLIB,\n\t.open\t\t= opl3_open,\n\t.close\t\t= opl3_close,\n\t.ioctl\t\t= opl3_ioctl,\n\t.kill_note\t= opl3_kill_note,\n\t.start_note\t= opl3_start_note,\n\t.set_instr\t= opl3_set_instr,\n\t.reset\t\t= opl3_reset,\n\t.hw_control\t= opl3_hw_control,\n\t.load_patch\t= opl3_load_patch,\n\t.aftertouch\t= opl3_aftertouch,\n\t.controller\t= opl3_controller,\n\t.panning\t= opl3_panning,\n\t.volume_method\t= opl3_volume_method,\n\t.bender\t\t= opl3_bender,\n\t.alloc_voice\t= opl3_alloc_voice,\n\t.setup_voice\t= opl3_setup_voice\n};\n\nstatic int opl3_init(int ioaddr, struct module *owner)\n{\n\tint i;\n\tint me;\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Device control structure not initialized.\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((me = sound_alloc_synthdev()) == -1)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Too many synthesizers\\n\");\n\t\treturn -1;\n\t}\n\n\tdevc->nr_voice = 9;\n\n\tdevc->fm_info.device = 0;\n\tdevc->fm_info.synth_type = SYNTH_TYPE_FM;\n\tdevc->fm_info.synth_subtype = FM_TYPE_ADLIB;\n\tdevc->fm_info.perc_mode = 0;\n\tdevc->fm_info.nr_voices = 9;\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.instr_bank_size = SBFM_MAXINSTR;\n\tdevc->fm_info.capabilities = 0;\n\tdevc->left_io = ioaddr;\n\tdevc->right_io = ioaddr + 2;\n\n\tif (detected_model <= 2)\n\t\tdevc->model = 1;\n\telse\n\t{\n\t\tdevc->model = 2;\n\t\tif (detected_model == 4)\n\t\t\tdevc->is_opl4 = 1;\n\t}\n\n\topl3_operations.info = &devc->fm_info;\n\n\tsynth_devs[me] = &opl3_operations;\n\n\tif (owner)\n\t\tsynth_devs[me]->owner = owner;\n\t\n\tsequencer_init();\n\tdevc->v_alloc = &opl3_operations.alloc;\n\tdevc->chn_info = &opl3_operations.chn_info[0];\n\n\tif (devc->model == 2)\n\t{\n\t\tif (devc->is_opl4) \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL4/OPL3 FM\");\n\t\telse \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL3\");\n\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\t\tdevc->fm_info.nr_drums = 0;\n\t\tdevc->fm_info.synth_subtype = FM_TYPE_OPL3;\n\t\tdevc->fm_info.capabilities |= SYNTH_CAP_OPL3;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t{\n\t\t\tif (pv_map[i].ioaddr == USE_LEFT)\n\t\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t\t\telse\n\t\t\t\tpv_map[i].ioaddr = devc->right_io;\n\t\t}\n\t\topl3_command(devc->right_io, OPL3_MODE_REGISTER, OPL3_ENABLE);\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x00);\n\t}\n\telse\n\t{\n\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL2\");\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 9;\n\t\tdevc->fm_info.nr_drums = 0;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t};\n\tconf_printf2(devc->fm_info.name, ioaddr, 0, -1, -1);\n\n\tfor (i = 0; i < SBFM_MAXINSTR; i++)\n\t\tdevc->i_map[i].channel = -1;\n\n\treturn me;\n}\n\nstatic int me;\n\nstatic int io = -1;\n\nmodule_param(io, int, 0);\n\nstatic int __init init_opl3 (void)\n{\n\tprintk(KERN_INFO \"YM3812 and OPL-3 driver Copyright (C) by Hannu Savolainen, Rob Hooft 1993-1996\\n\");\n\n\tif (io != -1)\t/* User loading pure OPL3 module */\n\t{\n\t\tif (!opl3_detect(io))\n\t\t{\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tme = opl3_init(io, THIS_MODULE);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_opl3(void)\n{\n\tif (devc && io != -1)\n\t{\n\t\tif (devc->base) {\n\t\t\trelease_region(devc->base,4);\n\t\t\tif (devc->is_opl4)\n\t\t\t\trelease_region(devc->base - 8, 2);\n\t\t}\n\t\tkfree(devc);\n\t\tdevc = NULL;\n\t\tsound_unload_synthdev(me);\n\t}\n}\n\nmodule_init(init_opl3);\nmodule_exit(cleanup_opl3);\n\n#ifndef MODULE\nstatic int __init setup_opl3(char *str)\n{\n        /* io  */\n\tint ints[2];\n\t\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\t\n\tio = ints[1];\n\n\treturn 1;\n}\n\n__setup(\"opl3=\", setup_opl3);\n#endif\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * sound/oss/opl3.c\n *\n * A low level driver for Yamaha YM3812 and OPL-3 -chips\n *\n *\n * Copyright (C) by Hannu Savolainen 1993-1997\n *\n * OSS/Free for Linux is distributed under the GNU GENERAL PUBLIC LICENSE (GPL)\n * Version 2 (June 1991). See the \"COPYING\" file distributed with this software\n * for more info.\n *\n *\n * Changes\n *\tThomas Sailer   \tioctl code reworked (vmalloc/vfree removed)\n *\tAlan Cox\t\tmodularisation, fixed sound_mem allocs.\n *\tChristoph Hellwig\tAdapted to module_init/module_exit\n *\tArnaldo C. de Melo\tget rid of check_region, use request_region for\n *\t\t\t\tOPL4, release it on exit, some cleanups.\n *\n * Status\n *\tBelieved to work. Badly needs rewriting a bit to support multiple\n *\tOPL3 devices.\n */\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n\n/*\n * Major improvements to the FM handling 30AUG92 by Rob Hooft,\n * hooft@chem.ruu.nl\n */\n\n#include \"sound_config.h\"\n\n#include \"opl3_hw.h\"\n\n#define MAX_VOICE\t18\n#define OFFS_4OP\t11\n\nstruct voice_info\n{\n\tunsigned char   keyon_byte;\n\tlong            bender;\n\tlong            bender_range;\n\tunsigned long   orig_freq;\n\tunsigned long   current_freq;\n\tint             volume;\n\tint             mode;\n\tint             panning;\t/* 0xffff means not set */\n};\n\ntypedef struct opl_devinfo\n{\n\tint             base;\n\tint             left_io, right_io;\n\tint             nr_voice;\n\tint             lv_map[MAX_VOICE];\n\n\tstruct voice_info voc[MAX_VOICE];\n\tstruct voice_alloc_info *v_alloc;\n\tstruct channel_info *chn_info;\n\n\tstruct sbi_instrument i_map[SBFM_MAXINSTR];\n\tstruct sbi_instrument *act_i[MAX_VOICE];\n\n\tstruct synth_info fm_info;\n\n\tint             busy;\n\tint             model;\n\tunsigned char   cmask;\n\n\tint             is_opl4;\n} opl_devinfo;\n\nstatic struct opl_devinfo *devc = NULL;\n\nstatic int      detected_model;\n\nstatic int      store_instr(int instr_no, struct sbi_instrument *instr);\nstatic void     freq_to_fnum(int freq, int *block, int *fnum);\nstatic void     opl3_command(int io_addr, unsigned int addr, unsigned int val);\nstatic int      opl3_kill_note(int dev, int voice, int note, int velocity);\n\nstatic void enter_4op_mode(void)\n{\n\tint i;\n\tstatic int v4op[MAX_VOICE] = {\n\t\t0, 1, 2, 9, 10, 11, 6, 7, 8, 15, 16, 17\n\t};\n\n\tdevc->cmask = 0x3f;\t/* Connect all possible 4 OP voice operators */\n\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x3f);\n\n\tfor (i = 0; i < 3; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 3; i < 6; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 9; i < 12; i++)\n\t\tpv_map[i].voice_mode = 4;\n\tfor (i = 12; i < 15; i++)\n\t\tpv_map[i].voice_mode = 0;\n\n\tfor (i = 0; i < 12; i++)\n\t\tdevc->lv_map[i] = v4op[i];\n\tdevc->v_alloc->max_voice = devc->nr_voice = 12;\n}\n\nstatic int opl3_ioctl(int dev, unsigned int cmd, void __user * arg)\n{\n\tstruct sbi_instrument ins;\n\t\n\tswitch (cmd) {\n\t\tcase SNDCTL_FM_LOAD_INSTR:\n\t\t\tprintk(KERN_WARNING \"Warning: Obsolete ioctl(SNDCTL_FM_LOAD_INSTR) used. Fix the program.\\n\");\n\t\t\tif (copy_from_user(&ins, arg, sizeof(ins)))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR) {\n\t\t\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\treturn store_instr(ins.channel, &ins);\n\n\t\tcase SNDCTL_SYNTH_INFO:\n\t\t\tdevc->fm_info.nr_voices = (devc->nr_voice == 12) ? 6 : devc->nr_voice;\n\t\t\tif (copy_to_user(arg, &devc->fm_info, sizeof(devc->fm_info)))\n\t\t\t\treturn -EFAULT;\n\t\t\treturn 0;\n\n\t\tcase SNDCTL_SYNTH_MEMAVL:\n\t\t\treturn 0x7fffffff;\n\n\t\tcase SNDCTL_FM_4OP_ENABLE:\n\t\t\tif (devc->model == 2)\n\t\t\t\tenter_4op_mode();\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n}\n\nstatic int opl3_detect(int ioaddr)\n{\n\t/*\n\t * This function returns 1 if the FM chip is present at the given I/O port\n\t * The detection algorithm plays with the timer built in the FM chip and\n\t * looks for a change in the status register.\n\t *\n\t * Note! The timers of the FM chip are not connected to AdLib (and compatible)\n\t * boards.\n\t *\n\t * Note2! The chip is initialized if detected.\n\t */\n\n\tunsigned char stat1, signature;\n\tint i;\n\n\tif (devc != NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Only one OPL3 supported.\\n\");\n\t\treturn 0;\n\t}\n\n\tdevc = kzalloc(sizeof(*devc), GFP_KERNEL);\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Can't allocate memory for the device control \"\n\t\t\t\"structure \\n \");\n\t\treturn 0;\n\t}\n\n\tstrcpy(devc->fm_info.name, \"OPL2\");\n\n\tif (!request_region(ioaddr, 4, devc->fm_info.name)) {\n\t\tprintk(KERN_WARNING \"opl3: I/O port 0x%x already in use\\n\", ioaddr);\n\t\tgoto cleanup_devc;\n\t}\n\n\tdevc->base = ioaddr;\n\n\t/* Reset timers 1 and 2 */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, TIMER1_MASK | TIMER2_MASK);\n\n\t/* Reset the IRQ of the FM chip */\n\topl3_command(ioaddr, TIMER_CONTROL_REGISTER, IRQ_RESET);\n\n\tsignature = stat1 = inb(ioaddr);\t/* Status register */\n\n\tif (signature != 0x00 && signature != 0x06 && signature != 0x02 &&\n\t\tsignature != 0x0f)\n\t{\n\t\tMDB(printk(KERN_INFO \"OPL3 not detected %x\\n\", signature));\n\t\tgoto cleanup_region;\n\t}\n\n\tif (signature == 0x06)\t\t/* OPL2 */\n\t{\n\t\tdetected_model = 2;\n\t}\n\telse if (signature == 0x00 || signature == 0x0f)\t/* OPL3 or OPL4 */\n\t{\n\t\tunsigned char tmp;\n\n\t\tdetected_model = 3;\n\n\t\t/*\n\t\t * Detect availability of OPL4 (_experimental_). Works probably\n\t\t * only after a cold boot. In addition the OPL4 port\n\t\t * of the chip may not be connected to the PC bus at all.\n\t\t */\n\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0x00);\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, OPL3_ENABLE | OPL4_ENABLE);\n\n\t\tif ((tmp = inb(ioaddr)) == 0x02)\t/* Have a OPL4 */\n\t\t{\n\t\t\tdetected_model = 4;\n\t\t}\n\n\t\tif (request_region(ioaddr - 8, 2, \"OPL4\"))\t/* OPL4 port was free */\n\t\t{\n\t\t\tint tmp;\n\n\t\t\toutb((0x02), ioaddr - 8);\t/* Select OPL4 ID register */\n\t\t\tudelay(10);\n\t\t\ttmp = inb(ioaddr - 7);\t\t/* Read it */\n\t\t\tudelay(10);\n\n\t\t\tif (tmp == 0x20)\t/* OPL4 should return 0x20 here */\n\t\t\t{\n\t\t\t\tdetected_model = 4;\n\t\t\t\toutb((0xF8), ioaddr - 8);\t/* Select OPL4 FM mixer control */\n\t\t\t\tudelay(10);\n\t\t\t\toutb((0x1B), ioaddr - 7);\t/* Write value */\n\t\t\t\tudelay(10);\n\t\t\t}\n\t\t\telse\n\t\t\t{ /* release OPL4 port */\n\t\t\t\trelease_region(ioaddr - 8, 2);\n\t\t\t\tdetected_model = 3;\n\t\t\t}\n\t\t}\n\t\topl3_command(ioaddr + 2, OPL3_MODE_REGISTER, 0);\n\t}\n\tfor (i = 0; i < 9; i++)\n\t\topl3_command(ioaddr, KEYON_BLOCK + i, 0);\t/*\n\t\t\t\t\t\t\t\t * Note off\n\t\t\t\t\t\t\t\t */\n\n\topl3_command(ioaddr, TEST_REGISTER, ENABLE_WAVE_SELECT);\n\topl3_command(ioaddr, PERCOSSION_REGISTER, 0x00);\t/*\n\t\t\t\t\t\t\t\t * Melodic mode.\n\t\t\t\t\t\t\t\t */\n\treturn 1;\ncleanup_region:\n\trelease_region(ioaddr, 4);\ncleanup_devc:\n\tkfree(devc);\n\tdevc = NULL;\n\treturn 0;\n}\n\nstatic int opl3_kill_note  (int devno, int voice, int note, int velocity)\n{\n\t struct physical_voice_info *map;\n\n\t if (voice < 0 || voice >= devc->nr_voice)\n\t\t return 0;\n\n\t devc->v_alloc->map[voice] = 0;\n\n\t map = &pv_map[devc->lv_map[voice]];\n\t DEB(printk(\"Kill note %d\\n\", voice));\n\n\t if (map->voice_mode == 0)\n\t\t return 0;\n\n\t opl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, devc->voc[voice].keyon_byte & ~0x20);\n\t devc->voc[voice].keyon_byte = 0;\n\t devc->voc[voice].bender = 0;\n\t devc->voc[voice].volume = 64;\n\t devc->voc[voice].panning = 0xffff;\t/* Not set */\n\t devc->voc[voice].bender_range = 200;\n\t devc->voc[voice].orig_freq = 0;\n\t devc->voc[voice].current_freq = 0;\n\t devc->voc[voice].mode = 0;\n\t return 0;\n}\n\n#define HIHAT\t\t\t0\n#define CYMBAL\t\t\t1\n#define TOMTOM\t\t\t2\n#define SNARE\t\t\t3\n#define BDRUM\t\t\t4\n#define UNDEFINED\t\tTOMTOM\n#define DEFAULT\t\t\tTOMTOM\n\nstatic int store_instr(int instr_no, struct sbi_instrument *instr)\n{\n\tif (instr->key != FM_PATCH && (instr->key != OPL3_PATCH || devc->model != 2))\n\t\tprintk(KERN_WARNING \"FM warning: Invalid patch format field (key) 0x%x\\n\", instr->key);\n\tmemcpy((char *) &(devc->i_map[instr_no]), (char *) instr, sizeof(*instr));\n\treturn 0;\n}\n\nstatic int opl3_set_instr  (int dev, int voice, int instr_no)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\tif (instr_no < 0 || instr_no >= SBFM_MAXINSTR)\n\t\tinstr_no = 0;\t/* Acoustic piano (usually) */\n\n\tdevc->act_i[voice] = &devc->i_map[instr_no];\n\treturn 0;\n}\n\n/*\n * The next table looks magical, but it certainly is not. Its values have\n * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception\n * for i=0. This log-table converts a linear volume-scaling (0..127) to a\n * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume\n * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative\n * volume -8 it was implemented as a table because it is only 128 bytes and\n * it saves a lot of log() calculations. (RH)\n */\n\nstatic char fm_volume_table[128] =\n{\n\t-64, -48, -40, -35, -32, -29, -27, -26,\n\t-24, -23, -21, -20, -19, -18, -18, -17,\n\t-16, -15, -15, -14, -13, -13, -12, -12,\n\t-11, -11, -10, -10, -10, -9, -9, -8,\n\t-8, -8, -7, -7, -7, -6, -6, -6,\n\t-5, -5, -5, -5, -4, -4, -4, -4,\n\t-3, -3, -3, -3, -2, -2, -2, -2,\n\t-2, -1, -1, -1, -1, 0, 0, 0,\n\t0, 0, 0, 1, 1, 1, 1, 1,\n\t1, 2, 2, 2, 2, 2, 2, 2,\n\t3, 3, 3, 3, 3, 3, 3, 4,\n\t4, 4, 4, 4, 4, 4, 4, 5,\n\t5, 5, 5, 5, 5, 5, 5, 5,\n\t6, 6, 6, 6, 6, 6, 6, 6,\n\t6, 7, 7, 7, 7, 7, 7, 7,\n\t7, 7, 7, 8, 8, 8, 8, 8\n};\n\nstatic void calc_vol(unsigned char *regbyte, int volume, int main_vol)\n{\n\tint level = (~*regbyte & 0x3f);\n\n\tif (main_vol > 127)\n\t\tmain_vol = 127;\n\tvolume = (volume * main_vol) / 127;\n\n\tif (level)\n\t\tlevel += fm_volume_table[volume];\n\n\tif (level > 0x3f)\n\t\tlevel = 0x3f;\n\tif (level < 0)\n\t\tlevel = 0;\n\n\t*regbyte = (*regbyte & 0xc0) | (~level & 0x3f);\n}\n\nstatic void set_voice_volume(int voice, int volume, int main_vol)\n{\n\tunsigned char vol1, vol2, vol3, vol4;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 0)\n\t\treturn;\n\n\tif (devc->voc[voice].mode == 2)\n\t{\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tif ((instr->operators[10] & 0x01))\n\t\t{\n\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t}\n\telse\n\t{\t/*\n\t\t * 4 OP voice\n\t\t */\n\t\tint connection;\n\n\t\tvol1 = instr->operators[2];\n\t\tvol2 = instr->operators[3];\n\t\tvol3 = instr->operators[OFFS_4OP + 2];\n\t\tvol4 = instr->operators[OFFS_4OP + 3];\n\n\t\t/*\n\t\t * The connection method for 4 OP devc->voc is defined by the rightmost\n\t\t * bits at the offsets 10 and 10+OFFS_4OP\n\t\t */\n\n\t\tconnection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tcalc_vol(&vol2, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tcalc_vol(&vol1, volume, main_vol);\n\t\t\t\tcalc_vol(&vol3, volume, main_vol);\n\t\t\t\tcalc_vol(&vol4, volume, main_vol);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t;\n\t\t}\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], vol1);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], vol2);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], vol3);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], vol4);\n\t}\n}\n\nstatic int opl3_start_note (int dev, int voice, int note, int volume)\n{\n\tunsigned char data, fpc;\n\tint block, fnum, freq, voice_mode, pan;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn 0;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\tpan = devc->voc[voice].panning;\n\n\tif (map->voice_mode == 0)\n\t\treturn 0;\n\n\tif (note == 255)\t/*\n\t\t\t\t * Just change the volume\n\t\t\t\t */\n\t{\n\t\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Kill previous note before playing\n\t */\n\t\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[1], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Carrier\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t * min\n\t\t\t\t\t\t\t\t\t */\n\topl3_command(map->ioaddr, KSL_LEVEL + map->op[0], 0xff);\t/*\n\t\t\t\t\t\t\t\t\t * Modulator\n\t\t\t\t\t\t\t\t\t * volume to\n\t\t\t\t\t\t\t\t\t */\n\n\tif (map->voice_mode == 4)\n\t{\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[2], 0xff);\n\t\topl3_command(map->ioaddr, KSL_LEVEL + map->op[3], 0xff);\n\t}\n\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, 0x00);\t/*\n\t\t\t\t\t\t\t\t\t * Note\n\t\t\t\t\t\t\t\t\t * off\n\t\t\t\t\t\t\t\t\t */\n\n\tinstr = devc->act_i[voice];\n\t\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (instr->channel < 0)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Initializing voice %d with undefined instrument\\n\", voice);\n\t\treturn 0;\n\t}\n\n\tif (map->voice_mode == 2 && instr->key == OPL3_PATCH)\n\t\treturn 0;\t/*\n\t\t\t\t * Cannot play\n\t\t\t\t */\n\n\tvoice_mode = map->voice_mode;\n\n\tif (voice_mode == 4)\n\t{\n\t\tint voice_shift;\n\n\t\tvoice_shift = (map->ioaddr == devc->left_io) ? 0 : 3;\n\t\tvoice_shift += map->voice_num;\n\n\t\tif (instr->key != OPL3_PATCH)\t/*\n\t\t\t\t\t\t * Just 2 OP patch\n\t\t\t\t\t\t */\n\t\t{\n\t\t\tvoice_mode = 2;\n\t\t\tdevc->cmask &= ~(1 << voice_shift);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdevc->cmask |= (1 << voice_shift);\n\t\t}\n\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\t}\n\n\t/*\n\t * Set Sound Characteristics\n\t */\n\t\n\topl3_command(map->ioaddr, AM_VIB + map->op[0], instr->operators[0]);\n\topl3_command(map->ioaddr, AM_VIB + map->op[1], instr->operators[1]);\n\n\t/*\n\t * Set Attack/Decay\n\t */\n\t\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[0], instr->operators[4]);\n\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[1], instr->operators[5]);\n\n\t/*\n\t * Set Sustain/Release\n\t */\n\t\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[0], instr->operators[6]);\n\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[1], instr->operators[7]);\n\n\t/*\n\t * Set Wave Select\n\t */\n\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[0], instr->operators[8]);\n\topl3_command(map->ioaddr, WAVE_SELECT + map->op[1], instr->operators[9]);\n\n\t/*\n\t * Set Feedback/Connection\n\t */\n\t\n\tfpc = instr->operators[10];\n\n\tif (pan != 0xffff)\n\t{\n\t\tfpc &= ~STEREO_BITS;\n\t\tif (pan < -64)\n\t\t\tfpc |= VOICE_TO_LEFT;\n\t\telse\n\t\t\tif (pan > 64)\n\t\t\t\tfpc |= VOICE_TO_RIGHT;\n\t\t\telse\n\t\t\t\tfpc |= (VOICE_TO_LEFT | VOICE_TO_RIGHT);\n\t}\n\n\tif (!(fpc & 0x30))\n\t\tfpc |= 0x30;\t/*\n\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t */\n\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num, fpc);\n\n\t/*\n\t * If the voice is a 4 OP one, initialize the operators 3 and 4 also\n\t */\n\n\tif (voice_mode == 4)\n\t{\n\t\t/*\n\t\t * Set Sound Characteristics\n\t\t */\n\t\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[2], instr->operators[OFFS_4OP + 0]);\n\t\topl3_command(map->ioaddr, AM_VIB + map->op[3], instr->operators[OFFS_4OP + 1]);\n\n\t\t/*\n\t\t * Set Attack/Decay\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[2], instr->operators[OFFS_4OP + 4]);\n\t\topl3_command(map->ioaddr, ATTACK_DECAY + map->op[3], instr->operators[OFFS_4OP + 5]);\n\n\t\t/*\n\t\t * Set Sustain/Release\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[2], instr->operators[OFFS_4OP + 6]);\n\t\topl3_command(map->ioaddr, SUSTAIN_RELEASE + map->op[3], instr->operators[OFFS_4OP + 7]);\n\n\t\t/*\n\t\t * Set Wave Select\n\t\t */\n\t\t\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[2], instr->operators[OFFS_4OP + 8]);\n\t\topl3_command(map->ioaddr, WAVE_SELECT + map->op[3], instr->operators[OFFS_4OP + 9]);\n\n\t\t/*\n\t\t * Set Feedback/Connection\n\t\t */\n\t\t\n\t\tfpc = instr->operators[OFFS_4OP + 10];\n\t\tif (!(fpc & 0x30))\n\t\t\t fpc |= 0x30;\t/*\n\t\t\t\t\t * Ensure that at least one chn is enabled\n\t\t\t\t\t */\n\t\topl3_command(map->ioaddr, FEEDBACK_CONNECTION + map->voice_num + 3, fpc);\n\t}\n\n\tdevc->voc[voice].mode = voice_mode;\n\tset_voice_volume(voice, volume, devc->voc[voice].volume);\n\n\tfreq = devc->voc[voice].orig_freq = note_to_freq(note) / 1000;\n\n\t/*\n\t * Since the pitch bender may have been set before playing the note, we\n\t * have to calculate the bending now.\n\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\t/*\n\t * Play note\n\t */\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\t\t devc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n\tif (voice_mode == 4)\n\t\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num + 3, data);\n\n\treturn 0;\n}\n\nstatic void freq_to_fnum    (int freq, int *block, int *fnum)\n{\n\tint f, octave;\n\n\t/*\n\t * Converts the note frequency to block and fnum values for the FM chip\n\t */\n\t/*\n\t * First try to compute the block -value (octave) where the note belongs\n\t */\n\n\tf = freq;\n\n\toctave = 5;\n\n\tif (f == 0)\n\t\toctave = 0;\n\telse if (f < 261)\n\t{\n\t\twhile (f < 261)\n\t\t{\n\t\t\toctave--;\n\t\t\tf <<= 1;\n\t\t}\n\t}\n\telse if (f > 493)\n\t{\n\t\twhile (f > 493)\n\t\t{\n\t\t\t octave++;\n\t\t\t f >>= 1;\n\t\t}\n\t}\n\n\tif (octave > 7)\n\t\toctave = 7;\n\n\t*fnum = freq * (1 << (20 - octave)) / 49716;\n\t*block = octave;\n}\n\nstatic void opl3_command    (int io_addr, unsigned int addr, unsigned int val)\n{\n\t int i;\n\n\t/*\n\t * The original 2-OP synth requires a quite long delay after writing to a\n\t * register. The OPL-3 survives with just two INBs\n\t */\n\n\toutb(((unsigned char) (addr & 0xff)), io_addr);\n\n\tif (devc->model != 2)\n\t\tudelay(10);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n\n\toutb(((unsigned char) (val & 0xff)), io_addr + 1);\n\n\tif (devc->model != 2)\n\t\tudelay(30);\n\telse\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tinb(io_addr);\n}\n\nstatic void opl3_reset(int devno)\n{\n\tint i;\n\n\tfor (i = 0; i < 18; i++)\n\t\tdevc->lv_map[i] = i;\n\n\tfor (i = 0; i < devc->nr_voice; i++)\n\t{\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[0], 0xff);\n\n\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[1], 0xff);\n\n\t\tif (pv_map[devc->lv_map[i]].voice_mode == 4)\n\t\t{\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[2], 0xff);\n\n\t\t\topl3_command(pv_map[devc->lv_map[i]].ioaddr,\n\t\t\t\tKSL_LEVEL + pv_map[devc->lv_map[i]].op[3], 0xff);\n\t\t}\n\n\t\topl3_kill_note(devno, i, 0, 64);\n\t}\n\n\tif (devc->model == 2)\n\t{\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].voice_mode = 2;\n\n\t}\n}\n\nstatic int opl3_open(int dev, int mode)\n{\n\tint i;\n\n\tif (devc->busy)\n\t\treturn -EBUSY;\n\tdevc->busy = 1;\n\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\tdevc->v_alloc->timestamp = 0;\n\n\tfor (i = 0; i < 18; i++)\n\t{\n\t\tdevc->v_alloc->map[i] = 0;\n\t\tdevc->v_alloc->alloc_times[i] = 0;\n\t}\n\n\tdevc->cmask = 0x00;\t/*\n\t\t\t\t * Just 2 OP mode\n\t\t\t\t */\n\tif (devc->model == 2)\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, devc->cmask);\n\treturn 0;\n}\n\nstatic void opl3_close(int dev)\n{\n\tdevc->busy = 0;\n\tdevc->v_alloc->max_voice = devc->nr_voice = (devc->model == 2) ? 18 : 9;\n\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.perc_mode = 0;\n\n\topl3_reset(dev);\n}\n\nstatic void opl3_hw_control(int dev, unsigned char *event)\n{\n}\n\nstatic int opl3_load_patch(int dev, int format, const char __user *addr,\n\t\tint count, int pmgr_flag)\n{\n\tstruct sbi_instrument ins;\n\n\tif (count <sizeof(ins))\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Patch record too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&ins, addr, sizeof(ins)))\n\t\treturn -EFAULT;\n\n\tif (ins.channel < 0 || ins.channel >= SBFM_MAXINSTR)\n\t{\n\t\tprintk(KERN_WARNING \"FM Error: Invalid instrument number %d\\n\", ins.channel);\n\t\treturn -EINVAL;\n\t}\n\tins.key = format;\n\n\treturn store_instr(ins.channel, &ins);\n}\n\nstatic void opl3_panning(int dev, int voice, int value)\n{\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tdevc->voc[voice].panning = value;\n}\n\nstatic void opl3_volume_method(int dev, int mode)\n{\n}\n\n#define SET_VIBRATO(cell) { \\\n\ttmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \\\n\tif (pressure > 110) \\\n\t\ttmp |= 0x40;\t\t/* Vibrato on */ \\\n\topl3_command (map->ioaddr, AM_VIB + map->op[cell-1], tmp);}\n\nstatic void opl3_aftertouch(int dev, int voice, int pressure)\n{\n\tint tmp;\n\tstruct sbi_instrument *instr;\n\tstruct physical_voice_info *map;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tDEB(printk(\"Aftertouch %d\\n\", voice));\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\t/*\n\t * Adjust the amount of vibrato depending the pressure\n\t */\n\n\tinstr = devc->act_i[voice];\n\n\tif (!instr)\n\t\tinstr = &devc->i_map[0];\n\n\tif (devc->voc[voice].mode == 4)\n\t{\n\t\tint connection = ((instr->operators[10] & 0x01) << 1) | (instr->operators[10 + OFFS_4OP] & 0x01);\n\n\t\tswitch (connection)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\tSET_VIBRATO(2);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\tSET_VIBRATO(1);\n\t\t\t\tSET_VIBRATO(3);\n\t\t\t\tSET_VIBRATO(4);\n\t\t\t\tbreak;\n\n\t\t}\n\t\t/*\n\t\t * Not implemented yet\n\t\t */\n\t}\n\telse\n\t{\n\t\tSET_VIBRATO(1);\n\n\t\tif ((instr->operators[10] & 0x01))\t/*\n\t\t\t\t\t\t\t * Additive synthesis\n\t\t\t\t\t\t\t */\n\t\t\tSET_VIBRATO(2);\n\t}\n}\n\n#undef SET_VIBRATO\n\nstatic void bend_pitch(int dev, int voice, int value)\n{\n\tunsigned char data;\n\tint block, fnum, freq;\n\tstruct physical_voice_info *map;\n\n\tmap = &pv_map[devc->lv_map[voice]];\n\n\tif (map->voice_mode == 0)\n\t\treturn;\n\n\tdevc->voc[voice].bender = value;\n\tif (!value)\n\t\treturn;\n\tif (!(devc->voc[voice].keyon_byte & 0x20))\n\t\treturn;\t/*\n\t\t\t * Not keyed on\n\t\t\t */\n\n\tfreq = compute_finetune(devc->voc[voice].orig_freq, devc->voc[voice].bender, devc->voc[voice].bender_range, 0);\n\tdevc->voc[voice].current_freq = freq;\n\n\tfreq_to_fnum(freq, &block, &fnum);\n\n\tdata = fnum & 0xff;\t/*\n\t\t\t\t * Least significant bits of fnumber\n\t\t\t\t */\n\topl3_command(map->ioaddr, FNUM_LOW + map->voice_num, data);\n\n\tdata = 0x20 | ((block & 0x7) << 2) | ((fnum >> 8) & 0x3);\n\tdevc->voc[voice].keyon_byte = data;\n\topl3_command(map->ioaddr, KEYON_BLOCK + map->voice_num, data);\n}\n\nstatic void opl3_controller (int dev, int voice, int ctrl_num, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tswitch (ctrl_num)\n\t{\n\t\tcase CTRL_PITCH_BENDER:\n\t\t\tbend_pitch(dev, voice, value);\n\t\t\tbreak;\n\n\t\tcase CTRL_PITCH_BENDER_RANGE:\n\t\t\tdevc->voc[voice].bender_range = value;\n\t\t\tbreak;\n\n\t\tcase CTL_MAIN_VOLUME:\n\t\t\tdevc->voc[voice].volume = value / 128;\n\t\t\tbreak;\n\n\t\tcase CTL_PAN:\n\t\t\tdevc->voc[voice].panning = (value * 2) - 128;\n\t\t\tbreak;\n\t}\n}\n\nstatic void opl3_bender(int dev, int voice, int value)\n{\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tbend_pitch(dev, voice, value - 8192);\n}\n\nstatic int opl3_alloc_voice(int dev, int chn, int note, struct voice_alloc_info *alloc)\n{\n\tint i, p, best, first, avail, best_time = 0x7fffffff;\n\tstruct sbi_instrument *instr;\n\tint is4op;\n\tint instr_no;\n\n\tif (chn < 0 || chn > 15)\n\t\tinstr_no = 0;\n\telse\n\t\tinstr_no = devc->chn_info[chn].pgm_num;\n\n\tinstr = &devc->i_map[instr_no];\n\tif (instr->channel < 0 ||\t/* Instrument not loaded */\n\t\tdevc->nr_voice != 12)\t/* Not in 4 OP mode */\n\t\tis4op = 0;\n\telse if (devc->nr_voice == 12)\t/* 4 OP mode */\n\t\tis4op = (instr->key == OPL3_PATCH);\n\telse\n\t\tis4op = 0;\n\n\tif (is4op)\n\t{\n\t\tfirst = p = 0;\n\t\tavail = 6;\n\t}\n\telse\n\t{\n\t\tif (devc->nr_voice == 12)\t/* 4 OP mode. Use the '2 OP only' operators first */\n\t\t\tfirst = p = 6;\n\t\telse\n\t\t\tfirst = p = 0;\n\t\tavail = devc->nr_voice;\n\t}\n\n\t/*\n\t *    Now try to find a free voice\n\t */\n\tbest = first;\n\n\tfor (i = 0; i < avail; i++)\n\t{\n\t\tif (alloc->map[p] == 0)\n\t\t{\n\t\t\treturn p;\n\t\t}\n\t\tif (alloc->alloc_times[p] < best_time)\t\t/* Find oldest playing note */\n\t\t{\n\t\t\tbest_time = alloc->alloc_times[p];\n\t\t\tbest = p;\n\t\t}\n\t\tp = (p + 1) % avail;\n\t}\n\n\t/*\n\t *    Insert some kind of priority mechanism here.\n\t */\n\n\tif (best < 0)\n\t\tbest = 0;\n\tif (best > devc->nr_voice)\n\t\tbest -= devc->nr_voice;\n\n\treturn best;\t/* All devc->voc in use. Select the first one. */\n}\n\nstatic void opl3_setup_voice(int dev, int voice, int chn)\n{\n\tstruct channel_info *info;\n\n\tif (voice < 0 || voice >= devc->nr_voice)\n\t\treturn;\n\n\tif (chn < 0 || chn > 15)\n\t\treturn;\n\n\tinfo = &synth_devs[dev]->chn_info[chn];\n\n\topl3_set_instr(dev, voice, info->pgm_num);\n\n\tdevc->voc[voice].bender = 0;\n\tdevc->voc[voice].bender_range = info->bender_range;\n\tdevc->voc[voice].volume = info->controllers[CTL_MAIN_VOLUME];\n\tdevc->voc[voice].panning = (info->controllers[CTL_PAN] * 2) - 128;\n}\n\nstatic struct synth_operations opl3_operations =\n{\n\t.owner\t\t= THIS_MODULE,\n\t.id\t\t= \"OPL\",\n\t.info\t\t= NULL,\n\t.midi_dev\t= 0,\n\t.synth_type\t= SYNTH_TYPE_FM,\n\t.synth_subtype\t= FM_TYPE_ADLIB,\n\t.open\t\t= opl3_open,\n\t.close\t\t= opl3_close,\n\t.ioctl\t\t= opl3_ioctl,\n\t.kill_note\t= opl3_kill_note,\n\t.start_note\t= opl3_start_note,\n\t.set_instr\t= opl3_set_instr,\n\t.reset\t\t= opl3_reset,\n\t.hw_control\t= opl3_hw_control,\n\t.load_patch\t= opl3_load_patch,\n\t.aftertouch\t= opl3_aftertouch,\n\t.controller\t= opl3_controller,\n\t.panning\t= opl3_panning,\n\t.volume_method\t= opl3_volume_method,\n\t.bender\t\t= opl3_bender,\n\t.alloc_voice\t= opl3_alloc_voice,\n\t.setup_voice\t= opl3_setup_voice\n};\n\nstatic int opl3_init(int ioaddr, struct module *owner)\n{\n\tint i;\n\tint me;\n\n\tif (devc == NULL)\n\t{\n\t\tprintk(KERN_ERR \"opl3: Device control structure not initialized.\\n\");\n\t\treturn -1;\n\t}\n\n\tif ((me = sound_alloc_synthdev()) == -1)\n\t{\n\t\tprintk(KERN_WARNING \"opl3: Too many synthesizers\\n\");\n\t\treturn -1;\n\t}\n\n\tdevc->nr_voice = 9;\n\n\tdevc->fm_info.device = 0;\n\tdevc->fm_info.synth_type = SYNTH_TYPE_FM;\n\tdevc->fm_info.synth_subtype = FM_TYPE_ADLIB;\n\tdevc->fm_info.perc_mode = 0;\n\tdevc->fm_info.nr_voices = 9;\n\tdevc->fm_info.nr_drums = 0;\n\tdevc->fm_info.instr_bank_size = SBFM_MAXINSTR;\n\tdevc->fm_info.capabilities = 0;\n\tdevc->left_io = ioaddr;\n\tdevc->right_io = ioaddr + 2;\n\n\tif (detected_model <= 2)\n\t\tdevc->model = 1;\n\telse\n\t{\n\t\tdevc->model = 2;\n\t\tif (detected_model == 4)\n\t\t\tdevc->is_opl4 = 1;\n\t}\n\n\topl3_operations.info = &devc->fm_info;\n\n\tsynth_devs[me] = &opl3_operations;\n\n\tif (owner)\n\t\tsynth_devs[me]->owner = owner;\n\t\n\tsequencer_init();\n\tdevc->v_alloc = &opl3_operations.alloc;\n\tdevc->chn_info = &opl3_operations.chn_info[0];\n\n\tif (devc->model == 2)\n\t{\n\t\tif (devc->is_opl4) \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL4/OPL3 FM\");\n\t\telse \n\t\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL3\");\n\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 18;\n\t\tdevc->fm_info.nr_drums = 0;\n\t\tdevc->fm_info.synth_subtype = FM_TYPE_OPL3;\n\t\tdevc->fm_info.capabilities |= SYNTH_CAP_OPL3;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t{\n\t\t\tif (pv_map[i].ioaddr == USE_LEFT)\n\t\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t\t\telse\n\t\t\t\tpv_map[i].ioaddr = devc->right_io;\n\t\t}\n\t\topl3_command(devc->right_io, OPL3_MODE_REGISTER, OPL3_ENABLE);\n\t\topl3_command(devc->right_io, CONNECTION_SELECT_REGISTER, 0x00);\n\t}\n\telse\n\t{\n\t\tstrcpy(devc->fm_info.name, \"Yamaha OPL2\");\n\t\tdevc->v_alloc->max_voice = devc->nr_voice = 9;\n\t\tdevc->fm_info.nr_drums = 0;\n\n\t\tfor (i = 0; i < 18; i++)\n\t\t\tpv_map[i].ioaddr = devc->left_io;\n\t};\n\tconf_printf2(devc->fm_info.name, ioaddr, 0, -1, -1);\n\n\tfor (i = 0; i < SBFM_MAXINSTR; i++)\n\t\tdevc->i_map[i].channel = -1;\n\n\treturn me;\n}\n\nstatic int me;\n\nstatic int io = -1;\n\nmodule_param(io, int, 0);\n\nstatic int __init init_opl3 (void)\n{\n\tprintk(KERN_INFO \"YM3812 and OPL-3 driver Copyright (C) by Hannu Savolainen, Rob Hooft 1993-1996\\n\");\n\n\tif (io != -1)\t/* User loading pure OPL3 module */\n\t{\n\t\tif (!opl3_detect(io))\n\t\t{\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tme = opl3_init(io, THIS_MODULE);\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cleanup_opl3(void)\n{\n\tif (devc && io != -1)\n\t{\n\t\tif (devc->base) {\n\t\t\trelease_region(devc->base,4);\n\t\t\tif (devc->is_opl4)\n\t\t\t\trelease_region(devc->base - 8, 2);\n\t\t}\n\t\tkfree(devc);\n\t\tdevc = NULL;\n\t\tsound_unload_synthdev(me);\n\t}\n}\n\nmodule_init(init_opl3);\nmodule_exit(cleanup_opl3);\n\n#ifndef MODULE\nstatic int __init setup_opl3(char *str)\n{\n        /* io  */\n\tint ints[2];\n\t\n\tstr = get_options(str, ARRAY_SIZE(ints), ints);\n\t\n\tio = ints[1];\n\n\treturn 1;\n}\n\n__setup(\"opl3=\", setup_opl3);\n#endif\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["sound/oss/opl3.c"], "buggy_code_start_loc": [847], "buggy_code_end_loc": [1067], "fixing_code_start_loc": [848], "fixing_code_end_loc": [1078], "type": "CWE-119", "message": "Multiple array index errors in sound/oss/opl3.c in the Linux kernel before 2.6.39 allow local users to cause a denial of service (heap memory corruption) or possibly gain privileges by leveraging write access to /dev/sequencer.", "other": {"cve": {"id": "CVE-2011-1477", "sourceIdentifier": "secalert@redhat.com", "published": "2012-06-21T23:55:02.240", "lastModified": "2023-02-13T01:19:10.960", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Multiple array index errors in sound/oss/opl3.c in the Linux kernel before 2.6.39 allow local users to cause a denial of service (heap memory corruption) or possibly gain privileges by leveraging write access to /dev/sequencer."}, {"lang": "es", "value": "M\u00faltiples errores de \u00edndice de matriz en sound/oss/opl3.c en versiones del kernel de Linux anteriores a v2.6.39 permiten a usuarios locales provocar una denegaci\u00f3n de servicio (corrupci\u00f3n de memoria din\u00e1mica) o posiblemente obtener privilegios mediante el aprovechamiento del acceso de escritura a /dev/sequencer."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.6.38.8", "matchCriteriaId": "57A0A2B0-3B9F-40C2-8C7A-CD9590B51315"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:suse:linux_enterprise_desktop:10:sp4:*:*:lts:*:*:*", "matchCriteriaId": "B307E9E6-85D2-42C3-9638-75E3499DEEE4"}]}]}], "references": [{"url": "http://ftp.osuosl.org/pub/linux/kernel/v2.6/ChangeLog-2.6.39", "source": "secalert@redhat.com", "tags": ["Broken Link"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=4d00135a680727f6c3be78f8befaac009030e4df", "source": "secalert@redhat.com"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/03/25/1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/4d00135a680727f6c3be78f8befaac009030e4df", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4d00135a680727f6c3be78f8befaac009030e4df"}}