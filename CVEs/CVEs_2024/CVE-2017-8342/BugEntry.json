{"buggy_code": ["# This file is part of Radicale Server - Calendar Server\n# Copyright \u00a9 2008 Nicolas Kandel\n# Copyright \u00a9 2008 Pascal Halter\n# Copyright \u00a9 2008-2016 Guillaume Ayoub\n#\n# This library is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Radicale.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nAuthentication management.\n\nDefault is htpasswd authentication.\n\nApache's htpasswd command (httpd.apache.org/docs/programs/htpasswd.html)\nmanages a file for storing user credentials. It can encrypt passwords using\ndifferent methods, e.g. BCRYPT, MD5-APR1 (a version of MD5 modified for\nApache), SHA1, or by using the system's CRYPT routine. The CRYPT and SHA1\nencryption methods implemented by htpasswd are considered as insecure. MD5-APR1\nprovides medium security as of 2015. Only BCRYPT can be considered secure by\ncurrent standards.\n\nMD5-APR1-encrypted credentials can be written by all versions of htpasswd (it\nis the default, in fact), whereas BCRYPT requires htpasswd 2.4.x or newer.\n\nThe `is_authenticated(user, password)` function provided by this module\nverifies the user-given credentials by parsing the htpasswd credential file\npointed to by the ``htpasswd_filename`` configuration value while assuming\nthe password encryption method specified via the ``htpasswd_encryption``\nconfiguration value.\n\nThe following htpasswd password encrpytion methods are supported by Radicale\nout-of-the-box:\n\n    - plain-text (created by htpasswd -p...) -- INSECURE\n    - CRYPT      (created by htpasswd -d...) -- INSECURE\n    - SHA1       (created by htpasswd -s...) -- INSECURE\n\nWhen passlib (https://pypi.python.org/pypi/passlib) is importable, the\nfollowing significantly more secure schemes are parsable by Radicale:\n\n    - MD5-APR1   (htpasswd -m...) -- htpasswd's default method\n    - BCRYPT     (htpasswd -B...) -- Requires htpasswd 2.4.x\n\n\"\"\"\n\nimport base64\nimport functools\nimport hashlib\nimport os\nfrom importlib import import_module\n\n\ndef load(configuration, logger):\n    \"\"\"Load the authentication manager chosen in configuration.\"\"\"\n    auth_type = configuration.get(\"auth\", \"type\")\n    logger.debug(\"Authentication type is %s\", auth_type)\n    if auth_type == \"None\":\n        class_ = NoneAuth\n    elif auth_type == \"htpasswd\":\n        class_ = Auth\n    else:\n        class_ = import_module(auth_type).Auth\n    return class_(configuration, logger)\n\n\nclass BaseAuth:\n    def __init__(self, configuration, logger):\n        self.configuration = configuration\n        self.logger = logger\n\n    def is_authenticated(self, user, password):\n        \"\"\"Validate credentials.\n\n        Iterate through htpasswd credential file until user matches, extract\n        hash (encrypted password) and check hash against user-given password,\n        using the method specified in the Radicale config.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def map_login_to_user(self, login):\n        \"\"\"Map login to internal username.\"\"\"\n        return login\n\n\nclass NoneAuth(BaseAuth):\n    def is_authenticated(self, user, password):\n        return True\n\n\nclass Auth(BaseAuth):\n    def __init__(self, configuration, logger):\n        super().__init__(configuration, logger)\n        self.filename = os.path.expanduser(\n            configuration.get(\"auth\", \"htpasswd_filename\"))\n        self.encryption = configuration.get(\"auth\", \"htpasswd_encryption\")\n\n        if self.encryption == \"ssha\":\n            self.verify = self._ssha\n        elif self.encryption == \"sha1\":\n            self.verify = self._sha1\n        elif self.encryption == \"plain\":\n            self.verify = self._plain\n        elif self.encryption == \"md5\":\n            try:\n                from passlib.hash import apr_md5_crypt\n            except ImportError:\n                raise RuntimeError(\n                    \"The htpasswd encryption method 'md5' requires \"\n                    \"the passlib module.\")\n            self.verify = functools.partial(self._md5apr1, apr_md5_crypt)\n        elif self.encryption == \"bcrypt\":\n            try:\n                from passlib.hash import bcrypt\n            except ImportError:\n                raise RuntimeError(\n                    \"The htpasswd encryption method 'bcrypt' requires \"\n                    \"the passlib module with bcrypt support.\")\n            # A call to `encrypt` raises passlib.exc.MissingBackendError with a\n            # good error message if bcrypt backend is not available. Trigger\n            # this here.\n            bcrypt.encrypt(\"test-bcrypt-backend\")\n            self.verify = functools.partial(self._bcrypt, bcrypt)\n        elif self.encryption == \"crypt\":\n            try:\n                import crypt\n            except ImportError:\n                raise RuntimeError(\n                    \"The htpasswd encryption method 'crypt' requires \"\n                    \"the crypt() system support.\")\n            self.verify = functools.partial(self._crypt, crypt)\n        else:\n            raise RuntimeError(\n                \"The htpasswd encryption method '%s' is not \"\n                \"supported.\" % self.encryption)\n\n    def _plain(self, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, plain method.\"\"\"\n        return hash_value == password\n\n    def _crypt(self, crypt, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, crypt method.\"\"\"\n        return crypt.crypt(password, hash_value) == hash_value\n\n    def _sha1(self, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, sha1 method.\"\"\"\n        hash_value = hash_value.replace(\"{SHA}\", \"\").encode(\"ascii\")\n        password = password.encode(self.configuration.get(\"encoding\", \"stock\"))\n        sha1 = hashlib.sha1()\n        sha1.update(password)\n        return sha1.digest() == base64.b64decode(hash_value)\n\n    def _ssha(self, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, salted sha1 method.\n\n        This method is not directly supported by htpasswd, but it can be\n        written with e.g. openssl, and nginx can parse it.\n\n        \"\"\"\n        hash_value = hash_value.replace(\n            \"{SSHA}\", \"\").encode(\"ascii\").decode(\"base64\")\n        password = password.encode(self.configuration.get(\"encoding\", \"stock\"))\n        hash_value = hash_value[:20]\n        salt_value = hash_value[20:]\n        sha1 = hashlib.sha1()\n        sha1.update(password)\n        sha1.update(salt_value)\n        return sha1.digest() == hash_value\n\n    def _bcrypt(self, bcrypt, hash_value, password):\n        return bcrypt.verify(password, hash_value)\n\n    def _md5apr1(self, md5_apr1, hash_value, password):\n        return md5_apr1.verify(password, hash_value)\n\n    def is_authenticated(self, user, password):\n        # The content of the file is not cached because reading is generally a\n        # very cheap operation, and it's useful to get live updates of the\n        # htpasswd file.\n        with open(self.filename) as fd:\n            for line in fd:\n                line = line.strip()\n                if line:\n                    login, hash_value = line.split(\":\")\n                    if login == user:\n                        return self.verify(hash_value, password)\n        return False\n"], "fixing_code": ["# This file is part of Radicale Server - Calendar Server\n# Copyright \u00a9 2008 Nicolas Kandel\n# Copyright \u00a9 2008 Pascal Halter\n# Copyright \u00a9 2008-2016 Guillaume Ayoub\n#\n# This library is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Radicale.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"\nAuthentication management.\n\nDefault is htpasswd authentication.\n\nApache's htpasswd command (httpd.apache.org/docs/programs/htpasswd.html)\nmanages a file for storing user credentials. It can encrypt passwords using\ndifferent methods, e.g. BCRYPT, MD5-APR1 (a version of MD5 modified for\nApache), SHA1, or by using the system's CRYPT routine. The CRYPT and SHA1\nencryption methods implemented by htpasswd are considered as insecure. MD5-APR1\nprovides medium security as of 2015. Only BCRYPT can be considered secure by\ncurrent standards.\n\nMD5-APR1-encrypted credentials can be written by all versions of htpasswd (it\nis the default, in fact), whereas BCRYPT requires htpasswd 2.4.x or newer.\n\nThe `is_authenticated(user, password)` function provided by this module\nverifies the user-given credentials by parsing the htpasswd credential file\npointed to by the ``htpasswd_filename`` configuration value while assuming\nthe password encryption method specified via the ``htpasswd_encryption``\nconfiguration value.\n\nThe following htpasswd password encrpytion methods are supported by Radicale\nout-of-the-box:\n\n    - plain-text (created by htpasswd -p...) -- INSECURE\n    - CRYPT      (created by htpasswd -d...) -- INSECURE\n    - SHA1       (created by htpasswd -s...) -- INSECURE\n\nWhen passlib (https://pypi.python.org/pypi/passlib) is importable, the\nfollowing significantly more secure schemes are parsable by Radicale:\n\n    - MD5-APR1   (htpasswd -m...) -- htpasswd's default method\n    - BCRYPT     (htpasswd -B...) -- Requires htpasswd 2.4.x\n\n\"\"\"\n\nimport base64\nimport functools\nimport hashlib\nimport os\nimport random\nimport time\nfrom importlib import import_module\n\n\ndef load(configuration, logger):\n    \"\"\"Load the authentication manager chosen in configuration.\"\"\"\n    auth_type = configuration.get(\"auth\", \"type\")\n    logger.debug(\"Authentication type is %s\", auth_type)\n    if auth_type == \"None\":\n        class_ = NoneAuth\n    elif auth_type == \"htpasswd\":\n        class_ = Auth\n    else:\n        class_ = import_module(auth_type).Auth\n    return class_(configuration, logger)\n\n\nclass BaseAuth:\n    def __init__(self, configuration, logger):\n        self.configuration = configuration\n        self.logger = logger\n\n    def is_authenticated(self, user, password):\n        \"\"\"Validate credentials.\n\n        Iterate through htpasswd credential file until user matches, extract\n        hash (encrypted password) and check hash against user-given password,\n        using the method specified in the Radicale config.\n\n        \"\"\"\n        raise NotImplementedError\n\n    def map_login_to_user(self, login):\n        \"\"\"Map login to internal username.\"\"\"\n        return login\n\n\nclass NoneAuth(BaseAuth):\n    def is_authenticated(self, user, password):\n        return True\n\n\nclass Auth(BaseAuth):\n    def __init__(self, configuration, logger):\n        super().__init__(configuration, logger)\n        self.filename = os.path.expanduser(\n            configuration.get(\"auth\", \"htpasswd_filename\"))\n        self.encryption = configuration.get(\"auth\", \"htpasswd_encryption\")\n\n        if self.encryption == \"ssha\":\n            self.verify = self._ssha\n        elif self.encryption == \"sha1\":\n            self.verify = self._sha1\n        elif self.encryption == \"plain\":\n            self.verify = self._plain\n        elif self.encryption == \"md5\":\n            try:\n                from passlib.hash import apr_md5_crypt\n            except ImportError:\n                raise RuntimeError(\n                    \"The htpasswd encryption method 'md5' requires \"\n                    \"the passlib module.\")\n            self.verify = functools.partial(self._md5apr1, apr_md5_crypt)\n        elif self.encryption == \"bcrypt\":\n            try:\n                from passlib.hash import bcrypt\n            except ImportError:\n                raise RuntimeError(\n                    \"The htpasswd encryption method 'bcrypt' requires \"\n                    \"the passlib module with bcrypt support.\")\n            # A call to `encrypt` raises passlib.exc.MissingBackendError with a\n            # good error message if bcrypt backend is not available. Trigger\n            # this here.\n            bcrypt.encrypt(\"test-bcrypt-backend\")\n            self.verify = functools.partial(self._bcrypt, bcrypt)\n        elif self.encryption == \"crypt\":\n            try:\n                import crypt\n            except ImportError:\n                raise RuntimeError(\n                    \"The htpasswd encryption method 'crypt' requires \"\n                    \"the crypt() system support.\")\n            self.verify = functools.partial(self._crypt, crypt)\n        else:\n            raise RuntimeError(\n                \"The htpasswd encryption method '%s' is not \"\n                \"supported.\" % self.encryption)\n\n    def _plain(self, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, plain method.\"\"\"\n        return hash_value == password\n\n    def _crypt(self, crypt, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, crypt method.\"\"\"\n        return crypt.crypt(password, hash_value) == hash_value\n\n    def _sha1(self, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, sha1 method.\"\"\"\n        hash_value = hash_value.replace(\"{SHA}\", \"\").encode(\"ascii\")\n        password = password.encode(self.configuration.get(\"encoding\", \"stock\"))\n        sha1 = hashlib.sha1()\n        sha1.update(password)\n        return sha1.digest() == base64.b64decode(hash_value)\n\n    def _ssha(self, hash_value, password):\n        \"\"\"Check if ``hash_value`` and ``password`` match, salted sha1 method.\n\n        This method is not directly supported by htpasswd, but it can be\n        written with e.g. openssl, and nginx can parse it.\n\n        \"\"\"\n        hash_value = hash_value.replace(\n            \"{SSHA}\", \"\").encode(\"ascii\").decode(\"base64\")\n        password = password.encode(self.configuration.get(\"encoding\", \"stock\"))\n        hash_value = hash_value[:20]\n        salt_value = hash_value[20:]\n        sha1 = hashlib.sha1()\n        sha1.update(password)\n        sha1.update(salt_value)\n        return sha1.digest() == hash_value\n\n    def _bcrypt(self, bcrypt, hash_value, password):\n        return bcrypt.verify(password, hash_value)\n\n    def _md5apr1(self, md5_apr1, hash_value, password):\n        return md5_apr1.verify(password, hash_value)\n\n    def is_authenticated(self, user, password):\n        # The content of the file is not cached because reading is generally a\n        # very cheap operation, and it's useful to get live updates of the\n        # htpasswd file.\n        with open(self.filename) as fd:\n            for line in fd:\n                line = line.strip()\n                if line:\n                    login, hash_value = line.split(\":\")\n                    if login == user and self.verify(hash_value, password):\n                        return True\n        # Random timer to avoid timing oracles and simple bruteforce attacks\n        time.sleep(1 + random.random())\n        return False\n"], "filenames": ["radicale/auth.py"], "buggy_code_start_loc": [59], "buggy_code_end_loc": [197], "fixing_code_start_loc": [60], "fixing_code_end_loc": [201], "type": "CWE-362", "message": "Radicale before 1.1.2 and 2.x before 2.0.0rc2 is prone to timing oracles and simple brute-force attacks when using the htpasswd authentication method.", "other": {"cve": {"id": "CVE-2017-8342", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-30T15:59:00.153", "lastModified": "2020-04-25T23:15:10.577", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Radicale before 1.1.2 and 2.x before 2.0.0rc2 is prone to timing oracles and simple brute-force attacks when using the htpasswd authentication method."}, {"lang": "es", "value": "Radicale anterior a 1.1.2 y 2.x anterior a 2.0.0rc2 es propenso a ataques basados en tiempo y ataques simples de fuerza bruta cuando se utiliza el m\u00e9todo de autenticaci\u00f3n htpasswd."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radicale:radicale:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.1", "matchCriteriaId": "8ECE0BB4-F1C0-4B17-9036-2A304CCF6739"}, {"vulnerable": true, "criteria": "cpe:2.3:a:radicale:radicale:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "16EAED4B-E061-4C6C-807B-8048E2AF0AB2"}]}]}], "references": [{"url": "https://bugs.debian.org/861514", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "VDB Entry"]}, {"url": "https://github.com/Kozea/Radicale/blob/1.1.2/NEWS.rst", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Kozea/Radicale/commit/059ba8dec1f22ccbeab837e288b3833a099cee2d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Kozea/Radicale/commit/190b1dd795f0c552a4992445a231da760211183b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/04/msg00019.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/Kozea/Radicale/commit/059ba8dec1f22ccbeab837e288b3833a099cee2d"}}