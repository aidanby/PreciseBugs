{"buggy_code": ["/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/crypto/Utils.h>\n#include <fizz/crypto/exchange/AsyncKeyExchange.h>\n#include <fizz/protocol/CertificateVerifier.h>\n#include <fizz/protocol/Protocol.h>\n#include <fizz/protocol/StateMachine.h>\n#include <fizz/protocol/ech/Decrypter.h>\n#include <fizz/record/Extensions.h>\n#include <fizz/record/PlaintextRecordLayer.h>\n#include <fizz/server/AsyncSelfCert.h>\n#include <fizz/server/Negotiator.h>\n#include <fizz/server/ReplayCache.h>\n#include <fizz/server/ServerProtocol.h>\n#include <fizz/util/Workarounds.h>\n#include <folly/Overload.h>\n#include <folly/tracing/StaticTracepoint.h>\n#include <algorithm>\n\nusing folly::Optional;\nusing folly::SemiFuture;\n\nusing namespace fizz::server;\nusing namespace fizz::server::detail;\n\n// We only ever use the first PSK sent.\nstatic constexpr uint16_t kPskIndex = 0;\n\nnamespace fizz {\nnamespace sm {\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::Uninitialized,\n    Event::Accept,\n    StateEnum::ExpectingClientHello);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingClientHello,\n    Event::ClientHello,\n    StateEnum::ExpectingClientHello,\n    StateEnum::ExpectingCertificate,\n    StateEnum::ExpectingFinished,\n    StateEnum::AcceptingEarlyData,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::AppData,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::AppWrite,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::EndOfEarlyData,\n    StateEnum::ExpectingFinished);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingCertificate,\n    Event::Certificate,\n    StateEnum::ExpectingCertificateVerify,\n    StateEnum::ExpectingFinished)\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingCertificateVerify,\n    Event::CertificateVerify,\n    StateEnum::ExpectingFinished);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingFinished,\n    Event::AppWrite,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingFinished,\n    Event::Finished,\n    StateEnum::AcceptingData);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::WriteNewSessionTicket,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::AppData,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::AppWrite,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::KeyUpdateInitiation,\n    StateEnum::AcceptingData);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::KeyUpdate,\n    StateEnum::AcceptingData);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::CloseNotify,\n    StateEnum::Closed);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingCloseNotify,\n    Event::CloseNotify,\n    StateEnum::Closed);\n} // namespace sm\n\nnamespace server {\n\nAsyncActions ServerStateMachine::processAccept(\n    const State& state,\n    folly::Executor* executor,\n    std::shared_ptr<const FizzServerContext> context,\n    const std::shared_ptr<ServerExtensions>& extensions) {\n  Accept accept;\n  accept.executor = executor;\n  accept.context = std::move(context);\n  accept.extensions = extensions;\n  return detail::processEvent(state, std::move(accept));\n}\n\nAsyncActions ServerStateMachine::processSocketData(\n    const State& state,\n    folly::IOBufQueue& buf,\n    Aead::AeadOptions options) {\n  try {\n    if (!state.readRecordLayer()) {\n      return detail::handleError(\n          state,\n          ReportError(\"attempting to process data without record layer\"),\n          folly::none);\n    }\n    auto param = state.readRecordLayer()->readEvent(buf, std::move(options));\n    if (!param.has_value()) {\n      return actions(WaitForData{param.sizeHint});\n    }\n    return detail::processEvent(state, std::move(*param));\n  } catch (const FizzException& e) {\n    return detail::handleError(\n        state,\n        ReportError(folly::exception_wrapper(std::current_exception())),\n        e.getAlert());\n  } catch (...) {\n    return detail::handleError(\n        state,\n        ReportError(folly::make_exception_wrapper<FizzException>(\n            folly::to<std::string>(\n                \"error decoding record in state \",\n                toString(state.state()),\n                \": \",\n                folly::exceptionStr(std::current_exception())),\n            AlertDescription::decode_error)),\n        AlertDescription::decode_error);\n  }\n}\n\nAsyncActions ServerStateMachine::processWriteNewSessionTicket(\n    const State& state,\n    WriteNewSessionTicket write) {\n  return detail::processEvent(state, std::move(write));\n}\n\nAsyncActions ServerStateMachine::processAppWrite(\n    const State& state,\n    AppWrite write) {\n  return detail::processEvent(state, std::move(write));\n}\n\nAsyncActions ServerStateMachine::processEarlyAppWrite(\n    const State& state,\n    EarlyAppWrite write) {\n  return detail::processEvent(state, std::move(write));\n}\n\nActions ServerStateMachine::processAppClose(const State& state) {\n  return detail::handleAppClose(state);\n}\n\nActions ServerStateMachine::processAppCloseImmediate(const State& state) {\n  return detail::handleAppCloseImmediate(state);\n}\n\nAsyncActions ServerStateMachine::processKeyUpdateInitiation(\n    const State& state,\n    KeyUpdateInitiation keyUpdateInitiation) {\n  return detail::processEvent(state, std::move(keyUpdateInitiation));\n}\n\nnamespace detail {\n\nAsyncActions processEvent(const State& state, Param param) {\n  auto event = EventVisitor()(param);\n  // We can have an exception directly in the handler or in a future so we need\n  // to handle both types.\n  try {\n    auto actions = sm::StateMachine<ServerTypes>::getHandler(\n        state.state(), event)(state, std::move(param));\n\n    return folly::variant_match(\n        actions,\n        ::fizz::detail::result_type<AsyncActions>(),\n        [&state](SemiFuture<Actions>& futureActions) -> AsyncActions {\n          if (futureActions.isReady()) {\n            // any exception thrown by get will be caught below\n            return std::move(futureActions).get();\n          }\n          return std::move(futureActions)\n              .deferError([&state](folly::exception_wrapper ew) {\n                auto ex = ew.get_exception<FizzException>();\n                if (ex) {\n                  return detail::handleError(\n                      state, ReportError(std::move(ew)), ex->getAlert());\n                }\n                return detail::handleError(\n                    state,\n                    ReportError(std::move(ew)),\n                    AlertDescription::unexpected_message);\n              });\n        },\n        [](Actions& immediateActions) -> AsyncActions {\n          return std::move(immediateActions);\n        });\n  } catch (const FizzException& e) {\n    return detail::handleError(\n        state,\n        ReportError(folly::exception_wrapper(std::current_exception())),\n        e.getAlert());\n  } catch (...) {\n    return detail::handleError(\n        state,\n        ReportError(folly::exception_wrapper(std::current_exception())),\n        AlertDescription::unexpected_message);\n  }\n}\n\nActions handleError(\n    const State& state,\n    ReportError error,\n    Optional<AlertDescription> alertDesc) {\n  if (state.state() == StateEnum::Error) {\n    return Actions();\n  }\n  MutateState transition([](State& newState) {\n    newState.state() = StateEnum::Error;\n    newState.writeRecordLayer() = nullptr;\n    newState.readRecordLayer() = nullptr;\n  });\n  if (alertDesc && state.writeRecordLayer()) {\n    Alert alert(*alertDesc);\n    WriteToSocket write;\n    write.contents.emplace_back(\n        state.writeRecordLayer()->writeAlert(std::move(alert)));\n    return actions(std::move(transition), std::move(write), std::move(error));\n  } else {\n    return actions(std::move(transition), std::move(error));\n  }\n}\n\nActions handleAppCloseImmediate(const State& state) {\n  MutateState transition([](State& newState) {\n    newState.state() = StateEnum::Closed;\n    newState.readRecordLayer() = nullptr;\n    newState.writeRecordLayer() = nullptr;\n  });\n\n  if (state.writeRecordLayer()) {\n    Alert alert(AlertDescription::close_notify);\n    WriteToSocket write;\n    write.contents.emplace_back(\n        state.writeRecordLayer()->writeAlert(std::move(alert)));\n    return actions(std::move(transition), std::move(write));\n  } else {\n    return actions(std::move(transition));\n  }\n}\n\nActions handleAppClose(const State& state) {\n  if (state.writeRecordLayer()) {\n    MutateState transition([](State& newState) {\n      newState.state() = StateEnum::ExpectingCloseNotify;\n      newState.writeRecordLayer() = nullptr;\n    });\n\n    Alert alert(AlertDescription::close_notify);\n    WriteToSocket write;\n    write.contents.emplace_back(\n        state.writeRecordLayer()->writeAlert(std::move(alert)));\n    return actions(std::move(transition), std::move(write));\n  } else {\n    MutateState transition([](State& newState) {\n      newState.state() = StateEnum::Closed;\n      newState.writeRecordLayer() = nullptr;\n      newState.readRecordLayer() = nullptr;\n    });\n    return actions(std::move(transition));\n  }\n}\n\nActions handleInvalidEvent(const State& state, Event event, Param param) {\n  if (event == Event::Alert) {\n    auto& alert = *param.asAlert();\n    throw FizzException(\n        folly::to<std::string>(\n            \"received alert: \",\n            toString(alert.description),\n            \", in state \",\n            toString(state.state())),\n        folly::none);\n  } else {\n    throw FizzException(\n        folly::to<std::string>(\n            \"invalid event: \",\n            toString(event),\n            \", in state \",\n            toString(state.state())),\n        AlertDescription::unexpected_message);\n  }\n}\n\ntemplate <typename T, typename F>\nSemiFuture<\n    typename folly::futures::detail::valueCallableResult<T, F>::value_type>\nrunOnCallerIfComplete(\n    folly::Executor* executor,\n    SemiFuture<T> future,\n    F&& func) {\n  if (future.isReady()) {\n    return func(std::move(future).get());\n  } else {\n    return std::move(future)\n        .via(executor)\n        .thenValueInline(std::forward<F>(func))\n        .semi();\n  }\n}\n\n} // namespace detail\n} // namespace server\n\nnamespace sm {\n\nstatic void ensureNoUnparsedHandshakeData(const State& state, Event event) {\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        folly::to<std::string>(\n            \"unprocessed handshake data while handling event \",\n            toString(event),\n            \" in state \",\n            toString(state.state())),\n        AlertDescription::unexpected_message);\n  }\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::Uninitialized, Event::Accept>::handle(\n    const State& /*state*/,\n    Param param) {\n  auto& accept = *param.asAccept();\n  auto factory = accept.context->getFactory();\n  auto readRecordLayer = factory->makePlaintextReadRecordLayer();\n  auto writeRecordLayer = factory->makePlaintextWriteRecordLayer();\n  auto handshakeLogging = std::make_unique<HandshakeLogging>();\n  return actions(\n      MutateState([executor = accept.executor,\n                   rrl = std::move(readRecordLayer),\n                   wrl = std::move(writeRecordLayer),\n                   context = std::move(accept.context),\n                   handshakeLogging = std::move(handshakeLogging),\n                   extensions = accept.extensions](State& newState) mutable {\n        newState.executor() = executor;\n        newState.context() = std::move(context);\n        newState.readRecordLayer() = std::move(rrl);\n        newState.writeRecordLayer() = std::move(wrl);\n        newState.handshakeLogging() = std::move(handshakeLogging);\n        newState.extensions() = std::move(extensions);\n      }),\n      MutateState(&Transition<StateEnum::ExpectingClientHello>));\n}\n\nstatic void addHandshakeLogging(const State& state, const ClientHello& chlo) {\n  auto logging = state.handshakeLogging();\n  if (!logging) {\n    return;\n  }\n  logging->populateFromClientHello(chlo);\n  auto plaintextReadRecord =\n      dynamic_cast<PlaintextReadRecordLayer*>(state.readRecordLayer());\n  if (plaintextReadRecord) {\n    logging->clientRecordVersion =\n        plaintextReadRecord->getReceivedRecordVersion();\n  }\n}\n\nstatic void validateClientHello(const ClientHello& chlo) {\n  if (chlo.legacy_compression_methods.size() != 1 ||\n      chlo.legacy_compression_methods.front() != 0x00) {\n    throw FizzException(\n        \"client compression methods not exactly NULL\",\n        AlertDescription::illegal_parameter);\n  }\n  Protocol::checkDuplicateExtensions(chlo.extensions);\n}\n\nstatic Optional<ProtocolVersion> negotiateVersion(\n    const ClientHello& chlo,\n    const std::vector<ProtocolVersion>& versions) {\n  const auto& clientVersions = getExtension<SupportedVersions>(chlo.extensions);\n  if (!clientVersions) {\n    return folly::none;\n  }\n  auto version = negotiate(versions, clientVersions->versions);\n  if (!version) {\n    return folly::none;\n  }\n  return version;\n}\n\nstatic Optional<CookieState> getCookieState(\n    const ClientHello& chlo,\n    const CookieCipher* cookieCipher) {\n  auto cookieExt = getExtension<Cookie>(chlo.extensions);\n  if (!cookieExt) {\n    return folly::none;\n  }\n\n  // If the client sent a cookie we can't use we have to consider it a fatal\n  // error since we can't reconstruct the handshake transcript.\n  if (!cookieCipher) {\n    throw FizzException(\n        \"no cookie cipher\", AlertDescription::unsupported_extension);\n  }\n\n  auto cookieState = cookieCipher->decrypt(std::move(cookieExt->cookie));\n\n  if (!cookieState) {\n    throw FizzException(\n        \"could not decrypt cookie\", AlertDescription::decrypt_error);\n  }\n\n  if (cookieState->echCipherSuite.has_value() ^\n      cookieState->echConfigId.has_value()) {\n    throw FizzException(\n        \"cookie has incomplete ech params\", AlertDescription::internal_error);\n  }\n\n  return cookieState;\n}\n\nstatic void verifyCookieState(\n    Optional<CookieState>& cookieState,\n    ProtocolVersion version,\n    CipherSuite cipher) {\n  if (!cookieState) {\n    return;\n  }\n  if (cookieState->version != version) {\n    throw FizzException(\n        \"version mismatch with cookie\", AlertDescription::protocol_version);\n  }\n\n  if (cookieState->cipher != cipher) {\n    throw FizzException(\n        \"cipher mismatch with cookie\", AlertDescription::handshake_failure);\n  }\n}\n\nnamespace {\nstruct ResumptionStateResult {\n  explicit ResumptionStateResult(\n      SemiFuture<std::pair<PskType, Optional<ResumptionState>>>\n          futureResStateArg,\n      Optional<PskKeyExchangeMode> pskModeArg = folly::none,\n      Optional<uint32_t> obfuscatedAgeArg = folly::none)\n      : futureResState(std::move(futureResStateArg)),\n        pskMode(std::move(pskModeArg)),\n        obfuscatedAge(std::move(obfuscatedAgeArg)) {}\n\n  SemiFuture<std::pair<PskType, Optional<ResumptionState>>> futureResState;\n  Optional<PskKeyExchangeMode> pskMode;\n  Optional<uint32_t> obfuscatedAge;\n};\n} // namespace\n\nstatic ResumptionStateResult getResumptionState(\n    const ClientHello& chlo,\n    const TicketCipher* ticketCipher,\n    const std::vector<PskKeyExchangeMode>& supportedModes) {\n  auto psks = getExtension<ClientPresharedKey>(chlo.extensions);\n  auto clientModes = getExtension<PskKeyExchangeModes>(chlo.extensions);\n  if (psks && !clientModes) {\n    throw FizzException(\"no psk modes\", AlertDescription::missing_extension);\n  }\n\n  Optional<PskKeyExchangeMode> pskMode;\n  if (clientModes) {\n    pskMode = negotiate(supportedModes, clientModes->modes);\n  }\n  if (!psks && !pskMode) {\n    FOLLY_SDT(fizz, session_cache_NotSupported);\n    return ResumptionStateResult(\n        std::make_pair(PskType::NotSupported, folly::none));\n  } else if (!psks || psks->identities.size() <= kPskIndex) {\n    FOLLY_SDT(fizz, session_cache_NotAttempted);\n    return ResumptionStateResult(\n        std::make_pair(PskType::NotAttempted, folly::none));\n  } else if (!ticketCipher) {\n    FOLLY_SDT(fizz, session_cache_NoTicketCipher);\n    VLOG(8) << \"No ticket cipher, rejecting PSK.\";\n    return ResumptionStateResult(\n        std::make_pair(PskType::Rejected, folly::none));\n  } else if (!pskMode) {\n    FOLLY_SDT(fizz, session_cache_PskModeMismatch);\n    VLOG(8) << \"No psk mode match, rejecting PSK.\";\n    return ResumptionStateResult(\n        std::make_pair(PskType::Rejected, folly::none));\n  } else {\n    FOLLY_SDT(fizz, session_cache_ResumptionSuccess);\n    const auto& ident = psks->identities[kPskIndex].psk_identity;\n    return ResumptionStateResult(\n        ticketCipher->decrypt(ident->clone()),\n        pskMode,\n        psks->identities[kPskIndex].obfuscated_ticket_age);\n  }\n}\n\nstatic SemiFuture<ReplayCacheResult> getReplayCacheResult(\n    const ClientHello& chlo,\n    bool zeroRttEnabled,\n    ReplayCache* replayCache) {\n  if (!zeroRttEnabled || !replayCache ||\n      !getExtension<ClientEarlyData>(chlo.extensions)) {\n    FOLLY_SDT(fizz, replay_cache_NotChecked);\n    return ReplayCacheResult::NotChecked;\n  }\n  auto randBuf = folly::IOBuf::copyBuffer(chlo.random, chlo.random.size());\n  return replayCache->check(std::move(randBuf));\n}\n\nstatic bool validateResumptionState(\n    const ResumptionState& resState,\n    PskKeyExchangeMode /* mode */,\n    ProtocolVersion version,\n    CipherSuite cipher) {\n  if (resState.version != version) {\n    FOLLY_SDT(fizz, resumption_state_ProtocolVersionMismatch);\n    VLOG(8) << \"Protocol version mismatch, rejecting PSK.\";\n    return false;\n  }\n\n  if (getHashFunction(resState.cipher) != getHashFunction(cipher)) {\n    FOLLY_SDT(fizz, resumption_state_HashFunctionMismatch);\n    VLOG(8) << \"Hash mismatch, rejecting PSK.\";\n    return false;\n  }\n\n  return true;\n}\n\nstatic CipherSuite negotiateCipher(\n    const ClientHello& chlo,\n    const std::vector<std::vector<CipherSuite>>& supportedCiphers) {\n  auto cipher = negotiate(supportedCiphers, chlo.cipher_suites);\n  if (!cipher) {\n    throw FizzException(\"no cipher match\", AlertDescription::handshake_failure);\n  }\n  return *cipher;\n}\n\n/*\n * Sets up a KeyScheduler and HandshakeContext for the connection. The\n * KeyScheduler will have the early secret derived if applicable, and the\n * ClientHello will be added to the HandshakeContext. This also verifies the\n * PSK binder if applicable.\n *\n * If the passed in handshakeContext is non-null it is used instead of a new\n * context. This is used after a HelloRetryRequest when there is already a\n * handshake transcript before the current ClientHello.\n */\nstatic std::\n    pair<std::unique_ptr<KeyScheduler>, std::unique_ptr<HandshakeContext>>\n    setupSchedulerAndContext(\n        const Factory& factory,\n        CipherSuite cipher,\n        const ClientHello& chlo,\n        const Optional<ResumptionState>& resState,\n        const Optional<CookieState>& cookieState,\n        PskType pskType,\n        std::unique_ptr<HandshakeContext> handshakeContext,\n        ProtocolVersion /*version*/) {\n  auto scheduler = factory.makeKeyScheduler(cipher);\n\n  if (cookieState) {\n    handshakeContext = factory.makeHandshakeContext(cipher);\n\n    message_hash chloHash;\n    chloHash.hash = cookieState->chloHash->clone();\n    handshakeContext->appendToTranscript(encodeHandshake(std::move(chloHash)));\n\n    auto cookie = getExtension<Cookie>(chlo.extensions);\n    handshakeContext->appendToTranscript(getStatelessHelloRetryRequest(\n        cookieState->version,\n        cookieState->cipher,\n        cookieState->group,\n        std::move(cookie->cookie)));\n  } else if (!handshakeContext) {\n    handshakeContext = factory.makeHandshakeContext(cipher);\n  }\n\n  if (resState) {\n    scheduler->deriveEarlySecret(resState->resumptionSecret->coalesce());\n\n    auto binderKey = scheduler\n                         ->getSecret(\n                             pskType == PskType::External\n                                 ? EarlySecrets::ExternalPskBinder\n                                 : EarlySecrets::ResumptionPskBinder,\n                             handshakeContext->getBlankContext())\n                         .secret;\n\n    folly::IOBufQueue chloQueue(folly::IOBufQueue::cacheChainLength());\n    chloQueue.append((*chlo.originalEncoding)->clone());\n    auto chloPrefix =\n        chloQueue.split(chloQueue.chainLength() - getBinderLength(chlo));\n    handshakeContext->appendToTranscript(chloPrefix);\n\n    const auto& psks = getExtension<ClientPresharedKey>(chlo.extensions);\n    if (!psks || psks->binders.size() <= kPskIndex) {\n      throw FizzException(\"no binders\", AlertDescription::illegal_parameter);\n    }\n    auto expectedBinder =\n        handshakeContext->getFinishedData(folly::range(binderKey));\n    if (!CryptoUtils::equal(\n            expectedBinder->coalesce(),\n            psks->binders[kPskIndex].binder->coalesce())) {\n      throw FizzException(\n          \"binder does not match\", AlertDescription::bad_record_mac);\n    }\n\n    handshakeContext->appendToTranscript(chloQueue.move());\n    return std::make_pair(std::move(scheduler), std::move(handshakeContext));\n  } else {\n    handshakeContext->appendToTranscript(*chlo.originalEncoding);\n    return std::make_pair(std::move(scheduler), std::move(handshakeContext));\n  }\n}\n\nstatic void validateGroups(const std::vector<KeyShareEntry>& client_shares) {\n  std::set<NamedGroup> setOfNamedGroups;\n\n  for (const auto& share : client_shares) {\n    if (setOfNamedGroups.find(share.group) != setOfNamedGroups.end()) {\n      throw FizzException(\n          \"duplicate client key share\", AlertDescription::illegal_parameter);\n    }\n\n    setOfNamedGroups.insert(share.group);\n  }\n}\n\nstatic std::tuple<NamedGroup, Optional<Buf>> negotiateGroup(\n    ProtocolVersion version,\n    const ClientHello& chlo,\n    const std::vector<NamedGroup>& supportedGroups) {\n  auto groups = getExtension<SupportedGroups>(chlo.extensions);\n  if (!groups) {\n    throw FizzException(\"no named groups\", AlertDescription::missing_extension);\n  }\n  auto group = negotiate(supportedGroups, groups->named_group_list);\n  if (!group) {\n    throw FizzException(\"no group match\", AlertDescription::handshake_failure);\n  }\n  auto clientShares = getExtension<ClientKeyShare>(chlo.extensions);\n  if (!clientShares) {\n    throw FizzException(\n        \"no client shares\", AlertDescription::missing_extension);\n  }\n\n  validateGroups(clientShares->client_shares);\n  for (const auto& share : clientShares->client_shares) {\n    if (share.group == *group) {\n      return std::make_tuple(*group, share.key_exchange->clone());\n    }\n  }\n  return std::make_tuple(*group, folly::none);\n}\n\nstatic SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> doKexSyncFuture(\n    KeyExchange* kex,\n    std::unique_ptr<folly::IOBuf> clientShare) {\n  AsyncKeyExchange::DoKexResult res;\n  kex->generateKeyPair();\n  res.sharedSecret = kex->generateSharedSecret(clientShare->coalesce());\n  res.ourKeyShare = kex->getKeyShare();\n  return folly::makeSemiFuture(Optional(std::move(res)));\n  // Everything completed and clientShare can be safely freed now.\n}\n\n// Caller is responsible to hold pKex until the lambda finished.\nstatic SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> doKexFuture(\n    KeyExchange* pKex,\n    std::unique_ptr<folly::IOBuf> clientShare) {\n  auto pAsyncKex = dynamic_cast<AsyncKeyExchange*>(pKex);\n  if (pAsyncKex) {\n    auto fut = pAsyncKex->doAsyncKexFuture(std::move(clientShare));\n    return std::move(fut).deferValue([](AsyncKeyExchange::DoKexResult res) {\n      return Optional(std::move(res));\n    });\n  } else {\n    return doKexSyncFuture(pKex, std::move(clientShare));\n  }\n}\n\nstatic HelloRetryRequest getHelloRetryRequest(\n    ProtocolVersion version,\n    CipherSuite cipher,\n    NamedGroup group,\n    Buf legacySessionId,\n    HandshakeContext& handshakeContext) {\n  HelloRetryRequest hrr;\n  hrr.legacy_version = ProtocolVersion::tls_1_2;\n  hrr.legacy_session_id_echo = std::move(legacySessionId);\n  hrr.cipher_suite = cipher;\n  ServerSupportedVersions versionExt;\n  versionExt.selected_version = version;\n  hrr.extensions.push_back(encodeExtension(std::move(versionExt)));\n  HelloRetryRequestKeyShare keyShare;\n  keyShare.selected_group = group;\n  hrr.extensions.push_back(encodeExtension(std::move(keyShare)));\n  return hrr;\n}\n\nstatic ServerHello getServerHello(\n    ProtocolVersion version,\n    Random random,\n    CipherSuite cipher,\n    bool psk,\n    Optional<NamedGroup> group,\n    Optional<Buf> serverShare,\n    Buf legacySessionId) {\n  ServerHello serverHello;\n\n  serverHello.legacy_version = ProtocolVersion::tls_1_2;\n  ServerSupportedVersions versionExt;\n  versionExt.selected_version = version;\n  serverHello.extensions.push_back(encodeExtension(std::move(versionExt)));\n  serverHello.legacy_session_id_echo = std::move(legacySessionId);\n\n  serverHello.random = std::move(random);\n  serverHello.cipher_suite = cipher;\n  if (group) {\n    ServerKeyShare serverKeyShare;\n    serverKeyShare.server_share.group = *group;\n    serverKeyShare.server_share.key_exchange = std::move(*serverShare);\n\n    serverHello.extensions.push_back(\n        encodeExtension(std::move(serverKeyShare)));\n  }\n  if (psk) {\n    ServerPresharedKey serverPsk;\n    serverPsk.selected_identity = kPskIndex;\n    serverHello.extensions.push_back(encodeExtension(std::move(serverPsk)));\n  }\n  return serverHello;\n}\n\nstatic Optional<std::string> negotiateAlpn(\n    const ClientHello& chlo,\n    folly::Optional<std::string> zeroRttAlpn,\n    const FizzServerContext& context) {\n  auto ext = getExtension<ProtocolNameList>(chlo.extensions);\n  std::vector<std::string> clientProtocols;\n  // Check whether client supports ALPN\n  if (ext) {\n    for (auto& protocol : ext->protocol_name_list) {\n      clientProtocols.push_back(protocol.name->moveToFbString().toStdString());\n    }\n  } else {\n    VLOG(6) << \"Client did not send ALPN extension\";\n    if (context.getAlpnMode() == AlpnMode::Required) {\n      throw FizzException(\n          \"ALPN is required\", AlertDescription::no_application_protocol);\n    }\n    return folly::none;\n  }\n\n  // Since both support ALPN, check whether the protocols match.\n  // Server's support for ALPN is to be enforced at the configuration.\n  auto selected = context.negotiateAlpn(clientProtocols, zeroRttAlpn);\n  if (!selected) {\n    VLOG(6) << \"ALPN mismatch\";\n    if (context.getAlpnMode() != AlpnMode::AllowMismatch) {\n      auto msg = context.getAlpnMode() == AlpnMode::Optional\n          ? \"Unable to negotiate ALPN, as required by policy. policy=AlpnMode::Optional\"\n          : \"Unable to negotiate ALPN, as required by policy. policy=AlpnMode::Required\";\n      throw FizzException(msg, AlertDescription::no_application_protocol);\n    }\n  } else {\n    VLOG(6) << \"ALPN: \" << *selected;\n  }\n  return selected;\n}\n\nstatic Optional<std::chrono::milliseconds> getClockSkew(\n    const Optional<ResumptionState>& psk,\n    Optional<uint32_t> obfuscatedAge,\n    const std::chrono::system_clock::time_point& currentTime) {\n  if (!psk || !obfuscatedAge) {\n    return folly::none;\n  }\n\n  auto age = std::chrono::milliseconds(\n      static_cast<uint32_t>(*obfuscatedAge - psk->ticketAgeAdd));\n\n  auto expected = std::chrono::duration_cast<std::chrono::milliseconds>(\n      currentTime - psk->ticketIssueTime);\n\n  return std::chrono::milliseconds(age - expected);\n}\n\nstatic Optional<Buf> getAppToken(const Optional<ResumptionState>& psk) {\n  if (!psk.has_value() || !psk->appToken) {\n    return folly::none;\n  }\n  return psk->appToken->clone();\n}\n\nstatic EarlyDataType negotiateEarlyDataType(\n    bool acceptEarlyData,\n    const ClientHello& chlo,\n    const Optional<ResumptionState>& psk,\n    CipherSuite cipher,\n    Optional<KeyExchangeType> keyExchangeType,\n    const Optional<CookieState>& cookieState,\n    Optional<std::string> alpn,\n    ReplayCacheResult replayCacheResult,\n    Optional<std::chrono::milliseconds> clockSkew,\n    ClockSkewTolerance clockSkewTolerance,\n    const AppTokenValidator* appTokenValidator) {\n  if (!getExtension<ClientEarlyData>(chlo.extensions)) {\n    return EarlyDataType::NotAttempted;\n  }\n\n  if (!acceptEarlyData) {\n    VLOG(5) << \"Rejecting early data: disabled\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (!psk) {\n    VLOG(5) << \"Rejected early data: psk rejected\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (psk->cipher != cipher) {\n    VLOG(5) << \"Rejected early data: cipher mismatch\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (psk->alpn != alpn) {\n    VLOG(5) << \"Rejecting early data: alpn mismatch\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (keyExchangeType &&\n      *keyExchangeType == KeyExchangeType::HelloRetryRequest) {\n    VLOG(5) << \"Rejecting early data: HelloRetryRequest\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (cookieState) {\n    VLOG(5) << \"Rejecting early data: Cookie\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (replayCacheResult != ReplayCacheResult::NotReplay) {\n    VLOG(5) << \"Rejecting early data: replay\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (!clockSkew || *clockSkew < clockSkewTolerance.before ||\n      *clockSkew > clockSkewTolerance.after) {\n    VLOG(5) << \"Rejecting early data: clock skew clockSkew=\"\n            << (clockSkew ? folly::to<std::string>(clockSkew->count())\n                          : \"(none)\")\n            << \" toleranceBefore=\" << clockSkewTolerance.before.count()\n            << \" toleranceAfter=\" << clockSkewTolerance.after.count();\n    return EarlyDataType::Rejected;\n  }\n\n  if (appTokenValidator && !appTokenValidator->validate(*psk)) {\n    VLOG(5) << \"Rejecting early data: invalid app token\";\n    return EarlyDataType::Rejected;\n  }\n\n  return EarlyDataType::Accepted;\n}\n\nstatic Buf getEncryptedExt(\n    HandshakeContext& handshakeContext,\n    const folly::Optional<std::string>& selectedAlpn,\n    EarlyDataType earlyData,\n    folly::Optional<std::vector<ech::ECHConfig>> echRetryConfigs,\n    std::vector<Extension> otherExtensions) {\n  EncryptedExtensions encryptedExt;\n  if (selectedAlpn) {\n    ProtocolNameList alpn;\n    ProtocolName protocol;\n    protocol.name = folly::IOBuf::copyBuffer(*selectedAlpn);\n    alpn.protocol_name_list.push_back(std::move(protocol));\n    encryptedExt.extensions.push_back(encodeExtension(std::move(alpn)));\n  }\n\n  if (earlyData == EarlyDataType::Accepted) {\n    encryptedExt.extensions.push_back(encodeExtension(ServerEarlyData()));\n  }\n\n  if (echRetryConfigs.has_value()) {\n    ech::ECHEncryptedExtensions serverEch;\n    serverEch.retry_configs = std::move(*echRetryConfigs);\n    encryptedExt.extensions.push_back(encodeExtension(std::move(serverEch)));\n  }\n\n  for (auto& ext : otherExtensions) {\n    encryptedExt.extensions.push_back(std::move(ext));\n  }\n  auto encodedEncryptedExt =\n      encodeHandshake<EncryptedExtensions>(std::move(encryptedExt));\n  handshakeContext.appendToTranscript(encodedEncryptedExt);\n  return encodedEncryptedExt;\n}\n\nstatic std::pair<std::shared_ptr<SelfCert>, SignatureScheme> chooseCert(\n    const FizzServerContext& context,\n    const ClientHello& chlo) {\n  const auto& clientSigSchemes =\n      getExtension<SignatureAlgorithms>(chlo.extensions);\n  if (!clientSigSchemes) {\n    throw FizzException(\"no sig schemes\", AlertDescription::missing_extension);\n  }\n  Optional<std::string> sni;\n  auto serverNameList = getExtension<ServerNameList>(chlo.extensions);\n  if (serverNameList && !serverNameList->server_name_list.empty()) {\n    sni = serverNameList->server_name_list.front()\n              .hostname->moveToFbString()\n              .toStdString();\n  }\n\n  auto certAndScheme = context.getCert(\n      sni, clientSigSchemes->supported_signature_algorithms, chlo.extensions);\n  if (!certAndScheme) {\n    throw FizzException(\n        \"could not find suitable cert\", AlertDescription::handshake_failure);\n  }\n  return *certAndScheme;\n}\n\nstatic std::tuple<Buf, folly::Optional<CertificateCompressionAlgorithm>>\ngetCertificate(\n    const std::shared_ptr<const SelfCert>& serverCert,\n    const FizzServerContext& context,\n    const ClientHello& chlo,\n    HandshakeContext& handshakeContext) {\n  // Check for compression support first, and if so, send compressed.\n  Buf encodedCertificate;\n  folly::Optional<CertificateCompressionAlgorithm> algo;\n  auto compAlgos =\n      getExtension<CertificateCompressionAlgorithms>(chlo.extensions);\n  if (compAlgos && !context.getSupportedCompressionAlgorithms().empty()) {\n    algo = negotiate(\n        context.getSupportedCompressionAlgorithms(), compAlgos->algorithms);\n  }\n\n  if (algo) {\n    encodedCertificate = encodeHandshake(serverCert->getCompressedCert(*algo));\n  } else {\n    encodedCertificate = encodeHandshake(serverCert->getCertMessage());\n  }\n  handshakeContext.appendToTranscript(encodedCertificate);\n  return std::make_tuple(std::move(encodedCertificate), std::move(algo));\n}\n\nstatic Buf getCertificateVerify(\n    SignatureScheme sigScheme,\n    Buf signature,\n    HandshakeContext& handshakeContext) {\n  CertificateVerify verify;\n  verify.algorithm = sigScheme;\n  verify.signature = std::move(signature);\n  auto encodedCertificateVerify = encodeHandshake(std::move(verify));\n  handshakeContext.appendToTranscript(encodedCertificateVerify);\n  return encodedCertificateVerify;\n}\n\nstatic Buf getCertificateRequest(\n    const std::vector<SignatureScheme>& acceptableSigSchemes,\n    const CertificateVerifier* const verifier,\n    HandshakeContext& handshakeContext) {\n  CertificateRequest request;\n  SignatureAlgorithms algos;\n  algos.supported_signature_algorithms = acceptableSigSchemes;\n  request.extensions.push_back(encodeExtension(std::move(algos)));\n  if (verifier) {\n    auto verifierExtensions = verifier->getCertificateRequestExtensions();\n    for (auto& ext : verifierExtensions) {\n      request.extensions.push_back(std::move(ext));\n    }\n  }\n  auto encodedCertificateRequest = encodeHandshake(std::move(request));\n  handshakeContext.appendToTranscript(encodedCertificateRequest);\n  return encodedCertificateRequest;\n}\n\nstatic std::tuple<ECHStatus, uint8_t> processECHHRR(\n    const Optional<CookieState>& cookieState,\n    const State& state,\n    ClientHello& chlo) {\n  auto decrypter = state.context()->getECHDecrypter();\n  auto echExt = getExtension<ech::OuterECHClientHello>(chlo.extensions);\n  ECHStatus echStatus = state.echStatus();\n\n  // Check for cookie ECH\n  bool cookieHasECH = cookieState && cookieState->echCipherSuite.has_value();\n\n  // Do checks for both cases.\n  if (echStatus == ECHStatus::Accepted || cookieHasECH) {\n    if (!decrypter) {\n      throw FizzException(\n          \"ech accepted but no decrypter set up\",\n          AlertDescription::internal_error);\n    }\n    if (!echExt) {\n      throw FizzException(\n          \"ech not sent for hrr\", AlertDescription::missing_extension);\n    }\n    if (!echExt->enc->empty()) {\n      throw FizzException(\n          \"hrr ech enc not empty\", AlertDescription::illegal_parameter);\n    }\n  }\n\n  if (echStatus == ECHStatus::Accepted) {\n    // Stateful HRR first.\n    if (state.echState()->cipherSuite != echExt->cipher_suite) {\n      throw FizzException(\n          \"ech hrr cipher suite mismatch\", AlertDescription::illegal_parameter);\n    }\n    if (state.echState()->configId != echExt->config_id) {\n      throw FizzException(\n          \"ech hrr config id mismatch\", AlertDescription::illegal_parameter);\n    }\n\n    chlo =\n        decrypter->decryptClientHelloHRR(chlo, state.echState()->hpkeContext);\n\n    return {ECHStatus::Accepted, echExt->config_id};\n  } else if (cookieHasECH) {\n    // Stateless HRR now\n    if (*cookieState->echCipherSuite != echExt->cipher_suite) {\n      throw FizzException(\n          \"ech hrr cipher suite mismatch\", AlertDescription::illegal_parameter);\n    }\n    if (*cookieState->echConfigId != echExt->config_id) {\n      throw FizzException(\n          \"ech hrr config id mismatch\", AlertDescription::illegal_parameter);\n    }\n\n    chlo = decrypter->decryptClientHelloHRR(chlo, cookieState->echEnc);\n\n    return {ECHStatus::Accepted, echExt->config_id};\n  }\n\n  // Just return the ECH status as is\n  return {echStatus, 0};\n}\n\n// Process ECH, replacing chlo if successful\nstatic std::pair<ECHStatus, ECHState> processECH(\n    const Optional<CookieState>& cookieState,\n    const State& state,\n    ClientHello& chlo) {\n  // First, fetch current state (if any).\n  ECHState echState;\n  ECHStatus echStatus = state.echStatus();\n  auto decrypter = state.context()->getECHDecrypter();\n\n  if (state.handshakeContext() || cookieState) {\n    // Process ECH for HRR (if any)\n    std::tie(echStatus, echState.configId) =\n        processECHHRR(cookieState, state, chlo);\n    // Populate ECH state for saving\n    if (state.echState().has_value()) {\n      echState.hpkeContext = std::move(state.echState()->hpkeContext);\n      echState.cipherSuite = state.echState()->cipherSuite;\n    }\n  } else {\n    bool requestedECH =\n        findExtension(chlo.extensions, ExtensionType::encrypted_client_hello) !=\n        chlo.extensions.end();\n    if (requestedECH && decrypter) {\n      auto gotChlo = decrypter->decryptClientHello(chlo);\n      if (gotChlo.has_value()) {\n        auto echExt = getExtension<ech::OuterECHClientHello>(chlo.extensions);\n        echStatus = ECHStatus::Accepted;\n        echState.hpkeContext = std::move(gotChlo->context);\n        echState.configId = gotChlo->configId;\n        echState.cipherSuite = echExt->cipher_suite;\n        chlo = std::move(gotChlo->chlo);\n      } else if (requestedECH) {\n        echStatus = ECHStatus::Rejected;\n      }\n    }\n  }\n\n  if (echStatus == ECHStatus::Accepted &&\n      getExtension<ech::InnerECHClientHello>(chlo.extensions) == folly::none) {\n    throw FizzException(\n        \"inner clienthello missing encrypted_client_hello\",\n        AlertDescription::missing_extension);\n  }\n\n  return std::make_pair(echStatus, std::move(echState));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle(const State& state, Param param) {\n  ClientHello chlo = std::move(*param.asClientHello());\n\n  auto cookieState = getCookieState(chlo, state.context()->getCookieCipher());\n\n  if (state.handshakeContext() && cookieState.has_value()) {\n    throw FizzException(\n        \"cookie after statefull hrr\", AlertDescription::illegal_parameter);\n  }\n\n  ECHStatus echStatus;\n  ECHState echState;\n  std::tie(echStatus, echState) = processECH(cookieState, state, chlo);\n\n  addHandshakeLogging(state, chlo);\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after client hello\", AlertDescription::unexpected_message);\n  }\n\n  auto version =\n      negotiateVersion(chlo, state.context()->getSupportedVersions());\n\n  if (state.version().has_value() &&\n      (!version || *version != *state.version())) {\n    throw FizzException(\n        \"version mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  if (!version) {\n    if (getExtension<ClientEarlyData>(chlo.extensions)) {\n      throw FizzException(\n          \"supported version mismatch with early data\",\n          AlertDescription::protocol_version);\n    }\n    if (state.context()->getVersionFallbackEnabled()) {\n      AttemptVersionFallback fallback;\n      // Re-encode to put the record layer header back on. This won't\n      // necessarily preserve it byte-for-byte, but it isn't authenticated so\n      // should be ok.\n      fallback.clientHello =\n          PlaintextWriteRecordLayer()\n              .writeInitialClientHello(std::move(*chlo.originalEncoding))\n              .data;\n      return actions(\n          MutateState(&Transition<StateEnum::Error>), std::move(fallback));\n    } else {\n      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n      state.context()->getReplayCache());\n\n  auto results =\n      collectAll(resStateResult.futureResState, replayCacheResultFuture);\n\n  using FutureResultType = std::tuple<\n      folly::Try<std::pair<PskType, Optional<ResumptionState>>>,\n      folly::Try<ReplayCacheResult>>;\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(results),\n      [&state,\n       chlo = std::move(chlo),\n       cookieState = std::move(cookieState),\n       version = *version,\n       cipher,\n       pskMode = resStateResult.pskMode,\n       echStatus,\n       echState = std::move(echState),\n       obfuscatedAge =\n           resStateResult.obfuscatedAge](FutureResultType result) mutable {\n        auto& resumption = *std::get<0>(result);\n        auto pskType = resumption.first;\n        auto resState = std::move(resumption.second);\n        auto replayCacheResult = *std::get<1>(result);\n\n        if (resState) {\n          if (!validateResumptionState(*resState, *pskMode, version, cipher)) {\n            pskType = PskType::Rejected;\n            pskMode = folly::none;\n            resState = folly::none;\n          }\n        } else {\n          pskMode = folly::none;\n        }\n\n        auto legacySessionId = chlo.legacy_session_id->clone();\n\n        // If we successfully resumed, set the handshake time to the ticket's\n        // handshake time to preserve it across ticket updates. If not, set it\n        // to now.\n        std::chrono::system_clock::time_point handshakeTime;\n        if (resState) {\n          handshakeTime = resState->handshakeTime;\n        } else {\n          handshakeTime = state.context()->getClock().getCurrentTime();\n        }\n\n        std::unique_ptr<KeyScheduler> scheduler;\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        if (state.cipher().has_value() && cipher != *state.cipher()) {\n          throw FizzException(\n              \"cipher mismatch with previous negotiation\",\n              AlertDescription::illegal_parameter);\n        }\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n\n        auto earlyDataType = negotiateEarlyDataType(\n            state.context()->getAcceptEarlyData(version),\n            chlo,\n            resState,\n            cipher,\n            state.keyExchangeType(),\n            cookieState,\n            alpn,\n            replayCacheResult,\n            clockSkew,\n            state.context()->getClockSkewTolerance(),\n            state.appTokenValidator());\n\n        std::unique_ptr<EncryptedReadRecordLayer> earlyReadRecordLayer;\n        Buf earlyExporterMaster;\n        folly::Optional<SecretAvailable> earlyReadSecretAvailable;\n        if (earlyDataType == EarlyDataType::Accepted) {\n          auto earlyContext = handshakeContext->getHandshakeContext();\n          auto earlyReadSecret = scheduler->getSecret(\n              EarlySecrets::ClientEarlyTraffic, earlyContext->coalesce());\n          if (!state.context()->getOmitEarlyRecordLayer()) {\n            earlyReadRecordLayer =\n                state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                    EncryptionLevel::EarlyData);\n            earlyReadRecordLayer->setProtocolVersion(version);\n\n            Protocol::setAead(\n                *earlyReadRecordLayer,\n                cipher,\n                folly::range(earlyReadSecret.secret),\n                *state.context()->getFactory(),\n                *scheduler);\n          }\n\n          earlyReadSecretAvailable =\n              SecretAvailable(std::move(earlyReadSecret));\n          earlyExporterMaster = folly::IOBuf::copyBuffer(\n              scheduler\n                  ->getSecret(\n                      EarlySecrets::EarlyExporter, earlyContext->coalesce())\n                  .secret);\n        }\n\n        Optional<NamedGroup> group;\n        KeyExchangeType keyExchangeType;\n        SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> kexResultFuture =\n            folly::none;\n        std::unique_ptr<KeyExchange> kex = nullptr;\n\n        if (!pskMode || *pskMode != PskKeyExchangeMode::psk_ke) {\n          Optional<Buf> clientShare;\n          std::tie(group, clientShare) = negotiateGroup(\n              version, chlo, state.context()->getSupportedGroups());\n          if (!clientShare) {\n            VLOG(8) << \"Did not find key share for \" << toString(*group);\n            if (state.group().has_value() || cookieState) {\n              throw FizzException(\n                  \"key share not found for already negotiated group\",\n                  AlertDescription::illegal_parameter);\n            }\n\n            // If we were otherwise going to accept early data we now need to\n            // reject it. It's a little ugly to change our previous early data\n            // decision, but doing it this way allows us to move the key\n            // schedule forward as we do the key exchange.\n            if (earlyDataType == EarlyDataType::Accepted) {\n              earlyDataType = EarlyDataType::Rejected;\n            }\n\n            message_hash chloHash;\n            chloHash.hash = handshakeContext->getHandshakeContext();\n            handshakeContext =\n                state.context()->getFactory()->makeHandshakeContext(cipher);\n            handshakeContext->appendToTranscript(\n                encodeHandshake(std::move(chloHash)));\n\n            auto hrr = getHelloRetryRequest(\n                version,\n                cipher,\n                *group,\n                legacySessionId ? legacySessionId->clone() : nullptr,\n                *handshakeContext);\n\n            if (echStatus == ECHStatus::Accepted) {\n              // Set up acceptance scheduler\n              auto echScheduler =\n                  state.context()->getFactory()->makeKeyScheduler(cipher);\n              echScheduler->deriveEarlySecret(folly::range(chlo.random));\n              // Add acceptance extension\n              ech::setAcceptConfirmation(\n                  hrr, handshakeContext->clone(), std::move(echScheduler));\n            }\n\n            auto encodedHelloRetryRequest = encodeHandshake(std::move(hrr));\n            handshakeContext->appendToTranscript(encodedHelloRetryRequest);\n\n            WriteToSocket serverFlight;\n            serverFlight.contents.emplace_back(\n                state.writeRecordLayer()->writeHandshake(\n                    std::move(encodedHelloRetryRequest)));\n\n            if (legacySessionId && !legacySessionId->empty()) {\n              TLSContent writeCCS;\n              writeCCS.encryptionLevel = EncryptionLevel::Plaintext;\n              writeCCS.contentType = ContentType::change_cipher_spec;\n              writeCCS.data = folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n              serverFlight.contents.emplace_back(std::move(writeCCS));\n            }\n\n            // Create a new record layer in case we need to skip early data.\n            auto newReadRecordLayer =\n                state.context()->getFactory()->makePlaintextReadRecordLayer();\n            newReadRecordLayer->setSkipEncryptedRecords(\n                earlyDataType == EarlyDataType::Rejected);\n\n            return SemiFuture<Actions>(actions(\n                MutateState([handshakeContext = std::move(handshakeContext),\n                             version,\n                             cipher,\n                             group,\n                             earlyDataType,\n                             replayCacheResult,\n                             newReadRecordLayer = std::move(newReadRecordLayer),\n                             echStatus,\n                             echState =\n                                 std::move(echState)](State& newState) mutable {\n                  // Save some information about the current state to be\n                  // validated when we get the second client hello. We don't\n                  // validate that the second client hello matches the first\n                  // as strictly as we could according to the spec however.\n                  newState.handshakeContext() = std::move(handshakeContext);\n                  newState.version() = version;\n                  newState.cipher() = cipher;\n                  newState.group() = group;\n                  newState.keyExchangeType() =\n                      KeyExchangeType::HelloRetryRequest;\n                  newState.earlyDataType() = earlyDataType;\n                  newState.replayCacheResult() = replayCacheResult;\n                  newState.readRecordLayer() = std::move(newReadRecordLayer);\n                  newState.echStatus() = echStatus;\n                  if (echStatus == ECHStatus::Accepted) {\n                    newState.echState() = std::move(echState);\n                  }\n                }),\n                std::move(serverFlight),\n                MutateState(&Transition<StateEnum::ExpectingClientHello>)));\n          }\n\n          if (state.keyExchangeType().has_value()) {\n            keyExchangeType = *state.keyExchangeType();\n          } else {\n            keyExchangeType = KeyExchangeType::OneRtt;\n          }\n\n          // The exceptions in SemiFutures will be processed in\n          // detail::processEvent.\n          kex = state.context()->getFactory()->makeKeyExchange(\n              *group, Factory::KeyExchangeMode::Server);\n          kexResultFuture =\n              doKexFuture(kex.get(), std::move(clientShare.value()));\n        } else {\n          keyExchangeType = KeyExchangeType::None;\n        }\n\n        return runOnCallerIfComplete(\n            state.executor(),\n            std::move(kexResultFuture),\n            [&state,\n             scheduler = std::move(scheduler),\n             handshakeContext = std::move(handshakeContext),\n             cipher,\n             group,\n             echStatus,\n             earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n             earlyReadSecretAvailable = std::move(earlyReadSecretAvailable),\n             earlyExporterMaster = std::move(earlyExporterMaster),\n             pskType,\n             pskMode,\n             version,\n             keyExchangeType,\n             earlyDataType,\n             replayCacheResult,\n             alpn = std::move(alpn),\n             clockSkew,\n             appToken = std::move(appToken),\n             legacySessionId = std::move(legacySessionId),\n             handshakeTime,\n             chlo = std::move(chlo),\n             cookieState = std::move(cookieState),\n             resState = std::move(resState),\n             // Hold kex until the doKexFuture finished.\n             kex = std::move(kex)](\n                Optional<AsyncKeyExchange::DoKexResult> kexResult) mutable {\n              Optional<Buf> serverShare;\n              if (kexResult.hasValue()) {\n                serverShare = std::move(kexResult.value().ourKeyShare);\n                scheduler->deriveHandshakeSecret(\n                    kexResult.value().sharedSecret->coalesce());\n              } else {\n                DCHECK(keyExchangeType == KeyExchangeType::None);\n                scheduler->deriveHandshakeSecret();\n              }\n              std::vector<Extension> additionalExtensions;\n              if (state.extensions()) {\n                additionalExtensions = state.extensions()->getExtensions(chlo);\n              }\n\n              if (state.group().has_value() &&\n                  (!group || *group != *state.group())) {\n                throw FizzException(\n                    \"group mismatch with previous negotiation\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              // Cookies are not required to have already negotiated the group\n              // but if they did it must match (psk_ke is still allowed as we\n              // may not know if we are accepting the psk when sending the\n              // cookie).\n              if (cookieState && cookieState->group && group &&\n                  *group != *cookieState->group) {\n                throw FizzException(\n                    \"group mismatch with cookie\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              auto serverHello = getServerHello(\n                  version,\n                  state.context()->getFactory()->makeRandom(),\n                  cipher,\n                  resState.has_value(),\n                  group,\n                  std::move(serverShare),\n                  legacySessionId ? legacySessionId->clone() : nullptr);\n\n              folly::Optional<std::vector<ech::ECHConfig>> echRetryConfigs;\n              if (echStatus == ECHStatus::Accepted) {\n                // Set up acceptance scheduler\n                auto echScheduler =\n                    state.context()->getFactory()->makeKeyScheduler(cipher);\n                echScheduler->deriveEarlySecret(folly::range(chlo.random));\n                // Add acceptance extension\n                ech::setAcceptConfirmation(\n                    serverHello,\n                    handshakeContext->clone(),\n                    std::move(echScheduler));\n              } else if (echStatus == ECHStatus::Rejected) {\n                auto decrypter = state.context()->getECHDecrypter();\n                echRetryConfigs = decrypter->getRetryConfigs();\n              }\n\n              auto encodedServerHello = encodeHandshake(std::move(serverHello));\n              handshakeContext->appendToTranscript(encodedServerHello);\n\n              // Derive handshake keys.\n              auto handshakeWriteRecordLayer =\n                  state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeWriteRecordLayer->setProtocolVersion(version);\n              auto handshakeWriteSecret = scheduler->getSecret(\n                  HandshakeSecrets::ServerHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeWriteRecordLayer,\n                  cipher,\n                  folly::range(handshakeWriteSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n\n              auto handshakeReadRecordLayer =\n                  state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeReadRecordLayer->setProtocolVersion(version);\n              handshakeReadRecordLayer->setSkipFailedDecryption(\n                  earlyDataType == EarlyDataType::Rejected);\n              auto handshakeReadSecret = scheduler->getSecret(\n                  HandshakeSecrets::ClientHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeReadRecordLayer,\n                  cipher,\n                  folly::range(handshakeReadSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n              auto clientHandshakeSecret =\n                  folly::IOBuf::copyBuffer(handshakeReadSecret.secret);\n\n              auto encodedEncryptedExt = getEncryptedExt(\n                  *handshakeContext,\n                  alpn,\n                  earlyDataType,\n                  std::move(echRetryConfigs),\n                  std::move(additionalExtensions));\n\n              /*\n               * Determine we are requesting client auth.\n               * If yes, add CertificateRequest to handshake write and\n               * transcript.\n               */\n              bool requestClientAuth = state.context()->getClientAuthMode() !=\n                      ClientAuthMode::None &&\n                  !resState;\n              Optional<Buf> encodedCertRequest;\n              if (requestClientAuth) {\n                encodedCertRequest = getCertificateRequest(\n                    state.context()->getSupportedSigSchemes(),\n                    state.context()->getClientCertVerifier().get(),\n                    *handshakeContext);\n              }\n\n              /*\n               * Set the cert and signature scheme we are using.\n               * If sending new cert, add Certificate to handshake write and\n               * transcript.\n               */\n              Optional<Buf> encodedCertificate;\n              SemiFuture<Optional<Buf>> signature = folly::none;\n              Optional<SignatureScheme> sigScheme;\n              Optional<std::shared_ptr<const Cert>> serverCert;\n              std::shared_ptr<const Cert> clientCert;\n              Optional<CertificateCompressionAlgorithm> certCompressionAlgo;\n              if (!resState) { // TODO or reauth\n                std::shared_ptr<const SelfCert> originalSelfCert;\n                std::tie(originalSelfCert, sigScheme) =\n                    chooseCert(*state.context(), chlo);\n\n                std::tie(encodedCertificate, certCompressionAlgo) =\n                    getCertificate(\n                        originalSelfCert,\n                        *state.context(),\n                        chlo,\n                        *handshakeContext);\n\n                auto toBeSigned = handshakeContext->getHandshakeContext();\n                auto asyncSelfCert =\n                    dynamic_cast<const AsyncSelfCert*>(originalSelfCert.get());\n                if (asyncSelfCert) {\n                  signature = asyncSelfCert->signFuture(\n                      *sigScheme,\n                      CertificateVerifyContext::Server,\n                      std::move(toBeSigned));\n                } else {\n                  signature = folly::makeSemiFuture<Optional<Buf>>(\n                      originalSelfCert->sign(\n                          *sigScheme,\n                          CertificateVerifyContext::Server,\n                          toBeSigned->coalesce()));\n                }\n                serverCert = std::move(originalSelfCert);\n              } else {\n                serverCert = std::move(resState->serverCert);\n                clientCert = std::move(resState->clientCert);\n              }\n\n              auto clientRandom = std::move(chlo.random);\n\n              return runOnCallerIfComplete(\n                  state.executor(),\n                  std::move(signature),\n                  [&state,\n                   scheduler = std::move(scheduler),\n                   handshakeContext = std::move(handshakeContext),\n                   cipher,\n                   clientRandom = std::move(clientRandom),\n                   group,\n                   echStatus,\n                   encodedServerHello = std::move(encodedServerHello),\n                   handshakeWriteRecordLayer =\n                       std::move(handshakeWriteRecordLayer),\n                   handshakeWriteSecret = std::move(handshakeWriteSecret),\n                   handshakeReadRecordLayer =\n                       std::move(handshakeReadRecordLayer),\n                   handshakeReadSecret = std::move(handshakeReadSecret),\n                   earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n                   earlyReadSecretAvailable =\n                       std::move(earlyReadSecretAvailable),\n                   earlyExporterMaster = std::move(earlyExporterMaster),\n                   clientHandshakeSecret = std::move(clientHandshakeSecret),\n                   encodedEncryptedExt = std::move(encodedEncryptedExt),\n                   encodedCertificate = std::move(encodedCertificate),\n                   encodedCertRequest = std::move(encodedCertRequest),\n                   requestClientAuth,\n                   pskType,\n                   pskMode,\n                   sigScheme,\n                   version,\n                   keyExchangeType,\n                   earlyDataType,\n                   replayCacheResult,\n                   serverCert = std::move(serverCert),\n                   clientCert = std::move(clientCert),\n                   alpn = std::move(alpn),\n                   clockSkew,\n                   appToken = std::move(appToken),\n                   legacySessionId = std::move(legacySessionId),\n                   serverCertCompAlgo = certCompressionAlgo,\n                   handshakeTime](Optional<Buf> sig) mutable {\n                    Optional<Buf> encodedCertificateVerify;\n                    if (sig) {\n                      encodedCertificateVerify = getCertificateVerify(\n                          *sigScheme, std::move(*sig), *handshakeContext);\n                    }\n\n                    auto encodedFinished = Protocol::getFinished(\n                        folly::range(handshakeWriteSecret.secret),\n                        *handshakeContext);\n\n                    folly::IOBufQueue combined;\n                    if (encodedCertificate) {\n                      if (encodedCertRequest) {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertRequest));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      } else {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      }\n                    } else {\n                      combined.append(std::move(encodedEncryptedExt));\n                      combined.append(std::move(encodedFinished));\n                    }\n\n                    // Some middleboxes appear to break if the first encrypted\n                    // record is larger than ~1300 bytes (likely if it does not\n                    // fit in the first packet).\n                    auto serverEncrypted =\n                        handshakeWriteRecordLayer->writeHandshake(\n                            combined.splitAtMost(1000));\n                    if (!combined.empty()) {\n                      auto splitRecord =\n                          handshakeWriteRecordLayer->writeHandshake(\n                              combined.move());\n                      // Split record must have the same encryption level as the\n                      // main handshake.\n                      DCHECK(\n                          splitRecord.encryptionLevel ==\n                          serverEncrypted.encryptionLevel);\n                      serverEncrypted.data->prependChain(\n                          std::move(splitRecord.data));\n                    }\n\n                    WriteToSocket serverFlight;\n                    serverFlight.contents.emplace_back(\n                        state.writeRecordLayer()->writeHandshake(\n                            std::move(encodedServerHello)));\n                    if (legacySessionId && !legacySessionId->empty()) {\n                      TLSContent ccsWrite;\n                      ccsWrite.encryptionLevel = EncryptionLevel::Plaintext;\n                      ccsWrite.contentType = ContentType::change_cipher_spec;\n                      ccsWrite.data =\n                          folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n                      serverFlight.contents.emplace_back(std::move(ccsWrite));\n                    }\n                    serverFlight.contents.emplace_back(\n                        std::move(serverEncrypted));\n\n                    scheduler->deriveMasterSecret();\n                    auto clientFinishedContext =\n                        handshakeContext->getHandshakeContext();\n                    auto exporterMasterVector = scheduler->getSecret(\n                        MasterSecrets::ExporterMaster,\n                        clientFinishedContext->coalesce());\n                    auto exporterMaster = folly::IOBuf::copyBuffer(\n                        folly::range(exporterMasterVector.secret));\n\n                    scheduler->deriveAppTrafficSecrets(\n                        clientFinishedContext->coalesce());\n                    auto appTrafficWriteRecordLayer =\n                        state.context()\n                            ->getFactory()\n                            ->makeEncryptedWriteRecordLayer(\n                                EncryptionLevel::AppTraffic);\n                    appTrafficWriteRecordLayer->setProtocolVersion(version);\n                    auto writeSecret = scheduler->getSecret(\n                        AppTrafficSecrets::ServerAppTraffic);\n                    Protocol::setAead(\n                        *appTrafficWriteRecordLayer,\n                        cipher,\n                        folly::range(writeSecret.secret),\n                        *state.context()->getFactory(),\n                        *scheduler);\n\n                    // If we have previously dealt with early data (before a\n                    // HelloRetryRequest), don't overwrite the previous result.\n                    auto earlyDataTypeSave = state.earlyDataType()\n                        ? *state.earlyDataType()\n                        : earlyDataType;\n\n                    SecretAvailable handshakeReadSecretAvailable(\n                        std::move(handshakeReadSecret));\n                    SecretAvailable handshakeWriteSecretAvailable(\n                        std::move(handshakeWriteSecret));\n                    SecretAvailable appWriteSecretAvailable(\n                        std::move(writeSecret));\n\n                    // Save all the necessary state except for the read record\n                    // layer, which is done separately as it varies if early\n                    // data was accepted.\n                    MutateState saveState(\n                        [appTrafficWriteRecordLayer =\n                             std::move(appTrafficWriteRecordLayer),\n                         handshakeContext = std::move(handshakeContext),\n                         scheduler = std::move(scheduler),\n                         exporterMaster = std::move(exporterMaster),\n                         serverCert = std::move(serverCert),\n                         clientCert = std::move(clientCert),\n                         cipher,\n                         group,\n                         sigScheme,\n                         clientHandshakeSecret =\n                             std::move(clientHandshakeSecret),\n                         pskType,\n                         pskMode,\n                         version,\n                         keyExchangeType,\n                         alpn = std::move(alpn),\n                         earlyDataTypeSave,\n                         replayCacheResult,\n                         clockSkew,\n                         appToken = std::move(appToken),\n                         serverCertCompAlgo,\n                         echStatus,\n                         clientRandom = std::move(clientRandom),\n                         handshakeTime = std::move(handshakeTime)](\n                            State& newState) mutable {\n                          newState.writeRecordLayer() =\n                              std::move(appTrafficWriteRecordLayer);\n                          newState.handshakeContext() =\n                              std::move(handshakeContext);\n                          newState.keyScheduler() = std::move(scheduler);\n                          newState.exporterMasterSecret() =\n                              std::move(exporterMaster);\n                          newState.serverCert() = std::move(*serverCert);\n                          newState.clientCert() = std::move(clientCert);\n                          newState.version() = version;\n                          newState.cipher() = cipher;\n                          newState.group() = group;\n                          newState.sigScheme() = sigScheme;\n                          newState.clientHandshakeSecret() =\n                              std::move(clientHandshakeSecret);\n                          newState.pskType() = pskType;\n                          newState.pskMode() = pskMode;\n                          newState.keyExchangeType() = keyExchangeType;\n                          newState.earlyDataType() = earlyDataTypeSave;\n                          newState.replayCacheResult() = replayCacheResult;\n                          newState.alpn() = std::move(alpn);\n                          newState.clientClockSkew() = clockSkew;\n                          newState.appToken() = std::move(appToken);\n                          newState.serverCertCompAlgo() = serverCertCompAlgo;\n                          newState.handshakeTime() = std::move(handshakeTime);\n                          newState.clientRandom() = std::move(clientRandom);\n                          newState.echStatus() = echStatus;\n                          newState.echState() = folly::none;\n                        });\n\n                    if (earlyDataType == EarlyDataType::Accepted) {\n                      if (state.context()->getOmitEarlyRecordLayer()) {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::ExpectingFinished>),\n                            ReportEarlyHandshakeSuccess());\n\n                      } else {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyReadRecordLayer =\n                                             std::move(earlyReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(earlyReadRecordLayer);\n                              newState.handshakeReadRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::AcceptingEarlyData>),\n                            ReportEarlyHandshakeSuccess());\n                      }\n                    } else {\n                      auto transition = requestClientAuth\n                          ? Transition<StateEnum::ExpectingCertificate>\n                          : Transition<StateEnum::ExpectingFinished>;\n                      return actions(\n                          MutateState([handshakeReadRecordLayer =\n                                           std::move(handshakeReadRecordLayer)](\n                                          State& newState) mutable {\n                            newState.readRecordLayer() =\n                                std::move(handshakeReadRecordLayer);\n                          }),\n                          std::move(saveState),\n                          std::move(handshakeReadSecretAvailable),\n                          std::move(handshakeWriteSecretAvailable),\n                          std::move(appWriteSecretAvailable),\n                          std::move(serverFlight),\n                          MutateState(transition));\n                    }\n                  });\n            });\n      });\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingEarlyData, Event::AppData>::\n    handle(const State&, Param param) {\n  auto& appData = *param.asAppData();\n\n  return actions(DeliverAppData{std::move(appData.data)});\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingEarlyData, Event::AppWrite>::\n    handle(const State& state, Param param) {\n  auto& appWrite = *param.asAppWrite();\n\n  WriteToSocket write;\n  write.callback = appWrite.callback;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAppData(\n      std::move(appWrite.data), appWrite.aeadOptions));\n  write.flags = appWrite.flags;\n\n  return actions(std::move(write));\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::EndOfEarlyData>::handle(const State& state, Param param) {\n  auto& eoed = *param.asEndOfEarlyData();\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after eoed\", AlertDescription::unexpected_message);\n  }\n\n  state.handshakeContext()->appendToTranscript(*eoed.originalEncoding);\n\n  auto readRecordLayer = std::move(state.handshakeReadRecordLayer());\n\n  return actions(\n      MutateState([readRecordLayer =\n                       std::move(readRecordLayer)](State& newState) mutable {\n        newState.readRecordLayer() = std::move(readRecordLayer);\n      }),\n      MutateState(&Transition<StateEnum::ExpectingFinished>));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingFinished, Event::AppWrite>::\n    handle(const State& state, Param param) {\n  auto& appWrite = *param.asAppWrite();\n\n  WriteToSocket write;\n  write.callback = appWrite.callback;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAppData(\n      std::move(appWrite.data), appWrite.aeadOptions));\n  write.flags = appWrite.flags;\n\n  return actions(std::move(write));\n}\n\nstatic WriteToSocket writeNewSessionTicket(\n    const FizzServerContext& context,\n    const WriteRecordLayer& recordLayer,\n    std::chrono::seconds ticketLifetime,\n    uint32_t ticketAgeAdd,\n    Buf nonce,\n    Buf ticket,\n    ProtocolVersion version) {\n  NewSessionTicket nst;\n  nst.ticket_lifetime = ticketLifetime.count();\n  nst.ticket_age_add = ticketAgeAdd;\n  nst.ticket_nonce = std::move(nonce);\n  nst.ticket = std::move(ticket);\n\n  if (context.getAcceptEarlyData(version)) {\n    TicketEarlyData early;\n    early.max_early_data_size = context.getMaxEarlyDataSize();\n    nst.extensions.push_back(encodeExtension(std::move(early)));\n  }\n\n  auto encodedNst = encodeHandshake(std::move(nst));\n  WriteToSocket nstWrite;\n  nstWrite.contents.emplace_back(\n      recordLayer.writeHandshake(std::move(encodedNst)));\n  return nstWrite;\n}\n\nstatic SemiFuture<Optional<WriteToSocket>> generateTicket(\n    const State& state,\n    const std::vector<uint8_t>& resumptionMasterSecret,\n    Buf appToken = nullptr) {\n  auto ticketCipher = state.context()->getTicketCipher();\n\n  if (!ticketCipher || *state.pskType() == PskType::NotSupported) {\n    return folly::none;\n  }\n\n  Buf resumptionSecret;\n  auto ticketNonce = folly::IOBuf::create(0);\n  resumptionSecret = state.keyScheduler()->getResumptionSecret(\n      folly::range(resumptionMasterSecret), ticketNonce->coalesce());\n\n  ResumptionState resState;\n  resState.version = *state.version();\n  resState.cipher = *state.cipher();\n  resState.resumptionSecret = std::move(resumptionSecret);\n  resState.serverCert = state.serverCert();\n  resState.clientCert = state.clientCert();\n  resState.alpn = state.alpn();\n  resState.ticketAgeAdd = state.context()->getFactory()->makeTicketAgeAdd();\n  resState.ticketIssueTime = state.context()->getClock().getCurrentTime();\n  resState.appToken = std::move(appToken);\n  resState.handshakeTime = *state.handshakeTime();\n\n  auto ticketFuture = ticketCipher->encrypt(std::move(resState));\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(ticketFuture),\n      [&state,\n       ticketAgeAdd = resState.ticketAgeAdd,\n       ticketNonce = std::move(ticketNonce)](\n          Optional<std::pair<Buf, std::chrono::seconds>> ticket) mutable\n      -> Optional<WriteToSocket> {\n        if (!ticket) {\n          return folly::none;\n        }\n        return writeNewSessionTicket(\n            *state.context(),\n            *state.writeRecordLayer(),\n            ticket->second,\n            ticketAgeAdd,\n            std::move(ticketNonce),\n            std::move(ticket->first),\n            *state.version());\n      });\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingCertificate, Event::Certificate>::\n    handle(const State& state, Param param) {\n  auto certMsg = std::move(*param.asCertificateMsg());\n\n  state.handshakeContext()->appendToTranscript(*certMsg.originalEncoding);\n\n  if (!certMsg.certificate_request_context->empty()) {\n    throw FizzException(\n        \"certificate request context must be empty\",\n        AlertDescription::illegal_parameter);\n  }\n\n  std::vector<std::shared_ptr<const PeerCert>> clientCerts;\n  bool leaf = true;\n  for (auto& certEntry : certMsg.certificate_list) {\n    // We don't request any extensions, so this ought to be empty\n    if (!certEntry.extensions.empty()) {\n      throw FizzException(\n          \"certificate extensions must be empty\",\n          AlertDescription::illegal_parameter);\n    }\n\n    clientCerts.emplace_back(state.context()->getFactory()->makePeerCert(\n        std::move(certEntry), leaf));\n    leaf = false;\n  }\n\n  if (clientCerts.empty()) {\n    if (state.context()->getClientAuthMode() == ClientAuthMode::Optional) {\n      VLOG(6) << \"Client authentication not sent\";\n      return actions(\n          MutateState([](State& newState) {\n            newState.unverifiedCertChain() = folly::none;\n          }),\n          MutateState(&Transition<StateEnum::ExpectingFinished>));\n    } else {\n      throw FizzException(\n          \"certificate requested but none received\",\n          AlertDescription::certificate_required);\n    }\n  } else {\n    return actions(\n        MutateState([certs = std::move(clientCerts)](State& newState) mutable {\n          newState.unverifiedCertChain() = std::move(certs);\n        }),\n        MutateState(&Transition<StateEnum::ExpectingCertificateVerify>));\n  }\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::ExpectingCertificateVerify,\n    Event::CertificateVerify>::handle(const State& state, Param param) {\n  auto certVerify = std::move(*param.asCertificateVerify());\n\n  if (std::find(\n          state.context()->getSupportedSigSchemes().begin(),\n          state.context()->getSupportedSigSchemes().end(),\n          certVerify.algorithm) ==\n      state.context()->getSupportedSigSchemes().end()) {\n    throw FizzException(\n        folly::to<std::string>(\n            \"client chose unsupported sig scheme: \",\n            toString(certVerify.algorithm)),\n        AlertDescription::handshake_failure);\n  }\n\n  const auto& certs = *state.unverifiedCertChain();\n  auto leafCert = certs.front();\n  leafCert->verify(\n      certVerify.algorithm,\n      CertificateVerifyContext::Client,\n      state.handshakeContext()->getHandshakeContext()->coalesce(),\n      certVerify.signature->coalesce());\n\n  std::shared_ptr<const Cert> newCert;\n\n  try {\n    const auto& verifier = state.context()->getClientCertVerifier();\n    if (verifier) {\n      if (auto verifiedCert = verifier->verify(certs)) {\n        newCert = std::move(verifiedCert);\n      } else {\n        newCert = std::move(leafCert);\n      }\n    } else {\n      newCert = std::move(leafCert);\n    }\n  } catch (const FizzException&) {\n    throw;\n  } catch (const std::exception& e) {\n    throw FizzVerificationException(\n        folly::to<std::string>(\"client certificate failure: \", e.what()),\n        AlertDescription::bad_certificate);\n  }\n\n  state.handshakeContext()->appendToTranscript(*certVerify.originalEncoding);\n\n  return actions(\n      MutateState([cert = std::move(newCert)](State& newState) {\n        newState.unverifiedCertChain() = folly::none;\n        newState.clientCert() = std::move(cert);\n      }),\n      MutateState(&Transition<StateEnum::ExpectingFinished>));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingFinished, Event::Finished>::\n    handle(const State& state, Param param) {\n  auto& finished = *param.asFinished();\n\n  auto expectedFinished = state.handshakeContext()->getFinishedData(\n      state.clientHandshakeSecret()->coalesce());\n  if (!CryptoUtils::equal(\n          expectedFinished->coalesce(), finished.verify_data->coalesce())) {\n    throw FizzException(\"client finished verify failure\", folly::none);\n  }\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\"data after finished\", folly::none);\n  }\n\n  auto readRecordLayer =\n      state.context()->getFactory()->makeEncryptedReadRecordLayer(\n          EncryptionLevel::AppTraffic);\n  readRecordLayer->setProtocolVersion(*state.version());\n  auto readSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ClientAppTraffic);\n  Protocol::setAead(\n      *readRecordLayer,\n      *state.cipher(),\n      folly::range(readSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  state.handshakeContext()->appendToTranscript(*finished.originalEncoding);\n\n  auto resumptionMasterSecret =\n      state.keyScheduler()\n          ->getSecret(\n              MasterSecrets::ResumptionMaster,\n              state.handshakeContext()->getHandshakeContext()->coalesce())\n          .secret;\n  state.keyScheduler()->clearMasterSecret();\n\n  MutateState saveState([readRecordLayer = std::move(readRecordLayer),\n                         resumptionMasterSecret](State& newState) mutable {\n    newState.readRecordLayer() = std::move(readRecordLayer);\n    newState.resumptionMasterSecret() = std::move(resumptionMasterSecret);\n  });\n\n  SecretAvailable appReadTrafficSecretAvailable(std::move(readSecret));\n\n  if (!state.context()->getSendNewSessionTicket()) {\n    return actions(\n        std::move(saveState),\n        std::move(appReadTrafficSecretAvailable),\n        MutateState(&Transition<StateEnum::AcceptingData>),\n        ReportHandshakeSuccess());\n  } else {\n    auto ticketFuture = generateTicket(state, resumptionMasterSecret);\n    return runOnCallerIfComplete(\n        state.executor(),\n        std::move(ticketFuture),\n        [saveState = std::move(saveState),\n         appReadTrafficSecretAvailable =\n             std::move(appReadTrafficSecretAvailable)](\n            Optional<WriteToSocket> nstWrite) mutable {\n          if (!nstWrite) {\n            return actions(\n                std::move(saveState),\n                MutateState(&Transition<StateEnum::AcceptingData>),\n                std::move(appReadTrafficSecretAvailable),\n                ReportHandshakeSuccess());\n          }\n\n          return actions(\n              std::move(saveState),\n              MutateState(&Transition<StateEnum::AcceptingData>),\n              std::move(appReadTrafficSecretAvailable),\n              std::move(*nstWrite),\n              ReportHandshakeSuccess());\n        });\n  }\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::WriteNewSessionTicket>::handle(const State& state, Param param) {\n  auto& writeNewSessionTicket = *param.asWriteNewSessionTicket();\n  auto ticketFuture = generateTicket(\n      state,\n      state.resumptionMasterSecret(),\n      std::move(writeNewSessionTicket.appToken));\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(ticketFuture),\n      [](Optional<WriteToSocket> nstWrite) {\n        if (!nstWrite) {\n          return Actions();\n        }\n        return actions(std::move(*nstWrite));\n      });\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::AppData>::handle(\n    const State& /*state*/,\n    Param param) {\n  auto& appData = *param.asAppData();\n\n  return actions(DeliverAppData{std::move(appData.data)});\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::AppWrite>::handle(\n    const State& state,\n    Param param) {\n  auto& appWrite = *param.asAppWrite();\n\n  WriteToSocket write;\n  write.callback = appWrite.callback;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAppData(\n      std::move(appWrite.data), appWrite.aeadOptions));\n  write.flags = appWrite.flags;\n\n  return actions(std::move(write));\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::KeyUpdateInitiation>::handle(const State& state, Param param) {\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\"data after key_update\", folly::none);\n  }\n  auto& keyUpdateInitiation = *param.asKeyUpdateInitiation();\n  auto encodedKeyUpdated =\n      Protocol::getKeyUpdated(keyUpdateInitiation.request_update);\n  WriteToSocket write;\n  write.contents.emplace_back(\n      state.writeRecordLayer()->writeHandshake(std::move(encodedKeyUpdated)));\n\n  state.keyScheduler()->serverKeyUpdate();\n\n  auto writeRecordLayer =\n      state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n          EncryptionLevel::AppTraffic);\n  writeRecordLayer->setProtocolVersion(*state.version());\n  auto writeSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ServerAppTraffic);\n  Protocol::setAead(\n      *writeRecordLayer,\n      *state.cipher(),\n      folly::range(writeSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  return actions(\n      MutateState([wRecordLayer =\n                       std::move(writeRecordLayer)](State& newState) mutable {\n        newState.writeRecordLayer() = std::move(wRecordLayer);\n      }),\n      SecretAvailable(std::move(writeSecret)),\n      std::move(write));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::KeyUpdate>::handle(\n    const State& state,\n    Param param) {\n  auto& keyUpdate = *param.asKeyUpdate();\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\"data after key_update\", folly::none);\n  }\n\n  state.keyScheduler()->clientKeyUpdate();\n  auto readRecordLayer =\n      state.context()->getFactory()->makeEncryptedReadRecordLayer(\n          EncryptionLevel::AppTraffic);\n  readRecordLayer->setProtocolVersion(*state.version());\n  auto readSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ClientAppTraffic);\n  Protocol::setAead(\n      *readRecordLayer,\n      *state.cipher(),\n      folly::range(readSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  if (keyUpdate.request_update == KeyUpdateRequest::update_not_requested) {\n    return actions(\n        MutateState([rRecordLayer =\n                         std::move(readRecordLayer)](State& newState) mutable {\n          newState.readRecordLayer() = std::move(rRecordLayer);\n        }),\n        SecretAvailable(std::move(readSecret)));\n  }\n\n  auto encodedKeyUpdated =\n      Protocol::getKeyUpdated(KeyUpdateRequest::update_not_requested);\n  WriteToSocket write;\n  write.contents.emplace_back(\n      state.writeRecordLayer()->writeHandshake(std::move(encodedKeyUpdated)));\n\n  state.keyScheduler()->serverKeyUpdate();\n\n  auto writeRecordLayer =\n      state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n          EncryptionLevel::AppTraffic);\n  writeRecordLayer->setProtocolVersion(*state.version());\n  auto writeSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ServerAppTraffic);\n  Protocol::setAead(\n      *writeRecordLayer,\n      *state.cipher(),\n      folly::range(writeSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  return actions(\n      MutateState([rRecordLayer = std::move(readRecordLayer),\n                   wRecordLayer =\n                       std::move(writeRecordLayer)](State& newState) mutable {\n        newState.readRecordLayer() = std::move(rRecordLayer);\n        newState.writeRecordLayer() = std::move(wRecordLayer);\n      }),\n      SecretAvailable(std::move(writeSecret)),\n      SecretAvailable(std::move(readSecret)),\n      std::move(write));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::CloseNotify>::handle(\n    const State& state,\n    Param param) {\n  ensureNoUnparsedHandshakeData(state, Event::CloseNotify);\n  auto& closenotify = *param.asCloseNotify();\n  auto eod = EndOfData(std::move(closenotify.ignoredPostCloseData));\n\n  MutateState clearRecordLayers([](State& newState) {\n    newState.writeRecordLayer() = nullptr;\n    newState.readRecordLayer() = nullptr;\n  });\n\n  WriteToSocket write;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAlert(\n      Alert(AlertDescription::close_notify)));\n  return actions(\n      std::move(write),\n      std::move(clearRecordLayers),\n      MutateState(&Transition<StateEnum::Closed>),\n      std::move(eod));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingCloseNotify, Event::CloseNotify>::\n    handle(const State& state, Param param) {\n  ensureNoUnparsedHandshakeData(state, Event::CloseNotify);\n  auto& closenotify = *param.asCloseNotify();\n  auto eod = EndOfData(std::move(closenotify.ignoredPostCloseData));\n\n  MutateState clearRecordLayers([](State& newState) {\n    newState.readRecordLayer() = nullptr;\n    newState.writeRecordLayer() = nullptr;\n  });\n  return actions(\n      std::move(clearRecordLayers),\n      MutateState(&Transition<StateEnum::Closed>),\n      std::move(eod));\n}\n\n} // namespace sm\n} // namespace fizz\n"], "fixing_code": ["/*\n *  Copyright (c) 2018-present, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n#include <fizz/crypto/Utils.h>\n#include <fizz/crypto/exchange/AsyncKeyExchange.h>\n#include <fizz/protocol/CertificateVerifier.h>\n#include <fizz/protocol/Protocol.h>\n#include <fizz/protocol/StateMachine.h>\n#include <fizz/protocol/ech/Decrypter.h>\n#include <fizz/record/Extensions.h>\n#include <fizz/record/PlaintextRecordLayer.h>\n#include <fizz/server/AsyncSelfCert.h>\n#include <fizz/server/Negotiator.h>\n#include <fizz/server/ReplayCache.h>\n#include <fizz/server/ServerProtocol.h>\n#include <fizz/util/Workarounds.h>\n#include <folly/Overload.h>\n#include <folly/tracing/StaticTracepoint.h>\n#include <algorithm>\n\nusing folly::Optional;\nusing folly::SemiFuture;\n\nusing namespace fizz::server;\nusing namespace fizz::server::detail;\n\n// We only ever use the first PSK sent.\nstatic constexpr uint16_t kPskIndex = 0;\n\nnamespace fizz {\nnamespace sm {\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::Uninitialized,\n    Event::Accept,\n    StateEnum::ExpectingClientHello);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingClientHello,\n    Event::ClientHello,\n    StateEnum::ExpectingClientHello,\n    StateEnum::ExpectingCertificate,\n    StateEnum::ExpectingFinished,\n    StateEnum::AcceptingEarlyData,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::AppData,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::AppWrite,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::EndOfEarlyData,\n    StateEnum::ExpectingFinished);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingCertificate,\n    Event::Certificate,\n    StateEnum::ExpectingCertificateVerify,\n    StateEnum::ExpectingFinished)\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingCertificateVerify,\n    Event::CertificateVerify,\n    StateEnum::ExpectingFinished);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingFinished,\n    Event::AppWrite,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingFinished,\n    Event::Finished,\n    StateEnum::AcceptingData);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::WriteNewSessionTicket,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::AppData,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::AppWrite,\n    StateEnum::Error);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::KeyUpdateInitiation,\n    StateEnum::AcceptingData);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::KeyUpdate,\n    StateEnum::AcceptingData);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::CloseNotify,\n    StateEnum::Closed);\n\nFIZZ_DECLARE_EVENT_HANDLER(\n    ServerTypes,\n    StateEnum::ExpectingCloseNotify,\n    Event::CloseNotify,\n    StateEnum::Closed);\n} // namespace sm\n\nnamespace server {\n\nAsyncActions ServerStateMachine::processAccept(\n    const State& state,\n    folly::Executor* executor,\n    std::shared_ptr<const FizzServerContext> context,\n    const std::shared_ptr<ServerExtensions>& extensions) {\n  Accept accept;\n  accept.executor = executor;\n  accept.context = std::move(context);\n  accept.extensions = extensions;\n  return detail::processEvent(state, std::move(accept));\n}\n\nAsyncActions ServerStateMachine::processSocketData(\n    const State& state,\n    folly::IOBufQueue& buf,\n    Aead::AeadOptions options) {\n  try {\n    if (!state.readRecordLayer()) {\n      return detail::handleError(\n          state,\n          ReportError(\"attempting to process data without record layer\"),\n          folly::none);\n    }\n    auto param = state.readRecordLayer()->readEvent(buf, std::move(options));\n    if (!param.has_value()) {\n      return actions(WaitForData{param.sizeHint});\n    }\n    return detail::processEvent(state, std::move(*param));\n  } catch (const FizzException& e) {\n    return detail::handleError(\n        state,\n        ReportError(folly::exception_wrapper(std::current_exception())),\n        e.getAlert());\n  } catch (...) {\n    return detail::handleError(\n        state,\n        ReportError(folly::make_exception_wrapper<FizzException>(\n            folly::to<std::string>(\n                \"error decoding record in state \",\n                toString(state.state()),\n                \": \",\n                folly::exceptionStr(std::current_exception())),\n            AlertDescription::decode_error)),\n        AlertDescription::decode_error);\n  }\n}\n\nAsyncActions ServerStateMachine::processWriteNewSessionTicket(\n    const State& state,\n    WriteNewSessionTicket write) {\n  return detail::processEvent(state, std::move(write));\n}\n\nAsyncActions ServerStateMachine::processAppWrite(\n    const State& state,\n    AppWrite write) {\n  return detail::processEvent(state, std::move(write));\n}\n\nAsyncActions ServerStateMachine::processEarlyAppWrite(\n    const State& state,\n    EarlyAppWrite write) {\n  return detail::processEvent(state, std::move(write));\n}\n\nActions ServerStateMachine::processAppClose(const State& state) {\n  return detail::handleAppClose(state);\n}\n\nActions ServerStateMachine::processAppCloseImmediate(const State& state) {\n  return detail::handleAppCloseImmediate(state);\n}\n\nAsyncActions ServerStateMachine::processKeyUpdateInitiation(\n    const State& state,\n    KeyUpdateInitiation keyUpdateInitiation) {\n  return detail::processEvent(state, std::move(keyUpdateInitiation));\n}\n\nnamespace detail {\n\nAsyncActions processEvent(const State& state, Param param) {\n  auto event = EventVisitor()(param);\n  // We can have an exception directly in the handler or in a future so we need\n  // to handle both types.\n  try {\n    auto actions = sm::StateMachine<ServerTypes>::getHandler(\n        state.state(), event)(state, std::move(param));\n\n    return folly::variant_match(\n        actions,\n        ::fizz::detail::result_type<AsyncActions>(),\n        [&state](SemiFuture<Actions>& futureActions) -> AsyncActions {\n          if (futureActions.isReady()) {\n            // any exception thrown by get will be caught below\n            return std::move(futureActions).get();\n          }\n          return std::move(futureActions)\n              .deferError([&state](folly::exception_wrapper ew) {\n                auto ex = ew.get_exception<FizzException>();\n                if (ex) {\n                  return detail::handleError(\n                      state, ReportError(std::move(ew)), ex->getAlert());\n                }\n                return detail::handleError(\n                    state,\n                    ReportError(std::move(ew)),\n                    AlertDescription::unexpected_message);\n              });\n        },\n        [](Actions& immediateActions) -> AsyncActions {\n          return std::move(immediateActions);\n        });\n  } catch (const FizzException& e) {\n    return detail::handleError(\n        state,\n        ReportError(folly::exception_wrapper(std::current_exception())),\n        e.getAlert());\n  } catch (...) {\n    return detail::handleError(\n        state,\n        ReportError(folly::exception_wrapper(std::current_exception())),\n        AlertDescription::unexpected_message);\n  }\n}\n\nActions handleError(\n    const State& state,\n    ReportError error,\n    Optional<AlertDescription> alertDesc) {\n  if (state.state() == StateEnum::Error) {\n    return Actions();\n  }\n  MutateState transition([](State& newState) {\n    newState.state() = StateEnum::Error;\n    newState.writeRecordLayer() = nullptr;\n    newState.readRecordLayer() = nullptr;\n  });\n  if (alertDesc && state.writeRecordLayer()) {\n    Alert alert(*alertDesc);\n    WriteToSocket write;\n    write.contents.emplace_back(\n        state.writeRecordLayer()->writeAlert(std::move(alert)));\n    return actions(std::move(transition), std::move(write), std::move(error));\n  } else {\n    return actions(std::move(transition), std::move(error));\n  }\n}\n\nActions handleAppCloseImmediate(const State& state) {\n  MutateState transition([](State& newState) {\n    newState.state() = StateEnum::Closed;\n    newState.readRecordLayer() = nullptr;\n    newState.writeRecordLayer() = nullptr;\n  });\n\n  if (state.writeRecordLayer()) {\n    Alert alert(AlertDescription::close_notify);\n    WriteToSocket write;\n    write.contents.emplace_back(\n        state.writeRecordLayer()->writeAlert(std::move(alert)));\n    return actions(std::move(transition), std::move(write));\n  } else {\n    return actions(std::move(transition));\n  }\n}\n\nActions handleAppClose(const State& state) {\n  if (state.writeRecordLayer()) {\n    MutateState transition([](State& newState) {\n      newState.state() = StateEnum::ExpectingCloseNotify;\n      newState.writeRecordLayer() = nullptr;\n    });\n\n    Alert alert(AlertDescription::close_notify);\n    WriteToSocket write;\n    write.contents.emplace_back(\n        state.writeRecordLayer()->writeAlert(std::move(alert)));\n    return actions(std::move(transition), std::move(write));\n  } else {\n    MutateState transition([](State& newState) {\n      newState.state() = StateEnum::Closed;\n      newState.writeRecordLayer() = nullptr;\n      newState.readRecordLayer() = nullptr;\n    });\n    return actions(std::move(transition));\n  }\n}\n\nActions handleInvalidEvent(const State& state, Event event, Param param) {\n  if (event == Event::Alert) {\n    auto& alert = *param.asAlert();\n    throw FizzException(\n        folly::to<std::string>(\n            \"received alert: \",\n            toString(alert.description),\n            \", in state \",\n            toString(state.state())),\n        folly::none);\n  } else {\n    throw FizzException(\n        folly::to<std::string>(\n            \"invalid event: \",\n            toString(event),\n            \", in state \",\n            toString(state.state())),\n        AlertDescription::unexpected_message);\n  }\n}\n\ntemplate <typename T, typename F>\nSemiFuture<\n    typename folly::futures::detail::valueCallableResult<T, F>::value_type>\nrunOnCallerIfComplete(\n    folly::Executor* executor,\n    SemiFuture<T> future,\n    F&& func) {\n  if (future.isReady()) {\n    return func(std::move(future).get());\n  } else {\n    return std::move(future)\n        .via(executor)\n        .thenValueInline(std::forward<F>(func))\n        .semi();\n  }\n}\n\n} // namespace detail\n} // namespace server\n\nnamespace sm {\n\nstatic void ensureNoUnparsedHandshakeData(const State& state, Event event) {\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        folly::to<std::string>(\n            \"unprocessed handshake data while handling event \",\n            toString(event),\n            \" in state \",\n            toString(state.state())),\n        AlertDescription::unexpected_message);\n  }\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::Uninitialized, Event::Accept>::handle(\n    const State& /*state*/,\n    Param param) {\n  auto& accept = *param.asAccept();\n  auto factory = accept.context->getFactory();\n  auto readRecordLayer = factory->makePlaintextReadRecordLayer();\n  auto writeRecordLayer = factory->makePlaintextWriteRecordLayer();\n  auto handshakeLogging = std::make_unique<HandshakeLogging>();\n  return actions(\n      MutateState([executor = accept.executor,\n                   rrl = std::move(readRecordLayer),\n                   wrl = std::move(writeRecordLayer),\n                   context = std::move(accept.context),\n                   handshakeLogging = std::move(handshakeLogging),\n                   extensions = accept.extensions](State& newState) mutable {\n        newState.executor() = executor;\n        newState.context() = std::move(context);\n        newState.readRecordLayer() = std::move(rrl);\n        newState.writeRecordLayer() = std::move(wrl);\n        newState.handshakeLogging() = std::move(handshakeLogging);\n        newState.extensions() = std::move(extensions);\n      }),\n      MutateState(&Transition<StateEnum::ExpectingClientHello>));\n}\n\nstatic void addHandshakeLogging(const State& state, const ClientHello& chlo) {\n  auto logging = state.handshakeLogging();\n  if (!logging) {\n    return;\n  }\n  logging->populateFromClientHello(chlo);\n  auto plaintextReadRecord =\n      dynamic_cast<PlaintextReadRecordLayer*>(state.readRecordLayer());\n  if (plaintextReadRecord) {\n    logging->clientRecordVersion =\n        plaintextReadRecord->getReceivedRecordVersion();\n  }\n}\n\nstatic void validateClientHello(const ClientHello& chlo) {\n  if (chlo.legacy_compression_methods.size() != 1 ||\n      chlo.legacy_compression_methods.front() != 0x00) {\n    throw FizzException(\n        \"client compression methods not exactly NULL\",\n        AlertDescription::illegal_parameter);\n  }\n  Protocol::checkDuplicateExtensions(chlo.extensions);\n}\n\nstatic Optional<ProtocolVersion> negotiateVersion(\n    const ClientHello& chlo,\n    const std::vector<ProtocolVersion>& versions) {\n  const auto& clientVersions = getExtension<SupportedVersions>(chlo.extensions);\n  if (!clientVersions) {\n    return folly::none;\n  }\n  auto version = negotiate(versions, clientVersions->versions);\n  if (!version) {\n    return folly::none;\n  }\n  return version;\n}\n\nstatic Optional<CookieState> getCookieState(\n    const ClientHello& chlo,\n    const CookieCipher* cookieCipher) {\n  auto cookieExt = getExtension<Cookie>(chlo.extensions);\n  if (!cookieExt) {\n    return folly::none;\n  }\n\n  // If the client sent a cookie we can't use we have to consider it a fatal\n  // error since we can't reconstruct the handshake transcript.\n  if (!cookieCipher) {\n    throw FizzException(\n        \"no cookie cipher\", AlertDescription::unsupported_extension);\n  }\n\n  auto cookieState = cookieCipher->decrypt(std::move(cookieExt->cookie));\n\n  if (!cookieState) {\n    throw FizzException(\n        \"could not decrypt cookie\", AlertDescription::decrypt_error);\n  }\n\n  if (cookieState->echCipherSuite.has_value() ^\n      cookieState->echConfigId.has_value()) {\n    throw FizzException(\n        \"cookie has incomplete ech params\", AlertDescription::internal_error);\n  }\n\n  return cookieState;\n}\n\nstatic void verifyCookieState(\n    Optional<CookieState>& cookieState,\n    ProtocolVersion version,\n    CipherSuite cipher) {\n  if (!cookieState) {\n    return;\n  }\n  if (cookieState->version != version) {\n    throw FizzException(\n        \"version mismatch with cookie\", AlertDescription::protocol_version);\n  }\n\n  if (cookieState->cipher != cipher) {\n    throw FizzException(\n        \"cipher mismatch with cookie\", AlertDescription::handshake_failure);\n  }\n}\n\nnamespace {\nstruct ResumptionStateResult {\n  explicit ResumptionStateResult(\n      SemiFuture<std::pair<PskType, Optional<ResumptionState>>>\n          futureResStateArg,\n      Optional<PskKeyExchangeMode> pskModeArg = folly::none,\n      Optional<uint32_t> obfuscatedAgeArg = folly::none)\n      : futureResState(std::move(futureResStateArg)),\n        pskMode(std::move(pskModeArg)),\n        obfuscatedAge(std::move(obfuscatedAgeArg)) {}\n\n  SemiFuture<std::pair<PskType, Optional<ResumptionState>>> futureResState;\n  Optional<PskKeyExchangeMode> pskMode;\n  Optional<uint32_t> obfuscatedAge;\n};\n} // namespace\n\nstatic ResumptionStateResult getResumptionState(\n    const ClientHello& chlo,\n    const TicketCipher* ticketCipher,\n    const std::vector<PskKeyExchangeMode>& supportedModes) {\n  auto psks = getExtension<ClientPresharedKey>(chlo.extensions);\n  auto clientModes = getExtension<PskKeyExchangeModes>(chlo.extensions);\n  if (psks && !clientModes) {\n    throw FizzException(\"no psk modes\", AlertDescription::missing_extension);\n  }\n\n  Optional<PskKeyExchangeMode> pskMode;\n  if (clientModes) {\n    pskMode = negotiate(supportedModes, clientModes->modes);\n  }\n  if (!psks && !pskMode) {\n    FOLLY_SDT(fizz, session_cache_NotSupported);\n    return ResumptionStateResult(\n        std::make_pair(PskType::NotSupported, folly::none));\n  } else if (!psks || psks->identities.size() <= kPskIndex) {\n    FOLLY_SDT(fizz, session_cache_NotAttempted);\n    return ResumptionStateResult(\n        std::make_pair(PskType::NotAttempted, folly::none));\n  } else if (!ticketCipher) {\n    FOLLY_SDT(fizz, session_cache_NoTicketCipher);\n    VLOG(8) << \"No ticket cipher, rejecting PSK.\";\n    return ResumptionStateResult(\n        std::make_pair(PskType::Rejected, folly::none));\n  } else if (!pskMode) {\n    FOLLY_SDT(fizz, session_cache_PskModeMismatch);\n    VLOG(8) << \"No psk mode match, rejecting PSK.\";\n    return ResumptionStateResult(\n        std::make_pair(PskType::Rejected, folly::none));\n  } else {\n    FOLLY_SDT(fizz, session_cache_ResumptionSuccess);\n    const auto& ident = psks->identities[kPskIndex].psk_identity;\n    return ResumptionStateResult(\n        ticketCipher->decrypt(ident->clone()),\n        pskMode,\n        psks->identities[kPskIndex].obfuscated_ticket_age);\n  }\n}\n\nstatic SemiFuture<ReplayCacheResult> getReplayCacheResult(\n    const ClientHello& chlo,\n    bool zeroRttEnabled,\n    ReplayCache* replayCache) {\n  if (!zeroRttEnabled || !replayCache ||\n      !getExtension<ClientEarlyData>(chlo.extensions)) {\n    FOLLY_SDT(fizz, replay_cache_NotChecked);\n    return ReplayCacheResult::NotChecked;\n  }\n  auto randBuf = folly::IOBuf::copyBuffer(chlo.random, chlo.random.size());\n  return replayCache->check(std::move(randBuf));\n}\n\nstatic bool validateResumptionState(\n    const ResumptionState& resState,\n    PskKeyExchangeMode /* mode */,\n    ProtocolVersion version,\n    CipherSuite cipher) {\n  if (resState.version != version) {\n    FOLLY_SDT(fizz, resumption_state_ProtocolVersionMismatch);\n    VLOG(8) << \"Protocol version mismatch, rejecting PSK.\";\n    return false;\n  }\n\n  if (getHashFunction(resState.cipher) != getHashFunction(cipher)) {\n    FOLLY_SDT(fizz, resumption_state_HashFunctionMismatch);\n    VLOG(8) << \"Hash mismatch, rejecting PSK.\";\n    return false;\n  }\n\n  return true;\n}\n\nstatic CipherSuite negotiateCipher(\n    const ClientHello& chlo,\n    const std::vector<std::vector<CipherSuite>>& supportedCiphers) {\n  auto cipher = negotiate(supportedCiphers, chlo.cipher_suites);\n  if (!cipher) {\n    throw FizzException(\"no cipher match\", AlertDescription::handshake_failure);\n  }\n  return *cipher;\n}\n\n/*\n * Sets up a KeyScheduler and HandshakeContext for the connection. The\n * KeyScheduler will have the early secret derived if applicable, and the\n * ClientHello will be added to the HandshakeContext. This also verifies the\n * PSK binder if applicable.\n *\n * If the passed in handshakeContext is non-null it is used instead of a new\n * context. This is used after a HelloRetryRequest when there is already a\n * handshake transcript before the current ClientHello.\n */\nstatic std::\n    pair<std::unique_ptr<KeyScheduler>, std::unique_ptr<HandshakeContext>>\n    setupSchedulerAndContext(\n        const Factory& factory,\n        CipherSuite cipher,\n        const ClientHello& chlo,\n        const Optional<ResumptionState>& resState,\n        const Optional<CookieState>& cookieState,\n        PskType pskType,\n        std::unique_ptr<HandshakeContext> handshakeContext,\n        ProtocolVersion /*version*/) {\n  auto scheduler = factory.makeKeyScheduler(cipher);\n\n  if (cookieState) {\n    handshakeContext = factory.makeHandshakeContext(cipher);\n\n    message_hash chloHash;\n    chloHash.hash = cookieState->chloHash->clone();\n    handshakeContext->appendToTranscript(encodeHandshake(std::move(chloHash)));\n\n    auto cookie = getExtension<Cookie>(chlo.extensions);\n    handshakeContext->appendToTranscript(getStatelessHelloRetryRequest(\n        cookieState->version,\n        cookieState->cipher,\n        cookieState->group,\n        std::move(cookie->cookie)));\n  } else if (!handshakeContext) {\n    handshakeContext = factory.makeHandshakeContext(cipher);\n  }\n\n  if (resState) {\n    scheduler->deriveEarlySecret(resState->resumptionSecret->coalesce());\n\n    auto binderKey = scheduler\n                         ->getSecret(\n                             pskType == PskType::External\n                                 ? EarlySecrets::ExternalPskBinder\n                                 : EarlySecrets::ResumptionPskBinder,\n                             handshakeContext->getBlankContext())\n                         .secret;\n\n    folly::IOBufQueue chloQueue(folly::IOBufQueue::cacheChainLength());\n    chloQueue.append((*chlo.originalEncoding)->clone());\n    auto chloPrefix =\n        chloQueue.split(chloQueue.chainLength() - getBinderLength(chlo));\n    handshakeContext->appendToTranscript(chloPrefix);\n\n    const auto& psks = getExtension<ClientPresharedKey>(chlo.extensions);\n    if (!psks || psks->binders.size() <= kPskIndex) {\n      throw FizzException(\"no binders\", AlertDescription::illegal_parameter);\n    }\n    auto expectedBinder =\n        handshakeContext->getFinishedData(folly::range(binderKey));\n    if (!CryptoUtils::equal(\n            expectedBinder->coalesce(),\n            psks->binders[kPskIndex].binder->coalesce())) {\n      throw FizzException(\n          \"binder does not match\", AlertDescription::bad_record_mac);\n    }\n\n    handshakeContext->appendToTranscript(chloQueue.move());\n    return std::make_pair(std::move(scheduler), std::move(handshakeContext));\n  } else {\n    handshakeContext->appendToTranscript(*chlo.originalEncoding);\n    return std::make_pair(std::move(scheduler), std::move(handshakeContext));\n  }\n}\n\nstatic void validateGroups(const std::vector<KeyShareEntry>& client_shares) {\n  std::set<NamedGroup> setOfNamedGroups;\n\n  for (const auto& share : client_shares) {\n    if (setOfNamedGroups.find(share.group) != setOfNamedGroups.end()) {\n      throw FizzException(\n          \"duplicate client key share\", AlertDescription::illegal_parameter);\n    }\n\n    setOfNamedGroups.insert(share.group);\n  }\n}\n\nstatic std::tuple<NamedGroup, Optional<Buf>> negotiateGroup(\n    ProtocolVersion version,\n    const ClientHello& chlo,\n    const std::vector<NamedGroup>& supportedGroups) {\n  auto groups = getExtension<SupportedGroups>(chlo.extensions);\n  if (!groups) {\n    throw FizzException(\"no named groups\", AlertDescription::missing_extension);\n  }\n  auto group = negotiate(supportedGroups, groups->named_group_list);\n  if (!group) {\n    throw FizzException(\"no group match\", AlertDescription::handshake_failure);\n  }\n  auto clientShares = getExtension<ClientKeyShare>(chlo.extensions);\n  if (!clientShares) {\n    throw FizzException(\n        \"no client shares\", AlertDescription::missing_extension);\n  }\n\n  validateGroups(clientShares->client_shares);\n  for (const auto& share : clientShares->client_shares) {\n    if (share.group == *group) {\n      return std::make_tuple(*group, share.key_exchange->clone());\n    }\n  }\n  return std::make_tuple(*group, folly::none);\n}\n\nstatic SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> doKexSyncFuture(\n    KeyExchange* kex,\n    std::unique_ptr<folly::IOBuf> clientShare) {\n  AsyncKeyExchange::DoKexResult res;\n  kex->generateKeyPair();\n  res.sharedSecret = kex->generateSharedSecret(clientShare->coalesce());\n  res.ourKeyShare = kex->getKeyShare();\n  return folly::makeSemiFuture(Optional(std::move(res)));\n  // Everything completed and clientShare can be safely freed now.\n}\n\n// Caller is responsible to hold pKex until the lambda finished.\nstatic SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> doKexFuture(\n    KeyExchange* pKex,\n    std::unique_ptr<folly::IOBuf> clientShare) {\n  auto pAsyncKex = dynamic_cast<AsyncKeyExchange*>(pKex);\n  if (pAsyncKex) {\n    auto fut = pAsyncKex->doAsyncKexFuture(std::move(clientShare));\n    return std::move(fut).deferValue([](AsyncKeyExchange::DoKexResult res) {\n      return Optional(std::move(res));\n    });\n  } else {\n    return doKexSyncFuture(pKex, std::move(clientShare));\n  }\n}\n\nstatic HelloRetryRequest getHelloRetryRequest(\n    ProtocolVersion version,\n    CipherSuite cipher,\n    NamedGroup group,\n    Buf legacySessionId,\n    HandshakeContext& handshakeContext) {\n  HelloRetryRequest hrr;\n  hrr.legacy_version = ProtocolVersion::tls_1_2;\n  hrr.legacy_session_id_echo = std::move(legacySessionId);\n  hrr.cipher_suite = cipher;\n  ServerSupportedVersions versionExt;\n  versionExt.selected_version = version;\n  hrr.extensions.push_back(encodeExtension(std::move(versionExt)));\n  HelloRetryRequestKeyShare keyShare;\n  keyShare.selected_group = group;\n  hrr.extensions.push_back(encodeExtension(std::move(keyShare)));\n  return hrr;\n}\n\nstatic ServerHello getServerHello(\n    ProtocolVersion version,\n    Random random,\n    CipherSuite cipher,\n    bool psk,\n    Optional<NamedGroup> group,\n    Optional<Buf> serverShare,\n    Buf legacySessionId) {\n  ServerHello serverHello;\n\n  serverHello.legacy_version = ProtocolVersion::tls_1_2;\n  ServerSupportedVersions versionExt;\n  versionExt.selected_version = version;\n  serverHello.extensions.push_back(encodeExtension(std::move(versionExt)));\n  serverHello.legacy_session_id_echo = std::move(legacySessionId);\n\n  serverHello.random = std::move(random);\n  serverHello.cipher_suite = cipher;\n  if (group) {\n    ServerKeyShare serverKeyShare;\n    serverKeyShare.server_share.group = *group;\n    serverKeyShare.server_share.key_exchange = std::move(*serverShare);\n\n    serverHello.extensions.push_back(\n        encodeExtension(std::move(serverKeyShare)));\n  }\n  if (psk) {\n    ServerPresharedKey serverPsk;\n    serverPsk.selected_identity = kPskIndex;\n    serverHello.extensions.push_back(encodeExtension(std::move(serverPsk)));\n  }\n  return serverHello;\n}\n\nstatic Optional<std::string> negotiateAlpn(\n    const ClientHello& chlo,\n    folly::Optional<std::string> zeroRttAlpn,\n    const FizzServerContext& context) {\n  auto ext = getExtension<ProtocolNameList>(chlo.extensions);\n  std::vector<std::string> clientProtocols;\n  // Check whether client supports ALPN\n  if (ext) {\n    for (auto& protocol : ext->protocol_name_list) {\n      clientProtocols.push_back(protocol.name->moveToFbString().toStdString());\n    }\n  } else {\n    VLOG(6) << \"Client did not send ALPN extension\";\n    if (context.getAlpnMode() == AlpnMode::Required) {\n      throw FizzException(\n          \"ALPN is required\", AlertDescription::no_application_protocol);\n    }\n    return folly::none;\n  }\n\n  // Since both support ALPN, check whether the protocols match.\n  // Server's support for ALPN is to be enforced at the configuration.\n  auto selected = context.negotiateAlpn(clientProtocols, zeroRttAlpn);\n  if (!selected) {\n    VLOG(6) << \"ALPN mismatch\";\n    if (context.getAlpnMode() != AlpnMode::AllowMismatch) {\n      auto msg = context.getAlpnMode() == AlpnMode::Optional\n          ? \"Unable to negotiate ALPN, as required by policy. policy=AlpnMode::Optional\"\n          : \"Unable to negotiate ALPN, as required by policy. policy=AlpnMode::Required\";\n      throw FizzException(msg, AlertDescription::no_application_protocol);\n    }\n  } else {\n    VLOG(6) << \"ALPN: \" << *selected;\n  }\n  return selected;\n}\n\nstatic Optional<std::chrono::milliseconds> getClockSkew(\n    const Optional<ResumptionState>& psk,\n    Optional<uint32_t> obfuscatedAge,\n    const std::chrono::system_clock::time_point& currentTime) {\n  if (!psk || !obfuscatedAge) {\n    return folly::none;\n  }\n\n  auto age = std::chrono::milliseconds(\n      static_cast<uint32_t>(*obfuscatedAge - psk->ticketAgeAdd));\n\n  auto expected = std::chrono::duration_cast<std::chrono::milliseconds>(\n      currentTime - psk->ticketIssueTime);\n\n  return std::chrono::milliseconds(age - expected);\n}\n\nstatic Optional<Buf> getAppToken(const Optional<ResumptionState>& psk) {\n  if (!psk.has_value() || !psk->appToken) {\n    return folly::none;\n  }\n  return psk->appToken->clone();\n}\n\nstatic EarlyDataType negotiateEarlyDataType(\n    bool acceptEarlyData,\n    const ClientHello& chlo,\n    const Optional<ResumptionState>& psk,\n    CipherSuite cipher,\n    Optional<KeyExchangeType> keyExchangeType,\n    const Optional<CookieState>& cookieState,\n    Optional<std::string> alpn,\n    ReplayCacheResult replayCacheResult,\n    Optional<std::chrono::milliseconds> clockSkew,\n    ClockSkewTolerance clockSkewTolerance,\n    const AppTokenValidator* appTokenValidator) {\n  if (!getExtension<ClientEarlyData>(chlo.extensions)) {\n    return EarlyDataType::NotAttempted;\n  }\n\n  if (!acceptEarlyData) {\n    VLOG(5) << \"Rejecting early data: disabled\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (!psk) {\n    VLOG(5) << \"Rejected early data: psk rejected\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (psk->cipher != cipher) {\n    VLOG(5) << \"Rejected early data: cipher mismatch\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (psk->alpn != alpn) {\n    VLOG(5) << \"Rejecting early data: alpn mismatch\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (keyExchangeType &&\n      *keyExchangeType == KeyExchangeType::HelloRetryRequest) {\n    VLOG(5) << \"Rejecting early data: HelloRetryRequest\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (cookieState) {\n    VLOG(5) << \"Rejecting early data: Cookie\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (replayCacheResult != ReplayCacheResult::NotReplay) {\n    VLOG(5) << \"Rejecting early data: replay\";\n    return EarlyDataType::Rejected;\n  }\n\n  if (!clockSkew || *clockSkew < clockSkewTolerance.before ||\n      *clockSkew > clockSkewTolerance.after) {\n    VLOG(5) << \"Rejecting early data: clock skew clockSkew=\"\n            << (clockSkew ? folly::to<std::string>(clockSkew->count())\n                          : \"(none)\")\n            << \" toleranceBefore=\" << clockSkewTolerance.before.count()\n            << \" toleranceAfter=\" << clockSkewTolerance.after.count();\n    return EarlyDataType::Rejected;\n  }\n\n  if (appTokenValidator && !appTokenValidator->validate(*psk)) {\n    VLOG(5) << \"Rejecting early data: invalid app token\";\n    return EarlyDataType::Rejected;\n  }\n\n  return EarlyDataType::Accepted;\n}\n\nstatic Buf getEncryptedExt(\n    HandshakeContext& handshakeContext,\n    const folly::Optional<std::string>& selectedAlpn,\n    EarlyDataType earlyData,\n    folly::Optional<std::vector<ech::ECHConfig>> echRetryConfigs,\n    std::vector<Extension> otherExtensions) {\n  EncryptedExtensions encryptedExt;\n  if (selectedAlpn) {\n    ProtocolNameList alpn;\n    ProtocolName protocol;\n    protocol.name = folly::IOBuf::copyBuffer(*selectedAlpn);\n    alpn.protocol_name_list.push_back(std::move(protocol));\n    encryptedExt.extensions.push_back(encodeExtension(std::move(alpn)));\n  }\n\n  if (earlyData == EarlyDataType::Accepted) {\n    encryptedExt.extensions.push_back(encodeExtension(ServerEarlyData()));\n  }\n\n  if (echRetryConfigs.has_value()) {\n    ech::ECHEncryptedExtensions serverEch;\n    serverEch.retry_configs = std::move(*echRetryConfigs);\n    encryptedExt.extensions.push_back(encodeExtension(std::move(serverEch)));\n  }\n\n  for (auto& ext : otherExtensions) {\n    encryptedExt.extensions.push_back(std::move(ext));\n  }\n  auto encodedEncryptedExt =\n      encodeHandshake<EncryptedExtensions>(std::move(encryptedExt));\n  handshakeContext.appendToTranscript(encodedEncryptedExt);\n  return encodedEncryptedExt;\n}\n\nstatic std::pair<std::shared_ptr<SelfCert>, SignatureScheme> chooseCert(\n    const FizzServerContext& context,\n    const ClientHello& chlo) {\n  const auto& clientSigSchemes =\n      getExtension<SignatureAlgorithms>(chlo.extensions);\n  if (!clientSigSchemes) {\n    throw FizzException(\"no sig schemes\", AlertDescription::missing_extension);\n  }\n  Optional<std::string> sni;\n  auto serverNameList = getExtension<ServerNameList>(chlo.extensions);\n  if (serverNameList && !serverNameList->server_name_list.empty()) {\n    sni = serverNameList->server_name_list.front()\n              .hostname->moveToFbString()\n              .toStdString();\n  }\n\n  auto certAndScheme = context.getCert(\n      sni, clientSigSchemes->supported_signature_algorithms, chlo.extensions);\n  if (!certAndScheme) {\n    throw FizzException(\n        \"could not find suitable cert\", AlertDescription::handshake_failure);\n  }\n  return *certAndScheme;\n}\n\nstatic std::tuple<Buf, folly::Optional<CertificateCompressionAlgorithm>>\ngetCertificate(\n    const std::shared_ptr<const SelfCert>& serverCert,\n    const FizzServerContext& context,\n    const ClientHello& chlo,\n    HandshakeContext& handshakeContext) {\n  // Check for compression support first, and if so, send compressed.\n  Buf encodedCertificate;\n  folly::Optional<CertificateCompressionAlgorithm> algo;\n  auto compAlgos =\n      getExtension<CertificateCompressionAlgorithms>(chlo.extensions);\n  if (compAlgos && !context.getSupportedCompressionAlgorithms().empty()) {\n    algo = negotiate(\n        context.getSupportedCompressionAlgorithms(), compAlgos->algorithms);\n  }\n\n  if (algo) {\n    encodedCertificate = encodeHandshake(serverCert->getCompressedCert(*algo));\n  } else {\n    encodedCertificate = encodeHandshake(serverCert->getCertMessage());\n  }\n  handshakeContext.appendToTranscript(encodedCertificate);\n  return std::make_tuple(std::move(encodedCertificate), std::move(algo));\n}\n\nstatic Buf getCertificateVerify(\n    SignatureScheme sigScheme,\n    Buf signature,\n    HandshakeContext& handshakeContext) {\n  CertificateVerify verify;\n  verify.algorithm = sigScheme;\n  verify.signature = std::move(signature);\n  auto encodedCertificateVerify = encodeHandshake(std::move(verify));\n  handshakeContext.appendToTranscript(encodedCertificateVerify);\n  return encodedCertificateVerify;\n}\n\nstatic Buf getCertificateRequest(\n    const std::vector<SignatureScheme>& acceptableSigSchemes,\n    const CertificateVerifier* const verifier,\n    HandshakeContext& handshakeContext) {\n  CertificateRequest request;\n  SignatureAlgorithms algos;\n  algos.supported_signature_algorithms = acceptableSigSchemes;\n  request.extensions.push_back(encodeExtension(std::move(algos)));\n  if (verifier) {\n    auto verifierExtensions = verifier->getCertificateRequestExtensions();\n    for (auto& ext : verifierExtensions) {\n      request.extensions.push_back(std::move(ext));\n    }\n  }\n  auto encodedCertificateRequest = encodeHandshake(std::move(request));\n  handshakeContext.appendToTranscript(encodedCertificateRequest);\n  return encodedCertificateRequest;\n}\n\nstatic std::tuple<ECHStatus, uint8_t> processECHHRR(\n    const Optional<CookieState>& cookieState,\n    const State& state,\n    ClientHello& chlo) {\n  auto decrypter = state.context()->getECHDecrypter();\n  auto echExt = getExtension<ech::OuterECHClientHello>(chlo.extensions);\n  ECHStatus echStatus = state.echStatus();\n\n  // Check for cookie ECH\n  bool cookieHasECH = cookieState && cookieState->echCipherSuite.has_value();\n\n  // Do checks for both cases.\n  if (echStatus == ECHStatus::Accepted || cookieHasECH) {\n    if (!decrypter) {\n      throw FizzException(\n          \"ech accepted but no decrypter set up\",\n          AlertDescription::internal_error);\n    }\n    if (!echExt) {\n      throw FizzException(\n          \"ech not sent for hrr\", AlertDescription::missing_extension);\n    }\n    if (!echExt->enc->empty()) {\n      throw FizzException(\n          \"hrr ech enc not empty\", AlertDescription::illegal_parameter);\n    }\n  }\n\n  if (echStatus == ECHStatus::Accepted) {\n    // Stateful HRR first.\n    if (state.echState()->cipherSuite != echExt->cipher_suite) {\n      throw FizzException(\n          \"ech hrr cipher suite mismatch\", AlertDescription::illegal_parameter);\n    }\n    if (state.echState()->configId != echExt->config_id) {\n      throw FizzException(\n          \"ech hrr config id mismatch\", AlertDescription::illegal_parameter);\n    }\n\n    chlo =\n        decrypter->decryptClientHelloHRR(chlo, state.echState()->hpkeContext);\n\n    return {ECHStatus::Accepted, echExt->config_id};\n  } else if (cookieHasECH) {\n    // Stateless HRR now\n    if (*cookieState->echCipherSuite != echExt->cipher_suite) {\n      throw FizzException(\n          \"ech hrr cipher suite mismatch\", AlertDescription::illegal_parameter);\n    }\n    if (*cookieState->echConfigId != echExt->config_id) {\n      throw FizzException(\n          \"ech hrr config id mismatch\", AlertDescription::illegal_parameter);\n    }\n\n    chlo = decrypter->decryptClientHelloHRR(chlo, cookieState->echEnc);\n\n    return {ECHStatus::Accepted, echExt->config_id};\n  }\n\n  // Just return the ECH status as is\n  return {echStatus, 0};\n}\n\n// Process ECH, replacing chlo if successful\nstatic std::pair<ECHStatus, ECHState> processECH(\n    const Optional<CookieState>& cookieState,\n    const State& state,\n    ClientHello& chlo) {\n  // First, fetch current state (if any).\n  ECHState echState;\n  ECHStatus echStatus = state.echStatus();\n  auto decrypter = state.context()->getECHDecrypter();\n\n  if (state.handshakeContext() || cookieState) {\n    // Process ECH for HRR (if any)\n    std::tie(echStatus, echState.configId) =\n        processECHHRR(cookieState, state, chlo);\n    // Populate ECH state for saving\n    if (state.echState().has_value()) {\n      echState.hpkeContext = std::move(state.echState()->hpkeContext);\n      echState.cipherSuite = state.echState()->cipherSuite;\n    }\n  } else {\n    bool requestedECH =\n        findExtension(chlo.extensions, ExtensionType::encrypted_client_hello) !=\n        chlo.extensions.end();\n    if (requestedECH && decrypter) {\n      auto gotChlo = decrypter->decryptClientHello(chlo);\n      if (gotChlo.has_value()) {\n        auto echExt = getExtension<ech::OuterECHClientHello>(chlo.extensions);\n        echStatus = ECHStatus::Accepted;\n        echState.hpkeContext = std::move(gotChlo->context);\n        echState.configId = gotChlo->configId;\n        echState.cipherSuite = echExt->cipher_suite;\n        chlo = std::move(gotChlo->chlo);\n      } else if (requestedECH) {\n        echStatus = ECHStatus::Rejected;\n      }\n    }\n  }\n\n  if (echStatus == ECHStatus::Accepted &&\n      getExtension<ech::InnerECHClientHello>(chlo.extensions) == folly::none) {\n    throw FizzException(\n        \"inner clienthello missing encrypted_client_hello\",\n        AlertDescription::missing_extension);\n  }\n\n  return std::make_pair(echStatus, std::move(echState));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingClientHello, Event::ClientHello>::\n    handle(const State& state, Param param) {\n  ClientHello chlo = std::move(*param.asClientHello());\n\n  auto cookieState = getCookieState(chlo, state.context()->getCookieCipher());\n\n  if (state.handshakeContext() && cookieState.has_value()) {\n    throw FizzException(\n        \"cookie after statefull hrr\", AlertDescription::illegal_parameter);\n  }\n\n  ECHStatus echStatus;\n  ECHState echState;\n  std::tie(echStatus, echState) = processECH(cookieState, state, chlo);\n\n  addHandshakeLogging(state, chlo);\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after client hello\", AlertDescription::unexpected_message);\n  }\n\n  auto version =\n      negotiateVersion(chlo, state.context()->getSupportedVersions());\n\n  if (state.version().has_value() &&\n      (!version || *version != *state.version())) {\n    throw FizzException(\n        \"version mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  if (!version) {\n    if (getExtension<ClientEarlyData>(chlo.extensions)) {\n      throw FizzException(\n          \"supported version mismatch with early data\",\n          AlertDescription::protocol_version);\n    }\n    if (state.context()->getVersionFallbackEnabled()) {\n      AttemptVersionFallback fallback;\n      // Re-encode to put the record layer header back on. This won't\n      // necessarily preserve it byte-for-byte, but it isn't authenticated so\n      // should be ok.\n      fallback.clientHello =\n          PlaintextWriteRecordLayer()\n              .writeInitialClientHello(std::move(*chlo.originalEncoding))\n              .data;\n      return actions(\n          MutateState(&Transition<StateEnum::Error>), std::move(fallback));\n    } else {\n      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  if (state.cipher().has_value() && cipher != *state.cipher()) {\n    throw FizzException(\n        \"cipher mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n      state.context()->getReplayCache());\n\n  auto results =\n      collectAll(resStateResult.futureResState, replayCacheResultFuture);\n\n  using FutureResultType = std::tuple<\n      folly::Try<std::pair<PskType, Optional<ResumptionState>>>,\n      folly::Try<ReplayCacheResult>>;\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(results),\n      [&state,\n       chlo = std::move(chlo),\n       cookieState = std::move(cookieState),\n       version = *version,\n       cipher,\n       pskMode = resStateResult.pskMode,\n       echStatus,\n       echState = std::move(echState),\n       obfuscatedAge =\n           resStateResult.obfuscatedAge](FutureResultType result) mutable {\n        auto& resumption = *std::get<0>(result);\n        auto pskType = resumption.first;\n        auto resState = std::move(resumption.second);\n        auto replayCacheResult = *std::get<1>(result);\n\n        if (resState) {\n          if (!validateResumptionState(*resState, *pskMode, version, cipher)) {\n            pskType = PskType::Rejected;\n            pskMode = folly::none;\n            resState = folly::none;\n          }\n        } else {\n          pskMode = folly::none;\n        }\n\n        auto legacySessionId = chlo.legacy_session_id->clone();\n\n        // If we successfully resumed, set the handshake time to the ticket's\n        // handshake time to preserve it across ticket updates. If not, set it\n        // to now.\n        std::chrono::system_clock::time_point handshakeTime;\n        if (resState) {\n          handshakeTime = resState->handshakeTime;\n        } else {\n          handshakeTime = state.context()->getClock().getCurrentTime();\n        }\n\n        std::unique_ptr<KeyScheduler> scheduler;\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n\n        auto earlyDataType = negotiateEarlyDataType(\n            state.context()->getAcceptEarlyData(version),\n            chlo,\n            resState,\n            cipher,\n            state.keyExchangeType(),\n            cookieState,\n            alpn,\n            replayCacheResult,\n            clockSkew,\n            state.context()->getClockSkewTolerance(),\n            state.appTokenValidator());\n\n        std::unique_ptr<EncryptedReadRecordLayer> earlyReadRecordLayer;\n        Buf earlyExporterMaster;\n        folly::Optional<SecretAvailable> earlyReadSecretAvailable;\n        if (earlyDataType == EarlyDataType::Accepted) {\n          auto earlyContext = handshakeContext->getHandshakeContext();\n          auto earlyReadSecret = scheduler->getSecret(\n              EarlySecrets::ClientEarlyTraffic, earlyContext->coalesce());\n          if (!state.context()->getOmitEarlyRecordLayer()) {\n            earlyReadRecordLayer =\n                state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                    EncryptionLevel::EarlyData);\n            earlyReadRecordLayer->setProtocolVersion(version);\n\n            Protocol::setAead(\n                *earlyReadRecordLayer,\n                cipher,\n                folly::range(earlyReadSecret.secret),\n                *state.context()->getFactory(),\n                *scheduler);\n          }\n\n          earlyReadSecretAvailable =\n              SecretAvailable(std::move(earlyReadSecret));\n          earlyExporterMaster = folly::IOBuf::copyBuffer(\n              scheduler\n                  ->getSecret(\n                      EarlySecrets::EarlyExporter, earlyContext->coalesce())\n                  .secret);\n        }\n\n        Optional<NamedGroup> group;\n        KeyExchangeType keyExchangeType;\n        SemiFuture<Optional<AsyncKeyExchange::DoKexResult>> kexResultFuture =\n            folly::none;\n        std::unique_ptr<KeyExchange> kex = nullptr;\n\n        if (!pskMode || *pskMode != PskKeyExchangeMode::psk_ke) {\n          Optional<Buf> clientShare;\n          std::tie(group, clientShare) = negotiateGroup(\n              version, chlo, state.context()->getSupportedGroups());\n          if (!clientShare) {\n            VLOG(8) << \"Did not find key share for \" << toString(*group);\n            if (state.group().has_value() || cookieState) {\n              throw FizzException(\n                  \"key share not found for already negotiated group\",\n                  AlertDescription::illegal_parameter);\n            }\n\n            // If we were otherwise going to accept early data we now need to\n            // reject it. It's a little ugly to change our previous early data\n            // decision, but doing it this way allows us to move the key\n            // schedule forward as we do the key exchange.\n            if (earlyDataType == EarlyDataType::Accepted) {\n              earlyDataType = EarlyDataType::Rejected;\n            }\n\n            message_hash chloHash;\n            chloHash.hash = handshakeContext->getHandshakeContext();\n            handshakeContext =\n                state.context()->getFactory()->makeHandshakeContext(cipher);\n            handshakeContext->appendToTranscript(\n                encodeHandshake(std::move(chloHash)));\n\n            auto hrr = getHelloRetryRequest(\n                version,\n                cipher,\n                *group,\n                legacySessionId ? legacySessionId->clone() : nullptr,\n                *handshakeContext);\n\n            if (echStatus == ECHStatus::Accepted) {\n              // Set up acceptance scheduler\n              auto echScheduler =\n                  state.context()->getFactory()->makeKeyScheduler(cipher);\n              echScheduler->deriveEarlySecret(folly::range(chlo.random));\n              // Add acceptance extension\n              ech::setAcceptConfirmation(\n                  hrr, handshakeContext->clone(), std::move(echScheduler));\n            }\n\n            auto encodedHelloRetryRequest = encodeHandshake(std::move(hrr));\n            handshakeContext->appendToTranscript(encodedHelloRetryRequest);\n\n            WriteToSocket serverFlight;\n            serverFlight.contents.emplace_back(\n                state.writeRecordLayer()->writeHandshake(\n                    std::move(encodedHelloRetryRequest)));\n\n            if (legacySessionId && !legacySessionId->empty()) {\n              TLSContent writeCCS;\n              writeCCS.encryptionLevel = EncryptionLevel::Plaintext;\n              writeCCS.contentType = ContentType::change_cipher_spec;\n              writeCCS.data = folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n              serverFlight.contents.emplace_back(std::move(writeCCS));\n            }\n\n            // Create a new record layer in case we need to skip early data.\n            auto newReadRecordLayer =\n                state.context()->getFactory()->makePlaintextReadRecordLayer();\n            newReadRecordLayer->setSkipEncryptedRecords(\n                earlyDataType == EarlyDataType::Rejected);\n\n            return SemiFuture<Actions>(actions(\n                MutateState([handshakeContext = std::move(handshakeContext),\n                             version,\n                             cipher,\n                             group,\n                             earlyDataType,\n                             replayCacheResult,\n                             newReadRecordLayer = std::move(newReadRecordLayer),\n                             echStatus,\n                             echState =\n                                 std::move(echState)](State& newState) mutable {\n                  // Save some information about the current state to be\n                  // validated when we get the second client hello. We don't\n                  // validate that the second client hello matches the first\n                  // as strictly as we could according to the spec however.\n                  newState.handshakeContext() = std::move(handshakeContext);\n                  newState.version() = version;\n                  newState.cipher() = cipher;\n                  newState.group() = group;\n                  newState.keyExchangeType() =\n                      KeyExchangeType::HelloRetryRequest;\n                  newState.earlyDataType() = earlyDataType;\n                  newState.replayCacheResult() = replayCacheResult;\n                  newState.readRecordLayer() = std::move(newReadRecordLayer);\n                  newState.echStatus() = echStatus;\n                  if (echStatus == ECHStatus::Accepted) {\n                    newState.echState() = std::move(echState);\n                  }\n                }),\n                std::move(serverFlight),\n                MutateState(&Transition<StateEnum::ExpectingClientHello>)));\n          }\n\n          if (state.keyExchangeType().has_value()) {\n            keyExchangeType = *state.keyExchangeType();\n          } else {\n            keyExchangeType = KeyExchangeType::OneRtt;\n          }\n\n          // The exceptions in SemiFutures will be processed in\n          // detail::processEvent.\n          kex = state.context()->getFactory()->makeKeyExchange(\n              *group, Factory::KeyExchangeMode::Server);\n          kexResultFuture =\n              doKexFuture(kex.get(), std::move(clientShare.value()));\n        } else {\n          keyExchangeType = KeyExchangeType::None;\n        }\n\n        return runOnCallerIfComplete(\n            state.executor(),\n            std::move(kexResultFuture),\n            [&state,\n             scheduler = std::move(scheduler),\n             handshakeContext = std::move(handshakeContext),\n             cipher,\n             group,\n             echStatus,\n             earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n             earlyReadSecretAvailable = std::move(earlyReadSecretAvailable),\n             earlyExporterMaster = std::move(earlyExporterMaster),\n             pskType,\n             pskMode,\n             version,\n             keyExchangeType,\n             earlyDataType,\n             replayCacheResult,\n             alpn = std::move(alpn),\n             clockSkew,\n             appToken = std::move(appToken),\n             legacySessionId = std::move(legacySessionId),\n             handshakeTime,\n             chlo = std::move(chlo),\n             cookieState = std::move(cookieState),\n             resState = std::move(resState),\n             // Hold kex until the doKexFuture finished.\n             kex = std::move(kex)](\n                Optional<AsyncKeyExchange::DoKexResult> kexResult) mutable {\n              Optional<Buf> serverShare;\n              if (kexResult.hasValue()) {\n                serverShare = std::move(kexResult.value().ourKeyShare);\n                scheduler->deriveHandshakeSecret(\n                    kexResult.value().sharedSecret->coalesce());\n              } else {\n                DCHECK(keyExchangeType == KeyExchangeType::None);\n                scheduler->deriveHandshakeSecret();\n              }\n              std::vector<Extension> additionalExtensions;\n              if (state.extensions()) {\n                additionalExtensions = state.extensions()->getExtensions(chlo);\n              }\n\n              if (state.group().has_value() &&\n                  (!group || *group != *state.group())) {\n                throw FizzException(\n                    \"group mismatch with previous negotiation\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              // Cookies are not required to have already negotiated the group\n              // but if they did it must match (psk_ke is still allowed as we\n              // may not know if we are accepting the psk when sending the\n              // cookie).\n              if (cookieState && cookieState->group && group &&\n                  *group != *cookieState->group) {\n                throw FizzException(\n                    \"group mismatch with cookie\",\n                    AlertDescription::illegal_parameter);\n              }\n\n              auto serverHello = getServerHello(\n                  version,\n                  state.context()->getFactory()->makeRandom(),\n                  cipher,\n                  resState.has_value(),\n                  group,\n                  std::move(serverShare),\n                  legacySessionId ? legacySessionId->clone() : nullptr);\n\n              folly::Optional<std::vector<ech::ECHConfig>> echRetryConfigs;\n              if (echStatus == ECHStatus::Accepted) {\n                // Set up acceptance scheduler\n                auto echScheduler =\n                    state.context()->getFactory()->makeKeyScheduler(cipher);\n                echScheduler->deriveEarlySecret(folly::range(chlo.random));\n                // Add acceptance extension\n                ech::setAcceptConfirmation(\n                    serverHello,\n                    handshakeContext->clone(),\n                    std::move(echScheduler));\n              } else if (echStatus == ECHStatus::Rejected) {\n                auto decrypter = state.context()->getECHDecrypter();\n                echRetryConfigs = decrypter->getRetryConfigs();\n              }\n\n              auto encodedServerHello = encodeHandshake(std::move(serverHello));\n              handshakeContext->appendToTranscript(encodedServerHello);\n\n              // Derive handshake keys.\n              auto handshakeWriteRecordLayer =\n                  state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeWriteRecordLayer->setProtocolVersion(version);\n              auto handshakeWriteSecret = scheduler->getSecret(\n                  HandshakeSecrets::ServerHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeWriteRecordLayer,\n                  cipher,\n                  folly::range(handshakeWriteSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n\n              auto handshakeReadRecordLayer =\n                  state.context()->getFactory()->makeEncryptedReadRecordLayer(\n                      EncryptionLevel::Handshake);\n              handshakeReadRecordLayer->setProtocolVersion(version);\n              handshakeReadRecordLayer->setSkipFailedDecryption(\n                  earlyDataType == EarlyDataType::Rejected);\n              auto handshakeReadSecret = scheduler->getSecret(\n                  HandshakeSecrets::ClientHandshakeTraffic,\n                  handshakeContext->getHandshakeContext()->coalesce());\n              Protocol::setAead(\n                  *handshakeReadRecordLayer,\n                  cipher,\n                  folly::range(handshakeReadSecret.secret),\n                  *state.context()->getFactory(),\n                  *scheduler);\n              auto clientHandshakeSecret =\n                  folly::IOBuf::copyBuffer(handshakeReadSecret.secret);\n\n              auto encodedEncryptedExt = getEncryptedExt(\n                  *handshakeContext,\n                  alpn,\n                  earlyDataType,\n                  std::move(echRetryConfigs),\n                  std::move(additionalExtensions));\n\n              /*\n               * Determine we are requesting client auth.\n               * If yes, add CertificateRequest to handshake write and\n               * transcript.\n               */\n              bool requestClientAuth = state.context()->getClientAuthMode() !=\n                      ClientAuthMode::None &&\n                  !resState;\n              Optional<Buf> encodedCertRequest;\n              if (requestClientAuth) {\n                encodedCertRequest = getCertificateRequest(\n                    state.context()->getSupportedSigSchemes(),\n                    state.context()->getClientCertVerifier().get(),\n                    *handshakeContext);\n              }\n\n              /*\n               * Set the cert and signature scheme we are using.\n               * If sending new cert, add Certificate to handshake write and\n               * transcript.\n               */\n              Optional<Buf> encodedCertificate;\n              SemiFuture<Optional<Buf>> signature = folly::none;\n              Optional<SignatureScheme> sigScheme;\n              Optional<std::shared_ptr<const Cert>> serverCert;\n              std::shared_ptr<const Cert> clientCert;\n              Optional<CertificateCompressionAlgorithm> certCompressionAlgo;\n              if (!resState) { // TODO or reauth\n                std::shared_ptr<const SelfCert> originalSelfCert;\n                std::tie(originalSelfCert, sigScheme) =\n                    chooseCert(*state.context(), chlo);\n\n                std::tie(encodedCertificate, certCompressionAlgo) =\n                    getCertificate(\n                        originalSelfCert,\n                        *state.context(),\n                        chlo,\n                        *handshakeContext);\n\n                auto toBeSigned = handshakeContext->getHandshakeContext();\n                auto asyncSelfCert =\n                    dynamic_cast<const AsyncSelfCert*>(originalSelfCert.get());\n                if (asyncSelfCert) {\n                  signature = asyncSelfCert->signFuture(\n                      *sigScheme,\n                      CertificateVerifyContext::Server,\n                      std::move(toBeSigned));\n                } else {\n                  signature = folly::makeSemiFuture<Optional<Buf>>(\n                      originalSelfCert->sign(\n                          *sigScheme,\n                          CertificateVerifyContext::Server,\n                          toBeSigned->coalesce()));\n                }\n                serverCert = std::move(originalSelfCert);\n              } else {\n                serverCert = std::move(resState->serverCert);\n                clientCert = std::move(resState->clientCert);\n              }\n\n              auto clientRandom = std::move(chlo.random);\n\n              return runOnCallerIfComplete(\n                  state.executor(),\n                  std::move(signature),\n                  [&state,\n                   scheduler = std::move(scheduler),\n                   handshakeContext = std::move(handshakeContext),\n                   cipher,\n                   clientRandom = std::move(clientRandom),\n                   group,\n                   echStatus,\n                   encodedServerHello = std::move(encodedServerHello),\n                   handshakeWriteRecordLayer =\n                       std::move(handshakeWriteRecordLayer),\n                   handshakeWriteSecret = std::move(handshakeWriteSecret),\n                   handshakeReadRecordLayer =\n                       std::move(handshakeReadRecordLayer),\n                   handshakeReadSecret = std::move(handshakeReadSecret),\n                   earlyReadRecordLayer = std::move(earlyReadRecordLayer),\n                   earlyReadSecretAvailable =\n                       std::move(earlyReadSecretAvailable),\n                   earlyExporterMaster = std::move(earlyExporterMaster),\n                   clientHandshakeSecret = std::move(clientHandshakeSecret),\n                   encodedEncryptedExt = std::move(encodedEncryptedExt),\n                   encodedCertificate = std::move(encodedCertificate),\n                   encodedCertRequest = std::move(encodedCertRequest),\n                   requestClientAuth,\n                   pskType,\n                   pskMode,\n                   sigScheme,\n                   version,\n                   keyExchangeType,\n                   earlyDataType,\n                   replayCacheResult,\n                   serverCert = std::move(serverCert),\n                   clientCert = std::move(clientCert),\n                   alpn = std::move(alpn),\n                   clockSkew,\n                   appToken = std::move(appToken),\n                   legacySessionId = std::move(legacySessionId),\n                   serverCertCompAlgo = certCompressionAlgo,\n                   handshakeTime](Optional<Buf> sig) mutable {\n                    Optional<Buf> encodedCertificateVerify;\n                    if (sig) {\n                      encodedCertificateVerify = getCertificateVerify(\n                          *sigScheme, std::move(*sig), *handshakeContext);\n                    }\n\n                    auto encodedFinished = Protocol::getFinished(\n                        folly::range(handshakeWriteSecret.secret),\n                        *handshakeContext);\n\n                    folly::IOBufQueue combined;\n                    if (encodedCertificate) {\n                      if (encodedCertRequest) {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertRequest));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      } else {\n                        combined.append(std::move(encodedEncryptedExt));\n                        combined.append(std::move(*encodedCertificate));\n                        combined.append(std::move(*encodedCertificateVerify));\n                        combined.append(std::move(encodedFinished));\n                      }\n                    } else {\n                      combined.append(std::move(encodedEncryptedExt));\n                      combined.append(std::move(encodedFinished));\n                    }\n\n                    // Some middleboxes appear to break if the first encrypted\n                    // record is larger than ~1300 bytes (likely if it does not\n                    // fit in the first packet).\n                    auto serverEncrypted =\n                        handshakeWriteRecordLayer->writeHandshake(\n                            combined.splitAtMost(1000));\n                    if (!combined.empty()) {\n                      auto splitRecord =\n                          handshakeWriteRecordLayer->writeHandshake(\n                              combined.move());\n                      // Split record must have the same encryption level as the\n                      // main handshake.\n                      DCHECK(\n                          splitRecord.encryptionLevel ==\n                          serverEncrypted.encryptionLevel);\n                      serverEncrypted.data->prependChain(\n                          std::move(splitRecord.data));\n                    }\n\n                    WriteToSocket serverFlight;\n                    serverFlight.contents.emplace_back(\n                        state.writeRecordLayer()->writeHandshake(\n                            std::move(encodedServerHello)));\n                    if (legacySessionId && !legacySessionId->empty()) {\n                      TLSContent ccsWrite;\n                      ccsWrite.encryptionLevel = EncryptionLevel::Plaintext;\n                      ccsWrite.contentType = ContentType::change_cipher_spec;\n                      ccsWrite.data =\n                          folly::IOBuf::wrapBuffer(FakeChangeCipherSpec);\n                      serverFlight.contents.emplace_back(std::move(ccsWrite));\n                    }\n                    serverFlight.contents.emplace_back(\n                        std::move(serverEncrypted));\n\n                    scheduler->deriveMasterSecret();\n                    auto clientFinishedContext =\n                        handshakeContext->getHandshakeContext();\n                    auto exporterMasterVector = scheduler->getSecret(\n                        MasterSecrets::ExporterMaster,\n                        clientFinishedContext->coalesce());\n                    auto exporterMaster = folly::IOBuf::copyBuffer(\n                        folly::range(exporterMasterVector.secret));\n\n                    scheduler->deriveAppTrafficSecrets(\n                        clientFinishedContext->coalesce());\n                    auto appTrafficWriteRecordLayer =\n                        state.context()\n                            ->getFactory()\n                            ->makeEncryptedWriteRecordLayer(\n                                EncryptionLevel::AppTraffic);\n                    appTrafficWriteRecordLayer->setProtocolVersion(version);\n                    auto writeSecret = scheduler->getSecret(\n                        AppTrafficSecrets::ServerAppTraffic);\n                    Protocol::setAead(\n                        *appTrafficWriteRecordLayer,\n                        cipher,\n                        folly::range(writeSecret.secret),\n                        *state.context()->getFactory(),\n                        *scheduler);\n\n                    // If we have previously dealt with early data (before a\n                    // HelloRetryRequest), don't overwrite the previous result.\n                    auto earlyDataTypeSave = state.earlyDataType()\n                        ? *state.earlyDataType()\n                        : earlyDataType;\n\n                    SecretAvailable handshakeReadSecretAvailable(\n                        std::move(handshakeReadSecret));\n                    SecretAvailable handshakeWriteSecretAvailable(\n                        std::move(handshakeWriteSecret));\n                    SecretAvailable appWriteSecretAvailable(\n                        std::move(writeSecret));\n\n                    // Save all the necessary state except for the read record\n                    // layer, which is done separately as it varies if early\n                    // data was accepted.\n                    MutateState saveState(\n                        [appTrafficWriteRecordLayer =\n                             std::move(appTrafficWriteRecordLayer),\n                         handshakeContext = std::move(handshakeContext),\n                         scheduler = std::move(scheduler),\n                         exporterMaster = std::move(exporterMaster),\n                         serverCert = std::move(serverCert),\n                         clientCert = std::move(clientCert),\n                         cipher,\n                         group,\n                         sigScheme,\n                         clientHandshakeSecret =\n                             std::move(clientHandshakeSecret),\n                         pskType,\n                         pskMode,\n                         version,\n                         keyExchangeType,\n                         alpn = std::move(alpn),\n                         earlyDataTypeSave,\n                         replayCacheResult,\n                         clockSkew,\n                         appToken = std::move(appToken),\n                         serverCertCompAlgo,\n                         echStatus,\n                         clientRandom = std::move(clientRandom),\n                         handshakeTime = std::move(handshakeTime)](\n                            State& newState) mutable {\n                          newState.writeRecordLayer() =\n                              std::move(appTrafficWriteRecordLayer);\n                          newState.handshakeContext() =\n                              std::move(handshakeContext);\n                          newState.keyScheduler() = std::move(scheduler);\n                          newState.exporterMasterSecret() =\n                              std::move(exporterMaster);\n                          newState.serverCert() = std::move(*serverCert);\n                          newState.clientCert() = std::move(clientCert);\n                          newState.version() = version;\n                          newState.cipher() = cipher;\n                          newState.group() = group;\n                          newState.sigScheme() = sigScheme;\n                          newState.clientHandshakeSecret() =\n                              std::move(clientHandshakeSecret);\n                          newState.pskType() = pskType;\n                          newState.pskMode() = pskMode;\n                          newState.keyExchangeType() = keyExchangeType;\n                          newState.earlyDataType() = earlyDataTypeSave;\n                          newState.replayCacheResult() = replayCacheResult;\n                          newState.alpn() = std::move(alpn);\n                          newState.clientClockSkew() = clockSkew;\n                          newState.appToken() = std::move(appToken);\n                          newState.serverCertCompAlgo() = serverCertCompAlgo;\n                          newState.handshakeTime() = std::move(handshakeTime);\n                          newState.clientRandom() = std::move(clientRandom);\n                          newState.echStatus() = echStatus;\n                          newState.echState() = folly::none;\n                        });\n\n                    if (earlyDataType == EarlyDataType::Accepted) {\n                      if (state.context()->getOmitEarlyRecordLayer()) {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::ExpectingFinished>),\n                            ReportEarlyHandshakeSuccess());\n\n                      } else {\n                        return actions(\n                            MutateState([handshakeReadRecordLayer = std::move(\n                                             handshakeReadRecordLayer),\n                                         earlyReadRecordLayer =\n                                             std::move(earlyReadRecordLayer),\n                                         earlyExporterMaster =\n                                             std::move(earlyExporterMaster)](\n                                            State& newState) mutable {\n                              newState.readRecordLayer() =\n                                  std::move(earlyReadRecordLayer);\n                              newState.handshakeReadRecordLayer() =\n                                  std::move(handshakeReadRecordLayer);\n                              newState.earlyExporterMasterSecret() =\n                                  std::move(earlyExporterMaster);\n                            }),\n                            std::move(saveState),\n                            std::move(*earlyReadSecretAvailable),\n                            std::move(handshakeReadSecretAvailable),\n                            std::move(handshakeWriteSecretAvailable),\n                            std::move(appWriteSecretAvailable),\n                            std::move(serverFlight),\n                            MutateState(\n                                &Transition<StateEnum::AcceptingEarlyData>),\n                            ReportEarlyHandshakeSuccess());\n                      }\n                    } else {\n                      auto transition = requestClientAuth\n                          ? Transition<StateEnum::ExpectingCertificate>\n                          : Transition<StateEnum::ExpectingFinished>;\n                      return actions(\n                          MutateState([handshakeReadRecordLayer =\n                                           std::move(handshakeReadRecordLayer)](\n                                          State& newState) mutable {\n                            newState.readRecordLayer() =\n                                std::move(handshakeReadRecordLayer);\n                          }),\n                          std::move(saveState),\n                          std::move(handshakeReadSecretAvailable),\n                          std::move(handshakeWriteSecretAvailable),\n                          std::move(appWriteSecretAvailable),\n                          std::move(serverFlight),\n                          MutateState(transition));\n                    }\n                  });\n            });\n      });\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingEarlyData, Event::AppData>::\n    handle(const State&, Param param) {\n  auto& appData = *param.asAppData();\n\n  return actions(DeliverAppData{std::move(appData.data)});\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingEarlyData, Event::AppWrite>::\n    handle(const State& state, Param param) {\n  auto& appWrite = *param.asAppWrite();\n\n  WriteToSocket write;\n  write.callback = appWrite.callback;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAppData(\n      std::move(appWrite.data), appWrite.aeadOptions));\n  write.flags = appWrite.flags;\n\n  return actions(std::move(write));\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::AcceptingEarlyData,\n    Event::EndOfEarlyData>::handle(const State& state, Param param) {\n  auto& eoed = *param.asEndOfEarlyData();\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\n        \"data after eoed\", AlertDescription::unexpected_message);\n  }\n\n  state.handshakeContext()->appendToTranscript(*eoed.originalEncoding);\n\n  auto readRecordLayer = std::move(state.handshakeReadRecordLayer());\n\n  return actions(\n      MutateState([readRecordLayer =\n                       std::move(readRecordLayer)](State& newState) mutable {\n        newState.readRecordLayer() = std::move(readRecordLayer);\n      }),\n      MutateState(&Transition<StateEnum::ExpectingFinished>));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingFinished, Event::AppWrite>::\n    handle(const State& state, Param param) {\n  auto& appWrite = *param.asAppWrite();\n\n  WriteToSocket write;\n  write.callback = appWrite.callback;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAppData(\n      std::move(appWrite.data), appWrite.aeadOptions));\n  write.flags = appWrite.flags;\n\n  return actions(std::move(write));\n}\n\nstatic WriteToSocket writeNewSessionTicket(\n    const FizzServerContext& context,\n    const WriteRecordLayer& recordLayer,\n    std::chrono::seconds ticketLifetime,\n    uint32_t ticketAgeAdd,\n    Buf nonce,\n    Buf ticket,\n    ProtocolVersion version) {\n  NewSessionTicket nst;\n  nst.ticket_lifetime = ticketLifetime.count();\n  nst.ticket_age_add = ticketAgeAdd;\n  nst.ticket_nonce = std::move(nonce);\n  nst.ticket = std::move(ticket);\n\n  if (context.getAcceptEarlyData(version)) {\n    TicketEarlyData early;\n    early.max_early_data_size = context.getMaxEarlyDataSize();\n    nst.extensions.push_back(encodeExtension(std::move(early)));\n  }\n\n  auto encodedNst = encodeHandshake(std::move(nst));\n  WriteToSocket nstWrite;\n  nstWrite.contents.emplace_back(\n      recordLayer.writeHandshake(std::move(encodedNst)));\n  return nstWrite;\n}\n\nstatic SemiFuture<Optional<WriteToSocket>> generateTicket(\n    const State& state,\n    const std::vector<uint8_t>& resumptionMasterSecret,\n    Buf appToken = nullptr) {\n  auto ticketCipher = state.context()->getTicketCipher();\n\n  if (!ticketCipher || *state.pskType() == PskType::NotSupported) {\n    return folly::none;\n  }\n\n  Buf resumptionSecret;\n  auto ticketNonce = folly::IOBuf::create(0);\n  resumptionSecret = state.keyScheduler()->getResumptionSecret(\n      folly::range(resumptionMasterSecret), ticketNonce->coalesce());\n\n  ResumptionState resState;\n  resState.version = *state.version();\n  resState.cipher = *state.cipher();\n  resState.resumptionSecret = std::move(resumptionSecret);\n  resState.serverCert = state.serverCert();\n  resState.clientCert = state.clientCert();\n  resState.alpn = state.alpn();\n  resState.ticketAgeAdd = state.context()->getFactory()->makeTicketAgeAdd();\n  resState.ticketIssueTime = state.context()->getClock().getCurrentTime();\n  resState.appToken = std::move(appToken);\n  resState.handshakeTime = *state.handshakeTime();\n\n  auto ticketFuture = ticketCipher->encrypt(std::move(resState));\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(ticketFuture),\n      [&state,\n       ticketAgeAdd = resState.ticketAgeAdd,\n       ticketNonce = std::move(ticketNonce)](\n          Optional<std::pair<Buf, std::chrono::seconds>> ticket) mutable\n      -> Optional<WriteToSocket> {\n        if (!ticket) {\n          return folly::none;\n        }\n        return writeNewSessionTicket(\n            *state.context(),\n            *state.writeRecordLayer(),\n            ticket->second,\n            ticketAgeAdd,\n            std::move(ticketNonce),\n            std::move(ticket->first),\n            *state.version());\n      });\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingCertificate, Event::Certificate>::\n    handle(const State& state, Param param) {\n  auto certMsg = std::move(*param.asCertificateMsg());\n\n  state.handshakeContext()->appendToTranscript(*certMsg.originalEncoding);\n\n  if (!certMsg.certificate_request_context->empty()) {\n    throw FizzException(\n        \"certificate request context must be empty\",\n        AlertDescription::illegal_parameter);\n  }\n\n  std::vector<std::shared_ptr<const PeerCert>> clientCerts;\n  bool leaf = true;\n  for (auto& certEntry : certMsg.certificate_list) {\n    // We don't request any extensions, so this ought to be empty\n    if (!certEntry.extensions.empty()) {\n      throw FizzException(\n          \"certificate extensions must be empty\",\n          AlertDescription::illegal_parameter);\n    }\n\n    clientCerts.emplace_back(state.context()->getFactory()->makePeerCert(\n        std::move(certEntry), leaf));\n    leaf = false;\n  }\n\n  if (clientCerts.empty()) {\n    if (state.context()->getClientAuthMode() == ClientAuthMode::Optional) {\n      VLOG(6) << \"Client authentication not sent\";\n      return actions(\n          MutateState([](State& newState) {\n            newState.unverifiedCertChain() = folly::none;\n          }),\n          MutateState(&Transition<StateEnum::ExpectingFinished>));\n    } else {\n      throw FizzException(\n          \"certificate requested but none received\",\n          AlertDescription::certificate_required);\n    }\n  } else {\n    return actions(\n        MutateState([certs = std::move(clientCerts)](State& newState) mutable {\n          newState.unverifiedCertChain() = std::move(certs);\n        }),\n        MutateState(&Transition<StateEnum::ExpectingCertificateVerify>));\n  }\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::ExpectingCertificateVerify,\n    Event::CertificateVerify>::handle(const State& state, Param param) {\n  auto certVerify = std::move(*param.asCertificateVerify());\n\n  if (std::find(\n          state.context()->getSupportedSigSchemes().begin(),\n          state.context()->getSupportedSigSchemes().end(),\n          certVerify.algorithm) ==\n      state.context()->getSupportedSigSchemes().end()) {\n    throw FizzException(\n        folly::to<std::string>(\n            \"client chose unsupported sig scheme: \",\n            toString(certVerify.algorithm)),\n        AlertDescription::handshake_failure);\n  }\n\n  const auto& certs = *state.unverifiedCertChain();\n  auto leafCert = certs.front();\n  leafCert->verify(\n      certVerify.algorithm,\n      CertificateVerifyContext::Client,\n      state.handshakeContext()->getHandshakeContext()->coalesce(),\n      certVerify.signature->coalesce());\n\n  std::shared_ptr<const Cert> newCert;\n\n  try {\n    const auto& verifier = state.context()->getClientCertVerifier();\n    if (verifier) {\n      if (auto verifiedCert = verifier->verify(certs)) {\n        newCert = std::move(verifiedCert);\n      } else {\n        newCert = std::move(leafCert);\n      }\n    } else {\n      newCert = std::move(leafCert);\n    }\n  } catch (const FizzException&) {\n    throw;\n  } catch (const std::exception& e) {\n    throw FizzVerificationException(\n        folly::to<std::string>(\"client certificate failure: \", e.what()),\n        AlertDescription::bad_certificate);\n  }\n\n  state.handshakeContext()->appendToTranscript(*certVerify.originalEncoding);\n\n  return actions(\n      MutateState([cert = std::move(newCert)](State& newState) {\n        newState.unverifiedCertChain() = folly::none;\n        newState.clientCert() = std::move(cert);\n      }),\n      MutateState(&Transition<StateEnum::ExpectingFinished>));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingFinished, Event::Finished>::\n    handle(const State& state, Param param) {\n  auto& finished = *param.asFinished();\n\n  auto expectedFinished = state.handshakeContext()->getFinishedData(\n      state.clientHandshakeSecret()->coalesce());\n  if (!CryptoUtils::equal(\n          expectedFinished->coalesce(), finished.verify_data->coalesce())) {\n    throw FizzException(\"client finished verify failure\", folly::none);\n  }\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\"data after finished\", folly::none);\n  }\n\n  auto readRecordLayer =\n      state.context()->getFactory()->makeEncryptedReadRecordLayer(\n          EncryptionLevel::AppTraffic);\n  readRecordLayer->setProtocolVersion(*state.version());\n  auto readSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ClientAppTraffic);\n  Protocol::setAead(\n      *readRecordLayer,\n      *state.cipher(),\n      folly::range(readSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  state.handshakeContext()->appendToTranscript(*finished.originalEncoding);\n\n  auto resumptionMasterSecret =\n      state.keyScheduler()\n          ->getSecret(\n              MasterSecrets::ResumptionMaster,\n              state.handshakeContext()->getHandshakeContext()->coalesce())\n          .secret;\n  state.keyScheduler()->clearMasterSecret();\n\n  MutateState saveState([readRecordLayer = std::move(readRecordLayer),\n                         resumptionMasterSecret](State& newState) mutable {\n    newState.readRecordLayer() = std::move(readRecordLayer);\n    newState.resumptionMasterSecret() = std::move(resumptionMasterSecret);\n  });\n\n  SecretAvailable appReadTrafficSecretAvailable(std::move(readSecret));\n\n  if (!state.context()->getSendNewSessionTicket()) {\n    return actions(\n        std::move(saveState),\n        std::move(appReadTrafficSecretAvailable),\n        MutateState(&Transition<StateEnum::AcceptingData>),\n        ReportHandshakeSuccess());\n  } else {\n    auto ticketFuture = generateTicket(state, resumptionMasterSecret);\n    return runOnCallerIfComplete(\n        state.executor(),\n        std::move(ticketFuture),\n        [saveState = std::move(saveState),\n         appReadTrafficSecretAvailable =\n             std::move(appReadTrafficSecretAvailable)](\n            Optional<WriteToSocket> nstWrite) mutable {\n          if (!nstWrite) {\n            return actions(\n                std::move(saveState),\n                MutateState(&Transition<StateEnum::AcceptingData>),\n                std::move(appReadTrafficSecretAvailable),\n                ReportHandshakeSuccess());\n          }\n\n          return actions(\n              std::move(saveState),\n              MutateState(&Transition<StateEnum::AcceptingData>),\n              std::move(appReadTrafficSecretAvailable),\n              std::move(*nstWrite),\n              ReportHandshakeSuccess());\n        });\n  }\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::WriteNewSessionTicket>::handle(const State& state, Param param) {\n  auto& writeNewSessionTicket = *param.asWriteNewSessionTicket();\n  auto ticketFuture = generateTicket(\n      state,\n      state.resumptionMasterSecret(),\n      std::move(writeNewSessionTicket.appToken));\n  return runOnCallerIfComplete(\n      state.executor(),\n      std::move(ticketFuture),\n      [](Optional<WriteToSocket> nstWrite) {\n        if (!nstWrite) {\n          return Actions();\n        }\n        return actions(std::move(*nstWrite));\n      });\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::AppData>::handle(\n    const State& /*state*/,\n    Param param) {\n  auto& appData = *param.asAppData();\n\n  return actions(DeliverAppData{std::move(appData.data)});\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::AppWrite>::handle(\n    const State& state,\n    Param param) {\n  auto& appWrite = *param.asAppWrite();\n\n  WriteToSocket write;\n  write.callback = appWrite.callback;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAppData(\n      std::move(appWrite.data), appWrite.aeadOptions));\n  write.flags = appWrite.flags;\n\n  return actions(std::move(write));\n}\n\nAsyncActions EventHandler<\n    ServerTypes,\n    StateEnum::AcceptingData,\n    Event::KeyUpdateInitiation>::handle(const State& state, Param param) {\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\"data after key_update\", folly::none);\n  }\n  auto& keyUpdateInitiation = *param.asKeyUpdateInitiation();\n  auto encodedKeyUpdated =\n      Protocol::getKeyUpdated(keyUpdateInitiation.request_update);\n  WriteToSocket write;\n  write.contents.emplace_back(\n      state.writeRecordLayer()->writeHandshake(std::move(encodedKeyUpdated)));\n\n  state.keyScheduler()->serverKeyUpdate();\n\n  auto writeRecordLayer =\n      state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n          EncryptionLevel::AppTraffic);\n  writeRecordLayer->setProtocolVersion(*state.version());\n  auto writeSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ServerAppTraffic);\n  Protocol::setAead(\n      *writeRecordLayer,\n      *state.cipher(),\n      folly::range(writeSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  return actions(\n      MutateState([wRecordLayer =\n                       std::move(writeRecordLayer)](State& newState) mutable {\n        newState.writeRecordLayer() = std::move(wRecordLayer);\n      }),\n      SecretAvailable(std::move(writeSecret)),\n      std::move(write));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::KeyUpdate>::handle(\n    const State& state,\n    Param param) {\n  auto& keyUpdate = *param.asKeyUpdate();\n\n  if (state.readRecordLayer()->hasUnparsedHandshakeData()) {\n    throw FizzException(\"data after key_update\", folly::none);\n  }\n\n  state.keyScheduler()->clientKeyUpdate();\n  auto readRecordLayer =\n      state.context()->getFactory()->makeEncryptedReadRecordLayer(\n          EncryptionLevel::AppTraffic);\n  readRecordLayer->setProtocolVersion(*state.version());\n  auto readSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ClientAppTraffic);\n  Protocol::setAead(\n      *readRecordLayer,\n      *state.cipher(),\n      folly::range(readSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  if (keyUpdate.request_update == KeyUpdateRequest::update_not_requested) {\n    return actions(\n        MutateState([rRecordLayer =\n                         std::move(readRecordLayer)](State& newState) mutable {\n          newState.readRecordLayer() = std::move(rRecordLayer);\n        }),\n        SecretAvailable(std::move(readSecret)));\n  }\n\n  auto encodedKeyUpdated =\n      Protocol::getKeyUpdated(KeyUpdateRequest::update_not_requested);\n  WriteToSocket write;\n  write.contents.emplace_back(\n      state.writeRecordLayer()->writeHandshake(std::move(encodedKeyUpdated)));\n\n  state.keyScheduler()->serverKeyUpdate();\n\n  auto writeRecordLayer =\n      state.context()->getFactory()->makeEncryptedWriteRecordLayer(\n          EncryptionLevel::AppTraffic);\n  writeRecordLayer->setProtocolVersion(*state.version());\n  auto writeSecret =\n      state.keyScheduler()->getSecret(AppTrafficSecrets::ServerAppTraffic);\n  Protocol::setAead(\n      *writeRecordLayer,\n      *state.cipher(),\n      folly::range(writeSecret.secret),\n      *state.context()->getFactory(),\n      *state.keyScheduler());\n\n  return actions(\n      MutateState([rRecordLayer = std::move(readRecordLayer),\n                   wRecordLayer =\n                       std::move(writeRecordLayer)](State& newState) mutable {\n        newState.readRecordLayer() = std::move(rRecordLayer);\n        newState.writeRecordLayer() = std::move(wRecordLayer);\n      }),\n      SecretAvailable(std::move(writeSecret)),\n      SecretAvailable(std::move(readSecret)),\n      std::move(write));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::AcceptingData, Event::CloseNotify>::handle(\n    const State& state,\n    Param param) {\n  ensureNoUnparsedHandshakeData(state, Event::CloseNotify);\n  auto& closenotify = *param.asCloseNotify();\n  auto eod = EndOfData(std::move(closenotify.ignoredPostCloseData));\n\n  MutateState clearRecordLayers([](State& newState) {\n    newState.writeRecordLayer() = nullptr;\n    newState.readRecordLayer() = nullptr;\n  });\n\n  WriteToSocket write;\n  write.contents.emplace_back(state.writeRecordLayer()->writeAlert(\n      Alert(AlertDescription::close_notify)));\n  return actions(\n      std::move(write),\n      std::move(clearRecordLayers),\n      MutateState(&Transition<StateEnum::Closed>),\n      std::move(eod));\n}\n\nAsyncActions\nEventHandler<ServerTypes, StateEnum::ExpectingCloseNotify, Event::CloseNotify>::\n    handle(const State& state, Param param) {\n  ensureNoUnparsedHandshakeData(state, Event::CloseNotify);\n  auto& closenotify = *param.asCloseNotify();\n  auto eod = EndOfData(std::move(closenotify.ignoredPostCloseData));\n\n  MutateState clearRecordLayers([](State& newState) {\n    newState.readRecordLayer() = nullptr;\n    newState.writeRecordLayer() = nullptr;\n  });\n  return actions(\n      std::move(clearRecordLayers),\n      MutateState(&Transition<StateEnum::Closed>),\n      std::move(eod));\n}\n\n} // namespace sm\n} // namespace fizz\n"], "filenames": ["fizz/server/ServerProtocol.cpp"], "buggy_code_start_loc": [1216], "buggy_code_end_loc": [1292], "fixing_code_start_loc": [1217], "fixing_code_end_loc": [1291], "type": "CWE-617", "message": "There is a vulnerability in the fizz library prior to v2023.01.30.00 where a CHECK failure can be triggered remotely. This behavior requires the client supported cipher advertisement changing between the original ClientHello and the second ClientHello, crashing the process (impact is limited to denial of service).", "other": {"cve": {"id": "CVE-2023-23759", "sourceIdentifier": "cve-assign@fb.com", "published": "2023-05-18T22:15:09.597", "lastModified": "2023-05-27T00:59:33.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "There is a vulnerability in the fizz library prior to v2023.01.30.00 where a CHECK failure can be triggered remotely. This behavior requires the client supported cipher advertisement changing between the original ClientHello and the second ClientHello, crashing the process (impact is limited to denial of service)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:fizz:*:*:*:*:*:*:*:*", "versionEndExcluding": "2023.01.30.00", "matchCriteriaId": "A867776B-F2FD-4862-9D5F-DFEC19C29DB5"}]}]}], "references": [{"url": "https://github.com/facebookincubator/fizz/commit/8d3649841597bedfb6986c30431ebad0eb215265", "source": "cve-assign@fb.com", "tags": ["Patch"]}, {"url": "https://www.facebook.com/security/advisories/cve-2023-23759", "source": "cve-assign@fb.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebookincubator/fizz/commit/8d3649841597bedfb6986c30431ebad0eb215265"}}