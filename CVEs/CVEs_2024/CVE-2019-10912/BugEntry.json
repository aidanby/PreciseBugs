{"buggy_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit\\Legacy;\n\nuse Doctrine\\Common\\Annotations\\AnnotationRegistry;\nuse PHPUnit\\Framework\\AssertionFailedError;\nuse PHPUnit\\Framework\\TestCase;\nuse PHPUnit\\Framework\\TestSuite;\nuse PHPUnit\\Util\\Blacklist;\nuse Symfony\\Bridge\\PhpUnit\\ClockMock;\nuse Symfony\\Bridge\\PhpUnit\\DnsMock;\n\n/**\n * PHP 5.3 compatible trait-like shared implementation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nclass SymfonyTestsListenerTrait\n{\n    private static $globallyEnabled = false;\n    private $state = -1;\n    private $skippedFile = false;\n    private $wasSkipped = array();\n    private $isSkipped = array();\n    private $expectedDeprecations = array();\n    private $gatheredDeprecations = array();\n    private $previousErrorHandler;\n    private $testsWithWarnings;\n    private $reportUselessTests;\n    private $error;\n    private $runsInSeparateProcess = false;\n\n    /**\n     * @param array $mockedNamespaces List of namespaces, indexed by mocked features (time-sensitive or dns-sensitive)\n     */\n    public function __construct(array $mockedNamespaces = array())\n    {\n        if (class_exists('PHPUnit_Util_Blacklist')) {\n            \\PHPUnit_Util_Blacklist::$blacklistedClassNames['\\Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerTrait'] = 2;\n        } else {\n            Blacklist::$blacklistedClassNames['\\Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerTrait'] = 2;\n        }\n\n        $warn = false;\n        foreach ($mockedNamespaces as $type => $namespaces) {\n            if (!\\is_array($namespaces)) {\n                $namespaces = array($namespaces);\n            }\n            if (\\is_int($type)) {\n                // @deprecated BC with v2.8 to v3.0\n                $type = 'time-sensitive';\n                $warn = true;\n            }\n            if ('time-sensitive' === $type) {\n                foreach ($namespaces as $ns) {\n                    ClockMock::register($ns.'\\DummyClass');\n                }\n            }\n            if ('dns-sensitive' === $type) {\n                foreach ($namespaces as $ns) {\n                    DnsMock::register($ns.'\\DummyClass');\n                }\n            }\n        }\n        if (self::$globallyEnabled) {\n            $this->state = -2;\n        } else {\n            self::$globallyEnabled = true;\n            if ($warn) {\n                echo \"Clock-mocked namespaces for SymfonyTestsListener need to be nested in a \\\"time-sensitive\\\" key. This will be enforced in Symfony 4.0.\\n\";\n            }\n        }\n    }\n\n    public function __destruct()\n    {\n        if (0 < $this->state) {\n            file_put_contents($this->skippedFile, '<?php return '.var_export($this->isSkipped, true).';');\n        }\n    }\n\n    public function globalListenerDisabled()\n    {\n        self::$globallyEnabled = false;\n        $this->state = -1;\n    }\n\n    public function startTestSuite($suite)\n    {\n        if (class_exists('PHPUnit_Util_Blacklist', false)) {\n            $Test = 'PHPUnit_Util_Test';\n        } else {\n            $Test = 'PHPUnit\\Util\\Test';\n        }\n        $suiteName = $suite->getName();\n        $this->testsWithWarnings = array();\n\n        foreach ($suite->tests() as $test) {\n            if (!($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)) {\n                continue;\n            }\n            if (null === $Test::getPreserveGlobalStateSettings(\\get_class($test), $test->getName(false))) {\n                $test->setPreserveGlobalState(false);\n            }\n        }\n\n        if (-1 === $this->state) {\n            echo \"Testing $suiteName\\n\";\n            $this->state = 0;\n\n            if (!class_exists('Doctrine\\Common\\Annotations\\AnnotationRegistry', false) && class_exists('Doctrine\\Common\\Annotations\\AnnotationRegistry')) {\n                if (method_exists('Doctrine\\Common\\Annotations\\AnnotationRegistry', 'registerUniqueLoader')) {\n                    AnnotationRegistry::registerUniqueLoader('class_exists');\n                } else {\n                    AnnotationRegistry::registerLoader('class_exists');\n                }\n            }\n\n            if ($this->skippedFile = getenv('SYMFONY_PHPUNIT_SKIPPED_TESTS')) {\n                $this->state = 1;\n\n                if (file_exists($this->skippedFile)) {\n                    $this->state = 2;\n\n                    if (!$this->wasSkipped = require $this->skippedFile) {\n                        echo \"All tests already ran successfully.\\n\";\n                        $suite->setTests(array());\n                    }\n                }\n            }\n            $testSuites = array($suite);\n            for ($i = 0; isset($testSuites[$i]); ++$i) {\n                foreach ($testSuites[$i]->tests() as $test) {\n                    if ($test instanceof \\PHPUnit_Framework_TestSuite || $test instanceof TestSuite) {\n                        if (!class_exists($test->getName(), false)) {\n                            $testSuites[] = $test;\n                            continue;\n                        }\n                        $groups = $Test::getGroups($test->getName());\n                        if (\\in_array('time-sensitive', $groups, true)) {\n                            ClockMock::register($test->getName());\n                        }\n                        if (\\in_array('dns-sensitive', $groups, true)) {\n                            DnsMock::register($test->getName());\n                        }\n                    }\n                }\n            }\n        } elseif (2 === $this->state) {\n            $skipped = array();\n            foreach ($suite->tests() as $test) {\n                if (!($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)\n                    || isset($this->wasSkipped[$suiteName]['*'])\n                    || isset($this->wasSkipped[$suiteName][$test->getName()])) {\n                    $skipped[] = $test;\n                }\n            }\n            $suite->setTests($skipped);\n        }\n    }\n\n    public function addSkippedTest($test, \\Exception $e, $time)\n    {\n        if (0 < $this->state) {\n            if ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) {\n                $class = \\get_class($test);\n                $method = $test->getName();\n            } else {\n                $class = $test->getName();\n                $method = '*';\n            }\n\n            $this->isSkipped[$class][$method] = 1;\n        }\n    }\n\n    public function startTest($test)\n    {\n        if (-2 < $this->state && ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)) {\n            if (null !== $test->getTestResultObject()) {\n                $this->reportUselessTests = $test->getTestResultObject()->isStrictAboutTestsThatDoNotTestAnything();\n            }\n\n            // This event is triggered before the test is re-run in isolation\n            if ($this->willBeIsolated($test)) {\n                $this->runsInSeparateProcess = tempnam(sys_get_temp_dir(), 'deprec');\n                putenv('SYMFONY_DEPRECATIONS_SERIALIZE='.$this->runsInSeparateProcess);\n            }\n\n            if (class_exists('PHPUnit_Util_Blacklist', false)) {\n                $Test = 'PHPUnit_Util_Test';\n                $AssertionFailedError = 'PHPUnit_Framework_AssertionFailedError';\n            } else {\n                $Test = 'PHPUnit\\Util\\Test';\n                $AssertionFailedError = 'PHPUnit\\Framework\\AssertionFailedError';\n            }\n            $groups = $Test::getGroups(\\get_class($test), $test->getName(false));\n\n            if (!$this->runsInSeparateProcess) {\n                if (\\in_array('time-sensitive', $groups, true)) {\n                    ClockMock::register(\\get_class($test));\n                    ClockMock::withClockMock(true);\n                }\n                if (\\in_array('dns-sensitive', $groups, true)) {\n                    DnsMock::register(\\get_class($test));\n                }\n            }\n\n            $annotations = $Test::parseTestMethodAnnotations(\\get_class($test), $test->getName(false));\n\n            if (isset($annotations['class']['expectedDeprecation'])) {\n                $test->getTestResultObject()->addError($test, new $AssertionFailedError('`@expectedDeprecation` annotations are not allowed at the class level.'), 0);\n            }\n            if (isset($annotations['method']['expectedDeprecation'])) {\n                if (!\\in_array('legacy', $groups, true)) {\n                    $this->error = new $AssertionFailedError('Only tests with the `@group legacy` annotation can have `@expectedDeprecation`.');\n                }\n\n                $test->getTestResultObject()->beStrictAboutTestsThatDoNotTestAnything(false);\n\n                $this->expectedDeprecations = $annotations['method']['expectedDeprecation'];\n                $this->previousErrorHandler = set_error_handler(array($this, 'handleError'));\n            }\n        }\n    }\n\n    public function addWarning($test, $e, $time)\n    {\n        if ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) {\n            $this->testsWithWarnings[$test->getName()] = true;\n        }\n    }\n\n    public function endTest($test, $time)\n    {\n        if (class_exists('PHPUnit_Util_Blacklist', false)) {\n            $Test = 'PHPUnit_Util_Test';\n            $BaseTestRunner = 'PHPUnit_Runner_BaseTestRunner';\n            $Warning = 'PHPUnit_Framework_Warning';\n        } else {\n            $Test = 'PHPUnit\\Util\\Test';\n            $BaseTestRunner = 'PHPUnit\\Runner\\BaseTestRunner';\n            $Warning = 'PHPUnit\\Framework\\Warning';\n        }\n        $className = \\get_class($test);\n        $classGroups = $Test::getGroups($className);\n        $groups = $Test::getGroups($className, $test->getName(false));\n\n        if (null !== $this->reportUselessTests) {\n            $test->getTestResultObject()->beStrictAboutTestsThatDoNotTestAnything($this->reportUselessTests);\n            $this->reportUselessTests = null;\n        }\n\n        if ($errored = null !== $this->error) {\n            $test->getTestResultObject()->addError($test, $this->error, 0);\n            $this->error = null;\n        }\n\n        if ($this->runsInSeparateProcess) {\n            $deprecations = file_get_contents($this->runsInSeparateProcess);\n            unlink($this->runsInSeparateProcess);\n            putenv('SYMFONY_DEPRECATIONS_SERIALIZE');\n            foreach ($deprecations ? unserialize($deprecations) : array() as $deprecation) {\n                $error = serialize(array('deprecation' => $deprecation[1], 'class' => $className, 'method' => $test->getName(false), 'triggering_file' => isset($deprecation[2]) ? $deprecation[2] : null));\n                if ($deprecation[0]) {\n                    @trigger_error($error, E_USER_DEPRECATED);\n                } else {\n                    @trigger_error($error, E_USER_DEPRECATED);\n                }\n            }\n            $this->runsInSeparateProcess = false;\n        }\n\n        if ($this->expectedDeprecations) {\n            if (!\\in_array($test->getStatus(), array($BaseTestRunner::STATUS_SKIPPED, $BaseTestRunner::STATUS_INCOMPLETE), true)) {\n                $test->addToAssertionCount(\\count($this->expectedDeprecations));\n            }\n\n            restore_error_handler();\n\n            if (!$errored && !\\in_array($test->getStatus(), array($BaseTestRunner::STATUS_SKIPPED, $BaseTestRunner::STATUS_INCOMPLETE, $BaseTestRunner::STATUS_FAILURE, $BaseTestRunner::STATUS_ERROR), true)) {\n                try {\n                    $prefix = \"@expectedDeprecation:\\n\";\n                    $test->assertStringMatchesFormat($prefix.'%A  '.implode(\"\\n%A  \", $this->expectedDeprecations).\"\\n%A\", $prefix.'  '.implode(\"\\n  \", $this->gatheredDeprecations).\"\\n\");\n                } catch (AssertionFailedError $e) {\n                    $test->getTestResultObject()->addFailure($test, $e, $time);\n                } catch (\\PHPUnit_Framework_AssertionFailedError $e) {\n                    $test->getTestResultObject()->addFailure($test, $e, $time);\n                }\n            }\n\n            $this->expectedDeprecations = $this->gatheredDeprecations = array();\n            $this->previousErrorHandler = null;\n        }\n        if (!$this->runsInSeparateProcess && -2 < $this->state && ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)) {\n            if (\\in_array('time-sensitive', $groups, true)) {\n                ClockMock::withClockMock(false);\n            }\n            if (\\in_array('dns-sensitive', $groups, true)) {\n                DnsMock::withMockedHosts(array());\n            }\n        }\n\n        if (($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) && 0 === strpos($test->getName(), 'testLegacy') && !isset($this->testsWithWarnings[$test->getName()]) && !\\in_array('legacy', $groups, true)) {\n            $result = $test->getTestResultObject();\n\n            if (method_exists($result, 'addWarning')) {\n                $result->addWarning($test, new $Warning('Using the \"testLegacy\" prefix to mark tests as legacy is deprecated since version 3.3 and will be removed in 4.0. Use the \"@group legacy\" notation instead to add the test to the legacy group.'), $time);\n            }\n        }\n\n        if (($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) && strpos($className, '\\Legacy') && !isset($this->testsWithWarnings[$test->getName()]) && !\\in_array('legacy', $classGroups, true)) {\n            $result = $test->getTestResultObject();\n\n            if (method_exists($result, 'addWarning')) {\n                $result->addWarning($test, new $Warning('Using the \"Legacy\" prefix to mark all tests of a class as legacy is deprecated since version 3.3 and will be removed in 4.0. Use the \"@group legacy\" notation instead to add the test to the legacy group.'), $time);\n            }\n        }\n    }\n\n    public function handleError($type, $msg, $file, $line, $context = array())\n    {\n        if (E_USER_DEPRECATED !== $type && E_DEPRECATED !== $type) {\n            $h = $this->previousErrorHandler;\n\n            return $h ? $h($type, $msg, $file, $line, $context) : false;\n        }\n        // If the message is serialized we need to extract the message. This occurs when the error is triggered by\n        // by the isolated test path in \\Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerTrait::endTest().\n        $parsedMsg = @unserialize($msg);\n        if (\\is_array($parsedMsg)) {\n            $msg = $parsedMsg['deprecation'];\n        }\n        if (error_reporting()) {\n            $msg = 'Unsilenced deprecation: '.$msg;\n        }\n        $this->gatheredDeprecations[] = $msg;\n    }\n\n    /**\n     * @param TestCase $test\n     *\n     * @return bool\n     */\n    private function willBeIsolated($test)\n    {\n        if ($test->isInIsolation()) {\n            return false;\n        }\n\n        $r = new \\ReflectionProperty($test, 'runTestInSeparateProcess');\n        $r->setAccessible(true);\n\n        return $r->getValue($test);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\FrameworkBundle\\Tests\\Kernel;\n\nuse Psr\\Log\\NullLogger;\nuse Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle;\nuse Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait;\nuse Symfony\\Component\\Config\\Loader\\LoaderInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseForExceptionEvent;\nuse Symfony\\Component\\HttpKernel\\Kernel;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\nuse Symfony\\Component\\Routing\\RouteCollectionBuilder;\n\nclass ConcreteMicroKernel extends Kernel implements EventSubscriberInterface\n{\n    use MicroKernelTrait;\n\n    private $cacheDir;\n\n    public function onKernelException(GetResponseForExceptionEvent $event)\n    {\n        if ($event->getException() instanceof Danger) {\n            $event->setResponse(Response::create('It\\'s dangerous to go alone. Take this \u2694'));\n        }\n    }\n\n    public function halloweenAction()\n    {\n        return new Response('halloween');\n    }\n\n    public function dangerousAction()\n    {\n        throw new Danger();\n    }\n\n    public function registerBundles()\n    {\n        return [\n            new FrameworkBundle(),\n        ];\n    }\n\n    public function getCacheDir()\n    {\n        return $this->cacheDir = sys_get_temp_dir().'/sf_micro_kernel';\n    }\n\n    public function getLogDir()\n    {\n        return $this->cacheDir;\n    }\n\n    public function __destruct()\n    {\n        $fs = new Filesystem();\n        $fs->remove($this->cacheDir);\n    }\n\n    protected function configureRoutes(RouteCollectionBuilder $routes)\n    {\n        $routes->add('/', 'kernel:halloweenAction');\n        $routes->add('/danger', 'kernel:dangerousAction');\n    }\n\n    protected function configureContainer(ContainerBuilder $c, LoaderInterface $loader)\n    {\n        $c->register('logger', NullLogger::class);\n        $c->loadFromExtension('framework', [\n            'secret' => '$ecret',\n        ]);\n\n        $c->setParameter('halloween', 'Have a great day!');\n        $c->register('halloween', 'stdClass')->setPublic(true);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public static function getSubscribedEvents()\n    {\n        return [\n            KernelEvents::EXCEPTION => 'onKernelException',\n        ];\n    }\n}\n\nclass Danger extends \\RuntimeException\n{\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache\\Traits;\n\nuse Symfony\\Component\\Cache\\Exception\\InvalidArgumentException;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\ntrait FilesystemCommonTrait\n{\n    private $directory;\n    private $tmp;\n\n    private function init($namespace, $directory)\n    {\n        if (!isset($directory[0])) {\n            $directory = sys_get_temp_dir().'/symfony-cache';\n        } else {\n            $directory = realpath($directory) ?: $directory;\n        }\n        if (isset($namespace[0])) {\n            if (preg_match('#[^-+_.A-Za-z0-9]#', $namespace, $match)) {\n                throw new InvalidArgumentException(sprintf('Namespace contains \"%s\" but only characters in [-+_.A-Za-z0-9] are allowed.', $match[0]));\n            }\n            $directory .= \\DIRECTORY_SEPARATOR.$namespace;\n        }\n        if (!file_exists($directory)) {\n            @mkdir($directory, 0777, true);\n        }\n        $directory .= \\DIRECTORY_SEPARATOR;\n        // On Windows the whole path is limited to 258 chars\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && \\strlen($directory) > 234) {\n            throw new InvalidArgumentException(sprintf('Cache directory too long (%s)', $directory));\n        }\n\n        $this->directory = $directory;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function doClear($namespace)\n    {\n        $ok = true;\n\n        foreach (new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($this->directory, \\FilesystemIterator::SKIP_DOTS)) as $file) {\n            $ok = ($file->isDir() || @unlink($file) || !file_exists($file)) && $ok;\n        }\n\n        return $ok;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function doDelete(array $ids)\n    {\n        $ok = true;\n\n        foreach ($ids as $id) {\n            $file = $this->getFile($id);\n            $ok = (!file_exists($file) || @unlink($file) || !file_exists($file)) && $ok;\n        }\n\n        return $ok;\n    }\n\n    private function write($file, $data, $expiresAt = null)\n    {\n        set_error_handler(__CLASS__.'::throwError');\n        try {\n            if (null === $this->tmp) {\n                $this->tmp = $this->directory.uniqid('', true);\n            }\n            file_put_contents($this->tmp, $data);\n\n            if (null !== $expiresAt) {\n                touch($this->tmp, $expiresAt);\n            }\n\n            return rename($this->tmp, $file);\n        } finally {\n            restore_error_handler();\n        }\n    }\n\n    private function getFile($id, $mkdir = false)\n    {\n        $hash = str_replace('/', '-', base64_encode(hash('sha256', static::class.$id, true)));\n        $dir = $this->directory.strtoupper($hash[0].\\DIRECTORY_SEPARATOR.$hash[1].\\DIRECTORY_SEPARATOR);\n\n        if ($mkdir && !file_exists($dir)) {\n            @mkdir($dir, 0777, true);\n        }\n\n        return $dir.substr($hash, 2, 20);\n    }\n\n    /**\n     * @internal\n     */\n    public static function throwError($type, $message, $file, $line)\n    {\n        throw new \\ErrorException($message, 0, $type, $file, $line);\n    }\n\n    public function __destruct()\n    {\n        if (method_exists(parent::class, '__destruct')) {\n            parent::__destruct();\n        }\n        if (null !== $this->tmp && file_exists($this->tmp)) {\n            unlink($this->tmp);\n        }\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bridge\\PhpUnit\\Legacy;\n\nuse Doctrine\\Common\\Annotations\\AnnotationRegistry;\nuse PHPUnit\\Framework\\AssertionFailedError;\nuse PHPUnit\\Framework\\TestCase;\nuse PHPUnit\\Framework\\TestSuite;\nuse PHPUnit\\Util\\Blacklist;\nuse Symfony\\Bridge\\PhpUnit\\ClockMock;\nuse Symfony\\Bridge\\PhpUnit\\DnsMock;\n\n/**\n * PHP 5.3 compatible trait-like shared implementation.\n *\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\nclass SymfonyTestsListenerTrait\n{\n    private static $globallyEnabled = false;\n    private $state = -1;\n    private $skippedFile = false;\n    private $wasSkipped = array();\n    private $isSkipped = array();\n    private $expectedDeprecations = array();\n    private $gatheredDeprecations = array();\n    private $previousErrorHandler;\n    private $testsWithWarnings;\n    private $reportUselessTests;\n    private $error;\n    private $runsInSeparateProcess = false;\n\n    /**\n     * @param array $mockedNamespaces List of namespaces, indexed by mocked features (time-sensitive or dns-sensitive)\n     */\n    public function __construct(array $mockedNamespaces = array())\n    {\n        if (class_exists('PHPUnit_Util_Blacklist')) {\n            \\PHPUnit_Util_Blacklist::$blacklistedClassNames['\\Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerTrait'] = 2;\n        } else {\n            Blacklist::$blacklistedClassNames['\\Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerTrait'] = 2;\n        }\n\n        $warn = false;\n        foreach ($mockedNamespaces as $type => $namespaces) {\n            if (!\\is_array($namespaces)) {\n                $namespaces = array($namespaces);\n            }\n            if (\\is_int($type)) {\n                // @deprecated BC with v2.8 to v3.0\n                $type = 'time-sensitive';\n                $warn = true;\n            }\n            if ('time-sensitive' === $type) {\n                foreach ($namespaces as $ns) {\n                    ClockMock::register($ns.'\\DummyClass');\n                }\n            }\n            if ('dns-sensitive' === $type) {\n                foreach ($namespaces as $ns) {\n                    DnsMock::register($ns.'\\DummyClass');\n                }\n            }\n        }\n        if (self::$globallyEnabled) {\n            $this->state = -2;\n        } else {\n            self::$globallyEnabled = true;\n            if ($warn) {\n                echo \"Clock-mocked namespaces for SymfonyTestsListener need to be nested in a \\\"time-sensitive\\\" key. This will be enforced in Symfony 4.0.\\n\";\n            }\n        }\n    }\n\n    public function __sleep()\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __wakeup()\n    {\n        throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n    }\n\n    public function __destruct()\n    {\n        if (0 < $this->state) {\n            file_put_contents($this->skippedFile, '<?php return '.var_export($this->isSkipped, true).';');\n        }\n    }\n\n    public function globalListenerDisabled()\n    {\n        self::$globallyEnabled = false;\n        $this->state = -1;\n    }\n\n    public function startTestSuite($suite)\n    {\n        if (class_exists('PHPUnit_Util_Blacklist', false)) {\n            $Test = 'PHPUnit_Util_Test';\n        } else {\n            $Test = 'PHPUnit\\Util\\Test';\n        }\n        $suiteName = $suite->getName();\n        $this->testsWithWarnings = array();\n\n        foreach ($suite->tests() as $test) {\n            if (!($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)) {\n                continue;\n            }\n            if (null === $Test::getPreserveGlobalStateSettings(\\get_class($test), $test->getName(false))) {\n                $test->setPreserveGlobalState(false);\n            }\n        }\n\n        if (-1 === $this->state) {\n            echo \"Testing $suiteName\\n\";\n            $this->state = 0;\n\n            if (!class_exists('Doctrine\\Common\\Annotations\\AnnotationRegistry', false) && class_exists('Doctrine\\Common\\Annotations\\AnnotationRegistry')) {\n                if (method_exists('Doctrine\\Common\\Annotations\\AnnotationRegistry', 'registerUniqueLoader')) {\n                    AnnotationRegistry::registerUniqueLoader('class_exists');\n                } else {\n                    AnnotationRegistry::registerLoader('class_exists');\n                }\n            }\n\n            if ($this->skippedFile = getenv('SYMFONY_PHPUNIT_SKIPPED_TESTS')) {\n                $this->state = 1;\n\n                if (file_exists($this->skippedFile)) {\n                    $this->state = 2;\n\n                    if (!$this->wasSkipped = require $this->skippedFile) {\n                        echo \"All tests already ran successfully.\\n\";\n                        $suite->setTests(array());\n                    }\n                }\n            }\n            $testSuites = array($suite);\n            for ($i = 0; isset($testSuites[$i]); ++$i) {\n                foreach ($testSuites[$i]->tests() as $test) {\n                    if ($test instanceof \\PHPUnit_Framework_TestSuite || $test instanceof TestSuite) {\n                        if (!class_exists($test->getName(), false)) {\n                            $testSuites[] = $test;\n                            continue;\n                        }\n                        $groups = $Test::getGroups($test->getName());\n                        if (\\in_array('time-sensitive', $groups, true)) {\n                            ClockMock::register($test->getName());\n                        }\n                        if (\\in_array('dns-sensitive', $groups, true)) {\n                            DnsMock::register($test->getName());\n                        }\n                    }\n                }\n            }\n        } elseif (2 === $this->state) {\n            $skipped = array();\n            foreach ($suite->tests() as $test) {\n                if (!($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)\n                    || isset($this->wasSkipped[$suiteName]['*'])\n                    || isset($this->wasSkipped[$suiteName][$test->getName()])) {\n                    $skipped[] = $test;\n                }\n            }\n            $suite->setTests($skipped);\n        }\n    }\n\n    public function addSkippedTest($test, \\Exception $e, $time)\n    {\n        if (0 < $this->state) {\n            if ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) {\n                $class = \\get_class($test);\n                $method = $test->getName();\n            } else {\n                $class = $test->getName();\n                $method = '*';\n            }\n\n            $this->isSkipped[$class][$method] = 1;\n        }\n    }\n\n    public function startTest($test)\n    {\n        if (-2 < $this->state && ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)) {\n            if (null !== $test->getTestResultObject()) {\n                $this->reportUselessTests = $test->getTestResultObject()->isStrictAboutTestsThatDoNotTestAnything();\n            }\n\n            // This event is triggered before the test is re-run in isolation\n            if ($this->willBeIsolated($test)) {\n                $this->runsInSeparateProcess = tempnam(sys_get_temp_dir(), 'deprec');\n                putenv('SYMFONY_DEPRECATIONS_SERIALIZE='.$this->runsInSeparateProcess);\n            }\n\n            if (class_exists('PHPUnit_Util_Blacklist', false)) {\n                $Test = 'PHPUnit_Util_Test';\n                $AssertionFailedError = 'PHPUnit_Framework_AssertionFailedError';\n            } else {\n                $Test = 'PHPUnit\\Util\\Test';\n                $AssertionFailedError = 'PHPUnit\\Framework\\AssertionFailedError';\n            }\n            $groups = $Test::getGroups(\\get_class($test), $test->getName(false));\n\n            if (!$this->runsInSeparateProcess) {\n                if (\\in_array('time-sensitive', $groups, true)) {\n                    ClockMock::register(\\get_class($test));\n                    ClockMock::withClockMock(true);\n                }\n                if (\\in_array('dns-sensitive', $groups, true)) {\n                    DnsMock::register(\\get_class($test));\n                }\n            }\n\n            $annotations = $Test::parseTestMethodAnnotations(\\get_class($test), $test->getName(false));\n\n            if (isset($annotations['class']['expectedDeprecation'])) {\n                $test->getTestResultObject()->addError($test, new $AssertionFailedError('`@expectedDeprecation` annotations are not allowed at the class level.'), 0);\n            }\n            if (isset($annotations['method']['expectedDeprecation'])) {\n                if (!\\in_array('legacy', $groups, true)) {\n                    $this->error = new $AssertionFailedError('Only tests with the `@group legacy` annotation can have `@expectedDeprecation`.');\n                }\n\n                $test->getTestResultObject()->beStrictAboutTestsThatDoNotTestAnything(false);\n\n                $this->expectedDeprecations = $annotations['method']['expectedDeprecation'];\n                $this->previousErrorHandler = set_error_handler(array($this, 'handleError'));\n            }\n        }\n    }\n\n    public function addWarning($test, $e, $time)\n    {\n        if ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) {\n            $this->testsWithWarnings[$test->getName()] = true;\n        }\n    }\n\n    public function endTest($test, $time)\n    {\n        if (class_exists('PHPUnit_Util_Blacklist', false)) {\n            $Test = 'PHPUnit_Util_Test';\n            $BaseTestRunner = 'PHPUnit_Runner_BaseTestRunner';\n            $Warning = 'PHPUnit_Framework_Warning';\n        } else {\n            $Test = 'PHPUnit\\Util\\Test';\n            $BaseTestRunner = 'PHPUnit\\Runner\\BaseTestRunner';\n            $Warning = 'PHPUnit\\Framework\\Warning';\n        }\n        $className = \\get_class($test);\n        $classGroups = $Test::getGroups($className);\n        $groups = $Test::getGroups($className, $test->getName(false));\n\n        if (null !== $this->reportUselessTests) {\n            $test->getTestResultObject()->beStrictAboutTestsThatDoNotTestAnything($this->reportUselessTests);\n            $this->reportUselessTests = null;\n        }\n\n        if ($errored = null !== $this->error) {\n            $test->getTestResultObject()->addError($test, $this->error, 0);\n            $this->error = null;\n        }\n\n        if ($this->runsInSeparateProcess) {\n            $deprecations = file_get_contents($this->runsInSeparateProcess);\n            unlink($this->runsInSeparateProcess);\n            putenv('SYMFONY_DEPRECATIONS_SERIALIZE');\n            foreach ($deprecations ? unserialize($deprecations) : array() as $deprecation) {\n                $error = serialize(array('deprecation' => $deprecation[1], 'class' => $className, 'method' => $test->getName(false), 'triggering_file' => isset($deprecation[2]) ? $deprecation[2] : null));\n                if ($deprecation[0]) {\n                    @trigger_error($error, E_USER_DEPRECATED);\n                } else {\n                    @trigger_error($error, E_USER_DEPRECATED);\n                }\n            }\n            $this->runsInSeparateProcess = false;\n        }\n\n        if ($this->expectedDeprecations) {\n            if (!\\in_array($test->getStatus(), array($BaseTestRunner::STATUS_SKIPPED, $BaseTestRunner::STATUS_INCOMPLETE), true)) {\n                $test->addToAssertionCount(\\count($this->expectedDeprecations));\n            }\n\n            restore_error_handler();\n\n            if (!$errored && !\\in_array($test->getStatus(), array($BaseTestRunner::STATUS_SKIPPED, $BaseTestRunner::STATUS_INCOMPLETE, $BaseTestRunner::STATUS_FAILURE, $BaseTestRunner::STATUS_ERROR), true)) {\n                try {\n                    $prefix = \"@expectedDeprecation:\\n\";\n                    $test->assertStringMatchesFormat($prefix.'%A  '.implode(\"\\n%A  \", $this->expectedDeprecations).\"\\n%A\", $prefix.'  '.implode(\"\\n  \", $this->gatheredDeprecations).\"\\n\");\n                } catch (AssertionFailedError $e) {\n                    $test->getTestResultObject()->addFailure($test, $e, $time);\n                } catch (\\PHPUnit_Framework_AssertionFailedError $e) {\n                    $test->getTestResultObject()->addFailure($test, $e, $time);\n                }\n            }\n\n            $this->expectedDeprecations = $this->gatheredDeprecations = array();\n            $this->previousErrorHandler = null;\n        }\n        if (!$this->runsInSeparateProcess && -2 < $this->state && ($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase)) {\n            if (\\in_array('time-sensitive', $groups, true)) {\n                ClockMock::withClockMock(false);\n            }\n            if (\\in_array('dns-sensitive', $groups, true)) {\n                DnsMock::withMockedHosts(array());\n            }\n        }\n\n        if (($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) && 0 === strpos($test->getName(), 'testLegacy') && !isset($this->testsWithWarnings[$test->getName()]) && !\\in_array('legacy', $groups, true)) {\n            $result = $test->getTestResultObject();\n\n            if (method_exists($result, 'addWarning')) {\n                $result->addWarning($test, new $Warning('Using the \"testLegacy\" prefix to mark tests as legacy is deprecated since version 3.3 and will be removed in 4.0. Use the \"@group legacy\" notation instead to add the test to the legacy group.'), $time);\n            }\n        }\n\n        if (($test instanceof \\PHPUnit\\Framework\\TestCase || $test instanceof TestCase) && strpos($className, '\\Legacy') && !isset($this->testsWithWarnings[$test->getName()]) && !\\in_array('legacy', $classGroups, true)) {\n            $result = $test->getTestResultObject();\n\n            if (method_exists($result, 'addWarning')) {\n                $result->addWarning($test, new $Warning('Using the \"Legacy\" prefix to mark all tests of a class as legacy is deprecated since version 3.3 and will be removed in 4.0. Use the \"@group legacy\" notation instead to add the test to the legacy group.'), $time);\n            }\n        }\n    }\n\n    public function handleError($type, $msg, $file, $line, $context = array())\n    {\n        if (E_USER_DEPRECATED !== $type && E_DEPRECATED !== $type) {\n            $h = $this->previousErrorHandler;\n\n            return $h ? $h($type, $msg, $file, $line, $context) : false;\n        }\n        // If the message is serialized we need to extract the message. This occurs when the error is triggered by\n        // by the isolated test path in \\Symfony\\Bridge\\PhpUnit\\Legacy\\SymfonyTestsListenerTrait::endTest().\n        $parsedMsg = @unserialize($msg);\n        if (\\is_array($parsedMsg)) {\n            $msg = $parsedMsg['deprecation'];\n        }\n        if (error_reporting()) {\n            $msg = 'Unsilenced deprecation: '.$msg;\n        }\n        $this->gatheredDeprecations[] = $msg;\n    }\n\n    /**\n     * @param TestCase $test\n     *\n     * @return bool\n     */\n    private function willBeIsolated($test)\n    {\n        if ($test->isInIsolation()) {\n            return false;\n        }\n\n        $r = new \\ReflectionProperty($test, 'runTestInSeparateProcess');\n        $r->setAccessible(true);\n\n        return $r->getValue($test);\n    }\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Bundle\\FrameworkBundle\\Tests\\Kernel;\n\nuse Psr\\Log\\NullLogger;\nuse Symfony\\Bundle\\FrameworkBundle\\FrameworkBundle;\nuse Symfony\\Bundle\\FrameworkBundle\\Kernel\\MicroKernelTrait;\nuse Symfony\\Component\\Config\\Loader\\LoaderInterface;\nuse Symfony\\Component\\DependencyInjection\\ContainerBuilder;\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\Filesystem\\Filesystem;\nuse Symfony\\Component\\HttpFoundation\\Response;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseForExceptionEvent;\nuse Symfony\\Component\\HttpKernel\\Kernel;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\nuse Symfony\\Component\\Routing\\RouteCollectionBuilder;\n\nclass ConcreteMicroKernel extends Kernel implements EventSubscriberInterface\n{\n    use MicroKernelTrait;\n\n    private $cacheDir;\n\n    public function onKernelException(GetResponseForExceptionEvent $event)\n    {\n        if ($event->getException() instanceof Danger) {\n            $event->setResponse(Response::create('It\\'s dangerous to go alone. Take this \u2694'));\n        }\n    }\n\n    public function halloweenAction()\n    {\n        return new Response('halloween');\n    }\n\n    public function dangerousAction()\n    {\n        throw new Danger();\n    }\n\n    public function registerBundles()\n    {\n        return [\n            new FrameworkBundle(),\n        ];\n    }\n\n    public function getCacheDir()\n    {\n        return $this->cacheDir = sys_get_temp_dir().'/sf_micro_kernel';\n    }\n\n    public function getLogDir()\n    {\n        return $this->cacheDir;\n    }\n\n    public function __sleep()\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __wakeup()\n    {\n        throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n    }\n\n    public function __destruct()\n    {\n        $fs = new Filesystem();\n        $fs->remove($this->cacheDir);\n    }\n\n    protected function configureRoutes(RouteCollectionBuilder $routes)\n    {\n        $routes->add('/', 'kernel:halloweenAction');\n        $routes->add('/danger', 'kernel:dangerousAction');\n    }\n\n    protected function configureContainer(ContainerBuilder $c, LoaderInterface $loader)\n    {\n        $c->register('logger', NullLogger::class);\n        $c->loadFromExtension('framework', [\n            'secret' => '$ecret',\n        ]);\n\n        $c->setParameter('halloween', 'Have a great day!');\n        $c->register('halloween', 'stdClass')->setPublic(true);\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public static function getSubscribedEvents()\n    {\n        return [\n            KernelEvents::EXCEPTION => 'onKernelException',\n        ];\n    }\n}\n\nclass Danger extends \\RuntimeException\n{\n}\n", "<?php\n\n/*\n * This file is part of the Symfony package.\n *\n * (c) Fabien Potencier <fabien@symfony.com>\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Symfony\\Component\\Cache\\Traits;\n\nuse Symfony\\Component\\Cache\\Exception\\InvalidArgumentException;\n\n/**\n * @author Nicolas Grekas <p@tchwork.com>\n *\n * @internal\n */\ntrait FilesystemCommonTrait\n{\n    private $directory;\n    private $tmp;\n\n    private function init($namespace, $directory)\n    {\n        if (!isset($directory[0])) {\n            $directory = sys_get_temp_dir().'/symfony-cache';\n        } else {\n            $directory = realpath($directory) ?: $directory;\n        }\n        if (isset($namespace[0])) {\n            if (preg_match('#[^-+_.A-Za-z0-9]#', $namespace, $match)) {\n                throw new InvalidArgumentException(sprintf('Namespace contains \"%s\" but only characters in [-+_.A-Za-z0-9] are allowed.', $match[0]));\n            }\n            $directory .= \\DIRECTORY_SEPARATOR.$namespace;\n        }\n        if (!file_exists($directory)) {\n            @mkdir($directory, 0777, true);\n        }\n        $directory .= \\DIRECTORY_SEPARATOR;\n        // On Windows the whole path is limited to 258 chars\n        if ('\\\\' === \\DIRECTORY_SEPARATOR && \\strlen($directory) > 234) {\n            throw new InvalidArgumentException(sprintf('Cache directory too long (%s)', $directory));\n        }\n\n        $this->directory = $directory;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function doClear($namespace)\n    {\n        $ok = true;\n\n        foreach (new \\RecursiveIteratorIterator(new \\RecursiveDirectoryIterator($this->directory, \\FilesystemIterator::SKIP_DOTS)) as $file) {\n            $ok = ($file->isDir() || @unlink($file) || !file_exists($file)) && $ok;\n        }\n\n        return $ok;\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    protected function doDelete(array $ids)\n    {\n        $ok = true;\n\n        foreach ($ids as $id) {\n            $file = $this->getFile($id);\n            $ok = (!file_exists($file) || @unlink($file) || !file_exists($file)) && $ok;\n        }\n\n        return $ok;\n    }\n\n    private function write($file, $data, $expiresAt = null)\n    {\n        set_error_handler(__CLASS__.'::throwError');\n        try {\n            if (null === $this->tmp) {\n                $this->tmp = $this->directory.uniqid('', true);\n            }\n            file_put_contents($this->tmp, $data);\n\n            if (null !== $expiresAt) {\n                touch($this->tmp, $expiresAt);\n            }\n\n            return rename($this->tmp, $file);\n        } finally {\n            restore_error_handler();\n        }\n    }\n\n    private function getFile($id, $mkdir = false)\n    {\n        $hash = str_replace('/', '-', base64_encode(hash('sha256', static::class.$id, true)));\n        $dir = $this->directory.strtoupper($hash[0].\\DIRECTORY_SEPARATOR.$hash[1].\\DIRECTORY_SEPARATOR);\n\n        if ($mkdir && !file_exists($dir)) {\n            @mkdir($dir, 0777, true);\n        }\n\n        return $dir.substr($hash, 2, 20);\n    }\n\n    /**\n     * @internal\n     */\n    public static function throwError($type, $message, $file, $line)\n    {\n        throw new \\ErrorException($message, 0, $type, $file, $line);\n    }\n\n    public function __sleep()\n    {\n        throw new \\BadMethodCallException('Cannot serialize '.__CLASS__);\n    }\n\n    public function __wakeup()\n    {\n        throw new \\BadMethodCallException('Cannot unserialize '.__CLASS__);\n    }\n\n    public function __destruct()\n    {\n        if (method_exists(parent::class, '__destruct')) {\n            parent::__destruct();\n        }\n        if (null !== $this->tmp && file_exists($this->tmp)) {\n            unlink($this->tmp);\n        }\n    }\n}\n"], "filenames": ["src/Symfony/Bridge/PhpUnit/Legacy/SymfonyTestsListenerTrait.php", "src/Symfony/Bundle/FrameworkBundle/Tests/Kernel/ConcreteMicroKernel.php", "src/Symfony/Component/Cache/Traits/FilesystemCommonTrait.php"], "buggy_code_start_loc": [85, 66, 118], "buggy_code_end_loc": [85, 66, 118], "fixing_code_start_loc": [86, 67, 119], "fixing_code_end_loc": [96, 77, 129], "type": "CWE-502", "message": "In Symfony before 2.8.50, 3.x before 3.4.26, 4.x before 4.1.12, and 4.2.x before 4.2.7, it is possible to cache objects that may contain bad user input. On serialization or unserialization, this could result in the deletion of files that the current user has access to. This is related to symfony/cache and symfony/phpunit-bridge.", "other": {"cve": {"id": "CVE-2019-10912", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-16T22:29:00.580", "lastModified": "2019-07-12T14:15:11.450", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In Symfony before 2.8.50, 3.x before 3.4.26, 4.x before 4.1.12, and 4.2.x before 4.2.7, it is possible to cache objects that may contain bad user input. On serialization or unserialization, this could result in the deletion of files that the current user has access to. This is related to symfony/cache and symfony/phpunit-bridge."}, {"lang": "es", "value": "En Symfony versi\u00f3n anterior a 2.8.50, versi\u00f3n 3.x anterior a 3.4.26, versi\u00f3n 4.x anterior a 4.1.12 y versi\u00f3n 4.2.x anterior a 4.2.7, es posible guardar en cach\u00e9 objetos que pueden contener informaci\u00f3n errada del usuario. En la serializaci\u00f3n o unserialization, esto podr\u00eda resultar en la eliminaci\u00f3n de archivos a los que el usuario actual tiene acceso. Esto est\u00e1 relacionado con Symfony/cache y Symfony/ phpunit-bridge."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.50", "matchCriteriaId": "A4716654-1055-44B3-8E51-5BC0E739E0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.26", "matchCriteriaId": "CF53486E-FAAC-40B3-82CE-4EDCD2C96690"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.0", "versionEndExcluding": "4.1.12", "matchCriteriaId": "25A92454-6E0B-4BDE-8967-BB3E32125102"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sensiolabs:symfony:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2.0", "versionEndExcluding": "4.2.7", "matchCriteriaId": "53E58B92-6D5D-4949-B75F-687F52961FDA"}]}]}], "references": [{"url": "https://github.com/symfony/symfony/commit/4fb975281634b8d49ebf013af9e502e67c28816b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/42UEKSLKJB72P24JBWVN6AADHLMYSUQD/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6QEAOZXVNDA63537A2OIH4QE77EKZR5O/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BAC2TQVEEH5FDJSSWPM2BCRIPTCOEMMO/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BHHIG4GMSGEIDT3RITSW7GJ5NT6IBHXU/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LFARAUAWZE4UDSKVDWRD35D75HI5UGSD/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MDSM576XIOVXVCMHNJHLBBZBTOD62LDA/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RTJGZJLPG5FHKFH7KNAKNTWOGBB6LXAL/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/ZLOZX5BZMQKWG7PJRQL6MB5CAMKBQAWD/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/May/21", "source": "cve@mitre.org"}, {"url": "https://symfony.com/blog/cve-2019-10912-prevent-destructors-with-side-effects-from-being-unserialized", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://typo3.org/security/advisory/typo3-core-sa-2019-016/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4441", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/symfony/symfony/commit/4fb975281634b8d49ebf013af9e502e67c28816b"}}