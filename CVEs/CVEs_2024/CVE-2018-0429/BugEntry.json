{"buggy_code": ["/*\nCopyright (c) 2015, Cisco Systems\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <string.h>\n#include <memory.h>\n#include <assert.h>\n\n#include \"global.h\"\n#include \"snr.h\"\n#include \"getvlc.h\"\n#include \"read_bits.h\"\n#include \"transform.h\"\n#include \"common_block.h\"\n#include \"inter_prediction.h\"\n#include \"intra_prediction.h\"\n#include \"simd.h\"\n#include \"wt_matrix.h\"\n\nextern int chroma_qp[52];\n\nstatic void decode_and_reconstruct_block_intra (SAMPLE *rec, int stride, int size, int qp, SAMPLE *pblock, int16_t *coeffq,\n                                                int tb_split, int upright_available,int downleft_available, intra_mode_t intra_mode,int ypos,int xpos,int width,int comp, int bitdepth,\n                                                qmtx_t ** iwmatrix){\n\n  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  SAMPLE* left_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE* top_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE top_left;\n\n  if (tb_split){\n    int size2 = size/2;\n    int i,j,index;\n    for (i=0;i<size;i+=size2){\n      for (j=0;j<size;j+=size2){\n        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec,stride,&rec[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);\n        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock[i*size+j],size,intra_mode,bitdepth);\n        index = 2*(i/size2) + (j/size2);\n        TEMPLATE(dequantize)(coeffq+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        TEMPLATE(reconstruct_block)(rblock2,&pblock[i*size+j],&rec[i*stride+j],size2,size,stride,bitdepth);\n      }\n    }\n  }\n  else{\n    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);\n    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock,size,intra_mode,bitdepth);\n    TEMPLATE(dequantize)(coeffq, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n    TEMPLATE(reconstruct_block)(rblock,pblock,rec,size,size,stride,bitdepth);\n  }\n\n  thor_free(top_data - 1);\n  thor_free(left_data - 1);\n  thor_free(rcoeff);\n  thor_free(rblock);\n  thor_free(rblock2);\n}\n\nstatic void decode_and_reconstruct_block_intra_uv (SAMPLE *rec_u, SAMPLE *rec_v, int stride, int size, int qp, SAMPLE *pblock_u, SAMPLE *pblock_v, int16_t *coeffq_u, int16_t *coeffq_v,\n                                                   int tb_split, int upright_available,int downleft_available, intra_mode_t intra_mode,int ypos,int xpos,int width,int comp, int bitdepth,\n                                                   qmtx_t ** iwmatrix, SAMPLE *pblock_y, SAMPLE *rec_y, int rec_stride, int sub){\n\n  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  SAMPLE* left_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE* top_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE top_left;\n\n  if (tb_split){\n    int size2 = size/2;\n    int i,j,index;\n    for (i=0;i<size;i+=size2){\n      for (j=0;j<size;j+=size2){\n        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_u,stride,&rec_u[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);\n        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock_u[i*size+j],size,intra_mode,bitdepth);\n        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_v,stride,&rec_v[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);\n        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock_v[i*size+j],size,intra_mode,bitdepth);\n\tif (pblock_y)\n\t  TEMPLATE(improve_uv_prediction)(&pblock_y[i*size+j], &pblock_u[i*size+j], &pblock_v[i*size+j], &rec_y[(i<<sub)*rec_stride+(j<<sub)], size2 << sub, size << sub, rec_stride, sub, bitdepth);\n        index = 2*(i/size2) + (j/size2);\n        TEMPLATE(dequantize)(coeffq_u+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        TEMPLATE(reconstruct_block)(rblock2,&pblock_u[i*size+j],&rec_u[i*stride+j],size2,size,stride,bitdepth);\n        TEMPLATE(dequantize)(coeffq_v+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        TEMPLATE(reconstruct_block)(rblock2,&pblock_v[i*size+j],&rec_v[i*stride+j],size2,size,stride,bitdepth);\n      }\n    }\n  }\n  else{\n    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_u,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);\n    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock_u,size,intra_mode,bitdepth);\n    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_v,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);\n    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock_v,size,intra_mode,bitdepth);\n    if (pblock_y)\n      TEMPLATE(improve_uv_prediction)(pblock_y, pblock_u, pblock_v, rec_y, size << sub, size << sub, rec_stride, sub, bitdepth);\n    TEMPLATE(dequantize)(coeffq_u, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n    TEMPLATE(reconstruct_block)(rblock,pblock_u,rec_u,size,size,stride,bitdepth);\n    TEMPLATE(dequantize)(coeffq_v, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n    TEMPLATE(reconstruct_block)(rblock,pblock_v,rec_v,size,size,stride,bitdepth);\n  }\n\n  thor_free(top_data - 1);\n  thor_free(left_data - 1);\n  thor_free(rcoeff);\n  thor_free(rblock);\n  thor_free(rblock2);\n}\n\nstatic void decode_and_reconstruct_block_inter (SAMPLE *rec, int stride, int size, int qp, SAMPLE *pblock,\n                                                int16_t *coeffq,int tb_split, int bitdepth, qmtx_t ** iwmatrix){\n\n  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  if (tb_split){\n    int size2 = size/2;\n    int i,j,k,index;\n    for (i=0;i<size;i+=size2){\n      for (j=0;j<size;j+=size2){\n        index = 2*(i/size2) + (j/size2);\n        TEMPLATE(dequantize)(coeffq+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        /* Copy from compact block of quarter size to full size */\n        for (k=0;k<size2;k++){\n          memcpy(rblock+(i+k)*size+j,rblock2+k*size2,size2*sizeof(int16_t));\n        }\n      }\n    }\n  }\n  else {\n    TEMPLATE(dequantize)(coeffq, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n  }\n  TEMPLATE(reconstruct_block)(rblock,pblock,rec,size,size,stride,bitdepth);\n\n  thor_free(rcoeff);\n  thor_free(rblock);\n  thor_free(rblock2);\n}\n\nstatic void copy_deblock_data(decoder_info_t *decoder_info, block_info_dec_t *block_info){\n\n  int size = block_info->block_pos.size;\n  int block_posy = block_info->block_pos.ypos/MIN_PB_SIZE;\n  int block_posx = block_info->block_pos.xpos/MIN_PB_SIZE;\n  int block_stride = decoder_info->width/MIN_PB_SIZE;\n  int block_index;\n  int m,n,m0,n0,index;\n  int div = size/(2*MIN_PB_SIZE);\n  int bwidth =  block_info->block_pos.bwidth;\n  int bheight =  block_info->block_pos.bheight;\n  uint8_t tb_split = block_info->block_param.tb_split > 0;\n  part_t pb_part = block_info->block_param.mode == MODE_INTER ? block_info->block_param.pb_part : PART_NONE; //TODO: Set pb_part properly for SKIP and BIPRED\n\n  for (m=0;m<bheight/MIN_PB_SIZE;m++){\n    for (n=0;n<bwidth/MIN_PB_SIZE;n++){\n      block_index = (block_posy+m)*block_stride + block_posx+n;\n      m0 = div > 0 ? m/div : 0;\n      n0 = div > 0 ? n/div : 0;\n      index = 2*m0+n0;\n      if (index > 3) printf(\"error: index=%4d\\n\",index);\n      decoder_info->deblock_data[block_index].cbp = block_info->cbp;\n      decoder_info->deblock_data[block_index].tb_split = tb_split;\n      decoder_info->deblock_data[block_index].pb_part = pb_part;\n      decoder_info->deblock_data[block_index].size = block_info->block_pos.size;\n\n      decoder_info->deblock_data[block_index].mode = block_info->block_param.mode;\n      if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2 && block_info->block_param.mode == MODE_SKIP && block_info->block_param.skip_idx==0) {\n        int phase = decoder_info->frame_info.phase;\n        decoder_info->deblock_data[block_index].inter_pred.mv0 = decoder_info->deblock_data[block_index].inter_pred_arr[phase].mv0;\n        decoder_info->deblock_data[block_index].inter_pred.mv1 = decoder_info->deblock_data[block_index].inter_pred_arr[phase].mv0;\n        if (decoder_info->num_reorder_pics == 2 && phase == 1) {\n          decoder_info->deblock_data[block_index].inter_pred.mv1.x *= 2;\n          decoder_info->deblock_data[block_index].inter_pred.mv1.y *= 2;\n        }\n      }\n      else {\n        decoder_info->deblock_data[block_index].inter_pred.mv0 = block_info->block_param.mv_arr0[index];\n        decoder_info->deblock_data[block_index].inter_pred.mv1 = block_info->block_param.mv_arr1[index];\n      }\n      decoder_info->deblock_data[block_index].inter_pred.ref_idx0 = block_info->block_param.ref_idx0;\n      decoder_info->deblock_data[block_index].inter_pred.ref_idx1 = block_info->block_param.ref_idx1;\n      decoder_info->deblock_data[block_index].inter_pred.bipred_flag = block_info->block_param.dir;\n    }\n  }\n}\n\nstatic void decode_block(decoder_info_t *decoder_info,int size,int ypos,int xpos,int sub){\n\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  int xposY = xpos;\n  int yposY = ypos;\n  int xposC = xpos >> sub;\n  int yposC = ypos >> sub;\n  int sizeY = size;\n  int sizeC = size >> sub;\n\n  block_mode_t mode;\n  intra_mode_t intra_mode;\n\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int bipred = decoder_info->bipred;\n\n  int qpY = decoder_info->frame_info.qpb;\n  int qpC = sub ? chroma_qp[qpY] : qpY;\n\n  /* Intermediate block variables */\n  SAMPLE *pblock_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n  SAMPLE *pblock_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  int16_t *coeff_y = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *coeff_u = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *coeff_v = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  /* Block variables for bipred */\n  SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n  SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n  SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  yuv_frame_t *rec = decoder_info->rec;\n  yuv_frame_t *ref = decoder_info->ref[0];\n\n\n  /* Pointers to current position in reconstructed frame*/\n  SAMPLE *rec_y = &rec->y[yposY*rec->stride_y+xposY];\n  SAMPLE *rec_u = &rec->u[yposC*rec->stride_c+xposC];\n  SAMPLE *rec_v = &rec->v[yposC*rec->stride_c+xposC];\n\n  stream_t *stream = decoder_info->stream;\n\n  /* Read data from bitstream */\n  block_info_dec_t block_info;\n  block_info.block_pos.size = size;\n  block_info.block_pos.ypos = ypos;\n  block_info.block_pos.xpos = xpos;\n  block_info.coeffq_y = coeff_y;\n  block_info.coeffq_u = coeff_u;\n  block_info.coeffq_v = coeff_v;\n  block_info.sub = sub;\n\n  /* Used for rectangular skip blocks */\n  int bwidth = min(size,width - xpos);\n  int bheight = min(size,height - ypos);\n  block_info.block_pos.bwidth = bwidth;\n  block_info.block_pos.bheight = bheight;\n\n  read_block(decoder_info,stream,&block_info,frame_type);\n  mode = block_info.block_param.mode;\n\n  if (mode == MODE_INTRA){\n    int ql = decoder_info->qmtx ? qp_to_qlevel(qpY,decoder_info->qmtx_offset) : 0;\n    intra_mode = block_info.block_param.intra_mode;\n    int bwidth = size; //TODO: fix for non-square blocks\n    int bheight = size; //TODO: fix for non-square blocks\n    int upright_available = get_upright_available(yposY, xposY, bwidth, bheight, width, height, 1 << decoder_info->log2_sb_size);\n    int downleft_available = get_downleft_available(yposY, xposY, bwidth, bheight, width, height, 1 << decoder_info->log2_sb_size);\n\n    //int upright_available = get_upright_available(ypos, xpos, size, width, 1 << decoder_info->log2_sb_size);\n    //int downleft_available = get_downleft_available(ypos, xpos, size, height, 1 << decoder_info->log2_sb_size);\n    int tb_split = block_info.block_param.tb_split;\n    decode_and_reconstruct_block_intra(rec_y,rec->stride_y,sizeY,qpY,pblock_y,coeff_y,tb_split,upright_available,downleft_available,intra_mode,yposY,xposY,width,0,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][0][1] : NULL);\n    if (decoder_info->subsample != 400)\n      decode_and_reconstruct_block_intra_uv(rec_u,rec_v,rec->stride_c,sizeC,qpC,pblock_u,pblock_v,coeff_u,coeff_v,tb_split && sizeC > 4,upright_available,downleft_available,intra_mode,yposC,xposC,width>>sub,1,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][1][1] : NULL, decoder_info->cfl_intra ? pblock_y : 0, rec_y, rec->stride_y, sub);\n  }\n  else\n  {\n    int tb_split = block_info.block_param.tb_split;\n    if (mode==MODE_SKIP){\n      if (block_info.block_param.dir==2){\n        SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n\n        int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];\n        yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];\n        int sign0 = ref0->frame_num >= rec->frame_num;\n        int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];\n        yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];\n        int sign1 = ref1->frame_num >= rec->frame_num;\n        if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2 && block_info.block_param.skip_idx==0) {\n          TEMPLATE(get_inter_prediction_temp)(width, height, ref0, ref1, &block_info.block_pos, decoder_info->deblock_data, decoder_info->num_reorder_pics + 1, decoder_info->frame_info.phase, pblock_y, pblock_u, pblock_v);\n        }\n        else {\n          TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, 0, decoder_info->bitdepth);\n          TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, 0, decoder_info->bitdepth);\n          TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);\n        }\n        thor_free(pblock0_y);\n        thor_free(pblock0_u);\n        thor_free(pblock0_v);\n        thor_free(pblock1_y);\n        thor_free(pblock1_u);\n        thor_free(pblock1_v);\n      }\n      else{\n        int ref_idx = block_info.block_param.ref_idx0; //TODO: Move to top\n        int r = decoder_info->frame_info.ref_array[ref_idx];\n        ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];\n        int sign = ref->frame_num > rec->frame_num;\n\n        TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, 0, decoder_info->bitdepth);\n      }\n      int j;\n      for (j = 0; j<bheight; j++) {\n        memcpy(&rec_y[j*rec->stride_y], &pblock_y[j*sizeY], bwidth*sizeof(SAMPLE));\n      }\n      for (j = 0; j<bheight >> sub; j++) {\n        memcpy(&rec_u[j*rec->stride_c], &pblock_u[j*sizeC], (bwidth >> sub)*sizeof(SAMPLE));\n        memcpy(&rec_v[j*rec->stride_c], &pblock_v[j*sizeC], (bwidth >> sub)*sizeof(SAMPLE));\n      }\n      copy_deblock_data(decoder_info, &block_info);\n      return;\n    }\n    else if (mode==MODE_MERGE){\n      if (block_info.block_param.dir==2){\n\n        SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n\n        int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];\n        yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];\n        int sign0 = ref0->frame_num >= rec->frame_num;\n        TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, 0, decoder_info->bitdepth);\n\n        int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];\n        yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];\n        int sign1 = ref1->frame_num >= rec->frame_num;\n        TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, 0, decoder_info->bitdepth);\n\n        TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);\n\n        thor_free(pblock0_y);\n        thor_free(pblock0_u);\n        thor_free(pblock0_v);\n        thor_free(pblock1_y);\n        thor_free(pblock1_u);\n        thor_free(pblock1_v);\n      }\n      else{\n        int ref_idx = block_info.block_param.ref_idx0; //TODO: Move to top\n        int r = decoder_info->frame_info.ref_array[ref_idx];\n        ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];\n        int sign = ref->frame_num > rec->frame_num;\n        TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, 0, decoder_info->bitdepth);\n      }\n    }\n    else if (mode == MODE_INTER){\n      int ref_idx = block_info.block_param.ref_idx0;\n      int r = decoder_info->frame_info.ref_array[ref_idx];\n      ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];\n      int sign = ref->frame_num > rec->frame_num;\n      TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);\n    }\n    else if (mode == MODE_BIPRED){\n\n      SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n      SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n      SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n      SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n      SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n      SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n\n      int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];\n      yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];\n      int sign0 = ref0->frame_num >= rec->frame_num;\n      TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);\n\n      int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];\n      yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];\n      int sign1 = ref1->frame_num >= rec->frame_num;\n      TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);\n\n      TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);\n\n      thor_free(pblock0_y);\n      thor_free(pblock0_u);\n      thor_free(pblock0_v);\n      thor_free(pblock1_y);\n      thor_free(pblock1_u);\n      thor_free(pblock1_v);\n    }\n\n    /* Dequantize, invere tranform and reconstruct */\n    int ql = decoder_info->qmtx ? qp_to_qlevel(qpY,decoder_info->qmtx_offset) : 0;\n    decode_and_reconstruct_block_inter(rec_y,rec->stride_y,sizeY,qpY,pblock_y,coeff_y,tb_split,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][0][0] : NULL);\n    // Use reconstructed luma to improve chroma prediction\n    if (decoder_info->cfl_inter && decoder_info->subsample != 400)\n      TEMPLATE(improve_uv_prediction)(pblock_y, pblock_u, pblock_v, rec_y, sizeY, sizeY, rec->stride_y, sub, decoder_info->bitdepth);\n    decode_and_reconstruct_block_inter(rec_u,rec->stride_c,sizeC,qpC,pblock_u,coeff_u,tb_split&&sizeC>4,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][1][0] : NULL);\n    decode_and_reconstruct_block_inter(rec_v,rec->stride_c,sizeC,qpC,pblock_v,coeff_v,tb_split&&sizeC>4,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][2][0] : NULL);\n  }\n\n  /* Copy deblock data to frame array */\n  copy_deblock_data(decoder_info,&block_info);\n\n  thor_free(pblock0_y);\n  thor_free(pblock0_u);\n  thor_free(pblock0_v);\n  thor_free(pblock1_y);\n  thor_free(pblock1_u);\n  thor_free(pblock1_v);\n  thor_free(pblock_y);\n  thor_free(pblock_u);\n  thor_free(pblock_v);\n  thor_free(coeff_y);\n  thor_free(coeff_u);\n  thor_free(coeff_v);\n}\n\n\nstatic int decode_super_mode(decoder_info_t *decoder_info, int size, int decode_this_size){\n  stream_t *stream = decoder_info->stream;\n  block_context_t *block_context = decoder_info->block_context;\n\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n  int mode = MODE_SKIP;\n  int stat_mode = STAT_SKIP;\n  int num_ref=0,code,maxbit;\n  int idx = log2i(size)-3;\n\n  decoder_info->mode = MODE_SKIP; //Default initial value\n\n  if (frame_type==I_FRAME){\n    decoder_info->mode = MODE_INTRA;\n    if (size > MIN_BLOCK_SIZE && decode_this_size)\n      split_flag = get_flc(1, stream);\n    else\n      split_flag = !decode_this_size;\n    return split_flag;\n  }\n\n  if (!decode_this_size) {\n    split_flag = !get_flc(1, stream);\n    return split_flag;\n  }\n\n  if (size > MAX_TR_SIZE) {\n    split_flag = !get_flc(1, stream);\n    if (!split_flag)  decoder_info->mode = MODE_SKIP;\n    return split_flag;\n  }\n\n\n  num_ref = decoder_info->frame_info.num_ref;\n  int bipred_possible_flag = num_ref > 1 && decoder_info->bipred;\n  int split_possible_flag = size > MIN_BLOCK_SIZE;\n  maxbit = 2 + num_ref + split_possible_flag + bipred_possible_flag;\n\n  int interp_ref = decoder_info->frame_info.interp_ref;\n\n  if (interp_ref > 2) {\n    maxbit -= 1; //ref_idx = 0 is disallowed\n  }\n\n  code = get_vlc(10 + maxbit, stream);\n\n  if (interp_ref) {\n\n    if ((block_context->index == 2 || block_context->index>3) && size>MIN_BLOCK_SIZE){\n      /* Move skip down the list */\n      if (code<3)\n        code = (code + 1) % 3;\n    }\n\n    if (split_possible_flag && code==1) {\n      /* Set split flag and return */\n      split_flag = 1;\n      decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][STAT_SPLIT] += 1;\n      return split_flag;\n    }\n\n    if (!split_possible_flag && code > 0) {\n      /* Didn't need a codeword for split so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (!bipred_possible_flag && code >= 3) {\n      /* Don't need a codeword for bipred so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (code == 0) {\n      mode = MODE_SKIP;\n      stat_mode = STAT_SKIP;\n    } else if (code == 2) {\n      mode = MODE_MERGE;\n      stat_mode = STAT_MERGE;\n    } else if (code == 3) {\n      mode = MODE_BIPRED;\n      stat_mode = STAT_BIPRED;\n    } else if (code == 4) {\n      mode = MODE_INTRA;\n      stat_mode = STAT_INTRA;\n    } else if (code == 4 + num_ref) {\n      mode = MODE_INTER;\n      decoder_info->ref_idx = 0;\n      stat_mode = STAT_REF_IDX0;\n    }\n    else{\n      mode = MODE_INTER;\n      decoder_info->ref_idx = code - 4;\n      stat_mode = STAT_REF_IDX1 + decoder_info->ref_idx-1;\n    }\n    decoder_info->mode = mode;\n\n\n  } else {\n    if ((block_context->index == 2 || block_context->index>3) && size>MIN_BLOCK_SIZE){\n      /* Skip is less likely than split, merge and inter-ref_idx=0 so move skip down the list */\n      if (code<4)\n        code = (code + 1) % 4;\n    }\n\n    if (split_possible_flag && code==1) {\n      /* Set split flag and return */\n      split_flag = 1;\n      decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][STAT_SPLIT] += 1;\n      return split_flag;\n    }\n\n    if (!split_possible_flag && code > 0) {\n      /* Didn't need a codeword for split so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (!bipred_possible_flag && code >= 4) {\n      /* Don't need a codeword for bipred so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (code == 0) {\n      mode = MODE_SKIP;\n      stat_mode = STAT_SKIP;\n    }\n    else if (code == 2) {\n      mode = MODE_INTER;\n      decoder_info->ref_idx = 0;\n      stat_mode = STAT_REF_IDX0;\n    }\n    else if (code == 3) {\n      mode = MODE_MERGE;\n      stat_mode = STAT_MERGE;\n    }\n    else if (code == 4) {\n      mode = MODE_BIPRED;\n      stat_mode = STAT_BIPRED;\n    }\n    else if (code == 5) {\n      mode = MODE_INTRA;\n      stat_mode = STAT_INTRA;\n    }\n    else{\n      mode = MODE_INTER;\n      decoder_info->ref_idx = code - 5;\n      stat_mode = STAT_REF_IDX1 + decoder_info->ref_idx - 1;\n    }\n    decoder_info->mode = mode;\n\n  }\n  decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][stat_mode] += 1;\n\n  return split_flag;\n}\n\n\nvoid TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n\n  if (yposY >= height || xposY >= width)\n    return;\n\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n\n  int bit_start = stream->bitcnt;\n\n  int mode = MODE_SKIP;\n \n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  \n  /* Read delta_qp and set block-level qp */\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    /* Read delta_qp */\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n\n  decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n\n  if (split_flag){\n    int new_size = size/2;\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}\n", "/*\nCopyright (c) 2015, Cisco Systems\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <string.h>\n#include <memory.h>\n#include <assert.h>\n\n#include \"global.h\"\n#include \"getvlc.h\"\n#include \"common_block.h\"\n#include \"inter_prediction.h\"\n\nextern int zigzag16[16];\nextern int zigzag64[64];\nextern int zigzag256[256];\n\nint YPOS, XPOS;\n\n#undef TEMPLATE\n#define TEMPLATE(func) (decoder_info->bitdepth == 8 ? func ## _lbd : func ## _hbd)\n\nvoid read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = // 0: 400  1: 420  2: 422  3: 444\n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}\n\nvoid read_frame_header(decoder_info_t *dec_info, stream_t *stream) {\n  frame_info_t *frame_info = &dec_info->frame_info;\n  frame_info->frame_type = get_flc(1, stream);\n  frame_info->qp = get_flc(8, stream);\n  frame_info->num_intra_modes = get_flc(4, stream);\n  if (frame_info->frame_type != I_FRAME) {\n    frame_info->num_ref = get_flc(2, stream) + 1;\n    int r;\n    for (r = 0; r < frame_info->num_ref; r++) {\n      frame_info->ref_array[r] = get_flc(6, stream) - 1;\n    }\n    if (frame_info->num_ref == 2 && frame_info->ref_array[0] == -1) {\n      frame_info->ref_array[frame_info->num_ref++] = get_flc(5, stream) - 1;\n    }\n  }\n  else {\n    frame_info->num_ref = 0;\n  }\n  frame_info->display_frame_num = get_flc(16, stream);\n\n#if CDEF\n  dec_info->cdef_damping[1] = dec_info->cdef_damping[0] = get_flc(2, stream) + 3;\n  dec_info->cdef_bits = get_flc(2, stream);\n\n  for (int i = 0; i < (1 << dec_info->cdef_bits); i++) {\n    dec_info->cdef_presets[i].pri_strength[0] = get_flc(4, stream);\n    dec_info->cdef_presets[i].skip_condition[0] = get_flc(1, stream);\n    dec_info->cdef_presets[i].sec_strength[0] = get_flc(2, stream);\n    if (dec_info->subsample != 400) {\n      dec_info->cdef_presets[i].pri_strength[1] = get_flc(4, stream);\n      dec_info->cdef_presets[i].skip_condition[1] = get_flc(1, stream);\n      dec_info->cdef_presets[i].sec_strength[1] = get_flc(2, stream);\n    }\n  }\n#endif\n}\n\n\nvoid read_mv(stream_t *stream,mv_t *mv,mv_t *mvp)\n{\n    mv_t mvd;\n    int mvabs, mvsign = 0;\n\n    /* MVX */\n    if ((mvabs = get_vlc(7, stream)))\n      mvsign = get_flc(1, stream);\n    mvd.x = mvabs * (mvsign ? -1 : 1);\n    mv->x = mvp->x + mvd.x;\n\n    /* MVY */\n    if ((mvabs = get_vlc(7, stream)))\n      mvsign = get_flc(1, stream);\n    mvd.y = mvabs * (mvsign ? -1 : 1);\n    mv->y = mvp->y + mvd.y;\n}\n\n\n\nvoid read_coeff(stream_t *stream,int16_t *coeff,int size,int type){\n\n  int16_t scoeff[MAX_QUANT_SIZE*MAX_QUANT_SIZE];\n  int i,j,levelFlag,sign,level,pos,run,tmp,code;\n  int qsize = min(size,MAX_QUANT_SIZE);\n  int N = qsize*qsize;\n  int level_mode;\n  int chroma_flag = type&1;\n  int intra_flag = (type>>1)&1;\n  int vlc_adaptive = intra_flag && !chroma_flag;\n\n  /* Initialize arrays */\n  memset(scoeff,0,N*sizeof(int16_t));\n  memset(coeff,0,size*size*sizeof(int16_t));\n\n  pos = 0;\n  /* Use one bit to signal chroma/last_pos=1/level=1 */\n  if (chroma_flag==1){\n    int tmp = get_flc(1, stream);\n    if (tmp){\n      sign = get_flc(1, stream);\n      scoeff[pos] = sign ? -1 : 1;\n      pos = N;\n    }\n  }\n\n  /* Initiate forward scan */\n  level_mode = 1;\n  level = 1;\n  while (pos < N){\n    if (level_mode){\n      /* Level-mode */\n      while (pos < N && level > 0){\n        level = get_vlc(vlc_adaptive,stream);\n        if (level){\n          sign = get_flc(1, stream);\n        }\n        else{\n          sign = 1;\n        }\n        scoeff[pos] = sign ? -level : level;\n        if (chroma_flag==0)\n          vlc_adaptive = level > 3;\n        pos++;\n      }\n    }\n    if (pos >= N){\n      break;\n    }\n\n    /* Run-mode */\n    int eob;\n    int eob_pos = chroma_flag ? 0 : 2;\n    if (chroma_flag && size <= 8)\n      code = get_vlc(10, stream);\n    else\n      code = get_vlc(6, stream);\n\n    eob = code == eob_pos;\n    if (eob) {\n      break;\n    }\n    if (code > eob_pos) code -= 1;\n    levelFlag = (code % 5) == 4;\n    if (levelFlag)\n      run = code / 5;\n    else\n      run = 4*(code/5) + code % 5;\n    pos += run;\n\n    /* Decode level and sign */\n    if (levelFlag){\n      tmp = get_vlc(0,stream);\n      sign = tmp&1;\n      level = (tmp>>1)+2;\n    }\n    else{\n      level = 1;\n      sign = get_flc(1, stream);\n    }\n    scoeff[pos] = sign ? -level : level;\n\n    level_mode = level > 1; //Set level_mode\n    pos++;\n  } //while pos < N\n\n  /* Perform inverse zigzag scan */\n  int *zigzagptr = zigzag64;\n  if (qsize==4)\n    zigzagptr = zigzag16;\n  else if (qsize==8)\n    zigzagptr = zigzag64;\n  else if (qsize==16)\n    zigzagptr = zigzag256;\n  for (i=0;i<qsize;i++){\n    for (j=0;j<qsize;j++){\n      coeff[i*qsize + j] = scoeff[zigzagptr[i*qsize + j]];\n    }\n  }\n}\n\nint read_delta_qp(stream_t *stream){\n  int abs_delta_qp,sign_delta_qp,delta_qp;\n  sign_delta_qp = 0;\n  abs_delta_qp = get_vlc(0,stream);\n  if (abs_delta_qp > 0)\n    sign_delta_qp = get_flc(1, stream);\n  delta_qp = sign_delta_qp ? -abs_delta_qp : abs_delta_qp;\n  return delta_qp;\n}\nint read_block(decoder_info_t *decoder_info,stream_t *stream,block_info_dec_t *block_info, frame_type_t frame_type)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  int bit_start;\n  int code,tb_split;\n  int pb_part=0;\n  cbp_t cbp;\n  int stat_frame_type = decoder_info->bit_count.stat_frame_type; //TODO: Use only one variable for frame type\n\n  int size = block_info->block_pos.size;\n  int ypos = block_info->block_pos.ypos;\n  int xpos = block_info->block_pos.xpos;\n\n  YPOS = ypos;\n  XPOS = xpos;\n\n  int sizeY = size;\n  int sizeC = size>>block_info->sub;\n\n  mv_t mv,zerovec;\n  mv_t mvp;\n  mv_t mv_arr[4]; //TODO: Use mv_arr0 instead\n  mv_t mv_arr0[4];\n  mv_t mv_arr1[4];\n\n  block_mode_t mode;\n  intra_mode_t intra_mode = MODE_DC;\n\n  int16_t *coeff_y = block_info->coeffq_y;\n  int16_t *coeff_u = block_info->coeffq_u;\n  int16_t *coeff_v = block_info->coeffq_v;\n\n  zerovec.y = zerovec.x = 0;\n  bit_start = stream->bitcnt;\n\n  mode = decoder_info->mode;\n  int coeff_block_type = (mode == MODE_INTRA)<<1;\n\n  /* Initialize bit counter for statistical purposes */\n  bit_start = stream->bitcnt;\n\n  if (mode == MODE_SKIP){\n    /* Derive skip vector candidates and number of skip vector candidates from neighbour blocks */\n    mv_t mv_skip[MAX_NUM_SKIP];\n    int num_skip_vec,skip_idx;\n    inter_pred_t skip_candidates[MAX_NUM_SKIP];\n    num_skip_vec = TEMPLATE(get_mv_skip)(ypos, xpos, width, height, size, size, 1 << decoder_info->log2_sb_size, decoder_info->deblock_data, skip_candidates);\n    if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2) {\n      num_skip_vec = TEMPLATE(get_mv_skip_temp)(decoder_info->width, decoder_info->frame_info.phase, decoder_info->num_reorder_pics + 1, &block_info->block_pos, decoder_info->deblock_data, skip_candidates);\n    }\n    for (int idx = 0; idx < num_skip_vec; idx++) {\n      mv_skip[idx] = skip_candidates[idx].mv0;\n    }\n    /* Decode skip index */\n    if (num_skip_vec == 4)\n      skip_idx = get_flc(2, stream);\n    else if (num_skip_vec == 3){\n      skip_idx = get_vlc(12, stream);\n    }\n    else if (num_skip_vec == 2){\n      skip_idx = get_flc(1, stream);\n    }\n    else\n      skip_idx = 0;\n    decoder_info->bit_count.skip_idx[stat_frame_type] += (stream->bitcnt - bit_start);\n\n    block_info->num_skip_vec = num_skip_vec;\n    block_info->block_param.skip_idx = skip_idx;\n\n    if (skip_idx == num_skip_vec)\n      mv = mv_skip[0];\n    else\n      mv = mv_skip[skip_idx];\n    mv_arr[0] = mv;\n    mv_arr[1] = mv;\n    mv_arr[2] = mv;\n    mv_arr[3] = mv;\n\n    block_info->block_param.ref_idx0 = skip_candidates[skip_idx].ref_idx0;\n    block_info->block_param.ref_idx1 = skip_candidates[skip_idx].ref_idx1;\n    for (int i = 0; i < 4; i++) {\n      mv_arr0[i] = skip_candidates[skip_idx].mv0;\n      mv_arr1[i] = skip_candidates[skip_idx].mv1;\n    }\n    block_info->block_param.dir = skip_candidates[skip_idx].bipred_flag;\n  }\n  else if (mode == MODE_MERGE){\n    /* Derive skip vector candidates and number of skip vector candidates from neighbour blocks */\n    mv_t mv_skip[MAX_NUM_SKIP];\n    int num_skip_vec,skip_idx;\n    inter_pred_t merge_candidates[MAX_NUM_SKIP];\n    num_skip_vec = TEMPLATE(get_mv_merge)(ypos, xpos, width, height, size, size, 1 << decoder_info->log2_sb_size, decoder_info->deblock_data, merge_candidates);\n    for (int idx = 0; idx < num_skip_vec; idx++) {\n      mv_skip[idx] = merge_candidates[idx].mv0;\n    }\n    /* Decode skip index */\n    if (num_skip_vec == 4)\n      skip_idx = get_flc(2, stream);\n    else if (num_skip_vec == 3){\n      skip_idx = get_vlc(12, stream);\n    }\n    else if (num_skip_vec == 2){\n      skip_idx = get_flc(1, stream);\n    }\n    else\n      skip_idx = 0;\n    decoder_info->bit_count.skip_idx[stat_frame_type] += (stream->bitcnt - bit_start);\n\n    block_info->num_skip_vec = num_skip_vec;\n    block_info->block_param.skip_idx = skip_idx;\n\n    if (skip_idx == num_skip_vec)\n      mv = mv_skip[0];\n    else\n      mv = mv_skip[skip_idx];\n    mv_arr[0] = mv;\n    mv_arr[1] = mv;\n    mv_arr[2] = mv;\n    mv_arr[3] = mv;\n\n    block_info->block_param.ref_idx0 = merge_candidates[skip_idx].ref_idx0;\n    block_info->block_param.ref_idx1 = merge_candidates[skip_idx].ref_idx1;\n    for (int i = 0; i < 4; i++) {\n      mv_arr0[i] = merge_candidates[skip_idx].mv0;\n      mv_arr1[i] = merge_candidates[skip_idx].mv1;\n    }\n    block_info->block_param.dir = merge_candidates[skip_idx].bipred_flag;\n  }\n  else if (mode==MODE_INTER){\n    int ref_idx;\n\n    if (decoder_info->pb_split){\n      /* Decode PU partition */\n      pb_part = get_vlc(13, stream);\n    }\n    else{\n      pb_part = 0;\n    }\n    block_info->block_param.pb_part = pb_part;\n    if (decoder_info->frame_info.num_ref > 1){\n      ref_idx = decoder_info->ref_idx;\n    }\n    else{\n      ref_idx = 0;\n    }\n\n    //if (mode==MODE_INTER)\n    decoder_info->bit_count.size_and_ref_idx[stat_frame_type][log2i(size)-3][ref_idx] += 1;\n\n    mvp = TEMPLATE(get_mv_pred)(ypos,xpos,width,height,size,size,1<<decoder_info->log2_sb_size,ref_idx,decoder_info->deblock_data);\n\n    /* Deode motion vectors for each prediction block */\n    mv_t mvp2 = mvp;\n\n    if (pb_part==0){\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mv_arr[1] = mv_arr[0];\n      mv_arr[2] = mv_arr[0];\n      mv_arr[3] = mv_arr[0];\n    }\n    else if(pb_part==1){ //HOR\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mvp2 = mv_arr[0];\n      read_mv(stream,&mv_arr[2],&mvp2);\n      mv_arr[1] = mv_arr[0];\n      mv_arr[3] = mv_arr[2];\n    }\n    else if(pb_part==2){ //VER\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mvp2 = mv_arr[0];\n      read_mv(stream,&mv_arr[1],&mvp2);\n      mv_arr[2] = mv_arr[0];\n      mv_arr[3] = mv_arr[1];\n    }\n    else{\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mvp2 = mv_arr[0];\n      read_mv(stream,&mv_arr[1],&mvp2);\n      read_mv(stream,&mv_arr[2],&mvp2);\n      read_mv(stream,&mv_arr[3],&mvp2);\n    }\n    decoder_info->bit_count.mv[stat_frame_type] += (stream->bitcnt - bit_start);\n    block_info->block_param.ref_idx0 = ref_idx;\n    block_info->block_param.ref_idx1 = ref_idx;\n    block_info->block_param.dir = 0;\n  }\n  else if (mode==MODE_BIPRED){\n    int ref_idx = 0;\n    mvp = TEMPLATE(get_mv_pred)(ypos,xpos,width,height,size,size,1 << decoder_info->log2_sb_size, ref_idx,decoder_info->deblock_data);\n\n    /* Deode motion vectors */\n    mv_t mvp2 = mvp;\n\n#if BIPRED_PART\n    if (decoder_info->pb_split) {\n      /* Decode PU partition */\n      pb_part = get_vlc(13, stream);\n    }\n    else {\n      pb_part = 0;\n    }\n#else\n    pb_part = 0;\n#endif\n    block_info->block_param.pb_part = pb_part;\n\n    if (pb_part == 0) {\n      read_mv(stream, &mv_arr0[0], &mvp2);\n      mv_arr0[1] = mv_arr0[0];\n      mv_arr0[2] = mv_arr0[0];\n      mv_arr0[3] = mv_arr0[0];\n    }\n    else {\n      mv_arr0[0] = mvp2;\n      mv_arr0[1] = mvp2;\n      mv_arr0[2] = mvp2;\n      mv_arr0[3] = mvp2;\n    }\n    if (decoder_info->bit_count.stat_frame_type == B_FRAME)\n      mvp2 = mv_arr0[0];\n    if (pb_part == 0) {\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mv_arr1[1] = mv_arr1[0];\n      mv_arr1[2] = mv_arr1[0];\n      mv_arr1[3] = mv_arr1[0];\n    }\n    else if (pb_part == 1) { //HOR\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mvp2 = mv_arr1[0];\n      read_mv(stream, &mv_arr1[2], &mvp2);\n      mv_arr1[1] = mv_arr1[0];\n      mv_arr1[3] = mv_arr1[2];\n    }\n    else if (pb_part == 2) { //VER\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mvp2 = mv_arr1[0];\n      read_mv(stream, &mv_arr1[1], &mvp2);\n      mv_arr1[2] = mv_arr1[0];\n      mv_arr1[3] = mv_arr1[1];\n    }\n    else {\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mvp2 = mv_arr1[0];\n      read_mv(stream, &mv_arr1[1], &mvp2);\n      read_mv(stream, &mv_arr1[2], &mvp2);\n      read_mv(stream, &mv_arr1[3], &mvp2);\n    }\n\n    if (decoder_info->bit_count.stat_frame_type == B_FRAME) {\n      block_info->block_param.ref_idx0 = 0;\n      block_info->block_param.ref_idx1 = 1;\n      if (decoder_info->frame_info.interp_ref > 0) {\n        block_info->block_param.ref_idx0 += 1;\n        block_info->block_param.ref_idx1 += 1;\n      }\n    }\n    else{\n      if (decoder_info->frame_info.num_ref == 2) {\n        int code = get_vlc(13, stream);\n        block_info->block_param.ref_idx0 = (code >> 1) & 1;\n        block_info->block_param.ref_idx1 = (code >> 0) & 1;\n      }\n      else {\n        int code = get_vlc(10, stream);\n        block_info->block_param.ref_idx0 = (code >> 2) & 3;\n        block_info->block_param.ref_idx1 = (code >> 0) & 3;\n      }\n    }\n    block_info->block_param.dir = 2;\n    int combined_ref = block_info->block_param.ref_idx0 * decoder_info->frame_info.num_ref + block_info->block_param.ref_idx1;\n    decoder_info->bit_count.bi_ref[stat_frame_type][combined_ref] += 1;\n    decoder_info->bit_count.mv[stat_frame_type] += (stream->bitcnt - bit_start);\n  }\n\n  else if (mode==MODE_INTRA){\n    /* Decode intra prediction mode */\n    if (decoder_info->frame_info.num_intra_modes<=4){\n      intra_mode = get_flc(2, stream);\n    }\n    else {\n      intra_mode = get_vlc(8, stream);\n    }\n\n    decoder_info->bit_count.intra_mode[stat_frame_type] += (stream->bitcnt - bit_start);\n    decoder_info->bit_count.size_and_intra_mode[stat_frame_type][log2i(size)-3][intra_mode] += 1;\n\n    block_info->block_param.intra_mode = intra_mode;\n    for (int i=0;i<4;i++){\n      mv_arr[i] = zerovec; //Note: This is necessary for derivation of mvp and mv_skip\n    }\n    block_info->block_param.ref_idx0 = 0;\n    block_info->block_param.ref_idx1 = 0;\n    block_info->block_param.dir = -1;\n  }\n\n\n  if (mode!=MODE_SKIP){\n    int tmp;\n    int cbp_table[8] = {1,0,5,2,6,3,7,4};\n    code = 0;\n\n    if (decoder_info->subsample == 400) {\n      tb_split = cbp.u = cbp.v = 0;\n      cbp.y = get_flc(1,stream);\n      if (decoder_info->tb_split_enable && cbp.y) {\n        // 0: cbp=split=0, 10: cbp=1,split=0, 11: split=1\n        tb_split = get_flc(1,stream);\n        cbp.y &= !tb_split;\n      }\n    } else {\n      bit_start = stream->bitcnt;\n      code = get_vlc(0,stream);\n      int off = (mode == MODE_MERGE) ? 1 : 2;\n      if (decoder_info->tb_split_enable) {\n        tb_split = code == off;\n        if (code > off) code -= 1;\n        if (tb_split)\n          decoder_info->bit_count.cbp2_stat[0][stat_frame_type][mode-1][log2i(size)-3][8] += 1;\n      }\n      else{\n        tb_split = 0;\n      }\n    }\n    block_info->block_param.tb_split = tb_split;\n    decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n\n    if (tb_split == 0){\n      if (decoder_info->subsample != 400) {\n        tmp = 0;\n        if (mode==MODE_MERGE){\n          if (code==7)\n            code = 1;\n          else if (code>0)\n            code = code+1;\n        }\n        else {\n          if (decoder_info->block_context->cbp == 0 && code < 2) {\n            code = 1 - code;\n          }\n        }\n        while (tmp < 8 && code != cbp_table[tmp]) tmp++;\n        decoder_info->bit_count.cbp2_stat[max(0,decoder_info->block_context->cbp)][stat_frame_type][mode-1][log2i(size)-3][tmp] += 1;\n\n        cbp.y = ((tmp>>0)&1);\n        cbp.u = ((tmp>>1)&1);\n        cbp.v = ((tmp>>2)&1);\n      }\n      block_info->cbp = cbp;\n\n      if (cbp.y){\n        bit_start = stream->bitcnt;\n        read_coeff(stream,coeff_y,sizeY,coeff_block_type|0);\n        decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);\n      }\n      else\n        memset(coeff_y,0,sizeY*sizeY*sizeof(int16_t));\n\n      if (cbp.u){\n        bit_start = stream->bitcnt;\n        read_coeff(stream,coeff_u,sizeC,coeff_block_type|1);\n        decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);\n      }\n      else\n        memset(coeff_u,0,sizeC*sizeC*sizeof(int16_t));\n\n      if (cbp.v){\n        bit_start = stream->bitcnt;\n        read_coeff(stream,coeff_v,sizeC,coeff_block_type|1);\n        decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);\n      }\n      else\n        memset(coeff_v,0,sizeC*sizeC*sizeof(int16_t));\n    }\n    else{\n      if (sizeC > 4){\n        int index;\n        int16_t *coeff;\n\n        /* Loop over 4 TUs */\n        for (index=0;index<4;index++){\n          bit_start = stream->bitcnt;\n          code = get_vlc(0,stream);\n          int tmp = 0;\n          while (code != cbp_table[tmp] && tmp < 8) tmp++;\n          if (decoder_info->block_context->cbp==0 && tmp < 2)\n            tmp = 1-tmp;\n          cbp.y = ((tmp>>0)&1);\n          cbp.u = ((tmp>>1)&1);\n          cbp.v = ((tmp>>2)&1);\n\n          /* Updating statistics for CBP */\n          decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n          decoder_info->bit_count.cbp_stat[stat_frame_type][cbp.y + (cbp.u<<1) + (cbp.v<<2)] += 1;\n\n          /* Decode coefficients for this TU */\n\n          /* Y */\n          coeff = coeff_y + index*sizeY/2*sizeY/2;\n          if (cbp.y){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeY/2,coeff_block_type|0);\n            decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeY/2*sizeY/2*sizeof(int16_t));\n          }\n\n          /* U */\n          coeff = coeff_u + index*sizeC/2*sizeC/2;\n          if (cbp.u){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeC/2,coeff_block_type|1);\n            decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeC/2*sizeC/2*sizeof(int16_t));\n          }\n\n          /* V */\n          coeff = coeff_v + index*sizeC/2*sizeC/2;\n          if (cbp.v){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeC/2,coeff_block_type|1);\n            decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeC/2*sizeC/2*sizeof(int16_t));\n          }\n        }\n        block_info->cbp.y = 1; //TODO: Do properly with respect to deblocking filter\n        block_info->cbp.u = 1;\n        block_info->cbp.v = 1;\n      }\n      else{\n        int index;\n        int16_t *coeff;\n\n        /* Loop over 4 TUs */\n        for (index=0;index<4;index++){\n          bit_start = stream->bitcnt;\n          cbp.y = get_flc(1, stream);\n          decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n\n          /* Y */\n          coeff = coeff_y + index*sizeY/2*sizeY/2;\n          if (cbp.y){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeY/2,coeff_block_type|0);\n            decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeY/2*sizeY/2*sizeof(int16_t));\n          }\n        }\n\n        bit_start = stream->bitcnt;\n        if (decoder_info->subsample != 400) {\n          int tmp;\n          tmp = get_vlc(13, stream);\n          cbp.u = tmp & 1;\n          cbp.v = (tmp >> 1) & 1;\n        } else\n          cbp.u = cbp.v = 0;\n        decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n        if (cbp.u){\n          bit_start = stream->bitcnt;\n          read_coeff(stream,coeff_u,sizeC,coeff_block_type|1);\n          decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);\n        }\n        else\n          memset(coeff_u,0,sizeC*sizeC*sizeof(int16_t));\n        if (cbp.v){\n          bit_start = stream->bitcnt;\n          read_coeff(stream,coeff_v,sizeC,coeff_block_type|1);\n          decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);\n        }\n        else\n          memset(coeff_v,0,sizeC*sizeC*sizeof(int16_t));\n\n        block_info->cbp.y = 1; //TODO: Do properly with respect to deblocking filter\n        block_info->cbp.u = 1;\n        block_info->cbp.v = 1;\n      } //if (size==8)\n    } //if (tb_split==0)\n  } //if (mode!=MODE_SKIP)\n  else{\n    tb_split = 0;\n    block_info->cbp.y = 0;\n    block_info->cbp.u = 0;\n    block_info->cbp.v = 0;\n  }\n\n  /* Store block data */\n  if (mode==MODE_BIPRED){\n    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  else if(mode==MODE_SKIP){\n    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  else if(mode==MODE_MERGE){\n    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  else{\n    memcpy(block_info->block_param.mv_arr0,mv_arr,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  block_info->block_param.mode = mode;\n  block_info->block_param.tb_split = tb_split;\n\n  int bwidth = min(size,width - xpos);\n  int bheight = min(size,height - ypos);\n\n  /* Update mode and block size statistics */\n  decoder_info->bit_count.mode[stat_frame_type][mode] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);\n  decoder_info->bit_count.size[stat_frame_type][log2i(size)-3] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);\n  decoder_info->bit_count.size_and_mode[stat_frame_type][log2i(size)-3][mode] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);\n  return 0;\n}\n"], "fixing_code": ["/*\nCopyright (c) 2015, Cisco Systems\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <string.h>\n#include <memory.h>\n#include <assert.h>\n\n#include \"global.h\"\n#include \"snr.h\"\n#include \"getvlc.h\"\n#include \"read_bits.h\"\n#include \"transform.h\"\n#include \"common_block.h\"\n#include \"inter_prediction.h\"\n#include \"intra_prediction.h\"\n#include \"simd.h\"\n#include \"wt_matrix.h\"\n\nextern int chroma_qp[52];\n\nstatic void decode_and_reconstruct_block_intra (SAMPLE *rec, int stride, int size, int qp, SAMPLE *pblock, int16_t *coeffq,\n                                                int tb_split, int upright_available,int downleft_available, intra_mode_t intra_mode,int ypos,int xpos,int width,int comp, int bitdepth,\n                                                qmtx_t ** iwmatrix){\n\n  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  SAMPLE* left_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE* top_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE top_left;\n\n  if (tb_split){\n    int size2 = size/2;\n    int i,j,index;\n    for (i=0;i<size;i+=size2){\n      for (j=0;j<size;j+=size2){\n        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec,stride,&rec[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);\n        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock[i*size+j],size,intra_mode,bitdepth);\n        index = 2*(i/size2) + (j/size2);\n        TEMPLATE(dequantize)(coeffq+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        TEMPLATE(reconstruct_block)(rblock2,&pblock[i*size+j],&rec[i*stride+j],size2,size,stride,bitdepth);\n      }\n    }\n  }\n  else{\n    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);\n    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock,size,intra_mode,bitdepth);\n    TEMPLATE(dequantize)(coeffq, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n    TEMPLATE(reconstruct_block)(rblock,pblock,rec,size,size,stride,bitdepth);\n  }\n\n  thor_free(top_data - 1);\n  thor_free(left_data - 1);\n  thor_free(rcoeff);\n  thor_free(rblock);\n  thor_free(rblock2);\n}\n\nstatic void decode_and_reconstruct_block_intra_uv (SAMPLE *rec_u, SAMPLE *rec_v, int stride, int size, int qp, SAMPLE *pblock_u, SAMPLE *pblock_v, int16_t *coeffq_u, int16_t *coeffq_v,\n                                                   int tb_split, int upright_available,int downleft_available, intra_mode_t intra_mode,int ypos,int xpos,int width,int comp, int bitdepth,\n                                                   qmtx_t ** iwmatrix, SAMPLE *pblock_y, SAMPLE *rec_y, int rec_stride, int sub){\n\n  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  SAMPLE* left_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE* top_data = (SAMPLE*)thor_alloc((2*MAX_TR_SIZE+2)*sizeof(SAMPLE),32)+1;\n  SAMPLE top_left;\n\n  if (tb_split){\n    int size2 = size/2;\n    int i,j,index;\n    for (i=0;i<size;i+=size2){\n      for (j=0;j<size;j+=size2){\n        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_u,stride,&rec_u[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);\n        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock_u[i*size+j],size,intra_mode,bitdepth);\n        TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_v,stride,&rec_v[i*stride+j],stride,i,j,ypos,xpos,size2,upright_available,downleft_available,1,bitdepth);\n        TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos+i,xpos+j,size2,&pblock_v[i*size+j],size,intra_mode,bitdepth);\n\tif (pblock_y)\n\t  TEMPLATE(improve_uv_prediction)(&pblock_y[i*size+j], &pblock_u[i*size+j], &pblock_v[i*size+j], &rec_y[(i<<sub)*rec_stride+(j<<sub)], size2 << sub, size << sub, rec_stride, sub, bitdepth);\n        index = 2*(i/size2) + (j/size2);\n        TEMPLATE(dequantize)(coeffq_u+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        TEMPLATE(reconstruct_block)(rblock2,&pblock_u[i*size+j],&rec_u[i*stride+j],size2,size,stride,bitdepth);\n        TEMPLATE(dequantize)(coeffq_v+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        TEMPLATE(reconstruct_block)(rblock2,&pblock_v[i*size+j],&rec_v[i*stride+j],size2,size,stride,bitdepth);\n      }\n    }\n  }\n  else{\n    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_u,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);\n    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock_u,size,intra_mode,bitdepth);\n    TEMPLATE(make_top_and_left)(left_data,top_data,&top_left,rec_v,stride,NULL,0,0,0,ypos,xpos,size,upright_available,downleft_available,0,bitdepth);\n    TEMPLATE(get_intra_prediction)(left_data,top_data,top_left,ypos,xpos,size,pblock_v,size,intra_mode,bitdepth);\n    if (pblock_y)\n      TEMPLATE(improve_uv_prediction)(pblock_y, pblock_u, pblock_v, rec_y, size << sub, size << sub, rec_stride, sub, bitdepth);\n    TEMPLATE(dequantize)(coeffq_u, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n    TEMPLATE(reconstruct_block)(rblock,pblock_u,rec_u,size,size,stride,bitdepth);\n    TEMPLATE(dequantize)(coeffq_v, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n    TEMPLATE(reconstruct_block)(rblock,pblock_v,rec_v,size,size,stride,bitdepth);\n  }\n\n  thor_free(top_data - 1);\n  thor_free(left_data - 1);\n  thor_free(rcoeff);\n  thor_free(rblock);\n  thor_free(rblock2);\n}\n\nstatic void decode_and_reconstruct_block_inter (SAMPLE *rec, int stride, int size, int qp, SAMPLE *pblock,\n                                                int16_t *coeffq,int tb_split, int bitdepth, qmtx_t ** iwmatrix){\n\n  int16_t *rcoeff = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *rblock2 = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  if (tb_split){\n    int size2 = size/2;\n    int i,j,k,index;\n    for (i=0;i<size;i+=size2){\n      for (j=0;j<size;j+=size2){\n        index = 2*(i/size2) + (j/size2);\n        TEMPLATE(dequantize)(coeffq+index*size2*size2, rcoeff, qp, size2, iwmatrix ? iwmatrix[log2i(size2/4)] : NULL);\n        inverse_transform (rcoeff, rblock2, size2, bitdepth);\n        /* Copy from compact block of quarter size to full size */\n        for (k=0;k<size2;k++){\n          memcpy(rblock+(i+k)*size+j,rblock2+k*size2,size2*sizeof(int16_t));\n        }\n      }\n    }\n  }\n  else {\n    TEMPLATE(dequantize)(coeffq, rcoeff, qp, size, iwmatrix ? iwmatrix[log2i(size/4)] : NULL);\n\n    inverse_transform (rcoeff, rblock, size, bitdepth);\n  }\n  TEMPLATE(reconstruct_block)(rblock,pblock,rec,size,size,stride,bitdepth);\n\n  thor_free(rcoeff);\n  thor_free(rblock);\n  thor_free(rblock2);\n}\n\nstatic void copy_deblock_data(decoder_info_t *decoder_info, block_info_dec_t *block_info){\n\n  int size = block_info->block_pos.size;\n  int block_posy = block_info->block_pos.ypos/MIN_PB_SIZE;\n  int block_posx = block_info->block_pos.xpos/MIN_PB_SIZE;\n  int block_stride = decoder_info->width/MIN_PB_SIZE;\n  int block_index;\n  int m,n,m0,n0,index;\n  int div = size/(2*MIN_PB_SIZE);\n  int bwidth =  block_info->block_pos.bwidth;\n  int bheight =  block_info->block_pos.bheight;\n  uint8_t tb_split = block_info->block_param.tb_split > 0;\n  part_t pb_part = block_info->block_param.mode == MODE_INTER ? block_info->block_param.pb_part : PART_NONE; //TODO: Set pb_part properly for SKIP and BIPRED\n\n  for (m=0;m<bheight/MIN_PB_SIZE;m++){\n    for (n=0;n<bwidth/MIN_PB_SIZE;n++){\n      block_index = (block_posy+m)*block_stride + block_posx+n;\n      m0 = div > 0 ? m/div : 0;\n      n0 = div > 0 ? n/div : 0;\n      index = 2*m0+n0;\n      if (index > 3) printf(\"error: index=%4d\\n\",index);\n      decoder_info->deblock_data[block_index].cbp = block_info->cbp;\n      decoder_info->deblock_data[block_index].tb_split = tb_split;\n      decoder_info->deblock_data[block_index].pb_part = pb_part;\n      decoder_info->deblock_data[block_index].size = block_info->block_pos.size;\n\n      decoder_info->deblock_data[block_index].mode = block_info->block_param.mode;\n      if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2 && block_info->block_param.mode == MODE_SKIP && block_info->block_param.skip_idx==0) {\n        int phase = decoder_info->frame_info.phase;\n        decoder_info->deblock_data[block_index].inter_pred.mv0 = decoder_info->deblock_data[block_index].inter_pred_arr[phase].mv0;\n        decoder_info->deblock_data[block_index].inter_pred.mv1 = decoder_info->deblock_data[block_index].inter_pred_arr[phase].mv0;\n        if (decoder_info->num_reorder_pics == 2 && phase == 1) {\n          decoder_info->deblock_data[block_index].inter_pred.mv1.x *= 2;\n          decoder_info->deblock_data[block_index].inter_pred.mv1.y *= 2;\n        }\n      }\n      else {\n        decoder_info->deblock_data[block_index].inter_pred.mv0 = block_info->block_param.mv_arr0[index];\n        decoder_info->deblock_data[block_index].inter_pred.mv1 = block_info->block_param.mv_arr1[index];\n      }\n      decoder_info->deblock_data[block_index].inter_pred.ref_idx0 = block_info->block_param.ref_idx0;\n      decoder_info->deblock_data[block_index].inter_pred.ref_idx1 = block_info->block_param.ref_idx1;\n      decoder_info->deblock_data[block_index].inter_pred.bipred_flag = block_info->block_param.dir;\n    }\n  }\n}\n\nstatic void decode_block(decoder_info_t *decoder_info,int size,int ypos,int xpos,int sub){\n\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  int xposY = xpos;\n  int yposY = ypos;\n  int xposC = xpos >> sub;\n  int yposC = ypos >> sub;\n  int sizeY = size;\n  int sizeC = size >> sub;\n\n  block_mode_t mode;\n  intra_mode_t intra_mode;\n\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int bipred = decoder_info->bipred;\n\n  int qpY = decoder_info->frame_info.qpb;\n  int qpC = sub ? chroma_qp[qpY] : qpY;\n\n  /* Intermediate block variables */\n  SAMPLE *pblock_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n  SAMPLE *pblock_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  int16_t *coeff_y = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *coeff_u = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n  int16_t *coeff_v = thor_alloc(2*MAX_TR_SIZE*MAX_TR_SIZE, 32);\n\n  /* Block variables for bipred */\n  SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n  SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n  SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n  yuv_frame_t *rec = decoder_info->rec;\n  yuv_frame_t *ref = decoder_info->ref[0];\n\n\n  /* Pointers to current position in reconstructed frame*/\n  SAMPLE *rec_y = &rec->y[yposY*rec->stride_y+xposY];\n  SAMPLE *rec_u = &rec->u[yposC*rec->stride_c+xposC];\n  SAMPLE *rec_v = &rec->v[yposC*rec->stride_c+xposC];\n\n  stream_t *stream = decoder_info->stream;\n\n  /* Read data from bitstream */\n  block_info_dec_t block_info;\n  block_info.block_pos.size = size;\n  block_info.block_pos.ypos = ypos;\n  block_info.block_pos.xpos = xpos;\n  block_info.coeffq_y = coeff_y;\n  block_info.coeffq_u = coeff_u;\n  block_info.coeffq_v = coeff_v;\n  block_info.sub = sub;\n\n  /* Used for rectangular skip blocks */\n  int bwidth = min(size,width - xpos);\n  int bheight = min(size,height - ypos);\n  block_info.block_pos.bwidth = bwidth;\n  block_info.block_pos.bheight = bheight;\n\n  read_block(decoder_info,stream,&block_info,frame_type);\n  mode = block_info.block_param.mode;\n\n  if (mode == MODE_INTRA){\n    int ql = decoder_info->qmtx ? qp_to_qlevel(qpY,decoder_info->qmtx_offset) : 0;\n    intra_mode = block_info.block_param.intra_mode;\n    int bwidth = size; //TODO: fix for non-square blocks\n    int bheight = size; //TODO: fix for non-square blocks\n    int upright_available = get_upright_available(yposY, xposY, bwidth, bheight, width, height, 1 << decoder_info->log2_sb_size);\n    int downleft_available = get_downleft_available(yposY, xposY, bwidth, bheight, width, height, 1 << decoder_info->log2_sb_size);\n\n    //int upright_available = get_upright_available(ypos, xpos, size, width, 1 << decoder_info->log2_sb_size);\n    //int downleft_available = get_downleft_available(ypos, xpos, size, height, 1 << decoder_info->log2_sb_size);\n    int tb_split = block_info.block_param.tb_split;\n    decode_and_reconstruct_block_intra(rec_y,rec->stride_y,sizeY,qpY,pblock_y,coeff_y,tb_split,upright_available,downleft_available,intra_mode,yposY,xposY,width,0,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][0][1] : NULL);\n    if (decoder_info->subsample != 400)\n      decode_and_reconstruct_block_intra_uv(rec_u,rec_v,rec->stride_c,sizeC,qpC,pblock_u,pblock_v,coeff_u,coeff_v,tb_split && sizeC > 4,upright_available,downleft_available,intra_mode,yposC,xposC,width>>sub,1,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][1][1] : NULL, decoder_info->cfl_intra ? pblock_y : 0, rec_y, rec->stride_y, sub);\n  }\n  else\n  {\n    int tb_split = block_info.block_param.tb_split;\n    if (mode==MODE_SKIP){\n      if (block_info.block_param.dir==2){\n        SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n\n        int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];\n        yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];\n        int sign0 = ref0->frame_num >= rec->frame_num;\n        int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];\n        yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];\n        int sign1 = ref1->frame_num >= rec->frame_num;\n        if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2 && block_info.block_param.skip_idx==0) {\n          TEMPLATE(get_inter_prediction_temp)(width, height, ref0, ref1, &block_info.block_pos, decoder_info->deblock_data, decoder_info->num_reorder_pics + 1, decoder_info->frame_info.phase, pblock_y, pblock_u, pblock_v);\n        }\n        else {\n          TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, 0, decoder_info->bitdepth);\n          TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, 0, decoder_info->bitdepth);\n          TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);\n        }\n        thor_free(pblock0_y);\n        thor_free(pblock0_u);\n        thor_free(pblock0_v);\n        thor_free(pblock1_y);\n        thor_free(pblock1_u);\n        thor_free(pblock1_v);\n      }\n      else{\n        int ref_idx = block_info.block_param.ref_idx0; //TODO: Move to top\n        int r = decoder_info->frame_info.ref_array[ref_idx];\n        ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];\n        int sign = ref->frame_num > rec->frame_num;\n\n        TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, 0, decoder_info->bitdepth);\n      }\n      int j;\n      for (j = 0; j<bheight; j++) {\n        memcpy(&rec_y[j*rec->stride_y], &pblock_y[j*sizeY], bwidth*sizeof(SAMPLE));\n      }\n      for (j = 0; j<bheight >> sub; j++) {\n        memcpy(&rec_u[j*rec->stride_c], &pblock_u[j*sizeC], (bwidth >> sub)*sizeof(SAMPLE));\n        memcpy(&rec_v[j*rec->stride_c], &pblock_v[j*sizeC], (bwidth >> sub)*sizeof(SAMPLE));\n      }\n      copy_deblock_data(decoder_info, &block_info);\n      return;\n    }\n    else if (mode==MODE_MERGE){\n      if (block_info.block_param.dir==2){\n\n        SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n        SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n\n        int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];\n        yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];\n        int sign0 = ref0->frame_num >= rec->frame_num;\n        TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, 0, decoder_info->bitdepth);\n\n        int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];\n        yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];\n        int sign1 = ref1->frame_num >= rec->frame_num;\n        TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, 0, decoder_info->bitdepth);\n\n        TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);\n\n        thor_free(pblock0_y);\n        thor_free(pblock0_u);\n        thor_free(pblock0_v);\n        thor_free(pblock1_y);\n        thor_free(pblock1_u);\n        thor_free(pblock1_v);\n      }\n      else{\n        int ref_idx = block_info.block_param.ref_idx0; //TODO: Move to top\n        int r = decoder_info->frame_info.ref_array[ref_idx];\n        ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];\n        int sign = ref->frame_num > rec->frame_num;\n        TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, 0, decoder_info->bitdepth);\n      }\n    }\n    else if (mode == MODE_INTER){\n      int ref_idx = block_info.block_param.ref_idx0;\n      int r = decoder_info->frame_info.ref_array[ref_idx];\n      ref = r>=0 ? decoder_info->ref[r] : decoder_info->interp_frames[0];\n      int sign = ref->frame_num > rec->frame_num;\n      TEMPLATE(get_inter_prediction_yuv)(ref, pblock_y, pblock_u, pblock_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);\n    }\n    else if (mode == MODE_BIPRED){\n\n      SAMPLE *pblock0_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n      SAMPLE *pblock0_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n      SAMPLE *pblock0_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n      SAMPLE *pblock1_y = thor_alloc(MAX_SB_SIZE*MAX_SB_SIZE*sizeof(SAMPLE), 32);\n      SAMPLE *pblock1_u = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n      SAMPLE *pblock1_v = thor_alloc((MAX_SB_SIZE*MAX_SB_SIZE >> 2*sub)*sizeof(SAMPLE), 32);\n\n      int r0 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx0];\n      yuv_frame_t *ref0 = r0 >= 0 ? decoder_info->ref[r0] : decoder_info->interp_frames[0];\n      int sign0 = ref0->frame_num >= rec->frame_num;\n      TEMPLATE(get_inter_prediction_yuv)(ref0, pblock0_y, pblock0_u, pblock0_v, &block_info.block_pos, block_info.block_param.mv_arr0, sign0, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);\n\n      int r1 = decoder_info->frame_info.ref_array[block_info.block_param.ref_idx1];\n      yuv_frame_t *ref1 = r1 >= 0 ? decoder_info->ref[r1] : decoder_info->interp_frames[0];\n      int sign1 = ref1->frame_num >= rec->frame_num;\n      TEMPLATE(get_inter_prediction_yuv)(ref1, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, block_info.block_param.mv_arr1, sign1, width, height, bipred, decoder_info->pb_split, decoder_info->bitdepth);\n\n      TEMPLATE(average_blocks_all)(pblock_y, pblock_u, pblock_v, pblock0_y, pblock0_u, pblock0_v, pblock1_y, pblock1_u, pblock1_v, &block_info.block_pos, sub);\n\n      thor_free(pblock0_y);\n      thor_free(pblock0_u);\n      thor_free(pblock0_v);\n      thor_free(pblock1_y);\n      thor_free(pblock1_u);\n      thor_free(pblock1_v);\n    }\n\n    /* Dequantize, invere tranform and reconstruct */\n    int ql = decoder_info->qmtx ? qp_to_qlevel(qpY,decoder_info->qmtx_offset) : 0;\n    decode_and_reconstruct_block_inter(rec_y,rec->stride_y,sizeY,qpY,pblock_y,coeff_y,tb_split,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][0][0] : NULL);\n    // Use reconstructed luma to improve chroma prediction\n    if (decoder_info->cfl_inter && decoder_info->subsample != 400)\n      TEMPLATE(improve_uv_prediction)(pblock_y, pblock_u, pblock_v, rec_y, sizeY, sizeY, rec->stride_y, sub, decoder_info->bitdepth);\n    decode_and_reconstruct_block_inter(rec_u,rec->stride_c,sizeC,qpC,pblock_u,coeff_u,tb_split&&sizeC>4,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][1][0] : NULL);\n    decode_and_reconstruct_block_inter(rec_v,rec->stride_c,sizeC,qpC,pblock_v,coeff_v,tb_split&&sizeC>4,decoder_info->bitdepth,decoder_info->qmtx ? decoder_info->iwmatrix[ql][2][0] : NULL);\n  }\n\n  /* Copy deblock data to frame array */\n  copy_deblock_data(decoder_info,&block_info);\n\n  thor_free(pblock0_y);\n  thor_free(pblock0_u);\n  thor_free(pblock0_v);\n  thor_free(pblock1_y);\n  thor_free(pblock1_u);\n  thor_free(pblock1_v);\n  thor_free(pblock_y);\n  thor_free(pblock_u);\n  thor_free(pblock_v);\n  thor_free(coeff_y);\n  thor_free(coeff_u);\n  thor_free(coeff_v);\n}\n\n\nstatic int decode_super_mode(decoder_info_t *decoder_info, int size, int decode_this_size){\n  stream_t *stream = decoder_info->stream;\n  block_context_t *block_context = decoder_info->block_context;\n\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n  int mode = MODE_SKIP;\n  int stat_mode = STAT_SKIP;\n  int num_ref=0,code,maxbit;\n  int idx = log2i(size)-3;\n\n  decoder_info->mode = MODE_SKIP; //Default initial value\n\n  if (frame_type==I_FRAME){\n    decoder_info->mode = MODE_INTRA;\n    if (size > MIN_BLOCK_SIZE && decode_this_size)\n      split_flag = get_flc(1, stream);\n    else\n      split_flag = !decode_this_size;\n    return split_flag;\n  }\n\n  if (!decode_this_size) {\n    split_flag = !get_flc(1, stream);\n    return split_flag;\n  }\n\n  if (size > MAX_TR_SIZE) {\n    split_flag = !get_flc(1, stream);\n    if (!split_flag)  decoder_info->mode = MODE_SKIP;\n    return split_flag;\n  }\n\n\n  num_ref = decoder_info->frame_info.num_ref;\n  int bipred_possible_flag = num_ref > 1 && decoder_info->bipred;\n  int split_possible_flag = size > MIN_BLOCK_SIZE;\n  maxbit = 2 + num_ref + split_possible_flag + bipred_possible_flag;\n\n  int interp_ref = decoder_info->frame_info.interp_ref;\n\n  if (interp_ref > 2) {\n    maxbit -= 1; //ref_idx = 0 is disallowed\n  }\n\n  code = get_vlc(10 + maxbit, stream);\n\n  if (interp_ref) {\n\n    if ((block_context->index == 2 || block_context->index>3) && size>MIN_BLOCK_SIZE){\n      /* Move skip down the list */\n      if (code<3)\n        code = (code + 1) % 3;\n    }\n\n    if (split_possible_flag && code==1) {\n      /* Set split flag and return */\n      split_flag = 1;\n      decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][STAT_SPLIT] += 1;\n      return split_flag;\n    }\n\n    if (!split_possible_flag && code > 0) {\n      /* Didn't need a codeword for split so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (!bipred_possible_flag && code >= 3) {\n      /* Don't need a codeword for bipred so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (code == 0) {\n      mode = MODE_SKIP;\n      stat_mode = STAT_SKIP;\n    } else if (code == 2) {\n      mode = MODE_MERGE;\n      stat_mode = STAT_MERGE;\n    } else if (code == 3) {\n      mode = MODE_BIPRED;\n      stat_mode = STAT_BIPRED;\n    } else if (code == 4) {\n      mode = MODE_INTRA;\n      stat_mode = STAT_INTRA;\n    } else if (code == 4 + num_ref) {\n      mode = MODE_INTER;\n      decoder_info->ref_idx = 0;\n      stat_mode = STAT_REF_IDX0;\n    }\n    else{\n      mode = MODE_INTER;\n      decoder_info->ref_idx = code - 4;\n      stat_mode = STAT_REF_IDX1 + decoder_info->ref_idx-1;\n    }\n    decoder_info->mode = mode;\n\n\n  } else {\n    if ((block_context->index == 2 || block_context->index>3) && size>MIN_BLOCK_SIZE){\n      /* Skip is less likely than split, merge and inter-ref_idx=0 so move skip down the list */\n      if (code<4)\n        code = (code + 1) % 4;\n    }\n\n    if (split_possible_flag && code==1) {\n      /* Set split flag and return */\n      split_flag = 1;\n      decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][STAT_SPLIT] += 1;\n      return split_flag;\n    }\n\n    if (!split_possible_flag && code > 0) {\n      /* Didn't need a codeword for split so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (!bipred_possible_flag && code >= 4) {\n      /* Don't need a codeword for bipred so adjust for the empty slot */\n      code += 1;\n    }\n\n    if (code == 0) {\n      mode = MODE_SKIP;\n      stat_mode = STAT_SKIP;\n    }\n    else if (code == 2) {\n      mode = MODE_INTER;\n      decoder_info->ref_idx = 0;\n      stat_mode = STAT_REF_IDX0;\n    }\n    else if (code == 3) {\n      mode = MODE_MERGE;\n      stat_mode = STAT_MERGE;\n    }\n    else if (code == 4) {\n      mode = MODE_BIPRED;\n      stat_mode = STAT_BIPRED;\n    }\n    else if (code == 5) {\n      mode = MODE_INTRA;\n      stat_mode = STAT_INTRA;\n    }\n    else{\n      mode = MODE_INTER;\n      decoder_info->ref_idx = code - 5;\n      stat_mode = STAT_REF_IDX1 + decoder_info->ref_idx - 1;\n    }\n    decoder_info->mode = mode;\n\n  }\n  decoder_info->bit_count.super_mode_stat[decoder_info->bit_count.stat_frame_type][idx][stat_mode] += 1;\n\n  return split_flag;\n}\n\n\nvoid TEMPLATE(process_block_dec)(decoder_info_t *decoder_info,int size,int yposY,int xposY,int sub)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  stream_t *stream = decoder_info->stream;\n  frame_type_t frame_type = decoder_info->frame_info.frame_type;\n  int split_flag = 0;\n\n  if (yposY >= height || xposY >= width)\n    return;\n\n  int decode_this_size = (yposY + size <= height) && (xposY + size <= width);\n  int decode_rectangular_size = !decode_this_size && frame_type != I_FRAME;\n\n  int bit_start = stream->bitcnt;\n\n  int mode = MODE_SKIP;\n \n  block_context_t block_context;\n  TEMPLATE(find_block_contexts)(yposY, xposY, height, width, size, decoder_info->deblock_data, &block_context, decoder_info->use_block_contexts);\n  decoder_info->block_context = &block_context;\n\n  split_flag = decode_super_mode(decoder_info,size,decode_this_size);\n  mode = decoder_info->mode;\n  \n  /* Read delta_qp and set block-level qp */\n  if (size == (1<<decoder_info->log2_sb_size) && (split_flag || mode != MODE_SKIP) && decoder_info->max_delta_qp > 0) {\n    /* Read delta_qp */\n    int delta_qp = read_delta_qp(stream);\n    int prev_qp;\n    if (yposY == 0 && xposY == 0)\n      prev_qp = decoder_info->frame_info.qp;\n    else\n      prev_qp = decoder_info->frame_info.qpb;\n    decoder_info->frame_info.qpb = prev_qp + delta_qp;\n  }\n\n  decoder_info->bit_count.super_mode[decoder_info->bit_count.stat_frame_type] += (stream->bitcnt - bit_start);\n\n  if (split_flag && size >= MIN_BLOCK_SIZE){\n    int new_size = size/2;\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+0*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+0*new_size,xposY+1*new_size,sub);\n    TEMPLATE(process_block_dec)(decoder_info,new_size,yposY+1*new_size,xposY+1*new_size,sub);\n  }\n  else if (decode_this_size || decode_rectangular_size){\n    decode_block(decoder_info,size,yposY,xposY,sub);\n  }\n}\n", "/*\nCopyright (c) 2015, Cisco Systems\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <math.h>\n#include <string.h>\n#include <memory.h>\n#include <assert.h>\n\n#include \"global.h\"\n#include \"getvlc.h\"\n#include \"common_block.h\"\n#include \"inter_prediction.h\"\n\nextern int zigzag16[16];\nextern int zigzag64[64];\nextern int zigzag256[256];\n\nint YPOS, XPOS;\n\n#undef TEMPLATE\n#define TEMPLATE(func) (decoder_info->bitdepth == 8 ? func ## _lbd : func ## _hbd)\n\nvoid read_sequence_header(decoder_info_t *decoder_info, stream_t *stream) {\n  decoder_info->width = get_flc(16, stream);\n  decoder_info->height = get_flc(16, stream);\n  decoder_info->log2_sb_size = get_flc(3, stream);\n  decoder_info->log2_sb_size = clip(decoder_info->log2_sb_size, log2i(MIN_BLOCK_SIZE), log2i(MAX_SB_SIZE));\n  decoder_info->pb_split = get_flc(1, stream);\n  decoder_info->tb_split_enable = get_flc(1, stream);\n  decoder_info->max_num_ref = get_flc(2, stream) + 1;\n  decoder_info->interp_ref = get_flc(2, stream);\n  decoder_info->max_delta_qp = get_flc(1, stream);\n  decoder_info->deblocking = get_flc(1, stream);\n  decoder_info->clpf = get_flc(1, stream);\n  decoder_info->use_block_contexts = get_flc(1, stream);\n  decoder_info->bipred = get_flc(2, stream);\n  decoder_info->qmtx = get_flc(1, stream);\n  if (decoder_info->qmtx) {\n    decoder_info->qmtx_offset = get_flc(6, stream) - 32;\n  }\n  decoder_info->subsample = get_flc(2, stream);\n    decoder_info->subsample = // 0: 400  1: 420  2: 422  3: 444\n    (decoder_info->subsample & 1) * 20 + (decoder_info->subsample & 2) * 22 +\n    ((decoder_info->subsample & 3) == 3) * 2 + 400;\n  decoder_info->num_reorder_pics = get_flc(4, stream);\n  if (decoder_info->subsample != 400) {\n    decoder_info->cfl_intra = get_flc(1, stream);\n    decoder_info->cfl_inter = get_flc(1, stream);\n  }\n  decoder_info->bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->bitdepth == 10)\n    decoder_info->bitdepth += 2 * get_flc(1, stream);\n  decoder_info->input_bitdepth = get_flc(1, stream) ? 10 : 8;\n  if (decoder_info->input_bitdepth == 10)\n    decoder_info->input_bitdepth += 2 * get_flc(1, stream);\n}\n\nvoid read_frame_header(decoder_info_t *dec_info, stream_t *stream) {\n  frame_info_t *frame_info = &dec_info->frame_info;\n  frame_info->frame_type = get_flc(1, stream);\n  frame_info->qp = get_flc(8, stream);\n  frame_info->num_intra_modes = get_flc(4, stream);\n  if (frame_info->frame_type != I_FRAME) {\n    frame_info->num_ref = get_flc(2, stream) + 1;\n    int r;\n    for (r = 0; r < frame_info->num_ref; r++) {\n      frame_info->ref_array[r] = get_flc(6, stream) - 1;\n    }\n    if (frame_info->num_ref == 2 && frame_info->ref_array[0] == -1) {\n      frame_info->ref_array[frame_info->num_ref++] = get_flc(5, stream) - 1;\n    }\n  }\n  else {\n    frame_info->num_ref = 0;\n  }\n  frame_info->display_frame_num = get_flc(16, stream);\n\n#if CDEF\n  dec_info->cdef_damping[1] = dec_info->cdef_damping[0] = get_flc(2, stream) + 3;\n  dec_info->cdef_bits = get_flc(2, stream);\n\n  for (int i = 0; i < (1 << dec_info->cdef_bits); i++) {\n    dec_info->cdef_presets[i].pri_strength[0] = get_flc(4, stream);\n    dec_info->cdef_presets[i].skip_condition[0] = get_flc(1, stream);\n    dec_info->cdef_presets[i].sec_strength[0] = get_flc(2, stream);\n    if (dec_info->subsample != 400) {\n      dec_info->cdef_presets[i].pri_strength[1] = get_flc(4, stream);\n      dec_info->cdef_presets[i].skip_condition[1] = get_flc(1, stream);\n      dec_info->cdef_presets[i].sec_strength[1] = get_flc(2, stream);\n    }\n  }\n#endif\n}\n\n\nvoid read_mv(stream_t *stream,mv_t *mv,mv_t *mvp)\n{\n    mv_t mvd;\n    int mvabs, mvsign = 0;\n\n    /* MVX */\n    if ((mvabs = get_vlc(7, stream)))\n      mvsign = get_flc(1, stream);\n    mvd.x = mvabs * (mvsign ? -1 : 1);\n    mv->x = mvp->x + mvd.x;\n\n    /* MVY */\n    if ((mvabs = get_vlc(7, stream)))\n      mvsign = get_flc(1, stream);\n    mvd.y = mvabs * (mvsign ? -1 : 1);\n    mv->y = mvp->y + mvd.y;\n}\n\n\n\nvoid read_coeff(stream_t *stream,int16_t *coeff,int size,int type){\n\n  int16_t scoeff[MAX_QUANT_SIZE*MAX_QUANT_SIZE];\n  int i,j,levelFlag,sign,level,pos,run,tmp,code;\n  int qsize = min(size,MAX_QUANT_SIZE);\n  int N = qsize*qsize;\n  int level_mode;\n  int chroma_flag = type&1;\n  int intra_flag = (type>>1)&1;\n  int vlc_adaptive = intra_flag && !chroma_flag;\n\n  /* Initialize arrays */\n  memset(scoeff,0,N*sizeof(int16_t));\n  memset(coeff,0,size*size*sizeof(int16_t));\n\n  pos = 0;\n  /* Use one bit to signal chroma/last_pos=1/level=1 */\n  if (chroma_flag==1){\n    int tmp = get_flc(1, stream);\n    if (tmp){\n      sign = get_flc(1, stream);\n      scoeff[pos] = sign ? -1 : 1;\n      pos = N;\n    }\n  }\n\n  /* Initiate forward scan */\n  level_mode = 1;\n  level = 1;\n  while (pos < N){\n    if (level_mode){\n      /* Level-mode */\n      while (pos < N && level > 0){\n        level = get_vlc(vlc_adaptive,stream);\n        if (level){\n          sign = get_flc(1, stream);\n        }\n        else{\n          sign = 1;\n        }\n        scoeff[pos] = sign ? -level : level;\n        if (chroma_flag==0)\n          vlc_adaptive = level > 3;\n        pos++;\n      }\n    }\n    if (pos >= N){\n      break;\n    }\n\n    /* Run-mode */\n    int eob;\n    int eob_pos = chroma_flag ? 0 : 2;\n    if (chroma_flag && size <= 8)\n      code = get_vlc(10, stream);\n    else\n      code = get_vlc(6, stream);\n\n    eob = code == eob_pos;\n    if (eob) {\n      break;\n    }\n    if (code > eob_pos) code -= 1;\n    levelFlag = (code % 5) == 4;\n    if (levelFlag)\n      run = code / 5;\n    else\n      run = 4*(code/5) + code % 5;\n    pos += run;\n\n    /* Decode level and sign */\n    if (levelFlag){\n      tmp = get_vlc(0,stream);\n      sign = tmp&1;\n      level = (tmp>>1)+2;\n    }\n    else{\n      level = 1;\n      sign = get_flc(1, stream);\n    }\n    scoeff[pos] = sign ? -level : level;\n\n    level_mode = level > 1; //Set level_mode\n    pos++;\n  } //while pos < N\n\n  /* Perform inverse zigzag scan */\n  int *zigzagptr = zigzag64;\n  if (qsize==4)\n    zigzagptr = zigzag16;\n  else if (qsize==8)\n    zigzagptr = zigzag64;\n  else if (qsize==16)\n    zigzagptr = zigzag256;\n  for (i=0;i<qsize;i++){\n    for (j=0;j<qsize;j++){\n      coeff[i*qsize + j] = scoeff[zigzagptr[i*qsize + j]];\n    }\n  }\n}\n\nint read_delta_qp(stream_t *stream){\n  int abs_delta_qp,sign_delta_qp,delta_qp;\n  sign_delta_qp = 0;\n  abs_delta_qp = get_vlc(0,stream);\n  if (abs_delta_qp > 0)\n    sign_delta_qp = get_flc(1, stream);\n  delta_qp = sign_delta_qp ? -abs_delta_qp : abs_delta_qp;\n  return delta_qp;\n}\nint read_block(decoder_info_t *decoder_info,stream_t *stream,block_info_dec_t *block_info, frame_type_t frame_type)\n{\n  int width = decoder_info->width;\n  int height = decoder_info->height;\n  int bit_start;\n  int code,tb_split;\n  int pb_part=0;\n  cbp_t cbp;\n  int stat_frame_type = decoder_info->bit_count.stat_frame_type; //TODO: Use only one variable for frame type\n\n  int size = block_info->block_pos.size;\n  int ypos = block_info->block_pos.ypos;\n  int xpos = block_info->block_pos.xpos;\n\n  YPOS = ypos;\n  XPOS = xpos;\n\n  int sizeY = size;\n  int sizeC = size>>block_info->sub;\n\n  mv_t mv,zerovec;\n  mv_t mvp;\n  mv_t mv_arr[4]; //TODO: Use mv_arr0 instead\n  mv_t mv_arr0[4];\n  mv_t mv_arr1[4];\n\n  block_mode_t mode;\n  intra_mode_t intra_mode = MODE_DC;\n\n  int16_t *coeff_y = block_info->coeffq_y;\n  int16_t *coeff_u = block_info->coeffq_u;\n  int16_t *coeff_v = block_info->coeffq_v;\n\n  zerovec.y = zerovec.x = 0;\n  bit_start = stream->bitcnt;\n\n  mode = decoder_info->mode;\n  int coeff_block_type = (mode == MODE_INTRA)<<1;\n\n  /* Initialize bit counter for statistical purposes */\n  bit_start = stream->bitcnt;\n\n  if (mode == MODE_SKIP){\n    /* Derive skip vector candidates and number of skip vector candidates from neighbour blocks */\n    mv_t mv_skip[MAX_NUM_SKIP];\n    int num_skip_vec,skip_idx;\n    inter_pred_t skip_candidates[MAX_NUM_SKIP];\n    num_skip_vec = TEMPLATE(get_mv_skip)(ypos, xpos, width, height, size, size, 1 << decoder_info->log2_sb_size, decoder_info->deblock_data, skip_candidates);\n    if (decoder_info->bit_count.stat_frame_type == B_FRAME && decoder_info->interp_ref == 2) {\n      num_skip_vec = TEMPLATE(get_mv_skip_temp)(decoder_info->width, decoder_info->frame_info.phase, decoder_info->num_reorder_pics + 1, &block_info->block_pos, decoder_info->deblock_data, skip_candidates);\n    }\n    for (int idx = 0; idx < num_skip_vec; idx++) {\n      mv_skip[idx] = skip_candidates[idx].mv0;\n    }\n    /* Decode skip index */\n    if (num_skip_vec == 4)\n      skip_idx = get_flc(2, stream);\n    else if (num_skip_vec == 3){\n      skip_idx = get_vlc(12, stream);\n    }\n    else if (num_skip_vec == 2){\n      skip_idx = get_flc(1, stream);\n    }\n    else\n      skip_idx = 0;\n    decoder_info->bit_count.skip_idx[stat_frame_type] += (stream->bitcnt - bit_start);\n\n    block_info->num_skip_vec = num_skip_vec;\n    block_info->block_param.skip_idx = skip_idx;\n\n    if (skip_idx == num_skip_vec)\n      mv = mv_skip[0];\n    else\n      mv = mv_skip[skip_idx];\n    mv_arr[0] = mv;\n    mv_arr[1] = mv;\n    mv_arr[2] = mv;\n    mv_arr[3] = mv;\n\n    block_info->block_param.ref_idx0 = skip_candidates[skip_idx].ref_idx0;\n    block_info->block_param.ref_idx1 = skip_candidates[skip_idx].ref_idx1;\n    for (int i = 0; i < 4; i++) {\n      mv_arr0[i] = skip_candidates[skip_idx].mv0;\n      mv_arr1[i] = skip_candidates[skip_idx].mv1;\n    }\n    block_info->block_param.dir = skip_candidates[skip_idx].bipred_flag;\n  }\n  else if (mode == MODE_MERGE){\n    /* Derive skip vector candidates and number of skip vector candidates from neighbour blocks */\n    mv_t mv_skip[MAX_NUM_SKIP];\n    int num_skip_vec,skip_idx;\n    inter_pred_t merge_candidates[MAX_NUM_SKIP];\n    num_skip_vec = TEMPLATE(get_mv_merge)(ypos, xpos, width, height, size, size, 1 << decoder_info->log2_sb_size, decoder_info->deblock_data, merge_candidates);\n    for (int idx = 0; idx < num_skip_vec; idx++) {\n      mv_skip[idx] = merge_candidates[idx].mv0;\n    }\n    /* Decode skip index */\n    if (num_skip_vec == 4)\n      skip_idx = get_flc(2, stream);\n    else if (num_skip_vec == 3){\n      skip_idx = get_vlc(12, stream);\n    }\n    else if (num_skip_vec == 2){\n      skip_idx = get_flc(1, stream);\n    }\n    else\n      skip_idx = 0;\n    decoder_info->bit_count.skip_idx[stat_frame_type] += (stream->bitcnt - bit_start);\n\n    block_info->num_skip_vec = num_skip_vec;\n    block_info->block_param.skip_idx = skip_idx;\n\n    if (skip_idx == num_skip_vec)\n      mv = mv_skip[0];\n    else\n      mv = mv_skip[skip_idx];\n    mv_arr[0] = mv;\n    mv_arr[1] = mv;\n    mv_arr[2] = mv;\n    mv_arr[3] = mv;\n\n    block_info->block_param.ref_idx0 = merge_candidates[skip_idx].ref_idx0;\n    block_info->block_param.ref_idx1 = merge_candidates[skip_idx].ref_idx1;\n    for (int i = 0; i < 4; i++) {\n      mv_arr0[i] = merge_candidates[skip_idx].mv0;\n      mv_arr1[i] = merge_candidates[skip_idx].mv1;\n    }\n    block_info->block_param.dir = merge_candidates[skip_idx].bipred_flag;\n  }\n  else if (mode==MODE_INTER){\n    int ref_idx;\n\n    if (decoder_info->pb_split){\n      /* Decode PU partition */\n      pb_part = get_vlc(13, stream);\n    }\n    else{\n      pb_part = 0;\n    }\n    block_info->block_param.pb_part = pb_part;\n    if (decoder_info->frame_info.num_ref > 1){\n      ref_idx = decoder_info->ref_idx;\n    }\n    else{\n      ref_idx = 0;\n    }\n\n    //if (mode==MODE_INTER)\n    decoder_info->bit_count.size_and_ref_idx[stat_frame_type][log2i(size)-3][ref_idx] += 1;\n\n    mvp = TEMPLATE(get_mv_pred)(ypos,xpos,width,height,size,size,1<<decoder_info->log2_sb_size,ref_idx,decoder_info->deblock_data);\n\n    /* Deode motion vectors for each prediction block */\n    mv_t mvp2 = mvp;\n\n    if (pb_part==0){\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mv_arr[1] = mv_arr[0];\n      mv_arr[2] = mv_arr[0];\n      mv_arr[3] = mv_arr[0];\n    }\n    else if(pb_part==1){ //HOR\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mvp2 = mv_arr[0];\n      read_mv(stream,&mv_arr[2],&mvp2);\n      mv_arr[1] = mv_arr[0];\n      mv_arr[3] = mv_arr[2];\n    }\n    else if(pb_part==2){ //VER\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mvp2 = mv_arr[0];\n      read_mv(stream,&mv_arr[1],&mvp2);\n      mv_arr[2] = mv_arr[0];\n      mv_arr[3] = mv_arr[1];\n    }\n    else{\n      read_mv(stream,&mv_arr[0],&mvp2);\n      mvp2 = mv_arr[0];\n      read_mv(stream,&mv_arr[1],&mvp2);\n      read_mv(stream,&mv_arr[2],&mvp2);\n      read_mv(stream,&mv_arr[3],&mvp2);\n    }\n    decoder_info->bit_count.mv[stat_frame_type] += (stream->bitcnt - bit_start);\n    block_info->block_param.ref_idx0 = ref_idx;\n    block_info->block_param.ref_idx1 = ref_idx;\n    block_info->block_param.dir = 0;\n  }\n  else if (mode==MODE_BIPRED){\n    int ref_idx = 0;\n    mvp = TEMPLATE(get_mv_pred)(ypos,xpos,width,height,size,size,1 << decoder_info->log2_sb_size, ref_idx,decoder_info->deblock_data);\n\n    /* Deode motion vectors */\n    mv_t mvp2 = mvp;\n\n#if BIPRED_PART\n    if (decoder_info->pb_split) {\n      /* Decode PU partition */\n      pb_part = get_vlc(13, stream);\n    }\n    else {\n      pb_part = 0;\n    }\n#else\n    pb_part = 0;\n#endif\n    block_info->block_param.pb_part = pb_part;\n\n    if (pb_part == 0) {\n      read_mv(stream, &mv_arr0[0], &mvp2);\n      mv_arr0[1] = mv_arr0[0];\n      mv_arr0[2] = mv_arr0[0];\n      mv_arr0[3] = mv_arr0[0];\n    }\n    else {\n      mv_arr0[0] = mvp2;\n      mv_arr0[1] = mvp2;\n      mv_arr0[2] = mvp2;\n      mv_arr0[3] = mvp2;\n    }\n    if (decoder_info->bit_count.stat_frame_type == B_FRAME)\n      mvp2 = mv_arr0[0];\n    if (pb_part == 0) {\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mv_arr1[1] = mv_arr1[0];\n      mv_arr1[2] = mv_arr1[0];\n      mv_arr1[3] = mv_arr1[0];\n    }\n    else if (pb_part == 1) { //HOR\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mvp2 = mv_arr1[0];\n      read_mv(stream, &mv_arr1[2], &mvp2);\n      mv_arr1[1] = mv_arr1[0];\n      mv_arr1[3] = mv_arr1[2];\n    }\n    else if (pb_part == 2) { //VER\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mvp2 = mv_arr1[0];\n      read_mv(stream, &mv_arr1[1], &mvp2);\n      mv_arr1[2] = mv_arr1[0];\n      mv_arr1[3] = mv_arr1[1];\n    }\n    else {\n      read_mv(stream, &mv_arr1[0], &mvp2);\n      mvp2 = mv_arr1[0];\n      read_mv(stream, &mv_arr1[1], &mvp2);\n      read_mv(stream, &mv_arr1[2], &mvp2);\n      read_mv(stream, &mv_arr1[3], &mvp2);\n    }\n\n    if (decoder_info->bit_count.stat_frame_type == B_FRAME) {\n      block_info->block_param.ref_idx0 = 0;\n      block_info->block_param.ref_idx1 = 1;\n      if (decoder_info->frame_info.interp_ref > 0) {\n        block_info->block_param.ref_idx0 += 1;\n        block_info->block_param.ref_idx1 += 1;\n      }\n    }\n    else{\n      if (decoder_info->frame_info.num_ref == 2) {\n        int code = get_vlc(13, stream);\n        block_info->block_param.ref_idx0 = (code >> 1) & 1;\n        block_info->block_param.ref_idx1 = (code >> 0) & 1;\n      }\n      else {\n        int code = get_vlc(10, stream);\n        block_info->block_param.ref_idx0 = (code >> 2) & 3;\n        block_info->block_param.ref_idx1 = (code >> 0) & 3;\n      }\n    }\n    block_info->block_param.dir = 2;\n    int combined_ref = block_info->block_param.ref_idx0 * decoder_info->frame_info.num_ref + block_info->block_param.ref_idx1;\n    decoder_info->bit_count.bi_ref[stat_frame_type][combined_ref] += 1;\n    decoder_info->bit_count.mv[stat_frame_type] += (stream->bitcnt - bit_start);\n  }\n\n  else if (mode==MODE_INTRA){\n    /* Decode intra prediction mode */\n    if (decoder_info->frame_info.num_intra_modes<=4){\n      intra_mode = get_flc(2, stream);\n    }\n    else {\n      intra_mode = get_vlc(8, stream);\n    }\n\n    decoder_info->bit_count.intra_mode[stat_frame_type] += (stream->bitcnt - bit_start);\n    decoder_info->bit_count.size_and_intra_mode[stat_frame_type][log2i(size)-3][intra_mode] += 1;\n\n    block_info->block_param.intra_mode = intra_mode;\n    for (int i=0;i<4;i++){\n      mv_arr[i] = zerovec; //Note: This is necessary for derivation of mvp and mv_skip\n    }\n    block_info->block_param.ref_idx0 = 0;\n    block_info->block_param.ref_idx1 = 0;\n    block_info->block_param.dir = -1;\n  }\n\n\n  if (mode!=MODE_SKIP){\n    int tmp;\n    int cbp_table[8] = {1,0,5,2,6,3,7,4};\n    code = 0;\n\n    if (decoder_info->subsample == 400) {\n      tb_split = cbp.u = cbp.v = 0;\n      cbp.y = get_flc(1,stream);\n      if (decoder_info->tb_split_enable && cbp.y) {\n        // 0: cbp=split=0, 10: cbp=1,split=0, 11: split=1\n        tb_split = get_flc(1,stream);\n        cbp.y &= !tb_split;\n      }\n    } else {\n      bit_start = stream->bitcnt;\n      code = get_vlc(0,stream);\n      int off = (mode == MODE_MERGE) ? 1 : 2;\n      if (decoder_info->tb_split_enable) {\n        tb_split = code == off;\n        if (code > off) code -= 1;\n        if (tb_split)\n          decoder_info->bit_count.cbp2_stat[0][stat_frame_type][mode-1][log2i(size)-3][8] += 1;\n      }\n      else{\n        tb_split = 0;\n      }\n    }\n    block_info->block_param.tb_split = tb_split;\n    decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n\n    if (tb_split == 0){\n      if (decoder_info->subsample != 400) {\n        tmp = 0;\n        if (mode==MODE_MERGE){\n          if (code==7)\n            code = 1;\n          else if (code>0)\n            code = code+1;\n        }\n        else {\n          if (decoder_info->block_context->cbp == 0 && code < 2) {\n            code = 1 - code;\n          }\n        }\n        while (tmp < 8 && code != cbp_table[tmp]) tmp++;\n        decoder_info->bit_count.cbp2_stat[max(0,decoder_info->block_context->cbp)][stat_frame_type][mode-1][log2i(size)-3][tmp] += 1;\n\n        cbp.y = ((tmp>>0)&1);\n        cbp.u = ((tmp>>1)&1);\n        cbp.v = ((tmp>>2)&1);\n      }\n      block_info->cbp = cbp;\n\n      if (cbp.y){\n        bit_start = stream->bitcnt;\n        read_coeff(stream,coeff_y,sizeY,coeff_block_type|0);\n        decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);\n      }\n      else\n        memset(coeff_y,0,sizeY*sizeY*sizeof(int16_t));\n\n      if (cbp.u){\n        bit_start = stream->bitcnt;\n        read_coeff(stream,coeff_u,sizeC,coeff_block_type|1);\n        decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);\n      }\n      else\n        memset(coeff_u,0,sizeC*sizeC*sizeof(int16_t));\n\n      if (cbp.v){\n        bit_start = stream->bitcnt;\n        read_coeff(stream,coeff_v,sizeC,coeff_block_type|1);\n        decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);\n      }\n      else\n        memset(coeff_v,0,sizeC*sizeC*sizeof(int16_t));\n    }\n    else{\n      if (sizeC > 4){\n        int index;\n        int16_t *coeff;\n\n        /* Loop over 4 TUs */\n        for (index=0;index<4;index++){\n          bit_start = stream->bitcnt;\n          code = get_vlc(0,stream);\n          int tmp = 0;\n          while (code != cbp_table[tmp] && tmp < 8) tmp++;\n          if (decoder_info->block_context->cbp==0 && tmp < 2)\n            tmp = 1-tmp;\n          cbp.y = ((tmp>>0)&1);\n          cbp.u = ((tmp>>1)&1);\n          cbp.v = ((tmp>>2)&1);\n\n          /* Updating statistics for CBP */\n          decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n          decoder_info->bit_count.cbp_stat[stat_frame_type][cbp.y + (cbp.u<<1) + (cbp.v<<2)] += 1;\n\n          /* Decode coefficients for this TU */\n\n          /* Y */\n          coeff = coeff_y + index*sizeY/2*sizeY/2;\n          if (cbp.y){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeY/2,coeff_block_type|0);\n            decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeY/2*sizeY/2*sizeof(int16_t));\n          }\n\n          /* U */\n          coeff = coeff_u + index*sizeC/2*sizeC/2;\n          if (cbp.u){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeC/2,coeff_block_type|1);\n            decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeC/2*sizeC/2*sizeof(int16_t));\n          }\n\n          /* V */\n          coeff = coeff_v + index*sizeC/2*sizeC/2;\n          if (cbp.v){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeC/2,coeff_block_type|1);\n            decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeC/2*sizeC/2*sizeof(int16_t));\n          }\n        }\n        block_info->cbp.y = 1; //TODO: Do properly with respect to deblocking filter\n        block_info->cbp.u = 1;\n        block_info->cbp.v = 1;\n      }\n      else{\n        int index;\n        int16_t *coeff;\n\n        /* Loop over 4 TUs */\n        for (index=0;index<4;index++){\n          bit_start = stream->bitcnt;\n          cbp.y = get_flc(1, stream);\n          decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n\n          /* Y */\n          coeff = coeff_y + index*sizeY/2*sizeY/2;\n          if (cbp.y){\n            bit_start = stream->bitcnt;\n            read_coeff(stream,coeff,sizeY/2,coeff_block_type|0);\n            decoder_info->bit_count.coeff_y[stat_frame_type] += (stream->bitcnt - bit_start);\n          }\n          else{\n            memset(coeff,0,sizeY/2*sizeY/2*sizeof(int16_t));\n          }\n        }\n\n        bit_start = stream->bitcnt;\n        if (decoder_info->subsample != 400) {\n          int tmp;\n          tmp = get_vlc(13, stream);\n          cbp.u = tmp & 1;\n          cbp.v = (tmp >> 1) & 1;\n        } else\n          cbp.u = cbp.v = 0;\n        decoder_info->bit_count.cbp[stat_frame_type] += (stream->bitcnt - bit_start);\n        if (cbp.u){\n          bit_start = stream->bitcnt;\n          read_coeff(stream,coeff_u,sizeC,coeff_block_type|1);\n          decoder_info->bit_count.coeff_u[stat_frame_type] += (stream->bitcnt - bit_start);\n        }\n        else\n          memset(coeff_u,0,sizeC*sizeC*sizeof(int16_t));\n        if (cbp.v){\n          bit_start = stream->bitcnt;\n          read_coeff(stream,coeff_v,sizeC,coeff_block_type|1);\n          decoder_info->bit_count.coeff_v[stat_frame_type] += (stream->bitcnt - bit_start);\n        }\n        else\n          memset(coeff_v,0,sizeC*sizeC*sizeof(int16_t));\n\n        block_info->cbp.y = 1; //TODO: Do properly with respect to deblocking filter\n        block_info->cbp.u = 1;\n        block_info->cbp.v = 1;\n      } //if (size==8)\n    } //if (tb_split==0)\n  } //if (mode!=MODE_SKIP)\n  else{\n    tb_split = 0;\n    block_info->cbp.y = 0;\n    block_info->cbp.u = 0;\n    block_info->cbp.v = 0;\n  }\n\n  /* Store block data */\n  if (mode==MODE_BIPRED){\n    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  else if(mode==MODE_SKIP){\n    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  else if(mode==MODE_MERGE){\n    memcpy(block_info->block_param.mv_arr0,mv_arr0,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr1,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  else{\n    memcpy(block_info->block_param.mv_arr0,mv_arr,4*sizeof(mv_t)); //Used for mv0 coding\n    memcpy(block_info->block_param.mv_arr1,mv_arr,4*sizeof(mv_t)); //Used for mv1 coding\n  }\n  block_info->block_param.mode = mode;\n  block_info->block_param.tb_split = tb_split;\n\n  int bwidth = min(size,width - xpos);\n  int bheight = min(size,height - ypos);\n\n  /* Update mode and block size statistics */\n  decoder_info->bit_count.mode[stat_frame_type][mode] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);\n  decoder_info->bit_count.size[stat_frame_type][log2i(size)-3] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);\n  decoder_info->bit_count.size_and_mode[stat_frame_type][log2i(size)-3][mode] += (bwidth/MIN_BLOCK_SIZE * bheight/MIN_BLOCK_SIZE);\n  return 0;\n}\n"], "filenames": ["dec/decode_block.c", "dec/read_bits.c"], "buggy_code_start_loc": [653, 52], "buggy_code_end_loc": [654, 52], "fixing_code_start_loc": [653, 53], "fixing_code_end_loc": [654, 54], "type": "CWE-119", "message": "Stack-based buffer overflow in the Cisco Thor decoder before commit 18de8f9f0762c3a542b1122589edb8af859d9813 allows local users to cause a denial of service (segmentation fault) and execute arbitrary code via a crafted non-conformant Thor bitstream.", "other": {"cve": {"id": "CVE-2018-0429", "sourceIdentifier": "ykramarz@cisco.com", "published": "2018-08-09T20:29:00.143", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stack-based buffer overflow in the Cisco Thor decoder before commit 18de8f9f0762c3a542b1122589edb8af859d9813 allows local users to cause a denial of service (segmentation fault) and execute arbitrary code via a crafted non-conformant Thor bitstream."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en pila en el decodificador de Cisco Thor antes del commit con ID 18de8f9f0762c3a542b1122589edb8af859d9813 permite que usuarios locales provoquen una denegaci\u00f3n de servicio (fallo de segmentaci\u00f3n) y ejecuten c\u00f3digo arbitrario mediante un bitstream Thor manipulado no conforme."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cisco:thor_video_codec:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-8-8", "matchCriteriaId": "3E206463-3F27-49D7-9428-DF1BCE08EF1F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/105059", "source": "ykramarz@cisco.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/cisco/thor/commit/18de8f9f0762c3a542b1122589edb8af859d9813", "source": "ykramarz@cisco.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/cisco/thor/commit/18de8f9f0762c3a542b1122589edb8af859d9813"}}