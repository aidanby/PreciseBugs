{"buggy_code": ["use std::num::{IntErrorKind, ParseIntError};\n\nuse crate::{\n    parse::{Input, ParseErrorMsg, Token},\n    repetition::RepetitionError,\n    span::Span,\n};\n\nuse super::Diagnostic;\n\n/// An error than can occur only during parsing\n#[derive(Debug, Clone)]\npub struct ParseError {\n    pub(super) kind: ParseErrorKind,\n    pub(super) span: Option<Span>,\n}\n\nimpl ParseError {\n    /// Create a [Diagnostic] from this error.\n    pub fn diagnostic(self, source_code: &str) -> Diagnostic {\n        Diagnostic::from_parse_error(self, source_code)\n    }\n}\n\nimpl core::fmt::Display for ParseError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        if let Some(span) = self.span {\n            write!(f, \"{}\\n  at {}\", self.kind, span)\n        } else {\n            self.kind.fmt(f)\n        }\n    }\n}\n\nimpl From<nom::Err<ParseError>> for ParseError {\n    fn from(e: nom::Err<ParseError>) -> Self {\n        match e {\n            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),\n            nom::Err::Error(e) | nom::Err::Failure(e) => e,\n        }\n    }\n}\n\nimpl<'i, 'b> nom::error::ParseError<Input<'i, 'b>> for ParseError {\n    fn from_error_kind(i: Input<'i, 'b>, kind: nom::error::ErrorKind) -> Self {\n        ParseErrorKind::Nom(kind).at(i.span())\n    }\n\n    fn append(_: Input<'i, 'b>, _: nom::error::ErrorKind, other: Self) -> Self {\n        other\n    }\n}\n\n/// An error kind (without a span) than can occur only during parsing\n#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub(crate) enum ParseErrorKind {\n    #[error(\"Unknown token\")]\n    UnknownToken,\n    #[error(transparent)]\n    LexErrorWithMessage(ParseErrorMsg),\n    #[error(\"Unexpected dot. Use `[.]` instead\")]\n    Dot,\n\n    #[error(\"Expected {}\", .0)]\n    Expected(&'static str),\n    #[error(\"There are leftover tokens that couldn't be parsed\")]\n    LeftoverTokens,\n    #[error(\"Expected {}\", .0)]\n    ExpectedToken(Token),\n    #[error(\"Expected code point or character\")]\n    ExpectedCodePointOrChar,\n    #[error(\"The first number in a range must be smaller than the second\")]\n    RangeIsNotIncreasing,\n    #[error(\"This expression can't be negated\")]\n    UnallowedNot,\n    #[error(\"An expression can't be negated twice\")]\n    UnallowedDoubleNot,\n    #[error(\"Range is too big, it isn't allowed to contain more than {} digits\", .0)]\n    RangeIsTooBig(u8),\n    #[error(\"A variable with the same name already exists in this scope\")]\n    LetBindingExists,\n    #[error(\"Unsupported escape sequence in string\")]\n    InvalidEscapeInStringAt(usize),\n    #[error(transparent)]\n    CharString(CharStringError),\n    #[error(transparent)]\n    CharClass(CharClassError),\n    #[error(transparent)]\n    CodePoint(CodePointError),\n    #[error(transparent)]\n    Number(#[from] NumberError),\n    #[error(transparent)]\n    Repetition(RepetitionError),\n    #[error(transparent)]\n    Unsupported(UnsupportedError),\n\n    #[error(\"Unknown error: {:?}\", .0)]\n    Nom(nom::error::ErrorKind),\n    #[error(\"Incomplete parse\")]\n    Incomplete,\n}\n\nimpl ParseErrorKind {\n    pub(crate) fn at(self, span: Span) -> ParseError {\n        ParseError { kind: self, span: Some(span) }\n    }\n\n    pub(crate) fn unknown_index(self) -> ParseError {\n        ParseError { kind: self, span: None }\n    }\n}\n\nimpl From<RepetitionError> for ParseErrorKind {\n    fn from(e: RepetitionError) -> Self {\n        ParseErrorKind::Repetition(e)\n    }\n}\n\n/// An error that relates to a character string\n#[derive(Debug, Clone, Copy, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum CharStringError {\n    /// Empty string in a code point range within a character class, e.g.\n    /// `[''-'z']`\n    #[error(\"Strings used in ranges can't be empty\")]\n    Empty,\n\n    /// String in a code point range within a character class that contains\n    /// multiple code points, e.g. `['abc'-'z']`\n    #[error(\"Strings used in ranges can only contain 1 code point\")]\n    TooManyCodePoints,\n}\n\n/// An error that relates to a character class\n#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum CharClassError {\n    /// Empty character class, i.e. `[]`\n    #[error(\"This character class is empty\")]\n    Empty,\n\n    /// Descending code point range, e.g. `['z'-'a']`\n    #[error(\n        \"Character range must be in increasing order, but it is U+{:04X?} - U+{:04X?}\",\n        *.0 as u32, *.1 as u32\n    )]\n    DescendingRange(char, char),\n\n    /// Invalid token within a character class\n    #[error(\"Expected string, range, code point or named character class\")]\n    Invalid,\n\n    /// Unknown shorthand character class, currently unused\n    #[deprecated = \"No longer used. Use the `UnknownNamedClass` variant instead\"]\n    // TODO: remove in next major version\n    #[error(\"This character class is unknown\")]\n    Unknown,\n\n    /// Character class contains incompatible shorthands, e.g. `[. codepoint]`\n    #[error(\"This combination of character classes is not allowed\")]\n    Unallowed,\n\n    /// Unknown shorthand character class or Unicode property\n    #[error(\"Unknown character class `{}`\", .0)]\n    UnknownNamedClass(String),\n\n    /// A character class that can't be negated, e.g. `[!ascii]`\n    #[error(\"This character class can't be negated\")]\n    Negative,\n\n    /// The `Grapheme` identifier within a character class\n    #[deprecated = \"Grapheme is no longer a keyword, so this is unused.\"]\n    // TODO: remove in next major version\n    #[error(\"A character class can't contain `Grapheme`\")]\n    Grapheme,\n\n    /// Unexpected keyword within a character class, e.g. `[let]`\n    #[error(\"Unexpected keyword `{}`\", .0)]\n    Keyword(String),\n}\n\n/// An error that relates to a Unicode code point\n#[derive(Debug, Clone, Copy, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum CodePointError {\n    /// Code point that is outside the allowed range, e.g. `U+200000`\n    #[error(\"This code point is outside the allowed range\")]\n    Invalid,\n\n    /// Invalid code point. Currently unused\n    #[deprecated = \"This variant is unused and will be removed.\"]\n    // TODO: remove in next major version\n    #[error(\"This code point range is invalid\")]\n    InvalidRange,\n}\n\n/// An error that relates to parsing a number\n#[derive(Debug, Copy, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum NumberError {\n    /// The parsed string is empty\n    #[error(\"cannot parse integer from empty string\")]\n    Empty,\n\n    /// The parsed string contains a character that isn't a digit\n    #[error(\"invalid digit found in string\")]\n    InvalidDigit,\n\n    /// The number is too large to fit in the target integer type\n    #[error(\"number too large\")]\n    TooLarge,\n\n    /// The number is too small to fit in the target integer type\n    #[error(\"number too small\")]\n    TooSmall,\n\n    /// The number is zero, but the target number type can't be zero\n    #[error(\"number would be zero for non-zero type\")]\n    Zero,\n}\n\nimpl From<ParseIntError> for NumberError {\n    fn from(e: ParseIntError) -> Self {\n        match e.kind() {\n            IntErrorKind::Empty => NumberError::Empty,\n            IntErrorKind::InvalidDigit => NumberError::InvalidDigit,\n            IntErrorKind::PosOverflow => NumberError::TooLarge,\n            IntErrorKind::NegOverflow => NumberError::TooSmall,\n            IntErrorKind::Zero => NumberError::Zero,\n            _ => unimplemented!(),\n        }\n    }\n}\n\n/// An error that indicates that an unsupported feature was used.\n///\n/// See [`crate::features::RulexFeatures`] for details.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\n#[allow(missing_docs)]\npub enum UnsupportedError {\n    #[error(\"Grapheme is not supported\")]\n    Grapheme,\n\n    #[error(\"Numbered capturing groups is not supported\")]\n    NumberedGroups,\n\n    #[error(\"Named capturing groups is not supported\")]\n    NamedGroups,\n\n    #[error(\"References aren't supported\")]\n    References,\n\n    #[error(\"Lazy mode isn't supported\")]\n    LazyMode,\n\n    #[error(\"Ranges aren't supported\")]\n    Ranges,\n\n    #[error(\"Variables aren't supported\")]\n    Variables,\n\n    #[error(\"Lookahead isn't supported\")]\n    Lookahead,\n\n    #[error(\"Lookbehind isn't supported\")]\n    Lookbehind,\n\n    #[error(\"Word boundaries aren't supported\")]\n    Boundaries,\n}\n\nstruct ListWithoutBrackets<'a, T>(&'a [T]);\n\nimpl<T: core::fmt::Display> core::fmt::Display for ListWithoutBrackets<'_, T> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        for (i, item) in self.0.iter().enumerate() {\n            if i > 0 {\n                f.write_str(\", \")?;\n            }\n            write!(f, \"{}\", item)?;\n        }\n        Ok(())\n    }\n}\n", "//! # rulex\n//!\n//! To learn about the _rulex language_, please read [the book](https://rulex-rs.github.io/rulex).\n//!\n//! The _rulex macro_ can be [found here](https://docs.rs/rulex-macro/latest/rulex_macro/).\n//!\n//! ## Usage\n//!\n//! This library can parse a rulex expression and generate a regex string:\n//!\n//! ```\n//! use rulex::Rulex;\n//! use rulex::options::{CompileOptions, RegexFlavor};\n//!\n//! let options = CompileOptions { flavor: RegexFlavor::Java };\n//! let regex: String = match Rulex::parse_and_compile(\"'test'\", Default::default(), options) {\n//!     Ok(regex) => regex,\n//!     Err(_) => {\n//!         eprintln!(\"The input is not a valid rulex\");\n//!         return;\n//!     }\n//! };\n//! ```\n//!\n//! You can get fancy error messages with [miette](https://docs.rs/miette/latest/miette/)\n//! by enabling the `diagnostics` feature:\n//!\n//! ```\n//! use rulex::Rulex;\n//! use rulex::options::{CompileOptions, RegexFlavor};\n//! use rulex::error::Diagnostic;\n//!\n//! pub fn compile(input: &str) -> miette::Result<String> {\n//!     let options = CompileOptions { flavor: RegexFlavor::Java };\n//!     let compiled: String = Rulex::parse_and_compile(input, Default::default(), options)\n//!         .map_err(|e| e.diagnostic(input))?;\n//!     Ok(compiled)\n//! }\n//! ```\n\n#![warn(missing_docs)]\n\nuse std::collections::HashMap;\n\nuse boundary::{Boundary, BoundaryKind};\nuse char_class::{CharClass, CharGroup};\nuse compile::CompileState;\nuse error::{CompileError, ParseError};\nuse grapheme::Grapheme;\nuse options::{CompileOptions, ParseOptions};\nuse repetition::RegexQuantifier;\nuse rule::Rule;\nuse span::Span;\n\npub mod error;\npub mod features;\npub mod options;\n\nmod alternation;\nmod boundary;\nmod char_class;\nmod compile;\nmod grapheme;\nmod group;\nmod literal;\nmod lookaround;\nmod parse;\nmod range;\nmod reference;\nmod regex;\nmod repetition;\nmod rule;\nmod span;\nmod stmt;\nmod var;\n\n/// A parsed rulex expression, which might contain more sub-expressions.\n#[derive(Clone)]\npub struct Rulex<'i>(Rule<'i>);\n\nimpl<'i> Rulex<'i> {\n    /// Parse a `Rulex` without generating code.\n    ///\n    /// The parsed `Rulex` can be displayed with `Debug` if the `dbg` feature is\n    /// enabled.\n    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {\n        let rule = parse::parse(input)?;\n        rule.validate(&options)?;\n        Ok(Rulex(rule))\n    }\n\n    /// Compile a `Rulex` that has been parsed, to a regex\n    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {\n        let mut used_names = HashMap::new();\n        let mut groups_count = 0;\n        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;\n\n        let empty_span = Span::new(0, 0);\n\n        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));\n        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));\n        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });\n        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));\n\n        let builtins = vec![\n            (\"Start\", &start),\n            (\"End\", &end),\n            (\"Grapheme\", &grapheme),\n            (\"G\", &grapheme),\n            (\"Codepoint\", &codepoint),\n            (\"C\", &codepoint),\n        ];\n\n        let mut state = CompileState {\n            next_idx: 1,\n            used_names,\n            groups_count,\n            default_quantifier: RegexQuantifier::Greedy,\n            variables: builtins,\n            current_vars: Default::default(),\n        };\n        let compiled = self.0.comp(options, &mut state)?;\n\n        let mut buf = String::new();\n        compiled.codegen(&mut buf, options.flavor);\n        Ok(buf)\n    }\n\n    /// Parse a string to a `Rulex` and compile it to a regex.\n    pub fn parse_and_compile(\n        input: &'i str,\n        parse_options: ParseOptions,\n        compile_options: CompileOptions,\n    ) -> Result<String, CompileError> {\n        let parsed = Self::parse(input, parse_options)?;\n        parsed.compile(compile_options)\n    }\n}\n\n#[cfg(feature = \"dbg\")]\nimpl core::fmt::Debug for Rulex<'_> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        self.0.fmt(f)\n    }\n}\n", "use std::iter::Enumerate;\n\nuse nom::{InputIter, InputLength, InputTake};\n\nuse crate::{\n    error::{ParseError, ParseErrorKind},\n    span::Span,\n};\n\nuse super::token::Token;\n\n#[derive(Clone)]\npub(crate) struct Input<'i, 'b> {\n    source: &'i str,\n    tokens: &'b [(Token, Span)],\n}\n\nimpl<'i, 'b> Input<'i, 'b> {\n    pub(super) fn from(source: &'i str, tokens: &'b [(Token, Span)]) -> Result<Self, ParseError> {\n        let error = tokens.iter().find_map(|&(t, span)| match t {\n            Token::Error => Some((span, None)),\n            Token::ErrorMsg(m) => Some((span, Some(m))),\n            _ => None,\n        });\n        if let Some((span, msg)) = error {\n            return match msg {\n                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),\n                None => Err(ParseErrorKind::UnknownToken.at(span)),\n            };\n        }\n\n        Ok(Input { source, tokens })\n    }\n\n    pub(super) fn is_empty(&self) -> bool {\n        self.tokens.is_empty()\n    }\n\n    pub(crate) fn span(&self) -> Span {\n        self.tokens\n            .first()\n            .map(|&(_, span)| span)\n            .unwrap_or_else(|| (self.source.len()..self.source.len()).into())\n    }\n\n    pub(super) fn peek(&self) -> Option<(Token, &'i str)> {\n        self.iter_elements().next()\n    }\n}\n\nimpl<'i, 'b> PartialEq for Input<'i, 'b> {\n    fn eq(&self, other: &Self) -> bool {\n        Iterator::eq(self.iter_elements(), other.iter_elements())\n    }\n}\n\n#[cfg(feature = \"dbg\")]\nimpl<'i, 'b> core::fmt::Debug for Input<'i, 'b> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        struct FmtHelper<'a>(Token, &'a str);\n\n        impl core::fmt::Debug for FmtHelper<'_> {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?} {:?}\", self.0, self.1)\n            }\n        }\n\n        let v = self\n            .tokens\n            .iter()\n            .map(|&(t, span)| FmtHelper(t, &self.source[span.range()]))\n            .collect::<Vec<_>>();\n\n        v.fmt(f)\n    }\n}\n\nimpl<'i, 'b> Iterator for Input<'i, 'b> {\n    type Item = (Token, &'i str);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.tokens.split_first() {\n            Some((&(token, span), rest)) => {\n                self.tokens = rest;\n                Some((token, &self.source[span.range()]))\n            }\n            None => None,\n        }\n    }\n}\n\nimpl<'i, 'b> InputIter for Input<'i, 'b> {\n    type Item = (Token, &'i str);\n\n    type Iter = Enumerate<Self>;\n\n    type IterElem = Self;\n\n    fn iter_indices(&self) -> Self::Iter {\n        self.iter_elements().enumerate()\n    }\n\n    fn iter_elements(&self) -> Self::IterElem {\n        Input { source: self.source, tokens: self.tokens }\n    }\n\n    fn position<P>(&self, predicate: P) -> Option<usize>\n    where\n        P: Fn(Self::Item) -> bool,\n    {\n        let mut iter = self.iter_elements();\n        Iterator::position(&mut iter, predicate)\n    }\n\n    fn slice_index(&self, count: usize) -> Result<usize, nom::Needed> {\n        if count <= self.tokens.len() {\n            Ok(count)\n        } else {\n            Err(nom::Needed::Size((count - self.tokens.len()).try_into().unwrap()))\n        }\n    }\n}\n\nimpl<'i, 'b> InputLength for Input<'i, 'b> {\n    fn input_len(&self) -> usize {\n        self.tokens.len()\n    }\n}\n\nimpl<'i, 'b> InputTake for Input<'i, 'b> {\n    fn take(&self, count: usize) -> Self {\n        let tokens = &self.tokens[..count];\n\n        Input { source: self.source, tokens }\n    }\n\n    fn take_split(&self, count: usize) -> (Self, Self) {\n        let (left, right) = self.tokens.split_at(count);\n\n        (Input { source: self.source, tokens: left }, Input { source: self.source, tokens: right })\n    }\n}\n", "use std::{\n    borrow::{Borrow, Cow},\n    collections::HashSet,\n    str::FromStr,\n};\n\nuse nom::{\n    branch::alt,\n    combinator::{cut, map, opt, value},\n    multi::{many0, many1, separated_list0},\n    sequence::{pair, preceded, separated_pair, tuple},\n    IResult, Parser,\n};\n\nuse crate::{\n    alternation::Alternation,\n    boundary::{Boundary, BoundaryKind},\n    char_class::{CharClass, CharGroup},\n    error::{\n        CharClassError, CharStringError, CodePointError, NumberError, ParseError, ParseErrorKind,\n    },\n    group::{Capture, Group},\n    literal::Literal,\n    lookaround::{Lookaround, LookaroundKind},\n    range::Range,\n    reference::{Reference, ReferenceTarget},\n    repetition::{Quantifier, Repetition, RepetitionError, RepetitionKind},\n    rule::Rule,\n    span::Span,\n    stmt::{BooleanSetting, Let, Stmt, StmtExpr},\n    var::Variable,\n};\n\nuse super::{Input, Token};\n\npub(super) type PResult<'i, 'b, T> = IResult<Input<'i, 'b>, T, ParseError>;\n\npub(crate) fn parse(source: &str) -> Result<Rule<'_>, ParseError> {\n    let tokens = super::tokenize::tokenize(source);\n    let input = Input::from(source, &tokens)?;\n\n    let (rest, rules) = parse_modified(input)?;\n    if rest.is_empty() {\n        Ok(rules)\n    } else {\n        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))\n    }\n}\n\npub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    enum ModifierKind {\n        Enable,\n        Disable,\n    }\n\n    try_map2(\n        pair(\n            many0(alt((\n                map(\n                    tuple((\n                        alt((\n                            map(\"enable\", |(_, span)| (ModifierKind::Enable, span)),\n                            map(\"disable\", |(_, span)| (ModifierKind::Disable, span)),\n                        )),\n                        value(BooleanSetting::Lazy, \"lazy\"),\n                        Token::Semicolon,\n                    )),\n                    |((kind, span_start), value, (_, span_end))| {\n                        let stmt = match kind {\n                            ModifierKind::Enable => Stmt::Enable(value),\n                            ModifierKind::Disable => Stmt::Disable(value),\n                        };\n                        (stmt, span_start.join(span_end))\n                    },\n                ),\n                map(\n                    tuple((\n                        \"let\",\n                        cut(Token::Identifier),\n                        cut(Token::Equals),\n                        cut(parse_or),\n                        cut(Token::Semicolon),\n                    )),\n                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {\n                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))\n                    },\n                ),\n            ))),\n            parse_or,\n        ),\n        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {\n            if stmts.len() > 1 {\n                let mut set = HashSet::new();\n                for (stmt, _) in &stmts {\n                    if let Stmt::Let(l) = stmt {\n                        if set.contains(l.name()) {\n                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));\n                        }\n                        set.insert(l.name());\n                    }\n                }\n            }\n\n            let span_end = rule.span();\n            for (stmt, span) in stmts.into_iter().rev() {\n                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));\n            }\n            Ok(rule)\n        },\n        nom::Err::Failure,\n    )(input)\n}\n\npub(super) fn parse_or<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(separated_list0(Token::Pipe, parse_sequence), |mut rules| {\n        if rules.len() == 1 {\n            rules.pop().unwrap()\n        } else {\n            Alternation::new_rulex(rules)\n        }\n    })(input)\n}\n\npub(super) fn parse_sequence<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(many1(parse_fixes), |mut rules| {\n        if rules.len() == 1 {\n            rules.pop().unwrap()\n        } else {\n            let start = rules.first().map(|f| f.span()).unwrap_or_default();\n            let end = rules.last().map(|f| f.span()).unwrap_or_default();\n\n            Rule::Group(Group::new(rules, None, start.join(end)))\n        }\n    })(input)\n}\n\npub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        try_map(\n            pair(Token::Not, opt(parse_fixes)),\n            |(_, rule)| {\n                if let Some(mut rule) = rule {\n                    rule.negate()?;\n                    Ok(rule)\n                } else {\n                    Err(ParseErrorKind::Expected(\"expression\"))\n                }\n            },\n            nom::Err::Failure,\n        ),\n        map(pair(parse_lookaround, parse_modified), |((kind, span), rule)| {\n            let span = span.join(rule.span());\n            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))\n        }),\n        try_map2(\n            pair(parse_atom, many0(parse_repetition)),\n            |(mut rule, repetitions)| {\n                let mut prev_syntax = RepSyntax::ExplicitQuantifier;\n                for (kind, quantifier, span, syntax) in repetitions {\n                    if matches!(\n                        (&prev_syntax, &syntax),\n                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)\n                    ) {\n                        return Err(ParseErrorKind::Repetition(\n                            RepetitionError::QuestionMarkAfterRepetition,\n                        )\n                        .at(span));\n                    }\n                    prev_syntax = syntax;\n\n                    let span = rule.span().join(span);\n                    rule =\n                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));\n                }\n                Ok(rule)\n            },\n            nom::Err::Failure,\n        ),\n    ))(input)\n}\n\npub(super) fn parse_lookaround<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (LookaroundKind, Span)> {\n    alt((\n        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),\n        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),\n    ))(input)\n}\n\npub(super) enum RepSyntax {\n    ExplicitQuantifier,\n    QuestionMark,\n    Other,\n}\n\npub(super) fn parse_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {\n    map(\n        pair(\n            alt((\n                map(Token::QuestionMark, |(_, span)| {\n                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)\n                }),\n                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),\n                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),\n                parse_braced_repetition,\n            )),\n            map(\n                opt(alt((\n                    map(\"greedy\", |(_, span)| (Quantifier::Greedy, span)),\n                    map(\"lazy\", |(_, span)| (Quantifier::Lazy, span)),\n                ))),\n                |a| match a {\n                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),\n                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),\n                },\n            ),\n        ),\n        |((kind, span1, rs1), (quantifier, span2, rs2))| {\n            (\n                kind,\n                quantifier,\n                span1.join(span2),\n                match (rs1, rs2) {\n                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,\n                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,\n                    _ => RepSyntax::Other,\n                },\n            )\n        },\n    )(input)\n}\n\npub(super) fn parse_braced_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {\n    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {\n        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)\n    }\n\n    map(\n        tuple((\n            Token::OpenBrace,\n            cut(alt((\n                try_map(\n                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),\n                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),\n                    nom::Err::Failure,\n                ),\n                map(parse_u32, RepetitionKind::fixed),\n            ))),\n            cut(Token::CloseBrace),\n        )),\n        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),\n    )(input)\n}\n\npub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        parse_group,\n        parse_string,\n        parse_char_class,\n        parse_boundary,\n        parse_reference,\n        map(parse_code_point, |(c, span)| {\n            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))\n        }),\n        parse_range,\n        parse_variable,\n        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),\n        err(|| ParseErrorKind::Expected(\"expression\")),\n    ))(input)\n}\n\npub(super) fn parse_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    fn parse_capture<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (Capture<'i>, Span)> {\n        map(pair(Token::Colon, opt(Token::Identifier)), |((_, span1), name)| {\n            (Capture::new(name.map(|(s, _)| s)), span1)\n        })(input)\n    }\n\n    map(\n        pair(opt(parse_capture), tuple((Token::OpenParen, parse_modified, cut(Token::CloseParen)))),\n        |(capture, (_, rule, (_, close_paren)))| match (capture, rule) {\n            (None, rule) => rule,\n            (Some((capture, c_span)), Rule::Group(mut g)) if !g.is_capturing() => {\n                g.set_capture(capture);\n                g.span = c_span.join(g.span);\n                Rule::Group(g)\n            }\n            (Some((capture, c_span)), rule) => {\n                Rule::Group(Group::new(vec![rule], Some(capture), c_span.join(close_paren)))\n            }\n        },\n    )(input)\n}\n\npub(super) fn parse_string<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    try_map(\n        Token::String,\n        |(s, span)| Ok(Rule::Literal(Literal::new(parse_quoted_text(s)?, span))),\n        nom::Err::Failure,\n    )(input)\n}\n\npub(super) fn parse_char_class<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    #[derive(Clone, Copy)]\n    enum StringOrChar<'i> {\n        String(&'i str),\n        Char(char),\n    }\n\n    impl StringOrChar<'_> {\n        fn to_char(self) -> Result<char, ParseErrorKind> {\n            Err(ParseErrorKind::CharString(match self {\n                StringOrChar::Char(c) => return Ok(c),\n                StringOrChar::String(s) => {\n                    let s = parse_quoted_text(s)?;\n                    let mut iter = s.chars();\n                    match iter.next() {\n                        Some(c) if matches!(iter.next(), None) => return Ok(c),\n                        Some(_) => CharStringError::TooManyCodePoints,\n                        _ => CharStringError::Empty,\n                    }\n                }\n            }))\n        }\n    }\n\n    fn parse_string_or_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, StringOrChar<'i>> {\n        alt((\n            map(Token::String, |(s, _)| StringOrChar::String(s)),\n            map(parse_code_point, |(c, _)| StringOrChar::Char(c)),\n            map(parse_special_char, StringOrChar::Char),\n            err(|| ParseErrorKind::ExpectedCodePointOrChar),\n        ))(input)\n    }\n\n    fn parse_chars_or_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {\n        // this is not clean code, but using the combinators results in worse error\n        // spans\n        let span1 = input.span();\n        let (input, first) = parse_string_or_char(input)?;\n\n        if let Ok((input, _)) = Token::Dash.parse(input.clone()) {\n            let span2 = input.span();\n            let (input, last) = cut(parse_string_or_char)(input)?;\n\n            let first = first.to_char().map_err(|e| nom::Err::Failure(e.at(span1)))?;\n            let last = last.to_char().map_err(|e| nom::Err::Failure(e.at(span2)))?;\n\n            let group = CharGroup::try_from_range(first, last).ok_or_else(|| {\n                nom::Err::Failure(\n                    ParseErrorKind::CharClass(CharClassError::DescendingRange(first, last))\n                        .at(span1.join(span2)),\n                )\n            })?;\n            Ok((input, group))\n        } else {\n            let group = match first {\n                StringOrChar::String(s) => CharGroup::from_chars(\n                    parse_quoted_text(s).map_err(|k| nom::Err::Failure(k.at(span1)))?.borrow(),\n                ),\n                StringOrChar::Char(c) => CharGroup::from_char(c),\n            };\n            Ok((input, group))\n        }\n    }\n\n    fn parse_char_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {\n        let span1 = input.span();\n\n        let (input, ranges) = many1(alt((\n            parse_chars_or_range,\n            value(CharGroup::Dot, Token::Dot),\n            try_map(\n                pair(opt(Token::Not), Token::Identifier),\n                |(not, (s, _))| {\n                    // FIXME: When this fails on a negative item, the span of the exclamation mark\n                    // is used instead of the identifier's span\n                    CharGroup::try_from_group_name(s, not.is_some())\n                        .map_err(ParseErrorKind::CharClass)\n                },\n                nom::Err::Failure,\n            ),\n            err(|| ParseErrorKind::CharClass(CharClassError::Invalid)),\n        )))(input)?;\n\n        let mut iter = ranges.into_iter();\n        let mut class = iter.next().unwrap();\n\n        for range in iter {\n            class.add(range).map_err(|e| {\n                nom::Err::Failure(ParseErrorKind::CharClass(e).at(span1.join(input.span().start())))\n            })?;\n        }\n        Ok((input, class))\n    }\n\n    map(\n        tuple((Token::OpenBracket, cut(parse_char_group), cut(Token::CloseBracket))),\n        |((_, start), inner, (_, end))| Rule::CharClass(CharClass::new(inner, start.join(end))),\n    )(input)\n}\n\npub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {\n    alt((\n        try_map(\n            Token::CodePoint,\n            |(s, span)| {\n                let hex = &s[2..];\n                if hex.len() > 6 {\n                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))\n                } else {\n                    u32::from_str_radix(hex, 16)\n                        .ok()\n                        .and_then(|n| char::try_from(n).ok())\n                        .map(|c| (c, span))\n                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))\n                }\n            },\n            nom::Err::Failure,\n        ),\n        try_map(\n            Token::Identifier,\n            |(str, span)| {\n                if let Some(rest) = str.strip_prefix('U') {\n                    if let Ok(n) = u32::from_str_radix(rest, 16) {\n                        if let Ok(c) = char::try_from(n) {\n                            return Ok((c, span));\n                        } else {\n                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));\n                        }\n                    }\n                }\n                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))\n            },\n            nom::Err::Error,\n        ),\n    ))(input)\n}\n\npub(super) fn parse_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    fn parse_base<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (u8, Span)> {\n        preceded(\n            \"base\",\n            try_map(\n                cut(Token::Number),\n                |(s, span)| {\n                    let n = s.parse().map_err(NumberError::from)?;\n                    if n > 36 {\n                        Err(ParseErrorKind::Number(NumberError::TooLarge))\n                    } else if n < 2 {\n                        Err(ParseErrorKind::Number(NumberError::TooSmall))\n                    } else {\n                        Ok((n, span))\n                    }\n                },\n                nom::Err::Failure,\n            ),\n        )(input)\n    }\n\n    fn parse_number(src: &str, radix: u8) -> Result<Vec<u8>, NumberError> {\n        let mut digits = Vec::with_capacity(src.len());\n        for c in src.bytes() {\n            let n = match c {\n                b'0'..=b'9' => c - b'0',\n                b'a'..=b'z' => c - b'a' + 10,\n                b'A'..=b'Z' => c - b'A' + 10,\n                _ => return Err(NumberError::InvalidDigit),\n            };\n            if n >= radix {\n                return Err(NumberError::InvalidDigit);\n            }\n            digits.push(n);\n        }\n        Ok(digits)\n    }\n\n    map(\n        pair(\n            \"range\",\n            try_map(\n                pair(\n                    cut(separated_pair(Token::String, Token::Dash, Token::String)),\n                    opt(parse_base),\n                ),\n                |(((start, span1), (end, span2)), base)| {\n                    let (radix, span) = match base {\n                        Some((base, span3)) => (base, span1.join(span3)),\n                        None => (10, span1.join(span2)),\n                    };\n                    let start = parse_number(strip_first_last(start), radix)?;\n                    let end = parse_number(strip_first_last(end), radix)?;\n\n                    if start.len() > end.len() || (start.len() == end.len() && start > end) {\n                        return Err(ParseErrorKind::RangeIsNotIncreasing);\n                    }\n\n                    Ok(Range::new(start, end, radix, span))\n                },\n                nom::Err::Failure,\n            ),\n        ),\n        |((_, span), mut range)| {\n            range.span = range.span.join(span);\n            Rule::Range(range)\n        },\n    )(input)\n}\n\npub(super) fn parse_variable<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(Token::Identifier, |(name, span)| Rule::Variable(Variable::new(name, span)))(input)\n}\n\npub(super) fn parse_special_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, char> {\n    try_map(\n        Token::Identifier,\n        |(s, _)| {\n            Ok(match s {\n                \"n\" => '\\n',\n                \"r\" => '\\r',\n                \"t\" => '\\t',\n                \"a\" => '\\u{07}',\n                \"e\" => '\\u{1B}',\n                \"f\" => '\\u{0C}',\n                _ => return Err(ParseErrorKind::Incomplete),\n            })\n        },\n        nom::Err::Error,\n    )(input)\n}\n\npub(super) fn parse_boundary<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(\n        alt((\n            map(Token::BStart, |(_, span)| Boundary::new(BoundaryKind::Start, span)),\n            map(Token::BEnd, |(_, span)| Boundary::new(BoundaryKind::End, span)),\n            map(Token::BWord, |(_, span)| Boundary::new(BoundaryKind::Word, span)),\n            map(pair(Token::Not, Token::BWord), |((_, span1), (_, span2))| {\n                Boundary::new(BoundaryKind::NotWord, span1.join(span2))\n            }),\n        )),\n        Rule::Boundary,\n    )(input)\n}\n\npub(super) fn parse_reference<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    preceded(\n        Token::Backref,\n        alt((\n            try_map(\n                Token::Number,\n                |(s, span)| {\n                    let target = ReferenceTarget::Number(from_str(s)?);\n                    Ok(Rule::Reference(Reference::new(target, span)))\n                },\n                nom::Err::Failure,\n            ),\n            map(Token::Identifier, |(s, span)| {\n                let target = ReferenceTarget::Named(s);\n                Rule::Reference(Reference::new(target, span))\n            }),\n            try_map(\n                pair(alt((Token::Plus, Token::Dash)), Token::Number),\n                |((sign, span1), (s, span2))| {\n                    let num = if sign == \"-\" { from_str(&format!(\"-{s}\")) } else { from_str(s) }?;\n                    let target = ReferenceTarget::Relative(num);\n                    Ok(Rule::Reference(Reference::new(target, span1.join(span2))))\n                },\n                nom::Err::Failure,\n            ),\n            err(|| ParseErrorKind::Expected(\"number or group name\")),\n        )),\n    )(input)\n}\n\nfn from_str<T: FromStr>(s: &str) -> Result<T, ParseErrorKind> {\n    str::parse(s).map_err(|_| ParseErrorKind::Number(NumberError::TooLarge))\n}\n\nfn strip_first_last(s: &str) -> &str {\n    &s[1..s.len() - 1]\n}\n\nfn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {\n    Ok(match input.as_bytes()[0] {\n        b'\"' => {\n            let mut s = strip_first_last(input);\n            let mut buf = String::new();\n\n            loop {\n                let mut chars = s.chars();\n                let char_len;\n                match chars.next() {\n                    Some('\\\\') => {\n                        char_len = 1;\n                        match chars.next() {\n                            Some('\\\\') => {\n                                buf.push('\\\\');\n                                s = &s[1..];\n                            }\n                            Some('\"') => {\n                                buf.push('\"');\n                                s = &s[1..];\n                            }\n                            _ => {\n                                return Err(ParseErrorKind::InvalidEscapeInStringAt(\n                                    input.len() - s.len(),\n                                ));\n                            }\n                        }\n                    }\n                    Some(c) => {\n                        char_len = c.len_utf8();\n                        buf.push(c)\n                    }\n                    None => break,\n                }\n                s = &s[char_len..];\n            }\n            Cow::Owned(buf)\n        }\n        _ => Cow::Borrowed(strip_first_last(input)),\n    })\n}\n\nfn try_map<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseErrorKind>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let span = input.span();\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;\n        Ok((rest, o2))\n    }\n}\n\nfn try_map2<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseError>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(err_kind)?;\n        Ok((rest, o2))\n    }\n}\n\nfn err<'i, 'b, T>(\n    mut error_fn: impl FnMut() -> ParseErrorKind,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {\n    move |input| Err(nom::Err::Error(error_fn().at(input.span())))\n}\n"], "fixing_code": ["use std::num::{IntErrorKind, ParseIntError};\n\nuse crate::{\n    parse::{Input, ParseErrorMsg, Token},\n    repetition::RepetitionError,\n    span::Span,\n};\n\nuse super::Diagnostic;\n\n/// An error than can occur only during parsing\n#[derive(Debug, Clone)]\npub struct ParseError {\n    pub(super) kind: ParseErrorKind,\n    pub(super) span: Option<Span>,\n}\n\nimpl ParseError {\n    /// Create a [Diagnostic] from this error.\n    pub fn diagnostic(self, source_code: &str) -> Diagnostic {\n        Diagnostic::from_parse_error(self, source_code)\n    }\n}\n\nimpl core::fmt::Display for ParseError {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        if let Some(span) = self.span {\n            write!(f, \"{}\\n  at {}\", self.kind, span)\n        } else {\n            self.kind.fmt(f)\n        }\n    }\n}\n\nimpl From<nom::Err<ParseError>> for ParseError {\n    fn from(e: nom::Err<ParseError>) -> Self {\n        match e {\n            nom::Err::Incomplete(_) => ParseErrorKind::Incomplete.unknown_index(),\n            nom::Err::Error(e) | nom::Err::Failure(e) => e,\n        }\n    }\n}\n\nimpl<'i, 'b> nom::error::ParseError<Input<'i, 'b>> for ParseError {\n    fn from_error_kind(i: Input<'i, 'b>, kind: nom::error::ErrorKind) -> Self {\n        ParseErrorKind::Nom(kind).at(i.span())\n    }\n\n    fn append(_: Input<'i, 'b>, _: nom::error::ErrorKind, other: Self) -> Self {\n        other\n    }\n}\n\n/// An error kind (without a span) than can occur only during parsing\n#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub(crate) enum ParseErrorKind {\n    #[error(\"Unknown token\")]\n    UnknownToken,\n    #[error(transparent)]\n    LexErrorWithMessage(ParseErrorMsg),\n    #[error(\"Unexpected dot. Use `[.]` instead\")]\n    Dot,\n\n    #[error(\"Expected {}\", .0)]\n    Expected(&'static str),\n    #[error(\"There are leftover tokens that couldn't be parsed\")]\n    LeftoverTokens,\n    #[error(\"Expected {}\", .0)]\n    ExpectedToken(Token),\n    #[error(\"Expected code point or character\")]\n    ExpectedCodePointOrChar,\n    #[error(\"The first number in a range must be smaller than the second\")]\n    RangeIsNotIncreasing,\n    #[error(\"This expression can't be negated\")]\n    UnallowedNot,\n    #[error(\"An expression can't be negated twice\")]\n    UnallowedDoubleNot,\n    #[error(\"Range is too big, it isn't allowed to contain more than {} digits\", .0)]\n    RangeIsTooBig(u8),\n    #[error(\"A variable with the same name already exists in this scope\")]\n    LetBindingExists,\n    #[error(\"Unsupported escape sequence in string\")]\n    InvalidEscapeInStringAt(usize),\n    #[error(transparent)]\n    CharString(CharStringError),\n    #[error(transparent)]\n    CharClass(CharClassError),\n    #[error(transparent)]\n    CodePoint(CodePointError),\n    #[error(transparent)]\n    Number(#[from] NumberError),\n    #[error(transparent)]\n    Repetition(RepetitionError),\n    #[error(transparent)]\n    Unsupported(UnsupportedError),\n\n    #[error(\"Recursion limit reached. Try a less nested expression\")]\n    RecursionLimit,\n\n    #[error(\"Unknown error: {:?}\", .0)]\n    Nom(nom::error::ErrorKind),\n    #[error(\"Incomplete parse\")]\n    Incomplete,\n}\n\nimpl ParseErrorKind {\n    pub(crate) fn at(self, span: Span) -> ParseError {\n        ParseError { kind: self, span: Some(span) }\n    }\n\n    pub(crate) fn unknown_index(self) -> ParseError {\n        ParseError { kind: self, span: None }\n    }\n}\n\nimpl From<RepetitionError> for ParseErrorKind {\n    fn from(e: RepetitionError) -> Self {\n        ParseErrorKind::Repetition(e)\n    }\n}\n\n/// An error that relates to a character string\n#[derive(Debug, Clone, Copy, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum CharStringError {\n    /// Empty string in a code point range within a character class, e.g.\n    /// `[''-'z']`\n    #[error(\"Strings used in ranges can't be empty\")]\n    Empty,\n\n    /// String in a code point range within a character class that contains\n    /// multiple code points, e.g. `['abc'-'z']`\n    #[error(\"Strings used in ranges can only contain 1 code point\")]\n    TooManyCodePoints,\n}\n\n/// An error that relates to a character class\n#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum CharClassError {\n    /// Empty character class, i.e. `[]`\n    #[error(\"This character class is empty\")]\n    Empty,\n\n    /// Descending code point range, e.g. `['z'-'a']`\n    #[error(\n        \"Character range must be in increasing order, but it is U+{:04X?} - U+{:04X?}\",\n        *.0 as u32, *.1 as u32\n    )]\n    DescendingRange(char, char),\n\n    /// Invalid token within a character class\n    #[error(\"Expected string, range, code point or named character class\")]\n    Invalid,\n\n    /// Unknown shorthand character class, currently unused\n    #[deprecated = \"No longer used. Use the `UnknownNamedClass` variant instead\"]\n    // TODO: remove in next major version\n    #[error(\"This character class is unknown\")]\n    Unknown,\n\n    /// Character class contains incompatible shorthands, e.g. `[. codepoint]`\n    #[error(\"This combination of character classes is not allowed\")]\n    Unallowed,\n\n    /// Unknown shorthand character class or Unicode property\n    #[error(\"Unknown character class `{}`\", .0)]\n    UnknownNamedClass(String),\n\n    /// A character class that can't be negated, e.g. `[!ascii]`\n    #[error(\"This character class can't be negated\")]\n    Negative,\n\n    /// The `Grapheme` identifier within a character class\n    #[deprecated = \"Grapheme is no longer a keyword, so this is unused.\"]\n    // TODO: remove in next major version\n    #[error(\"A character class can't contain `Grapheme`\")]\n    Grapheme,\n\n    /// Unexpected keyword within a character class, e.g. `[let]`\n    #[error(\"Unexpected keyword `{}`\", .0)]\n    Keyword(String),\n}\n\n/// An error that relates to a Unicode code point\n#[derive(Debug, Clone, Copy, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum CodePointError {\n    /// Code point that is outside the allowed range, e.g. `U+200000`\n    #[error(\"This code point is outside the allowed range\")]\n    Invalid,\n\n    /// Invalid code point. Currently unused\n    #[deprecated = \"This variant is unused and will be removed.\"]\n    // TODO: remove in next major version\n    #[error(\"This code point range is invalid\")]\n    InvalidRange,\n}\n\n/// An error that relates to parsing a number\n#[derive(Debug, Copy, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\npub enum NumberError {\n    /// The parsed string is empty\n    #[error(\"cannot parse integer from empty string\")]\n    Empty,\n\n    /// The parsed string contains a character that isn't a digit\n    #[error(\"invalid digit found in string\")]\n    InvalidDigit,\n\n    /// The number is too large to fit in the target integer type\n    #[error(\"number too large\")]\n    TooLarge,\n\n    /// The number is too small to fit in the target integer type\n    #[error(\"number too small\")]\n    TooSmall,\n\n    /// The number is zero, but the target number type can't be zero\n    #[error(\"number would be zero for non-zero type\")]\n    Zero,\n}\n\nimpl From<ParseIntError> for NumberError {\n    fn from(e: ParseIntError) -> Self {\n        match e.kind() {\n            IntErrorKind::Empty => NumberError::Empty,\n            IntErrorKind::InvalidDigit => NumberError::InvalidDigit,\n            IntErrorKind::PosOverflow => NumberError::TooLarge,\n            IntErrorKind::NegOverflow => NumberError::TooSmall,\n            IntErrorKind::Zero => NumberError::Zero,\n            _ => unimplemented!(),\n        }\n    }\n}\n\n/// An error that indicates that an unsupported feature was used.\n///\n/// See [`crate::features::RulexFeatures`] for details.\n#[derive(Debug, Copy, Clone, PartialEq, Eq, thiserror::Error)]\n#[non_exhaustive]\n#[allow(missing_docs)]\npub enum UnsupportedError {\n    #[error(\"Grapheme is not supported\")]\n    Grapheme,\n\n    #[error(\"Numbered capturing groups is not supported\")]\n    NumberedGroups,\n\n    #[error(\"Named capturing groups is not supported\")]\n    NamedGroups,\n\n    #[error(\"References aren't supported\")]\n    References,\n\n    #[error(\"Lazy mode isn't supported\")]\n    LazyMode,\n\n    #[error(\"Ranges aren't supported\")]\n    Ranges,\n\n    #[error(\"Variables aren't supported\")]\n    Variables,\n\n    #[error(\"Lookahead isn't supported\")]\n    Lookahead,\n\n    #[error(\"Lookbehind isn't supported\")]\n    Lookbehind,\n\n    #[error(\"Word boundaries aren't supported\")]\n    Boundaries,\n}\n\nstruct ListWithoutBrackets<'a, T>(&'a [T]);\n\nimpl<T: core::fmt::Display> core::fmt::Display for ListWithoutBrackets<'_, T> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        for (i, item) in self.0.iter().enumerate() {\n            if i > 0 {\n                f.write_str(\", \")?;\n            }\n            write!(f, \"{}\", item)?;\n        }\n        Ok(())\n    }\n}\n", "//! # rulex\n//!\n//! To learn about the _rulex language_, please read [the book](https://rulex-rs.github.io/rulex).\n//!\n//! The _rulex macro_ can be [found here](https://docs.rs/rulex-macro/latest/rulex_macro/).\n//!\n//! ## Usage\n//!\n//! This library can parse a rulex expression and generate a regex string:\n//!\n//! ```\n//! use rulex::Rulex;\n//! use rulex::options::{CompileOptions, RegexFlavor};\n//!\n//! let options = CompileOptions { flavor: RegexFlavor::Java };\n//! let regex: String = match Rulex::parse_and_compile(\"'test'\", Default::default(), options) {\n//!     Ok(regex) => regex,\n//!     Err(_) => {\n//!         eprintln!(\"The input is not a valid rulex\");\n//!         return;\n//!     }\n//! };\n//! ```\n//!\n//! You can get fancy error messages with [miette](https://docs.rs/miette/latest/miette/)\n//! by enabling the `diagnostics` feature:\n//!\n//! ```\n//! use rulex::Rulex;\n//! use rulex::options::{CompileOptions, RegexFlavor};\n//! use rulex::error::Diagnostic;\n//!\n//! pub fn compile(input: &str) -> miette::Result<String> {\n//!     let options = CompileOptions { flavor: RegexFlavor::Java };\n//!     let compiled: String = Rulex::parse_and_compile(input, Default::default(), options)\n//!         .map_err(|e| e.diagnostic(input))?;\n//!     Ok(compiled)\n//! }\n//! ```\n\n#![warn(missing_docs)]\n\nuse std::collections::HashMap;\n\nuse boundary::{Boundary, BoundaryKind};\nuse char_class::{CharClass, CharGroup};\nuse compile::CompileState;\nuse error::{CompileError, ParseError};\nuse grapheme::Grapheme;\nuse options::{CompileOptions, ParseOptions};\nuse repetition::RegexQuantifier;\nuse rule::Rule;\nuse span::Span;\n\npub mod error;\npub mod features;\npub mod options;\n\nmod alternation;\nmod boundary;\nmod char_class;\nmod compile;\nmod grapheme;\nmod group;\nmod literal;\nmod lookaround;\nmod parse;\nmod range;\nmod reference;\nmod regex;\nmod repetition;\nmod rule;\nmod span;\nmod stmt;\nmod var;\n\n/// A parsed rulex expression, which might contain more sub-expressions.\n#[derive(Clone)]\npub struct Rulex<'i>(Rule<'i>);\n\nimpl<'i> Rulex<'i> {\n    /// Parse a `Rulex` without generating code.\n    ///\n    /// The parsed `Rulex` can be displayed with `Debug` if the `dbg` feature is\n    /// enabled.\n    pub fn parse(input: &'i str, options: ParseOptions) -> Result<Self, ParseError> {\n        let rule = parse::parse(input, 256)?;\n        rule.validate(&options)?;\n        Ok(Rulex(rule))\n    }\n\n    /// Compile a `Rulex` that has been parsed, to a regex\n    pub fn compile(&self, options: CompileOptions) -> Result<String, CompileError> {\n        let mut used_names = HashMap::new();\n        let mut groups_count = 0;\n        self.0.get_capturing_groups(&mut groups_count, &mut used_names, false)?;\n\n        let empty_span = Span::new(0, 0);\n\n        let start = Rule::Boundary(Boundary::new(BoundaryKind::Start, empty_span));\n        let end = Rule::Boundary(Boundary::new(BoundaryKind::End, empty_span));\n        let grapheme = Rule::Grapheme(Grapheme { span: empty_span });\n        let codepoint = Rule::CharClass(CharClass::new(CharGroup::CodePoint, empty_span));\n\n        let builtins = vec![\n            (\"Start\", &start),\n            (\"End\", &end),\n            (\"Grapheme\", &grapheme),\n            (\"G\", &grapheme),\n            (\"Codepoint\", &codepoint),\n            (\"C\", &codepoint),\n        ];\n\n        let mut state = CompileState {\n            next_idx: 1,\n            used_names,\n            groups_count,\n            default_quantifier: RegexQuantifier::Greedy,\n            variables: builtins,\n            current_vars: Default::default(),\n        };\n        let compiled = self.0.comp(options, &mut state)?;\n\n        let mut buf = String::new();\n        compiled.codegen(&mut buf, options.flavor);\n        Ok(buf)\n    }\n\n    /// Parse a string to a `Rulex` and compile it to a regex.\n    pub fn parse_and_compile(\n        input: &'i str,\n        parse_options: ParseOptions,\n        compile_options: CompileOptions,\n    ) -> Result<String, CompileError> {\n        let parsed = Self::parse(input, parse_options)?;\n        parsed.compile(compile_options)\n    }\n}\n\n#[cfg(feature = \"dbg\")]\nimpl core::fmt::Debug for Rulex<'_> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        self.0.fmt(f)\n    }\n}\n", "use std::iter::Enumerate;\n\nuse nom::{InputIter, InputLength, InputTake};\n\nuse crate::{\n    error::{ParseError, ParseErrorKind},\n    span::Span,\n};\n\nuse super::token::Token;\n\n#[derive(Clone)]\npub(crate) struct Input<'i, 'b> {\n    source: &'i str,\n    tokens: &'b [(Token, Span)],\n    recursion: u16,\n}\n\nimpl<'i, 'b> Input<'i, 'b> {\n    pub(super) fn from(\n        source: &'i str,\n        tokens: &'b [(Token, Span)],\n        recursion: u16,\n    ) -> Result<Self, ParseError> {\n        let error = tokens.iter().find_map(|&(t, span)| match t {\n            Token::Error => Some((span, None)),\n            Token::ErrorMsg(m) => Some((span, Some(m))),\n            _ => None,\n        });\n        if let Some((span, msg)) = error {\n            return match msg {\n                Some(msg) => Err(ParseErrorKind::LexErrorWithMessage(msg).at(span)),\n                None => Err(ParseErrorKind::UnknownToken.at(span)),\n            };\n        }\n\n        Ok(Input { source, tokens, recursion })\n    }\n\n    pub(super) fn recursion_start(&mut self) -> Result<(), ParseError> {\n        self.recursion = self\n            .recursion\n            .checked_sub(1)\n            .ok_or_else(|| ParseErrorKind::RecursionLimit.at(self.span()))?;\n        Ok(())\n    }\n\n    pub(super) fn recursion_end(&mut self) {\n        self.recursion += 1;\n    }\n\n    pub(super) fn is_empty(&self) -> bool {\n        self.tokens.is_empty()\n    }\n\n    pub(crate) fn span(&self) -> Span {\n        self.tokens\n            .first()\n            .map(|&(_, span)| span)\n            .unwrap_or_else(|| (self.source.len()..self.source.len()).into())\n    }\n\n    pub(super) fn peek(&self) -> Option<(Token, &'i str)> {\n        self.iter_elements().next()\n    }\n}\n\nimpl<'i, 'b> PartialEq for Input<'i, 'b> {\n    fn eq(&self, other: &Self) -> bool {\n        Iterator::eq(self.iter_elements(), other.iter_elements())\n    }\n}\n\n#[cfg(feature = \"dbg\")]\nimpl<'i, 'b> core::fmt::Debug for Input<'i, 'b> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n        struct FmtHelper<'a>(Token, &'a str);\n\n        impl core::fmt::Debug for FmtHelper<'_> {\n            fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n                write!(f, \"{:?} {:?}\", self.0, self.1)\n            }\n        }\n\n        let v = self\n            .tokens\n            .iter()\n            .map(|&(t, span)| FmtHelper(t, &self.source[span.range()]))\n            .collect::<Vec<_>>();\n\n        v.fmt(f)\n    }\n}\n\nimpl<'i, 'b> Iterator for Input<'i, 'b> {\n    type Item = (Token, &'i str);\n\n    fn next(&mut self) -> Option<Self::Item> {\n        match self.tokens.split_first() {\n            Some((&(token, span), rest)) => {\n                self.tokens = rest;\n                Some((token, &self.source[span.range()]))\n            }\n            None => None,\n        }\n    }\n}\n\nimpl<'i, 'b> InputIter for Input<'i, 'b> {\n    type Item = (Token, &'i str);\n\n    type Iter = Enumerate<Self>;\n\n    type IterElem = Self;\n\n    fn iter_indices(&self) -> Self::Iter {\n        self.iter_elements().enumerate()\n    }\n\n    fn iter_elements(&self) -> Self::IterElem {\n        Input { ..*self }\n    }\n\n    fn position<P>(&self, predicate: P) -> Option<usize>\n    where\n        P: Fn(Self::Item) -> bool,\n    {\n        let mut iter = self.iter_elements();\n        Iterator::position(&mut iter, predicate)\n    }\n\n    fn slice_index(&self, count: usize) -> Result<usize, nom::Needed> {\n        if count <= self.tokens.len() {\n            Ok(count)\n        } else {\n            Err(nom::Needed::Size((count - self.tokens.len()).try_into().unwrap()))\n        }\n    }\n}\n\nimpl<'i, 'b> InputLength for Input<'i, 'b> {\n    fn input_len(&self) -> usize {\n        self.tokens.len()\n    }\n}\n\nimpl<'i, 'b> InputTake for Input<'i, 'b> {\n    fn take(&self, count: usize) -> Self {\n        let tokens = &self.tokens[..count];\n\n        Input { tokens, ..*self }\n    }\n\n    fn take_split(&self, count: usize) -> (Self, Self) {\n        let (left, right) = self.tokens.split_at(count);\n\n        (Input { tokens: left, ..*self }, Input { tokens: right, ..*self })\n    }\n}\n", "use std::{\n    borrow::{Borrow, Cow},\n    collections::HashSet,\n    str::FromStr,\n};\n\nuse nom::{\n    branch::alt,\n    combinator::{cut, map, opt, value},\n    multi::{many0, many1, separated_list0},\n    sequence::{pair, preceded, separated_pair, tuple},\n    IResult, Parser,\n};\n\nuse crate::{\n    alternation::Alternation,\n    boundary::{Boundary, BoundaryKind},\n    char_class::{CharClass, CharGroup},\n    error::{\n        CharClassError, CharStringError, CodePointError, NumberError, ParseError, ParseErrorKind,\n    },\n    group::{Capture, Group},\n    literal::Literal,\n    lookaround::{Lookaround, LookaroundKind},\n    range::Range,\n    reference::{Reference, ReferenceTarget},\n    repetition::{Quantifier, Repetition, RepetitionError, RepetitionKind},\n    rule::Rule,\n    span::Span,\n    stmt::{BooleanSetting, Let, Stmt, StmtExpr},\n    var::Variable,\n};\n\nuse super::{Input, Token};\n\npub(super) type PResult<'i, 'b, T> = IResult<Input<'i, 'b>, T, ParseError>;\n\npub(crate) fn parse(source: &str, recursion: u16) -> Result<Rule<'_>, ParseError> {\n    let tokens = super::tokenize::tokenize(source);\n    let input = Input::from(source, &tokens, recursion)?;\n\n    let (rest, rules) = parse_modified(input)?;\n    if rest.is_empty() {\n        Ok(rules)\n    } else {\n        Err(ParseErrorKind::LeftoverTokens.at(rest.span()))\n    }\n}\n\nfn recurse<'i, 'b, O>(\n    mut parser: impl Parser<Input<'i, 'b>, O, ParseError>,\n) -> impl FnMut(Input<'i, 'b>) -> PResult<'i, 'b, O> {\n    move |mut input| {\n        input.recursion_start().map_err(nom::Err::Failure)?;\n\n        match parser.parse(input) {\n            Ok((mut input, output)) => {\n                input.recursion_end();\n                Ok((input, output))\n            }\n            Err(e) => Err(e),\n        }\n    }\n}\n\npub(super) fn parse_modified<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    enum ModifierKind {\n        Enable,\n        Disable,\n    }\n\n    try_map2(\n        pair(\n            many0(alt((\n                map(\n                    tuple((\n                        alt((\n                            map(\"enable\", |(_, span)| (ModifierKind::Enable, span)),\n                            map(\"disable\", |(_, span)| (ModifierKind::Disable, span)),\n                        )),\n                        value(BooleanSetting::Lazy, \"lazy\"),\n                        Token::Semicolon,\n                    )),\n                    |((kind, span_start), value, (_, span_end))| {\n                        let stmt = match kind {\n                            ModifierKind::Enable => Stmt::Enable(value),\n                            ModifierKind::Disable => Stmt::Disable(value),\n                        };\n                        (stmt, span_start.join(span_end))\n                    },\n                ),\n                map(\n                    tuple((\n                        \"let\",\n                        cut(Token::Identifier),\n                        cut(Token::Equals),\n                        cut(recurse(parse_or)),\n                        cut(Token::Semicolon),\n                    )),\n                    |((_, span_start), (name, name_span), _, rule, (_, span_end))| {\n                        (Stmt::Let(Let::new(name, rule, name_span)), span_start.join(span_end))\n                    },\n                ),\n            ))),\n            recurse(parse_or),\n        ),\n        |(stmts, mut rule): (Vec<(Stmt, Span)>, _)| {\n            if stmts.len() > 1 {\n                let mut set = HashSet::new();\n                for (stmt, _) in &stmts {\n                    if let Stmt::Let(l) = stmt {\n                        if set.contains(l.name()) {\n                            return Err(ParseErrorKind::LetBindingExists.at(l.name_span));\n                        }\n                        set.insert(l.name());\n                    }\n                }\n            }\n\n            let span_end = rule.span();\n            for (stmt, span) in stmts.into_iter().rev() {\n                rule = Rule::StmtExpr(Box::new(StmtExpr::new(stmt, rule, span.join(span_end))));\n            }\n            Ok(rule)\n        },\n        nom::Err::Failure,\n    )(input)\n}\n\npub(super) fn parse_or<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(separated_list0(Token::Pipe, parse_sequence), |mut rules| {\n        if rules.len() == 1 {\n            rules.pop().unwrap()\n        } else {\n            Alternation::new_rulex(rules)\n        }\n    })(input)\n}\n\npub(super) fn parse_sequence<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(many1(parse_fixes), |mut rules| {\n        if rules.len() == 1 {\n            rules.pop().unwrap()\n        } else {\n            let start = rules.first().map(|f| f.span()).unwrap_or_default();\n            let end = rules.last().map(|f| f.span()).unwrap_or_default();\n\n            Rule::Group(Group::new(rules, None, start.join(end)))\n        }\n    })(input)\n}\n\npub(super) fn parse_fixes<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        try_map(\n            pair(Token::Not, opt(recurse(parse_fixes))),\n            |(_, rule)| {\n                if let Some(mut rule) = rule {\n                    rule.negate()?;\n                    Ok(rule)\n                } else {\n                    Err(ParseErrorKind::Expected(\"expression\"))\n                }\n            },\n            nom::Err::Failure,\n        ),\n        map(pair(parse_lookaround, recurse(parse_modified)), |((kind, span), rule)| {\n            let span = span.join(rule.span());\n            Rule::Lookaround(Box::new(Lookaround::new(rule, kind, span)))\n        }),\n        try_map2(\n            pair(parse_atom, many0(parse_repetition)),\n            |(mut rule, repetitions)| {\n                let mut prev_syntax = RepSyntax::ExplicitQuantifier;\n                for (kind, quantifier, span, syntax) in repetitions {\n                    if matches!(\n                        (&prev_syntax, &syntax),\n                        (RepSyntax::Other | RepSyntax::QuestionMark, RepSyntax::QuestionMark)\n                    ) {\n                        return Err(ParseErrorKind::Repetition(\n                            RepetitionError::QuestionMarkAfterRepetition,\n                        )\n                        .at(span));\n                    }\n                    prev_syntax = syntax;\n\n                    let span = rule.span().join(span);\n                    rule =\n                        Rule::Repetition(Box::new(Repetition::new(rule, kind, quantifier, span)));\n                }\n                Ok(rule)\n            },\n            nom::Err::Failure,\n        ),\n    ))(input)\n}\n\npub(super) fn parse_lookaround<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (LookaroundKind, Span)> {\n    alt((\n        map(Token::LookAhead, |(_, span)| (LookaroundKind::Ahead, span)),\n        map(Token::LookBehind, |(_, span)| (LookaroundKind::Behind, span)),\n    ))(input)\n}\n\npub(super) enum RepSyntax {\n    ExplicitQuantifier,\n    QuestionMark,\n    Other,\n}\n\npub(super) fn parse_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Quantifier, Span, RepSyntax)> {\n    map(\n        pair(\n            alt((\n                map(Token::QuestionMark, |(_, span)| {\n                    (RepetitionKind::zero_one(), span, RepSyntax::QuestionMark)\n                }),\n                map(Token::Star, |(_, span)| (RepetitionKind::zero_inf(), span, RepSyntax::Other)),\n                map(Token::Plus, |(_, span)| (RepetitionKind::one_inf(), span, RepSyntax::Other)),\n                parse_braced_repetition,\n            )),\n            map(\n                opt(alt((\n                    map(\"greedy\", |(_, span)| (Quantifier::Greedy, span)),\n                    map(\"lazy\", |(_, span)| (Quantifier::Lazy, span)),\n                ))),\n                |a| match a {\n                    Some((q, span)) => (q, span, RepSyntax::ExplicitQuantifier),\n                    None => (Quantifier::Default, Span::default(), RepSyntax::Other),\n                },\n            ),\n        ),\n        |((kind, span1, rs1), (quantifier, span2, rs2))| {\n            (\n                kind,\n                quantifier,\n                span1.join(span2),\n                match (rs1, rs2) {\n                    (_, RepSyntax::ExplicitQuantifier) => RepSyntax::ExplicitQuantifier,\n                    (RepSyntax::QuestionMark, _) => RepSyntax::QuestionMark,\n                    _ => RepSyntax::Other,\n                },\n            )\n        },\n    )(input)\n}\n\npub(super) fn parse_braced_repetition<'i, 'b>(\n    input: Input<'i, 'b>,\n) -> PResult<'i, 'b, (RepetitionKind, Span, RepSyntax)> {\n    fn parse_u32<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, u32> {\n        try_map(Token::Number, |(s, _)| from_str(s), nom::Err::Failure)(input)\n    }\n\n    map(\n        tuple((\n            Token::OpenBrace,\n            cut(alt((\n                try_map(\n                    separated_pair(opt(parse_u32), Token::Comma, opt(parse_u32)),\n                    |(lower, upper)| Ok(RepetitionKind::try_from((lower.unwrap_or(0), upper))?),\n                    nom::Err::Failure,\n                ),\n                map(parse_u32, RepetitionKind::fixed),\n            ))),\n            cut(Token::CloseBrace),\n        )),\n        |((_, start), rep, (_, end))| (rep, start.join(end), RepSyntax::Other),\n    )(input)\n}\n\npub(super) fn parse_atom<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    alt((\n        parse_group,\n        parse_string,\n        parse_char_class,\n        parse_boundary,\n        parse_reference,\n        map(parse_code_point, |(c, span)| {\n            Rule::CharClass(CharClass::new(CharGroup::from_char(c), span))\n        }),\n        parse_range,\n        parse_variable,\n        try_map(Token::Dot, |_| Err(ParseErrorKind::Dot), nom::Err::Failure),\n        err(|| ParseErrorKind::Expected(\"expression\")),\n    ))(input)\n}\n\npub(super) fn parse_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    fn parse_capture<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (Capture<'i>, Span)> {\n        map(pair(Token::Colon, opt(Token::Identifier)), |((_, span1), name)| {\n            (Capture::new(name.map(|(s, _)| s)), span1)\n        })(input)\n    }\n\n    map(\n        pair(\n            opt(parse_capture),\n            tuple((Token::OpenParen, recurse(parse_modified), cut(Token::CloseParen))),\n        ),\n        |(capture, (_, rule, (_, close_paren)))| match (capture, rule) {\n            (None, rule) => rule,\n            (Some((capture, c_span)), Rule::Group(mut g)) if !g.is_capturing() => {\n                g.set_capture(capture);\n                g.span = c_span.join(g.span);\n                Rule::Group(g)\n            }\n            (Some((capture, c_span)), rule) => {\n                Rule::Group(Group::new(vec![rule], Some(capture), c_span.join(close_paren)))\n            }\n        },\n    )(input)\n}\n\npub(super) fn parse_string<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    try_map(\n        Token::String,\n        |(s, span)| Ok(Rule::Literal(Literal::new(parse_quoted_text(s)?, span))),\n        nom::Err::Failure,\n    )(input)\n}\n\npub(super) fn parse_char_class<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    #[derive(Clone, Copy)]\n    enum StringOrChar<'i> {\n        String(&'i str),\n        Char(char),\n    }\n\n    impl StringOrChar<'_> {\n        fn to_char(self) -> Result<char, ParseErrorKind> {\n            Err(ParseErrorKind::CharString(match self {\n                StringOrChar::Char(c) => return Ok(c),\n                StringOrChar::String(s) => {\n                    let s = parse_quoted_text(s)?;\n                    let mut iter = s.chars();\n                    match iter.next() {\n                        Some(c) if matches!(iter.next(), None) => return Ok(c),\n                        Some(_) => CharStringError::TooManyCodePoints,\n                        _ => CharStringError::Empty,\n                    }\n                }\n            }))\n        }\n    }\n\n    fn parse_string_or_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, StringOrChar<'i>> {\n        alt((\n            map(Token::String, |(s, _)| StringOrChar::String(s)),\n            map(parse_code_point, |(c, _)| StringOrChar::Char(c)),\n            map(parse_special_char, StringOrChar::Char),\n            err(|| ParseErrorKind::ExpectedCodePointOrChar),\n        ))(input)\n    }\n\n    fn parse_chars_or_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {\n        // this is not clean code, but using the combinators results in worse error\n        // spans\n        let span1 = input.span();\n        let (input, first) = parse_string_or_char(input)?;\n\n        if let Ok((input, _)) = Token::Dash.parse(input.clone()) {\n            let span2 = input.span();\n            let (input, last) = cut(parse_string_or_char)(input)?;\n\n            let first = first.to_char().map_err(|e| nom::Err::Failure(e.at(span1)))?;\n            let last = last.to_char().map_err(|e| nom::Err::Failure(e.at(span2)))?;\n\n            let group = CharGroup::try_from_range(first, last).ok_or_else(|| {\n                nom::Err::Failure(\n                    ParseErrorKind::CharClass(CharClassError::DescendingRange(first, last))\n                        .at(span1.join(span2)),\n                )\n            })?;\n            Ok((input, group))\n        } else {\n            let group = match first {\n                StringOrChar::String(s) => CharGroup::from_chars(\n                    parse_quoted_text(s).map_err(|k| nom::Err::Failure(k.at(span1)))?.borrow(),\n                ),\n                StringOrChar::Char(c) => CharGroup::from_char(c),\n            };\n            Ok((input, group))\n        }\n    }\n\n    fn parse_char_group<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, CharGroup> {\n        let span1 = input.span();\n\n        let (input, ranges) = many1(alt((\n            parse_chars_or_range,\n            value(CharGroup::Dot, Token::Dot),\n            try_map(\n                pair(opt(Token::Not), Token::Identifier),\n                |(not, (s, _))| {\n                    // FIXME: When this fails on a negative item, the span of the exclamation mark\n                    // is used instead of the identifier's span\n                    CharGroup::try_from_group_name(s, not.is_some())\n                        .map_err(ParseErrorKind::CharClass)\n                },\n                nom::Err::Failure,\n            ),\n            err(|| ParseErrorKind::CharClass(CharClassError::Invalid)),\n        )))(input)?;\n\n        let mut iter = ranges.into_iter();\n        let mut class = iter.next().unwrap();\n\n        for range in iter {\n            class.add(range).map_err(|e| {\n                nom::Err::Failure(ParseErrorKind::CharClass(e).at(span1.join(input.span().start())))\n            })?;\n        }\n        Ok((input, class))\n    }\n\n    map(\n        tuple((Token::OpenBracket, cut(parse_char_group), cut(Token::CloseBracket))),\n        |((_, start), inner, (_, end))| Rule::CharClass(CharClass::new(inner, start.join(end))),\n    )(input)\n}\n\npub(super) fn parse_code_point<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (char, Span)> {\n    alt((\n        try_map(\n            Token::CodePoint,\n            |(s, span)| {\n                let hex = &s[2..];\n                if hex.len() > 6 {\n                    Err(ParseErrorKind::CodePoint(CodePointError::Invalid))\n                } else {\n                    u32::from_str_radix(hex, 16)\n                        .ok()\n                        .and_then(|n| char::try_from(n).ok())\n                        .map(|c| (c, span))\n                        .ok_or(ParseErrorKind::CodePoint(CodePointError::Invalid))\n                }\n            },\n            nom::Err::Failure,\n        ),\n        try_map(\n            Token::Identifier,\n            |(str, span)| {\n                if let Some(rest) = str.strip_prefix('U') {\n                    if let Ok(n) = u32::from_str_radix(rest, 16) {\n                        if let Ok(c) = char::try_from(n) {\n                            return Ok((c, span));\n                        } else {\n                            return Err(ParseErrorKind::CodePoint(CodePointError::Invalid));\n                        }\n                    }\n                }\n                Err(ParseErrorKind::ExpectedToken(Token::CodePoint))\n            },\n            nom::Err::Error,\n        ),\n    ))(input)\n}\n\npub(super) fn parse_range<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    fn parse_base<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, (u8, Span)> {\n        preceded(\n            \"base\",\n            try_map(\n                cut(Token::Number),\n                |(s, span)| {\n                    let n = s.parse().map_err(NumberError::from)?;\n                    if n > 36 {\n                        Err(ParseErrorKind::Number(NumberError::TooLarge))\n                    } else if n < 2 {\n                        Err(ParseErrorKind::Number(NumberError::TooSmall))\n                    } else {\n                        Ok((n, span))\n                    }\n                },\n                nom::Err::Failure,\n            ),\n        )(input)\n    }\n\n    fn parse_number(src: &str, radix: u8) -> Result<Vec<u8>, NumberError> {\n        let mut digits = Vec::with_capacity(src.len());\n        for c in src.bytes() {\n            let n = match c {\n                b'0'..=b'9' => c - b'0',\n                b'a'..=b'z' => c - b'a' + 10,\n                b'A'..=b'Z' => c - b'A' + 10,\n                _ => return Err(NumberError::InvalidDigit),\n            };\n            if n >= radix {\n                return Err(NumberError::InvalidDigit);\n            }\n            digits.push(n);\n        }\n        Ok(digits)\n    }\n\n    map(\n        pair(\n            \"range\",\n            try_map(\n                pair(\n                    cut(separated_pair(Token::String, Token::Dash, Token::String)),\n                    opt(parse_base),\n                ),\n                |(((start, span1), (end, span2)), base)| {\n                    let (radix, span) = match base {\n                        Some((base, span3)) => (base, span1.join(span3)),\n                        None => (10, span1.join(span2)),\n                    };\n                    let start = parse_number(strip_first_last(start), radix)?;\n                    let end = parse_number(strip_first_last(end), radix)?;\n\n                    if start.len() > end.len() || (start.len() == end.len() && start > end) {\n                        return Err(ParseErrorKind::RangeIsNotIncreasing);\n                    }\n\n                    Ok(Range::new(start, end, radix, span))\n                },\n                nom::Err::Failure,\n            ),\n        ),\n        |((_, span), mut range)| {\n            range.span = range.span.join(span);\n            Rule::Range(range)\n        },\n    )(input)\n}\n\npub(super) fn parse_variable<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(Token::Identifier, |(name, span)| Rule::Variable(Variable::new(name, span)))(input)\n}\n\npub(super) fn parse_special_char<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, char> {\n    try_map(\n        Token::Identifier,\n        |(s, _)| {\n            Ok(match s {\n                \"n\" => '\\n',\n                \"r\" => '\\r',\n                \"t\" => '\\t',\n                \"a\" => '\\u{07}',\n                \"e\" => '\\u{1B}',\n                \"f\" => '\\u{0C}',\n                _ => return Err(ParseErrorKind::Incomplete),\n            })\n        },\n        nom::Err::Error,\n    )(input)\n}\n\npub(super) fn parse_boundary<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    map(\n        alt((\n            map(Token::BStart, |(_, span)| Boundary::new(BoundaryKind::Start, span)),\n            map(Token::BEnd, |(_, span)| Boundary::new(BoundaryKind::End, span)),\n            map(Token::BWord, |(_, span)| Boundary::new(BoundaryKind::Word, span)),\n            map(pair(Token::Not, Token::BWord), |((_, span1), (_, span2))| {\n                Boundary::new(BoundaryKind::NotWord, span1.join(span2))\n            }),\n        )),\n        Rule::Boundary,\n    )(input)\n}\n\npub(super) fn parse_reference<'i, 'b>(input: Input<'i, 'b>) -> PResult<'i, 'b, Rule<'i>> {\n    preceded(\n        Token::Backref,\n        alt((\n            try_map(\n                Token::Number,\n                |(s, span)| {\n                    let target = ReferenceTarget::Number(from_str(s)?);\n                    Ok(Rule::Reference(Reference::new(target, span)))\n                },\n                nom::Err::Failure,\n            ),\n            map(Token::Identifier, |(s, span)| {\n                let target = ReferenceTarget::Named(s);\n                Rule::Reference(Reference::new(target, span))\n            }),\n            try_map(\n                pair(alt((Token::Plus, Token::Dash)), Token::Number),\n                |((sign, span1), (s, span2))| {\n                    let num = if sign == \"-\" { from_str(&format!(\"-{s}\")) } else { from_str(s) }?;\n                    let target = ReferenceTarget::Relative(num);\n                    Ok(Rule::Reference(Reference::new(target, span1.join(span2))))\n                },\n                nom::Err::Failure,\n            ),\n            err(|| ParseErrorKind::Expected(\"number or group name\")),\n        )),\n    )(input)\n}\n\nfn from_str<T: FromStr>(s: &str) -> Result<T, ParseErrorKind> {\n    str::parse(s).map_err(|_| ParseErrorKind::Number(NumberError::TooLarge))\n}\n\nfn strip_first_last(s: &str) -> &str {\n    &s[1..s.len() - 1]\n}\n\nfn parse_quoted_text(input: &str) -> Result<Cow<'_, str>, ParseErrorKind> {\n    Ok(match input.as_bytes()[0] {\n        b'\"' => {\n            let mut s = strip_first_last(input);\n            let mut buf = String::new();\n\n            loop {\n                let mut chars = s.chars();\n                let char_len;\n                match chars.next() {\n                    Some('\\\\') => {\n                        char_len = 1;\n                        match chars.next() {\n                            Some('\\\\') => {\n                                buf.push('\\\\');\n                                s = &s[1..];\n                            }\n                            Some('\"') => {\n                                buf.push('\"');\n                                s = &s[1..];\n                            }\n                            _ => {\n                                return Err(ParseErrorKind::InvalidEscapeInStringAt(\n                                    input.len() - s.len(),\n                                ));\n                            }\n                        }\n                    }\n                    Some(c) => {\n                        char_len = c.len_utf8();\n                        buf.push(c)\n                    }\n                    None => break,\n                }\n                s = &s[char_len..];\n            }\n            Cow::Owned(buf)\n        }\n        _ => Cow::Borrowed(strip_first_last(input)),\n    })\n}\n\nfn try_map<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseErrorKind>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let span = input.span();\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(|e| err_kind(e.at(span)))?;\n        Ok((rest, o2))\n    }\n}\n\nfn try_map2<'i, 'b, O1, O2, P, M, EM>(\n    mut parser: P,\n    mut map: M,\n    err_kind: EM,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, O2, ParseError>\nwhere\n    P: Parser<Input<'i, 'b>, O1, ParseError>,\n    M: FnMut(O1) -> Result<O2, ParseError>,\n    EM: Copy + FnOnce(ParseError) -> nom::Err<ParseError>,\n{\n    move |input| {\n        let (rest, o1) = parser.parse(input)?;\n        let o2 = map(o1).map_err(err_kind)?;\n        Ok((rest, o2))\n    }\n}\n\nfn err<'i, 'b, T>(\n    mut error_fn: impl FnMut() -> ParseErrorKind,\n) -> impl FnMut(Input<'i, 'b>) -> IResult<Input<'i, 'b>, T, ParseError> {\n    move |input| Err(nom::Err::Error(error_fn().at(input.span())))\n}\n"], "filenames": ["rulex-lib/src/error/parse_error.rs", "rulex-lib/src/lib.rs", "rulex-lib/src/parse/input.rs", "rulex-lib/src/parse/parsers.rs"], "buggy_code_start_loc": [97, 87, 15, 38], "buggy_code_end_loc": [97, 88, 141, 286], "fixing_code_start_loc": [98, 87, 16, 38], "fixing_code_end_loc": [101, 88, 158, 305], "type": "CWE-674", "message": "rulex is a new, portable, regular expression language. When parsing untrusted rulex expressions, the stack may overflow, possibly enabling a Denial of Service attack. This happens when parsing an expression with several hundred levels of nesting, causing the process to abort immediately. This is a security concern for you, if your service parses untrusted rulex expressions (expressions provided by an untrusted user), and your service becomes unavailable when the process running rulex aborts due to a stack overflow. The crash is fixed in version **0.4.3**. Affected users are advised to update to this version. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31099", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-27T23:15:08.043", "lastModified": "2022-07-11T14:26:28.353", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rulex is a new, portable, regular expression language. When parsing untrusted rulex expressions, the stack may overflow, possibly enabling a Denial of Service attack. This happens when parsing an expression with several hundred levels of nesting, causing the process to abort immediately. This is a security concern for you, if your service parses untrusted rulex expressions (expressions provided by an untrusted user), and your service becomes unavailable when the process running rulex aborts due to a stack overflow. The crash is fixed in version **0.4.3**. Affected users are advised to update to this version. There are no known workarounds for this issue."}, {"lang": "es", "value": "rulex es un nuevo lenguaje de expresiones regulares port\u00e1til. Cuando son analizadas expresiones de rulex que no son confiables, la pila puede desbordarse, permitiendo posiblemente un ataque de Denegaci\u00f3n de Servicio. Esto sucede cuando es analizada una expresi\u00f3n con varios cientos de niveles de anidamiento, causando que el proceso sea abortado inmediatamente. Esto es un problema de seguridad para usted, si su servicio analiza expresiones rulex que no son confiables (expresiones proporcionadas por un usuario que no es confiable), y su servicio no est\u00e1 disponible cuando el proceso que ejecuta rulex aborta debido a un desbordamiento de la pila. El bloqueo ha sido corregido en versi\u00f3n **0.4.3**. Es recomendado a usuarios afectados actualizar a esta versi\u00f3n. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pomsky-lang:pomsky:*:*:*:*:*:rust:*:*", "versionEndExcluding": "0.4.3", "matchCriteriaId": "BD1AEB74-00F4-4E35-839A-98858DF404B2"}]}]}], "references": [{"url": "https://github.com/rulex-rs/rulex/commit/60aa2dc03a22d69c8800fec81f99c96958a11363", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rulex-rs/rulex/security/advisories/GHSA-v78m-2q7v-fjqp", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rulex-rs/rulex/commit/60aa2dc03a22d69c8800fec81f99c96958a11363"}}