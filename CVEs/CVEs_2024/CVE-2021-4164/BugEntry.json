{"buggy_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport base64\nimport json\nimport time\nimport operator\nfrom datetime import datetime, timedelta\n\nfrom babel import Locale as LC\nfrom babel.dates import format_datetime\nfrom flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response\nfrom flask_login import login_required, current_user, logout_user, confirm_login\nfrom flask_babel import gettext as _\nfrom flask import session as flask_session\nfrom sqlalchemy import and_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError\nfrom sqlalchemy.sql.expression import func, or_, text\n\nfrom . import constants, logger, helper, services\nfrom . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status\nfrom .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\\n    valid_email, check_username\nfrom .gdriveutils import is_gdrive_ready, gdrive_support\nfrom .render_template import render_title_template, get_sidebar_config\nfrom . import debug_info, _BABEL_TRANSLATIONS\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\nlog = logger.create()\n\nfeature_support = {\n        'ldap': bool(services.ldap),\n        'goodreads': bool(services.goodreads_support),\n        'kobo':  bool(services.kobo),\n        'updater': constants.UPDATER_AVAILABLE,\n        'gmail': bool(services.gmail)\n    }\n\ntry:\n    import rarfile  # pylint: disable=unused-import\n    feature_support['rar'] = True\nexcept (ImportError, SyntaxError):\n    feature_support['rar'] = False\n\ntry:\n    from .oauth_bb import oauth_check, oauthblueprints\n    feature_support['oauth'] = True\nexcept ImportError as err:\n    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)\n    feature_support['oauth'] = False\n    oauthblueprints = []\n    oauth_check = {}\n\n\nfeature_support['gdrive'] = gdrive_support\nadmi = Blueprint('admin', __name__)\n\n\ndef admin_required(f):\n    \"\"\"\n    Checks if current_user.role == 1\n    \"\"\"\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\n@admi.before_app_request\ndef before_request():\n    # make remember me function work\n    if current_user.is_authenticated:\n        confirm_login()\n    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:\n        logout_user()\n    g.constants = constants\n    g.user = current_user\n    g.allow_registration = config.config_public_reg\n    g.allow_anonymous = config.config_anonbrowse\n    g.allow_upload = config.config_uploading\n    g.current_theme = config.config_theme\n    g.config_authors_max = config.config_authors_max\n    g.shelves_access = ub.session.query(ub.Shelf).filter(\n        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()\n    if '/static/' not in request.path and not config.db_configured and \\\n        request.endpoint not in ('admin.ajax_db_config',\n                                 'admin.simulatedbchange',\n                                 'admin.db_configuration',\n                                 'web.login',\n                                 'web.logout',\n                                 'admin.load_dialogtexts',\n                                 'admin.ajax_pathchooser'):\n        return redirect(url_for('admin.db_configuration'))\n\n\n@admi.route(\"/admin\")\n@login_required\ndef admin_forbidden():\n    abort(403)\n\n\n@admi.route(\"/shutdown\")\n@login_required\n@admin_required\ndef shutdown():\n    task = int(request.args.get(\"parameter\").strip())\n    showtext = {}\n    if task in (0, 1):  # valid commandos received\n        # close all database connections\n        calibre_db.dispose()\n        ub.dispose()\n\n        if task == 0:\n            showtext['text'] = _(u'Server restarted, please reload page')\n        else:\n            showtext['text'] = _(u'Performing shutdown of server, please close window')\n        # stop gevent/tornado server\n        web_server.stop(task == 0)\n        return json.dumps(showtext)\n\n    if task == 2:\n        log.warning(\"reconnecting to calibre database\")\n        calibre_db.reconnect_db(config, ub.app_DB_path)\n        showtext['text'] = _(u'Reconnect successful')\n        return json.dumps(showtext)\n\n    showtext['text'] = _(u'Unknown command')\n    return json.dumps(showtext), 400\n\n\n@admi.route(\"/admin/view\")\n@login_required\n@admin_required\ndef admin():\n    version = updater_thread.get_current_version_info()\n    if version is False:\n        commit = _(u'Unknown')\n    else:\n        if 'datetime' in version:\n            commit = version['datetime']\n\n            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)\n            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")\n            if len(commit) > 19:    # check if string has timezone\n                if commit[19] == '+':\n                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n                elif commit[19] == '-':\n                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n            commit = format_datetime(form_date - tz, format='short', locale=get_locale())\n        else:\n            commit = version['version']\n\n    allUser = ub.session.query(ub.User).all()\n    email_settings = config.get_mail_settings()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,\n                                 feature_support=feature_support, kobo_support=kobo_support,\n                                 title=_(u\"Admin page\"), page=\"admin\")\n\n@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef db_configuration():\n    if request.method == \"POST\":\n        return _db_configuration_update_helper()\n    return _db_configuration_result()\n\n\n@admi.route(\"/admin/config\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef configuration():\n    return render_title_template(\"config_edit.html\",\n                                 config=config,\n                                 provider=oauthblueprints,\n                                 feature_support=feature_support,\n                                 title=_(u\"Basic Configuration\"), page=\"config\")\n\n\n@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_config():\n    return _configuration_update_helper()\n\n\n@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_db_config():\n    return _db_configuration_update_helper()\n\n\n@admi.route(\"/admin/alive\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef calibreweb_alive():\n    return \"\", 200\n\n@admi.route(\"/admin/viewconfig\")\n@login_required\n@admin_required\ndef view_configuration():\n    read_column = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()\n    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()\n    languages = calibre_db.speaking_language()\n    translations = [LC('en')] + babel.list_translations()\n    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,\n                                 restrictColumns=restrict_columns,\n                                 languages=languages,\n                                 translations=translations,\n                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")\n\n@admi.route(\"/admin/usertable\")\n@login_required\n@admin_required\ndef edit_user_table():\n    visibility = current_user.view_settings.get('useredit', {})\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [LC('en')]\n    allUser = ub.session.query(ub.User)\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    if config.config_restricted_column:\n        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()\n    else:\n        custom_values = []\n    if not config.config_anonbrowse:\n        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"user_table.html\",\n                                 users=allUser.all(),\n                                 tags=tags,\n                                 custom_values=custom_values,\n                                 translations=translations,\n                                 languages=languages,\n                                 visiblility=visibility,\n                                 all_roles=constants.ALL_ROLES,\n                                 kobo_support=kobo_support,\n                                 sidebar_settings=constants.sidebar_settings,\n                                 title=_(u\"Edit Users\"),\n                                 page=\"usertable\")\n\n\n@admi.route(\"/ajax/listusers\")\n@login_required\n@admin_required\ndef list_users():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or 10)\n    search = request.args.get(\"search\")\n    sort = request.args.get(\"sort\", \"id\")\n    order = request.args.get(\"order\", \"\").lower()\n    state = None\n    if sort == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n\n    if sort != \"state\" and order:\n        order = text(sort + \" \" + order)\n    elif not state:\n        order = ub.User.id.asc()\n\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n\n    total_count = filtered_count = all_user.count()\n\n    if search:\n        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),\n                                    func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),\n                                    func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))\n    if state:\n        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())\n    else:\n        users = all_user.order_by(order).offset(off).limit(limit).all()\n    if search:\n        filtered_count = len(users)\n\n    for user in users:\n        if user.default_language == \"all\":\n            user.default = _(\"All\")\n        else:\n            user.default = LC.parse(user.default_language).get_language_name(get_locale())\n\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@admi.route(\"/ajax/deleteuser\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user():\n    user_ids = request.form.to_dict(flat=False)\n    users = None\n    if \"userid[]\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()\n    elif \"userid\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()\n    count = 0\n    errors = list()\n    success = list()\n    if not users:\n        log.error(\"User not found\")\n        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')\n    for user in users:\n        try:\n            message = _delete_user(user)\n            count += 1\n        except Exception as ex:\n            log.error(ex)\n            errors.append({'type': \"danger\", 'message': str(ex)})\n\n    if count == 1:\n        log.info(\"User {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': message}]\n    elif count > 1:\n        log.info(\"Users {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]\n    success.extend(errors)\n    return Response(json.dumps(success), mimetype='application/json')\n\n@admi.route(\"/ajax/getlocale\")\n@login_required\n@admin_required\ndef table_get_locale():\n    locale = babel.list_translations() + [LC('en')]\n    ret = list()\n    current_locale = get_locale()\n    for loc in locale:\n        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/getdefaultlanguage\")\n@login_required\n@admin_required\ndef table_get_default_lang():\n    languages = calibre_db.speaking_language()\n    ret = list()\n    ret.append({'value': 'all', 'text': _('Show All')})\n    for lang in languages:\n        ret.append({'value': lang.lang_code, 'text': lang.name})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_list_user(param):\n    vals = request.form.to_dict(flat=False)\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    # only one user is posted\n    if \"pk\" in vals:\n        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]\n    else:\n        if \"pk[]\" in vals:\n            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()\n        else:\n            return _(\"Malformed request\"), 400\n    if 'field_index' in vals:\n        vals['field_index'] = vals['field_index'][0]\n    if 'value' in vals:\n        vals['value'] = vals['value'][0]\n    elif not ('value[]' in vals):\n        return _(\"Malformed request\"), 400\n    for user in users:\n        try:\n            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:\n                if 'value[]' in vals:\n                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))\n                else:\n                    setattr(user, param, vals['value'].strip())\n            else:\n                vals['value'] = vals['value'].strip()\n                if param == 'name':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest Name can't be changed\"))\n                    user.name = check_username(vals['value'])\n                elif param =='email':\n                    user.email = check_email(vals['value'])\n                elif param =='kobo_only_shelves_sync':\n                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')\n                elif param == 'kindle_mail':\n                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"\n                elif param.endswith('role'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value in \\\n                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:\n                        raise Exception(_(\"Guest can't have this role\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.role |= value\n                        elif vals['value'] == 'false':\n                            if value == constants.ROLE_ADMIN:\n                                if not ub.session.query(ub.User).\\\n                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                              ub.User.id != user.id).count():\n                                    return Response(\n                                        json.dumps([{'type': \"danger\",\n                                                     'message':_(u\"No admin user remaining, can't remove admin role\",\n                                                                 nick=user.name)}]), mimetype='application/json')\n                            user.role &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid role\"))\n                elif param.startswith('sidebar'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:\n                        raise Exception(_(\"Guest can't have this view\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.sidebar_view |= value\n                        elif vals['value'] == 'false':\n                            user.sidebar_view &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid view\"))\n                elif param == 'locale':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))\n                    if vals['value'] in _BABEL_TRANSLATIONS:\n                        user.locale = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Locale Given\"))\n                elif param == 'default_language':\n                    languages = calibre_db.session.query(db.Languages) \\\n                        .join(db.books_languages_link) \\\n                        .join(db.Books) \\\n                        .filter(calibre_db.common_filters()) \\\n                        .group_by(text('books_languages_link.lang_code')).all()\n                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]\n                    if vals['value'] in lang_codes:\n                        user.default_language = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Book Language Given\"))\n                else:\n                    return _(\"Parameter not found\"), 400\n        except Exception as ex:\n            log.debug_or_exception(ex)\n            return str(ex), 400\n    ub.session_commit()\n    return \"\"\n\n\n@admi.route(\"/ajax/user_table_settings\", methods=['POST'])\n@login_required\n@admin_required\ndef update_table_settings():\n    current_user.view_settings['useredit'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: {}\".format(request))\n        return \"Invalid request\", 400\n    return \"\"\n\ndef check_valid_read_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\\n              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():\n            return False\n    return True\n\ndef check_valid_restricted_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\\n              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():\n            return False\n    return True\n\n\n@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_view_configuration():\n    to_save = request.form.to_dict()\n\n    _config_string(to_save, \"config_calibre_web_title\")\n    _config_string(to_save, \"config_columns_to_ignore\")\n    if _config_string(to_save, \"config_title_regex\"):\n        calibre_db.update_title_sort(config)\n\n    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):\n        flash(_(u\"Invalid Read Column\"), category=\"error\")\n        log.debug(\"Invalid Read column\")\n        return view_configuration()\n    _config_int(to_save, \"config_read_column\")\n\n    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):\n        flash(_(u\"Invalid Restricted Column\"), category=\"error\")\n        log.debug(\"Invalid Restricted Column\")\n        return view_configuration()\n    _config_int(to_save, \"config_restricted_column\")\n\n    _config_int(to_save, \"config_theme\")\n    _config_int(to_save, \"config_random_books\")\n    _config_int(to_save, \"config_books_per_page\")\n    _config_int(to_save, \"config_authors_max\")\n    _config_string(to_save, \"config_default_language\")\n    _config_string(to_save, \"config_default_locale\")\n\n\n    config.config_default_role = constants.selected_roles(to_save)\n    config.config_default_role &= ~constants.ROLE_ANONYMOUS\n\n    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))\n    if \"Show_detail_random\" in to_save:\n        config.config_default_show |= constants.DETAIL_RANDOM\n\n    config.save()\n    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")\n    log.debug(\"Calibre-Web configuration updated\")\n    before_request()\n\n    return view_configuration()\n\n\n@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])\n@login_required\ndef load_dialogtexts(element_id):\n    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}\n    if element_id == \"config_delete_kobo_token\":\n        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')\n    elif element_id == \"btndeletedomain\":\n        texts[\"main\"] = _('Do you really want to delete this domain?')\n    elif element_id == \"btndeluser\":\n        texts[\"main\"] = _('Do you really want to delete this user?')\n    elif element_id == \"delete_shelf\":\n        texts[\"main\"] = _('Are you sure you want to delete this shelf?')\n    elif element_id == \"select_locale\":\n        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')\n    elif element_id == \"select_default_language\":\n        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')\n    elif element_id == \"role\":\n        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')\n    elif element_id == \"restrictions\":\n        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')\n    elif element_id == \"sidebar_view\":\n        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions for the selected user(s)?')\n    elif element_id == \"kobo_only_shelves_sync\":\n        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')\n    elif element_id == \"db_submit\":\n        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')\n    elif element_id == \"btnfullsync\":\n        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database to force a full sync with your Kobo Reader?\")\n    return json.dumps(texts)\n\n\n@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_domain(allow):\n    # POST /post\n    # name:  'username',  //name of field (column in db)\n    # pk:    1            //primary key (record id)\n    # value: 'superuser!' //new value\n    vals = request.form.to_dict()\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()\n    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()\n    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))\n\n\n@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_domain(allow):\n    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()\n    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\\n        .filter(ub.Registration.allow == allow).first()\n    if not check:\n        new_domain = ub.Registration(domain=domain_name, allow=allow)\n        ub.session.add(new_domain)\n        ub.session_commit(\"Registering Domains added {}\".format(domain_name))\n    return \"\"\n\n\n@admi.route(\"/ajax/deletedomain\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_domain():\n    try:\n        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()\n        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()\n        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))\n        # If last domain was deleted, add all domains by default\n        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():\n            new_domain = ub.Registration(domain=\"%.%\", allow=1)\n            ub.session.add(new_domain)\n            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")\n    except KeyError:\n        pass\n    return \"\"\n\n\n@admi.route(\"/ajax/domainlist/<int:allow>\")\n@login_required\n@admin_required\ndef list_domain(allow):\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()\n    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])\n    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')\n    response = make_response(js.replace(\"'\", '\"'))\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])\n@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if element['id'].startswith('a'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))\n    if element['id'].startswith('d'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))\n    return \"\"\n\n\ndef restriction_addition(element, list_func):\n    elementlist = list_func()\n    if elementlist == ['']:\n        elementlist = []\n    if not element['add_element'] in elementlist:\n        elementlist += [element['add_element']]\n    return ','.join(elementlist)\n\n\ndef restriction_deletion(element, list_func):\n    elementlist = list_func()\n    if element['Element'] in elementlist:\n        elementlist.remove(element['Element'])\n    return ','.join(elementlist)\n\n\ndef prepare_tags(user, action, tags_name, id_list):\n    if \"tags\" in tags_name:\n        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()\n        if not tags:\n            raise Exception(_(\"Tag not found\"))\n        new_tags_list = [x.name for x in tags]\n    else:\n        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\\n            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()\n        new_tags_list = [x.value for x in tags]\n    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []\n    if action == \"remove\":\n        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]\n    elif action == \"add\":\n        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)\n    else:\n        raise Exception(_(\"Invalid Action\"))\n    return \",\".join(saved_tags_list)\n\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_user_0_restriction(res_type):\n    return add_restriction(res_type, 0)\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if 'submit_allow' in element:\n            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)\n            config.save()\n    if res_type == 1:  # CCustom as template\n        if 'submit_allow' in element:\n            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)\n            config.save()\n    if res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))\n        elif 'submit_deny' in element:\n            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))\n    if res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,\n                                                                                usr.list_allowed_column_values()))\n        elif 'submit_deny' in element:\n            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,\n                                                                               usr.list_denied_column_values()))\n    return \"\"\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user_0_restriction(res_type):\n    return delete_restriction(res_type, 0)\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if element['id'].startswith('a'):\n            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)\n            config.save()\n    elif res_type == 1:  # CustomC as template\n        if element['id'].startswith('a'):\n            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)\n            config.save()\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)\n            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n        elif element['id'].startswith('d'):\n            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)\n            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n    elif res_type == 3:  # Columns per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,\n                                                                              usr.list_allowed_column_values))\n\n        elif element['id'].startswith('d'):\n            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)\n            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,\n                                                                             usr.list_denied_column_values))\n    return \"\"\n\n\n@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})\n@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")\n@login_required\n@admin_required\ndef list_restriction(res_type, user_id):\n    if res_type == 0:   # Tags as template\n        restrict = [{'Element': x, 'type':_('Deny'), 'id': 'd'+str(i) }\n                    for i,x in enumerate(config.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 1:  # CustomC as template\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(config.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    else:\n        json_dumps = \"\"\n    js = json.dumps(json_dumps)\n    response = make_response(js)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@admi.route(\"/ajax/fullsync\")\n@login_required\ndef ajax_fullsync():\n    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()\n    message = _(\"{} sync entries deleted\").format(count)\n    ub.session_commit(message)\n    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')\n\n\n@admi.route(\"/ajax/pathchooser/\")\n@login_required\n@admin_required\ndef ajax_pathchooser():\n    return pathchooser()\n\n\ndef pathchooser():\n    browse_for = \"folder\"\n    folder_only = request.args.get('folder', False) == \"true\"\n    file_filter = request.args.get('filter', \"\")\n    path = os.path.normpath(request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    absolute = False\n\n    if os.path.isdir(path):\n        # if os.path.isabs(path):\n        cwd = os.path.realpath(path)\n        absolute = True\n        # else:\n        #    cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not absolute:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            if folder_only:\n                continue\n            if file_filter != \"\" and file_filter != f:\n                continue\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": absolute,\n    }\n    return json.dumps(context)\n\n\ndef _config_int(to_save, x, func=int):\n    return config.set_from_dictionary(to_save, x, func)\n\n\ndef _config_checkbox(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)\n\n\ndef _config_checkbox_int(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)\n\n\ndef _config_string(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)\n\n\ndef _configuration_gdrive_helper(to_save):\n    gdrive_error = None\n    if to_save.get(\"config_use_google_drive\"):\n        gdrive_secrets = {}\n\n        if not os.path.isfile(gdriveutils.SETTINGS_YAML):\n            config.config_use_google_drive = False\n\n        if gdrive_support:\n            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)\n        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:\n            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:\n                gdrive_secrets = json.load(settings)['web']\n            if not gdrive_secrets:\n                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))\n            gdriveutils.update_settings(\n                                gdrive_secrets['client_id'],\n                                gdrive_secrets['client_secret'],\n                                gdrive_secrets['redirect_uris'][0]\n                            )\n\n    # always show google drive settings, but in case of error deny support\n    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)\n    if config.config_use_google_drive and not new_gdrive_value:\n        config.config_google_drive_watch_changes_response = {}\n    config.config_use_google_drive = new_gdrive_value\n    if _config_string(to_save, \"config_google_drive_folder\"):\n        gdriveutils.deleteDatabaseOnChange()\n    return gdrive_error\n\n\ndef _configuration_oauth_helper(to_save):\n    active_oauths = 0\n    reboot_required = False\n    for element in oauthblueprints:\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\\n            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:\n            reboot_required = True\n            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]\n            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\\n            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:\n            active_oauths += 1\n            element[\"active\"] = 1\n        else:\n            element[\"active\"] = 0\n        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(\n            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],\n             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],\n             \"active\": element[\"active\"]})\n    return reboot_required\n\n\ndef _configuration_logfile_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_int(to_save, \"config_log_level\")\n    reboot_required |= _config_string(to_save, \"config_logfile\")\n    if not logger.is_valid_logfile(config.config_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))\n\n    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")\n    reboot_required |= _config_string(to_save, \"config_access_logfile\")\n    if not logger.is_valid_logfile(config.config_access_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))\n    return reboot_required, None\n\n\ndef _configuration_ldap_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")\n    reboot_required |= _config_int(to_save, \"config_ldap_port\")\n    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")\n    reboot_required |= _config_string(to_save, \"config_ldap_dn\")\n    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")\n    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")\n    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")\n    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")\n    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")\n    _config_string(to_save, \"config_ldap_group_name\")\n    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":\n        reboot_required |= 1\n        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')\n    config.save()\n\n    if not config.config_ldap_provider_url \\\n        or not config.config_ldap_port \\\n        or not config.config_ldap_dn \\\n        or not config.config_ldap_user_object:\n        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '\n                                                        'Port, DN and User Object Identifier'))\n\n    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:\n        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:\n            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))\n        else:\n            if not config.config_ldap_serv_username:\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))\n\n    if config.config_ldap_group_object_filter:\n        if config.config_ldap_group_object_filter.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_user_object.count(\"%s\") != 1:\n        return reboot_required, \\\n               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))\n    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):\n        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))\n\n    if to_save.get(\"ldap_import_user_filter\") == '0':\n        config.config_ldap_member_user_object = \"\"\n    else:\n        if config.config_ldap_member_user_object.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:\n        if not (os.path.isfile(config.config_ldap_cacert_path) and\n                os.path.isfile(config.config_ldap_cert_path) and\n                os.path.isfile(config.config_ldap_key_path)):\n            return reboot_required, \\\n                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '\n                                           'Please Enter Correct Path'))\n    return reboot_required, None\n\n\n@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])\n@login_required\n@admin_required\ndef simulatedbchange():\n    db_change, db_valid = _db_simulate_change()\n    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')\n\n\ndef _db_simulate_change():\n    param = request.form.to_dict()\n    to_save = {}\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           param['config_calibre_dir'],\n                                           flags=re.IGNORECASE).strip()\n    db_change = config.config_calibre_dir != to_save[\"config_calibre_dir\"] and config.config_calibre_dir\n    db_valid = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"], ub.app_DB_path)\n    return db_change, db_valid\n\n\ndef _db_configuration_update_helper():\n    db_change = False\n    to_save = request.form.to_dict()\n    gdrive_error = None\n\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           to_save['config_calibre_dir'],\n                                           flags=re.IGNORECASE)\n    try:\n        db_change, db_valid = _db_simulate_change()\n\n        # gdrive_error drive setup\n        gdrive_error = _configuration_gdrive_helper(to_save)\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        _db_configuration_result(_(\"Settings DB is not Writeable\"), gdrive_error)\n    try:\n        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")\n        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):\n            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)\n            db_change = True\n    except Exception as ex:\n        return _db_configuration_result('{}'.format(ex), gdrive_error)\n\n    if db_change or not db_valid or not config.db_configured:\n        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):\n            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),\n                                            gdrive_error)\n        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...\n        ub.session.query(ub.Downloads).delete()\n        ub.session.query(ub.ArchivedBook).delete()\n        ub.session.query(ub.ReadBook).delete()\n        ub.session.query(ub.BookShelf).delete()\n        ub.session.query(ub.Bookmark).delete()\n        ub.session.query(ub.KoboReadingState).delete()\n        ub.session.query(ub.KoboStatistics).delete()\n        ub.session.query(ub.KoboSyncedBooks).delete()\n        ub.session_commit()\n        _config_string(to_save, \"config_calibre_dir\")\n        calibre_db.update_config(config)\n        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):\n            flash(_(u\"DB is not Writeable\"), category=\"warning\")\n    config.save()\n    return _db_configuration_result(None, gdrive_error)\n\ndef _configuration_update_helper():\n    reboot_required = False\n    to_save = request.form.to_dict()\n    try:\n        reboot_required |= _config_int(to_save, \"config_port\")\n        reboot_required |= _config_string(to_save, \"config_trustedhosts\")\n        reboot_required |= _config_string(to_save, \"config_keyfile\")\n        if config.config_keyfile and not os.path.isfile(config.config_keyfile):\n            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))\n\n        reboot_required |= _config_string(to_save, \"config_certfile\")\n        if config.config_certfile and not os.path.isfile(config.config_certfile):\n            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))\n\n        _config_checkbox_int(to_save, \"config_uploading\")\n        _config_checkbox_int(to_save, \"config_unicode_filename\")\n        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case\n        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")\n                             and config.config_login_type == constants.LOGIN_LDAP)\n        _config_checkbox_int(to_save, \"config_public_reg\")\n        _config_checkbox_int(to_save, \"config_register_email\")\n        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")\n        _config_int(to_save, \"config_external_port\")\n        _config_checkbox_int(to_save, \"config_kobo_proxy\")\n\n        if \"config_upload_formats\" in to_save:\n            to_save[\"config_upload_formats\"] = ','.join(\n                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))\n            _config_string(to_save, \"config_upload_formats\")\n            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')\n\n        _config_string(to_save, \"config_calibre\")\n        _config_string(to_save, \"config_converterpath\")\n        _config_string(to_save, \"config_kepubifypath\")\n\n        reboot_required |= _config_int(to_save, \"config_login_type\")\n\n        # LDAP configurator\n        if config.config_login_type == constants.LOGIN_LDAP:\n            reboot, message = _configuration_ldap_helper(to_save)\n            if message:\n                return message\n            reboot_required |= reboot\n\n        # Remote login configuration\n        _config_checkbox(to_save, \"config_remote_login\")\n        if not config.config_remote_login:\n            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()\n\n        # Goodreads configuration\n        _config_checkbox(to_save, \"config_use_goodreads\")\n        _config_string(to_save, \"config_goodreads_api_key\")\n        _config_string(to_save, \"config_goodreads_api_secret\")\n        if services.goodreads_support:\n            services.goodreads_support.connect(config.config_goodreads_api_key,\n                                               config.config_goodreads_api_secret,\n                                               config.config_use_goodreads)\n\n        _config_int(to_save, \"config_updatechannel\")\n\n        # Reverse proxy login configuration\n        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")\n        _config_string(to_save, \"config_reverse_proxy_login_header_name\")\n\n        # OAuth configuration\n        if config.config_login_type == constants.LOGIN_OAUTH:\n            reboot_required |= _configuration_oauth_helper(to_save)\n\n        reboot, message = _configuration_logfile_helper(to_save)\n        if message:\n            return message\n        reboot_required |= reboot\n        # Rarfile Content configuration\n        _config_string(to_save, \"config_rarfile_location\")\n        if \"config_rarfile_location\" in to_save:\n            unrar_status = helper.check_unrar(config.config_rarfile_location)\n            if unrar_status:\n                return _configuration_result(unrar_status)\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        _configuration_result(_(\"Settings DB is not Writeable\"))\n\n    config.save()\n    if reboot_required:\n        web_server.stop(True)\n\n    return _configuration_result(None, reboot_required)\n\ndef _configuration_result(error_flash=None, reboot=False):\n    resp = {}\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        resp['result'] = [{'type': \"danger\", 'message': error_flash}]\n    else:\n        resp['result'] = [{'type': \"success\", 'message':_(u\"Calibre-Web configuration updated\")}]\n    resp['reboot'] = reboot\n    resp['config_upload']= config.config_upload_formats\n    return Response(json.dumps(resp), mimetype='application/json')\n\n\ndef _db_configuration_result(error_flash=None, gdrive_error=None):\n    gdrive_authenticate = not is_gdrive_ready()\n    gdrivefolders = []\n    if not gdrive_error and config.config_use_google_drive:\n        gdrive_error = gdriveutils.get_error_text()\n    if gdrive_error and gdrive_support:\n        log.error(gdrive_error)\n        gdrive_error = _(gdrive_error)\n        flash(gdrive_error, category=\"error\")\n    else:\n        if not gdrive_authenticate and gdrive_support:\n            gdrivefolders = gdriveutils.listRootFolders()\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        flash(error_flash, category=\"error\")\n    elif request.method == \"POST\" and not gdrive_error:\n        flash(_(\"Database Settings updated\"), category=\"success\")\n\n    return render_title_template(\"config_db.html\",\n                                 config=config,\n                                 show_authenticate_google_drive=gdrive_authenticate,\n                                 gdriveError=gdrive_error,\n                                 gdrivefolders=gdrivefolders,\n                                 feature_support=feature_support,\n                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")\n\n\ndef _handle_new_user(to_save, content, languages, translations, kobo_support):\n    content.default_language = to_save[\"default_language\"]\n    content.locale = to_save.get(\"locale\", content.locale)\n\n    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))\n    if \"show_detail_random\" in to_save:\n        content.sidebar_view |= constants.DETAIL_RANDOM\n\n    content.role = constants.selected_roles(to_save)\n    content.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:\n            log.info(\"Missing entries on new user\")\n            raise Exception(_(u\"Please fill out all fields!\"))\n        content.email = check_email(to_save[\"email\"])\n        # Query User name, if not existing, change\n        content.name = check_username(to_save[\"name\"])\n        if to_save.get(\"kindle_mail\"):\n            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if config.config_public_reg and not check_valid_domain(content.email):\n            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))\n            raise Exception(_(u\"E-mail is not from valid domain\"))\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                     config=config,\n                                     translations=translations,\n                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                     kobo_support=kobo_support, registered_oauth=oauth_check)\n    try:\n        content.allowed_tags = config.config_allowed_tags\n        content.denied_tags = config.config_denied_tags\n        content.allowed_column_value = config.config_allowed_column_value\n        content.denied_column_value = config.config_denied_column_value\n        # No default value for kobo sync shelf setting\n        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"\n        ub.session.add(content)\n        ub.session.commit()\n        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")\n        log.debug(\"User {} created\".format(content.name))\n        return redirect(url_for('admin.admin'))\n    except IntegrityError:\n        ub.session.rollback()\n        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))\n        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")\n    except OperationalError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\ndef _delete_user(content):\n    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                        ub.User.id != content.id).count():\n        if content.name != \"Guest\":\n            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status\n            # and user itself\n            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()\n            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()\n            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):\n                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()\n            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()\n            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()\n            ub.session_commit()\n            log.info(u\"User {} deleted\".format(content.name))\n            return(_(u\"User '%(nick)s' deleted\", nick=content.name))\n        else:\n            log.warning(_(u\"Can't delete Guest User\"))\n            raise Exception(_(u\"Can't delete Guest User\"))\n    else:\n        log.warning(u\"No admin user remaining, can't delete user\")\n        raise Exception(_(u\"No admin user remaining, can't delete user\"))\n\n\ndef _handle_edit_user(to_save, content, languages, translations, kobo_support):\n    if to_save.get(\"delete\"):\n        try:\n            flash(_delete_user(content), category=\"success\")\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    else:\n        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:\n            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))\n            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")\n            return redirect(url_for('admin.admin'))\n        if to_save.get(\"password\"):\n            content.password = generate_password_hash(to_save[\"password\"])\n        anonymous = content.is_anonymous\n        content.role = constants.selected_roles(to_save)\n        if anonymous:\n            content.role |= constants.ROLE_ANONYMOUS\n        else:\n            content.role &= ~constants.ROLE_ANONYMOUS\n\n        val = [int(k[5:]) for k in to_save if k.startswith('show_')]\n        sidebar = get_sidebar_config()\n        for element in sidebar:\n            value = element['visibility']\n            if value in val and not content.check_visibility(value):\n                content.sidebar_view |= value\n            elif value not in val and content.check_visibility(value):\n                content.sidebar_view &= ~value\n\n        if to_save.get(\"Show_detail_random\"):\n            content.sidebar_view |= constants.DETAIL_RANDOM\n        else:\n            content.sidebar_view &= ~constants.DETAIL_RANDOM\n\n        old_state = content.kobo_only_shelves_sync\n        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs\n        # which don't have to be synced have to be removed (added to Shelf archive)\n        if old_state == 0 and content.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(content.id)\n        if to_save.get(\"default_language\"):\n            content.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            content.locale = to_save[\"locale\"]\n        try:\n            if to_save.get(\"email\", content.email) != content.email:\n                content.email = check_email(to_save[\"email\"])\n            # Query User name, if not existing, change\n            if to_save.get(\"name\", content.name) != content.name:\n                if to_save.get(\"name\") == \"Guest\":\n                    raise Exception(_(\"Guest Name can't be changed\"))\n                content.name = check_username(to_save[\"name\"])\n            if to_save.get(\"kindle_mail\") != content.kindle_mail:\n                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n            return render_title_template(\"user_edit.html\",\n                                         translations=translations,\n                                         languages=languages,\n                                         mail_configured=config.get_mail_server_configured(),\n                                         kobo_support=kobo_support,\n                                         new_user=0,\n                                         content=content,\n                                         config=config,\n                                         registered_oauth=oauth_check,\n                                         title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                         page=\"edituser\")\n    try:\n        ub.session_commit()\n        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")\n    except IntegrityError as ex:\n        ub.session.rollback()\n        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))\n        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n    except OperationalError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    return \"\"\n\n\n@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef new_user():\n    content = ub.User()\n    languages = calibre_db.speaking_language()\n    translations = [LC('en')] + babel.list_translations()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        _handle_new_user(to_save, content, languages, translations, kobo_support)\n    else:\n        content.role = config.config_default_role\n        content.sidebar_view = config.config_default_show\n        content.locale = config.config_default_locale\n        content.default_language = config.config_default_language\n    return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                 config=config, translations=translations,\n                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                 kobo_support=kobo_support, registered_oauth=oauth_check)\n\n\n@admi.route(\"/admin/mailsettings\")\n@login_required\n@admin_required\ndef edit_mailsettings():\n    content = config.get_mail_settings()\n    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),\n                                 page=\"mailset\", feature_support=feature_support)\n\n\n@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_mailsettings():\n    to_save = request.form.to_dict()\n    _config_int(to_save, \"mail_server_type\")\n    if to_save.get(\"invalidate\"):\n        config.mail_gmail_token = {}\n        try:\n            flag_modified(config, \"mail_gmail_token\")\n        except AttributeError:\n            pass\n    elif to_save.get(\"gmail\"):\n        try:\n            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)\n            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            log.error(ex)\n            return edit_mailsettings()\n\n    else:\n        _config_string(to_save, \"mail_server\")\n        _config_int(to_save, \"mail_port\")\n        _config_int(to_save, \"mail_use_ssl\")\n        _config_string(to_save, \"mail_login\")\n        _config_string(to_save, \"mail_password\")\n        _config_string(to_save, \"mail_from\")\n        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)\n    try:\n        config.save()\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n        return edit_mailsettings()\n\n    if to_save.get(\"test\"):\n        if current_user.email:\n            result = send_test_mail(current_user.email, current_user.name)\n            if result is None:\n                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",\n                        email=current_user.email), category=\"info\")\n            else:\n                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")\n        else:\n            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")\n    else:\n        flash(_(u\"E-mail server settings updated\"), category=\"success\")\n\n    return edit_mailsettings()\n\n\n@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef edit_user(user_id):\n    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User\n    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):\n        flash(_(u\"User not found\"), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    languages = calibre_db.speaking_language(return_all_languages=True)\n    translations = babel.list_translations() + [LC('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)\n        if resp:\n            return resp\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 languages=languages,\n                                 new_user=0,\n                                 content=content,\n                                 config=config,\n                                 registered_oauth=oauth_check,\n                                 mail_configured=config.get_mail_server_configured(),\n                                 kobo_support=kobo_support,\n                                 title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                 page=\"edituser\")\n\n\n@admi.route(\"/admin/resetpassword/<int:user_id>\")\n@login_required\n@admin_required\ndef reset_user_password(user_id):\n    if current_user is not None and current_user.is_authenticated:\n        ret, message = reset_password(user_id)\n        if ret == 1:\n            log.debug(u\"Password for user %s reset\", message)\n            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")\n        elif ret == 0:\n            log.error(u\"An unknown error occurred. Please try again later.\")\n            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n        else:\n            log.error(u\"Please configure the SMTP mail settings first...\")\n            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    return redirect(url_for('admin.admin'))\n\n\n@admi.route(\"/admin/logfile\")\n@login_required\n@admin_required\ndef view_logfile():\n    logfiles = {0: logger.get_logfile(config.config_logfile),\n                1: logger.get_accesslogfile(config.config_access_logfile)}\n    return render_title_template(\"logviewer.html\",\n                                 title=_(u\"Logfile viewer\"),\n                                 accesslog_enable=config.config_access_log,\n                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),\n                                 logfiles=logfiles,\n                                 page=\"logfile\")\n\n\n@admi.route(\"/ajax/log/<int:logtype>\")\n@login_required\n@admin_required\ndef send_logfile(logtype):\n    if logtype == 1:\n        logfile = logger.get_accesslogfile(config.config_access_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    if logtype == 0:\n        logfile = logger.get_logfile(config.config_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    else:\n        return \"\"\n\n\n@admi.route(\"/admin/logdownload/<int:logtype>\")\n@login_required\n@admin_required\ndef download_log(logtype):\n    if logtype == 0:\n        file_name = logger.get_logfile(config.config_logfile)\n    elif logtype == 1:\n        file_name = logger.get_accesslogfile(config.config_access_logfile)\n    else:\n        abort(404)\n    if logger.is_valid_logfile(file_name):\n        return debug_info.assemble_logfiles(file_name)\n    abort(404)\n\n\n@admi.route(\"/admin/debug\")\n@login_required\n@admin_required\ndef download_debug():\n    return debug_info.send_debug()\n\n\n@admi.route(\"/get_update_status\", methods=['GET'])\n@login_required\n@admin_required\ndef get_update_status():\n    if feature_support['updater']:\n        log.info(u\"Update status requested\")\n        return updater_thread.get_available_updates(request.method, locale=get_locale())\n    else:\n        return ''\n\n\n@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])\n@login_required\n@admin_required\ndef get_updater_status():\n    status = {}\n    if feature_support['updater']:\n        if request.method == \"POST\":\n            commit = request.form.to_dict()\n            if \"start\" in commit and commit['start'] == 'True':\n                text = {\n                    \"1\": _(u'Requesting update package'),\n                    \"2\": _(u'Downloading update package'),\n                    \"3\": _(u'Unzipping update package'),\n                    \"4\": _(u'Replacing files'),\n                    \"5\": _(u'Database connections are closed'),\n                    \"6\": _(u'Stopping server'),\n                    \"7\": _(u'Update finished, please press okay and reload page'),\n                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),\n                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),\n                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),\n                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),\n                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),\n                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')\n                }\n                status['text'] = text\n                updater_thread.status = 0\n                updater_thread.resume()\n                status['status'] = updater_thread.get_update_status()\n        elif request.method == \"GET\":\n            try:\n                status['status'] = updater_thread.get_update_status()\n                if status['status'] == -1:\n                    status['status'] = 7\n            except Exception:\n                status['status'] = 11\n        return json.dumps(status)\n    return ''\n\n\ndef ldap_import_create_user(user, user_data):\n    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)\n\n    try:\n        username = user_data[user_login_field][0].decode('utf-8')\n    except KeyError as ex:\n        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)\n        message = _(u'Failed to extract at least One LDAP User')\n        return 0, message\n\n    # check for duplicate username\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():\n        # if ub.session.query(ub.User).filter(ub.User.name == username).first():\n        log.warning(\"LDAP User  %s Already in Database\", user_data)\n        return 0, None\n\n    kindlemail = ''\n    if 'mail' in user_data:\n        useremail = user_data['mail'][0].decode('utf-8')\n        if len(user_data['mail']) > 1:\n            kindlemail = user_data['mail'][1].decode('utf-8')\n\n    else:\n        log.debug('No Mail Field Found in LDAP Response')\n        useremail = username + '@email.com'\n\n    try:\n        # check for duplicate email\n        useremail = check_email(useremail)\n    except Exception as ex:\n        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))\n        return 0, None\n    content = ub.User()\n    content.name = username\n    content.password = ''  # dummy password which will be replaced by ldap one\n    content.email = useremail\n    content.kindle_mail = kindlemail\n    content.default_language = config.config_default_language\n    content.locale = config.config_default_locale\n    content.role = config.config_default_role\n    content.sidebar_view = config.config_default_show\n    content.allowed_tags = config.config_allowed_tags\n    content.denied_tags = config.config_denied_tags\n    content.allowed_column_value = config.config_allowed_column_value\n    content.denied_column_value = config.config_denied_column_value\n    ub.session.add(content)\n    try:\n        ub.session.commit()\n        return 1, None    # increase no of users\n    except Exception as ex:\n        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)\n        ub.session.rollback()\n        message = _(u'Failed to Create at Least One LDAP User')\n        return 0, message\n\n\n@admi.route('/import_ldap_users')\n@login_required\n@admin_required\ndef import_ldap_users():\n    showtext = {}\n    try:\n        new_users = services.ldap.get_group_members(config.config_ldap_group_name)\n    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:\n        log.debug_or_exception(e)\n        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)\n        return json.dumps(showtext)\n    if not new_users:\n        log.debug('LDAP empty response')\n        showtext['text'] = _(u'Error: No user returned in response of LDAP server')\n        return json.dumps(showtext)\n\n    imported = 0\n    for username in new_users:\n        user = username.decode('utf-8')\n        if '=' in user:\n            # if member object field is empty take user object as filter\n            if config.config_ldap_member_user_object:\n                query_filter = config.config_ldap_member_user_object\n            else:\n                query_filter = config.config_ldap_user_object\n            try:\n                user_identifier = extract_user_identifier(user, query_filter)\n            except Exception as ex:\n                log.warning(ex)\n                continue\n        else:\n            user_identifier = user\n            query_filter = None\n        try:\n            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)\n        except AttributeError as ex:\n            log.debug_or_exception(ex)\n            continue\n        if user_data:\n            user_count, message = ldap_import_create_user(user, user_data)\n            if message:\n                showtext['text'] = message\n            else:\n                imported += user_count\n        else:\n            log.warning(\"LDAP User: %s Not Found\", user)\n            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')\n    if not showtext:\n        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))\n    return json.dumps(showtext)\n\n\ndef extract_user_data_from_field(user, field):\n    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))\n\n\ndef extract_dynamic_field_from_filter(user, filtr):\n    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)\n\n\ndef extract_user_identifier(user, filtr):\n    dynamic_field = extract_dynamic_field_from_filter(user, filtr)\n    return extract_user_data_from_field(user, dynamic_field)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nfrom shutil import copyfile\nfrom uuid import uuid4\nfrom markupsafe import escape\ntry:\n    from lxml.html.clean import clean_html\nexcept ImportError:\n    pass\n\n# Improve this to check if scholarly is available in a global way, like other pythonic libraries\ntry:\n    from scholarly import scholarly\n    have_scholar = True\nexcept ImportError:\n    have_scholar = False\n\nfrom flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import OperationalError, IntegrityError\nfrom sqlite3 import OperationalError as sqliteOperationalError\nfrom . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status\nfrom . import config, get_locale, ub, db\nfrom . import calibre_db\nfrom .services.worker import WorkerThread\nfrom .tasks.upload import TaskUpload\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\n\n\n\neditbook = Blueprint('editbook', __name__)\nlog = logger.create()\n\n\ndef upload_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_upload():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef edit_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_edit() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef search_objects_remove(db_book_object, db_type, input_elements):\n    del_elements = []\n    for c_elements in db_book_object:\n        found = False\n        if db_type == 'languages':\n            type_elements = c_elements.lang_code\n        elif db_type == 'custom':\n            type_elements = c_elements.value\n        else:\n            type_elements = c_elements.name\n        for inp_element in input_elements:\n            if inp_element.lower() == type_elements.lower():\n                # if inp_element == type_elements:\n                found = True\n                break\n        # if the element was not found in the new list, add it to remove list\n        if not found:\n            del_elements.append(c_elements)\n    return del_elements\n\n\ndef search_objects_add(db_book_object, db_type, input_elements):\n    add_elements = []\n    for inp_element in input_elements:\n        found = False\n        for c_elements in db_book_object:\n            if db_type == 'languages':\n                type_elements = c_elements.lang_code\n            elif db_type == 'custom':\n                type_elements = c_elements.value\n            else:\n                type_elements = c_elements.name\n            if inp_element == type_elements:\n                found = True\n                break\n        if not found:\n            add_elements.append(inp_element)\n    return add_elements\n\n\ndef remove_objects(db_book_object, db_session, del_elements):\n    changed = False\n    if len(del_elements) > 0:\n        for del_element in del_elements:\n            db_book_object.remove(del_element)\n            changed = True\n            if len(del_element.books) == 0:\n                db_session.delete(del_element)\n    return changed\n\ndef add_objects(db_book_object, db_object, db_session, db_type, add_elements):\n    changed = False\n    if db_type == 'languages':\n        db_filter = db_object.lang_code\n    elif db_type == 'custom':\n        db_filter = db_object.value\n    else:\n        db_filter = db_object.name\n    for add_element in add_elements:\n        # check if a element with that name exists\n        db_element = db_session.query(db_object).filter(db_filter == add_element).first()\n        # if no element is found add it\n        # if new_element is None:\n        if db_type == 'author':\n            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")\n        elif db_type == 'series':\n            new_element = db_object(add_element, add_element)\n        elif db_type == 'custom':\n            new_element = db_object(value=add_element)\n        elif db_type == 'publisher':\n            new_element = db_object(add_element, None)\n        else:  # db_type should be tag or language\n            new_element = db_object(add_element)\n        if db_element is None:\n            changed = True\n            db_session.add(new_element)\n            db_book_object.append(new_element)\n        else:\n            db_element = create_objects_for_addition(db_element, add_element, db_type)\n            changed = True\n            # add element to book\n            changed = True\n            db_book_object.append(db_element)\n    return changed\n\n\ndef create_objects_for_addition(db_element, add_element, db_type):\n    if db_type == 'custom':\n        if db_element.value != add_element:\n            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible\n    elif db_type == 'languages':\n        if db_element.lang_code != add_element:\n            db_element.lang_code = add_element\n    elif db_type == 'series':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element\n    elif db_type == 'author':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element.replace('|', ',')\n    elif db_type == 'publisher':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = None\n    elif db_element.name != add_element:\n        db_element.name = add_element\n    return db_element\n\n\n# Modifies different Database objects, first check if elements if elements have to be deleted,\n# because they are no longer used, than check if elements have to be added to database\ndef modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):\n    # passing input_elements not as a list may lead to undesired results\n    if not isinstance(input_elements, list):\n        raise TypeError(str(input_elements) + \" should be passed as a list\")\n    input_elements = [x for x in input_elements if x != '']\n    # we have all input element (authors, series, tags) names now\n    # 1. search for elements to remove\n    del_elements = search_objects_remove(db_book_object, db_type, input_elements)\n    # 2. search for elements that need to be added\n    add_elements = search_objects_add(db_book_object, db_type, input_elements)\n    # if there are elements to remove, we remove them now\n    changed = remove_objects(db_book_object, db_session, del_elements)\n    # if there are elements to add, we add them now!\n    if len(add_elements) > 0:\n        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)\n    return changed\n\n\ndef modify_identifiers(input_identifiers, db_identifiers, db_session):\n    \"\"\"Modify Identifiers to match input information.\n       input_identifiers is a list of read-to-persist Identifiers objects.\n       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"\n    changed = False\n    error = False\n    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])\n    if len(input_identifiers) != len(input_dict):\n        error = True\n    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])\n    # delete db identifiers not present in input or modify them with input val\n    for identifier_type, identifier in db_dict.items():\n        if identifier_type not in input_dict.keys():\n            db_session.delete(identifier)\n            changed = True\n        else:\n            input_identifier = input_dict[identifier_type]\n            identifier.type = input_identifier.type\n            identifier.val = input_identifier.val\n    # add input identifiers not present in db\n    for identifier_type, identifier in input_dict.items():\n        if identifier_type not in db_dict.keys():\n            db_session.add(identifier)\n            changed = True\n    return changed, error\n\n@editbook.route(\"/ajax/delete/<int:book_id>\")\n@login_required\ndef delete_book_from_details(book_id):\n    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')\n\n\n@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"})\n@editbook.route(\"/delete/<int:book_id>/<string:book_format>\")\n@login_required\ndef delete_book_ajax(book_id, book_format):\n    return delete_book_from_table(book_id, book_format, False)\n\n\ndef delete_whole_book(book_id, book):\n    # delete book from Shelfs, Downloads, Read list\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()\n    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()\n    ub.delete_download(book_id)\n    ub.session_commit()\n\n    # check if only this book links to:\n    # author, language, series, tags, custom columns\n    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')\n    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')\n    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')\n    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')\n    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')\n\n    cc = calibre_db.session.query(db.Custom_Columns). \\\n        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n                elif c.datatype == 'rating':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if len(del_cc.books) == 0:\n                        log.debug('remove ' + str(c.id))\n                        calibre_db.session.delete(del_cc)\n                        calibre_db.session.commit()\n                else:\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n        else:\n            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],\n                                   calibre_db.session, 'custom')\n    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()\n\n\ndef render_delete_book_result(book_format, jsonResponse, warning, book_id):\n    if book_format:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Format Successfully Deleted')}])\n        else:\n            flash(_('Book Format Successfully Deleted'), category=\"success\")\n            return redirect(url_for('editbook.edit_book', book_id=book_id))\n    else:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for('web.index'),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Successfully Deleted')}])\n        else:\n            flash(_('Book Successfully Deleted'), category=\"success\")\n            return redirect(url_for('web.index'))\n\n\ndef delete_book_from_table(book_id, book_format, jsonResponse):\n    warning = {}\n    if current_user.role_delete_books():\n        book = calibre_db.get_book(book_id)\n        if book:\n            try:\n                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())\n                if not result:\n                    if jsonResponse:\n                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                           \"type\": \"danger\",\n                                           \"format\": \"\",\n                                           \"message\": error}])\n                    else:\n                        flash(error, category=\"error\")\n                        return redirect(url_for('editbook.edit_book', book_id=book_id))\n                if error:\n                    if jsonResponse:\n                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                                \"type\": \"warning\",\n                                                \"format\": \"\",\n                                                \"message\": error}\n                    else:\n                        flash(error, category=\"warning\")\n                if not book_format:\n                    delete_whole_book(book_id, book)\n                else:\n                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\\n                        filter(db.Data.format == book_format).delete()\n                calibre_db.session.commit()\n            except Exception as ex:\n                log.debug_or_exception(ex)\n                calibre_db.session.rollback()\n                if jsonResponse:\n                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                        \"type\": \"danger\",\n                                        \"format\": \"\",\n                                        \"message\": ex}])\n                else:\n                    flash(str(ex), category=\"error\")\n                    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n        else:\n            # book not found\n            log.error('Book with id \"%s\" could not be deleted: not found', book_id)\n    return render_delete_book_result(book_format, jsonResponse, warning, book_id)\n\n\ndef render_edit_book(book_id):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    for lang in book.languages:\n        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n\n    book = calibre_db.order_authors(book)\n\n    author_names = []\n    for authr in book.authors:\n        author_names.append(authr.name.replace('|', ','))\n\n    # Option for showing convertbook button\n    valid_source_formats=list()\n    allowed_conversion_formats = list()\n    kepub_possible=None\n    if config.config_converterpath:\n        for file in book.data:\n            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:\n                valid_source_formats.append(file.format.lower())\n    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:\n        kepub_possible = True\n        if not config.config_converterpath:\n            valid_source_formats.append('epub')\n\n    # Determine what formats don't already exist\n    if config.config_converterpath:\n        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]\n        for file in book.data:\n            if file.format.lower() in allowed_conversion_formats:\n                allowed_conversion_formats.remove(file.format.lower())\n    if kepub_possible:\n        allowed_conversion_formats.append('kepub')\n    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,\n                                 title=_(u\"edit metadata\"), page=\"editbook\",\n                                 conversion_formats=allowed_conversion_formats,\n                                 config=config,\n                                 source_formats=valid_source_formats)\n\n\ndef edit_book_ratings(to_save, book):\n    changed = False\n    if to_save[\"rating\"].strip():\n        old_rating = False\n        if len(book.ratings) > 0:\n            old_rating = book.ratings[0].rating\n        ratingx2 = int(float(to_save[\"rating\"]) * 2)\n        if ratingx2 != old_rating:\n            changed = True\n            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()\n            if is_rating:\n                book.ratings.append(is_rating)\n            else:\n                new_rating = db.Ratings(rating=ratingx2)\n                book.ratings.append(new_rating)\n            if old_rating:\n                book.ratings.remove(book.ratings[0])\n    else:\n        if len(book.ratings) > 0:\n            book.ratings.remove(book.ratings[0])\n            changed = True\n    return changed\n\ndef edit_book_tags(tags, book):\n    input_tags = tags.split(',')\n    input_tags = list(map(lambda it: it.strip(), input_tags))\n    # Remove duplicates\n    input_tags = helper.uniq(input_tags)\n    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')\n\n\ndef edit_book_series(series, book):\n    input_series = [series.strip()]\n    input_series = [x for x in input_series if x != '']\n    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')\n\n\ndef edit_book_series_index(series_index, book):\n    # Add default series_index to book\n    modif_date = False\n    series_index = series_index or '1'\n    if not series_index.replace('.', '', 1).isdigit():\n        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")\n        return False\n    if str(book.series_index) != series_index:\n        book.series_index = series_index\n        modif_date = True\n    return modif_date\n\n\n# Handle book comments/description\ndef edit_book_comments(comments, book):\n    modif_date = False\n    if comments:\n        comments = clean_html(comments)\n    if len(book.comments):\n        if book.comments[0].text != comments:\n            book.comments[0].text = comments\n            modif_date = True\n    else:\n        if comments:\n            book.comments.append(db.Comments(text=comments, book=book.id))\n            modif_date = True\n    return modif_date\n\n\ndef edit_book_languages(languages, book, upload=False, invalid=None):\n    input_languages = languages.split(',')\n    unknown_languages = []\n    if not upload:\n        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)\n    else:\n        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)\n    for l in unknown_languages:\n        log.error(\"'%s' is not a valid language\", l)\n        if isinstance(invalid, list):\n            invalid.append(l)\n        else:\n            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))\n    # ToDo: Not working correct\n    if upload and len(input_l) == 1:\n        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view\n        # the book it's language is set to the filter language\n        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":\n            input_l[0] = calibre_db.session.query(db.Languages). \\\n                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code\n    # Remove duplicates\n    input_l = helper.uniq(input_l)\n    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')\n\n\ndef edit_book_publisher(publishers, book):\n    changed = False\n    if publishers:\n        publisher = publishers.rstrip().strip()\n        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):\n            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,\n                                              'publisher')\n    elif len(book.publishers):\n        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')\n    return changed\n\n\ndef edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if to_save[cc_string] == 'None':\n        to_save[cc_string] = None\n    elif c.datatype == 'bool':\n        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0\n    elif c.datatype == 'comments':\n        to_save[cc_string] = Markup(to_save[cc_string]).unescape()\n        if to_save[cc_string]:\n            to_save[cc_string] = clean_html(to_save[cc_string])\n    elif c.datatype == 'datetime':\n        try:\n            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")\n        except ValueError:\n            to_save[cc_string] = db.Books.DEFAULT_PUBDATE\n\n    if to_save[cc_string] != cc_db_value:\n        if cc_db_value is not None:\n            if to_save[cc_string] is not None:\n                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])\n                changed = True\n            else:\n                del_cc = getattr(book, cc_string)[0]\n                getattr(book, cc_string).remove(del_cc)\n                calibre_db.session.delete(del_cc)\n                changed = True\n        else:\n            cc_class = db.cc_classes[c.id]\n            new_cc = cc_class(value=to_save[cc_string], book=book_id)\n            calibre_db.session.add(new_cc)\n            changed = True\n    return changed, to_save\n\n\ndef edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if c.datatype == 'rating':\n        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))\n    if to_save[cc_string].strip() != cc_db_value:\n        if cc_db_value is not None:\n            # remove old cc_val\n            del_cc = getattr(book, cc_string)[0]\n            getattr(book, cc_string).remove(del_cc)\n            if len(del_cc.books) == 0:\n                calibre_db.session.delete(del_cc)\n                changed = True\n        cc_class = db.cc_classes[c.id]\n        new_cc = calibre_db.session.query(cc_class).filter(\n            cc_class.value == to_save[cc_string].strip()).first()\n        # if no cc val is found add it\n        if new_cc is None:\n            new_cc = cc_class(value=to_save[cc_string].strip())\n            calibre_db.session.add(new_cc)\n            changed = True\n            calibre_db.session.flush()\n            new_cc = calibre_db.session.query(cc_class).filter(\n                cc_class.value == to_save[cc_string].strip()).first()\n        # add cc value to book\n        getattr(book, cc_string).append(new_cc)\n    return changed, to_save\n\ndef edit_single_cc_data(book_id, book, column_id, to_save):\n    cc = (calibre_db.session.query(db.Custom_Columns)\n          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))\n          .filter(db.Custom_Columns.id == column_id)\n          .all())\n    return edit_cc_data(book_id, book, to_save, cc)\n\ndef edit_all_cc_data(book_id, book, to_save):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    return edit_cc_data(book_id, book, to_save, cc)\n\ndef edit_cc_data(book_id, book, to_save, cc):\n    changed = False\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                cc_db_value = getattr(book, cc_string)[0].value\n            else:\n                cc_db_value = None\n            if to_save[cc_string].strip():\n                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:\n                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)\n                else:\n                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)\n            else:\n                if cc_db_value is not None:\n                    # remove old cc_val\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if not del_cc.books or len(del_cc.books) == 0:\n                        calibre_db.session.delete(del_cc)\n                        changed = True\n        else:\n            input_tags = to_save[cc_string].split(',')\n            input_tags = list(map(lambda it: it.strip(), input_tags))\n            changed |= modify_database_object(input_tags,\n                                              getattr(book, cc_string),\n                                              db.cc_classes[c.id],\n                                              calibre_db.session,\n                                              'custom')\n    return changed\n\ndef upload_single_file(request, book, book_id):\n    # Check and handle Uploaded file\n    if 'btn-upload-format' in request.files:\n        requested_file = request.files['btn-upload-format']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            if '.' in requested_file.filename:\n                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),\n                          category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_('File to be uploaded must have an extension'), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_name = book.path.rsplit('/', 1)[-1]\n            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))\n            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)\n\n            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n            if not os.path.exists(filepath):\n                try:\n                    os.makedirs(filepath)\n                except OSError:\n                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            try:\n                requested_file.save(saved_filename)\n            except OSError:\n                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_size = os.path.getsize(saved_filename)\n            is_format = calibre_db.get_book_format(book_id, file_ext.upper())\n\n            # Format entry already exists, no need to update the database\n            if is_format:\n                log.warning('Book format %s already existing', file_ext.upper())\n            else:\n                try:\n                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)\n                    calibre_db.session.add(db_format)\n                    calibre_db.session.commit()\n                    calibre_db.update_title_sort(config)\n                except (OperationalError, IntegrityError) as e:\n                    calibre_db.session.rollback()\n                    log.error('Database error: %s', e)\n                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n\n            # Queue uploader info\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))\n            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)\n            WorkerThread.add(current_user.name, TaskUpload(uploadText))\n\n            return uploader.process(\n                saved_filename, *os.path.splitext(requested_file.filename),\n                rarExecutable=config.config_rarfile_location)\n\n\ndef upload_cover(request, book):\n    if 'btn-upload-cover' in request.files:\n        requested_file = request.files['btn-upload-cover']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            ret, message = helper.save_cover(requested_file, book.path)\n            if ret is True:\n                return True\n            else:\n                flash(message, category=\"error\")\n                return False\n    return None\n\n\ndef handle_title_on_edit(book, book_title):\n    # handle book title\n    book_title = book_title.rstrip().strip()\n    if book.title != book_title:\n        if book_title == '':\n            book_title = _(u'Unknown')\n        book.title = book_title\n        return True\n    return False\n\n\ndef handle_author_on_edit(book, author_name, update_stored=True):\n    # handle author(s)\n    input_authors = author_name.split('&')\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')\n\n    # Search for each author if author is in database, if not, author name and sorted author name is generated new\n    # everything then is assembled for sorted author field in database\n    sort_authors_list = list()\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            stored_author = helper.get_sorted_author(inp)\n        else:\n            stored_author = stored_author.sort\n        sort_authors_list.append(helper.get_sorted_author(stored_author))\n    sort_authors = ' & '.join(sort_authors_list)\n    if book.author_sort != sort_authors and update_stored:\n        book.author_sort = sort_authors\n        change = True\n    return input_authors, change\n\n\n@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_book(book_id):\n    modif_date = False\n\n    # create the function for sorting...\n    try:\n        calibre_db.update_title_sort(config)\n    except sqliteOperationalError as e:\n        log.debug_or_exception(e)\n        calibre_db.session.rollback()\n\n    # Show form\n    if request.method != 'POST':\n        return render_edit_book(book_id)\n\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n\n    # Book not found\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    meta = upload_single_file(request, book, book_id)\n    if upload_cover(request, book) is True:\n        book.has_cover = 1\n        modif_date = True\n    try:\n        to_save = request.form.to_dict()\n        merge_metadata(to_save, meta)\n        # Update book\n        edited_books_id = None\n\n        # handle book title\n        title_change = handle_title_on_edit(book, to_save[\"book_title\"])\n\n        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])\n        if authorchange or title_change:\n            edited_books_id = book.id\n            modif_date = True\n\n        if config.config_use_google_drive:\n            gdriveutils.updateGdriveCalibreFromLocal()\n\n        error = False\n        if edited_books_id:\n            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n\n        if not error:\n            if \"cover_url\" in to_save:\n                if to_save[\"cover_url\"]:\n                    if not current_user.role_upload():\n                        return \"\", (403)\n                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):\n                        book.has_cover = 0\n                    else:\n                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)\n                        if result is True:\n                            book.has_cover = 1\n                            modif_date = True\n                        else:\n                            flash(error, category=\"error\")\n\n            # Add default series_index to book\n            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)\n            # Handle book comments/description\n            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)\n            # Handle identifiers\n            input_identifiers = identifier_list(to_save, book)\n            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)\n            if warning:\n                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")\n            modif_date |= modification\n            # Handle book tags\n            modif_date |= edit_book_tags(to_save['tags'], book)\n            # Handle book series\n            modif_date |= edit_book_series(to_save[\"series\"], book)\n            # handle book publisher\n            modif_date |= edit_book_publisher(to_save['publisher'], book)\n            # handle book languages\n            modif_date |= edit_book_languages(to_save['languages'], book)\n            # handle book ratings\n            modif_date |= edit_book_ratings(to_save, book)\n            # handle cc data\n            modif_date |= edit_all_cc_data(book_id, book, to_save)\n\n            if to_save[\"pubdate\"]:\n                try:\n                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")\n                except ValueError:\n                    book.pubdate = db.Books.DEFAULT_PUBDATE\n            else:\n                book.pubdate = db.Books.DEFAULT_PUBDATE\n\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n                kobo_sync_status.remove_synced_book(edited_books_id)\n\n            calibre_db.session.merge(book)\n            calibre_db.session.commit()\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n            if \"detail_view\" in to_save:\n                return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_(\"Metadata successfully updated\"), category=\"success\")\n                return render_edit_book(book_id)\n        else:\n            calibre_db.session.rollback()\n            flash(error, category=\"error\")\n            return render_edit_book(book_id)\n    except ValueError as e:\n        calibre_db.session.rollback()\n        flash(str(e), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n    except Exception as ex:\n        log.debug_or_exception(ex)\n        calibre_db.session.rollback()\n        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n\n\ndef merge_metadata(to_save, meta):\n    if to_save['author_name'] == _(u'Unknown'):\n        to_save['author_name'] = ''\n    if to_save['book_title'] == _(u'Unknown'):\n        to_save['book_title'] = ''\n    for s_field, m_field in [\n            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),\n            ('series_index', 'series_id'), ('languages', 'languages'),\n            ('book_title', 'title')]:\n        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')\n    to_save[\"description\"] = to_save[\"description\"] or Markup(\n        getattr(meta, 'description', '')).unescape()\n\n\ndef identifier_list(to_save, book):\n    \"\"\"Generate a list of Identifiers from form information\"\"\"\n    id_type_prefix = 'identifier-type-'\n    id_val_prefix = 'identifier-val-'\n    result = []\n    for type_key, type_value in to_save.items():\n        if not type_key.startswith(id_type_prefix):\n            continue\n        val_key = id_val_prefix + type_key[len(id_type_prefix):]\n        if val_key not in to_save.keys():\n            continue\n        result.append(db.Identifiers(to_save[val_key], type_value, book.id))\n    return result\n\n\ndef prepare_authors_on_upload(title, authr):\n    if title != _(u'Unknown') and authr != _(u'Unknown'):\n        entry = calibre_db.check_exists_book(authr, title)\n        if entry:\n            log.info(\"Uploaded book probably exists in library\")\n            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")\n                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")\n\n    # handle authors\n    input_authors = authr.split('&')\n    # handle_authors(input_authors)\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    sort_authors_list = list()\n    db_author = None\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            if not db_author:\n                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")\n                calibre_db.session.add(db_author)\n                calibre_db.session.commit()\n            sort_author = helper.get_sorted_author(inp)\n        else:\n            if not db_author:\n                db_author = stored_author\n            sort_author = stored_author.sort\n        sort_authors_list.append(sort_author)\n    sort_authors = ' & '.join(sort_authors_list)\n    return sort_authors, input_authors, db_author\n\n\ndef create_book_on_upload(modif_date, meta):\n    title = meta.title\n    authr = meta.author\n    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)\n\n    title_dir = helper.get_valid_filename(title)\n    author_dir = helper.get_valid_filename(db_author.name)\n\n    # combine path and normalize path from windows systems\n    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')\n\n    # Calibre adds books with utc as timezone\n    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),\n                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")\n\n    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,\n                                         'author')\n\n    # Add series_index to book\n    modif_date |= edit_book_series_index(meta.series_id, db_book)\n\n    # add languages\n    invalid=[]\n    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)\n    if invalid:\n        for l in invalid:\n            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")\n\n    # handle tags\n    modif_date |= edit_book_tags(meta.tags, db_book)\n\n    # handle publisher\n    modif_date |= edit_book_publisher(meta.publisher, db_book)\n\n    # handle series\n    modif_date |= edit_book_series(meta.series, db_book)\n\n    # Add file to book\n    file_size = os.path.getsize(meta.file_path)\n    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)\n    db_book.data.append(db_data)\n    calibre_db.session.add(db_book)\n\n    # flush content, get db_book.id available\n    calibre_db.session.flush()\n    return db_book, input_authors, title_dir\n\ndef file_handling_on_upload(requested_file):\n    # check if file extension is correct\n    if '.' in requested_file.filename:\n        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n            flash(\n                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",\n                  ext=file_ext), category=\"error\")\n            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    else:\n        flash(_('File to be uploaded must have an extension'), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n    # extract metadata from file\n    try:\n        meta = uploader.upload(requested_file, config.config_rarfile_location)\n    except (IOError, OSError):\n        log.error(\"File %s could not saved to temp dir\", requested_file.filename)\n        flash(_(u\"File %(filename)s could not saved to temp dir\",\n                filename=requested_file.filename), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    return meta, None\n\n\ndef move_coverfile(meta, db_book):\n    # move cover to final directory, including book id\n    if meta.cover:\n        coverfile = meta.cover\n    else:\n        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')\n    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")\n    try:\n        copyfile(coverfile, new_coverpath)\n        if meta.cover:\n            os.unlink(meta.cover)\n    except OSError as e:\n        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)\n        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,\n                error=e),\n              category=\"error\")\n\n\n@editbook.route(\"/upload\", methods=[\"GET\", \"POST\"])\n@login_required_if_no_ano\n@upload_required\ndef upload():\n    if not config.config_uploading:\n        abort(404)\n    if request.method == 'POST' and 'btn-upload' in request.files:\n        for requested_file in request.files.getlist(\"btn-upload\"):\n            try:\n                modif_date = False\n                # create the function for sorting...\n                calibre_db.update_title_sort(config)\n                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))\n\n                meta, error = file_handling_on_upload(requested_file)\n                if error:\n                    return error\n\n                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)\n\n                # Comments needs book id therefore only possible after flush\n                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)\n\n                book_id = db_book.id\n                title = db_book.title\n\n                error = helper.update_dir_structure_file(book_id,\n                                                   config.config_calibre_dir,\n                                                   input_authors[0],\n                                                   meta.file_path,\n                                                   title_dir + meta.extension.lower())\n\n                move_coverfile(meta, db_book)\n\n                # save data to database, reread data\n                calibre_db.session.commit()\n\n                if config.config_use_google_drive:\n                    gdriveutils.updateGdriveCalibreFromLocal()\n                if error:\n                    flash(error, category=\"error\")\n                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))\n                uploadText = _(u\"File %(file)s uploaded\", file=link)\n                WorkerThread.add(current_user.name, TaskUpload(uploadText))\n\n                if len(request.files.getlist(\"btn-upload\")) < 2:\n                    if current_user.role_edit() or current_user.role_admin():\n                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n                    else:\n                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef convert_bookformat(book_id):\n    # check to see if we have form fields to work with -  if not send user back\n    book_format_from = request.form.get('book_format_from', None)\n    book_format_to = request.form.get('book_format_to', None)\n\n    if (book_format_from is None) or (book_format_to is None):\n        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")\n        return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)\n    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),\n                                     book_format_to.upper(), current_user.name)\n\n    if rtn is None:\n        flash(_(u\"Book successfully queued for converting to %(book_format)s\",\n                    book_format=book_format_to),\n                    category=\"success\")\n    else:\n        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")\n    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")\n@login_required\ndef table_get_custom_enum(c_id):\n    ret = list()\n    cc = (calibre_db.session.query(db.Custom_Columns)\n              .filter(db.Custom_Columns.id == c_id)\n              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())\n    ret.append({'value': \"\", 'text': \"\"})\n    for idx, en in enumerate(cc.get_display_dict()['enum_values']):\n        ret.append({'value': en, 'text': en})\n    return json.dumps(ret)\n\n\n@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_list_book(param):\n    vals = request.form.to_dict()\n    book = calibre_db.get_book(vals['pk'])\n    ret = \"\"\n    if param =='series_index':\n        edit_book_series_index(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')\n    elif param =='tags':\n        edit_book_tags(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),\n                       mimetype='application/json')\n    elif param =='series':\n        edit_book_series(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),\n                       mimetype='application/json')\n    elif param =='publishers':\n        edit_book_publisher(vals['value'], book)\n        ret =  Response(json.dumps({'success': True,\n                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),\n                       mimetype='application/json')\n    elif param =='languages':\n        invalid = list()\n        edit_book_languages(vals['value'], book, invalid=invalid)\n        if invalid:\n            ret = Response(json.dumps({'success': False,\n                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),\n                           mimetype='application/json')\n        else:\n            lang_names = list()\n            for lang in book.languages:\n                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))\n            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),\n                            mimetype='application/json')\n    elif param =='author_sort':\n        book.author_sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),\n                       mimetype='application/json')\n    elif param == 'title':\n        sort = book.sort\n        handle_title_on_edit(book, vals.get('value', \"\"))\n        helper.update_dir_stucture(book.id, config.config_calibre_dir)\n        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),\n                       mimetype='application/json')\n    elif param =='sort':\n        book.sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),\n                       mimetype='application/json')\n    elif param =='comments':\n        edit_book_comments(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),\n                       mimetype='application/json')\n    elif param =='authors':\n        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")\n        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])\n        ret = Response(json.dumps({'success': True,\n                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),\n                       mimetype='application/json')\n    elif param.startswith(\"custom_column_\"):\n        new_val = dict()\n        new_val[param] = vals['value']\n        edit_single_cc_data(book.id, book, param[14:], new_val)\n        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),\n                       mimetype='application/json')\n\n    book.last_modified = datetime.utcnow()\n    try:\n        calibre_db.session.commit()\n        # revert change for sort if automatic fields link is deactivated\n        if param == 'title' and vals.get('checkT') == \"false\":\n            book.sort = sort\n            calibre_db.session.commit()\n    except (OperationalError, IntegrityError) as e:\n        calibre_db.session.rollback()\n        log.error(\"Database error: %s\", e)\n    return ret\n\n\n@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")\n@login_required\ndef get_sorted_entry(field, bookid):\n    if field in ['title', 'authors', 'sort', 'author_sort']:\n        book = calibre_db.get_filtered_book(bookid)\n        if book:\n            if field == 'title':\n                return json.dumps({'sort': book.sort})\n            elif field == 'authors':\n                return json.dumps({'author_sort': book.author_sort})\n            if field == 'sort':\n                return json.dumps({'sort': book.title})\n            if field == 'author_sort':\n                return json.dumps({'author_sort': book.author})\n    return \"\"\n\n\n@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])\n@login_required\n@edit_required\ndef simulate_merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    if vals:\n        to_book = calibre_db.get_book(vals[0]).title\n        vals.pop(0)\n        if to_book:\n            for book_id in vals:\n                from_book = []\n                from_book.append(calibre_db.get_book(book_id).title)\n            return json.dumps({'to': to_book, 'from': from_book})\n    return \"\"\n\n\n@editbook.route(\"/ajax/mergebooks\", methods=['POST'])\n@login_required\n@edit_required\ndef merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    to_file = list()\n    if vals:\n        # load all formats from target book\n        to_book = calibre_db.get_book(vals[0])\n        vals.pop(0)\n        if to_book:\n            for file in to_book.data:\n                to_file.append(file.format)\n            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\\n                      helper.get_valid_filename(to_book.authors[0].name)\n            for book_id in vals:\n                from_book = calibre_db.get_book(book_id)\n                if from_book:\n                    for element in from_book.data:\n                        if element.format not in to_file:\n                            # create new data entry with: book_id, book_format, uncompressed_size, name\n                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         to_book.path,\n                                                                         to_name + \".\" + element.format.lower()))\n                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         from_book.path,\n                                                                         element.name + \".\" + element.format.lower()))\n                            copyfile(filepath_old, filepath_new)\n                            to_book.data.append(db.Data(to_book.id,\n                                                        element.format,\n                                                        element.uncompressed_size,\n                                                        to_name))\n                    delete_book_from_table(from_book.id,\"\", True)\n                    return json.dumps({'success': True})\n    return \"\"\n\n@editbook.route(\"/ajax/xchange\", methods=['POST'])\n@login_required\n@edit_required\ndef table_xchange_author_title():\n    vals = request.get_json().get('xchange')\n    if vals:\n        for val in vals:\n            modif_date = False\n            book = calibre_db.get_book(val)\n            authors = book.title\n            entries = calibre_db.order_authors(book)\n            author_names = []\n            for authr in entries.authors:\n                author_names.append(authr.name.replace('|', ','))\n\n            title_change = handle_title_on_edit(book, \" \".join(author_names))\n            input_authors, authorchange = handle_author_on_edit(book, authors)\n            if authorchange or title_change:\n                edited_books_id = book.id\n                modif_date = True\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n\n            if edited_books_id:\n                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            try:\n                calibre_db.session.commit()\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                return json.dumps({'success': False})\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n        return json.dumps({'success': True})\n    return \"\"\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 shavitmichael, OzzieIsaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\n\"\"\"This module is used to control authentication/authorization of Kobo sync requests.\nThis module also includes research notes into the auth protocol used by Kobo devices.\n\nLog-in:\nWhen first booting a Kobo device the user must sign into a Kobo (or affiliate) account.\nUpon successful sign-in, the user is redirected to\n    https://auth.kobobooks.com/CrossDomainSignIn?id=<some id>\nwhich serves the following response:\n    <script type='text/javascript'>\n        location.href='kobo://UserAuthenticated?userId=<redacted>&userKey<redacted>&email=<redacted>&returnUrl=https%3a%2f%2fwww.kobo.com';\n    </script>\nAnd triggers the insertion of a userKey into the device's User table.\n\nTogether, the device's DeviceId and UserKey act as an *irrevocable* authentication\ntoken to most (if not all) Kobo APIs. In fact, in most cases only the UserKey is\nrequired to authorize the API call.\n\nChanging Kobo password *does not* invalidate user keys! This is apparently a known\nissue for a few years now https://www.mobileread.com/forums/showpost.php?p=3476851&postcount=13\n(although this poster hypothesised that Kobo could blacklist a DeviceId, many endpoints\nwill still grant access given the userkey.)\n\nOfficial Kobo Store Api authorization:\n* For most of the endpoints we care about (sync, metadata, tags, etc), the userKey is\npassed in the x-kobo-userkey header, and is sufficient to authorize the API call.\n* Some endpoints (e.g: AnnotationService) instead make use of Bearer tokens pass through\nan authorization header. To get a BearerToken, the device makes a POST request to the\nv1/auth/device endpoint with the secret UserKey and the device's DeviceId.\n* The book download endpoint passes an auth token as a URL param instead of a header.\n\nOur implementation:\nWe pretty much ignore all of the above. To authenticate the user, we generate a random\nand unique token that they append to the CalibreWeb Url when setting up the api_store\nsetting on the device.\nThus, every request from the device to the api_store will hit CalibreWeb with the\nauth_token in the url (e.g: https://mylibrary.com/<auth_token>/v1/library/sync).\nIn addition, once authenticated we also set the login cookie on the response that will\nbe sent back for the duration of the session to authorize subsequent API calls (in\nparticular calls to non-Kobo specific endpoints such as the CalibreWeb book download).\n\"\"\"\n\nfrom binascii import hexlify\nfrom datetime import datetime\nfrom os import urandom\n\nfrom flask import g, Blueprint, url_for, abort, request\nfrom flask_login import login_user, current_user, login_required\nfrom flask_babel import gettext as _\n\nfrom . import logger, config, calibre_db, db, helper, ub, lm\nfrom .render_template import render_title_template\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\n\nlog = logger.create()\n\n\ndef register_url_value_preprocessor(kobo):\n    @kobo.url_value_preprocessor\n    # pylint: disable=unused-variable\n    def pop_auth_token(__, values):\n        g.auth_token = values.pop(\"auth_token\")\n\n\ndef disable_failed_auth_redirect_for_blueprint(bp):\n    lm.blueprint_login_views[bp.name] = None\n\n\ndef get_auth_token():\n    if \"auth_token\" in g:\n        return g.get(\"auth_token\")\n    else:\n        return None\n\n\ndef requires_kobo_auth(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        auth_token = get_auth_token()\n        if auth_token is not None:\n            user = (\n                ub.session.query(ub.User)\n                .join(ub.RemoteAuthToken)\n                .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)\n                .first()\n            )\n            if user is not None:\n                login_user(user)\n                return f(*args, **kwargs)\n            log.debug(\"Received Kobo request without a recognizable auth token.\")\n            return abort(401)\n    return inner\n\n\nkobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")\n\n\n@kobo_auth.route(\"/generate_auth_token/<int:user_id>\")\n@login_required\ndef generate_auth_token(user_id):\n    host_list = request.host.rsplit(':')\n    if len(host_list) == 1:\n        host = ':'.join(host_list)\n    else:\n        host = ':'.join(host_list[0:-1])\n    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):\n        warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')\n        return render_title_template(\n            \"generate_kobo_auth_url.html\",\n            title=_(u\"Kobo Setup\"),\n            warning = warning\n        )\n    else:\n        # Invalidate any prevously generated Kobo Auth token for this user.\n        auth_token = ub.session.query(ub.RemoteAuthToken).filter(\n            ub.RemoteAuthToken.user_id == user_id\n        ).filter(ub.RemoteAuthToken.token_type==1).first()\n\n        if not auth_token:\n            auth_token = ub.RemoteAuthToken()\n            auth_token.user_id = user_id\n            auth_token.expiration = datetime.max\n            auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")\n            auth_token.token_type = 1\n\n            ub.session.add(auth_token)\n            ub.session_commit()\n\n        books = calibre_db.session.query(db.Books).join(db.Data).all()\n\n        for book in books:\n            formats = [data.format for data in book.data]\n            if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:\n                helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)\n\n        return render_title_template(\n            \"generate_kobo_auth_url.html\",\n            title=_(u\"Kobo Setup\"),\n            kobo_auth_url=url_for(\n                \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True\n            ),\n            warning = False\n        )\n\n\n@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\")\n@login_required\ndef delete_auth_token(user_id):\n    # Invalidate any prevously generated Kobo Auth token for this user.\n    ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\\n        .filter(ub.RemoteAuthToken.token_type==1).delete()\n\n    return ub.session_commit()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nfrom datetime import datetime\n\nfrom flask import Blueprint, flash, redirect, request, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import func, true\n\nfrom . import calibre_db, config, db, logger, ub\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\nshelf = Blueprint('shelf', __name__)\nlog = logger.create()\n\n\ndef check_shelf_edit_permissions(cur_shelf):\n    if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):\n        log.error(\"User %s not allowed to edit shelf %s\", current_user, cur_shelf)\n        return False\n    if cur_shelf.is_public and not current_user.role_edit_shelfs():\n        log.info(\"User %s not allowed to edit public shelves\", current_user)\n        return False\n    return True\n\n\ndef check_shelf_view_permissions(cur_shelf):\n    if cur_shelf.is_public:\n        return True\n    if current_user.is_anonymous or cur_shelf.user_id != current_user.id:\n        log.error(\"User is unauthorized to view non-public shelf: %s\", cur_shelf)\n        return False\n    return True\n\n\n@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\")\n@login_required\ndef add_to_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        if not xhr:\n            flash(_(u\"Invalid shelf specified\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    if not check_shelf_edit_permissions(shelf):\n        if not xhr:\n            flash(_(u\"Sorry you are not allowed to add a book to that shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to add a book to the that shelf\", 403\n\n    book_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                          ub.BookShelf.book_id == book_id).first()\n    if book_in_shelf:\n        log.error(\"Book %s is already part of %s\", book_id, shelf)\n        if not xhr:\n            flash(_(u\"Book is already part of the shelf: %(shelfname)s\", shelfname=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Book is already part of the shelf: %s\" % shelf.name, 400\n\n    maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()\n    if maxOrder[0] is None:\n        maxOrder = 0\n    else:\n        maxOrder = maxOrder[0]\n\n    shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book_id, order=maxOrder + 1))\n    shelf.last_modified = datetime.utcnow()\n    try:\n        ub.session.merge(shelf)\n        ub.session.commit()\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(u\"Settings DB is not Writeable\"), category=\"error\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    if not xhr:\n        log.debug(\"Book has been added to shelf: {}\".format(shelf.name))\n        flash(_(u\"Book has been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    return \"\", 204\n\n\n@shelf.route(\"/shelf/massadd/<int:shelf_id>\")\n@login_required\ndef search_to_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        flash(_(u\"Invalid shelf specified\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if not check_shelf_edit_permissions(shelf):\n        log.warning(\"You are not allowed to add a book to the shelf\".format(shelf.name))\n        flash(_(u\"You are not allowed to add a book to the shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if current_user.id in ub.searched_ids and ub.searched_ids[current_user.id]:\n        books_for_shelf = list()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).all()\n        if books_in_shelf:\n            book_ids = list()\n            for book_id in books_in_shelf:\n                book_ids.append(book_id.book_id)\n            for searchid in ub.searched_ids[current_user.id]:\n                if searchid not in book_ids:\n                    books_for_shelf.append(searchid)\n        else:\n            books_for_shelf = ub.searched_ids[current_user.id]\n\n        if not books_for_shelf:\n            log.error(\"Books are already part of {}\".format(shelf.name))\n            flash(_(u\"Books are already part of the shelf: %(name)s\", name=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n\n        maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()[0] or 0\n\n        for book in books_for_shelf:\n            maxOrder += 1\n            shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book, order=maxOrder))\n        shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.merge(shelf)\n            ub.session.commit()\n            flash(_(u\"Books have been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    else:\n        log.error(\"Could not add books to shelf: {}\".format(shelf.name))\n        flash(_(u\"Could not add books to shelf: %(sname)s\", sname=shelf.name), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\")\n@login_required\ndef remove_from_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: {}\".format(shelf_id))\n        if not xhr:\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    # if shelf is public and use is allowed to edit shelfs, or if shelf is private and user is owner\n    # allow editing shelfs\n    # result   shelf public   user allowed    user owner\n    #   false        1             0             x\n    #   true         1             1             x\n    #   true         0             x             1\n    #   false        0             x             0\n\n    if check_shelf_edit_permissions(shelf):\n        book_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                           ub.BookShelf.book_id == book_id).first()\n\n        if book_shelf is None:\n            log.error(\"Book %s already removed from %s\", book_id, shelf)\n            if not xhr:\n                return redirect(url_for('web.index'))\n            return \"Book already removed from shelf\", 410\n\n        try:\n            ub.session.delete(book_shelf)\n            shelf.last_modified = datetime.utcnow()\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        if not xhr:\n            flash(_(u\"Book has been removed from shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        return \"\", 204\n    else:\n        if not xhr:\n            log.warning(\"You are not allowed to remove a book from shelf: {}\".format(shelf.name))\n            flash(_(u\"Sorry you are not allowed to remove a book from this shelf\"),\n                  category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to remove a book from this shelf\", 403\n\n\n@shelf.route(\"/shelf/create\", methods=[\"GET\", \"POST\"])\n@login_required\ndef create_shelf():\n    shelf = ub.Shelf()\n    return create_edit_shelf(shelf, page_title=_(u\"Create a Shelf\"), page=\"shelfcreate\")\n\n\n\n@shelf.route(\"/shelf/edit/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if not check_shelf_edit_permissions(shelf):\n        flash(_(u\"Sorry you are not allowed to edit this shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n    return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)\n\n\n# if shelf ID is set, we are editing a shelf\ndef create_edit_shelf(shelf, page_title, page, shelf_id=False):\n    sync_only_selected_shelves = current_user.kobo_only_shelves_sync\n    # calibre_db.session.query(ub.Shelf).filter(ub.Shelf.user_id == current_user.id).filter(ub.Shelf.kobo_sync).count()\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        if not current_user.role_edit_shelfs() and to_save.get(\"is_public\") == \"on\":\n            flash(_(u\"Sorry you are not allowed to create a public shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        shelf.is_public = 1 if to_save.get(\"is_public\") else 0\n        if config.config_kobo_sync:\n            shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False\n        shelf_title = to_save.get(\"title\", \"\")\n        if check_shelf_is_unique(shelf, shelf_title, shelf_id):\n            shelf.name = shelf_title\n            if not shelf_id:\n                shelf.user_id = int(current_user.id)\n                ub.session.add(shelf)\n                shelf_action = \"created\"\n                flash_text = _(u\"Shelf %(title)s created\", title=shelf_title)\n            else:\n                shelf_action = \"changed\"\n                flash_text = _(u\"Shelf %(title)s changed\", title=shelf_title)\n            try:\n                ub.session.commit()\n                log.info(u\"Shelf {} {}\".format(shelf_title, shelf_action))\n                flash(flash_text, category=\"success\")\n                return redirect(url_for('shelf.show_shelf', shelf_id=shelf.id))\n            except (OperationalError, InvalidRequestError) as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            except Exception as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                flash(_(u\"There was an error\"), category=\"error\")\n    return render_title_template('shelf_edit.html',\n                                 shelf=shelf,\n                                 title=page_title,\n                                 page=page,\n                                 kobo_sync_enabled=config.config_kobo_sync,\n                                 sync_only_selected_shelves=sync_only_selected_shelves)\n\n\ndef check_shelf_is_unique(shelf, title, shelf_id=False):\n    if shelf_id:\n        ident = ub.Shelf.id != shelf_id\n    else:\n        ident = true()\n    if shelf.is_public == 1:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 1)) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A public shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A public shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    else:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 0) &\n                                           (ub.Shelf.user_id == int(current_user.id))) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A private shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A private shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    return is_shelf_name_unique\n\n\ndef delete_shelf_helper(cur_shelf):\n    if not cur_shelf or not check_shelf_edit_permissions(cur_shelf):\n        return\n    shelf_id = cur_shelf.id\n    ub.session.delete(cur_shelf)\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).delete()\n    ub.session.add(ub.ShelfArchive(uuid=cur_shelf.uuid, user_id=cur_shelf.user_id))\n    ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))\n\n\n@shelf.route(\"/shelf/delete/<int:shelf_id>\")\n@login_required\ndef delete_shelf(shelf_id):\n    cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    try:\n        delete_shelf_helper(cur_shelf)\n    except InvalidRequestError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/simpleshelf/<int:shelf_id>\")\n@login_required_if_no_ano\ndef show_simpleshelf(shelf_id):\n    return render_show_shelf(2, shelf_id, 1, None)\n\n\n@shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")\n@login_required_if_no_ano\ndef show_shelf(shelf_id, sort_param, page):\n    return render_show_shelf(1, shelf_id, page, sort_param)\n\n\n@shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef order_shelf(shelf_id):\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(\n            ub.BookShelf.order.asc()).all()\n        counter = 0\n        for book in books_in_shelf:\n            setattr(book, 'order', to_save[str(book.book_id)])\n            counter += 1\n            # if order diffrent from before -> shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    result = list()\n    if shelf and check_shelf_view_permissions(shelf):\n        result = calibre_db.session.query(db.Books) \\\n            .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .add_columns(calibre_db.common_filters().label(\"visible\")) \\\n            .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()\n    return render_title_template('shelf_order.html', entries=result,\n                                 title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),\n                                 shelf=shelf, page=\"shelforder\")\n\n\ndef change_shelf_order(shelf_id, order):\n    result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,\n                                                          db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series).join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id) \\\n        .filter(ub.BookShelf.shelf == shelf_id).order_by(*order).all()\n    for index, entry in enumerate(result):\n        book = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id) \\\n            .filter(ub.BookShelf.book_id == entry.id).first()\n        book.order = index\n    ub.session_commit(\"Shelf-id:{} - Order changed\".format(shelf_id))\n\n\ndef render_show_shelf(shelf_type, shelf_id, page_no, sort_param):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n\n    # check user is allowed to access shelf\n    if shelf and check_shelf_view_permissions(shelf):\n\n        if shelf_type == 1:\n            # order = [ub.BookShelf.order.asc()]\n            if sort_param == 'pubnew':\n                change_shelf_order(shelf_id, [db.Books.pubdate.desc()])\n            if sort_param == 'pubold':\n                change_shelf_order(shelf_id, [db.Books.pubdate])\n            if sort_param == 'abc':\n                change_shelf_order(shelf_id, [db.Books.sort])\n            if sort_param == 'zyx':\n                change_shelf_order(shelf_id, [db.Books.sort.desc()])\n            if sort_param == 'new':\n                change_shelf_order(shelf_id, [db.Books.timestamp.desc()])\n            if sort_param == 'old':\n                change_shelf_order(shelf_id, [db.Books.timestamp])\n            if sort_param == 'authaz':\n                change_shelf_order(shelf_id, [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index])\n            if sort_param == 'authza':\n                change_shelf_order(shelf_id, [db.Books.author_sort.desc(),\n                                              db.Series.name.desc(),\n                                              db.Books.series_index.desc()])\n            page = \"shelf.html\"\n            pagesize = 0\n        else:\n            pagesize = sys.maxsize\n            page = 'shelfdown.html'\n\n        result, __, pagination = calibre_db.fill_indexpage(page_no, pagesize,\n                                                           db.Books,\n                                                           ub.BookShelf.shelf == shelf_id,\n                                                           [ub.BookShelf.order.asc()],\n                                                           ub.BookShelf, ub.BookShelf.book_id == db.Books.id)\n        # delete chelf entries where book is not existent anymore, can happen if book is deleted outside calibre-web\n        wrong_entries = calibre_db.session.query(ub.BookShelf) \\\n            .join(db.Books, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .filter(db.Books.id == None).all()\n        for entry in wrong_entries:\n            log.info('Not existing book {} in {} deleted'.format(entry.book_id, shelf))\n            try:\n                ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == entry.book_id).delete()\n                ub.session.commit()\n            except (OperationalError, InvalidRequestError):\n                ub.session.rollback()\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n        return render_title_template(page,\n                                     entries=result,\n                                     pagination=pagination,\n                                     title=_(u\"Shelf: '%(name)s'\", name=shelf.name),\n                                     shelf=shelf,\n                                     page=\"shelf\")\n    else:\n        flash(_(u\"Error opening shelf. Shelf does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n", "/* This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n *    Copyright (C) 2012-2019  mutschler, janeczku, jkrehm, OzzieIsaacs\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nfunction getPath() {\n    var jsFileLocation = $(\"script[src*=jquery]\").attr(\"src\");  // the js file path\n    return jsFileLocation.substr(0, jsFileLocation.search(\"/static/js/libs/jquery.min.js\"));  // the js folder path\n}\n\nfunction elementSorter(a, b) {\n    a = +a.slice(0, -2);\n    b = +b.slice(0, -2);\n    if (a > b) return 1;\n    if (a < b) return -1;\n    return 0;\n}\n\n// Generic control/related handler to show/hide fields based on a checkbox' value\n// e.g.\n//  <input type=\"checkbox\" data-control=\"stuff-to-show\">\n//  <div data-related=\"stuff-to-show\">...</div>\n$(document).on(\"change\", \"input[type=\\\"checkbox\\\"][data-control]\", function () {\n    var $this = $(this);\n    var name = $this.data(\"control\");\n    var showOrHide = $this.prop(\"checked\");\n\n    $(\"[data-related=\\\"\" + name + \"\\\"]\").each(function () {\n        $(this).toggle(showOrHide);\n    });\n});\n\n// Generic control/related handler to show/hide fields based on a select' value\n$(document).on(\"change\", \"select[data-control]\", function() {\n    var $this = $(this);\n    var name = $this.data(\"control\");\n    var showOrHide = parseInt($this.val(), 10);\n    // var showOrHideLast = $(\"#\" + name + \" option:last\").val()\n    for (var i = 0; i < $(this)[0].length; i++) {\n        var element = parseInt($(this)[0][i].value, 10);\n        if (element === showOrHide) {\n            $(\"[data-related^=\" + name + \"][data-related*=-\" + element + \"]\").show();\n        } else {\n            $(\"[data-related^=\" + name + \"][data-related*=-\" + element + \"]\").hide();\n        }\n    }\n});\n\n// Generic control/related handler to show/hide fields based on a select' value\n// this one is made to show all values if select value is not 0\n$(document).on(\"change\", \"select[data-controlall]\", function() {\n    var $this = $(this);\n    var name = $this.data(\"controlall\");\n    var showOrHide = parseInt($this.val(), 10);\n    if (showOrHide) {\n        $(\"[data-related=\" + name + \"]\").show();\n    } else {\n        $(\"[data-related=\" + name + \"]\").hide();\n    }\n});\n\n// Syntax has to be bind not on, otherwise problems with firefox\n$(\".container-fluid\").bind(\"dragenter dragover\", function () {\n    if($(\"#btn-upload\").length && !$('body').hasClass('shelforder')) {\n        $(this).css('background', '#e6e6e6');\n    }\n    return false;\n});\n\n// Syntax has to be bind not on, otherwise problems with firefox\n$(\".container-fluid\").bind(\"dragleave\", function () {\n    if($(\"#btn-upload\").length && !$('body').hasClass('shelforder')) {\n        $(this).css('background', '');\n    }\n    return false;\n});\n\n// Syntax has to be bind not on, otherwise problems with firefox\n$(\".container-fluid\").bind('drop', function (e) {\n    e.preventDefault()\n    e.stopPropagation();\n    if($(\"#btn-upload\").length) {\n        var files = e.originalEvent.dataTransfer.files;\n        var test = $(\"#btn-upload\")[0].accept;\n        $(this).css('background', '');\n        const dt = new DataTransfer();\n        jQuery.each(files, function (index, item) {\n            if (test.indexOf(item.name.substr(item.name.lastIndexOf('.'))) !== -1) {\n                dt.items.add(item);\n            }\n        });\n        if (dt.files.length) {\n            $(\"#btn-upload\")[0].files = dt.files;\n            $(\"#form-upload\").submit();\n        }\n    }\n});\n\n$(\"#btn-upload\").change(function() {\n    $(\"#form-upload\").submit();\n});\n\n$(\"#form-upload\").uploadprogress({\n    redirect_url: getPath() + \"/\", //\"{{ url_for('web.index')}}\",\n    uploadedMsg: $(\"#form-upload\").data(\"message\"), //\"{{_('Upload done, processing, please wait...')}}\",\n    modalTitle: $(\"#form-upload\").data(\"title\"), //\"{{_('Uploading...')}}\",\n    modalFooter: $(\"#form-upload\").data(\"footer\"), //\"{{_('Close')}}\",\n    modalTitleFailed: $(\"#form-upload\").data(\"failed\") //\"{{_('Error')}}\"\n});\n\n$(document).ready(function() {\n  var inp = $('#query').first()\n  if (inp.length) {\n    var val = inp.val()\n    if (val.length) {\n      inp.val('').blur().focus().val(val)\n    }\n  }\n});\n\n$(\".session\").click(function() {\n    window.sessionStorage.setItem(\"back\", window.location.pathname);\n});\n\n$(\"#back\").click(function() {\n   var loc = sessionStorage.getItem(\"back\");\n   if (!loc) {\n       loc = $(this).data(\"back\");\n   }\n   sessionStorage.removeItem(\"back\");\n   window.location.href = loc;\n\n});\n\nfunction confirmDialog(id, dialogid, dataValue, yesFn, noFn) {\n    var $confirm = $(\"#\" + dialogid);\n    $(\"#btnConfirmYes-\"+ dialogid).off('click').click(function () {\n        yesFn(dataValue);\n        $confirm.modal(\"hide\");\n    });\n    $(\"#btnConfirmNo-\"+ dialogid).off('click').click(function () {\n        if (typeof noFn !== 'undefined') {\n            noFn(dataValue);\n        }\n        $confirm.modal(\"hide\");\n    });\n    $.ajax({\n        method:\"post\",\n        dataType: \"json\",\n        url: getPath() + \"/ajax/loaddialogtexts/\" + id,\n        success: function success(data) {\n            $(\"#header-\"+ dialogid).html(data.header);\n            $(\"#text-\"+ dialogid).html(data.main);\n        }\n    });\n    $confirm.modal('show');\n}\n\n$(\"#delete_confirm\").click(function() {\n    //get data-id attribute of the clicked element\n    var deleteId = $(this).data(\"delete-id\");\n    var bookFormat = $(this).data(\"delete-format\");\n    var ajaxResponse = $(this).data(\"ajax\");\n    if (bookFormat) {\n        window.location.href = getPath() + \"/delete/\" + deleteId + \"/\" + bookFormat;\n    } else {\n        if (ajaxResponse) {\n            path = getPath() + \"/ajax/delete/\" + deleteId;\n            $.ajax({\n                method:\"get\",\n                url: path,\n                timeout: 900,\n                success:function(data) {\n                    data.forEach(function(item) {\n                        if (!jQuery.isEmptyObject(item)) {\n                            if (item.format != \"\") {\n                                $(\"button[data-delete-format='\"+item.format+\"']\").addClass('hidden');\n                            }\n                            $( \".navbar\" ).after( '<div class=\"row-fluid text-center\" >' +\n                                '<div id=\"flash_'+item.type+'\" class=\"alert alert-'+item.type+'\">'+item.message+'</div>' +\n                                '</div>');\n\n                        }\n                    });\n                    $(\"#books-table\").bootstrapTable(\"refresh\");\n                }\n            });\n        } else {\n            window.location.href = getPath() + \"/delete/\" + deleteId;\n\n        }\n    }\n\n});\n\n//triggered when modal is about to be shown\n$(\"#deleteModal\").on(\"show.bs.modal\", function(e) {\n    //get data-id attribute of the clicked element and store in button\n    var bookId = $(e.relatedTarget).data(\"delete-id\");\n    var bookfomat = $(e.relatedTarget).data(\"delete-format\");\n    if (bookfomat) {\n        $(\"#book_format\").removeClass('hidden');\n        $(\"#book_complete\").addClass('hidden');\n    } else {\n        $(\"#book_complete\").removeClass('hidden');\n        $(\"#book_format\").addClass('hidden');\n    }\n    $(e.currentTarget).find(\"#delete_confirm\").data(\"delete-id\", bookId);\n    $(e.currentTarget).find(\"#delete_confirm\").data(\"delete-format\", bookfomat);\n    $(e.currentTarget).find(\"#delete_confirm\").data(\"ajax\", $(e.relatedTarget).data(\"ajax\"));\n});\n\n$(function() {\n    var updateTimerID;\n    var updateText;\n\n    // Allow ajax prefilters to be added/removed dynamically\n    // eslint-disable-next-line new-cap\n    var preFilters = $.Callbacks();\n    $.ajaxPrefilter(preFilters.fire);\n\n    // equip all post requests with csrf_token\n    var csrftoken = $(\"input[name='csrf_token']\").val();\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrftoken)\n            }\n        }\n    });\n\n    function restartTimer() {\n        $(\"#spinner\").addClass(\"hidden\");\n        $(\"#RestartDialog\").modal(\"hide\");\n    }\n\n    function cleanUp() {\n        clearInterval(updateTimerID);\n        $(\"#spinner2\").hide();\n        $(\"#DialogFinished\").removeClass(\"hidden\");\n        $(\"#check_for_update\").removeClass(\"hidden\");\n        $(\"#perform_update\").addClass(\"hidden\");\n        $(\"#message\").alert(\"close\");\n        $(\"#update_table > tbody > tr\").each(function () {\n            if ($(this).attr(\"id\") !== \"current_version\") {\n                $(this).closest(\"tr\").remove();\n            }\n        });\n    }\n\n    function updateTimer() {\n        var no_response = 0;\n        $.ajax({\n            dataType: \"json\",\n            url: getPath() + \"/get_updater_status\",\n            success: function success(data) {\n                $(\"#DialogContent\").html(updateText[data.status]);\n                if (data.status > 6) {\n                    cleanUp();\n                }\n            },\n            error: function error() {\n                // Server has to restart in 60 Sek. otherwise output error message\n                no_response += 1;\n                if (no_response > 30) {\n                    $(\"#DialogContent\").html(updateText[11]);\n                    cleanUp();\n                }\n            },\n            timeout: 2000\n        });\n    }\n\n    function fillFileTable(path, type, folder, filt) {\n        var request_path = \"/../../ajax/pathchooser/\";\n        $.ajax({\n            dataType: \"json\",\n            data: {\n                path: path,\n                folder: folder,\n                filter: filt\n            },\n            url: window.location.pathname + request_path,\n            success: function success(data) {\n                if ($(\"#element_selected\").text() ===\"\") {\n                    $(\"#element_selected\").text(data.cwd);\n                }\n                $(\"#file_table > tbody > tr\").each(function () {\n                    if ($(this).attr(\"id\") !== \"parent\") {\n                        $(this).closest(\"tr\").remove();\n                    } else {\n                        if(data.absolute && data.parentdir !== \"\") {\n                           $(this)[0].attributes['data-path'].value  = data.parentdir;\n                        } else {\n                            $(this)[0].attributes['data-path'].value  = \"..\";\n                        }\n                    }\n                });\n                if (data.parentdir !== \"\") {\n                    $(\"#parent\").removeClass('hidden')\n                } else {\n                    $(\"#parent\").addClass('hidden')\n                }\n                // console.log(data);\n                data.files.forEach(function(entry) {\n                    if(entry.type === \"dir\") {\n                        var type = \"<span class=\\\"glyphicon glyphicon-folder-close\\\"></span>\";\n                } else {\n                    var type = \"\";\n                }\n                    $(\"<tr class=\\\"tr-clickable\\\" data-type=\\\"\" + entry.type + \"\\\" data-path=\\\"\" +\n                        entry.fullpath + \"\\\"><td>\" + type + \"</td><td>\" + entry.name + \"</td><td>\" +\n                        entry.size + \"</td></tr>\").appendTo($(\"#file_table\"));\n                });\n            },\n            timeout: 2000\n        });\n    }\n\n    $(\".discover .row\").isotope({\n        // options\n        itemSelector : \".book\",\n        layoutMode : \"fitRows\"\n    });\n\n    $(\".grid\").isotope({\n        // options\n        itemSelector : \".grid-item\",\n        layoutMode : \"fitColumns\"\n    });\n\n    if ($(\".load-more\").length && $(\".next\").length) {\n        var $loadMore = $(\".load-more .row\").infiniteScroll({\n            debug: false,\n            // selector for the paged navigation (it will be hidden)\n            path : \".next\",\n            // selector for the NEXT link (to page 2)\n            append : \".load-more .book\"\n            //animate      : true, # ToDo: Reenable function\n            //extraScrollPx: 300\n        });\n        $loadMore.on( \"append.infiniteScroll\", function( event, response, path, data ) {\n            if ($(\"body\").hasClass(\"blur\")) {\n                $(\".pagination\").addClass(\"hidden\").html(() => $(response).find(\".pagination\").html());\n                $(\" a:not(.dropdown-toggle) \")\n                  .removeAttr(\"data-toggle\");\n            }\n            $(\".load-more .row\").isotope( \"appended\", $(data), null );\n        });\n\n        // fix for infinite scroll on CaliBlur Theme (#981)\n        if ($(\"body\").hasClass(\"blur\")) {\n            $(\".col-sm-10\").bind(\"scroll\", function () {\n                if (\n                    $(this).scrollTop() + $(this).innerHeight() >=\n                    $(this)[0].scrollHeight\n                ) {\n                    $loadMore.infiniteScroll(\"loadNextPage\");\n                    window.history.replaceState({}, null, $loadMore.infiniteScroll(\"getAbsolutePath\"));\n                }\n            });\n        }\n    }\n\n    $(\"#restart\").click(function() {\n        $.ajax({\n            dataType: \"json\",\n            url: window.location.pathname + \"/../../shutdown\",\n            data: {\"parameter\":0},\n            success: function success() {\n                $(\"#spinner\").show();\n                setTimeout(restartTimer, 3000);\n            }\n        });\n    });\n    $(\"#shutdown\").click(function() {\n        $.ajax({\n            dataType: \"json\",\n            url: window.location.pathname + \"/../../shutdown\",\n            data: {\"parameter\":1},\n            success: function success(data) {\n                return alert(data.text);\n            }\n        });\n    });\n    $(\"#check_for_update\").click(function() {\n        var $this = $(this);\n        var buttonText = $this.html();\n        $this.html(\"...\");\n        $(\"#DialogContent\").html(\"\");\n        $(\"#DialogFinished\").addClass(\"hidden\");\n        $(\"#update_error\").addClass(\"hidden\");\n        if ($(\"#message\").length) {\n            $(\"#message\").alert(\"close\");\n        }\n        $.ajax({\n            dataType: \"json\",\n            url: window.location.pathname + \"/../../get_update_status\",\n            success: function success(data) {\n                $this.html(buttonText);\n\n                var cssClass = \"\";\n                var message = \"\";\n\n                if (data.success === true) {\n                    if (data.update === true) {\n                        $(\"#check_for_update\").addClass(\"hidden\");\n                        $(\"#perform_update\").removeClass(\"hidden\");\n                        $(\"#update_info\")\n                            .removeClass(\"hidden\")\n                            .find(\"span\").html(data.commit);\n\n                        data.history.forEach(function(entry) {\n                            $(\"<tr><td>\" + entry[0] + \"</td><td>\" + entry[1] + \"</td></tr>\").appendTo($(\"#update_table\"));\n                        });\n                        cssClass = \"alert-warning\";\n                    } else {\n                        cssClass = \"alert-success\";\n                    }\n                } else {\n                    cssClass = \"alert-danger\";\n                }\n\n                message = \"<div id=\\\"message\\\" class=\\\"alert \" + cssClass\n                    + \" fade in\\\"><a href=\\\"#\\\" class=\\\"close\\\" data-dismiss=\\\"alert\\\">&times;</a>\"\n                    + data.message + \"</div>\";\n\n                $(message).insertAfter($(\"#update_table\"));\n            }\n        });\n    });\n    $(\"#restart_database\").click(function() {\n        $(\"#DialogHeader\").addClass(\"hidden\");\n        $(\"#DialogFinished\").addClass(\"hidden\");\n        $(\"#DialogContent\").html(\"\");\n        $(\"#spinner2\").show();\n        $.ajax({\n            dataType: \"json\",\n            url: getPath() + \"/shutdown\",\n            data: {\"parameter\":2},\n            success: function success(data) {\n                $(\"#spinner2\").hide();\n                $(\"#DialogContent\").html(data.text);\n                $(\"#DialogFinished\").removeClass(\"hidden\");\n            }\n        });\n    });\n    $(\"#perform_update\").click(function() {\n        $(\"#DialogHeader\").removeClass(\"hidden\");\n        $(\"#spinner2\").show();\n        $.ajax({\n            type: \"POST\",\n            dataType: \"json\",\n            data: { start: \"True\" },\n            url: getPath() + \"/get_updater_status\",\n            success: function success(data) {\n                updateText = data.text;\n                $(\"#DialogContent\").html(updateText[data.status]);\n                updateTimerID = setInterval(updateTimer, 2000);\n            }\n        });\n    });\n\n    // Init all data control handlers to default\n    $(\"input[data-control]\").trigger(\"change\");\n    $(\"select[data-control]\").trigger(\"change\");\n    $(\"select[data-controlall]\").trigger(\"change\");\n\n    $(\"#bookDetailsModal\")\n        .on(\"show.bs.modal\", function(e) {\n            var $modalBody = $(this).find(\".modal-body\");\n\n            // Prevent static assets from loading multiple times\n            var useCache = function(options) {\n                options.async = true;\n                options.cache = true;\n            };\n            preFilters.add(useCache);\n\n            $.get(e.relatedTarget.href).done(function(content) {\n                $modalBody.html(content);\n                preFilters.remove(useCache);\n            });\n        })\n        .on(\"hidden.bs.modal\", function() {\n            $(this).find(\".modal-body\").html(\"...\");\n        });\n\n    $(\"#modal_kobo_token\")\n        .on(\"show.bs.modal\", function(e) {\n            var $modalBody = $(this).find(\".modal-body\");\n\n            // Prevent static assets from loading multiple times\n            var useCache = function(options) {\n                options.async = true;\n                options.cache = true;\n            };\n            preFilters.add(useCache);\n\n            $.get(e.relatedTarget.href).done(function(content) {\n                $modalBody.html(content);\n                preFilters.remove(useCache);\n            });\n        })\n        .on(\"hidden.bs.modal\", function() {\n            $(this).find(\".modal-body\").html(\"...\");\n            $(\"#config_delete_kobo_token\").show();\n            $(\"#kobo_full_sync\").show();\n        });\n\n    $(\"#config_delete_kobo_token\").click(function() {\n        confirmDialog(\n            $(this).attr('id'),\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function (value) {\n                $.ajax({\n                    method: \"get\",\n                    url: getPath() + \"/kobo_auth/deleteauthtoken/\" + value,\n                });\n                $(\"#config_delete_kobo_token\").hide();\n                $(\"#kobo_full_sync\").hide();\n            }\n        );\n    });\n\n    $(\"#toggle_order_shelf\").click(function() {\n        $(\"#new\").toggleClass(\"disabled\");\n        $(\"#old\").toggleClass(\"disabled\");\n        $(\"#asc\").toggleClass(\"disabled\");\n        $(\"#desc\").toggleClass(\"disabled\");\n        $(\"#auth_az\").toggleClass(\"disabled\");\n        $(\"#auth_za\").toggleClass(\"disabled\");\n        $(\"#pub_new\").toggleClass(\"disabled\");\n        $(\"#pub_old\").toggleClass(\"disabled\");\n        var alternative_text = $(\"#toggle_order_shelf\").data('alt-text');\n        $(\"#toggle_order_shelf\").data('alt-text', $(\"#toggle_order_shelf\").html());\n        $(\"#toggle_order_shelf\").html(alternative_text);\n    });\n\n    $(\"#btndeluser\").click(function() {\n        confirmDialog(\n            $(this).attr('id'),\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function(value){\n                var subform = $('#user_submit').closest(\"form\");\n                subform.submit(function(eventObj) {\n                    $(this).append('<input type=\"hidden\" name=\"delete\" value=\"True\" />');\n                    return true;\n                });\n                subform.submit();\n            }\n        );\n    });\n\n    $(\"#kobo_full_sync\").click(function() {\n        confirmDialog(\n           \"btnfullsync\",\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function(value){\n                path = getPath() + \"/ajax/fullsync\"\n                $.ajax({\n                    method:\"get\",\n                    url: path,\n                    timeout: 900,\n                    success:function(data) {\n                        data.forEach(function(item) {\n                            if (!jQuery.isEmptyObject(item)) {\n                                $( \".navbar\" ).after( '<div class=\"row-fluid text-center\" >' +\n                                    '<div id=\"flash_'+item.type+'\" class=\"alert alert-'+item.type+'\">'+item.message+'</div>' +\n                                    '</div>');\n                            }\n                        });\n                    }\n                });\n            }\n        );\n    });\n\n\n    $(\"#user_submit\").click(function() {\n        this.closest(\"form\").submit();\n    });\n\n    function handle_response(data) {\n        if (!jQuery.isEmptyObject(data)) {\n            data.forEach(function (item) {\n                $(\".navbar\").after('<div class=\"row-fluid text-center\">' +\n                    '<div id=\"flash_' + item.type + '\" class=\"alert alert-' + item.type + '\">' + item.message + '</div>' +\n                    '</div>');\n            });\n        }\n    }\n\n    $('.collapse').on('shown.bs.collapse', function(){\n        $(this).parent().find(\".glyphicon-plus\").removeClass(\"glyphicon-plus\").addClass(\"glyphicon-minus\");\n    }).on('hidden.bs.collapse', function(){\n    $(this).parent().find(\".glyphicon-minus\").removeClass(\"glyphicon-minus\").addClass(\"glyphicon-plus\");\n    });\n\n    function changeDbSettings() {\n        $(\"#db_submit\").closest('form').submit();\n    }\n\n    $(\"#db_submit\").click(function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.blur();\n        $.ajax({\n            method:\"post\",\n            dataType: \"json\",\n            url: window.location.pathname + \"/../../ajax/simulatedbchange\",\n            data: {config_calibre_dir: $(\"#config_calibre_dir\").val(), csrf_token: $(\"input[name='csrf_token']\").val()},\n            success: function success(data) {\n                if ( data.change ) {\n                    if ( data.valid ) {\n                        confirmDialog(\n                        \"db_submit\",\n                    \"GeneralChangeModal\",\n                            0,\n                            changeDbSettings\n                        );\n                    }\n                    else {\n                        $(\"#InvalidDialog\").modal('show');\n                    }\n                } else {                \t\n                    changeDbSettings();\n                }\n            }\n        });\n    });\n\n    $(\"#config_submit\").click(function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.blur();\n        window.scrollTo({top: 0, behavior: 'smooth'});\n        var request_path = \"/../../admin/ajaxconfig\";\n        var loader = \"/../..\";\n        $(\"#flash_success\").remove();\n        $(\"#flash_danger\").remove();\n        $.post(window.location.pathname + request_path, $(this).closest(\"form\").serialize(), function(data) {\n            $('#config_upload_formats').val(data.config_upload);\n            if(data.reboot) {\n                $(\"#spinning_success\").show();\n                var rebootInterval = setInterval(function(){\n                    $.get({\n                        url:window.location.pathname + \"/../../admin/alive\",\n                        success: function (d, statusText, xhr) {\n                            if (xhr.status < 400) {\n                                $(\"#spinning_success\").hide();\n                                clearInterval(rebootInterval);\n                                if (data.result) {\n                                    handle_response(data.result);\n                                    data.result = \"\";\n                                }\n                            }\n                        },\n                    });\n                }, 1000);\n            } else {\n                handle_response(data.result);\n            }\n        });\n    });\n\n    $(\"#delete_shelf\").click(function() {\n        confirmDialog(\n            $(this).attr('id'),\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function(value){\n                window.location.href = window.location.pathname + \"/../../shelf/delete/\" + value\n            }\n        );\n\n    });\n\n    $(\"#fileModal\").on(\"show.bs.modal\", function(e) {\n        var target = $(e.relatedTarget);\n        var path = $(\"#\" + target.data(\"link\"))[0].value;\n        var folder = target.data(\"folderonly\");\n        var filter = target.data(\"filefilter\");\n        $(\"#element_selected\").text(path);\n        $(\"#file_confirm\").data(\"link\", target.data(\"link\"));\n        $(\"#file_confirm\").data(\"folderonly\", (typeof folder === 'undefined') ? false : true);\n        $(\"#file_confirm\").data(\"filefilter\", (typeof filter === 'undefined') ? \"\" : filter);\n        $(\"#file_confirm\").data(\"newfile\", target.data(\"newfile\"));\n        fillFileTable(path,\"dir\", folder, filter);\n    });\n\n    $(\"#file_confirm\").click(function() {\n        $(\"#\" + $(this).data(\"link\"))[0].value = $(\"#element_selected\").text()\n    });\n\n    $(document).on(\"click\", \".tr-clickable\", function() {\n        var path = this.attributes[\"data-path\"].value;\n        var type = this.attributes[\"data-type\"].value;\n        var folder = $(file_confirm).data(\"folderonly\");\n        var filter = $(file_confirm).data(\"filefilter\");\n        var newfile = $(file_confirm).data(\"newfile\");\n        if (newfile !== \"\") {\n            $(\"#element_selected\").text(path + $(\"#new_file\".text()));\n        } else {\n            $(\"#element_selected\").text(path);\n        }\n        if(type === \"dir\") {\n            fillFileTable(path, type, folder, filter);\n        }\n    });\n\n    $(window).resize(function() {\n        $(\".discover .row\").isotope(\"layout\");\n    });\n\n    $(\"#import_ldap_users\").click(function() {\n        $(\"#DialogHeader\").addClass(\"hidden\");\n        $(\"#DialogFinished\").addClass(\"hidden\");\n        $(\"#DialogContent\").html(\"\");\n        $(\"#spinner2\").show();\n        $.ajax({\n            method:\"get\",\n            dataType: \"json\",\n            url: getPath() + \"/import_ldap_users\",\n            success: function success(data) {\n                $(\"#spinner2\").hide();\n                $(\"#DialogContent\").html(data.text);\n                $(\"#DialogFinished\").removeClass(\"hidden\");\n            }\n        });\n    });\n\n    $(\".author-expand\").click(function() {\n        $(this).parent().find(\"a.author-name\").slice($(this).data(\"authors-max\")).toggle();\n        $(this).parent().find(\"span.author-hidden-divider\").toggle();\n        $(this).html() === $(this).data(\"collapse-caption\") ? $(this).html(\"(...)\") : $(this).html($(this).data(\"collapse-caption\"));\n        $(\".discover .row\").isotope(\"layout\");\n    });\n\n    $(\".update-view\").click(function(e) {\n        var view = $(this).data(\"view\");\n        e.preventDefault();\n        e.stopPropagation();\n        $.ajax({\n            method:\"post\",\n            contentType: \"application/json; charset=utf-8\",\n            dataType: \"json\",\n            url: getPath() + \"/ajax/view\",\n            data: \"{\\\"series\\\": {\\\"series_view\\\": \\\"\"+ view +\"\\\"}}\",\n            success: function success() {\n                location.reload();\n            }\n        });\n    });\n});\n\n", "{% extends \"layout.html\" %}\n{% block body %}\n<div class=\"discover\">\n  <h2>{{title}}</h2>\n  {% if g.user.role_download() %}\n  <a id=\"shelf_down\" href=\"{{ url_for('shelf.show_simpleshelf', shelf_id=shelf.id) }}\" class=\"btn btn-primary\">{{ _('Download') }} </a>\n      {% endif %}\n  {% if g.user.is_authenticated %}\n    {% if (g.user.role_edit_shelfs() and shelf.is_public ) or not shelf.is_public  %}\n      <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n      <div class=\"btn btn-danger\" id=\"delete_shelf\" data-value=\"{{ shelf.id }}\">{{ _('Delete this Shelf') }}</div>\n      <a id=\"edit_shelf\" href=\"{{ url_for('shelf.edit_shelf', shelf_id=shelf.id) }}\" class=\"btn btn-primary\">{{ _('Edit Shelf Properties') }} </a>\n      {% if entries.__len__() %}\n      <a id=\"order_shelf\" href=\"{{ url_for('shelf.order_shelf', shelf_id=shelf.id) }}\" class=\"btn btn-primary\">{{ _('Arrange books manually') }} </a>\n      <button id=\"toggle_order_shelf\" type=\"button\" data-alt-text=\"{{ _('Disable Change order') }}\" class=\"btn btn-primary\">{{ _('Enable Change order') }}</button>\n        <div class=\"filterheader hidden-xs\">\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, newest first')}}\" id=\"new\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='new')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, oldest first')}}\" id=\"old\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='old')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort title in alphabetical order')}}\" id=\"asc\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='abc')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort title in reverse alphabetical order')}}\" id=\"desc\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='zyx')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in alphabetical order')}}\" id=\"auth_az\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='authaz')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in reverse alphabetical order')}}\" id=\"auth_za\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='authza')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, newest first')}}\" id=\"pub_new\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='pubnew')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, oldest first')}}\" id=\"pub_old\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='pubold')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n        </div>\n      {% endif %}\n    {% endif %}\n  {% endif %}\n  <div class=\"row display-flex\">\n    {% for entry in entries %}\n    <div class=\"col-sm-3 col-lg-2 col-xs-6 book\">\n      <div class=\"cover\">\n            <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n              <span class=\"img\" title=\"{{entry.title}}\" >\n                <img src=\"{{ url_for('web.get_cover', book_id=entry.id) }}\" alt=\"{{ entry.title }}\" />\n                {% if entry.id in read_book_ids %}<span class=\"badge read glyphicon glyphicon-ok\"></span>{% endif %}\n              </span>\n            </a>\n      </div>\n      <div class=\"meta\">\n        <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n          <p title=\"{{entry.title}}\" class=\"title\">{{entry.title|shortentitle}}</p>\n        </a>\n        <p class=\"author\">\n          {% for author in entry.authors %}\n            {% if loop.index > g.config_authors_max and g.config_authors_max != 0 %}\n              {% if not loop.first %}\n                <span class=\"author-hidden-divider\">&amp;</span>\n\t\t\t  {% endif %}\n              <a class=\"author-name author-hidden\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n              {% if loop.last %}\n                <a href=\"#\" class=\"author-expand\" data-authors-max=\"{{g.config_authors_max}}\" data-collapse-caption=\"({{_('reduce')}})\">(...)</a>\n              {% endif %}\n            {% else %}\n              {% if not loop.first %}\n                <span>&amp;</span>\n              {% endif %}\n              <a class=\"author-name\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n            {% endif %}\n          {% endfor %}\n        </p>\n        {% if entry.series.__len__() > 0 %}\n        <p class=\"series\">\n          <a href=\"{{url_for('web.books_list', data='series', sort_param='new', book_id=entry.series[0].id )}}\">\n            {{entry.series[0].name}}\n          </a>\n          ({{entry.series_index|formatseriesindex}})\n        </p>\n        {% endif %}\n        {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </div>\n        {% endif %}\n      </div>\n    </div>\n    {% endfor %}\n  </div>\n</div>\n<!--div id=\"DeleteShelfDialog\" class=\"modal fade\" role=\"dialog\">\n  <div class=\"modal-dialog modal-sm\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header bg-danger text-center\">\n      <span>{{_('Are you sure you want to delete this shelf?')}}</span>\n      </div>\n      <div class=\"modal-body text-center\">\n        <span>{{_('Shelf will be deleted for all users')}}</span>\n          <p></p>\n        <a id=\"confirm\" href=\"{{ url_for('shelf.delete_shelf', shelf_id=shelf.id) }}\" class=\"btn btn-danger\">{{_('OK')}}</a>\n        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">{{_('Cancel')}}</button>\n      </div>\n    </div>\n  </div>\n</div-->\n\n{% endblock %}\n{% block modal %}\n{{ delete_confirm_modal() }}\n{% endblock %}\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nimport mimetypes\nimport chardet  # dependency of requests\nimport copy\n\nfrom babel.dates import format_date\nfrom babel import Locale as LC\nfrom flask import Blueprint, jsonify\nfrom flask import request, redirect, send_from_directory, make_response, flash, abort, url_for\nfrom flask import session as flask_session\nfrom flask_babel import gettext as _\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom sqlalchemy.exc import IntegrityError, InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import text, func, false, not_, and_, or_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.sql.functions import coalesce\n\nfrom .services.worker import WorkerThread\n\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nfrom . import constants, logger, isoLanguages, services\nfrom . import babel, db, ub, config, get_locale, app\nfrom . import calibre_db, kobo_sync_status\nfrom .gdriveutils import getFileFromEbooksFolder, do_gdrive_download\nfrom .helper import check_valid_domain, render_task_status, check_email, check_username, \\\n    get_cc_columns, get_book_cover, get_download_link, send_mail, generate_random_password, \\\n    send_registration_mail, check_send_to_kindle, check_read_formats, tags_filters, reset_password, valid_email\nfrom .pagination import Pagination\nfrom .redirect import redirect_back\nfrom .usermanagement import login_required_if_no_ano\nfrom .kobo_sync_status import remove_synced_book\nfrom .render_template import render_title_template\nfrom .kobo_sync_status import change_archived_books\n\nfeature_support = {\n    'ldap': bool(services.ldap),\n    'goodreads': bool(services.goodreads_support),\n    'kobo': bool(services.kobo)\n}\n\ntry:\n    from .oauth_bb import oauth_check, register_user_with_oauth, logout_oauth_user, get_oauth_status\n    feature_support['oauth'] = True\nexcept ImportError:\n    feature_support['oauth'] = False\n    oauth_check = {}\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\ntry:\n    from natsort import natsorted as sort\nexcept ImportError:\n    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files\n\n\n@app.after_request\ndef add_security_headers(resp):\n    resp.headers['Content-Security-Policy'] = \"default-src 'self'\" + ''.join([' '+host for host in config.config_trustedhosts.strip().split(',')]) + \" 'unsafe-inline' 'unsafe-eval'; font-src 'self' data:; img-src 'self' data:\"\n    if request.endpoint == \"editbook.edit_book\" or config.config_use_google_drive:\n        resp.headers['Content-Security-Policy'] += \" *\"\n    elif request.endpoint == \"web.read_book\":\n        resp.headers['Content-Security-Policy'] += \" blob:;style-src-elem 'self' blob: 'unsafe-inline';\"\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    resp.headers['X-XSS-Protection'] = '1; mode=block'\n    resp.headers['Strict-Transport-Security'] = 'max-age=31536000;'\n    return resp\n\nweb = Blueprint('web', __name__)\nlog = logger.create()\n\n\n# ################################### Login logic and rights management ###############################################\n\n\ndef download_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_download():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\ndef viewer_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_viewer():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n# ################################### data provider functions #########################################################\n\n\n@web.route(\"/ajax/emailstat\")\n@login_required\ndef get_email_status_json():\n    tasks = WorkerThread.getInstance().tasks\n    return jsonify(render_task_status(tasks))\n\n\n@web.route(\"/ajax/bookmark/<int:book_id>/<book_format>\", methods=['POST'])\n@login_required\ndef bookmark(book_id, book_format):\n    bookmark_key = request.form[\"bookmark\"]\n    ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                              ub.Bookmark.book_id == book_id,\n                                              ub.Bookmark.format == book_format)).delete()\n    if not bookmark_key:\n        ub.session_commit()\n        return \"\", 204\n\n    lbookmark = ub.Bookmark(user_id=current_user.id,\n                            book_id=book_id,\n                            format=book_format,\n                            bookmark_key=bookmark_key)\n    ub.session.merge(lbookmark)\n    ub.session_commit(\"Bookmark for user {} in book {} created\".format(current_user.id, book_id))\n    return \"\", 201\n\n\n@web.route(\"/ajax/toggleread/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_read(book_id):\n    if not config.config_read_column:\n        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),\n                                                         ub.ReadBook.book_id == book_id)).first()\n        if book:\n            if book.read_status == ub.ReadBook.STATUS_FINISHED:\n                book.read_status = ub.ReadBook.STATUS_UNREAD\n            else:\n                book.read_status = ub.ReadBook.STATUS_FINISHED\n        else:\n            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)\n            readBook.read_status = ub.ReadBook.STATUS_FINISHED\n            book = readBook\n        if not book.kobo_reading_state:\n            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)\n            kobo_reading_state.current_bookmark = ub.KoboBookmark()\n            kobo_reading_state.statistics = ub.KoboStatistics()\n            book.kobo_reading_state = kobo_reading_state\n        ub.session.merge(book)\n        ub.session_commit(\"Book {} readbit toggled\".format(book_id))\n    else:\n        try:\n            calibre_db.update_title_sort(config)\n            book = calibre_db.get_filtered_book(book_id)\n            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))\n            if len(read_status):\n                read_status[0].value = not read_status[0].value\n                calibre_db.session.commit()\n            else:\n                cc_class = db.cc_classes[config.config_read_column]\n                new_cc = cc_class(value=1, book=book_id)\n                calibre_db.session.add(new_cc)\n                calibre_db.session.commit()\n        except (KeyError, AttributeError):\n            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column), 400\n        except (OperationalError, InvalidRequestError) as e:\n            calibre_db.session.rollback()\n            log.error(u\"Read status could not set: {}\".format(e))\n            return \"Read status could not set: {}\".format(e), 400\n    return \"\"\n\n@web.route(\"/ajax/togglearchived/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_archived(book_id):\n    is_archived = change_archived_books(book_id, message=\"Book {} archivebit toggled\".format(book_id))\n    if is_archived:\n        remove_synced_book(book_id)\n    return \"\"\n\n\n@web.route(\"/ajax/view\", methods=[\"POST\"])\n@login_required_if_no_ano\ndef update_view():\n    to_save = request.get_json()\n    try:\n        for element in to_save:\n            for param in to_save[element]:\n                current_user.set_view_property(element, param, to_save[element][param])\n    except Exception as ex:\n        log.error(\"Could not save view_settings: %r %r: %e\", request, to_save, ex)\n        return \"Invalid request\", 400\n    return \"1\", 200\n\n\n'''\n@web.route(\"/ajax/getcomic/<int:book_id>/<book_format>/<int:page>\")\n@login_required\ndef get_comic_book(book_id, book_format, page):\n    book = calibre_db.get_book(book_id)\n    if not book:\n        return \"\", 204\n    else:\n        for bookformat in book.data:\n            if bookformat.format.lower() == book_format.lower():\n                cbr_file = os.path.join(config.config_calibre_dir, book.path, bookformat.name) + \".\" + book_format\n                if book_format in (\"cbr\", \"rar\"):\n                    if feature_support['rar'] == True:\n                        rarfile.UNRAR_TOOL = config.config_rarfile_location\n                        try:\n                            rf = rarfile.RarFile(cbr_file)\n                            names = sort(rf.namelist())\n                            extract = lambda page: rf.read(names[page])\n                        except:\n                            # rarfile not valid\n                            log.error('Unrar binary not found, or unable to decompress file %s', cbr_file)\n                            return \"\", 204\n                    else:\n                        log.info('Unrar is not supported please install python rarfile extension')\n                        # no support means return nothing\n                        return \"\", 204\n                elif book_format in (\"cbz\", \"zip\"):\n                    zf = zipfile.ZipFile(cbr_file)\n                    names=sort(zf.namelist())\n                    extract = lambda page: zf.read(names[page])\n                elif book_format in (\"cbt\", \"tar\"):\n                    tf = tarfile.TarFile(cbr_file)\n                    names=sort(tf.getnames())\n                    extract = lambda page: tf.extractfile(names[page]).read()\n                else:\n                    log.error('unsupported comic format')\n                    return \"\", 204\n\n                b64 = codecs.encode(extract(page), 'base64').decode()\n                ext = names[page].rpartition('.')[-1]\n                if ext not in ('png', 'gif', 'jpg', 'jpeg', 'webp'):\n                    ext = 'png'\n                extractedfile=\"data:image/\" + ext + \";base64,\" + b64\n                fileData={\"name\": names[page], \"page\":page, \"last\":len(names)-1, \"content\": extractedfile}\n                return make_response(json.dumps(fileData))\n        return \"\", 204\n'''\n\n# ################################### Typeahead ##################################################################\n\n\n@web.route(\"/get_authors_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_authors_json():\n    return calibre_db.get_typeahead(db.Authors, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_publishers_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_publishers_json():\n    return calibre_db.get_typeahead(db.Publishers, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_tags_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_tags_json():\n    return calibre_db.get_typeahead(db.Tags, request.args.get('q'), tag_filter=tags_filters())\n\n\n@web.route(\"/get_series_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_series_json():\n    return calibre_db.get_typeahead(db.Series, request.args.get('q'))\n\n\n@web.route(\"/get_languages_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_languages_json():\n    query = (request.args.get('q') or '').lower()\n    language_names = isoLanguages.get_language_names(get_locale())\n    entries_start = [s for key, s in language_names.items() if s.lower().startswith(query.lower())]\n    if len(entries_start) < 5:\n        entries = [s for key, s in language_names.items() if query in s.lower()]\n        entries_start.extend(entries[0:(5 - len(entries_start))])\n        entries_start = list(set(entries_start))\n    json_dumps = json.dumps([dict(name=r) for r in entries_start[0:5]])\n    return json_dumps\n\n\n@web.route(\"/get_matching_tags\", methods=['GET'])\n@login_required_if_no_ano\ndef get_matching_tags():\n    tag_dict = {'tags': []}\n    q = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(True))\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    author_input = request.args.get('author_name') or ''\n    title_input = request.args.get('book_title') or ''\n    include_tag_inputs = request.args.getlist('include_tag') or ''\n    exclude_tag_inputs = request.args.getlist('exclude_tag') or ''\n    q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_input + \"%\")),\n                 func.lower(db.Books.title).ilike(\"%\" + title_input + \"%\"))\n    if len(include_tag_inputs) > 0:\n        for tag in include_tag_inputs:\n            q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    if len(exclude_tag_inputs) > 0:\n        for tag in exclude_tag_inputs:\n            q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    for book in q:\n        for tag in book.tags:\n            if tag.id not in tag_dict['tags']:\n                tag_dict['tags'].append(tag.id)\n    json_dumps = json.dumps(tag_dict)\n    return json_dumps\n\n\ndef get_sort_function(sort, data):\n    order = [db.Books.timestamp.desc()]\n    if sort == 'stored':\n        sort = current_user.get_view_property(data, 'stored')\n    else:\n        current_user.set_view_property(data, 'stored', sort)\n    if sort == 'pubnew':\n        order = [db.Books.pubdate.desc()]\n    if sort == 'pubold':\n        order = [db.Books.pubdate]\n    if sort == 'abc':\n        order = [db.Books.sort]\n    if sort == 'zyx':\n        order = [db.Books.sort.desc()]\n    if sort == 'new':\n        order = [db.Books.timestamp.desc()]\n    if sort == 'old':\n        order = [db.Books.timestamp]\n    if sort == 'authaz':\n        order = [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index]\n    if sort == 'authza':\n        order = [db.Books.author_sort.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n    if sort == 'seriesasc':\n        order = [db.Books.series_index.asc()]\n    if sort == 'seriesdesc':\n        order = [db.Books.series_index.desc()]\n    if sort == 'hotdesc':\n        order = [func.count(ub.Downloads.book_id).desc()]\n    if sort == 'hotasc':\n        order = [func.count(ub.Downloads.book_id).asc()]\n    if sort is None:\n        sort = \"new\"\n    return order, sort\n\n\ndef render_books_list(data, sort, book_id, page):\n    order = get_sort_function(sort, data)\n    if data == \"rated\":\n        return render_rated_books(page, book_id, order=order)\n    elif data == \"discover\":\n        return render_discover_books(page, book_id)\n    elif data == \"unread\":\n        return render_read_books(page, False, order=order)\n    elif data == \"read\":\n        return render_read_books(page, True, order=order)\n    elif data == \"hot\":\n        return render_hot_books(page, order)\n    elif data == \"download\":\n        return render_downloaded_books(page, order, book_id)\n    elif data == \"author\":\n        return render_author_books(page, book_id, order)\n    elif data == \"publisher\":\n        return render_publisher_books(page, book_id, order)\n    elif data == \"series\":\n        return render_series_books(page, book_id, order)\n    elif data == \"ratings\":\n        return render_ratings_books(page, book_id, order)\n    elif data == \"formats\":\n        return render_formats_books(page, book_id, order)\n    elif data == \"category\":\n        return render_category_books(page, book_id, order)\n    elif data == \"language\":\n        return render_language_books(page, book_id, order)\n    elif data == \"archived\":\n        return render_archived_books(page, order)\n    elif data == \"search\":\n        term = (request.args.get('query') or '')\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_search_results(term, offset, order, config.config_books_per_page)\n    elif data == \"advsearch\":\n        term = json.loads(flask_session['query'])\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_adv_search_results(term, offset, order, config.config_books_per_page)\n    else:\n        website = data or \"newest\"\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, order[0],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Books\"), page=website, order=order[1])\n\n\ndef render_rated_books(page, book_id, order):\n    if current_user.check_visibility(constants.SIDEBAR_BEST_RATED):\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.ratings.any(db.Ratings.rating > 9),\n                                                                order[0],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     id=book_id, title=_(u\"Top Rated Books\"), page=\"rated\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_discover_books(page, book_id):\n    if current_user.check_visibility(constants.SIDEBAR_RANDOM):\n        entries, __, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, [func.randomblob(2)])\n        pagination = Pagination(1, config.config_books_per_page, config.config_books_per_page)\n        return render_title_template('discover.html', entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Discover (Random Books)\"), page=\"discover\")\n    else:\n        abort(404)\n\ndef render_hot_books(page, order):\n    if current_user.check_visibility(constants.SIDEBAR_HOT):\n        if order[1] not in ['hotasc', 'hotdesc']:\n        # Unary expression comparsion only working (for this expression) in sqlalchemy 1.4+\n        #if not (order[0][0].compare(func.count(ub.Downloads.book_id).desc()) or\n        #        order[0][0].compare(func.count(ub.Downloads.book_id).asc())):\n            order = [func.count(ub.Downloads.book_id).desc()], 'hotdesc'\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n        off = int(int(config.config_books_per_page) * (page - 1))\n        all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id))\\\n            .order_by(*order[0]).group_by(ub.Downloads.book_id)\n        hot_books = all_books.offset(off).limit(config.config_books_per_page)\n        entries = list()\n        for book in hot_books:\n            downloadBook = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).filter(\n                db.Books.id == book.Downloads.book_id).first()\n            if downloadBook:\n                entries.append(downloadBook)\n            else:\n                ub.delete_download(book.Downloads.book_id)\n        numBooks = entries.__len__()\n        pagination = Pagination(page, config.config_books_per_page, numBooks)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Hot Books (Most Downloaded)\"), page=\"hot\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_downloaded_books(page, order, user_id):\n    if current_user.role_admin():\n        user_id = int(user_id)\n    else:\n        user_id = current_user.id\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD):\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n\n        entries, __, pagination = calibre_db.fill_indexpage(page,\n                                                            0,\n                                                            db.Books,\n                                                            ub.Downloads.user_id == user_id,\n                                                            order[0],\n                                                            db.books_series_link,\n                                                            db.Books.id == db.books_series_link.c.book,\n                                                            db.Series,\n                                                            ub.Downloads, db.Books.id == ub.Downloads.book_id)\n        for book in entries:\n            if not calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                             .filter(db.Books.id == book.id).first():\n                ub.delete_download(book.id)\n        user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        return render_title_template('index.html',\n                                     random=random,\n                                     entries=entries,\n                                     pagination=pagination,\n                                     id=user_id,\n                                     title=_(u\"Downloaded books by %(user)s\",user=user.name),\n                                     page=\"download\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_author_books(page, author_id, order):\n    entries, __, pagination = calibre_db.fill_indexpage(page, 0,\n                                                        db.Books,\n                                                        db.Books.authors.any(db.Authors.id == author_id),\n                                                        [order[0][0], db.Series.name, db.Books.series_index],\n                                                        db.books_series_link,\n                                                        db.Books.id == db.books_series_link.c.book,\n                                                        db.Series)\n    if entries is None or not len(entries):\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n    if constants.sqlalchemy_version2:\n        author = calibre_db.session.get(db.Authors, author_id)\n    else:\n        author = calibre_db.session.query(db.Authors).get(author_id)\n    author_name = author.name.replace('|', ',')\n\n    author_info = None\n    other_books = []\n    if services.goodreads_support and config.config_use_goodreads:\n        author_info = services.goodreads_support.get_author_info(author_name)\n        other_books = services.goodreads_support.get_other_books(author_info, entries)\n\n    return render_title_template('author.html', entries=entries, pagination=pagination, id=author_id,\n                                 title=_(u\"Author: %(name)s\", name=author_name), author=author_info,\n                                 other_books=other_books, page=\"author\", order=order[1])\n\n\ndef render_publisher_books(page, book_id, order):\n    publisher = calibre_db.session.query(db.Publishers).filter(db.Publishers.id == book_id).first()\n    if publisher:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.publishers.any(db.Publishers.id == book_id),\n                                                                [db.Series.name, order[0][0], db.Books.series_index],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Publisher: %(name)s\", name=publisher.name),\n                                     page=\"publisher\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_series_books(page, book_id, order):\n    name = calibre_db.session.query(db.Series).filter(db.Series.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.series.any(db.Series.id == book_id),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Series: %(serie)s\", serie=name.name), page=\"series\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_ratings_books(page, book_id, order):\n    name = calibre_db.session.query(db.Ratings).filter(db.Ratings.id == book_id).first()\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.ratings.any(db.Ratings.id == book_id),\n                                                            [order[0][0]])\n    if name and name.rating <= 10:\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Rating: %(rating)s stars\", rating=int(name.rating / 2)),\n                                     page=\"ratings\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_formats_books(page, book_id, order):\n    name = calibre_db.session.query(db.Data).filter(db.Data.format == book_id.upper()).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.data.any(db.Data.format == book_id.upper()),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"File format: %(format)s\", format=name.format),\n                                     page=\"formats\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_category_books(page, book_id, order):\n    name = calibre_db.session.query(db.Tags).filter(db.Tags.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.tags.any(db.Tags.id == book_id),\n                                                                [order[0][0], db.Series.name, db.Books.series_index],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Category: %(name)s\", name=name.name), page=\"category\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_language_books(page, name, order):\n    try:\n        lang_name = isoLanguages.get_language_name(get_locale(), name)\n    except KeyError:\n        abort(404)\n\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.languages.any(db.Languages.lang_code == name),\n                                                            [order[0][0]])\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=name,\n                                 title=_(u\"Language: %(name)s\", name=lang_name), page=\"language\", order=order[1])\n\n\ndef render_read_books(page, are_read, as_xml=False, order=None):\n    sort = order[0] if order else []\n    if not config.config_read_column:\n        if are_read:\n            db_filter = and_(ub.ReadBook.user_id == int(current_user.id),\n                             ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n        else:\n            db_filter = coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db_filter,\n                                                                sort,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series,\n                                                                ub.ReadBook, db.Books.id == ub.ReadBook.book_id)\n    else:\n        try:\n            if are_read:\n                db_filter = db.cc_classes[config.config_read_column].value == True\n            else:\n                db_filter = coalesce(db.cc_classes[config.config_read_column].value, False) != True\n            entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                    db.Books,\n                                                                    db_filter,\n                                                                    sort,\n                                                                    db.books_series_link,\n                                                                    db.Books.id == db.books_series_link.c.book,\n                                                                    db.Series,\n                                                                    db.cc_classes[config.config_read_column])\n        except (KeyError, AttributeError):\n            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            if not as_xml:\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return redirect(url_for(\"web.index\"))\n            # ToDo: Handle error Case for opds\n    if as_xml:\n        return entries, pagination\n    else:\n        if are_read:\n            name = _(u'Read Books') + ' (' + str(pagination.total_count) + ')'\n            pagename = \"read\"\n        else:\n            name = _(u'Unread Books') + ' (' + str(pagination.total_count) + ')'\n            pagename = \"unread\"\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=name, page=pagename, order=order[1])\n\n\ndef render_archived_books(page, sort):\n    order = sort[0] or []\n    archived_books = (\n        ub.session.query(ub.ArchivedBook)\n        .filter(ub.ArchivedBook.user_id == int(current_user.id))\n        .filter(ub.ArchivedBook.is_archived == True)\n        .all()\n    )\n    archived_book_ids = [archived_book.book_id for archived_book in archived_books]\n\n    archived_filter = db.Books.id.in_(archived_book_ids)\n\n    entries, random, pagination = calibre_db.fill_indexpage_with_archived_books(page, 0,\n                                                                                db.Books,\n                                                                                archived_filter,\n                                                                                order,\n                                                                                allow_show_archived=True)\n\n    name = _(u'Archived Books') + ' (' + str(len(archived_book_ids)) + ')'\n    pagename = \"archived\"\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                 title=name, page=pagename, order=sort[1])\n\n\ndef render_prepare_search_form(cc):\n    # prepare data for search-form\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    series = calibre_db.session.query(db.Series)\\\n        .join(db.books_series_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_series_link.series'))\\\n        .order_by(db.Series.name)\\\n        .filter(calibre_db.common_filters()).all()\n    shelves = ub.session.query(ub.Shelf)\\\n        .filter(or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == int(current_user.id)))\\\n        .order_by(ub.Shelf.name).all()\n    extensions = calibre_db.session.query(db.Data)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(db.Data.format)\\\n        .order_by(db.Data.format).all()\n    if current_user.filter_language() == u\"all\":\n        languages = calibre_db.speaking_language()\n    else:\n        languages = None\n    return render_title_template('search_form.html', tags=tags, languages=languages, extensions=extensions,\n                                 series=series,shelves=shelves, title=_(u\"Advanced Search\"), cc=cc, page=\"advsearch\")\n\n\ndef render_search_results(term, offset=None, order=None, limit=None):\n    join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    entries, result_count, pagination = calibre_db.get_search_results(term, offset, order, limit, *join)\n    return render_title_template('search.html',\n                                 searchterm=term,\n                                 pagination=pagination,\n                                 query=term,\n                                 adv_searchterm=term,\n                                 entries=entries,\n                                 result_count=result_count,\n                                 title=_(u\"Search\"),\n                                 page=\"search\",\n                                 order=order[1])\n\n\n# ################################### View Books list ##################################################################\n\n\n@web.route(\"/\", defaults={'page': 1})\n@web.route('/page/<int:page>')\n@login_required_if_no_ano\ndef index(page):\n    sort_param = (request.args.get('sort') or 'stored').lower()\n    return render_books_list(\"newest\", sort_param, 1, page)\n\n\n@web.route('/<data>/<sort_param>', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/<book_id>', defaults={'page': 1})\n@web.route('/<data>/<sort_param>/<book_id>/<int:page>')\n@login_required_if_no_ano\ndef books_list(data, sort_param, book_id, page):\n    return render_books_list(data, sort_param, book_id, page)\n\n\n@web.route(\"/table\")\n@login_required\ndef books_table():\n    visibility = current_user.view_settings.get('table', {})\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_title_template('book_table.html', title=_(u\"Books List\"), cc=cc, page=\"book_table\",\n                                 visiblility=visibility)\n\n@web.route(\"/ajax/listbooks\")\n@login_required\ndef list_books():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or config.config_books_per_page)\n    search = request.args.get(\"search\")\n    sort = request.args.get(\"sort\", \"id\")\n    order = request.args.get(\"order\", \"\").lower()\n    state = None\n    join = tuple()\n\n    if sort == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n    elif sort == \"tags\":\n        order = [db.Tags.name.asc()] if order == \"asc\" else [db.Tags.name.desc()]\n        join = db.books_tags_link,db.Books.id == db.books_tags_link.c.book, db.Tags\n    elif sort == \"series\":\n        order = [db.Series.name.asc()] if order == \"asc\" else [db.Series.name.desc()]\n        join = db.books_series_link,db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort == \"publishers\":\n        order = [db.Publishers.name.asc()] if order == \"asc\" else [db.Publishers.name.desc()]\n        join = db.books_publishers_link,db.Books.id == db.books_publishers_link.c.book, db.Publishers\n    elif sort == \"authors\":\n        order = [db.Authors.name.asc(), db.Series.name, db.Books.series_index] if order == \"asc\" \\\n            else [db.Authors.name.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n        join = db.books_authors_link, db.Books.id == db.books_authors_link.c.book, db.Authors, \\\n               db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort == \"languages\":\n        order = [db.Languages.lang_code.asc()] if order == \"asc\" else [db.Languages.lang_code.desc()]\n        join = db.books_languages_link, db.Books.id == db.books_languages_link.c.book, db.Languages\n    elif order and sort in [\"sort\", \"title\", \"authors_sort\", \"series_index\"]:\n        order = [text(sort + \" \" + order)]\n    elif not state:\n        order = [db.Books.timestamp.desc()]\n\n    total_count = filtered_count = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(False)).count()\n\n    if state is not None:\n        if search:\n            books = calibre_db.search_query(search).all()\n            filtered_count = len(books)\n        else:\n            books = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).all()\n        entries = calibre_db.get_checkbox_sorted(books, state, off, limit, order)\n    elif search:\n        entries, filtered_count, __ = calibre_db.get_search_results(search, off, [order,''], limit, *join)\n    else:\n        entries, __, __ = calibre_db.fill_indexpage((int(off) / (int(limit)) + 1), limit, db.Books, True, order, *join)\n\n    for entry in entries:\n        for index in range(0, len(entry.languages)):\n            entry.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entry.languages[\n                index].lang_code)\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": entries}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@web.route(\"/ajax/table_settings\", methods=['POST'])\n@login_required\ndef update_table_settings():\n    # vals = request.get_json()\n    # ToDo: Save table settings\n    current_user.view_settings['table'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: %r \", request, )\n        return \"Invalid request\", 400\n    return \"\"\n\n\n@web.route(\"/author\")\n@login_required_if_no_ano\ndef author_list():\n    if current_user.check_visibility(constants.SIDEBAR_AUTHOR):\n        if current_user.get_view_property('author', 'dir') == 'desc':\n            order = db.Authors.sort.desc()\n            order_no = 0\n        else:\n            order = db.Authors.sort.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Authors, func.count('books_authors_link.book').label('count')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_authors_link.author')).order_by(order).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Authors.sort, 1, 1)).label('char')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Authors.sort, 1, 1))).all()\n        # If not creating a copy, readonly databases can not display authornames with \"|\" in it as changing the name\n        # starts a change session\n        autor_copy = copy.deepcopy(entries)\n        for entry in autor_copy:\n            entry.Authors.name = entry.Authors.name.replace('|', ',')\n        return render_title_template('list.html', entries=autor_copy, folder='web.books_list', charlist=charlist,\n                                     title=u\"Authors\", page=\"authorlist\", data='author', order=order_no)\n    else:\n        abort(404)\n\n@web.route(\"/downloadlist\")\n@login_required_if_no_ano\ndef download_list():\n    if current_user.get_view_property('download', 'dir') == 'desc':\n        order = ub.User.name.desc()\n        order_no = 0\n    else:\n        order = ub.User.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD) and current_user.role_admin():\n        entries = ub.session.query(ub.User, func.count(ub.Downloads.book_id).label('count'))\\\n            .join(ub.Downloads).group_by(ub.Downloads.user_id).order_by(order).all()\n        charlist = ub.session.query(func.upper(func.substr(ub.User.name, 1, 1)).label('char')) \\\n            .filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS) \\\n            .group_by(func.upper(func.substr(ub.User.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Downloads\"), page=\"downloadlist\", data=\"download\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/publisher\")\n@login_required_if_no_ano\ndef publisher_list():\n    if current_user.get_view_property('publisher', 'dir') == 'desc':\n        order = db.Publishers.name.desc()\n        order_no = 0\n    else:\n        order = db.Publishers.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_PUBLISHER):\n        entries = calibre_db.session.query(db.Publishers, func.count('books_publishers_link.book').label('count')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_publishers_link.publisher')).order_by(order).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Publishers.name, 1, 1)).label('char')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Publishers.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Publishers\"), page=\"publisherlist\", data=\"publisher\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/series\")\n@login_required_if_no_ano\ndef series_list():\n    if current_user.check_visibility(constants.SIDEBAR_SERIES):\n        if current_user.get_view_property('series', 'dir') == 'desc':\n            order = db.Series.sort.desc()\n            order_no = 0\n        else:\n            order = db.Series.sort.asc()\n            order_no = 1\n        if current_user.get_view_property('series', 'series_view') == 'list':\n            entries = calibre_db.session.query(db.Series, func.count('books_series_link.book').label('count')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n            return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", order=order_no)\n        else:\n            entries = calibre_db.session.query(db.Books, func.count('books_series_link').label('count'),\n                                               func.max(db.Books.series_index), db.Books.id) \\\n                .join(db.books_series_link).join(db.Series).filter(calibre_db.common_filters())\\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n\n            return render_title_template('grid.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", bodyClass=\"grid-view\",\n                                         order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/ratings\")\n@login_required_if_no_ano\ndef ratings_list():\n    if current_user.check_visibility(constants.SIDEBAR_RATING):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Ratings.rating.desc()\n            order_no = 0\n        else:\n            order = db.Ratings.rating.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),\n                                   (db.Ratings.rating / 2).label('name')) \\\n            .join(db.books_ratings_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_ratings_link.rating')).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"Ratings list\"), page=\"ratingslist\", data=\"ratings\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/formats\")\n@login_required_if_no_ano\ndef formats_list():\n    if current_user.check_visibility(constants.SIDEBAR_FORMAT):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Data.format.desc()\n            order_no = 0\n        else:\n            order = db.Data.format.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Data,\n                                           func.count('data.book').label('count'),\n                                           db.Data.format.label('format')) \\\n            .join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(db.Data.format).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"File formats list\"), page=\"formatslist\", data=\"formats\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/language\")\n@login_required_if_no_ano\ndef language_overview():\n    if current_user.check_visibility(constants.SIDEBAR_LANGUAGE) and current_user.filter_language() == u\"all\":\n        order_no = 0 if current_user.get_view_property('language', 'dir') == 'desc' else 1\n        charlist = list()\n        languages = calibre_db.speaking_language(reverse_order=not order_no, with_count=True)\n        for lang in languages:\n            upper_lang = lang[0].name[0].upper()\n            if upper_lang not in charlist:\n                charlist.append(upper_lang)\n        return render_title_template('languages.html', languages=languages,\n                                     charlist=charlist, title=_(u\"Languages\"), page=\"langlist\",\n                                     data=\"language\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/category\")\n@login_required_if_no_ano\ndef category_list():\n    if current_user.check_visibility(constants.SIDEBAR_CATEGORY):\n        if current_user.get_view_property('category', 'dir') == 'desc':\n            order = db.Tags.name.desc()\n            order_no = 0\n        else:\n            order = db.Tags.name.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Tags, func.count('books_tags_link.book').label('count')) \\\n            .join(db.books_tags_link).join(db.Books).order_by(order).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_tags_link.tag')).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Tags.name, 1, 1)).label('char')) \\\n            .join(db.books_tags_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Tags.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Categories\"), page=\"catlist\", data=\"category\", order=order_no)\n    else:\n        abort(404)\n\n\n# ################################### Task functions ################################################################\n\n\n@web.route(\"/tasks\")\n@login_required\ndef get_tasks_status():\n    # if current user admin, show all email, otherwise only own emails\n    tasks = WorkerThread.getInstance().tasks\n    answer = render_task_status(tasks)\n    return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")\n\n\n@app.route(\"/reconnect\")\ndef reconnect():\n    calibre_db.reconnect_db(config, ub.app_DB_path)\n    return json.dumps({})\n\n\n# ################################### Search functions ################################################################\n\n@web.route(\"/search\", methods=[\"GET\"])\n@login_required_if_no_ano\ndef search():\n    term = request.args.get(\"query\")\n    if term:\n        return redirect(url_for('web.books_list', data=\"search\", sort_param='stored', query=term))\n    else:\n        return render_title_template('search.html',\n                                     searchterm=\"\",\n                                     result_count=0,\n                                     title=_(u\"Search\"),\n                                     page=\"search\")\n\n\n@web.route(\"/advsearch\", methods=['POST'])\n@login_required_if_no_ano\ndef advanced_search():\n    values = dict(request.form)\n    params = ['include_tag', 'exclude_tag', 'include_serie', 'exclude_serie', 'include_shelf', 'exclude_shelf',\n              'include_language', 'exclude_language', 'include_extension', 'exclude_extension']\n    for param in params:\n        values[param] = list(request.form.getlist(param))\n    flask_session['query'] = json.dumps(values)\n    return redirect(url_for('web.books_list', data=\"advsearch\", sort_param='stored', query=\"\"))\n\n\ndef adv_search_custom_columns(cc, term, q):\n    for c in cc:\n        if c.datatype == \"datetime\":\n            custom_start = term.get('custom_column_' + str(c.id) + '_start')\n            custom_end = term.get('custom_column_' + str(c.id) + '_end')\n            if custom_start:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) >= func.datetime(custom_start)))\n            if custom_end:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) <= func.datetime(custom_end)))\n        else:\n            custom_query = term.get('custom_column_' + str(c.id))\n            if custom_query != '' and custom_query is not None:\n                if c.datatype == 'bool':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == (custom_query == \"True\")))\n                elif c.datatype == 'int' or c.datatype == 'float':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == custom_query))\n                elif c.datatype == 'rating':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == int(float(custom_query) * 2)))\n                else:\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        func.lower(db.cc_classes[c.id].value).ilike(\"%\" + custom_query + \"%\")))\n    return q\n\n\ndef adv_search_language(q, include_languages_inputs, exclude_languages_inputs):\n    if current_user.filter_language() != \"all\":\n        q = q.filter(db.Books.languages.any(db.Languages.lang_code == current_user.filter_language()))\n    else:\n        for language in include_languages_inputs:\n            q = q.filter(db.Books.languages.any(db.Languages.id == language))\n        for language in exclude_languages_inputs:\n            q = q.filter(not_(db.Books.series.any(db.Languages.id == language)))\n    return q\n\n\ndef adv_search_ratings(q, rating_high, rating_low):\n    if rating_high:\n        rating_high = int(rating_high) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating <= rating_high))\n    if rating_low:\n        rating_low = int(rating_low) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating >= rating_low))\n    return q\n\n\ndef adv_search_read_status(q, read_status):\n    if read_status:\n        if config.config_read_column:\n            try:\n                if read_status == \"True\":\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(db.cc_classes[config.config_read_column].value == True)\n                else:\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(coalesce(db.cc_classes[config.config_read_column].value, False) != True)\n            except (KeyError, AttributeError):\n                log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return q\n        else:\n            if read_status == \"True\":\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n            else:\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED)\n    return q\n\n\ndef adv_search_extension(q, include_extension_inputs, exclude_extension_inputs):\n    for extension in include_extension_inputs:\n        q = q.filter(db.Books.data.any(db.Data.format == extension))\n    for extension in exclude_extension_inputs:\n        q = q.filter(not_(db.Books.data.any(db.Data.format == extension)))\n    return q\n\n\ndef adv_search_tag(q, include_tag_inputs, exclude_tag_inputs):\n    for tag in include_tag_inputs:\n        q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    for tag in exclude_tag_inputs:\n        q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    return q\n\n\ndef adv_search_serie(q, include_series_inputs, exclude_series_inputs):\n    for serie in include_series_inputs:\n        q = q.filter(db.Books.series.any(db.Series.id == serie))\n    for serie in exclude_series_inputs:\n        q = q.filter(not_(db.Books.series.any(db.Series.id == serie)))\n    return q\n\ndef adv_search_shelf(q, include_shelf_inputs, exclude_shelf_inputs):\n    q = q.outerjoin(ub.BookShelf, db.Books.id == ub.BookShelf.book_id)\\\n        .filter(or_(ub.BookShelf.shelf == None, ub.BookShelf.shelf.notin_(exclude_shelf_inputs)))\n    if len(include_shelf_inputs) > 0:\n        q = q.filter(ub.BookShelf.shelf.in_(include_shelf_inputs))\n    return q\n\ndef extend_search_term(searchterm,\n                       author_name,\n                       book_title,\n                       publisher,\n                       pub_start,\n                       pub_end,\n                       tags,\n                       rating_high,\n                       rating_low,\n                       read_status,\n                       ):\n    searchterm.extend((author_name.replace('|', ','), book_title, publisher))\n    if pub_start:\n        try:\n            searchterm.extend([_(u\"Published after \") +\n                               format_date(datetime.strptime(pub_start, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_start = u\"\"\n    if pub_end:\n        try:\n            searchterm.extend([_(u\"Published before \") +\n                               format_date(datetime.strptime(pub_end, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_end = u\"\"\n    elements = {'tag': db.Tags, 'serie':db.Series, 'shelf':ub.Shelf}\n    for key, db_element in elements.items():\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['include_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['exclude_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['include_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['exclude_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    if rating_high:\n        searchterm.extend([_(u\"Rating <= %(rating)s\", rating=rating_high)])\n    if rating_low:\n        searchterm.extend([_(u\"Rating >= %(rating)s\", rating=rating_low)])\n    if read_status:\n        searchterm.extend([_(u\"Read Status = %(status)s\", status=read_status)])\n    searchterm.extend(ext for ext in tags['include_extension'])\n    searchterm.extend(ext for ext in tags['exclude_extension'])\n    # handle custom columns\n    searchterm = \" + \".join(filter(None, searchterm))\n    return searchterm, pub_start, pub_end\n\n\ndef render_adv_search_results(term, offset=None, order=None, limit=None):\n    sort = order[0] if order else [db.Books.sort]\n    pagination = None\n\n    cc = get_cc_columns(filter_config_custom_read=True)\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    q = calibre_db.session.query(db.Books).outerjoin(db.books_series_link, db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series)\\\n        .filter(calibre_db.common_filters(True))\n\n    # parse multiselects to a complete dict\n    tags = dict()\n    elements = ['tag', 'serie', 'shelf', 'language', 'extension']\n    for element in elements:\n        tags['include_' + element] = term.get('include_' + element)\n        tags['exclude_' + element] = term.get('exclude_' + element)\n\n    author_name = term.get(\"author_name\")\n    book_title = term.get(\"book_title\")\n    publisher = term.get(\"publisher\")\n    pub_start = term.get(\"publishstart\")\n    pub_end = term.get(\"publishend\")\n    rating_low = term.get(\"ratinghigh\")\n    rating_high = term.get(\"ratinglow\")\n    description = term.get(\"comment\")\n    read_status = term.get(\"read_status\")\n    if author_name:\n        author_name = author_name.strip().lower().replace(',', '|')\n    if book_title:\n        book_title = book_title.strip().lower()\n    if publisher:\n        publisher = publisher.strip().lower()\n\n    searchterm = []\n    cc_present = False\n    for c in cc:\n        if c.datatype == \"datetime\":\n            column_start = term.get('custom_column_' + str(c.id) + '_start')\n            column_end = term.get('custom_column_' + str(c.id) + '_end')\n            if column_start:\n                searchterm.extend([u\"{} >= {}\".format(c.name,\n                                                      format_date(datetime.strptime(column_start, \"%Y-%m-%d\").date(),\n                                                                      format='medium',\n                                                                      locale=get_locale())\n                                                      )])\n                cc_present = True\n            if column_end:\n                searchterm.extend([u\"{} <= {}\".format(c.name,\n                                                      format_date(datetime.strptime(column_end, \"%Y-%m-%d\").date(),\n                                                                      format='medium',\n                                                                      locale=get_locale())\n                                                      )])\n                cc_present = True\n        elif term.get('custom_column_' + str(c.id)):\n            searchterm.extend([(u\"{}: {}\".format(c.name, term.get('custom_column_' + str(c.id))))])\n            cc_present = True\n\n\n    if any(tags.values()) or author_name or book_title or publisher or pub_start or pub_end or rating_low \\\n       or rating_high or description or cc_present or read_status:\n        searchterm, pub_start, pub_end = extend_search_term(searchterm,\n                                                            author_name,\n                                                            book_title,\n                                                            publisher,\n                                                            pub_start,\n                                                            pub_end,\n                                                            tags,\n                                                            rating_high,\n                                                            rating_low,\n                                                            read_status)\n        q = q.filter()\n        if author_name:\n            q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_name + \"%\")))\n        if book_title:\n            q = q.filter(func.lower(db.Books.title).ilike(\"%\" + book_title + \"%\"))\n        if pub_start:\n            q = q.filter(func.datetime(db.Books.pubdate) > func.datetime(pub_start))\n        if pub_end:\n            q = q.filter(func.datetime(db.Books.pubdate) < func.datetime(pub_end))\n        q = adv_search_read_status(q, read_status)\n        if publisher:\n            q = q.filter(db.Books.publishers.any(func.lower(db.Publishers.name).ilike(\"%\" + publisher + \"%\")))\n        q = adv_search_tag(q, tags['include_tag'], tags['exclude_tag'])\n        q = adv_search_serie(q, tags['include_serie'], tags['exclude_serie'])\n        q = adv_search_shelf(q, tags['include_shelf'], tags['exclude_shelf'])\n        q = adv_search_extension(q, tags['include_extension'], tags['exclude_extension'])\n        q = adv_search_language(q, tags['include_language'], tags['exclude_language'])\n        q = adv_search_ratings(q, rating_high, rating_low)\n\n        if description:\n            q = q.filter(db.Books.comments.any(func.lower(db.Comments.text).ilike(\"%\" + description + \"%\")))\n\n        # search custom culumns\n        try:\n            q = adv_search_custom_columns(cc, term, q)\n        except AttributeError as ex:\n            log.debug_or_exception(ex)\n            flash(_(\"Error on search for custom columns, please restart Calibre-Web\"), category=\"error\")\n\n    q = q.order_by(*sort).all()\n    flask_session['query'] = json.dumps(term)\n    ub.store_ids(q)\n    result_count = len(q)\n    if offset is not None and limit is not None:\n        offset = int(offset)\n        limit_all = offset + int(limit)\n        pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)\n    else:\n        offset = 0\n        limit_all = result_count\n    return render_title_template('search.html',\n                                 adv_searchterm=searchterm,\n                                 pagination=pagination,\n                                 entries=q[offset:limit_all],\n                                 result_count=result_count,\n                                 title=_(u\"Advanced Search\"), page=\"advsearch\",\n                                 order=order[1])\n\n\n\n@web.route(\"/advsearch\", methods=['GET'])\n@login_required_if_no_ano\ndef advanced_search_form():\n    # Build custom columns names\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_prepare_search_form(cc)\n\n\n# ################################### Download/Send ##################################################################\n\n\n@web.route(\"/cover/<int:book_id>\")\n@login_required_if_no_ano\ndef get_cover(book_id):\n    return get_book_cover(book_id)\n\n@web.route(\"/robots.txt\")\ndef get_robots():\n    return send_from_directory(constants.STATIC_DIR, \"robots.txt\")\n\n@web.route(\"/show/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/show/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@viewer_required\ndef serve_book(book_id, book_format, anyname):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book_id, book_format.upper())\n    if not data:\n        return \"File not in Database\"\n    log.info('Serving book: %s', data.name)\n    if config.config_use_google_drive:\n        try:\n            headers = Headers()\n            headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n            df = getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n            return do_gdrive_download(df, headers, (book_format.upper() == 'TXT'))\n        except AttributeError as ex:\n            log.debug_or_exception(ex)\n            return \"File Not Found\"\n    else:\n        if book_format.upper() == 'TXT':\n            try:\n                rawdata = open(os.path.join(config.config_calibre_dir, book.path, data.name + \".\" + book_format),\n                               \"rb\").read()\n                result = chardet.detect(rawdata)\n                return make_response(\n                    rawdata.decode(result['encoding'], 'surrogatepass').encode('utf-8', 'surrogatepass'))\n            except FileNotFoundError:\n                log.error(\"File Not Found\")\n                return \"File Not Found\"\n        return send_from_directory(os.path.join(config.config_calibre_dir, book.path), data.name + \".\" + book_format)\n\n\n@web.route(\"/download/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/download/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@download_required\ndef download_link(book_id, book_format, anyname):\n    client = \"kobo\" if \"Kobo\" in request.headers.get('User-Agent') else \"\"\n    return get_download_link(book_id, book_format, client)\n\n\n@web.route('/send/<int:book_id>/<book_format>/<int:convert>')\n@login_required\n@download_required\ndef send_to_kindle(book_id, book_format, convert):\n    if not config.get_mail_server_configured():\n        flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    elif current_user.kindle_mail:\n        result = send_mail(book_id, book_format, convert, current_user.kindle_mail, config.config_calibre_dir,\n                           current_user.name)\n        if result is None:\n            flash(_(u\"Book successfully queued for sending to %(kindlemail)s\", kindlemail=current_user.kindle_mail),\n                  category=\"success\")\n            ub.update_download(book_id, int(current_user.id))\n        else:\n            flash(_(u\"Oops! There was an error sending this book: %(res)s\", res=result), category=\"error\")\n    else:\n        flash(_(u\"Please update your profile with a valid Send to Kindle E-mail Address.\"), category=\"error\")\n    if \"HTTP_REFERER\" in request.environ:\n        return redirect(request.environ[\"HTTP_REFERER\"])\n    else:\n        return redirect(url_for('web.index'))\n\n\n# ################################### Login Logout ##################################################################\n\n\n@web.route('/register', methods=['GET', 'POST'])\ndef register():\n    if not config.config_public_reg:\n        abort(404)\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if not config.get_mail_server_configured():\n        flash(_(u\"E-Mail server is not configured, please contact your administrator!\"), category=\"error\")\n        return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        nickname = to_save[\"email\"].strip() if config.config_register_email else to_save.get('name')\n        if not nickname or not to_save.get(\"email\"):\n            flash(_(u\"Please fill out all fields!\"), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        try:\n            nickname = check_username(nickname)\n            email = check_email(to_save[\"email\"])\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n        content = ub.User()\n        if check_valid_domain(email):\n            content.name = nickname\n            content.email = email\n            password = generate_random_password()\n            content.password = generate_password_hash(password)\n            content.role = config.config_default_role\n            content.sidebar_view = config.config_default_show\n            try:\n                ub.session.add(content)\n                ub.session.commit()\n                if feature_support['oauth']:\n                    register_user_with_oauth(content)\n                send_registration_mail(to_save[\"email\"].strip(), nickname, password)\n            except Exception:\n                ub.session.rollback()\n                flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        else:\n            flash(_(u\"Your e-mail is not allowed to register\"), category=\"error\")\n            log.warning('Registering failed for user \"%s\" e-mail address: %s', nickname, to_save[\"email\"])\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        flash(_(u\"Confirmation e-mail was send to your e-mail account.\"), category=\"success\")\n        return redirect(url_for('web.login'))\n\n    if feature_support['oauth']:\n        register_user_with_oauth()\n    return render_title_template('register.html', config=config, title=_(\"Register\"), page=\"register\")\n\n\n@web.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if config.config_login_type == constants.LOGIN_LDAP and not services.ldap:\n        log.error(u\"Cannot activate LDAP authentication\")\n        flash(_(u\"Cannot activate LDAP authentication\"), category=\"error\")\n    if request.method == \"POST\":\n        form = request.form.to_dict()\n        user = ub.session.query(ub.User).filter(func.lower(ub.User.name) == form['username'].strip().lower()) \\\n            .first()\n        if config.config_login_type == constants.LOGIN_LDAP and services.ldap and user and form['password'] != \"\":\n            login_result, error = services.ldap.bind_user(form['username'], form['password'])\n            if login_result:\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.debug(u\"You are now logged in as: '%s'\", user.name)\n                flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name),\n                      category=\"success\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None and user and check_password_hash(str(user.password), form['password']) \\\n                and user.name != \"Guest\":\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.info(\"Local Fallback Login as: '%s'\", user.name)\n                flash(_(u\"Fallback Login as: '%(nickname)s', LDAP Server not reachable, or user not known\",\n                        nickname=user.name),\n                      category=\"warning\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None:\n                log.info(error)\n                flash(_(u\"Could not login: %(message)s\", message=error), category=\"error\")\n            else:\n                ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n                log.warning('LDAP Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                flash(_(u\"Wrong Username or Password\"), category=\"error\")\n        else:\n            ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n            if 'forgot' in form and form['forgot'] == 'forgot':\n                if user is not None and user.name != \"Guest\":\n                    ret, __ = reset_password(user.id)\n                    if ret == 1:\n                        flash(_(u\"New Password was send to your email address\"), category=\"info\")\n                        log.info('Password reset for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                    else:\n                        log.error(u\"An unknown error occurred. Please try again later\")\n                        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                else:\n                    flash(_(u\"Please enter valid username to reset password\"), category=\"error\")\n                    log.warning('Username missing for password reset IP-address: %s', ip_Address)\n            else:\n                if user and check_password_hash(str(user.password), form['password']) and user.name != \"Guest\":\n                    login_user(user, remember=bool(form.get('remember_me')))\n                    ub.store_user_session()\n                    log.debug(u\"You are now logged in as: '%s'\", user.name)\n                    flash(_(u\"You are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")\n                    config.config_is_initial = False\n                    return redirect_back(url_for(\"web.index\"))\n                else:\n                    log.warning('Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                    flash(_(u\"Wrong Username or Password\"), category=\"error\")\n\n    next_url = request.args.get('next', default=url_for(\"web.index\"), type=str)\n    if url_for(\"web.logout\") == next_url:\n        next_url = url_for(\"web.index\")\n    return render_title_template('login.html',\n                                 title=_(u\"Login\"),\n                                 next_url=next_url,\n                                 config=config,\n                                 oauth_check=oauth_check,\n                                 mail=config.get_mail_server_configured(), page=\"login\")\n\n\n@web.route('/logout')\n@login_required\ndef logout():\n    if current_user is not None and current_user.is_authenticated:\n        ub.delete_user_session(current_user.id, flask_session.get('_id',\"\"))\n        logout_user()\n        if feature_support['oauth'] and (config.config_login_type == 2 or config.config_login_type == 3):\n            logout_oauth_user()\n    log.debug(u\"User logged out\")\n    return redirect(url_for('web.login'))\n\n\n# ################################### Users own configuration #########################################################\ndef change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages):\n    to_save = request.form.to_dict()\n    current_user.random_books = 0\n    if current_user.role_passwd() or current_user.role_admin():\n        if to_save.get(\"password\"):\n            current_user.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if to_save.get(\"kindle_mail\", current_user.kindle_mail) != current_user.kindle_mail:\n            current_user.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if to_save.get(\"email\", current_user.email) != current_user.email:\n            current_user.email = check_email(to_save[\"email\"])\n        if current_user.role_admin():\n            if to_save.get(\"name\", current_user.name) != current_user.name:\n                # Query User name, if not existing, change\n                current_user.name = check_username(to_save[\"name\"])\n        current_user.random_books = 1 if to_save.get(\"show_random\") == \"on\" else 0\n        if to_save.get(\"default_language\"):\n            current_user.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            current_user.locale = to_save[\"locale\"]\n        old_state = current_user.kobo_only_shelves_sync\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs which\n        # don't have to be synced have to be removed (added to Shelf archive)\n        current_user.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        if old_state == 0 and current_user.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(current_user.id)\n\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\",\n                                     content=current_user,\n                                     translations=translations,\n                                     profile=1,\n                                     languages=languages,\n                                     title=_(u\"%(name)s's profile\", name=current_user.name),\n                                     page=\"me\",\n                                     kobo_support=kobo_support,\n                                     registered_oauth=local_oauth_check,\n                                     oauth_status=oauth_status)\n\n    val = 0\n    for key, __ in to_save.items():\n        if key.startswith('show'):\n            val += int(key[5:])\n    current_user.sidebar_view = val\n    if to_save.get(\"Show_detail_random\"):\n        current_user.sidebar_view += constants.DETAIL_RANDOM\n\n    try:\n        ub.session.commit()\n        flash(_(u\"Profile updated\"), category=\"success\")\n        log.debug(u\"Profile updated\")\n    except IntegrityError:\n        ub.session.rollback()\n        flash(_(u\"Found an existing account for this e-mail address\"), category=\"error\")\n        log.debug(u\"Found an existing account for this e-mail address\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error(\"Database error: %s\", e)\n        flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n\n\n@web.route(\"/me\", methods=[\"GET\", \"POST\"])\n@login_required\ndef profile():\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [LC('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if feature_support['oauth'] and config.config_login_type == 2:\n        oauth_status = get_oauth_status()\n        local_oauth_check = oauth_check\n    else:\n        oauth_status = None\n        local_oauth_check = {}\n\n    if request.method == \"POST\":\n        change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages)\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 profile=1,\n                                 languages=languages,\n                                 content=current_user,\n                                 kobo_support=kobo_support,\n                                 title=_(u\"%(name)s's profile\", name=current_user.name),\n                                 page=\"me\",\n                                 registered_oauth=local_oauth_check,\n                                 oauth_status=oauth_status)\n\n\n# ###################################Show single book ##################################################################\n\n\n@web.route(\"/read/<int:book_id>/<book_format>\")\n@login_required_if_no_ano\n@viewer_required\ndef read_book(book_id, book_format):\n    book = calibre_db.get_filtered_book(book_id)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        return redirect(url_for(\"web.index\"))\n\n    # check if book has bookmark\n    bookmark = None\n    if current_user.is_authenticated:\n        bookmark = ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                                             ub.Bookmark.book_id == book_id,\n                                                             ub.Bookmark.format == book_format.upper())).first()\n    if book_format.lower() == \"epub\":\n        log.debug(u\"Start epub reader for %d\", book_id)\n        return render_title_template('read.html', bookid=book_id, title=book.title, bookmark=bookmark)\n    elif book_format.lower() == \"pdf\":\n        log.debug(u\"Start pdf reader for %d\", book_id)\n        return render_title_template('readpdf.html', pdffile=book_id, title=book.title)\n    elif book_format.lower() == \"txt\":\n        log.debug(u\"Start txt reader for %d\", book_id)\n        return render_title_template('readtxt.html', txtfile=book_id, title=book.title)\n    elif book_format.lower() == \"djvu\":\n        log.debug(u\"Start djvu reader for %d\", book_id)\n        return render_title_template('readdjvu.html', djvufile=book_id, title=book.title)\n    else:\n        for fileExt in constants.EXTENSIONS_AUDIO:\n            if book_format.lower() == fileExt:\n                entries = calibre_db.get_filtered_book(book_id)\n                log.debug(u\"Start mp3 listening for %d\", book_id)\n                return render_title_template('listenmp3.html', mp3file=book_id, audioformat=book_format.lower(),\n                                             entry=entries, bookmark=bookmark)\n        for fileExt in [\"cbr\", \"cbt\", \"cbz\"]:\n            if book_format.lower() == fileExt:\n                all_name = str(book_id)\n                title = book.title\n                if len(book.series):\n                    title = title + \" - \" + book.series[0].name\n                    if book.series_index:\n                        title = title + \" #\" + '{0:.2f}'.format(book.series_index).rstrip('0').rstrip('.')\n                log.debug(u\"Start comic reader for %d\", book_id)\n                return render_title_template('readcbr.html', comicfile=all_name, title=title,\n                                             extension=fileExt)\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n\n@web.route(\"/book/<int:book_id>\")\n@login_required_if_no_ano\ndef show_book(book_id):\n    entries = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if entries:\n        for index in range(0, len(entries.languages)):\n            entries.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entries.languages[\n                index].lang_code)\n        cc = get_cc_columns(filter_config_custom_read=True)\n        book_in_shelfs = []\n        shelfs = ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).all()\n        for entry in shelfs:\n            book_in_shelfs.append(entry.shelf)\n\n        if not current_user.is_anonymous:\n            if not config.config_read_column:\n                matching_have_read_book = ub.session.query(ub.ReadBook). \\\n                    filter(and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == book_id)).all()\n                have_read = len(\n                    matching_have_read_book) > 0 and matching_have_read_book[0].read_status == ub.ReadBook.STATUS_FINISHED\n            else:\n                try:\n                    matching_have_read_book = getattr(entries, 'custom_column_' + str(config.config_read_column))\n                    have_read = len(matching_have_read_book) > 0 and matching_have_read_book[0].value\n                except (KeyError, AttributeError):\n                    log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n                    have_read = None\n\n            archived_book = ub.session.query(ub.ArchivedBook).\\\n                filter(and_(ub.ArchivedBook.user_id == int(current_user.id),\n                            ub.ArchivedBook.book_id == book_id)).first()\n            is_archived = archived_book and archived_book.is_archived\n\n        else:\n            have_read = None\n            is_archived = None\n\n        entries.tags = sort(entries.tags, key=lambda tag: tag.name)\n\n        entries = calibre_db.order_authors(entries)\n\n        kindle_list = check_send_to_kindle(entries)\n        reader_list = check_read_formats(entries)\n\n        audioentries = []\n        for media_format in entries.data:\n            if media_format.format.lower() in constants.EXTENSIONS_AUDIO:\n                audioentries.append(media_format.format.lower())\n\n        return render_title_template('detail.html',\n                                     entry=entries,\n                                     audioentries=audioentries,\n                                     cc=cc,\n                                     is_xhr=request.headers.get('X-Requested-With')=='XMLHttpRequest',\n                                     title=entries.title,\n                                     books_shelfs=book_in_shelfs,\n                                     have_read=have_read,\n                                     is_archived=is_archived,\n                                     kindle_list=kindle_list,\n                                     reader_list=reader_list,\n                                     page=\"book\")\n    else:\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler, GammaC0de, vuolter\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nimport re\nimport base64\nimport json\nimport time\nimport operator\nfrom datetime import datetime, timedelta\n\nfrom babel import Locale as LC\nfrom babel.dates import format_datetime\nfrom flask import Blueprint, flash, redirect, url_for, abort, request, make_response, send_from_directory, g, Response\nfrom flask_login import login_required, current_user, logout_user, confirm_login\nfrom flask_babel import gettext as _\nfrom flask import session as flask_session\nfrom sqlalchemy import and_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.exc import IntegrityError, OperationalError, InvalidRequestError\nfrom sqlalchemy.sql.expression import func, or_, text\n\nfrom . import constants, logger, helper, services\nfrom . import db, calibre_db, ub, web_server, get_locale, config, updater_thread, babel, gdriveutils, kobo_sync_status\nfrom .helper import check_valid_domain, send_test_mail, reset_password, generate_password_hash, check_email, \\\n    valid_email, check_username\nfrom .gdriveutils import is_gdrive_ready, gdrive_support\nfrom .render_template import render_title_template, get_sidebar_config\nfrom . import debug_info, _BABEL_TRANSLATIONS\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\nlog = logger.create()\n\nfeature_support = {\n        'ldap': bool(services.ldap),\n        'goodreads': bool(services.goodreads_support),\n        'kobo':  bool(services.kobo),\n        'updater': constants.UPDATER_AVAILABLE,\n        'gmail': bool(services.gmail)\n    }\n\ntry:\n    import rarfile  # pylint: disable=unused-import\n    feature_support['rar'] = True\nexcept (ImportError, SyntaxError):\n    feature_support['rar'] = False\n\ntry:\n    from .oauth_bb import oauth_check, oauthblueprints\n    feature_support['oauth'] = True\nexcept ImportError as err:\n    log.debug('Cannot import Flask-Dance, login with Oauth will not work: %s', err)\n    feature_support['oauth'] = False\n    oauthblueprints = []\n    oauth_check = {}\n\n\nfeature_support['gdrive'] = gdrive_support\nadmi = Blueprint('admin', __name__)\n\n\ndef admin_required(f):\n    \"\"\"\n    Checks if current_user.role == 1\n    \"\"\"\n\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\n@admi.before_app_request\ndef before_request():\n    # make remember me function work\n    if current_user.is_authenticated:\n        confirm_login()\n    if not ub.check_user_session(current_user.id, flask_session.get('_id')) and 'opds' not in request.path:\n        logout_user()\n    g.constants = constants\n    g.user = current_user\n    g.allow_registration = config.config_public_reg\n    g.allow_anonymous = config.config_anonbrowse\n    g.allow_upload = config.config_uploading\n    g.current_theme = config.config_theme\n    g.config_authors_max = config.config_authors_max\n    g.shelves_access = ub.session.query(ub.Shelf).filter(\n        or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == current_user.id)).order_by(ub.Shelf.name).all()\n    if '/static/' not in request.path and not config.db_configured and \\\n        request.endpoint not in ('admin.ajax_db_config',\n                                 'admin.simulatedbchange',\n                                 'admin.db_configuration',\n                                 'web.login',\n                                 'web.logout',\n                                 'admin.load_dialogtexts',\n                                 'admin.ajax_pathchooser'):\n        return redirect(url_for('admin.db_configuration'))\n\n\n@admi.route(\"/admin\")\n@login_required\ndef admin_forbidden():\n    abort(403)\n\n\n@admi.route(\"/shutdown\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef shutdown():\n    task = request.get_json().get('parameter', -1)\n    showtext = {}\n    if task in (0, 1):  # valid commandos received\n        # close all database connections\n        calibre_db.dispose()\n        ub.dispose()\n\n        if task == 0:\n            showtext['text'] = _(u'Server restarted, please reload page')\n        else:\n            showtext['text'] = _(u'Performing shutdown of server, please close window')\n        # stop gevent/tornado server\n        web_server.stop(task == 0)\n        return json.dumps(showtext)\n\n    if task == 2:\n        log.warning(\"reconnecting to calibre database\")\n        calibre_db.reconnect_db(config, ub.app_DB_path)\n        showtext['text'] = _(u'Reconnect successful')\n        return json.dumps(showtext)\n\n    showtext['text'] = _(u'Unknown command')\n    return json.dumps(showtext), 400\n\n\n@admi.route(\"/admin/view\")\n@login_required\n@admin_required\ndef admin():\n    version = updater_thread.get_current_version_info()\n    if version is False:\n        commit = _(u'Unknown')\n    else:\n        if 'datetime' in version:\n            commit = version['datetime']\n\n            tz = timedelta(seconds=time.timezone if (time.localtime().tm_isdst == 0) else time.altzone)\n            form_date = datetime.strptime(commit[:19], \"%Y-%m-%dT%H:%M:%S\")\n            if len(commit) > 19:    # check if string has timezone\n                if commit[19] == '+':\n                    form_date -= timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n                elif commit[19] == '-':\n                    form_date += timedelta(hours=int(commit[20:22]), minutes=int(commit[23:]))\n            commit = format_datetime(form_date - tz, format='short', locale=get_locale())\n        else:\n            commit = version['version']\n\n    allUser = ub.session.query(ub.User).all()\n    email_settings = config.get_mail_settings()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"admin.html\", allUser=allUser, email=email_settings, config=config, commit=commit,\n                                 feature_support=feature_support, kobo_support=kobo_support,\n                                 title=_(u\"Admin page\"), page=\"admin\")\n\n@admi.route(\"/admin/dbconfig\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef db_configuration():\n    if request.method == \"POST\":\n        return _db_configuration_update_helper()\n    return _db_configuration_result()\n\n\n@admi.route(\"/admin/config\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef configuration():\n    return render_title_template(\"config_edit.html\",\n                                 config=config,\n                                 provider=oauthblueprints,\n                                 feature_support=feature_support,\n                                 title=_(u\"Basic Configuration\"), page=\"config\")\n\n\n@admi.route(\"/admin/ajaxconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_config():\n    return _configuration_update_helper()\n\n\n@admi.route(\"/admin/ajaxdbconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef ajax_db_config():\n    return _db_configuration_update_helper()\n\n\n@admi.route(\"/admin/alive\", methods=[\"GET\"])\n@login_required\n@admin_required\ndef calibreweb_alive():\n    return \"\", 200\n\n@admi.route(\"/admin/viewconfig\")\n@login_required\n@admin_required\ndef view_configuration():\n    read_column = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all()\n    restrict_columns = calibre_db.session.query(db.Custom_Columns)\\\n        .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all()\n    languages = calibre_db.speaking_language()\n    translations = [LC('en')] + babel.list_translations()\n    return render_title_template(\"config_view_edit.html\", conf=config, readColumns=read_column,\n                                 restrictColumns=restrict_columns,\n                                 languages=languages,\n                                 translations=translations,\n                                 title=_(u\"UI Configuration\"), page=\"uiconfig\")\n\n@admi.route(\"/admin/usertable\")\n@login_required\n@admin_required\ndef edit_user_table():\n    visibility = current_user.view_settings.get('useredit', {})\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [LC('en')]\n    allUser = ub.session.query(ub.User)\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    if config.config_restricted_column:\n        custom_values = calibre_db.session.query(db.cc_classes[config.config_restricted_column]).all()\n    else:\n        custom_values = []\n    if not config.config_anonbrowse:\n        allUser = allUser.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    return render_title_template(\"user_table.html\",\n                                 users=allUser.all(),\n                                 tags=tags,\n                                 custom_values=custom_values,\n                                 translations=translations,\n                                 languages=languages,\n                                 visiblility=visibility,\n                                 all_roles=constants.ALL_ROLES,\n                                 kobo_support=kobo_support,\n                                 sidebar_settings=constants.sidebar_settings,\n                                 title=_(u\"Edit Users\"),\n                                 page=\"usertable\")\n\n\n@admi.route(\"/ajax/listusers\")\n@login_required\n@admin_required\ndef list_users():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or 10)\n    search = request.args.get(\"search\")\n    sort = request.args.get(\"sort\", \"id\")\n    order = request.args.get(\"order\", \"\").lower()\n    state = None\n    if sort == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n\n    if sort != \"state\" and order:\n        order = text(sort + \" \" + order)\n    elif not state:\n        order = ub.User.id.asc()\n\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n\n    total_count = filtered_count = all_user.count()\n\n    if search:\n        all_user = all_user.filter(or_(func.lower(ub.User.name).ilike(\"%\" + search + \"%\"),\n                                    func.lower(ub.User.kindle_mail).ilike(\"%\" + search + \"%\"),\n                                    func.lower(ub.User.email).ilike(\"%\" + search + \"%\")))\n    if state:\n        users = calibre_db.get_checkbox_sorted(all_user.all(), state, off, limit, request.args.get(\"order\", \"\").lower())\n    else:\n        users = all_user.order_by(order).offset(off).limit(limit).all()\n    if search:\n        filtered_count = len(users)\n\n    for user in users:\n        if user.default_language == \"all\":\n            user.default = _(\"All\")\n        else:\n            user.default = LC.parse(user.default_language).get_language_name(get_locale())\n\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": users}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@admi.route(\"/ajax/deleteuser\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user():\n    user_ids = request.form.to_dict(flat=False)\n    users = None\n    if \"userid[]\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id.in_(user_ids['userid[]'])).all()\n    elif \"userid\" in user_ids:\n        users = ub.session.query(ub.User).filter(ub.User.id == user_ids['userid'][0]).all()\n    count = 0\n    errors = list()\n    success = list()\n    if not users:\n        log.error(\"User not found\")\n        return Response(json.dumps({'type': \"danger\", 'message': _(\"User not found\")}), mimetype='application/json')\n    for user in users:\n        try:\n            message = _delete_user(user)\n            count += 1\n        except Exception as ex:\n            log.error(ex)\n            errors.append({'type': \"danger\", 'message': str(ex)})\n\n    if count == 1:\n        log.info(\"User {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': message}]\n    elif count > 1:\n        log.info(\"Users {} deleted\".format(user_ids))\n        success = [{'type': \"success\", 'message': _(\"{} users deleted successfully\").format(count)}]\n    success.extend(errors)\n    return Response(json.dumps(success), mimetype='application/json')\n\n@admi.route(\"/ajax/getlocale\")\n@login_required\n@admin_required\ndef table_get_locale():\n    locale = babel.list_translations() + [LC('en')]\n    ret = list()\n    current_locale = get_locale()\n    for loc in locale:\n        ret.append({'value': str(loc), 'text': loc.get_language_name(current_locale)})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/getdefaultlanguage\")\n@login_required\n@admin_required\ndef table_get_default_lang():\n    languages = calibre_db.speaking_language()\n    ret = list()\n    ret.append({'value': 'all', 'text': _('Show All')})\n    for lang in languages:\n        ret.append({'value': lang.lang_code, 'text': lang.name})\n    return json.dumps(ret)\n\n\n@admi.route(\"/ajax/editlistusers/<param>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_list_user(param):\n    vals = request.form.to_dict(flat=False)\n    all_user = ub.session.query(ub.User)\n    if not config.config_anonbrowse:\n        all_user = all_user.filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS)\n    # only one user is posted\n    if \"pk\" in vals:\n        users = [all_user.filter(ub.User.id == vals['pk'][0]).one_or_none()]\n    else:\n        if \"pk[]\" in vals:\n            users = all_user.filter(ub.User.id.in_(vals['pk[]'])).all()\n        else:\n            return _(\"Malformed request\"), 400\n    if 'field_index' in vals:\n        vals['field_index'] = vals['field_index'][0]\n    if 'value' in vals:\n        vals['value'] = vals['value'][0]\n    elif not ('value[]' in vals):\n        return _(\"Malformed request\"), 400\n    for user in users:\n        try:\n            if param in ['denied_tags', 'allowed_tags', 'allowed_column_value', 'denied_column_value']:\n                if 'value[]' in vals:\n                    setattr(user, param, prepare_tags(user, vals['action'][0], param, vals['value[]']))\n                else:\n                    setattr(user, param, vals['value'].strip())\n            else:\n                vals['value'] = vals['value'].strip()\n                if param == 'name':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest Name can't be changed\"))\n                    user.name = check_username(vals['value'])\n                elif param =='email':\n                    user.email = check_email(vals['value'])\n                elif param =='kobo_only_shelves_sync':\n                    user.kobo_only_shelves_sync = int(vals['value'] == 'true')\n                elif param == 'kindle_mail':\n                    user.kindle_mail = valid_email(vals['value']) if vals['value'] else \"\"\n                elif param.endswith('role'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value in \\\n                                 [constants.ROLE_ADMIN, constants.ROLE_PASSWD, constants.ROLE_EDIT_SHELFS]:\n                        raise Exception(_(\"Guest can't have this role\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.ROLE_VIEWER and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.role |= value\n                        elif vals['value'] == 'false':\n                            if value == constants.ROLE_ADMIN:\n                                if not ub.session.query(ub.User).\\\n                                       filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                              ub.User.id != user.id).count():\n                                    return Response(\n                                        json.dumps([{'type': \"danger\",\n                                                     'message':_(u\"No admin user remaining, can't remove admin role\",\n                                                                 nick=user.name)}]), mimetype='application/json')\n                            user.role &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid role\"))\n                elif param.startswith('sidebar'):\n                    value = int(vals['field_index'])\n                    if user.name == \"Guest\" and value == constants.SIDEBAR_READ_AND_UNREAD:\n                        raise Exception(_(\"Guest can't have this view\"))\n                    # check for valid value, last on checks for power of 2 value\n                    if value > 0 and value <= constants.SIDEBAR_LIST and (value & value-1 == 0 or value == 1):\n                        if vals['value'] == 'true':\n                            user.sidebar_view |= value\n                        elif vals['value'] == 'false':\n                            user.sidebar_view &= ~value\n                        else:\n                            raise Exception(_(\"Value has to be true or false\"))\n                    else:\n                        raise Exception(_(\"Invalid view\"))\n                elif param == 'locale':\n                    if user.name == \"Guest\":\n                        raise Exception(_(\"Guest's Locale is determined automatically and can't be set\"))\n                    if vals['value'] in _BABEL_TRANSLATIONS:\n                        user.locale = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Locale Given\"))\n                elif param == 'default_language':\n                    languages = calibre_db.session.query(db.Languages) \\\n                        .join(db.books_languages_link) \\\n                        .join(db.Books) \\\n                        .filter(calibre_db.common_filters()) \\\n                        .group_by(text('books_languages_link.lang_code')).all()\n                    lang_codes = [lang.lang_code for lang in languages] + [\"all\"]\n                    if vals['value'] in lang_codes:\n                        user.default_language = vals['value']\n                    else:\n                        raise Exception(_(\"No Valid Book Language Given\"))\n                else:\n                    return _(\"Parameter not found\"), 400\n        except Exception as ex:\n            log.debug_or_exception(ex)\n            return str(ex), 400\n    ub.session_commit()\n    return \"\"\n\n\n@admi.route(\"/ajax/user_table_settings\", methods=['POST'])\n@login_required\n@admin_required\ndef update_table_settings():\n    current_user.view_settings['useredit'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: {}\".format(request))\n        return \"Invalid request\", 400\n    return \"\"\n\ndef check_valid_read_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\\n              .filter(and_(db.Custom_Columns.datatype == 'bool', db.Custom_Columns.mark_for_delete == 0)).all():\n            return False\n    return True\n\ndef check_valid_restricted_column(column):\n    if column != \"0\":\n        if not calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.id == column) \\\n              .filter(and_(db.Custom_Columns.datatype == 'text', db.Custom_Columns.mark_for_delete == 0)).all():\n            return False\n    return True\n\n\n@admi.route(\"/admin/viewconfig\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_view_configuration():\n    to_save = request.form.to_dict()\n\n    _config_string(to_save, \"config_calibre_web_title\")\n    _config_string(to_save, \"config_columns_to_ignore\")\n    if _config_string(to_save, \"config_title_regex\"):\n        calibre_db.update_title_sort(config)\n\n    if not check_valid_read_column(to_save.get(\"config_read_column\", \"0\")):\n        flash(_(u\"Invalid Read Column\"), category=\"error\")\n        log.debug(\"Invalid Read column\")\n        return view_configuration()\n    _config_int(to_save, \"config_read_column\")\n\n    if not check_valid_restricted_column(to_save.get(\"config_restricted_column\", \"0\")):\n        flash(_(u\"Invalid Restricted Column\"), category=\"error\")\n        log.debug(\"Invalid Restricted Column\")\n        return view_configuration()\n    _config_int(to_save, \"config_restricted_column\")\n\n    _config_int(to_save, \"config_theme\")\n    _config_int(to_save, \"config_random_books\")\n    _config_int(to_save, \"config_books_per_page\")\n    _config_int(to_save, \"config_authors_max\")\n    _config_string(to_save, \"config_default_language\")\n    _config_string(to_save, \"config_default_locale\")\n\n\n    config.config_default_role = constants.selected_roles(to_save)\n    config.config_default_role &= ~constants.ROLE_ANONYMOUS\n\n    config.config_default_show = sum(int(k[5:]) for k in to_save if k.startswith('show_'))\n    if \"Show_detail_random\" in to_save:\n        config.config_default_show |= constants.DETAIL_RANDOM\n\n    config.save()\n    flash(_(u\"Calibre-Web configuration updated\"), category=\"success\")\n    log.debug(\"Calibre-Web configuration updated\")\n    before_request()\n\n    return view_configuration()\n\n\n@admi.route(\"/ajax/loaddialogtexts/<element_id>\", methods=['POST'])\n@login_required\ndef load_dialogtexts(element_id):\n    texts = {\"header\": \"\", \"main\": \"\", \"valid\": 1}\n    if element_id == \"config_delete_kobo_token\":\n        texts[\"main\"] = _('Do you really want to delete the Kobo Token?')\n    elif element_id == \"btndeletedomain\":\n        texts[\"main\"] = _('Do you really want to delete this domain?')\n    elif element_id == \"btndeluser\":\n        texts[\"main\"] = _('Do you really want to delete this user?')\n    elif element_id == \"delete_shelf\":\n        texts[\"main\"] = _('Are you sure you want to delete this shelf?')\n    elif element_id == \"select_locale\":\n        texts[\"main\"] = _('Are you sure you want to change locales of selected user(s)?')\n    elif element_id == \"select_default_language\":\n        texts[\"main\"] = _('Are you sure you want to change visible book languages for selected user(s)?')\n    elif element_id == \"role\":\n        texts[\"main\"] = _('Are you sure you want to change the selected role for the selected user(s)?')\n    elif element_id == \"restrictions\":\n        texts[\"main\"] = _('Are you sure you want to change the selected restrictions for the selected user(s)?')\n    elif element_id == \"sidebar_view\":\n        texts[\"main\"] = _('Are you sure you want to change the selected visibility restrictions for the selected user(s)?')\n    elif element_id == \"kobo_only_shelves_sync\":\n        texts[\"main\"] = _('Are you sure you want to change shelf sync behavior for the selected user(s)?')\n    elif element_id == \"db_submit\":\n        texts[\"main\"] = _('Are you sure you want to change Calibre library location?')\n    elif element_id == \"btnfullsync\":\n        texts[\"main\"] = _(\"Are you sure you want delete Calibre-Web's sync database to force a full sync with your Kobo Reader?\")\n    return json.dumps(texts)\n\n\n@admi.route(\"/ajax/editdomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_domain(allow):\n    # POST /post\n    # name:  'username',  //name of field (column in db)\n    # pk:    1            //primary key (record id)\n    # value: 'superuser!' //new value\n    vals = request.form.to_dict()\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.id == vals['pk']).first()\n    answer.domain = vals['value'].replace('*', '%').replace('?', '_').lower()\n    return ub.session_commit(\"Registering Domains edited {}\".format(answer.domain))\n\n\n@admi.route(\"/ajax/adddomain/<int:allow>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_domain(allow):\n    domain_name = request.form.to_dict()['domainname'].replace('*', '%').replace('?', '_').lower()\n    check = ub.session.query(ub.Registration).filter(ub.Registration.domain == domain_name)\\\n        .filter(ub.Registration.allow == allow).first()\n    if not check:\n        new_domain = ub.Registration(domain=domain_name, allow=allow)\n        ub.session.add(new_domain)\n        ub.session_commit(\"Registering Domains added {}\".format(domain_name))\n    return \"\"\n\n\n@admi.route(\"/ajax/deletedomain\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_domain():\n    try:\n        domain_id = request.form.to_dict()['domainid'].replace('*', '%').replace('?', '_').lower()\n        ub.session.query(ub.Registration).filter(ub.Registration.id == domain_id).delete()\n        ub.session_commit(\"Registering Domains deleted {}\".format(domain_id))\n        # If last domain was deleted, add all domains by default\n        if not ub.session.query(ub.Registration).filter(ub.Registration.allow == 1).count():\n            new_domain = ub.Registration(domain=\"%.%\", allow=1)\n            ub.session.add(new_domain)\n            ub.session_commit(\"Last Registering Domain deleted, added *.* as default\")\n    except KeyError:\n        pass\n    return \"\"\n\n\n@admi.route(\"/ajax/domainlist/<int:allow>\")\n@login_required\n@admin_required\ndef list_domain(allow):\n    answer = ub.session.query(ub.Registration).filter(ub.Registration.allow == allow).all()\n    json_dumps = json.dumps([{\"domain\": r.domain.replace('%', '*').replace('_', '?'), \"id\": r.id} for r in answer])\n    js = json.dumps(json_dumps.replace('\"', \"'\")).lstrip('\"').strip('\"')\n    response = make_response(js.replace(\"'\", '\"'))\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n\n@admi.route(\"/ajax/editrestriction/<int:res_type>\", defaults={\"user_id\": 0}, methods=['POST'])\n@admi.route(\"/ajax/editrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef edit_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if element['id'].startswith('a'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_allowed_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.allowed_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_allowed_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.allowed_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name, usr.allowed_column_value))\n    if element['id'].startswith('d'):\n        if res_type == 0:  # Tags as template\n            elementlist = config.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_tags = ','.join(elementlist)\n            config.save()\n        if res_type == 1:  # CustomC\n            elementlist = config.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            config.config_denied_column_value = ','.join(elementlist)\n            config.save()\n        if res_type == 2:  # Tags per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_tags()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_tags = ','.join(elementlist)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.denied_tags))\n        if res_type == 3:  # CColumn per user\n            if isinstance(user_id, int):\n                usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n            else:\n                usr = current_user\n            elementlist = usr.list_denied_column_values()\n            elementlist[int(element['id'][1:])] = element['Element']\n            usr.denied_column_value = ','.join(elementlist)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name, usr.denied_column_value))\n    return \"\"\n\n\ndef restriction_addition(element, list_func):\n    elementlist = list_func()\n    if elementlist == ['']:\n        elementlist = []\n    if not element['add_element'] in elementlist:\n        elementlist += [element['add_element']]\n    return ','.join(elementlist)\n\n\ndef restriction_deletion(element, list_func):\n    elementlist = list_func()\n    if element['Element'] in elementlist:\n        elementlist.remove(element['Element'])\n    return ','.join(elementlist)\n\n\ndef prepare_tags(user, action, tags_name, id_list):\n    if \"tags\" in tags_name:\n        tags = calibre_db.session.query(db.Tags).filter(db.Tags.id.in_(id_list)).all()\n        if not tags:\n            raise Exception(_(\"Tag not found\"))\n        new_tags_list = [x.name for x in tags]\n    else:\n        tags = calibre_db.session.query(db.cc_classes[config.config_restricted_column])\\\n            .filter(db.cc_classes[config.config_restricted_column].id.in_(id_list)).all()\n        new_tags_list = [x.value for x in tags]\n    saved_tags_list = user.__dict__[tags_name].split(\",\") if len(user.__dict__[tags_name]) else []\n    if action == \"remove\":\n        saved_tags_list = [x for x in saved_tags_list if x not in new_tags_list]\n    elif action == \"add\":\n        saved_tags_list.extend(x for x in new_tags_list if x not in saved_tags_list)\n    else:\n        raise Exception(_(\"Invalid Action\"))\n    return \",\".join(saved_tags_list)\n\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_user_0_restriction(res_type):\n    return add_restriction(res_type, 0)\n\n@admi.route(\"/ajax/addrestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef add_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if 'submit_allow' in element:\n            config.config_allowed_tags = restriction_addition(element, config.list_allowed_tags)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_tags = restriction_addition(element, config.list_denied_tags)\n            config.save()\n    if res_type == 1:  # CCustom as template\n        if 'submit_allow' in element:\n            config.config_allowed_column_value = restriction_addition(element, config.list_denied_column_values)\n            config.save()\n        elif 'submit_deny' in element:\n            config.config_denied_column_value = restriction_addition(element, config.list_allowed_column_values)\n            config.save()\n    if res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_tags = restriction_addition(element, usr.list_allowed_tags)\n            ub.session_commit(\"Changed allowed tags of user {} to {}\".format(usr.name, usr.list_allowed_tags()))\n        elif 'submit_deny' in element:\n            usr.denied_tags = restriction_addition(element, usr.list_denied_tags)\n            ub.session_commit(\"Changed denied tags of user {} to {}\".format(usr.name, usr.list_denied_tags()))\n    if res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if 'submit_allow' in element:\n            usr.allowed_column_value = restriction_addition(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Changed allowed columns of user {} to {}\".format(usr.name,\n                                                                                usr.list_allowed_column_values()))\n        elif 'submit_deny' in element:\n            usr.denied_column_value = restriction_addition(element, usr.list_denied_column_values)\n            ub.session_commit(\"Changed denied columns of user {} to {}\".format(usr.name,\n                                                                               usr.list_denied_column_values()))\n    return \"\"\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_user_0_restriction(res_type):\n    return delete_restriction(res_type, 0)\n\n\n@admi.route(\"/ajax/deleterestriction/<int:res_type>/<int:user_id>\", methods=['POST'])\n@login_required\n@admin_required\ndef delete_restriction(res_type, user_id):\n    element = request.form.to_dict()\n    if res_type == 0:  # Tags as template\n        if element['id'].startswith('a'):\n            config.config_allowed_tags = restriction_deletion(element, config.list_allowed_tags)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_tags = restriction_deletion(element, config.list_denied_tags)\n            config.save()\n    elif res_type == 1:  # CustomC as template\n        if element['id'].startswith('a'):\n            config.config_allowed_column_value = restriction_deletion(element, config.list_allowed_column_values)\n            config.save()\n        elif element['id'].startswith('d'):\n            config.config_denied_column_value = restriction_deletion(element, config.list_denied_column_values)\n            config.save()\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_tags = restriction_deletion(element, usr.list_allowed_tags)\n            ub.session_commit(\"Deleted allowed tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n        elif element['id'].startswith('d'):\n            usr.denied_tags = restriction_deletion(element, usr.list_denied_tags)\n            ub.session_commit(\"Deleted denied tags of user {}: {}\".format(usr.name, usr.list_allowed_tags))\n    elif res_type == 3:  # Columns per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()\n        else:\n            usr = current_user\n        if element['id'].startswith('a'):\n            usr.allowed_column_value = restriction_deletion(element, usr.list_allowed_column_values)\n            ub.session_commit(\"Deleted allowed columns of user {}: {}\".format(usr.name,\n                                                                              usr.list_allowed_column_values))\n\n        elif element['id'].startswith('d'):\n            usr.denied_column_value = restriction_deletion(element, usr.list_denied_column_values)\n            ub.session_commit(\"Deleted denied columns of user {}: {}\".format(usr.name,\n                                                                             usr.list_denied_column_values))\n    return \"\"\n\n\n@admi.route(\"/ajax/listrestriction/<int:res_type>\", defaults={\"user_id\": 0})\n@admi.route(\"/ajax/listrestriction/<int:res_type>/<int:user_id>\")\n@login_required\n@admin_required\ndef list_restriction(res_type, user_id):\n    if res_type == 0:   # Tags as template\n        restrict = [{'Element': x, 'type':_('Deny'), 'id': 'd'+str(i) }\n                    for i,x in enumerate(config.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 1:  # CustomC as template\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(config.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(config.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 2:  # Tags per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_tags()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_tags()) if x != '']\n        json_dumps = restrict + allow\n    elif res_type == 3:  # CustomC per user\n        if isinstance(user_id, int):\n            usr = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        else:\n            usr = current_user\n        restrict = [{'Element': x, 'type': _('Deny'), 'id': 'd'+str(i)}\n                    for i, x in enumerate(usr.list_denied_column_values()) if x != '']\n        allow = [{'Element': x, 'type': _('Allow'), 'id': 'a'+str(i)}\n                 for i, x in enumerate(usr.list_allowed_column_values()) if x != '']\n        json_dumps = restrict + allow\n    else:\n        json_dumps = \"\"\n    js = json.dumps(json_dumps)\n    response = make_response(js)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@admi.route(\"/ajax/fullsync\", methods=[\"POST\"])\n@login_required\ndef ajax_fullsync():\n    count = ub.session.query(ub.KoboSyncedBooks).filter(current_user.id == ub.KoboSyncedBooks.user_id).delete()\n    message = _(\"{} sync entries deleted\").format(count)\n    ub.session_commit(message)\n    return Response(json.dumps([{\"type\": \"success\", \"message\": message}]), mimetype='application/json')\n\n\n@admi.route(\"/ajax/pathchooser/\")\n@login_required\n@admin_required\ndef ajax_pathchooser():\n    return pathchooser()\n\n\ndef pathchooser():\n    browse_for = \"folder\"\n    folder_only = request.args.get('folder', False) == \"true\"\n    file_filter = request.args.get('filter', \"\")\n    path = os.path.normpath(request.args.get('path', \"\"))\n\n    if os.path.isfile(path):\n        oldfile = path\n        path = os.path.dirname(path)\n    else:\n        oldfile = \"\"\n\n    absolute = False\n\n    if os.path.isdir(path):\n        # if os.path.isabs(path):\n        cwd = os.path.realpath(path)\n        absolute = True\n        # else:\n        #    cwd = os.path.relpath(path)\n    else:\n        cwd = os.getcwd()\n\n    cwd = os.path.normpath(os.path.realpath(cwd))\n    parentdir = os.path.dirname(cwd)\n    if not absolute:\n        if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n            cwd = os.path.relpath(cwd)\n        else:\n            cwd = os.path.relpath(cwd) + os.path.sep\n        parentdir = os.path.relpath(parentdir) + os.path.sep\n\n    if os.path.realpath(cwd) == os.path.realpath(\"/\"):\n        parentdir = \"\"\n\n    try:\n        folders = os.listdir(cwd)\n    except Exception:\n        folders = []\n\n    files = []\n    for f in folders:\n        try:\n            data = {\"name\": f, \"fullpath\": os.path.join(cwd, f)}\n            data[\"sort\"] = data[\"fullpath\"].lower()\n        except Exception:\n            continue\n\n        if os.path.isfile(os.path.join(cwd, f)):\n            if folder_only:\n                continue\n            if file_filter != \"\" and file_filter != f:\n                continue\n            data[\"type\"] = \"file\"\n            data[\"size\"] = os.path.getsize(os.path.join(cwd, f))\n\n            power = 0\n            while (data[\"size\"] >> 10) > 0.3:\n                power += 1\n                data[\"size\"] >>= 10\n            units = (\"\", \"K\", \"M\", \"G\", \"T\")\n            data[\"size\"] = str(data[\"size\"]) + \" \" + units[power] + \"Byte\"\n        else:\n            data[\"type\"] = \"dir\"\n            data[\"size\"] = \"\"\n\n        files.append(data)\n\n    files = sorted(files, key=operator.itemgetter(\"type\", \"sort\"))\n\n    context = {\n        \"cwd\": cwd,\n        \"files\": files,\n        \"parentdir\": parentdir,\n        \"type\": browse_for,\n        \"oldfile\": oldfile,\n        \"absolute\": absolute,\n    }\n    return json.dumps(context)\n\n\ndef _config_int(to_save, x, func=int):\n    return config.set_from_dictionary(to_save, x, func)\n\n\ndef _config_checkbox(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y == \"on\", False)\n\n\ndef _config_checkbox_int(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: 1 if (y == \"on\") else 0, 0)\n\n\ndef _config_string(to_save, x):\n    return config.set_from_dictionary(to_save, x, lambda y: y.strip() if y else y)\n\n\ndef _configuration_gdrive_helper(to_save):\n    gdrive_error = None\n    if to_save.get(\"config_use_google_drive\"):\n        gdrive_secrets = {}\n\n        if not os.path.isfile(gdriveutils.SETTINGS_YAML):\n            config.config_use_google_drive = False\n\n        if gdrive_support:\n            gdrive_error = gdriveutils.get_error_text(gdrive_secrets)\n        if \"config_use_google_drive\" in to_save and not config.config_use_google_drive and not gdrive_error:\n            with open(gdriveutils.CLIENT_SECRETS, 'r') as settings:\n                gdrive_secrets = json.load(settings)['web']\n            if not gdrive_secrets:\n                return _configuration_result(_('client_secrets.json Is Not Configured For Web Application'))\n            gdriveutils.update_settings(\n                                gdrive_secrets['client_id'],\n                                gdrive_secrets['client_secret'],\n                                gdrive_secrets['redirect_uris'][0]\n                            )\n\n    # always show google drive settings, but in case of error deny support\n    new_gdrive_value = (not gdrive_error) and (\"config_use_google_drive\" in to_save)\n    if config.config_use_google_drive and not new_gdrive_value:\n        config.config_google_drive_watch_changes_response = {}\n    config.config_use_google_drive = new_gdrive_value\n    if _config_string(to_save, \"config_google_drive_folder\"):\n        gdriveutils.deleteDatabaseOnChange()\n    return gdrive_error\n\n\ndef _configuration_oauth_helper(to_save):\n    active_oauths = 0\n    reboot_required = False\n    for element in oauthblueprints:\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] != element['oauth_client_id'] \\\n            or to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"] != element['oauth_client_secret']:\n            reboot_required = True\n            element['oauth_client_id'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"]\n            element['oauth_client_secret'] = to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]\n        if to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"] \\\n            and to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"]:\n            active_oauths += 1\n            element[\"active\"] = 1\n        else:\n            element[\"active\"] = 0\n        ub.session.query(ub.OAuthProvider).filter(ub.OAuthProvider.id == element['id']).update(\n            {\"oauth_client_id\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_id\"],\n             \"oauth_client_secret\": to_save[\"config_\" + str(element['id']) + \"_oauth_client_secret\"],\n             \"active\": element[\"active\"]})\n    return reboot_required\n\n\ndef _configuration_logfile_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_int(to_save, \"config_log_level\")\n    reboot_required |= _config_string(to_save, \"config_logfile\")\n    if not logger.is_valid_logfile(config.config_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Logfile Location is not Valid, Please Enter Correct Path'))\n\n    reboot_required |= _config_checkbox_int(to_save, \"config_access_log\")\n    reboot_required |= _config_string(to_save, \"config_access_logfile\")\n    if not logger.is_valid_logfile(config.config_access_logfile):\n        return reboot_required, \\\n               _configuration_result(_('Access Logfile Location is not Valid, Please Enter Correct Path'))\n    return reboot_required, None\n\n\ndef _configuration_ldap_helper(to_save):\n    reboot_required = False\n    reboot_required |= _config_string(to_save, \"config_ldap_provider_url\")\n    reboot_required |= _config_int(to_save, \"config_ldap_port\")\n    reboot_required |= _config_int(to_save, \"config_ldap_authentication\")\n    reboot_required |= _config_string(to_save, \"config_ldap_dn\")\n    reboot_required |= _config_string(to_save, \"config_ldap_serv_username\")\n    reboot_required |= _config_string(to_save, \"config_ldap_user_object\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_object_filter\")\n    reboot_required |= _config_string(to_save, \"config_ldap_group_members_field\")\n    reboot_required |= _config_string(to_save, \"config_ldap_member_user_object\")\n    reboot_required |= _config_checkbox(to_save, \"config_ldap_openldap\")\n    reboot_required |= _config_int(to_save, \"config_ldap_encryption\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cacert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_cert_path\")\n    reboot_required |= _config_string(to_save, \"config_ldap_key_path\")\n    _config_string(to_save, \"config_ldap_group_name\")\n    if to_save.get(\"config_ldap_serv_password\", \"\") != \"\":\n        reboot_required |= 1\n        config.set_from_dictionary(to_save, \"config_ldap_serv_password\", base64.b64encode, encode='UTF-8')\n    config.save()\n\n    if not config.config_ldap_provider_url \\\n        or not config.config_ldap_port \\\n        or not config.config_ldap_dn \\\n        or not config.config_ldap_user_object:\n        return reboot_required, _configuration_result(_('Please Enter a LDAP Provider, '\n                                                        'Port, DN and User Object Identifier'))\n\n    if config.config_ldap_authentication > constants.LDAP_AUTH_ANONYMOUS:\n        if config.config_ldap_authentication > constants.LDAP_AUTH_UNAUTHENTICATE:\n            if not config.config_ldap_serv_username or not bool(config.config_ldap_serv_password):\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account and Password'))\n        else:\n            if not config.config_ldap_serv_username:\n                return reboot_required, _configuration_result(_('Please Enter a LDAP Service Account'))\n\n    if config.config_ldap_group_object_filter:\n        if config.config_ldap_group_object_filter.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Group Object Filter Needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_group_object_filter.count(\"(\") != config.config_ldap_group_object_filter.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Group Object Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_user_object.count(\"%s\") != 1:\n        return reboot_required, \\\n               _configuration_result(_('LDAP User Object Filter needs to Have One \"%s\" Format Identifier'))\n    if config.config_ldap_user_object.count(\"(\") != config.config_ldap_user_object.count(\")\"):\n        return reboot_required, _configuration_result(_('LDAP User Object Filter Has Unmatched Parenthesis'))\n\n    if to_save.get(\"ldap_import_user_filter\") == '0':\n        config.config_ldap_member_user_object = \"\"\n    else:\n        if config.config_ldap_member_user_object.count(\"%s\") != 1:\n            return reboot_required, \\\n                   _configuration_result(_('LDAP Member User Filter needs to Have One \"%s\" Format Identifier'))\n        if config.config_ldap_member_user_object.count(\"(\") != config.config_ldap_member_user_object.count(\")\"):\n            return reboot_required, _configuration_result(_('LDAP Member User Filter Has Unmatched Parenthesis'))\n\n    if config.config_ldap_cacert_path or config.config_ldap_cert_path or config.config_ldap_key_path:\n        if not (os.path.isfile(config.config_ldap_cacert_path) and\n                os.path.isfile(config.config_ldap_cert_path) and\n                os.path.isfile(config.config_ldap_key_path)):\n            return reboot_required, \\\n                   _configuration_result(_('LDAP CACertificate, Certificate or Key Location is not Valid, '\n                                           'Please Enter Correct Path'))\n    return reboot_required, None\n\n\n@admi.route(\"/ajax/simulatedbchange\", methods=['POST'])\n@login_required\n@admin_required\ndef simulatedbchange():\n    db_change, db_valid = _db_simulate_change()\n    return Response(json.dumps({\"change\": db_change, \"valid\": db_valid}), mimetype='application/json')\n\n\ndef _db_simulate_change():\n    param = request.form.to_dict()\n    to_save = {}\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           param['config_calibre_dir'],\n                                           flags=re.IGNORECASE).strip()\n    db_change = config.config_calibre_dir != to_save[\"config_calibre_dir\"] and config.config_calibre_dir\n    db_valid = calibre_db.check_valid_db(to_save[\"config_calibre_dir\"], ub.app_DB_path)\n    return db_change, db_valid\n\n\ndef _db_configuration_update_helper():\n    db_change = False\n    to_save = request.form.to_dict()\n    gdrive_error = None\n\n    to_save['config_calibre_dir'] = re.sub(r'[\\\\/]metadata\\.db$',\n                                           '',\n                                           to_save['config_calibre_dir'],\n                                           flags=re.IGNORECASE)\n    try:\n        db_change, db_valid = _db_simulate_change()\n\n        # gdrive_error drive setup\n        gdrive_error = _configuration_gdrive_helper(to_save)\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        _db_configuration_result(_(\"Settings DB is not Writeable\"), gdrive_error)\n    try:\n        metadata_db = os.path.join(to_save['config_calibre_dir'], \"metadata.db\")\n        if config.config_use_google_drive and is_gdrive_ready() and not os.path.exists(metadata_db):\n            gdriveutils.downloadFile(None, \"metadata.db\", metadata_db)\n            db_change = True\n    except Exception as ex:\n        return _db_configuration_result('{}'.format(ex), gdrive_error)\n\n    if db_change or not db_valid or not config.db_configured:\n        if not calibre_db.setup_db(to_save['config_calibre_dir'], ub.app_DB_path):\n            return _db_configuration_result(_('DB Location is not Valid, Please Enter Correct Path'),\n                                            gdrive_error)\n        # if db changed -> delete shelfs, delete download books, delete read books, kobo sync...\n        ub.session.query(ub.Downloads).delete()\n        ub.session.query(ub.ArchivedBook).delete()\n        ub.session.query(ub.ReadBook).delete()\n        ub.session.query(ub.BookShelf).delete()\n        ub.session.query(ub.Bookmark).delete()\n        ub.session.query(ub.KoboReadingState).delete()\n        ub.session.query(ub.KoboStatistics).delete()\n        ub.session.query(ub.KoboSyncedBooks).delete()\n        ub.session_commit()\n        _config_string(to_save, \"config_calibre_dir\")\n        calibre_db.update_config(config)\n        if not os.access(os.path.join(config.config_calibre_dir, \"metadata.db\"), os.W_OK):\n            flash(_(u\"DB is not Writeable\"), category=\"warning\")\n    config.save()\n    return _db_configuration_result(None, gdrive_error)\n\ndef _configuration_update_helper():\n    reboot_required = False\n    to_save = request.form.to_dict()\n    try:\n        reboot_required |= _config_int(to_save, \"config_port\")\n        reboot_required |= _config_string(to_save, \"config_trustedhosts\")\n        reboot_required |= _config_string(to_save, \"config_keyfile\")\n        if config.config_keyfile and not os.path.isfile(config.config_keyfile):\n            return _configuration_result(_('Keyfile Location is not Valid, Please Enter Correct Path'))\n\n        reboot_required |= _config_string(to_save, \"config_certfile\")\n        if config.config_certfile and not os.path.isfile(config.config_certfile):\n            return _configuration_result(_('Certfile Location is not Valid, Please Enter Correct Path'))\n\n        _config_checkbox_int(to_save, \"config_uploading\")\n        _config_checkbox_int(to_save, \"config_unicode_filename\")\n        # Reboot on config_anonbrowse with enabled ldap, as decoraters are changed in this case\n        reboot_required |= (_config_checkbox_int(to_save, \"config_anonbrowse\")\n                             and config.config_login_type == constants.LOGIN_LDAP)\n        _config_checkbox_int(to_save, \"config_public_reg\")\n        _config_checkbox_int(to_save, \"config_register_email\")\n        reboot_required |= _config_checkbox_int(to_save, \"config_kobo_sync\")\n        _config_int(to_save, \"config_external_port\")\n        _config_checkbox_int(to_save, \"config_kobo_proxy\")\n\n        if \"config_upload_formats\" in to_save:\n            to_save[\"config_upload_formats\"] = ','.join(\n                helper.uniq([x.lstrip().rstrip().lower() for x in to_save[\"config_upload_formats\"].split(',')]))\n            _config_string(to_save, \"config_upload_formats\")\n            constants.EXTENSIONS_UPLOAD = config.config_upload_formats.split(',')\n\n        _config_string(to_save, \"config_calibre\")\n        _config_string(to_save, \"config_converterpath\")\n        _config_string(to_save, \"config_kepubifypath\")\n\n        reboot_required |= _config_int(to_save, \"config_login_type\")\n\n        # LDAP configurator\n        if config.config_login_type == constants.LOGIN_LDAP:\n            reboot, message = _configuration_ldap_helper(to_save)\n            if message:\n                return message\n            reboot_required |= reboot\n\n        # Remote login configuration\n        _config_checkbox(to_save, \"config_remote_login\")\n        if not config.config_remote_login:\n            ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.token_type == 0).delete()\n\n        # Goodreads configuration\n        _config_checkbox(to_save, \"config_use_goodreads\")\n        _config_string(to_save, \"config_goodreads_api_key\")\n        _config_string(to_save, \"config_goodreads_api_secret\")\n        if services.goodreads_support:\n            services.goodreads_support.connect(config.config_goodreads_api_key,\n                                               config.config_goodreads_api_secret,\n                                               config.config_use_goodreads)\n\n        _config_int(to_save, \"config_updatechannel\")\n\n        # Reverse proxy login configuration\n        _config_checkbox(to_save, \"config_allow_reverse_proxy_header_login\")\n        _config_string(to_save, \"config_reverse_proxy_login_header_name\")\n\n        # OAuth configuration\n        if config.config_login_type == constants.LOGIN_OAUTH:\n            reboot_required |= _configuration_oauth_helper(to_save)\n\n        reboot, message = _configuration_logfile_helper(to_save)\n        if message:\n            return message\n        reboot_required |= reboot\n        # Rarfile Content configuration\n        _config_string(to_save, \"config_rarfile_location\")\n        if \"config_rarfile_location\" in to_save:\n            unrar_status = helper.check_unrar(config.config_rarfile_location)\n            if unrar_status:\n                return _configuration_result(unrar_status)\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        _configuration_result(_(\"Settings DB is not Writeable\"))\n\n    config.save()\n    if reboot_required:\n        web_server.stop(True)\n\n    return _configuration_result(None, reboot_required)\n\ndef _configuration_result(error_flash=None, reboot=False):\n    resp = {}\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        resp['result'] = [{'type': \"danger\", 'message': error_flash}]\n    else:\n        resp['result'] = [{'type': \"success\", 'message':_(u\"Calibre-Web configuration updated\")}]\n    resp['reboot'] = reboot\n    resp['config_upload']= config.config_upload_formats\n    return Response(json.dumps(resp), mimetype='application/json')\n\n\ndef _db_configuration_result(error_flash=None, gdrive_error=None):\n    gdrive_authenticate = not is_gdrive_ready()\n    gdrivefolders = []\n    if not gdrive_error and config.config_use_google_drive:\n        gdrive_error = gdriveutils.get_error_text()\n    if gdrive_error and gdrive_support:\n        log.error(gdrive_error)\n        gdrive_error = _(gdrive_error)\n        flash(gdrive_error, category=\"error\")\n    else:\n        if not gdrive_authenticate and gdrive_support:\n            gdrivefolders = gdriveutils.listRootFolders()\n    if error_flash:\n        log.error(error_flash)\n        config.load()\n        flash(error_flash, category=\"error\")\n    elif request.method == \"POST\" and not gdrive_error:\n        flash(_(\"Database Settings updated\"), category=\"success\")\n\n    return render_title_template(\"config_db.html\",\n                                 config=config,\n                                 show_authenticate_google_drive=gdrive_authenticate,\n                                 gdriveError=gdrive_error,\n                                 gdrivefolders=gdrivefolders,\n                                 feature_support=feature_support,\n                                 title=_(u\"Database Configuration\"), page=\"dbconfig\")\n\n\ndef _handle_new_user(to_save, content, languages, translations, kobo_support):\n    content.default_language = to_save[\"default_language\"]\n    content.locale = to_save.get(\"locale\", content.locale)\n\n    content.sidebar_view = sum(int(key[5:]) for key in to_save if key.startswith('show_'))\n    if \"show_detail_random\" in to_save:\n        content.sidebar_view |= constants.DETAIL_RANDOM\n\n    content.role = constants.selected_roles(to_save)\n    content.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if not to_save[\"name\"] or not to_save[\"email\"] or not to_save[\"password\"]:\n            log.info(\"Missing entries on new user\")\n            raise Exception(_(u\"Please fill out all fields!\"))\n        content.email = check_email(to_save[\"email\"])\n        # Query User name, if not existing, change\n        content.name = check_username(to_save[\"name\"])\n        if to_save.get(\"kindle_mail\"):\n            content.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if config.config_public_reg and not check_valid_domain(content.email):\n            log.info(\"E-mail: {} for new user is not from valid domain\".format(content.email))\n            raise Exception(_(u\"E-mail is not from valid domain\"))\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                     config=config,\n                                     translations=translations,\n                                     languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                     kobo_support=kobo_support, registered_oauth=oauth_check)\n    try:\n        content.allowed_tags = config.config_allowed_tags\n        content.denied_tags = config.config_denied_tags\n        content.allowed_column_value = config.config_allowed_column_value\n        content.denied_column_value = config.config_denied_column_value\n        # No default value for kobo sync shelf setting\n        content.kobo_only_shelves_sync = to_save.get(\"kobo_only_shelves_sync\", 0) == \"on\"\n        ub.session.add(content)\n        ub.session.commit()\n        flash(_(u\"User '%(user)s' created\", user=content.name), category=\"success\")\n        log.debug(\"User {} created\".format(content.name))\n        return redirect(url_for('admin.admin'))\n    except IntegrityError:\n        ub.session.rollback()\n        log.error(\"Found an existing account for {} or {}\".format(content.name, content.email))\n        flash(_(\"Found an existing account for this e-mail address or name.\"), category=\"error\")\n    except OperationalError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\ndef _delete_user(content):\n    if ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                        ub.User.id != content.id).count():\n        if content.name != \"Guest\":\n            # Delete all books in shelfs belonging to user, all shelfs of user, downloadstat of user, read status\n            # and user itself\n            ub.session.query(ub.ReadBook).filter(content.id == ub.ReadBook.user_id).delete()\n            ub.session.query(ub.Downloads).filter(content.id == ub.Downloads.user_id).delete()\n            for us in ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id):\n                ub.session.query(ub.BookShelf).filter(us.id == ub.BookShelf.shelf).delete()\n            ub.session.query(ub.Shelf).filter(content.id == ub.Shelf.user_id).delete()\n            ub.session.query(ub.User).filter(ub.User.id == content.id).delete()\n            ub.session_commit()\n            log.info(u\"User {} deleted\".format(content.name))\n            return(_(u\"User '%(nick)s' deleted\", nick=content.name))\n        else:\n            log.warning(_(u\"Can't delete Guest User\"))\n            raise Exception(_(u\"Can't delete Guest User\"))\n    else:\n        log.warning(u\"No admin user remaining, can't delete user\")\n        raise Exception(_(u\"No admin user remaining, can't delete user\"))\n\n\ndef _handle_edit_user(to_save, content, languages, translations, kobo_support):\n    if to_save.get(\"delete\"):\n        try:\n            flash(_delete_user(content), category=\"success\")\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    else:\n        if not ub.session.query(ub.User).filter(ub.User.role.op('&')(constants.ROLE_ADMIN) == constants.ROLE_ADMIN,\n                                                ub.User.id != content.id).count() and 'admin_role' not in to_save:\n            log.warning(\"No admin user remaining, can't remove admin role from {}\".format(content.name))\n            flash(_(\"No admin user remaining, can't remove admin role\"), category=\"error\")\n            return redirect(url_for('admin.admin'))\n        if to_save.get(\"password\"):\n            content.password = generate_password_hash(to_save[\"password\"])\n        anonymous = content.is_anonymous\n        content.role = constants.selected_roles(to_save)\n        if anonymous:\n            content.role |= constants.ROLE_ANONYMOUS\n        else:\n            content.role &= ~constants.ROLE_ANONYMOUS\n\n        val = [int(k[5:]) for k in to_save if k.startswith('show_')]\n        sidebar = get_sidebar_config()\n        for element in sidebar:\n            value = element['visibility']\n            if value in val and not content.check_visibility(value):\n                content.sidebar_view |= value\n            elif value not in val and content.check_visibility(value):\n                content.sidebar_view &= ~value\n\n        if to_save.get(\"Show_detail_random\"):\n            content.sidebar_view |= constants.DETAIL_RANDOM\n        else:\n            content.sidebar_view &= ~constants.DETAIL_RANDOM\n\n        old_state = content.kobo_only_shelves_sync\n        content.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs\n        # which don't have to be synced have to be removed (added to Shelf archive)\n        if old_state == 0 and content.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(content.id)\n        if to_save.get(\"default_language\"):\n            content.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            content.locale = to_save[\"locale\"]\n        try:\n            if to_save.get(\"email\", content.email) != content.email:\n                content.email = check_email(to_save[\"email\"])\n            # Query User name, if not existing, change\n            if to_save.get(\"name\", content.name) != content.name:\n                if to_save.get(\"name\") == \"Guest\":\n                    raise Exception(_(\"Guest Name can't be changed\"))\n                content.name = check_username(to_save[\"name\"])\n            if to_save.get(\"kindle_mail\") != content.kindle_mail:\n                content.kindle_mail = valid_email(to_save[\"kindle_mail\"]) if to_save[\"kindle_mail\"] else \"\"\n        except Exception as ex:\n            log.error(ex)\n            flash(str(ex), category=\"error\")\n            return render_title_template(\"user_edit.html\",\n                                         translations=translations,\n                                         languages=languages,\n                                         mail_configured=config.get_mail_server_configured(),\n                                         kobo_support=kobo_support,\n                                         new_user=0,\n                                         content=content,\n                                         config=config,\n                                         registered_oauth=oauth_check,\n                                         title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                         page=\"edituser\")\n    try:\n        ub.session_commit()\n        flash(_(u\"User '%(nick)s' updated\", nick=content.name), category=\"success\")\n    except IntegrityError as ex:\n        ub.session.rollback()\n        log.error(\"An unknown error occurred while changing user: {}\".format(str(ex)))\n        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n    except OperationalError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    return \"\"\n\n\n@admi.route(\"/admin/user/new\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef new_user():\n    content = ub.User()\n    languages = calibre_db.speaking_language()\n    translations = [LC('en')] + babel.list_translations()\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        _handle_new_user(to_save, content, languages, translations, kobo_support)\n    else:\n        content.role = config.config_default_role\n        content.sidebar_view = config.config_default_show\n        content.locale = config.config_default_locale\n        content.default_language = config.config_default_language\n    return render_title_template(\"user_edit.html\", new_user=1, content=content,\n                                 config=config, translations=translations,\n                                 languages=languages, title=_(u\"Add new user\"), page=\"newuser\",\n                                 kobo_support=kobo_support, registered_oauth=oauth_check)\n\n\n@admi.route(\"/admin/mailsettings\")\n@login_required\n@admin_required\ndef edit_mailsettings():\n    content = config.get_mail_settings()\n    return render_title_template(\"email_edit.html\", content=content, title=_(u\"Edit E-mail Server Settings\"),\n                                 page=\"mailset\", feature_support=feature_support)\n\n\n@admi.route(\"/admin/mailsettings\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef update_mailsettings():\n    to_save = request.form.to_dict()\n    _config_int(to_save, \"mail_server_type\")\n    if to_save.get(\"invalidate\"):\n        config.mail_gmail_token = {}\n        try:\n            flag_modified(config, \"mail_gmail_token\")\n        except AttributeError:\n            pass\n    elif to_save.get(\"gmail\"):\n        try:\n            config.mail_gmail_token = services.gmail.setup_gmail(config.mail_gmail_token)\n            flash(_(u\"Gmail Account Verification Successful\"), category=\"success\")\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            log.error(ex)\n            return edit_mailsettings()\n\n    else:\n        _config_string(to_save, \"mail_server\")\n        _config_int(to_save, \"mail_port\")\n        _config_int(to_save, \"mail_use_ssl\")\n        _config_string(to_save, \"mail_login\")\n        _config_string(to_save, \"mail_password\")\n        _config_string(to_save, \"mail_from\")\n        _config_int(to_save, \"mail_size\", lambda y: int(y)*1024*1024)\n    try:\n        config.save()\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n        return edit_mailsettings()\n\n    if to_save.get(\"test\"):\n        if current_user.email:\n            result = send_test_mail(current_user.email, current_user.name)\n            if result is None:\n                flash(_(u\"Test e-mail queued for sending to %(email)s, please check Tasks for result\",\n                        email=current_user.email), category=\"info\")\n            else:\n                flash(_(u\"There was an error sending the Test e-mail: %(res)s\", res=result), category=\"error\")\n        else:\n            flash(_(u\"Please configure your e-mail address first...\"), category=\"error\")\n    else:\n        flash(_(u\"E-mail server settings updated\"), category=\"success\")\n\n    return edit_mailsettings()\n\n\n@admi.route(\"/admin/user/<int:user_id>\", methods=[\"GET\", \"POST\"])\n@login_required\n@admin_required\ndef edit_user(user_id):\n    content = ub.session.query(ub.User).filter(ub.User.id == int(user_id)).first()  # type: ub.User\n    if not content or (not config.config_anonbrowse and content.name == \"Guest\"):\n        flash(_(u\"User not found\"), category=\"error\")\n        return redirect(url_for('admin.admin'))\n    languages = calibre_db.speaking_language(return_all_languages=True)\n    translations = babel.list_translations() + [LC('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        resp = _handle_edit_user(to_save, content, languages, translations, kobo_support)\n        if resp:\n            return resp\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 languages=languages,\n                                 new_user=0,\n                                 content=content,\n                                 config=config,\n                                 registered_oauth=oauth_check,\n                                 mail_configured=config.get_mail_server_configured(),\n                                 kobo_support=kobo_support,\n                                 title=_(u\"Edit User %(nick)s\", nick=content.name),\n                                 page=\"edituser\")\n\n\n@admi.route(\"/admin/resetpassword/<int:user_id>\", methods=[\"POST\"])\n@login_required\n@admin_required\ndef reset_user_password(user_id):\n    if current_user is not None and current_user.is_authenticated:\n        ret, message = reset_password(user_id)\n        if ret == 1:\n            log.debug(u\"Password for user %s reset\", message)\n            flash(_(u\"Password for user %(user)s reset\", user=message), category=\"success\")\n        elif ret == 0:\n            log.error(u\"An unknown error occurred. Please try again later.\")\n            flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n        else:\n            log.error(u\"Please configure the SMTP mail settings first...\")\n            flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    return redirect(url_for('admin.admin'))\n\n\n@admi.route(\"/admin/logfile\")\n@login_required\n@admin_required\ndef view_logfile():\n    logfiles = {0: logger.get_logfile(config.config_logfile),\n                1: logger.get_accesslogfile(config.config_access_logfile)}\n    return render_title_template(\"logviewer.html\",\n                                 title=_(u\"Logfile viewer\"),\n                                 accesslog_enable=config.config_access_log,\n                                 log_enable=bool(config.config_logfile != logger.LOG_TO_STDOUT),\n                                 logfiles=logfiles,\n                                 page=\"logfile\")\n\n\n@admi.route(\"/ajax/log/<int:logtype>\")\n@login_required\n@admin_required\ndef send_logfile(logtype):\n    if logtype == 1:\n        logfile = logger.get_accesslogfile(config.config_access_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    if logtype == 0:\n        logfile = logger.get_logfile(config.config_logfile)\n        return send_from_directory(os.path.dirname(logfile),\n                                   os.path.basename(logfile))\n    else:\n        return \"\"\n\n\n@admi.route(\"/admin/logdownload/<int:logtype>\")\n@login_required\n@admin_required\ndef download_log(logtype):\n    if logtype == 0:\n        file_name = logger.get_logfile(config.config_logfile)\n    elif logtype == 1:\n        file_name = logger.get_accesslogfile(config.config_access_logfile)\n    else:\n        abort(404)\n    if logger.is_valid_logfile(file_name):\n        return debug_info.assemble_logfiles(file_name)\n    abort(404)\n\n\n@admi.route(\"/admin/debug\")\n@login_required\n@admin_required\ndef download_debug():\n    return debug_info.send_debug()\n\n\n@admi.route(\"/get_update_status\", methods=['GET'])\n@login_required\n@admin_required\ndef get_update_status():\n    if feature_support['updater']:\n        log.info(u\"Update status requested\")\n        return updater_thread.get_available_updates(request.method, locale=get_locale())\n    else:\n        return ''\n\n\n@admi.route(\"/get_updater_status\", methods=['GET', 'POST'])\n@login_required\n@admin_required\ndef get_updater_status():\n    status = {}\n    if feature_support['updater']:\n        if request.method == \"POST\":\n            commit = request.form.to_dict()\n            if \"start\" in commit and commit['start'] == 'True':\n                text = {\n                    \"1\": _(u'Requesting update package'),\n                    \"2\": _(u'Downloading update package'),\n                    \"3\": _(u'Unzipping update package'),\n                    \"4\": _(u'Replacing files'),\n                    \"5\": _(u'Database connections are closed'),\n                    \"6\": _(u'Stopping server'),\n                    \"7\": _(u'Update finished, please press okay and reload page'),\n                    \"8\": _(u'Update failed:') + u' ' + _(u'HTTP Error'),\n                    \"9\": _(u'Update failed:') + u' ' + _(u'Connection error'),\n                    \"10\": _(u'Update failed:') + u' ' + _(u'Timeout while establishing connection'),\n                    \"11\": _(u'Update failed:') + u' ' + _(u'General error'),\n                    \"12\": _(u'Update failed:') + u' ' + _(u'Update file could not be saved in temp dir'),\n                    \"13\": _(u'Update failed:') + u' ' + _(u'Files could not be replaced during update')\n                }\n                status['text'] = text\n                updater_thread.status = 0\n                updater_thread.resume()\n                status['status'] = updater_thread.get_update_status()\n        elif request.method == \"GET\":\n            try:\n                status['status'] = updater_thread.get_update_status()\n                if status['status'] == -1:\n                    status['status'] = 7\n            except Exception:\n                status['status'] = 11\n        return json.dumps(status)\n    return ''\n\n\ndef ldap_import_create_user(user, user_data):\n    user_login_field = extract_dynamic_field_from_filter(user, config.config_ldap_user_object)\n\n    try:\n        username = user_data[user_login_field][0].decode('utf-8')\n    except KeyError as ex:\n        log.error(\"Failed to extract LDAP user: %s - %s\", user, ex)\n        message = _(u'Failed to extract at least One LDAP User')\n        return 0, message\n\n    # check for duplicate username\n    if ub.session.query(ub.User).filter(func.lower(ub.User.name) == username.lower()).first():\n        # if ub.session.query(ub.User).filter(ub.User.name == username).first():\n        log.warning(\"LDAP User  %s Already in Database\", user_data)\n        return 0, None\n\n    kindlemail = ''\n    if 'mail' in user_data:\n        useremail = user_data['mail'][0].decode('utf-8')\n        if len(user_data['mail']) > 1:\n            kindlemail = user_data['mail'][1].decode('utf-8')\n\n    else:\n        log.debug('No Mail Field Found in LDAP Response')\n        useremail = username + '@email.com'\n\n    try:\n        # check for duplicate email\n        useremail = check_email(useremail)\n    except Exception as ex:\n        log.warning(\"LDAP Email Error: {}, {}\".format(user_data, ex))\n        return 0, None\n    content = ub.User()\n    content.name = username\n    content.password = ''  # dummy password which will be replaced by ldap one\n    content.email = useremail\n    content.kindle_mail = kindlemail\n    content.default_language = config.config_default_language\n    content.locale = config.config_default_locale\n    content.role = config.config_default_role\n    content.sidebar_view = config.config_default_show\n    content.allowed_tags = config.config_allowed_tags\n    content.denied_tags = config.config_denied_tags\n    content.allowed_column_value = config.config_allowed_column_value\n    content.denied_column_value = config.config_denied_column_value\n    ub.session.add(content)\n    try:\n        ub.session.commit()\n        return 1, None    # increase no of users\n    except Exception as ex:\n        log.warning(\"Failed to create LDAP user: %s - %s\", user, ex)\n        ub.session.rollback()\n        message = _(u'Failed to Create at Least One LDAP User')\n        return 0, message\n\n\n@admi.route('/import_ldap_users', methods=[\"POST\"])\n@login_required\n@admin_required\ndef import_ldap_users():\n    showtext = {}\n    try:\n        new_users = services.ldap.get_group_members(config.config_ldap_group_name)\n    except (services.ldap.LDAPException, TypeError, AttributeError, KeyError) as e:\n        log.debug_or_exception(e)\n        showtext['text'] = _(u'Error: %(ldaperror)s', ldaperror=e)\n        return json.dumps(showtext)\n    if not new_users:\n        log.debug('LDAP empty response')\n        showtext['text'] = _(u'Error: No user returned in response of LDAP server')\n        return json.dumps(showtext)\n\n    imported = 0\n    for username in new_users:\n        user = username.decode('utf-8')\n        if '=' in user:\n            # if member object field is empty take user object as filter\n            if config.config_ldap_member_user_object:\n                query_filter = config.config_ldap_member_user_object\n            else:\n                query_filter = config.config_ldap_user_object\n            try:\n                user_identifier = extract_user_identifier(user, query_filter)\n            except Exception as ex:\n                log.warning(ex)\n                continue\n        else:\n            user_identifier = user\n            query_filter = None\n        try:\n            user_data = services.ldap.get_object_details(user=user_identifier, query_filter=query_filter)\n        except AttributeError as ex:\n            log.debug_or_exception(ex)\n            continue\n        if user_data:\n            user_count, message = ldap_import_create_user(user, user_data)\n            if message:\n                showtext['text'] = message\n            else:\n                imported += user_count\n        else:\n            log.warning(\"LDAP User: %s Not Found\", user)\n            showtext['text'] = _(u'At Least One LDAP User Not Found in Database')\n    if not showtext:\n        showtext['text'] = _(u'{} User Successfully Imported'.format(imported))\n    return json.dumps(showtext)\n\n\ndef extract_user_data_from_field(user, field):\n    match = re.search(field + r\"=([\\.\\d\\s\\w-]+)\", user, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP User: {}\".format(user))\n\n\ndef extract_dynamic_field_from_filter(user, filtr):\n    match = re.search(\"([a-zA-Z0-9-]+)=%s\", filtr, re.IGNORECASE | re.UNICODE)\n    if match:\n        return match.group(1)\n    else:\n        raise Exception(\"Could Not Parse LDAP Userfield: {}\", user)\n\n\ndef extract_user_identifier(user, filtr):\n    dynamic_field = extract_dynamic_field_from_filter(user, filtr)\n    return extract_user_data_from_field(user, dynamic_field)\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nfrom shutil import copyfile\nfrom uuid import uuid4\nfrom markupsafe import escape\nfrom functools import wraps\n\ntry:\n    from lxml.html.clean import clean_html\nexcept ImportError:\n    pass\n\n# Improve this to check if scholarly is available in a global way, like other pythonic libraries\ntry:\n    from scholarly import scholarly\n    have_scholar = True\nexcept ImportError:\n    have_scholar = False\n\nfrom flask import Blueprint, request, flash, redirect, url_for, abort, Markup, Response\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import OperationalError, IntegrityError\nfrom sqlite3 import OperationalError as sqliteOperationalError\nfrom . import constants, logger, isoLanguages, gdriveutils, uploader, helper, kobo_sync_status\nfrom . import config, get_locale, ub, db\nfrom . import calibre_db\nfrom .services.worker import WorkerThread\nfrom .tasks.upload import TaskUpload\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\n\neditbook = Blueprint('editbook', __name__)\nlog = logger.create()\n\n\ndef upload_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_upload():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef edit_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_edit() or current_user.role_admin():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\ndef search_objects_remove(db_book_object, db_type, input_elements):\n    del_elements = []\n    for c_elements in db_book_object:\n        found = False\n        if db_type == 'languages':\n            type_elements = c_elements.lang_code\n        elif db_type == 'custom':\n            type_elements = c_elements.value\n        else:\n            type_elements = c_elements.name\n        for inp_element in input_elements:\n            if inp_element.lower() == type_elements.lower():\n                # if inp_element == type_elements:\n                found = True\n                break\n        # if the element was not found in the new list, add it to remove list\n        if not found:\n            del_elements.append(c_elements)\n    return del_elements\n\n\ndef search_objects_add(db_book_object, db_type, input_elements):\n    add_elements = []\n    for inp_element in input_elements:\n        found = False\n        for c_elements in db_book_object:\n            if db_type == 'languages':\n                type_elements = c_elements.lang_code\n            elif db_type == 'custom':\n                type_elements = c_elements.value\n            else:\n                type_elements = c_elements.name\n            if inp_element == type_elements:\n                found = True\n                break\n        if not found:\n            add_elements.append(inp_element)\n    return add_elements\n\n\ndef remove_objects(db_book_object, db_session, del_elements):\n    changed = False\n    if len(del_elements) > 0:\n        for del_element in del_elements:\n            db_book_object.remove(del_element)\n            changed = True\n            if len(del_element.books) == 0:\n                db_session.delete(del_element)\n    return changed\n\ndef add_objects(db_book_object, db_object, db_session, db_type, add_elements):\n    changed = False\n    if db_type == 'languages':\n        db_filter = db_object.lang_code\n    elif db_type == 'custom':\n        db_filter = db_object.value\n    else:\n        db_filter = db_object.name\n    for add_element in add_elements:\n        # check if a element with that name exists\n        db_element = db_session.query(db_object).filter(db_filter == add_element).first()\n        # if no element is found add it\n        # if new_element is None:\n        if db_type == 'author':\n            new_element = db_object(add_element, helper.get_sorted_author(add_element.replace('|', ',')), \"\")\n        elif db_type == 'series':\n            new_element = db_object(add_element, add_element)\n        elif db_type == 'custom':\n            new_element = db_object(value=add_element)\n        elif db_type == 'publisher':\n            new_element = db_object(add_element, None)\n        else:  # db_type should be tag or language\n            new_element = db_object(add_element)\n        if db_element is None:\n            changed = True\n            db_session.add(new_element)\n            db_book_object.append(new_element)\n        else:\n            db_element = create_objects_for_addition(db_element, add_element, db_type)\n            changed = True\n            # add element to book\n            changed = True\n            db_book_object.append(db_element)\n    return changed\n\n\ndef create_objects_for_addition(db_element, add_element, db_type):\n    if db_type == 'custom':\n        if db_element.value != add_element:\n            db_element.value = add_element  # ToDo: Before new_element, but this is not plausible\n    elif db_type == 'languages':\n        if db_element.lang_code != add_element:\n            db_element.lang_code = add_element\n    elif db_type == 'series':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element\n    elif db_type == 'author':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = add_element.replace('|', ',')\n    elif db_type == 'publisher':\n        if db_element.name != add_element:\n            db_element.name = add_element\n            db_element.sort = None\n    elif db_element.name != add_element:\n        db_element.name = add_element\n    return db_element\n\n\n# Modifies different Database objects, first check if elements if elements have to be deleted,\n# because they are no longer used, than check if elements have to be added to database\ndef modify_database_object(input_elements, db_book_object, db_object, db_session, db_type):\n    # passing input_elements not as a list may lead to undesired results\n    if not isinstance(input_elements, list):\n        raise TypeError(str(input_elements) + \" should be passed as a list\")\n    input_elements = [x for x in input_elements if x != '']\n    # we have all input element (authors, series, tags) names now\n    # 1. search for elements to remove\n    del_elements = search_objects_remove(db_book_object, db_type, input_elements)\n    # 2. search for elements that need to be added\n    add_elements = search_objects_add(db_book_object, db_type, input_elements)\n    # if there are elements to remove, we remove them now\n    changed = remove_objects(db_book_object, db_session, del_elements)\n    # if there are elements to add, we add them now!\n    if len(add_elements) > 0:\n        changed |= add_objects(db_book_object, db_object, db_session, db_type, add_elements)\n    return changed\n\n\ndef modify_identifiers(input_identifiers, db_identifiers, db_session):\n    \"\"\"Modify Identifiers to match input information.\n       input_identifiers is a list of read-to-persist Identifiers objects.\n       db_identifiers is a list of already persisted list of Identifiers objects.\"\"\"\n    changed = False\n    error = False\n    input_dict = dict([(identifier.type.lower(), identifier) for identifier in input_identifiers])\n    if len(input_identifiers) != len(input_dict):\n        error = True\n    db_dict = dict([(identifier.type.lower(), identifier) for identifier in db_identifiers ])\n    # delete db identifiers not present in input or modify them with input val\n    for identifier_type, identifier in db_dict.items():\n        if identifier_type not in input_dict.keys():\n            db_session.delete(identifier)\n            changed = True\n        else:\n            input_identifier = input_dict[identifier_type]\n            identifier.type = input_identifier.type\n            identifier.val = input_identifier.val\n    # add input identifiers not present in db\n    for identifier_type, identifier in input_dict.items():\n        if identifier_type not in db_dict.keys():\n            db_session.add(identifier)\n            changed = True\n    return changed, error\n\n@editbook.route(\"/ajax/delete/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef delete_book_from_details(book_id):\n    return Response(delete_book_from_table(book_id, \"\", True), mimetype='application/json')\n\n\n@editbook.route(\"/delete/<int:book_id>\", defaults={'book_format': \"\"}, methods=[\"POST\"])\n@editbook.route(\"/delete/<int:book_id>/<string:book_format>\", methods=[\"POST\"])\n@login_required\ndef delete_book_ajax(book_id, book_format):\n    return delete_book_from_table(book_id, book_format, False)\n\n\ndef delete_whole_book(book_id, book):\n    # delete book from Shelfs, Downloads, Read list\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).delete()\n    ub.session.query(ub.ReadBook).filter(ub.ReadBook.book_id == book_id).delete()\n    ub.delete_download(book_id)\n    ub.session_commit()\n\n    # check if only this book links to:\n    # author, language, series, tags, custom columns\n    modify_database_object([u''], book.authors, db.Authors, calibre_db.session, 'author')\n    modify_database_object([u''], book.tags, db.Tags, calibre_db.session, 'tags')\n    modify_database_object([u''], book.series, db.Series, calibre_db.session, 'series')\n    modify_database_object([u''], book.languages, db.Languages, calibre_db.session, 'languages')\n    modify_database_object([u''], book.publishers, db.Publishers, calibre_db.session, 'publishers')\n\n    cc = calibre_db.session.query(db.Custom_Columns). \\\n        filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                if c.datatype == 'bool' or c.datatype == 'integer' or c.datatype == 'float':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n                elif c.datatype == 'rating':\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if len(del_cc.books) == 0:\n                        log.debug('remove ' + str(c.id))\n                        calibre_db.session.delete(del_cc)\n                        calibre_db.session.commit()\n                else:\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    log.debug('remove ' + str(c.id))\n                    calibre_db.session.delete(del_cc)\n                    calibre_db.session.commit()\n        else:\n            modify_database_object([u''], getattr(book, cc_string), db.cc_classes[c.id],\n                                   calibre_db.session, 'custom')\n    calibre_db.session.query(db.Books).filter(db.Books.id == book_id).delete()\n\n\ndef render_delete_book_result(book_format, jsonResponse, warning, book_id):\n    if book_format:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Format Successfully Deleted')}])\n        else:\n            flash(_('Book Format Successfully Deleted'), category=\"success\")\n            return redirect(url_for('editbook.edit_book', book_id=book_id))\n    else:\n        if jsonResponse:\n            return json.dumps([warning, {\"location\": url_for('web.index'),\n                                         \"type\": \"success\",\n                                         \"format\": book_format,\n                                         \"message\": _('Book Successfully Deleted')}])\n        else:\n            flash(_('Book Successfully Deleted'), category=\"success\")\n            return redirect(url_for('web.index'))\n\n\ndef delete_book_from_table(book_id, book_format, jsonResponse):\n    warning = {}\n    if current_user.role_delete_books():\n        book = calibre_db.get_book(book_id)\n        if book:\n            try:\n                result, error = helper.delete_book(book, config.config_calibre_dir, book_format=book_format.upper())\n                if not result:\n                    if jsonResponse:\n                        return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                           \"type\": \"danger\",\n                                           \"format\": \"\",\n                                           \"message\": error}])\n                    else:\n                        flash(error, category=\"error\")\n                        return redirect(url_for('editbook.edit_book', book_id=book_id))\n                if error:\n                    if jsonResponse:\n                        warning = {\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                                \"type\": \"warning\",\n                                                \"format\": \"\",\n                                                \"message\": error}\n                    else:\n                        flash(error, category=\"warning\")\n                if not book_format:\n                    delete_whole_book(book_id, book)\n                else:\n                    calibre_db.session.query(db.Data).filter(db.Data.book == book.id).\\\n                        filter(db.Data.format == book_format).delete()\n                calibre_db.session.commit()\n            except Exception as ex:\n                log.debug_or_exception(ex)\n                calibre_db.session.rollback()\n                if jsonResponse:\n                    return json.dumps([{\"location\": url_for(\"editbook.edit_book\", book_id=book_id),\n                                        \"type\": \"danger\",\n                                        \"format\": \"\",\n                                        \"message\": ex}])\n                else:\n                    flash(str(ex), category=\"error\")\n                    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n        else:\n            # book not found\n            log.error('Book with id \"%s\" could not be deleted: not found', book_id)\n    return render_delete_book_result(book_format, jsonResponse, warning, book_id)\n\n\ndef render_edit_book(book_id):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    for lang in book.languages:\n        lang.language_name = isoLanguages.get_language_name(get_locale(), lang.lang_code)\n\n    book = calibre_db.order_authors(book)\n\n    author_names = []\n    for authr in book.authors:\n        author_names.append(authr.name.replace('|', ','))\n\n    # Option for showing convertbook button\n    valid_source_formats=list()\n    allowed_conversion_formats = list()\n    kepub_possible=None\n    if config.config_converterpath:\n        for file in book.data:\n            if file.format.lower() in constants.EXTENSIONS_CONVERT_FROM:\n                valid_source_formats.append(file.format.lower())\n    if config.config_kepubifypath and 'epub' in [file.format.lower() for file in book.data]:\n        kepub_possible = True\n        if not config.config_converterpath:\n            valid_source_formats.append('epub')\n\n    # Determine what formats don't already exist\n    if config.config_converterpath:\n        allowed_conversion_formats = constants.EXTENSIONS_CONVERT_TO[:]\n        for file in book.data:\n            if file.format.lower() in allowed_conversion_formats:\n                allowed_conversion_formats.remove(file.format.lower())\n    if kepub_possible:\n        allowed_conversion_formats.append('kepub')\n    return render_title_template('book_edit.html', book=book, authors=author_names, cc=cc,\n                                 title=_(u\"edit metadata\"), page=\"editbook\",\n                                 conversion_formats=allowed_conversion_formats,\n                                 config=config,\n                                 source_formats=valid_source_formats)\n\n\ndef edit_book_ratings(to_save, book):\n    changed = False\n    if to_save[\"rating\"].strip():\n        old_rating = False\n        if len(book.ratings) > 0:\n            old_rating = book.ratings[0].rating\n        ratingx2 = int(float(to_save[\"rating\"]) * 2)\n        if ratingx2 != old_rating:\n            changed = True\n            is_rating = calibre_db.session.query(db.Ratings).filter(db.Ratings.rating == ratingx2).first()\n            if is_rating:\n                book.ratings.append(is_rating)\n            else:\n                new_rating = db.Ratings(rating=ratingx2)\n                book.ratings.append(new_rating)\n            if old_rating:\n                book.ratings.remove(book.ratings[0])\n    else:\n        if len(book.ratings) > 0:\n            book.ratings.remove(book.ratings[0])\n            changed = True\n    return changed\n\ndef edit_book_tags(tags, book):\n    input_tags = tags.split(',')\n    input_tags = list(map(lambda it: it.strip(), input_tags))\n    # Remove duplicates\n    input_tags = helper.uniq(input_tags)\n    return modify_database_object(input_tags, book.tags, db.Tags, calibre_db.session, 'tags')\n\n\ndef edit_book_series(series, book):\n    input_series = [series.strip()]\n    input_series = [x for x in input_series if x != '']\n    return modify_database_object(input_series, book.series, db.Series, calibre_db.session, 'series')\n\n\ndef edit_book_series_index(series_index, book):\n    # Add default series_index to book\n    modif_date = False\n    series_index = series_index or '1'\n    if not series_index.replace('.', '', 1).isdigit():\n        flash(_(\"%(seriesindex)s is not a valid number, skipping\", seriesindex=series_index), category=\"warning\")\n        return False\n    if str(book.series_index) != series_index:\n        book.series_index = series_index\n        modif_date = True\n    return modif_date\n\n\n# Handle book comments/description\ndef edit_book_comments(comments, book):\n    modif_date = False\n    if comments:\n        comments = clean_html(comments)\n    if len(book.comments):\n        if book.comments[0].text != comments:\n            book.comments[0].text = comments\n            modif_date = True\n    else:\n        if comments:\n            book.comments.append(db.Comments(text=comments, book=book.id))\n            modif_date = True\n    return modif_date\n\n\ndef edit_book_languages(languages, book, upload=False, invalid=None):\n    input_languages = languages.split(',')\n    unknown_languages = []\n    if not upload:\n        input_l = isoLanguages.get_language_codes(get_locale(), input_languages, unknown_languages)\n    else:\n        input_l = isoLanguages.get_valid_language_codes(get_locale(), input_languages, unknown_languages)\n    for l in unknown_languages:\n        log.error(\"'%s' is not a valid language\", l)\n        if isinstance(invalid, list):\n            invalid.append(l)\n        else:\n            raise ValueError(_(u\"'%(langname)s' is not a valid language\", langname=l))\n    # ToDo: Not working correct\n    if upload and len(input_l) == 1:\n        # If the language of the file is excluded from the users view, it's not imported, to allow the user to view\n        # the book it's language is set to the filter language\n        if input_l[0] != current_user.filter_language() and current_user.filter_language() != \"all\":\n            input_l[0] = calibre_db.session.query(db.Languages). \\\n                filter(db.Languages.lang_code == current_user.filter_language()).first().lang_code\n    # Remove duplicates\n    input_l = helper.uniq(input_l)\n    return modify_database_object(input_l, book.languages, db.Languages, calibre_db.session, 'languages')\n\n\ndef edit_book_publisher(publishers, book):\n    changed = False\n    if publishers:\n        publisher = publishers.rstrip().strip()\n        if len(book.publishers) == 0 or (len(book.publishers) > 0 and publisher != book.publishers[0].name):\n            changed |= modify_database_object([publisher], book.publishers, db.Publishers, calibre_db.session,\n                                              'publisher')\n    elif len(book.publishers):\n        changed |= modify_database_object([], book.publishers, db.Publishers, calibre_db.session, 'publisher')\n    return changed\n\n\ndef edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if to_save[cc_string] == 'None':\n        to_save[cc_string] = None\n    elif c.datatype == 'bool':\n        to_save[cc_string] = 1 if to_save[cc_string] == 'True' else 0\n    elif c.datatype == 'comments':\n        to_save[cc_string] = Markup(to_save[cc_string]).unescape()\n        if to_save[cc_string]:\n            to_save[cc_string] = clean_html(to_save[cc_string])\n    elif c.datatype == 'datetime':\n        try:\n            to_save[cc_string] = datetime.strptime(to_save[cc_string], \"%Y-%m-%d\")\n        except ValueError:\n            to_save[cc_string] = db.Books.DEFAULT_PUBDATE\n\n    if to_save[cc_string] != cc_db_value:\n        if cc_db_value is not None:\n            if to_save[cc_string] is not None:\n                setattr(getattr(book, cc_string)[0], 'value', to_save[cc_string])\n                changed = True\n            else:\n                del_cc = getattr(book, cc_string)[0]\n                getattr(book, cc_string).remove(del_cc)\n                calibre_db.session.delete(del_cc)\n                changed = True\n        else:\n            cc_class = db.cc_classes[c.id]\n            new_cc = cc_class(value=to_save[cc_string], book=book_id)\n            calibre_db.session.add(new_cc)\n            changed = True\n    return changed, to_save\n\n\ndef edit_cc_data_string(book, c, to_save, cc_db_value, cc_string):\n    changed = False\n    if c.datatype == 'rating':\n        to_save[cc_string] = str(int(float(to_save[cc_string]) * 2))\n    if to_save[cc_string].strip() != cc_db_value:\n        if cc_db_value is not None:\n            # remove old cc_val\n            del_cc = getattr(book, cc_string)[0]\n            getattr(book, cc_string).remove(del_cc)\n            if len(del_cc.books) == 0:\n                calibre_db.session.delete(del_cc)\n                changed = True\n        cc_class = db.cc_classes[c.id]\n        new_cc = calibre_db.session.query(cc_class).filter(\n            cc_class.value == to_save[cc_string].strip()).first()\n        # if no cc val is found add it\n        if new_cc is None:\n            new_cc = cc_class(value=to_save[cc_string].strip())\n            calibre_db.session.add(new_cc)\n            changed = True\n            calibre_db.session.flush()\n            new_cc = calibre_db.session.query(cc_class).filter(\n                cc_class.value == to_save[cc_string].strip()).first()\n        # add cc value to book\n        getattr(book, cc_string).append(new_cc)\n    return changed, to_save\n\ndef edit_single_cc_data(book_id, book, column_id, to_save):\n    cc = (calibre_db.session.query(db.Custom_Columns)\n          .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions))\n          .filter(db.Custom_Columns.id == column_id)\n          .all())\n    return edit_cc_data(book_id, book, to_save, cc)\n\ndef edit_all_cc_data(book_id, book, to_save):\n    cc = calibre_db.session.query(db.Custom_Columns).filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).all()\n    return edit_cc_data(book_id, book, to_save, cc)\n\ndef edit_cc_data(book_id, book, to_save, cc):\n    changed = False\n    for c in cc:\n        cc_string = \"custom_column_\" + str(c.id)\n        if not c.is_multiple:\n            if len(getattr(book, cc_string)) > 0:\n                cc_db_value = getattr(book, cc_string)[0].value\n            else:\n                cc_db_value = None\n            if to_save[cc_string].strip():\n                if c.datatype in ['int', 'bool', 'float', \"datetime\", \"comments\"]:\n                    changed, to_save = edit_cc_data_value(book_id, book, c, to_save, cc_db_value, cc_string)\n                else:\n                    changed, to_save = edit_cc_data_string(book, c, to_save, cc_db_value, cc_string)\n            else:\n                if cc_db_value is not None:\n                    # remove old cc_val\n                    del_cc = getattr(book, cc_string)[0]\n                    getattr(book, cc_string).remove(del_cc)\n                    if not del_cc.books or len(del_cc.books) == 0:\n                        calibre_db.session.delete(del_cc)\n                        changed = True\n        else:\n            input_tags = to_save[cc_string].split(',')\n            input_tags = list(map(lambda it: it.strip(), input_tags))\n            changed |= modify_database_object(input_tags,\n                                              getattr(book, cc_string),\n                                              db.cc_classes[c.id],\n                                              calibre_db.session,\n                                              'custom')\n    return changed\n\ndef upload_single_file(request, book, book_id):\n    # Check and handle Uploaded file\n    if 'btn-upload-format' in request.files:\n        requested_file = request.files['btn-upload-format']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            if '.' in requested_file.filename:\n                file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n                if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n                    flash(_(\"File extension '%(ext)s' is not allowed to be uploaded to this server\", ext=file_ext),\n                          category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_('File to be uploaded must have an extension'), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_name = book.path.rsplit('/', 1)[-1]\n            filepath = os.path.normpath(os.path.join(config.config_calibre_dir, book.path))\n            saved_filename = os.path.join(filepath, file_name + '.' + file_ext)\n\n            # check if file path exists, otherwise create it, copy file to calibre path and delete temp file\n            if not os.path.exists(filepath):\n                try:\n                    os.makedirs(filepath)\n                except OSError:\n                    flash(_(u\"Failed to create path %(path)s (Permission denied).\", path=filepath), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n            try:\n                requested_file.save(saved_filename)\n            except OSError:\n                flash(_(u\"Failed to store file %(file)s.\", file=saved_filename), category=\"error\")\n                return redirect(url_for('web.show_book', book_id=book.id))\n\n            file_size = os.path.getsize(saved_filename)\n            is_format = calibre_db.get_book_format(book_id, file_ext.upper())\n\n            # Format entry already exists, no need to update the database\n            if is_format:\n                log.warning('Book format %s already existing', file_ext.upper())\n            else:\n                try:\n                    db_format = db.Data(book_id, file_ext.upper(), file_size, file_name)\n                    calibre_db.session.add(db_format)\n                    calibre_db.session.commit()\n                    calibre_db.update_title_sort(config)\n                except (OperationalError, IntegrityError) as e:\n                    calibre_db.session.rollback()\n                    log.error('Database error: %s', e)\n                    flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n                    return redirect(url_for('web.show_book', book_id=book.id))\n\n            # Queue uploader info\n            link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book.id), escape(book.title))\n            uploadText=_(u\"File format %(ext)s added to %(book)s\", ext=file_ext.upper(), book=link)\n            WorkerThread.add(current_user.name, TaskUpload(uploadText))\n\n            return uploader.process(\n                saved_filename, *os.path.splitext(requested_file.filename),\n                rarExecutable=config.config_rarfile_location)\n\n\ndef upload_cover(request, book):\n    if 'btn-upload-cover' in request.files:\n        requested_file = request.files['btn-upload-cover']\n        # check for empty request\n        if requested_file.filename != '':\n            if not current_user.role_upload():\n                abort(403)\n            ret, message = helper.save_cover(requested_file, book.path)\n            if ret is True:\n                return True\n            else:\n                flash(message, category=\"error\")\n                return False\n    return None\n\n\ndef handle_title_on_edit(book, book_title):\n    # handle book title\n    book_title = book_title.rstrip().strip()\n    if book.title != book_title:\n        if book_title == '':\n            book_title = _(u'Unknown')\n        book.title = book_title\n        return True\n    return False\n\n\ndef handle_author_on_edit(book, author_name, update_stored=True):\n    # handle author(s)\n    input_authors = author_name.split('&')\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    change = modify_database_object(input_authors, book.authors, db.Authors, calibre_db.session, 'author')\n\n    # Search for each author if author is in database, if not, author name and sorted author name is generated new\n    # everything then is assembled for sorted author field in database\n    sort_authors_list = list()\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            stored_author = helper.get_sorted_author(inp)\n        else:\n            stored_author = stored_author.sort\n        sort_authors_list.append(helper.get_sorted_author(stored_author))\n    sort_authors = ' & '.join(sort_authors_list)\n    if book.author_sort != sort_authors and update_stored:\n        book.author_sort = sort_authors\n        change = True\n    return input_authors, change\n\n\n@editbook.route(\"/admin/book/<int:book_id>\", methods=['GET', 'POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_book(book_id):\n    modif_date = False\n\n    # create the function for sorting...\n    try:\n        calibre_db.update_title_sort(config)\n    except sqliteOperationalError as e:\n        log.debug_or_exception(e)\n        calibre_db.session.rollback()\n\n    # Show form\n    if request.method != 'POST':\n        return render_edit_book(book_id)\n\n    book = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n\n    # Book not found\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n    meta = upload_single_file(request, book, book_id)\n    if upload_cover(request, book) is True:\n        book.has_cover = 1\n        modif_date = True\n    try:\n        to_save = request.form.to_dict()\n        merge_metadata(to_save, meta)\n        # Update book\n        edited_books_id = None\n\n        # handle book title\n        title_change = handle_title_on_edit(book, to_save[\"book_title\"])\n\n        input_authors, authorchange = handle_author_on_edit(book, to_save[\"author_name\"])\n        if authorchange or title_change:\n            edited_books_id = book.id\n            modif_date = True\n\n        if config.config_use_google_drive:\n            gdriveutils.updateGdriveCalibreFromLocal()\n\n        error = False\n        if edited_books_id:\n            error = helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n\n        if not error:\n            if \"cover_url\" in to_save:\n                if to_save[\"cover_url\"]:\n                    if not current_user.role_upload():\n                        return \"\", (403)\n                    if to_save[\"cover_url\"].endswith('/static/generic_cover.jpg'):\n                        book.has_cover = 0\n                    else:\n                        result, error = helper.save_cover_from_url(to_save[\"cover_url\"], book.path)\n                        if result is True:\n                            book.has_cover = 1\n                            modif_date = True\n                        else:\n                            flash(error, category=\"error\")\n\n            # Add default series_index to book\n            modif_date |= edit_book_series_index(to_save[\"series_index\"], book)\n            # Handle book comments/description\n            modif_date |= edit_book_comments(Markup(to_save['description']).unescape(), book)\n            # Handle identifiers\n            input_identifiers = identifier_list(to_save, book)\n            modification, warning = modify_identifiers(input_identifiers, book.identifiers, calibre_db.session)\n            if warning:\n                flash(_(\"Identifiers are not Case Sensitive, Overwriting Old Identifier\"), category=\"warning\")\n            modif_date |= modification\n            # Handle book tags\n            modif_date |= edit_book_tags(to_save['tags'], book)\n            # Handle book series\n            modif_date |= edit_book_series(to_save[\"series\"], book)\n            # handle book publisher\n            modif_date |= edit_book_publisher(to_save['publisher'], book)\n            # handle book languages\n            modif_date |= edit_book_languages(to_save['languages'], book)\n            # handle book ratings\n            modif_date |= edit_book_ratings(to_save, book)\n            # handle cc data\n            modif_date |= edit_all_cc_data(book_id, book, to_save)\n\n            if to_save[\"pubdate\"]:\n                try:\n                    book.pubdate = datetime.strptime(to_save[\"pubdate\"], \"%Y-%m-%d\")\n                except ValueError:\n                    book.pubdate = db.Books.DEFAULT_PUBDATE\n            else:\n                book.pubdate = db.Books.DEFAULT_PUBDATE\n\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n                kobo_sync_status.remove_synced_book(edited_books_id)\n\n            calibre_db.session.merge(book)\n            calibre_db.session.commit()\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n            if \"detail_view\" in to_save:\n                return redirect(url_for('web.show_book', book_id=book.id))\n            else:\n                flash(_(\"Metadata successfully updated\"), category=\"success\")\n                return render_edit_book(book_id)\n        else:\n            calibre_db.session.rollback()\n            flash(error, category=\"error\")\n            return render_edit_book(book_id)\n    except ValueError as e:\n        calibre_db.session.rollback()\n        flash(str(e), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n    except Exception as ex:\n        log.debug_or_exception(ex)\n        calibre_db.session.rollback()\n        flash(_(\"Error editing book, please check logfile for details\"), category=\"error\")\n        return redirect(url_for('web.show_book', book_id=book.id))\n\n\ndef merge_metadata(to_save, meta):\n    if to_save['author_name'] == _(u'Unknown'):\n        to_save['author_name'] = ''\n    if to_save['book_title'] == _(u'Unknown'):\n        to_save['book_title'] = ''\n    for s_field, m_field in [\n            ('tags', 'tags'), ('author_name', 'author'), ('series', 'series'),\n            ('series_index', 'series_id'), ('languages', 'languages'),\n            ('book_title', 'title')]:\n        to_save[s_field] = to_save[s_field] or getattr(meta, m_field, '')\n    to_save[\"description\"] = to_save[\"description\"] or Markup(\n        getattr(meta, 'description', '')).unescape()\n\n\ndef identifier_list(to_save, book):\n    \"\"\"Generate a list of Identifiers from form information\"\"\"\n    id_type_prefix = 'identifier-type-'\n    id_val_prefix = 'identifier-val-'\n    result = []\n    for type_key, type_value in to_save.items():\n        if not type_key.startswith(id_type_prefix):\n            continue\n        val_key = id_val_prefix + type_key[len(id_type_prefix):]\n        if val_key not in to_save.keys():\n            continue\n        result.append(db.Identifiers(to_save[val_key], type_value, book.id))\n    return result\n\n\ndef prepare_authors_on_upload(title, authr):\n    if title != _(u'Unknown') and authr != _(u'Unknown'):\n        entry = calibre_db.check_exists_book(authr, title)\n        if entry:\n            log.info(\"Uploaded book probably exists in library\")\n            flash(_(u\"Uploaded book probably exists in the library, consider to change before upload new: \")\n                  + Markup(render_title_template('book_exists_flash.html', entry=entry)), category=\"warning\")\n\n    # handle authors\n    input_authors = authr.split('&')\n    # handle_authors(input_authors)\n    input_authors = list(map(lambda it: it.strip().replace(',', '|'), input_authors))\n    # Remove duplicates in authors list\n    input_authors = helper.uniq(input_authors)\n\n    # we have all author names now\n    if input_authors == ['']:\n        input_authors = [_(u'Unknown')]  # prevent empty Author\n\n    sort_authors_list = list()\n    db_author = None\n    for inp in input_authors:\n        stored_author = calibre_db.session.query(db.Authors).filter(db.Authors.name == inp).first()\n        if not stored_author:\n            if not db_author:\n                db_author = db.Authors(inp, helper.get_sorted_author(inp), \"\")\n                calibre_db.session.add(db_author)\n                calibre_db.session.commit()\n            sort_author = helper.get_sorted_author(inp)\n        else:\n            if not db_author:\n                db_author = stored_author\n            sort_author = stored_author.sort\n        sort_authors_list.append(sort_author)\n    sort_authors = ' & '.join(sort_authors_list)\n    return sort_authors, input_authors, db_author\n\n\ndef create_book_on_upload(modif_date, meta):\n    title = meta.title\n    authr = meta.author\n    sort_authors, input_authors, db_author = prepare_authors_on_upload(title, authr)\n\n    title_dir = helper.get_valid_filename(title)\n    author_dir = helper.get_valid_filename(db_author.name)\n\n    # combine path and normalize path from windows systems\n    path = os.path.join(author_dir, title_dir).replace('\\\\', '/')\n\n    # Calibre adds books with utc as timezone\n    db_book = db.Books(title, \"\", sort_authors, datetime.utcnow(), datetime(101, 1, 1),\n                       '1', datetime.utcnow(), path, meta.cover, db_author, [], \"\")\n\n    modif_date |= modify_database_object(input_authors, db_book.authors, db.Authors, calibre_db.session,\n                                         'author')\n\n    # Add series_index to book\n    modif_date |= edit_book_series_index(meta.series_id, db_book)\n\n    # add languages\n    invalid=[]\n    modif_date |= edit_book_languages(meta.languages, db_book, upload=True, invalid=invalid)\n    if invalid:\n        for l in invalid:\n            flash(_(u\"'%(langname)s' is not a valid language\", langname=l), category=\"warning\")\n\n    # handle tags\n    modif_date |= edit_book_tags(meta.tags, db_book)\n\n    # handle publisher\n    modif_date |= edit_book_publisher(meta.publisher, db_book)\n\n    # handle series\n    modif_date |= edit_book_series(meta.series, db_book)\n\n    # Add file to book\n    file_size = os.path.getsize(meta.file_path)\n    db_data = db.Data(db_book, meta.extension.upper()[1:], file_size, title_dir)\n    db_book.data.append(db_data)\n    calibre_db.session.add(db_book)\n\n    # flush content, get db_book.id available\n    calibre_db.session.flush()\n    return db_book, input_authors, title_dir\n\ndef file_handling_on_upload(requested_file):\n    # check if file extension is correct\n    if '.' in requested_file.filename:\n        file_ext = requested_file.filename.rsplit('.', 1)[-1].lower()\n        if file_ext not in constants.EXTENSIONS_UPLOAD and '' not in constants.EXTENSIONS_UPLOAD:\n            flash(\n                _(\"File extension '%(ext)s' is not allowed to be uploaded to this server\",\n                  ext=file_ext), category=\"error\")\n            return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    else:\n        flash(_('File to be uploaded must have an extension'), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n    # extract metadata from file\n    try:\n        meta = uploader.upload(requested_file, config.config_rarfile_location)\n    except (IOError, OSError):\n        log.error(\"File %s could not saved to temp dir\", requested_file.filename)\n        flash(_(u\"File %(filename)s could not saved to temp dir\",\n                filename=requested_file.filename), category=\"error\")\n        return None, Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n    return meta, None\n\n\ndef move_coverfile(meta, db_book):\n    # move cover to final directory, including book id\n    if meta.cover:\n        coverfile = meta.cover\n    else:\n        coverfile = os.path.join(constants.STATIC_DIR, 'generic_cover.jpg')\n    new_coverpath = os.path.join(config.config_calibre_dir, db_book.path, \"cover.jpg\")\n    try:\n        copyfile(coverfile, new_coverpath)\n        if meta.cover:\n            os.unlink(meta.cover)\n    except OSError as e:\n        log.error(\"Failed to move cover file %s: %s\", new_coverpath, e)\n        flash(_(u\"Failed to Move Cover File %(file)s: %(error)s\", file=new_coverpath,\n                error=e),\n              category=\"error\")\n\n\n@editbook.route(\"/upload\", methods=[\"POST\"])\n@login_required_if_no_ano\n@upload_required\ndef upload():\n    if not config.config_uploading:\n        abort(404)\n    if request.method == 'POST' and 'btn-upload' in request.files:\n        for requested_file in request.files.getlist(\"btn-upload\"):\n            try:\n                modif_date = False\n                # create the function for sorting...\n                calibre_db.update_title_sort(config)\n                calibre_db.session.connection().connection.connection.create_function('uuid4', 0, lambda: str(uuid4()))\n\n                meta, error = file_handling_on_upload(requested_file)\n                if error:\n                    return error\n\n                db_book, input_authors, title_dir = create_book_on_upload(modif_date, meta)\n\n                # Comments needs book id therefore only possible after flush\n                modif_date |= edit_book_comments(Markup(meta.description).unescape(), db_book)\n\n                book_id = db_book.id\n                title = db_book.title\n\n                error = helper.update_dir_structure_file(book_id,\n                                                   config.config_calibre_dir,\n                                                   input_authors[0],\n                                                   meta.file_path,\n                                                   title_dir + meta.extension.lower())\n\n                move_coverfile(meta, db_book)\n\n                # save data to database, reread data\n                calibre_db.session.commit()\n\n                if config.config_use_google_drive:\n                    gdriveutils.updateGdriveCalibreFromLocal()\n                if error:\n                    flash(error, category=\"error\")\n                link = '<a href=\"{}\">{}</a>'.format(url_for('web.show_book', book_id=book_id), escape(title))\n                uploadText = _(u\"File %(file)s uploaded\", file=link)\n                WorkerThread.add(current_user.name, TaskUpload(uploadText))\n\n                if len(request.files.getlist(\"btn-upload\")) < 2:\n                    if current_user.role_edit() or current_user.role_admin():\n                        resp = {\"location\": url_for('editbook.edit_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n                    else:\n                        resp = {\"location\": url_for('web.show_book', book_id=book_id)}\n                        return Response(json.dumps(resp), mimetype='application/json')\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n        return Response(json.dumps({\"location\": url_for(\"web.index\")}), mimetype='application/json')\n\n@editbook.route(\"/admin/book/convert/<int:book_id>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef convert_bookformat(book_id):\n    # check to see if we have form fields to work with -  if not send user back\n    book_format_from = request.form.get('book_format_from', None)\n    book_format_to = request.form.get('book_format_to', None)\n\n    if (book_format_from is None) or (book_format_to is None):\n        flash(_(u\"Source or destination format for conversion missing\"), category=\"error\")\n        return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n    log.info('converting: book id: %s from: %s to: %s', book_id, book_format_from, book_format_to)\n    rtn = helper.convert_book_format(book_id, config.config_calibre_dir, book_format_from.upper(),\n                                     book_format_to.upper(), current_user.name)\n\n    if rtn is None:\n        flash(_(u\"Book successfully queued for converting to %(book_format)s\",\n                    book_format=book_format_to),\n                    category=\"success\")\n    else:\n        flash(_(u\"There was an error converting this book: %(res)s\", res=rtn), category=\"error\")\n    return redirect(url_for('editbook.edit_book', book_id=book_id))\n\n@editbook.route(\"/ajax/getcustomenum/<int:c_id>\")\n@login_required\ndef table_get_custom_enum(c_id):\n    ret = list()\n    cc = (calibre_db.session.query(db.Custom_Columns)\n              .filter(db.Custom_Columns.id == c_id)\n              .filter(db.Custom_Columns.datatype.notin_(db.cc_exceptions)).one_or_none())\n    ret.append({'value': \"\", 'text': \"\"})\n    for idx, en in enumerate(cc.get_display_dict()['enum_values']):\n        ret.append({'value': en, 'text': en})\n    return json.dumps(ret)\n\n\n@editbook.route(\"/ajax/editbooks/<param>\", methods=['POST'])\n@login_required_if_no_ano\n@edit_required\ndef edit_list_book(param):\n    vals = request.form.to_dict()\n    book = calibre_db.get_book(vals['pk'])\n    ret = \"\"\n    if param =='series_index':\n        edit_book_series_index(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': book.series_index}), mimetype='application/json')\n    elif param =='tags':\n        edit_book_tags(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue': ', '.join([tag.name for tag in book.tags])}),\n                       mimetype='application/json')\n    elif param =='series':\n        edit_book_series(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue':  ', '.join([serie.name for serie in book.series])}),\n                       mimetype='application/json')\n    elif param =='publishers':\n        edit_book_publisher(vals['value'], book)\n        ret =  Response(json.dumps({'success': True,\n                                    'newValue': ', '.join([publisher.name for publisher in book.publishers])}),\n                       mimetype='application/json')\n    elif param =='languages':\n        invalid = list()\n        edit_book_languages(vals['value'], book, invalid=invalid)\n        if invalid:\n            ret = Response(json.dumps({'success': False,\n                                       'msg': 'Invalid languages in request: {}'.format(','.join(invalid))}),\n                           mimetype='application/json')\n        else:\n            lang_names = list()\n            for lang in book.languages:\n                lang_names.append(isoLanguages.get_language_name(get_locale(), lang.lang_code))\n            ret =  Response(json.dumps({'success': True, 'newValue':  ', '.join(lang_names)}),\n                            mimetype='application/json')\n    elif param =='author_sort':\n        book.author_sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.author_sort}),\n                       mimetype='application/json')\n    elif param == 'title':\n        sort = book.sort\n        handle_title_on_edit(book, vals.get('value', \"\"))\n        helper.update_dir_stucture(book.id, config.config_calibre_dir)\n        ret = Response(json.dumps({'success': True, 'newValue':  book.title}),\n                       mimetype='application/json')\n    elif param =='sort':\n        book.sort = vals['value']\n        ret = Response(json.dumps({'success': True, 'newValue':  book.sort}),\n                       mimetype='application/json')\n    elif param =='comments':\n        edit_book_comments(vals['value'], book)\n        ret = Response(json.dumps({'success': True, 'newValue':  book.comments[0].text}),\n                       mimetype='application/json')\n    elif param =='authors':\n        input_authors, __ = handle_author_on_edit(book, vals['value'], vals.get('checkA', None) == \"true\")\n        helper.update_dir_stucture(book.id, config.config_calibre_dir, input_authors[0])\n        ret = Response(json.dumps({'success': True,\n                                   'newValue':  ' & '.join([author.replace('|',',') for author in input_authors])}),\n                       mimetype='application/json')\n    elif param.startswith(\"custom_column_\"):\n        new_val = dict()\n        new_val[param] = vals['value']\n        edit_single_cc_data(book.id, book, param[14:], new_val)\n        ret = Response(json.dumps({'success': True, 'newValue': vals['value']}),\n                       mimetype='application/json')\n\n    book.last_modified = datetime.utcnow()\n    try:\n        calibre_db.session.commit()\n        # revert change for sort if automatic fields link is deactivated\n        if param == 'title' and vals.get('checkT') == \"false\":\n            book.sort = sort\n            calibre_db.session.commit()\n    except (OperationalError, IntegrityError) as e:\n        calibre_db.session.rollback()\n        log.error(\"Database error: %s\", e)\n    return ret\n\n\n@editbook.route(\"/ajax/sort_value/<field>/<int:bookid>\")\n@login_required\ndef get_sorted_entry(field, bookid):\n    if field in ['title', 'authors', 'sort', 'author_sort']:\n        book = calibre_db.get_filtered_book(bookid)\n        if book:\n            if field == 'title':\n                return json.dumps({'sort': book.sort})\n            elif field == 'authors':\n                return json.dumps({'author_sort': book.author_sort})\n            if field == 'sort':\n                return json.dumps({'sort': book.title})\n            if field == 'author_sort':\n                return json.dumps({'author_sort': book.author})\n    return \"\"\n\n\n@editbook.route(\"/ajax/simulatemerge\", methods=['POST'])\n@login_required\n@edit_required\ndef simulate_merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    if vals:\n        to_book = calibre_db.get_book(vals[0]).title\n        vals.pop(0)\n        if to_book:\n            for book_id in vals:\n                from_book = []\n                from_book.append(calibre_db.get_book(book_id).title)\n            return json.dumps({'to': to_book, 'from': from_book})\n    return \"\"\n\n\n@editbook.route(\"/ajax/mergebooks\", methods=['POST'])\n@login_required\n@edit_required\ndef merge_list_book():\n    vals = request.get_json().get('Merge_books')\n    to_file = list()\n    if vals:\n        # load all formats from target book\n        to_book = calibre_db.get_book(vals[0])\n        vals.pop(0)\n        if to_book:\n            for file in to_book.data:\n                to_file.append(file.format)\n            to_name = helper.get_valid_filename(to_book.title) + ' - ' + \\\n                      helper.get_valid_filename(to_book.authors[0].name)\n            for book_id in vals:\n                from_book = calibre_db.get_book(book_id)\n                if from_book:\n                    for element in from_book.data:\n                        if element.format not in to_file:\n                            # create new data entry with: book_id, book_format, uncompressed_size, name\n                            filepath_new = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         to_book.path,\n                                                                         to_name + \".\" + element.format.lower()))\n                            filepath_old = os.path.normpath(os.path.join(config.config_calibre_dir,\n                                                                         from_book.path,\n                                                                         element.name + \".\" + element.format.lower()))\n                            copyfile(filepath_old, filepath_new)\n                            to_book.data.append(db.Data(to_book.id,\n                                                        element.format,\n                                                        element.uncompressed_size,\n                                                        to_name))\n                    delete_book_from_table(from_book.id,\"\", True)\n                    return json.dumps({'success': True})\n    return \"\"\n\n@editbook.route(\"/ajax/xchange\", methods=['POST'])\n@login_required\n@edit_required\ndef table_xchange_author_title():\n    vals = request.get_json().get('xchange')\n    if vals:\n        for val in vals:\n            modif_date = False\n            book = calibre_db.get_book(val)\n            authors = book.title\n            entries = calibre_db.order_authors(book)\n            author_names = []\n            for authr in entries.authors:\n                author_names.append(authr.name.replace('|', ','))\n\n            title_change = handle_title_on_edit(book, \" \".join(author_names))\n            input_authors, authorchange = handle_author_on_edit(book, authors)\n            if authorchange or title_change:\n                edited_books_id = book.id\n                modif_date = True\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n\n            if edited_books_id:\n                helper.update_dir_stucture(edited_books_id, config.config_calibre_dir, input_authors[0])\n            if modif_date:\n                book.last_modified = datetime.utcnow()\n            try:\n                calibre_db.session.commit()\n            except (OperationalError, IntegrityError) as e:\n                calibre_db.session.rollback()\n                log.error(\"Database error: %s\", e)\n                return json.dumps({'success': False})\n\n            if config.config_use_google_drive:\n                gdriveutils.updateGdriveCalibreFromLocal()\n        return json.dumps({'success': True})\n    return \"\"\n", "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 shavitmichael, OzzieIsaacs\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n\n\"\"\"This module is used to control authentication/authorization of Kobo sync requests.\nThis module also includes research notes into the auth protocol used by Kobo devices.\n\nLog-in:\nWhen first booting a Kobo device the user must sign into a Kobo (or affiliate) account.\nUpon successful sign-in, the user is redirected to\n    https://auth.kobobooks.com/CrossDomainSignIn?id=<some id>\nwhich serves the following response:\n    <script type='text/javascript'>\n        location.href='kobo://UserAuthenticated?userId=<redacted>&userKey<redacted>&email=<redacted>&returnUrl=https%3a%2f%2fwww.kobo.com';\n    </script>\nAnd triggers the insertion of a userKey into the device's User table.\n\nTogether, the device's DeviceId and UserKey act as an *irrevocable* authentication\ntoken to most (if not all) Kobo APIs. In fact, in most cases only the UserKey is\nrequired to authorize the API call.\n\nChanging Kobo password *does not* invalidate user keys! This is apparently a known\nissue for a few years now https://www.mobileread.com/forums/showpost.php?p=3476851&postcount=13\n(although this poster hypothesised that Kobo could blacklist a DeviceId, many endpoints\nwill still grant access given the userkey.)\n\nOfficial Kobo Store Api authorization:\n* For most of the endpoints we care about (sync, metadata, tags, etc), the userKey is\npassed in the x-kobo-userkey header, and is sufficient to authorize the API call.\n* Some endpoints (e.g: AnnotationService) instead make use of Bearer tokens pass through\nan authorization header. To get a BearerToken, the device makes a POST request to the\nv1/auth/device endpoint with the secret UserKey and the device's DeviceId.\n* The book download endpoint passes an auth token as a URL param instead of a header.\n\nOur implementation:\nWe pretty much ignore all of the above. To authenticate the user, we generate a random\nand unique token that they append to the CalibreWeb Url when setting up the api_store\nsetting on the device.\nThus, every request from the device to the api_store will hit CalibreWeb with the\nauth_token in the url (e.g: https://mylibrary.com/<auth_token>/v1/library/sync).\nIn addition, once authenticated we also set the login cookie on the response that will\nbe sent back for the duration of the session to authorize subsequent API calls (in\nparticular calls to non-Kobo specific endpoints such as the CalibreWeb book download).\n\"\"\"\n\nfrom binascii import hexlify\nfrom datetime import datetime\nfrom os import urandom\nfrom functools import wraps\n\nfrom flask import g, Blueprint, url_for, abort, request\nfrom flask_login import login_user, current_user, login_required\nfrom flask_babel import gettext as _\n\nfrom . import logger, config, calibre_db, db, helper, ub, lm\nfrom .render_template import render_title_template\n\n\nlog = logger.create()\n\n\ndef register_url_value_preprocessor(kobo):\n    @kobo.url_value_preprocessor\n    # pylint: disable=unused-variable\n    def pop_auth_token(__, values):\n        g.auth_token = values.pop(\"auth_token\")\n\n\ndef disable_failed_auth_redirect_for_blueprint(bp):\n    lm.blueprint_login_views[bp.name] = None\n\n\ndef get_auth_token():\n    if \"auth_token\" in g:\n        return g.get(\"auth_token\")\n    else:\n        return None\n\n\ndef requires_kobo_auth(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        auth_token = get_auth_token()\n        if auth_token is not None:\n            user = (\n                ub.session.query(ub.User)\n                .join(ub.RemoteAuthToken)\n                .filter(ub.RemoteAuthToken.auth_token == auth_token).filter(ub.RemoteAuthToken.token_type==1)\n                .first()\n            )\n            if user is not None:\n                login_user(user)\n                return f(*args, **kwargs)\n            log.debug(\"Received Kobo request without a recognizable auth token.\")\n            return abort(401)\n    return inner\n\n\nkobo_auth = Blueprint(\"kobo_auth\", __name__, url_prefix=\"/kobo_auth\")\n\n\n@kobo_auth.route(\"/generate_auth_token/<int:user_id>\")\n@login_required\ndef generate_auth_token(user_id):\n    host_list = request.host.rsplit(':')\n    if len(host_list) == 1:\n        host = ':'.join(host_list)\n    else:\n        host = ':'.join(host_list[0:-1])\n    if host.startswith('127.') or host.lower() == 'localhost' or host.startswith('[::ffff:7f'):\n        warning = _('PLease access calibre-web from non localhost to get valid api_endpoint for kobo device')\n        return render_title_template(\n            \"generate_kobo_auth_url.html\",\n            title=_(u\"Kobo Setup\"),\n            warning = warning\n        )\n    else:\n        # Invalidate any prevously generated Kobo Auth token for this user.\n        auth_token = ub.session.query(ub.RemoteAuthToken).filter(\n            ub.RemoteAuthToken.user_id == user_id\n        ).filter(ub.RemoteAuthToken.token_type==1).first()\n\n        if not auth_token:\n            auth_token = ub.RemoteAuthToken()\n            auth_token.user_id = user_id\n            auth_token.expiration = datetime.max\n            auth_token.auth_token = (hexlify(urandom(16))).decode(\"utf-8\")\n            auth_token.token_type = 1\n\n            ub.session.add(auth_token)\n            ub.session_commit()\n\n        books = calibre_db.session.query(db.Books).join(db.Data).all()\n\n        for book in books:\n            formats = [data.format for data in book.data]\n            if not 'KEPUB' in formats and config.config_kepubifypath and 'EPUB' in formats:\n                helper.convert_book_format(book.id, config.config_calibre_dir, 'EPUB', 'KEPUB', current_user.name)\n\n        return render_title_template(\n            \"generate_kobo_auth_url.html\",\n            title=_(u\"Kobo Setup\"),\n            kobo_auth_url=url_for(\n                \"kobo.TopLevelEndpoint\", auth_token=auth_token.auth_token, _external=True\n            ),\n            warning = False\n        )\n\n\n@kobo_auth.route(\"/deleteauthtoken/<int:user_id>\", methods=[\"POST\"])\n@login_required\ndef delete_auth_token(user_id):\n    # Invalidate any prevously generated Kobo Auth token for this user.\n    ub.session.query(ub.RemoteAuthToken).filter(ub.RemoteAuthToken.user_id == user_id)\\\n        .filter(ub.RemoteAuthToken.token_type==1).delete()\n\n    return ub.session_commit()\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nfrom datetime import datetime\n\nfrom flask import Blueprint, flash, redirect, request, url_for\nfrom flask_babel import gettext as _\nfrom flask_login import current_user, login_required\nfrom sqlalchemy.exc import InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import func, true\n\nfrom . import calibre_db, config, db, logger, ub\nfrom .render_template import render_title_template\nfrom .usermanagement import login_required_if_no_ano\n\nshelf = Blueprint('shelf', __name__)\nlog = logger.create()\n\n\ndef check_shelf_edit_permissions(cur_shelf):\n    if not cur_shelf.is_public and not cur_shelf.user_id == int(current_user.id):\n        log.error(\"User %s not allowed to edit shelf %s\", current_user, cur_shelf)\n        return False\n    if cur_shelf.is_public and not current_user.role_edit_shelfs():\n        log.info(\"User %s not allowed to edit public shelves\", current_user)\n        return False\n    return True\n\n\ndef check_shelf_view_permissions(cur_shelf):\n    if cur_shelf.is_public:\n        return True\n    if current_user.is_anonymous or cur_shelf.user_id != current_user.id:\n        log.error(\"User is unauthorized to view non-public shelf: %s\", cur_shelf)\n        return False\n    return True\n\n\n@shelf.route(\"/shelf/add/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef add_to_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        if not xhr:\n            flash(_(u\"Invalid shelf specified\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    if not check_shelf_edit_permissions(shelf):\n        if not xhr:\n            flash(_(u\"Sorry you are not allowed to add a book to that shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to add a book to the that shelf\", 403\n\n    book_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                          ub.BookShelf.book_id == book_id).first()\n    if book_in_shelf:\n        log.error(\"Book %s is already part of %s\", book_id, shelf)\n        if not xhr:\n            flash(_(u\"Book is already part of the shelf: %(shelfname)s\", shelfname=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Book is already part of the shelf: %s\" % shelf.name, 400\n\n    maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()\n    if maxOrder[0] is None:\n        maxOrder = 0\n    else:\n        maxOrder = maxOrder[0]\n\n    shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book_id, order=maxOrder + 1))\n    shelf.last_modified = datetime.utcnow()\n    try:\n        ub.session.merge(shelf)\n        ub.session.commit()\n    except (OperationalError, InvalidRequestError):\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(u\"Settings DB is not Writeable\"), category=\"error\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    if not xhr:\n        log.debug(\"Book has been added to shelf: {}\".format(shelf.name))\n        flash(_(u\"Book has been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        if \"HTTP_REFERER\" in request.environ:\n            return redirect(request.environ[\"HTTP_REFERER\"])\n        else:\n            return redirect(url_for('web.index'))\n    return \"\", 204\n\n\n@shelf.route(\"/shelf/massadd/<int:shelf_id>\", methods=[\"POST\"])\n@login_required\ndef search_to_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: %s\", shelf_id)\n        flash(_(u\"Invalid shelf specified\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if not check_shelf_edit_permissions(shelf):\n        log.warning(\"You are not allowed to add a book to the shelf\".format(shelf.name))\n        flash(_(u\"You are not allowed to add a book to the shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n\n    if current_user.id in ub.searched_ids and ub.searched_ids[current_user.id]:\n        books_for_shelf = list()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).all()\n        if books_in_shelf:\n            book_ids = list()\n            for book_id in books_in_shelf:\n                book_ids.append(book_id.book_id)\n            for searchid in ub.searched_ids[current_user.id]:\n                if searchid not in book_ids:\n                    books_for_shelf.append(searchid)\n        else:\n            books_for_shelf = ub.searched_ids[current_user.id]\n\n        if not books_for_shelf:\n            log.error(\"Books are already part of {}\".format(shelf.name))\n            flash(_(u\"Books are already part of the shelf: %(name)s\", name=shelf.name), category=\"error\")\n            return redirect(url_for('web.index'))\n\n        maxOrder = ub.session.query(func.max(ub.BookShelf.order)).filter(ub.BookShelf.shelf == shelf_id).first()[0] or 0\n\n        for book in books_for_shelf:\n            maxOrder += 1\n            shelf.books.append(ub.BookShelf(shelf=shelf.id, book_id=book, order=maxOrder))\n        shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.merge(shelf)\n            ub.session.commit()\n            flash(_(u\"Books have been added to shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    else:\n        log.error(\"Could not add books to shelf: {}\".format(shelf.name))\n        flash(_(u\"Could not add books to shelf: %(sname)s\", sname=shelf.name), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/shelf/remove/<int:shelf_id>/<int:book_id>\", methods=[\"POST\"])\n@login_required\ndef remove_from_shelf(shelf_id, book_id):\n    xhr = request.headers.get('X-Requested-With') == 'XMLHttpRequest'\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if shelf is None:\n        log.error(\"Invalid shelf specified: {}\".format(shelf_id))\n        if not xhr:\n            return redirect(url_for('web.index'))\n        return \"Invalid shelf specified\", 400\n\n    # if shelf is public and use is allowed to edit shelfs, or if shelf is private and user is owner\n    # allow editing shelfs\n    # result   shelf public   user allowed    user owner\n    #   false        1             0             x\n    #   true         1             1             x\n    #   true         0             x             1\n    #   false        0             x             0\n\n    if check_shelf_edit_permissions(shelf):\n        book_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id,\n                                                           ub.BookShelf.book_id == book_id).first()\n\n        if book_shelf is None:\n            log.error(\"Book %s already removed from %s\", book_id, shelf)\n            if not xhr:\n                return redirect(url_for('web.index'))\n            return \"Book already removed from shelf\", 410\n\n        try:\n            ub.session.delete(book_shelf)\n            shelf.last_modified = datetime.utcnow()\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        if not xhr:\n            flash(_(u\"Book has been removed from shelf: %(sname)s\", sname=shelf.name), category=\"success\")\n            if \"HTTP_REFERER\" in request.environ:\n                return redirect(request.environ[\"HTTP_REFERER\"])\n            else:\n                return redirect(url_for('web.index'))\n        return \"\", 204\n    else:\n        if not xhr:\n            log.warning(\"You are not allowed to remove a book from shelf: {}\".format(shelf.name))\n            flash(_(u\"Sorry you are not allowed to remove a book from this shelf\"),\n                  category=\"error\")\n            return redirect(url_for('web.index'))\n        return \"Sorry you are not allowed to remove a book from this shelf\", 403\n\n\n@shelf.route(\"/shelf/create\", methods=[\"GET\", \"POST\"])\n@login_required\ndef create_shelf():\n    shelf = ub.Shelf()\n    return create_edit_shelf(shelf, page_title=_(u\"Create a Shelf\"), page=\"shelfcreate\")\n\n\n\n@shelf.route(\"/shelf/edit/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef edit_shelf(shelf_id):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    if not check_shelf_edit_permissions(shelf):\n        flash(_(u\"Sorry you are not allowed to edit this shelf\"), category=\"error\")\n        return redirect(url_for('web.index'))\n    return create_edit_shelf(shelf, page_title=_(u\"Edit a shelf\"), page=\"shelfedit\", shelf_id=shelf_id)\n\n\n# if shelf ID is set, we are editing a shelf\ndef create_edit_shelf(shelf, page_title, page, shelf_id=False):\n    sync_only_selected_shelves = current_user.kobo_only_shelves_sync\n    # calibre_db.session.query(ub.Shelf).filter(ub.Shelf.user_id == current_user.id).filter(ub.Shelf.kobo_sync).count()\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        if not current_user.role_edit_shelfs() and to_save.get(\"is_public\") == \"on\":\n            flash(_(u\"Sorry you are not allowed to create a public shelf\"), category=\"error\")\n            return redirect(url_for('web.index'))\n        shelf.is_public = 1 if to_save.get(\"is_public\") else 0\n        if config.config_kobo_sync:\n            shelf.kobo_sync = True if to_save.get(\"kobo_sync\") else False\n        shelf_title = to_save.get(\"title\", \"\")\n        if check_shelf_is_unique(shelf, shelf_title, shelf_id):\n            shelf.name = shelf_title\n            if not shelf_id:\n                shelf.user_id = int(current_user.id)\n                ub.session.add(shelf)\n                shelf_action = \"created\"\n                flash_text = _(u\"Shelf %(title)s created\", title=shelf_title)\n            else:\n                shelf_action = \"changed\"\n                flash_text = _(u\"Shelf %(title)s changed\", title=shelf_title)\n            try:\n                ub.session.commit()\n                log.info(u\"Shelf {} {}\".format(shelf_title, shelf_action))\n                flash(flash_text, category=\"success\")\n                return redirect(url_for('shelf.show_shelf', shelf_id=shelf.id))\n            except (OperationalError, InvalidRequestError) as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n            except Exception as ex:\n                ub.session.rollback()\n                log.debug_or_exception(ex)\n                flash(_(u\"There was an error\"), category=\"error\")\n    return render_title_template('shelf_edit.html',\n                                 shelf=shelf,\n                                 title=page_title,\n                                 page=page,\n                                 kobo_sync_enabled=config.config_kobo_sync,\n                                 sync_only_selected_shelves=sync_only_selected_shelves)\n\n\ndef check_shelf_is_unique(shelf, title, shelf_id=False):\n    if shelf_id:\n        ident = ub.Shelf.id != shelf_id\n    else:\n        ident = true()\n    if shelf.is_public == 1:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 1)) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A public shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A public shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    else:\n        is_shelf_name_unique = ub.session.query(ub.Shelf) \\\n                                   .filter((ub.Shelf.name == title) & (ub.Shelf.is_public == 0) &\n                                           (ub.Shelf.user_id == int(current_user.id))) \\\n                                   .filter(ident) \\\n                                   .first() is None\n\n        if not is_shelf_name_unique:\n            log.error(\"A private shelf with the name '{}' already exists.\".format(title))\n            flash(_(u\"A private shelf with the name '%(title)s' already exists.\", title=title),\n                  category=\"error\")\n    return is_shelf_name_unique\n\n\ndef delete_shelf_helper(cur_shelf):\n    if not cur_shelf or not check_shelf_edit_permissions(cur_shelf):\n        return\n    shelf_id = cur_shelf.id\n    ub.session.delete(cur_shelf)\n    ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).delete()\n    ub.session.add(ub.ShelfArchive(uuid=cur_shelf.uuid, user_id=cur_shelf.user_id))\n    ub.session_commit(\"successfully deleted Shelf {}\".format(cur_shelf.name))\n\n\n@shelf.route(\"/shelf/delete/<int:shelf_id>\", methods=[\"POST\"])\n@login_required\ndef delete_shelf(shelf_id):\n    cur_shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    try:\n        delete_shelf_helper(cur_shelf)\n        flash(_(\"Shelf successfully deleted\"), category=\"success\")\n    except InvalidRequestError:\n        ub.session.rollback()\n        log.error(\"Settings DB is not Writeable\")\n        flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n    return redirect(url_for('web.index'))\n\n\n@shelf.route(\"/simpleshelf/<int:shelf_id>\")\n@login_required_if_no_ano\ndef show_simpleshelf(shelf_id):\n    return render_show_shelf(2, shelf_id, 1, None)\n\n\n@shelf.route(\"/shelf/<int:shelf_id>\", defaults={\"sort_param\": \"order\", 'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>\", defaults={'page': 1})\n@shelf.route(\"/shelf/<int:shelf_id>/<sort_param>/<int:page>\")\n@login_required_if_no_ano\ndef show_shelf(shelf_id, sort_param, page):\n    return render_show_shelf(1, shelf_id, page, sort_param)\n\n\n@shelf.route(\"/shelf/order/<int:shelf_id>\", methods=[\"GET\", \"POST\"])\n@login_required\ndef order_shelf(shelf_id):\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        books_in_shelf = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id).order_by(\n            ub.BookShelf.order.asc()).all()\n        counter = 0\n        for book in books_in_shelf:\n            setattr(book, 'order', to_save[str(book.book_id)])\n            counter += 1\n            # if order diffrent from before -> shelf.last_modified = datetime.utcnow()\n        try:\n            ub.session.commit()\n        except (OperationalError, InvalidRequestError):\n            ub.session.rollback()\n            log.error(\"Settings DB is not Writeable\")\n            flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n    result = list()\n    if shelf and check_shelf_view_permissions(shelf):\n        result = calibre_db.session.query(db.Books) \\\n            .join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .add_columns(calibre_db.common_filters().label(\"visible\")) \\\n            .filter(ub.BookShelf.shelf == shelf_id).order_by(ub.BookShelf.order.asc()).all()\n    return render_title_template('shelf_order.html', entries=result,\n                                 title=_(u\"Change order of Shelf: '%(name)s'\", name=shelf.name),\n                                 shelf=shelf, page=\"shelforder\")\n\n\ndef change_shelf_order(shelf_id, order):\n    result = calibre_db.session.query(db.Books).outerjoin(db.books_series_link,\n                                                          db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series).join(ub.BookShelf, ub.BookShelf.book_id == db.Books.id) \\\n        .filter(ub.BookShelf.shelf == shelf_id).order_by(*order).all()\n    for index, entry in enumerate(result):\n        book = ub.session.query(ub.BookShelf).filter(ub.BookShelf.shelf == shelf_id) \\\n            .filter(ub.BookShelf.book_id == entry.id).first()\n        book.order = index\n    ub.session_commit(\"Shelf-id:{} - Order changed\".format(shelf_id))\n\n\ndef render_show_shelf(shelf_type, shelf_id, page_no, sort_param):\n    shelf = ub.session.query(ub.Shelf).filter(ub.Shelf.id == shelf_id).first()\n\n    # check user is allowed to access shelf\n    if shelf and check_shelf_view_permissions(shelf):\n\n        if shelf_type == 1:\n            # order = [ub.BookShelf.order.asc()]\n            if sort_param == 'pubnew':\n                change_shelf_order(shelf_id, [db.Books.pubdate.desc()])\n            if sort_param == 'pubold':\n                change_shelf_order(shelf_id, [db.Books.pubdate])\n            if sort_param == 'abc':\n                change_shelf_order(shelf_id, [db.Books.sort])\n            if sort_param == 'zyx':\n                change_shelf_order(shelf_id, [db.Books.sort.desc()])\n            if sort_param == 'new':\n                change_shelf_order(shelf_id, [db.Books.timestamp.desc()])\n            if sort_param == 'old':\n                change_shelf_order(shelf_id, [db.Books.timestamp])\n            if sort_param == 'authaz':\n                change_shelf_order(shelf_id, [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index])\n            if sort_param == 'authza':\n                change_shelf_order(shelf_id, [db.Books.author_sort.desc(),\n                                              db.Series.name.desc(),\n                                              db.Books.series_index.desc()])\n            page = \"shelf.html\"\n            pagesize = 0\n        else:\n            pagesize = sys.maxsize\n            page = 'shelfdown.html'\n\n        result, __, pagination = calibre_db.fill_indexpage(page_no, pagesize,\n                                                           db.Books,\n                                                           ub.BookShelf.shelf == shelf_id,\n                                                           [ub.BookShelf.order.asc()],\n                                                           ub.BookShelf, ub.BookShelf.book_id == db.Books.id)\n        # delete chelf entries where book is not existent anymore, can happen if book is deleted outside calibre-web\n        wrong_entries = calibre_db.session.query(ub.BookShelf) \\\n            .join(db.Books, ub.BookShelf.book_id == db.Books.id, isouter=True) \\\n            .filter(db.Books.id == None).all()\n        for entry in wrong_entries:\n            log.info('Not existing book {} in {} deleted'.format(entry.book_id, shelf))\n            try:\n                ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == entry.book_id).delete()\n                ub.session.commit()\n            except (OperationalError, InvalidRequestError):\n                ub.session.rollback()\n                log.error(\"Settings DB is not Writeable\")\n                flash(_(\"Settings DB is not Writeable\"), category=\"error\")\n\n        return render_title_template(page,\n                                     entries=result,\n                                     pagination=pagination,\n                                     title=_(u\"Shelf: '%(name)s'\", name=shelf.name),\n                                     shelf=shelf,\n                                     page=\"shelf\")\n    else:\n        flash(_(u\"Error opening shelf. Shelf does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n", "/* This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n *    Copyright (C) 2012-2019  mutschler, janeczku, jkrehm, OzzieIsaacs\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nfunction getPath() {\n    var jsFileLocation = $(\"script[src*=jquery]\").attr(\"src\");  // the js file path\n    return jsFileLocation.substr(0, jsFileLocation.search(\"/static/js/libs/jquery.min.js\"));  // the js folder path\n}\n\nfunction elementSorter(a, b) {\n    a = +a.slice(0, -2);\n    b = +b.slice(0, -2);\n    if (a > b) return 1;\n    if (a < b) return -1;\n    return 0;\n}\n\n// Generic control/related handler to show/hide fields based on a checkbox' value\n// e.g.\n//  <input type=\"checkbox\" data-control=\"stuff-to-show\">\n//  <div data-related=\"stuff-to-show\">...</div>\n$(document).on(\"change\", \"input[type=\\\"checkbox\\\"][data-control]\", function () {\n    var $this = $(this);\n    var name = $this.data(\"control\");\n    var showOrHide = $this.prop(\"checked\");\n\n    $(\"[data-related=\\\"\" + name + \"\\\"]\").each(function () {\n        $(this).toggle(showOrHide);\n    });\n});\n\n// Generic control/related handler to show/hide fields based on a select' value\n$(document).on(\"change\", \"select[data-control]\", function() {\n    var $this = $(this);\n    var name = $this.data(\"control\");\n    var showOrHide = parseInt($this.val(), 10);\n    // var showOrHideLast = $(\"#\" + name + \" option:last\").val()\n    for (var i = 0; i < $(this)[0].length; i++) {\n        var element = parseInt($(this)[0][i].value, 10);\n        if (element === showOrHide) {\n            $(\"[data-related^=\" + name + \"][data-related*=-\" + element + \"]\").show();\n        } else {\n            $(\"[data-related^=\" + name + \"][data-related*=-\" + element + \"]\").hide();\n        }\n    }\n});\n\n// Generic control/related handler to show/hide fields based on a select' value\n// this one is made to show all values if select value is not 0\n$(document).on(\"change\", \"select[data-controlall]\", function() {\n    var $this = $(this);\n    var name = $this.data(\"controlall\");\n    var showOrHide = parseInt($this.val(), 10);\n    if (showOrHide) {\n        $(\"[data-related=\" + name + \"]\").show();\n    } else {\n        $(\"[data-related=\" + name + \"]\").hide();\n    }\n});\n\n// Syntax has to be bind not on, otherwise problems with firefox\n$(\".container-fluid\").bind(\"dragenter dragover\", function () {\n    if($(\"#btn-upload\").length && !$('body').hasClass('shelforder')) {\n        $(this).css('background', '#e6e6e6');\n    }\n    return false;\n});\n\n// Syntax has to be bind not on, otherwise problems with firefox\n$(\".container-fluid\").bind(\"dragleave\", function () {\n    if($(\"#btn-upload\").length && !$('body').hasClass('shelforder')) {\n        $(this).css('background', '');\n    }\n    return false;\n});\n\n// Syntax has to be bind not on, otherwise problems with firefox\n$(\".container-fluid\").bind('drop', function (e) {\n    e.preventDefault()\n    e.stopPropagation();\n    if($(\"#btn-upload\").length) {\n        var files = e.originalEvent.dataTransfer.files;\n        var test = $(\"#btn-upload\")[0].accept;\n        $(this).css('background', '');\n        const dt = new DataTransfer();\n        jQuery.each(files, function (index, item) {\n            if (test.indexOf(item.name.substr(item.name.lastIndexOf('.'))) !== -1) {\n                dt.items.add(item);\n            }\n        });\n        if (dt.files.length) {\n            $(\"#btn-upload\")[0].files = dt.files;\n            $(\"#form-upload\").submit();\n        }\n    }\n});\n\n$(\"#btn-upload\").change(function() {\n    $(\"#form-upload\").submit();\n});\n\n$(\"#form-upload\").uploadprogress({\n    redirect_url: getPath() + \"/\", //\"{{ url_for('web.index')}}\",\n    uploadedMsg: $(\"#form-upload\").data(\"message\"), //\"{{_('Upload done, processing, please wait...')}}\",\n    modalTitle: $(\"#form-upload\").data(\"title\"), //\"{{_('Uploading...')}}\",\n    modalFooter: $(\"#form-upload\").data(\"footer\"), //\"{{_('Close')}}\",\n    modalTitleFailed: $(\"#form-upload\").data(\"failed\") //\"{{_('Error')}}\"\n});\n\n$(document).ready(function() {\n  var inp = $('#query').first()\n  if (inp.length) {\n    var val = inp.val()\n    if (val.length) {\n      inp.val('').blur().focus().val(val)\n    }\n  }\n});\n\n$(\".session\").click(function() {\n    window.sessionStorage.setItem(\"back\", window.location.pathname);\n});\n\n$(\"#back\").click(function() {\n   var loc = sessionStorage.getItem(\"back\");\n   if (!loc) {\n       loc = $(this).data(\"back\");\n   }\n   sessionStorage.removeItem(\"back\");\n   window.location.href = loc;\n\n});\n\nfunction confirmDialog(id, dialogid, dataValue, yesFn, noFn) {\n    var $confirm = $(\"#\" + dialogid);\n    $(\"#btnConfirmYes-\"+ dialogid).off('click').click(function () {\n        yesFn(dataValue);\n        $confirm.modal(\"hide\");\n    });\n    $(\"#btnConfirmNo-\"+ dialogid).off('click').click(function () {\n        if (typeof noFn !== 'undefined') {\n            noFn(dataValue);\n        }\n        $confirm.modal(\"hide\");\n    });\n    $.ajax({\n        method:\"post\",\n        dataType: \"json\",\n        url: getPath() + \"/ajax/loaddialogtexts/\" + id,\n        success: function success(data) {\n            $(\"#header-\"+ dialogid).html(data.header);\n            $(\"#text-\"+ dialogid).html(data.main);\n        }\n    });\n    $confirm.modal('show');\n}\n\n$(\"#delete_confirm\").click(function() {\n    //get data-id attribute of the clicked element\n    var deleteId = $(this).data(\"delete-id\");\n    var bookFormat = $(this).data(\"delete-format\");\n    var ajaxResponse = $(this).data(\"ajax\");\n    if (bookFormat) {\n        window.location.href = getPath() + \"/delete/\" + deleteId + \"/\" + bookFormat;\n    } else {\n        if (ajaxResponse) {\n            path = getPath() + \"/ajax/delete/\" + deleteId;\n            $.ajax({\n                method:\"post\",\n                url: path,\n                timeout: 900,\n                success:function(data) {\n                    data.forEach(function(item) {\n                        if (!jQuery.isEmptyObject(item)) {\n                            if (item.format != \"\") {\n                                $(\"button[data-delete-format='\"+item.format+\"']\").addClass('hidden');\n                            }\n                            $( \".navbar\" ).after( '<div class=\"row-fluid text-center\" >' +\n                                '<div id=\"flash_'+item.type+'\" class=\"alert alert-'+item.type+'\">'+item.message+'</div>' +\n                                '</div>');\n\n                        }\n                    });\n                    $(\"#books-table\").bootstrapTable(\"refresh\");\n                }\n            });\n        } else {\n            window.location.href = getPath() + \"/delete/\" + deleteId;\n\n        }\n    }\n\n});\n\n//triggered when modal is about to be shown\n$(\"#deleteModal\").on(\"show.bs.modal\", function(e) {\n    //get data-id attribute of the clicked element and store in button\n    var bookId = $(e.relatedTarget).data(\"delete-id\");\n    var bookfomat = $(e.relatedTarget).data(\"delete-format\");\n    if (bookfomat) {\n        $(\"#book_format\").removeClass('hidden');\n        $(\"#book_complete\").addClass('hidden');\n    } else {\n        $(\"#book_complete\").removeClass('hidden');\n        $(\"#book_format\").addClass('hidden');\n    }\n    $(e.currentTarget).find(\"#delete_confirm\").data(\"delete-id\", bookId);\n    $(e.currentTarget).find(\"#delete_confirm\").data(\"delete-format\", bookfomat);\n    $(e.currentTarget).find(\"#delete_confirm\").data(\"ajax\", $(e.relatedTarget).data(\"ajax\"));\n});\n\n$(function() {\n    var updateTimerID;\n    var updateText;\n\n    // Allow ajax prefilters to be added/removed dynamically\n    // eslint-disable-next-line new-cap\n    var preFilters = $.Callbacks();\n    $.ajaxPrefilter(preFilters.fire);\n\n    // equip all post requests with csrf_token\n    var csrftoken = $(\"input[name='csrf_token']\").val();\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrftoken)\n            }\n        }\n    });\n\n    function restartTimer() {\n        $(\"#spinner\").addClass(\"hidden\");\n        $(\"#RestartDialog\").modal(\"hide\");\n    }\n\n    function cleanUp() {\n        clearInterval(updateTimerID);\n        $(\"#spinner2\").hide();\n        $(\"#DialogFinished\").removeClass(\"hidden\");\n        $(\"#check_for_update\").removeClass(\"hidden\");\n        $(\"#perform_update\").addClass(\"hidden\");\n        $(\"#message\").alert(\"close\");\n        $(\"#update_table > tbody > tr\").each(function () {\n            if ($(this).attr(\"id\") !== \"current_version\") {\n                $(this).closest(\"tr\").remove();\n            }\n        });\n    }\n\n    function updateTimer() {\n        var no_response = 0;\n        $.ajax({\n            dataType: \"json\",\n            url: getPath() + \"/get_updater_status\",\n            success: function success(data) {\n                $(\"#DialogContent\").html(updateText[data.status]);\n                if (data.status > 6) {\n                    cleanUp();\n                }\n            },\n            error: function error() {\n                // Server has to restart in 60 Sek. otherwise output error message\n                no_response += 1;\n                if (no_response > 30) {\n                    $(\"#DialogContent\").html(updateText[11]);\n                    cleanUp();\n                }\n            },\n            timeout: 2000\n        });\n    }\n\n    function fillFileTable(path, type, folder, filt) {\n        var request_path = \"/../../ajax/pathchooser/\";\n        $.ajax({\n            dataType: \"json\",\n            data: {\n                path: path,\n                folder: folder,\n                filter: filt\n            },\n            url: window.location.pathname + request_path,\n            success: function success(data) {\n                if ($(\"#element_selected\").text() ===\"\") {\n                    $(\"#element_selected\").text(data.cwd);\n                }\n                $(\"#file_table > tbody > tr\").each(function () {\n                    if ($(this).attr(\"id\") !== \"parent\") {\n                        $(this).closest(\"tr\").remove();\n                    } else {\n                        if(data.absolute && data.parentdir !== \"\") {\n                           $(this)[0].attributes['data-path'].value  = data.parentdir;\n                        } else {\n                            $(this)[0].attributes['data-path'].value  = \"..\";\n                        }\n                    }\n                });\n                if (data.parentdir !== \"\") {\n                    $(\"#parent\").removeClass('hidden')\n                } else {\n                    $(\"#parent\").addClass('hidden')\n                }\n                // console.log(data);\n                data.files.forEach(function(entry) {\n                    if(entry.type === \"dir\") {\n                        var type = \"<span class=\\\"glyphicon glyphicon-folder-close\\\"></span>\";\n                } else {\n                    var type = \"\";\n                }\n                    $(\"<tr class=\\\"tr-clickable\\\" data-type=\\\"\" + entry.type + \"\\\" data-path=\\\"\" +\n                        entry.fullpath + \"\\\"><td>\" + type + \"</td><td>\" + entry.name + \"</td><td>\" +\n                        entry.size + \"</td></tr>\").appendTo($(\"#file_table\"));\n                });\n            },\n            timeout: 2000\n        });\n    }\n\n    $(\".discover .row\").isotope({\n        // options\n        itemSelector : \".book\",\n        layoutMode : \"fitRows\"\n    });\n\n    $(\".grid\").isotope({\n        // options\n        itemSelector : \".grid-item\",\n        layoutMode : \"fitColumns\"\n    });\n\n    if ($(\".load-more\").length && $(\".next\").length) {\n        var $loadMore = $(\".load-more .row\").infiniteScroll({\n            debug: false,\n            // selector for the paged navigation (it will be hidden)\n            path : \".next\",\n            // selector for the NEXT link (to page 2)\n            append : \".load-more .book\"\n            //animate      : true, # ToDo: Reenable function\n            //extraScrollPx: 300\n        });\n        $loadMore.on( \"append.infiniteScroll\", function( event, response, path, data ) {\n            if ($(\"body\").hasClass(\"blur\")) {\n                $(\".pagination\").addClass(\"hidden\").html(() => $(response).find(\".pagination\").html());\n                $(\" a:not(.dropdown-toggle) \")\n                  .removeAttr(\"data-toggle\");\n            }\n            $(\".load-more .row\").isotope( \"appended\", $(data), null );\n        });\n\n        // fix for infinite scroll on CaliBlur Theme (#981)\n        if ($(\"body\").hasClass(\"blur\")) {\n            $(\".col-sm-10\").bind(\"scroll\", function () {\n                if (\n                    $(this).scrollTop() + $(this).innerHeight() >=\n                    $(this)[0].scrollHeight\n                ) {\n                    $loadMore.infiniteScroll(\"loadNextPage\");\n                    window.history.replaceState({}, null, $loadMore.infiniteScroll(\"getAbsolutePath\"));\n                }\n            });\n        }\n    }\n\n    $(\"#restart\").click(function() {\n        $.ajax({\n            method:\"post\",\n            contentType: \"application/json; charset=utf-8\",\n            dataType: \"json\",\n            url: getPath() + \"/shutdown\",\n            data: JSON.stringify({\"parameter\":0}),\n            success: function success() {\n                $(\"#spinner\").show();\n                setTimeout(restartTimer, 3000);\n            }\n        });\n    });\n    $(\"#shutdown\").click(function() {\n        $.ajax({\n            method:\"post\",\n            contentType: \"application/json; charset=utf-8\",\n            dataType: \"json\",\n            url: getPath() + \"/shutdown\",\n            data: JSON.stringify({\"parameter\":1}),\n            success: function success(data) {\n                return alert(data.text);\n            }\n        });\n    });\n    $(\"#check_for_update\").click(function() {\n        var $this = $(this);\n        var buttonText = $this.html();\n        $this.html(\"...\");\n        $(\"#DialogContent\").html(\"\");\n        $(\"#DialogFinished\").addClass(\"hidden\");\n        $(\"#update_error\").addClass(\"hidden\");\n        if ($(\"#message\").length) {\n            $(\"#message\").alert(\"close\");\n        }\n        $.ajax({\n            dataType: \"json\",\n            url: window.location.pathname + \"/../../get_update_status\",\n            success: function success(data) {\n                $this.html(buttonText);\n\n                var cssClass = \"\";\n                var message = \"\";\n\n                if (data.success === true) {\n                    if (data.update === true) {\n                        $(\"#check_for_update\").addClass(\"hidden\");\n                        $(\"#perform_update\").removeClass(\"hidden\");\n                        $(\"#update_info\")\n                            .removeClass(\"hidden\")\n                            .find(\"span\").html(data.commit);\n\n                        data.history.forEach(function(entry) {\n                            $(\"<tr><td>\" + entry[0] + \"</td><td>\" + entry[1] + \"</td></tr>\").appendTo($(\"#update_table\"));\n                        });\n                        cssClass = \"alert-warning\";\n                    } else {\n                        cssClass = \"alert-success\";\n                    }\n                } else {\n                    cssClass = \"alert-danger\";\n                }\n\n                message = \"<div id=\\\"message\\\" class=\\\"alert \" + cssClass\n                    + \" fade in\\\"><a href=\\\"#\\\" class=\\\"close\\\" data-dismiss=\\\"alert\\\">&times;</a>\"\n                    + data.message + \"</div>\";\n\n                $(message).insertAfter($(\"#update_table\"));\n            }\n        });\n    });\n    $(\"#restart_database\").click(function() {\n        $(\"#DialogHeader\").addClass(\"hidden\");\n        $(\"#DialogFinished\").addClass(\"hidden\");\n        $(\"#DialogContent\").html(\"\");\n        $(\"#spinner2\").show();\n        $.ajax({\n            method:\"post\",\n            contentType: \"application/json; charset=utf-8\",\n            dataType: \"json\",\n            url: getPath() + \"/shutdown\",\n            data: JSON.stringify({\"parameter\":2}),\n            success: function success(data) {\n                $(\"#spinner2\").hide();\n                $(\"#DialogContent\").html(data.text);\n                $(\"#DialogFinished\").removeClass(\"hidden\");\n            }\n        });\n    });\n    $(\"#perform_update\").click(function() {\n        $(\"#DialogHeader\").removeClass(\"hidden\");\n        $(\"#spinner2\").show();\n        $.ajax({\n            type: \"POST\",\n            dataType: \"json\",\n            data: { start: \"True\" },\n            url: getPath() + \"/get_updater_status\",\n            success: function success(data) {\n                updateText = data.text;\n                $(\"#DialogContent\").html(updateText[data.status]);\n                updateTimerID = setInterval(updateTimer, 2000);\n            }\n        });\n    });\n\n    // Init all data control handlers to default\n    $(\"input[data-control]\").trigger(\"change\");\n    $(\"select[data-control]\").trigger(\"change\");\n    $(\"select[data-controlall]\").trigger(\"change\");\n\n    $(\"#bookDetailsModal\")\n        .on(\"show.bs.modal\", function(e) {\n            var $modalBody = $(this).find(\".modal-body\");\n\n            // Prevent static assets from loading multiple times\n            var useCache = function(options) {\n                options.async = true;\n                options.cache = true;\n            };\n            preFilters.add(useCache);\n\n            $.get(e.relatedTarget.href).done(function(content) {\n                $modalBody.html(content);\n                preFilters.remove(useCache);\n            });\n        })\n        .on(\"hidden.bs.modal\", function() {\n            $(this).find(\".modal-body\").html(\"...\");\n        });\n\n    $(\"#modal_kobo_token\")\n        .on(\"show.bs.modal\", function(e) {\n            var $modalBody = $(this).find(\".modal-body\");\n\n            // Prevent static assets from loading multiple times\n            var useCache = function(options) {\n                options.async = true;\n                options.cache = true;\n            };\n            preFilters.add(useCache);\n\n            $.get(e.relatedTarget.href).done(function(content) {\n                $modalBody.html(content);\n                preFilters.remove(useCache);\n            });\n        })\n        .on(\"hidden.bs.modal\", function() {\n            $(this).find(\".modal-body\").html(\"...\");\n            $(\"#config_delete_kobo_token\").show();\n            $(\"#kobo_full_sync\").show();\n        });\n\n    $(\"#config_delete_kobo_token\").click(function() {\n        confirmDialog(\n            $(this).attr('id'),\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function (value) {\n                $.ajax({\n                    method: \"post\",\n                    url: getPath() + \"/kobo_auth/deleteauthtoken/\" + value,\n                });\n                $(\"#config_delete_kobo_token\").hide();\n                $(\"#kobo_full_sync\").hide();\n            }\n        );\n    });\n\n    $(\"#toggle_order_shelf\").click(function() {\n        $(\"#new\").toggleClass(\"disabled\");\n        $(\"#old\").toggleClass(\"disabled\");\n        $(\"#asc\").toggleClass(\"disabled\");\n        $(\"#desc\").toggleClass(\"disabled\");\n        $(\"#auth_az\").toggleClass(\"disabled\");\n        $(\"#auth_za\").toggleClass(\"disabled\");\n        $(\"#pub_new\").toggleClass(\"disabled\");\n        $(\"#pub_old\").toggleClass(\"disabled\");\n        var alternative_text = $(\"#toggle_order_shelf\").data('alt-text');\n        $(\"#toggle_order_shelf\").data('alt-text', $(\"#toggle_order_shelf\").html());\n        $(\"#toggle_order_shelf\").html(alternative_text);\n    });\n\n    $(\"#btndeluser\").click(function() {\n        confirmDialog(\n            $(this).attr('id'),\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function(value){\n                var subform = $('#user_submit').closest(\"form\");\n                subform.submit(function(eventObj) {\n                    $(this).append('<input type=\"hidden\" name=\"delete\" value=\"True\" />');\n                    return true;\n                });\n                subform.submit();\n            }\n        );\n    });\n\n    $(\"#kobo_full_sync\").click(function() {\n        confirmDialog(\n           \"btnfullsync\",\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function(value){\n                path = getPath() + \"/ajax/fullsync\"\n                $.ajax({\n                    method:\"post\",\n                    url: path,\n                    timeout: 900,\n                    success:function(data) {\n                        data.forEach(function(item) {\n                            if (!jQuery.isEmptyObject(item)) {\n                                $( \".navbar\" ).after( '<div class=\"row-fluid text-center\" >' +\n                                    '<div id=\"flash_'+item.type+'\" class=\"alert alert-'+item.type+'\">'+item.message+'</div>' +\n                                    '</div>');\n                            }\n                        });\n                    }\n                });\n            }\n        );\n    });\n\n\n    $(\"#user_submit\").click(function() {\n        this.closest(\"form\").submit();\n    });\n\n    function handle_response(data) {\n        if (!jQuery.isEmptyObject(data)) {\n            data.forEach(function (item) {\n                $(\".navbar\").after('<div class=\"row-fluid text-center\">' +\n                    '<div id=\"flash_' + item.type + '\" class=\"alert alert-' + item.type + '\">' + item.message + '</div>' +\n                    '</div>');\n            });\n        }\n    }\n\n    $('.collapse').on('shown.bs.collapse', function(){\n        $(this).parent().find(\".glyphicon-plus\").removeClass(\"glyphicon-plus\").addClass(\"glyphicon-minus\");\n    }).on('hidden.bs.collapse', function(){\n    $(this).parent().find(\".glyphicon-minus\").removeClass(\"glyphicon-minus\").addClass(\"glyphicon-plus\");\n    });\n\n    function changeDbSettings() {\n        $(\"#db_submit\").closest('form').submit();\n    }\n\n    $(\"#db_submit\").click(function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.blur();\n        $.ajax({\n            method:\"post\",\n            dataType: \"json\",\n            url: window.location.pathname + \"/../../ajax/simulatedbchange\",\n            data: {config_calibre_dir: $(\"#config_calibre_dir\").val(), csrf_token: $(\"input[name='csrf_token']\").val()},\n            success: function success(data) {\n                if ( data.change ) {\n                    if ( data.valid ) {\n                        confirmDialog(\n                        \"db_submit\",\n                    \"GeneralChangeModal\",\n                            0,\n                            changeDbSettings\n                        );\n                    }\n                    else {\n                        $(\"#InvalidDialog\").modal('show');\n                    }\n                } else {\n                    changeDbSettings();\n                }\n            }\n        });\n    });\n\n    $(\"#config_submit\").click(function(e) {\n        e.preventDefault();\n        e.stopPropagation();\n        this.blur();\n        window.scrollTo({top: 0, behavior: 'smooth'});\n        var request_path = \"/../../admin/ajaxconfig\";\n        var loader = \"/../..\";\n        $(\"#flash_success\").remove();\n        $(\"#flash_danger\").remove();\n        $.post(window.location.pathname + request_path, $(this).closest(\"form\").serialize(), function(data) {\n            $('#config_upload_formats').val(data.config_upload);\n            if(data.reboot) {\n                $(\"#spinning_success\").show();\n                var rebootInterval = setInterval(function(){\n                    $.get({\n                        url:window.location.pathname + \"/../../admin/alive\",\n                        success: function (d, statusText, xhr) {\n                            if (xhr.status < 400) {\n                                $(\"#spinning_success\").hide();\n                                clearInterval(rebootInterval);\n                                if (data.result) {\n                                    handle_response(data.result);\n                                    data.result = \"\";\n                                }\n                            }\n                        },\n                    });\n                }, 1000);\n            } else {\n                handle_response(data.result);\n            }\n        });\n    });\n\n    $(\"#delete_shelf\").click(function() {\n        confirmDialog(\n            $(this).attr('id'),\n            \"GeneralDeleteModal\",\n            $(this).data('value'),\n            function(value){\n                $(\"#delete_shelf\").closest(\"form\").submit()\n            }\n        );\n\n    });\n\n    $(\"#fileModal\").on(\"show.bs.modal\", function(e) {\n        var target = $(e.relatedTarget);\n        var path = $(\"#\" + target.data(\"link\"))[0].value;\n        var folder = target.data(\"folderonly\");\n        var filter = target.data(\"filefilter\");\n        $(\"#element_selected\").text(path);\n        $(\"#file_confirm\").data(\"link\", target.data(\"link\"));\n        $(\"#file_confirm\").data(\"folderonly\", (typeof folder === 'undefined') ? false : true);\n        $(\"#file_confirm\").data(\"filefilter\", (typeof filter === 'undefined') ? \"\" : filter);\n        $(\"#file_confirm\").data(\"newfile\", target.data(\"newfile\"));\n        fillFileTable(path,\"dir\", folder, filter);\n    });\n\n    $(\"#file_confirm\").click(function() {\n        $(\"#\" + $(this).data(\"link\"))[0].value = $(\"#element_selected\").text()\n    });\n\n    $(document).on(\"click\", \".tr-clickable\", function() {\n        var path = this.attributes[\"data-path\"].value;\n        var type = this.attributes[\"data-type\"].value;\n        var folder = $(file_confirm).data(\"folderonly\");\n        var filter = $(file_confirm).data(\"filefilter\");\n        var newfile = $(file_confirm).data(\"newfile\");\n        if (newfile !== \"\") {\n            $(\"#element_selected\").text(path + $(\"#new_file\".text()));\n        } else {\n            $(\"#element_selected\").text(path);\n        }\n        if(type === \"dir\") {\n            fillFileTable(path, type, folder, filter);\n        }\n    });\n\n    $(window).resize(function() {\n        $(\".discover .row\").isotope(\"layout\");\n    });\n\n    $(\"#import_ldap_users\").click(function() {\n        $(\"#DialogHeader\").addClass(\"hidden\");\n        $(\"#DialogFinished\").addClass(\"hidden\");\n        $(\"#DialogContent\").html(\"\");\n        $(\"#spinner2\").show();\n        $.ajax({\n            method:\"post\",\n            contentType: \"application/json; charset=utf-8\",\n            dataType: \"json\",\n            url: getPath() + \"/import_ldap_users\",\n            success: function success(data) {\n                $(\"#spinner2\").hide();\n                $(\"#DialogContent\").html(data.text);\n                $(\"#DialogFinished\").removeClass(\"hidden\");\n            }\n        });\n    });\n\n    $(\".author-expand\").click(function() {\n        $(this).parent().find(\"a.author-name\").slice($(this).data(\"authors-max\")).toggle();\n        $(this).parent().find(\"span.author-hidden-divider\").toggle();\n        $(this).html() === $(this).data(\"collapse-caption\") ? $(this).html(\"(...)\") : $(this).html($(this).data(\"collapse-caption\"));\n        $(\".discover .row\").isotope(\"layout\");\n    });\n\n    $(\".update-view\").click(function(e) {\n        var view = $(this).data(\"view\");\n        e.preventDefault();\n        e.stopPropagation();\n        $.ajax({\n            method:\"post\",\n            contentType: \"application/json; charset=utf-8\",\n            dataType: \"json\",\n            url: getPath() + \"/ajax/view\",\n            data: \"{\\\"series\\\": {\\\"series_view\\\": \\\"\"+ view +\"\\\"}}\",\n            success: function success() {\n                location.reload();\n            }\n        });\n    });\n});\n\n", "{% extends \"layout.html\" %}\n{% block body %}\n<div class=\"discover\">\n  <h2>{{title}}</h2>\n      <form action=\"{{url_for('shelf.delete_shelf', shelf_id=shelf.id)}}\" method=\"post\">\n  {% if g.user.role_download() %}\n  <a id=\"shelf_down\" href=\"{{ url_for('shelf.show_simpleshelf', shelf_id=shelf.id) }}\" class=\"btn btn-primary\">{{ _('Download') }} </a>\n      {% endif %}\n  {% if g.user.is_authenticated %}\n    {% if (g.user.role_edit_shelfs() and shelf.is_public ) or not shelf.is_public  %}\n        <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\">\n        <div class=\"btn btn-danger\" id=\"delete_shelf\" data-value=\"{{ shelf.id }}\">{{ _('Delete this Shelf') }}</div>\n      <a id=\"edit_shelf\" href=\"{{ url_for('shelf.edit_shelf', shelf_id=shelf.id) }}\" class=\"btn btn-primary\">{{ _('Edit Shelf Properties') }} </a>\n      </form>\n      {% if entries.__len__() %}\n      <a id=\"order_shelf\" href=\"{{ url_for('shelf.order_shelf', shelf_id=shelf.id) }}\" class=\"btn btn-primary\">{{ _('Arrange books manually') }} </a>\n      <button id=\"toggle_order_shelf\" type=\"button\" data-alt-text=\"{{ _('Disable Change order') }}\" class=\"btn btn-primary\">{{ _('Enable Change order') }}</button>\n        <div class=\"filterheader hidden-xs\">\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, newest first')}}\" id=\"new\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='new')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to book date, oldest first')}}\" id=\"old\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='old')}}\"><span class=\"glyphicon glyphicon-book\"></span> <span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort title in alphabetical order')}}\" id=\"asc\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='abc')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort title in reverse alphabetical order')}}\" id=\"desc\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='zyx')}}\"><span class=\"glyphicon glyphicon-font\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in alphabetical order')}}\" id=\"auth_az\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='authaz')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort authors in reverse alphabetical order')}}\" id=\"auth_za\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='authza')}}\"><span class=\"glyphicon glyphicon-user\"></span><span class=\"glyphicon glyphicon-sort-by-alphabet-alt\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, newest first')}}\" id=\"pub_new\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='pubnew')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order\"></span></a>\n          <a data-toggle=\"tooltip\" title=\"{{_('Sort according to publishing date, oldest first')}}\" id=\"pub_old\" class=\"btn btn-primary disabled\" href=\"{{url_for('shelf.show_shelf', shelf_id=shelf.id, sort_param='pubold')}}\"><span class=\"glyphicon glyphicon-calendar\"></span><span class=\"glyphicon glyphicon-sort-by-order-alt\"></span></a>\n        </div>\n      {% endif %}\n    {% endif %}\n  {% endif %}\n  <div class=\"row display-flex\">\n    {% for entry in entries %}\n    <div class=\"col-sm-3 col-lg-2 col-xs-6 book\">\n      <div class=\"cover\">\n            <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n              <span class=\"img\" title=\"{{entry.title}}\" >\n                <img src=\"{{ url_for('web.get_cover', book_id=entry.id) }}\" alt=\"{{ entry.title }}\" />\n                {% if entry.id in read_book_ids %}<span class=\"badge read glyphicon glyphicon-ok\"></span>{% endif %}\n              </span>\n            </a>\n      </div>\n      <div class=\"meta\">\n        <a href=\"{{ url_for('web.show_book', book_id=entry.id) }}\" data-toggle=\"modal\" data-target=\"#bookDetailsModal\" data-remote=\"false\">\n          <p title=\"{{entry.title}}\" class=\"title\">{{entry.title|shortentitle}}</p>\n        </a>\n        <p class=\"author\">\n          {% for author in entry.authors %}\n            {% if loop.index > g.config_authors_max and g.config_authors_max != 0 %}\n              {% if not loop.first %}\n                <span class=\"author-hidden-divider\">&amp;</span>\n\t\t\t  {% endif %}\n              <a class=\"author-name author-hidden\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n              {% if loop.last %}\n                <a href=\"#\" class=\"author-expand\" data-authors-max=\"{{g.config_authors_max}}\" data-collapse-caption=\"({{_('reduce')}})\">(...)</a>\n              {% endif %}\n            {% else %}\n              {% if not loop.first %}\n                <span>&amp;</span>\n              {% endif %}\n              <a class=\"author-name\" href=\"{{url_for('web.books_list',  data='author', sort_param='new', book_id=author.id) }}\">{{author.name.replace('|',',')|shortentitle(30)}}</a>\n            {% endif %}\n          {% endfor %}\n        </p>\n        {% if entry.series.__len__() > 0 %}\n        <p class=\"series\">\n          <a href=\"{{url_for('web.books_list', data='series', sort_param='new', book_id=entry.series[0].id )}}\">\n            {{entry.series[0].name}}\n          </a>\n          ({{entry.series_index|formatseriesindex}})\n        </p>\n        {% endif %}\n        {% if entry.ratings.__len__() > 0 %}\n        <div class=\"rating\">\n          {% for number in range((entry.ratings[0].rating/2)|int(2)) %}\n            <span class=\"glyphicon glyphicon-star good\"></span>\n            {% if loop.last and loop.index < 5 %}\n              {% for numer in range(5 - loop.index) %}\n                <span class=\"glyphicon glyphicon-star-empty\"></span>\n              {% endfor %}\n            {% endif %}\n          {% endfor %}\n        </div>\n        {% endif %}\n      </div>\n    </div>\n    {% endfor %}\n  </div>\n</div>\n{% endblock %}\n{% block modal %}\n{{ delete_confirm_modal() }}\n{% endblock %}\n", "# -*- coding: utf-8 -*-\n\n#  This file is part of the Calibre-Web (https://github.com/janeczku/calibre-web)\n#    Copyright (C) 2018-2019 OzzieIsaacs, cervinko, jkrehm, bodybybuddha, ok11,\n#                            andy29485, idalin, Kyosfonica, wuqi, Kennyl, lemmsh,\n#                            falgh1, grunjol, csitko, ytils, xybydy, trasba, vrabe,\n#                            ruben-herold, marblepebble, JackED42, SiphonSquirrel,\n#                            apetresc, nanu-c, mutschler\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nimport os\nfrom datetime import datetime\nimport json\nimport mimetypes\nimport chardet  # dependency of requests\nimport copy\n\nfrom babel.dates import format_date\nfrom babel import Locale as LC\nfrom flask import Blueprint, jsonify\nfrom flask import request, redirect, send_from_directory, make_response, flash, abort, url_for\nfrom flask import session as flask_session\nfrom flask_babel import gettext as _\nfrom flask_login import login_user, logout_user, login_required, current_user\nfrom sqlalchemy.exc import IntegrityError, InvalidRequestError, OperationalError\nfrom sqlalchemy.sql.expression import text, func, false, not_, and_, or_\nfrom sqlalchemy.orm.attributes import flag_modified\nfrom sqlalchemy.sql.functions import coalesce\n\nfrom .services.worker import WorkerThread\n\nfrom werkzeug.datastructures import Headers\nfrom werkzeug.security import generate_password_hash, check_password_hash\n\nfrom . import constants, logger, isoLanguages, services\nfrom . import babel, db, ub, config, get_locale, app\nfrom . import calibre_db, kobo_sync_status\nfrom .gdriveutils import getFileFromEbooksFolder, do_gdrive_download\nfrom .helper import check_valid_domain, render_task_status, check_email, check_username, \\\n    get_cc_columns, get_book_cover, get_download_link, send_mail, generate_random_password, \\\n    send_registration_mail, check_send_to_kindle, check_read_formats, tags_filters, reset_password, valid_email\nfrom .pagination import Pagination\nfrom .redirect import redirect_back\nfrom .usermanagement import login_required_if_no_ano\nfrom .kobo_sync_status import remove_synced_book\nfrom .render_template import render_title_template\nfrom .kobo_sync_status import change_archived_books\n\nfeature_support = {\n    'ldap': bool(services.ldap),\n    'goodreads': bool(services.goodreads_support),\n    'kobo': bool(services.kobo)\n}\n\ntry:\n    from .oauth_bb import oauth_check, register_user_with_oauth, logout_oauth_user, get_oauth_status\n    feature_support['oauth'] = True\nexcept ImportError:\n    feature_support['oauth'] = False\n    oauth_check = {}\n\ntry:\n    from functools import wraps\nexcept ImportError:\n    pass  # We're not using Python 3\n\ntry:\n    from natsort import natsorted as sort\nexcept ImportError:\n    sort = sorted  # Just use regular sort then, may cause issues with badly named pages in cbz/cbr files\n\n\n@app.after_request\ndef add_security_headers(resp):\n    resp.headers['Content-Security-Policy'] = \"default-src 'self'\" + ''.join([' '+host for host in config.config_trustedhosts.strip().split(',')]) + \" 'unsafe-inline' 'unsafe-eval'; font-src 'self' data:; img-src 'self' data:\"\n    if request.endpoint == \"editbook.edit_book\" or config.config_use_google_drive:\n        resp.headers['Content-Security-Policy'] += \" *\"\n    elif request.endpoint == \"web.read_book\":\n        resp.headers['Content-Security-Policy'] += \" blob:;style-src-elem 'self' blob: 'unsafe-inline';\"\n    resp.headers['X-Content-Type-Options'] = 'nosniff'\n    resp.headers['X-Frame-Options'] = 'SAMEORIGIN'\n    resp.headers['X-XSS-Protection'] = '1; mode=block'\n    resp.headers['Strict-Transport-Security'] = 'max-age=31536000;'\n    return resp\n\nweb = Blueprint('web', __name__)\nlog = logger.create()\n\n\n# ################################### Login logic and rights management ###############################################\n\n\ndef download_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_download():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n\ndef viewer_required(f):\n    @wraps(f)\n    def inner(*args, **kwargs):\n        if current_user.role_viewer():\n            return f(*args, **kwargs)\n        abort(403)\n\n    return inner\n\n# ################################### data provider functions #########################################################\n\n\n@web.route(\"/ajax/emailstat\")\n@login_required\ndef get_email_status_json():\n    tasks = WorkerThread.getInstance().tasks\n    return jsonify(render_task_status(tasks))\n\n\n@web.route(\"/ajax/bookmark/<int:book_id>/<book_format>\", methods=['POST'])\n@login_required\ndef bookmark(book_id, book_format):\n    bookmark_key = request.form[\"bookmark\"]\n    ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                              ub.Bookmark.book_id == book_id,\n                                              ub.Bookmark.format == book_format)).delete()\n    if not bookmark_key:\n        ub.session_commit()\n        return \"\", 204\n\n    lbookmark = ub.Bookmark(user_id=current_user.id,\n                            book_id=book_id,\n                            format=book_format,\n                            bookmark_key=bookmark_key)\n    ub.session.merge(lbookmark)\n    ub.session_commit(\"Bookmark for user {} in book {} created\".format(current_user.id, book_id))\n    return \"\", 201\n\n\n@web.route(\"/ajax/toggleread/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_read(book_id):\n    if not config.config_read_column:\n        book = ub.session.query(ub.ReadBook).filter(and_(ub.ReadBook.user_id == int(current_user.id),\n                                                         ub.ReadBook.book_id == book_id)).first()\n        if book:\n            if book.read_status == ub.ReadBook.STATUS_FINISHED:\n                book.read_status = ub.ReadBook.STATUS_UNREAD\n            else:\n                book.read_status = ub.ReadBook.STATUS_FINISHED\n        else:\n            readBook = ub.ReadBook(user_id=current_user.id, book_id = book_id)\n            readBook.read_status = ub.ReadBook.STATUS_FINISHED\n            book = readBook\n        if not book.kobo_reading_state:\n            kobo_reading_state = ub.KoboReadingState(user_id=current_user.id, book_id=book_id)\n            kobo_reading_state.current_bookmark = ub.KoboBookmark()\n            kobo_reading_state.statistics = ub.KoboStatistics()\n            book.kobo_reading_state = kobo_reading_state\n        ub.session.merge(book)\n        ub.session_commit(\"Book {} readbit toggled\".format(book_id))\n    else:\n        try:\n            calibre_db.update_title_sort(config)\n            book = calibre_db.get_filtered_book(book_id)\n            read_status = getattr(book, 'custom_column_' + str(config.config_read_column))\n            if len(read_status):\n                read_status[0].value = not read_status[0].value\n                calibre_db.session.commit()\n            else:\n                cc_class = db.cc_classes[config.config_read_column]\n                new_cc = cc_class(value=1, book=book_id)\n                calibre_db.session.add(new_cc)\n                calibre_db.session.commit()\n        except (KeyError, AttributeError):\n            log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            return \"Custom Column No.{} is not existing in calibre database\".format(config.config_read_column), 400\n        except (OperationalError, InvalidRequestError) as e:\n            calibre_db.session.rollback()\n            log.error(u\"Read status could not set: {}\".format(e))\n            return \"Read status could not set: {}\".format(e), 400\n    return \"\"\n\n@web.route(\"/ajax/togglearchived/<int:book_id>\", methods=['POST'])\n@login_required\ndef toggle_archived(book_id):\n    is_archived = change_archived_books(book_id, message=\"Book {} archivebit toggled\".format(book_id))\n    if is_archived:\n        remove_synced_book(book_id)\n    return \"\"\n\n\n@web.route(\"/ajax/view\", methods=[\"POST\"])\n@login_required_if_no_ano\ndef update_view():\n    to_save = request.get_json()\n    try:\n        for element in to_save:\n            for param in to_save[element]:\n                current_user.set_view_property(element, param, to_save[element][param])\n    except Exception as ex:\n        log.error(\"Could not save view_settings: %r %r: %e\", request, to_save, ex)\n        return \"Invalid request\", 400\n    return \"1\", 200\n\n\n'''\n@web.route(\"/ajax/getcomic/<int:book_id>/<book_format>/<int:page>\")\n@login_required\ndef get_comic_book(book_id, book_format, page):\n    book = calibre_db.get_book(book_id)\n    if not book:\n        return \"\", 204\n    else:\n        for bookformat in book.data:\n            if bookformat.format.lower() == book_format.lower():\n                cbr_file = os.path.join(config.config_calibre_dir, book.path, bookformat.name) + \".\" + book_format\n                if book_format in (\"cbr\", \"rar\"):\n                    if feature_support['rar'] == True:\n                        rarfile.UNRAR_TOOL = config.config_rarfile_location\n                        try:\n                            rf = rarfile.RarFile(cbr_file)\n                            names = sort(rf.namelist())\n                            extract = lambda page: rf.read(names[page])\n                        except:\n                            # rarfile not valid\n                            log.error('Unrar binary not found, or unable to decompress file %s', cbr_file)\n                            return \"\", 204\n                    else:\n                        log.info('Unrar is not supported please install python rarfile extension')\n                        # no support means return nothing\n                        return \"\", 204\n                elif book_format in (\"cbz\", \"zip\"):\n                    zf = zipfile.ZipFile(cbr_file)\n                    names=sort(zf.namelist())\n                    extract = lambda page: zf.read(names[page])\n                elif book_format in (\"cbt\", \"tar\"):\n                    tf = tarfile.TarFile(cbr_file)\n                    names=sort(tf.getnames())\n                    extract = lambda page: tf.extractfile(names[page]).read()\n                else:\n                    log.error('unsupported comic format')\n                    return \"\", 204\n\n                b64 = codecs.encode(extract(page), 'base64').decode()\n                ext = names[page].rpartition('.')[-1]\n                if ext not in ('png', 'gif', 'jpg', 'jpeg', 'webp'):\n                    ext = 'png'\n                extractedfile=\"data:image/\" + ext + \";base64,\" + b64\n                fileData={\"name\": names[page], \"page\":page, \"last\":len(names)-1, \"content\": extractedfile}\n                return make_response(json.dumps(fileData))\n        return \"\", 204\n'''\n\n# ################################### Typeahead ##################################################################\n\n\n@web.route(\"/get_authors_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_authors_json():\n    return calibre_db.get_typeahead(db.Authors, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_publishers_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_publishers_json():\n    return calibre_db.get_typeahead(db.Publishers, request.args.get('q'), ('|', ','))\n\n\n@web.route(\"/get_tags_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_tags_json():\n    return calibre_db.get_typeahead(db.Tags, request.args.get('q'), tag_filter=tags_filters())\n\n\n@web.route(\"/get_series_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_series_json():\n    return calibre_db.get_typeahead(db.Series, request.args.get('q'))\n\n\n@web.route(\"/get_languages_json\", methods=['GET'])\n@login_required_if_no_ano\ndef get_languages_json():\n    query = (request.args.get('q') or '').lower()\n    language_names = isoLanguages.get_language_names(get_locale())\n    entries_start = [s for key, s in language_names.items() if s.lower().startswith(query.lower())]\n    if len(entries_start) < 5:\n        entries = [s for key, s in language_names.items() if query in s.lower()]\n        entries_start.extend(entries[0:(5 - len(entries_start))])\n        entries_start = list(set(entries_start))\n    json_dumps = json.dumps([dict(name=r) for r in entries_start[0:5]])\n    return json_dumps\n\n\n@web.route(\"/get_matching_tags\", methods=['GET'])\n@login_required_if_no_ano\ndef get_matching_tags():\n    tag_dict = {'tags': []}\n    q = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(True))\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    author_input = request.args.get('author_name') or ''\n    title_input = request.args.get('book_title') or ''\n    include_tag_inputs = request.args.getlist('include_tag') or ''\n    exclude_tag_inputs = request.args.getlist('exclude_tag') or ''\n    q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_input + \"%\")),\n                 func.lower(db.Books.title).ilike(\"%\" + title_input + \"%\"))\n    if len(include_tag_inputs) > 0:\n        for tag in include_tag_inputs:\n            q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    if len(exclude_tag_inputs) > 0:\n        for tag in exclude_tag_inputs:\n            q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    for book in q:\n        for tag in book.tags:\n            if tag.id not in tag_dict['tags']:\n                tag_dict['tags'].append(tag.id)\n    json_dumps = json.dumps(tag_dict)\n    return json_dumps\n\n\ndef get_sort_function(sort, data):\n    order = [db.Books.timestamp.desc()]\n    if sort == 'stored':\n        sort = current_user.get_view_property(data, 'stored')\n    else:\n        current_user.set_view_property(data, 'stored', sort)\n    if sort == 'pubnew':\n        order = [db.Books.pubdate.desc()]\n    if sort == 'pubold':\n        order = [db.Books.pubdate]\n    if sort == 'abc':\n        order = [db.Books.sort]\n    if sort == 'zyx':\n        order = [db.Books.sort.desc()]\n    if sort == 'new':\n        order = [db.Books.timestamp.desc()]\n    if sort == 'old':\n        order = [db.Books.timestamp]\n    if sort == 'authaz':\n        order = [db.Books.author_sort.asc(), db.Series.name, db.Books.series_index]\n    if sort == 'authza':\n        order = [db.Books.author_sort.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n    if sort == 'seriesasc':\n        order = [db.Books.series_index.asc()]\n    if sort == 'seriesdesc':\n        order = [db.Books.series_index.desc()]\n    if sort == 'hotdesc':\n        order = [func.count(ub.Downloads.book_id).desc()]\n    if sort == 'hotasc':\n        order = [func.count(ub.Downloads.book_id).asc()]\n    if sort is None:\n        sort = \"new\"\n    return order, sort\n\n\ndef render_books_list(data, sort, book_id, page):\n    order = get_sort_function(sort, data)\n    if data == \"rated\":\n        return render_rated_books(page, book_id, order=order)\n    elif data == \"discover\":\n        return render_discover_books(page, book_id)\n    elif data == \"unread\":\n        return render_read_books(page, False, order=order)\n    elif data == \"read\":\n        return render_read_books(page, True, order=order)\n    elif data == \"hot\":\n        return render_hot_books(page, order)\n    elif data == \"download\":\n        return render_downloaded_books(page, order, book_id)\n    elif data == \"author\":\n        return render_author_books(page, book_id, order)\n    elif data == \"publisher\":\n        return render_publisher_books(page, book_id, order)\n    elif data == \"series\":\n        return render_series_books(page, book_id, order)\n    elif data == \"ratings\":\n        return render_ratings_books(page, book_id, order)\n    elif data == \"formats\":\n        return render_formats_books(page, book_id, order)\n    elif data == \"category\":\n        return render_category_books(page, book_id, order)\n    elif data == \"language\":\n        return render_language_books(page, book_id, order)\n    elif data == \"archived\":\n        return render_archived_books(page, order)\n    elif data == \"search\":\n        term = (request.args.get('query') or '')\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_search_results(term, offset, order, config.config_books_per_page)\n    elif data == \"advsearch\":\n        term = json.loads(flask_session['query'])\n        offset = int(int(config.config_books_per_page) * (page - 1))\n        return render_adv_search_results(term, offset, order, config.config_books_per_page)\n    else:\n        website = data or \"newest\"\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, order[0],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Books\"), page=website, order=order[1])\n\n\ndef render_rated_books(page, book_id, order):\n    if current_user.check_visibility(constants.SIDEBAR_BEST_RATED):\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.ratings.any(db.Ratings.rating > 9),\n                                                                order[0],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     id=book_id, title=_(u\"Top Rated Books\"), page=\"rated\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_discover_books(page, book_id):\n    if current_user.check_visibility(constants.SIDEBAR_RANDOM):\n        entries, __, pagination = calibre_db.fill_indexpage(page, 0, db.Books, True, [func.randomblob(2)])\n        pagination = Pagination(1, config.config_books_per_page, config.config_books_per_page)\n        return render_title_template('discover.html', entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Discover (Random Books)\"), page=\"discover\")\n    else:\n        abort(404)\n\ndef render_hot_books(page, order):\n    if current_user.check_visibility(constants.SIDEBAR_HOT):\n        if order[1] not in ['hotasc', 'hotdesc']:\n        # Unary expression comparsion only working (for this expression) in sqlalchemy 1.4+\n        #if not (order[0][0].compare(func.count(ub.Downloads.book_id).desc()) or\n        #        order[0][0].compare(func.count(ub.Downloads.book_id).asc())):\n            order = [func.count(ub.Downloads.book_id).desc()], 'hotdesc'\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n        off = int(int(config.config_books_per_page) * (page - 1))\n        all_books = ub.session.query(ub.Downloads, func.count(ub.Downloads.book_id))\\\n            .order_by(*order[0]).group_by(ub.Downloads.book_id)\n        hot_books = all_books.offset(off).limit(config.config_books_per_page)\n        entries = list()\n        for book in hot_books:\n            downloadBook = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).filter(\n                db.Books.id == book.Downloads.book_id).first()\n            if downloadBook:\n                entries.append(downloadBook)\n            else:\n                ub.delete_download(book.Downloads.book_id)\n        numBooks = entries.__len__()\n        pagination = Pagination(page, config.config_books_per_page, numBooks)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=_(u\"Hot Books (Most Downloaded)\"), page=\"hot\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_downloaded_books(page, order, user_id):\n    if current_user.role_admin():\n        user_id = int(user_id)\n    else:\n        user_id = current_user.id\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD):\n        if current_user.show_detail_random():\n            random = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                .order_by(func.random()).limit(config.config_random_books)\n        else:\n            random = false()\n\n        entries, __, pagination = calibre_db.fill_indexpage(page,\n                                                            0,\n                                                            db.Books,\n                                                            ub.Downloads.user_id == user_id,\n                                                            order[0],\n                                                            db.books_series_link,\n                                                            db.Books.id == db.books_series_link.c.book,\n                                                            db.Series,\n                                                            ub.Downloads, db.Books.id == ub.Downloads.book_id)\n        for book in entries:\n            if not calibre_db.session.query(db.Books).filter(calibre_db.common_filters()) \\\n                             .filter(db.Books.id == book.id).first():\n                ub.delete_download(book.id)\n        user = ub.session.query(ub.User).filter(ub.User.id == user_id).first()\n        return render_title_template('index.html',\n                                     random=random,\n                                     entries=entries,\n                                     pagination=pagination,\n                                     id=user_id,\n                                     title=_(u\"Downloaded books by %(user)s\",user=user.name),\n                                     page=\"download\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_author_books(page, author_id, order):\n    entries, __, pagination = calibre_db.fill_indexpage(page, 0,\n                                                        db.Books,\n                                                        db.Books.authors.any(db.Authors.id == author_id),\n                                                        [order[0][0], db.Series.name, db.Books.series_index],\n                                                        db.books_series_link,\n                                                        db.Books.id == db.books_series_link.c.book,\n                                                        db.Series)\n    if entries is None or not len(entries):\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n    if constants.sqlalchemy_version2:\n        author = calibre_db.session.get(db.Authors, author_id)\n    else:\n        author = calibre_db.session.query(db.Authors).get(author_id)\n    author_name = author.name.replace('|', ',')\n\n    author_info = None\n    other_books = []\n    if services.goodreads_support and config.config_use_goodreads:\n        author_info = services.goodreads_support.get_author_info(author_name)\n        other_books = services.goodreads_support.get_other_books(author_info, entries)\n\n    return render_title_template('author.html', entries=entries, pagination=pagination, id=author_id,\n                                 title=_(u\"Author: %(name)s\", name=author_name), author=author_info,\n                                 other_books=other_books, page=\"author\", order=order[1])\n\n\ndef render_publisher_books(page, book_id, order):\n    publisher = calibre_db.session.query(db.Publishers).filter(db.Publishers.id == book_id).first()\n    if publisher:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.publishers.any(db.Publishers.id == book_id),\n                                                                [db.Series.name, order[0][0], db.Books.series_index],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Publisher: %(name)s\", name=publisher.name),\n                                     page=\"publisher\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_series_books(page, book_id, order):\n    name = calibre_db.session.query(db.Series).filter(db.Series.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.series.any(db.Series.id == book_id),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Series: %(serie)s\", serie=name.name), page=\"series\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_ratings_books(page, book_id, order):\n    name = calibre_db.session.query(db.Ratings).filter(db.Ratings.id == book_id).first()\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.ratings.any(db.Ratings.id == book_id),\n                                                            [order[0][0]])\n    if name and name.rating <= 10:\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"Rating: %(rating)s stars\", rating=int(name.rating / 2)),\n                                     page=\"ratings\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_formats_books(page, book_id, order):\n    name = calibre_db.session.query(db.Data).filter(db.Data.format == book_id.upper()).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.data.any(db.Data.format == book_id.upper()),\n                                                                [order[0][0]])\n        return render_title_template('index.html', random=random, pagination=pagination, entries=entries, id=book_id,\n                                     title=_(u\"File format: %(format)s\", format=name.format),\n                                     page=\"formats\",\n                                     order=order[1])\n    else:\n        abort(404)\n\n\ndef render_category_books(page, book_id, order):\n    name = calibre_db.session.query(db.Tags).filter(db.Tags.id == book_id).first()\n    if name:\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db.Books.tags.any(db.Tags.id == book_id),\n                                                                [order[0][0], db.Series.name, db.Books.series_index],\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series)\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=book_id,\n                                     title=_(u\"Category: %(name)s\", name=name.name), page=\"category\", order=order[1])\n    else:\n        abort(404)\n\n\ndef render_language_books(page, name, order):\n    try:\n        lang_name = isoLanguages.get_language_name(get_locale(), name)\n    except KeyError:\n        abort(404)\n\n    entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                            db.Books,\n                                                            db.Books.languages.any(db.Languages.lang_code == name),\n                                                            [order[0][0]])\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination, id=name,\n                                 title=_(u\"Language: %(name)s\", name=lang_name), page=\"language\", order=order[1])\n\n\ndef render_read_books(page, are_read, as_xml=False, order=None):\n    sort = order[0] if order else []\n    if not config.config_read_column:\n        if are_read:\n            db_filter = and_(ub.ReadBook.user_id == int(current_user.id),\n                             ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n        else:\n            db_filter = coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED\n        entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                db.Books,\n                                                                db_filter,\n                                                                sort,\n                                                                db.books_series_link,\n                                                                db.Books.id == db.books_series_link.c.book,\n                                                                db.Series,\n                                                                ub.ReadBook, db.Books.id == ub.ReadBook.book_id)\n    else:\n        try:\n            if are_read:\n                db_filter = db.cc_classes[config.config_read_column].value == True\n            else:\n                db_filter = coalesce(db.cc_classes[config.config_read_column].value, False) != True\n            entries, random, pagination = calibre_db.fill_indexpage(page, 0,\n                                                                    db.Books,\n                                                                    db_filter,\n                                                                    sort,\n                                                                    db.books_series_link,\n                                                                    db.Books.id == db.books_series_link.c.book,\n                                                                    db.Series,\n                                                                    db.cc_classes[config.config_read_column])\n        except (KeyError, AttributeError):\n            log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n            if not as_xml:\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return redirect(url_for(\"web.index\"))\n            # ToDo: Handle error Case for opds\n    if as_xml:\n        return entries, pagination\n    else:\n        if are_read:\n            name = _(u'Read Books') + ' (' + str(pagination.total_count) + ')'\n            pagename = \"read\"\n        else:\n            name = _(u'Unread Books') + ' (' + str(pagination.total_count) + ')'\n            pagename = \"unread\"\n        return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                     title=name, page=pagename, order=order[1])\n\n\ndef render_archived_books(page, sort):\n    order = sort[0] or []\n    archived_books = (\n        ub.session.query(ub.ArchivedBook)\n        .filter(ub.ArchivedBook.user_id == int(current_user.id))\n        .filter(ub.ArchivedBook.is_archived == True)\n        .all()\n    )\n    archived_book_ids = [archived_book.book_id for archived_book in archived_books]\n\n    archived_filter = db.Books.id.in_(archived_book_ids)\n\n    entries, random, pagination = calibre_db.fill_indexpage_with_archived_books(page, 0,\n                                                                                db.Books,\n                                                                                archived_filter,\n                                                                                order,\n                                                                                allow_show_archived=True)\n\n    name = _(u'Archived Books') + ' (' + str(len(archived_book_ids)) + ')'\n    pagename = \"archived\"\n    return render_title_template('index.html', random=random, entries=entries, pagination=pagination,\n                                 title=name, page=pagename, order=sort[1])\n\n\ndef render_prepare_search_form(cc):\n    # prepare data for search-form\n    tags = calibre_db.session.query(db.Tags)\\\n        .join(db.books_tags_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_tags_link.tag'))\\\n        .order_by(db.Tags.name).all()\n    series = calibre_db.session.query(db.Series)\\\n        .join(db.books_series_link)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(text('books_series_link.series'))\\\n        .order_by(db.Series.name)\\\n        .filter(calibre_db.common_filters()).all()\n    shelves = ub.session.query(ub.Shelf)\\\n        .filter(or_(ub.Shelf.is_public == 1, ub.Shelf.user_id == int(current_user.id)))\\\n        .order_by(ub.Shelf.name).all()\n    extensions = calibre_db.session.query(db.Data)\\\n        .join(db.Books)\\\n        .filter(calibre_db.common_filters()) \\\n        .group_by(db.Data.format)\\\n        .order_by(db.Data.format).all()\n    if current_user.filter_language() == u\"all\":\n        languages = calibre_db.speaking_language()\n    else:\n        languages = None\n    return render_title_template('search_form.html', tags=tags, languages=languages, extensions=extensions,\n                                 series=series,shelves=shelves, title=_(u\"Advanced Search\"), cc=cc, page=\"advsearch\")\n\n\ndef render_search_results(term, offset=None, order=None, limit=None):\n    join = db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    entries, result_count, pagination = calibre_db.get_search_results(term, offset, order, limit, *join)\n    return render_title_template('search.html',\n                                 searchterm=term,\n                                 pagination=pagination,\n                                 query=term,\n                                 adv_searchterm=term,\n                                 entries=entries,\n                                 result_count=result_count,\n                                 title=_(u\"Search\"),\n                                 page=\"search\",\n                                 order=order[1])\n\n\n# ################################### View Books list ##################################################################\n\n\n@web.route(\"/\", defaults={'page': 1})\n@web.route('/page/<int:page>')\n@login_required_if_no_ano\ndef index(page):\n    sort_param = (request.args.get('sort') or 'stored').lower()\n    return render_books_list(\"newest\", sort_param, 1, page)\n\n\n@web.route('/<data>/<sort_param>', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/', defaults={'page': 1, 'book_id': 1})\n@web.route('/<data>/<sort_param>/<book_id>', defaults={'page': 1})\n@web.route('/<data>/<sort_param>/<book_id>/<int:page>')\n@login_required_if_no_ano\ndef books_list(data, sort_param, book_id, page):\n    return render_books_list(data, sort_param, book_id, page)\n\n\n@web.route(\"/table\")\n@login_required\ndef books_table():\n    visibility = current_user.view_settings.get('table', {})\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_title_template('book_table.html', title=_(u\"Books List\"), cc=cc, page=\"book_table\",\n                                 visiblility=visibility)\n\n@web.route(\"/ajax/listbooks\")\n@login_required\ndef list_books():\n    off = int(request.args.get(\"offset\") or 0)\n    limit = int(request.args.get(\"limit\") or config.config_books_per_page)\n    search = request.args.get(\"search\")\n    sort = request.args.get(\"sort\", \"id\")\n    order = request.args.get(\"order\", \"\").lower()\n    state = None\n    join = tuple()\n\n    if sort == \"state\":\n        state = json.loads(request.args.get(\"state\", \"[]\"))\n    elif sort == \"tags\":\n        order = [db.Tags.name.asc()] if order == \"asc\" else [db.Tags.name.desc()]\n        join = db.books_tags_link,db.Books.id == db.books_tags_link.c.book, db.Tags\n    elif sort == \"series\":\n        order = [db.Series.name.asc()] if order == \"asc\" else [db.Series.name.desc()]\n        join = db.books_series_link,db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort == \"publishers\":\n        order = [db.Publishers.name.asc()] if order == \"asc\" else [db.Publishers.name.desc()]\n        join = db.books_publishers_link,db.Books.id == db.books_publishers_link.c.book, db.Publishers\n    elif sort == \"authors\":\n        order = [db.Authors.name.asc(), db.Series.name, db.Books.series_index] if order == \"asc\" \\\n            else [db.Authors.name.desc(), db.Series.name.desc(), db.Books.series_index.desc()]\n        join = db.books_authors_link, db.Books.id == db.books_authors_link.c.book, db.Authors, \\\n               db.books_series_link, db.Books.id == db.books_series_link.c.book, db.Series\n    elif sort == \"languages\":\n        order = [db.Languages.lang_code.asc()] if order == \"asc\" else [db.Languages.lang_code.desc()]\n        join = db.books_languages_link, db.Books.id == db.books_languages_link.c.book, db.Languages\n    elif order and sort in [\"sort\", \"title\", \"authors_sort\", \"series_index\"]:\n        order = [text(sort + \" \" + order)]\n    elif not state:\n        order = [db.Books.timestamp.desc()]\n\n    total_count = filtered_count = calibre_db.session.query(db.Books).filter(calibre_db.common_filters(False)).count()\n\n    if state is not None:\n        if search:\n            books = calibre_db.search_query(search).all()\n            filtered_count = len(books)\n        else:\n            books = calibre_db.session.query(db.Books).filter(calibre_db.common_filters()).all()\n        entries = calibre_db.get_checkbox_sorted(books, state, off, limit, order)\n    elif search:\n        entries, filtered_count, __ = calibre_db.get_search_results(search, off, [order,''], limit, *join)\n    else:\n        entries, __, __ = calibre_db.fill_indexpage((int(off) / (int(limit)) + 1), limit, db.Books, True, order, *join)\n\n    for entry in entries:\n        for index in range(0, len(entry.languages)):\n            entry.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entry.languages[\n                index].lang_code)\n    table_entries = {'totalNotFiltered': total_count, 'total': filtered_count, \"rows\": entries}\n    js_list = json.dumps(table_entries, cls=db.AlchemyEncoder)\n\n    response = make_response(js_list)\n    response.headers[\"Content-Type\"] = \"application/json; charset=utf-8\"\n    return response\n\n@web.route(\"/ajax/table_settings\", methods=['POST'])\n@login_required\ndef update_table_settings():\n    # vals = request.get_json()\n    # ToDo: Save table settings\n    current_user.view_settings['table'] = json.loads(request.data)\n    try:\n        try:\n            flag_modified(current_user, \"view_settings\")\n        except AttributeError:\n            pass\n        ub.session.commit()\n    except (InvalidRequestError, OperationalError):\n        log.error(\"Invalid request received: %r \", request, )\n        return \"Invalid request\", 400\n    return \"\"\n\n\n@web.route(\"/author\")\n@login_required_if_no_ano\ndef author_list():\n    if current_user.check_visibility(constants.SIDEBAR_AUTHOR):\n        if current_user.get_view_property('author', 'dir') == 'desc':\n            order = db.Authors.sort.desc()\n            order_no = 0\n        else:\n            order = db.Authors.sort.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Authors, func.count('books_authors_link.book').label('count')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_authors_link.author')).order_by(order).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Authors.sort, 1, 1)).label('char')) \\\n            .join(db.books_authors_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Authors.sort, 1, 1))).all()\n        # If not creating a copy, readonly databases can not display authornames with \"|\" in it as changing the name\n        # starts a change session\n        autor_copy = copy.deepcopy(entries)\n        for entry in autor_copy:\n            entry.Authors.name = entry.Authors.name.replace('|', ',')\n        return render_title_template('list.html', entries=autor_copy, folder='web.books_list', charlist=charlist,\n                                     title=u\"Authors\", page=\"authorlist\", data='author', order=order_no)\n    else:\n        abort(404)\n\n@web.route(\"/downloadlist\")\n@login_required_if_no_ano\ndef download_list():\n    if current_user.get_view_property('download', 'dir') == 'desc':\n        order = ub.User.name.desc()\n        order_no = 0\n    else:\n        order = ub.User.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_DOWNLOAD) and current_user.role_admin():\n        entries = ub.session.query(ub.User, func.count(ub.Downloads.book_id).label('count'))\\\n            .join(ub.Downloads).group_by(ub.Downloads.user_id).order_by(order).all()\n        charlist = ub.session.query(func.upper(func.substr(ub.User.name, 1, 1)).label('char')) \\\n            .filter(ub.User.role.op('&')(constants.ROLE_ANONYMOUS) != constants.ROLE_ANONYMOUS) \\\n            .group_by(func.upper(func.substr(ub.User.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Downloads\"), page=\"downloadlist\", data=\"download\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/publisher\")\n@login_required_if_no_ano\ndef publisher_list():\n    if current_user.get_view_property('publisher', 'dir') == 'desc':\n        order = db.Publishers.name.desc()\n        order_no = 0\n    else:\n        order = db.Publishers.name.asc()\n        order_no = 1\n    if current_user.check_visibility(constants.SIDEBAR_PUBLISHER):\n        entries = calibre_db.session.query(db.Publishers, func.count('books_publishers_link.book').label('count')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_publishers_link.publisher')).order_by(order).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Publishers.name, 1, 1)).label('char')) \\\n            .join(db.books_publishers_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Publishers.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Publishers\"), page=\"publisherlist\", data=\"publisher\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/series\")\n@login_required_if_no_ano\ndef series_list():\n    if current_user.check_visibility(constants.SIDEBAR_SERIES):\n        if current_user.get_view_property('series', 'dir') == 'desc':\n            order = db.Series.sort.desc()\n            order_no = 0\n        else:\n            order = db.Series.sort.asc()\n            order_no = 1\n        if current_user.get_view_property('series', 'series_view') == 'list':\n            entries = calibre_db.session.query(db.Series, func.count('books_series_link.book').label('count')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n            return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", order=order_no)\n        else:\n            entries = calibre_db.session.query(db.Books, func.count('books_series_link').label('count'),\n                                               func.max(db.Books.series_index), db.Books.id) \\\n                .join(db.books_series_link).join(db.Series).filter(calibre_db.common_filters())\\\n                .group_by(text('books_series_link.series')).order_by(order).all()\n            charlist = calibre_db.session.query(func.upper(func.substr(db.Series.sort, 1, 1)).label('char')) \\\n                .join(db.books_series_link).join(db.Books).filter(calibre_db.common_filters()) \\\n                .group_by(func.upper(func.substr(db.Series.sort, 1, 1))).all()\n\n            return render_title_template('grid.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                         title=_(u\"Series\"), page=\"serieslist\", data=\"series\", bodyClass=\"grid-view\",\n                                         order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/ratings\")\n@login_required_if_no_ano\ndef ratings_list():\n    if current_user.check_visibility(constants.SIDEBAR_RATING):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Ratings.rating.desc()\n            order_no = 0\n        else:\n            order = db.Ratings.rating.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Ratings, func.count('books_ratings_link.book').label('count'),\n                                   (db.Ratings.rating / 2).label('name')) \\\n            .join(db.books_ratings_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_ratings_link.rating')).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"Ratings list\"), page=\"ratingslist\", data=\"ratings\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/formats\")\n@login_required_if_no_ano\ndef formats_list():\n    if current_user.check_visibility(constants.SIDEBAR_FORMAT):\n        if current_user.get_view_property('ratings', 'dir') == 'desc':\n            order = db.Data.format.desc()\n            order_no = 0\n        else:\n            order = db.Data.format.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Data,\n                                           func.count('data.book').label('count'),\n                                           db.Data.format.label('format')) \\\n            .join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(db.Data.format).order_by(order).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=list(),\n                                     title=_(u\"File formats list\"), page=\"formatslist\", data=\"formats\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/language\")\n@login_required_if_no_ano\ndef language_overview():\n    if current_user.check_visibility(constants.SIDEBAR_LANGUAGE) and current_user.filter_language() == u\"all\":\n        order_no = 0 if current_user.get_view_property('language', 'dir') == 'desc' else 1\n        charlist = list()\n        languages = calibre_db.speaking_language(reverse_order=not order_no, with_count=True)\n        for lang in languages:\n            upper_lang = lang[0].name[0].upper()\n            if upper_lang not in charlist:\n                charlist.append(upper_lang)\n        return render_title_template('languages.html', languages=languages,\n                                     charlist=charlist, title=_(u\"Languages\"), page=\"langlist\",\n                                     data=\"language\", order=order_no)\n    else:\n        abort(404)\n\n\n@web.route(\"/category\")\n@login_required_if_no_ano\ndef category_list():\n    if current_user.check_visibility(constants.SIDEBAR_CATEGORY):\n        if current_user.get_view_property('category', 'dir') == 'desc':\n            order = db.Tags.name.desc()\n            order_no = 0\n        else:\n            order = db.Tags.name.asc()\n            order_no = 1\n        entries = calibre_db.session.query(db.Tags, func.count('books_tags_link.book').label('count')) \\\n            .join(db.books_tags_link).join(db.Books).order_by(order).filter(calibre_db.common_filters()) \\\n            .group_by(text('books_tags_link.tag')).all()\n        charlist = calibre_db.session.query(func.upper(func.substr(db.Tags.name, 1, 1)).label('char')) \\\n            .join(db.books_tags_link).join(db.Books).filter(calibre_db.common_filters()) \\\n            .group_by(func.upper(func.substr(db.Tags.name, 1, 1))).all()\n        return render_title_template('list.html', entries=entries, folder='web.books_list', charlist=charlist,\n                                     title=_(u\"Categories\"), page=\"catlist\", data=\"category\", order=order_no)\n    else:\n        abort(404)\n\n\n# ################################### Task functions ################################################################\n\n\n@web.route(\"/tasks\")\n@login_required\ndef get_tasks_status():\n    # if current user admin, show all email, otherwise only own emails\n    tasks = WorkerThread.getInstance().tasks\n    answer = render_task_status(tasks)\n    return render_title_template('tasks.html', entries=answer, title=_(u\"Tasks\"), page=\"tasks\")\n\n\n# method is available without login and not protected by CSRF to make it easy reachable\n@app.route(\"/reconnect\", methods=['GET'])\ndef reconnect():\n    calibre_db.reconnect_db(config, ub.app_DB_path)\n    return json.dumps({})\n\n\n# ################################### Search functions ################################################################\n\n@web.route(\"/search\", methods=[\"GET\"])\n@login_required_if_no_ano\ndef search():\n    term = request.args.get(\"query\")\n    if term:\n        return redirect(url_for('web.books_list', data=\"search\", sort_param='stored', query=term))\n    else:\n        return render_title_template('search.html',\n                                     searchterm=\"\",\n                                     result_count=0,\n                                     title=_(u\"Search\"),\n                                     page=\"search\")\n\n\n@web.route(\"/advsearch\", methods=['POST'])\n@login_required_if_no_ano\ndef advanced_search():\n    values = dict(request.form)\n    params = ['include_tag', 'exclude_tag', 'include_serie', 'exclude_serie', 'include_shelf', 'exclude_shelf',\n              'include_language', 'exclude_language', 'include_extension', 'exclude_extension']\n    for param in params:\n        values[param] = list(request.form.getlist(param))\n    flask_session['query'] = json.dumps(values)\n    return redirect(url_for('web.books_list', data=\"advsearch\", sort_param='stored', query=\"\"))\n\n\ndef adv_search_custom_columns(cc, term, q):\n    for c in cc:\n        if c.datatype == \"datetime\":\n            custom_start = term.get('custom_column_' + str(c.id) + '_start')\n            custom_end = term.get('custom_column_' + str(c.id) + '_end')\n            if custom_start:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) >= func.datetime(custom_start)))\n            if custom_end:\n                q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                    func.datetime(db.cc_classes[c.id].value) <= func.datetime(custom_end)))\n        else:\n            custom_query = term.get('custom_column_' + str(c.id))\n            if custom_query != '' and custom_query is not None:\n                if c.datatype == 'bool':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == (custom_query == \"True\")))\n                elif c.datatype == 'int' or c.datatype == 'float':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == custom_query))\n                elif c.datatype == 'rating':\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        db.cc_classes[c.id].value == int(float(custom_query) * 2)))\n                else:\n                    q = q.filter(getattr(db.Books, 'custom_column_' + str(c.id)).any(\n                        func.lower(db.cc_classes[c.id].value).ilike(\"%\" + custom_query + \"%\")))\n    return q\n\n\ndef adv_search_language(q, include_languages_inputs, exclude_languages_inputs):\n    if current_user.filter_language() != \"all\":\n        q = q.filter(db.Books.languages.any(db.Languages.lang_code == current_user.filter_language()))\n    else:\n        for language in include_languages_inputs:\n            q = q.filter(db.Books.languages.any(db.Languages.id == language))\n        for language in exclude_languages_inputs:\n            q = q.filter(not_(db.Books.series.any(db.Languages.id == language)))\n    return q\n\n\ndef adv_search_ratings(q, rating_high, rating_low):\n    if rating_high:\n        rating_high = int(rating_high) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating <= rating_high))\n    if rating_low:\n        rating_low = int(rating_low) * 2\n        q = q.filter(db.Books.ratings.any(db.Ratings.rating >= rating_low))\n    return q\n\n\ndef adv_search_read_status(q, read_status):\n    if read_status:\n        if config.config_read_column:\n            try:\n                if read_status == \"True\":\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(db.cc_classes[config.config_read_column].value == True)\n                else:\n                    q = q.join(db.cc_classes[config.config_read_column], isouter=True) \\\n                        .filter(coalesce(db.cc_classes[config.config_read_column].value, False) != True)\n            except (KeyError, AttributeError):\n                log.error(u\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n                flash(_(\"Custom Column No.%(column)d is not existing in calibre database\",\n                        column=config.config_read_column),\n                      category=\"error\")\n                return q\n        else:\n            if read_status == \"True\":\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            ub.ReadBook.read_status == ub.ReadBook.STATUS_FINISHED)\n            else:\n                q = q.join(ub.ReadBook, db.Books.id == ub.ReadBook.book_id, isouter=True) \\\n                    .filter(ub.ReadBook.user_id == int(current_user.id),\n                            coalesce(ub.ReadBook.read_status, 0) != ub.ReadBook.STATUS_FINISHED)\n    return q\n\n\ndef adv_search_extension(q, include_extension_inputs, exclude_extension_inputs):\n    for extension in include_extension_inputs:\n        q = q.filter(db.Books.data.any(db.Data.format == extension))\n    for extension in exclude_extension_inputs:\n        q = q.filter(not_(db.Books.data.any(db.Data.format == extension)))\n    return q\n\n\ndef adv_search_tag(q, include_tag_inputs, exclude_tag_inputs):\n    for tag in include_tag_inputs:\n        q = q.filter(db.Books.tags.any(db.Tags.id == tag))\n    for tag in exclude_tag_inputs:\n        q = q.filter(not_(db.Books.tags.any(db.Tags.id == tag)))\n    return q\n\n\ndef adv_search_serie(q, include_series_inputs, exclude_series_inputs):\n    for serie in include_series_inputs:\n        q = q.filter(db.Books.series.any(db.Series.id == serie))\n    for serie in exclude_series_inputs:\n        q = q.filter(not_(db.Books.series.any(db.Series.id == serie)))\n    return q\n\ndef adv_search_shelf(q, include_shelf_inputs, exclude_shelf_inputs):\n    q = q.outerjoin(ub.BookShelf, db.Books.id == ub.BookShelf.book_id)\\\n        .filter(or_(ub.BookShelf.shelf == None, ub.BookShelf.shelf.notin_(exclude_shelf_inputs)))\n    if len(include_shelf_inputs) > 0:\n        q = q.filter(ub.BookShelf.shelf.in_(include_shelf_inputs))\n    return q\n\ndef extend_search_term(searchterm,\n                       author_name,\n                       book_title,\n                       publisher,\n                       pub_start,\n                       pub_end,\n                       tags,\n                       rating_high,\n                       rating_low,\n                       read_status,\n                       ):\n    searchterm.extend((author_name.replace('|', ','), book_title, publisher))\n    if pub_start:\n        try:\n            searchterm.extend([_(u\"Published after \") +\n                               format_date(datetime.strptime(pub_start, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_start = u\"\"\n    if pub_end:\n        try:\n            searchterm.extend([_(u\"Published before \") +\n                               format_date(datetime.strptime(pub_end, \"%Y-%m-%d\"),\n                                           format='medium', locale=get_locale())])\n        except ValueError:\n            pub_end = u\"\"\n    elements = {'tag': db.Tags, 'serie':db.Series, 'shelf':ub.Shelf}\n    for key, db_element in elements.items():\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['include_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n        tag_names = calibre_db.session.query(db_element).filter(db_element.id.in_(tags['exclude_' + key])).all()\n        searchterm.extend(tag.name for tag in tag_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['include_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    language_names = calibre_db.session.query(db.Languages). \\\n        filter(db.Languages.id.in_(tags['exclude_language'])).all()\n    if language_names:\n        language_names = calibre_db.speaking_language(language_names)\n    searchterm.extend(language.name for language in language_names)\n    if rating_high:\n        searchterm.extend([_(u\"Rating <= %(rating)s\", rating=rating_high)])\n    if rating_low:\n        searchterm.extend([_(u\"Rating >= %(rating)s\", rating=rating_low)])\n    if read_status:\n        searchterm.extend([_(u\"Read Status = %(status)s\", status=read_status)])\n    searchterm.extend(ext for ext in tags['include_extension'])\n    searchterm.extend(ext for ext in tags['exclude_extension'])\n    # handle custom columns\n    searchterm = \" + \".join(filter(None, searchterm))\n    return searchterm, pub_start, pub_end\n\n\ndef render_adv_search_results(term, offset=None, order=None, limit=None):\n    sort = order[0] if order else [db.Books.sort]\n    pagination = None\n\n    cc = get_cc_columns(filter_config_custom_read=True)\n    calibre_db.session.connection().connection.connection.create_function(\"lower\", 1, db.lcase)\n    q = calibre_db.session.query(db.Books).outerjoin(db.books_series_link, db.Books.id == db.books_series_link.c.book)\\\n        .outerjoin(db.Series)\\\n        .filter(calibre_db.common_filters(True))\n\n    # parse multiselects to a complete dict\n    tags = dict()\n    elements = ['tag', 'serie', 'shelf', 'language', 'extension']\n    for element in elements:\n        tags['include_' + element] = term.get('include_' + element)\n        tags['exclude_' + element] = term.get('exclude_' + element)\n\n    author_name = term.get(\"author_name\")\n    book_title = term.get(\"book_title\")\n    publisher = term.get(\"publisher\")\n    pub_start = term.get(\"publishstart\")\n    pub_end = term.get(\"publishend\")\n    rating_low = term.get(\"ratinghigh\")\n    rating_high = term.get(\"ratinglow\")\n    description = term.get(\"comment\")\n    read_status = term.get(\"read_status\")\n    if author_name:\n        author_name = author_name.strip().lower().replace(',', '|')\n    if book_title:\n        book_title = book_title.strip().lower()\n    if publisher:\n        publisher = publisher.strip().lower()\n\n    searchterm = []\n    cc_present = False\n    for c in cc:\n        if c.datatype == \"datetime\":\n            column_start = term.get('custom_column_' + str(c.id) + '_start')\n            column_end = term.get('custom_column_' + str(c.id) + '_end')\n            if column_start:\n                searchterm.extend([u\"{} >= {}\".format(c.name,\n                                                      format_date(datetime.strptime(column_start, \"%Y-%m-%d\").date(),\n                                                                      format='medium',\n                                                                      locale=get_locale())\n                                                      )])\n                cc_present = True\n            if column_end:\n                searchterm.extend([u\"{} <= {}\".format(c.name,\n                                                      format_date(datetime.strptime(column_end, \"%Y-%m-%d\").date(),\n                                                                      format='medium',\n                                                                      locale=get_locale())\n                                                      )])\n                cc_present = True\n        elif term.get('custom_column_' + str(c.id)):\n            searchterm.extend([(u\"{}: {}\".format(c.name, term.get('custom_column_' + str(c.id))))])\n            cc_present = True\n\n\n    if any(tags.values()) or author_name or book_title or publisher or pub_start or pub_end or rating_low \\\n       or rating_high or description or cc_present or read_status:\n        searchterm, pub_start, pub_end = extend_search_term(searchterm,\n                                                            author_name,\n                                                            book_title,\n                                                            publisher,\n                                                            pub_start,\n                                                            pub_end,\n                                                            tags,\n                                                            rating_high,\n                                                            rating_low,\n                                                            read_status)\n        q = q.filter()\n        if author_name:\n            q = q.filter(db.Books.authors.any(func.lower(db.Authors.name).ilike(\"%\" + author_name + \"%\")))\n        if book_title:\n            q = q.filter(func.lower(db.Books.title).ilike(\"%\" + book_title + \"%\"))\n        if pub_start:\n            q = q.filter(func.datetime(db.Books.pubdate) > func.datetime(pub_start))\n        if pub_end:\n            q = q.filter(func.datetime(db.Books.pubdate) < func.datetime(pub_end))\n        q = adv_search_read_status(q, read_status)\n        if publisher:\n            q = q.filter(db.Books.publishers.any(func.lower(db.Publishers.name).ilike(\"%\" + publisher + \"%\")))\n        q = adv_search_tag(q, tags['include_tag'], tags['exclude_tag'])\n        q = adv_search_serie(q, tags['include_serie'], tags['exclude_serie'])\n        q = adv_search_shelf(q, tags['include_shelf'], tags['exclude_shelf'])\n        q = adv_search_extension(q, tags['include_extension'], tags['exclude_extension'])\n        q = adv_search_language(q, tags['include_language'], tags['exclude_language'])\n        q = adv_search_ratings(q, rating_high, rating_low)\n\n        if description:\n            q = q.filter(db.Books.comments.any(func.lower(db.Comments.text).ilike(\"%\" + description + \"%\")))\n\n        # search custom culumns\n        try:\n            q = adv_search_custom_columns(cc, term, q)\n        except AttributeError as ex:\n            log.debug_or_exception(ex)\n            flash(_(\"Error on search for custom columns, please restart Calibre-Web\"), category=\"error\")\n\n    q = q.order_by(*sort).all()\n    flask_session['query'] = json.dumps(term)\n    ub.store_ids(q)\n    result_count = len(q)\n    if offset is not None and limit is not None:\n        offset = int(offset)\n        limit_all = offset + int(limit)\n        pagination = Pagination((offset / (int(limit)) + 1), limit, result_count)\n    else:\n        offset = 0\n        limit_all = result_count\n    return render_title_template('search.html',\n                                 adv_searchterm=searchterm,\n                                 pagination=pagination,\n                                 entries=q[offset:limit_all],\n                                 result_count=result_count,\n                                 title=_(u\"Advanced Search\"), page=\"advsearch\",\n                                 order=order[1])\n\n\n\n@web.route(\"/advsearch\", methods=['GET'])\n@login_required_if_no_ano\ndef advanced_search_form():\n    # Build custom columns names\n    cc = get_cc_columns(filter_config_custom_read=True)\n    return render_prepare_search_form(cc)\n\n\n# ################################### Download/Send ##################################################################\n\n\n@web.route(\"/cover/<int:book_id>\")\n@login_required_if_no_ano\ndef get_cover(book_id):\n    return get_book_cover(book_id)\n\n@web.route(\"/robots.txt\")\ndef get_robots():\n    return send_from_directory(constants.STATIC_DIR, \"robots.txt\")\n\n@web.route(\"/show/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/show/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@viewer_required\ndef serve_book(book_id, book_format, anyname):\n    book_format = book_format.split(\".\")[0]\n    book = calibre_db.get_book(book_id)\n    data = calibre_db.get_book_format(book_id, book_format.upper())\n    if not data:\n        return \"File not in Database\"\n    log.info('Serving book: %s', data.name)\n    if config.config_use_google_drive:\n        try:\n            headers = Headers()\n            headers[\"Content-Type\"] = mimetypes.types_map.get('.' + book_format, \"application/octet-stream\")\n            df = getFileFromEbooksFolder(book.path, data.name + \".\" + book_format)\n            return do_gdrive_download(df, headers, (book_format.upper() == 'TXT'))\n        except AttributeError as ex:\n            log.debug_or_exception(ex)\n            return \"File Not Found\"\n    else:\n        if book_format.upper() == 'TXT':\n            try:\n                rawdata = open(os.path.join(config.config_calibre_dir, book.path, data.name + \".\" + book_format),\n                               \"rb\").read()\n                result = chardet.detect(rawdata)\n                return make_response(\n                    rawdata.decode(result['encoding'], 'surrogatepass').encode('utf-8', 'surrogatepass'))\n            except FileNotFoundError:\n                log.error(\"File Not Found\")\n                return \"File Not Found\"\n        return send_from_directory(os.path.join(config.config_calibre_dir, book.path), data.name + \".\" + book_format)\n\n\n@web.route(\"/download/<int:book_id>/<book_format>\", defaults={'anyname': 'None'})\n@web.route(\"/download/<int:book_id>/<book_format>/<anyname>\")\n@login_required_if_no_ano\n@download_required\ndef download_link(book_id, book_format, anyname):\n    client = \"kobo\" if \"Kobo\" in request.headers.get('User-Agent') else \"\"\n    return get_download_link(book_id, book_format, client)\n\n\n@web.route('/send/<int:book_id>/<book_format>/<int:convert>', methods=[\"POST\"])\n@login_required\n@download_required\ndef send_to_kindle(book_id, book_format, convert):\n    if not config.get_mail_server_configured():\n        flash(_(u\"Please configure the SMTP mail settings first...\"), category=\"error\")\n    elif current_user.kindle_mail:\n        result = send_mail(book_id, book_format, convert, current_user.kindle_mail, config.config_calibre_dir,\n                           current_user.name)\n        if result is None:\n            flash(_(u\"Book successfully queued for sending to %(kindlemail)s\", kindlemail=current_user.kindle_mail),\n                  category=\"success\")\n            ub.update_download(book_id, int(current_user.id))\n        else:\n            flash(_(u\"Oops! There was an error sending this book: %(res)s\", res=result), category=\"error\")\n    else:\n        flash(_(u\"Please update your profile with a valid Send to Kindle E-mail Address.\"), category=\"error\")\n    if \"HTTP_REFERER\" in request.environ:\n        return redirect(request.environ[\"HTTP_REFERER\"])\n    else:\n        return redirect(url_for('web.index'))\n\n\n# ################################### Login Logout ##################################################################\n\n\n@web.route('/register', methods=['GET', 'POST'])\ndef register():\n    if not config.config_public_reg:\n        abort(404)\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if not config.get_mail_server_configured():\n        flash(_(u\"E-Mail server is not configured, please contact your administrator!\"), category=\"error\")\n        return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n    if request.method == \"POST\":\n        to_save = request.form.to_dict()\n        nickname = to_save[\"email\"].strip() if config.config_register_email else to_save.get('name')\n        if not nickname or not to_save.get(\"email\"):\n            flash(_(u\"Please fill out all fields!\"), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        try:\n            nickname = check_username(nickname)\n            email = check_email(to_save[\"email\"])\n        except Exception as ex:\n            flash(str(ex), category=\"error\")\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n\n        content = ub.User()\n        if check_valid_domain(email):\n            content.name = nickname\n            content.email = email\n            password = generate_random_password()\n            content.password = generate_password_hash(password)\n            content.role = config.config_default_role\n            content.sidebar_view = config.config_default_show\n            try:\n                ub.session.add(content)\n                ub.session.commit()\n                if feature_support['oauth']:\n                    register_user_with_oauth(content)\n                send_registration_mail(to_save[\"email\"].strip(), nickname, password)\n            except Exception:\n                ub.session.rollback()\n                flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        else:\n            flash(_(u\"Your e-mail is not allowed to register\"), category=\"error\")\n            log.warning('Registering failed for user \"%s\" e-mail address: %s', nickname, to_save[\"email\"])\n            return render_title_template('register.html', title=_(\"Register\"), page=\"register\")\n        flash(_(u\"Confirmation e-mail was send to your e-mail account.\"), category=\"success\")\n        return redirect(url_for('web.login'))\n\n    if feature_support['oauth']:\n        register_user_with_oauth()\n    return render_title_template('register.html', config=config, title=_(\"Register\"), page=\"register\")\n\n\n@web.route('/login', methods=['GET', 'POST'])\ndef login():\n    if current_user is not None and current_user.is_authenticated:\n        return redirect(url_for('web.index'))\n    if config.config_login_type == constants.LOGIN_LDAP and not services.ldap:\n        log.error(u\"Cannot activate LDAP authentication\")\n        flash(_(u\"Cannot activate LDAP authentication\"), category=\"error\")\n    if request.method == \"POST\":\n        form = request.form.to_dict()\n        user = ub.session.query(ub.User).filter(func.lower(ub.User.name) == form['username'].strip().lower()) \\\n            .first()\n        if config.config_login_type == constants.LOGIN_LDAP and services.ldap and user and form['password'] != \"\":\n            login_result, error = services.ldap.bind_user(form['username'], form['password'])\n            if login_result:\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.debug(u\"You are now logged in as: '%s'\", user.name)\n                flash(_(u\"you are now logged in as: '%(nickname)s'\", nickname=user.name),\n                      category=\"success\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None and user and check_password_hash(str(user.password), form['password']) \\\n                and user.name != \"Guest\":\n                login_user(user, remember=bool(form.get('remember_me')))\n                ub.store_user_session()\n                log.info(\"Local Fallback Login as: '%s'\", user.name)\n                flash(_(u\"Fallback Login as: '%(nickname)s', LDAP Server not reachable, or user not known\",\n                        nickname=user.name),\n                      category=\"warning\")\n                return redirect_back(url_for(\"web.index\"))\n            elif login_result is None:\n                log.info(error)\n                flash(_(u\"Could not login: %(message)s\", message=error), category=\"error\")\n            else:\n                ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n                log.warning('LDAP Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                flash(_(u\"Wrong Username or Password\"), category=\"error\")\n        else:\n            ip_Address = request.headers.get('X-Forwarded-For', request.remote_addr)\n            if 'forgot' in form and form['forgot'] == 'forgot':\n                if user is not None and user.name != \"Guest\":\n                    ret, __ = reset_password(user.id)\n                    if ret == 1:\n                        flash(_(u\"New Password was send to your email address\"), category=\"info\")\n                        log.info('Password reset for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                    else:\n                        log.error(u\"An unknown error occurred. Please try again later\")\n                        flash(_(u\"An unknown error occurred. Please try again later.\"), category=\"error\")\n                else:\n                    flash(_(u\"Please enter valid username to reset password\"), category=\"error\")\n                    log.warning('Username missing for password reset IP-address: %s', ip_Address)\n            else:\n                if user and check_password_hash(str(user.password), form['password']) and user.name != \"Guest\":\n                    login_user(user, remember=bool(form.get('remember_me')))\n                    ub.store_user_session()\n                    log.debug(u\"You are now logged in as: '%s'\", user.name)\n                    flash(_(u\"You are now logged in as: '%(nickname)s'\", nickname=user.name), category=\"success\")\n                    config.config_is_initial = False\n                    return redirect_back(url_for(\"web.index\"))\n                else:\n                    log.warning('Login failed for user \"%s\" IP-address: %s', form['username'], ip_Address)\n                    flash(_(u\"Wrong Username or Password\"), category=\"error\")\n\n    next_url = request.args.get('next', default=url_for(\"web.index\"), type=str)\n    if url_for(\"web.logout\") == next_url:\n        next_url = url_for(\"web.index\")\n    return render_title_template('login.html',\n                                 title=_(u\"Login\"),\n                                 next_url=next_url,\n                                 config=config,\n                                 oauth_check=oauth_check,\n                                 mail=config.get_mail_server_configured(), page=\"login\")\n\n\n@web.route('/logout')\n@login_required\ndef logout():\n    if current_user is not None and current_user.is_authenticated:\n        ub.delete_user_session(current_user.id, flask_session.get('_id',\"\"))\n        logout_user()\n        if feature_support['oauth'] and (config.config_login_type == 2 or config.config_login_type == 3):\n            logout_oauth_user()\n    log.debug(u\"User logged out\")\n    return redirect(url_for('web.login'))\n\n\n# ################################### Users own configuration #########################################################\ndef change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages):\n    to_save = request.form.to_dict()\n    current_user.random_books = 0\n    if current_user.role_passwd() or current_user.role_admin():\n        if to_save.get(\"password\"):\n            current_user.password = generate_password_hash(to_save[\"password\"])\n    try:\n        if to_save.get(\"kindle_mail\", current_user.kindle_mail) != current_user.kindle_mail:\n            current_user.kindle_mail = valid_email(to_save[\"kindle_mail\"])\n        if to_save.get(\"email\", current_user.email) != current_user.email:\n            current_user.email = check_email(to_save[\"email\"])\n        if current_user.role_admin():\n            if to_save.get(\"name\", current_user.name) != current_user.name:\n                # Query User name, if not existing, change\n                current_user.name = check_username(to_save[\"name\"])\n        current_user.random_books = 1 if to_save.get(\"show_random\") == \"on\" else 0\n        if to_save.get(\"default_language\"):\n            current_user.default_language = to_save[\"default_language\"]\n        if to_save.get(\"locale\"):\n            current_user.locale = to_save[\"locale\"]\n        old_state = current_user.kobo_only_shelves_sync\n        # 1 -> 0: nothing has to be done\n        # 0 -> 1: all synced books have to be added to archived books, + currently synced shelfs which\n        # don't have to be synced have to be removed (added to Shelf archive)\n        current_user.kobo_only_shelves_sync = int(to_save.get(\"kobo_only_shelves_sync\") == \"on\") or 0\n        if old_state == 0 and current_user.kobo_only_shelves_sync == 1:\n            kobo_sync_status.update_on_sync_shelfs(current_user.id)\n\n    except Exception as ex:\n        flash(str(ex), category=\"error\")\n        return render_title_template(\"user_edit.html\",\n                                     content=current_user,\n                                     translations=translations,\n                                     profile=1,\n                                     languages=languages,\n                                     title=_(u\"%(name)s's profile\", name=current_user.name),\n                                     page=\"me\",\n                                     kobo_support=kobo_support,\n                                     registered_oauth=local_oauth_check,\n                                     oauth_status=oauth_status)\n\n    val = 0\n    for key, __ in to_save.items():\n        if key.startswith('show'):\n            val += int(key[5:])\n    current_user.sidebar_view = val\n    if to_save.get(\"Show_detail_random\"):\n        current_user.sidebar_view += constants.DETAIL_RANDOM\n\n    try:\n        ub.session.commit()\n        flash(_(u\"Profile updated\"), category=\"success\")\n        log.debug(u\"Profile updated\")\n    except IntegrityError:\n        ub.session.rollback()\n        flash(_(u\"Found an existing account for this e-mail address\"), category=\"error\")\n        log.debug(u\"Found an existing account for this e-mail address\")\n    except OperationalError as e:\n        ub.session.rollback()\n        log.error(\"Database error: %s\", e)\n        flash(_(u\"Database error: %(error)s.\", error=e), category=\"error\")\n\n\n@web.route(\"/me\", methods=[\"GET\", \"POST\"])\n@login_required\ndef profile():\n    languages = calibre_db.speaking_language()\n    translations = babel.list_translations() + [LC('en')]\n    kobo_support = feature_support['kobo'] and config.config_kobo_sync\n    if feature_support['oauth'] and config.config_login_type == 2:\n        oauth_status = get_oauth_status()\n        local_oauth_check = oauth_check\n    else:\n        oauth_status = None\n        local_oauth_check = {}\n\n    if request.method == \"POST\":\n        change_profile(kobo_support, local_oauth_check, oauth_status, translations, languages)\n    return render_title_template(\"user_edit.html\",\n                                 translations=translations,\n                                 profile=1,\n                                 languages=languages,\n                                 content=current_user,\n                                 kobo_support=kobo_support,\n                                 title=_(u\"%(name)s's profile\", name=current_user.name),\n                                 page=\"me\",\n                                 registered_oauth=local_oauth_check,\n                                 oauth_status=oauth_status)\n\n\n# ###################################Show single book ##################################################################\n\n\n@web.route(\"/read/<int:book_id>/<book_format>\")\n@login_required_if_no_ano\n@viewer_required\ndef read_book(book_id, book_format):\n    book = calibre_db.get_filtered_book(book_id)\n    if not book:\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        return redirect(url_for(\"web.index\"))\n\n    # check if book has bookmark\n    bookmark = None\n    if current_user.is_authenticated:\n        bookmark = ub.session.query(ub.Bookmark).filter(and_(ub.Bookmark.user_id == int(current_user.id),\n                                                             ub.Bookmark.book_id == book_id,\n                                                             ub.Bookmark.format == book_format.upper())).first()\n    if book_format.lower() == \"epub\":\n        log.debug(u\"Start epub reader for %d\", book_id)\n        return render_title_template('read.html', bookid=book_id, title=book.title, bookmark=bookmark)\n    elif book_format.lower() == \"pdf\":\n        log.debug(u\"Start pdf reader for %d\", book_id)\n        return render_title_template('readpdf.html', pdffile=book_id, title=book.title)\n    elif book_format.lower() == \"txt\":\n        log.debug(u\"Start txt reader for %d\", book_id)\n        return render_title_template('readtxt.html', txtfile=book_id, title=book.title)\n    elif book_format.lower() == \"djvu\":\n        log.debug(u\"Start djvu reader for %d\", book_id)\n        return render_title_template('readdjvu.html', djvufile=book_id, title=book.title)\n    else:\n        for fileExt in constants.EXTENSIONS_AUDIO:\n            if book_format.lower() == fileExt:\n                entries = calibre_db.get_filtered_book(book_id)\n                log.debug(u\"Start mp3 listening for %d\", book_id)\n                return render_title_template('listenmp3.html', mp3file=book_id, audioformat=book_format.lower(),\n                                             entry=entries, bookmark=bookmark)\n        for fileExt in [\"cbr\", \"cbt\", \"cbz\"]:\n            if book_format.lower() == fileExt:\n                all_name = str(book_id)\n                title = book.title\n                if len(book.series):\n                    title = title + \" - \" + book.series[0].name\n                    if book.series_index:\n                        title = title + \" #\" + '{0:.2f}'.format(book.series_index).rstrip('0').rstrip('.')\n                log.debug(u\"Start comic reader for %d\", book_id)\n                return render_title_template('readcbr.html', comicfile=all_name, title=title,\n                                             extension=fileExt)\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"), category=\"error\")\n        return redirect(url_for(\"web.index\"))\n\n\n@web.route(\"/book/<int:book_id>\")\n@login_required_if_no_ano\ndef show_book(book_id):\n    entries = calibre_db.get_filtered_book(book_id, allow_show_archived=True)\n    if entries:\n        for index in range(0, len(entries.languages)):\n            entries.languages[index].language_name = isoLanguages.get_language_name(get_locale(), entries.languages[\n                index].lang_code)\n        cc = get_cc_columns(filter_config_custom_read=True)\n        book_in_shelfs = []\n        shelfs = ub.session.query(ub.BookShelf).filter(ub.BookShelf.book_id == book_id).all()\n        for entry in shelfs:\n            book_in_shelfs.append(entry.shelf)\n\n        if not current_user.is_anonymous:\n            if not config.config_read_column:\n                matching_have_read_book = ub.session.query(ub.ReadBook). \\\n                    filter(and_(ub.ReadBook.user_id == int(current_user.id), ub.ReadBook.book_id == book_id)).all()\n                have_read = len(\n                    matching_have_read_book) > 0 and matching_have_read_book[0].read_status == ub.ReadBook.STATUS_FINISHED\n            else:\n                try:\n                    matching_have_read_book = getattr(entries, 'custom_column_' + str(config.config_read_column))\n                    have_read = len(matching_have_read_book) > 0 and matching_have_read_book[0].value\n                except (KeyError, AttributeError):\n                    log.error(\"Custom Column No.%d is not existing in calibre database\", config.config_read_column)\n                    have_read = None\n\n            archived_book = ub.session.query(ub.ArchivedBook).\\\n                filter(and_(ub.ArchivedBook.user_id == int(current_user.id),\n                            ub.ArchivedBook.book_id == book_id)).first()\n            is_archived = archived_book and archived_book.is_archived\n\n        else:\n            have_read = None\n            is_archived = None\n\n        entries.tags = sort(entries.tags, key=lambda tag: tag.name)\n\n        entries = calibre_db.order_authors(entries)\n\n        kindle_list = check_send_to_kindle(entries)\n        reader_list = check_read_formats(entries)\n\n        audioentries = []\n        for media_format in entries.data:\n            if media_format.format.lower() in constants.EXTENSIONS_AUDIO:\n                audioentries.append(media_format.format.lower())\n\n        return render_title_template('detail.html',\n                                     entry=entries,\n                                     audioentries=audioentries,\n                                     cc=cc,\n                                     is_xhr=request.headers.get('X-Requested-With')=='XMLHttpRequest',\n                                     title=entries.title,\n                                     books_shelfs=book_in_shelfs,\n                                     have_read=have_read,\n                                     is_archived=is_archived,\n                                     kindle_list=kindle_list,\n                                     reader_list=reader_list,\n                                     page=\"book\")\n    else:\n        log.debug(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\")\n        flash(_(u\"Oops! Selected book title is unavailable. File does not exist or is not accessible\"),\n              category=\"error\")\n        return redirect(url_for(\"web.index\"))\n"], "filenames": ["cps/admin.py", "cps/editbooks.py", "cps/kobo_auth.py", "cps/shelf.py", "cps/static/js/main.js", "cps/templates/shelf.html", "cps/web.py"], "buggy_code_start_loc": [132, 28, 64, 59, 182, 4, 1058], "buggy_code_end_loc": [1806, 1018, 171, 331, 738, 103, 1439], "fixing_code_start_loc": [132, 29, 65, 59, 182, 5, 1058], "fixing_code_end_loc": [1806, 1013, 167, 333, 745, 88, 1440], "type": "CWE-352", "message": "calibre-web is vulnerable to Cross-Site Request Forgery (CSRF)", "other": {"cve": {"id": "CVE-2021-4164", "sourceIdentifier": "security@huntr.dev", "published": "2022-01-17T13:15:08.193", "lastModified": "2022-01-22T03:47:47.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "calibre-web is vulnerable to Cross-Site Request Forgery (CSRF)"}, {"lang": "es", "value": "calibre-web es vulnerable a un ataque de tipo Cross-Site Request Forgery (CSRF)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-web_project:calibre-web:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.6.15", "matchCriteriaId": "3F8C0D67-A1E0-42E6-A31D-5590125DEADB"}]}]}], "references": [{"url": "https://github.com/janeczku/calibre-web/commit/785726deee13b4d56f6c3503dd57c1e3eb7d6f30", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2debace1-a0f3-45c1-95fa-9d0512680758", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/janeczku/calibre-web/commit/785726deee13b4d56f6c3503dd57c1e3eb7d6f30"}}