{"buggy_code": ["import pytest\n\nfrom vyper.exceptions import ArgumentException\n\n_fun_bytes32_bounds = [(0, 32), (3, 29), (27, 5), (0, 5), (5, 3), (30, 2)]\n\n\ndef _generate_bytes(length):\n    return bytes(list(range(length)))\n\n\n# good numbers to try\n_fun_numbers = [0, 1, 5, 31, 32, 33, 64, 99, 100, 101]\n\n\n# [b\"\", b\"\\x01\", b\"\\x02\"...]\n_bytes_examples = [_generate_bytes(i) for i in _fun_numbers if i <= 100]\n\n\ndef test_basic_slice(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef slice_tower_test(inp1: Bytes[50]) -> Bytes[50]:\n    inp: Bytes[50] = inp1\n    for i in range(1, 11):\n        inp = slice(inp, 1, 30 - i * 2)\n    return inp\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    x = c.slice_tower_test(b\"abcdefghijklmnopqrstuvwxyz1234\")\n    assert x == b\"klmnopqrst\", x\n\n\n@pytest.mark.parametrize(\"bytesdata\", _bytes_examples)\n@pytest.mark.parametrize(\"start\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_start\", (True, False))\n@pytest.mark.parametrize(\"length\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_length\", (True, False))\n@pytest.mark.fuzzing\ndef test_slice_immutable(\n    get_contract,\n    assert_compile_failed,\n    assert_tx_failed,\n    bytesdata,\n    start,\n    literal_start,\n    length,\n    literal_length,\n):\n    _start = start if literal_start else \"start\"\n    _length = length if literal_length else \"length\"\n\n    code = f\"\"\"\nIMMUTABLE_BYTES: immutable(Bytes[100])\nIMMUTABLE_SLICE: immutable(Bytes[100])\n\n@external\ndef __init__(inp: Bytes[100], start: uint256, length: uint256):\n    IMMUTABLE_BYTES = inp\n    IMMUTABLE_SLICE = slice(IMMUTABLE_BYTES, {_start}, {_length})\n\n@external\ndef do_splice() -> Bytes[100]:\n    return IMMUTABLE_SLICE\n    \"\"\"\n\n    if (\n        (start + length > 100 and literal_start and literal_length)\n        or (literal_length and length > 100)\n        or (literal_start and start > 100)\n        or (literal_length and length < 1)\n    ):\n        assert_compile_failed(\n            lambda: get_contract(code, bytesdata, start, length), ArgumentException\n        )\n    elif start + length > len(bytesdata):\n        assert_tx_failed(lambda: get_contract(code, bytesdata, start, length))\n    else:\n        c = get_contract(code, bytesdata, start, length)\n        assert c.do_splice() == bytesdata[start : start + length]\n\n\n@pytest.mark.parametrize(\"location\", (\"storage\", \"calldata\", \"memory\", \"literal\", \"code\"))\n@pytest.mark.parametrize(\"bytesdata\", _bytes_examples)\n@pytest.mark.parametrize(\"start\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_start\", (True, False))\n@pytest.mark.parametrize(\"length\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_length\", (True, False))\n@pytest.mark.fuzzing\ndef test_slice_bytes(\n    get_contract,\n    assert_compile_failed,\n    assert_tx_failed,\n    location,\n    bytesdata,\n    start,\n    literal_start,\n    length,\n    literal_length,\n):\n    if location == \"memory\":\n        spliced_code = \"foo: Bytes[100] = inp\"\n        foo = \"foo\"\n    elif location == \"storage\":\n        spliced_code = \"self.foo = inp\"\n        foo = \"self.foo\"\n    elif location == \"code\":\n        spliced_code = \"\"\n        foo = \"IMMUTABLE_BYTES\"\n    elif location == \"literal\":\n        spliced_code = \"\"\n        foo = f\"{bytesdata}\"\n    elif location == \"calldata\":\n        spliced_code = \"\"\n        foo = \"inp\"\n\n    _start = start if literal_start else \"start\"\n    _length = length if literal_length else \"length\"\n\n    code = f\"\"\"\nfoo: Bytes[100]\nIMMUTABLE_BYTES: immutable(Bytes[100])\n@external\ndef __init__(foo: Bytes[100]):\n    IMMUTABLE_BYTES = foo\n\n@external\ndef do_slice(inp: Bytes[100], start: uint256, length: uint256) -> Bytes[100]:\n    {spliced_code}\n    return slice({foo}, {_start}, {_length})\n    \"\"\"\n\n    length_bound = len(bytesdata) if location == \"literal\" else 100\n    if (\n        (start + length > length_bound and literal_start and literal_length)\n        or (literal_length and length > length_bound)\n        or (literal_start and start > length_bound)\n        or (literal_length and length < 1)\n    ):\n        assert_compile_failed(lambda: get_contract(code, bytesdata), ArgumentException)\n    elif start + length > len(bytesdata):\n        c = get_contract(code, bytesdata)\n        assert_tx_failed(lambda: c.do_slice(bytesdata, start, length))\n    else:\n        c = get_contract(code, bytesdata)\n        assert c.do_slice(bytesdata, start, length) == bytesdata[start : start + length], code\n\n\ndef test_slice_private(get_contract):\n    # test there are no buffer overruns in the slice function\n    code = \"\"\"\nbytez: public(String[12])\n\n@internal\ndef _slice(start: uint256, length: uint256):\n    self.bytez = slice(self.bytez, start, length)\n\n@external\ndef foo(x: uint256, y: uint256) -> (uint256, String[12]):\n    self.bytez = \"hello, world\"\n    dont_clobber_me: uint256 = MAX_UINT256\n    self._slice(x, y)\n    return dont_clobber_me, self.bytez\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo(0, 12) == [2 ** 256 - 1, \"hello, world\"]\n    assert c.foo(12, 0) == [2 ** 256 - 1, \"\"]\n    assert c.foo(7, 5) == [2 ** 256 - 1, \"world\"]\n    assert c.foo(0, 5) == [2 ** 256 - 1, \"hello\"]\n    assert c.foo(0, 1) == [2 ** 256 - 1, \"h\"]\n    assert c.foo(11, 1) == [2 ** 256 - 1, \"d\"]\n\n\ndef test_slice_storage_bytes32(get_contract):\n    code = \"\"\"\nbytez: bytes32\n@external\ndef dice() -> Bytes[1]:\n    self.bytez = convert(65, bytes32)\n    c: Bytes[1] = slice(self.bytez, 31, 1)\n    return c\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.dice() == b\"A\"\n\n\ndef test_slice_at_end(get_contract):\n    code = \"\"\"\n@external\ndef ret10_slice() -> Bytes[10]:\n    b: Bytes[32] = concat(convert(65, bytes32), b'')\n    c: Bytes[10] = slice(b, 31, 1)\n    return c\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.ret10_slice() == b\"A\"\n\n\ndef test_slice_expr(get_contract):\n    # test slice of a complex expression\n    code = \"\"\"\n@external\ndef ret10_slice() -> Bytes[10]:\n    return slice(convert(65, bytes32), 31, 1)\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.ret10_slice() == b\"A\"\n\n\ndef test_slice_convert(get_contract):\n    # test slice of converting between bytes32 and Bytes\n    code = \"\"\"\n@external\ndef f() -> bytes32:\n    a: Bytes[100] = convert(\"ab\", Bytes[100])\n    return convert(slice(a, 0, 1), bytes32)\n    \"\"\"\n    c = get_contract(code)\n    assert c.f() == b\"a\" + b\"\\x00\" * 31\n\n\ncode_bytes32 = [\n    \"\"\"\nfoo: bytes32\n\n@external\ndef __init__():\n    self.foo = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n\n@external\ndef bar() -> Bytes[{length}]:\n    return slice(self.foo, {start}, {length})\n    \"\"\",\n    \"\"\"\nfoo: bytes32\n\n@external\ndef __init__():\n    self.foo = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n\n@external\ndef bar() -> Bytes[32]:\n    a: uint256 = {start}\n    b: uint256 = {length}\n    return slice(self.foo, a, b)\n    \"\"\",\n    f\"\"\"\nfoo: Bytes[32]\n\n@external\ndef bar() -> Bytes[32]:\n    self.foo = {_generate_bytes(32)}\n    a: uint256 = {{start}}\n    b: uint256 = {{length}}\n    return slice(convert(self.foo, bytes32), a, b)\n    \"\"\",\n    \"\"\"\n@external\ndef bar() -> Bytes[{length}]:\n    foo: bytes32 = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n    return slice(foo, {start}, {length})\n    \"\"\",\n    \"\"\"\n@external\ndef bar() -> Bytes[32]:\n    b: uint256 = {length}\n    foo: bytes32 = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n    a: uint256 = {start}\n    return slice(foo, a, b)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"code\", code_bytes32)\n@pytest.mark.parametrize(\"start,length\", _fun_bytes32_bounds)\ndef test_slice_bytes32(get_contract, code, start, length):\n\n    c = get_contract(code.format(start=start, length=length))\n    assert c.bar() == _generate_bytes(32)[start : start + length]\n\n\ncode_bytes32_calldata = [\n    \"\"\"\n@external\ndef bar(foo: bytes32) -> Bytes[{length}]:\n    return slice(foo, {start}, {length})\n    \"\"\",\n    \"\"\"\n@external\ndef bar(foo: bytes32) -> Bytes[32]:\n    b: uint256 = {length}\n    a: uint256 = {start}\n    return slice(foo, a, b)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"code\", code_bytes32_calldata)\n@pytest.mark.parametrize(\"start,length\", _fun_bytes32_bounds)\ndef test_slice_bytes32_calldata(get_contract, code, start, length):\n\n    c = get_contract(code.format(start=start, length=length))\n    assert c.bar(_generate_bytes(32)) == _generate_bytes(32)[start : start + length]\n\n\ncode_bytes32_calldata_extended = [\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, 3, 5)\n    \"\"\",\n        \"0304050607\",\n    ),\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, a, b)\n    \"\"\",\n        \"0304050607\",\n    ),\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, 31, b-4)\n    \"\"\",\n        \"31\",\n    ),\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, 0, a+b)\n    \"\"\",\n        \"0001020304050607\",\n    ),\n]\n\n\n@pytest.mark.parametrize(\"code,result\", code_bytes32_calldata_extended)\ndef test_slice_bytes32_calldata_extended(get_contract, code, result):\n\n    c = get_contract(code)\n    assert (\n        c.bar(3, \"0x0001020304050607080910111213141516171819202122232425262728293031\", 5).hex()\n        == result\n    )\n", "import pytest\n\npytestmark = pytest.mark.usefixtures(\"memory_mocker\")\n\n\ndef test_string_return(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef testb() -> String[100]:\n    a: String[100] = \"test return\"\n    return a\n\n@external\ndef testa(inp: String[100]) -> String[100]:\n    return inp\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    assert c.testa(\"meh\") == \"meh\"\n    assert c.testb() == \"test return\"\n\n\ndef test_string_concat(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef testb(inp: String[10]) -> String[128]:\n    a: String[100] = \"return message:\"\n    b: String[128] = concat(a, \" \", inp)\n    return b\n\n@external\ndef testa(inp: String[10]) -> String[160]:\n    a: String[100] = \"<-- return message\"\n    return concat(\"Funny \", inp, \" \", inp, a)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    assert c.testb(\"bob\") == \"return message: bob\"\n    assert c.testa(\"foo\") == \"Funny foo foo<-- return message\"\n\n\ndef test_basic_long_string_as_keys(get_contract, w3):\n    code = \"\"\"\nmapped_string: HashMap[String[34], int128]\n\n@external\ndef set(k: String[34], v: int128):\n    self.mapped_string[k] = v\n\n@external\ndef get(k: String[34]) -> int128:\n    return self.mapped_string[k]\n    \"\"\"\n\n    c = get_contract(code)\n\n    c.set(b\"a\" * 34, 6789, transact={\"gas\": 10 ** 6})\n\n    assert c.get(b\"a\" * 34) == 6789\n\n\ndef test_string_slice(get_contract_with_gas_estimation, assert_tx_failed):\n    test_slice4 = \"\"\"\n@external\ndef foo(inp: String[10], start: uint256, _len: uint256) -> String[10]:\n    return slice(inp, start, _len)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(test_slice4)\n    assert c.foo(\"badminton\", 3, 3) == \"min\"\n    assert c.foo(\"badminton\", 0, 9) == \"badminton\"\n    assert c.foo(\"badminton\", 1, 8) == \"adminton\"\n    assert c.foo(\"badminton\", 1, 7) == \"adminto\"\n    assert c.foo(\"badminton\", 1, 0) == \"\"\n    assert c.foo(\"badminton\", 9, 0) == \"\"\n\n    assert_tx_failed(lambda: c.foo(\"badminton\", 0, 10))\n    assert_tx_failed(lambda: c.foo(\"badminton\", 1, 9))\n    assert_tx_failed(lambda: c.foo(\"badminton\", 9, 1))\n    assert_tx_failed(lambda: c.foo(\"badminton\", 10, 0))\n\n\ndef test_private_string(get_contract_with_gas_estimation):\n    private_test_code = \"\"\"\ngreeting: public(String[100])\n\n@external\ndef __init__():\n    self.greeting = \"Hello \"\n\n@internal\ndef construct(greet: String[100]) -> String[200]:\n    return concat(self.greeting, greet)\n\n@external\ndef hithere(name: String[100]) -> String[200]:\n    d: String[200] = self.construct(name)\n    return d\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(private_test_code)\n    assert c.hithere(\"bob\") == \"Hello bob\"\n    assert c.hithere(\"alice\") == \"Hello alice\"\n\n\ndef test_logging_extended_string(get_contract_with_gas_estimation, get_logs):\n    code = \"\"\"\nevent MyLog:\n    arg1: int128\n    arg2: String[64]\n    arg3: int128\n\n@external\ndef foo():\n    log MyLog(667788, 'hellohellohellohellohellohellohellohellohello', 334455)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    log = get_logs(c.foo(transact={}), c, \"MyLog\")\n\n    assert log[0].args.arg1 == 667788\n    assert log[0].args.arg2 == \"hello\" * 9\n    assert log[0].args.arg3 == 334455\n\n\ndef test_tuple_return_external_contract_call_string(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef out_literals() -> (int128, address, String[10]):\n    return 1, 0x0000000000000000000000000000000000000123, \"random\"\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def out_literals() -> (int128, address, String[10]) : view\n\n@external\ndef test(addr: address) -> (int128, address, String[10]):\n    a: int128 = 0\n    b: address = ZERO_ADDRESS\n    c: String[10] = \"\"\n    (a, b, c) = Test(addr).out_literals()\n    return a, b,c\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == [1, \"0x0000000000000000000000000000000000000123\", \"random\"]\n    assert c2.test(c1.address) == [1, \"0x0000000000000000000000000000000000000123\", \"random\"]\n\n\ndef test_default_arg_string(get_contract_with_gas_estimation):\n\n    code = \"\"\"\n@external\ndef test(a: uint256, b: String[50] = \"foo\") -> Bytes[100]:\n    return concat(\n        convert(a, bytes32),\n        convert(b, Bytes[50])\n    )\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    assert c.test(12345)[-3:] == b\"foo\"\n    assert c.test(12345, \"bar\")[-3:] == b\"bar\"\n\n\ndef test_string_equality(get_contract_with_gas_estimation):\n    code = \"\"\"\n_compA: String[100]\n_compB: String[100]\n\n@external\ndef equal_true() -> bool:\n    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    return compA == compB\n\n@external\ndef equal_false() -> bool:\n    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n    return compA == compB\n\n@external\ndef not_equal_true() -> bool:\n    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n    return compA != compB\n\n@external\ndef not_equal_false() -> bool:\n    compA: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    return compA != compB\n\n@external\ndef literal_equal_true() -> bool:\n    return \"The quick brown fox jumps over the lazy dog\" == \\\n    \"The quick brown fox jumps over the lazy dog\"\n\n@external\ndef literal_equal_false() -> bool:\n    return \"The quick brown fox jumps over the lazy dog\" == \\\n    \"The quick brown fox jumps over the lazy hog\"\n\n@external\ndef literal_not_equal_true() -> bool:\n    return \"The quick brown fox jumps over the lazy dog\" != \\\n    \"The quick brown fox jumps over the lazy hog\"\n\n@external\ndef literal_not_equal_false() -> bool:\n    return \"The quick brown fox jumps over the lazy dog\" != \\\n    \"The quick brown fox jumps over the lazy dog\"\n\n@external\ndef storage_equal_true() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    self._compB = \"The quick brown fox jumps over the lazy dog\"\n    return self._compA == self._compB\n\n@external\ndef storage_equal_false() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    self._compB = \"The quick brown fox jumps over the lazy hog\"\n    return self._compA == self._compB\n\n@external\ndef storage_not_equal_true() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    self._compB = \"The quick brown fox jumps over the lazy hog\"\n    return self._compA != self._compB\n\n@external\ndef storage_not_equal_false() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    self._compB = \"The quick brown fox jumps over the lazy dog\"\n    return self._compA != self._compB\n\n@external\ndef string_compare_equal(str1: String[100], str2: String[100]) -> bool:\n    return str1 == str2\n\n@external\ndef string_compare_not_equal(str1: String[100], str2: String[100]) -> bool:\n    return str1 != str2\n\n@external\ndef compare_passed_storage_equal(str: String[100]) -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    return self._compA == str\n\n@external\ndef compare_passed_storage_not_equal(str: String[100]) -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    return self._compA != str\n\n@external\ndef compare_var_storage_equal_true() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    return self._compA == compB\n\n@external\ndef compare_var_storage_equal_false() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n    return self._compA == compB\n\n@external\ndef compare_var_storage_not_equal_true() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy hog\"\n    return self._compA != compB\n\n@external\ndef compare_var_storage_not_equal_false() -> bool:\n    self._compA = \"The quick brown fox jumps over the lazy dog\"\n    compB: String[100] = \"The quick brown fox jumps over the lazy dog\"\n    return self._compA != compB\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.equal_true() is True\n    assert c.equal_false() is False\n    assert c.not_equal_true() is True\n    assert c.not_equal_false() is False\n    assert c.literal_equal_true() is True\n    assert c.literal_equal_false() is False\n    assert c.literal_not_equal_true() is True\n    assert c.literal_not_equal_false() is False\n    assert c.storage_equal_true() is True\n    assert c.storage_equal_false() is False\n    assert c.storage_not_equal_true() is True\n    assert c.storage_not_equal_false() is False\n\n    a = \"The quick brown fox jumps over the lazy dog\"\n    b = \"The quick brown fox jumps over the lazy hog\"\n    assert c.string_compare_equal(a, a) is True\n    assert c.string_compare_equal(a, b) is False\n    assert c.string_compare_not_equal(b, a) is True\n    assert c.string_compare_not_equal(b, b) is False\n\n    assert c.compare_passed_storage_equal(a) is True\n    assert c.compare_passed_storage_equal(b) is False\n    assert c.compare_passed_storage_not_equal(a) is False\n    assert c.compare_passed_storage_not_equal(b) is True\n\n    assert c.compare_var_storage_equal_true() is True\n    assert c.compare_var_storage_equal_false() is False\n    assert c.compare_var_storage_not_equal_true() is True\n    assert c.compare_var_storage_not_equal_false() is False\n", "from vyper import ast as vy_ast\nfrom vyper.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.codegen.types import (\n    DYNAMIC_ARRAY_OVERHEAD,\n    ArrayLike,\n    BaseType,\n    ByteArrayLike,\n    DArrayType,\n    MappingType,\n    SArrayType,\n    StructType,\n    TupleLike,\n    TupleType,\n    ceil32,\n    is_bytes_m_type,\n    is_decimal_type,\n    is_integer_type,\n)\nfrom vyper.evm.opcodes import version_check\nfrom vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure, TypeMismatch\nfrom vyper.utils import GAS_CALLDATACOPY_WORD, GAS_CODECOPY_WORD, GAS_IDENTITY, GAS_IDENTITYWORD\n\n\n# propagate revert message when calls to external contracts fail\ndef check_external_call(call_ir):\n    copy_revertdata = [\"returndatacopy\", 0, 0, \"returndatasize\"]\n    revert = [\"revert\", 0, \"returndatasize\"]\n\n    propagate_revert_ir = [\"seq\", copy_revertdata, revert]\n    return [\"if\", [\"iszero\", call_ir], propagate_revert_ir]\n\n\n# cost per byte of the identity precompile\ndef _identity_gas_bound(num_bytes):\n    return GAS_IDENTITY + GAS_IDENTITYWORD * (ceil32(num_bytes) // 32)\n\n\ndef _calldatacopy_gas_bound(num_bytes):\n    return GAS_CALLDATACOPY_WORD * ceil32(num_bytes) // 32\n\n\ndef _codecopy_gas_bound(num_bytes):\n    return GAS_CODECOPY_WORD * ceil32(num_bytes) // 32\n\n\n# Copy byte array word-for-word (including layout)\ndef make_byte_array_copier(dst, src):\n    assert isinstance(src.typ, ByteArrayLike)\n    assert isinstance(dst.typ, ByteArrayLike)\n\n    if src.typ.maxlen > dst.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from {src.typ} to {dst.typ}\")\n    # stricter check for zeroing a byte array.\n    if src.value == \"~empty\" and src.typ.maxlen != dst.typ.maxlen:\n        raise TypeMismatch(\n            f\"Bad type for clearing bytes: expected {dst.typ} but got {src.typ}\"\n        )  # pragma: notest\n\n    if src.value == \"~empty\":\n        # set length word to 0.\n        return STORE(dst, 0)\n\n    with src.cache_when_complex(\"src\") as (b1, src):\n        with get_bytearray_length(src).cache_when_complex(\"len\") as (b2, len_):\n\n            max_bytes = src.typ.maxlen\n\n            ret = [\"seq\"]\n            # store length\n            ret.append(STORE(dst, len_))\n\n            dst = bytes_data_ptr(dst)\n            src = bytes_data_ptr(src)\n\n            ret.append(copy_bytes(dst, src, len_, max_bytes))\n            return b1.resolve(b2.resolve(ret))\n\n\ndef bytes_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, ByteArrayLike)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef dynarray_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, DArrayType)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef _dynarray_make_setter(dst, src):\n    assert isinstance(src.typ, DArrayType)\n    assert isinstance(dst.typ, DArrayType)\n\n    if src.value == \"~empty\":\n        return IRnode.from_list(STORE(dst, 0))\n\n    if src.value == \"multi\":\n        ret = [\"seq\"]\n        # handle literals\n\n        # write the length word\n        store_length = STORE(dst, len(src.args))\n        ann = None\n        if src.annotation is not None:\n            ann = f\"len({src.annotation})\"\n        store_length = IRnode.from_list(store_length, annotation=ann)\n        ret.append(store_length)\n\n        n_items = len(src.args)\n        for i in range(n_items):\n            k = IRnode.from_list(i, typ=\"uint256\")\n            dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n            src_i = get_element_ptr(src, k, array_bounds_check=False)\n            ret.append(make_setter(dst_i, src_i))\n\n        return ret\n\n    with src.cache_when_complex(\"darray_src\") as (b1, src):\n\n        # for ABI-encoded dynamic data, we must loop to unpack, since\n        # the layout does not match our memory layout\n        should_loop = (\n            src.encoding in (Encoding.ABI, Encoding.JSON_ABI)\n            and src.typ.subtype.abi_type.is_dynamic()\n        )\n\n        # if the subtype is dynamic, there might be a lot of\n        # unused space inside of each element. for instance\n        # DynArray[DynArray[uint256, 100], 5] where all the child\n        # arrays are empty - for this case, we recursively call\n        # into make_setter instead of straight bytes copy\n        # TODO we can make this heuristic more precise, e.g.\n        # loop when subtype.is_dynamic AND location == storage\n        # OR array_size <= /bound where loop is cheaper than memcpy/\n        should_loop |= src.typ.subtype.abi_type.is_dynamic()\n        should_loop |= needs_clamp(src.typ.subtype, src.encoding)\n\n        with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n            ret = [\"seq\"]\n\n            ret.append(STORE(dst, count))\n\n            if should_loop:\n                i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=\"uint256\")\n\n                loop_body = make_setter(\n                    get_element_ptr(dst, i, array_bounds_check=False),\n                    get_element_ptr(src, i, array_bounds_check=False),\n                )\n                loop_body.annotation = f\"{dst}[i] = {src}[i]\"\n\n                ret.append([\"repeat\", i, 0, count, src.typ.count, loop_body])\n\n            else:\n                element_size = src.typ.subtype.memory_bytes_required\n                # number of elements * size of element in bytes\n                n_bytes = _mul(count, element_size)\n                max_bytes = src.typ.count * element_size\n\n                src_ = dynarray_data_ptr(src)\n                dst_ = dynarray_data_ptr(dst)\n                ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n\n            return b1.resolve(b2.resolve(ret))\n\n\n# Copy bytes\n# Accepts 4 arguments:\n# (i) an IR node for the start position of the source\n# (ii) an IR node for the start position of the destination\n# (iii) an IR node for the length (in bytes)\n# (iv) a constant for the max length (in bytes)\n# NOTE: may pad to ceil32 of `length`! If you ask to copy 1 byte, it may\n# copy an entire (32-byte) word, depending on the copy routine chosen.\n# TODO maybe always pad to ceil32, to reduce dirty bytes bugs\ndef copy_bytes(dst, src, length, length_bound):\n    annotation = f\"copy_bytes from {src} to {dst}\"\n\n    src = IRnode.from_list(src)\n    dst = IRnode.from_list(dst)\n    length = IRnode.from_list(length)\n\n    with src.cache_when_complex(\"src\") as (b1, src), length.cache_when_complex(\n        \"copy_bytes_count\"\n    ) as (b2, length,), dst.cache_when_complex(\"dst\") as (b3, dst):\n\n        # fast code for common case where num bytes is small\n        # TODO expand this for more cases where num words is less than ~8\n        if length_bound <= 32:\n            copy_op = STORE(dst, LOAD(src))\n            ret = IRnode.from_list(copy_op, annotation=annotation)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == MEMORY and src.location in (MEMORY, CALLDATA, DATA):\n            # special cases: batch copy to memory\n            # TODO: iloadbytes\n            if src.location == MEMORY:\n                copy_op = [\"staticcall\", \"gas\", 4, src, length, dst, length]\n                gas_bound = _identity_gas_bound(length_bound)\n            elif src.location == CALLDATA:\n                copy_op = [\"calldatacopy\", dst, src, length]\n                gas_bound = _calldatacopy_gas_bound(length_bound)\n            elif src.location == DATA:\n                copy_op = [\"dloadbytes\", dst, src, length]\n                # note: dloadbytes compiles to CODECOPY\n                gas_bound = _codecopy_gas_bound(length_bound)\n\n            ret = IRnode.from_list(copy_op, annotation=annotation, add_gas_estimate=gas_bound)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == IMMUTABLES and src.location in (MEMORY, DATA):\n            # TODO istorebytes-from-mem, istorebytes-from-calldata(?)\n            # compile to identity, CODECOPY respectively.\n            pass\n\n        # general case, copy word-for-word\n        # pseudocode for our approach (memory-storage as example):\n        # for i in range(len, bound=MAX_LEN):\n        #   sstore(_dst + i, mload(src + i * 32))\n        i = IRnode.from_list(_freshname(\"copy_bytes_ix\"), typ=\"uint256\")\n\n        n = [\"div\", [\"ceil32\", length], 32]\n        n_bound = ceil32(length_bound) // 32\n\n        dst_i = add_ofst(dst, _mul(i, dst.location.word_scale))\n        src_i = add_ofst(src, _mul(i, src.location.word_scale))\n\n        copy_one_word = STORE(dst_i, LOAD(src_i))\n\n        main_loop = [\"repeat\", i, 0, n, n_bound, copy_one_word]\n\n        return b1.resolve(\n            b2.resolve(b3.resolve(IRnode.from_list(main_loop, annotation=annotation)))\n        )\n\n\n# get the number of bytes at runtime\ndef get_bytearray_length(arg):\n    typ = BaseType(\"uint256\")\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\n# get the number of elements at runtime\ndef get_dyn_array_count(arg):\n    assert isinstance(arg.typ, DArrayType)\n\n    typ = BaseType(\"uint256\")\n\n    if arg.value == \"multi\":\n        return IRnode.from_list(len(arg.args), typ=typ)\n\n    if arg.value == \"~empty\":\n        # empty(DynArray[])\n        return IRnode.from_list(0, typ=typ)\n\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\ndef append_dyn_array(darray_node, elem_node):\n    assert isinstance(darray_node.typ, DArrayType)\n\n    assert darray_node.typ.count > 0, \"jerk boy u r out\"\n\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        len_ = get_dyn_array_count(darray_node)\n        with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n            ret.append([\"assert\", [\"le\", len_, darray_node.typ.count - 1]])\n            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n            # NOTE: typechecks elem_node\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            ret.append(\n                make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n            )\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)))\n\n\ndef pop_dyn_array(darray_node, return_popped_item):\n    assert isinstance(darray_node.typ, DArrayType)\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        old_len = [\"clamp_nonzero\", get_dyn_array_count(darray_node)]\n        new_len = IRnode.from_list([\"sub\", old_len, 1], typ=\"uint256\")\n\n        with new_len.cache_when_complex(\"new_len\") as (b2, new_len):\n            ret.append(STORE(darray_node, new_len))\n\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            if return_popped_item:\n                popped_item = get_element_ptr(darray_node, new_len, array_bounds_check=False)\n                ret.append(popped_item)\n                typ = popped_item.typ\n                location = popped_item.location\n                encoding = popped_item.encoding\n            else:\n                typ, location, encoding = None, None, None\n            return IRnode.from_list(\n                b1.resolve(b2.resolve(ret)), typ=typ, location=location, encoding=encoding\n            )\n\n\ndef getpos(node):\n    return (\n        node.lineno,\n        node.col_offset,\n        getattr(node, \"end_lineno\", None),\n        getattr(node, \"end_col_offset\", None),\n    )\n\n\n# TODO since this is always(?) used as add_ofst(ptr, n*ptr.location.word_scale)\n# maybe the API should be `add_words_to_ofst(ptr, n)` and handle the\n# word_scale multiplication inside\ndef add_ofst(ptr, ofst):\n    ofst = IRnode.from_list(ofst)\n    if isinstance(ptr.value, int) and isinstance(ofst.value, int):\n        # NOTE: duplicate with optimizer rule (but removing this makes a\n        # test on --no-optimize mode use too much gas)\n        ret = ptr.value + ofst.value\n    else:\n        ret = [\"add\", ptr, ofst]\n    return IRnode.from_list(ret, location=ptr.location, encoding=ptr.encoding)\n\n\n# shorthand util\ndef _mul(x, y):\n    x, y = IRnode.from_list(x), IRnode.from_list(y)\n    # NOTE: similar deal: duplicate with optimizer rule\n    if isinstance(x.value, int) and isinstance(y.value, int):\n        ret = x.value * y.value\n    else:\n        ret = [\"mul\", x, y]\n    return IRnode.from_list(ret)\n\n\n# Resolve pointer locations for ABI-encoded data\ndef _getelemptr_abi_helper(parent, member_t, ofst, clamp=True):\n    member_abi_t = member_t.abi_type\n\n    # ABI encoding has length word and then pretends length is not there\n    # e.g. [[1,2]] is encoded as 0x01 <len> 0x20 <inner array ofst> <encode(inner array)>\n    # note that inner array ofst is 0x20, not 0x40.\n    if has_length_word(parent.typ):\n        parent = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n\n    ofst_ir = add_ofst(parent, ofst)\n\n    if member_abi_t.is_dynamic():\n        # double dereference, according to ABI spec\n        # TODO optimize special case: first dynamic item\n        # offset is statically known.\n        ofst_ir = add_ofst(parent, unwrap_location(ofst_ir))\n\n    return IRnode.from_list(\n        ofst_ir,\n        typ=member_t,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=f\"{parent}{ofst}\",\n    )\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_tuplelike(parent, key):\n    typ = parent.typ\n    assert isinstance(typ, TupleLike)\n\n    if isinstance(typ, StructType):\n        assert isinstance(key, str)\n        subtype = typ.members[key]\n        attrs = list(typ.tuple_keys())\n        index = attrs.index(key)\n        annotation = key\n    else:\n        assert isinstance(key, int)\n        subtype = typ.members[key]\n        attrs = list(range(len(typ.members)))\n        index = key\n        annotation = None\n\n    # generated by empty() + make_setter\n    if parent.value == \"~empty\":\n        return IRnode.from_list(\"~empty\", typ=subtype)\n\n    if parent.value == \"multi\":\n        assert parent.encoding != Encoding.ABI, \"no abi-encoded literals\"\n        return parent.args[index]\n\n    ofst = 0  # offset from parent start\n\n    if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_t = typ.members[attrs[index]]\n\n        for i in range(index):\n            member_abi_t = typ.members[attrs[i]].abi_type\n            ofst += member_abi_t.embedded_static_size()\n\n        return _getelemptr_abi_helper(parent, member_t, ofst)\n\n    if parent.location.word_addressable:\n        for i in range(index):\n            ofst += typ.members[attrs[i]].storage_size_in_words\n    elif parent.location.byte_addressable:\n        for i in range(index):\n            ofst += typ.members[attrs[i]].memory_bytes_required\n    else:\n        raise CompilerPanic(f\"bad location {parent.location}\")  # pragma: notest\n\n    return IRnode.from_list(\n        add_ofst(parent, ofst),\n        typ=subtype,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=annotation,\n    )\n\n\ndef has_length_word(typ):\n    return isinstance(typ, (DArrayType, ByteArrayLike))\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_array(parent, key, array_bounds_check):\n\n    assert isinstance(parent.typ, ArrayLike)\n\n    if not is_integer_type(key.typ):\n        raise TypeCheckFailure(f\"{key.typ} used as array index\")\n\n    subtype = parent.typ.subtype\n\n    if parent.value == \"~empty\":\n        if array_bounds_check:\n            # this case was previously missing a bounds check. codegen\n            # is a bit complicated when bounds check is required, so\n            # block it. there is no reason to index into a literal empty\n            # array anyways!\n            raise TypeCheckFailure(\"indexing into zero array not allowed\")\n        return IRnode.from_list(\"~empty\", subtype)\n\n    if parent.value == \"multi\":\n        assert isinstance(key.value, int)\n        return parent.args[key.value]\n\n    ix = unwrap_location(key)\n\n    if array_bounds_check:\n        # clamplt works, even for signed ints. since two's-complement\n        # is used, if the index is negative, (unsigned) LT will interpret\n        # it as a very large number, larger than any practical value for\n        # an array index, and the clamp will throw an error.\n        clamp_op = \"uclamplt\"\n        is_darray = isinstance(parent.typ, DArrayType)\n        bound = get_dyn_array_count(parent) if is_darray else parent.typ.count\n        # NOTE: there are optimization rules for this when ix or bound is literal\n        ix = IRnode.from_list([clamp_op, ix, bound], typ=ix.typ)\n\n    if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_abi_t = subtype.abi_type\n\n        ofst = _mul(ix, member_abi_t.embedded_static_size())\n\n        return _getelemptr_abi_helper(parent, subtype, ofst)\n\n    if parent.location.word_addressable:\n        element_size = subtype.storage_size_in_words\n    elif parent.location.byte_addressable:\n        element_size = subtype.memory_bytes_required\n    else:\n        raise CompilerPanic(\"unreachable\")  # pragma: notest\n\n    ofst = _mul(ix, element_size)\n\n    if has_length_word(parent.typ):\n        data_ptr = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n    else:\n        data_ptr = parent\n\n    return IRnode.from_list(add_ofst(data_ptr, ofst), typ=subtype, location=parent.location)\n\n\ndef _get_element_ptr_mapping(parent, key):\n    assert isinstance(parent.typ, MappingType)\n    subtype = parent.typ.valuetype\n    key = unwrap_location(key)\n\n    # TODO when is key None?\n    if key is None or parent.location != STORAGE:\n        raise TypeCheckFailure(\"bad dereference on mapping {parent}[{sub}]\")\n\n    return IRnode.from_list([\"sha3_64\", parent, key], typ=subtype, location=STORAGE)\n\n\n# Take a value representing a memory or storage location, and descend down to\n# an element or member variable\n# This is analogous (but not necessarily equivalent to) getelementptr in LLVM.\ndef get_element_ptr(parent, key, array_bounds_check=True):\n    with parent.cache_when_complex(\"val\") as (b, parent):\n        typ = parent.typ\n\n        if isinstance(typ, TupleLike):\n            ret = _get_element_ptr_tuplelike(parent, key)\n\n        elif isinstance(typ, MappingType):\n            ret = _get_element_ptr_mapping(parent, key)\n\n        elif isinstance(typ, ArrayLike):\n            ret = _get_element_ptr_array(parent, key, array_bounds_check)\n\n        else:\n            raise CompilerPanic(f\"get_element_ptr cannot be called on {typ}\")  # pragma: notest\n\n        return b.resolve(ret)\n\n\ndef LOAD(ptr: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.load_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n    return IRnode.from_list([op, ptr])\n\n\ndef STORE(ptr: IRnode, val: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.store_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n    return IRnode.from_list([op, ptr, val])\n\n\n# Unwrap location\ndef unwrap_location(orig):\n    if orig.location is not None:\n        return IRnode.from_list(LOAD(orig), typ=orig.typ)\n    else:\n        # CMC 2022-03-24 TODO refactor so this branch can be removed\n        if orig.value == \"~empty\":\n            return IRnode.from_list(0, typ=orig.typ)\n        return orig\n\n\n# utility function, constructs an IR tuple out of a list of IR nodes\ndef ir_tuple_from_args(args):\n    typ = TupleType([x.typ for x in args])\n    return IRnode.from_list([\"multi\"] + [x for x in args], typ=typ)\n\n\ndef _needs_external_call_wrap(ir_typ):\n    # for calls to ABI conforming contracts.\n    # according to the ABI spec, return types are ALWAYS tuples even\n    # if only one element is being returned.\n    # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding\n    # \"and the return values v_1, ..., v_k of f are encoded as\n    #\n    #    enc((v_1, ..., v_k))\n    #    i.e. the values are combined into a tuple and encoded.\n    # \"\n    # therefore, wrap it in a tuple if it's not already a tuple.\n    # for example, `bytes` is returned as abi-encoded (bytes,)\n    # and `(bytes,)` is returned as abi-encoded ((bytes,),)\n    # In general `-> X` gets returned as (X,)\n    # including structs. MyStruct is returned as abi-encoded (MyStruct,).\n    # (Sorry this is so confusing. I didn't make these rules.)\n\n    return not (isinstance(ir_typ, TupleType) and len(ir_typ.members) > 1)\n\n\ndef calculate_type_for_external_return(ir_typ):\n    if _needs_external_call_wrap(ir_typ):\n        return TupleType([ir_typ])\n    return ir_typ\n\n\ndef wrap_value_for_external_return(ir_val):\n    # used for LHS promotion\n    if _needs_external_call_wrap(ir_val.typ):\n        return ir_tuple_from_args([ir_val])\n    else:\n        return ir_val\n\n\ndef set_type_for_external_return(ir_val):\n    # used for RHS promotion\n    ir_val.typ = calculate_type_for_external_return(ir_val.typ)\n\n\n# return a dummy IRnode with the given type\ndef dummy_node_for_type(typ):\n    return IRnode(\"fake_node\", typ=typ)\n\n\ndef _check_assign_bytes(left, right):\n    if right.typ.maxlen > left.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from {right.typ} to {left.typ}\")  # pragma: notest\n    # stricter check for zeroing a byte array.\n    if right.value == \"~empty\" and right.typ.maxlen != left.typ.maxlen:\n        raise TypeMismatch(\n            f\"Bad type for clearing bytes: expected {left.typ} but got {right.typ}\"\n        )  # pragma: notest\n\n\ndef _check_assign_list(left, right):\n    def FAIL():  # pragma: nocover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if left.value == \"multi\":\n        # Cannot do something like [a, b, c] = [1, 2, 3]\n        FAIL()  # pragma: notest\n\n    if isinstance(left, SArrayType):\n        if not isinstance(right, SArrayType):\n            FAIL()  # pragma: notest\n        if left.typ.count != right.typ.count:\n            FAIL()  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(dummy_node_for_type(left.typ.subtyp), dummy_node_for_type(right.typ.subtyp))\n\n    if isinstance(left, DArrayType):\n        if not isinstance(right, DArrayType):\n            FAIL()  # pragma: notest\n\n        if left.typ.count < right.typ.count:\n            FAIL()  # pragma: notest\n\n        # stricter check for zeroing\n        if right.value == \"~empty\" and right.typ.count != left.typ.count:\n            raise TypeCheckFailure(\n                f\"Bad type for clearing bytes: expected {left.typ} but got {right.typ}\"\n            )  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(dummy_node_for_type(left.typ.subtyp), dummy_node_for_type(right.typ.subtyp))\n\n\ndef _check_assign_tuple(left, right):\n    def FAIL():  # pragma: nocover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if not isinstance(right.typ, left.typ.__class__):\n        FAIL()  # pragma: notest\n\n    if isinstance(left.typ, StructType):\n        for k in left.typ.members:\n            if k not in right.typ.members:\n                FAIL()  # pragma: notest\n            # TODO recurse into left, right if literals?\n            check_assign(\n                dummy_node_for_type(left.typ.members[k]),\n                dummy_node_for_type(right.typ.members[k]),\n            )\n\n        for k in right.typ.members:\n            if k not in left.typ.members:\n                FAIL()  # pragma: notest\n\n        if left.typ.name != right.typ.name:\n            FAIL()  # pragma: notest\n\n    else:\n        if len(left.typ.members) != len(right.typ.members):\n            FAIL()  # pragma: notest\n        for (l, r) in zip(left.typ.members, right.typ.members):\n            # TODO recurse into left, right if literals?\n            check_assign(dummy_node_for_type(l), dummy_node_for_type(r))\n\n\n# sanity check an assignment\n# typechecking source code is done at an earlier phase\n# this function is more of a sanity check for typechecking internally\n# generated assignments\ndef check_assign(left, right):\n    def FAIL():  # pragma: nocover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ} {left} {right}\")\n\n    if isinstance(left.typ, ByteArrayLike):\n        _check_assign_bytes(left, right)\n    elif isinstance(left.typ, ArrayLike):\n        _check_assign_list(left, right)\n    elif isinstance(left.typ, TupleLike):\n        _check_assign_tuple(left, right)\n\n    elif isinstance(left.typ, BaseType):\n        # TODO once we propagate types from typechecker, introduce this check:\n        # if left.typ != right.typ:\n        #    FAIL()  # pragma: notest\n        pass\n\n    else:  # pragma: nocover\n        FAIL()\n\n\n_label = 0\n\n\n# TODO might want to coalesce with Context.fresh_varname and compile_ir.mksymbol\ndef _freshname(name):\n    global _label\n    _label += 1\n    return f\"{name}{_label}\"\n\n\n# returns True if t is ABI encoded and is a type that needs any kind of\n# validation\ndef needs_clamp(t, encoding):\n    if encoding not in (Encoding.ABI, Encoding.JSON_ABI):\n        return False\n    if isinstance(t, (ByteArrayLike, DArrayType)):\n        if encoding == Encoding.JSON_ABI:\n            # don't have bytestring size bound from json, don't clamp\n            return False\n        return True\n    if isinstance(t, BaseType) and t.typ not in (\"int256\", \"uint256\", \"bytes32\"):\n        return True\n    if isinstance(t, SArrayType):\n        return needs_clamp(t.subtype, encoding)\n    if isinstance(t, TupleLike):\n        return any(needs_clamp(m, encoding) for m in t.tuple_members())\n    return False\n\n\n# Create an x=y statement, where the types may be compound\ndef make_setter(left, right):\n    check_assign(left, right)\n\n    # Basic types\n    if isinstance(left.typ, BaseType):\n        enc = right.encoding  # unwrap_location butchers encoding\n        right = unwrap_location(right)\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, enc):\n            right = clamp_basetype(right)\n\n        return STORE(left, right)\n\n    # Byte arrays\n    elif isinstance(left.typ, ByteArrayLike):\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"bs_ptr\") as (b, right):\n                copier = make_byte_array_copier(left, right)\n                ret = b.resolve([\"seq\", clamp_bytestring(right), copier])\n        else:\n            ret = make_byte_array_copier(left, right)\n\n        return IRnode.from_list(ret)\n\n    elif isinstance(left.typ, DArrayType):\n        # TODO should we enable this?\n        # implicit conversion from sarray to darray\n        # if isinstance(right.typ, SArrayType):\n        #    return _complex_make_setter(left, right)\n\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"arr_ptr\") as (b, right):\n                copier = _dynarray_make_setter(left, right)\n                ret = b.resolve([\"seq\", clamp_dyn_array(right), copier])\n        else:\n            ret = _dynarray_make_setter(left, right)\n\n        return IRnode.from_list(ret)\n\n    # Arrays\n    elif isinstance(left.typ, (SArrayType, TupleLike)):\n        return _complex_make_setter(left, right)\n\n\ndef _complex_make_setter(left, right):\n    if right.value == \"~empty\" and left.location == MEMORY:\n        # optimized memzero\n        return mzero(left, left.typ.memory_bytes_required)\n\n    ret = [\"seq\"]\n\n    if isinstance(left.typ, SArrayType):\n        n_items = right.typ.count\n        keys = [IRnode.from_list(i, typ=\"uint256\") for i in range(n_items)]\n\n    if isinstance(left.typ, TupleLike):\n        keys = left.typ.tuple_keys()\n\n    # if len(keyz) == 0:\n    #    return IRnode.from_list([\"pass\"])\n\n    # general case\n    # TODO use copy_bytes when the generated code is above a certain size\n    with left.cache_when_complex(\"_L\") as (b1, left), right.cache_when_complex(\"_R\") as (b2, right):\n\n        for k in keys:\n            l_i = get_element_ptr(left, k, array_bounds_check=False)\n            r_i = get_element_ptr(right, k, array_bounds_check=False)\n            ret.append(make_setter(l_i, r_i))\n\n        return b1.resolve(b2.resolve(IRnode.from_list(ret)))\n\n\ndef ensure_in_memory(ir_var, context):\n    \"\"\"Ensure a variable is in memory. This is useful for functions\n    which expect to operate on memory variables.\n    \"\"\"\n    if ir_var.location == MEMORY:\n        return ir_var\n\n    typ = ir_var.typ\n    buf = IRnode.from_list(context.new_internal_variable(typ), typ=typ, location=MEMORY)\n    do_copy = make_setter(buf, ir_var)\n\n    return IRnode.from_list([\"seq\", do_copy, buf], typ=typ, location=MEMORY)\n\n\ndef eval_seq(ir_node):\n    \"\"\"Tries to find the \"return\" value of a `seq` statement, in order so\n    that the value can be known without possibly evaluating side effects\n    \"\"\"\n    if ir_node.value in (\"seq\", \"with\") and len(ir_node.args) > 0:\n        return eval_seq(ir_node.args[-1])\n    if isinstance(ir_node.value, int):\n        return IRnode.from_list(ir_node)\n    return None\n\n\n# TODO move return checks to vyper/semantics/validation\ndef is_return_from_function(node):\n    if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") == \"selfdestruct\":\n        return True\n    if isinstance(node, vy_ast.Return):\n        return True\n    elif isinstance(node, vy_ast.Raise):\n        return True\n    else:\n        return False\n\n\ndef check_single_exit(fn_node):\n    _check_return_body(fn_node, fn_node.body)\n    for node in fn_node.get_descendants(vy_ast.If):\n        _check_return_body(node, node.body)\n        if node.orelse:\n            _check_return_body(node, node.orelse)\n\n\ndef _check_return_body(node, node_list):\n    return_count = len([n for n in node_list if is_return_from_function(n)])\n    if return_count > 1:\n        raise StructureException(\n            \"Too too many exit statements (return, raise or selfdestruct).\", node\n        )\n    # Check for invalid code after returns.\n    last_node_pos = len(node_list) - 1\n    for idx, n in enumerate(node_list):\n        if is_return_from_function(n) and idx < last_node_pos:\n            # is not last statement in body.\n            raise StructureException(\n                \"Exit statement with succeeding code (that will not execute).\", node_list[idx + 1]\n            )\n\n\ndef mzero(dst, nbytes):\n    # calldatacopy from past-the-end gives zero bytes.\n    # cf. YP H.2 (ops section) with CALLDATACOPY spec.\n    return IRnode.from_list(\n        # calldatacopy mempos calldatapos len\n        [\"calldatacopy\", dst, \"calldatasize\", nbytes],\n        annotation=\"mzero\",\n    )\n\n\n# zero pad a bytearray according to the ABI spec. The last word\n# of the byte array needs to be right-padded with zeroes.\ndef zero_pad(bytez_placeholder):\n    len_ = [\"mload\", bytez_placeholder]\n    dst = [\"add\", [\"add\", bytez_placeholder, 32], \"len\"]\n    # the runtime length of the data rounded up to nearest 32\n    # from spec:\n    #   the actual value of X as a byte sequence,\n    #   followed by the *minimum* number of zero-bytes\n    #   such that len(enc(X)) is a multiple of 32.\n    num_zero_bytes = [\"sub\", [\"ceil32\", \"len\"], \"len\"]\n    return IRnode.from_list(\n        [\"with\", \"len\", len_, [\"with\", \"dst\", dst, mzero(\"dst\", num_zero_bytes)]],\n        annotation=\"Zero pad\",\n    )\n\n\n# convenience rewrites for shr/sar/shl\ndef shr(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shr\", bits, x]\n    return [\"div\", x, [\"exp\", 2, bits]]\n\n\n# convenience rewrites for shr/sar/shl\ndef shl(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shl\", bits, x]\n    return [\"mul\", x, [\"exp\", 2, bits]]\n\n\ndef sar(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"sar\", bits, x]\n\n    # emulate for older arches. keep in mind note from EIP 145:\n    # \"This is not equivalent to PUSH1 2 EXP SDIV, since it rounds\n    # differently. See SDIV(-1, 2) == 0, while SAR(-1, 1) == -1.\"\n    return [\"sdiv\", [\"add\", [\"slt\", x, 0], x], [\"exp\", 2, bits]]\n\n\ndef clamp_bytestring(ir_node):\n    t = ir_node.typ\n    if not isinstance(t, ByteArrayLike):\n        raise CompilerPanic(f\"{t} passed to clamp_bytestring\")  # pragma: notest\n    return [\"assert\", [\"le\", get_bytearray_length(ir_node), t.maxlen]]\n\n\ndef clamp_dyn_array(ir_node):\n    t = ir_node.typ\n    assert isinstance(t, DArrayType)\n    return [\"assert\", [\"le\", get_dyn_array_count(ir_node), t.count]]\n\n\n# clampers for basetype\ndef clamp_basetype(ir_node):\n    t = ir_node.typ\n    if not isinstance(t, BaseType):\n        raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest\n\n    # copy of the input\n    ir_node = unwrap_location(ir_node)\n\n    if is_integer_type(t) or is_decimal_type(t):\n        if t._num_info.bits == 256:\n            return ir_node\n        else:\n            return int_clamp(ir_node, t._num_info.bits, signed=t._num_info.is_signed)\n\n    if is_bytes_m_type(t):\n        if t._bytes_info.m == 32:\n            return ir_node  # special case, no clamp.\n        else:\n            return bytes_clamp(ir_node, t._bytes_info.m)\n\n    if t.typ in (\"address\",):\n        return int_clamp(ir_node, 160)\n    if t.typ in (\"bool\",):\n        return int_clamp(ir_node, 1)\n\n    raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest\n\n\ndef int_clamp(ir_node, bits, signed=False):\n    \"\"\"Generalized clamper for integer types. Takes the number of bits,\n    whether it's signed, and returns an IR node which checks it is\n    in bounds. (Consumers should use clamp_basetype instead which uses\n    type-based dispatch and is a little safer.)\n    \"\"\"\n    if bits >= 256:\n        raise CompilerPanic(f\"invalid clamp: {bits}>=256 ({ir_node})\")  # pragma: notest\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        if signed:\n            # example for bits==128:\n            # promote_signed_int(val, bits) is the \"canonical\" version of val\n            # if val is in bounds, the bits above bit 128 should be equal.\n            # (this works for both val >= 0 and val < 0. in the first case,\n            # all upper bits should be 0 if val is a valid int128,\n            # in the latter case, all upper bits should be 1.)\n            assertion = [\"assert\", [\"eq\", val, promote_signed_int(val, bits)]]\n        else:\n            assertion = [\"assert\", [\"iszero\", shr(bits, val)]]\n\n        ret = b.resolve([\"seq\", assertion, val])\n\n    # TODO fix this annotation\n    return IRnode.from_list(ret, annotation=f\"int_clamp {ir_node.typ}\")\n\n\ndef bytes_clamp(ir_node: IRnode, n_bytes: int) -> IRnode:\n    if not (0 < n_bytes <= 32):\n        raise CompilerPanic(f\"bad type: bytes{n_bytes}\")\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        assertion = [\"assert\", [\"iszero\", shl(n_bytes * 8, val)]]\n        ret = b.resolve([\"seq\", assertion, val])\n    return IRnode.from_list(ret, annotation=f\"bytes{n_bytes}_clamp\")\n\n\n# e.g. for int8, promote 255 to -1\ndef promote_signed_int(x, bits):\n    assert bits % 8 == 0\n    ret = [\"signextend\", bits // 8 - 1, x]\n    return IRnode.from_list(ret, annotation=f\"promote int{bits}\")\n", "import decimal\nimport math\n\nfrom vyper import ast as vy_ast\nfrom vyper.address_space import DATA, IMMUTABLES, MEMORY, STORAGE\nfrom vyper.codegen import external_call, self_call\nfrom vyper.codegen.core import (\n    LOAD,\n    bytes_data_ptr,\n    clamp_basetype,\n    ensure_in_memory,\n    get_dyn_array_count,\n    get_element_ptr,\n    getpos,\n    make_setter,\n    pop_dyn_array,\n    unwrap_location,\n)\nfrom vyper.codegen.ir_node import IRnode\nfrom vyper.codegen.keccak256_helper import keccak256_helper\nfrom vyper.codegen.types import (\n    ArrayLike,\n    BaseType,\n    ByteArrayLike,\n    ByteArrayType,\n    DArrayType,\n    InterfaceType,\n    MappingType,\n    SArrayType,\n    StringType,\n    StructType,\n    TupleType,\n    is_base_type,\n    is_numeric_type,\n)\nfrom vyper.codegen.types.convert import new_type_to_old_type\nfrom vyper.evm.opcodes import version_check\nfrom vyper.exceptions import (\n    CompilerPanic,\n    EvmVersionException,\n    StructureException,\n    TypeCheckFailure,\n    TypeMismatch,\n)\nfrom vyper.utils import DECIMAL_DIVISOR, SizeLimits, bytes_to_int, checksum_encode, string_to_bytes\n\nENVIRONMENT_VARIABLES = {\n    \"block\",\n    \"msg\",\n    \"tx\",\n    \"chain\",\n}\n\n\ndef calculate_largest_power(a: int, num_bits: int, is_signed: bool) -> int:\n    \"\"\"\n    For a given base `a`, compute the maximum power `b` that will not\n    produce an overflow in the equation `a ** b`\n\n    Arguments\n    ---------\n    a : int\n        Base value for the equation `a ** b`\n    num_bits : int\n        The maximum number of bits that the resulting value must fit in\n    is_signed : bool\n        Is the operation being performed on signed integers?\n\n    Returns\n    -------\n    int\n        Largest possible value for `b` where the result does not overflow\n        `num_bits`\n    \"\"\"\n    if num_bits % 8:\n        raise CompilerPanic(\"Type is not a modulo of 8\")\n\n    value_bits = num_bits - (1 if is_signed else 0)\n    if a >= 2 ** value_bits:\n        raise TypeCheckFailure(\"Value is too large and will always throw\")\n    elif a < -(2 ** value_bits):\n        raise TypeCheckFailure(\"Value is too small and will always throw\")\n\n    a_is_negative = a < 0\n    a = abs(a)  # No longer need to know if it's signed or not\n    if a in (0, 1):\n        raise CompilerPanic(\"Exponential operation is useless!\")\n\n    # NOTE: There is an edge case if `a` were left signed where the following\n    #       operation would not work (`ln(a)` is undefined if `a <= 0`)\n    b = int(decimal.Decimal(value_bits) / (decimal.Decimal(a).ln() / decimal.Decimal(2).ln()))\n    if b <= 1:\n        return 1  # Value is assumed to be in range, therefore power of 1 is max\n\n    # Do a bit of iteration to ensure we have the exact number\n    num_iterations = 0\n    while a ** (b + 1) < 2 ** value_bits:\n        b += 1\n        num_iterations += 1\n        assert num_iterations < 10000\n    while a ** b >= 2 ** value_bits:\n        b -= 1\n        num_iterations += 1\n        assert num_iterations < 10000\n\n    # Edge case: If a is negative and the values of a and b are such that:\n    #               (a) ** (b + 1) == -(2 ** value_bits)\n    #            we can actually squeak one more out of it because it's on the edge\n    if a_is_negative and (-a) ** (b + 1) == -(2 ** value_bits):  # NOTE: a = abs(a)\n        return b + 1\n    else:\n        return b  # Exact\n\n\ndef calculate_largest_base(b: int, num_bits: int, is_signed: bool) -> int:\n    \"\"\"\n    For a given power `b`, compute the maximum base `a` that will not produce an\n    overflow in the equation `a ** b`\n\n    Arguments\n    ---------\n    b : int\n        Power value for the equation `a ** b`\n    num_bits : int\n        The maximum number of bits that the resulting value must fit in\n    is_signed : bool\n        Is the operation being performed on signed integers?\n\n    Returns\n    -------\n    int\n        Largest possible value for `a` where the result does not overflow\n        `num_bits`\n    \"\"\"\n    if num_bits % 8:\n        raise CompilerPanic(\"Type is not a modulo of 8\")\n    if b < 0:\n        raise TypeCheckFailure(\"Cannot calculate negative exponents\")\n\n    value_bits = num_bits - (1 if is_signed else 0)\n    if b > value_bits:\n        raise TypeCheckFailure(\"Value is too large and will always throw\")\n    elif b < 2:\n        return 2 ** value_bits - 1  # Maximum value for type\n\n    # Estimate (up to ~39 digits precision required)\n    a = math.ceil(2 ** (decimal.Decimal(value_bits) / decimal.Decimal(b)))\n    # Do a bit of iteration to ensure we have the exact number\n    num_iterations = 0\n    while (a + 1) ** b < 2 ** value_bits:\n        a += 1\n        num_iterations += 1\n        assert num_iterations < 10000\n    while a ** b >= 2 ** value_bits:\n        a -= 1\n        num_iterations += 1\n        assert num_iterations < 10000\n\n    return a\n\n\nclass Expr:\n    # TODO: Once other refactors are made reevaluate all inline imports\n\n    def __init__(self, node, context):\n        self.expr = node\n        self.context = context\n\n        if isinstance(node, IRnode):\n            # TODO this seems bad\n            self.ir_node = node\n            return\n\n        fn = getattr(self, f\"parse_{type(node).__name__}\", None)\n        if fn is None:\n            raise TypeCheckFailure(f\"Invalid statement node: {type(node).__name__}\")\n\n        self.ir_node = fn()\n        if self.ir_node is None:\n            raise TypeCheckFailure(f\"{type(node).__name__} node did not produce IR. {self.expr}\")\n\n        self.ir_node.annotation = self.expr.get(\"node_source_code\")\n        self.ir_node.source_pos = getpos(self.expr)\n\n    def parse_Int(self):\n        # Literal (mostly likely) becomes int256\n        if self.expr.n < 0:\n            return IRnode.from_list(self.expr.n, typ=BaseType(\"int256\", is_literal=True))\n        # Literal is large enough (mostly likely) becomes uint256.\n        else:\n            return IRnode.from_list(self.expr.n, typ=BaseType(\"uint256\", is_literal=True))\n\n    def parse_Decimal(self):\n        val = self.expr.value * DECIMAL_DIVISOR\n\n        # sanity check that type checker did its job\n        assert isinstance(val, decimal.Decimal)\n        assert SizeLimits.in_bounds(\"decimal\", val)\n        assert math.ceil(val) == math.floor(val)\n\n        val = int(val)\n\n        return IRnode.from_list(val, typ=BaseType(\"decimal\", is_literal=True))\n\n    def parse_Hex(self):\n        hexstr = self.expr.value\n\n        if len(hexstr) == 42:\n            # sanity check typechecker did its job\n            assert checksum_encode(hexstr) == hexstr\n            typ = BaseType(\"address\")\n            # TODO allow non-checksum encoded bytes20\n            return IRnode.from_list(int(self.expr.value, 16), typ=typ)\n\n        else:\n            n_bytes = (len(hexstr) - 2) // 2  # e.g. \"0x1234\" is 2 bytes\n            # TODO: typ = new_type_to_old_type(self.expr._metadata[\"type\"])\n            #       assert n_bytes == typ._bytes_info.m\n\n            # bytes_m types are left padded with zeros\n            val = int(hexstr, 16) << 8 * (32 - n_bytes)\n\n            typ = BaseType(f\"bytes{n_bytes}\", is_literal=True)\n            typ.is_literal = True\n            return IRnode.from_list(val, typ=typ)\n\n    # String literals\n    def parse_Str(self):\n        bytez, bytez_length = string_to_bytes(self.expr.value)\n        typ = StringType(bytez_length, is_literal=True)\n        return self._make_bytelike(typ, bytez, bytez_length)\n\n    # Byte literals\n    def parse_Bytes(self):\n        bytez = self.expr.s\n        bytez_length = len(self.expr.s)\n        typ = ByteArrayType(bytez_length, is_literal=True)\n        return self._make_bytelike(typ, bytez, bytez_length)\n\n    def _make_bytelike(self, btype, bytez, bytez_length):\n        placeholder = self.context.new_internal_variable(btype)\n        seq = []\n        seq.append([\"mstore\", placeholder, bytez_length])\n        for i in range(0, len(bytez), 32):\n            seq.append(\n                [\n                    \"mstore\",\n                    [\"add\", placeholder, i + 32],\n                    bytes_to_int((bytez + b\"\\x00\" * 31)[i : i + 32]),\n                ]\n            )\n        return IRnode.from_list(\n            [\"seq\"] + seq + [placeholder],\n            typ=btype,\n            location=MEMORY,\n            annotation=f\"Create {btype}: {bytez}\",\n        )\n\n    # True, False, None constants\n    def parse_NameConstant(self):\n        if self.expr.value is True:\n            return IRnode.from_list(1, typ=BaseType(\"bool\", is_literal=True))\n        elif self.expr.value is False:\n            return IRnode.from_list(0, typ=BaseType(\"bool\", is_literal=True))\n\n    # Variable names\n    def parse_Name(self):\n\n        if self.expr.id == \"self\":\n            return IRnode.from_list([\"address\"], typ=\"address\")\n        elif self.expr.id in self.context.vars:\n            var = self.context.vars[self.expr.id]\n            return IRnode.from_list(\n                var.pos,\n                typ=var.typ,\n                location=var.location,  # either 'memory' or 'calldata' storage is handled above.\n                encoding=var.encoding,\n                annotation=self.expr.id,\n                mutable=var.mutable,\n            )\n\n        elif self.expr._metadata[\"type\"].is_immutable:\n            var = self.context.globals[self.expr.id]\n            ofst = self.expr._metadata[\"type\"].position.offset\n\n            if self.context.sig.is_init_func:\n                mutable = True\n                location = IMMUTABLES\n            else:\n                mutable = False\n                location = DATA\n\n            return IRnode.from_list(\n                ofst,\n                typ=var.typ,\n                location=location,\n                annotation=self.expr.id,\n                mutable=mutable,\n            )\n\n    # x.y or x[5]\n    def parse_Attribute(self):\n        # x.balance: balance of address x\n        if self.expr.attr == \"balance\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if is_base_type(addr.typ, \"address\"):\n                if (\n                    isinstance(self.expr.value, vy_ast.Name)\n                    and self.expr.value.id == \"self\"\n                    and version_check(begin=\"istanbul\")\n                ):\n                    seq = [\"selfbalance\"]\n                else:\n                    seq = [\"balance\", addr]\n                return IRnode.from_list(seq, typ=BaseType(\"uint256\"))\n        # x.codesize: codesize of address x\n        elif self.expr.attr == \"codesize\" or self.expr.attr == \"is_contract\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if is_base_type(addr.typ, \"address\"):\n                if self.expr.attr == \"codesize\":\n                    if self.expr.value.id == \"self\":\n                        eval_code = [\"codesize\"]\n                    else:\n                        eval_code = [\"extcodesize\", addr]\n                    output_type = \"uint256\"\n                else:\n                    eval_code = [\"gt\", [\"extcodesize\", addr], 0]\n                    output_type = \"bool\"\n                return IRnode.from_list(eval_code, typ=BaseType(output_type))\n        # x.codehash: keccak of address x\n        elif self.expr.attr == \"codehash\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if not version_check(begin=\"constantinople\"):\n                raise EvmVersionException(\n                    \"address.codehash is unavailable prior to constantinople ruleset\", self.expr\n                )\n            if is_base_type(addr.typ, \"address\"):\n                return IRnode.from_list([\"extcodehash\", addr], typ=BaseType(\"bytes32\"))\n        # x.code: codecopy/extcodecopy of address x\n        elif self.expr.attr == \"code\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if is_base_type(addr.typ, \"address\"):\n                # These adhoc nodes will be replaced with a valid node in `Slice.build_IR`\n                if addr.value == \"address\":  # for `self.code`\n                    return IRnode.from_list([\"~selfcode\"], typ=ByteArrayType(0))\n                return IRnode.from_list([\"~extcode\", addr], typ=ByteArrayType(0))\n        # self.x: global attribute\n        elif isinstance(self.expr.value, vy_ast.Name) and self.expr.value.id == \"self\":\n            type_ = self.expr._metadata[\"type\"]\n            var = self.context.globals[self.expr.attr]\n            return IRnode.from_list(\n                type_.position.position,\n                typ=var.typ,\n                location=STORAGE,\n                annotation=\"self.\" + self.expr.attr,\n            )\n        # Reserved keywords\n        elif (\n            isinstance(self.expr.value, vy_ast.Name) and self.expr.value.id in ENVIRONMENT_VARIABLES\n        ):\n            key = f\"{self.expr.value.id}.{self.expr.attr}\"\n            if key == \"msg.sender\":\n                return IRnode.from_list([\"caller\"], typ=\"address\")\n            elif key == \"msg.data\":\n                # This adhoc node will be replaced with a valid node in `Slice/Len.build_IR`\n                return IRnode.from_list([\"~calldata\"], typ=ByteArrayType(0))\n            elif key == \"msg.value\" and self.context.is_payable:\n                return IRnode.from_list([\"callvalue\"], typ=BaseType(\"uint256\"))\n            elif key == \"msg.gas\":\n                return IRnode.from_list([\"gas\"], typ=\"uint256\")\n            elif key == \"block.difficulty\":\n                return IRnode.from_list([\"difficulty\"], typ=\"uint256\")\n            elif key == \"block.timestamp\":\n                return IRnode.from_list([\"timestamp\"], typ=BaseType(\"uint256\"))\n            elif key == \"block.coinbase\":\n                return IRnode.from_list([\"coinbase\"], typ=\"address\")\n            elif key == \"block.number\":\n                return IRnode.from_list([\"number\"], typ=\"uint256\")\n            elif key == \"block.gaslimit\":\n                return IRnode.from_list([\"gaslimit\"], typ=\"uint256\")\n            elif key == \"block.basefee\":\n                return IRnode.from_list([\"basefee\"], typ=\"uint256\")\n            elif key == \"block.prevhash\":\n                return IRnode.from_list([\"blockhash\", [\"sub\", \"number\", 1]], typ=\"bytes32\")\n            elif key == \"tx.origin\":\n                return IRnode.from_list([\"origin\"], typ=\"address\")\n            elif key == \"tx.gasprice\":\n                return IRnode.from_list([\"gasprice\"], typ=\"uint256\")\n            elif key == \"chain.id\":\n                if not version_check(begin=\"istanbul\"):\n                    raise EvmVersionException(\n                        \"chain.id is unavailable prior to istanbul ruleset\", self.expr\n                    )\n                return IRnode.from_list([\"chainid\"], typ=\"uint256\")\n        # Other variables\n        else:\n            sub = Expr(self.expr.value, self.context).ir_node\n            # contract type\n            if isinstance(sub.typ, InterfaceType):\n                return sub\n            if isinstance(sub.typ, StructType) and self.expr.attr in sub.typ.members:\n                return get_element_ptr(sub, self.expr.attr)\n\n    def parse_Subscript(self):\n        sub = Expr(self.expr.value, self.context).ir_node\n        if sub.value == \"multi\":\n            # force literal to memory, e.g.\n            # MY_LIST: constant(decimal[6])\n            # ...\n            # return MY_LIST[ix]\n            sub = ensure_in_memory(sub, self.context)\n\n        if isinstance(sub.typ, MappingType):\n            # TODO sanity check we are in a self.my_map[i] situation\n            index = Expr.parse_value_expr(self.expr.slice.value, self.context)\n            if isinstance(index.typ, ByteArrayLike):\n                # we have to hash the key to get a storage location\n                assert len(index.args) == 1\n                index = keccak256_helper(self.expr.slice.value, index.args[0], self.context)\n\n        elif isinstance(sub.typ, ArrayLike):\n            index = Expr.parse_value_expr(self.expr.slice.value, self.context)\n\n        elif isinstance(sub.typ, TupleType):\n            index = self.expr.slice.value.n\n            # note: this check should also happen in get_element_ptr\n            if not 0 <= index < len(sub.typ.members):\n                return\n        else:\n            return\n\n        ir_node = get_element_ptr(sub, index)\n        ir_node.mutable = sub.mutable\n        return ir_node\n\n    def parse_BinOp(self):\n        left = Expr.parse_value_expr(self.expr.left, self.context)\n        right = Expr.parse_value_expr(self.expr.right, self.context)\n\n        if not is_numeric_type(left.typ) or not is_numeric_type(right.typ):\n            return\n\n        types = {left.typ.typ, right.typ.typ}\n        literals = {left.typ.is_literal, right.typ.is_literal}\n\n        # If one value of the operation is a literal, we recast it to match the non-literal type.\n        # We know this is OK because types were already verified in the actual typechecking pass.\n        # This is a temporary solution to not break codegen while we work toward removing types\n        # altogether at this stage of complition. @iamdefinitelyahuman\n        if literals == {True, False} and len(types) > 1 and \"decimal\" not in types:\n            if left.typ.is_literal and SizeLimits.in_bounds(right.typ.typ, left.value):\n                left = IRnode.from_list(left.value, typ=BaseType(right.typ.typ, is_literal=True))\n            elif right.typ.is_literal and SizeLimits.in_bounds(left.typ.typ, right.value):\n                right = IRnode.from_list(right.value, typ=BaseType(left.typ.typ, is_literal=True))\n\n        ltyp, rtyp = left.typ.typ, right.typ.typ\n\n        # Sanity check - ensure that we aren't dealing with different types\n        # This should be unreachable due to the type check pass\n        assert ltyp == rtyp, \"unreachable\"\n\n        arith = None\n        if isinstance(self.expr.op, (vy_ast.Add, vy_ast.Sub)):\n            new_typ = BaseType(ltyp)\n\n            if ltyp == \"uint256\":\n                if isinstance(self.expr.op, vy_ast.Add):\n                    # safeadd\n                    arith = [\"seq\", [\"assert\", [\"ge\", [\"add\", \"l\", \"r\"], \"l\"]], [\"add\", \"l\", \"r\"]]\n\n                elif isinstance(self.expr.op, vy_ast.Sub):\n                    # safesub\n                    arith = [\"seq\", [\"assert\", [\"ge\", \"l\", \"r\"]], [\"sub\", \"l\", \"r\"]]\n\n            elif ltyp == \"int256\":\n                if isinstance(self.expr.op, vy_ast.Add):\n                    op, comp1, comp2 = \"add\", \"sge\", \"slt\"\n                else:\n                    op, comp1, comp2 = \"sub\", \"sle\", \"sgt\"\n\n                if right.typ.is_literal:\n                    if right.value >= 0:\n                        arith = [\"seq\", [\"assert\", [comp1, [op, \"l\", \"r\"], \"l\"]], [op, \"l\", \"r\"]]\n                    else:\n                        arith = [\"seq\", [\"assert\", [comp2, [op, \"l\", \"r\"], \"l\"]], [op, \"l\", \"r\"]]\n                else:\n                    arith = [\n                        \"with\",\n                        \"ans\",\n                        [op, \"l\", \"r\"],\n                        [\n                            \"seq\",\n                            [\n                                \"assert\",\n                                [\n                                    \"or\",\n                                    [\"and\", [\"sge\", \"r\", 0], [comp1, \"ans\", \"l\"]],\n                                    [\"and\", [\"slt\", \"r\", 0], [comp2, \"ans\", \"l\"]],\n                                ],\n                            ],\n                            \"ans\",\n                        ],\n                    ]\n\n            elif ltyp in (\"decimal\", \"int128\", \"uint8\"):\n                op = \"add\" if isinstance(self.expr.op, vy_ast.Add) else \"sub\"\n                arith = [op, \"l\", \"r\"]\n\n        elif isinstance(self.expr.op, vy_ast.Mult):\n            new_typ = BaseType(ltyp)\n            if ltyp == \"uint256\":\n                arith = [\n                    \"with\",\n                    \"ans\",\n                    [\"mul\", \"l\", \"r\"],\n                    [\n                        \"seq\",\n                        [\"assert\", [\"or\", [\"eq\", [\"div\", \"ans\", \"l\"], \"r\"], [\"iszero\", \"l\"]]],\n                        \"ans\",\n                    ],\n                ]\n\n            elif ltyp == \"int256\":\n                if version_check(begin=\"constantinople\"):\n                    upper_bound = [\"shl\", 255, 1]\n                else:\n                    upper_bound = -(2 ** 255)\n                if not left.typ.is_literal and not right.typ.is_literal:\n                    bounds_check = [\n                        \"assert\",\n                        [\"or\", [\"ne\", \"l\", [\"not\", 0]], [\"ne\", \"r\", upper_bound]],\n                    ]\n                elif left.typ.is_literal and left.value == -1:\n                    bounds_check = [\"assert\", [\"ne\", \"r\", upper_bound]]\n                elif right.typ.is_literal and right.value == -(2 ** 255):\n                    bounds_check = [\"assert\", [\"ne\", \"l\", [\"not\", 0]]]\n                else:\n                    bounds_check = \"pass\"\n                arith = [\n                    \"with\",\n                    \"ans\",\n                    [\"mul\", \"l\", \"r\"],\n                    [\n                        \"seq\",\n                        bounds_check,\n                        [\"assert\", [\"or\", [\"eq\", [\"sdiv\", \"ans\", \"l\"], \"r\"], [\"iszero\", \"l\"]]],\n                        \"ans\",\n                    ],\n                ]\n\n            elif ltyp in (\"int128\", \"uint8\"):\n                arith = [\"mul\", \"l\", \"r\"]\n\n            elif ltyp == \"decimal\":\n                arith = [\n                    \"with\",\n                    \"ans\",\n                    [\"mul\", \"l\", \"r\"],\n                    [\n                        \"seq\",\n                        [\"assert\", [\"or\", [\"eq\", [\"sdiv\", \"ans\", \"l\"], \"r\"], [\"iszero\", \"l\"]]],\n                        [\"sdiv\", \"ans\", DECIMAL_DIVISOR],\n                    ],\n                ]\n\n        elif isinstance(self.expr.op, vy_ast.Div):\n            if right.typ.is_literal and right.value == 0:\n                return\n\n            new_typ = BaseType(ltyp)\n\n            if right.typ.is_literal:\n                divisor = \"r\"\n            else:\n                # only apply the non-zero clamp when r is not a constant\n                divisor = [\"clamp_nonzero\", \"r\"]\n\n            if ltyp in (\"uint8\", \"uint256\"):\n                arith = [\"div\", \"l\", divisor]\n\n            elif ltyp == \"int256\":\n                if version_check(begin=\"constantinople\"):\n                    upper_bound = [\"shl\", 255, 1]\n                else:\n                    upper_bound = -(2 ** 255)\n                if not left.typ.is_literal and not right.typ.is_literal:\n                    bounds_check = [\n                        \"assert\",\n                        [\"or\", [\"ne\", \"r\", [\"not\", 0]], [\"ne\", \"l\", upper_bound]],\n                    ]\n                elif left.typ.is_literal and left.value == -(2 ** 255):\n                    bounds_check = [\"assert\", [\"ne\", \"r\", [\"not\", 0]]]\n                elif right.typ.is_literal and right.value == -1:\n                    bounds_check = [\"assert\", [\"ne\", \"l\", upper_bound]]\n                else:\n                    bounds_check = \"pass\"\n                arith = [\"seq\", bounds_check, [\"sdiv\", \"l\", divisor]]\n\n            elif ltyp == \"int128\":\n                arith = [\"sdiv\", \"l\", divisor]\n\n            elif ltyp == \"decimal\":\n                arith = [\n                    \"sdiv\",\n                    [\"mul\", \"l\", DECIMAL_DIVISOR],\n                    divisor,\n                ]\n\n        elif isinstance(self.expr.op, vy_ast.Mod):\n            if right.typ.is_literal and right.value == 0:\n                return\n\n            new_typ = BaseType(ltyp)\n\n            if right.typ.is_literal:\n                divisor = \"r\"\n            else:\n                # only apply the non-zero clamp when r is not a constant\n                divisor = [\"clamp_nonzero\", \"r\"]\n\n            if ltyp in (\"uint8\", \"uint256\"):\n                arith = [\"mod\", \"l\", divisor]\n            else:\n                arith = [\"smod\", \"l\", divisor]\n\n        elif isinstance(self.expr.op, vy_ast.Pow):\n            new_typ = BaseType(ltyp)\n\n            # TODO optimizer rule for special cases\n            if self.expr.left.get(\"value\") == 1:\n                return IRnode.from_list([1], typ=new_typ)\n            if self.expr.left.get(\"value\") == 0:\n                return IRnode.from_list([\"iszero\", right], typ=new_typ)\n\n            if ltyp == \"int128\":\n                is_signed = True\n                num_bits = 128\n            elif ltyp == \"int256\":\n                is_signed = True\n                num_bits = 256\n            elif ltyp == \"uint8\":\n                is_signed = False\n                num_bits = 8\n            else:\n                is_signed = False\n                num_bits = 256\n\n            if isinstance(self.expr.left, vy_ast.Int):\n                value = self.expr.left.value\n                upper_bound = calculate_largest_power(value, num_bits, is_signed) + 1\n                # for signed integers, this also prevents negative values\n                clamp = [\"lt\", right, upper_bound]\n                return IRnode.from_list(\n                    [\"seq\", [\"assert\", clamp], [\"exp\", left, right]],\n                    typ=new_typ,\n                )\n            elif isinstance(self.expr.right, vy_ast.Int):\n                value = self.expr.right.value\n                upper_bound = calculate_largest_base(value, num_bits, is_signed) + 1\n                if is_signed:\n                    clamp = [\"and\", [\"slt\", left, upper_bound], [\"sgt\", left, -upper_bound]]\n                else:\n                    clamp = [\"lt\", left, upper_bound]\n                return IRnode.from_list(\n                    [\"seq\", [\"assert\", clamp], [\"exp\", left, right]], typ=new_typ\n                )\n            else:\n                # `a ** b` where neither `a` or `b` are known\n                # TODO this is currently unreachable, once we implement a way to do it safely\n                # remove the check in `vyper/context/types/value/numeric.py`\n                return\n\n        if arith is None:\n            return\n\n        arith = IRnode.from_list(arith, typ=new_typ)\n\n        p = [\n            \"with\",\n            \"l\",\n            left,\n            [\n                \"with\",\n                \"r\",\n                right,\n                # note clamp_basetype is a noop on [u]int256\n                # note: clamp_basetype throws on unclampable input\n                clamp_basetype(arith),\n            ],\n        ]\n        return IRnode.from_list(p, typ=new_typ)\n\n    def build_in_comparator(self):\n        left = Expr(self.expr.left, self.context).ir_node\n        right = Expr(self.expr.right, self.context).ir_node\n\n        # temporary kludge to block #2637 bug\n        # TODO actually fix the bug\n        if not isinstance(left.typ, BaseType):\n            raise TypeMismatch(\n                \"`in` not allowed for arrays of non-base types, tracked in issue #2637\", self.expr\n            )\n\n        if isinstance(self.expr.op, vy_ast.In):\n            found, not_found = 1, 0\n        elif isinstance(self.expr.op, vy_ast.NotIn):\n            found, not_found = 0, 1\n        else:\n            return  # pragma: notest\n\n        i = IRnode.from_list(self.context.fresh_varname(\"in_ix\"), typ=\"uint256\")\n\n        found_ptr = self.context.new_internal_variable(BaseType(\"bool\"))\n\n        ret = [\"seq\"]\n\n        left = unwrap_location(left)\n        with left.cache_when_complex(\"needle\") as (b1, left), right.cache_when_complex(\n            \"haystack\"\n        ) as (b2, right):\n            if right.value == \"multi\":\n                # Copy literal to memory to be compared.\n                tmp_list = IRnode.from_list(\n                    self.context.new_internal_variable(right.typ), typ=right.typ, location=MEMORY\n                )\n                ret.append(make_setter(tmp_list, right))\n\n                right = tmp_list\n\n            # location of i'th item from list\n            ith_element_ptr = get_element_ptr(right, i, array_bounds_check=False)\n            ith_element = unwrap_location(ith_element_ptr)\n\n            if isinstance(right.typ, SArrayType):\n                len_ = right.typ.count\n            else:\n                len_ = get_dyn_array_count(right)\n\n            # Condition repeat loop has to break on.\n            # TODO maybe put result on the stack\n            loop_body = [\n                \"if\",\n                [\"eq\", left, ith_element],\n                [\"seq\", [\"mstore\", found_ptr, found], \"break\"],  # store true.\n            ]\n            loop = [\"repeat\", i, 0, len_, right.typ.count, loop_body]\n\n            ret.append(\n                [\n                    \"seq\",\n                    [\"mstore\", found_ptr, not_found],\n                    loop,\n                    [\"mload\", found_ptr],\n                ]\n            )\n\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=\"bool\")\n\n    @staticmethod\n    def _signed_to_unsigned_comparision_op(op):\n        translation_map = {\n            \"sgt\": \"gt\",\n            \"sge\": \"ge\",\n            \"sle\": \"le\",\n            \"slt\": \"lt\",\n        }\n        if op in translation_map:\n            return translation_map[op]\n        else:\n            return op\n\n    def parse_Compare(self):\n        left = Expr.parse_value_expr(self.expr.left, self.context)\n        right = Expr.parse_value_expr(self.expr.right, self.context)\n\n        if right.value is None:\n            return\n\n        if isinstance(self.expr.op, (vy_ast.In, vy_ast.NotIn)):\n            if isinstance(right.typ, ArrayLike):\n                return self.build_in_comparator()\n            return  # pragma: notest\n\n        if isinstance(self.expr.op, vy_ast.Gt):\n            op = \"sgt\"\n        elif isinstance(self.expr.op, vy_ast.GtE):\n            op = \"sge\"\n        elif isinstance(self.expr.op, vy_ast.LtE):\n            op = \"sle\"\n        elif isinstance(self.expr.op, vy_ast.Lt):\n            op = \"slt\"\n        elif isinstance(self.expr.op, vy_ast.Eq):\n            op = \"eq\"\n        elif isinstance(self.expr.op, vy_ast.NotEq):\n            op = \"ne\"\n        else:\n            return  # pragma: notest\n\n        # Compare (limited to 32) byte arrays.\n        if isinstance(left.typ, ByteArrayLike) and isinstance(right.typ, ByteArrayLike):\n            left = Expr(self.expr.left, self.context).ir_node\n            right = Expr(self.expr.right, self.context).ir_node\n\n            length_mismatch = left.typ.maxlen != right.typ.maxlen\n            left_over_32 = left.typ.maxlen > 32\n            right_over_32 = right.typ.maxlen > 32\n\n            if length_mismatch or left_over_32 or right_over_32:\n                left_keccak = keccak256_helper(self.expr, left, self.context)\n                right_keccak = keccak256_helper(self.expr, right, self.context)\n\n                if op == \"eq\" or op == \"ne\":\n                    return IRnode.from_list([op, left_keccak, right_keccak], typ=\"bool\")\n\n                else:\n                    return\n\n            else:\n\n                def load_bytearray(side):\n                    return LOAD(bytes_data_ptr(side))\n\n                return IRnode.from_list(\n                    # CMC 2022-03-24 TODO investigate this.\n                    [op, load_bytearray(left), load_bytearray(right)],\n                    typ=\"bool\",\n                )\n\n        # Compare other types.\n        elif is_numeric_type(left.typ) and is_numeric_type(right.typ):\n            if left.typ.typ == right.typ.typ == \"uint256\":\n                # this works because we only have one unsigned integer type\n                # in the future if others are added, this logic must be expanded\n                op = self._signed_to_unsigned_comparision_op(op)\n\n        elif isinstance(left.typ, BaseType) and isinstance(right.typ, BaseType):\n            if op not in (\"eq\", \"ne\"):\n                return\n        else:\n            # kludge to block behavior in #2638\n            # TODO actually implement equality for complex types\n            raise TypeMismatch(\n                f\"operation not yet supported for {left.typ}, {right.typ}, see issue #2638\",\n                self.expr.op,\n            )\n\n        return IRnode.from_list([op, left, right], typ=\"bool\")\n\n    def parse_BoolOp(self):\n        for value in self.expr.values:\n            # Check for boolean operations with non-boolean inputs\n            _expr = Expr.parse_value_expr(value, self.context)\n            if not is_base_type(_expr.typ, \"bool\"):\n                return\n\n        def _build_if_ir(condition, true, false):\n            # generate a basic if statement in IR\n            o = [\"if\", condition, true, false]\n            return o\n\n        if isinstance(self.expr.op, vy_ast.And):\n            # create the initial `x and y` from the final two values\n            ir_node = _build_if_ir(\n                Expr.parse_value_expr(self.expr.values[-2], self.context),\n                Expr.parse_value_expr(self.expr.values[-1], self.context),\n                [0],\n            )\n            # iterate backward through the remaining values\n            for node in self.expr.values[-3::-1]:\n                ir_node = _build_if_ir(Expr.parse_value_expr(node, self.context), ir_node, [0])\n\n        elif isinstance(self.expr.op, vy_ast.Or):\n            # create the initial `x or y` from the final two values\n            ir_node = _build_if_ir(\n                Expr.parse_value_expr(self.expr.values[-2], self.context),\n                [1],\n                Expr.parse_value_expr(self.expr.values[-1], self.context),\n            )\n\n            # iterate backward through the remaining values\n            for node in self.expr.values[-3::-1]:\n                ir_node = _build_if_ir(Expr.parse_value_expr(node, self.context), 1, ir_node)\n        else:\n            raise TypeCheckFailure(f\"Unexpected boolean operator: {type(self.expr.op).__name__}\")\n\n        return IRnode.from_list(ir_node, typ=\"bool\")\n\n    # Unary operations (only \"not\" supported)\n    def parse_UnaryOp(self):\n        operand = Expr.parse_value_expr(self.expr.operand, self.context)\n        if isinstance(self.expr.op, vy_ast.Not):\n            if isinstance(operand.typ, BaseType) and operand.typ.typ == \"bool\":\n                return IRnode.from_list([\"iszero\", operand], typ=\"bool\")\n        elif isinstance(self.expr.op, vy_ast.USub) and is_numeric_type(operand.typ):\n            assert operand.typ._num_info.is_signed\n            # Clamp on minimum integer value as we cannot negate that value\n            # (all other integer values are fine)\n            min_int_val, _ = operand.typ._num_info.bounds\n            return IRnode.from_list(\n                [\"sub\", 0, [\"clampgt\", operand, min_int_val]],\n                typ=operand.typ,\n            )\n\n    def _is_valid_interface_assign(self):\n        if self.expr.args and len(self.expr.args) == 1:\n            arg_ir = Expr(self.expr.args[0], self.context).ir_node\n            if arg_ir.typ == BaseType(\"address\"):\n                return True, arg_ir\n        return False, None\n\n    # Function calls\n    def parse_Call(self):\n        # TODO check out this inline import\n        from vyper.builtin_functions import DISPATCH_TABLE\n\n        if isinstance(self.expr.func, vy_ast.Name):\n            function_name = self.expr.func.id\n\n            if function_name in DISPATCH_TABLE:\n                return DISPATCH_TABLE[function_name].build_IR(self.expr, self.context)\n\n            # Struct constructors do not need `self` prefix.\n            elif function_name in self.context.structs:\n                args = self.expr.args\n                if len(args) == 1 and isinstance(args[0], vy_ast.Dict):\n                    return Expr.struct_literals(args[0], function_name, self.context)\n\n            # Interface assignment. Bar(<address>).\n            elif function_name in self.context.sigs:\n                ret, arg_ir = self._is_valid_interface_assign()\n                if ret is True:\n                    arg_ir.typ = InterfaceType(function_name)  # Cast to Correct interface type.\n                    return arg_ir\n\n        elif isinstance(self.expr.func, vy_ast.Attribute) and self.expr.func.attr == \"pop\":\n            darray = Expr(self.expr.func.value, self.context).ir_node\n            assert len(self.expr.args) == 0\n            assert isinstance(darray.typ, DArrayType)\n            return pop_dyn_array(\n                darray,\n                return_popped_item=True,\n            )\n\n        elif (\n            isinstance(self.expr.func, vy_ast.Attribute)\n            and isinstance(self.expr.func.value, vy_ast.Name)\n            and self.expr.func.value.id == \"self\"\n        ):  # noqa: E501\n            return self_call.ir_for_self_call(self.expr, self.context)\n        else:\n            return external_call.ir_for_external_call(self.expr, self.context)\n\n    def parse_List(self):\n        typ = new_type_to_old_type(self.expr._metadata[\"type\"])\n        if len(self.expr.elements) == 0:\n            return IRnode.from_list(\"~empty\", typ=typ)\n\n        multi_ir = [Expr(x, self.context).ir_node for x in self.expr.elements]\n\n        return IRnode.from_list([\"multi\"] + multi_ir, typ=typ)\n\n    def parse_Tuple(self):\n        tuple_elements = [Expr(x, self.context).ir_node for x in self.expr.elements]\n        typ = TupleType([x.typ for x in tuple_elements], is_literal=True)\n        multi_ir = IRnode.from_list([\"multi\"] + tuple_elements, typ=typ)\n        return multi_ir\n\n    @staticmethod\n    def struct_literals(expr, name, context):\n        member_subs = {}\n        member_typs = {}\n        for key, value in zip(expr.keys, expr.values):\n            if not isinstance(key, vy_ast.Name):\n                return\n            if key.id in member_subs:\n                return\n            sub = Expr(value, context).ir_node\n            member_subs[key.id] = sub\n            member_typs[key.id] = sub.typ\n        return IRnode.from_list(\n            [\"multi\"] + [member_subs[key] for key in member_subs.keys()],\n            typ=StructType(member_typs, name, is_literal=True),\n        )\n\n    # Parse an expression that results in a value\n    @classmethod\n    def parse_value_expr(cls, expr, context):\n        return unwrap_location(cls(expr, context).ir_node)\n\n    # Parse an expression that represents a pointer to memory/calldata or storage.\n    @classmethod\n    def parse_pointer_expr(cls, expr, context):\n        o = cls(expr, context).ir_node\n        if not o.location:\n            raise StructureException(\"Looking for a variable location, instead got a value\", expr)\n        return o\n", "from math import ceil\n\nfrom vyper.codegen.core import ensure_in_memory\nfrom vyper.codegen.ir_node import IRnode\nfrom vyper.codegen.types import BaseType, ByteArrayLike, is_base_type\nfrom vyper.exceptions import CompilerPanic\nfrom vyper.utils import MemoryPositions, bytes_to_int, keccak256\n\n\ndef _check_byteslike(typ, _expr):\n    if not isinstance(typ, ByteArrayLike) and not is_base_type(typ, \"bytes32\"):\n        # NOTE this may be checked at a higher level, but just be safe\n        raise CompilerPanic(\n            \"keccak256 only accepts bytes-like objects\",\n        )\n\n\ndef _gas_bound(num_words):\n    SHA3_BASE = 30\n    SHA3_PER_WORD = 6\n    return SHA3_BASE + num_words * SHA3_PER_WORD\n\n\ndef keccak256_helper(expr, ir_arg, context):\n    sub = ir_arg  # TODO get rid of useless variable\n    _check_byteslike(sub.typ, expr)\n\n    # Can hash literals\n    # TODO this is dead code.\n    if isinstance(sub, bytes):\n        return IRnode.from_list(bytes_to_int(keccak256(sub)), typ=BaseType(\"bytes32\"))\n\n    # Can hash bytes32 objects\n    if is_base_type(sub.typ, \"bytes32\"):\n        return IRnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, sub],\n                [\"sha3\", MemoryPositions.FREE_VAR_SPACE, 32],\n            ],\n            typ=BaseType(\"bytes32\"),\n            add_gas_estimate=_gas_bound(1),\n        )\n\n    sub = ensure_in_memory(sub, context)\n\n    return IRnode.from_list(\n        [\n            \"with\",\n            \"_buf\",\n            sub,\n            [\"sha3\", [\"add\", \"_buf\", 32], [\"mload\", \"_buf\"]],\n        ],\n        typ=BaseType(\"bytes32\"),\n        annotation=\"keccak256\",\n        add_gas_estimate=_gas_bound(ceil(sub.typ.maxlen / 32)),\n    )\n"], "fixing_code": ["import pytest\n\nfrom vyper.exceptions import ArgumentException\n\n_fun_bytes32_bounds = [(0, 32), (3, 29), (27, 5), (0, 5), (5, 3), (30, 2)]\n\n\ndef _generate_bytes(length):\n    return bytes(list(range(length)))\n\n\n# good numbers to try\n_fun_numbers = [0, 1, 5, 31, 32, 33, 64, 99, 100, 101]\n\n\n# [b\"\", b\"\\x01\", b\"\\x02\"...]\n_bytes_examples = [_generate_bytes(i) for i in _fun_numbers if i <= 100]\n\n\ndef test_basic_slice(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef slice_tower_test(inp1: Bytes[50]) -> Bytes[50]:\n    inp: Bytes[50] = inp1\n    for i in range(1, 11):\n        inp = slice(inp, 1, 30 - i * 2)\n    return inp\n    \"\"\"\n    c = get_contract_with_gas_estimation(code)\n    x = c.slice_tower_test(b\"abcdefghijklmnopqrstuvwxyz1234\")\n    assert x == b\"klmnopqrst\", x\n\n\n@pytest.mark.parametrize(\"bytesdata\", _bytes_examples)\n@pytest.mark.parametrize(\"start\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_start\", (True, False))\n@pytest.mark.parametrize(\"length\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_length\", (True, False))\n@pytest.mark.fuzzing\ndef test_slice_immutable(\n    get_contract,\n    assert_compile_failed,\n    assert_tx_failed,\n    bytesdata,\n    start,\n    literal_start,\n    length,\n    literal_length,\n):\n    _start = start if literal_start else \"start\"\n    _length = length if literal_length else \"length\"\n\n    code = f\"\"\"\nIMMUTABLE_BYTES: immutable(Bytes[100])\nIMMUTABLE_SLICE: immutable(Bytes[100])\n\n@external\ndef __init__(inp: Bytes[100], start: uint256, length: uint256):\n    IMMUTABLE_BYTES = inp\n    IMMUTABLE_SLICE = slice(IMMUTABLE_BYTES, {_start}, {_length})\n\n@external\ndef do_splice() -> Bytes[100]:\n    return IMMUTABLE_SLICE\n    \"\"\"\n\n    if (\n        (start + length > 100 and literal_start and literal_length)\n        or (literal_length and length > 100)\n        or (literal_start and start > 100)\n        or (literal_length and length < 1)\n    ):\n        assert_compile_failed(\n            lambda: get_contract(code, bytesdata, start, length), ArgumentException\n        )\n    elif start + length > len(bytesdata):\n        assert_tx_failed(lambda: get_contract(code, bytesdata, start, length))\n    else:\n        c = get_contract(code, bytesdata, start, length)\n        assert c.do_splice() == bytesdata[start : start + length]\n\n\n@pytest.mark.parametrize(\"location\", (\"storage\", \"calldata\", \"memory\", \"literal\", \"code\"))\n@pytest.mark.parametrize(\"bytesdata\", _bytes_examples)\n@pytest.mark.parametrize(\"start\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_start\", (True, False))\n@pytest.mark.parametrize(\"length\", _fun_numbers)\n@pytest.mark.parametrize(\"literal_length\", (True, False))\n@pytest.mark.fuzzing\ndef test_slice_bytes(\n    get_contract,\n    assert_compile_failed,\n    assert_tx_failed,\n    location,\n    bytesdata,\n    start,\n    literal_start,\n    length,\n    literal_length,\n):\n    if location == \"memory\":\n        spliced_code = \"foo: Bytes[100] = inp\"\n        foo = \"foo\"\n    elif location == \"storage\":\n        spliced_code = \"self.foo = inp\"\n        foo = \"self.foo\"\n    elif location == \"code\":\n        spliced_code = \"\"\n        foo = \"IMMUTABLE_BYTES\"\n    elif location == \"literal\":\n        spliced_code = \"\"\n        foo = f\"{bytesdata}\"\n    elif location == \"calldata\":\n        spliced_code = \"\"\n        foo = \"inp\"\n\n    _start = start if literal_start else \"start\"\n    _length = length if literal_length else \"length\"\n\n    code = f\"\"\"\nfoo: Bytes[100]\nIMMUTABLE_BYTES: immutable(Bytes[100])\n@external\ndef __init__(foo: Bytes[100]):\n    IMMUTABLE_BYTES = foo\n\n@external\ndef do_slice(inp: Bytes[100], start: uint256, length: uint256) -> Bytes[100]:\n    {spliced_code}\n    return slice({foo}, {_start}, {_length})\n    \"\"\"\n\n    length_bound = len(bytesdata) if location == \"literal\" else 100\n    if (\n        (start + length > length_bound and literal_start and literal_length)\n        or (literal_length and length > length_bound)\n        or (literal_start and start > length_bound)\n        or (literal_length and length < 1)\n    ):\n        assert_compile_failed(lambda: get_contract(code, bytesdata), ArgumentException)\n    elif start + length > len(bytesdata):\n        c = get_contract(code, bytesdata)\n        assert_tx_failed(lambda: c.do_slice(bytesdata, start, length))\n    else:\n        c = get_contract(code, bytesdata)\n        assert c.do_slice(bytesdata, start, length) == bytesdata[start : start + length], code\n\n\ndef test_slice_private(get_contract):\n    # test there are no buffer overruns in the slice function\n    code = \"\"\"\nbytez: public(String[12])\n\n@internal\ndef _slice(start: uint256, length: uint256):\n    self.bytez = slice(self.bytez, start, length)\n\n@external\ndef foo(x: uint256, y: uint256) -> (uint256, String[12]):\n    self.bytez = \"hello, world\"\n    dont_clobber_me: uint256 = MAX_UINT256\n    self._slice(x, y)\n    return dont_clobber_me, self.bytez\n    \"\"\"\n    c = get_contract(code)\n    assert c.foo(0, 12) == [2 ** 256 - 1, \"hello, world\"]\n    assert c.foo(12, 0) == [2 ** 256 - 1, \"\"]\n    assert c.foo(7, 5) == [2 ** 256 - 1, \"world\"]\n    assert c.foo(0, 5) == [2 ** 256 - 1, \"hello\"]\n    assert c.foo(0, 1) == [2 ** 256 - 1, \"h\"]\n    assert c.foo(11, 1) == [2 ** 256 - 1, \"d\"]\n\n\ndef test_slice_storage_bytes32(get_contract):\n    code = \"\"\"\nbytez: bytes32\n@external\ndef dice() -> Bytes[1]:\n    self.bytez = convert(65, bytes32)\n    c: Bytes[1] = slice(self.bytez, 31, 1)\n    return c\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.dice() == b\"A\"\n\n\ndef test_slice_at_end(get_contract):\n    code = \"\"\"\n@external\ndef ret10_slice() -> Bytes[10]:\n    b: Bytes[32] = concat(convert(65, bytes32), b'')\n    c: Bytes[10] = slice(b, 31, 1)\n    return c\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.ret10_slice() == b\"A\"\n\n\ndef test_slice_expr(get_contract):\n    # test slice of a complex expression\n    code = \"\"\"\n@external\ndef ret10_slice() -> Bytes[10]:\n    return slice(convert(65, bytes32), 31, 1)\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.ret10_slice() == b\"A\"\n\n\ndef test_slice_equality(get_contract):\n    # test for equality with dirty bytes\n    code = \"\"\"\n@external\ndef assert_eq() -> bool:\n    dirty_bytes: String[4] = \"abcd\"\n    dirty_bytes = slice(dirty_bytes, 0, 3)\n    clean_bytes: String[4] = \"abc\"\n    return dirty_bytes == clean_bytes\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.assert_eq()\n\n\ndef test_slice_inequality(get_contract):\n    # test for equality with dirty bytes\n    code = \"\"\"\n@external\ndef assert_ne() -> bool:\n    dirty_bytes: String[4] = \"abcd\"\n    dirty_bytes = slice(dirty_bytes, 0, 3)\n    clean_bytes: String[4] = \"abcd\"\n    return dirty_bytes != clean_bytes\n    \"\"\"\n\n    c = get_contract(code)\n    assert c.assert_ne()\n\n\ndef test_slice_convert(get_contract):\n    # test slice of converting between bytes32 and Bytes\n    code = \"\"\"\n@external\ndef f() -> bytes32:\n    a: Bytes[100] = convert(\"ab\", Bytes[100])\n    return convert(slice(a, 0, 1), bytes32)\n    \"\"\"\n    c = get_contract(code)\n    assert c.f() == b\"a\" + b\"\\x00\" * 31\n\n\ncode_bytes32 = [\n    \"\"\"\nfoo: bytes32\n\n@external\ndef __init__():\n    self.foo = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n\n@external\ndef bar() -> Bytes[{length}]:\n    return slice(self.foo, {start}, {length})\n    \"\"\",\n    \"\"\"\nfoo: bytes32\n\n@external\ndef __init__():\n    self.foo = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n\n@external\ndef bar() -> Bytes[32]:\n    a: uint256 = {start}\n    b: uint256 = {length}\n    return slice(self.foo, a, b)\n    \"\"\",\n    f\"\"\"\nfoo: Bytes[32]\n\n@external\ndef bar() -> Bytes[32]:\n    self.foo = {_generate_bytes(32)}\n    a: uint256 = {{start}}\n    b: uint256 = {{length}}\n    return slice(convert(self.foo, bytes32), a, b)\n    \"\"\",\n    \"\"\"\n@external\ndef bar() -> Bytes[{length}]:\n    foo: bytes32 = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n    return slice(foo, {start}, {length})\n    \"\"\",\n    \"\"\"\n@external\ndef bar() -> Bytes[32]:\n    b: uint256 = {length}\n    foo: bytes32 = 0x000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\n    a: uint256 = {start}\n    return slice(foo, a, b)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"code\", code_bytes32)\n@pytest.mark.parametrize(\"start,length\", _fun_bytes32_bounds)\ndef test_slice_bytes32(get_contract, code, start, length):\n\n    c = get_contract(code.format(start=start, length=length))\n    assert c.bar() == _generate_bytes(32)[start : start + length]\n\n\ncode_bytes32_calldata = [\n    \"\"\"\n@external\ndef bar(foo: bytes32) -> Bytes[{length}]:\n    return slice(foo, {start}, {length})\n    \"\"\",\n    \"\"\"\n@external\ndef bar(foo: bytes32) -> Bytes[32]:\n    b: uint256 = {length}\n    a: uint256 = {start}\n    return slice(foo, a, b)\n    \"\"\",\n]\n\n\n@pytest.mark.parametrize(\"code\", code_bytes32_calldata)\n@pytest.mark.parametrize(\"start,length\", _fun_bytes32_bounds)\ndef test_slice_bytes32_calldata(get_contract, code, start, length):\n\n    c = get_contract(code.format(start=start, length=length))\n    assert c.bar(_generate_bytes(32)) == _generate_bytes(32)[start : start + length]\n\n\ncode_bytes32_calldata_extended = [\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, 3, 5)\n    \"\"\",\n        \"0304050607\",\n    ),\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, a, b)\n    \"\"\",\n        \"0304050607\",\n    ),\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, 31, b-4)\n    \"\"\",\n        \"31\",\n    ),\n    (\n        \"\"\"\n@external\ndef bar(a: uint256, foo: bytes32, b: uint256) -> Bytes[32]:\n    return slice(foo, 0, a+b)\n    \"\"\",\n        \"0001020304050607\",\n    ),\n]\n\n\n@pytest.mark.parametrize(\"code,result\", code_bytes32_calldata_extended)\ndef test_slice_bytes32_calldata_extended(get_contract, code, result):\n\n    c = get_contract(code)\n    assert (\n        c.bar(3, \"0x0001020304050607080910111213141516171819202122232425262728293031\", 5).hex()\n        == result\n    )\n", "import pytest\n\npytestmark = pytest.mark.usefixtures(\"memory_mocker\")\n\n\ndef test_string_return(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef testb() -> String[100]:\n    a: String[100] = \"test return\"\n    return a\n\n@external\ndef testa(inp: String[100]) -> String[100]:\n    return inp\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    assert c.testa(\"meh\") == \"meh\"\n    assert c.testb() == \"test return\"\n\n\ndef test_string_concat(get_contract_with_gas_estimation):\n    code = \"\"\"\n@external\ndef testb(inp: String[10]) -> String[128]:\n    a: String[100] = \"return message:\"\n    b: String[128] = concat(a, \" \", inp)\n    return b\n\n@external\ndef testa(inp: String[10]) -> String[160]:\n    a: String[100] = \"<-- return message\"\n    return concat(\"Funny \", inp, \" \", inp, a)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    assert c.testb(\"bob\") == \"return message: bob\"\n    assert c.testa(\"foo\") == \"Funny foo foo<-- return message\"\n\n\ndef test_basic_long_string_as_keys(get_contract, w3):\n    code = \"\"\"\nmapped_string: HashMap[String[34], int128]\n\n@external\ndef set(k: String[34], v: int128):\n    self.mapped_string[k] = v\n\n@external\ndef get(k: String[34]) -> int128:\n    return self.mapped_string[k]\n    \"\"\"\n\n    c = get_contract(code)\n\n    c.set(b\"a\" * 34, 6789, transact={\"gas\": 10 ** 6})\n\n    assert c.get(b\"a\" * 34) == 6789\n\n\ndef test_string_slice(get_contract_with_gas_estimation, assert_tx_failed):\n    test_slice4 = \"\"\"\n@external\ndef foo(inp: String[10], start: uint256, _len: uint256) -> String[10]:\n    return slice(inp, start, _len)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(test_slice4)\n    assert c.foo(\"badminton\", 3, 3) == \"min\"\n    assert c.foo(\"badminton\", 0, 9) == \"badminton\"\n    assert c.foo(\"badminton\", 1, 8) == \"adminton\"\n    assert c.foo(\"badminton\", 1, 7) == \"adminto\"\n    assert c.foo(\"badminton\", 1, 0) == \"\"\n    assert c.foo(\"badminton\", 9, 0) == \"\"\n\n    assert_tx_failed(lambda: c.foo(\"badminton\", 0, 10))\n    assert_tx_failed(lambda: c.foo(\"badminton\", 1, 9))\n    assert_tx_failed(lambda: c.foo(\"badminton\", 9, 1))\n    assert_tx_failed(lambda: c.foo(\"badminton\", 10, 0))\n\n\ndef test_private_string(get_contract_with_gas_estimation):\n    private_test_code = \"\"\"\ngreeting: public(String[100])\n\n@external\ndef __init__():\n    self.greeting = \"Hello \"\n\n@internal\ndef construct(greet: String[100]) -> String[200]:\n    return concat(self.greeting, greet)\n\n@external\ndef hithere(name: String[100]) -> String[200]:\n    d: String[200] = self.construct(name)\n    return d\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(private_test_code)\n    assert c.hithere(\"bob\") == \"Hello bob\"\n    assert c.hithere(\"alice\") == \"Hello alice\"\n\n\ndef test_logging_extended_string(get_contract_with_gas_estimation, get_logs):\n    code = \"\"\"\nevent MyLog:\n    arg1: int128\n    arg2: String[64]\n    arg3: int128\n\n@external\ndef foo():\n    log MyLog(667788, 'hellohellohellohellohellohellohellohellohello', 334455)\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    log = get_logs(c.foo(transact={}), c, \"MyLog\")\n\n    assert log[0].args.arg1 == 667788\n    assert log[0].args.arg2 == \"hello\" * 9\n    assert log[0].args.arg3 == 334455\n\n\ndef test_tuple_return_external_contract_call_string(get_contract_with_gas_estimation):\n    contract_1 = \"\"\"\n@external\ndef out_literals() -> (int128, address, String[10]):\n    return 1, 0x0000000000000000000000000000000000000123, \"random\"\n    \"\"\"\n\n    contract_2 = \"\"\"\ninterface Test:\n    def out_literals() -> (int128, address, String[10]) : view\n\n@external\ndef test(addr: address) -> (int128, address, String[10]):\n    a: int128 = 0\n    b: address = ZERO_ADDRESS\n    c: String[10] = \"\"\n    (a, b, c) = Test(addr).out_literals()\n    return a, b,c\n    \"\"\"\n    c1 = get_contract_with_gas_estimation(contract_1)\n    c2 = get_contract_with_gas_estimation(contract_2)\n\n    assert c1.out_literals() == [1, \"0x0000000000000000000000000000000000000123\", \"random\"]\n    assert c2.test(c1.address) == [1, \"0x0000000000000000000000000000000000000123\", \"random\"]\n\n\ndef test_default_arg_string(get_contract_with_gas_estimation):\n\n    code = \"\"\"\n@external\ndef test(a: uint256, b: String[50] = \"foo\") -> Bytes[100]:\n    return concat(\n        convert(a, bytes32),\n        convert(b, Bytes[50])\n    )\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n\n    assert c.test(12345)[-3:] == b\"foo\"\n    assert c.test(12345, \"bar\")[-3:] == b\"bar\"\n\n\nstring_equality_tests = [\n    (\n        100,\n        \"The quick brown fox jumps over the lazy dog\",\n        \"The quick brown fox jumps over the lazy hog\",\n    ),\n    # check <= 32 codepath\n    (32, \"abc\", \"abc\\0\"),\n    (32, \"abc\", \"abc\\1\"),  # use a_init dirty bytes\n    (32, \"abc\\2\", \"abc\"),  # use b_init dirty bytes\n    (32, \"\", \"\\0\"),\n    (32, \"\", \"\\1\"),\n    (33, \"\", \"\\1\"),\n    (33, \"\", \"\\0\"),\n]\n\n\n@pytest.mark.parametrize(\"len_,a,b\", string_equality_tests)\ndef test_string_equality(get_contract_with_gas_estimation, len_, a, b):\n    # fixtures to initialize strings with dirty bytes\n    a_init = \"\\\\1\" * len_\n    b_init = \"\\\\2\" * len_\n    string1 = a.encode(\"unicode_escape\").decode(\"utf-8\")\n    string2 = b.encode(\"unicode_escape\").decode(\"utf-8\")\n    code = f\"\"\"\na: String[{len_}]\nb: String[{len_}]\n\n@external\ndef equal_true() -> bool:\n    a: String[{len_}] = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    a = \"{string1}\"\n    b = \"{string1}\"\n    return a == b\n\n@external\ndef equal_false() -> bool:\n    a: String[{len_}] = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    a = \"{string1}\"\n    b = \"{string2}\"\n    return a == b\n\n@external\ndef not_equal_true() -> bool:\n    a: String[{len_}] = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    a = \"{string1}\"\n    b = \"{string2}\"\n    return a != b\n\n@external\ndef not_equal_false() -> bool:\n    a: String[{len_}] = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    a = \"{string1}\"\n    b = \"{string1}\"\n    return a != b\n\n@external\ndef literal_equal_true() -> bool:\n    return \"{string1}\" == \"{string1}\"\n\n@external\ndef literal_equal_false() -> bool:\n    return \"{string1}\" == \"{string2}\"\n\n@external\ndef literal_not_equal_true() -> bool:\n    return \"{string1}\" != \"{string2}\"\n\n@external\ndef literal_not_equal_false() -> bool:\n    return \"{string1}\" != \"{string1}\"\n\n@external\ndef storage_equal_true() -> bool:\n    self.a = \"{a_init}\"\n    self.b = \"{b_init}\"\n    self.a = \"{string1}\"\n    self.b = \"{string1}\"\n    return self.a == self.b\n\n@external\ndef storage_equal_false() -> bool:\n    self.a = \"{a_init}\"\n    self.b = \"{b_init}\"\n    self.a = \"{string1}\"\n    self.b = \"{string2}\"\n    return self.a == self.b\n\n@external\ndef storage_not_equal_true() -> bool:\n    self.a = \"{a_init}\"\n    self.b = \"{b_init}\"\n    self.a = \"{string1}\"\n    self.b = \"{string2}\"\n    return self.a != self.b\n\n@external\ndef storage_not_equal_false() -> bool:\n    self.a = \"{a_init}\"\n    self.b = \"{b_init}\"\n    self.a = \"{string1}\"\n    self.b = \"{string1}\"\n    return self.a != self.b\n\n@external\ndef string_compare_equal(str1: String[{len_}], str2: String[{len_}]) -> bool:\n    return str1 == str2\n\n@external\ndef string_compare_not_equal(str1: String[{len_}], str2: String[{len_}]) -> bool:\n    return str1 != str2\n\n@external\ndef compare_passed_storage_equal(str_: String[{len_}]) -> bool:\n    self.a = \"{a_init}\"\n    self.a = \"{string1}\"\n    return self.a == str_\n\n@external\ndef compare_passed_storage_not_equal(str_: String[{len_}]) -> bool:\n    self.a = \"{a_init}\"\n    self.a = \"{string1}\"\n    return self.a != str_\n\n@external\ndef compare_var_storage_equal_true() -> bool:\n    self.a = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    self.a = \"{string1}\"\n    b = \"{string1}\"\n    return self.a == b\n\n@external\ndef compare_var_storage_equal_false() -> bool:\n    self.a = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    self.a = \"{string1}\"\n    b = \"{string2}\"\n    return self.a == b\n\n@external\ndef compare_var_storage_not_equal_true() -> bool:\n    self.a = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    self.a = \"{string1}\"\n    b = \"{string2}\"\n    return self.a != b\n\n@external\ndef compare_var_storage_not_equal_false() -> bool:\n    self.a = \"{a_init}\"\n    b: String[{len_}] = \"{b_init}\"\n    self.a = \"{string1}\"\n    b = \"{string1}\"\n    return self.a != b\n    \"\"\"\n\n    c = get_contract_with_gas_estimation(code)\n    assert c.equal_true() is True\n    assert c.equal_false() is False\n    assert c.not_equal_true() is True\n    assert c.not_equal_false() is False\n    assert c.literal_equal_true() is True\n    assert c.literal_equal_false() is False\n    assert c.literal_not_equal_true() is True\n    assert c.literal_not_equal_false() is False\n    assert c.storage_equal_true() is True\n    assert c.storage_equal_false() is False\n    assert c.storage_not_equal_true() is True\n    assert c.storage_not_equal_false() is False\n\n    assert c.string_compare_equal(a, a) is True\n    assert c.string_compare_equal(a, b) is False\n    assert c.string_compare_not_equal(b, a) is True\n    assert c.string_compare_not_equal(b, b) is False\n\n    assert c.compare_passed_storage_equal(a) is True\n    assert c.compare_passed_storage_equal(b) is False\n    assert c.compare_passed_storage_not_equal(a) is False\n    assert c.compare_passed_storage_not_equal(b) is True\n\n    assert c.compare_var_storage_equal_true() is True\n    assert c.compare_var_storage_equal_false() is False\n    assert c.compare_var_storage_not_equal_true() is True\n    assert c.compare_var_storage_not_equal_false() is False\n", "from vyper import ast as vy_ast\nfrom vyper.address_space import CALLDATA, DATA, IMMUTABLES, MEMORY, STORAGE\nfrom vyper.codegen.ir_node import Encoding, IRnode\nfrom vyper.codegen.types import (\n    DYNAMIC_ARRAY_OVERHEAD,\n    ArrayLike,\n    BaseType,\n    ByteArrayLike,\n    DArrayType,\n    MappingType,\n    SArrayType,\n    StructType,\n    TupleLike,\n    TupleType,\n    ceil32,\n    is_bytes_m_type,\n    is_decimal_type,\n    is_integer_type,\n)\nfrom vyper.evm.opcodes import version_check\nfrom vyper.exceptions import CompilerPanic, StructureException, TypeCheckFailure, TypeMismatch\nfrom vyper.utils import GAS_CALLDATACOPY_WORD, GAS_CODECOPY_WORD, GAS_IDENTITY, GAS_IDENTITYWORD\n\n\n# propagate revert message when calls to external contracts fail\ndef check_external_call(call_ir):\n    copy_revertdata = [\"returndatacopy\", 0, 0, \"returndatasize\"]\n    revert = [\"revert\", 0, \"returndatasize\"]\n\n    propagate_revert_ir = [\"seq\", copy_revertdata, revert]\n    return [\"if\", [\"iszero\", call_ir], propagate_revert_ir]\n\n\n# cost per byte of the identity precompile\ndef _identity_gas_bound(num_bytes):\n    return GAS_IDENTITY + GAS_IDENTITYWORD * (ceil32(num_bytes) // 32)\n\n\ndef _calldatacopy_gas_bound(num_bytes):\n    return GAS_CALLDATACOPY_WORD * ceil32(num_bytes) // 32\n\n\ndef _codecopy_gas_bound(num_bytes):\n    return GAS_CODECOPY_WORD * ceil32(num_bytes) // 32\n\n\n# Copy byte array word-for-word (including layout)\ndef make_byte_array_copier(dst, src):\n    assert isinstance(src.typ, ByteArrayLike)\n    assert isinstance(dst.typ, ByteArrayLike)\n\n    if src.typ.maxlen > dst.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from {src.typ} to {dst.typ}\")\n    # stricter check for zeroing a byte array.\n    if src.value == \"~empty\" and src.typ.maxlen != dst.typ.maxlen:\n        raise TypeMismatch(\n            f\"Bad type for clearing bytes: expected {dst.typ} but got {src.typ}\"\n        )  # pragma: notest\n\n    if src.value == \"~empty\":\n        # set length word to 0.\n        return STORE(dst, 0)\n\n    with src.cache_when_complex(\"src\") as (b1, src):\n        with get_bytearray_length(src).cache_when_complex(\"len\") as (b2, len_):\n\n            max_bytes = src.typ.maxlen\n\n            ret = [\"seq\"]\n            # store length\n            ret.append(STORE(dst, len_))\n\n            dst = bytes_data_ptr(dst)\n            src = bytes_data_ptr(src)\n\n            ret.append(copy_bytes(dst, src, len_, max_bytes))\n            return b1.resolve(b2.resolve(ret))\n\n\ndef bytes_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, ByteArrayLike)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef dynarray_data_ptr(ptr):\n    if ptr.location is None:\n        raise CompilerPanic(\"tried to modify non-pointer type\")\n    assert isinstance(ptr.typ, DArrayType)\n    return add_ofst(ptr, ptr.location.word_scale)\n\n\ndef _dynarray_make_setter(dst, src):\n    assert isinstance(src.typ, DArrayType)\n    assert isinstance(dst.typ, DArrayType)\n\n    if src.value == \"~empty\":\n        return IRnode.from_list(STORE(dst, 0))\n\n    if src.value == \"multi\":\n        ret = [\"seq\"]\n        # handle literals\n\n        # write the length word\n        store_length = STORE(dst, len(src.args))\n        ann = None\n        if src.annotation is not None:\n            ann = f\"len({src.annotation})\"\n        store_length = IRnode.from_list(store_length, annotation=ann)\n        ret.append(store_length)\n\n        n_items = len(src.args)\n        for i in range(n_items):\n            k = IRnode.from_list(i, typ=\"uint256\")\n            dst_i = get_element_ptr(dst, k, array_bounds_check=False)\n            src_i = get_element_ptr(src, k, array_bounds_check=False)\n            ret.append(make_setter(dst_i, src_i))\n\n        return ret\n\n    with src.cache_when_complex(\"darray_src\") as (b1, src):\n\n        # for ABI-encoded dynamic data, we must loop to unpack, since\n        # the layout does not match our memory layout\n        should_loop = (\n            src.encoding in (Encoding.ABI, Encoding.JSON_ABI)\n            and src.typ.subtype.abi_type.is_dynamic()\n        )\n\n        # if the subtype is dynamic, there might be a lot of\n        # unused space inside of each element. for instance\n        # DynArray[DynArray[uint256, 100], 5] where all the child\n        # arrays are empty - for this case, we recursively call\n        # into make_setter instead of straight bytes copy\n        # TODO we can make this heuristic more precise, e.g.\n        # loop when subtype.is_dynamic AND location == storage\n        # OR array_size <= /bound where loop is cheaper than memcpy/\n        should_loop |= src.typ.subtype.abi_type.is_dynamic()\n        should_loop |= needs_clamp(src.typ.subtype, src.encoding)\n\n        with get_dyn_array_count(src).cache_when_complex(\"darray_count\") as (b2, count):\n            ret = [\"seq\"]\n\n            ret.append(STORE(dst, count))\n\n            if should_loop:\n                i = IRnode.from_list(_freshname(\"copy_darray_ix\"), typ=\"uint256\")\n\n                loop_body = make_setter(\n                    get_element_ptr(dst, i, array_bounds_check=False),\n                    get_element_ptr(src, i, array_bounds_check=False),\n                )\n                loop_body.annotation = f\"{dst}[i] = {src}[i]\"\n\n                ret.append([\"repeat\", i, 0, count, src.typ.count, loop_body])\n\n            else:\n                element_size = src.typ.subtype.memory_bytes_required\n                # number of elements * size of element in bytes\n                n_bytes = _mul(count, element_size)\n                max_bytes = src.typ.count * element_size\n\n                src_ = dynarray_data_ptr(src)\n                dst_ = dynarray_data_ptr(dst)\n                ret.append(copy_bytes(dst_, src_, n_bytes, max_bytes))\n\n            return b1.resolve(b2.resolve(ret))\n\n\n# Copy bytes\n# Accepts 4 arguments:\n# (i) an IR node for the start position of the source\n# (ii) an IR node for the start position of the destination\n# (iii) an IR node for the length (in bytes)\n# (iv) a constant for the max length (in bytes)\n# NOTE: may pad to ceil32 of `length`! If you ask to copy 1 byte, it may\n# copy an entire (32-byte) word, depending on the copy routine chosen.\n# TODO maybe always pad to ceil32, to reduce dirty bytes bugs\ndef copy_bytes(dst, src, length, length_bound):\n    annotation = f\"copy_bytes from {src} to {dst}\"\n\n    src = IRnode.from_list(src)\n    dst = IRnode.from_list(dst)\n    length = IRnode.from_list(length)\n\n    with src.cache_when_complex(\"src\") as (b1, src), length.cache_when_complex(\n        \"copy_bytes_count\"\n    ) as (b2, length), dst.cache_when_complex(\"dst\") as (b3, dst):\n\n        # fast code for common case where num bytes is small\n        # TODO expand this for more cases where num words is less than ~8\n        if length_bound <= 32:\n            copy_op = STORE(dst, LOAD(src))\n            ret = IRnode.from_list(copy_op, annotation=annotation)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == MEMORY and src.location in (MEMORY, CALLDATA, DATA):\n            # special cases: batch copy to memory\n            # TODO: iloadbytes\n            if src.location == MEMORY:\n                copy_op = [\"staticcall\", \"gas\", 4, src, length, dst, length]\n                gas_bound = _identity_gas_bound(length_bound)\n            elif src.location == CALLDATA:\n                copy_op = [\"calldatacopy\", dst, src, length]\n                gas_bound = _calldatacopy_gas_bound(length_bound)\n            elif src.location == DATA:\n                copy_op = [\"dloadbytes\", dst, src, length]\n                # note: dloadbytes compiles to CODECOPY\n                gas_bound = _codecopy_gas_bound(length_bound)\n\n            ret = IRnode.from_list(copy_op, annotation=annotation, add_gas_estimate=gas_bound)\n            return b1.resolve(b2.resolve(b3.resolve(ret)))\n\n        if dst.location == IMMUTABLES and src.location in (MEMORY, DATA):\n            # TODO istorebytes-from-mem, istorebytes-from-calldata(?)\n            # compile to identity, CODECOPY respectively.\n            pass\n\n        # general case, copy word-for-word\n        # pseudocode for our approach (memory-storage as example):\n        # for i in range(len, bound=MAX_LEN):\n        #   sstore(_dst + i, mload(src + i * 32))\n        i = IRnode.from_list(_freshname(\"copy_bytes_ix\"), typ=\"uint256\")\n\n        n = [\"div\", [\"ceil32\", length], 32]\n        n_bound = ceil32(length_bound) // 32\n\n        dst_i = add_ofst(dst, _mul(i, dst.location.word_scale))\n        src_i = add_ofst(src, _mul(i, src.location.word_scale))\n\n        copy_one_word = STORE(dst_i, LOAD(src_i))\n\n        main_loop = [\"repeat\", i, 0, n, n_bound, copy_one_word]\n\n        return b1.resolve(\n            b2.resolve(b3.resolve(IRnode.from_list(main_loop, annotation=annotation)))\n        )\n\n\n# get the number of bytes at runtime\ndef get_bytearray_length(arg):\n    typ = BaseType(\"uint256\")\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\n# get the number of elements at runtime\ndef get_dyn_array_count(arg):\n    assert isinstance(arg.typ, DArrayType)\n\n    typ = BaseType(\"uint256\")\n\n    if arg.value == \"multi\":\n        return IRnode.from_list(len(arg.args), typ=typ)\n\n    if arg.value == \"~empty\":\n        # empty(DynArray[])\n        return IRnode.from_list(0, typ=typ)\n\n    return IRnode.from_list(LOAD(arg), typ=typ)\n\n\ndef append_dyn_array(darray_node, elem_node):\n    assert isinstance(darray_node.typ, DArrayType)\n\n    assert darray_node.typ.count > 0, \"jerk boy u r out\"\n\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        len_ = get_dyn_array_count(darray_node)\n        with len_.cache_when_complex(\"old_darray_len\") as (b2, len_):\n            ret.append([\"assert\", [\"le\", len_, darray_node.typ.count - 1]])\n            ret.append(STORE(darray_node, [\"add\", len_, 1]))\n            # NOTE: typechecks elem_node\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            ret.append(\n                make_setter(get_element_ptr(darray_node, len_, array_bounds_check=False), elem_node)\n            )\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)))\n\n\ndef pop_dyn_array(darray_node, return_popped_item):\n    assert isinstance(darray_node.typ, DArrayType)\n    ret = [\"seq\"]\n    with darray_node.cache_when_complex(\"darray\") as (b1, darray_node):\n        old_len = [\"clamp_nonzero\", get_dyn_array_count(darray_node)]\n        new_len = IRnode.from_list([\"sub\", old_len, 1], typ=\"uint256\")\n\n        with new_len.cache_when_complex(\"new_len\") as (b2, new_len):\n            ret.append(STORE(darray_node, new_len))\n\n            # NOTE skip array bounds check bc we already asserted len two lines up\n            if return_popped_item:\n                popped_item = get_element_ptr(darray_node, new_len, array_bounds_check=False)\n                ret.append(popped_item)\n                typ = popped_item.typ\n                location = popped_item.location\n                encoding = popped_item.encoding\n            else:\n                typ, location, encoding = None, None, None\n            return IRnode.from_list(\n                b1.resolve(b2.resolve(ret)), typ=typ, location=location, encoding=encoding\n            )\n\n\ndef getpos(node):\n    return (\n        node.lineno,\n        node.col_offset,\n        getattr(node, \"end_lineno\", None),\n        getattr(node, \"end_col_offset\", None),\n    )\n\n\n# TODO since this is always(?) used as add_ofst(ptr, n*ptr.location.word_scale)\n# maybe the API should be `add_words_to_ofst(ptr, n)` and handle the\n# word_scale multiplication inside\ndef add_ofst(ptr, ofst):\n    ofst = IRnode.from_list(ofst)\n    if isinstance(ptr.value, int) and isinstance(ofst.value, int):\n        # NOTE: duplicate with optimizer rule (but removing this makes a\n        # test on --no-optimize mode use too much gas)\n        ret = ptr.value + ofst.value\n    else:\n        ret = [\"add\", ptr, ofst]\n    return IRnode.from_list(ret, location=ptr.location, encoding=ptr.encoding)\n\n\n# shorthand util\ndef _mul(x, y):\n    x, y = IRnode.from_list(x), IRnode.from_list(y)\n    # NOTE: similar deal: duplicate with optimizer rule\n    if isinstance(x.value, int) and isinstance(y.value, int):\n        ret = x.value * y.value\n    else:\n        ret = [\"mul\", x, y]\n    return IRnode.from_list(ret)\n\n\n# Resolve pointer locations for ABI-encoded data\ndef _getelemptr_abi_helper(parent, member_t, ofst, clamp=True):\n    member_abi_t = member_t.abi_type\n\n    # ABI encoding has length word and then pretends length is not there\n    # e.g. [[1,2]] is encoded as 0x01 <len> 0x20 <inner array ofst> <encode(inner array)>\n    # note that inner array ofst is 0x20, not 0x40.\n    if has_length_word(parent.typ):\n        parent = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n\n    ofst_ir = add_ofst(parent, ofst)\n\n    if member_abi_t.is_dynamic():\n        # double dereference, according to ABI spec\n        # TODO optimize special case: first dynamic item\n        # offset is statically known.\n        ofst_ir = add_ofst(parent, unwrap_location(ofst_ir))\n\n    return IRnode.from_list(\n        ofst_ir,\n        typ=member_t,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=f\"{parent}{ofst}\",\n    )\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_tuplelike(parent, key):\n    typ = parent.typ\n    assert isinstance(typ, TupleLike)\n\n    if isinstance(typ, StructType):\n        assert isinstance(key, str)\n        subtype = typ.members[key]\n        attrs = list(typ.tuple_keys())\n        index = attrs.index(key)\n        annotation = key\n    else:\n        assert isinstance(key, int)\n        subtype = typ.members[key]\n        attrs = list(range(len(typ.members)))\n        index = key\n        annotation = None\n\n    # generated by empty() + make_setter\n    if parent.value == \"~empty\":\n        return IRnode.from_list(\"~empty\", typ=subtype)\n\n    if parent.value == \"multi\":\n        assert parent.encoding != Encoding.ABI, \"no abi-encoded literals\"\n        return parent.args[index]\n\n    ofst = 0  # offset from parent start\n\n    if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_t = typ.members[attrs[index]]\n\n        for i in range(index):\n            member_abi_t = typ.members[attrs[i]].abi_type\n            ofst += member_abi_t.embedded_static_size()\n\n        return _getelemptr_abi_helper(parent, member_t, ofst)\n\n    if parent.location.word_addressable:\n        for i in range(index):\n            ofst += typ.members[attrs[i]].storage_size_in_words\n    elif parent.location.byte_addressable:\n        for i in range(index):\n            ofst += typ.members[attrs[i]].memory_bytes_required\n    else:\n        raise CompilerPanic(f\"bad location {parent.location}\")  # pragma: notest\n\n    return IRnode.from_list(\n        add_ofst(parent, ofst),\n        typ=subtype,\n        location=parent.location,\n        encoding=parent.encoding,\n        annotation=annotation,\n    )\n\n\ndef has_length_word(typ):\n    return isinstance(typ, (DArrayType, ByteArrayLike))\n\n\n# TODO simplify this code, especially the ABI decoding\ndef _get_element_ptr_array(parent, key, array_bounds_check):\n\n    assert isinstance(parent.typ, ArrayLike)\n\n    if not is_integer_type(key.typ):\n        raise TypeCheckFailure(f\"{key.typ} used as array index\")\n\n    subtype = parent.typ.subtype\n\n    if parent.value == \"~empty\":\n        if array_bounds_check:\n            # this case was previously missing a bounds check. codegen\n            # is a bit complicated when bounds check is required, so\n            # block it. there is no reason to index into a literal empty\n            # array anyways!\n            raise TypeCheckFailure(\"indexing into zero array not allowed\")\n        return IRnode.from_list(\"~empty\", subtype)\n\n    if parent.value == \"multi\":\n        assert isinstance(key.value, int)\n        return parent.args[key.value]\n\n    ix = unwrap_location(key)\n\n    if array_bounds_check:\n        # clamplt works, even for signed ints. since two's-complement\n        # is used, if the index is negative, (unsigned) LT will interpret\n        # it as a very large number, larger than any practical value for\n        # an array index, and the clamp will throw an error.\n        clamp_op = \"uclamplt\"\n        is_darray = isinstance(parent.typ, DArrayType)\n        bound = get_dyn_array_count(parent) if is_darray else parent.typ.count\n        # NOTE: there are optimization rules for this when ix or bound is literal\n        ix = IRnode.from_list([clamp_op, ix, bound], typ=ix.typ)\n\n    if parent.encoding in (Encoding.ABI, Encoding.JSON_ABI):\n        if parent.location == STORAGE:\n            raise CompilerPanic(\"storage variables should not be abi encoded\")  # pragma: notest\n\n        member_abi_t = subtype.abi_type\n\n        ofst = _mul(ix, member_abi_t.embedded_static_size())\n\n        return _getelemptr_abi_helper(parent, subtype, ofst)\n\n    if parent.location.word_addressable:\n        element_size = subtype.storage_size_in_words\n    elif parent.location.byte_addressable:\n        element_size = subtype.memory_bytes_required\n    else:\n        raise CompilerPanic(\"unreachable\")  # pragma: notest\n\n    ofst = _mul(ix, element_size)\n\n    if has_length_word(parent.typ):\n        data_ptr = add_ofst(parent, parent.location.word_scale * DYNAMIC_ARRAY_OVERHEAD)\n    else:\n        data_ptr = parent\n\n    return IRnode.from_list(add_ofst(data_ptr, ofst), typ=subtype, location=parent.location)\n\n\ndef _get_element_ptr_mapping(parent, key):\n    assert isinstance(parent.typ, MappingType)\n    subtype = parent.typ.valuetype\n    key = unwrap_location(key)\n\n    # TODO when is key None?\n    if key is None or parent.location != STORAGE:\n        raise TypeCheckFailure(\"bad dereference on mapping {parent}[{sub}]\")\n\n    return IRnode.from_list([\"sha3_64\", parent, key], typ=subtype, location=STORAGE)\n\n\n# Take a value representing a memory or storage location, and descend down to\n# an element or member variable\n# This is analogous (but not necessarily equivalent to) getelementptr in LLVM.\ndef get_element_ptr(parent, key, array_bounds_check=True):\n    with parent.cache_when_complex(\"val\") as (b, parent):\n        typ = parent.typ\n\n        if isinstance(typ, TupleLike):\n            ret = _get_element_ptr_tuplelike(parent, key)\n\n        elif isinstance(typ, MappingType):\n            ret = _get_element_ptr_mapping(parent, key)\n\n        elif isinstance(typ, ArrayLike):\n            ret = _get_element_ptr_array(parent, key, array_bounds_check)\n\n        else:\n            raise CompilerPanic(f\"get_element_ptr cannot be called on {typ}\")  # pragma: notest\n\n        return b.resolve(ret)\n\n\ndef LOAD(ptr: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.load_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n    return IRnode.from_list([op, ptr])\n\n\ndef STORE(ptr: IRnode, val: IRnode) -> IRnode:\n    if ptr.location is None:\n        raise CompilerPanic(\"cannot dereference non-pointer type\")\n    op = ptr.location.store_op\n    if op is None:\n        raise CompilerPanic(f\"unreachable {ptr.location}\")  # pragma: notest\n    return IRnode.from_list([op, ptr, val])\n\n\n# Unwrap location\ndef unwrap_location(orig):\n    if orig.location is not None:\n        return IRnode.from_list(LOAD(orig), typ=orig.typ)\n    else:\n        # CMC 2022-03-24 TODO refactor so this branch can be removed\n        if orig.value == \"~empty\":\n            return IRnode.from_list(0, typ=orig.typ)\n        return orig\n\n\n# utility function, constructs an IR tuple out of a list of IR nodes\ndef ir_tuple_from_args(args):\n    typ = TupleType([x.typ for x in args])\n    return IRnode.from_list([\"multi\"] + [x for x in args], typ=typ)\n\n\ndef _needs_external_call_wrap(ir_typ):\n    # for calls to ABI conforming contracts.\n    # according to the ABI spec, return types are ALWAYS tuples even\n    # if only one element is being returned.\n    # https://solidity.readthedocs.io/en/latest/abi-spec.html#function-selector-and-argument-encoding\n    # \"and the return values v_1, ..., v_k of f are encoded as\n    #\n    #    enc((v_1, ..., v_k))\n    #    i.e. the values are combined into a tuple and encoded.\n    # \"\n    # therefore, wrap it in a tuple if it's not already a tuple.\n    # for example, `bytes` is returned as abi-encoded (bytes,)\n    # and `(bytes,)` is returned as abi-encoded ((bytes,),)\n    # In general `-> X` gets returned as (X,)\n    # including structs. MyStruct is returned as abi-encoded (MyStruct,).\n    # (Sorry this is so confusing. I didn't make these rules.)\n\n    return not (isinstance(ir_typ, TupleType) and len(ir_typ.members) > 1)\n\n\ndef calculate_type_for_external_return(ir_typ):\n    if _needs_external_call_wrap(ir_typ):\n        return TupleType([ir_typ])\n    return ir_typ\n\n\ndef wrap_value_for_external_return(ir_val):\n    # used for LHS promotion\n    if _needs_external_call_wrap(ir_val.typ):\n        return ir_tuple_from_args([ir_val])\n    else:\n        return ir_val\n\n\ndef set_type_for_external_return(ir_val):\n    # used for RHS promotion\n    ir_val.typ = calculate_type_for_external_return(ir_val.typ)\n\n\n# return a dummy IRnode with the given type\ndef dummy_node_for_type(typ):\n    return IRnode(\"fake_node\", typ=typ)\n\n\ndef _check_assign_bytes(left, right):\n    if right.typ.maxlen > left.typ.maxlen:\n        raise TypeMismatch(f\"Cannot cast from {right.typ} to {left.typ}\")  # pragma: notest\n    # stricter check for zeroing a byte array.\n    if right.value == \"~empty\" and right.typ.maxlen != left.typ.maxlen:\n        raise TypeMismatch(\n            f\"Bad type for clearing bytes: expected {left.typ} but got {right.typ}\"\n        )  # pragma: notest\n\n\ndef _check_assign_list(left, right):\n    def FAIL():  # pragma: nocover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if left.value == \"multi\":\n        # Cannot do something like [a, b, c] = [1, 2, 3]\n        FAIL()  # pragma: notest\n\n    if isinstance(left, SArrayType):\n        if not isinstance(right, SArrayType):\n            FAIL()  # pragma: notest\n        if left.typ.count != right.typ.count:\n            FAIL()  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(dummy_node_for_type(left.typ.subtyp), dummy_node_for_type(right.typ.subtyp))\n\n    if isinstance(left, DArrayType):\n        if not isinstance(right, DArrayType):\n            FAIL()  # pragma: notest\n\n        if left.typ.count < right.typ.count:\n            FAIL()  # pragma: notest\n\n        # stricter check for zeroing\n        if right.value == \"~empty\" and right.typ.count != left.typ.count:\n            raise TypeCheckFailure(\n                f\"Bad type for clearing bytes: expected {left.typ} but got {right.typ}\"\n            )  # pragma: notest\n\n        # TODO recurse into left, right if literals?\n        check_assign(dummy_node_for_type(left.typ.subtyp), dummy_node_for_type(right.typ.subtyp))\n\n\ndef _check_assign_tuple(left, right):\n    def FAIL():  # pragma: nocover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ}\")\n\n    if not isinstance(right.typ, left.typ.__class__):\n        FAIL()  # pragma: notest\n\n    if isinstance(left.typ, StructType):\n        for k in left.typ.members:\n            if k not in right.typ.members:\n                FAIL()  # pragma: notest\n            # TODO recurse into left, right if literals?\n            check_assign(\n                dummy_node_for_type(left.typ.members[k]),\n                dummy_node_for_type(right.typ.members[k]),\n            )\n\n        for k in right.typ.members:\n            if k not in left.typ.members:\n                FAIL()  # pragma: notest\n\n        if left.typ.name != right.typ.name:\n            FAIL()  # pragma: notest\n\n    else:\n        if len(left.typ.members) != len(right.typ.members):\n            FAIL()  # pragma: notest\n        for (l, r) in zip(left.typ.members, right.typ.members):\n            # TODO recurse into left, right if literals?\n            check_assign(dummy_node_for_type(l), dummy_node_for_type(r))\n\n\n# sanity check an assignment\n# typechecking source code is done at an earlier phase\n# this function is more of a sanity check for typechecking internally\n# generated assignments\ndef check_assign(left, right):\n    def FAIL():  # pragma: nocover\n        raise TypeCheckFailure(f\"assigning {right.typ} to {left.typ} {left} {right}\")\n\n    if isinstance(left.typ, ByteArrayLike):\n        _check_assign_bytes(left, right)\n    elif isinstance(left.typ, ArrayLike):\n        _check_assign_list(left, right)\n    elif isinstance(left.typ, TupleLike):\n        _check_assign_tuple(left, right)\n\n    elif isinstance(left.typ, BaseType):\n        # TODO once we propagate types from typechecker, introduce this check:\n        # if left.typ != right.typ:\n        #    FAIL()  # pragma: notest\n        pass\n\n    else:  # pragma: nocover\n        FAIL()\n\n\n_label = 0\n\n\n# TODO might want to coalesce with Context.fresh_varname and compile_ir.mksymbol\ndef _freshname(name):\n    global _label\n    _label += 1\n    return f\"{name}{_label}\"\n\n\n# returns True if t is ABI encoded and is a type that needs any kind of\n# validation\ndef needs_clamp(t, encoding):\n    if encoding not in (Encoding.ABI, Encoding.JSON_ABI):\n        return False\n    if isinstance(t, (ByteArrayLike, DArrayType)):\n        if encoding == Encoding.JSON_ABI:\n            # don't have bytestring size bound from json, don't clamp\n            return False\n        return True\n    if isinstance(t, BaseType) and t.typ not in (\"int256\", \"uint256\", \"bytes32\"):\n        return True\n    if isinstance(t, SArrayType):\n        return needs_clamp(t.subtype, encoding)\n    if isinstance(t, TupleLike):\n        return any(needs_clamp(m, encoding) for m in t.tuple_members())\n    return False\n\n\n# Create an x=y statement, where the types may be compound\ndef make_setter(left, right):\n    check_assign(left, right)\n\n    # Basic types\n    if isinstance(left.typ, BaseType):\n        enc = right.encoding  # unwrap_location butchers encoding\n        right = unwrap_location(right)\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, enc):\n            right = clamp_basetype(right)\n\n        return STORE(left, right)\n\n    # Byte arrays\n    elif isinstance(left.typ, ByteArrayLike):\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"bs_ptr\") as (b, right):\n                copier = make_byte_array_copier(left, right)\n                ret = b.resolve([\"seq\", clamp_bytestring(right), copier])\n        else:\n            ret = make_byte_array_copier(left, right)\n\n        return IRnode.from_list(ret)\n\n    elif isinstance(left.typ, DArrayType):\n        # TODO should we enable this?\n        # implicit conversion from sarray to darray\n        # if isinstance(right.typ, SArrayType):\n        #    return _complex_make_setter(left, right)\n\n        # TODO rethink/streamline the clamp_basetype logic\n        if needs_clamp(right.typ, right.encoding):\n            with right.cache_when_complex(\"arr_ptr\") as (b, right):\n                copier = _dynarray_make_setter(left, right)\n                ret = b.resolve([\"seq\", clamp_dyn_array(right), copier])\n        else:\n            ret = _dynarray_make_setter(left, right)\n\n        return IRnode.from_list(ret)\n\n    # Arrays\n    elif isinstance(left.typ, (SArrayType, TupleLike)):\n        return _complex_make_setter(left, right)\n\n\ndef _complex_make_setter(left, right):\n    if right.value == \"~empty\" and left.location == MEMORY:\n        # optimized memzero\n        return mzero(left, left.typ.memory_bytes_required)\n\n    ret = [\"seq\"]\n\n    if isinstance(left.typ, SArrayType):\n        n_items = right.typ.count\n        keys = [IRnode.from_list(i, typ=\"uint256\") for i in range(n_items)]\n\n    if isinstance(left.typ, TupleLike):\n        keys = left.typ.tuple_keys()\n\n    # if len(keyz) == 0:\n    #    return IRnode.from_list([\"pass\"])\n\n    # general case\n    # TODO use copy_bytes when the generated code is above a certain size\n    with left.cache_when_complex(\"_L\") as (b1, left), right.cache_when_complex(\"_R\") as (b2, right):\n\n        for k in keys:\n            l_i = get_element_ptr(left, k, array_bounds_check=False)\n            r_i = get_element_ptr(right, k, array_bounds_check=False)\n            ret.append(make_setter(l_i, r_i))\n\n        return b1.resolve(b2.resolve(IRnode.from_list(ret)))\n\n\ndef ensure_in_memory(ir_var, context):\n    \"\"\"Ensure a variable is in memory. This is useful for functions\n    which expect to operate on memory variables.\n    \"\"\"\n    if ir_var.location == MEMORY:\n        return ir_var\n\n    typ = ir_var.typ\n    buf = IRnode.from_list(context.new_internal_variable(typ), typ=typ, location=MEMORY)\n    do_copy = make_setter(buf, ir_var)\n\n    return IRnode.from_list([\"seq\", do_copy, buf], typ=typ, location=MEMORY)\n\n\ndef eval_seq(ir_node):\n    \"\"\"Tries to find the \"return\" value of a `seq` statement, in order so\n    that the value can be known without possibly evaluating side effects\n    \"\"\"\n    if ir_node.value in (\"seq\", \"with\") and len(ir_node.args) > 0:\n        return eval_seq(ir_node.args[-1])\n    if isinstance(ir_node.value, int):\n        return IRnode.from_list(ir_node)\n    return None\n\n\n# TODO move return checks to vyper/semantics/validation\ndef is_return_from_function(node):\n    if isinstance(node, vy_ast.Expr) and node.get(\"value.func.id\") == \"selfdestruct\":\n        return True\n    if isinstance(node, vy_ast.Return):\n        return True\n    elif isinstance(node, vy_ast.Raise):\n        return True\n    else:\n        return False\n\n\ndef check_single_exit(fn_node):\n    _check_return_body(fn_node, fn_node.body)\n    for node in fn_node.get_descendants(vy_ast.If):\n        _check_return_body(node, node.body)\n        if node.orelse:\n            _check_return_body(node, node.orelse)\n\n\ndef _check_return_body(node, node_list):\n    return_count = len([n for n in node_list if is_return_from_function(n)])\n    if return_count > 1:\n        raise StructureException(\n            \"Too too many exit statements (return, raise or selfdestruct).\", node\n        )\n    # Check for invalid code after returns.\n    last_node_pos = len(node_list) - 1\n    for idx, n in enumerate(node_list):\n        if is_return_from_function(n) and idx < last_node_pos:\n            # is not last statement in body.\n            raise StructureException(\n                \"Exit statement with succeeding code (that will not execute).\", node_list[idx + 1]\n            )\n\n\ndef mzero(dst, nbytes):\n    # calldatacopy from past-the-end gives zero bytes.\n    # cf. YP H.2 (ops section) with CALLDATACOPY spec.\n    return IRnode.from_list(\n        # calldatacopy mempos calldatapos len\n        [\"calldatacopy\", dst, \"calldatasize\", nbytes],\n        annotation=\"mzero\",\n    )\n\n\n# zero pad a bytearray according to the ABI spec. The last word\n# of the byte array needs to be right-padded with zeroes.\ndef zero_pad(bytez_placeholder):\n    len_ = [\"mload\", bytez_placeholder]\n    dst = [\"add\", [\"add\", bytez_placeholder, 32], \"len\"]\n    # the runtime length of the data rounded up to nearest 32\n    # from spec:\n    #   the actual value of X as a byte sequence,\n    #   followed by the *minimum* number of zero-bytes\n    #   such that len(enc(X)) is a multiple of 32.\n    num_zero_bytes = [\"sub\", [\"ceil32\", \"len\"], \"len\"]\n    return IRnode.from_list(\n        [\"with\", \"len\", len_, [\"with\", \"dst\", dst, mzero(\"dst\", num_zero_bytes)]],\n        annotation=\"Zero pad\",\n    )\n\n\n# convenience rewrites for shr/sar/shl\ndef shr(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shr\", bits, x]\n    return [\"div\", x, [\"exp\", 2, bits]]\n\n\n# convenience rewrites for shr/sar/shl\ndef shl(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"shl\", bits, x]\n    return [\"mul\", x, [\"exp\", 2, bits]]\n\n\ndef sar(bits, x):\n    if version_check(begin=\"constantinople\"):\n        return [\"sar\", bits, x]\n\n    # emulate for older arches. keep in mind note from EIP 145:\n    # \"This is not equivalent to PUSH1 2 EXP SDIV, since it rounds\n    # differently. See SDIV(-1, 2) == 0, while SAR(-1, 1) == -1.\"\n    return [\"sdiv\", [\"add\", [\"slt\", x, 0], x], [\"exp\", 2, bits]]\n\n\ndef clamp_bytestring(ir_node):\n    t = ir_node.typ\n    if not isinstance(t, ByteArrayLike):\n        raise CompilerPanic(f\"{t} passed to clamp_bytestring\")  # pragma: notest\n    return [\"assert\", [\"le\", get_bytearray_length(ir_node), t.maxlen]]\n\n\ndef clamp_dyn_array(ir_node):\n    t = ir_node.typ\n    assert isinstance(t, DArrayType)\n    return [\"assert\", [\"le\", get_dyn_array_count(ir_node), t.count]]\n\n\n# clampers for basetype\ndef clamp_basetype(ir_node):\n    t = ir_node.typ\n    if not isinstance(t, BaseType):\n        raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest\n\n    # copy of the input\n    ir_node = unwrap_location(ir_node)\n\n    if is_integer_type(t) or is_decimal_type(t):\n        if t._num_info.bits == 256:\n            return ir_node\n        else:\n            return int_clamp(ir_node, t._num_info.bits, signed=t._num_info.is_signed)\n\n    if is_bytes_m_type(t):\n        if t._bytes_info.m == 32:\n            return ir_node  # special case, no clamp.\n        else:\n            return bytes_clamp(ir_node, t._bytes_info.m)\n\n    if t.typ in (\"address\",):\n        return int_clamp(ir_node, 160)\n    if t.typ in (\"bool\",):\n        return int_clamp(ir_node, 1)\n\n    raise CompilerPanic(f\"{t} passed to clamp_basetype\")  # pragma: notest\n\n\ndef int_clamp(ir_node, bits, signed=False):\n    \"\"\"Generalized clamper for integer types. Takes the number of bits,\n    whether it's signed, and returns an IR node which checks it is\n    in bounds. (Consumers should use clamp_basetype instead which uses\n    type-based dispatch and is a little safer.)\n    \"\"\"\n    if bits >= 256:\n        raise CompilerPanic(f\"invalid clamp: {bits}>=256 ({ir_node})\")  # pragma: notest\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        if signed:\n            # example for bits==128:\n            # promote_signed_int(val, bits) is the \"canonical\" version of val\n            # if val is in bounds, the bits above bit 128 should be equal.\n            # (this works for both val >= 0 and val < 0. in the first case,\n            # all upper bits should be 0 if val is a valid int128,\n            # in the latter case, all upper bits should be 1.)\n            assertion = [\"assert\", [\"eq\", val, promote_signed_int(val, bits)]]\n        else:\n            assertion = [\"assert\", [\"iszero\", shr(bits, val)]]\n\n        ret = b.resolve([\"seq\", assertion, val])\n\n    # TODO fix this annotation\n    return IRnode.from_list(ret, annotation=f\"int_clamp {ir_node.typ}\")\n\n\ndef bytes_clamp(ir_node: IRnode, n_bytes: int) -> IRnode:\n    if not (0 < n_bytes <= 32):\n        raise CompilerPanic(f\"bad type: bytes{n_bytes}\")\n    with ir_node.cache_when_complex(\"val\") as (b, val):\n        assertion = [\"assert\", [\"iszero\", shl(n_bytes * 8, val)]]\n        ret = b.resolve([\"seq\", assertion, val])\n    return IRnode.from_list(ret, annotation=f\"bytes{n_bytes}_clamp\")\n\n\n# e.g. for int8, promote 255 to -1\ndef promote_signed_int(x, bits):\n    assert bits % 8 == 0\n    ret = [\"signextend\", bits // 8 - 1, x]\n    return IRnode.from_list(ret, annotation=f\"promote int{bits}\")\n", "import decimal\nimport math\n\nfrom vyper import ast as vy_ast\nfrom vyper.address_space import DATA, IMMUTABLES, MEMORY, STORAGE\nfrom vyper.codegen import external_call, self_call\nfrom vyper.codegen.core import (\n    clamp_basetype,\n    ensure_in_memory,\n    get_dyn_array_count,\n    get_element_ptr,\n    getpos,\n    make_setter,\n    pop_dyn_array,\n    unwrap_location,\n)\nfrom vyper.codegen.ir_node import IRnode\nfrom vyper.codegen.keccak256_helper import keccak256_helper\nfrom vyper.codegen.types import (\n    ArrayLike,\n    BaseType,\n    ByteArrayLike,\n    ByteArrayType,\n    DArrayType,\n    InterfaceType,\n    MappingType,\n    SArrayType,\n    StringType,\n    StructType,\n    TupleType,\n    is_base_type,\n    is_numeric_type,\n)\nfrom vyper.codegen.types.convert import new_type_to_old_type\nfrom vyper.evm.opcodes import version_check\nfrom vyper.exceptions import (\n    CompilerPanic,\n    EvmVersionException,\n    StructureException,\n    TypeCheckFailure,\n    TypeMismatch,\n)\nfrom vyper.utils import DECIMAL_DIVISOR, SizeLimits, bytes_to_int, checksum_encode, string_to_bytes\n\nENVIRONMENT_VARIABLES = {\n    \"block\",\n    \"msg\",\n    \"tx\",\n    \"chain\",\n}\n\n\ndef calculate_largest_power(a: int, num_bits: int, is_signed: bool) -> int:\n    \"\"\"\n    For a given base `a`, compute the maximum power `b` that will not\n    produce an overflow in the equation `a ** b`\n\n    Arguments\n    ---------\n    a : int\n        Base value for the equation `a ** b`\n    num_bits : int\n        The maximum number of bits that the resulting value must fit in\n    is_signed : bool\n        Is the operation being performed on signed integers?\n\n    Returns\n    -------\n    int\n        Largest possible value for `b` where the result does not overflow\n        `num_bits`\n    \"\"\"\n    if num_bits % 8:\n        raise CompilerPanic(\"Type is not a modulo of 8\")\n\n    value_bits = num_bits - (1 if is_signed else 0)\n    if a >= 2 ** value_bits:\n        raise TypeCheckFailure(\"Value is too large and will always throw\")\n    elif a < -(2 ** value_bits):\n        raise TypeCheckFailure(\"Value is too small and will always throw\")\n\n    a_is_negative = a < 0\n    a = abs(a)  # No longer need to know if it's signed or not\n    if a in (0, 1):\n        raise CompilerPanic(\"Exponential operation is useless!\")\n\n    # NOTE: There is an edge case if `a` were left signed where the following\n    #       operation would not work (`ln(a)` is undefined if `a <= 0`)\n    b = int(decimal.Decimal(value_bits) / (decimal.Decimal(a).ln() / decimal.Decimal(2).ln()))\n    if b <= 1:\n        return 1  # Value is assumed to be in range, therefore power of 1 is max\n\n    # Do a bit of iteration to ensure we have the exact number\n    num_iterations = 0\n    while a ** (b + 1) < 2 ** value_bits:\n        b += 1\n        num_iterations += 1\n        assert num_iterations < 10000\n    while a ** b >= 2 ** value_bits:\n        b -= 1\n        num_iterations += 1\n        assert num_iterations < 10000\n\n    # Edge case: If a is negative and the values of a and b are such that:\n    #               (a) ** (b + 1) == -(2 ** value_bits)\n    #            we can actually squeak one more out of it because it's on the edge\n    if a_is_negative and (-a) ** (b + 1) == -(2 ** value_bits):  # NOTE: a = abs(a)\n        return b + 1\n    else:\n        return b  # Exact\n\n\ndef calculate_largest_base(b: int, num_bits: int, is_signed: bool) -> int:\n    \"\"\"\n    For a given power `b`, compute the maximum base `a` that will not produce an\n    overflow in the equation `a ** b`\n\n    Arguments\n    ---------\n    b : int\n        Power value for the equation `a ** b`\n    num_bits : int\n        The maximum number of bits that the resulting value must fit in\n    is_signed : bool\n        Is the operation being performed on signed integers?\n\n    Returns\n    -------\n    int\n        Largest possible value for `a` where the result does not overflow\n        `num_bits`\n    \"\"\"\n    if num_bits % 8:\n        raise CompilerPanic(\"Type is not a modulo of 8\")\n    if b < 0:\n        raise TypeCheckFailure(\"Cannot calculate negative exponents\")\n\n    value_bits = num_bits - (1 if is_signed else 0)\n    if b > value_bits:\n        raise TypeCheckFailure(\"Value is too large and will always throw\")\n    elif b < 2:\n        return 2 ** value_bits - 1  # Maximum value for type\n\n    # Estimate (up to ~39 digits precision required)\n    a = math.ceil(2 ** (decimal.Decimal(value_bits) / decimal.Decimal(b)))\n    # Do a bit of iteration to ensure we have the exact number\n    num_iterations = 0\n    while (a + 1) ** b < 2 ** value_bits:\n        a += 1\n        num_iterations += 1\n        assert num_iterations < 10000\n    while a ** b >= 2 ** value_bits:\n        a -= 1\n        num_iterations += 1\n        assert num_iterations < 10000\n\n    return a\n\n\nclass Expr:\n    # TODO: Once other refactors are made reevaluate all inline imports\n\n    def __init__(self, node, context):\n        self.expr = node\n        self.context = context\n\n        if isinstance(node, IRnode):\n            # TODO this seems bad\n            self.ir_node = node\n            return\n\n        fn = getattr(self, f\"parse_{type(node).__name__}\", None)\n        if fn is None:\n            raise TypeCheckFailure(f\"Invalid statement node: {type(node).__name__}\")\n\n        self.ir_node = fn()\n        if self.ir_node is None:\n            raise TypeCheckFailure(f\"{type(node).__name__} node did not produce IR. {self.expr}\")\n\n        self.ir_node.annotation = self.expr.get(\"node_source_code\")\n        self.ir_node.source_pos = getpos(self.expr)\n\n    def parse_Int(self):\n        # Literal (mostly likely) becomes int256\n        if self.expr.n < 0:\n            return IRnode.from_list(self.expr.n, typ=BaseType(\"int256\", is_literal=True))\n        # Literal is large enough (mostly likely) becomes uint256.\n        else:\n            return IRnode.from_list(self.expr.n, typ=BaseType(\"uint256\", is_literal=True))\n\n    def parse_Decimal(self):\n        val = self.expr.value * DECIMAL_DIVISOR\n\n        # sanity check that type checker did its job\n        assert isinstance(val, decimal.Decimal)\n        assert SizeLimits.in_bounds(\"decimal\", val)\n        assert math.ceil(val) == math.floor(val)\n\n        val = int(val)\n\n        return IRnode.from_list(val, typ=BaseType(\"decimal\", is_literal=True))\n\n    def parse_Hex(self):\n        hexstr = self.expr.value\n\n        if len(hexstr) == 42:\n            # sanity check typechecker did its job\n            assert checksum_encode(hexstr) == hexstr\n            typ = BaseType(\"address\")\n            # TODO allow non-checksum encoded bytes20\n            return IRnode.from_list(int(self.expr.value, 16), typ=typ)\n\n        else:\n            n_bytes = (len(hexstr) - 2) // 2  # e.g. \"0x1234\" is 2 bytes\n            # TODO: typ = new_type_to_old_type(self.expr._metadata[\"type\"])\n            #       assert n_bytes == typ._bytes_info.m\n\n            # bytes_m types are left padded with zeros\n            val = int(hexstr, 16) << 8 * (32 - n_bytes)\n\n            typ = BaseType(f\"bytes{n_bytes}\", is_literal=True)\n            typ.is_literal = True\n            return IRnode.from_list(val, typ=typ)\n\n    # String literals\n    def parse_Str(self):\n        bytez, bytez_length = string_to_bytes(self.expr.value)\n        typ = StringType(bytez_length, is_literal=True)\n        return self._make_bytelike(typ, bytez, bytez_length)\n\n    # Byte literals\n    def parse_Bytes(self):\n        bytez = self.expr.s\n        bytez_length = len(self.expr.s)\n        typ = ByteArrayType(bytez_length, is_literal=True)\n        return self._make_bytelike(typ, bytez, bytez_length)\n\n    def _make_bytelike(self, btype, bytez, bytez_length):\n        placeholder = self.context.new_internal_variable(btype)\n        seq = []\n        seq.append([\"mstore\", placeholder, bytez_length])\n        for i in range(0, len(bytez), 32):\n            seq.append(\n                [\n                    \"mstore\",\n                    [\"add\", placeholder, i + 32],\n                    bytes_to_int((bytez + b\"\\x00\" * 31)[i : i + 32]),\n                ]\n            )\n        return IRnode.from_list(\n            [\"seq\"] + seq + [placeholder],\n            typ=btype,\n            location=MEMORY,\n            annotation=f\"Create {btype}: {bytez}\",\n        )\n\n    # True, False, None constants\n    def parse_NameConstant(self):\n        if self.expr.value is True:\n            return IRnode.from_list(1, typ=BaseType(\"bool\", is_literal=True))\n        elif self.expr.value is False:\n            return IRnode.from_list(0, typ=BaseType(\"bool\", is_literal=True))\n\n    # Variable names\n    def parse_Name(self):\n\n        if self.expr.id == \"self\":\n            return IRnode.from_list([\"address\"], typ=\"address\")\n        elif self.expr.id in self.context.vars:\n            var = self.context.vars[self.expr.id]\n            return IRnode.from_list(\n                var.pos,\n                typ=var.typ,\n                location=var.location,  # either 'memory' or 'calldata' storage is handled above.\n                encoding=var.encoding,\n                annotation=self.expr.id,\n                mutable=var.mutable,\n            )\n\n        elif self.expr._metadata[\"type\"].is_immutable:\n            var = self.context.globals[self.expr.id]\n            ofst = self.expr._metadata[\"type\"].position.offset\n\n            if self.context.sig.is_init_func:\n                mutable = True\n                location = IMMUTABLES\n            else:\n                mutable = False\n                location = DATA\n\n            return IRnode.from_list(\n                ofst,\n                typ=var.typ,\n                location=location,\n                annotation=self.expr.id,\n                mutable=mutable,\n            )\n\n    # x.y or x[5]\n    def parse_Attribute(self):\n        # x.balance: balance of address x\n        if self.expr.attr == \"balance\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if is_base_type(addr.typ, \"address\"):\n                if (\n                    isinstance(self.expr.value, vy_ast.Name)\n                    and self.expr.value.id == \"self\"\n                    and version_check(begin=\"istanbul\")\n                ):\n                    seq = [\"selfbalance\"]\n                else:\n                    seq = [\"balance\", addr]\n                return IRnode.from_list(seq, typ=BaseType(\"uint256\"))\n        # x.codesize: codesize of address x\n        elif self.expr.attr == \"codesize\" or self.expr.attr == \"is_contract\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if is_base_type(addr.typ, \"address\"):\n                if self.expr.attr == \"codesize\":\n                    if self.expr.value.id == \"self\":\n                        eval_code = [\"codesize\"]\n                    else:\n                        eval_code = [\"extcodesize\", addr]\n                    output_type = \"uint256\"\n                else:\n                    eval_code = [\"gt\", [\"extcodesize\", addr], 0]\n                    output_type = \"bool\"\n                return IRnode.from_list(eval_code, typ=BaseType(output_type))\n        # x.codehash: keccak of address x\n        elif self.expr.attr == \"codehash\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if not version_check(begin=\"constantinople\"):\n                raise EvmVersionException(\n                    \"address.codehash is unavailable prior to constantinople ruleset\", self.expr\n                )\n            if is_base_type(addr.typ, \"address\"):\n                return IRnode.from_list([\"extcodehash\", addr], typ=BaseType(\"bytes32\"))\n        # x.code: codecopy/extcodecopy of address x\n        elif self.expr.attr == \"code\":\n            addr = Expr.parse_value_expr(self.expr.value, self.context)\n            if is_base_type(addr.typ, \"address\"):\n                # These adhoc nodes will be replaced with a valid node in `Slice.build_IR`\n                if addr.value == \"address\":  # for `self.code`\n                    return IRnode.from_list([\"~selfcode\"], typ=ByteArrayType(0))\n                return IRnode.from_list([\"~extcode\", addr], typ=ByteArrayType(0))\n        # self.x: global attribute\n        elif isinstance(self.expr.value, vy_ast.Name) and self.expr.value.id == \"self\":\n            type_ = self.expr._metadata[\"type\"]\n            var = self.context.globals[self.expr.attr]\n            return IRnode.from_list(\n                type_.position.position,\n                typ=var.typ,\n                location=STORAGE,\n                annotation=\"self.\" + self.expr.attr,\n            )\n        # Reserved keywords\n        elif (\n            isinstance(self.expr.value, vy_ast.Name) and self.expr.value.id in ENVIRONMENT_VARIABLES\n        ):\n            key = f\"{self.expr.value.id}.{self.expr.attr}\"\n            if key == \"msg.sender\":\n                return IRnode.from_list([\"caller\"], typ=\"address\")\n            elif key == \"msg.data\":\n                # This adhoc node will be replaced with a valid node in `Slice/Len.build_IR`\n                return IRnode.from_list([\"~calldata\"], typ=ByteArrayType(0))\n            elif key == \"msg.value\" and self.context.is_payable:\n                return IRnode.from_list([\"callvalue\"], typ=BaseType(\"uint256\"))\n            elif key == \"msg.gas\":\n                return IRnode.from_list([\"gas\"], typ=\"uint256\")\n            elif key == \"block.difficulty\":\n                return IRnode.from_list([\"difficulty\"], typ=\"uint256\")\n            elif key == \"block.timestamp\":\n                return IRnode.from_list([\"timestamp\"], typ=BaseType(\"uint256\"))\n            elif key == \"block.coinbase\":\n                return IRnode.from_list([\"coinbase\"], typ=\"address\")\n            elif key == \"block.number\":\n                return IRnode.from_list([\"number\"], typ=\"uint256\")\n            elif key == \"block.gaslimit\":\n                return IRnode.from_list([\"gaslimit\"], typ=\"uint256\")\n            elif key == \"block.basefee\":\n                return IRnode.from_list([\"basefee\"], typ=\"uint256\")\n            elif key == \"block.prevhash\":\n                return IRnode.from_list([\"blockhash\", [\"sub\", \"number\", 1]], typ=\"bytes32\")\n            elif key == \"tx.origin\":\n                return IRnode.from_list([\"origin\"], typ=\"address\")\n            elif key == \"tx.gasprice\":\n                return IRnode.from_list([\"gasprice\"], typ=\"uint256\")\n            elif key == \"chain.id\":\n                if not version_check(begin=\"istanbul\"):\n                    raise EvmVersionException(\n                        \"chain.id is unavailable prior to istanbul ruleset\", self.expr\n                    )\n                return IRnode.from_list([\"chainid\"], typ=\"uint256\")\n        # Other variables\n        else:\n            sub = Expr(self.expr.value, self.context).ir_node\n            # contract type\n            if isinstance(sub.typ, InterfaceType):\n                return sub\n            if isinstance(sub.typ, StructType) and self.expr.attr in sub.typ.members:\n                return get_element_ptr(sub, self.expr.attr)\n\n    def parse_Subscript(self):\n        sub = Expr(self.expr.value, self.context).ir_node\n        if sub.value == \"multi\":\n            # force literal to memory, e.g.\n            # MY_LIST: constant(decimal[6])\n            # ...\n            # return MY_LIST[ix]\n            sub = ensure_in_memory(sub, self.context)\n\n        if isinstance(sub.typ, MappingType):\n            # TODO sanity check we are in a self.my_map[i] situation\n            index = Expr.parse_value_expr(self.expr.slice.value, self.context)\n            if isinstance(index.typ, ByteArrayLike):\n                # we have to hash the key to get a storage location\n                assert len(index.args) == 1\n                index = keccak256_helper(self.expr.slice.value, index.args[0], self.context)\n\n        elif isinstance(sub.typ, ArrayLike):\n            index = Expr.parse_value_expr(self.expr.slice.value, self.context)\n\n        elif isinstance(sub.typ, TupleType):\n            index = self.expr.slice.value.n\n            # note: this check should also happen in get_element_ptr\n            if not 0 <= index < len(sub.typ.members):\n                return\n        else:\n            return\n\n        ir_node = get_element_ptr(sub, index)\n        ir_node.mutable = sub.mutable\n        return ir_node\n\n    def parse_BinOp(self):\n        left = Expr.parse_value_expr(self.expr.left, self.context)\n        right = Expr.parse_value_expr(self.expr.right, self.context)\n\n        if not is_numeric_type(left.typ) or not is_numeric_type(right.typ):\n            return\n\n        types = {left.typ.typ, right.typ.typ}\n        literals = {left.typ.is_literal, right.typ.is_literal}\n\n        # If one value of the operation is a literal, we recast it to match the non-literal type.\n        # We know this is OK because types were already verified in the actual typechecking pass.\n        # This is a temporary solution to not break codegen while we work toward removing types\n        # altogether at this stage of complition. @iamdefinitelyahuman\n        if literals == {True, False} and len(types) > 1 and \"decimal\" not in types:\n            if left.typ.is_literal and SizeLimits.in_bounds(right.typ.typ, left.value):\n                left = IRnode.from_list(left.value, typ=BaseType(right.typ.typ, is_literal=True))\n            elif right.typ.is_literal and SizeLimits.in_bounds(left.typ.typ, right.value):\n                right = IRnode.from_list(right.value, typ=BaseType(left.typ.typ, is_literal=True))\n\n        ltyp, rtyp = left.typ.typ, right.typ.typ\n\n        # Sanity check - ensure that we aren't dealing with different types\n        # This should be unreachable due to the type check pass\n        assert ltyp == rtyp, \"unreachable\"\n\n        arith = None\n        if isinstance(self.expr.op, (vy_ast.Add, vy_ast.Sub)):\n            new_typ = BaseType(ltyp)\n\n            if ltyp == \"uint256\":\n                if isinstance(self.expr.op, vy_ast.Add):\n                    # safeadd\n                    arith = [\"seq\", [\"assert\", [\"ge\", [\"add\", \"l\", \"r\"], \"l\"]], [\"add\", \"l\", \"r\"]]\n\n                elif isinstance(self.expr.op, vy_ast.Sub):\n                    # safesub\n                    arith = [\"seq\", [\"assert\", [\"ge\", \"l\", \"r\"]], [\"sub\", \"l\", \"r\"]]\n\n            elif ltyp == \"int256\":\n                if isinstance(self.expr.op, vy_ast.Add):\n                    op, comp1, comp2 = \"add\", \"sge\", \"slt\"\n                else:\n                    op, comp1, comp2 = \"sub\", \"sle\", \"sgt\"\n\n                if right.typ.is_literal:\n                    if right.value >= 0:\n                        arith = [\"seq\", [\"assert\", [comp1, [op, \"l\", \"r\"], \"l\"]], [op, \"l\", \"r\"]]\n                    else:\n                        arith = [\"seq\", [\"assert\", [comp2, [op, \"l\", \"r\"], \"l\"]], [op, \"l\", \"r\"]]\n                else:\n                    arith = [\n                        \"with\",\n                        \"ans\",\n                        [op, \"l\", \"r\"],\n                        [\n                            \"seq\",\n                            [\n                                \"assert\",\n                                [\n                                    \"or\",\n                                    [\"and\", [\"sge\", \"r\", 0], [comp1, \"ans\", \"l\"]],\n                                    [\"and\", [\"slt\", \"r\", 0], [comp2, \"ans\", \"l\"]],\n                                ],\n                            ],\n                            \"ans\",\n                        ],\n                    ]\n\n            elif ltyp in (\"decimal\", \"int128\", \"uint8\"):\n                op = \"add\" if isinstance(self.expr.op, vy_ast.Add) else \"sub\"\n                arith = [op, \"l\", \"r\"]\n\n        elif isinstance(self.expr.op, vy_ast.Mult):\n            new_typ = BaseType(ltyp)\n            if ltyp == \"uint256\":\n                arith = [\n                    \"with\",\n                    \"ans\",\n                    [\"mul\", \"l\", \"r\"],\n                    [\n                        \"seq\",\n                        [\"assert\", [\"or\", [\"eq\", [\"div\", \"ans\", \"l\"], \"r\"], [\"iszero\", \"l\"]]],\n                        \"ans\",\n                    ],\n                ]\n\n            elif ltyp == \"int256\":\n                if version_check(begin=\"constantinople\"):\n                    upper_bound = [\"shl\", 255, 1]\n                else:\n                    upper_bound = -(2 ** 255)\n                if not left.typ.is_literal and not right.typ.is_literal:\n                    bounds_check = [\n                        \"assert\",\n                        [\"or\", [\"ne\", \"l\", [\"not\", 0]], [\"ne\", \"r\", upper_bound]],\n                    ]\n                elif left.typ.is_literal and left.value == -1:\n                    bounds_check = [\"assert\", [\"ne\", \"r\", upper_bound]]\n                elif right.typ.is_literal and right.value == -(2 ** 255):\n                    bounds_check = [\"assert\", [\"ne\", \"l\", [\"not\", 0]]]\n                else:\n                    bounds_check = \"pass\"\n                arith = [\n                    \"with\",\n                    \"ans\",\n                    [\"mul\", \"l\", \"r\"],\n                    [\n                        \"seq\",\n                        bounds_check,\n                        [\"assert\", [\"or\", [\"eq\", [\"sdiv\", \"ans\", \"l\"], \"r\"], [\"iszero\", \"l\"]]],\n                        \"ans\",\n                    ],\n                ]\n\n            elif ltyp in (\"int128\", \"uint8\"):\n                arith = [\"mul\", \"l\", \"r\"]\n\n            elif ltyp == \"decimal\":\n                arith = [\n                    \"with\",\n                    \"ans\",\n                    [\"mul\", \"l\", \"r\"],\n                    [\n                        \"seq\",\n                        [\"assert\", [\"or\", [\"eq\", [\"sdiv\", \"ans\", \"l\"], \"r\"], [\"iszero\", \"l\"]]],\n                        [\"sdiv\", \"ans\", DECIMAL_DIVISOR],\n                    ],\n                ]\n\n        elif isinstance(self.expr.op, vy_ast.Div):\n            if right.typ.is_literal and right.value == 0:\n                return\n\n            new_typ = BaseType(ltyp)\n\n            if right.typ.is_literal:\n                divisor = \"r\"\n            else:\n                # only apply the non-zero clamp when r is not a constant\n                divisor = [\"clamp_nonzero\", \"r\"]\n\n            if ltyp in (\"uint8\", \"uint256\"):\n                arith = [\"div\", \"l\", divisor]\n\n            elif ltyp == \"int256\":\n                if version_check(begin=\"constantinople\"):\n                    upper_bound = [\"shl\", 255, 1]\n                else:\n                    upper_bound = -(2 ** 255)\n                if not left.typ.is_literal and not right.typ.is_literal:\n                    bounds_check = [\n                        \"assert\",\n                        [\"or\", [\"ne\", \"r\", [\"not\", 0]], [\"ne\", \"l\", upper_bound]],\n                    ]\n                elif left.typ.is_literal and left.value == -(2 ** 255):\n                    bounds_check = [\"assert\", [\"ne\", \"r\", [\"not\", 0]]]\n                elif right.typ.is_literal and right.value == -1:\n                    bounds_check = [\"assert\", [\"ne\", \"l\", upper_bound]]\n                else:\n                    bounds_check = \"pass\"\n                arith = [\"seq\", bounds_check, [\"sdiv\", \"l\", divisor]]\n\n            elif ltyp == \"int128\":\n                arith = [\"sdiv\", \"l\", divisor]\n\n            elif ltyp == \"decimal\":\n                arith = [\n                    \"sdiv\",\n                    [\"mul\", \"l\", DECIMAL_DIVISOR],\n                    divisor,\n                ]\n\n        elif isinstance(self.expr.op, vy_ast.Mod):\n            if right.typ.is_literal and right.value == 0:\n                return\n\n            new_typ = BaseType(ltyp)\n\n            if right.typ.is_literal:\n                divisor = \"r\"\n            else:\n                # only apply the non-zero clamp when r is not a constant\n                divisor = [\"clamp_nonzero\", \"r\"]\n\n            if ltyp in (\"uint8\", \"uint256\"):\n                arith = [\"mod\", \"l\", divisor]\n            else:\n                arith = [\"smod\", \"l\", divisor]\n\n        elif isinstance(self.expr.op, vy_ast.Pow):\n            new_typ = BaseType(ltyp)\n\n            # TODO optimizer rule for special cases\n            if self.expr.left.get(\"value\") == 1:\n                return IRnode.from_list([1], typ=new_typ)\n            if self.expr.left.get(\"value\") == 0:\n                return IRnode.from_list([\"iszero\", right], typ=new_typ)\n\n            if ltyp == \"int128\":\n                is_signed = True\n                num_bits = 128\n            elif ltyp == \"int256\":\n                is_signed = True\n                num_bits = 256\n            elif ltyp == \"uint8\":\n                is_signed = False\n                num_bits = 8\n            else:\n                is_signed = False\n                num_bits = 256\n\n            if isinstance(self.expr.left, vy_ast.Int):\n                value = self.expr.left.value\n                upper_bound = calculate_largest_power(value, num_bits, is_signed) + 1\n                # for signed integers, this also prevents negative values\n                clamp = [\"lt\", right, upper_bound]\n                return IRnode.from_list(\n                    [\"seq\", [\"assert\", clamp], [\"exp\", left, right]],\n                    typ=new_typ,\n                )\n            elif isinstance(self.expr.right, vy_ast.Int):\n                value = self.expr.right.value\n                upper_bound = calculate_largest_base(value, num_bits, is_signed) + 1\n                if is_signed:\n                    clamp = [\"and\", [\"slt\", left, upper_bound], [\"sgt\", left, -upper_bound]]\n                else:\n                    clamp = [\"lt\", left, upper_bound]\n                return IRnode.from_list(\n                    [\"seq\", [\"assert\", clamp], [\"exp\", left, right]], typ=new_typ\n                )\n            else:\n                # `a ** b` where neither `a` or `b` are known\n                # TODO this is currently unreachable, once we implement a way to do it safely\n                # remove the check in `vyper/context/types/value/numeric.py`\n                return\n\n        if arith is None:\n            return\n\n        arith = IRnode.from_list(arith, typ=new_typ)\n\n        p = [\n            \"with\",\n            \"l\",\n            left,\n            [\n                \"with\",\n                \"r\",\n                right,\n                # note clamp_basetype is a noop on [u]int256\n                # note: clamp_basetype throws on unclampable input\n                clamp_basetype(arith),\n            ],\n        ]\n        return IRnode.from_list(p, typ=new_typ)\n\n    def build_in_comparator(self):\n        left = Expr(self.expr.left, self.context).ir_node\n        right = Expr(self.expr.right, self.context).ir_node\n\n        # temporary kludge to block #2637 bug\n        # TODO actually fix the bug\n        if not isinstance(left.typ, BaseType):\n            raise TypeMismatch(\n                \"`in` not allowed for arrays of non-base types, tracked in issue #2637\", self.expr\n            )\n\n        if isinstance(self.expr.op, vy_ast.In):\n            found, not_found = 1, 0\n        elif isinstance(self.expr.op, vy_ast.NotIn):\n            found, not_found = 0, 1\n        else:\n            return  # pragma: notest\n\n        i = IRnode.from_list(self.context.fresh_varname(\"in_ix\"), typ=\"uint256\")\n\n        found_ptr = self.context.new_internal_variable(BaseType(\"bool\"))\n\n        ret = [\"seq\"]\n\n        left = unwrap_location(left)\n        with left.cache_when_complex(\"needle\") as (b1, left), right.cache_when_complex(\n            \"haystack\"\n        ) as (b2, right):\n            if right.value == \"multi\":\n                # Copy literal to memory to be compared.\n                tmp_list = IRnode.from_list(\n                    self.context.new_internal_variable(right.typ), typ=right.typ, location=MEMORY\n                )\n                ret.append(make_setter(tmp_list, right))\n\n                right = tmp_list\n\n            # location of i'th item from list\n            ith_element_ptr = get_element_ptr(right, i, array_bounds_check=False)\n            ith_element = unwrap_location(ith_element_ptr)\n\n            if isinstance(right.typ, SArrayType):\n                len_ = right.typ.count\n            else:\n                len_ = get_dyn_array_count(right)\n\n            # Condition repeat loop has to break on.\n            # TODO maybe put result on the stack\n            loop_body = [\n                \"if\",\n                [\"eq\", left, ith_element],\n                [\"seq\", [\"mstore\", found_ptr, found], \"break\"],  # store true.\n            ]\n            loop = [\"repeat\", i, 0, len_, right.typ.count, loop_body]\n\n            ret.append(\n                [\n                    \"seq\",\n                    [\"mstore\", found_ptr, not_found],\n                    loop,\n                    [\"mload\", found_ptr],\n                ]\n            )\n\n            return IRnode.from_list(b1.resolve(b2.resolve(ret)), typ=\"bool\")\n\n    @staticmethod\n    def _signed_to_unsigned_comparision_op(op):\n        translation_map = {\n            \"sgt\": \"gt\",\n            \"sge\": \"ge\",\n            \"sle\": \"le\",\n            \"slt\": \"lt\",\n        }\n        if op in translation_map:\n            return translation_map[op]\n        else:\n            return op\n\n    def parse_Compare(self):\n        left = Expr.parse_value_expr(self.expr.left, self.context)\n        right = Expr.parse_value_expr(self.expr.right, self.context)\n\n        if right.value is None:\n            return\n\n        if isinstance(self.expr.op, (vy_ast.In, vy_ast.NotIn)):\n            if isinstance(right.typ, ArrayLike):\n                return self.build_in_comparator()\n            return  # pragma: notest\n\n        if isinstance(self.expr.op, vy_ast.Gt):\n            op = \"sgt\"\n        elif isinstance(self.expr.op, vy_ast.GtE):\n            op = \"sge\"\n        elif isinstance(self.expr.op, vy_ast.LtE):\n            op = \"sle\"\n        elif isinstance(self.expr.op, vy_ast.Lt):\n            op = \"slt\"\n        elif isinstance(self.expr.op, vy_ast.Eq):\n            op = \"eq\"\n        elif isinstance(self.expr.op, vy_ast.NotEq):\n            op = \"ne\"\n        else:\n            return  # pragma: notest\n\n        # Compare (limited to 32) byte arrays.\n        if isinstance(left.typ, ByteArrayLike) and isinstance(right.typ, ByteArrayLike):\n            left = Expr(self.expr.left, self.context).ir_node\n            right = Expr(self.expr.right, self.context).ir_node\n\n            left_keccak = keccak256_helper(self.expr, left, self.context)\n            right_keccak = keccak256_helper(self.expr, right, self.context)\n\n            if op not in (\"eq\", \"ne\"):\n                return  # raises\n            else:\n                # use hash even for Bytes[N<=32], because there could be dirty\n                # bytes past the bytes data.\n                return IRnode.from_list([op, left_keccak, right_keccak], typ=\"bool\")\n\n        # Compare other types.\n        elif is_numeric_type(left.typ) and is_numeric_type(right.typ):\n            if left.typ.typ == right.typ.typ == \"uint256\":\n                # this works because we only have one unsigned integer type\n                # in the future if others are added, this logic must be expanded\n                op = self._signed_to_unsigned_comparision_op(op)\n\n        elif isinstance(left.typ, BaseType) and isinstance(right.typ, BaseType):\n            if op not in (\"eq\", \"ne\"):\n                return\n        else:\n            # kludge to block behavior in #2638\n            # TODO actually implement equality for complex types\n            raise TypeMismatch(\n                f\"operation not yet supported for {left.typ}, {right.typ}, see issue #2638\",\n                self.expr.op,\n            )\n\n        return IRnode.from_list([op, left, right], typ=\"bool\")\n\n    def parse_BoolOp(self):\n        for value in self.expr.values:\n            # Check for boolean operations with non-boolean inputs\n            _expr = Expr.parse_value_expr(value, self.context)\n            if not is_base_type(_expr.typ, \"bool\"):\n                return\n\n        def _build_if_ir(condition, true, false):\n            # generate a basic if statement in IR\n            o = [\"if\", condition, true, false]\n            return o\n\n        if isinstance(self.expr.op, vy_ast.And):\n            # create the initial `x and y` from the final two values\n            ir_node = _build_if_ir(\n                Expr.parse_value_expr(self.expr.values[-2], self.context),\n                Expr.parse_value_expr(self.expr.values[-1], self.context),\n                [0],\n            )\n            # iterate backward through the remaining values\n            for node in self.expr.values[-3::-1]:\n                ir_node = _build_if_ir(Expr.parse_value_expr(node, self.context), ir_node, [0])\n\n        elif isinstance(self.expr.op, vy_ast.Or):\n            # create the initial `x or y` from the final two values\n            ir_node = _build_if_ir(\n                Expr.parse_value_expr(self.expr.values[-2], self.context),\n                [1],\n                Expr.parse_value_expr(self.expr.values[-1], self.context),\n            )\n\n            # iterate backward through the remaining values\n            for node in self.expr.values[-3::-1]:\n                ir_node = _build_if_ir(Expr.parse_value_expr(node, self.context), 1, ir_node)\n        else:\n            raise TypeCheckFailure(f\"Unexpected boolean operator: {type(self.expr.op).__name__}\")\n\n        return IRnode.from_list(ir_node, typ=\"bool\")\n\n    # Unary operations (only \"not\" supported)\n    def parse_UnaryOp(self):\n        operand = Expr.parse_value_expr(self.expr.operand, self.context)\n        if isinstance(self.expr.op, vy_ast.Not):\n            if isinstance(operand.typ, BaseType) and operand.typ.typ == \"bool\":\n                return IRnode.from_list([\"iszero\", operand], typ=\"bool\")\n        elif isinstance(self.expr.op, vy_ast.USub) and is_numeric_type(operand.typ):\n            assert operand.typ._num_info.is_signed\n            # Clamp on minimum integer value as we cannot negate that value\n            # (all other integer values are fine)\n            min_int_val, _ = operand.typ._num_info.bounds\n            return IRnode.from_list(\n                [\"sub\", 0, [\"clampgt\", operand, min_int_val]],\n                typ=operand.typ,\n            )\n\n    def _is_valid_interface_assign(self):\n        if self.expr.args and len(self.expr.args) == 1:\n            arg_ir = Expr(self.expr.args[0], self.context).ir_node\n            if arg_ir.typ == BaseType(\"address\"):\n                return True, arg_ir\n        return False, None\n\n    # Function calls\n    def parse_Call(self):\n        # TODO check out this inline import\n        from vyper.builtin_functions import DISPATCH_TABLE\n\n        if isinstance(self.expr.func, vy_ast.Name):\n            function_name = self.expr.func.id\n\n            if function_name in DISPATCH_TABLE:\n                return DISPATCH_TABLE[function_name].build_IR(self.expr, self.context)\n\n            # Struct constructors do not need `self` prefix.\n            elif function_name in self.context.structs:\n                args = self.expr.args\n                if len(args) == 1 and isinstance(args[0], vy_ast.Dict):\n                    return Expr.struct_literals(args[0], function_name, self.context)\n\n            # Interface assignment. Bar(<address>).\n            elif function_name in self.context.sigs:\n                ret, arg_ir = self._is_valid_interface_assign()\n                if ret is True:\n                    arg_ir.typ = InterfaceType(function_name)  # Cast to Correct interface type.\n                    return arg_ir\n\n        elif isinstance(self.expr.func, vy_ast.Attribute) and self.expr.func.attr == \"pop\":\n            darray = Expr(self.expr.func.value, self.context).ir_node\n            assert len(self.expr.args) == 0\n            assert isinstance(darray.typ, DArrayType)\n            return pop_dyn_array(\n                darray,\n                return_popped_item=True,\n            )\n\n        elif (\n            isinstance(self.expr.func, vy_ast.Attribute)\n            and isinstance(self.expr.func.value, vy_ast.Name)\n            and self.expr.func.value.id == \"self\"\n        ):  # noqa: E501\n            return self_call.ir_for_self_call(self.expr, self.context)\n        else:\n            return external_call.ir_for_external_call(self.expr, self.context)\n\n    def parse_List(self):\n        typ = new_type_to_old_type(self.expr._metadata[\"type\"])\n        if len(self.expr.elements) == 0:\n            return IRnode.from_list(\"~empty\", typ=typ)\n\n        multi_ir = [Expr(x, self.context).ir_node for x in self.expr.elements]\n\n        return IRnode.from_list([\"multi\"] + multi_ir, typ=typ)\n\n    def parse_Tuple(self):\n        tuple_elements = [Expr(x, self.context).ir_node for x in self.expr.elements]\n        typ = TupleType([x.typ for x in tuple_elements], is_literal=True)\n        multi_ir = IRnode.from_list([\"multi\"] + tuple_elements, typ=typ)\n        return multi_ir\n\n    @staticmethod\n    def struct_literals(expr, name, context):\n        member_subs = {}\n        member_typs = {}\n        for key, value in zip(expr.keys, expr.values):\n            if not isinstance(key, vy_ast.Name):\n                return\n            if key.id in member_subs:\n                return\n            sub = Expr(value, context).ir_node\n            member_subs[key.id] = sub\n            member_typs[key.id] = sub.typ\n        return IRnode.from_list(\n            [\"multi\"] + [member_subs[key] for key in member_subs.keys()],\n            typ=StructType(member_typs, name, is_literal=True),\n        )\n\n    # Parse an expression that results in a value\n    @classmethod\n    def parse_value_expr(cls, expr, context):\n        return unwrap_location(cls(expr, context).ir_node)\n\n    # Parse an expression that represents a pointer to memory/calldata or storage.\n    @classmethod\n    def parse_pointer_expr(cls, expr, context):\n        o = cls(expr, context).ir_node\n        if not o.location:\n            raise StructureException(\"Looking for a variable location, instead got a value\", expr)\n        return o\n", "from math import ceil\n\nfrom vyper.codegen.core import bytes_data_ptr, ensure_in_memory, get_bytearray_length\nfrom vyper.codegen.ir_node import IRnode\nfrom vyper.codegen.types import BaseType, ByteArrayLike, is_base_type\nfrom vyper.exceptions import CompilerPanic\nfrom vyper.utils import MemoryPositions, bytes_to_int, keccak256\n\n\ndef _check_byteslike(typ, _expr):\n    if not isinstance(typ, ByteArrayLike) and not is_base_type(typ, \"bytes32\"):\n        # NOTE this may be checked at a higher level, but just be safe\n        raise CompilerPanic(\n            \"keccak256 only accepts bytes-like objects\",\n        )\n\n\ndef _gas_bound(num_words):\n    SHA3_BASE = 30\n    SHA3_PER_WORD = 6\n    return SHA3_BASE + num_words * SHA3_PER_WORD\n\n\ndef keccak256_helper(expr, to_hash, context):\n    _check_byteslike(to_hash.typ, expr)\n\n    # Can hash literals\n    # TODO this is dead code.\n    if isinstance(to_hash, bytes):\n        return IRnode.from_list(bytes_to_int(keccak256(to_hash)), typ=BaseType(\"bytes32\"))\n\n    # Can hash bytes32 objects\n    if is_base_type(to_hash.typ, \"bytes32\"):\n        return IRnode.from_list(\n            [\n                \"seq\",\n                [\"mstore\", MemoryPositions.FREE_VAR_SPACE, to_hash],\n                [\"sha3\", MemoryPositions.FREE_VAR_SPACE, 32],\n            ],\n            typ=BaseType(\"bytes32\"),\n            add_gas_estimate=_gas_bound(1),\n        )\n\n    to_hash = ensure_in_memory(to_hash, context)\n\n    with to_hash.cache_when_complex(\"buf\") as (b1, to_hash):\n        data = bytes_data_ptr(to_hash)\n        len_ = get_bytearray_length(to_hash)\n        return b1.resolve(\n            IRnode.from_list(\n                [\"sha3\", data, len_],\n                typ=\"bytes32\",\n                annotation=\"keccak256\",\n                add_gas_estimate=_gas_bound(ceil(to_hash.typ.maxlen / 32)),\n            )\n        )\n"], "filenames": ["tests/parser/functions/test_slice.py", "tests/parser/types/test_string.py", "vyper/codegen/core.py", "vyper/codegen/expr.py", "vyper/codegen/keccak256_helper.py"], "buggy_code_start_loc": [212, 171, 189, 8, 3], "buggy_code_end_loc": [212, 303, 190, 828, 58], "fixing_code_start_loc": [213, 171, 189, 7, 3], "fixing_code_end_loc": [243, 345, 190, 811, 57], "type": "CWE-697", "message": "Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-24787", "sourceIdentifier": "security-advisories@github.com", "published": "2022-04-04T18:15:07.877", "lastModified": "2022-04-11T17:45:52.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vyper is a Pythonic Smart Contract Language for the Ethereum Virtual Machine. In version 0.3.1 and prior, bytestrings can have dirty bytes in them, resulting in the word-for-word comparisons giving incorrect results. Even without dirty nonzero bytes, two bytestrings can compare to equal if one ends with `\"\\x00\"` because there is no comparison of the length. A patch is available and expected to be part of the 0.3.2 release. There are currently no known workarounds."}, {"lang": "es", "value": "Vyper es un Lenguaje de Contratos Inteligentes de Python para la M\u00e1quina Virtual de Ethereum. En versiones 0.3.1 y anteriores, las cadenas de bytes pueden presentar bytes sucios, resultando en que las comparaciones palabra por palabra den resultados incorrectos. Incluso sin bytes sucios distintos de cero, dos bytestrings pueden compararse como iguales si uno termina con \"\\x00\" porque no se presenta comparaci\u00f3n de la longitud. Se presenta un parche disponible y es esperado que forme parte de la versi\u00f3n 0.3.2. Actualmente no se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-697"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-697"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vyper_project:vyper:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.3.1", "matchCriteriaId": "AE4DDBAF-8428-4829-BEEF-A69196368324"}]}]}], "references": [{"url": "https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/vyperlang/vyper/security/advisories/GHSA-7vrm-3jc8-5wwm", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vyperlang/vyper/commit/2c73f8352635c0a433423a5b94740de1a118e508"}}