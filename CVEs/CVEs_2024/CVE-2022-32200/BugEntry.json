{"buggy_code": ["/*\n\n  Copyright (C) 2000-2005 Silicon Graphics, Inc.  All Rights Reserved.\n  Portions Copyright (C) 2007-2011 David Anderson. All Rights Reserved.\n\n  This program is free software; you can redistribute it\n  and/or modify it under the terms of version 2.1 of the\n  GNU Lesser General Public License as published by the Free\n  Software Foundation.\n\n  This program is distributed in the hope that it would be\n  useful, but WITHOUT ANY WARRANTY; without even the implied\n  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n  Further, this software is distributed without any warranty\n  that it is free of the rightful claim of any third person\n  regarding infringement or the like.  Any license provided\n  herein, whether implied or otherwise, applies only to this\n  software file.  Patent licenses, if any, provided herein\n  do not apply to combinations of this program with other\n  software, or any other product whatsoever.\n\n  You should have received a copy of the GNU Lesser General\n  Public License along with this program; if not, write the\n  Free Software Foundation, Inc., 51 Franklin Street - Fifth\n  Floor, Boston MA 02110-1301, USA.\n\n*/\n\n#include <config.h>\n\n#include <string.h> /* strlen() */\n\n#if defined(_WIN32) && defined(HAVE_STDAFX_H)\n#include \"stdafx.h\"\n#endif /* HAVE_STDAFX_H */\n\n#include \"dwarf.h\"\n#include \"libdwarf.h\"\n#include \"libdwarf_private.h\"\n#include \"dwarf_base_types.h\"\n#include \"dwarf_opaque.h\"\n#include \"dwarf_alloc.h\"\n#include \"dwarf_error.h\"\n#include \"dwarf_util.h\"\n#include \"dwarf_string.h\"\n#include \"dwarf_global.h\"\n\n#ifdef __sgi  /* __sgi should only be defined for IRIX/MIPS. */\n/* The 'fixup' here intended for IRIX targets only.\n   With a  2+GB Elf64 IRIX executable (under 4GB in size),\n   some DIE offsets wrongly\n   got the 32bit upper bit sign extended.  For the cu-header\n   offset in the .debug_pubnames section  and in the\n   .debug_aranges section.\n   the 'varp' here is a pointer to an offset into .debug_info.\n   We fix up the offset here if it seems advisable..\n\n   As of June 2005 we have identified a series of mistakes\n   in ldx64 that can cause this (64 bit values getting passed\n   thru 32-bit signed knothole).\n*/\nvoid\n_dwarf_fix_up_offset_irix(Dwarf_Debug dbg,\n    Dwarf_Unsigned * varp, char *caller_site_name)\n{\n\n    Dwarf_Unsigned var = *varp;\n\n#define UPPER33 0xffffffff80000000LL\n#define LOWER32         0xffffffffLL\n    /*  Restrict the hack to the known case. Upper 32 bits erroneously\n        sign extended from lower 32 upper bit. */\n    if ((var & UPPER33) == UPPER33) {\n        var &= LOWER32;\n        /* Apply the fix. Dreadful hack. */\n        *varp = var;\n    }\n#undef UPPER33\n#undef LOWER32\n    return;\n}\n#endif /* __sgi */\n\nstatic void\ndealloc_globals_chain(Dwarf_Debug dbg,\n    Dwarf_Chain head_chain)\n{\n    Dwarf_Chain curr_chain = 0;\n    int chaintype = DW_DLA_CHAIN;\n    Dwarf_Global_Context lastcontext = 0;\n    Dwarf_Global_Context curcontext = 0;\n\n    curr_chain = head_chain;\n    for (; curr_chain; ) {\n        Dwarf_Global item = 0;\n        int itemtype = 0;\n        Dwarf_Chain prev = 0;\n\n        item = (Dwarf_Global)curr_chain->ch_item;\n        itemtype = curr_chain->ch_itemtype;\n        curcontext = item->gl_context;\n        if (curcontext && curcontext != lastcontext) {\n            /* First time we see a context, dealloc it. */\n            lastcontext = curcontext;\n            dwarf_dealloc(dbg,curcontext,curcontext->pu_alloc_type);\n        }\n        prev = curr_chain;\n        dwarf_dealloc(dbg, item,itemtype);\n        prev->ch_item = 0;\n        curr_chain = curr_chain->ch_next;\n        dwarf_dealloc(dbg, prev, chaintype);\n    }\n}\n\nint\ndwarf_get_globals(Dwarf_Debug dbg,\n    Dwarf_Global ** globals,\n    Dwarf_Signed * return_count, Dwarf_Error * error)\n{\n    int res = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling dwarf_get_globals \"\n            \"Dwarf_Debug either null or it is\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_load_section(dbg, &dbg->de_debug_pubnames,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (!dbg->de_debug_pubnames.dss_size) {\n        return DW_DLV_NO_ENTRY;\n    }\n\n    res = _dwarf_internal_get_pubnames_like_data(dbg,\n        \".debug_pubnames\",\n        dbg->de_debug_pubnames.dss_data,\n        dbg->de_debug_pubnames.dss_size,\n        globals,\n        return_count,\n        error,\n        DW_DLA_GLOBAL_CONTEXT,\n        DW_DLA_GLOBAL,\n        DW_DLE_PUBNAMES_LENGTH_BAD,\n        DW_DLE_PUBNAMES_VERSION_ERROR);\n    return res;\n\n}\n\n/* Deallocating fully requires deallocating the list\n   and all entries.  But some internal data is\n   not exposed, so we need a function with internal knowledge.\n*/\n\nvoid\ndwarf_globals_dealloc(Dwarf_Debug dbg, Dwarf_Global * dwgl,\n    Dwarf_Signed count)\n{\n    _dwarf_internal_globals_dealloc(dbg, dwgl, count);\n    return;\n}\n\nvoid\n_dwarf_internal_globals_dealloc(Dwarf_Debug dbg,\n    Dwarf_Global * dwgl,\n    Dwarf_Signed count)\n{\n    Dwarf_Signed i = 0;\n    struct Dwarf_Global_Context_s *glcp = 0;\n    struct Dwarf_Global_Context_s *lastglcp = 0;\n\n    if (!dwgl) {\n        return;\n    }\n    for (i = 0; i < count; i++) {\n        Dwarf_Global dgd = dwgl[i];\n\n        if (!dgd) {\n            continue;\n        }\n        /*  Avoids duplicate frees of repeated\n            use of contexts (while assuming that\n            all uses of a particular gl_context\n            will appear next to each other. */\n        glcp = dgd->gl_context;\n        if (glcp && lastglcp != glcp) {\n            lastglcp = glcp;\n            dwarf_dealloc(dbg, glcp, glcp->pu_alloc_type);\n        }\n        dwarf_dealloc(dbg, dgd, dgd->gl_alloc_type);\n    }\n    dwarf_dealloc(dbg, dwgl, DW_DLA_LIST);\n    return;\n}\nstatic void\npubnames_error_length(Dwarf_Debug dbg,\n    Dwarf_Error *error,\n    Dwarf_Unsigned spaceneeded,\n    const char *secname,\n    const char *specificloc)\n{\n    dwarfstring m;\n\n    dwarfstring_constructor(&m);\n    dwarfstring_append(&m,\"DW_DLE_PUBNAMES_LENGTH_BAD: \"\n        \" In section \");\n    dwarfstring_append(&m,(char *)secname);\n    dwarfstring_append_printf_u(&m,\n        \" %u bytes of space needed \"\n        \"but the section is out of space \",\n        spaceneeded);\n    dwarfstring_append(&m, \"reading \");\n    dwarfstring_append(&m, (char *)specificloc);\n    dwarfstring_append(&m, \".\");\n    _dwarf_error_string(dbg,error,DW_DLE_PUBNAMES_LENGTH_BAD,\n        dwarfstring_string(&m));\n    dwarfstring_destructor(&m);\n}\n\n/*  INVARIANTS:\n    1) on error does not leak Dwarf_Global\n    2) glname is not malloc space. Never free.\n*/\nstatic int\n_dwarf_make_global_add_to_chain(Dwarf_Debug dbg,\n    Dwarf_Unsigned       global_DLA_code,\n    Dwarf_Global_Context pubnames_context,\n    Dwarf_Off            die_offset_in_cu,\n    unsigned char   *    glname,\n    Dwarf_Unsigned      *global_count,\n    Dwarf_Bool          *pubnames_context_on_list,\n    Dwarf_Chain         **plast_chain,\n    Dwarf_Error         *error)\n{\n    Dwarf_Chain  curr_chain = 0;\n    Dwarf_Global global = 0;\n\n    global = (Dwarf_Global)\n        _dwarf_get_alloc(dbg, global_DLA_code, 1);\n    if (!global) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    (*global_count)++;\n    /*  Recording the same context in another Dwarf_Global */\n    global->gl_context = pubnames_context;\n    global->gl_alloc_type = global_DLA_code;\n    global->gl_named_die_offset_within_cu = die_offset_in_cu;\n    global->gl_name = glname;\n    /* Finish off current entry chain */\n    curr_chain =\n        (Dwarf_Chain) _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);\n    if (!curr_chain) {\n        dwarf_dealloc(dbg,global,global_DLA_code);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    /* Put current global on singly_linked list. */\n    curr_chain->ch_item = (Dwarf_Global) global;\n    curr_chain->ch_itemtype = global_DLA_code;\n    (**plast_chain) = curr_chain;\n    *plast_chain = &(curr_chain->ch_next);\n    *pubnames_context_on_list = TRUE;\n    return DW_DLV_OK;\n}\n\n/* Sweeps the complete  section.  */\nint\n_dwarf_internal_get_pubnames_like_data(Dwarf_Debug dbg,\n    const char *secname,\n    Dwarf_Small * section_data_ptr,\n    Dwarf_Unsigned section_length,\n    Dwarf_Global ** globals,\n    Dwarf_Signed * return_count,\n    Dwarf_Error * error,\n    int context_DLA_code,\n    int global_DLA_code,\n    int length_err_num,\n    int version_err_num)\n{\n    Dwarf_Small *pubnames_like_ptr = 0;\n    Dwarf_Off pubnames_section_offset = 0;\n    Dwarf_Small *section_end_ptr = section_data_ptr +section_length;\n\n    /*  Points to the context for the current set of global names, and\n        contains information to identify the compilation-unit that the\n        set refers to. */\n    Dwarf_Global_Context pubnames_context = 0;\n    Dwarf_Bool           pubnames_context_on_list = FALSE;\n\n    Dwarf_Unsigned version = 0;\n\n    /*  Offset from the start of compilation-unit for the current\n        global. */\n    Dwarf_Off die_offset_in_cu = 0;\n\n    Dwarf_Unsigned global_count = 0;\n\n    /*  Used to chain the Dwarf_Global_s structs for\n        creating contiguous list of pointers to the structs. */\n    Dwarf_Chain head_chain = 0;\n    Dwarf_Chain *plast_chain = &head_chain;\n\n    /* Points to contiguous block of Dwarf_Global to be returned. */\n    Dwarf_Global *ret_globals = 0;\n    int mres = 0;\n\n    /* Temporary counter. */\n    Dwarf_Unsigned i = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling for pubnames-like data Dwarf_Debug \"\n            \"either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    /* We will eventually need the .debug_info data. Load it now. */\n    if (!dbg->de_debug_info.dss_data) {\n        int res = _dwarf_load_debug_info(dbg, error);\n\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    if (section_data_ptr == NULL) {\n        return DW_DLV_NO_ENTRY;\n    }\n    pubnames_like_ptr = section_data_ptr;\n    do {\n        Dwarf_Unsigned length = 0;\n        int local_extension_size = 0;\n        int local_length_size = 0;\n\n        /*  Some compilers emit padding at the end of each cu's area.\n            pubnames_ptr_past_end_cu records the true area end for the\n            pubnames(like) content of a cu.\n            Essentially the length in the header and the 0\n            terminator of the data are redundant information. The\n            dwarf2/3 spec does not mention what to do if the length is\n            past the 0 terminator. So we take any bytes left\n            after the 0 as padding and ignore them. */\n        Dwarf_Small *pubnames_ptr_past_end_cu = 0;\n\n        pubnames_context_on_list = FALSE;\n        pubnames_context = (Dwarf_Global_Context)\n            _dwarf_get_alloc(dbg, context_DLA_code, 1);\n        if (pubnames_context == NULL) {\n            dealloc_globals_chain(dbg,head_chain);\n            _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n            return DW_DLV_ERROR;\n        }\n        /*  ========pubnames_context not recorded anywhere yet. */\n        /*  READ_AREA_LENGTH updates pubnames_like_ptr for consumed\n            bytes. */\n        if ((pubnames_like_ptr + DWARF_32BIT_SIZE +\n            DWARF_HALF_SIZE + DWARF_32BIT_SIZE) >\n            /* A minimum size needed */\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                DWARF_32BIT_SIZE + DWARF_HALF_SIZE + DWARF_32BIT_SIZE,\n                secname,\n                \"header-record\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_area_length_ck_wrapper(dbg,\n            &length,&pubnames_like_ptr,&local_length_size,\n            &local_extension_size,section_length,section_end_ptr,\n            error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_context->pu_alloc_type = context_DLA_code;\n        pubnames_context->pu_length_size = local_length_size;\n        pubnames_context->pu_length = length;\n        pubnames_context->pu_extension_size = local_extension_size;\n        pubnames_context->pu_dbg = dbg;\n        pubnames_context->pu_pub_offset = pubnames_section_offset;\n        pubnames_ptr_past_end_cu = pubnames_like_ptr + length;\n        pubnames_context->pu_pub_entries_end_ptr =\n            pubnames_ptr_past_end_cu;\n\n        if ((pubnames_like_ptr + (DWARF_HALF_SIZE) ) >\n            /* A minimum size needed */\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                DWARF_HALF_SIZE,\n                secname,\"version-number\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &version,pubnames_like_ptr,DWARF_HALF_SIZE,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_context->pu_version = version;\n        pubnames_like_ptr += DWARF_HALF_SIZE;\n        /* ASSERT: DW_PUBNAMES_VERSION2 == DW_PUBTYPES_VERSION2 */\n        if (version != DW_PUBNAMES_VERSION2) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, version_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* Offset of CU header in debug section. */\n        if ((pubnames_like_ptr + 3*pubnames_context->pu_length_size)>\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                3*pubnames_context->pu_length_size,\n                secname,\n                \"header/DIE offsets\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &pubnames_context->pu_offset_of_cu_header,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n\n        FIX_UP_OFFSET_IRIX_BUG(dbg,\n            pubnames_context->pu_offset_of_cu_header,\n            \"pubnames cu header offset\");\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &pubnames_context->pu_info_length,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n\n        if (pubnames_like_ptr > (section_data_ptr + section_length)) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, length_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* ====begin pubname  */\n        /*  Read initial offset (of DIE within CU) of a pubname, final\n            entry is not a pair, just a zero offset. */\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &die_offset_in_cu,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            pubnames_context->pu_pub_entries_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n        FIX_UP_OFFSET_IRIX_BUG(dbg,\n            die_offset_in_cu, \"offset of die in cu\");\n        if (pubnames_like_ptr > (section_data_ptr + section_length)) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, length_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* Loop thru pairs. DIE off with CU followed by string. */\n        if (!die_offset_in_cu) {\n            if (dbg->de_return_empty_pubnames) {\n                int res = 0;\n\n                /*  Here we have a pubnames CU with no actual\n                    entries so we fake up an entry to hold the\n                    header data.  There are no 'pairs' here,\n                    just the end of list zero value.  We do this\n                    only if de_return_empty_pubnames is set\n                    so that we by default return exactly the same\n                    data this always returned, yet dwarfdump can\n                    request the empty-cu records get created\n                    to test that feature.\n                    see dwarf_get_globals_header()  */\n                res = _dwarf_make_global_add_to_chain(dbg,\n                    global_DLA_code,\n                    pubnames_context,\n                    die_offset_in_cu,\n                    /*  It is a fake global, so empty name */\n                    (unsigned char *)\"\",\n                    &global_count,\n                    &pubnames_context_on_list,\n                    &plast_chain,\n                    error);\n                if (res != DW_DLV_OK) {\n                    dealloc_globals_chain(dbg,head_chain);\n                    if (!pubnames_context_on_list) {\n                        dwarf_dealloc(dbg,pubnames_context,\n                            context_DLA_code);\n                    }\n                    return res;\n                }\n                /*  ========pubnames_context recorded in chain. */\n            } else {\n                /*  The section is empty.\n                    Nowhere to record pubnames_context); */\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n                pubnames_context = 0;\n                continue;\n            }\n        }\n        while (die_offset_in_cu) {\n            int res = 0;\n            unsigned char *glname = 0;\n\n            /*  non-zero die_offset_in_cu already read, so\n                pubnames_like_ptr points to a string.  */\n            res = _dwarf_check_string_valid(dbg,section_data_ptr,\n                pubnames_like_ptr,\n                pubnames_context->pu_pub_entries_end_ptr,\n                DW_DLE_STRING_OFF_END_PUBNAMES_LIKE,error);\n            if (res != DW_DLV_OK) {\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return res;\n            }\n            glname = (unsigned char *)pubnames_like_ptr;\n            pubnames_like_ptr = pubnames_like_ptr +\n                strlen((char *) pubnames_like_ptr) + 1;\n            /*  Already read offset and verified string, glname\n                now points to the string. */\n            res = _dwarf_make_global_add_to_chain(dbg,\n                global_DLA_code,\n                pubnames_context,\n                die_offset_in_cu,\n                glname,\n                &global_count,\n                &pubnames_context_on_list,\n                &plast_chain,\n                error);\n            if (res != DW_DLV_OK) {\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return res;\n            }\n            /*  ========pubnames_context recorded in chain. */\n            /*  Ensure room for a next entry  to exist. */\n            if ((pubnames_like_ptr +\n                pubnames_context->pu_length_size ) >\n                section_end_ptr) {\n                pubnames_error_length(dbg,error,\n                    2*pubnames_context->pu_length_size,\n                    secname,\n                    \"global record offset\");\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return DW_DLV_ERROR;\n            }\n            /* Read die offset for the *next* entry */\n            mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n                &die_offset_in_cu,\n                pubnames_like_ptr,\n                pubnames_context->pu_length_size,\n                pubnames_context->pu_pub_entries_end_ptr,\n                error);\n            if (mres != DW_DLV_OK) {\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                dealloc_globals_chain(dbg,head_chain);\n                return mres;\n            }\n            pubnames_like_ptr += pubnames_context->pu_length_size;\n            FIX_UP_OFFSET_IRIX_BUG(dbg,\n                die_offset_in_cu, \"offset of next die in cu\");\n            if (pubnames_like_ptr >\n                (section_data_ptr + section_length)) {\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                dealloc_globals_chain(dbg,head_chain);\n                _dwarf_error(dbg, error, length_err_num);\n                return DW_DLV_ERROR;\n            }\n        }\n        /* ASSERT: die_offset_in_cu == 0 */\n        if (pubnames_like_ptr > pubnames_ptr_past_end_cu) {\n            /* This is some kind of error. This simply cannot happen.\n            The encoding is wrong or the length in the header for\n            this cu's contribution is wrong. */\n            _dwarf_error(dbg, error, length_err_num);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            dealloc_globals_chain(dbg,head_chain);\n            return DW_DLV_ERROR;\n        }\n        /*  If there is some kind of padding at the end of\n            the section,\n            as emitted by some compilers, skip over that padding and\n            simply ignore the bytes thus passed-over.  With most\n            compilers, pubnames_like_ptr ==\n            pubnames_ptr_past_end_cu at this point */\n        {\n            Dwarf_Unsigned increment =\n                pubnames_context->pu_length_size +\n                pubnames_context->pu_length +\n                pubnames_context->pu_extension_size;\n            pubnames_section_offset += increment;\n        }\n        pubnames_like_ptr = pubnames_ptr_past_end_cu;\n    } while (pubnames_like_ptr < section_end_ptr);\n\n    /* Points to contiguous block of Dwarf_Global. */\n    ret_globals = (Dwarf_Global *)\n        _dwarf_get_alloc(dbg, DW_DLA_LIST, global_count);\n    if (ret_globals == NULL) {\n        if (!pubnames_context_on_list) {\n            dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n        }\n        dealloc_globals_chain(dbg,head_chain);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    /*  Store pointers to Dwarf_Global_s structs in contiguous block,\n        and deallocate the chain.  This ignores the various\n        headers */\n    {\n        Dwarf_Chain curr_chain = 0;\n        curr_chain = head_chain;\n        for (i = 0; i < global_count; i++) {\n            Dwarf_Chain prev = 0;\n\n            *(ret_globals + i) = curr_chain->ch_item;\n            prev = curr_chain;\n            curr_chain = curr_chain->ch_next;\n            prev->ch_item = 0; /* Not actually necessary. */\n            dwarf_dealloc(dbg, prev, DW_DLA_CHAIN);\n        }\n    }\n    *globals = ret_globals;\n    *return_count = (Dwarf_Signed) global_count;\n    return DW_DLV_OK;\n}\n\n/*  Given a pubnames entry (or other like section entry)\n    return thru the ret_name pointer\n    a pointer to the string which is the entry name.  */\nint\ndwarf_globname(Dwarf_Global glob,\n    char **ret_name,\n    Dwarf_Error * error)\n{\n    if (glob == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    *ret_name = (char *) (glob->gl_name);\n    return DW_DLV_OK;\n}\n\n/*  Given a pubnames entry (or other like section entry)\n    return thru the ret_off pointer the\n    global offset of the DIE for this entry.\n    The global offset is the offset within the .debug_info\n    section as a whole.  */\nint\ndwarf_global_die_offset(Dwarf_Global global,\n    Dwarf_Off * ret_off, Dwarf_Error * error)\n{\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    if (global->gl_context == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    *ret_off = (global->gl_named_die_offset_within_cu +\n        global->gl_context->pu_offset_of_cu_header);\n    return DW_DLV_OK;\n}\n\n/*  Given a pubnames entry (or other like section entry)\n    return thru the ret_off pointer the\n    offset of the compilation unit header of the\n    compilation unit the global is part of.\n*/\nint\ndwarf_global_cu_offset(Dwarf_Global global,\n    Dwarf_Off * cu_header_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Global_Context con = 0;\n\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n    con = global->gl_context;\n    if (con == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n    *cu_header_offset = con->pu_offset_of_cu_header;\n    return DW_DLV_OK;\n}\n\nstatic void\nbuild_off_end_msg(Dwarf_Unsigned offval,\n    Dwarf_Unsigned withincr,\n    Dwarf_Unsigned secsize,\n    dwarfstring *m)\n{\n    const char *msg = \"past\";\n    if (offval < secsize){\n        msg = \"too near\";\n    }\n    dwarfstring_append_printf_u(m,\"DW_DLE_OFFSET_BAD: \"\n        \"The CU header offset of %u in a pubnames-like entry \",\n        withincr);\n    dwarfstring_append_printf_s(m,\n        \"would put us %s the end of .debug_info. \"\n        \"No room for a DIE there... \"\n        \"Corrupt Dwarf.\",(char *)msg);\n    return;\n}\n\n/*\n  Give back the pubnames entry (or any other like section)\n  name, symbol DIE offset, and the cu-DIE offset.\n\n  Various errors are possible.\n\n  The string pointer returned thru ret_name is not\n  dwarf_get_alloc()ed, so no dwarf_dealloc()\n  DW_DLA_STRING should be applied to it.\n\n*/\nint\ndwarf_global_name_offsets(Dwarf_Global global,\n    char **ret_name,\n    Dwarf_Off * die_offset,\n    Dwarf_Off * cu_die_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Global_Context con = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_Off cuhdr_off = 0;\n\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    con = global->gl_context;\n    if (con == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    cuhdr_off = con->pu_offset_of_cu_header;\n    /*  The offset had better not be too close to the end. If it is,\n        _dwarf_length_of_cu_header() will step off the end\n        and therefore\n        must not be used. 10 is a meaningless heuristic, but no CU\n        header is that small so it is safe. An erroneous offset is due\n        to a bug in the tool chain. A bug like this has been seen on\n        IRIX with MIPSpro 7.3.1.3 and an executable > 2GB in size and\n        with 2 million pubnames entries. */\n#define MIN_CU_HDR_SIZE 10\n    dbg = con->pu_dbg;\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: Either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    /* Cannot refer to debug_types */\n    if (dbg->de_debug_info.dss_size &&\n        ((cuhdr_off + MIN_CU_HDR_SIZE) >=\n        dbg->de_debug_info.dss_size)) {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        build_off_end_msg(cuhdr_off,cuhdr_off+MIN_CU_HDR_SIZE,\n            dbg->de_debug_info.dss_size,&m);\n        _dwarf_error_string(dbg, error, DW_DLE_OFFSET_BAD,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n    }\n#undef MIN_CU_HDR_SIZE\n    /*  If global->gl_named_die_offset_within_cu\n        is zero then this is a fake global for\n        a pubnames CU with no pubnames. The offset is from the\n        start of the CU header, so no die can have a zero\n        offset, all valid offsets are positive numbers */\n    if (die_offset) {\n        if (global->gl_named_die_offset_within_cu) {\n            *die_offset = global->gl_named_die_offset_within_cu +\n                cuhdr_off;\n        } else {\n            *die_offset = 0;\n        }\n    }\n    *ret_name = (char *) global->gl_name;\n    if (cu_die_offset) {\n        /* Globals cannot refer to debug_types */\n        int cres = 0;\n        Dwarf_Unsigned headerlen = 0;\n        int res = _dwarf_load_debug_info(dbg, error);\n\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        /*  The offset had better not be too close to the end.\n            If it is,\n            _dwarf_length_of_cu_header() will step off the end and\n            therefore must not be used. 10 is a meaningless heuristic,\n            but no CU header is that small so it is safe. */\n        /* Globals cannot refer to debug_types */\n        if ((cuhdr_off + 10) >= dbg->de_debug_info.dss_size) {\n            dwarfstring m;\n\n            dwarfstring_constructor(&m);\n            build_off_end_msg(cuhdr_off,cuhdr_off+10,\n                dbg->de_debug_info.dss_size,&m);\n            _dwarf_error_string(dbg, error, DW_DLE_OFFSET_BAD,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            return DW_DLV_ERROR;\n        }\n        cres = _dwarf_length_of_cu_header(dbg, cuhdr_off,true,\n            &headerlen,error);\n        if (cres != DW_DLV_OK) {\n            return cres;\n        }\n        *cu_die_offset = cuhdr_off + headerlen;\n    }\n    return DW_DLV_OK;\n}\n\n/*  New February 2019 from better dwarfdump printing\n    of debug_pubnames and pubtypes.\n    For ao the Dwarf_Global records in one pubnames\n    CU group exactly the same data will be returned.\n\n*/\nint\ndwarf_get_globals_header(Dwarf_Global global,\n    Dwarf_Off      *pub_section_hdr_offset,\n    Dwarf_Unsigned *pub_offset_size,\n    Dwarf_Unsigned *pub_cu_length,\n    Dwarf_Unsigned *version,\n    Dwarf_Off      *info_header_offset,\n    Dwarf_Unsigned *info_length,\n    Dwarf_Error*   error)\n{\n    Dwarf_Global_Context con = 0;\n    Dwarf_Debug dbg = 0;\n\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n    con = global->gl_context;\n    if (con == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n    dbg = con->pu_dbg;\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling dwarf_get_globals_header() \"\n            \"either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    if (pub_section_hdr_offset) {\n        *pub_section_hdr_offset = con->pu_pub_offset;\n    }\n    if (pub_offset_size) {\n        *pub_offset_size = con->pu_length_size;\n    }\n    if (pub_cu_length) {\n        *pub_cu_length = con->pu_length;\n    }\n    if (version) {\n        *version = con->pu_version;\n    }\n    if (info_header_offset) {\n        *info_header_offset = con->pu_offset_of_cu_header;\n    }\n    if (info_length) {\n        *info_length = con->pu_info_length;\n    }\n    return DW_DLV_OK;\n}\n\n/*  We have the offset to a CU header.\n    Return thru outFileOffset the offset of the CU DIE.\n\n    New June, 2001.\n    Used by SGI IRIX debuggers.\n    No error used to be possible.\n    As of May 2016 an error is possible if the DWARF is\n    corrupted! (IRIX debuggers are no longer built ...)\n\n    See also dwarf_CU_dieoffset_given_die().\n\n    This is assumed to never apply to data in .debug_types, it\n    only refers to .debug_info.\n\n*/\n\n/* ARGSUSED */\n/*  The following version new in October 2011, does allow finding\n    the offset if one knows whether debug_info or debug_types\n    or any .debug_info type including the DWARF5 flavors.\n\n    It indirectly calls _dwarf_length_of_cu_header()\n    which knows all the varieties of header.  */\nint\ndwarf_get_cu_die_offset_given_cu_header_offset_b(Dwarf_Debug dbg,\n    Dwarf_Off in_cu_header_offset,\n    Dwarf_Bool is_info,\n    Dwarf_Off * out_cu_die_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Off headerlen = 0;\n    int cres = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling dwarf_get_cu_die_offset_given\"\n            \"cu_header_offset_b Dwarf_Debug is\"\n            \"either null or it is\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    cres = _dwarf_length_of_cu_header(dbg,\n        in_cu_header_offset,is_info, &headerlen,error);\n    if (cres != DW_DLV_OK) {\n        return cres;\n    }\n    *out_cu_die_offset = in_cu_header_offset + headerlen;\n    return DW_DLV_OK;\n}\n/*  dwarf_CU_dieoffset_given_die returns\n    the global debug_info section offset of the CU die\n    that is the CU containing the given (passed-in) die.\n    This information makes it possible for a consumer to\n    find and print context information for any die.\n\n    Use dwarf_offdie_b() passing in the offset this returns\n    to get a die pointer to the CU die.  */\nint\ndwarf_CU_dieoffset_given_die(Dwarf_Die die,\n    Dwarf_Off*       return_offset,\n    Dwarf_Error*     error)\n{\n    Dwarf_Off  dieoff = 0;\n    Dwarf_CU_Context cucontext = 0;\n\n    CHECK_DIE(die, DW_DLV_ERROR);\n    cucontext = die->di_cu_context;\n    dieoff =  cucontext->cc_debug_offset;\n    /*  The following call cannot fail, so no error check. */\n    dwarf_get_cu_die_offset_given_cu_header_offset_b(\n        cucontext->cc_dbg, dieoff,\n        die->di_is_info, return_offset,error);\n    return DW_DLV_OK;\n}\n\nint dwarf_return_empty_pubnames(Dwarf_Debug dbg, int flag)\n{\n    if (dbg == NULL) {\n        return DW_DLV_OK;\n    }\n    if (flag && flag != 1) {\n        return DW_DLV_OK;\n    }\n    dbg->de_return_empty_pubnames = (unsigned char)flag;\n    return DW_DLV_OK;\n}\n"], "fixing_code": ["/*\n\n  Copyright (C) 2000-2005 Silicon Graphics, Inc.  All Rights Reserved.\n  Portions Copyright (C) 2007-2011 David Anderson. All Rights Reserved.\n\n  This program is free software; you can redistribute it\n  and/or modify it under the terms of version 2.1 of the\n  GNU Lesser General Public License as published by the Free\n  Software Foundation.\n\n  This program is distributed in the hope that it would be\n  useful, but WITHOUT ANY WARRANTY; without even the implied\n  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE.\n\n  Further, this software is distributed without any warranty\n  that it is free of the rightful claim of any third person\n  regarding infringement or the like.  Any license provided\n  herein, whether implied or otherwise, applies only to this\n  software file.  Patent licenses, if any, provided herein\n  do not apply to combinations of this program with other\n  software, or any other product whatsoever.\n\n  You should have received a copy of the GNU Lesser General\n  Public License along with this program; if not, write the\n  Free Software Foundation, Inc., 51 Franklin Street - Fifth\n  Floor, Boston MA 02110-1301, USA.\n\n*/\n\n#include <config.h>\n\n#include <string.h> /* strlen() */\n#if defined(_WIN32) && defined(HAVE_STDAFX_H)\n#include \"stdafx.h\"\n#endif /* HAVE_STDAFX_H */\n\n#include \"dwarf.h\"\n#include \"libdwarf.h\"\n#include \"libdwarf_private.h\"\n#include \"dwarf_base_types.h\"\n#include \"dwarf_opaque.h\"\n#include \"dwarf_alloc.h\"\n#include \"dwarf_error.h\"\n#include \"dwarf_util.h\"\n#include \"dwarf_string.h\"\n#include \"dwarf_global.h\"\n\n#ifdef __sgi  /* __sgi should only be defined for IRIX/MIPS. */\n/* The 'fixup' here intended for IRIX targets only.\n   With a  2+GB Elf64 IRIX executable (under 4GB in size),\n   some DIE offsets wrongly\n   got the 32bit upper bit sign extended.  For the cu-header\n   offset in the .debug_pubnames section  and in the\n   .debug_aranges section.\n   the 'varp' here is a pointer to an offset into .debug_info.\n   We fix up the offset here if it seems advisable..\n\n   As of June 2005 we have identified a series of mistakes\n   in ldx64 that can cause this (64 bit values getting passed\n   thru 32-bit signed knothole).\n*/\nvoid\n_dwarf_fix_up_offset_irix(Dwarf_Debug dbg,\n    Dwarf_Unsigned * varp, char *caller_site_name)\n{\n\n    Dwarf_Unsigned var = *varp;\n\n#define UPPER33 0xffffffff80000000LL\n#define LOWER32         0xffffffffLL\n    /*  Restrict the hack to the known case. Upper 32 bits erroneously\n        sign extended from lower 32 upper bit. */\n    if ((var & UPPER33) == UPPER33) {\n        var &= LOWER32;\n        /* Apply the fix. Dreadful hack. */\n        *varp = var;\n    }\n#undef UPPER33\n#undef LOWER32\n    return;\n}\n#endif /* __sgi */\n\n#if 0\n/*  Debugging only. Requires start. can calulate one of len, end */\nstatic void\ndebug_print_range(const char *msg,\n    int lineno,\n    void *start, signed long len,\n    void *end)\n{\n\n    char *st = (char *)start;\n    char *en = (char *)end;\n    signed long le = len;\n\n    if (len) {\n        if (en) {\n            le = (long)(en-st);\n        } else {\n            en= start+len;\n        }\n    } else if (en) {\n        le = (long)(en-st);\n    }\n    printf(\"RANGEdebug %s  st=0x%lx le=%ld en=0x%lx line %d\\n\",\n        msg,(unsigned long)st,le,(unsigned long)en,lineno);\n}\n#endif\n\nstatic void\ndealloc_globals_chain(Dwarf_Debug dbg,\n    Dwarf_Chain head_chain)\n{\n    Dwarf_Chain curr_chain = 0;\n    int chaintype = DW_DLA_CHAIN;\n    Dwarf_Global_Context lastcontext = 0;\n    Dwarf_Global_Context curcontext = 0;\n\n    curr_chain = head_chain;\n    for (; curr_chain; ) {\n        Dwarf_Global item = 0;\n        int itemtype = 0;\n        Dwarf_Chain prev = 0;\n\n        item = (Dwarf_Global)curr_chain->ch_item;\n        itemtype = curr_chain->ch_itemtype;\n        curcontext = item->gl_context;\n        if (curcontext && curcontext != lastcontext) {\n            /* First time we see a context, dealloc it. */\n            lastcontext = curcontext;\n            dwarf_dealloc(dbg,curcontext,curcontext->pu_alloc_type);\n        }\n        prev = curr_chain;\n        dwarf_dealloc(dbg, item,itemtype);\n        prev->ch_item = 0;\n        curr_chain = curr_chain->ch_next;\n        dwarf_dealloc(dbg, prev, chaintype);\n    }\n}\n\nint\ndwarf_get_globals(Dwarf_Debug dbg,\n    Dwarf_Global ** globals,\n    Dwarf_Signed * return_count, Dwarf_Error * error)\n{\n    int res = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling dwarf_get_globals \"\n            \"Dwarf_Debug either null or it is\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    res = _dwarf_load_section(dbg, &dbg->de_debug_pubnames,error);\n    if (res != DW_DLV_OK) {\n        return res;\n    }\n    if (!dbg->de_debug_pubnames.dss_size) {\n        return DW_DLV_NO_ENTRY;\n    }\n\n    res = _dwarf_internal_get_pubnames_like_data(dbg,\n        \".debug_pubnames\",\n        dbg->de_debug_pubnames.dss_data,\n        dbg->de_debug_pubnames.dss_size,\n        globals,\n        return_count,\n        error,\n        DW_DLA_GLOBAL_CONTEXT,\n        DW_DLA_GLOBAL,\n        DW_DLE_PUBNAMES_LENGTH_BAD,\n        DW_DLE_PUBNAMES_VERSION_ERROR);\n    return res;\n\n}\n\n/* Deallocating fully requires deallocating the list\n   and all entries.  But some internal data is\n   not exposed, so we need a function with internal knowledge.\n*/\n\nvoid\ndwarf_globals_dealloc(Dwarf_Debug dbg, Dwarf_Global * dwgl,\n    Dwarf_Signed count)\n{\n    _dwarf_internal_globals_dealloc(dbg, dwgl, count);\n    return;\n}\n\nvoid\n_dwarf_internal_globals_dealloc(Dwarf_Debug dbg,\n    Dwarf_Global * dwgl,\n    Dwarf_Signed count)\n{\n    Dwarf_Signed i = 0;\n    struct Dwarf_Global_Context_s *glcp = 0;\n    struct Dwarf_Global_Context_s *lastglcp = 0;\n\n    if (!dwgl) {\n        return;\n    }\n    for (i = 0; i < count; i++) {\n        Dwarf_Global dgd = dwgl[i];\n\n        if (!dgd) {\n            continue;\n        }\n        /*  Avoids duplicate frees of repeated\n            use of contexts (while assuming that\n            all uses of a particular gl_context\n            will appear next to each other. */\n        glcp = dgd->gl_context;\n        if (glcp && lastglcp != glcp) {\n            lastglcp = glcp;\n            dwarf_dealloc(dbg, glcp, glcp->pu_alloc_type);\n        }\n        dwarf_dealloc(dbg, dgd, dgd->gl_alloc_type);\n    }\n    dwarf_dealloc(dbg, dwgl, DW_DLA_LIST);\n    return;\n}\nstatic void\npubnames_error_length(Dwarf_Debug dbg,\n    Dwarf_Error *error,\n    Dwarf_Unsigned spaceneeded,\n    const char *secname,\n    const char *specificloc)\n{\n    dwarfstring m;\n\n    dwarfstring_constructor(&m);\n    dwarfstring_append(&m,\"DW_DLE_PUBNAMES_LENGTH_BAD: \"\n        \" In section \");\n    dwarfstring_append(&m,(char *)secname);\n    dwarfstring_append_printf_u(&m,\n        \" %u bytes of space needed \"\n        \"but the section is out of space \",\n        spaceneeded);\n    dwarfstring_append(&m, \"reading \");\n    dwarfstring_append(&m, (char *)specificloc);\n    dwarfstring_append(&m, \".\");\n    _dwarf_error_string(dbg,error,DW_DLE_PUBNAMES_LENGTH_BAD,\n        dwarfstring_string(&m));\n    dwarfstring_destructor(&m);\n}\n\n/*  INVARIANTS:\n    1) on error does not leak Dwarf_Global\n    2) glname is not malloc space. Never free.\n*/\nstatic int\n_dwarf_make_global_add_to_chain(Dwarf_Debug dbg,\n    Dwarf_Unsigned       global_DLA_code,\n    Dwarf_Global_Context pubnames_context,\n    Dwarf_Off            die_offset_in_cu,\n    unsigned char   *    glname,\n    Dwarf_Unsigned      *global_count,\n    Dwarf_Bool          *pubnames_context_on_list,\n    Dwarf_Chain         **plast_chain,\n    Dwarf_Error         *error)\n{\n    Dwarf_Chain  curr_chain = 0;\n    Dwarf_Global global = 0;\n\n    global = (Dwarf_Global)\n        _dwarf_get_alloc(dbg, global_DLA_code, 1);\n    if (!global) {\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    (*global_count)++;\n    /*  Recording the same context in another Dwarf_Global */\n    global->gl_context = pubnames_context;\n    global->gl_alloc_type = global_DLA_code;\n    global->gl_named_die_offset_within_cu = die_offset_in_cu;\n    global->gl_name = glname;\n    /* Finish off current entry chain */\n    curr_chain =\n        (Dwarf_Chain) _dwarf_get_alloc(dbg, DW_DLA_CHAIN, 1);\n    if (!curr_chain) {\n        dwarf_dealloc(dbg,global,global_DLA_code);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n    /* Put current global on singly_linked list. */\n    curr_chain->ch_item = (Dwarf_Global) global;\n    curr_chain->ch_itemtype = global_DLA_code;\n    (**plast_chain) = curr_chain;\n    *plast_chain = &(curr_chain->ch_next);\n    *pubnames_context_on_list = TRUE;\n    return DW_DLV_OK;\n}\n\n/* Sweeps the complete  section.  */\nint\n_dwarf_internal_get_pubnames_like_data(Dwarf_Debug dbg,\n    const char *secname,\n    Dwarf_Small * section_data_ptr,\n    Dwarf_Unsigned section_length,\n    Dwarf_Global ** globals,\n    Dwarf_Signed * return_count,\n    Dwarf_Error * error,\n    int context_DLA_code,\n    int global_DLA_code,\n    int length_err_num,\n    int version_err_num)\n{\n    Dwarf_Small *pubnames_like_ptr = 0;\n    Dwarf_Off pubnames_section_offset = 0;\n    Dwarf_Small *section_end_ptr = section_data_ptr +section_length;\n\n    /*  Points to the context for the current set of global names,\n        and contains information to identify the compilation-unit\n        that the set refers to. */\n    Dwarf_Global_Context pubnames_context = 0;\n    Dwarf_Bool           pubnames_context_on_list = FALSE;\n\n    Dwarf_Unsigned version = 0;\n\n    /*  Offset from the start of compilation-unit for the current\n        global. */\n    Dwarf_Off die_offset_in_cu = 0;\n\n    Dwarf_Unsigned global_count = 0;\n\n    /*  The count is just to improve the error message\n        a few lines above. */\n    Dwarf_Unsigned context_count = 0;\n\n    /*  Used to chain the Dwarf_Global_s structs for\n        creating contiguous list of pointers to the structs. */\n    Dwarf_Chain head_chain = 0;\n    Dwarf_Chain *plast_chain = &head_chain;\n\n    /* Points to contiguous block of Dwarf_Global to be returned. */\n    Dwarf_Global *ret_globals = 0;\n    int mres = 0;\n\n    /* Temporary counter. */\n    Dwarf_Unsigned i = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling for pubnames-like data Dwarf_Debug \"\n            \"either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    /* We will eventually need the .debug_info data. Load it now. */\n    if (!dbg->de_debug_info.dss_data) {\n        int res = _dwarf_load_debug_info(dbg, error);\n\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n    }\n    if (section_data_ptr == NULL) {\n        return DW_DLV_NO_ENTRY;\n    }\n    pubnames_like_ptr = section_data_ptr;\n    do {\n        Dwarf_Unsigned length = 0;\n        int local_extension_size = 0;\n        int local_length_size = 0;\n\n        /*  Some compilers emit padding at the end of each cu's area.\n            pubnames_ptr_past_end_cu records the true area end for the\n            pubnames(like) content of a cu.\n            Essentially the length in the header and the 0\n            terminator of the data are redundant information. The\n            dwarf2/3 spec does not mention what to do if the length is\n            past the 0 terminator. So we take any bytes left\n            after the 0 as padding and ignore them. */\n        Dwarf_Small *pubnames_ptr_past_end_cu = 0;\n\n        pubnames_context_on_list = FALSE;\n        pubnames_context = (Dwarf_Global_Context)\n            _dwarf_get_alloc(dbg, context_DLA_code, 1);\n        if (pubnames_context == NULL) {\n            dealloc_globals_chain(dbg,head_chain);\n            _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n            return DW_DLV_ERROR;\n        }\n        /*  ========pubnames_context not recorded anywhere yet. */\n        /*  READ_AREA_LENGTH updates pubnames_like_ptr for consumed\n            bytes. */\n        if ((pubnames_like_ptr + DWARF_32BIT_SIZE +\n            DWARF_HALF_SIZE + DWARF_32BIT_SIZE) >\n            /* A minimum size needed */\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                DWARF_32BIT_SIZE + DWARF_HALF_SIZE + DWARF_32BIT_SIZE,\n                secname,\n                \"header-record\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_area_length_ck_wrapper(dbg,\n            &length,&pubnames_like_ptr,&local_length_size,\n            &local_extension_size,section_length,section_end_ptr,\n            error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        {\n            Dwarf_Small * localend =pubnames_like_ptr + length;\n\n            if ((length > section_length) ||\n                (localend > section_end_ptr)){\n                /*  The length field  is corrupted */\n                dwarfstring m;\n\n                dwarfstring_constructor(&m);\n                dwarfstring_append_printf_u(&m,\n                    \"DW_DLE_PUBNAMES_LENGTH_BAD (or similar) \"\n                    \"A DWARF length field in cu context %u \",\n                    context_count);\n                dwarfstring_append_printf_s(&m,\"of section %s \",\n                    (char *)secname);\n                dwarfstring_append_printf_u(&m,\"of \"\n                    \"%u bytes \",length);\n                dwarfstring_append_printf_u(&m,\n                    \"runs off the end of \"\n                    \"the %u bytes of the real section\",\n                    section_length);\n                _dwarf_error_string(dbg, error,length_err_num,\n                    dwarfstring_string(&m));\n                dwarfstring_destructor(&m);\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return DW_DLV_ERROR;\n            }\n        }\n        /*  The count is just to improve the error message\n            a few lines above. */\n        ++context_count;\n        pubnames_context->pu_alloc_type = context_DLA_code;\n        pubnames_context->pu_length_size = local_length_size;\n        pubnames_context->pu_length = length;\n        pubnames_context->pu_extension_size = local_extension_size;\n        pubnames_context->pu_dbg = dbg;\n        pubnames_context->pu_pub_offset = pubnames_section_offset;\n        pubnames_ptr_past_end_cu = pubnames_like_ptr + length;\n        pubnames_context->pu_pub_entries_end_ptr =\n            pubnames_ptr_past_end_cu;\n        if ((pubnames_like_ptr + (DWARF_HALF_SIZE) ) >=\n            /* A minimum size needed */\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                DWARF_HALF_SIZE,\n                secname,\"version-number\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &version,pubnames_like_ptr,DWARF_HALF_SIZE,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_context->pu_version = version;\n        pubnames_like_ptr += DWARF_HALF_SIZE;\n        /* ASSERT: DW_PUBNAMES_VERSION2 == DW_PUBTYPES_VERSION2 */\n        if (version != DW_PUBNAMES_VERSION2) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, version_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* Offset of CU header in debug section. */\n        if ((pubnames_like_ptr + 3*pubnames_context->pu_length_size)>\n            section_end_ptr) {\n            pubnames_error_length(dbg,error,\n                3*pubnames_context->pu_length_size,\n                secname,\n                \"header/DIE offsets\");\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return DW_DLV_ERROR;\n        }\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &pubnames_context->pu_offset_of_cu_header,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n\n        FIX_UP_OFFSET_IRIX_BUG(dbg,\n            pubnames_context->pu_offset_of_cu_header,\n            \"pubnames cu header offset\");\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &pubnames_context->pu_info_length,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            section_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n\n        if (pubnames_like_ptr > (section_data_ptr + section_length)) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, length_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* ====begin pubname  */\n        /*  Read initial offset (of DIE within CU) of a pubname, final\n            entry is not a pair, just a zero offset. */\n        mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n            &die_offset_in_cu,\n            pubnames_like_ptr,\n            pubnames_context->pu_length_size,\n            pubnames_context->pu_pub_entries_end_ptr,error);\n        if (mres != DW_DLV_OK) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            return mres;\n        }\n        pubnames_like_ptr += pubnames_context->pu_length_size;\n        FIX_UP_OFFSET_IRIX_BUG(dbg,\n            die_offset_in_cu, \"offset of die in cu\");\n        if (pubnames_like_ptr > (section_data_ptr + section_length)) {\n            dealloc_globals_chain(dbg,head_chain);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            _dwarf_error(dbg, error, length_err_num);\n            return DW_DLV_ERROR;\n        }\n\n        /* Loop thru pairs. DIE off with CU followed by string. */\n        if (!die_offset_in_cu) {\n            if (dbg->de_return_empty_pubnames) {\n                int res = 0;\n\n                /*  Here we have a pubnames CU with no actual\n                    entries so we fake up an entry to hold the\n                    header data.  There are no 'pairs' here,\n                    just the end of list zero value.  We do this\n                    only if de_return_empty_pubnames is set\n                    so that we by default return exactly the same\n                    data this always returned, yet dwarfdump can\n                    request the empty-cu records get created\n                    to test that feature.\n                    see dwarf_get_globals_header()  */\n                res = _dwarf_make_global_add_to_chain(dbg,\n                    global_DLA_code,\n                    pubnames_context,\n                    die_offset_in_cu,\n                    /*  It is a fake global, so empty name */\n                    (unsigned char *)\"\",\n                    &global_count,\n                    &pubnames_context_on_list,\n                    &plast_chain,\n                    error);\n                if (res != DW_DLV_OK) {\n                    dealloc_globals_chain(dbg,head_chain);\n                    if (!pubnames_context_on_list) {\n                        dwarf_dealloc(dbg,pubnames_context,\n                            context_DLA_code);\n                    }\n                    return res;\n                }\n                /*  ========pubnames_context recorded in chain. */\n            } else {\n                /*  The section is empty.\n                    Nowhere to record pubnames_context); */\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n                pubnames_context = 0;\n                continue;\n            }\n        }\n        while (die_offset_in_cu) {\n            int res = 0;\n            unsigned char *glname = 0;\n            Dwarf_Unsigned nstrlen = 0;\n\n            /*  non-zero die_offset_in_cu already read, so\n                pubnames_like_ptr points to a string.  */\n            res = _dwarf_check_string_valid(dbg,section_data_ptr,\n                pubnames_like_ptr,\n                pubnames_context->pu_pub_entries_end_ptr,\n                DW_DLE_STRING_OFF_END_PUBNAMES_LIKE,error);\n            if (res != DW_DLV_OK) {\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return res;\n            }\n            glname = (unsigned char *)pubnames_like_ptr;\n            nstrlen = strlen((char *)pubnames_like_ptr);\n            pubnames_like_ptr += nstrlen + 1;\n            /*  Already read offset and verified string, glname\n                now points to the string. */\n            res = _dwarf_make_global_add_to_chain(dbg,\n                global_DLA_code,\n                pubnames_context,\n                die_offset_in_cu,\n                glname,\n                &global_count,\n                &pubnames_context_on_list,\n                &plast_chain,\n                error);\n            if (res != DW_DLV_OK) {\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return res;\n            }\n            /*  ========pubnames_context recorded in chain. */\n            /*  Ensure room for a next entry  to exist. */\n            if ((pubnames_like_ptr +\n                pubnames_context->pu_length_size ) >\n                section_end_ptr) {\n                pubnames_error_length(dbg,error,\n                    2*pubnames_context->pu_length_size,\n                    secname,\n                    \"global record offset\");\n                dealloc_globals_chain(dbg,head_chain);\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                return DW_DLV_ERROR;\n            }\n            /* Read die offset for the *next* entry */\n            mres = _dwarf_read_unaligned_ck_wrapper(dbg,\n                &die_offset_in_cu,\n                pubnames_like_ptr,\n                pubnames_context->pu_length_size,\n                pubnames_context->pu_pub_entries_end_ptr,\n                error);\n            if (mres != DW_DLV_OK) {\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                dealloc_globals_chain(dbg,head_chain);\n                return mres;\n            }\n            pubnames_like_ptr += pubnames_context->pu_length_size;\n            FIX_UP_OFFSET_IRIX_BUG(dbg,\n                die_offset_in_cu, \"offset of next die in cu\");\n            if (pubnames_like_ptr >\n                (section_data_ptr + section_length)) {\n                if (!pubnames_context_on_list) {\n                    dwarf_dealloc(dbg,pubnames_context,\n                        context_DLA_code);\n                }\n                dealloc_globals_chain(dbg,head_chain);\n                _dwarf_error(dbg, error, length_err_num);\n                return DW_DLV_ERROR;\n            }\n        }\n        /* ASSERT: die_offset_in_cu == 0 */\n        if (pubnames_like_ptr > pubnames_ptr_past_end_cu) {\n            /* This is some kind of error. This simply cannot happen.\n            The encoding is wrong or the length in the header for\n            this cu's contribution is wrong. */\n            _dwarf_error(dbg, error, length_err_num);\n            if (!pubnames_context_on_list) {\n                dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n            }\n            dealloc_globals_chain(dbg,head_chain);\n            return DW_DLV_ERROR;\n        }\n        /*  If there is some kind of padding at the end of\n            the section,\n            as emitted by some compilers, skip over that padding and\n            simply ignore the bytes thus passed-over.  With most\n            compilers, pubnames_like_ptr ==\n            pubnames_ptr_past_end_cu at this point */\n        {\n            Dwarf_Unsigned increment =\n                pubnames_context->pu_length_size +\n                pubnames_context->pu_length +\n                pubnames_context->pu_extension_size;\n            pubnames_section_offset += increment;\n        }\n        pubnames_like_ptr = pubnames_ptr_past_end_cu;\n    } while (pubnames_like_ptr < section_end_ptr);\n\n    /* Points to contiguous block of Dwarf_Global. */\n    ret_globals = (Dwarf_Global *)\n        _dwarf_get_alloc(dbg, DW_DLA_LIST, global_count);\n    if (ret_globals == NULL) {\n        if (!pubnames_context_on_list) {\n            dwarf_dealloc(dbg,pubnames_context,context_DLA_code);\n        }\n        dealloc_globals_chain(dbg,head_chain);\n        _dwarf_error(dbg, error, DW_DLE_ALLOC_FAIL);\n        return DW_DLV_ERROR;\n    }\n\n    /*  Store pointers to Dwarf_Global_s structs in contiguous block,\n        and deallocate the chain.  This ignores the various\n        headers */\n    {\n        Dwarf_Chain curr_chain = 0;\n        curr_chain = head_chain;\n        for (i = 0; i < global_count; i++) {\n            Dwarf_Chain prev = 0;\n\n            *(ret_globals + i) = curr_chain->ch_item;\n            prev = curr_chain;\n            curr_chain = curr_chain->ch_next;\n            prev->ch_item = 0; /* Not actually necessary. */\n            dwarf_dealloc(dbg, prev, DW_DLA_CHAIN);\n        }\n    }\n    *globals = ret_globals;\n    *return_count = (Dwarf_Signed) global_count;\n    return DW_DLV_OK;\n}\n\n/*  Given a pubnames entry (or other like section entry)\n    return thru the ret_name pointer\n    a pointer to the string which is the entry name.  */\nint\ndwarf_globname(Dwarf_Global glob,\n    char **ret_name,\n    Dwarf_Error * error)\n{\n    if (glob == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    *ret_name = (char *) (glob->gl_name);\n    return DW_DLV_OK;\n}\n\n/*  Given a pubnames entry (or other like section entry)\n    return thru the ret_off pointer the\n    global offset of the DIE for this entry.\n    The global offset is the offset within the .debug_info\n    section as a whole.  */\nint\ndwarf_global_die_offset(Dwarf_Global global,\n    Dwarf_Off * ret_off, Dwarf_Error * error)\n{\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    if (global->gl_context == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    *ret_off = (global->gl_named_die_offset_within_cu +\n        global->gl_context->pu_offset_of_cu_header);\n    return DW_DLV_OK;\n}\n\n/*  Given a pubnames entry (or other like section entry)\n    return thru the ret_off pointer the\n    offset of the compilation unit header of the\n    compilation unit the global is part of.\n*/\nint\ndwarf_global_cu_offset(Dwarf_Global global,\n    Dwarf_Off * cu_header_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Global_Context con = 0;\n\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n    con = global->gl_context;\n    if (con == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n    *cu_header_offset = con->pu_offset_of_cu_header;\n    return DW_DLV_OK;\n}\n\nstatic void\nbuild_off_end_msg(Dwarf_Unsigned offval,\n    Dwarf_Unsigned withincr,\n    Dwarf_Unsigned secsize,\n    dwarfstring *m)\n{\n    const char *msg = \"past\";\n    if (offval < secsize){\n        msg = \"too near\";\n    }\n    dwarfstring_append_printf_u(m,\"DW_DLE_OFFSET_BAD: \"\n        \"The CU header offset of %u in a pubnames-like entry \",\n        withincr);\n    dwarfstring_append_printf_s(m,\n        \"would put us %s the end of .debug_info. \"\n        \"No room for a DIE there... \"\n        \"Corrupt Dwarf.\",(char *)msg);\n    return;\n}\n\n/*\n  Give back the pubnames entry (or any other like section)\n  name, symbol DIE offset, and the cu-DIE offset.\n\n  Various errors are possible.\n\n  The string pointer returned thru ret_name is not\n  dwarf_get_alloc()ed, so no dwarf_dealloc()\n  DW_DLA_STRING should be applied to it.\n\n*/\nint\ndwarf_global_name_offsets(Dwarf_Global global,\n    char **ret_name,\n    Dwarf_Off * die_offset,\n    Dwarf_Off * cu_die_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Global_Context con = 0;\n    Dwarf_Debug dbg = 0;\n    Dwarf_Off cuhdr_off = 0;\n\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    con = global->gl_context;\n    if (con == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n\n    cuhdr_off = con->pu_offset_of_cu_header;\n    /*  The offset had better not be too close to the end. If it is,\n        _dwarf_length_of_cu_header() will step off the end\n        and therefore\n        must not be used. 10 is a meaningless heuristic, but no CU\n        header is that small so it is safe. An erroneous offset is due\n        to a bug in the tool chain. A bug like this has been seen on\n        IRIX with MIPSpro 7.3.1.3 and an executable > 2GB in size and\n        with 2 million pubnames entries. */\n#define MIN_CU_HDR_SIZE 10\n    dbg = con->pu_dbg;\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: Either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    /* Cannot refer to debug_types */\n    if (dbg->de_debug_info.dss_size &&\n        ((cuhdr_off + MIN_CU_HDR_SIZE) >=\n        dbg->de_debug_info.dss_size)) {\n        dwarfstring m;\n\n        dwarfstring_constructor(&m);\n        build_off_end_msg(cuhdr_off,cuhdr_off+MIN_CU_HDR_SIZE,\n            dbg->de_debug_info.dss_size,&m);\n        _dwarf_error_string(dbg, error, DW_DLE_OFFSET_BAD,\n            dwarfstring_string(&m));\n        dwarfstring_destructor(&m);\n        return DW_DLV_ERROR;\n    }\n#undef MIN_CU_HDR_SIZE\n    /*  If global->gl_named_die_offset_within_cu\n        is zero then this is a fake global for\n        a pubnames CU with no pubnames. The offset is from the\n        start of the CU header, so no die can have a zero\n        offset, all valid offsets are positive numbers */\n    if (die_offset) {\n        if (global->gl_named_die_offset_within_cu) {\n            *die_offset = global->gl_named_die_offset_within_cu +\n                cuhdr_off;\n        } else {\n            *die_offset = 0;\n        }\n    }\n    *ret_name = (char *) global->gl_name;\n    if (cu_die_offset) {\n        /* Globals cannot refer to debug_types */\n        int cres = 0;\n        Dwarf_Unsigned headerlen = 0;\n        int res = _dwarf_load_debug_info(dbg, error);\n\n        if (res != DW_DLV_OK) {\n            return res;\n        }\n        /*  The offset had better not be too close to the end.\n            If it is,\n            _dwarf_length_of_cu_header() will step off the end and\n            therefore must not be used. 10 is a meaningless heuristic,\n            but no CU header is that small so it is safe. */\n        /* Globals cannot refer to debug_types */\n        if ((cuhdr_off + 10) >= dbg->de_debug_info.dss_size) {\n            dwarfstring m;\n\n            dwarfstring_constructor(&m);\n            build_off_end_msg(cuhdr_off,cuhdr_off+10,\n                dbg->de_debug_info.dss_size,&m);\n            _dwarf_error_string(dbg, error, DW_DLE_OFFSET_BAD,\n                dwarfstring_string(&m));\n            dwarfstring_destructor(&m);\n            return DW_DLV_ERROR;\n        }\n        cres = _dwarf_length_of_cu_header(dbg, cuhdr_off,true,\n            &headerlen,error);\n        if (cres != DW_DLV_OK) {\n            return cres;\n        }\n        *cu_die_offset = cuhdr_off + headerlen;\n    }\n    return DW_DLV_OK;\n}\n\n/*  New February 2019 from better dwarfdump printing\n    of debug_pubnames and pubtypes.\n    For ao the Dwarf_Global records in one pubnames\n    CU group exactly the same data will be returned.\n\n*/\nint\ndwarf_get_globals_header(Dwarf_Global global,\n    Dwarf_Off      *pub_section_hdr_offset,\n    Dwarf_Unsigned *pub_offset_size,\n    Dwarf_Unsigned *pub_cu_length,\n    Dwarf_Unsigned *version,\n    Dwarf_Off      *info_header_offset,\n    Dwarf_Unsigned *info_length,\n    Dwarf_Error*   error)\n{\n    Dwarf_Global_Context con = 0;\n    Dwarf_Debug dbg = 0;\n\n    if (global == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_NULL);\n        return DW_DLV_ERROR;\n    }\n    con = global->gl_context;\n    if (con == NULL) {\n        _dwarf_error(NULL, error, DW_DLE_GLOBAL_CONTEXT_NULL);\n        return DW_DLV_ERROR;\n    }\n    dbg = con->pu_dbg;\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling dwarf_get_globals_header() \"\n            \"either null or it contains\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    if (pub_section_hdr_offset) {\n        *pub_section_hdr_offset = con->pu_pub_offset;\n    }\n    if (pub_offset_size) {\n        *pub_offset_size = con->pu_length_size;\n    }\n    if (pub_cu_length) {\n        *pub_cu_length = con->pu_length;\n    }\n    if (version) {\n        *version = con->pu_version;\n    }\n    if (info_header_offset) {\n        *info_header_offset = con->pu_offset_of_cu_header;\n    }\n    if (info_length) {\n        *info_length = con->pu_info_length;\n    }\n    return DW_DLV_OK;\n}\n\n/*  We have the offset to a CU header.\n    Return thru outFileOffset the offset of the CU DIE.\n\n    New June, 2001.\n    Used by SGI IRIX debuggers.\n    No error used to be possible.\n    As of May 2016 an error is possible if the DWARF is\n    corrupted! (IRIX debuggers are no longer built ...)\n\n    See also dwarf_CU_dieoffset_given_die().\n\n    This is assumed to never apply to data in .debug_types, it\n    only refers to .debug_info.\n\n*/\n\n/* ARGSUSED */\n/*  The following version new in October 2011, does allow finding\n    the offset if one knows whether debug_info or debug_types\n    or any .debug_info type including the DWARF5 flavors.\n\n    It indirectly calls _dwarf_length_of_cu_header()\n    which knows all the varieties of header.  */\nint\ndwarf_get_cu_die_offset_given_cu_header_offset_b(Dwarf_Debug dbg,\n    Dwarf_Off in_cu_header_offset,\n    Dwarf_Bool is_info,\n    Dwarf_Off * out_cu_die_offset,\n    Dwarf_Error * error)\n{\n    Dwarf_Off headerlen = 0;\n    int cres = 0;\n\n    if (!dbg || dbg->de_magic != DBG_IS_VALID) {\n        _dwarf_error_string(NULL, error, DW_DLE_DBG_NULL,\n            \"DW_DLE_DBG_NULL: \"\n            \"calling dwarf_get_cu_die_offset_given\"\n            \"cu_header_offset_b Dwarf_Debug is\"\n            \"either null or it is\"\n            \"a stale Dwarf_Debug pointer\");\n        return DW_DLV_ERROR;\n    }\n    cres = _dwarf_length_of_cu_header(dbg,\n        in_cu_header_offset,is_info, &headerlen,error);\n    if (cres != DW_DLV_OK) {\n        return cres;\n    }\n    *out_cu_die_offset = in_cu_header_offset + headerlen;\n    return DW_DLV_OK;\n}\n/*  dwarf_CU_dieoffset_given_die returns\n    the global debug_info section offset of the CU die\n    that is the CU containing the given (passed-in) die.\n    This information makes it possible for a consumer to\n    find and print context information for any die.\n\n    Use dwarf_offdie_b() passing in the offset this returns\n    to get a die pointer to the CU die.  */\nint\ndwarf_CU_dieoffset_given_die(Dwarf_Die die,\n    Dwarf_Off*       return_offset,\n    Dwarf_Error*     error)\n{\n    Dwarf_Off  dieoff = 0;\n    Dwarf_CU_Context cucontext = 0;\n\n    CHECK_DIE(die, DW_DLV_ERROR);\n    cucontext = die->di_cu_context;\n    dieoff =  cucontext->cc_debug_offset;\n    /*  The following call cannot fail, so no error check. */\n    dwarf_get_cu_die_offset_given_cu_header_offset_b(\n        cucontext->cc_dbg, dieoff,\n        die->di_is_info, return_offset,error);\n    return DW_DLV_OK;\n}\n\nint dwarf_return_empty_pubnames(Dwarf_Debug dbg, int flag)\n{\n    if (dbg == NULL) {\n        return DW_DLV_OK;\n    }\n    if (flag && flag != 1) {\n        return DW_DLV_OK;\n    }\n    dbg->de_return_empty_pubnames = (unsigned char)flag;\n    return DW_DLV_OK;\n}\n"], "filenames": ["src/lib/libdwarf/dwarf_global.c"], "buggy_code_start_loc": [34], "buggy_code_end_loc": [575], "fixing_code_start_loc": [33], "fixing_code_end_loc": [640], "type": "CWE-125", "message": "libdwarf 0.4.0 has a heap-based buffer over-read in _dwarf_check_string_valid in dwarf_util.c.", "other": {"cve": {"id": "CVE-2022-32200", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:16:01.167", "lastModified": "2022-06-10T16:16:20.087", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libdwarf 0.4.0 has a heap-based buffer over-read in _dwarf_check_string_valid in dwarf_util.c."}, {"lang": "es", "value": "libdwarf versi\u00f3n 0.4.0, presenta una lectura excesiva del b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n _dwarf_check_string_valid en el archivo dwarf_util.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libdwarf_project:libdwarf:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "448D8623-0083-42B9-A9D1-60A5BF2F6DE5"}]}]}], "references": [{"url": "https://github.com/davea42/libdwarf-code/commit/8151575a6ace77d005ca5bb5d71c1bfdba3f7069", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/davea42/libdwarf-code/issues/116", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.prevanders.net/dwarfbug.html", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davea42/libdwarf-code/commit/8151575a6ace77d005ca5bb5d71c1bfdba3f7069"}}