{"buggy_code": ["/*\n * Wire\n * Copyright (C) 2018 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport ko from 'knockout';\nimport {amplify} from 'amplify';\nimport {Confirmation, LegalHoldStatus, Asset as ProtobufAsset} from '@wireapp/protocol-messaging';\nimport {flatten} from 'underscore';\nimport {WebAppEvents} from '@wireapp/webapp-events';\nimport {StatusCodes as HTTP_STATUS} from 'http-status-codes';\nimport {\n  CONVERSATION_EVENT,\n  ConversationMessageTimerUpdateEvent,\n  ConversationRenameEvent,\n  ConversationMemberJoinEvent,\n  ConversationCreateEvent,\n  ConversationEvent,\n  ConversationReceiptModeUpdateEvent,\n  ConversationMemberLeaveEvent,\n} from '@wireapp/api-client/src/event';\n\nimport {\n  DefaultConversationRoleName as DefaultRole,\n  CONVERSATION_ACCESS_ROLE,\n  CONVERSATION_ACCESS,\n  CONVERSATION_TYPE,\n  NewConversation,\n  Conversation as BackendConversation,\n} from '@wireapp/api-client/src/conversation/';\nimport {container} from 'tsyringe';\nimport {ConversationReceiptModeUpdateData} from '@wireapp/api-client/src/conversation/data/';\nimport {BackendErrorLabel} from '@wireapp/api-client/src/http/';\nimport type {QualifiedId} from '@wireapp/api-client/src/user/';\nimport {Logger, getLogger} from 'Util/Logger';\nimport {TIME_IN_MILLIS} from 'Util/TimeUtil';\nimport {PromiseQueue} from 'Util/PromiseQueue';\nimport {replaceLink, t} from 'Util/LocalizerUtil';\nimport {getDifference, getNextItem} from 'Util/ArrayUtil';\nimport {createRandomUuid, noop} from 'Util/util';\nimport {allowsAllFiles, getFileExtensionOrName, isAllowedFile} from 'Util/FileTypeUtil';\nimport {\n  compareTransliteration,\n  sortByPriority,\n  startsWith,\n  sortUsersByPriority,\n  fixWebsocketString,\n} from 'Util/StringUtil';\nimport {ClientEvent} from '../event/Client';\nimport {NOTIFICATION_HANDLING_STATE} from '../event/NotificationHandlingState';\nimport {EventRepository} from '../event/EventRepository';\nimport {\n  AssetAddEvent,\n  ButtonActionConfirmationEvent,\n  ClientConversationEvent,\n  DeleteEvent,\n  EventBuilder,\n  GroupCreationEvent,\n  MessageHiddenEvent,\n  OneToOneCreationEvent,\n  ReactionEvent,\n  TeamMemberLeaveEvent,\n} from '../conversation/EventBuilder';\nimport {Conversation} from '../entity/Conversation';\nimport {Message} from '../entity/message/Message';\nimport {ConversationMapper, ConversationDatabaseData} from './ConversationMapper';\nimport {ConversationStateHandler} from './ConversationStateHandler';\nimport {EventMapper} from './EventMapper';\nimport {ACCESS_STATE} from './AccessState';\nimport {ConversationStatus} from './ConversationStatus';\nimport {ConversationVerificationStateHandler} from './ConversationVerificationStateHandler';\nimport {NOTIFICATION_STATE} from './NotificationSetting';\nimport {ConversationEphemeralHandler} from './ConversationEphemeralHandler';\nimport {ConversationLabelRepository} from './ConversationLabelRepository';\nimport {AssetTransferState} from '../assets/AssetTransferState';\nimport {ModalsViewModel} from '../view_model/ModalsViewModel';\nimport {SystemMessageType} from '../message/SystemMessageType';\nimport {SuperType} from '../message/SuperType';\nimport {MessageCategory} from '../message/MessageCategory';\nimport {Config} from '../Config';\nimport {BaseError, BASE_ERROR_TYPE} from '../error/BaseError';\nimport {BackendClientError} from '../error/BackendClientError';\nimport * as LegalHoldEvaluator from '../legal-hold/LegalHoldEvaluator';\nimport {DeleteConversationMessage} from '../entity/message/DeleteConversationMessage';\nimport {ConversationRoleRepository} from './ConversationRoleRepository';\nimport {ConversationError} from '../error/ConversationError';\nimport {ConversationService} from './ConversationService';\nimport {ConnectionRepository} from '../connection/ConnectionRepository';\nimport {UserRepository} from '../user/UserRepository';\nimport {PropertiesRepository} from '../properties/PropertiesRepository';\nimport {ServerTimeHandler} from '../time/serverTimeHandler';\nimport {ContentMessage} from '../entity/message/ContentMessage';\nimport {User} from '../entity/User';\nimport {EventService} from '../event/EventService';\nimport {ConnectionEntity} from '../connection/ConnectionEntity';\nimport {EventSource} from '../event/EventSource';\nimport {MemberMessage} from '../entity/message/MemberMessage';\nimport {FileAsset} from '../entity/message/FileAsset';\nimport type {EventRecord} from '../storage';\nimport {MessageRepository} from './MessageRepository';\nimport {UserState} from '../user/UserState';\nimport {TeamState} from '../team/TeamState';\nimport {TeamRepository} from '../team/TeamRepository';\nimport {ConversationState} from './ConversationState';\nimport {ConversationRecord} from '../storage/record/ConversationRecord';\nimport {UserFilter} from '../user/UserFilter';\nimport {ConversationFilter} from './ConversationFilter';\nimport {ConversationMemberUpdateEvent} from '@wireapp/api-client/src/event';\nimport {matchQualifiedIds} from 'Util/QualifiedId';\nimport {flattenUserClientsQualifiedIds} from './userClientsUtils';\n\ntype ConversationDBChange = {obj: EventRecord; oldObj: EventRecord};\ntype FetchPromise = {rejectFn: (error: ConversationError) => void; resolveFn: (conversation: Conversation) => void};\ntype EntityObject = {conversationEntity: Conversation; messageEntity: Message};\ntype IncomingEvent = ConversationEvent | ClientConversationEvent;\n\nexport class ConversationRepository {\n  private init_handled: number;\n  private init_promise?: {rejectFn: (reason?: any) => void; resolveFn: (value?: unknown) => void};\n  private init_total: number;\n  private isBlockingNotificationHandling: boolean;\n  private readonly conversationsWithNewEvents: Map<any, any>;\n  private readonly ephemeralHandler: ConversationEphemeralHandler;\n  public readonly conversationLabelRepository: ConversationLabelRepository;\n  public readonly conversationRoleRepository: ConversationRoleRepository;\n  private readonly event_mapper: EventMapper;\n  private readonly eventService: EventService;\n  public leaveCall: (conversationId: string) => void;\n  private readonly receiving_queue: PromiseQueue;\n  private readonly logger: Logger;\n  public readonly stateHandler: ConversationStateHandler;\n  public readonly verificationStateHandler: ConversationVerificationStateHandler;\n\n  static get CONFIG() {\n    return {\n      CONFIRMATION_THRESHOLD: TIME_IN_MILLIS.WEEK,\n      EXTERNAL_MESSAGE_THRESHOLD: 200 * 1024,\n      GROUP: {\n        MAX_NAME_LENGTH: 64,\n        MAX_SIZE: Config.getConfig().MAX_GROUP_PARTICIPANTS,\n      },\n    };\n  }\n\n  static get CONSENT_TYPE() {\n    return {\n      INCOMING_CALL: 'incoming_call',\n      MESSAGE: 'message',\n      OUTGOING_CALL: 'outgoing_call',\n    };\n  }\n\n  constructor(\n    private readonly conversation_service: ConversationService,\n    private readonly messageRepository: MessageRepository,\n    private readonly connectionRepository: ConnectionRepository,\n    private readonly eventRepository: EventRepository,\n    private readonly teamRepository: TeamRepository,\n    private readonly userRepository: UserRepository,\n    private readonly propertyRepository: PropertiesRepository,\n    private readonly serverTimeHandler: ServerTimeHandler,\n    private readonly userState = container.resolve(UserState),\n    private readonly teamState = container.resolve(TeamState),\n    private readonly conversationState = container.resolve(ConversationState),\n  ) {\n    this.eventService = eventRepository.eventService;\n    // we register a client mismatch handler agains the message repository so that we can react to missing members\n    // FIXME this should be temporary. In the near future we want the core to handle clients/mismatch/verification. So the webapp won't need this logic at all\n    this.messageRepository.setClientMismatchHandler(async (mismatch, conversationId) => {\n      const deleted = flattenUserClientsQualifiedIds(mismatch.deleted);\n      const missing = flattenUserClientsQualifiedIds(mismatch.missing);\n      const conversation = conversationId ? await this.getConversationById(conversationId) : undefined;\n      if (conversation) {\n        // add/remove users from the conversation (if any)\n        const missingUserIds = missing.map(({userId}) => userId);\n        const knownUsers = conversation.participating_user_ets().map(user => user.qualifiedId);\n        const missingUsers = getDifference(knownUsers, missingUserIds, matchQualifiedIds);\n        if (missingUsers.length) {\n          await this.addMissingMember(conversation, missingUsers, new Date(mismatch.time).getTime() - 1);\n        }\n      }\n\n      deleted.forEach(({userId, clients}) => {\n        clients.forEach(client => this.userRepository.removeClientFromUser(userId, client));\n      });\n      if (missing.length) {\n        const deviceWasAdded = await this.userRepository.updateMissingUsersClients(missing.map(({userId}) => userId));\n        if (deviceWasAdded && conversation) {\n          // TODO trigger degradation warning if needed and return false if sending should be canceled\n          return true;\n        }\n      }\n      return true;\n    });\n\n    this.logger = getLogger('ConversationRepository');\n\n    this.event_mapper = new EventMapper();\n    this.verificationStateHandler = new ConversationVerificationStateHandler(\n      this.eventRepository,\n      this.serverTimeHandler,\n      this.userState,\n      this.conversationState,\n    );\n    this.isBlockingNotificationHandling = true;\n    this.conversationsWithNewEvents = new Map();\n\n    this.teamState.isTeam.subscribe(() => this.mapGuestStatusSelf());\n    this.receiving_queue = new PromiseQueue({name: 'ConversationRepository.Receiving'});\n\n    this.init_handled = 0;\n    this.init_promise = undefined;\n    this.init_total = 0;\n\n    this.initSubscriptions();\n\n    this.stateHandler = new ConversationStateHandler(this.conversation_service);\n    this.ephemeralHandler = new ConversationEphemeralHandler(this.eventService, {\n      onMessageTimeout: this.handleMessageExpiration,\n    });\n\n    this.userState.directlyConnectedUsers = this.conversationState.connectedUsers;\n\n    this.conversationLabelRepository = new ConversationLabelRepository(\n      this.conversationState.conversations,\n      this.conversationState.conversations_unarchived,\n      propertyRepository.propertiesService,\n    );\n\n    this.conversationRoleRepository = new ConversationRoleRepository(this.teamRepository, this.conversation_service);\n    this.leaveCall = noop;\n  }\n\n  checkMessageTimer(messageEntity: ContentMessage): void {\n    this.ephemeralHandler.checkMessageTimer(messageEntity, this.serverTimeHandler.getTimeOffset());\n  }\n\n  private initStateUpdates(): void {\n    ko.computed(() => {\n      const conversationsArchived: Conversation[] = [];\n      const conversationsCleared: Conversation[] = [];\n      const conversationsUnarchived: Conversation[] = [];\n\n      this.conversationState.sorted_conversations().forEach(conversationEntity => {\n        if (conversationEntity.is_cleared()) {\n          conversationsCleared.push(conversationEntity);\n        } else if (conversationEntity.is_archived()) {\n          conversationsArchived.push(conversationEntity);\n        } else {\n          conversationsUnarchived.push(conversationEntity);\n        }\n      });\n\n      this.conversationState.conversations_archived(conversationsArchived);\n      this.conversationState.conversations_cleared(conversationsCleared);\n      this.conversationState.conversations_unarchived(conversationsUnarchived);\n    });\n  }\n\n  private initSubscriptions(): void {\n    amplify.subscribe(WebAppEvents.CONVERSATION.DELETE, this.deleteConversationLocally);\n    amplify.subscribe(WebAppEvents.CONVERSATION.EVENT_FROM_BACKEND, this.onConversationEvent);\n    amplify.subscribe(WebAppEvents.CONVERSATION.MAP_CONNECTION, this.mapConnection);\n    amplify.subscribe(WebAppEvents.CONVERSATION.MISSED_EVENTS, this.onMissedEvents);\n    amplify.subscribe(WebAppEvents.CONVERSATION.PERSIST_STATE, this.saveConversationStateInDb);\n    amplify.subscribe(WebAppEvents.EVENT.NOTIFICATION_HANDLING_STATE, this.setNotificationHandlingState);\n    amplify.subscribe(WebAppEvents.TEAM.MEMBER_LEAVE, this.teamMemberLeave);\n    amplify.subscribe(WebAppEvents.USER.UNBLOCKED, this.onUnblockUser);\n    amplify.subscribe(WebAppEvents.CONVERSATION.INJECT_LEGAL_HOLD_MESSAGE, this.injectLegalHoldMessage);\n\n    this.eventService.addEventUpdatedListener(this.updateLocalMessageEntity);\n    this.eventService.addEventDeletedListener(this.deleteLocalMessageEntity);\n\n    window.addEventListener<any>(WebAppEvents.CONVERSATION.JOIN, this.onConversationJoin);\n  }\n\n  private readonly updateLocalMessageEntity = async ({\n    obj: updatedEvent,\n    oldObj: oldEvent,\n  }: ConversationDBChange): Promise<void> => {\n    const qualifiedId = updatedEvent.qualified_conversation || {domain: '', id: updatedEvent.conversation};\n    const conversationEntity = this.conversationState.findConversation(qualifiedId);\n    const replacedMessageEntity = await this.replaceMessageInConversation(\n      conversationEntity,\n      oldEvent.id,\n      updatedEvent,\n    );\n    if (replacedMessageEntity) {\n      const messageEntity = await this.updateMessageUserEntities(replacedMessageEntity);\n      amplify.publish(WebAppEvents.CONVERSATION.MESSAGE.UPDATED, oldEvent.id, messageEntity);\n    }\n  };\n\n  private readonly deleteLocalMessageEntity = ({oldObj: deletedEvent}: ConversationDBChange): void => {\n    const qualifiedId = deletedEvent.qualified_conversation || {domain: '', id: deletedEvent.conversation};\n    const conversationEntity = this.conversationState.findConversation(qualifiedId);\n    if (conversationEntity) {\n      conversationEntity.removeMessageById(deletedEvent.id);\n    }\n  };\n\n  /**\n   * Remove obsolete conversations locally.\n   */\n  cleanupConversations(): void {\n    this.conversationState.conversations().forEach(conversationEntity => {\n      if (\n        conversationEntity.isGroup() &&\n        conversationEntity.is_cleared() &&\n        conversationEntity.removed_from_conversation()\n      ) {\n        this.conversation_service.deleteConversationFromDb(conversationEntity);\n        this.deleteConversationFromRepository(conversationEntity);\n      }\n    });\n  }\n\n  //##############################################################################\n  // Conversation service interactions\n  //##############################################################################\n\n  /**\n   * Create a group conversation.\n   * @note Do not include the requester among the users\n   *\n   * @param userEntities Users (excluding the creator) to be part of the conversation\n   * @param groupName Name for the conversation\n   * @param accessState State for conversation access\n   * @param options Additional conversation creation options (like \"receipt_mode\")\n   * @returns Resolves when the conversation was created\n   */\n  public async createGroupConversation(\n    userEntities: User[],\n    groupName?: string,\n    accessState?: string,\n    options: Partial<NewConversation> = {},\n  ): Promise<Conversation | undefined> {\n    const isFederated = Config.getConfig().FEATURE.ENABLE_FEDERATION;\n    const userIds = isFederated ? userEntities.map(user => user.qualifiedId) : userEntities.map(user => user.id);\n\n    let payload: NewConversation & {conversation_role: string} = {\n      conversation_role: DefaultRole.WIRE_MEMBER,\n      name: groupName,\n      qualified_users: isFederated ? (userIds as QualifiedId[]) : undefined,\n      receipt_mode: null,\n      users: !isFederated ? (userIds as string[]) : [],\n      ...options,\n    };\n\n    if (this.teamState.team().id) {\n      payload.team = {\n        managed: false,\n        teamid: this.teamState.team().id!,\n      };\n\n      if (accessState) {\n        let accessPayload;\n\n        switch (accessState) {\n          case ACCESS_STATE.TEAM.GUEST_ROOM:\n            accessPayload = {\n              access: [CONVERSATION_ACCESS.INVITE, CONVERSATION_ACCESS.CODE],\n              access_role: CONVERSATION_ACCESS_ROLE.NON_ACTIVATED,\n            };\n            break;\n          case ACCESS_STATE.TEAM.TEAM_ONLY:\n            accessPayload = {\n              access: [CONVERSATION_ACCESS.INVITE],\n              access_role: CONVERSATION_ACCESS_ROLE.TEAM,\n            };\n            break;\n          default:\n            break;\n        }\n\n        if (accessPayload) {\n          payload = {...payload, ...accessPayload};\n        }\n      }\n    }\n\n    try {\n      const response = await this.conversation_service.postConversations(payload);\n      const {conversationEntity} = await this.onCreate({\n        conversation: response.id,\n        data: {\n          last_event: '0.0',\n          last_event_time: '1970-01-01T00:00:00.000Z',\n          receipt_mode: undefined,\n          ...response,\n        },\n        from: this.userState.self().id,\n        qualified_conversation: response.qualified_id,\n        time: new Date().toISOString(),\n        type: CONVERSATION_EVENT.CREATE,\n      });\n      return conversationEntity as Conversation;\n    } catch (error) {\n      this.handleConversationCreateError(\n        error,\n        userEntities.map(user => user.qualifiedId),\n      );\n      return undefined;\n    }\n  }\n\n  /**\n   * Create a guest room.\n   */\n  public createGuestRoom(): Promise<Conversation | undefined> {\n    const groupName = t('guestRoomConversationName');\n    return this.createGroupConversation([], groupName, ACCESS_STATE.TEAM.GUEST_ROOM);\n  }\n\n  /**\n   * Get a conversation from the backend.\n   */\n  private async fetchConversationById({id: conversationId, domain}: QualifiedId): Promise<Conversation> {\n    const qualifiedId = {domain, id: conversationId};\n    const fetching_conversations: Record<string, FetchPromise[]> = {};\n    if (fetching_conversations.hasOwnProperty(conversationId)) {\n      return new Promise((resolve, reject) => {\n        fetching_conversations[conversationId].push({rejectFn: reject, resolveFn: resolve});\n      });\n    }\n\n    fetching_conversations[conversationId] = [];\n    try {\n      const response = await this.conversation_service.getConversationById(qualifiedId);\n      const [conversationEntity] = this.mapConversations([response]);\n\n      this.logger.info(`Fetched conversation '${conversationId}' from backend`);\n      this.saveConversation(conversationEntity);\n\n      fetching_conversations[conversationId].forEach(({resolveFn}) => resolveFn(conversationEntity));\n      delete fetching_conversations[conversationId];\n\n      return conversationEntity;\n    } catch (originalError) {\n      if (originalError.code === HTTP_STATUS.NOT_FOUND) {\n        this.deleteConversationLocally(qualifiedId, false);\n      }\n      const error = new ConversationError(\n        ConversationError.TYPE.CONVERSATION_NOT_FOUND,\n        ConversationError.MESSAGE.CONVERSATION_NOT_FOUND,\n        originalError,\n      );\n      fetching_conversations[conversationId].forEach(({rejectFn}) => rejectFn(error));\n      delete fetching_conversations[conversationId];\n\n      throw error;\n    }\n  }\n\n  public async getConversations(): Promise<Conversation[]> {\n    const remoteConversationsPromise = this.conversation_service.getAllConversations().catch(error => {\n      this.logger.error(`Failed to get all conversations from backend: ${error.message}`);\n      return [];\n    });\n\n    const [localConversations, remoteConversations] = await Promise.all([\n      this.conversation_service.loadConversationStatesFromDb<ConversationDatabaseData>(),\n      remoteConversationsPromise,\n    ]);\n    let conversationsData: any[];\n    if (!remoteConversations.length) {\n      conversationsData = localConversations;\n    } else {\n      const data = ConversationMapper.mergeConversation(localConversations, remoteConversations);\n      conversationsData = (await this.conversation_service.saveConversationsInDb(data)) as any[];\n    }\n    const conversationEntities = this.mapConversations(conversationsData);\n    this.saveConversations(conversationEntities);\n    return this.conversationState.conversations();\n  }\n\n  public async updateConversationStates(conversationsDataArray: ConversationRecord[]) {\n    const handledConversationEntities: Conversation[] = [];\n    const unknownConversations: ConversationRecord[] = [];\n\n    conversationsDataArray.forEach(conversationData => {\n      const localEntity = this.conversationState\n        .conversations()\n        .find(conversation => matchQualifiedIds(conversation, conversationData));\n\n      if (localEntity) {\n        const entity = ConversationMapper.updateSelfStatus(localEntity, conversationData as any, true);\n        handledConversationEntities.push(entity);\n        return;\n      }\n\n      unknownConversations.push(conversationData);\n    });\n\n    let conversationEntities: Conversation[] = [];\n\n    if (unknownConversations.length) {\n      conversationEntities = conversationEntities.concat(this.mapConversations(unknownConversations as any[]));\n      this.saveConversations(conversationEntities);\n    }\n\n    conversationEntities = conversationEntities.concat(handledConversationEntities);\n    const handledConversationData = conversationEntities.map(conversationEntity => conversationEntity.serialize());\n    this.conversation_service.saveConversationsInDb(handledConversationData);\n    return conversationEntities;\n  }\n\n  /**\n   * Get preceding messages starting with the given message.\n   * @param conversationEntity Respective conversation\n   * @returns Resolves with the messages\n   */\n  public async getPrecedingMessages(conversationEntity: Conversation): Promise<ContentMessage[]> {\n    conversationEntity.is_pending(true);\n\n    const firstMessageEntity = conversationEntity.getFirstMessage();\n    const upperBound = firstMessageEntity\n      ? new Date(firstMessageEntity.timestamp())\n      : new Date(conversationEntity.getLatestTimestamp(this.serverTimeHandler.toServerTimestamp()) + 1);\n\n    const events = (await this.eventService.loadPrecedingEvents(\n      conversationEntity.id,\n      new Date(0),\n      upperBound,\n      Config.getConfig().MESSAGES_FETCH_LIMIT,\n    )) as EventRecord[];\n    const mappedMessageEntities = await this.addPrecedingEventsToConversation(events, conversationEntity);\n    conversationEntity.is_pending(false);\n    return mappedMessageEntities;\n  }\n\n  private async addPrecedingEventsToConversation(\n    events: EventRecord[],\n    conversationEntity: Conversation,\n  ): Promise<ContentMessage[]> {\n    const hasAdditionalMessages = events.length === Config.getConfig().MESSAGES_FETCH_LIMIT;\n\n    const mappedMessageEntities = await this.addEventsToConversation(events, conversationEntity);\n    conversationEntity.hasAdditionalMessages(hasAdditionalMessages);\n    if (!hasAdditionalMessages) {\n      const firstMessage = conversationEntity.getFirstMessage() as MemberMessage;\n      const checkCreationMessage = firstMessage?.isMember() && firstMessage.isCreation();\n      if (checkCreationMessage) {\n        const groupCreationMessageIn1to1 = conversationEntity.is1to1() && firstMessage.isGroupCreation();\n        const one2oneConnectionMessageInGroup = conversationEntity.isGroup() && firstMessage.isConnection();\n        const wrongMessageTypeForConversation = groupCreationMessageIn1to1 || one2oneConnectionMessageInGroup;\n\n        if (wrongMessageTypeForConversation) {\n          this.messageRepository.deleteMessage(conversationEntity, firstMessage);\n          conversationEntity.hasCreationMessage = false;\n        } else {\n          conversationEntity.hasCreationMessage = true;\n        }\n      }\n\n      const addCreationMessage = !conversationEntity.hasCreationMessage;\n      if (addCreationMessage) {\n        this.addCreationMessage(conversationEntity, this.userState.self().isTemporaryGuest());\n      }\n    }\n    return mappedMessageEntities;\n  }\n\n  private addCreationMessage(\n    conversationEntity: Conversation,\n    isTemporaryGuest: boolean,\n    timestamp?: number,\n    eventSource?: EventSource,\n  ): void {\n    conversationEntity.hasCreationMessage = true;\n\n    if (conversationEntity.inTeam()) {\n      const allTeamMembersParticipate = this.teamState.teamMembers().length\n        ? this.teamState\n            .teamMembers()\n            .every(\n              teamMember =>\n                !!conversationEntity.participating_user_ids().find(user => matchQualifiedIds(user, teamMember)),\n            )\n        : false;\n\n      conversationEntity.withAllTeamMembers(allTeamMembersParticipate);\n    }\n\n    const creationEvent = conversationEntity.isGroup()\n      ? EventBuilder.buildGroupCreation(conversationEntity, isTemporaryGuest, timestamp)\n      : EventBuilder.build1to1Creation(conversationEntity);\n\n    this.eventRepository.injectEvent(creationEvent, eventSource);\n  }\n\n  /**\n   * Get specified message and load number preceding and subsequent messages defined by padding.\n   *\n   * @param conversationEntity Conversation entity\n   * @param messageEntity Message entity\n   * @param padding Number of messages to load around the targeted message\n   * @returns Resolves with the messages\n   */\n  public async getMessagesWithOffset(\n    conversationEntity: Conversation,\n    messageEntity: Message,\n    padding = 30,\n  ): Promise<ContentMessage[]> {\n    const messageDate = new Date(messageEntity.timestamp());\n    const conversationId = conversationEntity.id;\n\n    conversationEntity.is_pending(true);\n\n    const precedingMessages = (await this.eventService.loadPrecedingEvents(\n      conversationId,\n      new Date(0),\n      messageDate,\n      Math.floor(padding / 2),\n    )) as EventRecord[];\n    const followingMessages = (await this.eventService.loadFollowingEvents(\n      conversationEntity.id,\n      messageDate,\n      padding - precedingMessages.length,\n    )) as EventRecord[];\n    const messages = precedingMessages.concat(followingMessages);\n    const mappedMessageEntities = await this.addEventsToConversation(messages, conversationEntity);\n    conversationEntity.is_pending(false);\n    return mappedMessageEntities;\n  }\n\n  /**\n   * Get subsequent messages starting with the given message.\n   * @returns Resolves with the messages\n   */\n  async getSubsequentMessages(conversationEntity: Conversation, messageEntity: ContentMessage) {\n    const messageDate = new Date(messageEntity.timestamp());\n    conversationEntity.is_pending(true);\n\n    const events = (await this.eventService.loadFollowingEvents(\n      conversationEntity.id,\n      messageDate,\n      Config.getConfig().MESSAGES_FETCH_LIMIT,\n    )) as EventRecord[];\n    const mappedMessageEntities = await this.addEventsToConversation(events, conversationEntity, false);\n    conversationEntity.is_pending(false);\n    return mappedMessageEntities;\n  }\n\n  /**\n   * Get messages for given category. Category param acts as lower bound.\n   */\n  async getEventsForCategory(conversationEntity: Conversation, category = MessageCategory.NONE): Promise<Message[]> {\n    const events = (await this.eventService.loadEventsWithCategory(conversationEntity.id, category)) as EventRecord[];\n    const messageEntities = (await this.event_mapper.mapJsonEvents(events, conversationEntity)) as Message[];\n    return this.updateMessagesUserEntities(messageEntities);\n  }\n\n  /**\n   * Search for given text in conversation.\n   */\n  public async searchInConversation(\n    conversationEntity: Conversation,\n    query: string,\n  ): Promise<{messageEntities?: Message[]; query?: string}> {\n    if (!conversationEntity || !query.length) {\n      return {};\n    }\n\n    const events = await this.conversation_service.searchInConversation(conversationEntity.id, query);\n    const mappedMessages = await this.event_mapper.mapJsonEvents(events, conversationEntity);\n    const messageEntities = await this.updateMessagesUserEntities(mappedMessages);\n    return {messageEntities, query};\n  }\n\n  /**\n   * Get conversation unread events.\n   *\n   * @param conversationEntity Conversation to start from\n   */\n  private async getUnreadEvents(conversationEntity: Conversation): Promise<void> {\n    const first_message = conversationEntity.getFirstMessage();\n    const lower_bound = new Date(conversationEntity.last_read_timestamp());\n    const upper_bound = first_message\n      ? new Date(first_message.timestamp())\n      : new Date(conversationEntity.getLatestTimestamp(this.serverTimeHandler.toServerTimestamp()) + 1);\n\n    if (lower_bound < upper_bound) {\n      conversationEntity.is_pending(true);\n\n      try {\n        const events = (await this.eventService.loadPrecedingEvents(\n          conversationEntity.id,\n          lower_bound,\n          upper_bound,\n        )) as EventRecord[];\n        if (events.length) {\n          this.addEventsToConversation(events, conversationEntity);\n        }\n      } catch (error) {\n        this.logger.info(`Could not load unread events for conversation: ${conversationEntity.id}`, error);\n      }\n      conversationEntity.is_pending(false);\n    }\n  }\n\n  /**\n   * Update conversation with a user you just unblocked\n   */\n  private readonly onUnblockUser = async (user_et: User): Promise<void> => {\n    const conversationEntity = await this.get1To1Conversation(user_et);\n    if (typeof conversationEntity !== 'boolean') {\n      conversationEntity.status(ConversationStatus.CURRENT_MEMBER);\n    }\n  };\n\n  /**\n   * Update all conversations on app init.\n   */\n  public async updateConversationsOnAppInit() {\n    this.logger.info('Updating group participants');\n    await this.updateUnarchivedConversations();\n    const updatePromises = this.conversationState.sorted_conversations().map(conversationEntity => {\n      return this.updateParticipatingUserEntities(conversationEntity, true);\n    });\n    return Promise.all(updatePromises);\n  }\n\n  /**\n   * Update users and events for archived conversations currently visible.\n   */\n  public updateArchivedConversations() {\n    this.updateConversations(this.conversationState.conversations_archived());\n  }\n\n  /**\n   * Update users and events for all unarchived conversations.\n   */\n  private updateUnarchivedConversations() {\n    return this.updateConversations(this.conversationState.conversations_unarchived());\n  }\n\n  private async updateConversationFromBackend(conversationEntity: Conversation) {\n    const conversationData = await this.conversation_service.getConversationById(conversationEntity);\n    const {name, message_timer, type} = conversationData;\n    ConversationMapper.updateProperties(conversationEntity, {name, type});\n    ConversationMapper.updateSelfStatus(conversationEntity, {message_timer});\n  }\n\n  /**\n   * Get users and events for conversations.\n   *\n   * @note To reduce the number of backend calls we merge the user IDs of all conversations first.\n   * @param conversationEntities Array of conversation entities to be updated\n   */\n  public async updateConversations(conversationEntities: Conversation[]): Promise<void> {\n    const mapOfUserIds = conversationEntities.map(conversationEntity => conversationEntity.participating_user_ids());\n    const userIds = flatten(mapOfUserIds);\n    await this.userRepository.getUsersById(userIds);\n    conversationEntities.forEach(conversationEntity => this.fetchUsersAndEvents(conversationEntity));\n  }\n\n  //##############################################################################\n  // Repository interactions\n  //##############################################################################\n\n  /**\n   * Deletes a conversation from the repository.\n   */\n  private deleteConversationFromRepository(conversationId: QualifiedId) {\n    this.conversationState.conversations.remove(conversation => {\n      return matchQualifiedIds(conversation, conversationId);\n    });\n  }\n\n  public deleteConversation(conversationEntity: Conversation) {\n    this.conversation_service\n      .deleteConversation(this.teamState.team().id, conversationEntity.id)\n      .then(() => {\n        this.deleteConversationLocally(conversationEntity, true);\n      })\n      .catch(() => {\n        amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.ACKNOWLEDGE, {\n          text: {\n            message: t('modalConversationDeleteErrorMessage', conversationEntity.name()),\n            title: t('modalConversationDeleteErrorHeadline'),\n          },\n        });\n      });\n  }\n\n  private readonly deleteConversationLocally = (conversationId: QualifiedId, skipNotification: boolean) => {\n    const conversationEntity = this.conversationState.findConversation(conversationId);\n    if (!conversationEntity) {\n      return;\n    }\n    if (this.conversationState.isActiveConversation(conversationEntity)) {\n      const nextConversation = this.getNextConversation(conversationEntity);\n      amplify.publish(WebAppEvents.CONVERSATION.SHOW, nextConversation, {});\n    }\n    if (!skipNotification) {\n      const deletionMessage = new DeleteConversationMessage(conversationEntity);\n      amplify.publish(WebAppEvents.NOTIFICATION.NOTIFY, deletionMessage);\n    }\n    if (this.conversationLabelRepository.getConversationCustomLabel(conversationEntity, true)) {\n      this.conversationLabelRepository.removeConversationFromAllLabels(conversationEntity, true);\n      this.conversationLabelRepository.saveLabels();\n    }\n    this.deleteConversationFromRepository(conversationId);\n    this.conversation_service.deleteConversationFromDb(conversationId);\n  };\n\n  public async getAllUsersInConversation(conversationId: QualifiedId): Promise<User[]> {\n    const conversationEntity = await this.getConversationById(conversationId);\n    const users = [this.userState.self()].concat(conversationEntity.participating_user_ets());\n    return users;\n  }\n\n  /**\n   * Check for conversation locally and fetch it from the server otherwise.\n   * TODO(Federation): Remove \"optional\" from \"domain\"\n   */\n  async getConversationById(conversation_id: QualifiedId): Promise<Conversation> {\n    if (typeof conversation_id.id !== 'string') {\n      throw new ConversationError(\n        ConversationError.TYPE.NO_CONVERSATION_ID,\n        ConversationError.MESSAGE.NO_CONVERSATION_ID,\n      );\n    }\n    const conversationEntity = this.conversationState.findConversation(conversation_id);\n    if (conversationEntity) {\n      return conversationEntity;\n    }\n    try {\n      return await this.fetchConversationById(conversation_id);\n    } catch (error) {\n      const isConversationNotFound = error.type === ConversationError.TYPE.CONVERSATION_NOT_FOUND;\n      if (isConversationNotFound) {\n        this.logger.warn(`Failed to get conversation '${conversation_id.id}': ${error.message}`, error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get group conversations by name.\n   *\n   * @param query Query to be searched in group conversation names\n   * @param isHandle Query string is handle\n   * @returns Matching group conversations\n   */\n  getGroupsByName(query: string, isHandle: boolean) {\n    return this.conversationState\n      .sorted_conversations()\n      .filter(conversationEntity => {\n        if (!conversationEntity.isGroup()) {\n          return false;\n        }\n\n        const queryString = isHandle ? `@${query}` : query;\n        if (compareTransliteration(conversationEntity.display_name(), queryString)) {\n          return true;\n        }\n\n        for (const userEntity of conversationEntity.participating_user_ets()) {\n          const nameString = isHandle ? userEntity.username() : userEntity.name();\n          if (startsWith(nameString, query)) {\n            return true;\n          }\n        }\n\n        return false;\n      })\n      .sort((conversationA, conversationB) => {\n        return sortByPriority(conversationA.display_name(), conversationB.display_name(), query);\n      })\n      .map(conversationEntity => {\n        this.updateParticipatingUserEntities(conversationEntity);\n        return conversationEntity;\n      });\n  }\n\n  /**\n   * Get the most recent event timestamp from any conversation.\n   * @param increment Increment by one for unique timestamp\n   * @returns Timestamp value\n   */\n  private getLatestEventTimestamp(increment = false) {\n    const mostRecentConversation = this.getMostRecentConversation(true);\n    if (mostRecentConversation) {\n      const lastEventTimestamp = mostRecentConversation.last_event_timestamp();\n      return lastEventTimestamp + (increment ? 1 : 0);\n    }\n\n    return 1;\n  }\n\n  /**\n   * Get the next unarchived conversation.\n   *\n   * @param conversationEntity Conversation to start from\n   * @returns Next conversation\n   */\n  getNextConversation(conversationEntity: Conversation) {\n    return getNextItem(this.conversationState.conversations_unarchived(), conversationEntity);\n  }\n\n  /**\n   * Get unarchived conversation with the most recent event.\n   * @param allConversations Search all conversations\n   * @returns Most recent conversation\n   */\n  getMostRecentConversation(allConversations = false) {\n    const [conversationEntity] = allConversations\n      ? this.conversationState.sorted_conversations()\n      : this.conversationState.conversations_unarchived();\n    return conversationEntity;\n  }\n\n  /**\n   * Returns a list of sorted conversation ids based on the number of messages in the last 30 days.\n   * @returns Resolve with the most active conversations\n   */\n  getMostActiveConversations() {\n    return this.conversation_service.getActiveConversationsFromDb().then(conversation_ids => {\n      return conversation_ids\n        .map(conversation_id => this.conversationState.findConversation(conversation_id))\n        .filter(conversationEntity => conversationEntity);\n    });\n  }\n\n  /**\n   * Get conversation with a user.\n   * @param userEntity User entity for whom to get the conversation\n   * @returns Resolves with the conversation with requested user\n   */\n  async get1To1Conversation(userEntity: User): Promise<Conversation | false> {\n    const inCurrentTeam = userEntity.inTeam() && userEntity.teamId === this.userState.self().teamId;\n\n    if (inCurrentTeam) {\n      const matchingConversationEntity = this.conversationState.conversations().find(conversationEntity => {\n        if (!conversationEntity.is1to1()) {\n          // Disregard conversations that are not 1:1\n          return false;\n        }\n\n        const inTeam = ConversationFilter.isInTeam(conversationEntity, userEntity);\n        if (!inTeam) {\n          // Disregard conversations that are not in the team\n          return false;\n        }\n\n        const isActiveConversation = !conversationEntity.removed_from_conversation();\n        if (!isActiveConversation) {\n          // Disregard conversations that self is no longer part of\n          return false;\n        }\n\n        return ConversationFilter.is1To1WithUser(conversationEntity, userEntity);\n      });\n\n      if (matchingConversationEntity) {\n        return matchingConversationEntity;\n      }\n      return this.createGroupConversation([userEntity]);\n    }\n\n    const conversationId = userEntity.connection().conversationId;\n    try {\n      const conversationEntity = await this.getConversationById(conversationId);\n      conversationEntity.connection(userEntity.connection());\n      this.updateParticipatingUserEntities(conversationEntity);\n      return conversationEntity;\n    } catch (error) {\n      const isConversationNotFound = error.type === ConversationError.TYPE.CONVERSATION_NOT_FOUND;\n      if (!isConversationNotFound) {\n        throw error;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Check whether message has been read.\n   *\n   * @param conversation_id Conversation ID\n   * @param message_id Message ID\n   * @returns Resolves with `true` if message is marked as read\n   */\n  async isMessageRead(conversation_id: QualifiedId, message_id: string): Promise<boolean> {\n    if (!conversation_id || !message_id) {\n      return false;\n    }\n\n    try {\n      const conversationEntity = await this.getConversationById(conversation_id);\n      const messageEntity = await this.messageRepository.getMessageInConversationById(conversationEntity, message_id);\n      return conversationEntity.last_read_timestamp() >= messageEntity.timestamp();\n    } catch (error) {\n      const messageNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n      if (messageNotFound) {\n        return true;\n      }\n\n      throw error;\n    }\n  }\n\n  initializeConversations(): Promise<unknown> | undefined {\n    this.initStateUpdates();\n    this.init_total = this.receiving_queue.getLength();\n\n    if (this.init_total > 5) {\n      this.logger.log(`Handling '${this.init_total}' additional messages on app start`);\n      return new Promise((resolve, reject) => (this.init_promise = {rejectFn: reject, resolveFn: resolve}));\n    }\n    return undefined;\n  }\n\n  /**\n   * Starts the join public conversation flow.\n   * Opens conversation directly when it is already known.\n   *\n   * @param event Custom event containing join key/code\n   */\n  private readonly onConversationJoin = async (event: {detail: {code: string; key: string}}) => {\n    const {key, code} = event.detail;\n\n    const showNoConversationModal = () => {\n      const titleText = t('modalConversationJoinNotFoundHeadline');\n      const messageText = t('modalConversationJoinNotFoundMessage');\n      this.showModal(messageText, titleText);\n    };\n    const showTooManyMembersModal = () => {\n      const titleText = t('modalConversationJoinFullHeadline');\n      const messageText = t('modalConversationJoinFullMessage');\n      this.showModal(messageText, titleText);\n    };\n\n    try {\n      const {id: conversationId, name: conversationName} = await this.conversation_service.getConversationJoin(\n        key,\n        code,\n      );\n      const knownConversation = this.conversationState.findConversation({domain: null, id: conversationId});\n      if (knownConversation?.status() === ConversationStatus.CURRENT_MEMBER) {\n        amplify.publish(WebAppEvents.CONVERSATION.SHOW, knownConversation, {});\n        return;\n      }\n      amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.CONFIRM, {\n        primaryAction: {\n          action: async () => {\n            try {\n              const response = await this.conversation_service.postConversationJoin(key, code);\n              const conversationEntity = await this.getConversationById({domain: '', id: conversationId});\n              if (response) {\n                await this.onMemberJoin(conversationEntity, response);\n              }\n              amplify.publish(WebAppEvents.CONVERSATION.SHOW, conversationEntity, {});\n            } catch (error) {\n              switch (error.label) {\n                case BackendErrorLabel.NO_CONVERSATION:\n                case BackendErrorLabel.NO_CONVERSATION_CODE: {\n                  showNoConversationModal();\n                  break;\n                }\n                case BackendErrorLabel.TOO_MANY_MEMBERS: {\n                  showTooManyMembersModal();\n                  break;\n                }\n\n                default: {\n                  throw error;\n                }\n              }\n            }\n          },\n          text: t('modalConversationJoinConfirm'),\n        },\n        text: {\n          message: t('modalConversationJoinMessage', {conversationName}),\n          title: t('modalConversationJoinHeadline'),\n        },\n      });\n    } catch (error) {\n      switch (error.label) {\n        case BackendErrorLabel.NO_CONVERSATION:\n        case BackendErrorLabel.NO_CONVERSATION_CODE: {\n          showNoConversationModal();\n          break;\n        }\n        default: {\n          throw error;\n        }\n      }\n    }\n  };\n\n  /**\n   * Maps user connection to the corresponding conversation.\n   *\n   * @note If there is no conversation it will request it from the backend\n   * @returns Resolves when connection was mapped return value\n   */\n  private readonly mapConnection = (connectionEntity: ConnectionEntity): Promise<Conversation | undefined> => {\n    const qualifiedId: QualifiedId = connectionEntity.conversationId;\n    return Promise.resolve(this.conversationState.findConversation(qualifiedId))\n      .then(conversationEntity => {\n        if (!conversationEntity) {\n          if (connectionEntity.isConnected() || connectionEntity.isOutgoingRequest()) {\n            return this.fetchConversationById(qualifiedId);\n          }\n        }\n        return conversationEntity;\n      })\n      .then(conversationEntity => {\n        if (!conversationEntity) {\n          return undefined;\n        }\n        conversationEntity.connection(connectionEntity);\n\n        if (connectionEntity.isConnected()) {\n          conversationEntity.type(CONVERSATION_TYPE.ONE_TO_ONE);\n        }\n\n        return this.updateParticipatingUserEntities(conversationEntity);\n      })\n      .then(updatedConversationEntity => {\n        this.conversationState.conversations.notifySubscribers();\n        return updatedConversationEntity;\n      })\n      .catch(error => {\n        const isConversationNotFound = error.type === ConversationError.TYPE.CONVERSATION_NOT_FOUND;\n        if (!isConversationNotFound) {\n          throw error;\n        }\n        return undefined;\n      });\n  };\n\n  /**\n   * @returns resolves when deleted conversations are locally deleted, too.\n   */\n  checkForDeletedConversations() {\n    return Promise.all(\n      this.conversationState.conversations().map(async conversation => {\n        try {\n          await this.conversation_service.getConversationById(conversation);\n        } catch ({code}) {\n          if (code === HTTP_STATUS.NOT_FOUND) {\n            this.deleteConversationLocally(conversation, true);\n          }\n        }\n      }),\n    );\n  }\n\n  /**\n   * Maps user connections to the corresponding conversations.\n   * @param connectionEntities Connections entities\n   */\n  mapConnections(connectionEntities: ConnectionEntity[]): Promise<Conversation>[] {\n    this.logger.info(`Mapping '${connectionEntities.length}' user connection(s) to conversations`, connectionEntities);\n    return connectionEntities.map(connectionEntity => this.mapConnection(connectionEntity));\n  }\n\n  /**\n   * Map conversation payload.\n   *\n   * @param payload Payload to map\n   * @param initialTimestamp Initial server and event timestamp\n   * @returns Mapped conversation/s\n   */\n  mapConversations(payload: BackendConversation[], initialTimestamp = this.getLatestEventTimestamp()): Conversation[] {\n    const entities = ConversationMapper.mapConversations(payload as ConversationDatabaseData[], initialTimestamp);\n    entities.forEach(conversationEntity => {\n      this._mapGuestStatusSelf(conversationEntity);\n      conversationEntity.selfUser(this.userState.self());\n      conversationEntity.setStateChangePersistence(true);\n    });\n\n    return entities;\n  }\n\n  private mapGuestStatusSelf() {\n    this.conversationState\n      .filtered_conversations()\n      .forEach(conversationEntity => this._mapGuestStatusSelf(conversationEntity));\n\n    if (this.teamState.isTeam()) {\n      this.userState.self().inTeam(true);\n      this.userState.self().isTeamMember(true);\n    }\n  }\n\n  private _mapGuestStatusSelf(conversationEntity: Conversation) {\n    const conversationTeamId = conversationEntity.team_id;\n    const selfTeamId = this.teamState.team()?.id;\n    const isConversationGuest = !!(conversationTeamId && (!selfTeamId || selfTeamId !== conversationTeamId));\n    conversationEntity.isGuest(isConversationGuest);\n  }\n\n  /**\n   * Save a conversation in the repository and in the database.\n   * Will resolve with local conversation entity and do nothing if conversation already exists in state\n   *\n   * @param conversationEntity Conversation to be saved in the repository\n   * @returns Resolves when conversation was saved\n   */\n  saveConversation(conversationEntity: Conversation) {\n    const localEntity = this.conversationState.findConversation(conversationEntity);\n    if (!localEntity) {\n      this.conversationState.conversations.push(conversationEntity);\n      return this.saveConversationStateInDb(conversationEntity);\n    }\n    return Promise.resolve(localEntity);\n  }\n\n  /**\n   * Persists a conversation state in the database.\n   * @param conversationEntity Conversation of which the state should be persisted\n   * @returns Resolves when conversation was saved\n   */\n  private readonly saveConversationStateInDb = (conversationEntity: Conversation) => {\n    return this.conversation_service.saveConversationStateInDb(conversationEntity);\n  };\n\n  /**\n   * Save conversations in the repository.\n   * @param conversationEntities Conversations to be saved in the repository\n   */\n  private saveConversations(conversationEntities: Conversation[]) {\n    this.conversationState.conversations.push(...conversationEntities);\n  }\n\n  /**\n   * Set the notification handling state.\n   *\n   * @note Temporarily do not unarchive conversations when handling the notification stream\n   * @param handlingState State of the notifications stream handling\n   */\n  private readonly setNotificationHandlingState = (handlingState: NOTIFICATION_HANDLING_STATE) => {\n    const isFetchingFromStream = handlingState !== NOTIFICATION_HANDLING_STATE.WEB_SOCKET;\n\n    if (this.isBlockingNotificationHandling !== isFetchingFromStream) {\n      if (!isFetchingFromStream) {\n        this.checkChangedConversations();\n      }\n      this.isBlockingNotificationHandling = isFetchingFromStream;\n      this.logger.info(`Block handling of conversation events: ${this.isBlockingNotificationHandling}`);\n    }\n  };\n\n  /**\n   * Update participating users in a conversation.\n   *\n   * @param conversationEntity Conversation to be updated\n   * @param offline Should we only look for cached contacts\n   * @param updateGuests Update conversation guests\n   * @returns Resolves when users have been updated\n   */\n  async updateParticipatingUserEntities(\n    conversationEntity: Conversation,\n    offline = false,\n    updateGuests = false,\n  ): Promise<Conversation> {\n    const userEntities = await this.userRepository.getUsersById(conversationEntity.participating_user_ids(), offline);\n    userEntities.sort(sortUsersByPriority);\n    conversationEntity.participating_user_ets(userEntities);\n\n    if (updateGuests) {\n      conversationEntity.updateGuests();\n    }\n\n    return conversationEntity;\n  }\n\n  //##############################################################################\n  // Send events\n  //##############################################################################\n\n  /**\n   * Add users to an existing conversation.\n   *\n   * @param conversationEntity Conversation to add users to\n   * @param userEntities Users to be added to the conversation\n   * @returns Resolves when members were added\n   */\n  async addMembers(conversationEntity: Conversation, userEntities: User[]) {\n    const userIds = userEntities.map(userEntity => userEntity.qualifiedId);\n\n    try {\n      const response = await this.conversation_service.postMembers(\n        conversationEntity.id,\n        userIds,\n        conversationEntity.isFederated(),\n      );\n      if (response) {\n        this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n      }\n    } catch (error) {\n      return this.handleAddToConversationError(error, conversationEntity, userIds);\n    }\n  }\n\n  addMissingMember(conversationEntity: Conversation, users: QualifiedId[], timestamp: number) {\n    const [sender] = users;\n    const event = EventBuilder.buildMemberJoin(conversationEntity, sender, users, timestamp);\n    return this.eventRepository.injectEvent(event, EventRepository.SOURCE.INJECTED);\n  }\n\n  /**\n   * Add a service to an existing conversation.\n   *\n   * @param conversationEntity Conversation to add service to\n   * @param providerId ID of service provider\n   * @param serviceId ID of service\n   * @returns Resolves when service was added\n   */\n  addService(conversationEntity: Conversation, providerId: string, serviceId: string) {\n    return this.conversation_service\n      .postBots(conversationEntity.id, providerId, serviceId)\n      .then((response: any) => {\n        const event = response?.event;\n        if (event) {\n          const logMessage = `Successfully added service to conversation '${conversationEntity.display_name()}'`;\n          this.logger.debug(logMessage, response);\n          return this.eventRepository.injectEvent(response.event, EventRepository.SOURCE.BACKEND_RESPONSE);\n        }\n\n        return event;\n      })\n      .catch(error => this.handleAddToConversationError(error, conversationEntity, [{domain: '', id: serviceId}]));\n  }\n\n  private handleAddToConversationError(\n    error: BackendClientError,\n    conversationEntity: Conversation,\n    userIds: QualifiedId[],\n  ) {\n    switch (error.label) {\n      case BackendErrorLabel.NOT_CONNECTED: {\n        this.handleUsersNotConnected(userIds);\n        break;\n      }\n\n      case BackendClientError.LABEL.BAD_GATEWAY:\n      case BackendClientError.LABEL.SERVER_ERROR:\n      case BackendClientError.LABEL.SERVICE_DISABLED:\n      case BackendClientError.LABEL.TOO_MANY_BOTS: {\n        const messageText = t('modalServiceUnavailableMessage');\n        const titleText = t('modalServiceUnavailableHeadline');\n\n        this.showModal(messageText, titleText);\n        break;\n      }\n\n      case BackendErrorLabel.TOO_MANY_MEMBERS: {\n        this.handleTooManyMembersError(conversationEntity.getNumberOfParticipants());\n        break;\n      }\n      case BackendErrorLabel.LEGAL_HOLD_MISSING_CONSENT: {\n        this.showLegalHoldConsentError();\n        break;\n      }\n\n      default: {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Clear conversation content and archive the conversation.\n   *\n   * @note According to spec we archive a conversation when we clear it.\n   * It will be unarchived once it is opened through search. We use the archive flag to distinguish states.\n   *\n   * @param conversationEntity Conversation to clear\n   * @param leaveConversation Should we leave the conversation before clearing the content?\n   */\n  public clearConversation(conversationEntity: Conversation, leaveConversation = false) {\n    const isActiveConversation = this.conversationState.isActiveConversation(conversationEntity);\n    const nextConversationEntity = this.getNextConversation(conversationEntity);\n\n    if (leaveConversation) {\n      conversationEntity.status(ConversationStatus.PAST_MEMBER);\n      this.leaveCall(conversationEntity.id);\n    }\n\n    this.messageRepository.updateClearedTimestamp(conversationEntity);\n    this._clearConversation(conversationEntity);\n\n    if (leaveConversation) {\n      this.removeMember(conversationEntity, this.userState.self().qualifiedId);\n    }\n\n    if (isActiveConversation) {\n      amplify.publish(WebAppEvents.CONVERSATION.SHOW, nextConversationEntity, {});\n    }\n  }\n\n  async leaveGuestRoom(): Promise<void> {\n    if (this.userState.self().isTemporaryGuest()) {\n      const conversationEntity = this.getMostRecentConversation(true);\n      await this.conversation_service.deleteMembers(conversationEntity.id, this.userState.self().id);\n    }\n  }\n\n  /**\n   * Remove member from conversation.\n   *\n   * @param conversationEntity Conversation to remove member from\n   * @param user ID of member to be removed from the conversation\n   * @returns Resolves when member was removed from the conversation\n   */\n  public async removeMember(conversationEntity: Conversation, user: QualifiedId) {\n    const response = conversationEntity.isFederated()\n      ? await this.conversation_service.deleteQualifiedMembers(conversationEntity.qualifiedId, user)\n      : await this.conversation_service.deleteMembers(conversationEntity.id, user.id);\n    const roles = conversationEntity.roles();\n    delete roles[user.id];\n    conversationEntity.roles(roles);\n    const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n    const event = response || EventBuilder.buildMemberLeave(conversationEntity, user, true, currentTimestamp);\n    this.eventRepository.injectEvent(event, EventRepository.SOURCE.BACKEND_RESPONSE);\n    return event;\n  }\n\n  /**\n   * Remove service from conversation.\n   *\n   * @param conversationEntity Conversation to remove service from\n   * @param user ID of service user to be removed from the conversation\n   * @returns Resolves when service was removed from the conversation\n   */\n  public removeService(conversationEntity: Conversation, user: QualifiedId) {\n    return this.conversation_service.deleteBots(conversationEntity.id, user.id).then((response: any) => {\n      // TODO: Can this even have a response? in the API Client it look like it always returns `void`\n      const hasResponse = response?.event;\n      const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n      const event = hasResponse\n        ? response.event\n        : EventBuilder.buildMemberLeave(conversationEntity, user, true, currentTimestamp);\n\n      this.eventRepository.injectEvent(event, EventRepository.SOURCE.BACKEND_RESPONSE);\n      return event;\n    });\n  }\n\n  /**\n   * Rename conversation.\n   *\n   * @param conversationEntity Conversation to rename\n   * @param name New conversation name\n   * @returns Resolves when conversation was renamed\n   */\n  public async renameConversation(\n    conversationEntity: Conversation,\n    name: string,\n  ): Promise<ConversationRenameEvent | undefined> {\n    const response = await this.conversation_service.updateConversationName(conversationEntity.id, name);\n    if (response) {\n      this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n      return response;\n    }\n    return undefined;\n  }\n\n  /**\n   * Set the global message timer\n   */\n  async updateConversationMessageTimer(\n    conversationEntity: Conversation,\n    messageTimer: number,\n  ): Promise<ConversationMessageTimerUpdateEvent> {\n    messageTimer = ConversationEphemeralHandler.validateTimer(messageTimer);\n\n    const response = await this.conversation_service.updateConversationMessageTimer(\n      conversationEntity.id,\n      messageTimer,\n    );\n    if (response) {\n      this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n    }\n    return response;\n  }\n\n  public async updateConversationReceiptMode(\n    conversationEntity: Conversation,\n    receiptMode: ConversationReceiptModeUpdateData,\n  ) {\n    const response = await this.conversation_service.updateConversationReceiptMode(conversationEntity.id, receiptMode);\n    if (response) {\n      this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n    }\n    return response;\n  }\n\n  /**\n   * Team member was removed.\n   * @param teamId ID of team that member was removed from\n   * @param userId ID of leaving user\n   * @param isoDate Date of member removal\n   */\n  readonly teamMemberLeave = async (\n    teamId: string,\n    userId: QualifiedId,\n    isoDate = this.serverTimeHandler.toServerTimestamp(),\n  ) => {\n    const userEntity = await this.userRepository.getUserById(userId);\n    this.conversationState\n      .conversations()\n      .filter(conversationEntity => {\n        const conversationInTeam = conversationEntity.team_id === teamId;\n        const userIsParticipant = UserFilter.isParticipant(conversationEntity, userId);\n        return conversationInTeam && userIsParticipant && !conversationEntity.removed_from_conversation();\n      })\n      .forEach(conversationEntity => {\n        const leaveEvent = EventBuilder.buildTeamMemberLeave(conversationEntity, userEntity, isoDate);\n        this.eventRepository.injectEvent(leaveEvent);\n      });\n    userEntity.isDeleted = true;\n  };\n\n  /**\n   * Set the notification state of a conversation.\n   *\n   * @param conversationEntity Conversation to change notification state off\n   * @param notificationState New notification state\n   * @returns Resolves when the notification stated was change\n   */\n  public async setNotificationState(conversationEntity: Conversation, notificationState: number) {\n    if (!conversationEntity || notificationState === undefined) {\n      return Promise.reject(\n        new ConversationError(BaseError.TYPE.MISSING_PARAMETER as BASE_ERROR_TYPE, BaseError.MESSAGE.MISSING_PARAMETER),\n      );\n    }\n\n    const validNotificationStates = Object.values(NOTIFICATION_STATE);\n    if (!validNotificationStates.includes(notificationState)) {\n      return Promise.reject(\n        new ConversationError(BaseError.TYPE.INVALID_PARAMETER as BASE_ERROR_TYPE, BaseError.MESSAGE.INVALID_PARAMETER),\n      );\n    }\n\n    const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n    const payload = {\n      otr_muted_ref: new Date(conversationEntity.getLastKnownTimestamp(currentTimestamp)).toISOString(),\n      otr_muted_status: notificationState,\n    };\n\n    try {\n      await this.conversation_service.updateMemberProperties(conversationEntity.id, payload);\n      const response = {data: payload, from: this.userState.self().id};\n      this.onMemberUpdate(conversationEntity, response);\n\n      const {otr_muted_ref: mutedRef, otr_muted_status: mutedStatus} = payload;\n      const logMessage = `Changed notification state of conversation to '${mutedStatus}' on '${mutedRef}'`;\n      this.logger.info(logMessage);\n      return response;\n    } catch (error) {\n      const log = `Failed to change notification state of conversation '${conversationEntity.id}': ${error.message}`;\n      const rejectError = new Error(log);\n      this.logger.warn(rejectError.message, error);\n      throw rejectError;\n    }\n  }\n\n  /**\n   * Archive a conversation.\n   *\n   * @param conversationEntity Conversation to rename\n   * @returns Resolves when the conversation was archived\n   */\n  public async archiveConversation(conversationEntity: Conversation) {\n    await this.toggleArchiveConversation(conversationEntity, true);\n    this.logger.info(`Conversation '${conversationEntity.id}' archived`);\n  }\n\n  /**\n   * Un-archive a conversation.\n   *\n   * @param conversationEntity Conversation to unarchive\n   * @param forceChange Force state change without new message\n   * @param trigger Trigger for unarchive\n   * @returns Resolves when the conversation was unarchived\n   */\n  public async unarchiveConversation(conversationEntity: Conversation, forceChange = false, trigger = 'unknown') {\n    await this.toggleArchiveConversation(conversationEntity, false, forceChange);\n    this.logger.info(`Conversation '${conversationEntity.id}' unarchived by trigger '${trigger}'`);\n  }\n\n  private async toggleArchiveConversation(\n    conversationEntity: Conversation,\n    newState: boolean,\n    forceChange: boolean = false,\n  ) {\n    if (!conversationEntity) {\n      const error = new ConversationError(\n        ConversationError.TYPE.CONVERSATION_NOT_FOUND,\n        ConversationError.MESSAGE.CONVERSATION_NOT_FOUND,\n      );\n      throw error;\n    }\n\n    const stateChange = conversationEntity.is_archived() !== newState;\n\n    const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n    const archiveTimestamp = conversationEntity.getLastKnownTimestamp(currentTimestamp);\n    const sameTimestamp = conversationEntity.archivedTimestamp() === archiveTimestamp;\n    const skipChange = sameTimestamp && !forceChange;\n\n    if (!stateChange && skipChange) {\n      throw new ConversationError(ConversationError.TYPE.NO_CHANGES, ConversationError.MESSAGE.NO_CHANGES);\n    }\n\n    const payload = {\n      otr_archived: newState,\n      otr_archived_ref: new Date(archiveTimestamp).toISOString(),\n    };\n\n    const conversationId = conversationEntity.id;\n\n    const updatePromise = conversationEntity.removed_from_conversation()\n      ? Promise.resolve()\n      : this.conversation_service.updateMemberProperties(conversationId, payload).catch(error => {\n          const logMessage = `Failed to change archived state of '${conversationId}' to '${newState}': ${error.code}`;\n          this.logger.error(logMessage);\n\n          const isNotFound = error.code === HTTP_STATUS.NOT_FOUND;\n          if (!isNotFound) {\n            throw error;\n          }\n        });\n\n    await updatePromise;\n    const response = {\n      data: payload,\n      from: this.userState.self().id,\n    };\n    this.onMemberUpdate(conversationEntity, response);\n  }\n\n  private checkChangedConversations() {\n    this.conversationsWithNewEvents.forEach(conversationEntity => {\n      if (conversationEntity.shouldUnarchive()) {\n        this.unarchiveConversation(conversationEntity, false, 'event from notification stream');\n      }\n    });\n\n    this.conversationsWithNewEvents.clear();\n  }\n\n  /**\n   * Clears conversation content from view and the database.\n   *\n   * @param conversationEntity Conversation entity to delete\n   * @param timestamp Optional timestamps for which messages to remove\n   */\n  private _clearConversation(conversationEntity: Conversation, timestamp?: number) {\n    this.deleteMessages(conversationEntity, timestamp);\n\n    if (conversationEntity.removed_from_conversation()) {\n      this.conversation_service.deleteConversationFromDb(conversationEntity);\n      this.deleteConversationFromRepository(conversationEntity);\n    }\n  }\n\n  private handleConversationCreateError(error: BackendClientError, userIds: QualifiedId[]): void {\n    switch (error.label) {\n      case BackendClientError.LABEL.CLIENT_ERROR:\n        this.handleTooManyMembersError();\n        break;\n      case BackendClientError.LABEL.NOT_CONNECTED:\n        this.handleUsersNotConnected(userIds);\n        break;\n      case BackendErrorLabel.LEGAL_HOLD_MISSING_CONSENT:\n        this.showLegalHoldConsentError();\n        break;\n      default:\n        throw error;\n    }\n  }\n\n  private handleTooManyMembersError(participants = ConversationRepository.CONFIG.GROUP.MAX_SIZE) {\n    const openSpots = ConversationRepository.CONFIG.GROUP.MAX_SIZE - participants;\n    const substitutions = {\n      number1: ConversationRepository.CONFIG.GROUP.MAX_SIZE.toString(10),\n      number2: Math.max(0, openSpots).toString(10),\n    };\n\n    const messageText = t('modalConversationTooManyMembersMessage', substitutions);\n    const titleText = t('modalConversationTooManyMembersHeadline');\n    this.showModal(messageText, titleText);\n  }\n\n  private async handleUsersNotConnected(userIds: QualifiedId[] = []): Promise<void> {\n    const titleText = t('modalConversationNotConnectedHeadline');\n\n    if (userIds.length > 1) {\n      this.showModal(t('modalConversationNotConnectedMessageMany'), titleText);\n    } else {\n      // TODO(Federation): Update code once connections are implemented on the backend\n      const userEntity = await this.userRepository.getUserById(userIds[0]);\n      this.showModal(t('modalConversationNotConnectedMessageOne', userEntity.name()), titleText);\n    }\n  }\n\n  private showModal(messageText: string, titleText: string) {\n    amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.ACKNOWLEDGE, {\n      text: {\n        message: messageText,\n        title: titleText,\n      },\n    });\n  }\n\n  private showLegalHoldConsentError() {\n    const replaceLinkLegalHold = replaceLink(\n      Config.getConfig().URL.SUPPORT.LEGAL_HOLD_BLOCK,\n      '',\n      'read-more-legal-hold',\n    );\n\n    const messageText = t('modalLegalHoldConversationMissingConsentMessage', {}, replaceLinkLegalHold);\n    const titleText = t('modalUserCannotBeAddedHeadline');\n\n    amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.ACKNOWLEDGE, {\n      text: {\n        htmlMessage: messageText,\n        title: titleText,\n      },\n    });\n  }\n\n  //##############################################################################\n  // Send Generic Messages\n  //##############################################################################\n\n  readonly injectLegalHoldMessage = async ({\n    conversationEntity,\n    conversationId,\n    userId,\n    timestamp,\n    legalHoldStatus,\n    beforeTimestamp = false,\n  }: {\n    beforeTimestamp?: boolean;\n    conversationEntity?: Conversation;\n    conversationId: QualifiedId;\n    legalHoldStatus: LegalHoldStatus;\n    timestamp: string | number;\n    userId: QualifiedId;\n  }) => {\n    if (typeof legalHoldStatus === 'undefined') {\n      return;\n    }\n    if (!timestamp) {\n      // TODO(federation) find with qualified id\n      const conversation = conversationEntity || this.conversationState.findConversation(conversationId);\n      const servertime = this.serverTimeHandler.toServerTimestamp();\n      timestamp = conversation.getLatestTimestamp(servertime);\n    }\n    const legalHoldUpdateMessage = EventBuilder.buildLegalHoldMessage(\n      conversationId || conversationEntity?.qualifiedId,\n      userId,\n      timestamp,\n      legalHoldStatus,\n      beforeTimestamp,\n    );\n    await this.eventRepository.injectEvent(legalHoldUpdateMessage);\n  };\n\n  async injectFileTypeRestrictedMessage(\n    conversation: Conversation,\n    user: User,\n    isIncoming: boolean,\n    fileExt: string,\n    id = createRandomUuid(),\n  ) {\n    const fileRestrictionMessage = EventBuilder.buildFileTypeRestricted(conversation, user, isIncoming, fileExt, id);\n    await this.eventRepository.injectEvent(fileRestrictionMessage);\n  }\n\n  //##############################################################################\n  // Event callbacks\n  //##############################################################################\n\n  /**\n   * Listener for incoming events.\n   *\n   * @param eventJson JSON data for event\n   * @param eventSource Source of event\n   * @returns Resolves when event was handled\n   */\n  private readonly onConversationEvent = (eventJson: IncomingEvent, eventSource = EventRepository.SOURCE.STREAM) => {\n    const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};\n    const logMessage = `Conversation Event: '${eventJson.type}' (Source: ${eventSource})`;\n    this.logger.info(logMessage, logObject);\n\n    return this.pushToReceivingQueue(eventJson, eventSource);\n  };\n\n  private handleConversationEvent(eventJson: IncomingEvent, eventSource = EventRepository.SOURCE.STREAM) {\n    if (!eventJson) {\n      return Promise.reject(new Error('Conversation Repository Event Handling: Event missing'));\n    }\n\n    const {conversation, qualified_conversation, data: eventData, type} = eventJson;\n    // data.conversationId is always the conversationId that should be read first. If not found we can fallback to qualified_conversation or conversation\n    const conversationId: QualifiedId = eventData?.conversationId\n      ? {domain: '', id: eventData.conversationId}\n      : qualified_conversation || {domain: '', id: conversation};\n    this.logger.info(\n      `Handling event '${type}' in conversation '${conversationId.id}/${conversationId.domain}' (Source: ${eventSource})`,\n    );\n\n    const selfConversation = this.conversationState.self_conversation();\n    const inSelfConversation = selfConversation && matchQualifiedIds(conversationId, selfConversation.qualifiedId);\n    if (inSelfConversation) {\n      const typesInSelfConversation = [CONVERSATION_EVENT.MEMBER_UPDATE, ClientEvent.CONVERSATION.MESSAGE_HIDDEN];\n\n      const isExpectedType = typesInSelfConversation.includes(type);\n      if (!isExpectedType) {\n        return Promise.reject(\n          new ConversationError(\n            ConversationError.TYPE.WRONG_CONVERSATION,\n            ConversationError.MESSAGE.WRONG_CONVERSATION,\n          ),\n        );\n      }\n    }\n\n    const isConversationCreate = type === CONVERSATION_EVENT.CREATE;\n    const onEventPromise = isConversationCreate ? Promise.resolve(null) : this.getConversationById(conversationId);\n    let previouslyArchived = false;\n\n    return onEventPromise\n      .then((conversationEntity: Conversation) => {\n        if (conversationEntity) {\n          // Check if conversation was archived\n          previouslyArchived = conversationEntity.is_archived();\n\n          const isBackendTimestamp = eventSource !== EventRepository.SOURCE.INJECTED;\n          conversationEntity.updateTimestampServer(eventJson.server_time || eventJson.time, isBackendTimestamp);\n        }\n\n        return conversationEntity;\n      })\n      .then(conversationEntity => this.checkLegalHoldStatus(conversationEntity, eventJson))\n      .then(conversationEntity => this.checkConversationParticipants(conversationEntity, eventJson, eventSource))\n      .then(conversationEntity => this.triggerFeatureEventHandlers(conversationEntity, eventJson))\n      .then(\n        conversationEntity => this.reactToConversationEvent(conversationEntity, eventJson, eventSource) as EntityObject,\n      )\n      .then((entityObject = {} as EntityObject) =>\n        this.handleConversationNotification(entityObject as EntityObject, eventSource, previouslyArchived),\n      )\n      .catch((error: BaseError) => {\n        const ignoredErrorTypes: string[] = [\n          ConversationError.TYPE.MESSAGE_NOT_FOUND,\n          ConversationError.TYPE.CONVERSATION_NOT_FOUND,\n        ];\n\n        const isRemovedFromConversation =\n          (error as BackendClientError).label === BackendClientError.LABEL.ACCESS_DENIED;\n        if (isRemovedFromConversation) {\n          const messageText = t('conversationNotFoundMessage');\n          const titleText = t('conversationNotFoundTitle', Config.getConfig().BRAND_NAME);\n\n          this.showModal(messageText, titleText);\n          return;\n        }\n\n        if (!ignoredErrorTypes.includes(error.type)) {\n          throw error;\n        }\n      });\n  }\n\n  /**\n   * Check that sender of received event is a known conversation participant.\n   *\n   * @param conversationEntity Conversation targeted by the event\n   * @param eventJson JSON data of the event\n   * @param eventSource Source of event\n   * @returns Resolves when the participant list has been checked\n   */\n  private checkConversationParticipants(\n    conversationEntity: Conversation,\n    eventJson: IncomingEvent,\n    eventSource: EventSource,\n  ) {\n    // We ignore injected events\n    const isInjectedEvent = eventSource === EventRepository.SOURCE.INJECTED;\n    if (isInjectedEvent || !conversationEntity) {\n      return conversationEntity;\n    }\n\n    const {from: senderId, type, time} = eventJson;\n\n    if (senderId) {\n      const allParticipants = conversationEntity.participating_user_ids().concat(this.userState.self().qualifiedId);\n      const isFromUnknownUser = allParticipants.every(participant => participant.id !== senderId);\n\n      if (isFromUnknownUser) {\n        const membersUpdateMessages = [\n          CONVERSATION_EVENT.MEMBER_LEAVE,\n          CONVERSATION_EVENT.MEMBER_JOIN,\n          ClientEvent.CONVERSATION.TEAM_MEMBER_LEAVE,\n        ];\n        const isMembersUpdateEvent = membersUpdateMessages.includes(eventJson.type);\n        if (isMembersUpdateEvent) {\n          const isFromUpdatedMember = eventJson.data.user_ids?.includes(senderId);\n          if (isFromUpdatedMember) {\n            // we ignore leave/join events that are sent by the user actually leaving or joining\n            return conversationEntity;\n          }\n        }\n\n        const message = `Received '${type}' event from user '${senderId}' unknown in '${conversationEntity.id}'`;\n        this.logger.warn(message, eventJson);\n\n        const qualifiedSender: QualifiedId = {domain: '', id: senderId};\n\n        const timestamp = new Date(time).getTime() - 1;\n        return this.addMissingMember(conversationEntity, [qualifiedSender], timestamp).then(() => conversationEntity);\n      }\n    }\n\n    return conversationEntity;\n  }\n\n  private async checkLegalHoldStatus(conversationEntity: Conversation, eventJson: IncomingEvent) {\n    if (!LegalHoldEvaluator.hasMessageLegalHoldFlag(eventJson)) {\n      return conversationEntity;\n    }\n\n    const renderLegalHoldMessage = LegalHoldEvaluator.renderLegalHoldMessage(\n      eventJson,\n      conversationEntity.legalHoldStatus(),\n    );\n\n    if (!renderLegalHoldMessage) {\n      return conversationEntity;\n    }\n\n    const {\n      conversation: conversationId,\n      qualified_conversation,\n      qualified_from,\n      data: {legal_hold_status: messageLegalHoldStatus},\n      from: userId,\n      time: isoTimestamp,\n    } = eventJson;\n    const qualifiedConversation = qualified_conversation || {domain: '', id: conversationId};\n    const qualifiedUser = qualified_from || {domain: '', id: userId};\n\n    await this.injectLegalHoldMessage({\n      beforeTimestamp: true,\n      conversationId: qualifiedConversation,\n      legalHoldStatus: messageLegalHoldStatus,\n      timestamp: isoTimestamp,\n      userId: qualifiedUser,\n    });\n\n    await this.messageRepository.updateAllClients(conversationEntity, true);\n\n    if (messageLegalHoldStatus === conversationEntity.legalHoldStatus()) {\n      return conversationEntity;\n    }\n\n    await this.injectLegalHoldMessage({\n      conversationId: qualifiedConversation,\n      legalHoldStatus: conversationEntity.legalHoldStatus(),\n      timestamp: isoTimestamp,\n      userId: qualifiedUser,\n    });\n\n    return conversationEntity;\n  }\n\n  /**\n   * Triggers the methods associated with a specific event.\n   *\n   * @param conversationEntity Conversation targeted by the event\n   * @param eventJson JSON data of the event\n   * @param eventSource Source of event\n   * @returns Resolves when the event has been treated\n   */\n  private reactToConversationEvent(\n    conversationEntity: Conversation,\n    eventJson: IncomingEvent,\n    eventSource: EventSource,\n  ) {\n    switch (eventJson.type) {\n      case CONVERSATION_EVENT.CREATE:\n        return this.onCreate(eventJson, eventSource);\n\n      case CONVERSATION_EVENT.DELETE:\n        return this.deleteConversationLocally({domain: conversationEntity.domain, id: eventJson.conversation}, false);\n\n      case CONVERSATION_EVENT.MEMBER_JOIN:\n        return this.onMemberJoin(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.MEMBER_LEAVE:\n      case ClientEvent.CONVERSATION.TEAM_MEMBER_LEAVE:\n        return this.onMemberLeave(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.MEMBER_UPDATE:\n        return this.onMemberUpdate(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.RENAME:\n        return this.onRename(conversationEntity, eventJson, eventSource === EventRepository.SOURCE.WEB_SOCKET);\n\n      case ClientEvent.CONVERSATION.ASSET_ADD:\n        return this.onAssetAdd(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.GROUP_CREATION:\n        return this.onGroupCreation(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.MESSAGE_DELETE:\n        return this.onMessageDeleted(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.MESSAGE_HIDDEN:\n        return this.onMessageHidden(eventJson);\n\n      case ClientEvent.CONVERSATION.ONE2ONE_CREATION:\n        return this.on1to1Creation(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.REACTION:\n        return this.onReaction(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.RECEIPT_MODE_UPDATE:\n        return this.onReceiptModeChanged(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.BUTTON_ACTION_CONFIRMATION:\n        return this.onButtonActionConfirmation(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.MESSAGE_ADD:\n        const isMessageEdit = !!eventJson.edited_time;\n        if (isMessageEdit) {\n          // in case of an edition, the DB listener will take care of updating the local entity\n          return {conversationEntity};\n        }\n        return this.addEventToConversation(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.MESSAGE_TIMER_UPDATE:\n      case ClientEvent.CONVERSATION.COMPOSITE_MESSAGE_ADD:\n      case ClientEvent.CONVERSATION.DELETE_EVERYWHERE:\n      case ClientEvent.CONVERSATION.FILE_TYPE_RESTRICTED:\n      case ClientEvent.CONVERSATION.INCOMING_MESSAGE_TOO_BIG:\n      case ClientEvent.CONVERSATION.KNOCK:\n      case ClientEvent.CONVERSATION.CALL_TIME_OUT:\n      case ClientEvent.CONVERSATION.LEGAL_HOLD_UPDATE:\n      case ClientEvent.CONVERSATION.LOCATION:\n      case ClientEvent.CONVERSATION.MISSED_MESSAGES:\n      case ClientEvent.CONVERSATION.UNABLE_TO_DECRYPT:\n      case ClientEvent.CONVERSATION.VERIFICATION:\n      case ClientEvent.CONVERSATION.VOICE_CHANNEL_ACTIVATE:\n      case ClientEvent.CONVERSATION.VOICE_CHANNEL_DEACTIVATE:\n        return this.addEventToConversation(conversationEntity, eventJson);\n    }\n  }\n\n  /**\n   * Calls the feature specific event handler on the current event being handled.\n   *\n   * @param conversationEntity Conversation targeted by the event\n   * @param eventJson JSON data of the event\n   * @param eventSource Source of event\n   * @returns Resolves when all the handlers have done their job\n   */\n  private async triggerFeatureEventHandlers(conversationEntity: Conversation, eventJson: IncomingEvent) {\n    const conversationEventHandlers = [this.ephemeralHandler, this.stateHandler];\n    const handlePromises = conversationEventHandlers.map(handler =>\n      handler.handleConversationEvent(conversationEntity, eventJson),\n    );\n    await Promise.all(handlePromises);\n    return conversationEntity;\n  }\n\n  /**\n   * Handles conversation update and notification message.\n   *\n   * @param entityObject Object containing the conversation and the message that are targeted by the event\n   * @param eventSource Source of event\n   * @param previouslyArchived `true` if the previous state of the conversation was archived\n   * @returns Resolves when the conversation was updated\n   */\n  private async handleConversationNotification(\n    entityObject: EntityObject,\n    eventSource: EventSource,\n    previouslyArchived: boolean,\n  ) {\n    const {conversationEntity, messageEntity} = entityObject;\n\n    if (conversationEntity) {\n      const eventFromWebSocket = eventSource === EventRepository.SOURCE.WEB_SOCKET;\n      const eventFromStream = eventSource === EventRepository.SOURCE.STREAM;\n\n      if (messageEntity) {\n        const isRemoteEvent = eventFromStream || eventFromWebSocket;\n\n        if (isRemoteEvent) {\n          this.messageRepository.sendConfirmationStatus(conversationEntity, messageEntity, Confirmation.Type.DELIVERED);\n        }\n\n        if (!eventFromStream) {\n          amplify.publish(WebAppEvents.NOTIFICATION.NOTIFY, messageEntity, undefined, conversationEntity);\n        }\n\n        if (conversationEntity.is_cleared()) {\n          conversationEntity.cleared_timestamp(0);\n        }\n      }\n\n      // Check if event needs to be un-archived\n      if (previouslyArchived) {\n        // Add to check for un-archiving at the end of stream handling\n        if (eventFromStream) {\n          return this.conversationsWithNewEvents.set(conversationEntity.id, conversationEntity);\n        }\n\n        if (eventFromWebSocket && conversationEntity.shouldUnarchive()) {\n          return this.unarchiveConversation(conversationEntity, false, 'event from WebSocket');\n        }\n      }\n    }\n  }\n\n  /**\n   * Push to receiving queue.\n   * @param eventJson JSON data for event\n   * @param source Source of event\n   */\n  private pushToReceivingQueue(eventJson: IncomingEvent, source: EventSource) {\n    this.receiving_queue\n      .push(() => this.handleConversationEvent(eventJson, source))\n      .then(() => {\n        if (this.init_promise) {\n          const eventFromStream = source === EventRepository.SOURCE.STREAM;\n          if (eventFromStream) {\n            this.init_handled = this.init_handled + 1;\n            if (this.init_handled % 5 === 0 || this.init_handled < 5) {\n              const content = {\n                handled: this.init_handled,\n                total: this.init_total,\n              };\n              const progress = (this.init_handled / this.init_total) * 20 + 75;\n\n              amplify.publish(WebAppEvents.APP.UPDATE_PROGRESS, progress, t('initEvents'), content);\n            }\n          }\n\n          if (!this.receiving_queue.getLength() || !eventFromStream) {\n            this.init_promise.resolveFn();\n            this.init_promise = undefined;\n          }\n        }\n      })\n      .catch(error => {\n        if (this.init_promise) {\n          this.init_promise.rejectFn(error);\n          this.init_promise = undefined;\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  /**\n   * Add \"missed events\" system message to conversation.\n   */\n  private readonly onMissedEvents = (): void => {\n    this.conversationState\n      .filtered_conversations()\n      .filter(conversationEntity => !conversationEntity.removed_from_conversation())\n      .forEach(conversationEntity => {\n        const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n        const missed_event = EventBuilder.buildMissed(conversationEntity, currentTimestamp);\n        this.eventRepository.injectEvent(missed_event);\n      });\n  };\n\n  private on1to1Creation(conversationEntity: Conversation, eventJson: OneToOneCreationEvent) {\n    return this.event_mapper\n      .mapJsonEvent(eventJson, conversationEntity)\n      .then(messageEntity => this.updateMessageUserEntities(messageEntity))\n      .then((messageEntity: MemberMessage) => {\n        const userEntity = messageEntity.otherUser();\n        const isOutgoingRequest = userEntity?.isOutgoingRequest();\n        if (isOutgoingRequest) {\n          messageEntity.memberMessageType = SystemMessageType.CONNECTION_REQUEST;\n        }\n\n        conversationEntity.addMessage(messageEntity);\n        return {conversationEntity};\n      });\n  }\n\n  /**\n   * A conversation was created.\n   *\n   * @param eventJson JSON data of 'conversation.create' event\n   * @param eventSource Source of event\n   * @returns Resolves when the event was handled\n   */\n  private async onCreate(\n    eventJson: ConversationCreateEvent,\n    eventSource?: EventSource,\n  ): Promise<{conversationEntity: Conversation}> {\n    const {conversation: conversationId, data: eventData, time} = eventJson;\n    const eventTimestamp = new Date(time).getTime();\n    const initialTimestamp = isNaN(eventTimestamp) ? this.getLatestEventTimestamp(true) : eventTimestamp;\n    try {\n      const existingConversationEntity = this.conversationState.findConversation({\n        domain: eventJson.qualified_conversation?.domain,\n        id: conversationId,\n      });\n      if (existingConversationEntity) {\n        throw new ConversationError(ConversationError.TYPE.NO_CHANGES, ConversationError.MESSAGE.NO_CHANGES);\n      }\n\n      const [conversationEntity] = this.mapConversations([eventData], initialTimestamp);\n      if (conversationEntity) {\n        if (conversationEntity.participating_user_ids().length) {\n          this.addCreationMessage(conversationEntity, false, initialTimestamp, eventSource);\n        }\n        await this.updateParticipatingUserEntities(conversationEntity);\n        this.verificationStateHandler.onConversationCreate(conversationEntity);\n        await this.saveConversation(conversationEntity);\n      }\n      return {conversationEntity};\n    } catch (error) {\n      const isNoChanges = error.type === ConversationError.TYPE.NO_CHANGES;\n      if (!isNoChanges) {\n        throw error;\n      }\n    }\n    return undefined;\n  }\n\n  private async onGroupCreation(conversationEntity: Conversation, eventJson: GroupCreationEvent) {\n    const messageEntity = await this.event_mapper.mapJsonEvent(eventJson, conversationEntity);\n    const creatorId = conversationEntity.creator;\n    const creatorDomain = conversationEntity.domain;\n    const createdByParticipant = !!conversationEntity\n      .participating_user_ids()\n      .find(userId => matchQualifiedIds(userId, {domain: creatorDomain, id: creatorId}));\n    const createdBySelfUser = conversationEntity.isCreatedBySelf();\n\n    const creatorIsParticipant = createdByParticipant || createdBySelfUser;\n\n    const data = await this.conversation_service.getConversationById(conversationEntity);\n    const allMembers = [...data.members.others, data.members.self];\n    const conversationRoles = allMembers.reduce<Record<string, string>>((roles, member) => {\n      roles[member.id] = member.conversation_role;\n      return roles;\n    }, {});\n    conversationEntity.roles(conversationRoles);\n\n    if (!creatorIsParticipant) {\n      (messageEntity as MemberMessage).memberMessageType = SystemMessageType.CONVERSATION_RESUME;\n    }\n\n    const updatedMessageEntity = await this.updateMessageUserEntities(messageEntity);\n    if (conversationEntity && updatedMessageEntity) {\n      conversationEntity.addMessage(updatedMessageEntity);\n    }\n\n    return {conversationEntity, messageEntity: updatedMessageEntity};\n  }\n\n  /**\n   * Users were added to a group conversation.\n   *\n   * @param conversationEntity Conversation to add users to\n   * @param eventJson JSON data of 'conversation.member-join' event\n   * @returns Resolves when the event was handled\n   */\n  private async onMemberJoin(\n    conversationEntity: Conversation,\n    eventJson: ConversationMemberJoinEvent,\n  ): Promise<void | EntityObject> {\n    // Ignore if we join a 1to1 conversation (accept a connection request)\n    const connectionEntity = this.connectionRepository.getConnectionByConversationId(conversationEntity.qualifiedId);\n    const isPendingConnection = connectionEntity?.isIncomingRequest();\n    if (isPendingConnection) {\n      return Promise.resolve();\n    }\n\n    const eventData = eventJson.data;\n\n    if (eventData.users) {\n      eventData.users.forEach(otherMember => {\n        const otherId = otherMember.qualified_id || {domain: '', id: otherMember.id};\n        const isSelfUser = matchQualifiedIds(otherId, this.userState.self());\n        const isParticipatingUser = !!conversationEntity\n          .participating_user_ids()\n          .find(participatingUser =>\n            matchQualifiedIds(participatingUser, otherMember.qualified_id || {domain: '', id: otherMember.id}),\n          );\n        if (!isSelfUser && !isParticipatingUser) {\n          conversationEntity.participating_user_ids.push({\n            domain: otherMember.qualified_id?.domain || null,\n            id: otherMember.id,\n          });\n        }\n      });\n    } else {\n      eventData.user_ids.forEach(userId => {\n        const isSelfUser = userId === this.userState.self().id;\n        const isParticipatingUser = conversationEntity.participating_user_ids().some(user => user.id === userId);\n        if (!isSelfUser && !isParticipatingUser) {\n          conversationEntity.participating_user_ids.push({domain: '', id: userId});\n        }\n      });\n    }\n\n    // Self user joins again\n    const selfUserRejoins = eventData.user_ids.includes(this.userState.self().id);\n    if (selfUserRejoins) {\n      conversationEntity.status(ConversationStatus.CURRENT_MEMBER);\n      await this.conversationRoleRepository.updateConversationRoles(conversationEntity);\n    }\n\n    const updateSequence =\n      selfUserRejoins || connectionEntity?.isConnected()\n        ? this.updateConversationFromBackend(conversationEntity)\n        : Promise.resolve();\n\n    const qualifiedUserIds =\n      eventData.users?.map(user => user.qualified_id) || eventData.user_ids.map(userId => ({domain: '', id: userId}));\n\n    return updateSequence\n      .then(() => this.updateParticipatingUserEntities(conversationEntity, false, true))\n      .then(() => this.addEventToConversation(conversationEntity, eventJson))\n      .then(({messageEntity}) => {\n        this.verificationStateHandler.onMemberJoined(conversationEntity, qualifiedUserIds);\n        return {conversationEntity, messageEntity};\n      });\n  }\n\n  /**\n   * Members of a group conversation were removed or left.\n   *\n   * @param conversationEntity Conversation to remove users from\n   * @param eventJson JSON data of 'conversation.member-leave' event\n   * @returns Resolves when the event was handled\n   */\n  private async onMemberLeave(\n    conversationEntity: Conversation,\n    eventJson: ConversationMemberLeaveEvent | TeamMemberLeaveEvent,\n  ): Promise<{conversationEntity: Conversation; messageEntity: Message} | undefined> {\n    const {data: eventData, from} = eventJson;\n    const isFromSelf = from === this.userState.self().id;\n    const removesSelfUser = eventData.user_ids.includes(this.userState.self().id);\n    const selfLeavingClearedConversation = isFromSelf && removesSelfUser && conversationEntity.is_cleared();\n\n    if (removesSelfUser) {\n      conversationEntity.status(ConversationStatus.PAST_MEMBER);\n      this.leaveCall(conversationEntity.id);\n      if (this.userState.self().isTemporaryGuest()) {\n        eventJson.from = this.userState.self().id;\n      }\n    }\n\n    if (!selfLeavingClearedConversation) {\n      const {messageEntity} = await this.addEventToConversation(conversationEntity, eventJson);\n      (messageEntity as MemberMessage)\n        .userEntities()\n        .filter(userEntity => !userEntity.isMe)\n        .forEach(userEntity => {\n          conversationEntity.participating_user_ids.remove(userId => matchQualifiedIds(userId, userEntity));\n\n          if (userEntity.isTemporaryGuest()) {\n            userEntity.clearExpirationTimeout();\n          }\n        });\n\n      await this.updateParticipatingUserEntities(conversationEntity);\n\n      this.verificationStateHandler.onMemberLeft(conversationEntity);\n\n      if (isFromSelf && conversationEntity.removed_from_conversation()) {\n        this.archiveConversation(conversationEntity);\n      }\n\n      return {conversationEntity, messageEntity};\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Membership properties for a conversation were updated.\n   *\n   * @param conversationEntity Conversation entity that will be updated\n   * @param eventJson JSON data of 'conversation.member-update' event\n   * @returns Resolves when the event was handled\n   */\n  private onMemberUpdate(\n    conversationEntity: Conversation,\n    eventJson: Pick<ConversationMemberUpdateEvent, 'data' | 'from'> & {conversation?: string},\n  ) {\n    const {conversation, data: eventData, from} = eventJson;\n    const conversationId = {domain: '', id: conversation || '' /* TODO(federation) add domain on the sender side */};\n\n    const isConversationRoleUpdate = !!eventData.conversation_role;\n    if (isConversationRoleUpdate) {\n      const {target, qualified_target, conversation_role} = eventData;\n      const userId = qualified_target || {domain: '', id: target};\n      const conversation = this.conversationState\n        .conversations()\n        .find(conversation => matchQualifiedIds(conversation, conversationId));\n      if (conversation) {\n        const roles = conversation.roles();\n        roles[userId.id] = conversation_role;\n        conversation.roles(roles);\n      }\n      return;\n    }\n\n    const isBackendEvent = eventData.otr_archived_ref || eventData.otr_muted_ref;\n    const selfConversation = this.conversationState.self_conversation();\n    const inSelfConversation = selfConversation && matchQualifiedIds(selfConversation, conversationId);\n    if (!inSelfConversation && conversation && !isBackendEvent) {\n      throw new ConversationError(\n        ConversationError.TYPE.WRONG_CONVERSATION,\n        ConversationError.MESSAGE.WRONG_CONVERSATION,\n      );\n    }\n\n    const isFromSelf = !this.userState.self() || from === this.userState.self().id;\n    if (!isFromSelf) {\n      throw new ConversationError(ConversationError.TYPE.WRONG_USER, ConversationError.MESSAGE.WRONG_USER);\n    }\n\n    const isActiveConversation = this.conversationState.isActiveConversation(conversationEntity);\n    const nextConversationEntity = isActiveConversation ? this.getNextConversation(conversationEntity) : undefined;\n    const previouslyArchived = conversationEntity.is_archived();\n\n    ConversationMapper.updateSelfStatus(conversationEntity, eventData);\n\n    const wasUnarchived = previouslyArchived && !conversationEntity.is_archived();\n    if (wasUnarchived) {\n      return this.fetchUsersAndEvents(conversationEntity);\n    }\n\n    if (conversationEntity.is_cleared()) {\n      this._clearConversation(conversationEntity, conversationEntity.cleared_timestamp());\n    }\n\n    if (isActiveConversation && (conversationEntity.is_archived() || conversationEntity.is_cleared())) {\n      amplify.publish(WebAppEvents.CONVERSATION.SHOW, nextConversationEntity, {});\n    }\n  }\n\n  /**\n   * An asset received in a conversation.\n   *\n   * @param conversationEntity Conversation to add the event to\n   * @param event JSON data of 'conversation.asset-add'\n   * @returns Resolves when the event was handled\n   */\n  private async onAssetAdd(conversationEntity: Conversation, event: AssetAddEvent) {\n    const fromSelf = event.from === this.userState.self().id;\n\n    const isRemoteFailure = !fromSelf && event.data.status === AssetTransferState.UPLOAD_FAILED;\n    const isLocalCancel = fromSelf && event.data.reason === ProtobufAsset.NotUploaded.CANCELLED;\n\n    if (isRemoteFailure || isLocalCancel) {\n      /**\n       * WEBAPP-6916: An unsuccessful asset upload triggers a removal of the original asset message in the `EventRepository`.\n       * Thus the event timestamps need to get updated, so that the latest event timestamp is from the message which was send before the original message.\n       *\n       * Info: Since the `EventRepository` does not have a reference to the `ConversationRepository` we do that event update at this location.\n       * A more fitting place would be the `AssetTransferState.UPLOAD_FAILED` case in `EventRepository._handleAssetUpdate`.\n       *\n       * Our assumption is that the `_handleAssetUpdate` function (invoked by `notificationsQueue.subscribe`) is executed before this function.\n       */\n      return conversationEntity.updateTimestamps(conversationEntity.getLastMessage(), true);\n    }\n\n    if (!allowsAllFiles()) {\n      const fileName = event.data.info.name;\n      const contentType = event.data.content_type;\n      if (!isAllowedFile(fileName, contentType)) {\n        // TODO(Federation): Update code once sending assets is implemented on the backend\n        const user = await this.userRepository.getUserById({domain: '', id: event.from});\n        return this.injectFileTypeRestrictedMessage(\n          conversationEntity,\n          user,\n          true,\n          getFileExtensionOrName(fileName),\n          event.id,\n        );\n      }\n    }\n    const {messageEntity} = await this.addEventToConversation(conversationEntity, event);\n    const firstAsset = (messageEntity as ContentMessage).getFirstAsset();\n    if (firstAsset.isImage() || (firstAsset as FileAsset).status() === AssetTransferState.UPLOADED) {\n      return {conversationEntity, messageEntity};\n    }\n  }\n\n  /**\n   * A hide message received in a conversation.\n   *\n   * @param conversationEntity Conversation to add the event to\n   * @param eventJson JSON data of 'conversation.message-delete'\n   * @returns Resolves when the event was handled\n   */\n  private onMessageDeleted(conversationEntity: Conversation, eventJson: DeleteEvent) {\n    const {data: eventData, from, id: eventId, time} = eventJson;\n\n    return this.messageRepository\n      .getMessageInConversationById(conversationEntity, eventData.message_id)\n      .then(deletedMessageEntity => {\n        if (deletedMessageEntity.ephemeral_expires()) {\n          return;\n        }\n\n        const isSameSender = from === deletedMessageEntity.from;\n        if (!isSameSender) {\n          throw new ConversationError(ConversationError.TYPE.WRONG_USER, ConversationError.MESSAGE.WRONG_USER);\n        }\n\n        const isFromSelf = from === this.userState.self().id;\n        if (!isFromSelf) {\n          return this.addDeleteMessage(conversationEntity, eventId, time, deletedMessageEntity);\n        }\n      })\n      .then(() => {\n        return this.messageRepository.deleteMessageById(conversationEntity, eventData.message_id);\n      })\n      .catch(error => {\n        const isNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n        if (!isNotFound) {\n          this.logger.info(`Failed to delete message for conversation '${conversationEntity.id}'`, error);\n          throw error;\n        }\n      });\n  }\n\n  /**\n   * A hide message received in a conversation.\n   *\n   * @param eventJson JSON data of 'conversation.message-hidden'\n   * @returns Resolves when the event was handled\n   */\n  private async onMessageHidden(eventJson: MessageHiddenEvent) {\n    const {conversation: conversationId, data: eventData, from} = eventJson;\n\n    try {\n      const inSelfConversation =\n        !this.conversationState.self_conversation() || conversationId === this.conversationState.self_conversation().id;\n      if (!inSelfConversation) {\n        throw new ConversationError(\n          ConversationError.TYPE.WRONG_CONVERSATION,\n          ConversationError.MESSAGE.WRONG_CONVERSATION,\n        );\n      }\n\n      const isFromSelf = !this.userState.self() || from === this.userState.self().id;\n      if (!isFromSelf) {\n        throw new ConversationError(ConversationError.TYPE.WRONG_USER, ConversationError.MESSAGE.WRONG_USER);\n      }\n      const conversationEntity = await this.getConversationById({domain: '', id: eventData.conversation_id});\n      return await this.messageRepository.deleteMessageById(conversationEntity, eventData.message_id);\n    } catch (error) {\n      this.logger.info(\n        `Failed to delete message '${eventData.message_id}' for conversation '${eventData.conversation_id}'`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Someone reacted to a message.\n   *\n   * @param conversationEntity Conversation entity that a message was reacted upon in\n   * @param eventJson JSON data of 'conversation.reaction' event\n   * @returns Resolves when the event was handled\n   */\n  private async onReaction(conversationEntity: Conversation, eventJson: ReactionEvent) {\n    const conversationId = conversationEntity.id;\n    const eventData = eventJson.data;\n    const messageId = eventData.message_id;\n\n    try {\n      const messageEntity = await this.messageRepository.getMessageInConversationById(conversationEntity, messageId);\n      if (!messageEntity || !messageEntity.isContent()) {\n        const type = messageEntity ? messageEntity.type : 'unknown';\n\n        const logMessage = `Cannot react to '${type}' message '${messageId}' in conversation '${conversationId}'`;\n        this.logger.error(logMessage, messageEntity);\n        throw new ConversationError(ConversationError.TYPE.WRONG_TYPE, ConversationError.MESSAGE.WRONG_TYPE);\n      }\n\n      const changes = messageEntity.getUpdatedReactions(eventJson);\n      if (changes) {\n        const logMessage = `Updating reactions of message '${messageId}' in conversation '${conversationId}'`;\n        this.logger.debug(logMessage, {changes, event: eventJson});\n\n        this.eventService.updateEventSequentially(messageEntity.primary_key, changes);\n        return await this.prepareReactionNotification(conversationEntity, messageEntity, eventJson);\n      }\n    } catch (error) {\n      const isNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n      if (!isNotFound) {\n        const logMessage = `Failed to handle reaction to message '${messageId}' in conversation '${conversationId}'`;\n        this.logger.error(logMessage, {error, event: eventJson});\n        throw error;\n      }\n    }\n    return undefined;\n  }\n\n  private async onButtonActionConfirmation(conversationEntity: Conversation, eventJson: ButtonActionConfirmationEvent) {\n    const {messageId, buttonId} = eventJson.data;\n    try {\n      const messageEntity = await this.messageRepository.getMessageInConversationById(conversationEntity, messageId);\n      if (!messageEntity || !messageEntity.isComposite()) {\n        const type = messageEntity ? messageEntity.type : 'unknown';\n\n        const log = `Cannot react to '${type}' message '${messageId}' in conversation '${conversationEntity.id}'`;\n        this.logger.error(log, messageEntity);\n        throw new ConversationError(ConversationError.TYPE.WRONG_TYPE, ConversationError.MESSAGE.WRONG_TYPE);\n      }\n      const changes = messageEntity.getSelectionChange(buttonId);\n      if (changes) {\n        this.eventService.updateEventSequentially(messageEntity.primary_key, changes);\n      }\n      return;\n    } catch (error) {\n      const isNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n      if (!isNotFound) {\n        const log = `Failed to handle reaction to message '${messageId}' in conversation '${conversationEntity.id}'`;\n        this.logger.error(log, {error, event: eventJson});\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * A conversation was renamed.\n   *\n   * @param conversationEntity Conversation entity that will be renamed\n   * @param eventJson JSON data of 'conversation.rename' event\n   * @returns Resolves when the event was handled\n   */\n  private async onRename(conversationEntity: Conversation, eventJson: ConversationRenameEvent, isWebSocket = false) {\n    if (isWebSocket && eventJson.data?.name) {\n      eventJson.data.name = fixWebsocketString(eventJson.data.name);\n    }\n    const {messageEntity} = await this.addEventToConversation(conversationEntity, eventJson);\n    ConversationMapper.updateProperties(conversationEntity, eventJson.data);\n    return {conversationEntity, messageEntity};\n  }\n\n  /**\n   * A conversation receipt mode was changed\n   *\n   * @param conversationEntity Conversation entity that will be renamed\n   * @param eventJson JSON data of 'conversation.receipt-mode-update' event\n   * @returns Resolves when the event was handled\n   */\n  private async onReceiptModeChanged(conversationEntity: Conversation, eventJson: ConversationReceiptModeUpdateEvent) {\n    const {messageEntity} = await this.addEventToConversation(conversationEntity, eventJson);\n    ConversationMapper.updateSelfStatus(conversationEntity, {receipt_mode: eventJson.data.receipt_mode});\n    return {conversationEntity, messageEntity};\n  }\n\n  private readonly handleMessageExpiration = (messageEntity: ContentMessage) => {\n    amplify.publish(WebAppEvents.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, messageEntity);\n    const shouldDeleteMessage = !messageEntity.user().isMe || messageEntity.isPing();\n    if (shouldDeleteMessage) {\n      // TODO(federation) map domain\n      this.getConversationById({domain: '', id: messageEntity.conversation_id}).then(conversationEntity => {\n        const isPingFromSelf = messageEntity.user().isMe && messageEntity.isPing();\n        const deleteForSelf = isPingFromSelf || conversationEntity.removed_from_conversation();\n        if (deleteForSelf) {\n          return this.messageRepository.deleteMessage(conversationEntity, messageEntity);\n        }\n\n        const userIds = conversationEntity.isGroup() ? [this.userState.self().id, messageEntity.from] : undefined;\n        return this.messageRepository.deleteMessageForEveryone(conversationEntity, messageEntity, userIds);\n      });\n    }\n  };\n\n  private async initMessageEntity(conversationEntity: Conversation, eventJson: IncomingEvent): Promise<Message> {\n    const messageEntity = await this.event_mapper.mapJsonEvent(eventJson, conversationEntity);\n    return this.updateMessageUserEntities(messageEntity);\n  }\n\n  private async replaceMessageInConversation(\n    conversationEntity: Conversation,\n    eventId: string,\n    newData: EventRecord,\n  ): Promise<ContentMessage | undefined> {\n    const originalMessage = conversationEntity.getMessage(eventId);\n    if (!originalMessage) {\n      return undefined;\n    }\n    const replacedMessageEntity = await this.event_mapper.updateMessageEvent(\n      originalMessage as ContentMessage,\n      newData,\n    );\n    await this.ephemeralHandler.validateMessage(replacedMessageEntity);\n    return replacedMessageEntity;\n  }\n\n  /**\n   * Convert a JSON event into an entity and add it to a given conversation.\n   *\n   * @param conversationEntity Conversation entity the event will be added to\n   * @param eventJson Event data\n   * @returns Promise that resolves with the message entity for the event\n   */\n  private async addEventToConversation(\n    conversationEntity: Conversation,\n    eventJson: IncomingEvent,\n  ): Promise<{conversationEntity: Conversation; messageEntity: Message}> {\n    const messageEntity = (await this.initMessageEntity(conversationEntity, eventJson)) as Message;\n    if (conversationEntity && messageEntity) {\n      const wasAdded = conversationEntity.addMessage(messageEntity);\n      if (wasAdded) {\n        await this.ephemeralHandler.validateMessage(messageEntity as ContentMessage);\n      }\n    }\n    return {conversationEntity, messageEntity};\n  }\n\n  /**\n   * Convert multiple JSON events into entities and add them to a given conversation.\n   *\n   * @param events Event data\n   * @param conversationEntity Conversation entity the events will be added to\n   * @param prepend Should existing messages be prepended\n   * @returns Resolves with an array of mapped messages\n   */\n  private async addEventsToConversation(events: EventRecord[], conversationEntity: Conversation, prepend = true) {\n    const mappedEvents = await this.event_mapper.mapJsonEvents(events, conversationEntity);\n    const updatedEvents = (await this.updateMessagesUserEntities(mappedEvents)) as ContentMessage[];\n    const validatedMessages = (await this.ephemeralHandler.validateMessages(updatedEvents)) as ContentMessage[];\n    if (prepend && conversationEntity.messages().length) {\n      conversationEntity.prependMessages(validatedMessages);\n    } else {\n      conversationEntity.addMessages(validatedMessages);\n    }\n    return validatedMessages;\n  }\n\n  /**\n   * Fetch all unread events and users of a conversation.\n   *\n   * @param conversationEntity Conversation fetch events and users for\n   */\n  private fetchUsersAndEvents(conversationEntity: Conversation) {\n    if (!conversationEntity.is_loaded() && !conversationEntity.is_pending()) {\n      this.updateParticipatingUserEntities(conversationEntity);\n      this.getUnreadEvents(conversationEntity);\n    }\n  }\n\n  /**\n   * Forward the reaction event to the Notification repository for browser and audio notifications.\n   *\n   * @param conversationEntity Conversation that event was received in\n   * @param messageEntity Message that has been reacted upon\n   * @param eventJson JSON data of received reaction event\n   * @returns Resolves when the notification was prepared\n   */\n  private async prepareReactionNotification(\n    conversationEntity: Conversation,\n    messageEntity: ContentMessage,\n    eventJson: ReactionEvent,\n  ) {\n    const {data: event_data, from} = eventJson;\n\n    const messageFromSelf = messageEntity.from === this.userState.self().id;\n    if (messageFromSelf && event_data.reaction) {\n      const userEntity = await this.userRepository.getUserById({domain: messageEntity.fromDomain, id: from});\n      const reactionMessageEntity = new Message(messageEntity.id, SuperType.REACTION);\n      reactionMessageEntity.user(userEntity);\n      reactionMessageEntity.reaction = event_data.reaction;\n      return {conversationEntity, messageEntity: reactionMessageEntity};\n    }\n\n    return {conversationEntity};\n  }\n\n  private updateMessagesUserEntities(messageEntities: Message[]) {\n    return Promise.all(messageEntities.map(messageEntity => this.updateMessageUserEntities(messageEntity)));\n  }\n\n  /**\n   * Updates the user entities that are part of a message.\n   *\n   * @param messageEntity Message to be updated\n   * @returns Resolves when users have been update\n   */\n  private async updateMessageUserEntities(messageEntity: Message) {\n    const userEntity = await this.userRepository.getUserById({\n      domain: messageEntity.fromDomain,\n      id: messageEntity.from,\n    });\n    messageEntity.user(userEntity);\n    const isMemberMessage = messageEntity.isMember();\n    if (isMemberMessage || messageEntity.hasOwnProperty('userEntities')) {\n      return this.userRepository.getUsersById((messageEntity as MemberMessage).userIds()).then(userEntities => {\n        userEntities.sort(sortUsersByPriority);\n        (messageEntity as MemberMessage).userEntities(userEntities);\n        return messageEntity;\n      });\n    }\n    if (messageEntity.isContent()) {\n      const userIds = Object.keys(messageEntity.reactions());\n\n      messageEntity.reactions_user_ets.removeAll();\n      if (userIds.length) {\n        // TODO(Federation): Make code federation-aware.\n        return this.userRepository\n          .getUsersById(userIds.map(userId => ({domain: '', id: userId})))\n          .then(userEntities => {\n            messageEntity.reactions_user_ets(userEntities);\n            return messageEntity;\n          });\n      }\n    }\n    return messageEntity;\n  }\n\n  /**\n   * Delete messages from UI and database.\n   *\n   * @param conversationEntity Conversation that contains the message\n   * @param timestamp Timestamp as upper bound which messages to remove\n   */\n  private deleteMessages(conversationEntity: Conversation, timestamp: number) {\n    conversationEntity.hasCreationMessage = false;\n\n    const iso_date = timestamp ? new Date(timestamp).toISOString() : undefined;\n    this.eventService.deleteEvents(conversationEntity.id, iso_date);\n  }\n\n  /**\n   * Add delete message to conversation.\n   *\n   * @param conversationId ID of conversation\n   * @param messageId ID of message\n   * @param time ISO 8601 formatted time string\n   * @param messageEntity Message to delete\n   */\n  public addDeleteMessage(conversation: Conversation, messageId: string, time: string, messageEntity: Message) {\n    const deleteEvent = EventBuilder.buildDelete(conversation, messageId, time, messageEntity);\n    this.eventRepository.injectEvent(deleteEvent);\n  }\n\n  //##############################################################################\n  // Message updates\n  //##############################################################################\n\n  expectReadReceipt(conversationEntity: Conversation): boolean {\n    if (conversationEntity.is1to1()) {\n      return !!this.propertyRepository.receiptMode();\n    }\n\n    if (conversationEntity.team_id && conversationEntity.isGroup()) {\n      return !!conversationEntity.receiptMode();\n    }\n\n    return false;\n  }\n}\n", "/*\n * Wire\n * Copyright (C) 2018 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport type {\n  CONVERSATION_ACCESS,\n  CONVERSATION_ACCESS_ROLE,\n  ClientMismatch,\n  Conversation as BackendConversation,\n  ConversationCode,\n  NewConversation,\n  NewOTRMessage,\n} from '@wireapp/api-client/src/conversation';\nimport type {\n  ConversationMemberUpdateData,\n  ConversationOtherMemberUpdateData,\n  ConversationReceiptModeUpdateData,\n  ConversationJoinData,\n} from '@wireapp/api-client/src/conversation/data';\nimport type {\n  ConversationCodeDeleteEvent,\n  ConversationCodeUpdateEvent,\n  ConversationEvent,\n  ConversationMemberJoinEvent,\n  ConversationMemberLeaveEvent,\n  ConversationMessageTimerUpdateEvent,\n  ConversationReceiptModeUpdateEvent,\n  ConversationRenameEvent,\n} from '@wireapp/api-client/src/event';\nimport {container} from 'tsyringe';\n\nimport {Logger, getLogger} from 'Util/Logger';\n\nimport type {Conversation as ConversationEntity} from '../entity/Conversation';\nimport type {EventService} from '../event/EventService';\nimport {MessageCategory} from '../message/MessageCategory';\nimport {search as fullTextSearch} from '../search/FullTextSearch';\nimport {StorageService} from '../storage';\nimport {StorageSchemata} from '../storage/StorageSchemata';\nimport {APIClient} from '../service/APIClientSingleton';\nimport {ConversationRecord} from '../storage/record/ConversationRecord';\nimport {Config} from '../Config';\nimport {QualifiedId} from '@wireapp/api-client/src/user';\n\nfunction isFederatedEnv() {\n  return Config.getConfig().FEATURE.ENABLE_FEDERATION;\n}\nexport class ConversationService {\n  private readonly eventService: EventService;\n  private readonly logger: Logger;\n\n  constructor(\n    eventService: EventService,\n    private readonly storageService = container.resolve(StorageService),\n    private readonly apiClient = container.resolve(APIClient),\n  ) {\n    this.eventService = eventService;\n    this.logger = getLogger('ConversationService');\n  }\n\n  //##############################################################################\n  // Create conversations\n  //##############################################################################\n\n  /**\n   * Create a group conversation.\n   *\n   * @note Do not include yourself as the requestor\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createGroupConversation\n   *\n   * @param payload Payload object for group creation\n   * @returns Resolves when the conversation was created\n   */\n  postConversations(payload: NewConversation): Promise<BackendConversation> {\n    return this.apiClient.conversation.api.postConversation(payload);\n  }\n\n  //##############################################################################\n  // Get conversations\n  //##############################################################################\n\n  /**\n   * Retrieves all the conversations of a user.\n   * @returns Resolves with the conversation information\n   */\n  async getAllConversations(): Promise<BackendConversation[]> {\n    const conversationApi = this.apiClient.conversation.api;\n    return isFederatedEnv() ? conversationApi.getConversationList() : conversationApi.getAllConversations();\n  }\n\n  /**\n   * Get a conversation by ID.\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/conversation\n   */\n  getConversationById({id, domain}: QualifiedId): Promise<BackendConversation> {\n    return isFederatedEnv()\n      ? this.apiClient.conversation.api.getConversation({domain, id}, true)\n      : this.apiClient.conversation.api.getConversation(id);\n  }\n\n  /**\n   * Update the conversation name.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversation\n   *\n   * @param conversationId ID of conversation to rename\n   * @param name new name of the conversation\n   * @returns Resolves with the server response\n   */\n  updateConversationName(conversationId: string, name: string): Promise<ConversationRenameEvent> {\n    return this.apiClient.conversation.api.putConversation(conversationId, {\n      name,\n    });\n  }\n\n  /**\n   * Update the conversation message timer value.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationMessageTimer\n   *\n   * @param conversationId ID of conversation to rename\n   * @param messageTimer new message timer of the conversation\n   * @returns Resolves with the server response\n   */\n  updateConversationMessageTimer(\n    conversationId: string,\n    message_timer: number,\n  ): Promise<ConversationMessageTimerUpdateEvent> {\n    return this.apiClient.conversation.api.putConversationMessageTimer(conversationId, {message_timer});\n  }\n\n  /**\n   * Update the conversation message timer value.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationMessageTimer\n   *\n   * @param conversationId ID of conversation to rename\n   * @param receiptMode new receipt mode\n   * @returns Resolves with the server response\n   */\n  updateConversationReceiptMode(\n    conversationId: string,\n    receiptMode: ConversationReceiptModeUpdateData,\n  ): Promise<ConversationReceiptModeUpdateEvent> {\n    return this.apiClient.conversation.api.putConversationReceiptMode(conversationId, receiptMode);\n  }\n\n  /**\n   * Update self membership properties.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateSelf\n   *\n   * @param conversation_id ID of conversation to update\n   * @param payload Updated properties\n   * @returns Resolves with the server response\n   */\n  updateMemberProperties(conversationId: string, payload: Partial<ConversationMemberUpdateData>): Promise<void> {\n    return this.apiClient.conversation.api.putMembershipProperties(conversationId, payload);\n  }\n\n  //##############################################################################\n  // Conversation access\n  //##############################################################################\n\n  /**\n   * Delete the conversation access code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/deleteConversationCode\n   * @param conversationId ID of conversation to delete access code for\n   * @returns Resolves with the server response\n   */\n  deleteConversationCode(conversationId: string): Promise<ConversationCodeDeleteEvent> {\n    return this.apiClient.conversation.api.deleteConversationCode(conversationId);\n  }\n\n  /**\n   * Get the conversation access code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/getConversationCode\n   * @param conversationId ID of conversation to get access code for\n   * @returns Resolves with the server response\n   */\n  getConversationCode(conversationId: string): Promise<ConversationCode> {\n    return this.apiClient.conversation.api.getConversationCode(conversationId);\n  }\n\n  /**\n   * Request a conversation access code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createConversationCode\n   * @param conversationId ID of conversation to request access code for\n   * @returns Resolves with the server response\n   */\n  postConversationCode(conversationId: string): Promise<ConversationCodeUpdateEvent> {\n    return this.apiClient.conversation.api.postConversationCodeRequest(conversationId);\n  }\n\n  /**\n   * Join a conversation using a code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/joinConversationByCode\n   * @param key Conversation identifier\n   * @param code Conversation access code\n   * @returns Resolves with the server response\n   */\n  postConversationJoin(key: string, code: string): Promise<ConversationMemberJoinEvent> {\n    return this.apiClient.conversation.api.postJoinByCode({code, key});\n  }\n\n  /**\n   * Join a conversation using a code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/joinConversationByCode\n   * @param key Conversation identifier\n   * @param code Conversation access code\n   * @returns Resolves with the server response\n   */\n  getConversationJoin(key: string, code: string): Promise<ConversationJoinData> {\n    return this.apiClient.conversation.api.getJoinByCode({code, key});\n  }\n\n  /**\n   * Update conversation access mode.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationAccess\n   *\n   * @param conversationId ID of conversation\n   * @param accessModes Conversation access mode\n   * @param accessRole Conversation access role\n   * @returns Resolves with the server response\n   */\n  putConversationAccess(\n    conversationId: string,\n    accessModes: CONVERSATION_ACCESS[],\n    accessRole: CONVERSATION_ACCESS_ROLE,\n  ): Promise<ConversationEvent> {\n    return this.apiClient.conversation.api.putAccess(conversationId, {\n      access: accessModes,\n      access_role: accessRole,\n    });\n  }\n\n  //##############################################################################\n  // Send events\n  //##############################################################################\n\n  /**\n   * Remove service from conversation.\n   *\n   * @param conversationId ID of conversation to remove service from\n   * @param userId ID of service to be removed from the the conversation\n   * @returns Resolves with the server response\n   */\n  deleteBots(conversationId: string, userId: string): Promise<void> {\n    return this.apiClient.conversation.api.deleteBot(conversationId, userId);\n  }\n\n  /**\n   * Remove member from conversation.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/removeMember\n   *\n   * @param conversationId ID of conversation to remove member from\n   * @param userId ID of member to be removed from the the conversation\n   * @returns Resolves with the server response\n   */\n  deleteMembers(conversationId: string, userId: string): Promise<ConversationMemberLeaveEvent> {\n    return this.apiClient.conversation.api.deleteMember(conversationId, userId);\n  }\n\n  /**\n   * Remove member from federated conversation.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/removeMember\n   *\n   * @param conversationId Qualified ID of conversation to remove member from\n   * @param userId Qualified ID of member to be removed from the the conversation\n   * @returns Resolves with the server response\n   */\n  deleteQualifiedMembers(conversationId: QualifiedId, userId: QualifiedId): Promise<ConversationMemberLeaveEvent> {\n    return this.apiClient.conversation.api.deleteQualifiedMember(conversationId, userId);\n  }\n\n  putMembers(conversationId: string, userId: string, data: ConversationOtherMemberUpdateData): Promise<void> {\n    return this.apiClient.conversation.api.putOtherMember(userId, conversationId, data);\n  }\n\n  deleteConversation(teamId: string, conversationId: string): Promise<void> {\n    return this.apiClient.teams.conversation.api.deleteConversation(teamId, conversationId);\n  }\n\n  /**\n   * Add a service to an existing conversation.\n   *\n   * @param conversationId ID of conversation to add users to\n   * @param providerId ID of service provider\n   * @param serviceId ID of service\n   * @returns Resolves with the server response\n   */\n  postBots(conversationId: string, providerId: string, serviceId: string): Promise<ConversationMemberJoinEvent> {\n    return this.apiClient.conversation.api.postBot(conversationId, providerId, serviceId);\n  }\n\n  /**\n   * Post an encrypted message to a conversation.\n   *\n   * @note If \"recipients\" are not specified you will receive a list of all missing OTR recipients (user-client-map).\n   * @note Options for the precondition check on missing clients are:\n   * - `false` - all clients\n   * - `Array<string>` - only clients of listed users\n   * - `true` - force sending\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/postOtrMessage\n   * @example How to send \"recipients\" payload\n   * \"recipients\": {\n   *   \"<user-id>\": {\n   *     \"<client-id>\": \"<base64-encoded-encrypted-content>\"\n   *   }\n   * }\n   *\n   * @param conversationId ID of conversation to send message in\n   * @param payload Payload to be posted\n   * @returns Promise that resolves when the message was sent\n   */\n  postEncryptedMessage(\n    conversationId: QualifiedId,\n    payload: NewOTRMessage<string>,\n    preconditionOption?: boolean | string[],\n  ): Promise<ClientMismatch> {\n    const reportMissing = Array.isArray(preconditionOption) ? preconditionOption : undefined;\n    const ignoreMissing = preconditionOption === true ? true : undefined;\n\n    if (reportMissing) {\n      payload.report_missing = reportMissing;\n    }\n\n    // TODO(federation): add domain in the postOTRMessage (?)\n    return this.apiClient.conversation.api.postOTRMessage(payload.sender, conversationId.id, payload, ignoreMissing);\n  }\n\n  /**\n   * Add users to an existing conversation.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/addMembers\n   *\n   * @param conversationId ID of conversation to add users to\n   * @param userIds IDs of users to be added to the conversation\n   * @returns Resolves with the server response\n   */\n  postMembers(\n    conversationId: string,\n    userIds: QualifiedId[],\n    useFederation: boolean,\n  ): Promise<ConversationMemberJoinEvent> {\n    return useFederation\n      ? this.apiClient.conversation.api.postMembersV2(conversationId, userIds)\n      : this.apiClient.conversation.api.postMembers(\n          conversationId,\n          userIds.map(({id}) => id),\n        );\n  }\n\n  //##############################################################################\n  // Database interactions\n  //##############################################################################\n\n  /**\n   * Deletes a conversation entity from the local database.\n   * @returns Resolves when the entity was deleted\n   */\n  async deleteConversationFromDb({id, domain}: QualifiedId): Promise<string> {\n    const key = domain ? `${id}@${domain}` : id;\n    const primaryKey = await this.storageService.delete(StorageSchemata.OBJECT_STORE.CONVERSATIONS, key);\n    return primaryKey;\n  }\n\n  loadConversation<T>(conversationId: string): Promise<T> {\n    return this.storageService.load(StorageSchemata.OBJECT_STORE.CONVERSATIONS, conversationId);\n  }\n\n  /**\n   * Get active conversations from database.\n   * @returns Resolves with active conversations\n   */\n  async getActiveConversationsFromDb(): Promise<QualifiedId[]> {\n    const min_date = new Date();\n    min_date.setDate(min_date.getDate() - 30);\n\n    let events;\n\n    if (this.storageService.db) {\n      events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where('time')\n        .aboveOrEqual(min_date.toISOString())\n        .toArray();\n    } else {\n      const records = await this.storageService.getAll<{time: number}>(StorageSchemata.OBJECT_STORE.EVENTS);\n      events = records\n        .filter(record => record.time.toString() >= min_date.toISOString())\n        .sort((a, b) => a.time - b.time);\n    }\n\n    const conversations = events.reduce((accumulated, event) => {\n      // TODO(federation): generate fully qualified ids\n      accumulated[event.conversation] = (accumulated[event.conversation] || 0) + 1;\n      return accumulated;\n    }, {});\n\n    return Object.keys(conversations)\n      .sort((id_a, id_b) => conversations[id_b] - conversations[id_a])\n      .map(id => ({domain: '', id}));\n  }\n\n  /**\n   * Loads conversation states from the local database.\n   * @returns Resolves with all the stored conversation states\n   */\n  loadConversationStatesFromDb<T>(): Promise<T[]> {\n    return this.storageService.getAll(StorageSchemata.OBJECT_STORE.CONVERSATIONS);\n  }\n\n  /**\n   * Saves a list of conversation records in the local database.\n   * @param conversations Conversation entity\n   * @returns Resolves with a list of conversation records\n   */\n  async saveConversationsInDb(conversations: ConversationRecord[]): Promise<ConversationRecord[]> {\n    if (this.storageService.db) {\n      const keys = conversations.map(conversation => conversation.id);\n      await this.storageService.db.table(StorageSchemata.OBJECT_STORE.CONVERSATIONS).bulkPut(conversations, keys);\n    } else {\n      for (const conversation of conversations) {\n        await this.storageService.save(StorageSchemata.OBJECT_STORE.CONVERSATIONS, conversation.id, conversation);\n      }\n    }\n\n    return conversations;\n  }\n\n  /**\n   * Saves a conversation entity in the local database.\n   * @param conversation_et Conversation entity\n   * @returns Resolves with the conversation entity\n   */\n  saveConversationStateInDb(conversation_et: ConversationEntity): Promise<ConversationEntity> {\n    const conversationData = conversation_et.serialize();\n\n    return this.storageService\n      .save(StorageSchemata.OBJECT_STORE.CONVERSATIONS, conversation_et.id, conversationData)\n      .then(primary_key => {\n        this.logger.info(`State of conversation '${primary_key}' was stored`, conversationData);\n        return conversation_et;\n      });\n  }\n\n  /**\n   * Search for text in given conversation.\n   *\n   * @param conversation_id ID of conversation to add users to\n   * @param query will be checked in against all text messages\n   * @returns Resolves with the matching events\n   */\n  searchInConversation(conversation_id: string, query: string): Promise<any> {\n    const category_min = MessageCategory.TEXT;\n    const category_max = MessageCategory.TEXT | MessageCategory.LINK | MessageCategory.LINK_PREVIEW;\n\n    return this.eventService.loadEventsWithCategory(conversation_id, category_min, category_max).then(events => {\n      return events.filter(({data: event_data}: any) => fullTextSearch(event_data.content, query));\n    });\n  }\n}\n", "/*\n * Wire\n * Copyright (C) 2018 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport type {Dexie} from 'dexie';\nimport {container} from 'tsyringe';\nimport {Asset as ProtobufAsset} from '@wireapp/protocol-messaging';\n\nimport {getLogger, Logger} from 'Util/Logger';\n\nimport {StatusType} from '../message/StatusType';\nimport {MessageCategory} from '../message/MessageCategory';\nimport {categoryFromEvent} from '../message/MessageCategorization';\n\nimport {AssetTransferState} from '../assets/AssetTransferState';\nimport {StorageSchemata} from '../storage/StorageSchemata';\n\nimport {BaseError, BASE_ERROR_TYPE} from '../error/BaseError';\nimport {ConversationError} from '../error/ConversationError';\nimport {StorageError} from '../error/StorageError';\nimport {StorageService, DatabaseListenerCallback, EventRecord} from '../storage';\nimport {AssetData} from '../cryptography/CryptographyMapper';\n\nexport type Includes = {includeFrom: boolean; includeTo: boolean};\ntype DexieCollection = Dexie.Collection<any, any>;\nexport type DBEvents = DexieCollection | EventRecord[];\n\nexport const eventTimeToDate = (time: string) => new Date(time) || new Date(parseInt(time, 10));\n\nexport const compareEventsByConversation = (eventA: EventRecord, eventB: EventRecord) =>\n  eventA.conversation.localeCompare(eventB.conversation);\n\nexport const compareEventsById = (eventA: EventRecord, eventB: EventRecord) => eventA.id.localeCompare(eventB.id);\nexport const compareEventsByTime = (eventA: EventRecord, eventB: EventRecord) =>\n  eventTimeToDate(eventA.time).getTime() - eventTimeToDate(eventB.time).getTime();\n\n/** Handles all databases interactions related to events */\nexport class EventService {\n  logger: Logger;\n\n  constructor(public readonly storageService = container.resolve(StorageService)) {\n    this.logger = getLogger('EventService');\n  }\n\n  async loadEvents(conversationId: string, eventIds: string[]): Promise<EventRecord[]> {\n    if (!conversationId || !eventIds) {\n      this.logger.error(`Cannot get events '${eventIds}' in conversation '${conversationId}' without IDs`);\n      throw new ConversationError(BASE_ERROR_TYPE.MISSING_PARAMETER, BaseError.MESSAGE.MISSING_PARAMETER);\n    }\n\n    try {\n      if (this.storageService.db) {\n        const events = await this.storageService.db\n          .table(StorageSchemata.OBJECT_STORE.EVENTS)\n          .where('id')\n          .anyOf(eventIds)\n          .filter(record => record.conversation === conversationId)\n          .toArray();\n        return events;\n      }\n\n      const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n      return records\n        .filter(record => record.conversation === conversationId && eventIds.includes(record.id))\n        .sort(compareEventsById);\n    } catch (error) {\n      const logMessage = `Failed to get events '${eventIds.join(',')}' for conversation '${conversationId}': ${\n        error.message\n      }`;\n      this.logger.error(logMessage, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load event from database.\n   *\n   * @param conversationId ID of conversation\n   * @param eventId ID of event to retrieve\n   */\n  async loadEvent(conversationId: string, eventId: string): Promise<EventRecord> {\n    if (!conversationId || !eventId) {\n      this.logger.error(`Cannot get event '${eventId}' in conversation '${conversationId}' without IDs`);\n      throw new ConversationError(BASE_ERROR_TYPE.MISSING_PARAMETER, BaseError.MESSAGE.MISSING_PARAMETER);\n    }\n\n    try {\n      if (this.storageService.db) {\n        const entry = await this.storageService.db\n          .table(StorageSchemata.OBJECT_STORE.EVENTS)\n          .where('id')\n          .equals(eventId)\n          .filter(record => record.conversation === conversationId)\n          .first();\n        return entry;\n      }\n\n      const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n      return records\n        .filter(record => record.id === eventId && record.conversation === conversationId)\n        .sort(compareEventsById)\n        .shift();\n    } catch (error) {\n      const logMessage = `Failed to get event '${eventId}' for conversation '${conversationId}': ${error.message}`;\n      this.logger.error(logMessage, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load all events matching a minimum category from the database.\n   *\n   * @param conversationId ID of conversation to add users to\n   * @param categoryMin Minimum message category\n   * @param categoryMax Maximum message category\n   */\n  async loadEventsWithCategory(\n    conversationId: string,\n    categoryMin: MessageCategory,\n    categoryMax = MessageCategory.LIKED,\n  ): Promise<DBEvents> {\n    if (this.storageService.db) {\n      const events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where('[conversation+category]')\n        .between([conversationId, categoryMin], [conversationId, categoryMax], true, true)\n        .sortBy('time');\n      return events;\n    }\n\n    const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n    return records\n      .filter(\n        record =>\n          record.conversation === conversationId && record.category >= categoryMin && record.category <= categoryMax,\n      )\n      .sort(compareEventsByTime);\n  }\n\n  async loadEventsReplyingToMessage(conversationId: string, quotedMessageId: string, quotedMessageTime: string) {\n    if (this.storageService.db) {\n      const events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where(['conversation', 'time'])\n        .between([conversationId, quotedMessageTime], [conversationId, new Date().toISOString()], true, true)\n        .filter(event => event.data && event.data.quote && event.data.quote.message_id === quotedMessageId)\n        .toArray();\n      return events;\n    }\n\n    const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n    return records\n      .filter(record => {\n        return (\n          record.conversation === conversationId &&\n          record.time >= quotedMessageTime &&\n          record.time <= new Date().toISOString()\n        );\n      })\n      .filter(event => !!event.data && !!event.data.quote && event.data.quote.message_id === quotedMessageId)\n      .sort(compareEventsByConversation);\n  }\n\n  /**\n   * Load events starting from the fromDate going back in history until either limit or toDate is reached.\n   *\n   * @param conversationId ID of conversation\n   * @param fromDate Load from this date (included)\n   * @param toDate Load until this date (excluded)\n   * @param limit Amount of events to load\n   */\n  async loadPrecedingEvents(\n    conversationId: string,\n    fromDate = new Date(0),\n    toDate = new Date(),\n    limit = Number.MAX_SAFE_INTEGER,\n  ): Promise<DBEvents> {\n    const includeParams = {\n      includeFrom: true,\n      includeTo: false,\n    };\n\n    try {\n      const events = await this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams);\n      return this.storageService.db\n        ? await (events as Dexie.Collection<any, any>).reverse().sortBy('time')\n        : (events as EventRecord[]).reverse().sort(compareEventsByTime);\n    } catch (error) {\n      const message = `Failed to load events for conversation '${conversationId}' from database: '${error.message}'`;\n      this.logger.error(message);\n      throw error;\n    }\n  }\n\n  /**\n   * Load events starting from the fromDate to the present until the limit is reached.\n   *\n   * @param conversationId ID of conversation\n   * @param fromDate Load until this date (excluded)\n   * @param limit Amount of events to load\n   * @param includeFrom Should upper bound be part of the messages\n   */\n  async loadFollowingEvents(\n    conversationId: string,\n    fromDate: Date,\n    limit = Number.MAX_SAFE_INTEGER,\n    includeFrom = true,\n  ): Promise<DBEvents> {\n    const includeParams = {\n      includeFrom,\n      includeTo: true,\n    };\n    if (!(fromDate instanceof Date)) {\n      const errorMessage = `fromDate ('${typeof fromDate}') must be of type 'Date'.`;\n      throw new Error(errorMessage);\n    }\n    const toDate = new Date(Math.max(fromDate.getTime() + 1, Date.now()));\n\n    const events = await this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams);\n    return this.storageService.db\n      ? (events as DexieCollection).sortBy('time')\n      : (events as EventRecord[]).sort(compareEventsByTime);\n  }\n\n  /**\n   *\n   * @param conversationId The conversation ID\n   * @param fromDate The lower date bound\n   * @param toDate The upper date bound\n   * @param limit The events limit\n   * @param includes If from and to should be included\n   */\n  async _loadEventsInDateRange(\n    conversationId: string,\n    fromDate: Date,\n    toDate: Date,\n    limit: number,\n    includes: Includes,\n  ): Promise<DBEvents> {\n    const {includeFrom, includeTo} = includes;\n    if (!(toDate instanceof Date) || !(fromDate instanceof Date)) {\n      const errorMessage = `Lower bound (${typeof toDate}) and upper bound (${typeof fromDate}) must be of type 'Date'.`;\n      throw new Error(errorMessage);\n    }\n\n    if (fromDate.getTime() > toDate.getTime()) {\n      const errorMessage = `Lower bound (${fromDate.getTime()}) cannot be greater than upper bound (${toDate.getTime()}).`;\n      throw new Error(errorMessage);\n    }\n\n    if (this.storageService.db) {\n      const events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where('[conversation+time]')\n        .between(\n          [conversationId, fromDate.toISOString()],\n          [conversationId, toDate.toISOString()],\n          includeFrom,\n          includeTo,\n        )\n        .limit(limit);\n      return events;\n    }\n\n    const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n    return records\n      .filter(record => {\n        const recordDate = eventTimeToDate(record.time).getTime();\n        return (\n          record.conversation === conversationId &&\n          (includeFrom ? recordDate >= fromDate.getTime() : recordDate > fromDate.getTime()) &&\n          (includeTo ? recordDate <= toDate.getTime() : recordDate < toDate.getTime())\n        );\n      })\n      .sort(compareEventsByConversation)\n      .slice(0, limit);\n  }\n\n  /**\n   * Save an unencrypted conversation event.\n   * Will also recompute the category of the event to be stored.\n   *\n   * @param event JSON event to be stored\n   */\n  async saveEvent(event: EventRecord): Promise<EventRecord> {\n    event.category = categoryFromEvent(event);\n    event.primary_key = await this.storageService.save(StorageSchemata.OBJECT_STORE.EVENTS, undefined, event);\n    if (this.storageService.isTemporaryAndNonPersistent) {\n      /**\n       * Dexie supports auto-incrementing primary keys and saves those keys to a predefined column.\n       * The SQLeetEngine also supports auto-incrementing primary keys but it does not save them to a predefined column, so we have to do that manually:\n       */\n      await this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, event.primary_key, {\n        primary_key: event.primary_key,\n      });\n    }\n    return event;\n  }\n\n  async replaceEvent<T extends Partial<EventRecord>>(event: T): Promise<T> {\n    await this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, event.primary_key, event);\n    return event;\n  }\n\n  addEventUpdatedListener(callback: DatabaseListenerCallback): void {\n    this.storageService.addUpdatedListener(StorageSchemata.OBJECT_STORE.EVENTS, callback);\n  }\n\n  addEventDeletedListener(callback: DatabaseListenerCallback): void {\n    this.storageService.addDeletedListener(StorageSchemata.OBJECT_STORE.EVENTS, callback);\n  }\n\n  /**\n   * Update event as uploaded in database.\n   *\n   * @param primaryKey Primary key used to find an event in the database\n   * @param event Updated event asset data\n   */\n  async updateEventAsUploadSucceeded(primaryKey: string, event: EventRecord): Promise<void> {\n    const record = await this.storageService.load<EventRecord>(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey);\n    if (!record) {\n      this.logger.warn('Did not find message to update asset (uploaded)', primaryKey);\n      return;\n    }\n    const assetData = event.data;\n    record.data.id = assetData.id;\n    record.data.key = assetData.key;\n    record.data.otr_key = assetData.otr_key;\n    record.data.sha256 = assetData.sha256;\n    record.data.status = AssetTransferState.UPLOADED;\n    record.data.token = assetData.token;\n    record.status = StatusType.SENT;\n    await this.replaceEvent(record);\n    this.logger.info('Updated asset message_et (uploaded)', primaryKey);\n  }\n\n  /**\n   * Update event as upload failed in database.\n   *\n   * @param primaryKey Primary key used to find an event in the database\n   * @param reason Failure reason\n   */\n  async updateEventAsUploadFailed(\n    primaryKey: string,\n    reason: ProtobufAsset.NotUploaded | AssetTransferState,\n  ): Promise<EventRecord | void> {\n    const record = await this.storageService.load<EventRecord<AssetData>>(\n      StorageSchemata.OBJECT_STORE.EVENTS,\n      primaryKey,\n    );\n    if (!record) {\n      this.logger.warn('Did not find message to update asset (failed)', primaryKey);\n      return;\n    }\n    record.data.reason = reason;\n    record.data.status = AssetTransferState.UPLOAD_FAILED;\n    await this.replaceEvent(record);\n    this.logger.info('Updated asset message_et (failed)', primaryKey);\n    return record;\n  }\n\n  /**\n   * Update an unencrypted event.\n   * A valid update must not contain a 'version' property.\n   *\n   * @param primaryKey event's primary key\n   * @param updates Updates to perform on the message.\n   */\n  async updateEvent<T extends Partial<EventRecord>>(\n    primaryKey: string,\n    updates: T,\n  ): Promise<T & {primary_key: string}> {\n    const hasNoChanges = !updates || !Object.keys(updates).length;\n    if (hasNoChanges) {\n      throw new ConversationError(ConversationError.TYPE.NO_CHANGES, ConversationError.MESSAGE.NO_CHANGES);\n    }\n    const hasVersionedUpdates = !!updates.version;\n    if (hasVersionedUpdates) {\n      const error = new ConversationError(ConversationError.TYPE.WRONG_CHANGE, ConversationError.MESSAGE.WRONG_CHANGE);\n      error.message += ' Use the `updateEventSequentially` method to perform a versioned update of an event';\n      throw error;\n    }\n    const identifiedUpdates = {...updates, primary_key: primaryKey};\n    return this.replaceEvent(identifiedUpdates);\n  }\n\n  /**\n   * Update an event in the database and checks that the update is sequential.\n   *\n   * @param primaryKey Event primary key\n   * @param changes Changes to update message with\n   */\n  async updateEventSequentially(primaryKey: string, changes: Partial<EventRecord> = {}): Promise<number> {\n    const hasVersionedChanges = !!changes.version;\n    if (!hasVersionedChanges) {\n      throw new ConversationError(ConversationError.TYPE.WRONG_CHANGE, ConversationError.MESSAGE.WRONG_CHANGE);\n    }\n\n    if (this.storageService.db) {\n      // Create a DB transaction to avoid concurrent sequential update.\n      return this.storageService.db.transaction('rw', StorageSchemata.OBJECT_STORE.EVENTS, async () => {\n        const record = await this.storageService.load<EventRecord>(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey);\n        if (!record) {\n          throw new StorageError(StorageError.TYPE.NOT_FOUND, StorageError.MESSAGE.NOT_FOUND);\n        }\n        const databaseVersion = record.version || 1;\n        const isSequentialUpdate = changes.version === databaseVersion + 1;\n        if (isSequentialUpdate) {\n          return this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey, changes);\n        }\n        const logMessage = 'Failed sequential database update';\n        const logObject = {\n          databaseVersion: databaseVersion,\n          updateVersion: changes.version,\n        };\n        this.logger.error(logMessage, logObject);\n        throw new StorageError(StorageError.TYPE.NON_SEQUENTIAL_UPDATE, StorageError.MESSAGE.NON_SEQUENTIAL_UPDATE);\n      });\n    }\n    return this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey, changes);\n  }\n\n  /**\n   * Delete an event from a conversation. Duplicates are delete as well.\n   *\n   * @param conversationId ID of conversation to remove message from\n   * @param eventId ID of the actual message\n   */\n  async deleteEvent(conversationId: string, eventId: string): Promise<number> {\n    return this.storageService.deleteEventInConversation(StorageSchemata.OBJECT_STORE.EVENTS, conversationId, eventId);\n  }\n\n  /**\n   * Delete an event from a conversation with the given primary.\n   *\n   * @param primaryKey ID of the actual message\n   */\n  deleteEventByKey(primaryKey: string): Promise<string> {\n    return this.storageService.delete(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey);\n  }\n\n  /**\n   * Delete all events of a conversation.\n   *\n   * @param conversationId Delete events for this conversation\n   * @param isoDate Date in ISO string format as upper bound which events should be removed\n   */\n  async deleteEvents(conversationId: string, isoDate: string): Promise<number> {\n    return this.storageService.deleteEventsByDate(StorageSchemata.OBJECT_STORE.EVENTS, conversationId, isoDate);\n  }\n}\n"], "fixing_code": ["/*\n * Wire\n * Copyright (C) 2018 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport ko from 'knockout';\nimport {amplify} from 'amplify';\nimport {Confirmation, LegalHoldStatus, Asset as ProtobufAsset} from '@wireapp/protocol-messaging';\nimport {flatten} from 'underscore';\nimport {WebAppEvents} from '@wireapp/webapp-events';\nimport {StatusCodes as HTTP_STATUS} from 'http-status-codes';\nimport {\n  CONVERSATION_EVENT,\n  ConversationMessageTimerUpdateEvent,\n  ConversationRenameEvent,\n  ConversationMemberJoinEvent,\n  ConversationCreateEvent,\n  ConversationEvent,\n  ConversationReceiptModeUpdateEvent,\n  ConversationMemberLeaveEvent,\n} from '@wireapp/api-client/src/event';\n\nimport {\n  DefaultConversationRoleName as DefaultRole,\n  CONVERSATION_ACCESS_ROLE,\n  CONVERSATION_ACCESS,\n  CONVERSATION_TYPE,\n  NewConversation,\n  Conversation as BackendConversation,\n} from '@wireapp/api-client/src/conversation/';\nimport {container} from 'tsyringe';\nimport {ConversationReceiptModeUpdateData} from '@wireapp/api-client/src/conversation/data/';\nimport {BackendErrorLabel} from '@wireapp/api-client/src/http/';\nimport type {QualifiedId} from '@wireapp/api-client/src/user/';\nimport {Logger, getLogger} from 'Util/Logger';\nimport {TIME_IN_MILLIS} from 'Util/TimeUtil';\nimport {PromiseQueue} from 'Util/PromiseQueue';\nimport {replaceLink, t} from 'Util/LocalizerUtil';\nimport {getDifference, getNextItem} from 'Util/ArrayUtil';\nimport {createRandomUuid, noop} from 'Util/util';\nimport {allowsAllFiles, getFileExtensionOrName, isAllowedFile} from 'Util/FileTypeUtil';\nimport {\n  compareTransliteration,\n  sortByPriority,\n  startsWith,\n  sortUsersByPriority,\n  fixWebsocketString,\n} from 'Util/StringUtil';\nimport {ClientEvent} from '../event/Client';\nimport {NOTIFICATION_HANDLING_STATE} from '../event/NotificationHandlingState';\nimport {EventRepository} from '../event/EventRepository';\nimport {\n  AssetAddEvent,\n  ButtonActionConfirmationEvent,\n  ClientConversationEvent,\n  DeleteEvent,\n  EventBuilder,\n  GroupCreationEvent,\n  MessageHiddenEvent,\n  OneToOneCreationEvent,\n  ReactionEvent,\n  TeamMemberLeaveEvent,\n} from '../conversation/EventBuilder';\nimport {Conversation} from '../entity/Conversation';\nimport {Message} from '../entity/message/Message';\nimport {ConversationMapper, ConversationDatabaseData} from './ConversationMapper';\nimport {ConversationStateHandler} from './ConversationStateHandler';\nimport {EventMapper} from './EventMapper';\nimport {ACCESS_STATE} from './AccessState';\nimport {ConversationStatus} from './ConversationStatus';\nimport {ConversationVerificationStateHandler} from './ConversationVerificationStateHandler';\nimport {NOTIFICATION_STATE} from './NotificationSetting';\nimport {ConversationEphemeralHandler} from './ConversationEphemeralHandler';\nimport {ConversationLabelRepository} from './ConversationLabelRepository';\nimport {AssetTransferState} from '../assets/AssetTransferState';\nimport {ModalsViewModel} from '../view_model/ModalsViewModel';\nimport {SystemMessageType} from '../message/SystemMessageType';\nimport {SuperType} from '../message/SuperType';\nimport {MessageCategory} from '../message/MessageCategory';\nimport {Config} from '../Config';\nimport {BaseError, BASE_ERROR_TYPE} from '../error/BaseError';\nimport {BackendClientError} from '../error/BackendClientError';\nimport * as LegalHoldEvaluator from '../legal-hold/LegalHoldEvaluator';\nimport {DeleteConversationMessage} from '../entity/message/DeleteConversationMessage';\nimport {ConversationRoleRepository} from './ConversationRoleRepository';\nimport {ConversationError} from '../error/ConversationError';\nimport {ConversationService} from './ConversationService';\nimport {ConnectionRepository} from '../connection/ConnectionRepository';\nimport {UserRepository} from '../user/UserRepository';\nimport {PropertiesRepository} from '../properties/PropertiesRepository';\nimport {ServerTimeHandler} from '../time/serverTimeHandler';\nimport {ContentMessage} from '../entity/message/ContentMessage';\nimport {User} from '../entity/User';\nimport {EventService} from '../event/EventService';\nimport {ConnectionEntity} from '../connection/ConnectionEntity';\nimport {EventSource} from '../event/EventSource';\nimport {MemberMessage} from '../entity/message/MemberMessage';\nimport {FileAsset} from '../entity/message/FileAsset';\nimport type {EventRecord} from '../storage';\nimport {MessageRepository} from './MessageRepository';\nimport {UserState} from '../user/UserState';\nimport {TeamState} from '../team/TeamState';\nimport {TeamRepository} from '../team/TeamRepository';\nimport {ConversationState} from './ConversationState';\nimport {ConversationRecord} from '../storage/record/ConversationRecord';\nimport {UserFilter} from '../user/UserFilter';\nimport {ConversationFilter} from './ConversationFilter';\nimport {ConversationMemberUpdateEvent} from '@wireapp/api-client/src/event';\nimport {matchQualifiedIds} from 'Util/QualifiedId';\nimport {flattenUserClientsQualifiedIds} from './userClientsUtils';\n\ntype ConversationDBChange = {obj: EventRecord; oldObj: EventRecord};\ntype FetchPromise = {rejectFn: (error: ConversationError) => void; resolveFn: (conversation: Conversation) => void};\ntype EntityObject = {conversationEntity: Conversation; messageEntity: Message};\ntype IncomingEvent = ConversationEvent | ClientConversationEvent;\n\nexport class ConversationRepository {\n  private init_handled: number;\n  private init_promise?: {rejectFn: (reason?: any) => void; resolveFn: (value?: unknown) => void};\n  private init_total: number;\n  private isBlockingNotificationHandling: boolean;\n  private readonly conversationsWithNewEvents: Map<any, any>;\n  private readonly ephemeralHandler: ConversationEphemeralHandler;\n  public readonly conversationLabelRepository: ConversationLabelRepository;\n  public readonly conversationRoleRepository: ConversationRoleRepository;\n  private readonly event_mapper: EventMapper;\n  private readonly eventService: EventService;\n  public leaveCall: (conversationId: string) => void;\n  private readonly receiving_queue: PromiseQueue;\n  private readonly logger: Logger;\n  public readonly stateHandler: ConversationStateHandler;\n  public readonly verificationStateHandler: ConversationVerificationStateHandler;\n\n  static get CONFIG() {\n    return {\n      CONFIRMATION_THRESHOLD: TIME_IN_MILLIS.WEEK,\n      EXTERNAL_MESSAGE_THRESHOLD: 200 * 1024,\n      GROUP: {\n        MAX_NAME_LENGTH: 64,\n        MAX_SIZE: Config.getConfig().MAX_GROUP_PARTICIPANTS,\n      },\n    };\n  }\n\n  static get CONSENT_TYPE() {\n    return {\n      INCOMING_CALL: 'incoming_call',\n      MESSAGE: 'message',\n      OUTGOING_CALL: 'outgoing_call',\n    };\n  }\n\n  constructor(\n    private readonly conversation_service: ConversationService,\n    private readonly messageRepository: MessageRepository,\n    private readonly connectionRepository: ConnectionRepository,\n    private readonly eventRepository: EventRepository,\n    private readonly teamRepository: TeamRepository,\n    private readonly userRepository: UserRepository,\n    private readonly propertyRepository: PropertiesRepository,\n    private readonly serverTimeHandler: ServerTimeHandler,\n    private readonly userState = container.resolve(UserState),\n    private readonly teamState = container.resolve(TeamState),\n    private readonly conversationState = container.resolve(ConversationState),\n  ) {\n    this.eventService = eventRepository.eventService;\n    // we register a client mismatch handler agains the message repository so that we can react to missing members\n    // FIXME this should be temporary. In the near future we want the core to handle clients/mismatch/verification. So the webapp won't need this logic at all\n    this.messageRepository.setClientMismatchHandler(async (mismatch, conversationId) => {\n      const deleted = flattenUserClientsQualifiedIds(mismatch.deleted);\n      const missing = flattenUserClientsQualifiedIds(mismatch.missing);\n      const conversation = conversationId ? await this.getConversationById(conversationId) : undefined;\n      if (conversation) {\n        // add/remove users from the conversation (if any)\n        const missingUserIds = missing.map(({userId}) => userId);\n        const knownUsers = conversation.participating_user_ets().map(user => user.qualifiedId);\n        const missingUsers = getDifference(knownUsers, missingUserIds, matchQualifiedIds);\n        if (missingUsers.length) {\n          await this.addMissingMember(conversation, missingUsers, new Date(mismatch.time).getTime() - 1);\n        }\n      }\n\n      deleted.forEach(({userId, clients}) => {\n        clients.forEach(client => this.userRepository.removeClientFromUser(userId, client));\n      });\n      if (missing.length) {\n        const deviceWasAdded = await this.userRepository.updateMissingUsersClients(missing.map(({userId}) => userId));\n        if (deviceWasAdded && conversation) {\n          // TODO trigger degradation warning if needed and return false if sending should be canceled\n          return true;\n        }\n      }\n      return true;\n    });\n\n    this.logger = getLogger('ConversationRepository');\n\n    this.event_mapper = new EventMapper();\n    this.verificationStateHandler = new ConversationVerificationStateHandler(\n      this.eventRepository,\n      this.serverTimeHandler,\n      this.userState,\n      this.conversationState,\n    );\n    this.isBlockingNotificationHandling = true;\n    this.conversationsWithNewEvents = new Map();\n\n    this.teamState.isTeam.subscribe(() => this.mapGuestStatusSelf());\n    this.receiving_queue = new PromiseQueue({name: 'ConversationRepository.Receiving'});\n\n    this.init_handled = 0;\n    this.init_promise = undefined;\n    this.init_total = 0;\n\n    this.initSubscriptions();\n\n    this.stateHandler = new ConversationStateHandler(this.conversation_service);\n    this.ephemeralHandler = new ConversationEphemeralHandler(this.eventService, {\n      onMessageTimeout: this.handleMessageExpiration,\n    });\n\n    this.userState.directlyConnectedUsers = this.conversationState.connectedUsers;\n\n    this.conversationLabelRepository = new ConversationLabelRepository(\n      this.conversationState.conversations,\n      this.conversationState.conversations_unarchived,\n      propertyRepository.propertiesService,\n    );\n\n    this.conversationRoleRepository = new ConversationRoleRepository(this.teamRepository, this.conversation_service);\n    this.leaveCall = noop;\n  }\n\n  checkMessageTimer(messageEntity: ContentMessage): void {\n    this.ephemeralHandler.checkMessageTimer(messageEntity, this.serverTimeHandler.getTimeOffset());\n  }\n\n  private initStateUpdates(): void {\n    ko.computed(() => {\n      const conversationsArchived: Conversation[] = [];\n      const conversationsCleared: Conversation[] = [];\n      const conversationsUnarchived: Conversation[] = [];\n\n      this.conversationState.sorted_conversations().forEach(conversationEntity => {\n        if (conversationEntity.is_cleared()) {\n          conversationsCleared.push(conversationEntity);\n        } else if (conversationEntity.is_archived()) {\n          conversationsArchived.push(conversationEntity);\n        } else {\n          conversationsUnarchived.push(conversationEntity);\n        }\n      });\n\n      this.conversationState.conversations_archived(conversationsArchived);\n      this.conversationState.conversations_cleared(conversationsCleared);\n      this.conversationState.conversations_unarchived(conversationsUnarchived);\n    });\n  }\n\n  private initSubscriptions(): void {\n    amplify.subscribe(WebAppEvents.CONVERSATION.DELETE, this.deleteConversationLocally);\n    amplify.subscribe(WebAppEvents.CONVERSATION.EVENT_FROM_BACKEND, this.onConversationEvent);\n    amplify.subscribe(WebAppEvents.CONVERSATION.MAP_CONNECTION, this.mapConnection);\n    amplify.subscribe(WebAppEvents.CONVERSATION.MISSED_EVENTS, this.onMissedEvents);\n    amplify.subscribe(WebAppEvents.CONVERSATION.PERSIST_STATE, this.saveConversationStateInDb);\n    amplify.subscribe(WebAppEvents.EVENT.NOTIFICATION_HANDLING_STATE, this.setNotificationHandlingState);\n    amplify.subscribe(WebAppEvents.TEAM.MEMBER_LEAVE, this.teamMemberLeave);\n    amplify.subscribe(WebAppEvents.USER.UNBLOCKED, this.onUnblockUser);\n    amplify.subscribe(WebAppEvents.CONVERSATION.INJECT_LEGAL_HOLD_MESSAGE, this.injectLegalHoldMessage);\n\n    this.eventService.addEventUpdatedListener(this.updateLocalMessageEntity);\n    this.eventService.addEventDeletedListener(this.deleteLocalMessageEntity);\n\n    window.addEventListener<any>(WebAppEvents.CONVERSATION.JOIN, this.onConversationJoin);\n  }\n\n  private readonly updateLocalMessageEntity = async ({\n    obj: updatedEvent,\n    oldObj: oldEvent,\n  }: ConversationDBChange): Promise<void> => {\n    const qualifiedId = updatedEvent.qualified_conversation || {domain: '', id: updatedEvent.conversation};\n    const conversationEntity = this.conversationState.findConversation(qualifiedId);\n    const replacedMessageEntity = await this.replaceMessageInConversation(\n      conversationEntity,\n      oldEvent.id,\n      updatedEvent,\n    );\n    if (replacedMessageEntity) {\n      const messageEntity = await this.updateMessageUserEntities(replacedMessageEntity);\n      amplify.publish(WebAppEvents.CONVERSATION.MESSAGE.UPDATED, oldEvent.id, messageEntity);\n    }\n  };\n\n  private readonly deleteLocalMessageEntity = ({oldObj: deletedEvent}: ConversationDBChange): void => {\n    const qualifiedId = deletedEvent.qualified_conversation || {domain: '', id: deletedEvent.conversation};\n    const conversationEntity = this.conversationState.findConversation(qualifiedId);\n    if (conversationEntity) {\n      conversationEntity.removeMessageById(deletedEvent.id);\n    }\n  };\n\n  /**\n   * Remove obsolete conversations locally.\n   */\n  cleanupConversations(): void {\n    this.conversationState.conversations().forEach(conversationEntity => {\n      if (\n        conversationEntity.isGroup() &&\n        conversationEntity.is_cleared() &&\n        conversationEntity.removed_from_conversation()\n      ) {\n        this.conversation_service.deleteConversationFromDb(conversationEntity);\n        this.deleteConversationFromRepository(conversationEntity);\n      }\n    });\n\n    this.cleanupEphemeralMessages();\n  }\n\n  //##############################################################################\n  // Conversation service interactions\n  //##############################################################################\n\n  /**\n   * Create a group conversation.\n   * @note Do not include the requester among the users\n   *\n   * @param userEntities Users (excluding the creator) to be part of the conversation\n   * @param groupName Name for the conversation\n   * @param accessState State for conversation access\n   * @param options Additional conversation creation options (like \"receipt_mode\")\n   * @returns Resolves when the conversation was created\n   */\n  public async createGroupConversation(\n    userEntities: User[],\n    groupName?: string,\n    accessState?: string,\n    options: Partial<NewConversation> = {},\n  ): Promise<Conversation | undefined> {\n    const isFederated = Config.getConfig().FEATURE.ENABLE_FEDERATION;\n    const userIds = isFederated ? userEntities.map(user => user.qualifiedId) : userEntities.map(user => user.id);\n\n    let payload: NewConversation & {conversation_role: string} = {\n      conversation_role: DefaultRole.WIRE_MEMBER,\n      name: groupName,\n      qualified_users: isFederated ? (userIds as QualifiedId[]) : undefined,\n      receipt_mode: null,\n      users: !isFederated ? (userIds as string[]) : [],\n      ...options,\n    };\n\n    if (this.teamState.team().id) {\n      payload.team = {\n        managed: false,\n        teamid: this.teamState.team().id!,\n      };\n\n      if (accessState) {\n        let accessPayload;\n\n        switch (accessState) {\n          case ACCESS_STATE.TEAM.GUEST_ROOM:\n            accessPayload = {\n              access: [CONVERSATION_ACCESS.INVITE, CONVERSATION_ACCESS.CODE],\n              access_role: CONVERSATION_ACCESS_ROLE.NON_ACTIVATED,\n            };\n            break;\n          case ACCESS_STATE.TEAM.TEAM_ONLY:\n            accessPayload = {\n              access: [CONVERSATION_ACCESS.INVITE],\n              access_role: CONVERSATION_ACCESS_ROLE.TEAM,\n            };\n            break;\n          default:\n            break;\n        }\n\n        if (accessPayload) {\n          payload = {...payload, ...accessPayload};\n        }\n      }\n    }\n\n    try {\n      const response = await this.conversation_service.postConversations(payload);\n      const {conversationEntity} = await this.onCreate({\n        conversation: response.id,\n        data: {\n          last_event: '0.0',\n          last_event_time: '1970-01-01T00:00:00.000Z',\n          receipt_mode: undefined,\n          ...response,\n        },\n        from: this.userState.self().id,\n        qualified_conversation: response.qualified_id,\n        time: new Date().toISOString(),\n        type: CONVERSATION_EVENT.CREATE,\n      });\n      return conversationEntity as Conversation;\n    } catch (error) {\n      this.handleConversationCreateError(\n        error,\n        userEntities.map(user => user.qualifiedId),\n      );\n      return undefined;\n    }\n  }\n\n  /**\n   * Create a guest room.\n   */\n  public createGuestRoom(): Promise<Conversation | undefined> {\n    const groupName = t('guestRoomConversationName');\n    return this.createGroupConversation([], groupName, ACCESS_STATE.TEAM.GUEST_ROOM);\n  }\n\n  /**\n   * Get a conversation from the backend.\n   */\n  private async fetchConversationById({id: conversationId, domain}: QualifiedId): Promise<Conversation> {\n    const qualifiedId = {domain, id: conversationId};\n    const fetching_conversations: Record<string, FetchPromise[]> = {};\n    if (fetching_conversations.hasOwnProperty(conversationId)) {\n      return new Promise((resolve, reject) => {\n        fetching_conversations[conversationId].push({rejectFn: reject, resolveFn: resolve});\n      });\n    }\n\n    fetching_conversations[conversationId] = [];\n    try {\n      const response = await this.conversation_service.getConversationById(qualifiedId);\n      const [conversationEntity] = this.mapConversations([response]);\n\n      this.logger.info(`Fetched conversation '${conversationId}' from backend`);\n      this.saveConversation(conversationEntity);\n\n      fetching_conversations[conversationId].forEach(({resolveFn}) => resolveFn(conversationEntity));\n      delete fetching_conversations[conversationId];\n\n      return conversationEntity;\n    } catch (originalError) {\n      if (originalError.code === HTTP_STATUS.NOT_FOUND) {\n        this.deleteConversationLocally(qualifiedId, false);\n      }\n      const error = new ConversationError(\n        ConversationError.TYPE.CONVERSATION_NOT_FOUND,\n        ConversationError.MESSAGE.CONVERSATION_NOT_FOUND,\n        originalError,\n      );\n      fetching_conversations[conversationId].forEach(({rejectFn}) => rejectFn(error));\n      delete fetching_conversations[conversationId];\n\n      throw error;\n    }\n  }\n\n  public async getConversations(): Promise<Conversation[]> {\n    const remoteConversationsPromise = this.conversation_service.getAllConversations().catch(error => {\n      this.logger.error(`Failed to get all conversations from backend: ${error.message}`);\n      return [];\n    });\n\n    const [localConversations, remoteConversations] = await Promise.all([\n      this.conversation_service.loadConversationStatesFromDb<ConversationDatabaseData>(),\n      remoteConversationsPromise,\n    ]);\n    let conversationsData: any[];\n    if (!remoteConversations.length) {\n      conversationsData = localConversations;\n    } else {\n      const data = ConversationMapper.mergeConversation(localConversations, remoteConversations);\n      conversationsData = (await this.conversation_service.saveConversationsInDb(data)) as any[];\n    }\n    const conversationEntities = this.mapConversations(conversationsData);\n    this.saveConversations(conversationEntities);\n    return this.conversationState.conversations();\n  }\n\n  public async updateConversationStates(conversationsDataArray: ConversationRecord[]) {\n    const handledConversationEntities: Conversation[] = [];\n    const unknownConversations: ConversationRecord[] = [];\n\n    conversationsDataArray.forEach(conversationData => {\n      const localEntity = this.conversationState\n        .conversations()\n        .find(conversation => matchQualifiedIds(conversation, conversationData));\n\n      if (localEntity) {\n        const entity = ConversationMapper.updateSelfStatus(localEntity, conversationData as any, true);\n        handledConversationEntities.push(entity);\n        return;\n      }\n\n      unknownConversations.push(conversationData);\n    });\n\n    let conversationEntities: Conversation[] = [];\n\n    if (unknownConversations.length) {\n      conversationEntities = conversationEntities.concat(this.mapConversations(unknownConversations as any[]));\n      this.saveConversations(conversationEntities);\n    }\n\n    conversationEntities = conversationEntities.concat(handledConversationEntities);\n    const handledConversationData = conversationEntities.map(conversationEntity => conversationEntity.serialize());\n    this.conversation_service.saveConversationsInDb(handledConversationData);\n    return conversationEntities;\n  }\n\n  /**\n   * Get preceding messages starting with the given message.\n   * @param conversationEntity Respective conversation\n   * @returns Resolves with the messages\n   */\n  public async getPrecedingMessages(conversationEntity: Conversation): Promise<ContentMessage[]> {\n    conversationEntity.is_pending(true);\n\n    const firstMessageEntity = conversationEntity.getFirstMessage();\n    const upperBound = firstMessageEntity\n      ? new Date(firstMessageEntity.timestamp())\n      : new Date(conversationEntity.getLatestTimestamp(this.serverTimeHandler.toServerTimestamp()) + 1);\n\n    const events = (await this.eventService.loadPrecedingEvents(\n      conversationEntity.id,\n      new Date(0),\n      upperBound,\n      Config.getConfig().MESSAGES_FETCH_LIMIT,\n    )) as EventRecord[];\n    const mappedMessageEntities = await this.addPrecedingEventsToConversation(events, conversationEntity);\n    conversationEntity.is_pending(false);\n    return mappedMessageEntities;\n  }\n\n  private async addPrecedingEventsToConversation(\n    events: EventRecord[],\n    conversationEntity: Conversation,\n  ): Promise<ContentMessage[]> {\n    const hasAdditionalMessages = events.length === Config.getConfig().MESSAGES_FETCH_LIMIT;\n\n    const mappedMessageEntities = await this.addEventsToConversation(events, conversationEntity);\n    conversationEntity.hasAdditionalMessages(hasAdditionalMessages);\n    if (!hasAdditionalMessages) {\n      const firstMessage = conversationEntity.getFirstMessage() as MemberMessage;\n      const checkCreationMessage = firstMessage?.isMember() && firstMessage.isCreation();\n      if (checkCreationMessage) {\n        const groupCreationMessageIn1to1 = conversationEntity.is1to1() && firstMessage.isGroupCreation();\n        const one2oneConnectionMessageInGroup = conversationEntity.isGroup() && firstMessage.isConnection();\n        const wrongMessageTypeForConversation = groupCreationMessageIn1to1 || one2oneConnectionMessageInGroup;\n\n        if (wrongMessageTypeForConversation) {\n          this.messageRepository.deleteMessage(conversationEntity, firstMessage);\n          conversationEntity.hasCreationMessage = false;\n        } else {\n          conversationEntity.hasCreationMessage = true;\n        }\n      }\n\n      const addCreationMessage = !conversationEntity.hasCreationMessage;\n      if (addCreationMessage) {\n        this.addCreationMessage(conversationEntity, this.userState.self().isTemporaryGuest());\n      }\n    }\n    return mappedMessageEntities;\n  }\n\n  private addCreationMessage(\n    conversationEntity: Conversation,\n    isTemporaryGuest: boolean,\n    timestamp?: number,\n    eventSource?: EventSource,\n  ): void {\n    conversationEntity.hasCreationMessage = true;\n\n    if (conversationEntity.inTeam()) {\n      const allTeamMembersParticipate = this.teamState.teamMembers().length\n        ? this.teamState\n            .teamMembers()\n            .every(\n              teamMember =>\n                !!conversationEntity.participating_user_ids().find(user => matchQualifiedIds(user, teamMember)),\n            )\n        : false;\n\n      conversationEntity.withAllTeamMembers(allTeamMembersParticipate);\n    }\n\n    const creationEvent = conversationEntity.isGroup()\n      ? EventBuilder.buildGroupCreation(conversationEntity, isTemporaryGuest, timestamp)\n      : EventBuilder.build1to1Creation(conversationEntity);\n\n    this.eventRepository.injectEvent(creationEvent, eventSource);\n  }\n\n  /**\n   * Get specified message and load number preceding and subsequent messages defined by padding.\n   *\n   * @param conversationEntity Conversation entity\n   * @param messageEntity Message entity\n   * @param padding Number of messages to load around the targeted message\n   * @returns Resolves with the messages\n   */\n  public async getMessagesWithOffset(\n    conversationEntity: Conversation,\n    messageEntity: Message,\n    padding = 30,\n  ): Promise<ContentMessage[]> {\n    const messageDate = new Date(messageEntity.timestamp());\n    const conversationId = conversationEntity.id;\n\n    conversationEntity.is_pending(true);\n\n    const precedingMessages = (await this.eventService.loadPrecedingEvents(\n      conversationId,\n      new Date(0),\n      messageDate,\n      Math.floor(padding / 2),\n    )) as EventRecord[];\n    const followingMessages = (await this.eventService.loadFollowingEvents(\n      conversationEntity.id,\n      messageDate,\n      padding - precedingMessages.length,\n    )) as EventRecord[];\n    const messages = precedingMessages.concat(followingMessages);\n    const mappedMessageEntities = await this.addEventsToConversation(messages, conversationEntity);\n    conversationEntity.is_pending(false);\n    return mappedMessageEntities;\n  }\n\n  /**\n   * Get subsequent messages starting with the given message.\n   * @returns Resolves with the messages\n   */\n  async getSubsequentMessages(conversationEntity: Conversation, messageEntity: ContentMessage) {\n    const messageDate = new Date(messageEntity.timestamp());\n    conversationEntity.is_pending(true);\n\n    const events = (await this.eventService.loadFollowingEvents(\n      conversationEntity.id,\n      messageDate,\n      Config.getConfig().MESSAGES_FETCH_LIMIT,\n    )) as EventRecord[];\n    const mappedMessageEntities = await this.addEventsToConversation(events, conversationEntity, false);\n    conversationEntity.is_pending(false);\n    return mappedMessageEntities;\n  }\n\n  /**\n   * Get messages for given category. Category param acts as lower bound.\n   */\n  async getEventsForCategory(conversationEntity: Conversation, category = MessageCategory.NONE): Promise<Message[]> {\n    const events = (await this.eventService.loadEventsWithCategory(conversationEntity.id, category)) as EventRecord[];\n    const messageEntities = (await this.event_mapper.mapJsonEvents(events, conversationEntity)) as Message[];\n    return this.updateMessagesUserEntities(messageEntities);\n  }\n\n  /**\n   * Search for given text in conversation.\n   */\n  public async searchInConversation(\n    conversationEntity: Conversation,\n    query: string,\n  ): Promise<{messageEntities?: Message[]; query?: string}> {\n    if (!conversationEntity || !query.length) {\n      return {};\n    }\n\n    const events = await this.conversation_service.searchInConversation(conversationEntity.id, query);\n    const mappedMessages = await this.event_mapper.mapJsonEvents(events, conversationEntity);\n    const messageEntities = await this.updateMessagesUserEntities(mappedMessages);\n    return {messageEntities, query};\n  }\n\n  /**\n   * Get conversation unread events.\n   *\n   * @param conversationEntity Conversation to start from\n   */\n  private async getUnreadEvents(conversationEntity: Conversation): Promise<void> {\n    const first_message = conversationEntity.getFirstMessage();\n    const lower_bound = new Date(conversationEntity.last_read_timestamp());\n    const upper_bound = first_message\n      ? new Date(first_message.timestamp())\n      : new Date(conversationEntity.getLatestTimestamp(this.serverTimeHandler.toServerTimestamp()) + 1);\n\n    if (lower_bound < upper_bound) {\n      conversationEntity.is_pending(true);\n\n      try {\n        const events = (await this.eventService.loadPrecedingEvents(\n          conversationEntity.id,\n          lower_bound,\n          upper_bound,\n        )) as EventRecord[];\n        if (events.length) {\n          this.addEventsToConversation(events, conversationEntity);\n        }\n      } catch (error) {\n        this.logger.info(`Could not load unread events for conversation: ${conversationEntity.id}`, error);\n      }\n      conversationEntity.is_pending(false);\n    }\n  }\n\n  /**\n   * Update conversation with a user you just unblocked\n   */\n  private readonly onUnblockUser = async (user_et: User): Promise<void> => {\n    const conversationEntity = await this.get1To1Conversation(user_et);\n    if (typeof conversationEntity !== 'boolean') {\n      conversationEntity.status(ConversationStatus.CURRENT_MEMBER);\n    }\n  };\n\n  /**\n   * Update all conversations on app init.\n   */\n  public async updateConversationsOnAppInit() {\n    this.logger.info('Updating group participants');\n    await this.updateUnarchivedConversations();\n    const updatePromises = this.conversationState.sorted_conversations().map(conversationEntity => {\n      return this.updateParticipatingUserEntities(conversationEntity, true);\n    });\n    return Promise.all(updatePromises);\n  }\n\n  /**\n   * Update users and events for archived conversations currently visible.\n   */\n  public updateArchivedConversations() {\n    this.updateConversations(this.conversationState.conversations_archived());\n  }\n\n  /**\n   * Update users and events for all unarchived conversations.\n   */\n  private updateUnarchivedConversations() {\n    return this.updateConversations(this.conversationState.conversations_unarchived());\n  }\n\n  private async updateConversationFromBackend(conversationEntity: Conversation) {\n    const conversationData = await this.conversation_service.getConversationById(conversationEntity);\n    const {name, message_timer, type} = conversationData;\n    ConversationMapper.updateProperties(conversationEntity, {name, type});\n    ConversationMapper.updateSelfStatus(conversationEntity, {message_timer});\n  }\n\n  /**\n   * Get users and events for conversations.\n   *\n   * @note To reduce the number of backend calls we merge the user IDs of all conversations first.\n   * @param conversationEntities Array of conversation entities to be updated\n   */\n  public async updateConversations(conversationEntities: Conversation[]): Promise<void> {\n    const mapOfUserIds = conversationEntities.map(conversationEntity => conversationEntity.participating_user_ids());\n    const userIds = flatten(mapOfUserIds);\n    await this.userRepository.getUsersById(userIds);\n    conversationEntities.forEach(conversationEntity => this.fetchUsersAndEvents(conversationEntity));\n  }\n\n  //##############################################################################\n  // Repository interactions\n  //##############################################################################\n\n  /**\n   * Deletes a conversation from the repository.\n   */\n  private deleteConversationFromRepository(conversationId: QualifiedId) {\n    this.conversationState.conversations.remove(conversation => {\n      return matchQualifiedIds(conversation, conversationId);\n    });\n  }\n\n  public deleteConversation(conversationEntity: Conversation) {\n    this.conversation_service\n      .deleteConversation(this.teamState.team().id, conversationEntity.id)\n      .then(() => {\n        this.deleteConversationLocally(conversationEntity, true);\n      })\n      .catch(() => {\n        amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.ACKNOWLEDGE, {\n          text: {\n            message: t('modalConversationDeleteErrorMessage', conversationEntity.name()),\n            title: t('modalConversationDeleteErrorHeadline'),\n          },\n        });\n      });\n  }\n\n  private readonly deleteConversationLocally = (conversationId: QualifiedId, skipNotification: boolean) => {\n    const conversationEntity = this.conversationState.findConversation(conversationId);\n    if (!conversationEntity) {\n      return;\n    }\n    if (this.conversationState.isActiveConversation(conversationEntity)) {\n      const nextConversation = this.getNextConversation(conversationEntity);\n      amplify.publish(WebAppEvents.CONVERSATION.SHOW, nextConversation, {});\n    }\n    if (!skipNotification) {\n      const deletionMessage = new DeleteConversationMessage(conversationEntity);\n      amplify.publish(WebAppEvents.NOTIFICATION.NOTIFY, deletionMessage);\n    }\n    if (this.conversationLabelRepository.getConversationCustomLabel(conversationEntity, true)) {\n      this.conversationLabelRepository.removeConversationFromAllLabels(conversationEntity, true);\n      this.conversationLabelRepository.saveLabels();\n    }\n    this.deleteConversationFromRepository(conversationId);\n    this.conversation_service.deleteConversationFromDb(conversationId);\n  };\n\n  public async getAllUsersInConversation(conversationId: QualifiedId): Promise<User[]> {\n    const conversationEntity = await this.getConversationById(conversationId);\n    const users = [this.userState.self()].concat(conversationEntity.participating_user_ets());\n    return users;\n  }\n\n  /**\n   * Check for conversation locally and fetch it from the server otherwise.\n   * TODO(Federation): Remove \"optional\" from \"domain\"\n   */\n  async getConversationById(conversation_id: QualifiedId): Promise<Conversation> {\n    if (typeof conversation_id.id !== 'string') {\n      throw new ConversationError(\n        ConversationError.TYPE.NO_CONVERSATION_ID,\n        ConversationError.MESSAGE.NO_CONVERSATION_ID,\n      );\n    }\n    const conversationEntity = this.conversationState.findConversation(conversation_id);\n    if (conversationEntity) {\n      return conversationEntity;\n    }\n    try {\n      return await this.fetchConversationById(conversation_id);\n    } catch (error) {\n      const isConversationNotFound = error.type === ConversationError.TYPE.CONVERSATION_NOT_FOUND;\n      if (isConversationNotFound) {\n        this.logger.warn(`Failed to get conversation '${conversation_id.id}': ${error.message}`, error);\n      }\n\n      throw error;\n    }\n  }\n\n  /**\n   * Get group conversations by name.\n   *\n   * @param query Query to be searched in group conversation names\n   * @param isHandle Query string is handle\n   * @returns Matching group conversations\n   */\n  getGroupsByName(query: string, isHandle: boolean) {\n    return this.conversationState\n      .sorted_conversations()\n      .filter(conversationEntity => {\n        if (!conversationEntity.isGroup()) {\n          return false;\n        }\n\n        const queryString = isHandle ? `@${query}` : query;\n        if (compareTransliteration(conversationEntity.display_name(), queryString)) {\n          return true;\n        }\n\n        for (const userEntity of conversationEntity.participating_user_ets()) {\n          const nameString = isHandle ? userEntity.username() : userEntity.name();\n          if (startsWith(nameString, query)) {\n            return true;\n          }\n        }\n\n        return false;\n      })\n      .sort((conversationA, conversationB) => {\n        return sortByPriority(conversationA.display_name(), conversationB.display_name(), query);\n      })\n      .map(conversationEntity => {\n        this.updateParticipatingUserEntities(conversationEntity);\n        return conversationEntity;\n      });\n  }\n\n  /**\n   * Get the most recent event timestamp from any conversation.\n   * @param increment Increment by one for unique timestamp\n   * @returns Timestamp value\n   */\n  private getLatestEventTimestamp(increment = false) {\n    const mostRecentConversation = this.getMostRecentConversation(true);\n    if (mostRecentConversation) {\n      const lastEventTimestamp = mostRecentConversation.last_event_timestamp();\n      return lastEventTimestamp + (increment ? 1 : 0);\n    }\n\n    return 1;\n  }\n\n  /**\n   * Get the next unarchived conversation.\n   *\n   * @param conversationEntity Conversation to start from\n   * @returns Next conversation\n   */\n  getNextConversation(conversationEntity: Conversation) {\n    return getNextItem(this.conversationState.conversations_unarchived(), conversationEntity);\n  }\n\n  /**\n   * Get unarchived conversation with the most recent event.\n   * @param allConversations Search all conversations\n   * @returns Most recent conversation\n   */\n  getMostRecentConversation(allConversations = false) {\n    const [conversationEntity] = allConversations\n      ? this.conversationState.sorted_conversations()\n      : this.conversationState.conversations_unarchived();\n    return conversationEntity;\n  }\n\n  /**\n   * Returns a list of sorted conversation ids based on the number of messages in the last 30 days.\n   * @returns Resolve with the most active conversations\n   */\n  getMostActiveConversations() {\n    return this.conversation_service.getActiveConversationsFromDb().then(conversation_ids => {\n      return conversation_ids\n        .map(conversation_id => this.conversationState.findConversation(conversation_id))\n        .filter(conversationEntity => conversationEntity);\n    });\n  }\n\n  /**\n   * Get conversation with a user.\n   * @param userEntity User entity for whom to get the conversation\n   * @returns Resolves with the conversation with requested user\n   */\n  async get1To1Conversation(userEntity: User): Promise<Conversation | false> {\n    const inCurrentTeam = userEntity.inTeam() && userEntity.teamId === this.userState.self().teamId;\n\n    if (inCurrentTeam) {\n      const matchingConversationEntity = this.conversationState.conversations().find(conversationEntity => {\n        if (!conversationEntity.is1to1()) {\n          // Disregard conversations that are not 1:1\n          return false;\n        }\n\n        const inTeam = ConversationFilter.isInTeam(conversationEntity, userEntity);\n        if (!inTeam) {\n          // Disregard conversations that are not in the team\n          return false;\n        }\n\n        const isActiveConversation = !conversationEntity.removed_from_conversation();\n        if (!isActiveConversation) {\n          // Disregard conversations that self is no longer part of\n          return false;\n        }\n\n        return ConversationFilter.is1To1WithUser(conversationEntity, userEntity);\n      });\n\n      if (matchingConversationEntity) {\n        return matchingConversationEntity;\n      }\n      return this.createGroupConversation([userEntity]);\n    }\n\n    const conversationId = userEntity.connection().conversationId;\n    try {\n      const conversationEntity = await this.getConversationById(conversationId);\n      conversationEntity.connection(userEntity.connection());\n      this.updateParticipatingUserEntities(conversationEntity);\n      return conversationEntity;\n    } catch (error) {\n      const isConversationNotFound = error.type === ConversationError.TYPE.CONVERSATION_NOT_FOUND;\n      if (!isConversationNotFound) {\n        throw error;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Check whether message has been read.\n   *\n   * @param conversation_id Conversation ID\n   * @param message_id Message ID\n   * @returns Resolves with `true` if message is marked as read\n   */\n  async isMessageRead(conversation_id: QualifiedId, message_id: string): Promise<boolean> {\n    if (!conversation_id || !message_id) {\n      return false;\n    }\n\n    try {\n      const conversationEntity = await this.getConversationById(conversation_id);\n      const messageEntity = await this.messageRepository.getMessageInConversationById(conversationEntity, message_id);\n      return conversationEntity.last_read_timestamp() >= messageEntity.timestamp();\n    } catch (error) {\n      const messageNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n      if (messageNotFound) {\n        return true;\n      }\n\n      throw error;\n    }\n  }\n\n  initializeConversations(): Promise<unknown> | undefined {\n    this.initStateUpdates();\n    this.init_total = this.receiving_queue.getLength();\n\n    if (this.init_total > 5) {\n      this.logger.log(`Handling '${this.init_total}' additional messages on app start`);\n      return new Promise((resolve, reject) => (this.init_promise = {rejectFn: reject, resolveFn: resolve}));\n    }\n    return undefined;\n  }\n\n  /**\n   * Starts the join public conversation flow.\n   * Opens conversation directly when it is already known.\n   *\n   * @param event Custom event containing join key/code\n   */\n  private readonly onConversationJoin = async (event: {detail: {code: string; key: string}}) => {\n    const {key, code} = event.detail;\n\n    const showNoConversationModal = () => {\n      const titleText = t('modalConversationJoinNotFoundHeadline');\n      const messageText = t('modalConversationJoinNotFoundMessage');\n      this.showModal(messageText, titleText);\n    };\n    const showTooManyMembersModal = () => {\n      const titleText = t('modalConversationJoinFullHeadline');\n      const messageText = t('modalConversationJoinFullMessage');\n      this.showModal(messageText, titleText);\n    };\n\n    try {\n      const {id: conversationId, name: conversationName} = await this.conversation_service.getConversationJoin(\n        key,\n        code,\n      );\n      const knownConversation = this.conversationState.findConversation({domain: null, id: conversationId});\n      if (knownConversation?.status() === ConversationStatus.CURRENT_MEMBER) {\n        amplify.publish(WebAppEvents.CONVERSATION.SHOW, knownConversation, {});\n        return;\n      }\n      amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.CONFIRM, {\n        primaryAction: {\n          action: async () => {\n            try {\n              const response = await this.conversation_service.postConversationJoin(key, code);\n              const conversationEntity = await this.getConversationById({domain: '', id: conversationId});\n              if (response) {\n                await this.onMemberJoin(conversationEntity, response);\n              }\n              amplify.publish(WebAppEvents.CONVERSATION.SHOW, conversationEntity, {});\n            } catch (error) {\n              switch (error.label) {\n                case BackendErrorLabel.NO_CONVERSATION:\n                case BackendErrorLabel.NO_CONVERSATION_CODE: {\n                  showNoConversationModal();\n                  break;\n                }\n                case BackendErrorLabel.TOO_MANY_MEMBERS: {\n                  showTooManyMembersModal();\n                  break;\n                }\n\n                default: {\n                  throw error;\n                }\n              }\n            }\n          },\n          text: t('modalConversationJoinConfirm'),\n        },\n        text: {\n          message: t('modalConversationJoinMessage', {conversationName}),\n          title: t('modalConversationJoinHeadline'),\n        },\n      });\n    } catch (error) {\n      switch (error.label) {\n        case BackendErrorLabel.NO_CONVERSATION:\n        case BackendErrorLabel.NO_CONVERSATION_CODE: {\n          showNoConversationModal();\n          break;\n        }\n        default: {\n          throw error;\n        }\n      }\n    }\n  };\n\n  /**\n   * Maps user connection to the corresponding conversation.\n   *\n   * @note If there is no conversation it will request it from the backend\n   * @returns Resolves when connection was mapped return value\n   */\n  private readonly mapConnection = (connectionEntity: ConnectionEntity): Promise<Conversation | undefined> => {\n    const qualifiedId: QualifiedId = connectionEntity.conversationId;\n    return Promise.resolve(this.conversationState.findConversation(qualifiedId))\n      .then(conversationEntity => {\n        if (!conversationEntity) {\n          if (connectionEntity.isConnected() || connectionEntity.isOutgoingRequest()) {\n            return this.fetchConversationById(qualifiedId);\n          }\n        }\n        return conversationEntity;\n      })\n      .then(conversationEntity => {\n        if (!conversationEntity) {\n          return undefined;\n        }\n        conversationEntity.connection(connectionEntity);\n\n        if (connectionEntity.isConnected()) {\n          conversationEntity.type(CONVERSATION_TYPE.ONE_TO_ONE);\n        }\n\n        return this.updateParticipatingUserEntities(conversationEntity);\n      })\n      .then(updatedConversationEntity => {\n        this.conversationState.conversations.notifySubscribers();\n        return updatedConversationEntity;\n      })\n      .catch(error => {\n        const isConversationNotFound = error.type === ConversationError.TYPE.CONVERSATION_NOT_FOUND;\n        if (!isConversationNotFound) {\n          throw error;\n        }\n        return undefined;\n      });\n  };\n\n  /**\n   * @returns resolves when deleted conversations are locally deleted, too.\n   */\n  checkForDeletedConversations() {\n    return Promise.all(\n      this.conversationState.conversations().map(async conversation => {\n        try {\n          await this.conversation_service.getConversationById(conversation);\n        } catch ({code}) {\n          if (code === HTTP_STATUS.NOT_FOUND) {\n            this.deleteConversationLocally(conversation, true);\n          }\n        }\n      }),\n    );\n  }\n\n  /**\n   * Maps user connections to the corresponding conversations.\n   * @param connectionEntities Connections entities\n   */\n  mapConnections(connectionEntities: ConnectionEntity[]): Promise<Conversation>[] {\n    this.logger.info(`Mapping '${connectionEntities.length}' user connection(s) to conversations`, connectionEntities);\n    return connectionEntities.map(connectionEntity => this.mapConnection(connectionEntity));\n  }\n\n  /**\n   * Map conversation payload.\n   *\n   * @param payload Payload to map\n   * @param initialTimestamp Initial server and event timestamp\n   * @returns Mapped conversation/s\n   */\n  mapConversations(payload: BackendConversation[], initialTimestamp = this.getLatestEventTimestamp()): Conversation[] {\n    const entities = ConversationMapper.mapConversations(payload as ConversationDatabaseData[], initialTimestamp);\n    entities.forEach(conversationEntity => {\n      this._mapGuestStatusSelf(conversationEntity);\n      conversationEntity.selfUser(this.userState.self());\n      conversationEntity.setStateChangePersistence(true);\n    });\n\n    return entities;\n  }\n\n  private mapGuestStatusSelf() {\n    this.conversationState\n      .filtered_conversations()\n      .forEach(conversationEntity => this._mapGuestStatusSelf(conversationEntity));\n\n    if (this.teamState.isTeam()) {\n      this.userState.self().inTeam(true);\n      this.userState.self().isTeamMember(true);\n    }\n  }\n\n  private _mapGuestStatusSelf(conversationEntity: Conversation) {\n    const conversationTeamId = conversationEntity.team_id;\n    const selfTeamId = this.teamState.team()?.id;\n    const isConversationGuest = !!(conversationTeamId && (!selfTeamId || selfTeamId !== conversationTeamId));\n    conversationEntity.isGuest(isConversationGuest);\n  }\n\n  /**\n   * Save a conversation in the repository and in the database.\n   * Will resolve with local conversation entity and do nothing if conversation already exists in state\n   *\n   * @param conversationEntity Conversation to be saved in the repository\n   * @returns Resolves when conversation was saved\n   */\n  saveConversation(conversationEntity: Conversation) {\n    const localEntity = this.conversationState.findConversation(conversationEntity);\n    if (!localEntity) {\n      this.conversationState.conversations.push(conversationEntity);\n      return this.saveConversationStateInDb(conversationEntity);\n    }\n    return Promise.resolve(localEntity);\n  }\n\n  /**\n   * Persists a conversation state in the database.\n   * @param conversationEntity Conversation of which the state should be persisted\n   * @returns Resolves when conversation was saved\n   */\n  private readonly saveConversationStateInDb = (conversationEntity: Conversation) => {\n    return this.conversation_service.saveConversationStateInDb(conversationEntity);\n  };\n\n  /**\n   * Save conversations in the repository.\n   * @param conversationEntities Conversations to be saved in the repository\n   */\n  private saveConversations(conversationEntities: Conversation[]) {\n    this.conversationState.conversations.push(...conversationEntities);\n  }\n\n  /**\n   * Set the notification handling state.\n   *\n   * @note Temporarily do not unarchive conversations when handling the notification stream\n   * @param handlingState State of the notifications stream handling\n   */\n  private readonly setNotificationHandlingState = (handlingState: NOTIFICATION_HANDLING_STATE) => {\n    const isFetchingFromStream = handlingState !== NOTIFICATION_HANDLING_STATE.WEB_SOCKET;\n\n    if (this.isBlockingNotificationHandling !== isFetchingFromStream) {\n      if (!isFetchingFromStream) {\n        this.checkChangedConversations();\n      }\n      this.isBlockingNotificationHandling = isFetchingFromStream;\n      this.logger.info(`Block handling of conversation events: ${this.isBlockingNotificationHandling}`);\n    }\n  };\n\n  /**\n   * Update participating users in a conversation.\n   *\n   * @param conversationEntity Conversation to be updated\n   * @param offline Should we only look for cached contacts\n   * @param updateGuests Update conversation guests\n   * @returns Resolves when users have been updated\n   */\n  async updateParticipatingUserEntities(\n    conversationEntity: Conversation,\n    offline = false,\n    updateGuests = false,\n  ): Promise<Conversation> {\n    const userEntities = await this.userRepository.getUsersById(conversationEntity.participating_user_ids(), offline);\n    userEntities.sort(sortUsersByPriority);\n    conversationEntity.participating_user_ets(userEntities);\n\n    if (updateGuests) {\n      conversationEntity.updateGuests();\n    }\n\n    return conversationEntity;\n  }\n\n  //##############################################################################\n  // Send events\n  //##############################################################################\n\n  /**\n   * Add users to an existing conversation.\n   *\n   * @param conversationEntity Conversation to add users to\n   * @param userEntities Users to be added to the conversation\n   * @returns Resolves when members were added\n   */\n  async addMembers(conversationEntity: Conversation, userEntities: User[]) {\n    const userIds = userEntities.map(userEntity => userEntity.qualifiedId);\n\n    try {\n      const response = await this.conversation_service.postMembers(\n        conversationEntity.id,\n        userIds,\n        conversationEntity.isFederated(),\n      );\n      if (response) {\n        this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n      }\n    } catch (error) {\n      return this.handleAddToConversationError(error, conversationEntity, userIds);\n    }\n  }\n\n  addMissingMember(conversationEntity: Conversation, users: QualifiedId[], timestamp: number) {\n    const [sender] = users;\n    const event = EventBuilder.buildMemberJoin(conversationEntity, sender, users, timestamp);\n    return this.eventRepository.injectEvent(event, EventRepository.SOURCE.INJECTED);\n  }\n\n  /**\n   * Add a service to an existing conversation.\n   *\n   * @param conversationEntity Conversation to add service to\n   * @param providerId ID of service provider\n   * @param serviceId ID of service\n   * @returns Resolves when service was added\n   */\n  addService(conversationEntity: Conversation, providerId: string, serviceId: string) {\n    return this.conversation_service\n      .postBots(conversationEntity.id, providerId, serviceId)\n      .then((response: any) => {\n        const event = response?.event;\n        if (event) {\n          const logMessage = `Successfully added service to conversation '${conversationEntity.display_name()}'`;\n          this.logger.debug(logMessage, response);\n          return this.eventRepository.injectEvent(response.event, EventRepository.SOURCE.BACKEND_RESPONSE);\n        }\n\n        return event;\n      })\n      .catch(error => this.handleAddToConversationError(error, conversationEntity, [{domain: '', id: serviceId}]));\n  }\n\n  private handleAddToConversationError(\n    error: BackendClientError,\n    conversationEntity: Conversation,\n    userIds: QualifiedId[],\n  ) {\n    switch (error.label) {\n      case BackendErrorLabel.NOT_CONNECTED: {\n        this.handleUsersNotConnected(userIds);\n        break;\n      }\n\n      case BackendClientError.LABEL.BAD_GATEWAY:\n      case BackendClientError.LABEL.SERVER_ERROR:\n      case BackendClientError.LABEL.SERVICE_DISABLED:\n      case BackendClientError.LABEL.TOO_MANY_BOTS: {\n        const messageText = t('modalServiceUnavailableMessage');\n        const titleText = t('modalServiceUnavailableHeadline');\n\n        this.showModal(messageText, titleText);\n        break;\n      }\n\n      case BackendErrorLabel.TOO_MANY_MEMBERS: {\n        this.handleTooManyMembersError(conversationEntity.getNumberOfParticipants());\n        break;\n      }\n      case BackendErrorLabel.LEGAL_HOLD_MISSING_CONSENT: {\n        this.showLegalHoldConsentError();\n        break;\n      }\n\n      default: {\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Clear conversation content and archive the conversation.\n   *\n   * @note According to spec we archive a conversation when we clear it.\n   * It will be unarchived once it is opened through search. We use the archive flag to distinguish states.\n   *\n   * @param conversationEntity Conversation to clear\n   * @param leaveConversation Should we leave the conversation before clearing the content?\n   */\n  public clearConversation(conversationEntity: Conversation, leaveConversation = false) {\n    const isActiveConversation = this.conversationState.isActiveConversation(conversationEntity);\n    const nextConversationEntity = this.getNextConversation(conversationEntity);\n\n    if (leaveConversation) {\n      conversationEntity.status(ConversationStatus.PAST_MEMBER);\n      this.leaveCall(conversationEntity.id);\n    }\n\n    this.messageRepository.updateClearedTimestamp(conversationEntity);\n    this._clearConversation(conversationEntity);\n\n    if (leaveConversation) {\n      this.removeMember(conversationEntity, this.userState.self().qualifiedId);\n    }\n\n    if (isActiveConversation) {\n      amplify.publish(WebAppEvents.CONVERSATION.SHOW, nextConversationEntity, {});\n    }\n  }\n\n  async leaveGuestRoom(): Promise<void> {\n    if (this.userState.self().isTemporaryGuest()) {\n      const conversationEntity = this.getMostRecentConversation(true);\n      await this.conversation_service.deleteMembers(conversationEntity.id, this.userState.self().id);\n    }\n  }\n\n  /**\n   * Remove member from conversation.\n   *\n   * @param conversationEntity Conversation to remove member from\n   * @param user ID of member to be removed from the conversation\n   * @returns Resolves when member was removed from the conversation\n   */\n  public async removeMember(conversationEntity: Conversation, user: QualifiedId) {\n    const response = conversationEntity.isFederated()\n      ? await this.conversation_service.deleteQualifiedMembers(conversationEntity.qualifiedId, user)\n      : await this.conversation_service.deleteMembers(conversationEntity.id, user.id);\n    const roles = conversationEntity.roles();\n    delete roles[user.id];\n    conversationEntity.roles(roles);\n    const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n    const event = response || EventBuilder.buildMemberLeave(conversationEntity, user, true, currentTimestamp);\n    this.eventRepository.injectEvent(event, EventRepository.SOURCE.BACKEND_RESPONSE);\n    return event;\n  }\n\n  /**\n   * Remove service from conversation.\n   *\n   * @param conversationEntity Conversation to remove service from\n   * @param user ID of service user to be removed from the conversation\n   * @returns Resolves when service was removed from the conversation\n   */\n  public removeService(conversationEntity: Conversation, user: QualifiedId) {\n    return this.conversation_service.deleteBots(conversationEntity.id, user.id).then((response: any) => {\n      // TODO: Can this even have a response? in the API Client it look like it always returns `void`\n      const hasResponse = response?.event;\n      const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n      const event = hasResponse\n        ? response.event\n        : EventBuilder.buildMemberLeave(conversationEntity, user, true, currentTimestamp);\n\n      this.eventRepository.injectEvent(event, EventRepository.SOURCE.BACKEND_RESPONSE);\n      return event;\n    });\n  }\n\n  /**\n   * Rename conversation.\n   *\n   * @param conversationEntity Conversation to rename\n   * @param name New conversation name\n   * @returns Resolves when conversation was renamed\n   */\n  public async renameConversation(\n    conversationEntity: Conversation,\n    name: string,\n  ): Promise<ConversationRenameEvent | undefined> {\n    const response = await this.conversation_service.updateConversationName(conversationEntity.id, name);\n    if (response) {\n      this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n      return response;\n    }\n    return undefined;\n  }\n\n  /**\n   * Set the global message timer\n   */\n  async updateConversationMessageTimer(\n    conversationEntity: Conversation,\n    messageTimer: number,\n  ): Promise<ConversationMessageTimerUpdateEvent> {\n    messageTimer = ConversationEphemeralHandler.validateTimer(messageTimer);\n\n    const response = await this.conversation_service.updateConversationMessageTimer(\n      conversationEntity.id,\n      messageTimer,\n    );\n    if (response) {\n      this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n    }\n    return response;\n  }\n\n  public async updateConversationReceiptMode(\n    conversationEntity: Conversation,\n    receiptMode: ConversationReceiptModeUpdateData,\n  ) {\n    const response = await this.conversation_service.updateConversationReceiptMode(conversationEntity.id, receiptMode);\n    if (response) {\n      this.eventRepository.injectEvent(response, EventRepository.SOURCE.BACKEND_RESPONSE);\n    }\n    return response;\n  }\n\n  /**\n   * Team member was removed.\n   * @param teamId ID of team that member was removed from\n   * @param userId ID of leaving user\n   * @param isoDate Date of member removal\n   */\n  readonly teamMemberLeave = async (\n    teamId: string,\n    userId: QualifiedId,\n    isoDate = this.serverTimeHandler.toServerTimestamp(),\n  ) => {\n    const userEntity = await this.userRepository.getUserById(userId);\n    this.conversationState\n      .conversations()\n      .filter(conversationEntity => {\n        const conversationInTeam = conversationEntity.team_id === teamId;\n        const userIsParticipant = UserFilter.isParticipant(conversationEntity, userId);\n        return conversationInTeam && userIsParticipant && !conversationEntity.removed_from_conversation();\n      })\n      .forEach(conversationEntity => {\n        const leaveEvent = EventBuilder.buildTeamMemberLeave(conversationEntity, userEntity, isoDate);\n        this.eventRepository.injectEvent(leaveEvent);\n      });\n    userEntity.isDeleted = true;\n  };\n\n  /**\n   * Set the notification state of a conversation.\n   *\n   * @param conversationEntity Conversation to change notification state off\n   * @param notificationState New notification state\n   * @returns Resolves when the notification stated was change\n   */\n  public async setNotificationState(conversationEntity: Conversation, notificationState: number) {\n    if (!conversationEntity || notificationState === undefined) {\n      return Promise.reject(\n        new ConversationError(BaseError.TYPE.MISSING_PARAMETER as BASE_ERROR_TYPE, BaseError.MESSAGE.MISSING_PARAMETER),\n      );\n    }\n\n    const validNotificationStates = Object.values(NOTIFICATION_STATE);\n    if (!validNotificationStates.includes(notificationState)) {\n      return Promise.reject(\n        new ConversationError(BaseError.TYPE.INVALID_PARAMETER as BASE_ERROR_TYPE, BaseError.MESSAGE.INVALID_PARAMETER),\n      );\n    }\n\n    const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n    const payload = {\n      otr_muted_ref: new Date(conversationEntity.getLastKnownTimestamp(currentTimestamp)).toISOString(),\n      otr_muted_status: notificationState,\n    };\n\n    try {\n      await this.conversation_service.updateMemberProperties(conversationEntity.id, payload);\n      const response = {data: payload, from: this.userState.self().id};\n      this.onMemberUpdate(conversationEntity, response);\n\n      const {otr_muted_ref: mutedRef, otr_muted_status: mutedStatus} = payload;\n      const logMessage = `Changed notification state of conversation to '${mutedStatus}' on '${mutedRef}'`;\n      this.logger.info(logMessage);\n      return response;\n    } catch (error) {\n      const log = `Failed to change notification state of conversation '${conversationEntity.id}': ${error.message}`;\n      const rejectError = new Error(log);\n      this.logger.warn(rejectError.message, error);\n      throw rejectError;\n    }\n  }\n\n  /**\n   * Archive a conversation.\n   *\n   * @param conversationEntity Conversation to rename\n   * @returns Resolves when the conversation was archived\n   */\n  public async archiveConversation(conversationEntity: Conversation) {\n    await this.toggleArchiveConversation(conversationEntity, true);\n    this.logger.info(`Conversation '${conversationEntity.id}' archived`);\n  }\n\n  /**\n   * Un-archive a conversation.\n   *\n   * @param conversationEntity Conversation to unarchive\n   * @param forceChange Force state change without new message\n   * @param trigger Trigger for unarchive\n   * @returns Resolves when the conversation was unarchived\n   */\n  public async unarchiveConversation(conversationEntity: Conversation, forceChange = false, trigger = 'unknown') {\n    await this.toggleArchiveConversation(conversationEntity, false, forceChange);\n    this.logger.info(`Conversation '${conversationEntity.id}' unarchived by trigger '${trigger}'`);\n  }\n\n  private async toggleArchiveConversation(\n    conversationEntity: Conversation,\n    newState: boolean,\n    forceChange: boolean = false,\n  ) {\n    if (!conversationEntity) {\n      const error = new ConversationError(\n        ConversationError.TYPE.CONVERSATION_NOT_FOUND,\n        ConversationError.MESSAGE.CONVERSATION_NOT_FOUND,\n      );\n      throw error;\n    }\n\n    const stateChange = conversationEntity.is_archived() !== newState;\n\n    const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n    const archiveTimestamp = conversationEntity.getLastKnownTimestamp(currentTimestamp);\n    const sameTimestamp = conversationEntity.archivedTimestamp() === archiveTimestamp;\n    const skipChange = sameTimestamp && !forceChange;\n\n    if (!stateChange && skipChange) {\n      throw new ConversationError(ConversationError.TYPE.NO_CHANGES, ConversationError.MESSAGE.NO_CHANGES);\n    }\n\n    const payload = {\n      otr_archived: newState,\n      otr_archived_ref: new Date(archiveTimestamp).toISOString(),\n    };\n\n    const conversationId = conversationEntity.id;\n\n    const updatePromise = conversationEntity.removed_from_conversation()\n      ? Promise.resolve()\n      : this.conversation_service.updateMemberProperties(conversationId, payload).catch(error => {\n          const logMessage = `Failed to change archived state of '${conversationId}' to '${newState}': ${error.code}`;\n          this.logger.error(logMessage);\n\n          const isNotFound = error.code === HTTP_STATUS.NOT_FOUND;\n          if (!isNotFound) {\n            throw error;\n          }\n        });\n\n    await updatePromise;\n    const response = {\n      data: payload,\n      from: this.userState.self().id,\n    };\n    this.onMemberUpdate(conversationEntity, response);\n  }\n\n  private checkChangedConversations() {\n    this.conversationsWithNewEvents.forEach(conversationEntity => {\n      if (conversationEntity.shouldUnarchive()) {\n        this.unarchiveConversation(conversationEntity, false, 'event from notification stream');\n      }\n    });\n\n    this.conversationsWithNewEvents.clear();\n  }\n\n  /**\n   * Clears conversation content from view and the database.\n   *\n   * @param conversationEntity Conversation entity to delete\n   * @param timestamp Optional timestamps for which messages to remove\n   */\n  private _clearConversation(conversationEntity: Conversation, timestamp?: number) {\n    this.deleteMessages(conversationEntity, timestamp);\n\n    if (conversationEntity.removed_from_conversation()) {\n      this.conversation_service.deleteConversationFromDb(conversationEntity);\n      this.deleteConversationFromRepository(conversationEntity);\n    }\n  }\n\n  private handleConversationCreateError(error: BackendClientError, userIds: QualifiedId[]): void {\n    switch (error.label) {\n      case BackendClientError.LABEL.CLIENT_ERROR:\n        this.handleTooManyMembersError();\n        break;\n      case BackendClientError.LABEL.NOT_CONNECTED:\n        this.handleUsersNotConnected(userIds);\n        break;\n      case BackendErrorLabel.LEGAL_HOLD_MISSING_CONSENT:\n        this.showLegalHoldConsentError();\n        break;\n      default:\n        throw error;\n    }\n  }\n\n  private handleTooManyMembersError(participants = ConversationRepository.CONFIG.GROUP.MAX_SIZE) {\n    const openSpots = ConversationRepository.CONFIG.GROUP.MAX_SIZE - participants;\n    const substitutions = {\n      number1: ConversationRepository.CONFIG.GROUP.MAX_SIZE.toString(10),\n      number2: Math.max(0, openSpots).toString(10),\n    };\n\n    const messageText = t('modalConversationTooManyMembersMessage', substitutions);\n    const titleText = t('modalConversationTooManyMembersHeadline');\n    this.showModal(messageText, titleText);\n  }\n\n  private async handleUsersNotConnected(userIds: QualifiedId[] = []): Promise<void> {\n    const titleText = t('modalConversationNotConnectedHeadline');\n\n    if (userIds.length > 1) {\n      this.showModal(t('modalConversationNotConnectedMessageMany'), titleText);\n    } else {\n      // TODO(Federation): Update code once connections are implemented on the backend\n      const userEntity = await this.userRepository.getUserById(userIds[0]);\n      this.showModal(t('modalConversationNotConnectedMessageOne', userEntity.name()), titleText);\n    }\n  }\n\n  private showModal(messageText: string, titleText: string) {\n    amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.ACKNOWLEDGE, {\n      text: {\n        message: messageText,\n        title: titleText,\n      },\n    });\n  }\n\n  private showLegalHoldConsentError() {\n    const replaceLinkLegalHold = replaceLink(\n      Config.getConfig().URL.SUPPORT.LEGAL_HOLD_BLOCK,\n      '',\n      'read-more-legal-hold',\n    );\n\n    const messageText = t('modalLegalHoldConversationMissingConsentMessage', {}, replaceLinkLegalHold);\n    const titleText = t('modalUserCannotBeAddedHeadline');\n\n    amplify.publish(WebAppEvents.WARNING.MODAL, ModalsViewModel.TYPE.ACKNOWLEDGE, {\n      text: {\n        htmlMessage: messageText,\n        title: titleText,\n      },\n    });\n  }\n\n  //##############################################################################\n  // Send Generic Messages\n  //##############################################################################\n\n  readonly injectLegalHoldMessage = async ({\n    conversationEntity,\n    conversationId,\n    userId,\n    timestamp,\n    legalHoldStatus,\n    beforeTimestamp = false,\n  }: {\n    beforeTimestamp?: boolean;\n    conversationEntity?: Conversation;\n    conversationId: QualifiedId;\n    legalHoldStatus: LegalHoldStatus;\n    timestamp: string | number;\n    userId: QualifiedId;\n  }) => {\n    if (typeof legalHoldStatus === 'undefined') {\n      return;\n    }\n    if (!timestamp) {\n      // TODO(federation) find with qualified id\n      const conversation = conversationEntity || this.conversationState.findConversation(conversationId);\n      const servertime = this.serverTimeHandler.toServerTimestamp();\n      timestamp = conversation.getLatestTimestamp(servertime);\n    }\n    const legalHoldUpdateMessage = EventBuilder.buildLegalHoldMessage(\n      conversationId || conversationEntity?.qualifiedId,\n      userId,\n      timestamp,\n      legalHoldStatus,\n      beforeTimestamp,\n    );\n    await this.eventRepository.injectEvent(legalHoldUpdateMessage);\n  };\n\n  async injectFileTypeRestrictedMessage(\n    conversation: Conversation,\n    user: User,\n    isIncoming: boolean,\n    fileExt: string,\n    id = createRandomUuid(),\n  ) {\n    const fileRestrictionMessage = EventBuilder.buildFileTypeRestricted(conversation, user, isIncoming, fileExt, id);\n    await this.eventRepository.injectEvent(fileRestrictionMessage);\n  }\n\n  //##############################################################################\n  // Event callbacks\n  //##############################################################################\n\n  /**\n   * Listener for incoming events.\n   *\n   * @param eventJson JSON data for event\n   * @param eventSource Source of event\n   * @returns Resolves when event was handled\n   */\n  private readonly onConversationEvent = (eventJson: IncomingEvent, eventSource = EventRepository.SOURCE.STREAM) => {\n    const logObject = {eventJson: JSON.stringify(eventJson), eventObject: eventJson};\n    const logMessage = `Conversation Event: '${eventJson.type}' (Source: ${eventSource})`;\n    this.logger.info(logMessage, logObject);\n\n    return this.pushToReceivingQueue(eventJson, eventSource);\n  };\n\n  private handleConversationEvent(eventJson: IncomingEvent, eventSource = EventRepository.SOURCE.STREAM) {\n    if (!eventJson) {\n      return Promise.reject(new Error('Conversation Repository Event Handling: Event missing'));\n    }\n\n    const {conversation, qualified_conversation, data: eventData, type} = eventJson;\n    // data.conversationId is always the conversationId that should be read first. If not found we can fallback to qualified_conversation or conversation\n    const conversationId: QualifiedId = eventData?.conversationId\n      ? {domain: '', id: eventData.conversationId}\n      : qualified_conversation || {domain: '', id: conversation};\n    this.logger.info(\n      `Handling event '${type}' in conversation '${conversationId.id}/${conversationId.domain}' (Source: ${eventSource})`,\n    );\n\n    const selfConversation = this.conversationState.self_conversation();\n    const inSelfConversation = selfConversation && matchQualifiedIds(conversationId, selfConversation.qualifiedId);\n    if (inSelfConversation) {\n      const typesInSelfConversation = [CONVERSATION_EVENT.MEMBER_UPDATE, ClientEvent.CONVERSATION.MESSAGE_HIDDEN];\n\n      const isExpectedType = typesInSelfConversation.includes(type);\n      if (!isExpectedType) {\n        return Promise.reject(\n          new ConversationError(\n            ConversationError.TYPE.WRONG_CONVERSATION,\n            ConversationError.MESSAGE.WRONG_CONVERSATION,\n          ),\n        );\n      }\n    }\n\n    const isConversationCreate = type === CONVERSATION_EVENT.CREATE;\n    const onEventPromise = isConversationCreate ? Promise.resolve(null) : this.getConversationById(conversationId);\n    let previouslyArchived = false;\n\n    return onEventPromise\n      .then((conversationEntity: Conversation) => {\n        if (conversationEntity) {\n          // Check if conversation was archived\n          previouslyArchived = conversationEntity.is_archived();\n\n          const isBackendTimestamp = eventSource !== EventRepository.SOURCE.INJECTED;\n          conversationEntity.updateTimestampServer(eventJson.server_time || eventJson.time, isBackendTimestamp);\n        }\n\n        return conversationEntity;\n      })\n      .then(conversationEntity => this.checkLegalHoldStatus(conversationEntity, eventJson))\n      .then(conversationEntity => this.checkConversationParticipants(conversationEntity, eventJson, eventSource))\n      .then(conversationEntity => this.triggerFeatureEventHandlers(conversationEntity, eventJson))\n      .then(\n        conversationEntity => this.reactToConversationEvent(conversationEntity, eventJson, eventSource) as EntityObject,\n      )\n      .then((entityObject = {} as EntityObject) =>\n        this.handleConversationNotification(entityObject as EntityObject, eventSource, previouslyArchived),\n      )\n      .catch((error: BaseError) => {\n        const ignoredErrorTypes: string[] = [\n          ConversationError.TYPE.MESSAGE_NOT_FOUND,\n          ConversationError.TYPE.CONVERSATION_NOT_FOUND,\n        ];\n\n        const isRemovedFromConversation =\n          (error as BackendClientError).label === BackendClientError.LABEL.ACCESS_DENIED;\n        if (isRemovedFromConversation) {\n          const messageText = t('conversationNotFoundMessage');\n          const titleText = t('conversationNotFoundTitle', Config.getConfig().BRAND_NAME);\n\n          this.showModal(messageText, titleText);\n          return;\n        }\n\n        if (!ignoredErrorTypes.includes(error.type)) {\n          throw error;\n        }\n      });\n  }\n\n  /**\n   * Check that sender of received event is a known conversation participant.\n   *\n   * @param conversationEntity Conversation targeted by the event\n   * @param eventJson JSON data of the event\n   * @param eventSource Source of event\n   * @returns Resolves when the participant list has been checked\n   */\n  private checkConversationParticipants(\n    conversationEntity: Conversation,\n    eventJson: IncomingEvent,\n    eventSource: EventSource,\n  ) {\n    // We ignore injected events\n    const isInjectedEvent = eventSource === EventRepository.SOURCE.INJECTED;\n    if (isInjectedEvent || !conversationEntity) {\n      return conversationEntity;\n    }\n\n    const {from: senderId, type, time} = eventJson;\n\n    if (senderId) {\n      const allParticipants = conversationEntity.participating_user_ids().concat(this.userState.self().qualifiedId);\n      const isFromUnknownUser = allParticipants.every(participant => participant.id !== senderId);\n\n      if (isFromUnknownUser) {\n        const membersUpdateMessages = [\n          CONVERSATION_EVENT.MEMBER_LEAVE,\n          CONVERSATION_EVENT.MEMBER_JOIN,\n          ClientEvent.CONVERSATION.TEAM_MEMBER_LEAVE,\n        ];\n        const isMembersUpdateEvent = membersUpdateMessages.includes(eventJson.type);\n        if (isMembersUpdateEvent) {\n          const isFromUpdatedMember = eventJson.data.user_ids?.includes(senderId);\n          if (isFromUpdatedMember) {\n            // we ignore leave/join events that are sent by the user actually leaving or joining\n            return conversationEntity;\n          }\n        }\n\n        const message = `Received '${type}' event from user '${senderId}' unknown in '${conversationEntity.id}'`;\n        this.logger.warn(message, eventJson);\n\n        const qualifiedSender: QualifiedId = {domain: '', id: senderId};\n\n        const timestamp = new Date(time).getTime() - 1;\n        return this.addMissingMember(conversationEntity, [qualifiedSender], timestamp).then(() => conversationEntity);\n      }\n    }\n\n    return conversationEntity;\n  }\n\n  private async checkLegalHoldStatus(conversationEntity: Conversation, eventJson: IncomingEvent) {\n    if (!LegalHoldEvaluator.hasMessageLegalHoldFlag(eventJson)) {\n      return conversationEntity;\n    }\n\n    const renderLegalHoldMessage = LegalHoldEvaluator.renderLegalHoldMessage(\n      eventJson,\n      conversationEntity.legalHoldStatus(),\n    );\n\n    if (!renderLegalHoldMessage) {\n      return conversationEntity;\n    }\n\n    const {\n      conversation: conversationId,\n      qualified_conversation,\n      qualified_from,\n      data: {legal_hold_status: messageLegalHoldStatus},\n      from: userId,\n      time: isoTimestamp,\n    } = eventJson;\n    const qualifiedConversation = qualified_conversation || {domain: '', id: conversationId};\n    const qualifiedUser = qualified_from || {domain: '', id: userId};\n\n    await this.injectLegalHoldMessage({\n      beforeTimestamp: true,\n      conversationId: qualifiedConversation,\n      legalHoldStatus: messageLegalHoldStatus,\n      timestamp: isoTimestamp,\n      userId: qualifiedUser,\n    });\n\n    await this.messageRepository.updateAllClients(conversationEntity, true);\n\n    if (messageLegalHoldStatus === conversationEntity.legalHoldStatus()) {\n      return conversationEntity;\n    }\n\n    await this.injectLegalHoldMessage({\n      conversationId: qualifiedConversation,\n      legalHoldStatus: conversationEntity.legalHoldStatus(),\n      timestamp: isoTimestamp,\n      userId: qualifiedUser,\n    });\n\n    return conversationEntity;\n  }\n\n  /**\n   * Triggers the methods associated with a specific event.\n   *\n   * @param conversationEntity Conversation targeted by the event\n   * @param eventJson JSON data of the event\n   * @param eventSource Source of event\n   * @returns Resolves when the event has been treated\n   */\n  private reactToConversationEvent(\n    conversationEntity: Conversation,\n    eventJson: IncomingEvent,\n    eventSource: EventSource,\n  ) {\n    switch (eventJson.type) {\n      case CONVERSATION_EVENT.CREATE:\n        return this.onCreate(eventJson, eventSource);\n\n      case CONVERSATION_EVENT.DELETE:\n        return this.deleteConversationLocally({domain: conversationEntity.domain, id: eventJson.conversation}, false);\n\n      case CONVERSATION_EVENT.MEMBER_JOIN:\n        return this.onMemberJoin(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.MEMBER_LEAVE:\n      case ClientEvent.CONVERSATION.TEAM_MEMBER_LEAVE:\n        return this.onMemberLeave(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.MEMBER_UPDATE:\n        return this.onMemberUpdate(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.RENAME:\n        return this.onRename(conversationEntity, eventJson, eventSource === EventRepository.SOURCE.WEB_SOCKET);\n\n      case ClientEvent.CONVERSATION.ASSET_ADD:\n        return this.onAssetAdd(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.GROUP_CREATION:\n        return this.onGroupCreation(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.MESSAGE_DELETE:\n        return this.onMessageDeleted(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.MESSAGE_HIDDEN:\n        return this.onMessageHidden(eventJson);\n\n      case ClientEvent.CONVERSATION.ONE2ONE_CREATION:\n        return this.on1to1Creation(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.REACTION:\n        return this.onReaction(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.RECEIPT_MODE_UPDATE:\n        return this.onReceiptModeChanged(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.BUTTON_ACTION_CONFIRMATION:\n        return this.onButtonActionConfirmation(conversationEntity, eventJson);\n\n      case ClientEvent.CONVERSATION.MESSAGE_ADD:\n        const isMessageEdit = !!eventJson.edited_time;\n        if (isMessageEdit) {\n          // in case of an edition, the DB listener will take care of updating the local entity\n          return {conversationEntity};\n        }\n        return this.addEventToConversation(conversationEntity, eventJson);\n\n      case CONVERSATION_EVENT.MESSAGE_TIMER_UPDATE:\n      case ClientEvent.CONVERSATION.COMPOSITE_MESSAGE_ADD:\n      case ClientEvent.CONVERSATION.DELETE_EVERYWHERE:\n      case ClientEvent.CONVERSATION.FILE_TYPE_RESTRICTED:\n      case ClientEvent.CONVERSATION.INCOMING_MESSAGE_TOO_BIG:\n      case ClientEvent.CONVERSATION.KNOCK:\n      case ClientEvent.CONVERSATION.CALL_TIME_OUT:\n      case ClientEvent.CONVERSATION.LEGAL_HOLD_UPDATE:\n      case ClientEvent.CONVERSATION.LOCATION:\n      case ClientEvent.CONVERSATION.MISSED_MESSAGES:\n      case ClientEvent.CONVERSATION.UNABLE_TO_DECRYPT:\n      case ClientEvent.CONVERSATION.VERIFICATION:\n      case ClientEvent.CONVERSATION.VOICE_CHANNEL_ACTIVATE:\n      case ClientEvent.CONVERSATION.VOICE_CHANNEL_DEACTIVATE:\n        return this.addEventToConversation(conversationEntity, eventJson);\n    }\n  }\n\n  /**\n   * Calls the feature specific event handler on the current event being handled.\n   *\n   * @param conversationEntity Conversation targeted by the event\n   * @param eventJson JSON data of the event\n   * @param eventSource Source of event\n   * @returns Resolves when all the handlers have done their job\n   */\n  private async triggerFeatureEventHandlers(conversationEntity: Conversation, eventJson: IncomingEvent) {\n    const conversationEventHandlers = [this.ephemeralHandler, this.stateHandler];\n    const handlePromises = conversationEventHandlers.map(handler =>\n      handler.handleConversationEvent(conversationEntity, eventJson),\n    );\n    await Promise.all(handlePromises);\n    return conversationEntity;\n  }\n\n  /**\n   * Handles conversation update and notification message.\n   *\n   * @param entityObject Object containing the conversation and the message that are targeted by the event\n   * @param eventSource Source of event\n   * @param previouslyArchived `true` if the previous state of the conversation was archived\n   * @returns Resolves when the conversation was updated\n   */\n  private async handleConversationNotification(\n    entityObject: EntityObject,\n    eventSource: EventSource,\n    previouslyArchived: boolean,\n  ) {\n    const {conversationEntity, messageEntity} = entityObject;\n\n    if (conversationEntity) {\n      const eventFromWebSocket = eventSource === EventRepository.SOURCE.WEB_SOCKET;\n      const eventFromStream = eventSource === EventRepository.SOURCE.STREAM;\n\n      if (messageEntity) {\n        const isRemoteEvent = eventFromStream || eventFromWebSocket;\n\n        if (isRemoteEvent) {\n          this.messageRepository.sendConfirmationStatus(conversationEntity, messageEntity, Confirmation.Type.DELIVERED);\n        }\n\n        if (!eventFromStream) {\n          amplify.publish(WebAppEvents.NOTIFICATION.NOTIFY, messageEntity, undefined, conversationEntity);\n        }\n\n        if (conversationEntity.is_cleared()) {\n          conversationEntity.cleared_timestamp(0);\n        }\n      }\n\n      // Check if event needs to be un-archived\n      if (previouslyArchived) {\n        // Add to check for un-archiving at the end of stream handling\n        if (eventFromStream) {\n          return this.conversationsWithNewEvents.set(conversationEntity.id, conversationEntity);\n        }\n\n        if (eventFromWebSocket && conversationEntity.shouldUnarchive()) {\n          return this.unarchiveConversation(conversationEntity, false, 'event from WebSocket');\n        }\n      }\n    }\n  }\n\n  /**\n   * Push to receiving queue.\n   * @param eventJson JSON data for event\n   * @param source Source of event\n   */\n  private pushToReceivingQueue(eventJson: IncomingEvent, source: EventSource) {\n    this.receiving_queue\n      .push(() => this.handleConversationEvent(eventJson, source))\n      .then(() => {\n        if (this.init_promise) {\n          const eventFromStream = source === EventRepository.SOURCE.STREAM;\n          if (eventFromStream) {\n            this.init_handled = this.init_handled + 1;\n            if (this.init_handled % 5 === 0 || this.init_handled < 5) {\n              const content = {\n                handled: this.init_handled,\n                total: this.init_total,\n              };\n              const progress = (this.init_handled / this.init_total) * 20 + 75;\n\n              amplify.publish(WebAppEvents.APP.UPDATE_PROGRESS, progress, t('initEvents'), content);\n            }\n          }\n\n          if (!this.receiving_queue.getLength() || !eventFromStream) {\n            this.init_promise.resolveFn();\n            this.init_promise = undefined;\n          }\n        }\n      })\n      .catch(error => {\n        if (this.init_promise) {\n          this.init_promise.rejectFn(error);\n          this.init_promise = undefined;\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  /**\n   * Add \"missed events\" system message to conversation.\n   */\n  private readonly onMissedEvents = (): void => {\n    this.conversationState\n      .filtered_conversations()\n      .filter(conversationEntity => !conversationEntity.removed_from_conversation())\n      .forEach(conversationEntity => {\n        const currentTimestamp = this.serverTimeHandler.toServerTimestamp();\n        const missed_event = EventBuilder.buildMissed(conversationEntity, currentTimestamp);\n        this.eventRepository.injectEvent(missed_event);\n      });\n  };\n\n  private on1to1Creation(conversationEntity: Conversation, eventJson: OneToOneCreationEvent) {\n    return this.event_mapper\n      .mapJsonEvent(eventJson, conversationEntity)\n      .then(messageEntity => this.updateMessageUserEntities(messageEntity))\n      .then((messageEntity: MemberMessage) => {\n        const userEntity = messageEntity.otherUser();\n        const isOutgoingRequest = userEntity?.isOutgoingRequest();\n        if (isOutgoingRequest) {\n          messageEntity.memberMessageType = SystemMessageType.CONNECTION_REQUEST;\n        }\n\n        conversationEntity.addMessage(messageEntity);\n        return {conversationEntity};\n      });\n  }\n\n  /**\n   * A conversation was created.\n   *\n   * @param eventJson JSON data of 'conversation.create' event\n   * @param eventSource Source of event\n   * @returns Resolves when the event was handled\n   */\n  private async onCreate(\n    eventJson: ConversationCreateEvent,\n    eventSource?: EventSource,\n  ): Promise<{conversationEntity: Conversation}> {\n    const {conversation: conversationId, data: eventData, time} = eventJson;\n    const eventTimestamp = new Date(time).getTime();\n    const initialTimestamp = isNaN(eventTimestamp) ? this.getLatestEventTimestamp(true) : eventTimestamp;\n    try {\n      const existingConversationEntity = this.conversationState.findConversation({\n        domain: eventJson.qualified_conversation?.domain,\n        id: conversationId,\n      });\n      if (existingConversationEntity) {\n        throw new ConversationError(ConversationError.TYPE.NO_CHANGES, ConversationError.MESSAGE.NO_CHANGES);\n      }\n\n      const [conversationEntity] = this.mapConversations([eventData], initialTimestamp);\n      if (conversationEntity) {\n        if (conversationEntity.participating_user_ids().length) {\n          this.addCreationMessage(conversationEntity, false, initialTimestamp, eventSource);\n        }\n        await this.updateParticipatingUserEntities(conversationEntity);\n        this.verificationStateHandler.onConversationCreate(conversationEntity);\n        await this.saveConversation(conversationEntity);\n      }\n      return {conversationEntity};\n    } catch (error) {\n      const isNoChanges = error.type === ConversationError.TYPE.NO_CHANGES;\n      if (!isNoChanges) {\n        throw error;\n      }\n    }\n    return undefined;\n  }\n\n  private async onGroupCreation(conversationEntity: Conversation, eventJson: GroupCreationEvent) {\n    const messageEntity = await this.event_mapper.mapJsonEvent(eventJson, conversationEntity);\n    const creatorId = conversationEntity.creator;\n    const creatorDomain = conversationEntity.domain;\n    const createdByParticipant = !!conversationEntity\n      .participating_user_ids()\n      .find(userId => matchQualifiedIds(userId, {domain: creatorDomain, id: creatorId}));\n    const createdBySelfUser = conversationEntity.isCreatedBySelf();\n\n    const creatorIsParticipant = createdByParticipant || createdBySelfUser;\n\n    const data = await this.conversation_service.getConversationById(conversationEntity);\n    const allMembers = [...data.members.others, data.members.self];\n    const conversationRoles = allMembers.reduce<Record<string, string>>((roles, member) => {\n      roles[member.id] = member.conversation_role;\n      return roles;\n    }, {});\n    conversationEntity.roles(conversationRoles);\n\n    if (!creatorIsParticipant) {\n      (messageEntity as MemberMessage).memberMessageType = SystemMessageType.CONVERSATION_RESUME;\n    }\n\n    const updatedMessageEntity = await this.updateMessageUserEntities(messageEntity);\n    if (conversationEntity && updatedMessageEntity) {\n      conversationEntity.addMessage(updatedMessageEntity);\n    }\n\n    return {conversationEntity, messageEntity: updatedMessageEntity};\n  }\n\n  /**\n   * Users were added to a group conversation.\n   *\n   * @param conversationEntity Conversation to add users to\n   * @param eventJson JSON data of 'conversation.member-join' event\n   * @returns Resolves when the event was handled\n   */\n  private async onMemberJoin(\n    conversationEntity: Conversation,\n    eventJson: ConversationMemberJoinEvent,\n  ): Promise<void | EntityObject> {\n    // Ignore if we join a 1to1 conversation (accept a connection request)\n    const connectionEntity = this.connectionRepository.getConnectionByConversationId(conversationEntity.qualifiedId);\n    const isPendingConnection = connectionEntity?.isIncomingRequest();\n    if (isPendingConnection) {\n      return Promise.resolve();\n    }\n\n    const eventData = eventJson.data;\n\n    if (eventData.users) {\n      eventData.users.forEach(otherMember => {\n        const otherId = otherMember.qualified_id || {domain: '', id: otherMember.id};\n        const isSelfUser = matchQualifiedIds(otherId, this.userState.self());\n        const isParticipatingUser = !!conversationEntity\n          .participating_user_ids()\n          .find(participatingUser =>\n            matchQualifiedIds(participatingUser, otherMember.qualified_id || {domain: '', id: otherMember.id}),\n          );\n        if (!isSelfUser && !isParticipatingUser) {\n          conversationEntity.participating_user_ids.push({\n            domain: otherMember.qualified_id?.domain || null,\n            id: otherMember.id,\n          });\n        }\n      });\n    } else {\n      eventData.user_ids.forEach(userId => {\n        const isSelfUser = userId === this.userState.self().id;\n        const isParticipatingUser = conversationEntity.participating_user_ids().some(user => user.id === userId);\n        if (!isSelfUser && !isParticipatingUser) {\n          conversationEntity.participating_user_ids.push({domain: '', id: userId});\n        }\n      });\n    }\n\n    // Self user joins again\n    const selfUserRejoins = eventData.user_ids.includes(this.userState.self().id);\n    if (selfUserRejoins) {\n      conversationEntity.status(ConversationStatus.CURRENT_MEMBER);\n      await this.conversationRoleRepository.updateConversationRoles(conversationEntity);\n    }\n\n    const updateSequence =\n      selfUserRejoins || connectionEntity?.isConnected()\n        ? this.updateConversationFromBackend(conversationEntity)\n        : Promise.resolve();\n\n    const qualifiedUserIds =\n      eventData.users?.map(user => user.qualified_id) || eventData.user_ids.map(userId => ({domain: '', id: userId}));\n\n    return updateSequence\n      .then(() => this.updateParticipatingUserEntities(conversationEntity, false, true))\n      .then(() => this.addEventToConversation(conversationEntity, eventJson))\n      .then(({messageEntity}) => {\n        this.verificationStateHandler.onMemberJoined(conversationEntity, qualifiedUserIds);\n        return {conversationEntity, messageEntity};\n      });\n  }\n\n  /**\n   * Members of a group conversation were removed or left.\n   *\n   * @param conversationEntity Conversation to remove users from\n   * @param eventJson JSON data of 'conversation.member-leave' event\n   * @returns Resolves when the event was handled\n   */\n  private async onMemberLeave(\n    conversationEntity: Conversation,\n    eventJson: ConversationMemberLeaveEvent | TeamMemberLeaveEvent,\n  ): Promise<{conversationEntity: Conversation; messageEntity: Message} | undefined> {\n    const {data: eventData, from} = eventJson;\n    const isFromSelf = from === this.userState.self().id;\n    const removesSelfUser = eventData.user_ids.includes(this.userState.self().id);\n    const selfLeavingClearedConversation = isFromSelf && removesSelfUser && conversationEntity.is_cleared();\n\n    if (removesSelfUser) {\n      conversationEntity.status(ConversationStatus.PAST_MEMBER);\n      this.leaveCall(conversationEntity.id);\n      if (this.userState.self().isTemporaryGuest()) {\n        eventJson.from = this.userState.self().id;\n      }\n    }\n\n    if (!selfLeavingClearedConversation) {\n      const {messageEntity} = await this.addEventToConversation(conversationEntity, eventJson);\n      (messageEntity as MemberMessage)\n        .userEntities()\n        .filter(userEntity => !userEntity.isMe)\n        .forEach(userEntity => {\n          conversationEntity.participating_user_ids.remove(userId => matchQualifiedIds(userId, userEntity));\n\n          if (userEntity.isTemporaryGuest()) {\n            userEntity.clearExpirationTimeout();\n          }\n        });\n\n      await this.updateParticipatingUserEntities(conversationEntity);\n\n      this.verificationStateHandler.onMemberLeft(conversationEntity);\n\n      if (isFromSelf && conversationEntity.removed_from_conversation()) {\n        this.archiveConversation(conversationEntity);\n      }\n\n      return {conversationEntity, messageEntity};\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Membership properties for a conversation were updated.\n   *\n   * @param conversationEntity Conversation entity that will be updated\n   * @param eventJson JSON data of 'conversation.member-update' event\n   * @returns Resolves when the event was handled\n   */\n  private onMemberUpdate(\n    conversationEntity: Conversation,\n    eventJson: Pick<ConversationMemberUpdateEvent, 'data' | 'from'> & {conversation?: string},\n  ) {\n    const {conversation, data: eventData, from} = eventJson;\n    const conversationId = {domain: '', id: conversation || '' /* TODO(federation) add domain on the sender side */};\n\n    const isConversationRoleUpdate = !!eventData.conversation_role;\n    if (isConversationRoleUpdate) {\n      const {target, qualified_target, conversation_role} = eventData;\n      const userId = qualified_target || {domain: '', id: target};\n      const conversation = this.conversationState\n        .conversations()\n        .find(conversation => matchQualifiedIds(conversation, conversationId));\n      if (conversation) {\n        const roles = conversation.roles();\n        roles[userId.id] = conversation_role;\n        conversation.roles(roles);\n      }\n      return;\n    }\n\n    const isBackendEvent = eventData.otr_archived_ref || eventData.otr_muted_ref;\n    const selfConversation = this.conversationState.self_conversation();\n    const inSelfConversation = selfConversation && matchQualifiedIds(selfConversation, conversationId);\n    if (!inSelfConversation && conversation && !isBackendEvent) {\n      throw new ConversationError(\n        ConversationError.TYPE.WRONG_CONVERSATION,\n        ConversationError.MESSAGE.WRONG_CONVERSATION,\n      );\n    }\n\n    const isFromSelf = !this.userState.self() || from === this.userState.self().id;\n    if (!isFromSelf) {\n      throw new ConversationError(ConversationError.TYPE.WRONG_USER, ConversationError.MESSAGE.WRONG_USER);\n    }\n\n    const isActiveConversation = this.conversationState.isActiveConversation(conversationEntity);\n    const nextConversationEntity = isActiveConversation ? this.getNextConversation(conversationEntity) : undefined;\n    const previouslyArchived = conversationEntity.is_archived();\n\n    ConversationMapper.updateSelfStatus(conversationEntity, eventData);\n\n    const wasUnarchived = previouslyArchived && !conversationEntity.is_archived();\n    if (wasUnarchived) {\n      return this.fetchUsersAndEvents(conversationEntity);\n    }\n\n    if (conversationEntity.is_cleared()) {\n      this._clearConversation(conversationEntity, conversationEntity.cleared_timestamp());\n    }\n\n    if (isActiveConversation && (conversationEntity.is_archived() || conversationEntity.is_cleared())) {\n      amplify.publish(WebAppEvents.CONVERSATION.SHOW, nextConversationEntity, {});\n    }\n  }\n\n  /**\n   * An asset received in a conversation.\n   *\n   * @param conversationEntity Conversation to add the event to\n   * @param event JSON data of 'conversation.asset-add'\n   * @returns Resolves when the event was handled\n   */\n  private async onAssetAdd(conversationEntity: Conversation, event: AssetAddEvent) {\n    const fromSelf = event.from === this.userState.self().id;\n\n    const isRemoteFailure = !fromSelf && event.data.status === AssetTransferState.UPLOAD_FAILED;\n    const isLocalCancel = fromSelf && event.data.reason === ProtobufAsset.NotUploaded.CANCELLED;\n\n    if (isRemoteFailure || isLocalCancel) {\n      /**\n       * WEBAPP-6916: An unsuccessful asset upload triggers a removal of the original asset message in the `EventRepository`.\n       * Thus the event timestamps need to get updated, so that the latest event timestamp is from the message which was send before the original message.\n       *\n       * Info: Since the `EventRepository` does not have a reference to the `ConversationRepository` we do that event update at this location.\n       * A more fitting place would be the `AssetTransferState.UPLOAD_FAILED` case in `EventRepository._handleAssetUpdate`.\n       *\n       * Our assumption is that the `_handleAssetUpdate` function (invoked by `notificationsQueue.subscribe`) is executed before this function.\n       */\n      return conversationEntity.updateTimestamps(conversationEntity.getLastMessage(), true);\n    }\n\n    if (!allowsAllFiles()) {\n      const fileName = event.data.info.name;\n      const contentType = event.data.content_type;\n      if (!isAllowedFile(fileName, contentType)) {\n        // TODO(Federation): Update code once sending assets is implemented on the backend\n        const user = await this.userRepository.getUserById({domain: '', id: event.from});\n        return this.injectFileTypeRestrictedMessage(\n          conversationEntity,\n          user,\n          true,\n          getFileExtensionOrName(fileName),\n          event.id,\n        );\n      }\n    }\n    const {messageEntity} = await this.addEventToConversation(conversationEntity, event);\n    const firstAsset = (messageEntity as ContentMessage).getFirstAsset();\n    if (firstAsset.isImage() || (firstAsset as FileAsset).status() === AssetTransferState.UPLOADED) {\n      return {conversationEntity, messageEntity};\n    }\n  }\n\n  /**\n   * A hide message received in a conversation.\n   *\n   * @param conversationEntity Conversation to add the event to\n   * @param eventJson JSON data of 'conversation.message-delete'\n   * @returns Resolves when the event was handled\n   */\n  private onMessageDeleted(conversationEntity: Conversation, eventJson: DeleteEvent) {\n    const {data: eventData, from, id: eventId, time} = eventJson;\n\n    return this.messageRepository\n      .getMessageInConversationById(conversationEntity, eventData.message_id)\n      .then(deletedMessageEntity => {\n        if (deletedMessageEntity.ephemeral_expires()) {\n          return;\n        }\n\n        const isSameSender = from === deletedMessageEntity.from;\n        if (!isSameSender) {\n          throw new ConversationError(ConversationError.TYPE.WRONG_USER, ConversationError.MESSAGE.WRONG_USER);\n        }\n\n        const isFromSelf = from === this.userState.self().id;\n        if (!isFromSelf) {\n          return this.addDeleteMessage(conversationEntity, eventId, time, deletedMessageEntity);\n        }\n      })\n      .then(() => {\n        return this.messageRepository.deleteMessageById(conversationEntity, eventData.message_id);\n      })\n      .catch(error => {\n        const isNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n        if (!isNotFound) {\n          this.logger.info(`Failed to delete message for conversation '${conversationEntity.id}'`, error);\n          throw error;\n        }\n      });\n  }\n\n  /**\n   * A hide message received in a conversation.\n   *\n   * @param eventJson JSON data of 'conversation.message-hidden'\n   * @returns Resolves when the event was handled\n   */\n  private async onMessageHidden(eventJson: MessageHiddenEvent) {\n    const {conversation: conversationId, data: eventData, from} = eventJson;\n\n    try {\n      const inSelfConversation =\n        !this.conversationState.self_conversation() || conversationId === this.conversationState.self_conversation().id;\n      if (!inSelfConversation) {\n        throw new ConversationError(\n          ConversationError.TYPE.WRONG_CONVERSATION,\n          ConversationError.MESSAGE.WRONG_CONVERSATION,\n        );\n      }\n\n      const isFromSelf = !this.userState.self() || from === this.userState.self().id;\n      if (!isFromSelf) {\n        throw new ConversationError(ConversationError.TYPE.WRONG_USER, ConversationError.MESSAGE.WRONG_USER);\n      }\n      const conversationEntity = await this.getConversationById({domain: '', id: eventData.conversation_id});\n      return await this.messageRepository.deleteMessageById(conversationEntity, eventData.message_id);\n    } catch (error) {\n      this.logger.info(\n        `Failed to delete message '${eventData.message_id}' for conversation '${eventData.conversation_id}'`,\n        error,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Someone reacted to a message.\n   *\n   * @param conversationEntity Conversation entity that a message was reacted upon in\n   * @param eventJson JSON data of 'conversation.reaction' event\n   * @returns Resolves when the event was handled\n   */\n  private async onReaction(conversationEntity: Conversation, eventJson: ReactionEvent) {\n    const conversationId = conversationEntity.id;\n    const eventData = eventJson.data;\n    const messageId = eventData.message_id;\n\n    try {\n      const messageEntity = await this.messageRepository.getMessageInConversationById(conversationEntity, messageId);\n      if (!messageEntity || !messageEntity.isContent()) {\n        const type = messageEntity ? messageEntity.type : 'unknown';\n\n        const logMessage = `Cannot react to '${type}' message '${messageId}' in conversation '${conversationId}'`;\n        this.logger.error(logMessage, messageEntity);\n        throw new ConversationError(ConversationError.TYPE.WRONG_TYPE, ConversationError.MESSAGE.WRONG_TYPE);\n      }\n\n      const changes = messageEntity.getUpdatedReactions(eventJson);\n      if (changes) {\n        const logMessage = `Updating reactions of message '${messageId}' in conversation '${conversationId}'`;\n        this.logger.debug(logMessage, {changes, event: eventJson});\n\n        this.eventService.updateEventSequentially(messageEntity.primary_key, changes);\n        return await this.prepareReactionNotification(conversationEntity, messageEntity, eventJson);\n      }\n    } catch (error) {\n      const isNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n      if (!isNotFound) {\n        const logMessage = `Failed to handle reaction to message '${messageId}' in conversation '${conversationId}'`;\n        this.logger.error(logMessage, {error, event: eventJson});\n        throw error;\n      }\n    }\n    return undefined;\n  }\n\n  private async onButtonActionConfirmation(conversationEntity: Conversation, eventJson: ButtonActionConfirmationEvent) {\n    const {messageId, buttonId} = eventJson.data;\n    try {\n      const messageEntity = await this.messageRepository.getMessageInConversationById(conversationEntity, messageId);\n      if (!messageEntity || !messageEntity.isComposite()) {\n        const type = messageEntity ? messageEntity.type : 'unknown';\n\n        const log = `Cannot react to '${type}' message '${messageId}' in conversation '${conversationEntity.id}'`;\n        this.logger.error(log, messageEntity);\n        throw new ConversationError(ConversationError.TYPE.WRONG_TYPE, ConversationError.MESSAGE.WRONG_TYPE);\n      }\n      const changes = messageEntity.getSelectionChange(buttonId);\n      if (changes) {\n        this.eventService.updateEventSequentially(messageEntity.primary_key, changes);\n      }\n      return;\n    } catch (error) {\n      const isNotFound = error.type === ConversationError.TYPE.MESSAGE_NOT_FOUND;\n      if (!isNotFound) {\n        const log = `Failed to handle reaction to message '${messageId}' in conversation '${conversationEntity.id}'`;\n        this.logger.error(log, {error, event: eventJson});\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * A conversation was renamed.\n   *\n   * @param conversationEntity Conversation entity that will be renamed\n   * @param eventJson JSON data of 'conversation.rename' event\n   * @returns Resolves when the event was handled\n   */\n  private async onRename(conversationEntity: Conversation, eventJson: ConversationRenameEvent, isWebSocket = false) {\n    if (isWebSocket && eventJson.data?.name) {\n      eventJson.data.name = fixWebsocketString(eventJson.data.name);\n    }\n    const {messageEntity} = await this.addEventToConversation(conversationEntity, eventJson);\n    ConversationMapper.updateProperties(conversationEntity, eventJson.data);\n    return {conversationEntity, messageEntity};\n  }\n\n  /**\n   * A conversation receipt mode was changed\n   *\n   * @param conversationEntity Conversation entity that will be renamed\n   * @param eventJson JSON data of 'conversation.receipt-mode-update' event\n   * @returns Resolves when the event was handled\n   */\n  private async onReceiptModeChanged(conversationEntity: Conversation, eventJson: ConversationReceiptModeUpdateEvent) {\n    const {messageEntity} = await this.addEventToConversation(conversationEntity, eventJson);\n    ConversationMapper.updateSelfStatus(conversationEntity, {receipt_mode: eventJson.data.receipt_mode});\n    return {conversationEntity, messageEntity};\n  }\n\n  private readonly handleMessageExpiration = (messageEntity: ContentMessage) => {\n    amplify.publish(WebAppEvents.CONVERSATION.EPHEMERAL_MESSAGE_TIMEOUT, messageEntity);\n    const shouldDeleteMessage = !messageEntity.user().isMe || messageEntity.isPing();\n    if (shouldDeleteMessage) {\n      // TODO(federation) map domain\n      this.getConversationById({domain: '', id: messageEntity.conversation_id}).then(conversationEntity => {\n        const isPingFromSelf = messageEntity.user().isMe && messageEntity.isPing();\n        const deleteForSelf = isPingFromSelf || conversationEntity.removed_from_conversation();\n        if (deleteForSelf) {\n          return this.messageRepository.deleteMessage(conversationEntity, messageEntity);\n        }\n\n        const userIds = conversationEntity.isGroup() ? [this.userState.self().id, messageEntity.from] : undefined;\n        return this.messageRepository.deleteMessageForEveryone(conversationEntity, messageEntity, userIds);\n      });\n    }\n  };\n\n  private async initMessageEntity(conversationEntity: Conversation, eventJson: IncomingEvent): Promise<Message> {\n    const messageEntity = await this.event_mapper.mapJsonEvent(eventJson, conversationEntity);\n    return this.updateMessageUserEntities(messageEntity);\n  }\n\n  private async replaceMessageInConversation(\n    conversationEntity: Conversation,\n    eventId: string,\n    newData: EventRecord,\n  ): Promise<ContentMessage | undefined> {\n    const originalMessage = conversationEntity.getMessage(eventId);\n    if (!originalMessage) {\n      return undefined;\n    }\n    const replacedMessageEntity = await this.event_mapper.updateMessageEvent(\n      originalMessage as ContentMessage,\n      newData,\n    );\n    await this.ephemeralHandler.validateMessage(replacedMessageEntity);\n    return replacedMessageEntity;\n  }\n\n  /**\n   * Convert a JSON event into an entity and add it to a given conversation.\n   *\n   * @param conversationEntity Conversation entity the event will be added to\n   * @param eventJson Event data\n   * @returns Promise that resolves with the message entity for the event\n   */\n  private async addEventToConversation(\n    conversationEntity: Conversation,\n    eventJson: IncomingEvent,\n  ): Promise<{conversationEntity: Conversation; messageEntity: Message}> {\n    const messageEntity = (await this.initMessageEntity(conversationEntity, eventJson)) as Message;\n    if (conversationEntity && messageEntity) {\n      const wasAdded = conversationEntity.addMessage(messageEntity);\n      if (wasAdded) {\n        await this.ephemeralHandler.validateMessage(messageEntity as ContentMessage);\n      }\n    }\n    return {conversationEntity, messageEntity};\n  }\n\n  /**\n   * Convert multiple JSON events into entities and validate them\n   *\n   * @param events Event data\n   * @param conversationEntity Conversation entity the events will be added to\n   * @returns Resolves with an array of mapped messages\n   */\n  private async validateMessages(events: EventRecord[], conversationEntity: Conversation) {\n    const mappedEvents = await this.event_mapper.mapJsonEvents(events, conversationEntity);\n    const updatedEvents = (await this.updateMessagesUserEntities(mappedEvents)) as ContentMessage[];\n    const validatedMessages = (await this.ephemeralHandler.validateMessages(updatedEvents)) as ContentMessage[];\n    return validatedMessages;\n  }\n\n  /**\n   * Convert multiple JSON events into entities, validate and add them to a given conversation.\n   *\n   * @param events Event data\n   * @param conversationEntity Conversation entity the events will be added to\n   * @param prepend Should existing messages be prepended\n   * @returns Resolves with an array of mapped messages\n   */\n  private async addEventsToConversation(events: EventRecord[], conversationEntity: Conversation, prepend = true) {\n    const validatedMessages = await this.validateMessages(events, conversationEntity);\n    if (prepend && conversationEntity.messages().length) {\n      conversationEntity.prependMessages(validatedMessages);\n    } else {\n      conversationEntity.addMessages(validatedMessages);\n    }\n    return validatedMessages;\n  }\n\n  /**\n   * Fetch all unread events and users of a conversation.\n   *\n   * @param conversationEntity Conversation fetch events and users for\n   */\n  private fetchUsersAndEvents(conversationEntity: Conversation) {\n    if (!conversationEntity.is_loaded() && !conversationEntity.is_pending()) {\n      this.updateParticipatingUserEntities(conversationEntity);\n      this.getUnreadEvents(conversationEntity);\n    }\n  }\n\n  /**\n   * Forward the reaction event to the Notification repository for browser and audio notifications.\n   *\n   * @param conversationEntity Conversation that event was received in\n   * @param messageEntity Message that has been reacted upon\n   * @param eventJson JSON data of received reaction event\n   * @returns Resolves when the notification was prepared\n   */\n  private async prepareReactionNotification(\n    conversationEntity: Conversation,\n    messageEntity: ContentMessage,\n    eventJson: ReactionEvent,\n  ) {\n    const {data: event_data, from} = eventJson;\n\n    const messageFromSelf = messageEntity.from === this.userState.self().id;\n    if (messageFromSelf && event_data.reaction) {\n      const userEntity = await this.userRepository.getUserById({domain: messageEntity.fromDomain, id: from});\n      const reactionMessageEntity = new Message(messageEntity.id, SuperType.REACTION);\n      reactionMessageEntity.user(userEntity);\n      reactionMessageEntity.reaction = event_data.reaction;\n      return {conversationEntity, messageEntity: reactionMessageEntity};\n    }\n\n    return {conversationEntity};\n  }\n\n  private updateMessagesUserEntities(messageEntities: Message[]) {\n    return Promise.all(messageEntities.map(messageEntity => this.updateMessageUserEntities(messageEntity)));\n  }\n\n  /**\n   * Updates the user entities that are part of a message.\n   *\n   * @param messageEntity Message to be updated\n   * @returns Resolves when users have been update\n   */\n  private async updateMessageUserEntities(messageEntity: Message) {\n    const userEntity = await this.userRepository.getUserById({\n      domain: messageEntity.fromDomain,\n      id: messageEntity.from,\n    });\n    messageEntity.user(userEntity);\n    const isMemberMessage = messageEntity.isMember();\n    if (isMemberMessage || messageEntity.hasOwnProperty('userEntities')) {\n      return this.userRepository.getUsersById((messageEntity as MemberMessage).userIds()).then(userEntities => {\n        userEntities.sort(sortUsersByPriority);\n        (messageEntity as MemberMessage).userEntities(userEntities);\n        return messageEntity;\n      });\n    }\n    if (messageEntity.isContent()) {\n      const userIds = Object.keys(messageEntity.reactions());\n\n      messageEntity.reactions_user_ets.removeAll();\n      if (userIds.length) {\n        // TODO(Federation): Make code federation-aware.\n        return this.userRepository\n          .getUsersById(userIds.map(userId => ({domain: '', id: userId})))\n          .then(userEntities => {\n            messageEntity.reactions_user_ets(userEntities);\n            return messageEntity;\n          });\n      }\n    }\n    return messageEntity;\n  }\n\n  /**\n   * Delete messages from UI and database.\n   *\n   * @param conversationEntity Conversation that contains the message\n   * @param timestamp Timestamp as upper bound which messages to remove\n   */\n  private deleteMessages(conversationEntity: Conversation, timestamp: number) {\n    conversationEntity.hasCreationMessage = false;\n\n    const iso_date = timestamp ? new Date(timestamp).toISOString() : undefined;\n    this.eventService.deleteEvents(conversationEntity.id, iso_date);\n  }\n\n  /**\n   * Add delete message to conversation.\n   *\n   * @param conversationId ID of conversation\n   * @param messageId ID of message\n   * @param time ISO 8601 formatted time string\n   * @param messageEntity Message to delete\n   */\n  public addDeleteMessage(conversation: Conversation, messageId: string, time: string, messageEntity: Message) {\n    const deleteEvent = EventBuilder.buildDelete(conversation, messageId, time, messageEntity);\n    this.eventRepository.injectEvent(deleteEvent);\n  }\n\n  //##############################################################################\n  // Message updates\n  //##############################################################################\n\n  expectReadReceipt(conversationEntity: Conversation): boolean {\n    if (conversationEntity.is1to1()) {\n      return !!this.propertyRepository.receiptMode();\n    }\n\n    if (conversationEntity.team_id && conversationEntity.isGroup()) {\n      return !!conversationEntity.receiptMode();\n    }\n\n    return false;\n  }\n\n  public async cleanupEphemeralMessages(): Promise<void> {\n    this.conversationState.conversations().forEach(async conversationEntity => {\n      const messages = (await this.eventService.loadEphemeralEvents(conversationEntity.id)) as EventRecord[];\n      this.validateMessages(messages, conversationEntity);\n    });\n  }\n}\n", "/*\n * Wire\n * Copyright (C) 2018 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport type {\n  CONVERSATION_ACCESS,\n  CONVERSATION_ACCESS_ROLE,\n  ClientMismatch,\n  Conversation as BackendConversation,\n  ConversationCode,\n  NewConversation,\n  NewOTRMessage,\n} from '@wireapp/api-client/src/conversation';\nimport type {\n  ConversationMemberUpdateData,\n  ConversationOtherMemberUpdateData,\n  ConversationReceiptModeUpdateData,\n  ConversationJoinData,\n} from '@wireapp/api-client/src/conversation/data';\nimport type {\n  ConversationCodeDeleteEvent,\n  ConversationCodeUpdateEvent,\n  ConversationEvent,\n  ConversationMemberJoinEvent,\n  ConversationMemberLeaveEvent,\n  ConversationMessageTimerUpdateEvent,\n  ConversationReceiptModeUpdateEvent,\n  ConversationRenameEvent,\n} from '@wireapp/api-client/src/event';\nimport {container} from 'tsyringe';\n\nimport {Logger, getLogger} from 'Util/Logger';\n\nimport type {Conversation as ConversationEntity} from '../entity/Conversation';\nimport type {EventService} from '../event/EventService';\nimport {MessageCategory} from '../message/MessageCategory';\nimport {search as fullTextSearch} from '../search/FullTextSearch';\nimport {StorageService} from '../storage';\nimport {StorageSchemata} from '../storage/StorageSchemata';\nimport {APIClient} from '../service/APIClientSingleton';\nimport {ConversationRecord} from '../storage/record/ConversationRecord';\nimport {Config} from '../Config';\nimport {QualifiedId} from '@wireapp/api-client/src/user';\n\nfunction isFederatedEnv() {\n  return Config.getConfig().FEATURE.ENABLE_FEDERATION;\n}\nexport class ConversationService {\n  private readonly eventService: EventService;\n  private readonly logger: Logger;\n\n  constructor(\n    eventService: EventService,\n    private readonly storageService = container.resolve(StorageService),\n    private readonly apiClient = container.resolve(APIClient),\n  ) {\n    this.eventService = eventService;\n    this.logger = getLogger('ConversationService');\n  }\n\n  //##############################################################################\n  // Create conversations\n  //##############################################################################\n\n  /**\n   * Create a group conversation.\n   *\n   * @note Do not include yourself as the requestor\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createGroupConversation\n   *\n   * @param payload Payload object for group creation\n   * @returns Resolves when the conversation was created\n   */\n  postConversations(payload: NewConversation): Promise<BackendConversation> {\n    return this.apiClient.conversation.api.postConversation(payload);\n  }\n\n  //##############################################################################\n  // Get conversations\n  //##############################################################################\n\n  /**\n   * Retrieves all the conversations of a user.\n   * @returns Resolves with the conversation information\n   */\n  async getAllConversations(): Promise<BackendConversation[]> {\n    const conversationApi = this.apiClient.conversation.api;\n    return isFederatedEnv() ? conversationApi.getConversationList() : conversationApi.getAllConversations();\n  }\n\n  /**\n   * Get a conversation by ID.\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/conversation\n   */\n  getConversationById({id, domain}: QualifiedId): Promise<BackendConversation> {\n    return isFederatedEnv()\n      ? this.apiClient.conversation.api.getConversation({domain, id}, true)\n      : this.apiClient.conversation.api.getConversation(id);\n  }\n\n  /**\n   * Update the conversation name.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversation\n   *\n   * @param conversationId ID of conversation to rename\n   * @param name new name of the conversation\n   * @returns Resolves with the server response\n   */\n  updateConversationName(conversationId: string, name: string): Promise<ConversationRenameEvent> {\n    return this.apiClient.conversation.api.putConversation(conversationId, {\n      name,\n    });\n  }\n\n  /**\n   * Update the conversation message timer value.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationMessageTimer\n   *\n   * @param conversationId ID of conversation to rename\n   * @param messageTimer new message timer of the conversation\n   * @returns Resolves with the server response\n   */\n  updateConversationMessageTimer(\n    conversationId: string,\n    message_timer: number,\n  ): Promise<ConversationMessageTimerUpdateEvent> {\n    return this.apiClient.conversation.api.putConversationMessageTimer(conversationId, {message_timer});\n  }\n\n  /**\n   * Update the conversation message timer value.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationMessageTimer\n   *\n   * @param conversationId ID of conversation to rename\n   * @param receiptMode new receipt mode\n   * @returns Resolves with the server response\n   */\n  updateConversationReceiptMode(\n    conversationId: string,\n    receiptMode: ConversationReceiptModeUpdateData,\n  ): Promise<ConversationReceiptModeUpdateEvent> {\n    return this.apiClient.conversation.api.putConversationReceiptMode(conversationId, receiptMode);\n  }\n\n  /**\n   * Update self membership properties.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateSelf\n   *\n   * @param conversation_id ID of conversation to update\n   * @param payload Updated properties\n   * @returns Resolves with the server response\n   */\n  updateMemberProperties(conversationId: string, payload: Partial<ConversationMemberUpdateData>): Promise<void> {\n    return this.apiClient.conversation.api.putMembershipProperties(conversationId, payload);\n  }\n\n  //##############################################################################\n  // Conversation access\n  //##############################################################################\n\n  /**\n   * Delete the conversation access code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/deleteConversationCode\n   * @param conversationId ID of conversation to delete access code for\n   * @returns Resolves with the server response\n   */\n  deleteConversationCode(conversationId: string): Promise<ConversationCodeDeleteEvent> {\n    return this.apiClient.conversation.api.deleteConversationCode(conversationId);\n  }\n\n  /**\n   * Get the conversation access code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/getConversationCode\n   * @param conversationId ID of conversation to get access code for\n   * @returns Resolves with the server response\n   */\n  getConversationCode(conversationId: string): Promise<ConversationCode> {\n    return this.apiClient.conversation.api.getConversationCode(conversationId);\n  }\n\n  /**\n   * Request a conversation access code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/createConversationCode\n   * @param conversationId ID of conversation to request access code for\n   * @returns Resolves with the server response\n   */\n  postConversationCode(conversationId: string): Promise<ConversationCodeUpdateEvent> {\n    return this.apiClient.conversation.api.postConversationCodeRequest(conversationId);\n  }\n\n  /**\n   * Join a conversation using a code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/joinConversationByCode\n   * @param key Conversation identifier\n   * @param code Conversation access code\n   * @returns Resolves with the server response\n   */\n  postConversationJoin(key: string, code: string): Promise<ConversationMemberJoinEvent> {\n    return this.apiClient.conversation.api.postJoinByCode({code, key});\n  }\n\n  /**\n   * Join a conversation using a code.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/joinConversationByCode\n   * @param key Conversation identifier\n   * @param code Conversation access code\n   * @returns Resolves with the server response\n   */\n  getConversationJoin(key: string, code: string): Promise<ConversationJoinData> {\n    return this.apiClient.conversation.api.getJoinByCode({code, key});\n  }\n\n  /**\n   * Update conversation access mode.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/updateConversationAccess\n   *\n   * @param conversationId ID of conversation\n   * @param accessModes Conversation access mode\n   * @param accessRole Conversation access role\n   * @returns Resolves with the server response\n   */\n  putConversationAccess(\n    conversationId: string,\n    accessModes: CONVERSATION_ACCESS[],\n    accessRole: CONVERSATION_ACCESS_ROLE,\n  ): Promise<ConversationEvent> {\n    return this.apiClient.conversation.api.putAccess(conversationId, {\n      access: accessModes,\n      access_role: accessRole,\n    });\n  }\n\n  //##############################################################################\n  // Send events\n  //##############################################################################\n\n  /**\n   * Remove service from conversation.\n   *\n   * @param conversationId ID of conversation to remove service from\n   * @param userId ID of service to be removed from the the conversation\n   * @returns Resolves with the server response\n   */\n  deleteBots(conversationId: string, userId: string): Promise<void> {\n    return this.apiClient.conversation.api.deleteBot(conversationId, userId);\n  }\n\n  /**\n   * Remove member from conversation.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/removeMember\n   *\n   * @param conversationId ID of conversation to remove member from\n   * @param userId ID of member to be removed from the the conversation\n   * @returns Resolves with the server response\n   */\n  deleteMembers(conversationId: string, userId: string): Promise<ConversationMemberLeaveEvent> {\n    return this.apiClient.conversation.api.deleteMember(conversationId, userId);\n  }\n\n  /**\n   * Remove member from federated conversation.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/removeMember\n   *\n   * @param conversationId Qualified ID of conversation to remove member from\n   * @param userId Qualified ID of member to be removed from the the conversation\n   * @returns Resolves with the server response\n   */\n  deleteQualifiedMembers(conversationId: QualifiedId, userId: QualifiedId): Promise<ConversationMemberLeaveEvent> {\n    return this.apiClient.conversation.api.deleteQualifiedMember(conversationId, userId);\n  }\n\n  putMembers(conversationId: string, userId: string, data: ConversationOtherMemberUpdateData): Promise<void> {\n    return this.apiClient.conversation.api.putOtherMember(userId, conversationId, data);\n  }\n\n  deleteConversation(teamId: string, conversationId: string): Promise<void> {\n    return this.apiClient.teams.conversation.api.deleteConversation(teamId, conversationId);\n  }\n\n  /**\n   * Add a service to an existing conversation.\n   *\n   * @param conversationId ID of conversation to add users to\n   * @param providerId ID of service provider\n   * @param serviceId ID of service\n   * @returns Resolves with the server response\n   */\n  postBots(conversationId: string, providerId: string, serviceId: string): Promise<ConversationMemberJoinEvent> {\n    return this.apiClient.conversation.api.postBot(conversationId, providerId, serviceId);\n  }\n\n  /**\n   * Post an encrypted message to a conversation.\n   *\n   * @note If \"recipients\" are not specified you will receive a list of all missing OTR recipients (user-client-map).\n   * @note Options for the precondition check on missing clients are:\n   * - `false` - all clients\n   * - `Array<string>` - only clients of listed users\n   * - `true` - force sending\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/postOtrMessage\n   * @example How to send \"recipients\" payload\n   * \"recipients\": {\n   *   \"<user-id>\": {\n   *     \"<client-id>\": \"<base64-encoded-encrypted-content>\"\n   *   }\n   * }\n   *\n   * @param conversationId ID of conversation to send message in\n   * @param payload Payload to be posted\n   * @returns Promise that resolves when the message was sent\n   */\n  postEncryptedMessage(\n    conversationId: QualifiedId,\n    payload: NewOTRMessage<string>,\n    preconditionOption?: boolean | string[],\n  ): Promise<ClientMismatch> {\n    const reportMissing = Array.isArray(preconditionOption) ? preconditionOption : undefined;\n    const ignoreMissing = preconditionOption === true ? true : undefined;\n\n    if (reportMissing) {\n      payload.report_missing = reportMissing;\n    }\n\n    // TODO(federation): add domain in the postOTRMessage (?)\n    return this.apiClient.conversation.api.postOTRMessage(payload.sender, conversationId.id, payload, ignoreMissing);\n  }\n\n  /**\n   * Add users to an existing conversation.\n   *\n   * @see https://staging-nginz-https.zinfra.io/swagger-ui/#!/conversations/addMembers\n   *\n   * @param conversationId ID of conversation to add users to\n   * @param userIds IDs of users to be added to the conversation\n   * @returns Resolves with the server response\n   */\n  postMembers(\n    conversationId: string,\n    userIds: QualifiedId[],\n    useFederation: boolean,\n  ): Promise<ConversationMemberJoinEvent> {\n    return useFederation\n      ? this.apiClient.conversation.api.postMembersV2(conversationId, userIds)\n      : this.apiClient.conversation.api.postMembers(\n          conversationId,\n          userIds.map(({id}) => id),\n        );\n  }\n\n  //##############################################################################\n  // Database interactions\n  //##############################################################################\n\n  /**\n   * Deletes a conversation entity from the local database.\n   * @returns Resolves when the entity was deleted\n   */\n  async deleteConversationFromDb({id, domain}: QualifiedId): Promise<string> {\n    const key = domain ? `${id}@${domain}` : id;\n    const primaryKey = await this.storageService.delete(StorageSchemata.OBJECT_STORE.CONVERSATIONS, key);\n    return primaryKey;\n  }\n\n  loadConversation<T>(conversationId: string): Promise<T> {\n    return this.storageService.load(StorageSchemata.OBJECT_STORE.CONVERSATIONS, conversationId);\n  }\n\n  /**\n   * Get active conversations from database.\n   * @returns Resolves with active conversations\n   */\n  async getActiveConversationsFromDb(): Promise<QualifiedId[]> {\n    const min_date = new Date();\n    min_date.setDate(min_date.getDate() - 30);\n\n    let events;\n\n    if (this.storageService.db) {\n      events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where('time')\n        .aboveOrEqual(min_date.toISOString())\n        .toArray();\n    } else {\n      const records = await this.storageService.getAll<{time: number}>(StorageSchemata.OBJECT_STORE.EVENTS);\n      events = records\n        .filter(record => record.time.toString() >= min_date.toISOString())\n        .sort((a, b) => a.time - b.time);\n    }\n\n    const conversations = events.reduce((accumulated, event) => {\n      // TODO(federation): generate fully qualified ids\n      accumulated[event.conversation] = (accumulated[event.conversation] || 0) + 1;\n      return accumulated;\n    }, {});\n\n    return Object.keys(conversations)\n      .sort((id_a, id_b) => conversations[id_b] - conversations[id_a])\n      .map(id => ({domain: '', id}));\n  }\n\n  /**\n   * Loads conversation states from the local database.\n   * @returns Resolves with all the stored conversation states\n   */\n  loadConversationStatesFromDb<T>(): Promise<T[]> {\n    return this.storageService.getAll(StorageSchemata.OBJECT_STORE.CONVERSATIONS);\n  }\n\n  /**\n   * Saves a list of conversation records in the local database.\n   * @param conversations Conversation entity\n   * @returns Resolves with a list of conversation records\n   */\n  async saveConversationsInDb(conversations: ConversationRecord[]): Promise<ConversationRecord[]> {\n    if (this.storageService.db) {\n      const keys = conversations.map(conversation => conversation.id);\n      await this.storageService.db.table(StorageSchemata.OBJECT_STORE.CONVERSATIONS).bulkPut(conversations, keys);\n    } else {\n      for (const conversation of conversations) {\n        await this.storageService.save(StorageSchemata.OBJECT_STORE.CONVERSATIONS, conversation.id, conversation);\n      }\n    }\n\n    return conversations;\n  }\n\n  /**\n   * Saves a conversation entity in the local database.\n   * @param conversation_et Conversation entity\n   * @returns Resolves with the conversation entity\n   */\n  saveConversationStateInDb(conversation_et: ConversationEntity): Promise<ConversationEntity> {\n    const conversationData = conversation_et.serialize();\n\n    return this.storageService\n      .save(StorageSchemata.OBJECT_STORE.CONVERSATIONS, conversation_et.id, conversationData)\n      .then(primary_key => {\n        this.logger.info(`State of conversation '${primary_key}' was stored`, conversationData);\n        return conversation_et;\n      });\n  }\n\n  /**\n   * Search for text in given conversation.\n   *\n   * @param conversation_id ID of conversation to add users to\n   * @param query will be checked in against all text messages\n   * @returns Resolves with the matching events\n   */\n  async searchInConversation(conversation_id: string, query: string): Promise<any> {\n    const category_min = MessageCategory.TEXT;\n    const category_max = MessageCategory.TEXT | MessageCategory.LINK | MessageCategory.LINK_PREVIEW;\n\n    const events = await this.eventService.loadEventsWithCategory(conversation_id, category_min, category_max);\n    return events\n      .filter(record => record.ephemeral_expires !== true)\n      .filter(({data: event_data}: any) => fullTextSearch(event_data.content, query));\n  }\n}\n", "/*\n * Wire\n * Copyright (C) 2018 Wire Swiss GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see http://www.gnu.org/licenses/.\n *\n */\n\nimport type {Dexie} from 'dexie';\nimport {container} from 'tsyringe';\nimport {Asset as ProtobufAsset} from '@wireapp/protocol-messaging';\n\nimport {getLogger, Logger} from 'Util/Logger';\n\nimport {StatusType} from '../message/StatusType';\nimport {MessageCategory} from '../message/MessageCategory';\nimport {categoryFromEvent} from '../message/MessageCategorization';\n\nimport {AssetTransferState} from '../assets/AssetTransferState';\nimport {StorageSchemata} from '../storage/StorageSchemata';\n\nimport {BaseError, BASE_ERROR_TYPE} from '../error/BaseError';\nimport {ConversationError} from '../error/ConversationError';\nimport {StorageError} from '../error/StorageError';\nimport {StorageService, DatabaseListenerCallback, EventRecord} from '../storage';\nimport {AssetData} from '../cryptography/CryptographyMapper';\n\nexport type Includes = {includeFrom: boolean; includeTo: boolean};\ntype DexieCollection = Dexie.Collection<any, any>;\nexport type DBEvents = DexieCollection | EventRecord[];\n\nexport const eventTimeToDate = (time: string) => new Date(time) || new Date(parseInt(time, 10));\n\nexport const compareEventsByConversation = (eventA: EventRecord, eventB: EventRecord) =>\n  eventA.conversation.localeCompare(eventB.conversation);\n\nexport const compareEventsById = (eventA: EventRecord, eventB: EventRecord) => eventA.id.localeCompare(eventB.id);\nexport const compareEventsByTime = (eventA: EventRecord, eventB: EventRecord) =>\n  eventTimeToDate(eventA.time).getTime() - eventTimeToDate(eventB.time).getTime();\n\n/** Handles all databases interactions related to events */\nexport class EventService {\n  logger: Logger;\n\n  constructor(public readonly storageService = container.resolve(StorageService)) {\n    this.logger = getLogger('EventService');\n  }\n\n  async loadEvents(conversationId: string, eventIds: string[]): Promise<EventRecord[]> {\n    if (!conversationId || !eventIds) {\n      this.logger.error(`Cannot get events '${eventIds}' in conversation '${conversationId}' without IDs`);\n      throw new ConversationError(BASE_ERROR_TYPE.MISSING_PARAMETER, BaseError.MESSAGE.MISSING_PARAMETER);\n    }\n\n    try {\n      if (this.storageService.db) {\n        const events = await this.storageService.db\n          .table(StorageSchemata.OBJECT_STORE.EVENTS)\n          .where('id')\n          .anyOf(eventIds)\n          .filter(record => record.conversation === conversationId)\n          .toArray();\n        return events;\n      }\n\n      const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n      return records\n        .filter(record => record.conversation === conversationId && eventIds.includes(record.id))\n        .sort(compareEventsById);\n    } catch (error) {\n      const logMessage = `Failed to get events '${eventIds.join(',')}' for conversation '${conversationId}': ${\n        error.message\n      }`;\n      this.logger.error(logMessage, error);\n      throw error;\n    }\n  }\n\n  async loadEphemeralEvents(conversationId: string): Promise<EventRecord[]> {\n    if (!conversationId) {\n      this.logger.error(`Cannot get ephemeral events in conversation '${conversationId}' without ID`);\n      throw new ConversationError(BASE_ERROR_TYPE.MISSING_PARAMETER, BaseError.MESSAGE.MISSING_PARAMETER);\n    }\n\n    try {\n      if (this.storageService.db) {\n        const events = await this.storageService.db\n          .table(StorageSchemata.OBJECT_STORE.EVENTS)\n          .where('conversation')\n          .equals(conversationId)\n          .and(record => !!record.ephemeral_expires)\n          .toArray();\n        return events;\n      }\n\n      const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n      return records\n        .filter(record => record.conversation === conversationId && !!record.ephemeral_expires)\n        .sort(compareEventsById);\n    } catch (error) {\n      const logMessage = `Failed to get ephemeral events for conversation '${conversationId}': ${error.message}`;\n      this.logger.error(logMessage, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load event from database.\n   *\n   * @param conversationId ID of conversation\n   * @param eventId ID of event to retrieve\n   */\n  async loadEvent(conversationId: string, eventId: string): Promise<EventRecord> {\n    if (!conversationId || !eventId) {\n      this.logger.error(`Cannot get event '${eventId}' in conversation '${conversationId}' without IDs`);\n      throw new ConversationError(BASE_ERROR_TYPE.MISSING_PARAMETER, BaseError.MESSAGE.MISSING_PARAMETER);\n    }\n\n    try {\n      if (this.storageService.db) {\n        const entry = await this.storageService.db\n          .table(StorageSchemata.OBJECT_STORE.EVENTS)\n          .where('id')\n          .equals(eventId)\n          .filter(record => record.conversation === conversationId)\n          .first();\n        return entry;\n      }\n\n      const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n      return records\n        .filter(record => record.id === eventId && record.conversation === conversationId)\n        .sort(compareEventsById)\n        .shift();\n    } catch (error) {\n      const logMessage = `Failed to get event '${eventId}' for conversation '${conversationId}': ${error.message}`;\n      this.logger.error(logMessage, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load all events matching a minimum category from the database.\n   *\n   * @param conversationId ID of conversation to add users to\n   * @param categoryMin Minimum message category\n   * @param categoryMax Maximum message category\n   */\n  async loadEventsWithCategory(\n    conversationId: string,\n    categoryMin: MessageCategory,\n    categoryMax = MessageCategory.LIKED,\n  ): Promise<DBEvents> {\n    const filterExpired = (record: EventRecord) => {\n      if (typeof record.ephemeral_expires !== 'undefined') {\n        return +record.ephemeral_expires - Date.now() > 0;\n      }\n\n      return true;\n    };\n\n    if (this.storageService.db) {\n      const events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where('[conversation+category]')\n        .between([conversationId, categoryMin], [conversationId, categoryMax], true, true)\n        .and(filterExpired)\n        .sortBy('time');\n      return events;\n    }\n\n    const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n    return records\n      .filter(\n        record =>\n          record.conversation === conversationId && record.category >= categoryMin && record.category <= categoryMax,\n      )\n      .filter(filterExpired)\n      .sort(compareEventsByTime);\n  }\n\n  async loadEventsReplyingToMessage(conversationId: string, quotedMessageId: string, quotedMessageTime: string) {\n    if (this.storageService.db) {\n      const events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where(['conversation', 'time'])\n        .between([conversationId, quotedMessageTime], [conversationId, new Date().toISOString()], true, true)\n        .filter(event => event.data && event.data.quote && event.data.quote.message_id === quotedMessageId)\n        .toArray();\n      return events;\n    }\n\n    const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n    return records\n      .filter(record => {\n        return (\n          record.conversation === conversationId &&\n          record.time >= quotedMessageTime &&\n          record.time <= new Date().toISOString()\n        );\n      })\n      .filter(event => !!event.data && !!event.data.quote && event.data.quote.message_id === quotedMessageId)\n      .sort(compareEventsByConversation);\n  }\n\n  /**\n   * Load events starting from the fromDate going back in history until either limit or toDate is reached.\n   *\n   * @param conversationId ID of conversation\n   * @param fromDate Load from this date (included)\n   * @param toDate Load until this date (excluded)\n   * @param limit Amount of events to load\n   */\n  async loadPrecedingEvents(\n    conversationId: string,\n    fromDate = new Date(0),\n    toDate = new Date(),\n    limit = Number.MAX_SAFE_INTEGER,\n  ): Promise<DBEvents> {\n    const includeParams = {\n      includeFrom: true,\n      includeTo: false,\n    };\n\n    try {\n      const events = await this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams);\n      return this.storageService.db\n        ? await (events as Dexie.Collection<any, any>).reverse().sortBy('time')\n        : (events as EventRecord[]).reverse().sort(compareEventsByTime);\n    } catch (error) {\n      const message = `Failed to load events for conversation '${conversationId}' from database: '${error.message}'`;\n      this.logger.error(message);\n      throw error;\n    }\n  }\n\n  /**\n   * Load events starting from the fromDate to the present until the limit is reached.\n   *\n   * @param conversationId ID of conversation\n   * @param fromDate Load until this date (excluded)\n   * @param limit Amount of events to load\n   * @param includeFrom Should upper bound be part of the messages\n   */\n  async loadFollowingEvents(\n    conversationId: string,\n    fromDate: Date,\n    limit = Number.MAX_SAFE_INTEGER,\n    includeFrom = true,\n  ): Promise<DBEvents> {\n    const includeParams = {\n      includeFrom,\n      includeTo: true,\n    };\n    if (!(fromDate instanceof Date)) {\n      const errorMessage = `fromDate ('${typeof fromDate}') must be of type 'Date'.`;\n      throw new Error(errorMessage);\n    }\n    const toDate = new Date(Math.max(fromDate.getTime() + 1, Date.now()));\n\n    const events = await this._loadEventsInDateRange(conversationId, fromDate, toDate, limit, includeParams);\n    return this.storageService.db\n      ? (events as DexieCollection).sortBy('time')\n      : (events as EventRecord[]).sort(compareEventsByTime);\n  }\n\n  /**\n   *\n   * @param conversationId The conversation ID\n   * @param fromDate The lower date bound\n   * @param toDate The upper date bound\n   * @param limit The events limit\n   * @param includes If from and to should be included\n   */\n  async _loadEventsInDateRange(\n    conversationId: string,\n    fromDate: Date,\n    toDate: Date,\n    limit: number,\n    includes: Includes,\n  ): Promise<DBEvents> {\n    const {includeFrom, includeTo} = includes;\n    if (!(toDate instanceof Date) || !(fromDate instanceof Date)) {\n      const errorMessage = `Lower bound (${typeof toDate}) and upper bound (${typeof fromDate}) must be of type 'Date'.`;\n      throw new Error(errorMessage);\n    }\n\n    if (fromDate.getTime() > toDate.getTime()) {\n      const errorMessage = `Lower bound (${fromDate.getTime()}) cannot be greater than upper bound (${toDate.getTime()}).`;\n      throw new Error(errorMessage);\n    }\n\n    if (this.storageService.db) {\n      const events = await this.storageService.db\n        .table(StorageSchemata.OBJECT_STORE.EVENTS)\n        .where('[conversation+time]')\n        .between(\n          [conversationId, fromDate.toISOString()],\n          [conversationId, toDate.toISOString()],\n          includeFrom,\n          includeTo,\n        )\n        .limit(limit);\n      return events;\n    }\n\n    const records = (await this.storageService.getAll(StorageSchemata.OBJECT_STORE.EVENTS)) as EventRecord[];\n    return records\n      .filter(record => {\n        const recordDate = eventTimeToDate(record.time).getTime();\n        return (\n          record.conversation === conversationId &&\n          (includeFrom ? recordDate >= fromDate.getTime() : recordDate > fromDate.getTime()) &&\n          (includeTo ? recordDate <= toDate.getTime() : recordDate < toDate.getTime())\n        );\n      })\n      .sort(compareEventsByConversation)\n      .slice(0, limit);\n  }\n\n  /**\n   * Save an unencrypted conversation event.\n   * Will also recompute the category of the event to be stored.\n   *\n   * @param event JSON event to be stored\n   */\n  async saveEvent(event: EventRecord): Promise<EventRecord> {\n    event.category = categoryFromEvent(event);\n    event.primary_key = await this.storageService.save(StorageSchemata.OBJECT_STORE.EVENTS, undefined, event);\n    if (this.storageService.isTemporaryAndNonPersistent) {\n      /**\n       * Dexie supports auto-incrementing primary keys and saves those keys to a predefined column.\n       * The SQLeetEngine also supports auto-incrementing primary keys but it does not save them to a predefined column, so we have to do that manually:\n       */\n      await this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, event.primary_key, {\n        primary_key: event.primary_key,\n      });\n    }\n    return event;\n  }\n\n  async replaceEvent<T extends Partial<EventRecord>>(event: T): Promise<T> {\n    await this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, event.primary_key, event);\n    return event;\n  }\n\n  addEventUpdatedListener(callback: DatabaseListenerCallback): void {\n    this.storageService.addUpdatedListener(StorageSchemata.OBJECT_STORE.EVENTS, callback);\n  }\n\n  addEventDeletedListener(callback: DatabaseListenerCallback): void {\n    this.storageService.addDeletedListener(StorageSchemata.OBJECT_STORE.EVENTS, callback);\n  }\n\n  /**\n   * Update event as uploaded in database.\n   *\n   * @param primaryKey Primary key used to find an event in the database\n   * @param event Updated event asset data\n   */\n  async updateEventAsUploadSucceeded(primaryKey: string, event: EventRecord): Promise<void> {\n    const record = await this.storageService.load<EventRecord>(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey);\n    if (!record) {\n      this.logger.warn('Did not find message to update asset (uploaded)', primaryKey);\n      return;\n    }\n    const assetData = event.data;\n    record.data.id = assetData.id;\n    record.data.key = assetData.key;\n    record.data.otr_key = assetData.otr_key;\n    record.data.sha256 = assetData.sha256;\n    record.data.status = AssetTransferState.UPLOADED;\n    record.data.token = assetData.token;\n    record.status = StatusType.SENT;\n    await this.replaceEvent(record);\n    this.logger.info('Updated asset message_et (uploaded)', primaryKey);\n  }\n\n  /**\n   * Update event as upload failed in database.\n   *\n   * @param primaryKey Primary key used to find an event in the database\n   * @param reason Failure reason\n   */\n  async updateEventAsUploadFailed(\n    primaryKey: string,\n    reason: ProtobufAsset.NotUploaded | AssetTransferState,\n  ): Promise<EventRecord | void> {\n    const record = await this.storageService.load<EventRecord<AssetData>>(\n      StorageSchemata.OBJECT_STORE.EVENTS,\n      primaryKey,\n    );\n    if (!record) {\n      this.logger.warn('Did not find message to update asset (failed)', primaryKey);\n      return;\n    }\n    record.data.reason = reason;\n    record.data.status = AssetTransferState.UPLOAD_FAILED;\n    await this.replaceEvent(record);\n    this.logger.info('Updated asset message_et (failed)', primaryKey);\n    return record;\n  }\n\n  /**\n   * Update an unencrypted event.\n   * A valid update must not contain a 'version' property.\n   *\n   * @param primaryKey event's primary key\n   * @param updates Updates to perform on the message.\n   */\n  async updateEvent<T extends Partial<EventRecord>>(\n    primaryKey: string,\n    updates: T,\n  ): Promise<T & {primary_key: string}> {\n    const hasNoChanges = !updates || !Object.keys(updates).length;\n    if (hasNoChanges) {\n      throw new ConversationError(ConversationError.TYPE.NO_CHANGES, ConversationError.MESSAGE.NO_CHANGES);\n    }\n    const hasVersionedUpdates = !!updates.version;\n    if (hasVersionedUpdates) {\n      const error = new ConversationError(ConversationError.TYPE.WRONG_CHANGE, ConversationError.MESSAGE.WRONG_CHANGE);\n      error.message += ' Use the `updateEventSequentially` method to perform a versioned update of an event';\n      throw error;\n    }\n    const identifiedUpdates = {...updates, primary_key: primaryKey};\n    return this.replaceEvent(identifiedUpdates);\n  }\n\n  /**\n   * Update an event in the database and checks that the update is sequential.\n   *\n   * @param primaryKey Event primary key\n   * @param changes Changes to update message with\n   */\n  async updateEventSequentially(primaryKey: string, changes: Partial<EventRecord> = {}): Promise<number> {\n    const hasVersionedChanges = !!changes.version;\n    if (!hasVersionedChanges) {\n      throw new ConversationError(ConversationError.TYPE.WRONG_CHANGE, ConversationError.MESSAGE.WRONG_CHANGE);\n    }\n\n    if (this.storageService.db) {\n      // Create a DB transaction to avoid concurrent sequential update.\n      return this.storageService.db.transaction('rw', StorageSchemata.OBJECT_STORE.EVENTS, async () => {\n        const record = await this.storageService.load<EventRecord>(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey);\n        if (!record) {\n          throw new StorageError(StorageError.TYPE.NOT_FOUND, StorageError.MESSAGE.NOT_FOUND);\n        }\n        const databaseVersion = record.version || 1;\n        const isSequentialUpdate = changes.version === databaseVersion + 1;\n        if (isSequentialUpdate) {\n          return this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey, changes);\n        }\n        const logMessage = 'Failed sequential database update';\n        const logObject = {\n          databaseVersion: databaseVersion,\n          updateVersion: changes.version,\n        };\n        this.logger.error(logMessage, logObject);\n        throw new StorageError(StorageError.TYPE.NON_SEQUENTIAL_UPDATE, StorageError.MESSAGE.NON_SEQUENTIAL_UPDATE);\n      });\n    }\n    return this.storageService.update(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey, changes);\n  }\n\n  /**\n   * Delete an event from a conversation. Duplicates are delete as well.\n   *\n   * @param conversationId ID of conversation to remove message from\n   * @param eventId ID of the actual message\n   */\n  async deleteEvent(conversationId: string, eventId: string): Promise<number> {\n    return this.storageService.deleteEventInConversation(StorageSchemata.OBJECT_STORE.EVENTS, conversationId, eventId);\n  }\n\n  /**\n   * Delete an event from a conversation with the given primary.\n   *\n   * @param primaryKey ID of the actual message\n   */\n  deleteEventByKey(primaryKey: string): Promise<string> {\n    return this.storageService.delete(StorageSchemata.OBJECT_STORE.EVENTS, primaryKey);\n  }\n\n  /**\n   * Delete all events of a conversation.\n   *\n   * @param conversationId Delete events for this conversation\n   * @param isoDate Date in ISO string format as upper bound which events should be removed\n   */\n  async deleteEvents(conversationId: string, isoDate: string): Promise<number> {\n    return this.storageService.deleteEventsByDate(StorageSchemata.OBJECT_STORE.EVENTS, conversationId, isoDate);\n  }\n}\n"], "filenames": ["src/script/conversation/ConversationRepository.ts", "src/script/conversation/ConversationService.ts", "src/script/event/EventService.ts"], "buggy_code_start_loc": [329, 479, 89], "buggy_code_end_loc": [2889, 486, 151], "fixing_code_start_loc": [330, 479, 90], "fixing_code_end_loc": [2911, 487, 190], "type": "CWE-212", "message": "Wire webapp is a web client for the wire messaging protocol. In versions prior to 2022-01-27-production.0 expired ephemeral messages were not reliably removed from local chat history of Wire Webapp. In versions before 2022-01-27-production.0 ephemeral messages and assets might still be accessible through the local search functionality. Any attempt to view one of these message in the chat view will then trigger the deletion. This issue only affects locally stored messages. On premise instances of wire-webapp need to be updated to 2022-01-27-production.0, so that their users are no longer affected. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-23605", "sourceIdentifier": "security-advisories@github.com", "published": "2022-02-04T23:15:15.567", "lastModified": "2022-02-11T03:05:50.400", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wire webapp is a web client for the wire messaging protocol. In versions prior to 2022-01-27-production.0 expired ephemeral messages were not reliably removed from local chat history of Wire Webapp. In versions before 2022-01-27-production.0 ephemeral messages and assets might still be accessible through the local search functionality. Any attempt to view one of these message in the chat view will then trigger the deletion. This issue only affects locally stored messages. On premise instances of wire-webapp need to be updated to 2022-01-27-production.0, so that their users are no longer affected. There are no known workarounds for this issue."}, {"lang": "es", "value": "Wire webapp es un cliente web para el protocolo de mensajer\u00eda Wire. En las versiones anteriores a 2022-01-27-production.0 los mensajes ef\u00edmeros caducados no eran eliminados de forma confiable del historial de chat local de Wire Webapp. En las versiones anteriores a 2022-01-27-production.0 los mensajes ef\u00edmeros y los activos podr\u00edan seguir siendo accesibles mediante la funcionalidad local search. Cualquier intento de visualizar uno de estos mensajes en la visualizaci\u00f3n de chat desencadenar\u00e1 entonces la eliminaci\u00f3n. Este problema s\u00f3lo afecta a los mensajes almacenados localmente. Las instancias locales de wire-webapp deben actualizarse a la versi\u00f3n 2022-01-27-production.0, para que sus usuarios ya no est\u00e9n afectados. No se presentan medidas de mitigaci\u00f3n conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.3, "baseSeverity": "LOW"}, "exploitabilityScore": 0.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-212"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-212"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-07-29-17-00:*:*:*:*:*:*:*", "matchCriteriaId": "9F7C539F-3406-4848-88B7-1A4CEE38D557"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-08-04-15-44:*:*:*:*:*:*:*", "matchCriteriaId": "17E0C8D9-5708-4291-81D1-F832887FC225"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-08-23-09-31:*:*:*:*:*:*:*", "matchCriteriaId": "C8105074-D75D-45CE-BD71-B89C223DF4D1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-08-24-10-10:*:*:*:*:*:*:*", "matchCriteriaId": "69BBA0A6-D920-421A-B891-B895A998B05A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-08-29-14-54:*:*:*:*:*:*:*", "matchCriteriaId": "89B4A31D-9A40-47A2-86F3-F1A2AA651B4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-09-08-15-38:*:*:*:*:*:*:*", "matchCriteriaId": "CEC3A79C-8538-49AC-BDFB-D402565C7E03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-09-19-14-01:*:*:*:*:*:*:*", "matchCriteriaId": "69AF5CF2-D72E-46F1-8215-8D5E4DCFB925"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-09-28-14-58:*:*:*:*:*:*:*", "matchCriteriaId": "0A3A8F43-DA0A-4F5D-A472-3A0B06D434C1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-10-11-15-34:*:*:*:*:*:*:*", "matchCriteriaId": "C57EE09E-592A-4FA0-8E59-D35361C021EA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-10-18-08-10:*:*:*:*:*:*:*", "matchCriteriaId": "53307D89-F157-46A4-90AA-3C55AEE3120C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-10-25-08-17:*:*:*:*:*:*:*", "matchCriteriaId": "6CAE7457-18ED-45A8-BB64-57AB21FEE836"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-10-26-18-58:*:*:*:*:*:*:*", "matchCriteriaId": "DC24AD26-4697-487D-9207-2C69143CE4D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-11-03-16-09:*:*:*:*:*:*:*", "matchCriteriaId": "7AE32987-DC06-4803-AAA8-9C0B0551B1C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-11-08-15-06:*:*:*:*:*:*:*", "matchCriteriaId": "F5F5E64A-3382-46E1-AFD8-08B0E3586850"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-12-01-12-57:*:*:*:*:*:*:*", "matchCriteriaId": "5E4EB81D-CF7E-4413-B7BA-9C295E7CE038"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2016-12-13-15-12:*:*:*:*:*:*:*", "matchCriteriaId": "843B53EC-AFB9-4EE3-8CD4-0D4B2A866AE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-01-23-12-12:*:*:*:*:*:*:*", "matchCriteriaId": "FFFCF1CB-F0B9-4A7D-944E-3D2CEB5BAB39"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-02-01-14-49:*:*:*:*:*:*:*", "matchCriteriaId": "9D7D882B-F9EF-420F-9AFF-E861D430CFF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-02-17-10-10:*:*:*:*:*:*:*", "matchCriteriaId": "4E70DB4C-ABD5-4C17-AD56-7F169573B15B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-02-24-13-06:*:*:*:*:*:*:*", "matchCriteriaId": "A863E546-BDE3-4D5A-9ADF-B49DC081C0CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-03-08-17-32:*:*:*:*:*:*:*", "matchCriteriaId": "CB175224-86C0-45CB-8A12-69EDDD07E8CD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-03-14-15-05:*:*:*:*:*:*:*", "matchCriteriaId": "4FA786C8-B3B6-4379-B7B3-1DA2052A9EAA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-03-21-11-00:*:*:*:*:*:*:*", "matchCriteriaId": "6E2DF068-E6DC-4BA5-AFE4-BF67055E4E91"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-03-27-17-10:*:*:*:*:*:*:*", "matchCriteriaId": "0AE8B336-C5F4-4CF8-846B-BFB4566C104D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-03-28-14-23:*:*:*:*:*:*:*", "matchCriteriaId": "A4CA9B72-D62D-4AC4-96BB-4898D638986B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-04-05-16-58:*:*:*:*:*:*:*", "matchCriteriaId": "5710465C-6031-4F9E-9355-02E600948829"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-04-07-09-42:*:*:*:*:*:*:*", "matchCriteriaId": "855EB691-A1B8-4D8D-AC6D-5B1232DFD08F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-04-19-12-31:*:*:*:*:*:*:*", "matchCriteriaId": "E6BA8AA6-DB10-47AF-9FAD-8E483CBEF317"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-04-20-15-54:*:*:*:*:*:*:*", "matchCriteriaId": "3C3C8FEA-884A-4991-B790-FAC75E461E0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-05-03-10-29:*:*:*:*:*:*:*", "matchCriteriaId": "06CAA931-4B33-4A9E-A26D-892ACB6C8AB3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-05-19-16-10:*:*:*:*:*:*:*", "matchCriteriaId": "E174117D-3B04-42A5-A3A6-DE2F37AF8145"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-05-26-08-16:*:*:*:*:*:*:*", "matchCriteriaId": "5D70A243-D148-4A6A-BB22-823E272D1913"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-05-26-12-03:*:*:*:*:*:*:*", "matchCriteriaId": "2F57CA5B-719A-4684-8018-6388700852BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-06-01-10-02:*:*:*:*:*:*:*", "matchCriteriaId": "2E2D961A-42BB-40C6-A3D2-836CD2F21F16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-06-07-15-03:*:*:*:*:*:*:*", "matchCriteriaId": "B39EDE4D-885D-47CD-A6F5-64A580666BD2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-06-07-18-05:*:*:*:*:*:*:*", "matchCriteriaId": "7292A70B-D0A2-4CD7-A229-268F3520B57B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-06-22-12-18:*:*:*:*:*:*:*", "matchCriteriaId": "87CFA36C-79F5-409C-9737-3EC8EF8359DE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-06-28-15-13:*:*:*:*:*:*:*", "matchCriteriaId": "4C6FD8B7-C1FC-47D4-968E-750F12C6EBCC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-07-06-12-44:*:*:*:*:*:*:*", "matchCriteriaId": "92CA3E21-10A5-4FC9-827A-EA76432F748D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-07-06-15-48:*:*:*:*:*:*:*", "matchCriteriaId": "6991E3D8-0599-4353-98A1-9D920AFBD1B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-07-18-12-50:*:*:*:*:*:*:*", "matchCriteriaId": "73D81970-3D5F-4085-A1ED-8B9CE09BBD7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-08-03-15-19:*:*:*:*:*:*:*", "matchCriteriaId": "0BF075E4-D307-48C7-8EE5-227C6532A478"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-08-04-09-04:*:*:*:*:*:*:*", "matchCriteriaId": "00A34B62-E72A-4121-B0F5-7DA6760EB898"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-08-04-15-01:*:*:*:*:*:*:*", "matchCriteriaId": "0EBBA781-432A-4818-B298-638F60669618"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-08-08-15-09:*:*:*:*:*:*:*", "matchCriteriaId": "4B04D48B-F041-43E6-A835-C146D3554349"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-08-24-10-57:*:*:*:*:*:*:*", "matchCriteriaId": "EEED22FA-343D-420E-B1C3-D9E7A48ABDD8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-08-31-14-21:*:*:*:*:*:*:*", "matchCriteriaId": "D065A91E-8767-4FD3-B03B-4B4B8A6E3424"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-09-26-07-18:*:*:*:*:*:*:*", "matchCriteriaId": "7E746341-D0BF-433D-934A-7FFE6A90AB2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-09-26-13-00:*:*:*:*:*:*:*", "matchCriteriaId": "62A60EC8-F015-4CA3-B675-57BF76A755DD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-10-09-08-42:*:*:*:*:*:*:*", "matchCriteriaId": "33D83552-0CD2-45D8-BE39-84C5E785FB3E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-10-19-10-45:*:*:*:*:*:*:*", "matchCriteriaId": "012816A1-AC4F-47CF-9E5C-92EB7502ED44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-10-25-07-08:*:*:*:*:*:*:*", "matchCriteriaId": "76BFA566-71AA-4B6B-8FCB-2F0686C31247"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-11-07-08-50:*:*:*:*:*:*:*", "matchCriteriaId": "887419A5-E84E-4C36-BF1F-69EC03C14B2C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-11-10-10-41:*:*:*:*:*:*:*", "matchCriteriaId": "5692B579-BD32-4EC6-88A8-04138FFBB4C8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-12-04-10-23:*:*:*:*:*:*:*", "matchCriteriaId": "8862C15F-3CD8-4A89-96C5-A9ACBBE36B42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-12-04-13-34:*:*:*:*:*:*:*", "matchCriteriaId": "8FBAD9BC-4995-46C4-8104-31F48E9F92C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-12-07-11-13:*:*:*:*:*:*:*", "matchCriteriaId": "620048DB-0CCF-4900-8006-A0ECD124CF16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2017-12-20-12-48:*:*:*:*:*:*:*", "matchCriteriaId": "A02F12E6-3894-4C6A-BCC0-844FC6E2470C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-01-24-18-11:*:*:*:*:*:*:*", "matchCriteriaId": "124FE630-8D9F-4D38-8593-5021CED0DE7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-02-01-10-26:*:*:*:*:*:*:*", "matchCriteriaId": "154FB7CC-CF39-4605-AC01-D00C1DC50148"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-02-16-07-54:*:*:*:*:*:*:*", "matchCriteriaId": "812CCBCA-26D9-4D09-AE60-22A09230EDC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-03-12-11-41:*:*:*:*:*:*:*", "matchCriteriaId": "B74315A4-FE81-4C6E-AF7F-6667D77A7F26"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-06-07-28:*:*:*:*:*:*:*", "matchCriteriaId": "8439A11D-641A-43D9-829A-29D4037456C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-06-09-44:*:*:*:*:*:*:*", "matchCriteriaId": "918DB01B-9629-4738-8D30-34B559E07A2E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-09-10-16:*:*:*:*:*:*:*", "matchCriteriaId": "09F72A1D-46D6-48E1-928D-A23C90BBE6DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-12-06-45:*:*:*:*:*:*:*", "matchCriteriaId": "9A81D216-7DA4-426C-978F-95A71EE8E489"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-12-11-12:*:*:*:*:*:*:*", "matchCriteriaId": "48BFB86A-F4A5-468A-BC17-F80D1065ECFC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-12-13-37:*:*:*:*:*:*:*", "matchCriteriaId": "513E5B07-B477-4136-A9A8-88D2290A3D80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-04-24-14-58:*:*:*:*:*:*:*", "matchCriteriaId": "86B2ECDA-CCAD-4623-BD36-A2909CB072FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-05-04-07-18:*:*:*:*:*:*:*", "matchCriteriaId": "5C1979A2-DE8F-42A3-8876-87863D62D69C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-05-24-15-49:*:*:*:*:*:*:*", "matchCriteriaId": "EA8C4A4E-94BE-458D-ABD5-75FFF601E39C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-06-19-08-04:*:*:*:*:*:*:*", "matchCriteriaId": "82FCD3A2-FA78-4B5C-AC36-06F0FF8E30B0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-07-03-08-25:*:*:*:*:*:*:*", "matchCriteriaId": "252A98FA-E1CE-4623-A2CE-0D83FEB4AFE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-07-16-08-55:*:*:*:*:*:*:*", "matchCriteriaId": "F356FB82-853C-4514-8E2B-BDFEF7F98219"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-07-16-14-05:*:*:*:*:*:*:*", "matchCriteriaId": "1FC19B65-7FF9-4EBB-BF98-F239AD8A2B38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-07-26-08-54:*:*:*:*:*:*:*", "matchCriteriaId": "733CABDE-88D7-45F6-A9E9-E6F2314D5E32"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-08-06-08-03:*:*:*:*:*:*:*", "matchCriteriaId": "ABE70A2F-B8F5-401D-BC4D-09DEE5353272"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-08-22-07-38:*:*:*:*:*:*:*", "matchCriteriaId": "89EE244E-A2E3-43D3-9F5B-F276EA279698"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-08-31-06-54:*:*:*:*:*:*:*", "matchCriteriaId": "0CAECC59-0DEC-4CDA-A2A9-EBBA749099B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-09-07-14-18:*:*:*:*:*:*:*", "matchCriteriaId": "BD2485E0-7EB6-4139-A034-05E9380ED8DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-09-28-11-46:*:*:*:*:*:*:*", "matchCriteriaId": "BC65D646-FCBC-47EF-A097-75078AF0F293"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-10-02-08-03:*:*:*:*:*:*:*", "matchCriteriaId": "60F45535-7563-4FF5-8D0D-6DBDAB0D7EEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-10-15-08-14:*:*:*:*:*:*:*", "matchCriteriaId": "173438F3-C9C1-4E02-BCF7-64A0C0ABA6DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-10-23-12-05:*:*:*:*:*:*:*", "matchCriteriaId": "22EDBEA8-129B-48E6-BE58-6847A339CB4E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-11-05-11-21:*:*:*:*:*:*:*", "matchCriteriaId": "8178BE20-3229-4906-B5F2-95CEA5875C28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-11-15-13-14:*:*:*:*:*:*:*", "matchCriteriaId": "A35C6F6D-EA9F-452E-839C-3232ACC0A885"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-11-30-11-03:*:*:*:*:*:*:*", "matchCriteriaId": "787E1701-5E39-4F00-9340-852EFA197232"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-12-03-11-26:*:*:*:*:*:*:*", "matchCriteriaId": "A26165D5-0226-4163-ABB1-996E0031B4BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2018-12-04-14-24:*:*:*:*:*:*:*", "matchCriteriaId": "619BA0A5-CC24-4CF0-A1F9-D73871072892"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-01-02-13-10:*:*:*:*:*:*:*", "matchCriteriaId": "71FB6741-D6B8-45AD-AD4E-9A010287FED9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-01-08-13-20:*:*:*:*:*:*:*", "matchCriteriaId": "958494C4-4C98-46E3-AC2F-371D1FC9AEB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-01-17-15-08:*:*:*:*:*:*:*", "matchCriteriaId": "A1FED7B2-0DB5-40B5-8A83-9563C339C9AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-11:staging0:*:*:*:*:*:*", "matchCriteriaId": "0E4BDC0E-5F3B-4DF9-9148-07860F5EB15C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-11:staging1:*:*:*:*:*:*", "matchCriteriaId": "673E127B-258B-4F7C-9EB2-E0D835053BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-11:staging2:*:*:*:*:*:*", "matchCriteriaId": "CC5A38F3-5A2F-4BAC-BDD6-C17ED8EA2ABC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "5D4468DB-3434-48D1-885D-40B1A9337B54"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "CB0BD5DC-CAFA-4657-86EE-D233BB605A21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-18-11-26:*:*:*:*:*:*:*", "matchCriteriaId": "578FE3BD-3E30-439B-ADF3-311555BEFBEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "CCCF1B28-2BCA-4FB3-936F-CD319E8920A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "8424FAA9-9EAD-4CFE-9AF2-48F89340C9C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-28:staging1:*:*:*:*:*:*", "matchCriteriaId": "884CAEF9-F053-475B-A1C5-35E23D3042FF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-28-15-10:*:*:*:*:*:*:*", "matchCriteriaId": "1B7645D9-7F20-48A1-A8FD-D6E118C4D303"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-02-28-15-11:*:*:*:*:*:*:*", "matchCriteriaId": "48F05A59-7849-4C42-AD10-B1B17BE676C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-05:staging0:*:*:*:*:*:*", "matchCriteriaId": "5F4D277E-3055-494E-BC5A-CCAD4C1C1845"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-07:staging0:*:*:*:*:*:*", "matchCriteriaId": "A9BC0A08-7606-4E48-BBD2-973C960DD8F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-11:staging0:*:*:*:*:*:*", "matchCriteriaId": "12A7C7B7-86E7-4F70-92D9-B6C3C6999BD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "7E80152D-6FAD-4741-8CAC-301DF844277C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-13:staging1:*:*:*:*:*:*", "matchCriteriaId": "0784BB5A-2CC0-4A63-99AE-39A074933E02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-14-11-05:*:*:*:*:*:*:*", "matchCriteriaId": "F7BD6A68-64F5-43DC-B12C-659CF29DC8D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-18-12-58:*:*:*:*:*:*:*", "matchCriteriaId": "4AE2319F-82C4-4A2D-BE6D-C48336E9C1B9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "A44316B8-751F-4CFE-AD46-6B846497C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "C53CCFBC-2116-4F0C-993B-7CF2906C898A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-25:staging1:*:*:*:*:*:*", "matchCriteriaId": "63C519FD-D5A9-4EC4-A9C4-4404C125A74F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "D990E0AB-0650-47EC-8AE2-7ACE29019F6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-28:staging1:*:*:*:*:*:*", "matchCriteriaId": "CFC7E941-EF3E-4A7B-8B36-F9FA154B1EF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-03-29-09-38:*:*:*:*:*:*:*", "matchCriteriaId": "71C8DCC5-0DA9-4792-ACFC-E16E4191D67E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-08:staging0:*:*:*:*:*:*", "matchCriteriaId": "620C777E-239A-46C9-B428-CD761863B26B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-10-10-55:*:*:*:*:*:*:*", "matchCriteriaId": "B0BBA0ED-47E0-4159-B04D-708A65CC6F2F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-11:staging0:*:*:*:*:*:*", "matchCriteriaId": "C407CDFD-55BA-45A7-AD3F-BD44B3FD579A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "3DDC1553-C0AE-4B22-A160-8EE4983E2D9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-23:staging1:*:*:*:*:*:*", "matchCriteriaId": "C25BCBFA-461D-4E1E-A0E3-EEBCE637FB5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-23-10-51:*:*:*:*:*:*:*", "matchCriteriaId": "6A604801-85D5-4DB8-9459-4C2E7701F179"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "D388C188-D909-40DF-A9A6-075EA946C234"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-04-29:staging0:*:*:*:*:*:*", "matchCriteriaId": "9458987D-383E-4BFD-A34A-F7E464CB3AFB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-09-09-36:*:*:*:*:*:*:*", "matchCriteriaId": "F13CDBBD-8818-4A9D-BC0D-241043E9E75C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-14:staging0:*:*:*:*:*:*", "matchCriteriaId": "DC6A2B96-9FF0-4B69-BD62-29A343ACF7A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "3FC2FE5A-F13B-4B71-8163-41FEEACAFA63"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-16:*:*:*:*:*:*:*", "matchCriteriaId": "7F1D044E-0FBC-48C5-B106-01516B66307C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-16-09-26:*:*:*:*:*:*:*", "matchCriteriaId": "67EC2F9C-3CCE-4297-A27A-78FF74B059DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-31:staging0:*:*:*:*:*:*", "matchCriteriaId": "025CE142-8B76-4013-A02B-888A6F04034F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-05-31-08-18:*:*:*:*:*:*:*", "matchCriteriaId": "B640B3D6-62A7-472C-B48C-424F762E9F28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-06-04:staging0:*:*:*:*:*:*", "matchCriteriaId": "4D4C30AE-5F2D-4309-AD01-00DCA87064C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-06-06-12-31:*:*:*:*:*:*:*", "matchCriteriaId": "27B10CDC-C8E2-4BA0-97C4-5C28BB5C0686"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-06-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "6C87BE96-7791-4B4E-877F-C6EE1AB75D60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-06-24:staging0:*:*:*:*:*:*", "matchCriteriaId": "FF7C4DE4-30D4-4163-84BC-137B1447753F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-06-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "BFAEB35F-B839-4D6D-ADFE-B038C9CDCD83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-06-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "551086BF-6882-4F40-A458-331BF1A54732"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-07-01:staging0:*:*:*:*:*:*", "matchCriteriaId": "74719751-4ED1-42D5-AB9D-8E40A7DC6B66"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-07-02-12-29:*:*:*:*:*:*:*", "matchCriteriaId": "03DD8F60-508B-46FF-9DDE-EA32441C8E04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-07-11-13-18:*:*:*:*:*:*:*", "matchCriteriaId": "68306D04-94DF-48F3-B407-3E26265049EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-07-30:staging0:*:*:*:*:*:*", "matchCriteriaId": "EABE2D35-9BA5-461C-8EE3-524C5B971C47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-01:staging0:*:*:*:*:*:*", "matchCriteriaId": "C686FA3A-FAD2-4711-8FDC-BFECB328F5B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-14:staging0:*:*:*:*:*:*", "matchCriteriaId": "A9E7C31B-CEEE-4BE0-8BA4-56E3C6F8998C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-19:staging0:*:*:*:*:*:*", "matchCriteriaId": "A60D9CC5-0F00-4EA6-B598-F8A8969448AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-21:production0:*:*:*:*:*:*", "matchCriteriaId": "16781A10-B098-4B01-BFF2-9464113C8F8C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-22:production0:*:*:*:*:*:*", "matchCriteriaId": "829ED145-8FA8-4825-8859-961B3FCE7283"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-22:staging0:*:*:*:*:*:*", "matchCriteriaId": "05AE3008-E54C-4D50-A199-F6DC4457555E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-08-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "4284544D-0FB9-4A8B-80A0-C1F6DB323C81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-02:production0:*:*:*:*:*:*", "matchCriteriaId": "59BF8A05-BDEC-44D2-9F2D-85CCDCD2623F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-05:staging0:*:*:*:*:*:*", "matchCriteriaId": "C6E489BC-0EB5-4934-A698-BC1EED867C1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-09:staging0:*:*:*:*:*:*", "matchCriteriaId": "0BCBFCF4-B530-4C60-9673-E4A32C3ED888"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-12:staging0:*:*:*:*:*:*", "matchCriteriaId": "E5C35CC2-2773-4D97-9945-E5DD16C73AE3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "F2AEF4F3-7C2A-4DCB-8A3E-1E412F8C1DCE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-17:production0:*:*:*:*:*:*", "matchCriteriaId": "323CCE05-97E8-4F74-B716-F4FFB25F83E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "9B9F15D8-DD60-47D7-87C6-DE6EBE5EEBDB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-23:staging0:*:*:*:*:*:*", "matchCriteriaId": "8F1D56EA-7B15-4C58-AD0D-0B1AD186EFB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-09-24:production0:*:*:*:*:*:*", "matchCriteriaId": "20050346-6328-4285-9530-A31080A74A81"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-07:staging0:*:*:*:*:*:*", "matchCriteriaId": "BFF5B1E7-040A-4184-B441-F50AB90BA00D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-07:staging1:*:*:*:*:*:*", "matchCriteriaId": "A7307B91-CF62-40B1-9A90-A493DBBF963C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-08:staging0:*:*:*:*:*:*", "matchCriteriaId": "53DEF027-2F50-46CF-978F-B469FDB5ECBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-10:staging0:*:*:*:*:*:*", "matchCriteriaId": "17842173-AC4E-4FB2-AB26-0DCD5ABE6FF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-10:staging1:*:*:*:*:*:*", "matchCriteriaId": "DE255636-9342-470D-8F00-4A2507B056F4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-14:staging0:*:*:*:*:*:*", "matchCriteriaId": "832F52E6-7CA5-465A-88FE-BAE7E61A7319"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-16:production0:*:*:*:*:*:*", "matchCriteriaId": "1CD2EBEA-6352-4CDD-8CE4-C20490088594"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-16:production1:*:*:*:*:*:*", "matchCriteriaId": "E1852CAC-FB66-421E-B8D3-CC67D7004273"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-16:staging0:*:*:*:*:*:*", "matchCriteriaId": "9CC369FA-3766-4AA1-AB99-0282608054C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-16:staging1:*:*:*:*:*:*", "matchCriteriaId": "5E38F646-BA40-489D-9ADE-4BCB1A0E568C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-21:staging0:*:*:*:*:*:*", "matchCriteriaId": "FD0BB660-224C-443A-BFB2-C34612FEB006"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "BDDA5925-E01E-4472-8761-2A9FA18D0E64"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-29:staging0:*:*:*:*:*:*", "matchCriteriaId": "F24A98D6-E1F0-4837-97AF-C02FC65EF194"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-10-31:staging0:*:*:*:*:*:*", "matchCriteriaId": "5ECB8D94-2140-4891-8D0B-C2C4F770A348"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-01:production0:*:*:*:*:*:*", "matchCriteriaId": "17D80EC6-9496-47C6-8786-8E5FA2FE2AB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-08:staging0:*:*:*:*:*:*", "matchCriteriaId": "97F150B2-8BE4-43D8-8A46-9CA3CA2318DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-12:staging0:*:*:*:*:*:*", "matchCriteriaId": "596F1AC5-D9AD-4FFA-A2E7-4C3FBA65F647"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-19:staging0:*:*:*:*:*:*", "matchCriteriaId": "1E1DB857-278C-466D-B128-BD38D76A42F6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-21:production0:*:*:*:*:*:*", "matchCriteriaId": "27973D86-2AF4-4424-9B52-22D27CA1AC88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-21:staging0:*:*:*:*:*:*", "matchCriteriaId": "872D4A83-CDBF-4140-BBE8-D7A06D45B23B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "14E95783-15FE-4997-B091-148D29037F16"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-11-26:production0:*:*:*:*:*:*", "matchCriteriaId": "E090810E-B2B8-4FD0-B5C8-F8845C6B4CFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-12-12:staging0:*:*:*:*:*:*", "matchCriteriaId": "8F42F8CC-218B-4030-A51D-5C488F42E3E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2019-12-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "B3FB0C98-559B-4664-9EAA-AFEA642252D9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-06:production0:*:*:*:*:*:*", "matchCriteriaId": "D5F68751-1DE7-4AC3-8B45-4D8EB07BFD55"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-09:staging0:*:*:*:*:*:*", "matchCriteriaId": "89685146-84E2-401F-A0BE-7B7658EAD8E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-13:production0:*:*:*:*:*:*", "matchCriteriaId": "45CCC915-90B7-4253-9895-F26F15C0CB9F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "E4AC25C5-1E49-40A7-9191-523CCAE5B4EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-16:staging0:*:*:*:*:*:*", "matchCriteriaId": "D9FCCBBE-0451-4344-A695-1EAE380198EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-17:staging0:*:*:*:*:*:*", "matchCriteriaId": "779E019F-AB8C-4793-AC68-5C82D5E77A73"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-21:staging0:*:*:*:*:*:*", "matchCriteriaId": "BD045A35-47B0-4753-8CEF-BCF891F8A341"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-01-22:production0:*:*:*:*:*:*", "matchCriteriaId": "6AB4E9C2-7BA9-4CD7-8DE1-A492BA5E0289"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "56102D55-5CE3-4FAA-A29D-2B5630CC316F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-11:staging0:*:*:*:*:*:*", "matchCriteriaId": "F808BE69-EF0C-4F2D-A4BC-451F5B58FB00"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-11:staging1:*:*:*:*:*:*", "matchCriteriaId": "098A3E28-FA67-4C9E-8D9C-44ABFB709894"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-14:production0:*:*:*:*:*:*", "matchCriteriaId": "2EECC296-021C-445A-A7B9-450646260F97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "636577A9-6B2B-4404-8626-45B9B5CD8F6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "D8C5A8D4-6DC0-41D9-8FC6-AA8EA001DD91"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-24:staging0:*:*:*:*:*:*", "matchCriteriaId": "31CF0B9E-6513-4522-BDAB-4C75DE9CB2B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "098C98D9-766B-43F9-AB69-B04F10F6B356"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-02-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "DDC3CED9-79B3-4E47-A8B1-69A395998F60"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-03:production0:*:*:*:*:*:*", "matchCriteriaId": "FB483527-C22F-48A2-8746-E18A5A191285"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-03:staging0:*:*:*:*:*:*", "matchCriteriaId": "8C0A9B78-7128-4DC7-ABD8-F0761B774B1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "2D1D64AA-C5F7-408D-BFD9-609076E624A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-12:staging0:*:*:*:*:*:*", "matchCriteriaId": "87E5EE83-722B-425B-885D-F248FB1E52DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "F07B5066-7224-4069-8C05-3A878F50E789"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "C0621ED4-5AEA-40FD-830B-F4478D36F448"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-23:production0:*:*:*:*:*:*", "matchCriteriaId": "4F8A815A-F44A-478F-948A-FECE9A9BDBFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-03-30:staging0:*:*:*:*:*:*", "matchCriteriaId": "40027F50-C9DD-4A59-BF91-9B2C571FC01A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-01:staging0:*:*:*:*:*:*", "matchCriteriaId": "42D393CD-9503-4727-8603-7690D5E4A7DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-07:production0:*:*:*:*:*:*", "matchCriteriaId": "044587FB-BAE3-4DE0-82B5-7E82E2FFC93A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-09:staging0:*:*:*:*:*:*", "matchCriteriaId": "0E833562-10A0-4AEB-ADDB-E9596AD8E8D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-16:staging0:*:*:*:*:*:*", "matchCriteriaId": "4250771C-7525-40C4-90EF-4EE7AD9CA5C5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-21:production0:*:*:*:*:*:*", "matchCriteriaId": "33B2A95F-0228-44E8-984E-53721AC5C8A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-22:staging0:*:*:*:*:*:*", "matchCriteriaId": "E567BA3D-1154-4ACD-A0BD-4B4848486F52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-23:staging0:*:*:*:*:*:*", "matchCriteriaId": "EAA64849-4984-465D-9AFF-3B5B4C638F95"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "0C2B4515-AA46-49E3-8D1B-BC32547B281D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-04-29:production0:*:*:*:*:*:*", "matchCriteriaId": "BC553328-4F12-4D7F-8B2C-2B46DA4FCB7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-04:staging0:*:*:*:*:*:*", "matchCriteriaId": "D0CFDDE4-FDA3-46FA-9752-84000310246D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "A223DAD4-1041-4CA9-A824-DECB7EBFF5C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-07:production0:*:*:*:*:*:*", "matchCriteriaId": "B220B6F7-10E7-483B-9E66-FD8220D78AC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-07:staging0:*:*:*:*:*:*", "matchCriteriaId": "5BFD81EC-3224-4677-BA40-B06B7A83DF67"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "AF37194D-4C5D-43CA-BA81-98C2E51DE0CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-14:staging0:*:*:*:*:*:*", "matchCriteriaId": "D97BCDFD-3BA6-4B1E-A51F-8217F2B1D0C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "54FF9525-01EC-46A3-AF64-989EBD642C36"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "FC6C8FDE-B5D0-4E29-8254-F22CC289F5CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-19:staging0:*:*:*:*:*:*", "matchCriteriaId": "C88E3237-25F7-4415-A050-23763FBCF284"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-20:production0:*:*:*:*:*:*", "matchCriteriaId": "4B1975EE-309E-4F65-A59E-2EA7392C828A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-22:staging0:*:*:*:*:*:*", "matchCriteriaId": "3E26353B-CB8E-4B5F-883B-10901B9B38DB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "6A9894C5-27B4-497B-A794-527CFFD12249"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "C05CF72B-A03E-43BC-AEFB-C42665B5590F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "BC8BCE8F-952A-402E-B2EF-8A6D9F30EB9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-05-29:staging0:*:*:*:*:*:*", "matchCriteriaId": "DE722C59-67B7-4335-A876-435DC92CFBCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-02:production0:*:*:*:*:*:*", "matchCriteriaId": "82D79908-3921-4E0E-81BA-2B0403B96F5C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-05:staging0:*:*:*:*:*:*", "matchCriteriaId": "CE6E4462-E96D-4CB8-BD6A-57C049F1C2D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-08:staging0:*:*:*:*:*:*", "matchCriteriaId": "7E8625E3-4E73-4863-92C4-B5074F571203"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-10:staging0:*:*:*:*:*:*", "matchCriteriaId": "D31C8B93-34C2-4008-B387-FA45B31BF679"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-12:staging0:*:*:*:*:*:*", "matchCriteriaId": "74D6674D-FC05-45B3-9712-A39915EFE330"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-15:production0:*:*:*:*:*:*", "matchCriteriaId": "19425C14-9FB2-4C0D-90AB-AFA639489935"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "6BD01F15-EA3E-4A37-9B87-602C4D18DDE0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-19:staging0:*:*:*:*:*:*", "matchCriteriaId": "5A09C46B-FA37-4BE2-BFF6-FD119822B494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-24:production0:*:*:*:*:*:*", "matchCriteriaId": "2E1BB266-A57E-4F22-970A-FE8D0B6C390C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-06-29:staging0:*:*:*:*:*:*", "matchCriteriaId": "E35AFBD0-3FEB-4C98-A7E6-B4A22BE8E0E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-07:staging0:*:*:*:*:*:*", "matchCriteriaId": "19824B3A-AB55-438C-B61D-2A37858B342B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-07:staging1:*:*:*:*:*:*", "matchCriteriaId": "A4DD45FD-FDC8-4589-9EA4-7D8171E2B1BF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "E4EAB1BD-13E2-4FC6-88E8-F410E8B02ADE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-16:staging0:*:*:*:*:*:*", "matchCriteriaId": "F30DC106-E2A5-48DD-A4F1-3FBA82214819"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-24:production0:*:*:*:*:*:*", "matchCriteriaId": "B16BA960-A9D9-4BEE-9E79-D972C96778E4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-24:staging0:*:*:*:*:*:*", "matchCriteriaId": "4D26A9F7-AF17-4FBC-9687-E457A8B3228B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-07-24:staging1:*:*:*:*:*:*", "matchCriteriaId": "2D0CB4D5-C31F-4525-B7B7-594EBCAF52ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "A90E1F42-FD59-4398-BCDE-E14BD21EB2B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-12:staging0:*:*:*:*:*:*", "matchCriteriaId": "FEDC1C78-87D2-43D7-B165-38F4EA9A0396"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-12:staging1:*:*:*:*:*:*", "matchCriteriaId": "B4CE9B41-3778-4B99-AB43-A9F94E359907"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-14:staging0:*:*:*:*:*:*", "matchCriteriaId": "B6D176B2-C1E0-45FC-916A-FB9CB6B62F49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "BBCC6C00-70BF-47C6-BE7F-616204DFEA02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-19:staging0:*:*:*:*:*:*", "matchCriteriaId": "1F2216B7-6365-4273-8E74-FE7D16429CBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-21:staging0:*:*:*:*:*:*", "matchCriteriaId": "B3FE0E90-E6AC-41FF-88C6-F2DD32793867"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "76E69F0A-2039-490C-BE1B-CC719EE345C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-08-26:production0:*:*:*:*:*:*", "matchCriteriaId": "35CEC15D-B5AC-4066-9687-A77034D35433"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-02:staging0:*:*:*:*:*:*", "matchCriteriaId": "29F28433-2660-4CCF-ADA6-B1E9D59F9725"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-03:staging0:*:*:*:*:*:*", "matchCriteriaId": "4B3179D6-FE68-42D9-AAFE-2662CFE0583E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-04:staging0:*:*:*:*:*:*", "matchCriteriaId": "838C3C92-BF10-4F16-9985-3EC85B267828"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-08:staging0:*:*:*:*:*:*", "matchCriteriaId": "528DE610-C626-41F7-BF77-8AC67211C9EF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-11:production0:*:*:*:*:*:*", "matchCriteriaId": "06DB5C24-93FF-4814-8D93-84D78A449DB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-17:staging0:*:*:*:*:*:*", "matchCriteriaId": "8331902A-6C19-4571-B459-60F5FE25EE9C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "762B672A-4898-48C5-ABEF-8AC96F2CDEC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-21:production0:*:*:*:*:*:*", "matchCriteriaId": "0A6855D8-3CC1-4469-97B0-3E1B642120A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "DEFEDFAD-16C8-4ED3-AABD-F103E7EF73FC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-09-29:production0:*:*:*:*:*:*", "matchCriteriaId": "CDDE68A9-C8CF-4210-A993-803015027602"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-01:staging0:*:*:*:*:*:*", "matchCriteriaId": "0476F488-7E63-4405-B915-E1F15DA87EEB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "0F8DF3F8-5ACC-41AE-B27E-DC5203CEA73F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-07:production0:*:*:*:*:*:*", "matchCriteriaId": "A8B4C59C-3901-4315-A247-709E1580EEE6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-07:staging0:*:*:*:*:*:*", "matchCriteriaId": "96B62909-26AC-457A-88AA-D746E6C639F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-08:production0:*:*:*:*:*:*", "matchCriteriaId": "9820960B-4B4C-4AAE-A18D-13E38DD1D1A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-14:staging0:*:*:*:*:*:*", "matchCriteriaId": "BAA01CD3-1850-45BD-B4AD-6BC88C19E574"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "1352B173-7478-492A-9F7F-03FD5A76483C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-21:staging0:*:*:*:*:*:*", "matchCriteriaId": "321EF557-D41E-4E55-BB34-11CD15DE2E1F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-21:staging1:*:*:*:*:*:*", "matchCriteriaId": "C5733738-FA67-40C4-BDC0-6602875CB8D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "5A4E8B8C-DA09-42D5-85A6-437D069A9A2A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "BF13024E-2094-4C93-BA63-B836A8C5F7AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-10-28:production0:*:*:*:*:*:*", "matchCriteriaId": "F5E65D3F-B1C8-4288-8C6C-DCCDC6FA1339"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-11-09:production0:*:*:*:*:*:*", "matchCriteriaId": "E1A592F1-F4F5-4CDF-9140-0721A223D74F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-11-30:production0:*:*:*:*:*:*", "matchCriteriaId": "B31D2864-4E51-4DFC-A169-1F9DD6314710"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-11-30:staging0:*:*:*:*:*:*", "matchCriteriaId": "77141266-2E6D-4DAE-89AE-9E5992B7CCF2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-12-10:staging0:*:*:*:*:*:*", "matchCriteriaId": "A7ECF0D4-4B70-4D10-8C6B-0F6FABEF364C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2020-12-14:production0:*:*:*:*:*:*", "matchCriteriaId": "D49B2C8C-2DF2-4555-AAC7-0FA687990944"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-01-18:production0:*:*:*:*:*:*", "matchCriteriaId": "79D07150-5D3D-4460-8D7C-88073642D8ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-01-18:staging1:*:*:*:*:*:*", "matchCriteriaId": "3B64A8E4-6EE2-4233-8B66-80930CF4DF9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-01-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "538929F3-4528-43DC-8EE1-E7BF815F0252"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-02:production0:*:*:*:*:*:*", "matchCriteriaId": "4E69FEC4-7A2C-4E27-9AD9-186C3D373CF6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-03:staging0:*:*:*:*:*:*", "matchCriteriaId": "49FBEB64-7D8D-4740-89A3-29DB34926DA8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-04:staging0:*:*:*:*:*:*", "matchCriteriaId": "E8C87EE6-0EE0-490F-9A58-976F76CF1386"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "01A83481-A454-4636-B178-9C72ADC349CA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-17:production0:*:*:*:*:*:*", "matchCriteriaId": "DDCCEB28-57EA-4875-9800-AE993FAD6783"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "BCCAA5BC-7898-4998-9AE9-20C9A42CADDC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-22:staging1:*:*:*:*:*:*", "matchCriteriaId": "2F084B4F-2543-47AF-82DE-B5514B99018B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-02-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "CC6E80E7-DAB4-48F0-82B8-093D16D162BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-04:production0:*:*:*:*:*:*", "matchCriteriaId": "5F50DCF8-17C2-43E8-ACBD-546E2DA51494"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-05:staging0:*:*:*:*:*:*", "matchCriteriaId": "E1DE4AAD-9894-41D7-AC5D-7051656928A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-10:staging0:*:*:*:*:*:*", "matchCriteriaId": "D3A9FB95-9D27-45B6-A536-63DBEF59BFBA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-15:production0:*:*:*:*:*:*", "matchCriteriaId": "66DFD20D-8672-4076-9564-48D36421B5A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-18:staging0:*:*:*:*:*:*", "matchCriteriaId": "653EA37B-AD92-4D5E-A7BA-2189F2112CE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-24:staging0:*:*:*:*:*:*", "matchCriteriaId": "84F0148E-02A6-44DC-8F96-741EAFEF070E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-03-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "DFF35810-62F0-4DCC-9414-867F3B7E13F0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-04-01:production0:*:*:*:*:*:*", "matchCriteriaId": "7C2F0626-F344-4BEE-A0DD-AD1EDDE3E98D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-04-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "4CB4C183-700C-4894-B332-BD2BFCD0FA38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-04-15:staging0:*:*:*:*:*:*", "matchCriteriaId": "309638E7-86EA-45B3-A195-737D397A3F45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-04-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "F992F271-E265-4217-9EC6-72D03CBC8503"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-04-28:staging0:*:*:*:*:*:*", "matchCriteriaId": "E407D214-5482-4CA2-9832-A53090D5D28D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-05-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "C1A1B66D-CC8F-41E6-9F4A-1688CD462EC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-05-10:production0:*:*:*:*:*:*", "matchCriteriaId": "90EA5568-D815-4D00-A2F6-B77620A4DEB8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-05-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "5F9A2A1E-F82B-4386-83D1-03DBFAE65780"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-06-01:production0:*:*:*:*:*:*", "matchCriteriaId": "A4B46404-76E8-4B07-B67C-97C1B5A33EA6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-06-17:staging0:*:*:*:*:*:*", "matchCriteriaId": "D414BA67-128D-4F3E-A4D4-8A4595857827"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-07-09:staging0:*:*:*:*:*:*", "matchCriteriaId": "BF3AC9FF-D66F-40CE-B297-BE8A310C3EB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-07-26:staging0:*:*:*:*:*:*", "matchCriteriaId": "81D6276D-01ED-461B-89AD-46AADBD6C345"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-07-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "61C65D07-2B14-4F44-B653-3D6C1482E0F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-03:staging0:*:*:*:*:*:*", "matchCriteriaId": "9F3BC3F7-BF71-4AC3-B9D3-0999E14FDC12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-04:staging0:*:*:*:*:*:*", "matchCriteriaId": "FF2DB418-7AF4-46CD-B96C-A01CB4A7AD57"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-09:staging0:*:*:*:*:*:*", "matchCriteriaId": "B4724122-8B45-4289-89CA-2CA23193A0A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-17:staging0:*:*:*:*:*:*", "matchCriteriaId": "0FD4A86C-4653-4E7F-9143-76FB3CB804B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "81ADF1F3-F554-4438-A833-A128FC2ABFE6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-25:staging1:*:*:*:*:*:*", "matchCriteriaId": "445CBE08-25C5-4176-B613-6BBBF2717951"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "192BE71C-1726-4C69-9B4D-27279A8EB627"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-30:production0:*:*:*:*:*:*", "matchCriteriaId": "6160B5D3-9F26-4A09-B071-8E084CBE16D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-08-30:staging0:*:*:*:*:*:*", "matchCriteriaId": "D0DBE607-AF06-49C2-8F30-4C4E91024261"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-03:staging0:*:*:*:*:*:*", "matchCriteriaId": "A498478F-D7F2-4159-8C39-121C4ED060D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-06:staging0:*:*:*:*:*:*", "matchCriteriaId": "BB593DC5-6FB1-4918-B277-E8AD4A6C7B5F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-06:staging1:*:*:*:*:*:*", "matchCriteriaId": "9E42271B-F1DC-454F-BCF0-23F388DCAABD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-06:staging2:*:*:*:*:*:*", "matchCriteriaId": "23DA48DB-F23A-49F9-8AA3-28A0F209BD3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-06:staging3:*:*:*:*:*:*", "matchCriteriaId": "2C254480-ED77-453B-B41C-2F28F68D66F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-08:staging0:*:*:*:*:*:*", "matchCriteriaId": "7FF74D56-D4B8-408B-BA0E-5FBBEFB5F3CC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-09:staging0:*:*:*:*:*:*", "matchCriteriaId": "6F2654B9-1EA9-4FA1-B28B-79CE308B62DC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-10:staging0:*:*:*:*:*:*", "matchCriteriaId": "32BABEE2-D9AA-4951-99F1-F1DE67473FD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-13:production0:*:*:*:*:*:*", "matchCriteriaId": "3D97B133-6835-434F-B311-641790973DE2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "2DDE0232-8EFF-4F30-BB5F-C7D5FFF61484"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "34AE2C75-C82E-41BD-8E38-83414C82B634"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-22:staging0:*:*:*:*:*:*", "matchCriteriaId": "69EF9327-DE4A-4784-96C1-2AB1DE48F9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-27:production0:*:*:*:*:*:*", "matchCriteriaId": "522B7FB0-7702-466D-8D3B-0C2753E42CDE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-29:staging0:*:*:*:*:*:*", "matchCriteriaId": "186239BC-23F1-4DFA-BB99-F85746AD2EDD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-09-30:staging0:*:*:*:*:*:*", "matchCriteriaId": "306EEBF5-6A28-457B-B2D5-5457CA4BA0A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-10-02:staging0:*:*:*:*:*:*", "matchCriteriaId": "6FBCD7A7-6846-4F75-AED1-60E4BECCEFB2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-10-04:production0:*:*:*:*:*:*", "matchCriteriaId": "29BECF70-2EDB-40D3-B2DC-ACEF459415D0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-10-13:staging0:*:*:*:*:*:*", "matchCriteriaId": "EDF3B256-6DF8-4522-BB32-636B583E8709"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-10-20:staging0:*:*:*:*:*:*", "matchCriteriaId": "59F445A4-1AF5-4B2E-8874-5E450F44CAC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-10-27:staging0:*:*:*:*:*:*", "matchCriteriaId": "CAE9D2BB-3C54-4ACE-AA07-F4AB38B94ACC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-11-01:production0:*:*:*:*:*:*", "matchCriteriaId": "62EA5D57-393B-459C-B8A2-A4B8EA70AB53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-11-25:staging0:*:*:*:*:*:*", "matchCriteriaId": "84A7E7D2-6C55-4F93-9643-88064D8BFB25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-12-01:production0:*:*:*:*:*:*", "matchCriteriaId": "989A0732-FA17-48DD-A28F-9CEF560BFF08"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-12-01:staging0:*:*:*:*:*:*", "matchCriteriaId": "735A80A4-2336-4D33-BF0E-8DCE39C31683"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wire:wire-webapp:2021-12-02:production0:*:*:*:*:*:*", "matchCriteriaId": "9DF8D014-E69A-4457-852D-0B244A4A329A"}]}]}], "references": [{"url": "https://github.com/wireapp/wire-webapp/commit/42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wireapp/wire-webapp/security/advisories/GHSA-2w3m-ppfg-hg62", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wireapp/wire-webapp/commit/42c9a1edddbdd5d4d8f9a196a98f6fc19bb21741"}}