{"buggy_code": ["require \"archive\"\nrequire \"csv\"\nrequire \"fileutils\"\nrequire \"statistics\"\n\nclass CoursesController < ApplicationController\n  skip_before_action :set_course, only: %i[courses_redirect index new create]\n  # you need to be able to pick a course to be authorized for it\n  skip_before_action :authorize_user_for_course, only: %i[courses_redirect index new create]\n  # if there's no course, there are no persistent announcements for that course\n  skip_before_action :update_persistent_announcements, only: %i[courses_redirect index new create]\n\n  rescue_from ActionView::MissingTemplate do |_exception|\n    redirect_to(\"/home/error_404\")\n  end\n\n  def index\n    courses_for_user = User.courses_for_user current_user\n\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n  end\n\n  def courses_redirect\n    courses_for_user = User.courses_for_user current_user\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n    # if only enrolled in one course (currently), go to that course\n    # only happens when first loading the site, not when user goes back to courses\n    if @listing[:current].one?\n      course_name = @listing[:current][0].name\n      redirect_to course_assessments_url(course_name)\n    else\n      redirect_to(action: :index)\n    end\n  end\n\n  action_auth_level :show, :student\n  def show\n    redirect_to course_assessments_url(@course)\n  end\n\n  ROSTER_COLUMNS_S15 = 29\n  ROSTER_COLUMNS_F16 = 32\n  ROSTER_COLUMNS_F20 = 34\n\n  action_auth_level :manage, :instructor\n  def manage\n    matrix = GradeMatrix.new @course, @cud\n    cols = {}\n    # extract assessment final scores\n    @course.assessments.each do |asmt|\n      next unless matrix.has_assessment? asmt.id\n\n      cells = matrix.cells_for_assessment asmt.id\n      final_scores = cells.map { |c| c[\"final_score\"] }\n      cols[asmt.name] = [\"asmt\", asmt, final_scores]\n    end\n\n    # category averages\n    @course.assessment_categories.each do |cat|\n      next unless matrix.has_category? cat\n\n      cols[\"#{cat} Average\"] = [\"avg\", nil, matrix.averages_for_category(cat)]\n    end\n\n    # course averages\n    cols[\"Course Average\"] = [\"avg\", nil, matrix.course_averages]\n\n    # calculate statistics\n    # send course_stats back in the form of\n    # name of average / assesment -> [type, asmt, statistics]\n    # where type = \"asmt\" or \"avg\" (assessment or average)\n    # asmt = assessment object or nil if an average of category / class\n    # statistics (statistics pertaining to asmt/avg (mean, median, std dev, etc))\n    @course_stats = {}\n    stat = Statistics.new\n    cols.each do |key, values|\n      @course_stats[key] = [values[0], values[1], stat.stats(values[2])]\n    end\n  end\n\n  def new\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n    @newCourse = Course.new\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.version_penalty = Penalty.new\n  end\n\n  def create\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n\n    @newCourse = Course.new(new_course_params)\n\n    @newCourse.display_name = @newCourse.name\n\n    # fill temporary values in other fields\n    @newCourse.late_slack = 0\n    @newCourse.grace_days = 0\n    @newCourse.start_date = Time.zone.now\n    @newCourse.end_date = Time.zone.now\n\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.late_penalty.kind = \"points\"\n    @newCourse.late_penalty.value = \"0\"\n\n    @newCourse.version_penalty = Penalty.new\n    @newCourse.version_penalty.kind = \"points\"\n    @newCourse.version_penalty.value = \"0\"\n\n    if @newCourse.save\n      instructor = User.where(email: params[:instructor_email]).first\n\n      # create a new user as instructor if he didn't exist\n      if instructor.nil?\n        begin\n          instructor = User.instructor_create(params[:instructor_email],\n                                              @newCourse.name)\n        rescue StandardError => e\n          # roll back course creation\n          @newCourse.destroy\n          flash[:error] = \"Can't create instructor for the course: #{e}\"\n          render(action: \"new\") && return\n        end\n\n      end\n\n      new_cud = @newCourse.course_user_data.new\n      new_cud.user = instructor\n      new_cud.instructor = true\n\n      if new_cud.save\n        begin\n          @newCourse.reload_course_config\n        rescue StandardError, SyntaxError\n          # roll back course creation and instruction creation\n          new_cud.destroy\n          @newCourse.destroy\n          flash[:error] = \"Can't load course config for #{@newCourse.name}.\"\n          render(action: \"new\") && return\n        else\n          flash[:success] = \"New Course #{@newCourse.name} successfully created!\"\n          redirect_to(edit_course_path(@newCourse)) && return\n        end\n      else\n        # roll back course creation\n        @newCourse.destroy\n        flash[:error] = \"Can't create instructor for the course.\"\n        render(action: \"new\") && return\n      end\n\n    else\n      flash[:error] = \"Course creation failed. Check all fields\"\n      render(action: \"new\") && return\n    end\n  end\n\n  action_auth_level :edit, :instructor\n  def edit; end\n\n  action_auth_level :update, :instructor\n  def update\n    uploaded_config_file = params[:editCourse][:config_file]\n    unless uploaded_config_file.nil?\n      config_source = uploaded_config_file.read\n\n      course_config_source_path = @course.source_config_file_path\n      File.open(course_config_source_path, \"w\") do |f|\n        f.write(config_source)\n      end\n\n      begin\n        @course.reload_course_config\n      rescue StandardError, SyntaxError => e\n        @error = e\n        render(\"reload\") && return\n      end\n    end\n\n    if @course.update(edit_course_params)\n      flash[:success] = \"Course configuration updated!\"\n    else\n      flash[:error] = \"Error: There were errors editing the course.\"\n      @course.errors.full_messages.each do |msg|\n        flash[:error] += \"<br>#{msg}\"\n      end\n      flash[:html_safe] = true\n    end\n    redirect_to edit_course_path(@course)\n  end\n\n  # DELETE courses/:id/\n  action_auth_level :destroy, :administrator\n  def destroy\n    # Delete config file copy in courseConfig\n    if File.exist? @course.config_file_path\n      File.delete @course.config_file_path\n    end\n    if File.exist? @course.config_backup_file_path\n      File.delete @course.config_backup_file_path\n    end\n\n    if @course.destroy\n      flash[:success] = \"Course destroyed.\"\n    else\n      flash[:error] = \"Error: Course wasn't destroyed!\"\n    end\n    redirect_to(courses_path) && return\n  end\n\n  # Non-RESTful Routes Below\n\n  def report_bug\n    return unless request.post?\n\n    CourseMailer.bug_report(\n      params[:title],\n      params[:summary],\n      current_user,\n      @course\n    ).deliver\n  end\n\n  # Only instructor (and above) can use this feature\n  # to look up user accounts and fill in cud fields\n  action_auth_level :user_lookup, :instructor\n  def user_lookup\n    if params[:email].empty?\n      flash[:error] = \"No email supplied for LDAP Lookup\"\n      render(action: :new, layout: false) && return\n    end\n\n    # make sure that user already exists in the database\n    user = User.where(email: params[:email]).first\n\n    render(json: nil) && return if user.nil?\n\n    @user_data = { first_name: user.first_name,\n                   last_name: user.last_name,\n                   email: user.email }\n\n    render json: @user_data\n  end\n\n  action_auth_level :users, :instructor\n  def users\n    @cuds = if params[:search]\n              # left over from when AJAX was used to find users on the admin users list\n              @course.course_user_data.joins(:user)\n                     .order(\"users.email ASC\")\n                     .where(CourseUserDatum\n                                .conditions_by_like(params[:search]))\n            else\n              @course.course_user_data.joins(:user).order(\"users.email ASC\")\n            end\n  end\n\n  action_auth_level :add_users_from_emails, :instructor\n  def add_users_from_emails\n    # check if user_emails and role exist in params\n    unless params.key?(:user_emails) && params.key?(:role)\n      flash[:error] = \"No user emails or role supplied\"\n      redirect_to(users_course_path(@course)) && return\n    end\n\n    user_emails = params[:user_emails].split(/\\n/).map(&:strip)\n\n    user_emails = user_emails.map do |email|\n      if email.nil?\n        nil\n        # when it's first name <email>\n      elsif email =~ /(.*)\\s+(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), middle_name: Regexp.last_match(2),\n          last_name: Regexp.last_match(3), email: Regexp.last_match(4) }\n        # when it's email\n      elsif email =~ /(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), last_name: Regexp.last_match(2),\n          email: Regexp.last_match(3) }\n        # when it's first name middle name last name <email>\n      elsif email =~ /(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), email: Regexp.last_match(2) }\n        # when it's first name last name <email>\n      else\n        { email: email }\n      end\n    end\n\n    # filter out nil emails\n    user_emails = user_emails.reject(&:nil?)\n\n    # check if email matches regex\n    email_regex = /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n    # raise error if any email is invalid and return which emails are invalid\n    invalid_emails = user_emails.reject { |user| user[:email] =~ email_regex }\n    if invalid_emails.any?\n      flash[:error] = \"Invalid email(s): #{invalid_emails.map { |user| user[:email] }.join(', ')}\"\n      redirect_to([:users, @course]) && return\n    end\n\n    role = params[:role]\n\n    @cuds = []\n    user_emails.each do |email|\n      user = User.find_by(email: email[:email])\n\n      # create users if they don't exist\n      if user.nil?\n        begin\n          user = if email[:first_name].nil? && email[:last_name].nil?\n                   User.roster_create(email[:email], email[:email], \"\", \"\", \"\", \"\")\n                 else\n                   User.roster_create(email[:email], email[:first_name] || \"\",\n                                      email[:last_name] || \"\", \"\", \"\", \"\")\n                 end\n        rescue StandardError => e\n          flash[:error] = \"Error: #{e.message}\"\n          redirect_to([:users, @course]) && return\n        end\n\n        if user.nil?\n          flash[:error] = \"Error: User #{email} could not be created.\"\n          redirect_to([:users, @course]) && return\n        end\n      end\n\n      # if user already exists in the course, retrieve the cud\n      cud = @course.course_user_data.find_by(user_id: user.id)\n\n      # if user doesn't exist in the course, create a new cud\n      if cud.nil?\n        cud = @course.course_user_data.new\n        cud.user = user\n      end\n\n      # set the role of the user\n      case role\n      when \"instructor\"\n        cud.instructor = true\n        cud.course_assistant = false\n      when \"ca\"\n        cud.instructor = false\n        cud.course_assistant = true\n      when \"student\"\n        cud.instructor = false\n        cud.course_assistant = false\n      # if role is not valid, return error\n      else\n        flash[:error] = \"Error: Invalid role #{role}.\"\n        redirect_to([:users, @course]) && return\n      end\n\n      # add the cud to the list of cuds to be saved\n      @cuds << cud\n    end\n\n    # save all the cuds\n    if @cuds.all?(&:save)\n      flash[:success] = \"Success: Users added to course.\"\n    else\n      flash[:error] = \"Error: Users could not be added to course.\"\n    end\n    redirect_to([:users, @course]) && return\n  end\n\n  action_auth_level :unlink_course, :instructor\n  def unlink_course\n    lcd = LtiCourseDatum.find_by(course_id: @course.id)\n\n    if lcd.nil?\n      flash[:error] = \"Unable to unlink course\"\n      redirect_to(action: :users) && return\n    end\n\n    lcd.destroy\n    flash[:success] = \"Course unlinked\"\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :update_lti_settings, :instructor\n  def update_lti_settings\n    lcd = @course.lti_course_datum\n    lcd.drop_missing_students = params[:lcd][:drop_missing_students] == \"1\"\n    lcd.save\n\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :reload, :instructor\n  def reload\n    @course.reload_course_config\n  rescue StandardError, SyntaxError => e\n    @error = e\n    # let the reload view render\n  else\n    flash[:success] = \"Success: Course config file reloaded!\"\n    redirect_to([@course]) && return\n  end\n\n  # Upload a CSV roster and import the users into the course\n  # Colors are associated to each row of CUD after roster is processed:\n  #   green - User doesn't exist in the course, and is going to be added\n  #   red - User is going to be dropped from the course\n  #   black - User exists in the course\n  action_auth_level :upload_roster, :instructor\n  def upload_roster\n    return unless request.post?\n\n    # Check if any file is attached\n    if params[\"upload\"] && params[\"upload\"][\"file\"].nil?\n      flash[:error] = \"Please attach a roster!\"\n      redirect_to(action: :upload_roster) && return\n    end\n\n    if params[:doIt]\n      begin\n        save_uploaded_roster\n        flash[:success] = \"Successfully updated roster!\"\n        redirect_to(action: \"users\") && return\n      rescue StandardError => e\n        if e != \"Roster validation error\"\n          flash[:error] = e\n        end\n        redirect_to(action: \"upload_roster\") && return\n      end\n    else\n      parse_roster_csv\n    end\n  end\n\n  action_auth_level :download_roster, :instructor\n  def download_roster\n    @cuds = @course.course_user_data.where(instructor: false,\n                                           course_assistant: false,\n                                           dropped: false)\n    output = \"\"\n    @cuds.each do |cud|\n      user = cud.user\n      # to_csv avoids issues with commas\n      output += [@course.semester, cud.user.email, user.last_name, user.first_name,\n                 cud.school, cud.major, cud.year, cud.grade_policy,\n                 @course.name, cud.lecture, cud.section].to_csv\n    end\n    send_data output, filename: \"roster.csv\", type: \"text/csv\", disposition: \"inline\"\n  end\n\n  # install_assessment - Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory.\n  action_auth_level :install_assessment, :instructor\n  def install_assessment\n    @assignDir = Rails.root.join(\"courses\", @course.name)\n    @availableAssessments = []\n    begin\n      Dir.foreach(@assignDir) do |filename|\n        if File.exist?(File.join(@assignDir, filename, \"#{filename}.rb\"))\n          # names must be only lowercase letters and digits\n          next if filename =~ /[^a-z0-9]/\n\n          # Only list assessments that aren't installed yet\n          assessment = @course.assessments.where(name: filename).first\n          @availableAssessments << filename unless assessment\n        end\n      end\n      @availableAssessments = @availableAssessments.sort\n    rescue StandardError => e\n      render(text: \"<h3>#{e}</h3>\", layout: true) && return\n    end\n  end\n\n  # email - The email action allows instructors to email the entire course, or\n  # a single section at a time.  Sections are passed via params[:section].\n  action_auth_level :email, :instructor\n  def email\n    return unless request.post?\n\n    section = (params[:section] if !params[:section].empty?)\n\n    # don't email kids who dropped!\n    @cuds = if section\n              @course.course_user_data.where(dropped: false, section: section)\n            else\n              @course.course_user_data.where(dropped: false)\n            end\n\n    bccString = make_dlist(@cuds)\n\n    @email = CourseMailer.course_announcement(\n      params[:from],\n      bccString,\n      params[:subject],\n      params[:body],\n      @cud,\n      @course\n    )\n    @email.deliver\n  end\n\n  action_auth_level :moss, :instructor\n  def moss; end\n\n  LANGUAGE_WHITELIST = %w[c cc java ml pascal ada lisp scheme haskell fortran ascii vhdl perl\n                          matlab python mips prolog spice vb csharp modula2 a8086 javascript plsql\n                          verilog].freeze\n\n  action_auth_level :run_moss, :instructor\n  def run_moss\n    # Return if we have no files to process.\n    unless params[:assessments] || params[:external_tar]\n      flash[:error] = \"No input files provided for MOSS.\"\n      redirect_to(action: :moss) && return\n    end\n    assessmentIDs = params[:assessments]\n    assessments = []\n\n    # First, validate access on each of the requested assessments\n    assessmentIDs&.keys&.each do |aid|\n      assessment = Assessment.find(aid)\n      unless assessment\n        flash[:error] = \"Invalid Assessment ID: #{aid}\"\n        redirect_to(action: :moss) && return\n      end\n      assessmentCUD = assessment.course.course_user_data.joins(:user).find_by(\n        users: { email: current_user.email }, instructor: true\n      )\n      if !assessmentCUD && !@cud.user.administrator?\n        flash[:error] = \"Invalid User\"\n        redirect_to(action: :moss) && return\n      end\n      assessments << assessment\n    end\n\n    # Create a temporary directory\n    @failures = []\n    tmp_dir = Dir.mktmpdir(\"#{@cud.user.email}Moss\", Rails.root.join(\"tmp\"))\n\n    files = params[:files]\n    base_file = params[:box_basefile]\n    max_lines = params[:box_max]\n    language = params[:box_language]\n\n    moss_params = \"\"\n    files&.each do |_, v|\n      # Space-separated patterns\n      patternList = v.split(\" \")\n      # Each pattern consists of one or more segments, where each segment consists of\n      # - a leading period (optional)\n      # - a word character (A..Z, a..z, 0..9, _), or hyphen (-), or asterisk (*)\n      # Each pattern optionally ends with a period\n      # OKAY: foo.c *.c * .c README foo_c foo-c .* **\n      # NOT OKAY: . ..\n      patternList.each do |pattern|\n        unless pattern =~ /\\A(\\.?[\\w*-])+\\.?\\z/\n          flash[:error] = \"Invalid file pattern\"\n          redirect_to(action: :moss) && return\n        end\n      end\n    end\n    unless base_file.nil?\n      extract_tar_for_moss(tmp_dir, params[:base_tar], false)\n      moss_params = [moss_params, \"-b\", @basefiles].join(\" \")\n    end\n    unless max_lines.nil?\n      params[:max_lines] = 10 if params[:max_lines] == \"\"\n      # Only accept positive integers (> 0)\n      unless params[:max_lines] =~ /\\A[1-9]([0-9]*)?\\z/\n        flash[:error] = \"Invalid max lines\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-m\", params[:max_lines]].join(\" \")\n    end\n    unless language.nil?\n      unless LANGUAGE_WHITELIST.include? params[:language_selection]\n        flash[:error] = \"Invalid language\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-l\", params[:language_selection]].join(\" \")\n    end\n\n    # Get moss flags from text field\n    moss_flags = [\"mossnet#{moss_params} -d\"].join(\" \")\n    @mossCmd = [Rails.root.join(\"vendor\", moss_flags)]\n\n    extract_asmt_for_moss(tmp_dir, assessments)\n    extract_tar_for_moss(tmp_dir, params[:external_tar], true)\n\n    # Ensure that all files in Moss tmp dir are readable\n    system(\"chmod -R a+r #{tmp_dir}\")\n    ActiveRecord::Base.clear_active_connections!\n    # Remove non text files when making a moss run\n    `~/Autolab/script/cleanMoss #{tmp_dir}`\n    # Now run the Moss command\n    @mossCmdString = @mossCmd.join(\" \")\n    @mossOutput = `#{@mossCmdString} 2>&1`\n    @mossExit = $?.exitstatus\n\n    # Clean up after ourselves (droh: leave for debugging)\n    `rm -rf #{tmp_dir}`\n  end\n\nprivate\n\n  def new_course_params\n    params.require(:newCourse).permit(:name, :semester)\n  end\n\n  def edit_course_params\n    params.require(:editCourse).permit(:semester, :website, :late_slack,\n                                       :grace_days, :display_name, :start_date, :end_date,\n                                       :disabled, :exam_in_progress, :version_threshold,\n                                       :gb_message, late_penalty_attributes: %i[kind value],\n                                                    version_penalty_attributes: %i[kind value])\n  end\n\n  def categorize_courses_for_listing(courses)\n    listing = {}\n\n    # temporal\n    listing[:current] = []\n    listing[:completed] = []\n    listing[:upcoming] = []\n\n    listing[:disabled] = []\n    # categorize\n    courses.each do |course|\n      if course.disabled?\n        listing[:disabled] << course\n      else\n        listing[course.temporal_status] << course\n      end\n    end\n\n    listing\n  end\n\n  def write_cuds(cuds)\n    rowNum = 0\n    rosterErrors = {}\n    rowCUDs = []\n    duplicates = Set.new\n\n    cuds.each do |new_cud|\n      cloneCUD = new_cud.clone\n      cloneCUD[:row_num] = rowNum + 2\n      rowCUDs.push(cloneCUD)\n\n      case new_cud[:color]\n      when \"green\"\n        # Add this user to the course\n        # Look for this user\n        email = new_cud[:email]\n        first_name = new_cud[:first_name]\n        last_name = new_cud[:last_name]\n        school = new_cud[:school]\n        major = new_cud[:major]\n        year = new_cud[:year]\n\n        if (user = User.where(email: email).first).nil?\n          begin\n            # Create a new user\n            user = User.roster_create(email, first_name, last_name, school,\n                                      major, year)\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        else\n          # Override current user\n          user.first_name = first_name\n          user.last_name = last_name\n          user.school = school\n          user.major = major\n          user.year = year\n          begin\n            user.save!\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        end\n\n        existing = @course.course_user_data.where(user: user).first\n        # Make sure this user doesn't have a cud in the course\n        if existing\n          duplicates.add(new_cud[:email])\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # Build cud\n        if !user.nil?\n          cud = @course.course_user_data.new\n          cud.user = user\n          params = ActionController::Parameters.new(\n            course_number: new_cud[:course_number],\n            lecture: new_cud[:lecture],\n            section: new_cud[:section],\n            grade_policy: new_cud[:grade_policy]\n          )\n          cud.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n\n          # Save without validations\n          cud.save(validate: false)\n        end\n\n      when \"red\"\n        # Drop this user from the course\n        existing = @course.course_user_data.includes(:user)\n                          .where(users: { email: new_cud[:email] }).first\n\n        fail \"Red CUD doesn't exist in the database.\" if existing.nil?\n\n        existing.dropped = true\n        existing.save(validate: false)\n      else\n        # Update this user's attributes.\n        existing = @course.course_user_data.includes(:user)\n                          .where(\"lower(users.email) = ?\", new_cud[:email].downcase)\n                          .references(:users).first\n        # existing = @course.course_user_data.includes(:user).\n        # where(users[:email].matches(\"%#{new_cud[:email]}%\")).first\n\n        fail \"Black CUD doesn't exist in the database.\" if existing.nil?\n\n        user = existing.user\n        if user.nil?\n          fail \"User associated to black CUD doesn't exist in the database.\"\n        end\n\n        # Update user data\n        user.first_name = new_cud[:first_name]\n        user.last_name = new_cud[:last_name]\n        user.school = new_cud[:school]\n        user.major = new_cud[:major]\n        user.year = new_cud[:year]\n\n        begin\n          user.save!\n        rescue StandardError => e\n          msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n          if !rosterErrors.key?(msg)\n            rosterErrors[msg] = []\n          end\n          rosterErrors[msg].push(cloneCUD)\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # assign attributes\n        params = ActionController::Parameters.new(\n          course_number: new_cud[:course_number],\n          lecture: new_cud[:lecture],\n          section: new_cud[:section],\n          grade_policy: new_cud[:grade_policy]\n        )\n        existing.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n        existing.dropped = false\n        existing.save(validate: false) # Save without validations.\n      end\n      rowNum += 1\n    end\n\n    rowCUDs.each do |cud|\n      next unless duplicates.include?(cud[:email])\n\n      msg = \"Validation failed: Duplicate email #{cud[:email]}\"\n      if !rosterErrors.key?(msg)\n        rosterErrors[msg] = []\n      end\n      rosterErrors[msg].push(cud)\n    end\n\n    return if rosterErrors.empty?\n\n    flash[:roster_error] = rosterErrors\n    fail \"Roster validation error\"\n  end\n\n  def save_uploaded_roster\n    cuds = []\n\n    rowNum = 0\n    until params[\"cuds\"][rowNum.to_s].nil?\n      cuds.push(params[\"cuds\"][rowNum.to_s])\n      rowNum += 1\n    end\n\n    CourseUserDatum.transaction do\n      write_cuds(cuds)\n    end\n  end\n\n  def change_view(is_sorted)\n    @cud_view = if is_sorted\n                  @sorted_cuds\n                else\n                  @cuds\n                end\n  end\n\n  def parse_roster_csv\n    # generate doIt form from the upload\n    @cuds = []\n    @currentCUDs = @course.course_user_data.all.to_a\n    @new_cuds = []\n\n    begin\n      csv = detect_and_convert_roster(params[\"upload\"][\"file\"].read)\n      csv.each do |row|\n        new_cud = { # Ignore Semester (row[0])\n          email: row[1].to_s,\n          last_name: row[2].to_s.chomp(\" \"),\n          first_name: row[3].to_s.chomp(\" \"),\n          school: row[4].to_s.chomp(\" \"),\n          major: row[5].to_s.chomp(\" \"),\n          year: row[6].to_s.chomp(\" \"),\n          grade_policy: row[7].to_s.chomp(\" \"),\n          course_number: row[8].to_s.chomp(\" \"),\n          lecture: row[9].to_s.chomp(\" \"),\n          section: row[10].to_s.chomp(\" \")\n        }\n        cud = @currentCUDs.find do |current|\n          current.user && current.user.email.downcase == new_cud[:email].downcase\n        end\n\n        if !cud\n          new_cud[:color] = \"green\"\n        else\n          @currentCUDs.delete(cud)\n        end\n        @cuds << new_cud\n      end\n    rescue CSV::MalformedCSVError => e\n      flash[:error] = \"Error parsing CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n    rescue StandardError => e\n      flash[:error] = \"Error uploading the CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n      raise e\n    end\n\n    # drop the rest if indicated\n    if params[:upload][:dropMissing] == \"1\"\n      # We never drop instructors, remove them first\n      @currentCUDs.delete_if do |cud|\n        cud.instructor? || cud.user.administrator? || cud.course_assistant?\n      end\n      @currentCUDs.each do |cud| # These are the drops\n        new_cud = {\n          email: cud.user.email,\n          last_name: cud.user.last_name,\n          first_name: cud.user.first_name,\n          school: cud.school,\n          major: cud.major,\n          year: cud.year,\n          grade_policy: cud.grade_policy,\n          course_number: cud.course_number,\n          lecture: cud.lecture,\n          section: cud.section,\n          color: \"red\"\n        }\n        @cuds << new_cud\n      end\n    end\n\n    # do dry run for error checking\n    CourseUserDatum.transaction do\n      cloned_cuds = Marshal.load(Marshal.dump(@cuds))\n      begin\n        write_cuds(cloned_cuds)\n      rescue StandardError => e\n        redirect_to(action: \"upload_roster\")\n      ensure\n        raise ActiveRecord::Rollback\n      end\n    end\n\n    @sorted_cuds = @cuds.sort_by { |cud| cud[:color] || \"z\" }\n    @cud_view = @sorted_cuds\n  end\n\n  # detect_and_convert_roster - Detect the type of a roster based on roster\n  # column matching and convert to default roster\n\n  # map fields:\n  # map[0]: semester (unused)\n  # map[1]: email\n  # map[2]: last_name\n  # map[3]: first_name\n  # map[4]: school\n  # map[5]: major\n  # map[6]: year\n  # map[7]: grade_policy\n  # map[8]: course\n  # map[9]: lecture\n  # map[10]: section\n  # rubocop:disable Lint/UselessAssignment\n  def detect_and_convert_roster(roster)\n    raise \"Roster is empty\" if roster.empty?\n\n    parsedRoster = CSV.parse(roster, skip_blanks: true)\n    raise \"Roster cannot be recognized\" if parsedRoster[0][0].nil?\n\n    case parsedRoster[0].length\n    when ROSTER_COLUMNS_F20 # 34 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11 - skip), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Time Zone Code(22), Time Zone Description(23), Added By(24),\n      # Added On(25), Confirmed(26), Waitlist Position(27), Units Carried/Max Units(28),\n      # Waitlisted By(29), Waitlisted On(30), Dropped By(31), Dropped On(32), Roster As Of Date(33)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F20\n    when ROSTER_COLUMNS_F16 # 32 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Added By(22), Added On(23), Confirmed(24), Waitlist Position(25),\n      # Units Carried/Max Units(26), Waitlisted By(27), Waitlisted On(28), Dropped By(29),\n      # Dropped On(30), Roster As Of Date(31)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F16\n    when ROSTER_COLUMNS_S15 # 29 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Lecture(1), Section(2), (skip)(3), (skip)(4), Last Name(5),\n      # First Name(6), (skip)(7), Andrew ID(8), (skip)(9), School(10),\n      # Major(11), Year(12), (skip)(13), Grade Policy(14), ... [elided]\n      map = [-1, 8, 5, 6, 10, 11, 12, 14, -1, 1, 2]\n      select_columns = ROSTER_COLUMNS_S15\n    else\n      # No header row. Columns are:\n      # Semester(0 - skip), Email(1), Last Name(2), First Name(3), School(4),\n      # Major(5), Year(6), Grade Policy(7), Course(8), Lecture(9),\n      # Section(10)\n      return parsedRoster\n    end\n    # rubocop:enable Lint/UselessAssignment\n\n    # Detect if there is a header row\n    offset = if parsedRoster[0][0] == \"Semester\"\n               1\n             else\n               0\n             end\n    numRows = parsedRoster.length - offset\n    convertedRoster = Array.new(numRows) { Array.new(11) }\n\n    domain = if Rails.env.production?\n               \"andrew.cmu.edu\"\n             else\n               \"foo.bar\"\n             end\n    (0..(numRows - 1)).each do |i|\n      11.times do |j|\n        next unless map[j] >= 0\n\n        convertedRoster[i][j] = if j == 1\n                                  \"#{parsedRoster[i + offset][map[j]]}@#{domain}\"\n                                else\n                                  parsedRoster[i + offset][map[j]]\n                                end\n      end\n    end\n    convertedRoster\n  end\n\n  def extract_asmt_for_moss(tmp_dir, assessments)\n    # for each assessment\n    assessments.each do |ass|\n      # Create a directory for ths assessment\n      assDir = File.join(tmp_dir, \"#{ass.name}-#{ass.course.name}\")\n      Dir.mkdir(assDir)\n\n      # params[:isArchive] might be nil if no archive assessments are submitted\n      isArchive = params[:isArchive] && params[:isArchive][ass.id.to_s]\n\n      visitedGroups = Set.new\n\n      # For each student who submitted\n      ass.submissions.latest.each do |sub|\n        subFile = sub.handin_file_path\n        next unless subFile && File.exist?(subFile)\n\n        if ass.has_groups?\n          group_id = sub.aud.group_id\n          next if visitedGroups.include?(group_id)\n\n          visitedGroups.add(group_id)\n        end\n\n        # Create a directory for this student\n        stuDir = File.join(assDir, sub.course_user_datum.email)\n        Dir.mkdir(stuDir)\n\n        # Copy their submission over\n        FileUtils.cp(subFile, stuDir)\n\n        # Read archive files\n        next unless isArchive\n\n        # If we need to unarchive this file, then create archive reader\n        archive_path = File.join(stuDir, sub.filename)\n        begin\n          archive_extract = Archive.get_archive(archive_path)\n\n          archive_extract.each do |entry|\n            pathname = Archive.get_entry_name(entry)\n            next if Archive.looks_like_directory?(pathname)\n\n            pathname.gsub!(%r{/}, \"-\")\n            destination = File.join(stuDir, pathname)\n            # make sure all subdirectories are there\n            FileUtils.mkdir_p(File.dirname(destination))\n            File.open(destination, \"wb\") do |out|\n              out.write Archive.read_entry_file(entry)\n              begin\n                out.fsync\n              rescue StandardError\n                nil\n              end\n            end\n          end\n        rescue StandardError\n          @failures << sub.filename\n        end\n      end\n\n      # add this assessment to the moss command\n      patternList = params[\"files\"][ass.id.to_s].split(\" \")\n      patternList.each do |pattern|\n        @mossCmd << File.join(assDir, [\"*\", pattern])\n      end\n    end\n  end\n\n  def extract_tar_for_moss(tmp_dir, external_tar, archive)\n    return unless external_tar\n\n    # Directory to hold tar ball and all individual files.\n    extTarDir = File.join(tmp_dir, \"external_input\")\n    baseFilesDir = File.join(tmp_dir, \"basefiles\")\n    begin\n      Dir.mkdir(extTarDir)\n      Dir.mkdir(baseFilesDir) # To hold all basefiles\n    rescue StandardError\n      nil\n    end\n\n    # Read in the tarfile from the given source.\n    extTarPath = File.join(extTarDir, \"input_file\")\n    external_tar.rewind\n    File.open(extTarPath, \"wb\") { |f| f.write(external_tar.read) } # Write tar file.\n\n    # Directory to hold all external individual submission.\n    extFilesDir = File.join(extTarDir, \"submissions\")\n\n    begin\n      Dir.mkdir(extFilesDir) # To hold all submissions\n    rescue StandardError\n      nil\n    end\n\n    # Untar the given Tar file.\n    begin\n      archive_extract = Archive.get_archive(extTarPath)\n\n      # write each file, renaming nested files\n      archive_extract.each do |entry|\n        pathname = Archive.get_entry_name(entry)\n        next if Archive.looks_like_directory?(pathname)\n\n        destination = if archive\n                        File.join(extFilesDir,\n                                  pathname)\n                      else\n                        File.join(baseFilesDir, pathname)\n                      end\n        pathname.gsub!(%r{/}, \"-\")\n        # make sure all subdirectories are there\n        File.open(destination, \"wb\") do |out|\n          out.write Archive.read_entry_file(entry)\n          begin\n            out.fsync\n          rescue StandardError\n            nil\n          end\n        end\n      end\n    rescue StandardError\n      @failures << \"External Tar\"\n    end\n\n    # Feed the uploaded files to MOSS.\n    if archive\n      @mossCmd << File.join(extFilesDir, \"*\")\n    else\n      @basefiles = File.join(baseFilesDir, \"*\")\n    end\n  end\nend\n", "require \"rubygems\"\nrequire \"rubygems/package\"\nrequire \"tempfile\"\nrequire \"zlib\"\nrequire \"zip\"\n\n##\n# This module provides functionality for dealing with Archives, including zips,\n# tars, and gunzipped tars\n#\nmodule Archive\n  def self.get_files(archive_path)\n    archive_type = get_archive_type(archive_path)\n    archive_extract = get_archive(archive_path, archive_type)\n\n    files = []\n\n    # Parse archive header\n    archive_extract.each_with_index do |entry, i|\n      # Obtain path name depending for tar/zip entry\n      pathname = get_entry_name(entry)\n\n      files << {\n        pathname: pathname,\n        header_position: i,\n        mac_bs_file: pathname.include?(\"__MACOSX\") ||\n          pathname.include?(\".DS_Store\") ||\n          pathname.include?(\".metadata\"),\n        directory: looks_like_directory?(pathname)\n      }\n    end\n\n    archive_extract.close\n\n    files\n  end\n\n  def self.recoverHierarchy(files, root)\n    depth = root[:pathname].chomp(\"/\").count \"/\"\n    if(root[:pathname] == \"\")\n      depth = -1\n    end\n    if(!root[:directory])\n      return root\n    end\n    subFiles = []\n    filesNestedSomewhere = files.select{|entry| entry[:pathname].start_with?(root[:pathname]) && !(entry[:pathname] == root[:pathname])}\n    for file in filesNestedSomewhere\n      fileDepth = file[:pathname].chomp(\"/\").count \"/\"\n      if(fileDepth == depth+1)\n        subFiles << recoverHierarchy(filesNestedSomewhere, file)\n      end\n    end\n    subFiles.sort! { |a, b| a[:header_position] <=> b[:header_position] }\n    root[:subfiles] = subFiles\n    return root\n  end\n\n  # given a list of files, sanitize and create\n  # missing file directories\n  def self.sanitize_directories(files)\n\n    cleaned_files = []\n    file_path_set = Set[]\n    \n    # arbitrary header positions for the new directories\n    starting_header = -1\n\n    # add pre-existing directories to the set\n    for file in files\n\n      # edge case for removing \"./\" from pathnames\n      if file[:pathname].include?(\"./\")\n        file[:pathname] = file[:pathname].split(\"./\")[1]\n      end\n\n      if(file[:directory])\n        file_path_set.add(file[:pathname])\n      end\n    end\n\n    for file in files\n      # for each file, check if each of its directories and subdir\n      # exist. If it does not, create and add them\n      if(!file[:directory])\n        paths = file[:pathname].split(\"/\")\n        mac_bs_file = false\n        for path in paths do\n          # note that __MACOSX is actually a folder\n          # need to check whether the path includes that\n          # for the completeness of cleaned_files\n          # mac_bs_file folder paths will still be added\n          if path.include?(\"__MACOSX\") || path.include?(\".DS_Store\") ||\n             path.include?(\".metadata\")\n             mac_bs_file = true\n             break\n          end\n        end\n        for i in 1..(paths.size - 1) do\n          new_path = paths[0,paths.size-i].join(\"/\") + \"/\"\n          if(!file_path_set.include?(new_path))\n            cleaned_files.append({\n              :pathname=>new_path,\n              :header_position=>starting_header,\n              :mac_bs_file=>mac_bs_file,\n              :directory=>true\n            })\n            starting_header = starting_header - 1\n            file_path_set.add(new_path)\n          end\n        end \n      end\n      \n      # excludes \"./\" paths\n      if(file[:pathname]!=nil)\n        cleaned_files.append(file)\n      end\n    end\n\n    cleaned_files\n  end\n\n  def self.get_file_hierarchy(archive_path)\n    files = get_files(archive_path)\n    files = sanitize_directories(files)\n    res = recoverHierarchy(files, {pathname: \"\", directory: true})\n    return res[:subfiles]\n  end\n\n  def self.get_nth_file(archive_path, n)\n    archive_type = get_archive_type(archive_path)\n    archive_extract = get_archive(archive_path, archive_type)\n\n    # Parse archive header\n    res = nil, nil\n    archive_extract.each_with_index do |entry, i|\n      # Obtain path name depending for tar/zip entry\n      pathname = get_entry_name(entry)\n\n      next if pathname.include?(\"__MACOSX\") ||\n              pathname.include?(\".DS_Store\") ||\n              pathname.include?(\".metadata\") ||\n              i != n\n\n      if looks_like_directory?(pathname)\n        res = nil, pathname\n      else\n        res = read_entry_file(entry), get_entry_name(entry)\n      end\n      break\n    end\n\n    archive_extract.close\n\n    res\n  end\n\n  def self.get_nth_filename(files, n)\n    files[n][:pathname]\n  end\n\n  def self.get_archive_type(filename)\n    IO.popen([\"file\", \"--brief\", \"--mime-type\", filename], in: :close, err: :close) do |io|\n      io.read.chomp\n    end\n  end\n\n  def self.archive?(filename)\n    return nil unless filename\n    archive_type = get_archive_type(filename)\n    (archive_type.include?(\"tar\") || archive_type.include?(\"gzip\") || archive_type.include?(\"zip\"))\n  end\n\n  def self.get_archive(filename, archive_type = nil)\n    archive_type = get_archive_type(filename) if archive_type.nil?\n\n    if archive_type.include? \"tar\"\n      archive_extract = Gem::Package::TarReader.new(File.new(filename))\n      archive_extract.rewind # The extract has to be rewinded after every iteration\n    elsif archive_type.include? \"gzip\"\n      archive_extract = Gem::Package::TarReader.new(Zlib::GzipReader.open(filename))\n      archive_extract.rewind\n    elsif archive_type.include? \"zip\"\n      archive_extract = Zip::File.open(filename)\n    else\n      fail \"Unrecognized archive type!\"\n    end\n    archive_extract\n  end\n\n  def self.get_entry_name(entry)\n    # tar/tgz vs zip\n    name = entry.respond_to?(:full_name) ? entry.full_name : entry.name\n    if ! name.ascii_only?\n      name = String.new(name)\n      name.force_encoding(\"UTF-8\")\n      if ! name.valid_encoding?\n        # not utf-8. Assume single byte and choose windows western, since\n        # iso8859-1 printables are a subset\n        name.force_encoding(\"Windows-1252\")\n        name.encode!()\n      end\n    end\n    name\n  end\n\n  def self.read_entry_file(entry)\n    # tar/tgz vs zip\n    entry.respond_to?(:read) ? entry.read : entry.get_input_stream.read\n  end\n\n  ##\n  # returns a zip archive containing every file in the given path array\n  #\n  def self.create_zip(paths)\n    return nil if paths.nil? || paths.empty?\n\n    # don't create a tempfile, just stream it to client for download\n    zip_stream = Zip::OutputStream.write_buffer do |zos|\n      paths.each do |filepath|\n        ctimestamp = Zip::DOSTime.at(File.open(filepath,\"r\").ctime) # use creation time of submitted file\n        zip_entry = Zip::Entry.new(zos, \"#{File.basename(filepath)}\", nil, nil, nil, nil, nil, nil,\n                    ctimestamp)\n        zos.put_next_entry(zip_entry)\n        zos.print File.read(filepath)\n      end\n    end\n    zip_stream.rewind\n    zip_stream\n  end\n\n  def self.looks_like_directory?(pathname)\n    pathname.ends_with?(\"/\")\n  end\nend\n"], "fixing_code": ["require \"archive\"\nrequire \"csv\"\nrequire \"fileutils\"\nrequire \"pathname\"\nrequire \"statistics\"\n\nclass CoursesController < ApplicationController\n  skip_before_action :set_course, only: %i[courses_redirect index new create]\n  # you need to be able to pick a course to be authorized for it\n  skip_before_action :authorize_user_for_course, only: %i[courses_redirect index new create]\n  # if there's no course, there are no persistent announcements for that course\n  skip_before_action :update_persistent_announcements, only: %i[courses_redirect index new create]\n\n  rescue_from ActionView::MissingTemplate do |_exception|\n    redirect_to(\"/home/error_404\")\n  end\n\n  def index\n    courses_for_user = User.courses_for_user current_user\n\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n  end\n\n  def courses_redirect\n    courses_for_user = User.courses_for_user current_user\n    redirect_to(home_no_user_path) && return unless courses_for_user.any?\n\n    @listing = categorize_courses_for_listing courses_for_user\n    # if only enrolled in one course (currently), go to that course\n    # only happens when first loading the site, not when user goes back to courses\n    if @listing[:current].one?\n      course_name = @listing[:current][0].name\n      redirect_to course_assessments_url(course_name)\n    else\n      redirect_to(action: :index)\n    end\n  end\n\n  action_auth_level :show, :student\n  def show\n    redirect_to course_assessments_url(@course)\n  end\n\n  ROSTER_COLUMNS_S15 = 29\n  ROSTER_COLUMNS_F16 = 32\n  ROSTER_COLUMNS_F20 = 34\n\n  action_auth_level :manage, :instructor\n  def manage\n    matrix = GradeMatrix.new @course, @cud\n    cols = {}\n    # extract assessment final scores\n    @course.assessments.each do |asmt|\n      next unless matrix.has_assessment? asmt.id\n\n      cells = matrix.cells_for_assessment asmt.id\n      final_scores = cells.map { |c| c[\"final_score\"] }\n      cols[asmt.name] = [\"asmt\", asmt, final_scores]\n    end\n\n    # category averages\n    @course.assessment_categories.each do |cat|\n      next unless matrix.has_category? cat\n\n      cols[\"#{cat} Average\"] = [\"avg\", nil, matrix.averages_for_category(cat)]\n    end\n\n    # course averages\n    cols[\"Course Average\"] = [\"avg\", nil, matrix.course_averages]\n\n    # calculate statistics\n    # send course_stats back in the form of\n    # name of average / assesment -> [type, asmt, statistics]\n    # where type = \"asmt\" or \"avg\" (assessment or average)\n    # asmt = assessment object or nil if an average of category / class\n    # statistics (statistics pertaining to asmt/avg (mean, median, std dev, etc))\n    @course_stats = {}\n    stat = Statistics.new\n    cols.each do |key, values|\n      @course_stats[key] = [values[0], values[1], stat.stats(values[2])]\n    end\n  end\n\n  def new\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n    @newCourse = Course.new\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.version_penalty = Penalty.new\n  end\n\n  def create\n    # check for permission\n    unless current_user.administrator?\n      flash[:error] = \"Permission denied.\"\n      redirect_to(root_path) && return\n    end\n\n    @newCourse = Course.new(new_course_params)\n\n    @newCourse.display_name = @newCourse.name\n\n    # fill temporary values in other fields\n    @newCourse.late_slack = 0\n    @newCourse.grace_days = 0\n    @newCourse.start_date = Time.zone.now\n    @newCourse.end_date = Time.zone.now\n\n    @newCourse.late_penalty = Penalty.new\n    @newCourse.late_penalty.kind = \"points\"\n    @newCourse.late_penalty.value = \"0\"\n\n    @newCourse.version_penalty = Penalty.new\n    @newCourse.version_penalty.kind = \"points\"\n    @newCourse.version_penalty.value = \"0\"\n\n    if @newCourse.save\n      instructor = User.where(email: params[:instructor_email]).first\n\n      # create a new user as instructor if he didn't exist\n      if instructor.nil?\n        begin\n          instructor = User.instructor_create(params[:instructor_email],\n                                              @newCourse.name)\n        rescue StandardError => e\n          # roll back course creation\n          @newCourse.destroy\n          flash[:error] = \"Can't create instructor for the course: #{e}\"\n          render(action: \"new\") && return\n        end\n\n      end\n\n      new_cud = @newCourse.course_user_data.new\n      new_cud.user = instructor\n      new_cud.instructor = true\n\n      if new_cud.save\n        begin\n          @newCourse.reload_course_config\n        rescue StandardError, SyntaxError\n          # roll back course creation and instruction creation\n          new_cud.destroy\n          @newCourse.destroy\n          flash[:error] = \"Can't load course config for #{@newCourse.name}.\"\n          render(action: \"new\") && return\n        else\n          flash[:success] = \"New Course #{@newCourse.name} successfully created!\"\n          redirect_to(edit_course_path(@newCourse)) && return\n        end\n      else\n        # roll back course creation\n        @newCourse.destroy\n        flash[:error] = \"Can't create instructor for the course.\"\n        render(action: \"new\") && return\n      end\n\n    else\n      flash[:error] = \"Course creation failed. Check all fields\"\n      render(action: \"new\") && return\n    end\n  end\n\n  action_auth_level :edit, :instructor\n  def edit; end\n\n  action_auth_level :update, :instructor\n  def update\n    uploaded_config_file = params[:editCourse][:config_file]\n    unless uploaded_config_file.nil?\n      config_source = uploaded_config_file.read\n\n      course_config_source_path = @course.source_config_file_path\n      File.open(course_config_source_path, \"w\") do |f|\n        f.write(config_source)\n      end\n\n      begin\n        @course.reload_course_config\n      rescue StandardError, SyntaxError => e\n        @error = e\n        render(\"reload\") && return\n      end\n    end\n\n    if @course.update(edit_course_params)\n      flash[:success] = \"Course configuration updated!\"\n    else\n      flash[:error] = \"Error: There were errors editing the course.\"\n      @course.errors.full_messages.each do |msg|\n        flash[:error] += \"<br>#{msg}\"\n      end\n      flash[:html_safe] = true\n    end\n    redirect_to edit_course_path(@course)\n  end\n\n  # DELETE courses/:id/\n  action_auth_level :destroy, :administrator\n  def destroy\n    # Delete config file copy in courseConfig\n    if File.exist? @course.config_file_path\n      File.delete @course.config_file_path\n    end\n    if File.exist? @course.config_backup_file_path\n      File.delete @course.config_backup_file_path\n    end\n\n    if @course.destroy\n      flash[:success] = \"Course destroyed.\"\n    else\n      flash[:error] = \"Error: Course wasn't destroyed!\"\n    end\n    redirect_to(courses_path) && return\n  end\n\n  # Non-RESTful Routes Below\n\n  def report_bug\n    return unless request.post?\n\n    CourseMailer.bug_report(\n      params[:title],\n      params[:summary],\n      current_user,\n      @course\n    ).deliver\n  end\n\n  # Only instructor (and above) can use this feature\n  # to look up user accounts and fill in cud fields\n  action_auth_level :user_lookup, :instructor\n  def user_lookup\n    if params[:email].empty?\n      flash[:error] = \"No email supplied for LDAP Lookup\"\n      render(action: :new, layout: false) && return\n    end\n\n    # make sure that user already exists in the database\n    user = User.where(email: params[:email]).first\n\n    render(json: nil) && return if user.nil?\n\n    @user_data = { first_name: user.first_name,\n                   last_name: user.last_name,\n                   email: user.email }\n\n    render json: @user_data\n  end\n\n  action_auth_level :users, :instructor\n  def users\n    @cuds = if params[:search]\n              # left over from when AJAX was used to find users on the admin users list\n              @course.course_user_data.joins(:user)\n                     .order(\"users.email ASC\")\n                     .where(CourseUserDatum\n                                .conditions_by_like(params[:search]))\n            else\n              @course.course_user_data.joins(:user).order(\"users.email ASC\")\n            end\n  end\n\n  action_auth_level :add_users_from_emails, :instructor\n  def add_users_from_emails\n    # check if user_emails and role exist in params\n    unless params.key?(:user_emails) && params.key?(:role)\n      flash[:error] = \"No user emails or role supplied\"\n      redirect_to(users_course_path(@course)) && return\n    end\n\n    user_emails = params[:user_emails].split(/\\n/).map(&:strip)\n\n    user_emails = user_emails.map do |email|\n      if email.nil?\n        nil\n        # when it's first name <email>\n      elsif email =~ /(.*)\\s+(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), middle_name: Regexp.last_match(2),\n          last_name: Regexp.last_match(3), email: Regexp.last_match(4) }\n        # when it's email\n      elsif email =~ /(.*)\\s+(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), last_name: Regexp.last_match(2),\n          email: Regexp.last_match(3) }\n        # when it's first name middle name last name <email>\n      elsif email =~ /(.*)\\s+<(.*)>/\n        { first_name: Regexp.last_match(1), email: Regexp.last_match(2) }\n        # when it's first name last name <email>\n      else\n        { email: email }\n      end\n    end\n\n    # filter out nil emails\n    user_emails = user_emails.reject(&:nil?)\n\n    # check if email matches regex\n    email_regex = /\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i\n\n    # raise error if any email is invalid and return which emails are invalid\n    invalid_emails = user_emails.reject { |user| user[:email] =~ email_regex }\n    if invalid_emails.any?\n      flash[:error] = \"Invalid email(s): #{invalid_emails.map { |user| user[:email] }.join(', ')}\"\n      redirect_to([:users, @course]) && return\n    end\n\n    role = params[:role]\n\n    @cuds = []\n    user_emails.each do |email|\n      user = User.find_by(email: email[:email])\n\n      # create users if they don't exist\n      if user.nil?\n        begin\n          user = if email[:first_name].nil? && email[:last_name].nil?\n                   User.roster_create(email[:email], email[:email], \"\", \"\", \"\", \"\")\n                 else\n                   User.roster_create(email[:email], email[:first_name] || \"\",\n                                      email[:last_name] || \"\", \"\", \"\", \"\")\n                 end\n        rescue StandardError => e\n          flash[:error] = \"Error: #{e.message}\"\n          redirect_to([:users, @course]) && return\n        end\n\n        if user.nil?\n          flash[:error] = \"Error: User #{email} could not be created.\"\n          redirect_to([:users, @course]) && return\n        end\n      end\n\n      # if user already exists in the course, retrieve the cud\n      cud = @course.course_user_data.find_by(user_id: user.id)\n\n      # if user doesn't exist in the course, create a new cud\n      if cud.nil?\n        cud = @course.course_user_data.new\n        cud.user = user\n      end\n\n      # set the role of the user\n      case role\n      when \"instructor\"\n        cud.instructor = true\n        cud.course_assistant = false\n      when \"ca\"\n        cud.instructor = false\n        cud.course_assistant = true\n      when \"student\"\n        cud.instructor = false\n        cud.course_assistant = false\n      # if role is not valid, return error\n      else\n        flash[:error] = \"Error: Invalid role #{role}.\"\n        redirect_to([:users, @course]) && return\n      end\n\n      # add the cud to the list of cuds to be saved\n      @cuds << cud\n    end\n\n    # save all the cuds\n    if @cuds.all?(&:save)\n      flash[:success] = \"Success: Users added to course.\"\n    else\n      flash[:error] = \"Error: Users could not be added to course.\"\n    end\n    redirect_to([:users, @course]) && return\n  end\n\n  action_auth_level :unlink_course, :instructor\n  def unlink_course\n    lcd = LtiCourseDatum.find_by(course_id: @course.id)\n\n    if lcd.nil?\n      flash[:error] = \"Unable to unlink course\"\n      redirect_to(action: :users) && return\n    end\n\n    lcd.destroy\n    flash[:success] = \"Course unlinked\"\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :update_lti_settings, :instructor\n  def update_lti_settings\n    lcd = @course.lti_course_datum\n    lcd.drop_missing_students = params[:lcd][:drop_missing_students] == \"1\"\n    lcd.save\n\n    redirect_to(action: :users) && return\n  end\n\n  action_auth_level :reload, :instructor\n  def reload\n    @course.reload_course_config\n  rescue StandardError, SyntaxError => e\n    @error = e\n    # let the reload view render\n  else\n    flash[:success] = \"Success: Course config file reloaded!\"\n    redirect_to([@course]) && return\n  end\n\n  # Upload a CSV roster and import the users into the course\n  # Colors are associated to each row of CUD after roster is processed:\n  #   green - User doesn't exist in the course, and is going to be added\n  #   red - User is going to be dropped from the course\n  #   black - User exists in the course\n  action_auth_level :upload_roster, :instructor\n  def upload_roster\n    return unless request.post?\n\n    # Check if any file is attached\n    if params[\"upload\"] && params[\"upload\"][\"file\"].nil?\n      flash[:error] = \"Please attach a roster!\"\n      redirect_to(action: :upload_roster) && return\n    end\n\n    if params[:doIt]\n      begin\n        save_uploaded_roster\n        flash[:success] = \"Successfully updated roster!\"\n        redirect_to(action: \"users\") && return\n      rescue StandardError => e\n        if e != \"Roster validation error\"\n          flash[:error] = e\n        end\n        redirect_to(action: \"upload_roster\") && return\n      end\n    else\n      parse_roster_csv\n    end\n  end\n\n  action_auth_level :download_roster, :instructor\n  def download_roster\n    @cuds = @course.course_user_data.where(instructor: false,\n                                           course_assistant: false,\n                                           dropped: false)\n    output = \"\"\n    @cuds.each do |cud|\n      user = cud.user\n      # to_csv avoids issues with commas\n      output += [@course.semester, cud.user.email, user.last_name, user.first_name,\n                 cud.school, cud.major, cud.year, cud.grade_policy,\n                 @course.name, cud.lecture, cud.section].to_csv\n    end\n    send_data output, filename: \"roster.csv\", type: \"text/csv\", disposition: \"inline\"\n  end\n\n  # install_assessment - Installs a new assessment, either by\n  # creating it from scratch, or importing it from an existing\n  # assessment directory.\n  action_auth_level :install_assessment, :instructor\n  def install_assessment\n    @assignDir = Rails.root.join(\"courses\", @course.name)\n    @availableAssessments = []\n    begin\n      Dir.foreach(@assignDir) do |filename|\n        if File.exist?(File.join(@assignDir, filename, \"#{filename}.rb\"))\n          # names must be only lowercase letters and digits\n          next if filename =~ /[^a-z0-9]/\n\n          # Only list assessments that aren't installed yet\n          assessment = @course.assessments.where(name: filename).first\n          @availableAssessments << filename unless assessment\n        end\n      end\n      @availableAssessments = @availableAssessments.sort\n    rescue StandardError => e\n      render(text: \"<h3>#{e}</h3>\", layout: true) && return\n    end\n  end\n\n  # email - The email action allows instructors to email the entire course, or\n  # a single section at a time.  Sections are passed via params[:section].\n  action_auth_level :email, :instructor\n  def email\n    return unless request.post?\n\n    section = (params[:section] if !params[:section].empty?)\n\n    # don't email kids who dropped!\n    @cuds = if section\n              @course.course_user_data.where(dropped: false, section: section)\n            else\n              @course.course_user_data.where(dropped: false)\n            end\n\n    bccString = make_dlist(@cuds)\n\n    @email = CourseMailer.course_announcement(\n      params[:from],\n      bccString,\n      params[:subject],\n      params[:body],\n      @cud,\n      @course\n    )\n    @email.deliver\n  end\n\n  action_auth_level :moss, :instructor\n  def moss; end\n\n  LANGUAGE_WHITELIST = %w[c cc java ml pascal ada lisp scheme haskell fortran ascii vhdl perl\n                          matlab python mips prolog spice vb csharp modula2 a8086 javascript plsql\n                          verilog].freeze\n\n  action_auth_level :run_moss, :instructor\n  def run_moss\n    # Return if we have no files to process.\n    unless params[:assessments] || params[:external_tar]\n      flash[:error] = \"No input files provided for MOSS.\"\n      redirect_to(action: :moss) && return\n    end\n    assessmentIDs = params[:assessments]\n    assessments = []\n\n    # First, validate access on each of the requested assessments\n    assessmentIDs&.keys&.each do |aid|\n      assessment = Assessment.find(aid)\n      unless assessment\n        flash[:error] = \"Invalid Assessment ID: #{aid}\"\n        redirect_to(action: :moss) && return\n      end\n      assessmentCUD = assessment.course.course_user_data.joins(:user).find_by(\n        users: { email: current_user.email }, instructor: true\n      )\n      if !assessmentCUD && !@cud.user.administrator?\n        flash[:error] = \"Invalid User\"\n        redirect_to(action: :moss) && return\n      end\n      assessments << assessment\n    end\n\n    # Create a temporary directory\n    @failures = []\n    tmp_dir = Dir.mktmpdir(\"#{@cud.user.email}Moss\", Rails.root.join(\"tmp\"))\n\n    files = params[:files]\n    base_file = params[:box_basefile]\n    max_lines = params[:box_max]\n    language = params[:box_language]\n\n    moss_params = \"\"\n    files&.each do |_, v|\n      # Space-separated patterns\n      patternList = v.split(\" \")\n      # Each pattern consists of one or more segments, where each segment consists of\n      # - a leading period (optional)\n      # - a word character (A..Z, a..z, 0..9, _), or hyphen (-), or asterisk (*)\n      # Each pattern optionally ends with a period\n      # OKAY: foo.c *.c * .c README foo_c foo-c .* **\n      # NOT OKAY: . ..\n      patternList.each do |pattern|\n        unless pattern =~ /\\A(\\.?[\\w*-])+\\.?\\z/\n          flash[:error] = \"Invalid file pattern\"\n          redirect_to(action: :moss) && return\n        end\n      end\n    end\n    unless base_file.nil?\n      extract_tar_for_moss(tmp_dir, params[:base_tar], false)\n      moss_params = [moss_params, \"-b\", @basefiles].join(\" \")\n    end\n    unless max_lines.nil?\n      params[:max_lines] = 10 if params[:max_lines] == \"\"\n      # Only accept positive integers (> 0)\n      unless params[:max_lines] =~ /\\A[1-9]([0-9]*)?\\z/\n        flash[:error] = \"Invalid max lines\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-m\", params[:max_lines]].join(\" \")\n    end\n    unless language.nil?\n      unless LANGUAGE_WHITELIST.include? params[:language_selection]\n        flash[:error] = \"Invalid language\"\n        redirect_to(action: :moss) && return\n      end\n      moss_params = [moss_params, \"-l\", params[:language_selection]].join(\" \")\n    end\n\n    # Get moss flags from text field\n    moss_flags = [\"mossnet#{moss_params} -d\"].join(\" \")\n    @mossCmd = [Rails.root.join(\"vendor\", moss_flags)]\n\n    extract_asmt_for_moss(tmp_dir, assessments)\n    extract_tar_for_moss(tmp_dir, params[:external_tar], true)\n\n    # Ensure that all files in Moss tmp dir are readable\n    system(\"chmod -R a+r #{tmp_dir}\")\n    ActiveRecord::Base.clear_active_connections!\n    # Remove non text files when making a moss run\n    `~/Autolab/script/cleanMoss #{tmp_dir}`\n    # Now run the Moss command\n    @mossCmdString = @mossCmd.join(\" \")\n    @mossOutput = `#{@mossCmdString} 2>&1`\n    @mossExit = $?.exitstatus\n\n    # Clean up after ourselves (droh: leave for debugging)\n    `rm -rf #{tmp_dir}`\n  end\n\nprivate\n\n  def new_course_params\n    params.require(:newCourse).permit(:name, :semester)\n  end\n\n  def edit_course_params\n    params.require(:editCourse).permit(:semester, :website, :late_slack,\n                                       :grace_days, :display_name, :start_date, :end_date,\n                                       :disabled, :exam_in_progress, :version_threshold,\n                                       :gb_message, late_penalty_attributes: %i[kind value],\n                                                    version_penalty_attributes: %i[kind value])\n  end\n\n  def categorize_courses_for_listing(courses)\n    listing = {}\n\n    # temporal\n    listing[:current] = []\n    listing[:completed] = []\n    listing[:upcoming] = []\n\n    listing[:disabled] = []\n    # categorize\n    courses.each do |course|\n      if course.disabled?\n        listing[:disabled] << course\n      else\n        listing[course.temporal_status] << course\n      end\n    end\n\n    listing\n  end\n\n  def write_cuds(cuds)\n    rowNum = 0\n    rosterErrors = {}\n    rowCUDs = []\n    duplicates = Set.new\n\n    cuds.each do |new_cud|\n      cloneCUD = new_cud.clone\n      cloneCUD[:row_num] = rowNum + 2\n      rowCUDs.push(cloneCUD)\n\n      case new_cud[:color]\n      when \"green\"\n        # Add this user to the course\n        # Look for this user\n        email = new_cud[:email]\n        first_name = new_cud[:first_name]\n        last_name = new_cud[:last_name]\n        school = new_cud[:school]\n        major = new_cud[:major]\n        year = new_cud[:year]\n\n        if (user = User.where(email: email).first).nil?\n          begin\n            # Create a new user\n            user = User.roster_create(email, first_name, last_name, school,\n                                      major, year)\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        else\n          # Override current user\n          user.first_name = first_name\n          user.last_name = last_name\n          user.school = school\n          user.major = major\n          user.year = year\n          begin\n            user.save!\n          rescue StandardError => e\n            msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n            if !rosterErrors.key?(msg)\n              rosterErrors[msg] = []\n            end\n            rosterErrors[msg].push(cloneCUD)\n          end\n        end\n\n        existing = @course.course_user_data.where(user: user).first\n        # Make sure this user doesn't have a cud in the course\n        if existing\n          duplicates.add(new_cud[:email])\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # Build cud\n        if !user.nil?\n          cud = @course.course_user_data.new\n          cud.user = user\n          params = ActionController::Parameters.new(\n            course_number: new_cud[:course_number],\n            lecture: new_cud[:lecture],\n            section: new_cud[:section],\n            grade_policy: new_cud[:grade_policy]\n          )\n          cud.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n\n          # Save without validations\n          cud.save(validate: false)\n        end\n\n      when \"red\"\n        # Drop this user from the course\n        existing = @course.course_user_data.includes(:user)\n                          .where(users: { email: new_cud[:email] }).first\n\n        fail \"Red CUD doesn't exist in the database.\" if existing.nil?\n\n        existing.dropped = true\n        existing.save(validate: false)\n      else\n        # Update this user's attributes.\n        existing = @course.course_user_data.includes(:user)\n                          .where(\"lower(users.email) = ?\", new_cud[:email].downcase)\n                          .references(:users).first\n        # existing = @course.course_user_data.includes(:user).\n        # where(users[:email].matches(\"%#{new_cud[:email]}%\")).first\n\n        fail \"Black CUD doesn't exist in the database.\" if existing.nil?\n\n        user = existing.user\n        if user.nil?\n          fail \"User associated to black CUD doesn't exist in the database.\"\n        end\n\n        # Update user data\n        user.first_name = new_cud[:first_name]\n        user.last_name = new_cud[:last_name]\n        user.school = new_cud[:school]\n        user.major = new_cud[:major]\n        user.year = new_cud[:year]\n\n        begin\n          user.save!\n        rescue StandardError => e\n          msg = \"#{e} at line #{rowNum + 2} of the CSV\"\n          if !rosterErrors.key?(msg)\n            rosterErrors[msg] = []\n          end\n          rosterErrors[msg].push(cloneCUD)\n        end\n\n        # Delete unneeded data\n        new_cud.delete(:color)\n        new_cud.delete(:email)\n        new_cud.delete(:first_name)\n        new_cud.delete(:last_name)\n        new_cud.delete(:school)\n        new_cud.delete(:major)\n        new_cud.delete(:year)\n\n        # assign attributes\n        params = ActionController::Parameters.new(\n          course_number: new_cud[:course_number],\n          lecture: new_cud[:lecture],\n          section: new_cud[:section],\n          grade_policy: new_cud[:grade_policy]\n        )\n        existing.assign_attributes(params.permit(:course_number, :lecture, :section, :grade_policy))\n        existing.dropped = false\n        existing.save(validate: false) # Save without validations.\n      end\n      rowNum += 1\n    end\n\n    rowCUDs.each do |cud|\n      next unless duplicates.include?(cud[:email])\n\n      msg = \"Validation failed: Duplicate email #{cud[:email]}\"\n      if !rosterErrors.key?(msg)\n        rosterErrors[msg] = []\n      end\n      rosterErrors[msg].push(cud)\n    end\n\n    return if rosterErrors.empty?\n\n    flash[:roster_error] = rosterErrors\n    fail \"Roster validation error\"\n  end\n\n  def save_uploaded_roster\n    cuds = []\n\n    rowNum = 0\n    until params[\"cuds\"][rowNum.to_s].nil?\n      cuds.push(params[\"cuds\"][rowNum.to_s])\n      rowNum += 1\n    end\n\n    CourseUserDatum.transaction do\n      write_cuds(cuds)\n    end\n  end\n\n  def change_view(is_sorted)\n    @cud_view = if is_sorted\n                  @sorted_cuds\n                else\n                  @cuds\n                end\n  end\n\n  def parse_roster_csv\n    # generate doIt form from the upload\n    @cuds = []\n    @currentCUDs = @course.course_user_data.all.to_a\n    @new_cuds = []\n\n    begin\n      csv = detect_and_convert_roster(params[\"upload\"][\"file\"].read)\n      csv.each do |row|\n        new_cud = { # Ignore Semester (row[0])\n          email: row[1].to_s,\n          last_name: row[2].to_s.chomp(\" \"),\n          first_name: row[3].to_s.chomp(\" \"),\n          school: row[4].to_s.chomp(\" \"),\n          major: row[5].to_s.chomp(\" \"),\n          year: row[6].to_s.chomp(\" \"),\n          grade_policy: row[7].to_s.chomp(\" \"),\n          course_number: row[8].to_s.chomp(\" \"),\n          lecture: row[9].to_s.chomp(\" \"),\n          section: row[10].to_s.chomp(\" \")\n        }\n        cud = @currentCUDs.find do |current|\n          current.user && current.user.email.downcase == new_cud[:email].downcase\n        end\n\n        if !cud\n          new_cud[:color] = \"green\"\n        else\n          @currentCUDs.delete(cud)\n        end\n        @cuds << new_cud\n      end\n    rescue CSV::MalformedCSVError => e\n      flash[:error] = \"Error parsing CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n    rescue StandardError => e\n      flash[:error] = \"Error uploading the CSV file: #{e}\"\n      redirect_to(action: \"upload_roster\") && return\n      raise e\n    end\n\n    # drop the rest if indicated\n    if params[:upload][:dropMissing] == \"1\"\n      # We never drop instructors, remove them first\n      @currentCUDs.delete_if do |cud|\n        cud.instructor? || cud.user.administrator? || cud.course_assistant?\n      end\n      @currentCUDs.each do |cud| # These are the drops\n        new_cud = {\n          email: cud.user.email,\n          last_name: cud.user.last_name,\n          first_name: cud.user.first_name,\n          school: cud.school,\n          major: cud.major,\n          year: cud.year,\n          grade_policy: cud.grade_policy,\n          course_number: cud.course_number,\n          lecture: cud.lecture,\n          section: cud.section,\n          color: \"red\"\n        }\n        @cuds << new_cud\n      end\n    end\n\n    # do dry run for error checking\n    CourseUserDatum.transaction do\n      cloned_cuds = Marshal.load(Marshal.dump(@cuds))\n      begin\n        write_cuds(cloned_cuds)\n      rescue StandardError => e\n        redirect_to(action: \"upload_roster\")\n      ensure\n        raise ActiveRecord::Rollback\n      end\n    end\n\n    @sorted_cuds = @cuds.sort_by { |cud| cud[:color] || \"z\" }\n    @cud_view = @sorted_cuds\n  end\n\n  # detect_and_convert_roster - Detect the type of a roster based on roster\n  # column matching and convert to default roster\n\n  # map fields:\n  # map[0]: semester (unused)\n  # map[1]: email\n  # map[2]: last_name\n  # map[3]: first_name\n  # map[4]: school\n  # map[5]: major\n  # map[6]: year\n  # map[7]: grade_policy\n  # map[8]: course\n  # map[9]: lecture\n  # map[10]: section\n  # rubocop:disable Lint/UselessAssignment\n  def detect_and_convert_roster(roster)\n    raise \"Roster is empty\" if roster.empty?\n\n    parsedRoster = CSV.parse(roster, skip_blanks: true)\n    raise \"Roster cannot be recognized\" if parsedRoster[0][0].nil?\n\n    case parsedRoster[0].length\n    when ROSTER_COLUMNS_F20 # 34 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11 - skip), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Time Zone Code(22), Time Zone Description(23), Added By(24),\n      # Added On(25), Confirmed(26), Waitlist Position(27), Units Carried/Max Units(28),\n      # Waitlisted By(29), Waitlisted On(30), Dropped By(31), Dropped On(32), Roster As Of Date(33)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F20\n    when ROSTER_COLUMNS_F16 # 32 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Course(1), Section(2), Lecture(3), Mini(4 - skip),\n      # Last Name(5), Preferred/First Name(6), MI(7 - skip), Andrew ID(8),\n      # Email(9 - skip), College(10), Department(11), Major(12),\n      # Class(13), Graduation Semester(14 - skip), Units(15 - skip), Grade Option(16)\n      # ... the remaining fields are all skipped but shown for completeness\n      # QPA Scale(17), Mid-Semester Grade(18), Primary Advisor(19), Final Grade(20),\n      # Default Grade(21), Added By(22), Added On(23), Confirmed(24), Waitlist Position(25),\n      # Units Carried/Max Units(26), Waitlisted By(27), Waitlisted On(28), Dropped By(29),\n      # Dropped On(30), Roster As Of Date(31)\n      map = [-1, 8, 5, 6, 10, 12, 13, 16, 1, 3, 2]\n      select_columns = ROSTER_COLUMNS_F16\n    when ROSTER_COLUMNS_S15 # 29 fields\n      # In CMU S3 roster. Columns are:\n      # Semester(0 - skip), Lecture(1), Section(2), (skip)(3), (skip)(4), Last Name(5),\n      # First Name(6), (skip)(7), Andrew ID(8), (skip)(9), School(10),\n      # Major(11), Year(12), (skip)(13), Grade Policy(14), ... [elided]\n      map = [-1, 8, 5, 6, 10, 11, 12, 14, -1, 1, 2]\n      select_columns = ROSTER_COLUMNS_S15\n    else\n      # No header row. Columns are:\n      # Semester(0 - skip), Email(1), Last Name(2), First Name(3), School(4),\n      # Major(5), Year(6), Grade Policy(7), Course(8), Lecture(9),\n      # Section(10)\n      return parsedRoster\n    end\n    # rubocop:enable Lint/UselessAssignment\n\n    # Detect if there is a header row\n    offset = if parsedRoster[0][0] == \"Semester\"\n               1\n             else\n               0\n             end\n    numRows = parsedRoster.length - offset\n    convertedRoster = Array.new(numRows) { Array.new(11) }\n\n    domain = if Rails.env.production?\n               \"andrew.cmu.edu\"\n             else\n               \"foo.bar\"\n             end\n    (0..(numRows - 1)).each do |i|\n      11.times do |j|\n        next unless map[j] >= 0\n\n        convertedRoster[i][j] = if j == 1\n                                  \"#{parsedRoster[i + offset][map[j]]}@#{domain}\"\n                                else\n                                  parsedRoster[i + offset][map[j]]\n                                end\n      end\n    end\n    convertedRoster\n  end\n\n  def extract_asmt_for_moss(tmp_dir, assessments)\n    # for each assessment\n    assessments.each do |ass|\n      # Create a directory for ths assessment\n      assDir = File.join(tmp_dir, \"#{ass.name}-#{ass.course.name}\")\n      Dir.mkdir(assDir)\n\n      # params[:isArchive] might be nil if no archive assessments are submitted\n      isArchive = params[:isArchive] && params[:isArchive][ass.id.to_s]\n\n      visitedGroups = Set.new\n\n      # For each student who submitted\n      ass.submissions.latest.each do |sub|\n        subFile = sub.handin_file_path\n        next unless subFile && File.exist?(subFile)\n\n        if ass.has_groups?\n          group_id = sub.aud.group_id\n          next if visitedGroups.include?(group_id)\n\n          visitedGroups.add(group_id)\n        end\n\n        # Create a directory for this student\n        stuDir = File.join(assDir, sub.course_user_datum.email)\n        Dir.mkdir(stuDir)\n\n        # Copy their submission over\n        FileUtils.cp(subFile, stuDir)\n\n        # Read archive files\n        next unless isArchive\n\n        # If we need to unarchive this file, then create archive reader\n        archive_path = File.join(stuDir, sub.filename)\n        begin\n          archive_extract = Archive.get_archive(archive_path)\n\n          archive_extract.each do |entry|\n            pathname = Archive.get_entry_name(entry)\n            next if Archive.looks_like_directory?(pathname)\n\n            pathname.gsub!(%r{/}, \"-\")\n            destination = File.join(stuDir, pathname)\n            # make sure all subdirectories are there\n            FileUtils.mkdir_p(File.dirname(destination))\n            File.open(destination, \"wb\") do |out|\n              out.write Archive.read_entry_file(entry)\n              begin\n                out.fsync\n              rescue StandardError\n                nil\n              end\n            end\n          end\n        rescue StandardError\n          @failures << sub.filename\n        end\n      end\n\n      # add this assessment to the moss command\n      patternList = params[\"files\"][ass.id.to_s].split(\" \")\n      patternList.each do |pattern|\n        @mossCmd << File.join(assDir, [\"*\", pattern])\n      end\n    end\n  end\n\n  def extract_tar_for_moss(tmp_dir, external_tar, archive)\n    return unless external_tar\n\n    # Directory to hold tar ball and all individual files.\n    extTarDir = File.join(tmp_dir, \"external_input\")\n    baseFilesDir = File.join(tmp_dir, \"basefiles\")\n    begin\n      Dir.mkdir(extTarDir)\n      Dir.mkdir(baseFilesDir) # To hold all basefiles\n    rescue StandardError\n      nil\n    end\n\n    # Read in the tarfile from the given source.\n    extTarPath = File.join(extTarDir, \"input_file\")\n    external_tar.rewind\n    File.open(extTarPath, \"wb\") { |f| f.write(external_tar.read) } # Write tar file.\n\n    # Directory to hold all external individual submission.\n    extFilesDir = File.join(extTarDir, \"submissions\")\n\n    begin\n      Dir.mkdir(extFilesDir) # To hold all submissions\n    rescue StandardError\n      nil\n    end\n\n    # Untar the given Tar file.\n    begin\n      archive_extract = Archive.get_archive(extTarPath)\n\n      # write each file, renaming nested files\n      archive_extract.each do |entry|\n        pathname = Archive.get_entry_name(entry)\n        next if Archive.looks_like_directory?(pathname)\n\n        output_dir = if archive\n                       extFilesDir\n                      else\n                        baseFilesDir\n                      end\n        output_file = File.join(output_dir, pathname)\n\n        # skip if the file lies outside the archive\n        next unless Archive.in_dir?(Pathname(output_file), Pathname(output_dir))\n\n        # make sure all subdirectories are there\n        File.open(output_file, \"wb\") do |out|\n          out.write Archive.read_entry_file(entry)\n          begin\n            out.fsync\n          rescue StandardError\n            nil\n          end\n        end\n      end\n    rescue StandardError\n      @failures << \"External Tar\"\n    end\n\n    # Feed the uploaded files to MOSS.\n    if archive\n      @mossCmd << File.join(extFilesDir, \"*\")\n    else\n      @basefiles = File.join(baseFilesDir, \"*\")\n    end\n  end\nend\n", "require \"rubygems\"\nrequire \"rubygems/package\"\nrequire \"tempfile\"\nrequire \"zlib\"\nrequire \"zip\"\n\n##\n# This module provides functionality for dealing with Archives, including zips,\n# tars, and gunzipped tars\n#\nmodule Archive\n  def self.get_files(archive_path)\n    archive_type = get_archive_type(archive_path)\n    archive_extract = get_archive(archive_path, archive_type)\n\n    files = []\n\n    # Parse archive header\n    archive_extract.each_with_index do |entry, i|\n      # Obtain path name depending for tar/zip entry\n      pathname = get_entry_name(entry)\n\n      files << {\n        pathname: pathname,\n        header_position: i,\n        mac_bs_file: pathname.include?(\"__MACOSX\") ||\n          pathname.include?(\".DS_Store\") ||\n          pathname.include?(\".metadata\"),\n        directory: looks_like_directory?(pathname)\n      }\n    end\n\n    archive_extract.close\n\n    files\n  end\n\n  def self.recoverHierarchy(files, root)\n    depth = root[:pathname].chomp(\"/\").count \"/\"\n    if(root[:pathname] == \"\")\n      depth = -1\n    end\n    if(!root[:directory])\n      return root\n    end\n    subFiles = []\n    filesNestedSomewhere = files.select{|entry| entry[:pathname].start_with?(root[:pathname]) && !(entry[:pathname] == root[:pathname])}\n    for file in filesNestedSomewhere\n      fileDepth = file[:pathname].chomp(\"/\").count \"/\"\n      if(fileDepth == depth+1)\n        subFiles << recoverHierarchy(filesNestedSomewhere, file)\n      end\n    end\n    subFiles.sort! { |a, b| a[:header_position] <=> b[:header_position] }\n    root[:subfiles] = subFiles\n    return root\n  end\n\n  # given a list of files, sanitize and create\n  # missing file directories\n  def self.sanitize_directories(files)\n\n    cleaned_files = []\n    file_path_set = Set[]\n    \n    # arbitrary header positions for the new directories\n    starting_header = -1\n\n    # add pre-existing directories to the set\n    for file in files\n\n      # edge case for removing \"./\" from pathnames\n      if file[:pathname].include?(\"./\")\n        file[:pathname] = file[:pathname].split(\"./\")[1]\n      end\n\n      if(file[:directory])\n        file_path_set.add(file[:pathname])\n      end\n    end\n\n    for file in files\n      # for each file, check if each of its directories and subdir\n      # exist. If it does not, create and add them\n      if(!file[:directory])\n        paths = file[:pathname].split(\"/\")\n        mac_bs_file = false\n        for path in paths do\n          # note that __MACOSX is actually a folder\n          # need to check whether the path includes that\n          # for the completeness of cleaned_files\n          # mac_bs_file folder paths will still be added\n          if path.include?(\"__MACOSX\") || path.include?(\".DS_Store\") ||\n             path.include?(\".metadata\")\n             mac_bs_file = true\n             break\n          end\n        end\n        for i in 1..(paths.size - 1) do\n          new_path = paths[0,paths.size-i].join(\"/\") + \"/\"\n          if(!file_path_set.include?(new_path))\n            cleaned_files.append({\n              :pathname=>new_path,\n              :header_position=>starting_header,\n              :mac_bs_file=>mac_bs_file,\n              :directory=>true\n            })\n            starting_header = starting_header - 1\n            file_path_set.add(new_path)\n          end\n        end \n      end\n      \n      # excludes \"./\" paths\n      if(file[:pathname]!=nil)\n        cleaned_files.append(file)\n      end\n    end\n\n    cleaned_files\n  end\n\n  def self.get_file_hierarchy(archive_path)\n    files = get_files(archive_path)\n    files = sanitize_directories(files)\n    res = recoverHierarchy(files, {pathname: \"\", directory: true})\n    return res[:subfiles]\n  end\n\n  def self.get_nth_file(archive_path, n)\n    archive_type = get_archive_type(archive_path)\n    archive_extract = get_archive(archive_path, archive_type)\n\n    # Parse archive header\n    res = nil, nil\n    archive_extract.each_with_index do |entry, i|\n      # Obtain path name depending for tar/zip entry\n      pathname = get_entry_name(entry)\n\n      next if pathname.include?(\"__MACOSX\") ||\n              pathname.include?(\".DS_Store\") ||\n              pathname.include?(\".metadata\") ||\n              i != n\n\n      if looks_like_directory?(pathname)\n        res = nil, pathname\n      else\n        res = read_entry_file(entry), get_entry_name(entry)\n      end\n      break\n    end\n\n    archive_extract.close\n\n    res\n  end\n\n  def self.get_nth_filename(files, n)\n    files[n][:pathname]\n  end\n\n  def self.get_archive_type(filename)\n    IO.popen([\"file\", \"--brief\", \"--mime-type\", filename], in: :close, err: :close) do |io|\n      io.read.chomp\n    end\n  end\n\n  def self.archive?(filename)\n    return nil unless filename\n    archive_type = get_archive_type(filename)\n    (archive_type.include?(\"tar\") || archive_type.include?(\"gzip\") || archive_type.include?(\"zip\"))\n  end\n\n  def self.get_archive(filename, archive_type = nil)\n    archive_type = get_archive_type(filename) if archive_type.nil?\n\n    if archive_type.include? \"tar\"\n      archive_extract = Gem::Package::TarReader.new(File.new(filename))\n      archive_extract.rewind # The extract has to be rewinded after every iteration\n    elsif archive_type.include? \"gzip\"\n      archive_extract = Gem::Package::TarReader.new(Zlib::GzipReader.open(filename))\n      archive_extract.rewind\n    elsif archive_type.include? \"zip\"\n      archive_extract = Zip::File.open(filename)\n    else\n      fail \"Unrecognized archive type!\"\n    end\n    archive_extract\n  end\n\n  def self.get_entry_name(entry)\n    # tar/tgz vs zip\n    name = entry.respond_to?(:full_name) ? entry.full_name : entry.name\n    if ! name.ascii_only?\n      name = String.new(name)\n      name.force_encoding(\"UTF-8\")\n      if ! name.valid_encoding?\n        # not utf-8. Assume single byte and choose windows western, since\n        # iso8859-1 printables are a subset\n        name.force_encoding(\"Windows-1252\")\n        name.encode!()\n      end\n    end\n    name\n  end\n\n  def self.read_entry_file(entry)\n    # tar/tgz vs zip\n    entry.respond_to?(:read) ? entry.read : entry.get_input_stream.read\n  end\n\n  ##\n  # returns a zip archive containing every file in the given path array\n  #\n  def self.create_zip(paths)\n    return nil if paths.nil? || paths.empty?\n\n    # don't create a tempfile, just stream it to client for download\n    zip_stream = Zip::OutputStream.write_buffer do |zos|\n      paths.each do |filepath|\n        ctimestamp = Zip::DOSTime.at(File.open(filepath,\"r\").ctime) # use creation time of submitted file\n        zip_entry = Zip::Entry.new(zos, \"#{File.basename(filepath)}\", nil, nil, nil, nil, nil, nil,\n                    ctimestamp)\n        zos.put_next_entry(zip_entry)\n        zos.print File.read(filepath)\n      end\n    end\n    zip_stream.rewind\n    zip_stream\n  end\n\n  def self.looks_like_directory?(pathname)\n    pathname.ends_with?(\"/\")\n  end\n\n  # Check if a path lies (strictly) within a directory\n  # Takes two Pathname objects\n  # https://gist.github.com/henrik/48e8bb74de9d887770dfb3cc6efaa9b2\n  def self.in_dir?(path, dir)\n    path_parts = path.expand_path.each_filename.to_a\n    dir_parts = dir.expand_path.each_filename.to_a\n    return false if path_parts == dir_parts\n\n    dir_parts.zip(path_parts).all? { |x, y| x == y }\n  end\nend\n"], "filenames": ["app/controllers/courses_controller.rb", "lib/archive.rb"], "buggy_code_start_loc": [3, 234], "buggy_code_end_loc": [1119, 234], "fixing_code_start_loc": [4, 235], "fixing_code_end_loc": [1123, 246], "type": "CWE-22", "message": "Autolab is a course management service that enables auto-graded programming assignments. A Tar slip vulnerability was found in the MOSS cheat checker functionality of Autolab. To exploit this vulnerability an authenticated attacker with instructor permissions needs to upload a specially crafted Tar file. Both \"Base File Tar\" and \"Additional file archive\" can be fed with Tar files that contain paths outside their target directories (e.g.,  `../../../../tmp/tarslipped2.sh`). When the MOSS cheat checker is started the files inside of the archives are expanded to the attacker-chosen locations. This issue may lead to arbitrary file write within the scope of the running process.  This issue has been addressed in version 2.11.0. Users are advised to upgrade.", "other": {"cve": {"id": "CVE-2023-32317", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-26T23:15:16.950", "lastModified": "2023-06-03T03:27:00.970", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Autolab is a course management service that enables auto-graded programming assignments. A Tar slip vulnerability was found in the MOSS cheat checker functionality of Autolab. To exploit this vulnerability an authenticated attacker with instructor permissions needs to upload a specially crafted Tar file. Both \"Base File Tar\" and \"Additional file archive\" can be fed with Tar files that contain paths outside their target directories (e.g.,  `../../../../tmp/tarslipped2.sh`). When the MOSS cheat checker is started the files inside of the archives are expanded to the attacker-chosen locations. This issue may lead to arbitrary file write within the scope of the running process.  This issue has been addressed in version 2.11.0. Users are advised to upgrade."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.5}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:autolabproject:autolab:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.11.0", "matchCriteriaId": "F025235E-3D41-4053-8167-1D8D94A645FF"}]}]}], "references": [{"url": "https://github.com/autolab/Autolab/commit/410a9228ee265f80692334d75eb2c3b4dac6f9e5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/autolab/Autolab/security/advisories/GHSA-h8g5-vhm4-wx6g", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/autolab/Autolab/commit/410a9228ee265f80692334d75eb2c3b4dac6f9e5"}}