{"buggy_code": ["/* radare - LGPL - Copyright 2011-2018 - pancake, Roc Valles, condret, killabyte */\n\n#if 0\nhttp://www.atmel.com/images/atmel-0856-avr-instruction-set-manual.pdf\nhttps://en.wikipedia.org/wiki/Atmel_AVR_instruction_set\n#endif\n\n#include <string.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n\nstatic RDESContext desctx;\n\ntypedef struct _cpu_const_tag {\n\tconst char *const key;\n\tut8 type;\n\tut32 value;\n\tut8 size;\n} CPU_CONST;\n\n#define CPU_CONST_NONE\t0\n#define CPU_CONST_PARAM\t1\n#define CPU_CONST_REG\t2\n\ntypedef struct _cpu_model_tag {\n\tconst char *const model;\n\tint pc;\n\tchar *inherit;\n\tstruct _cpu_model_tag *inherit_cpu_p;\n\tCPU_CONST *consts[10];\n} CPU_MODEL;\n\ntypedef void (*inst_handler_t) (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu);\n\ntypedef struct _opcodes_tag_ {\n\tconst char *const name;\n\tint mask;\n\tint selector;\n\tinst_handler_t handler;\n\tint cycles;\n\tint size;\n\tut64 type;\n} OPCODE_DESC;\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu);\n\n#define CPU_MODEL_DECL(model, pc, consts)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tmodel,\t\t\t\t\t\t\t\\\n\t\tpc,\t\t\t\t\t\t\t\\\n\t\tconsts\t\t\t\t\t\t\t\\\n\t}\n#define MASK(bits)\t\t\t((bits) == 32 ? 0xffffffff : (~((~((ut32) 0)) << (bits))))\n#define CPU_PC_MASK(cpu)\t\tMASK((cpu)->pc)\n#define CPU_PC_SIZE(cpu)\t\t((((cpu)->pc) >> 3) + ((((cpu)->pc) & 0x07) ? 1 : 0))\n\n#define INST_HANDLER(OPCODE_NAME)\tstatic void _inst__ ## OPCODE_NAME (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu)\n#define INST_DECL(OP, M, SL, C, SZ, T)\t{ #OP, (M), (SL), _inst__ ## OP, (C), (SZ), R_ANAL_OP_TYPE_ ## T }\n#define INST_LAST\t\t\t{ \"unknown\", 0, 0, (void *) 0, 2, 1, R_ANAL_OP_TYPE_UNK }\n\n#define INST_CALL(OPCODE_NAME)\t\t_inst__ ## OPCODE_NAME (anal, op, buf, len, fail, cpu)\n#define INST_INVALID\t\t\t{ *fail = 1; return; }\n#define INST_ASSERT(x)\t\t\t{ if (!(x)) { INST_INVALID; } }\n\n#define ESIL_A(e, ...)\t\t\tr_strbuf_appendf (&op->esil, e, ##__VA_ARGS__)\n\n#define STR_BEGINS(in, s)\t\tstrncasecmp (in, s, strlen (s))\n\n// Following IO definitions are valid for:\n//\tATmega8\n//\tATmega88\nCPU_CONST cpu_reg_common[] = {\n\t{ \"spl\",    CPU_CONST_REG, 0x3d, sizeof (ut8) },\n\t{ \"sph\",    CPU_CONST_REG, 0x3e, sizeof (ut8) },\n\t{ \"sreg\",   CPU_CONST_REG, 0x3f, sizeof (ut8) },\n\t{ \"spmcsr\", CPU_CONST_REG, 0x37, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_common[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x40, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM, 0x60, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 1024, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_m640_m1280m_m1281_m2560_m2561[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,    512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM,  0x1ff, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x200, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_xmega128a4u[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x1000, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_5_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 5, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_7_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 7, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_MODEL cpu_models[] = {\n\t{ .model = \"ATmega640\",   .pc = 15,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_m640_m1280m_m1281_m2560_m2561,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t},\n\t},\n\t{\n\t\t.model = \"ATxmega128a4u\", .pc = 17,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_xmega128a4u,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t}\n\t},\n\t{ .model = \"ATmega1280\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega1281\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2560\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2561\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega88\",    .pc = 8,  .inherit = \"ATmega8\" },\n//\tCPU_MODEL_DECL (\"ATmega168\",   13, 512, 512),\n\t// last model is the default AVR - ATmega8 forever!\n\t{\n\t\t.model = \"ATmega8\", .pc = 13,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_common,\n\t\t\tcpu_pagesize_5_bits,\n\t\t\tNULL\n\t\t}\n\t},\n};\n\nstatic CPU_MODEL *get_cpu_model(char *model);\n\nstatic CPU_MODEL *__get_cpu_model_recursive(char *model) {\n\tCPU_MODEL *cpu = NULL;\n\n\tfor (cpu = cpu_models; cpu < cpu_models + ((sizeof (cpu_models) / sizeof (CPU_MODEL))) - 1; cpu++) {\n\t\tif (!strcasecmp (model, cpu->model)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// fix inheritance tree\n\tif (cpu->inherit && !cpu->inherit_cpu_p) {\n\t\tcpu->inherit_cpu_p = get_cpu_model (cpu->inherit);\n\t\tif (!cpu->inherit_cpu_p) {\n\t\t\teprintf (\"ERROR: Cannot inherit from unknown CPU model '%s'.\\n\", cpu->inherit);\n\t\t}\n\t}\n\n\treturn cpu;\n}\n\nstatic CPU_MODEL *get_cpu_model(char *model) {\n\tstatic CPU_MODEL *cpu = NULL;\n\n\t// cached value?\n\tif (cpu && !strcasecmp (model, cpu->model))\n\t\treturn cpu;\n\n\t// do the real search\n\tcpu = __get_cpu_model_recursive (model);\n\n\treturn cpu;\n}\n\nstatic ut32 const_get_value(CPU_CONST *c) {\n\treturn c ? MASK (c->size * 8) & c->value : 0;\n}\n\n\nstatic CPU_CONST *const_by_name(CPU_MODEL *cpu, int type, char *c) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem->key; citem++) {\n\t\t\tif (!strcmp (c, citem->key)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_name (cpu->inherit_cpu_p, type, c);\n\teprintf (\"ERROR: CONSTANT key[%s] NOT FOUND.\\n\", c);\n\treturn NULL;\n}\n\nstatic int __esil_pop_argument(RAnalEsil *esil, ut64 *v) {\n\tchar *t = r_anal_esil_pop (esil);\n\tif (!t || !r_anal_esil_get_parm (esil, t, v)) {\n\t\tfree (t);\n\t\treturn false;\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic CPU_CONST *const_by_value(CPU_MODEL *cpu, int type, ut32 v) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem && citem->key; citem++) {\n\t\t\tif (citem->value == (MASK (citem->size * 8) & v)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_value (cpu->inherit_cpu_p, type, v);\n\treturn NULL;\n}\n\nstatic RStrBuf *__generic_io_dest(ut8 port, int write, CPU_MODEL *cpu) {\n\tRStrBuf *r = r_strbuf_new (\"\");\n\tCPU_CONST *c = const_by_value (cpu, CPU_CONST_REG, port);\n\tif (c != NULL) {\n\t\tr_strbuf_set (r, c->key);\n\t\tif (write) {\n\t\t\tr_strbuf_append (r, \",=\");\n\t\t}\n\t} else {\n\t\tr_strbuf_setf (r, \"_io,%d,+,%s[1]\", port, write ? \"=\" : \"\");\n\t}\n\n\treturn r;\n}\n\nstatic void __generic_bitop_flags(RAnalOp *op) {\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n}\n\nstatic void __generic_ld_st(RAnalOp *op, char *mem, char ireg, int use_ramp, int prepostdec, int offset, int st) {\n\tif (ireg) {\n\t\t// preincrement index register\n\t\tif (prepostdec < 0) {\n\t\t\tESIL_A (\"1,%c,-,%c,=,\", ireg, ireg);\n\t\t}\n\t\t// set register index address\n\t\tESIL_A (\"%c,\", ireg);\n\t\t// add offset\n\t\tif (offset != 0) {\n\t\t\tESIL_A (\"%d,+,\", offset);\n\t\t}\n\t} else {\n\t\tESIL_A (\"%d,\", offset);\n\t}\n\tif (use_ramp) {\n\t\tESIL_A (\"16,ramp%c,<<,+,\", ireg ? ireg : 'd');\n\t}\n\t// set SRAM base address\n\tESIL_A (\"_%s,+,\", mem);\n\t// read/write from SRAM\n\tESIL_A (\"%s[1],\", st ? \"=\" : \"\");\n\t// postincrement index register\n\tif (ireg && prepostdec > 0) {\n\t\tESIL_A (\"1,%c,+,%c,=,\", ireg, ireg);\n\t}\n}\n\nstatic void __generic_pop(RAnalOp *op, int sz) {\n\tif (sz > 1) {\n\t\tESIL_A (\"1,sp,+,_ram,+,\");\t// calc SRAM(sp+1)\n\t\tESIL_A (\"[%d],\", sz);\t\t// read value\n\t\tESIL_A (\"%d,sp,+=,\", sz);\t// sp += item_size\n\t} else {\n\t\tESIL_A (\"1,sp,+=,\"\t\t// increment stack pointer\n\t\t\t\"sp,_ram,+,[1],\");\t// load SRAM[sp]\n\t}\n}\n\nstatic void __generic_push(RAnalOp *op, int sz) {\n\tESIL_A (\"sp,_ram,+,\");\t\t\t// calc pointer SRAM(sp)\n\tif (sz > 1) {\n\t\tESIL_A (\"-%d,+,\", sz - 1);\t// dec SP by 'sz'\n\t}\n\tESIL_A (\"=[%d],\", sz);\t\t\t// store value in stack\n\tESIL_A (\"-%d,sp,+=,\", sz);\t\t// decrement stack pointer\n}\n\nstatic void __generic_add_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,!,\" \"%s,0x08,&,!,!,\"    \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"      \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,\"        \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"    \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_add_update_flags_rr(RAnalOp *op, int d, int r) {\n\t__generic_add_update_flags(op, 'r', d, 'r', r);\n}\n\nstatic void __generic_sub_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk, int carry) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,\"   \"%s,0x08,&,!,!,\"      \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,\"   \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,\"        \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tif (carry)\n\t\tESIL_A (\"0,RPICK,!,zf,&,zf,=,\");\t\t// Z\n\telse\n\t\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_sub_update_flags_rr(RAnalOp *op, int d, int r, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'r', r, carry);\n}\n\nstatic void __generic_sub_update_flags_rk(RAnalOp *op, int d, int k, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'k', k, carry);\n}\n\nINST_HANDLER (adc) {\t// ADC Rd, Rr\n\t\t\t// ROL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,cf,+,r%d,+,\", r, d);\t\t// Rd + Rr + C\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (add) {\t// ADD Rd, Rr\n\t\t\t// LSL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,+,\", r, d);\t\t\t// Rd + Rr\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (adiw) {\t// ADIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"r%d:r%d,%d,+,\", d + 1, d, k);\t\t\t// Rd+1:Rd + Rr\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t\t// Rd = result\n}\n\nINST_HANDLER (and) {\t// AND Rd, Rr\n\t\t\t// TST Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,&,\", r, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (andi) {\t// ANDI Rd, K\n\t\t\t// CBR Rd, K (= ANDI Rd, 1-K)\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0x0f) << 4) | (buf[0] & 0x0f);\n\top->val = k;\n\tESIL_A (\"%d,r%d,&,\", k, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (asr) {\t// ASR Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,r%d,0x80,&,|,\", d, d);\t\t// 0: R=(Rd >> 1) | Rd7\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (bclr) {\t// BCLR s\n\t\t\t// CLC\n\t\t\t// CLH\n\t\t\t// CLI\n\t\t\t// CLN\n\t\t\t// CLR\n\t\t\t// CLS\n\t\t\t// CLT\n\t\t\t// CLV\n\t\t\t// CLZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"0xff,%d,1,<<,^,sreg,&=,\", s);\n}\n\nINST_HANDLER (bld) {\t// BLD Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[1] & 0x01) << 4) | ((buf[0] >> 4) & 0xf);\n\tint b = buf[0] & 0x7;\n\tESIL_A (\"r%d,%d,1,<<,0xff,^,&,\", d, b);\t\t\t// Rd/b = 0\n\tESIL_A (\"%d,tf,<<,|,r%d,=,\", b, d);\t\t\t// Rd/b |= T<<b\n}\n\nINST_HANDLER (brbx) {\t// BRBC s, k\n\t\t\t// BRBS s, k\n\t\t\t// BRBC/S 0:\t\tBRCC\t\tBRCS\n\t\t\t//\t\t\tBRSH\t\tBRLO\n\t\t\t// BRBC/S 1:\t\tBREQ\t\tBRNE\n\t\t\t// BRBC/S 2:\t\tBRPL\t\tBRMI\n\t\t\t// BRBC/S 3:\t\tBRVC\t\tBRVS\n\t\t\t// BRBC/S 4:\t\tBRGE\t\tBRLT\n\t\t\t// BRBC/S 5:\t\tBRHC\t\tBRHS\n\t\t\t// BRBC/S 6:\t\tBRTC\t\tBRTS\n\t\t\t// BRBC/S 7:\t\tBRID\t\tBRIE\n\tint s = buf[0] & 0x7;\n\top->jump = op->addr\n\t\t+ ((((buf[1] & 0x03) << 6) | ((buf[0] & 0xf8) >> 2))\n\t\t\t| (buf[1] & 0x2 ? ~((int) 0x7f) : 0))\n\t\t+ 2;\n\top->fail = op->addr + op->size;\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,sreg,&,\", s);\t\t\t\t// SREG(s)\n\tESIL_A (buf[1] & 0x4\n\t\t\t? \"!,\"\t\t// BRBC => branch if cleared\n\t\t\t: \"!,!,\");\t// BRBS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (break) {\t// BREAK\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (bset) {\t// BSET s\n\t\t\t// SEC\n\t\t\t// SEH\n\t\t\t// SEI\n\t\t\t// SEN\n\t\t\t// SER\n\t\t\t// SES\n\t\t\t// SET\n\t\t\t// SEV\n\t\t\t// SEZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"%d,1,<<,sreg,|=,\", s);\n}\n\nINST_HANDLER (bst) {\t// BST Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tESIL_A (\"r%d,%d,1,<<,&,!,!,tf,=,\",\t\t\t// tf = Rd/b\n\t\t((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf),\t// r\n\t\tbuf[0] & 0x7);\t\t\t\t\t// b\n}\n\nINST_HANDLER (call) {\t// CALL k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->fail = op->addr + op->size;\n\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\top->cycles--;\t// AT*mega optimizes one cycle\n\t}\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (cbi) {\t// CBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->family = R_ANAL_OP_FAMILY_IO;\n\top->type2 = 1;\n\top->val = a;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,^,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (com) {\t// COM Rd\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 1) << 4);\n\n\tESIL_A (\"r%d,0xff,-,0xff,&,r%d,=,\", r, r);\t\t// Rd = 0xFF-Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,cf,=,\");\t\t\t\t\t// C\n\t__generic_bitop_flags (op);\t\t\t\t// ...rest...\n}\n\nINST_HANDLER (cp) {\t// CP Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// do Rd - Rr\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n}\n\nINST_HANDLER (cpc) {\t// CPC Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// Rd - Rr - C\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpi) { // CPI Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// Rd - k\n\t__generic_sub_update_flags_rk (op, d, k, 0);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (dec) {\t// DEC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"-1,r%d,+,\", d);\t\t\t\t// --Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x7f,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (des) {\t// DES k\n\tif (desctx.round < 16) {\t//DES\n\t\top->type = R_ANAL_OP_TYPE_CRYPTO;\n\t\top->cycles = 1;\t\t//redo this\n\t\tr_strbuf_setf (&op->esil, \"%d,des\", desctx.round);\n\t}\n}\n\nINST_HANDLER (eijmp) {\t// EIJMP\n\tut64 z, eind;\n\t// read z and eind for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\",    &z,    NULL);\n\tr_anal_esil_reg_read (anal->esil, \"eind\", &eind, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = ((eind << 16) + z) << 1;\n\t// jump\n\tESIL_A (\"1,z,16,eind,<<,+,<<,pc,=,\");\n\t// cycles\n\top->cycles = 2;\n}\n\nINST_HANDLER (eicall) {\t// EICALL\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard EIJMP\n\tINST_CALL (eijmp);\n\t// fix cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\") ? 3 : 4;\n}\n\nINST_HANDLER (elpm) {\t// ELPM\n\t\t\t// ELPM Rd\n\t\t\t// ELPM Rd, Z+\n\tint d = ((buf[1] & 0xfe) == 0x90)\n\t\t\t? ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf)\t// Rd\n\t\t\t: 0;\t\t\t\t\t\t// R0\n\tESIL_A (\"16,rampz,<<,z,+,_prog,+,[1],\");\t// read RAMPZ:Z\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = [1]\n\tif ((buf[1] & 0xfe) == 0x90 && (buf[0] & 0xf) == 0x7) {\n\t\tESIL_A (\"16,1,z,+,DUP,z,=,>>,1,&,rampz,+=,\");\t// ++(rampz:z)\n\t}\n}\n\nINST_HANDLER (eor) {\t// EOR Rd, Rr\n\t\t\t// CLR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,^,\", r, d);\t\t\t// 0: Rd ^ Rr\n\t__generic_bitop_flags (op);\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (fmul) {\t// FMUL Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,r%d,r%d,*,<<,\", r, d);\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmuls) {\t// FMULS Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"*,<<,\", r, d);\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmulsu) {\t// FMULSU Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"*,<<,\");\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (ijmp) {\t// IJMP k\n\tut64 z;\n\t// read z for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\", &z, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = z << 1;\n\top->cycles = 2;\n\tESIL_A (\"1,z,<<,pc,=,\");\t\t// jump!\n}\n\nINST_HANDLER (icall) {\t// ICALL k\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard IJMP\n\tINST_CALL (ijmp);\n\t// fix cycles\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (in) {\t// IN Rd, A\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_src = __generic_io_dest (a, 0, cpu);\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"%s,r%d,=,\", r_strbuf_get (io_src), r);\n\tr_strbuf_free (io_src);\n}\n\nINST_HANDLER (inc) {\t// INC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"1,r%d,+,\", d);\t\t\t\t\t// ++Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x80,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (jmp) {\t// JMP k\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->cycles = 3;\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (las) {\t// LAS Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,|,\", d);\t\t\t\t// 0: (Z) | Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (lat) {\t// LAT Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,^,\", d);\t\t\t\t// 0: (Z) ^ Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (ld) {\t// LD Rd, X\n\t\t\t// LD Rd, X+\n\t\t\t// LD Rd, -X\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles = (buf[0] & 0x3) == 0\n\t\t\t? 2\t\t\t// LD Rd, X\n\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldd) {\t// LD Rd, Y\tLD Rd, Z\n\t\t\t// LD Rd, Y+\tLD Rd, Z+\n\t\t\t// LD Rd, -Y\tLD Rd, -Z\n\t\t\t// LD Rd, Y+q\tLD Rd, Z+q\n\t// calculate offset (this value only has sense in some opcodes,\n\t// but we are optimistic and we calculate it always)\n\tint offset = (buf[1] & 0x20)\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7);\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10) ? offset : 0,\t// offset or not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles =\n\t\t(buf[1] & 0x10) == 0\n\t\t\t? (!offset ? 1 : 3)\t\t// LDD\n\t\t\t: (buf[0] & 0x3) == 0\n\t\t\t\t? 1\t\t\t// LD Rd, X\n\t\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldi) {\t// LDI Rd, K\n\tint k = (buf[0] & 0xf) + ((buf[1] & 0xf) << 4);\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\top->val = k;\n\tESIL_A (\"0x%x,r%d,=,\", k, d);\n}\n\nINST_HANDLER (lds) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n\nINST_HANDLER (sts) {\t// STS k, Rr\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}\n\n#if 0\nINST_HANDLER (lds16) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0x0f)\n\t\t| ((buf[1] << 3) & 0x30)\n\t\t| ((buf[1] << 4) & 0x40)\n\t\t| (~(buf[1] << 4) & 0x80);\n\top->ptr = k;\n\n\t// load value from @k\n\t__generic_ld_st (op, \"ram\", 0, 0, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n#endif\n\nINST_HANDLER (lpm) {\t// LPM\n\t\t\t// LPM Rd, Z\n\t\t\t// LPM Rd, Z+\n\tut16 ins = (((ut16) buf[1]) << 8) | ((ut16) buf[0]);\n\t// read program memory\n\t__generic_ld_st (\n\t\top, \"prog\",\n\t\t'z',\t\t\t\t// index register Y/Z\n\t\t1,\t\t\t\t// use RAMP* registers\n\t\t(ins & 0xfe0f) == 0x9005\n\t\t\t? 1\t\t\t// post incremented\n\t\t\t: 0,\t\t\t// no increment\n\t\t0,\t\t\t\t// not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\",\n\t\t(ins == 0x95c8)\n\t\t\t? 0\t\t\t// LPM (r0)\n\t\t\t: ((buf[0] >> 4) & 0xf)\t// LPM Rd\n\t\t\t\t| ((buf[1] & 0x1) << 4));\n}\n\nINST_HANDLER (lsr) {\t// LSR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,\", d);\t\t\t\t// 0: R=(Rd >> 1)\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,nf,=,\");\t\t\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (mov) {\t// MOV Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\tESIL_A (\"r%d,r%d,=,\", r, d);\n}\n\nINST_HANDLER (movw) {\t// MOVW Rd+1:Rd, Rr+1:Rr\n\tint d = (buf[0] & 0xf0) >> 3;\n\tint r = (buf[0] & 0x0f) << 1;\n\tESIL_A (\"r%d,r%d,=,r%d,r%d,=,\", r, d, r + 1, d + 1);\n}\n\nINST_HANDLER (mul) {\t// MUL Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\n\tESIL_A (\"r%d,r%d,*,\", r, d);\t\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (mulsu) {\t// MULSU Rd, Rr\n\tint d = (buf[0] >> 4 & 0x07) + 16;\n\tint r = (buf[0] & 0x07) + 16;\n\n\tESIL_A (\"r%d,\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (neg) {\t// NEG Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"r%d,0x00,-,0xff,&,\", d);\t\t\t// 0: (0-Rd)\n\tESIL_A (\"DUP,r%d,0xff,^,|,0x08,&,!,!,hf,=,\", d);\t// H\n\tESIL_A (\"DUP,0x80,-,!,vf,=,\", d);\t\t\t// V\n\tESIL_A (\"DUP,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t\t// Z\n\tESIL_A (\"DUP,!,!,cf,=,\");\t\t\t\t// C\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (nop) {\t// NOP\n\tESIL_A (\",,\");\n}\n\nINST_HANDLER (or) {\t// OR Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,|,\", r, d);\t\t\t\t// 0: (Rd | Rr)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (ori) {\t// ORI Rd, K\n\t\t\t// SBR Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\top->val = k;\n\tESIL_A (\"r%d,%d,|,\", d, k);\t\t\t\t// 0: (Rd | k)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (out) {\t// OUT A, Rr\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_dst = __generic_io_dest (a, 1, cpu);\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"r%d,%s,\", r, r_strbuf_get (io_dst));\n\tr_strbuf_free (io_dst);\n}\n\nINST_HANDLER (pop) {\t// POP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\t__generic_pop (op, 1);\n\tESIL_A (\"r%d,=,\", d);\t// store in Rd\n\n}\n\nINST_HANDLER (push) {\t// PUSH Rr\n\tint r = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"r%d,\", r);\t// load Rr\n\t__generic_push (op, 1);\t// push it into stack\n\t// cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\")\n\t\t\t? 1\t// AT*mega optimizes one cycle\n\t\t\t: 2;\n}\n\nINST_HANDLER (rcall) {\t// RCALL k\n\t// target address\n\top->jump = (op->addr\n\t\t+ (((((buf[1] & 0xf) << 8) | buf[0]) << 1)\n\t\t\t| (((buf[1] & 0x8) ? ~((int) 0x1fff) : 0)))\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\top->fail = op->addr + op->size;\n\t// esil\n\tESIL_A (\"pc,\");\t\t\t\t// esil already points to next\n\t\t\t\t\t\t// instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret addr\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n\t// cycles\n\tif (!strncasecmp (cpu->model, \"ATtiny\", 6)) {\n\t\top->cycles = 4;\t// ATtiny is always slow\n\t} else {\n\t\t// PC size decides required runtime!\n\t\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\t\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t\top->cycles--;\t// ATxmega optimizes one cycle\n\t\t}\n\t}\n}\n\nINST_HANDLER (ret) {\t// RET\n\top->eob = true;\n\t// esil\n\t__generic_pop (op, CPU_PC_SIZE (cpu));\n\tESIL_A (\"pc,=,\");\t// jump!\n\t// cycles\n\tif (CPU_PC_SIZE (cpu) > 2) {\t// if we have a bus bigger than 16 bit\n\t\top->cycles++;\t// (i.e. a 22-bit bus), add one extra cycle\n\t}\n}\n\nINST_HANDLER (reti) {\t// RETI\n\t//XXX: There are not privileged instructions in ATMEL/AVR\n\top->family = R_ANAL_OP_FAMILY_PRIV;\n\n\t// first perform a standard 'ret'\n\tINST_CALL (ret);\n\n\t// RETI: The I-bit is cleared by hardware after an interrupt\n\t// has occurred, and is set by the RETI instruction to enable\n\t// subsequent interrupts\n\tESIL_A (\"1,if,=,\");\n}\n\nINST_HANDLER (rjmp) {\t// RJMP k\n\top->jump = (op->addr\n#ifdef _MSC_VER\n#pragma message (\"anal_avr.c: WARNING: Probably broken on windows\")\n\t\t+ ((((( buf[1] & 0xf) << 9) | (buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~(0x1fff) : 0))\n#else\n\t\t+ ((((( (typeof (op->jump)) buf[1] & 0xf) << 9) | ((typeof (op->jump)) buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~((typeof (op->jump)) 0x1fff) : 0))\n#endif\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\n}\n\nINST_HANDLER (ror) {\t// ROR Rd\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"1,r%d,>>,7,cf,<<,|,\", d);\t\t// 0: (Rd>>1) | (cf<<7)\n\tESIL_A (\"r%d,1,&,cf,=,\", d);\t\t\t// C\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t// V\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (sbc) {\t// SBC Rd, Rr\n\tint r = (buf[0] & 0x0f) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// 0: (Rd-Rr-C)\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbci) {\t// SBCI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"cf,%d,+,r%d,-,\", k, d);\t\t// 0: (Rd-k-C)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sub) {\t// SUB Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (subi) {\t// SUBI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbi) {\t// SBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,|,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbix) {\t// SBIC A, b\n\t\t\t// SBIS A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRAnalOp next_op;\n\tRStrBuf *io_port;\n\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size,\n\t\t\tlen - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"%d,1,<<,%s,&,\", b, io_port);\t\t// IO(A,b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\t\t// SBIC => branch if 0\n\t\t\t: \"!,!,\");\t\t\t// SBIS => branch if 1\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbiw) {\t// SBIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"%d,r%d:r%d,-,\", k, d + 1, d);\t\t// 0(Rd+1:Rd - Rr)\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t// Rd = result\n}\n\nINST_HANDLER (sbrx) {\t// SBRC Rr, b\n\t\t\t// SBRS Rr, b\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op = {0};\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t// Rr(b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t// SBRC => branch if cleared\n\t\t\t: \"!,!,\");\t// SBRS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (sleep) {\t// SLEEP\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (spm) {\t// SPM Z+\n\tut64 spmcsr;\n\n\t// read SPM Control Register (SPMCR)\n\tr_anal_esil_reg_read (anal->esil, \"spmcsr\", &spmcsr, NULL);\n\n\t// clear SPMCSR\n\tESIL_A (\"0x7c,spmcsr,&=,\");\n\n\t// decide action depending on the old value of SPMCSR\n\tswitch (spmcsr & 0x7f) {\n\t\tcase 0x03: // PAGE ERASE\n\t\t\t// invoke SPM_CLEAR_PAGE (erases target page writing\n\t\t\t// the 0xff value\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_ERASE,\");  // do magic\n\t\t\tbreak;\n\n\t\tcase 0x01: // FILL TEMPORARY BUFFER\n\t\t\tESIL_A (\"r1,r0,\");           // push data\n\t\t\tESIL_A (\"z,\");               // push target address\n\t\t\tESIL_A (\"SPM_PAGE_FILL,\");   // do magic\n\t\t\tbreak;\n\n\t\tcase 0x05: // WRITE PAGE\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_WRITE,\");  // do magic\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\teprintf (\"SPM: I dont know what to do with SPMCSR %02x.\\n\",\n\t\t\t\t\t(unsigned int) spmcsr);\n\t}\n\n\top->cycles = 1;\t// This is truly false. Datasheets do not publish how\n\t\t\t// many cycles this instruction uses in all its\n\t\t\t// operation modes and I am pretty sure that this value\n\t\t\t// can vary substantially from one MCU type to another.\n\t\t\t// So... one cycle is fine.\n}\n\nINST_HANDLER (st) {\t// ST X, Rr\n\t\t\t// ST X+, Rr\n\t\t\t// ST -X, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post increment\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t1);\t\t\t\t// store operation (st)\n//\t// cycles\n//\top->cycles = buf[0] & 0x3 == 0\n//\t\t\t? 2\t\t\t// LD Rd, X\n//\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (std) {\t// ST Y, Rr\tST Z, Rr\n\t\t\t// ST Y+, Rr\tST Z+, Rr\n\t\t\t// ST -Y, Rr\tST -Z, Rr\n\t\t\t// ST Y+q, Rr\tST Z+q, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10)\n\t\t\t? (buf[1] & 0x20)\t// offset\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7)\n\t\t\t: 0,\t\t\t// no offset\n\t\t1);\t\t\t\t// load operation (!st)\n//\t// cycles\n//\top->cycles =\n//\t\tbuf[1] & 0x1 == 0\n//\t\t\t? !(offset ? 1 : 3)\t\t// LDD\n//\t\t\t: buf[0] & 0x3 == 0\n//\t\t\t\t? 1\t\t\t// LD Rd, X\n//\t\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (swap) {\t// SWAP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"4,r%d,>>,0x0f,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"4,r%d,<<,0xf0,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"|,\", d);\t\t\t// S[0] | S[1]\n\tESIL_A (\"r%d,=,\", d);\t\t\t// Rd = result\n}\n\nOPCODE_DESC opcodes[] = {\n\t//         op      mask    select  cycles  size type\n\tINST_DECL (break,  0xffff, 0x9698, 1,      2,   TRAP   ), // BREAK\n\tINST_DECL (eicall, 0xffff, 0x9519, 0,      2,   UCALL  ), // EICALL\n\tINST_DECL (eijmp,  0xffff, 0x9419, 0,      2,   UJMP   ), // EIJMP\n\tINST_DECL (icall,  0xffff, 0x9509, 0,      2,   UCALL  ), // ICALL\n\tINST_DECL (ijmp,   0xffff, 0x9409, 0,      2,   UJMP   ), // IJMP\n\tINST_DECL (lpm,    0xffff, 0x95c8, 3,      2,   LOAD   ), // LPM\n\tINST_DECL (nop,    0xffff, 0x0000, 1,      2,   NOP    ), // NOP\n\tINST_DECL (ret,    0xffff, 0x9508, 4,      2,   RET    ), // RET\n\tINST_DECL (reti,   0xffff, 0x9518, 4,      2,   RET    ), // RETI\n\tINST_DECL (sleep,  0xffff, 0x9588, 1,      2,   NOP    ), // SLEEP\n\tINST_DECL (spm,    0xffff, 0x95e8, 1,      2,   TRAP   ), // SPM ...\n\tINST_DECL (bclr,   0xff8f, 0x9488, 1,      2,   SWI    ), // BCLR s\n\tINST_DECL (bset,   0xff8f, 0x9408, 1,      2,   SWI    ), // BSET s\n\tINST_DECL (fmul,   0xff88, 0x0308, 2,      2,   MUL    ), // FMUL Rd, Rr\n\tINST_DECL (fmuls,  0xff88, 0x0380, 2,      2,   MUL    ), // FMULS Rd, Rr\n\tINST_DECL (fmulsu, 0xff88, 0x0388, 2,      2,   MUL    ), // FMULSU Rd, Rr\n\tINST_DECL (mulsu,  0xff88, 0x0300, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (des,    0xff0f, 0x940b, 0,      2,   CRYPTO ), // DES k\n\tINST_DECL (adiw,   0xff00, 0x9600, 2,      2,   ADD    ), // ADIW Rd+1:Rd, K\n\tINST_DECL (sbiw,   0xff00, 0x9700, 2,      2,   SUB    ), // SBIW Rd+1:Rd, K\n\tINST_DECL (cbi,    0xff00, 0x9800, 1,      2,   IO     ), // CBI A, K\n\tINST_DECL (sbi,    0xff00, 0x9a00, 1,      2,   IO     ), // SBI A, K\n\tINST_DECL (movw,   0xff00, 0x0100, 1,      2,   MOV    ), // MOVW Rd+1:Rd, Rr+1:Rr\n\tINST_DECL (muls,   0xff00, 0x0200, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (asr,    0xfe0f, 0x9405, 1,      2,   SAR    ), // ASR Rd\n\tINST_DECL (com,    0xfe0f, 0x9400, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (dec,    0xfe0f, 0x940a, 1,      2,   SUB    ), // DEC Rd\n\tINST_DECL (elpm,   0xfe0f, 0x9006, 0,      2,   LOAD   ), // ELPM Rd, Z\n\tINST_DECL (elpm,   0xfe0f, 0x9007, 0,      2,   LOAD   ), // ELPM Rd, Z+\n\tINST_DECL (inc,    0xfe0f, 0x9403, 1,      2,   ADD    ), // INC Rd\n\tINST_DECL (lac,    0xfe0f, 0x9206, 2,      2,   LOAD   ), // LAC Z, Rd\n\tINST_DECL (las,    0xfe0f, 0x9205, 2,      2,   LOAD   ), // LAS Z, Rd\n\tINST_DECL (lat,    0xfe0f, 0x9207, 2,      2,   LOAD   ), // LAT Z, Rd\n\tINST_DECL (ld,     0xfe0f, 0x900c, 0,      2,   LOAD   ), // LD Rd, X\n\tINST_DECL (ld,     0xfe0f, 0x900d, 0,      2,   LOAD   ), // LD Rd, X+\n\tINST_DECL (ld,     0xfe0f, 0x900e, 0,      2,   LOAD   ), // LD Rd, -X\n\tINST_DECL (lds,    0xfe0f, 0x9000, 0,      4,   LOAD   ), // LDS Rd, k\n\tINST_DECL (sts,    0xfe0f, 0x9200, 2,      4,   STORE  ), // STS k, Rr\n\tINST_DECL (lpm,    0xfe0f, 0x9004, 3,      2,   LOAD   ), // LPM Rd, Z\n\tINST_DECL (lpm,    0xfe0f, 0x9005, 3,      2,   LOAD   ), // LPM Rd, Z+\n\tINST_DECL (lsr,    0xfe0f, 0x9406, 1,      2,   SHR    ), // LSR Rd\n\tINST_DECL (neg,    0xfe0f, 0x9401, 2,      2,   SUB    ), // NEG Rd\n\tINST_DECL (pop,    0xfe0f, 0x900f, 2,      2,   POP    ), // POP Rd\n\tINST_DECL (push,   0xfe0f, 0x920f, 0,      2,   PUSH   ), // PUSH Rr\n\tINST_DECL (ror,    0xfe0f, 0x9407, 1,      2,   SAR    ), // ROR Rd\n\tINST_DECL (st,     0xfe0f, 0x920c, 2,      2,   STORE  ), // ST X, Rr\n\tINST_DECL (st,     0xfe0f, 0x920d, 0,      2,   STORE  ), // ST X+, Rr\n\tINST_DECL (st,     0xfe0f, 0x920e, 0,      2,   STORE  ), // ST -X, Rr\n\tINST_DECL (swap,   0xfe0f, 0x9402, 1,      2,   SAR    ), // SWAP Rd\n\tINST_DECL (call,   0xfe0e, 0x940e, 0,      4,   CALL   ), // CALL k\n\tINST_DECL (jmp,    0xfe0e, 0x940c, 2,      4,   JMP    ), // JMP k\n\tINST_DECL (bld,    0xfe08, 0xf800, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (bst,    0xfe08, 0xfa00, 1,      2,   SWI    ), // BST Rd, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIC A, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIS A, b\n\tINST_DECL (sbrx,   0xfe08, 0xfc00, 2,      2,   CJMP   ), // SBRC Rr, b\n\tINST_DECL (sbrx,   0xfe08, 0xfe00, 2,      2,   CJMP   ), // SBRS Rr, b\n\tINST_DECL (ldd,    0xfe07, 0x9001, 0,      2,   LOAD   ), // LD Rd, Y/Z+\n\tINST_DECL (ldd,    0xfe07, 0x9002, 0,      2,   LOAD   ), // LD Rd, -Y/Z\n\tINST_DECL (std,    0xfe07, 0x9201, 0,      2,   STORE  ), // ST Y/Z+, Rr\n\tINST_DECL (std,    0xfe07, 0x9202, 0,      2,   STORE  ), // ST -Y/Z, Rr\n\tINST_DECL (adc,    0xfc00, 0x1c00, 1,      2,   ADD    ), // ADC Rd, Rr\n\tINST_DECL (add,    0xfc00, 0x0c00, 1,      2,   ADD    ), // ADD Rd, Rr\n\tINST_DECL (and,    0xfc00, 0x2000, 1,      2,   AND    ), // AND Rd, Rr\n\tINST_DECL (brbx,   0xfc00, 0xf000, 0,      2,   CJMP   ), // BRBS s, k\n\tINST_DECL (brbx,   0xfc00, 0xf400, 0,      2,   CJMP   ), // BRBC s, k\n\tINST_DECL (cp,     0xfc00, 0x1400, 1,      2,   CMP    ), // CP Rd, Rr\n\tINST_DECL (cpc,    0xfc00, 0x0400, 1,      2,   CMP    ), // CPC Rd, Rr\n\tINST_DECL (cpse,   0xfc00, 0x1000, 0,      2,   CJMP   ), // CPSE Rd, Rr\n\tINST_DECL (eor,    0xfc00, 0x2400, 1,      2,   XOR    ), // EOR Rd, Rr\n\tINST_DECL (mov,    0xfc00, 0x2c00, 1,      2,   MOV    ), // MOV Rd, Rr\n\tINST_DECL (mul,    0xfc00, 0x9c00, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (or,     0xfc00, 0x2800, 1,      2,   OR     ), // OR Rd, Rr\n\tINST_DECL (sbc,    0xfc00, 0x0800, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (sub,    0xfc00, 0x1800, 1,      2,   SUB    ), // SUB Rd, Rr\n\tINST_DECL (in,     0xf800, 0xb000, 1,      2,   IO     ), // IN Rd, A\n\t//INST_DECL (lds16,  0xf800, 0xa000, 1,      2,   LOAD   ), // LDS Rd, k\n\tINST_DECL (out,    0xf800, 0xb800, 1,      2,   IO     ), // OUT A, Rr\n\tINST_DECL (andi,   0xf000, 0x7000, 1,      2,   AND    ), // ANDI Rd, K\n\tINST_DECL (cpi,    0xf000, 0x3000, 1,      2,   CMP    ), // CPI Rd, K\n\tINST_DECL (ldi,    0xf000, 0xe000, 1,      2,   LOAD   ), // LDI Rd, K\n\tINST_DECL (ori,    0xf000, 0x6000, 1,      2,   OR     ), // ORI Rd, K\n\tINST_DECL (rcall,  0xf000, 0xd000, 0,      2,   CALL   ), // RCALL k\n\tINST_DECL (rjmp,   0xf000, 0xc000, 2,      2,   JMP    ), // RJMP k\n\tINST_DECL (sbci,   0xf000, 0x4000, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (subi,   0xf000, 0x5000, 1,      2,   SUB    ), // SUBI Rd, Rr\n\tINST_DECL (ldd,    0xd200, 0x8000, 0,      2,   LOAD   ), // LD Rd, Y/Z+q\n\tINST_DECL (std,    0xd200, 0x8200, 0,      2,   STORE  ), // ST Y/Z+q, Rr\n\n\tINST_LAST\n};\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\n\t// initialize op struct\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\n\t// process opcode\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\n\t\t\t// copy default cycles/size values\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\t// op->fail = addr + op->size;\n\t\t\top->addr = addr;\n\n\t\t\t// start void esil expression\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\n\t\t\t// handle opcode\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\t// eprintf (\"opcode %s @%\"PFMT64x\" returned 0 cycles.\\n\", opcode_desc->name, op->addr);\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\n\t\t\t// remove trailing coma (COMETE LA COMA)\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\n\t// ignore reserved opcodes (if they have not been caught by the previous loop)\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\n\nINVALID_OP:\n\t// An unknown or invalid option has appeared.\n\t//  -- Throw pokeball!\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\t// launch esil trap (for communicating upper layers about this weird\n\t// and stinky situation\n\tr_strbuf_set (&op->esil, \"1,$\");\n\n\treturn NULL;\n}\n\nstatic int avr_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len) {\n\tCPU_MODEL *cpu;\n\tut64 offset;\n\n\t// init op\n\tif (!op) {\n\t\treturn 2;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (anal->cpu);\n\n\t// set memory layout registers\n\tif (anal->esil) {\n\t\toffset = 0;\n\t\tr_anal_esil_reg_write (anal->esil, \"_prog\", offset);\n\n\t\toffset += (1 << cpu->pc);\n\t\tr_anal_esil_reg_write (anal->esil, \"_io\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_start\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_sram\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_eeprom\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"eeprom_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_page\", offset);\n\t}\n\t// process opcode\n\tavr_op_analyze (anal, op, addr, buf, len, cpu);\n\n\treturn op->size;\n}\n\nstatic int avr_custom_des (RAnalEsil *esil) {\n\tut64 key, encrypt, text,des_round;\n\tut32 key_lo, key_hi, buf_lo, buf_hi;\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\tif (!__esil_pop_argument (esil, &des_round)) {\n\t\treturn false;\n\t}\n\tr_anal_esil_reg_read (esil, \"hf\", &encrypt, NULL);\n\tr_anal_esil_reg_read (esil, \"deskey\", &key, NULL);\n\tr_anal_esil_reg_read (esil, \"text\", &text, NULL);\n\n\tkey_lo = key & UT32_MAX;\n\tkey_hi = key >> 32;\n\tbuf_lo = text & UT32_MAX;\n\tbuf_hi = text >> 32;\n\n\tif (des_round != desctx.round) {\n\t\tdesctx.round = des_round;\n\t}\n\n\tif (!desctx.round) {\n\t\tint i;\n\t\t//generating all round keys\n\t\tr_des_permute_key (&key_lo, &key_hi);\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tr_des_round_key (i, &desctx.round_key_lo[i], &desctx.round_key_hi[i], &key_lo, &key_hi);\n\t\t}\n\t\tr_des_permute_block0 (&buf_lo, &buf_hi);\n\t}\n\n\tif (encrypt) {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[desctx.round], &desctx.round_key_hi[desctx.round]);\n\t} else {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[15 - desctx.round], &desctx.round_key_hi[15 - desctx.round]);\n\t}\n\n\tif (desctx.round == 15) {\n\t\tr_des_permute_block1 (&buf_hi, &buf_lo);\n\t\tdesctx.round = 0;\n\t} else {\n\t\tdesctx.round++;\n\t}\n\n\tr_anal_esil_reg_write (esil, \"text\", text);\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_ERASE\nstatic int avr_custom_spm_page_erase(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut8 c;\n\tut64 addr, page_size_bits, i;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align base address to page_size_bits\n\taddr &= ~(MASK (page_size_bits));\n\n\t// perform erase\n\t//eprintf (\"SPM_PAGE_ERASE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tc = 0xff;\n\tfor (i = 0; i < (1ULL << page_size_bits); i++) {\n\t\tr_anal_esil_mem_write (\n\t\t\tesil, (addr + i) & CPU_PC_MASK (cpu), &c, 1);\n\t}\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_FILL\nstatic int avr_custom_spm_page_fill(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut64 addr, page_size_bits, i;\n\tut8 r0, r1;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address, r0, r1\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr0 = i;\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr1 = i;\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align and crop base address\n\taddr &= (MASK (page_size_bits) ^ 1);\n\n\t// perform write to temporary page\n\t//eprintf (\"SPM_PAGE_FILL bytes (%02x, %02x) @ 0x%08\" PFMT64x \".\\n\", r1, r0, addr);\n\tr_anal_esil_mem_write (esil, addr++, &r0, 1);\n\tr_anal_esil_mem_write (esil, addr++, &r1, 1);\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_WRITE\nstatic int avr_custom_spm_page_write(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tchar *t = NULL;\n\tut64 addr, page_size_bits, tmp_page;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument (esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address and base address\n\t// of the internal temporary page\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\tr_anal_esil_reg_read (esil, \"_page\", &tmp_page, NULL);\n\n\t// align base address to page_size_bits\n\taddr &= (~(MASK (page_size_bits)) & CPU_PC_MASK (cpu));\n\n\t// perform writing\n\t//eprintf (\"SPM_PAGE_WRITE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tif (!(t = malloc (1 << page_size_bits))) {\n\t\teprintf (\"Cannot alloc a buffer for copying the temporary page.\\n\");\n\t\treturn false;\n\t}\n\tr_anal_esil_mem_read (esil, tmp_page, (ut8 *) t, 1 << page_size_bits);\n\tr_anal_esil_mem_write (esil, addr, (ut8 *) t, 1 << page_size_bits);\n\n\treturn true;\n}\n\nstatic int esil_avr_hook_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tCPU_MODEL *cpu;\n\n\tif (!esil || !esil->anal) {\n\t\treturn 0;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (esil->anal->cpu);\n\n\t// crop registers and force certain values\n\tif (!strcmp (name, \"pc\")) {\n\t\t*val &= CPU_PC_MASK (cpu);\n\t} else if (!strcmp (name, \"pcl\")) {\n\t\tif (cpu->pc < 8) {\n\t\t\t*val &= MASK (8);\n\t\t}\n\t} else if (!strcmp (name, \"pch\")) {\n\t\t*val = cpu->pc > 8\n\t\t\t? *val & MASK (cpu->pc - 8)\n\t\t\t: 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int esil_avr_init(RAnalEsil *esil) {\n\tif (!esil) {\n\t\treturn false;\n\t}\n\tdesctx.round = 0;\n\tr_anal_esil_set_op (esil, \"des\", avr_custom_des);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_ERASE\", avr_custom_spm_page_erase);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_FILL\", avr_custom_spm_page_fill);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_WRITE\", avr_custom_spm_page_write);\n\tesil->cb.hook_reg_write = esil_avr_hook_reg_write;\n\n\treturn true;\n}\n\nstatic int esil_avr_fini(RAnalEsil *esil) {\n\treturn true;\n}\n\nstatic int set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpcl\\n\"\n\t\t\"=SP\tsp\\n\"\n// explained in http://www.nongnu.org/avr-libc/user-manual/FAQ.html\n// and http://www.avrfreaks.net/forum/function-calling-convention-gcc-generated-assembly-file\n\t\t\"=A0\tr25\\n\"\n\t\t\"=A1\tr24\\n\"\n\t\t\"=A2\tr23\\n\"\n\t\t\"=A3\tr22\\n\"\n\t\t\"=R0\tr24\\n\"\n#if 0\nPC: 16- or 22-bit program counter\nSP: 8- or 16-bit stack pointer\nSREG: 8-bit status register\nRAMPX, RAMPY, RAMPZ, RAMPD and EIND:\n#endif\n// 8bit registers x 32\n\t\t\"gpr\tr0\t.8\t0\t0\\n\"\n\t\t\"gpr\tr1\t.8\t1\t0\\n\"\n\t\t\"gpr\tr2\t.8\t2\t0\\n\"\n\t\t\"gpr\tr3\t.8\t3\t0\\n\"\n\t\t\"gpr\tr4\t.8\t4\t0\\n\"\n\t\t\"gpr\tr5\t.8\t5\t0\\n\"\n\t\t\"gpr\tr6\t.8\t6\t0\\n\"\n\t\t\"gpr\tr7\t.8\t7\t0\\n\"\n\t\t\"gpr\ttext\t.64\t0\t0\\n\"\n\t\t\"gpr\tr8\t.8\t8\t0\\n\"\n\t\t\"gpr\tr9\t.8\t9\t0\\n\"\n\t\t\"gpr\tr10\t.8\t10\t0\\n\"\n\t\t\"gpr\tr11\t.8\t11\t0\\n\"\n\t\t\"gpr\tr12\t.8\t12\t0\\n\"\n\t\t\"gpr\tr13\t.8\t13\t0\\n\"\n\t\t\"gpr\tr14\t.8\t14\t0\\n\"\n\t\t\"gpr\tr15\t.8\t15\t0\\n\"\n\t\t\"gpr\tdeskey\t.64\t8\t0\\n\"\n\t\t\"gpr\tr16\t.8\t16\t0\\n\"\n\t\t\"gpr\tr17\t.8\t17\t0\\n\"\n\t\t\"gpr\tr18\t.8\t18\t0\\n\"\n\t\t\"gpr\tr19\t.8\t19\t0\\n\"\n\t\t\"gpr\tr20\t.8\t20\t0\\n\"\n\t\t\"gpr\tr21\t.8\t21\t0\\n\"\n\t\t\"gpr\tr22\t.8\t22\t0\\n\"\n\t\t\"gpr\tr23\t.8\t23\t0\\n\"\n\t\t\"gpr\tr24\t.8\t24\t0\\n\"\n\t\t\"gpr\tr25\t.8\t25\t0\\n\"\n\t\t\"gpr\tr26\t.8\t26\t0\\n\"\n\t\t\"gpr\tr27\t.8\t27\t0\\n\"\n\t\t\"gpr\tr28\t.8\t28\t0\\n\"\n\t\t\"gpr\tr29\t.8\t29\t0\\n\"\n\t\t\"gpr\tr30\t.8\t30\t0\\n\"\n\t\t\"gpr\tr31\t.8\t31\t0\\n\"\n\n// 16 bit overlapped registers for 16 bit math\n\t\t\"gpr\tr17:r16\t.16\t16\t0\\n\"\n\t\t\"gpr\tr19:r18\t.16\t18\t0\\n\"\n\t\t\"gpr\tr21:r20\t.16\t20\t0\\n\"\n\t\t\"gpr\tr23:r22\t.16\t22\t0\\n\"\n\t\t\"gpr\tr25:r24\t.16\t24\t0\\n\"\n\t\t\"gpr\tr27:r26\t.16\t26\t0\\n\"\n\t\t\"gpr\tr29:r28\t.16\t28\t0\\n\"\n\t\t\"gpr\tr31:r30\t.16\t30\t0\\n\"\n\n// 16 bit overlapped registers for memory addressing\n\t\t\"gpr\tx\t.16\t26\t0\\n\"\n\t\t\"gpr\ty\t.16\t28\t0\\n\"\n\t\t\"gpr\tz\t.16\t30\t0\\n\"\n// program counter\n// NOTE: program counter size in AVR depends on the CPU model. It seems that\n// the PC may range from 16 bits to 22 bits.\n\t\t\"gpr\tpc\t.32\t32\t0\\n\"\n\t\t\"gpr\tpcl\t.16\t32\t0\\n\"\n\t\t\"gpr\tpch\t.16\t34\t0\\n\"\n// special purpose registers\n\t\t\"gpr\tsp\t.16\t36\t0\\n\"\n\t\t\"gpr\tspl\t.8\t36\t0\\n\"\n\t\t\"gpr\tsph\t.8\t37\t0\\n\"\n// status bit register (SREG)\n\t\t\"gpr\tsreg\t.8\t38\t0\\n\"\n\t\t\"gpr\tcf\t.1\t38.0\t0\\n\" // Carry. This is a borrow flag on subtracts.\n\t\t\"gpr\tzf\t.1\t38.1\t0\\n\" // Zero. Set to 1 when an arithmetic result is zero.\n\t\t\"gpr\tnf\t.1\t38.2\t0\\n\" // Negative. Set to a copy of the most significant bit of an arithmetic result.\n\t\t\"gpr\tvf\t.1\t38.3\t0\\n\" // Overflow flag. Set in case of two's complement overflow.\n\t\t\"gpr\tsf\t.1\t38.4\t0\\n\" // Sign flag. Unique to AVR, this is always (N ^ V) (xor), and shows the true sign of a comparison.\n\t\t\"gpr\thf\t.1\t38.5\t0\\n\" // Half carry. This is an internal carry from additions and is used to support BCD arithmetic.\n\t\t\"gpr\ttf\t.1\t38.6\t0\\n\" // Bit copy. Special bit load and bit store instructions use this bit.\n\t\t\"gpr\tif\t.1\t38.7\t0\\n\" // Interrupt flag. Set when interrupts are enabled.\n// 8bit segment registers to be added to X, Y, Z to get 24bit offsets\n\t\t\"gpr\trampx\t.8\t39\t0\\n\"\n\t\t\"gpr\trampy\t.8\t40\t0\\n\"\n\t\t\"gpr\trampz\t.8\t41\t0\\n\"\n\t\t\"gpr\trampd\t.8\t42\t0\\n\"\n\t\t\"gpr\teind\t.8\t43\t0\\n\"\n// memory mapping emulator registers\n//      _prog\n//\t\tthe program flash. It has its own address space.\n//\t_ram\n//\t_io\n//\t\tstart of the data addres space. It is the same address of IO,\n//\t\tbecause IO is the first memory space addressable in the AVR.\n//\t_sram\n//\t\tstart of the SRAM (this offset depends on IO size, and it is\n//\t\tinside the _ram address space)\n//      _eeprom\n//              this is another address space, outside ram and flash\n//      _page\n//              this is the temporary page used by the SPM instruction. This\n//              memory is not directly addressable and it is used internally by\n//              the CPU when autoflashing.\n\t\t\"gpr\t_prog\t.32\t44\t0\\n\"\n\t\t\"gpr    _page   .32     48\t0\\n\"\n\t\t\"gpr\t_eeprom\t.32\t52\t0\\n\"\n\t\t\"gpr\t_ram\t.32\t56\t0\\n\"\n\t\t\"gpr\t_io\t.32\t56\t0\\n\"\n\t\t\"gpr\t_sram\t.32\t60\t0\\n\"\n// other important MCU registers\n//\tspmcsr/spmcr\n//\t\tStore Program Memory Control and Status Register (SPMCSR)\n\t\t\"gpr    spmcsr  .8      64      0\\n\"\n\t\t;\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nstatic int archinfo(RAnal *anal, int q) {\n\tif (q == R_ANAL_ARCHINFO_ALIGN)\n\t\treturn 2;\n\tif (q == R_ANAL_ARCHINFO_MAX_OP_SIZE)\n\t\treturn 4;\n\tif (q == R_ANAL_ARCHINFO_MIN_OP_SIZE)\n\t\treturn 2;\n\treturn 2; // XXX\n}\n\n\nstatic ut8 *anal_mask_avr(RAnal *anal, int size, const ut8 *data, ut64 at) {\n\tRAnalOp *op = NULL;\n\tut8 *ret = NULL;\n\tint idx;\n\n\tif (!(op = r_anal_op_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = malloc (size))) {\n\t\tr_anal_op_free (op);\n\t\treturn NULL;\n\t}\n\n\tmemset (ret, 0xff, size);\n\n\tCPU_MODEL *cpu = get_cpu_model (anal->cpu);\n\n\tfor (idx = 0; idx + 1 < size; idx += op->size) {\n\t\tOPCODE_DESC* opcode_desc = avr_op_analyze (anal, op, at + idx, data + idx, size - idx, cpu);\n\n\t\tif (op->size < 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!opcode_desc) { // invalid instruction\n\t\t\tcontinue;\n\t\t}\n\n\t\t// the additional data for \"long\" opcodes (4 bytes) is usually something we want to ignore for matching\n\t\t// (things like memory offsets or jump addresses)\n\t\tif (op->size == 4) {\n\t\t\tret[idx + 2] = 0;\n\t\t\tret[idx + 3] = 0;\n\t\t}\n\n\t\tif (op->ptr != UT64_MAX || op->jump != UT64_MAX) {\n\t\t\tret[idx] = opcode_desc->mask;\n\t\t\tret[idx + 1] = opcode_desc->mask >> 8;\n\t\t}\n\t}\n\n\tr_anal_op_free (op);\n\n\treturn ret;\n}\n\nRAnalPlugin r_anal_plugin_avr = {\n\t.name = \"avr\",\n\t.desc = \"AVR code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"avr\",\n\t.esil = true,\n\t.archinfo = archinfo,\n\t.bits = 8 | 16, // 24 big regs conflicts\n\t.op = &avr_op,\n\t.set_reg_profile = &set_reg_profile,\n\t.esil_init = esil_avr_init,\n\t.esil_fini = esil_avr_fini,\n\t.anal_mask = anal_mask_avr,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_avr,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare - LGPL - Copyright 2011-2018 - pancake, Roc Valles, condret, killabyte */\n\n#if 0\nhttp://www.atmel.com/images/atmel-0856-avr-instruction-set-manual.pdf\nhttps://en.wikipedia.org/wiki/Atmel_AVR_instruction_set\n#endif\n\n#include <string.h>\n#include <r_types.h>\n#include <r_util.h>\n#include <r_lib.h>\n#include <r_asm.h>\n#include <r_anal.h>\n\nstatic RDESContext desctx;\n\ntypedef struct _cpu_const_tag {\n\tconst char *const key;\n\tut8 type;\n\tut32 value;\n\tut8 size;\n} CPU_CONST;\n\n#define CPU_CONST_NONE\t0\n#define CPU_CONST_PARAM\t1\n#define CPU_CONST_REG\t2\n\ntypedef struct _cpu_model_tag {\n\tconst char *const model;\n\tint pc;\n\tchar *inherit;\n\tstruct _cpu_model_tag *inherit_cpu_p;\n\tCPU_CONST *consts[10];\n} CPU_MODEL;\n\ntypedef void (*inst_handler_t) (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu);\n\ntypedef struct _opcodes_tag_ {\n\tconst char *const name;\n\tint mask;\n\tint selector;\n\tinst_handler_t handler;\n\tint cycles;\n\tint size;\n\tut64 type;\n} OPCODE_DESC;\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu);\n\n#define CPU_MODEL_DECL(model, pc, consts)\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\tmodel,\t\t\t\t\t\t\t\\\n\t\tpc,\t\t\t\t\t\t\t\\\n\t\tconsts\t\t\t\t\t\t\t\\\n\t}\n#define MASK(bits)\t\t\t((bits) == 32 ? 0xffffffff : (~((~((ut32) 0)) << (bits))))\n#define CPU_PC_MASK(cpu)\t\tMASK((cpu)->pc)\n#define CPU_PC_SIZE(cpu)\t\t((((cpu)->pc) >> 3) + ((((cpu)->pc) & 0x07) ? 1 : 0))\n\n#define INST_HANDLER(OPCODE_NAME)\tstatic void _inst__ ## OPCODE_NAME (RAnal *anal, RAnalOp *op, const ut8 *buf, int len, int *fail, CPU_MODEL *cpu)\n#define INST_DECL(OP, M, SL, C, SZ, T)\t{ #OP, (M), (SL), _inst__ ## OP, (C), (SZ), R_ANAL_OP_TYPE_ ## T }\n#define INST_LAST\t\t\t{ \"unknown\", 0, 0, (void *) 0, 2, 1, R_ANAL_OP_TYPE_UNK }\n\n#define INST_CALL(OPCODE_NAME)\t\t_inst__ ## OPCODE_NAME (anal, op, buf, len, fail, cpu)\n#define INST_INVALID\t\t\t{ *fail = 1; return; }\n#define INST_ASSERT(x)\t\t\t{ if (!(x)) { INST_INVALID; } }\n\n#define ESIL_A(e, ...)\t\t\tr_strbuf_appendf (&op->esil, e, ##__VA_ARGS__)\n\n#define STR_BEGINS(in, s)\t\tstrncasecmp (in, s, strlen (s))\n\n// Following IO definitions are valid for:\n//\tATmega8\n//\tATmega88\nCPU_CONST cpu_reg_common[] = {\n\t{ \"spl\",    CPU_CONST_REG, 0x3d, sizeof (ut8) },\n\t{ \"sph\",    CPU_CONST_REG, 0x3e, sizeof (ut8) },\n\t{ \"sreg\",   CPU_CONST_REG, 0x3f, sizeof (ut8) },\n\t{ \"spmcsr\", CPU_CONST_REG, 0x37, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_common[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x40, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM, 0x60, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 1024, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_m640_m1280m_m1281_m2560_m2561[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,    512, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM,  0x1ff, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x200, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_memsize_xmega128a4u[] = {\n\t{ \"eeprom_size\", CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"io_size\",     CPU_CONST_PARAM, 0x1000, sizeof (ut32) },\n\t{ \"sram_start\",  CPU_CONST_PARAM,  0x800, sizeof (ut32) },\n\t{ \"sram_size\",   CPU_CONST_PARAM, 0x2000, sizeof (ut32) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_5_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 5, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_CONST cpu_pagesize_7_bits[] = {\n\t{ \"page_size\", CPU_CONST_PARAM, 7, sizeof (ut8) },\n\t{ NULL, 0, 0, 0 },\n};\n\nCPU_MODEL cpu_models[] = {\n\t{ .model = \"ATmega640\",   .pc = 15,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_m640_m1280m_m1281_m2560_m2561,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t},\n\t},\n\t{\n\t\t.model = \"ATxmega128a4u\", .pc = 17,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_xmega128a4u,\n\t\t\tcpu_pagesize_7_bits,\n\t\t\tNULL\n\t\t}\n\t},\n\t{ .model = \"ATmega1280\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega1281\",  .pc = 16, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2560\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega2561\",  .pc = 17, .inherit = \"ATmega640\" },\n\t{ .model = \"ATmega88\",    .pc = 8,  .inherit = \"ATmega8\" },\n//\tCPU_MODEL_DECL (\"ATmega168\",   13, 512, 512),\n\t// last model is the default AVR - ATmega8 forever!\n\t{\n\t\t.model = \"ATmega8\", .pc = 13,\n\t\t.consts = {\n\t\t\tcpu_reg_common,\n\t\t\tcpu_memsize_common,\n\t\t\tcpu_pagesize_5_bits,\n\t\t\tNULL\n\t\t}\n\t},\n};\n\nstatic CPU_MODEL *get_cpu_model(char *model);\n\nstatic CPU_MODEL *__get_cpu_model_recursive(char *model) {\n\tCPU_MODEL *cpu = NULL;\n\n\tfor (cpu = cpu_models; cpu < cpu_models + ((sizeof (cpu_models) / sizeof (CPU_MODEL))) - 1; cpu++) {\n\t\tif (!strcasecmp (model, cpu->model)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// fix inheritance tree\n\tif (cpu->inherit && !cpu->inherit_cpu_p) {\n\t\tcpu->inherit_cpu_p = get_cpu_model (cpu->inherit);\n\t\tif (!cpu->inherit_cpu_p) {\n\t\t\teprintf (\"ERROR: Cannot inherit from unknown CPU model '%s'.\\n\", cpu->inherit);\n\t\t}\n\t}\n\n\treturn cpu;\n}\n\nstatic CPU_MODEL *get_cpu_model(char *model) {\n\tstatic CPU_MODEL *cpu = NULL;\n\n\t// cached value?\n\tif (cpu && !strcasecmp (model, cpu->model))\n\t\treturn cpu;\n\n\t// do the real search\n\tcpu = __get_cpu_model_recursive (model);\n\n\treturn cpu;\n}\n\nstatic ut32 const_get_value(CPU_CONST *c) {\n\treturn c ? MASK (c->size * 8) & c->value : 0;\n}\n\n\nstatic CPU_CONST *const_by_name(CPU_MODEL *cpu, int type, char *c) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem->key; citem++) {\n\t\t\tif (!strcmp (c, citem->key)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_name (cpu->inherit_cpu_p, type, c);\n\teprintf (\"ERROR: CONSTANT key[%s] NOT FOUND.\\n\", c);\n\treturn NULL;\n}\n\nstatic int __esil_pop_argument(RAnalEsil *esil, ut64 *v) {\n\tchar *t = r_anal_esil_pop (esil);\n\tif (!t || !r_anal_esil_get_parm (esil, t, v)) {\n\t\tfree (t);\n\t\treturn false;\n\t}\n\tfree (t);\n\treturn true;\n}\n\nstatic CPU_CONST *const_by_value(CPU_MODEL *cpu, int type, ut32 v) {\n\tCPU_CONST **clist, *citem;\n\n\tfor (clist = cpu->consts; *clist; clist++) {\n\t\tfor (citem = *clist; citem && citem->key; citem++) {\n\t\t\tif (citem->value == (MASK (citem->size * 8) & v)\n\t\t\t&& (type == CPU_CONST_NONE || type == citem->type)) {\n\t\t\t\treturn citem;\n\t\t\t}\n\t\t}\n\t}\n\tif (cpu->inherit_cpu_p)\n\t\treturn const_by_value (cpu->inherit_cpu_p, type, v);\n\treturn NULL;\n}\n\nstatic RStrBuf *__generic_io_dest(ut8 port, int write, CPU_MODEL *cpu) {\n\tRStrBuf *r = r_strbuf_new (\"\");\n\tCPU_CONST *c = const_by_value (cpu, CPU_CONST_REG, port);\n\tif (c != NULL) {\n\t\tr_strbuf_set (r, c->key);\n\t\tif (write) {\n\t\t\tr_strbuf_append (r, \",=\");\n\t\t}\n\t} else {\n\t\tr_strbuf_setf (r, \"_io,%d,+,%s[1]\", port, write ? \"=\" : \"\");\n\t}\n\n\treturn r;\n}\n\nstatic void __generic_bitop_flags(RAnalOp *op) {\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n}\n\nstatic void __generic_ld_st(RAnalOp *op, char *mem, char ireg, int use_ramp, int prepostdec, int offset, int st) {\n\tif (ireg) {\n\t\t// preincrement index register\n\t\tif (prepostdec < 0) {\n\t\t\tESIL_A (\"1,%c,-,%c,=,\", ireg, ireg);\n\t\t}\n\t\t// set register index address\n\t\tESIL_A (\"%c,\", ireg);\n\t\t// add offset\n\t\tif (offset != 0) {\n\t\t\tESIL_A (\"%d,+,\", offset);\n\t\t}\n\t} else {\n\t\tESIL_A (\"%d,\", offset);\n\t}\n\tif (use_ramp) {\n\t\tESIL_A (\"16,ramp%c,<<,+,\", ireg ? ireg : 'd');\n\t}\n\t// set SRAM base address\n\tESIL_A (\"_%s,+,\", mem);\n\t// read/write from SRAM\n\tESIL_A (\"%s[1],\", st ? \"=\" : \"\");\n\t// postincrement index register\n\tif (ireg && prepostdec > 0) {\n\t\tESIL_A (\"1,%c,+,%c,=,\", ireg, ireg);\n\t}\n}\n\nstatic void __generic_pop(RAnalOp *op, int sz) {\n\tif (sz > 1) {\n\t\tESIL_A (\"1,sp,+,_ram,+,\");\t// calc SRAM(sp+1)\n\t\tESIL_A (\"[%d],\", sz);\t\t// read value\n\t\tESIL_A (\"%d,sp,+=,\", sz);\t// sp += item_size\n\t} else {\n\t\tESIL_A (\"1,sp,+=,\"\t\t// increment stack pointer\n\t\t\t\"sp,_ram,+,[1],\");\t// load SRAM[sp]\n\t}\n}\n\nstatic void __generic_push(RAnalOp *op, int sz) {\n\tESIL_A (\"sp,_ram,+,\");\t\t\t// calc pointer SRAM(sp)\n\tif (sz > 1) {\n\t\tESIL_A (\"-%d,+,\", sz - 1);\t// dec SP by 'sz'\n\t}\n\tESIL_A (\"=[%d],\", sz);\t\t\t// store value in stack\n\tESIL_A (\"-%d,sp,+=,\", sz);\t\t// decrement stack pointer\n}\n\nstatic void __generic_add_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,!,\" \"%s,0x08,&,!,!,\"    \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"      \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,\"        \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,!,\"    \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_add_update_flags_rr(RAnalOp *op, int d, int r) {\n\t__generic_add_update_flags(op, 'r', d, 'r', r);\n}\n\nstatic void __generic_sub_update_flags(RAnalOp *op, char t_d, ut64 v_d, char t_rk, ut64 v_rk, int carry) {\n\tRStrBuf *d_strbuf, *rk_strbuf;\n\tchar *d, *rk;\n\n\td_strbuf = r_strbuf_new (NULL);\n\trk_strbuf = r_strbuf_new (NULL);\n\tr_strbuf_setf (d_strbuf,  t_d  == 'r' ? \"r%d\" : \"%\" PFMT64d, v_d);\n\tr_strbuf_setf (rk_strbuf, t_rk == 'r' ? \"r%d\" : \"%\" PFMT64d, v_rk);\n\n\td = r_strbuf_get(d_strbuf);\n\trk = r_strbuf_get(rk_strbuf);\n\n\tESIL_A (\"%s,0x08,&,!,\"   \"%s,0x08,&,!,!,\"      \"&,\"\t// H\n\t\t\"%s,0x08,&,!,!,\" \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"%s,0x08,&,!,\"   \"0,RPICK,0x08,&,!,!,\" \"&,\"\n\t\t\"|,|,hf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"%s,0x80,&,!,!,\" \"%s,0x80,&,!,\"        \"&,\"\t// V\n\t\t\"\"               \"0,RPICK,0x80,&,!,\"   \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\n\t\t\"\"               \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,vf,=,\",\n\t\td, rk, d, rk);\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tif (carry)\n\t\tESIL_A (\"0,RPICK,!,zf,&,zf,=,\");\t\t// Z\n\telse\n\t\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"%s,0x80,&,!,\"   \"%s,0x80,&,!,!,\"      \"&,\"\t// C\n\t\t\"%s,0x80,&,!,!,\" \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"%s,0x80,&,!,\"   \"0,RPICK,0x80,&,!,!,\" \"&,\"\n\t\t\"|,|,cf,=,\",\n\t\td, rk, rk, d);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\n\tr_strbuf_free (d_strbuf);\n\tr_strbuf_free (rk_strbuf);\n}\n\nstatic void __generic_sub_update_flags_rr(RAnalOp *op, int d, int r, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'r', r, carry);\n}\n\nstatic void __generic_sub_update_flags_rk(RAnalOp *op, int d, int k, int carry) {\n\t__generic_sub_update_flags(op, 'r', d, 'k', k, carry);\n}\n\nINST_HANDLER (adc) {\t// ADC Rd, Rr\n\t\t\t// ROL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,cf,+,r%d,+,\", r, d);\t\t// Rd + Rr + C\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (add) {\t// ADD Rd, Rr\n\t\t\t// LSL Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,+,\", r, d);\t\t\t// Rd + Rr\n\t__generic_add_update_flags_rr(op, d, r);\t// FLAGS\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (adiw) {\t// ADIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"r%d:r%d,%d,+,\", d + 1, d, k);\t\t\t// Rd+1:Rd + Rr\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t\t// Rd = result\n}\n\nINST_HANDLER (and) {\t// AND Rd, Rr\n\t\t\t// TST Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,&,\", r, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (andi) {\t// ANDI Rd, K\n\t\t\t// CBR Rd, K (= ANDI Rd, 1-K)\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0x0f) << 4) | (buf[0] & 0x0f);\n\top->val = k;\n\tESIL_A (\"%d,r%d,&,\", k, d);\t\t\t\t// 0: Rd & Rr\n\t__generic_bitop_flags (op);\t\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (asr) {\t// ASR Rd\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,r%d,0x80,&,|,\", d, d);\t\t// 0: R=(Rd >> 1) | Rd7\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (bclr) {\t// BCLR s\n\t\t\t// CLC\n\t\t\t// CLH\n\t\t\t// CLI\n\t\t\t// CLN\n\t\t\t// CLR\n\t\t\t// CLS\n\t\t\t// CLT\n\t\t\t// CLV\n\t\t\t// CLZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"0xff,%d,1,<<,^,sreg,&=,\", s);\n}\n\nINST_HANDLER (bld) {\t// BLD Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tint d = ((buf[1] & 0x01) << 4) | ((buf[0] >> 4) & 0xf);\n\tint b = buf[0] & 0x7;\n\tESIL_A (\"r%d,%d,1,<<,0xff,^,&,\", d, b);\t\t\t// Rd/b = 0\n\tESIL_A (\"%d,tf,<<,|,r%d,=,\", b, d);\t\t\t// Rd/b |= T<<b\n}\n\nINST_HANDLER (brbx) {\t// BRBC s, k\n\t\t\t// BRBS s, k\n\t\t\t// BRBC/S 0:\t\tBRCC\t\tBRCS\n\t\t\t//\t\t\tBRSH\t\tBRLO\n\t\t\t// BRBC/S 1:\t\tBREQ\t\tBRNE\n\t\t\t// BRBC/S 2:\t\tBRPL\t\tBRMI\n\t\t\t// BRBC/S 3:\t\tBRVC\t\tBRVS\n\t\t\t// BRBC/S 4:\t\tBRGE\t\tBRLT\n\t\t\t// BRBC/S 5:\t\tBRHC\t\tBRHS\n\t\t\t// BRBC/S 6:\t\tBRTC\t\tBRTS\n\t\t\t// BRBC/S 7:\t\tBRID\t\tBRIE\n\tint s = buf[0] & 0x7;\n\top->jump = op->addr\n\t\t+ ((((buf[1] & 0x03) << 6) | ((buf[0] & 0xf8) >> 2))\n\t\t\t| (buf[1] & 0x2 ? ~((int) 0x7f) : 0))\n\t\t+ 2;\n\top->fail = op->addr + op->size;\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,sreg,&,\", s);\t\t\t\t// SREG(s)\n\tESIL_A (buf[1] & 0x4\n\t\t\t? \"!,\"\t\t// BRBC => branch if cleared\n\t\t\t: \"!,!,\");\t// BRBS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (break) {\t// BREAK\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (bset) {\t// BSET s\n\t\t\t// SEC\n\t\t\t// SEH\n\t\t\t// SEI\n\t\t\t// SEN\n\t\t\t// SER\n\t\t\t// SES\n\t\t\t// SET\n\t\t\t// SEV\n\t\t\t// SEZ\n\tint s = (buf[0] >> 4) & 0x7;\n\tESIL_A (\"%d,1,<<,sreg,|=,\", s);\n}\n\nINST_HANDLER (bst) {\t// BST Rd, b\n\tif (len < 2) {\n\t\treturn;\n\t}\n\tESIL_A (\"r%d,%d,1,<<,&,!,!,tf,=,\",\t\t\t// tf = Rd/b\n\t\t((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf),\t// r\n\t\tbuf[0] & 0x7);\t\t\t\t\t// b\n}\n\nINST_HANDLER (call) {\t// CALL k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->fail = op->addr + op->size;\n\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\top->cycles--;\t// AT*mega optimizes one cycle\n\t}\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (cbi) {\t// CBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->family = R_ANAL_OP_FAMILY_IO;\n\top->type2 = 1;\n\top->val = a;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,^,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (com) {\t// COM Rd\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 1) << 4);\n\n\tESIL_A (\"r%d,0xff,-,0xff,&,r%d,=,\", r, r);\t\t// Rd = 0xFF-Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,cf,=,\");\t\t\t\t\t// C\n\t__generic_bitop_flags (op);\t\t\t\t// ...rest...\n}\n\nINST_HANDLER (cp) {\t// CP Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// do Rd - Rr\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n}\n\nINST_HANDLER (cpc) {\t// CPC Rd, Rr\n\tint r = (buf[0]        & 0x0f) | ((buf[1] << 3) & 0x10);\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// Rd - Rr - C\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpi) { // CPI Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// Rd - k\n\t__generic_sub_update_flags_rk (op, d, k, 0);\t// FLAGS (carry)\n}\n\nINST_HANDLER (cpse) {\t// CPSE Rd, Rr\n\tint r = (buf[0] & 0xf) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tRAnalOp next_op;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to true, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"r%d,r%d,^,!,\", r, d);\t\t\t// Rr == Rd\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (dec) {\t// DEC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"-1,r%d,+,\", d);\t\t\t\t// --Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x7f,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (des) {\t// DES k\n\tif (desctx.round < 16) {\t//DES\n\t\top->type = R_ANAL_OP_TYPE_CRYPTO;\n\t\top->cycles = 1;\t\t//redo this\n\t\tr_strbuf_setf (&op->esil, \"%d,des\", desctx.round);\n\t}\n}\n\nINST_HANDLER (eijmp) {\t// EIJMP\n\tut64 z, eind;\n\t// read z and eind for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\",    &z,    NULL);\n\tr_anal_esil_reg_read (anal->esil, \"eind\", &eind, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = ((eind << 16) + z) << 1;\n\t// jump\n\tESIL_A (\"1,z,16,eind,<<,+,<<,pc,=,\");\n\t// cycles\n\top->cycles = 2;\n}\n\nINST_HANDLER (eicall) {\t// EICALL\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard EIJMP\n\tINST_CALL (eijmp);\n\t// fix cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\") ? 3 : 4;\n}\n\nINST_HANDLER (elpm) {\t// ELPM\n\t\t\t// ELPM Rd\n\t\t\t// ELPM Rd, Z+\n\tint d = ((buf[1] & 0xfe) == 0x90)\n\t\t\t? ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf)\t// Rd\n\t\t\t: 0;\t\t\t\t\t\t// R0\n\tESIL_A (\"16,rampz,<<,z,+,_prog,+,[1],\");\t// read RAMPZ:Z\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = [1]\n\tif ((buf[1] & 0xfe) == 0x90 && (buf[0] & 0xf) == 0x7) {\n\t\tESIL_A (\"16,1,z,+,DUP,z,=,>>,1,&,rampz,+=,\");\t// ++(rampz:z)\n\t}\n}\n\nINST_HANDLER (eor) {\t// EOR Rd, Rr\n\t\t\t// CLR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,^,\", r, d);\t\t\t// 0: Rd ^ Rr\n\t__generic_bitop_flags (op);\t\t\t// up flags\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (fmul) {\t// FMUL Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,r%d,r%d,*,<<,\", r, d);\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmuls) {\t// FMULS Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"*,<<,\", r, d);\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (fmulsu) {\t// FMULSU Rd, Rr\n\tint d = ((buf[0] >> 4) & 0x7) + 16;\n\tint r = (buf[0] & 0x7) + 16;\n\n\tESIL_A (\"1,\");\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"r%d\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"*,<<,\");\t\t\t\t// 0: (Rd*Rr)<<1\n\n\tESIL_A (\"0xffff,&,\");\t\t\t\t// prevent overflow\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/16\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (ijmp) {\t// IJMP k\n\tut64 z;\n\t// read z for calculating jump address on runtime\n\tr_anal_esil_reg_read (anal->esil, \"z\", &z, NULL);\n\t// real target address may change during execution, so this value will\n\t// be changing all the time\n\top->jump = z << 1;\n\top->cycles = 2;\n\tESIL_A (\"1,z,<<,pc,=,\");\t\t// jump!\n}\n\nINST_HANDLER (icall) {\t// ICALL k\n\t// push pc in stack\n\tESIL_A (\"pc,\");\t\t\t\t// esil is already pointing to\n\t\t\t\t\t\t// next instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret in stack\n\t// do a standard IJMP\n\tINST_CALL (ijmp);\n\t// fix cycles\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (in) {\t// IN Rd, A\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_src = __generic_io_dest (a, 0, cpu);\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"%s,r%d,=,\", r_strbuf_get (io_src), r);\n\tr_strbuf_free (io_src);\n}\n\nINST_HANDLER (inc) {\t// INC Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tESIL_A (\"1,r%d,+,\", d);\t\t\t\t\t// ++Rd\n\t\t\t\t\t\t\t\t// FLAGS:\n\tESIL_A (\"0,RPICK,0x80,==,vf,=,\");\t\t\t// V\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (jmp) {\t// JMP k\n\top->jump = (buf[2] << 1)\n\t\t | (buf[3] << 9)\n\t\t | (buf[1] & 0x01) << 23\n\t\t | (buf[0] & 0x01) << 17\n\t\t | (buf[0] & 0xf0) << 14;\n\top->cycles = 3;\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n}\n\nINST_HANDLER (lac) {\t// LAC Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,0xff,^,&,\", d);\t\t\t// 0: (Z) & ~Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (las) {\t// LAS Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,|,\", d);\t\t\t\t// 0: (Z) | Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (lat) {\t// LAT Z, Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\t// read memory from RAMPZ:Z\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 0);\t// 0: Read (RAMPZ:Z)\n\tESIL_A (\"r%d,^,\", d);\t\t\t\t// 0: (Z) ^ Rd\n\tESIL_A (\"DUP,r%d,=,\", d);\t\t\t// Rd = [0]\n\t__generic_ld_st (op, \"ram\", 'z', 1, 0, 0, 1);\t// Store in RAM\n}\n\nINST_HANDLER (ld) {\t// LD Rd, X\n\t\t\t// LD Rd, X+\n\t\t\t// LD Rd, -X\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles = (buf[0] & 0x3) == 0\n\t\t\t? 2\t\t\t// LD Rd, X\n\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldd) {\t// LD Rd, Y\tLD Rd, Z\n\t\t\t// LD Rd, Y+\tLD Rd, Z+\n\t\t\t// LD Rd, -Y\tLD Rd, -Z\n\t\t\t// LD Rd, Y+q\tLD Rd, Z+q\n\t// calculate offset (this value only has sense in some opcodes,\n\t// but we are optimistic and we calculate it always)\n\tint offset = (buf[1] & 0x20)\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7);\n\t// read memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10) ? offset : 0,\t// offset or not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// cycles\n\top->cycles =\n\t\t(buf[1] & 0x10) == 0\n\t\t\t? (!offset ? 1 : 3)\t\t// LDD\n\t\t\t: (buf[0] & 0x3) == 0\n\t\t\t\t? 1\t\t\t// LD Rd, X\n\t\t\t\t: (buf[0] & 0x3) == 1\n\t\t\t\t\t? 2\t\t// LD Rd, X+\n\t\t\t\t\t: 3;\t\t// LD Rd, -X\n\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n\t\t// AT*mega optimizes 1 cycle!\n\t\top->cycles--;\n\t}\n}\n\nINST_HANDLER (ldi) {\t// LDI Rd, K\n\tint k = (buf[0] & 0xf) + ((buf[1] & 0xf) << 4);\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\top->val = k;\n\tESIL_A (\"0x%x,r%d,=,\", k, d);\n}\n\nINST_HANDLER (lds) {\t// LDS Rd, k\n\tif (len < 4) {\n\t\treturn;\n\t}\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\t// load value from RAMPD:k\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n\nINST_HANDLER (sts) {\t// STS k, Rr\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\tint k = (buf[3] << 8) | buf[2];\n\top->ptr = k;\n\n\tESIL_A (\"r%d,\", r);\n\t__generic_ld_st (op, \"ram\", 0, 1, 0, k, 1);\n\n\top->cycles = 2;\n}\n\n#if 0\nINST_HANDLER (lds16) {\t// LDS Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0x0f)\n\t\t| ((buf[1] << 3) & 0x30)\n\t\t| ((buf[1] << 4) & 0x40)\n\t\t| (~(buf[1] << 4) & 0x80);\n\top->ptr = k;\n\n\t// load value from @k\n\t__generic_ld_st (op, \"ram\", 0, 0, 0, k, 0);\n\tESIL_A (\"r%d,=,\", d);\n}\n#endif\n\nINST_HANDLER (lpm) {\t// LPM\n\t\t\t// LPM Rd, Z\n\t\t\t// LPM Rd, Z+\n\tut16 ins = (((ut16) buf[1]) << 8) | ((ut16) buf[0]);\n\t// read program memory\n\t__generic_ld_st (\n\t\top, \"prog\",\n\t\t'z',\t\t\t\t// index register Y/Z\n\t\t1,\t\t\t\t// use RAMP* registers\n\t\t(ins & 0xfe0f) == 0x9005\n\t\t\t? 1\t\t\t// post incremented\n\t\t\t: 0,\t\t\t// no increment\n\t\t0,\t\t\t\t// not offset\n\t\t0);\t\t\t\t// load operation (!st)\n\t// load register\n\tESIL_A (\"r%d,=,\",\n\t\t(ins == 0x95c8)\n\t\t\t? 0\t\t\t// LPM (r0)\n\t\t\t: ((buf[0] >> 4) & 0xf)\t// LPM Rd\n\t\t\t\t| ((buf[1] & 0x1) << 4));\n}\n\nINST_HANDLER (lsr) {\t// LSR Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"1,r%d,>>,\", d);\t\t\t\t// 0: R=(Rd >> 1)\n\tESIL_A (\"r%d,0x1,&,!,!,cf,=,\", d);\t\t\t// C = Rd0\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,nf,=,\");\t\t\t\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t\t// V\n\tESIL_A (\"nf,vf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = R\n}\n\nINST_HANDLER (mov) {\t// MOV Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\tESIL_A (\"r%d,r%d,=,\", r, d);\n}\n\nINST_HANDLER (movw) {\t// MOVW Rd+1:Rd, Rr+1:Rr\n\tint d = (buf[0] & 0xf0) >> 3;\n\tint r = (buf[0] & 0x0f) << 1;\n\tESIL_A (\"r%d,r%d,=,r%d,r%d,=,\", r, d, r + 1, d + 1);\n}\n\nINST_HANDLER (mul) {\t// MUL Rd, Rr\n\tint d = ((buf[1] << 4) & 0x10) | ((buf[0] >> 4) & 0x0f);\n\tint r = ((buf[1] << 3) & 0x10) | (buf[0] & 0x0f);\n\n\tESIL_A (\"r%d,r%d,*,\", r, d);\t\t\t// 0: (Rd*Rr)<<1\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (muls) {\t// MULS Rd, Rr\n\tint d = (buf[0] >> 4 & 0x0f) + 16;\n\tint r = (buf[0] & 0x0f) + 16;\n\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", r);\t// sign extension Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (mulsu) {\t// MULSU Rd, Rr\n\tint d = (buf[0] >> 4 & 0x07) + 16;\n\tint r = (buf[0] & 0x07) + 16;\n\n\tESIL_A (\"r%d,\", r);\t\t\t\t// unsigned Rr\n\tESIL_A (\"r%d,DUP,0x80,&,?{,0xffff00,|,},\", d);\t// sign extension Rd\n\tESIL_A (\"*,\");\t\t\t\t\t// 0: (Rd*Rr)\n\tESIL_A (\"DUP,0xff,&,r0,=,\");\t\t\t// r0 = LO(0)\n\tESIL_A (\"8,0,RPICK,>>,0xff,&,r1,=,\");\t\t// r1 = HI(0)\n\tESIL_A (\"DUP,0x8000,&,!,!,cf,=,\");\t\t// C = R/15\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t// Z = !R\n}\n\nINST_HANDLER (neg) {\t// NEG Rd\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tESIL_A (\"r%d,0x00,-,0xff,&,\", d);\t\t\t// 0: (0-Rd)\n\tESIL_A (\"DUP,r%d,0xff,^,|,0x08,&,!,!,hf,=,\", d);\t// H\n\tESIL_A (\"DUP,0x80,-,!,vf,=,\", d);\t\t\t// V\n\tESIL_A (\"DUP,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"DUP,!,zf,=,\");\t\t\t\t\t// Z\n\tESIL_A (\"DUP,!,!,cf,=,\");\t\t\t\t// C\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (nop) {\t// NOP\n\tESIL_A (\",,\");\n}\n\nINST_HANDLER (or) {\t// OR Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\tESIL_A (\"r%d,r%d,|,\", r, d);\t\t\t\t// 0: (Rd | Rr)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (ori) {\t// ORI Rd, K\n\t\t\t// SBR Rd, K\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = (buf[0] & 0xf) | ((buf[1] & 0xf) << 4);\n\top->val = k;\n\tESIL_A (\"r%d,%d,|,\", d, k);\t\t\t\t// 0: (Rd | k)\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t\t// N\n\tESIL_A (\"0,vf,=,\");\t\t\t\t\t// V\n\tESIL_A (\"nf,sf,=,\");\t\t\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (out) {\t// OUT A, Rr\n\tint r = ((buf[0] >> 4) & 0x0f) | ((buf[1] & 0x01) << 4);\n\tint a = (buf[0] & 0x0f) | ((buf[1] & 0x6) << 3);\n\tRStrBuf *io_dst = __generic_io_dest (a, 1, cpu);\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\tESIL_A (\"r%d,%s,\", r, r_strbuf_get (io_dst));\n\tr_strbuf_free (io_dst);\n}\n\nINST_HANDLER (pop) {\t// POP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\t__generic_pop (op, 1);\n\tESIL_A (\"r%d,=,\", d);\t// store in Rd\n\n}\n\nINST_HANDLER (push) {\t// PUSH Rr\n\tint r = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"r%d,\", r);\t// load Rr\n\t__generic_push (op, 1);\t// push it into stack\n\t// cycles\n\top->cycles = !STR_BEGINS (cpu->model, \"ATxmega\")\n\t\t\t? 1\t// AT*mega optimizes one cycle\n\t\t\t: 2;\n}\n\nINST_HANDLER (rcall) {\t// RCALL k\n\t// target address\n\top->jump = (op->addr\n\t\t+ (((((buf[1] & 0xf) << 8) | buf[0]) << 1)\n\t\t\t| (((buf[1] & 0x8) ? ~((int) 0x1fff) : 0)))\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\top->fail = op->addr + op->size;\n\t// esil\n\tESIL_A (\"pc,\");\t\t\t\t// esil already points to next\n\t\t\t\t\t\t// instruction (@ret)\n\t__generic_push (op, CPU_PC_SIZE (cpu));\t// push @ret addr\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\t// jump!\n\t// cycles\n\tif (!strncasecmp (cpu->model, \"ATtiny\", 6)) {\n\t\top->cycles = 4;\t// ATtiny is always slow\n\t} else {\n\t\t// PC size decides required runtime!\n\t\top->cycles = cpu->pc <= 16 ? 3 : 4;\n\t\tif (!STR_BEGINS (cpu->model, \"ATxmega\")) {\n\t\t\top->cycles--;\t// ATxmega optimizes one cycle\n\t\t}\n\t}\n}\n\nINST_HANDLER (ret) {\t// RET\n\top->eob = true;\n\t// esil\n\t__generic_pop (op, CPU_PC_SIZE (cpu));\n\tESIL_A (\"pc,=,\");\t// jump!\n\t// cycles\n\tif (CPU_PC_SIZE (cpu) > 2) {\t// if we have a bus bigger than 16 bit\n\t\top->cycles++;\t// (i.e. a 22-bit bus), add one extra cycle\n\t}\n}\n\nINST_HANDLER (reti) {\t// RETI\n\t//XXX: There are not privileged instructions in ATMEL/AVR\n\top->family = R_ANAL_OP_FAMILY_PRIV;\n\n\t// first perform a standard 'ret'\n\tINST_CALL (ret);\n\n\t// RETI: The I-bit is cleared by hardware after an interrupt\n\t// has occurred, and is set by the RETI instruction to enable\n\t// subsequent interrupts\n\tESIL_A (\"1,if,=,\");\n}\n\nINST_HANDLER (rjmp) {\t// RJMP k\n\top->jump = (op->addr\n#ifdef _MSC_VER\n#pragma message (\"anal_avr.c: WARNING: Probably broken on windows\")\n\t\t+ ((((( buf[1] & 0xf) << 9) | (buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~(0x1fff) : 0))\n#else\n\t\t+ ((((( (typeof (op->jump)) buf[1] & 0xf) << 9) | ((typeof (op->jump)) buf[0] << 1)))\n\t\t\t| (buf[1] & 0x8 ? ~((typeof (op->jump)) 0x1fff) : 0))\n#endif\n\t\t+ 2) & CPU_PC_MASK (cpu);\n\tESIL_A (\"%\"PFMT64d\",pc,=,\", op->jump);\n}\n\nINST_HANDLER (ror) {\t// ROR Rd\n\tint d = ((buf[0] >> 4) & 0x0f) | ((buf[1] << 4) & 0x10);\n\tESIL_A (\"1,r%d,>>,7,cf,<<,|,\", d);\t\t// 0: (Rd>>1) | (cf<<7)\n\tESIL_A (\"r%d,1,&,cf,=,\", d);\t\t\t// C\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"0,RPICK,0x80,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"nf,cf,^,vf,=,\");\t\t\t// V\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = result\n}\n\nINST_HANDLER (sbc) {\t// SBC Rd, Rr\n\tint r = (buf[0] & 0x0f) | ((buf[1] & 0x2) << 3);\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);\n\n\tESIL_A (\"cf,r%d,+,r%d,-,\", r, d);\t\t// 0: (Rd-Rr-C)\n\t__generic_sub_update_flags_rr (op, d, r, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbci) {\t// SBCI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"cf,%d,+,r%d,-,\", k, d);\t\t// 0: (Rd-k-C)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sub) {\t// SUB Rd, Rr\n\tint d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 1) << 4);\n\tint r = (buf[0] & 0xf) | ((buf[1] & 2) << 3);\n\n\tESIL_A (\"r%d,r%d,-,\", r, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rr (op, d, r, 0);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (subi) {\t// SUBI Rd, k\n\tint d = ((buf[0] >> 4) & 0xf) + 16;\n\tint k = ((buf[1] & 0xf) << 4) | (buf[0] & 0xf);\n\top->val = k;\n\n\tESIL_A (\"%d,r%d,-,\", k, d);\t\t\t// 0: (Rd-k)\n\t__generic_sub_update_flags_rk (op, d, k, 1);\t// FLAGS (no carry)\n\tESIL_A (\"r%d,=,\", d);\t\t\t\t// Rd = Result\n}\n\nINST_HANDLER (sbi) {\t// SBI A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRStrBuf *io_port;\n\n\top->type2 = 1;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"0xff,%d,1,<<,|,%s,&,\", b, io_port);\n\tr_strbuf_free (io_port);\n\n\t// write result to port a\n\tio_port = __generic_io_dest (a, 1, cpu);\n\tESIL_A (\"%s,\", r_strbuf_get (io_port));\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbix) {\t// SBIC A, b\n\t\t\t// SBIS A, b\n\tint a = (buf[0] >> 3) & 0x1f;\n\tint b = buf[0] & 0x07;\n\tRAnalOp next_op;\n\tRStrBuf *io_port;\n\n\top->type2 = 0;\n\top->val = a;\n\top->family = R_ANAL_OP_FAMILY_IO;\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size,\n\t\t\tlen - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\n\t// read port a and clear bit b\n\tio_port = __generic_io_dest (a, 0, cpu);\n\tESIL_A (\"%d,1,<<,%s,&,\", b, io_port);\t\t// IO(A,b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t\t\t// SBIC => branch if 0\n\t\t\t: \"!,!,\");\t\t\t// SBIS => branch if 1\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n\tr_strbuf_free (io_port);\n}\n\nINST_HANDLER (sbiw) {\t// SBIW Rd+1:Rd, K\n\tint d = ((buf[0] & 0x30) >> 3) + 24;\n\tint k = (buf[0] & 0xf) | ((buf[0] >> 2) & 0x30);\n\top->val = k;\n\tESIL_A (\"%d,r%d:r%d,-,\", k, d + 1, d);\t\t// 0(Rd+1:Rd - Rr)\n\tESIL_A (\"r%d,0x80,&,!,!,\"\t\t\t// V\n\t\t\"0,RPICK,0x8000,&,!,\"\n\t\t\"&,vf,=,\", d + 1);\n\tESIL_A (\"0,RPICK,0x8000,&,!,!,nf,=,\");\t\t// N\n\tESIL_A (\"0,RPICK,!,zf,=,\");\t\t\t// Z\n\tESIL_A (\"r%d,0x80,&,!,\"\t\t\t\t// C\n\t\t\"0,RPICK,0x8000,&,!,!,\"\n\t\t\"&,cf,=,\", d + 1);\n\tESIL_A (\"vf,nf,^,sf,=,\");\t\t\t// S\n\tESIL_A (\"r%d:r%d,=,\", d + 1, d);\t\t// Rd = result\n}\n\nINST_HANDLER (sbrx) {\t// SBRC Rr, b\n\t\t\t// SBRS Rr, b\n\tint b = buf[0] & 0x7;\n\tint r = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x01) << 4);\n\tRAnalOp next_op = {0};\n\n\t// calculate next instruction size (call recursively avr_op_analyze)\n\t// and free next_op's esil string (we dont need it now)\n\tavr_op_analyze (anal,\n\t\t\t&next_op,\n\t\t\top->addr + op->size, buf + op->size, len - op->size,\n\t\t\tcpu);\n\tr_strbuf_fini (&next_op.esil);\n\top->jump = op->addr + next_op.size + 2;\n\n\t// cycles\n\top->cycles = 1;\t// XXX: This is a bug, because depends on eval state,\n\t\t\t// so it cannot be really be known until this\n\t\t\t// instruction is executed by the ESIL interpreter!!!\n\t\t\t// In case of evaluating to false, this instruction\n\t\t\t// needs 2/3 cycles, elsewhere it needs only 1 cycle.\n\tESIL_A (\"%d,1,<<,r%d,&,\", b, r);\t\t\t// Rr(b)\n\tESIL_A ((buf[1] & 0xe) == 0xc\n\t\t\t? \"!,\"\t\t// SBRC => branch if cleared\n\t\t\t: \"!,!,\");\t// SBRS => branch if set\n\tESIL_A (\"?{,%\"PFMT64d\",pc,=,},\", op->jump);\t// ?true => jmp\n}\n\nINST_HANDLER (sleep) {\t// SLEEP\n\tESIL_A (\"BREAK\");\n}\n\nINST_HANDLER (spm) {\t// SPM Z+\n\tut64 spmcsr;\n\n\t// read SPM Control Register (SPMCR)\n\tr_anal_esil_reg_read (anal->esil, \"spmcsr\", &spmcsr, NULL);\n\n\t// clear SPMCSR\n\tESIL_A (\"0x7c,spmcsr,&=,\");\n\n\t// decide action depending on the old value of SPMCSR\n\tswitch (spmcsr & 0x7f) {\n\t\tcase 0x03: // PAGE ERASE\n\t\t\t// invoke SPM_CLEAR_PAGE (erases target page writing\n\t\t\t// the 0xff value\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_ERASE,\");  // do magic\n\t\t\tbreak;\n\n\t\tcase 0x01: // FILL TEMPORARY BUFFER\n\t\t\tESIL_A (\"r1,r0,\");           // push data\n\t\t\tESIL_A (\"z,\");               // push target address\n\t\t\tESIL_A (\"SPM_PAGE_FILL,\");   // do magic\n\t\t\tbreak;\n\n\t\tcase 0x05: // WRITE PAGE\n\t\t\tESIL_A (\"16,rampz,<<,z,+,\"); // push target address\n\t\t\tESIL_A (\"SPM_PAGE_WRITE,\");  // do magic\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\teprintf (\"SPM: I dont know what to do with SPMCSR %02x.\\n\",\n\t\t\t\t\t(unsigned int) spmcsr);\n\t}\n\n\top->cycles = 1;\t// This is truly false. Datasheets do not publish how\n\t\t\t// many cycles this instruction uses in all its\n\t\t\t// operation modes and I am pretty sure that this value\n\t\t\t// can vary substantially from one MCU type to another.\n\t\t\t// So... one cycle is fine.\n}\n\nINST_HANDLER (st) {\t// ST X, Rr\n\t\t\t// ST X+, Rr\n\t\t\t// ST -X, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\t'x',\t\t\t\t// use index register X\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t(buf[0] & 0xf) == 0xe\n\t\t\t? -1\t\t\t// pre decremented\n\t\t\t: (buf[0] & 0xf) == 0xd\n\t\t\t\t? 1\t\t// post increment\n\t\t\t\t: 0,\t\t// no increment\n\t\t0,\t\t\t\t// offset always 0\n\t\t1);\t\t\t\t// store operation (st)\n//\t// cycles\n//\top->cycles = buf[0] & 0x3 == 0\n//\t\t\t? 2\t\t\t// LD Rd, X\n//\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (std) {\t// ST Y, Rr\tST Z, Rr\n\t\t\t// ST Y+, Rr\tST Z+, Rr\n\t\t\t// ST -Y, Rr\tST -Z, Rr\n\t\t\t// ST Y+q, Rr\tST Z+q, Rr\n\t// load register\n\tESIL_A (\"r%d,\", ((buf[1] & 1) << 4) | ((buf[0] >> 4) & 0xf));\n\t// write in memory\n\t__generic_ld_st (\n\t\top, \"ram\",\n\t\tbuf[0] & 0x8 ? 'y' : 'z',\t// index register Y/Z\n\t\t0,\t\t\t\t// no use RAMP* registers\n\t\t!(buf[1] & 0x10)\n\t\t\t? 0\t\t\t// no increment\n\t\t\t: buf[0] & 0x1\n\t\t\t\t? 1\t\t// post incremented\n\t\t\t\t: -1,\t\t// pre decremented\n\t\t!(buf[1] & 0x10)\n\t\t\t? (buf[1] & 0x20)\t// offset\n\t\t\t| ((buf[1] & 0xc) << 1)\n\t\t\t| (buf[0] & 0x7)\n\t\t\t: 0,\t\t\t// no offset\n\t\t1);\t\t\t\t// load operation (!st)\n//\t// cycles\n//\top->cycles =\n//\t\tbuf[1] & 0x1 == 0\n//\t\t\t? !(offset ? 1 : 3)\t\t// LDD\n//\t\t\t: buf[0] & 0x3 == 0\n//\t\t\t\t? 1\t\t\t// LD Rd, X\n//\t\t\t\t: buf[0] & 0x3 == 1\n//\t\t\t\t\t? 2\t\t// LD Rd, X+\n//\t\t\t\t\t: 3;\t\t// LD Rd, -X\n//\tif (!STR_BEGINS (cpu->model, \"ATxmega\") && op->cycles > 1) {\n//\t\t// AT*mega optimizes 1 cycle!\n//\t\top->cycles--;\n//\t}\n}\n\nINST_HANDLER (swap) {\t// SWAP Rd\n\tint d = ((buf[1] & 0x1) << 4) | ((buf[0] >> 4) & 0xf);\n\tESIL_A (\"4,r%d,>>,0x0f,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"4,r%d,<<,0xf0,&,\", d);\t\t// (Rd >> 4) & 0xf\n\tESIL_A (\"|,\", d);\t\t\t// S[0] | S[1]\n\tESIL_A (\"r%d,=,\", d);\t\t\t// Rd = result\n}\n\nOPCODE_DESC opcodes[] = {\n\t//         op      mask    select  cycles  size type\n\tINST_DECL (break,  0xffff, 0x9698, 1,      2,   TRAP   ), // BREAK\n\tINST_DECL (eicall, 0xffff, 0x9519, 0,      2,   UCALL  ), // EICALL\n\tINST_DECL (eijmp,  0xffff, 0x9419, 0,      2,   UJMP   ), // EIJMP\n\tINST_DECL (icall,  0xffff, 0x9509, 0,      2,   UCALL  ), // ICALL\n\tINST_DECL (ijmp,   0xffff, 0x9409, 0,      2,   UJMP   ), // IJMP\n\tINST_DECL (lpm,    0xffff, 0x95c8, 3,      2,   LOAD   ), // LPM\n\tINST_DECL (nop,    0xffff, 0x0000, 1,      2,   NOP    ), // NOP\n\tINST_DECL (ret,    0xffff, 0x9508, 4,      2,   RET    ), // RET\n\tINST_DECL (reti,   0xffff, 0x9518, 4,      2,   RET    ), // RETI\n\tINST_DECL (sleep,  0xffff, 0x9588, 1,      2,   NOP    ), // SLEEP\n\tINST_DECL (spm,    0xffff, 0x95e8, 1,      2,   TRAP   ), // SPM ...\n\tINST_DECL (bclr,   0xff8f, 0x9488, 1,      2,   SWI    ), // BCLR s\n\tINST_DECL (bset,   0xff8f, 0x9408, 1,      2,   SWI    ), // BSET s\n\tINST_DECL (fmul,   0xff88, 0x0308, 2,      2,   MUL    ), // FMUL Rd, Rr\n\tINST_DECL (fmuls,  0xff88, 0x0380, 2,      2,   MUL    ), // FMULS Rd, Rr\n\tINST_DECL (fmulsu, 0xff88, 0x0388, 2,      2,   MUL    ), // FMULSU Rd, Rr\n\tINST_DECL (mulsu,  0xff88, 0x0300, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (des,    0xff0f, 0x940b, 0,      2,   CRYPTO ), // DES k\n\tINST_DECL (adiw,   0xff00, 0x9600, 2,      2,   ADD    ), // ADIW Rd+1:Rd, K\n\tINST_DECL (sbiw,   0xff00, 0x9700, 2,      2,   SUB    ), // SBIW Rd+1:Rd, K\n\tINST_DECL (cbi,    0xff00, 0x9800, 1,      2,   IO     ), // CBI A, K\n\tINST_DECL (sbi,    0xff00, 0x9a00, 1,      2,   IO     ), // SBI A, K\n\tINST_DECL (movw,   0xff00, 0x0100, 1,      2,   MOV    ), // MOVW Rd+1:Rd, Rr+1:Rr\n\tINST_DECL (muls,   0xff00, 0x0200, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (asr,    0xfe0f, 0x9405, 1,      2,   SAR    ), // ASR Rd\n\tINST_DECL (com,    0xfe0f, 0x9400, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (dec,    0xfe0f, 0x940a, 1,      2,   SUB    ), // DEC Rd\n\tINST_DECL (elpm,   0xfe0f, 0x9006, 0,      2,   LOAD   ), // ELPM Rd, Z\n\tINST_DECL (elpm,   0xfe0f, 0x9007, 0,      2,   LOAD   ), // ELPM Rd, Z+\n\tINST_DECL (inc,    0xfe0f, 0x9403, 1,      2,   ADD    ), // INC Rd\n\tINST_DECL (lac,    0xfe0f, 0x9206, 2,      2,   LOAD   ), // LAC Z, Rd\n\tINST_DECL (las,    0xfe0f, 0x9205, 2,      2,   LOAD   ), // LAS Z, Rd\n\tINST_DECL (lat,    0xfe0f, 0x9207, 2,      2,   LOAD   ), // LAT Z, Rd\n\tINST_DECL (ld,     0xfe0f, 0x900c, 0,      2,   LOAD   ), // LD Rd, X\n\tINST_DECL (ld,     0xfe0f, 0x900d, 0,      2,   LOAD   ), // LD Rd, X+\n\tINST_DECL (ld,     0xfe0f, 0x900e, 0,      2,   LOAD   ), // LD Rd, -X\n\tINST_DECL (lds,    0xfe0f, 0x9000, 0,      4,   LOAD   ), // LDS Rd, k\n\tINST_DECL (sts,    0xfe0f, 0x9200, 2,      4,   STORE  ), // STS k, Rr\n\tINST_DECL (lpm,    0xfe0f, 0x9004, 3,      2,   LOAD   ), // LPM Rd, Z\n\tINST_DECL (lpm,    0xfe0f, 0x9005, 3,      2,   LOAD   ), // LPM Rd, Z+\n\tINST_DECL (lsr,    0xfe0f, 0x9406, 1,      2,   SHR    ), // LSR Rd\n\tINST_DECL (neg,    0xfe0f, 0x9401, 2,      2,   SUB    ), // NEG Rd\n\tINST_DECL (pop,    0xfe0f, 0x900f, 2,      2,   POP    ), // POP Rd\n\tINST_DECL (push,   0xfe0f, 0x920f, 0,      2,   PUSH   ), // PUSH Rr\n\tINST_DECL (ror,    0xfe0f, 0x9407, 1,      2,   SAR    ), // ROR Rd\n\tINST_DECL (st,     0xfe0f, 0x920c, 2,      2,   STORE  ), // ST X, Rr\n\tINST_DECL (st,     0xfe0f, 0x920d, 0,      2,   STORE  ), // ST X+, Rr\n\tINST_DECL (st,     0xfe0f, 0x920e, 0,      2,   STORE  ), // ST -X, Rr\n\tINST_DECL (swap,   0xfe0f, 0x9402, 1,      2,   SAR    ), // SWAP Rd\n\tINST_DECL (call,   0xfe0e, 0x940e, 0,      4,   CALL   ), // CALL k\n\tINST_DECL (jmp,    0xfe0e, 0x940c, 2,      4,   JMP    ), // JMP k\n\tINST_DECL (bld,    0xfe08, 0xf800, 1,      2,   SWI    ), // BLD Rd, b\n\tINST_DECL (bst,    0xfe08, 0xfa00, 1,      2,   SWI    ), // BST Rd, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIC A, b\n\tINST_DECL (sbix,   0xfe08, 0x9900, 2,      2,   CJMP   ), // SBIS A, b\n\tINST_DECL (sbrx,   0xfe08, 0xfc00, 2,      2,   CJMP   ), // SBRC Rr, b\n\tINST_DECL (sbrx,   0xfe08, 0xfe00, 2,      2,   CJMP   ), // SBRS Rr, b\n\tINST_DECL (ldd,    0xfe07, 0x9001, 0,      2,   LOAD   ), // LD Rd, Y/Z+\n\tINST_DECL (ldd,    0xfe07, 0x9002, 0,      2,   LOAD   ), // LD Rd, -Y/Z\n\tINST_DECL (std,    0xfe07, 0x9201, 0,      2,   STORE  ), // ST Y/Z+, Rr\n\tINST_DECL (std,    0xfe07, 0x9202, 0,      2,   STORE  ), // ST -Y/Z, Rr\n\tINST_DECL (adc,    0xfc00, 0x1c00, 1,      2,   ADD    ), // ADC Rd, Rr\n\tINST_DECL (add,    0xfc00, 0x0c00, 1,      2,   ADD    ), // ADD Rd, Rr\n\tINST_DECL (and,    0xfc00, 0x2000, 1,      2,   AND    ), // AND Rd, Rr\n\tINST_DECL (brbx,   0xfc00, 0xf000, 0,      2,   CJMP   ), // BRBS s, k\n\tINST_DECL (brbx,   0xfc00, 0xf400, 0,      2,   CJMP   ), // BRBC s, k\n\tINST_DECL (cp,     0xfc00, 0x1400, 1,      2,   CMP    ), // CP Rd, Rr\n\tINST_DECL (cpc,    0xfc00, 0x0400, 1,      2,   CMP    ), // CPC Rd, Rr\n\tINST_DECL (cpse,   0xfc00, 0x1000, 0,      2,   CJMP   ), // CPSE Rd, Rr\n\tINST_DECL (eor,    0xfc00, 0x2400, 1,      2,   XOR    ), // EOR Rd, Rr\n\tINST_DECL (mov,    0xfc00, 0x2c00, 1,      2,   MOV    ), // MOV Rd, Rr\n\tINST_DECL (mul,    0xfc00, 0x9c00, 2,      2,   AND    ), // MUL Rd, Rr\n\tINST_DECL (or,     0xfc00, 0x2800, 1,      2,   OR     ), // OR Rd, Rr\n\tINST_DECL (sbc,    0xfc00, 0x0800, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (sub,    0xfc00, 0x1800, 1,      2,   SUB    ), // SUB Rd, Rr\n\tINST_DECL (in,     0xf800, 0xb000, 1,      2,   IO     ), // IN Rd, A\n\t//INST_DECL (lds16,  0xf800, 0xa000, 1,      2,   LOAD   ), // LDS Rd, k\n\tINST_DECL (out,    0xf800, 0xb800, 1,      2,   IO     ), // OUT A, Rr\n\tINST_DECL (andi,   0xf000, 0x7000, 1,      2,   AND    ), // ANDI Rd, K\n\tINST_DECL (cpi,    0xf000, 0x3000, 1,      2,   CMP    ), // CPI Rd, K\n\tINST_DECL (ldi,    0xf000, 0xe000, 1,      2,   LOAD   ), // LDI Rd, K\n\tINST_DECL (ori,    0xf000, 0x6000, 1,      2,   OR     ), // ORI Rd, K\n\tINST_DECL (rcall,  0xf000, 0xd000, 0,      2,   CALL   ), // RCALL k\n\tINST_DECL (rjmp,   0xf000, 0xc000, 2,      2,   JMP    ), // RJMP k\n\tINST_DECL (sbci,   0xf000, 0x4000, 1,      2,   SUB    ), // SBC Rd, Rr\n\tINST_DECL (subi,   0xf000, 0x5000, 1,      2,   SUB    ), // SUBI Rd, Rr\n\tINST_DECL (ldd,    0xd200, 0x8000, 0,      2,   LOAD   ), // LD Rd, Y/Z+q\n\tINST_DECL (std,    0xd200, 0x8200, 0,      2,   STORE  ), // ST Y/Z+q, Rr\n\n\tINST_LAST\n};\n\nstatic OPCODE_DESC* avr_op_analyze(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, CPU_MODEL *cpu) {\n\tOPCODE_DESC *opcode_desc;\n\tif (len < 2) {\n\t\treturn NULL;\n\t}\n\tut16 ins = (buf[1] << 8) | buf[0];\n\tint fail;\n\tchar *t;\n\n\t// initialize op struct\n\tmemset (op, 0, sizeof (RAnalOp));\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->jump = UT64_MAX;\n\tr_strbuf_init (&op->esil);\n\n\t// process opcode\n\tfor (opcode_desc = opcodes; opcode_desc->handler; opcode_desc++) {\n\t\tif ((ins & opcode_desc->mask) == opcode_desc->selector) {\n\t\t\tfail = 0;\n\n\t\t\t// copy default cycles/size values\n\t\t\top->cycles = opcode_desc->cycles;\n\t\t\top->size = opcode_desc->size;\n\t\t\top->type = opcode_desc->type;\n\t\t\top->jump = UT64_MAX;\n\t\t\top->fail = UT64_MAX;\n\t\t\t// op->fail = addr + op->size;\n\t\t\top->addr = addr;\n\n\t\t\t// start void esil expression\n\t\t\tr_strbuf_setf (&op->esil, \"\");\n\n\t\t\t// handle opcode\n\t\t\topcode_desc->handler (anal, op, buf, len, &fail, cpu);\n\t\t\tif (fail) {\n\t\t\t\tgoto INVALID_OP;\n\t\t\t}\n\t\t\tif (op->cycles <= 0) {\n\t\t\t\t// eprintf (\"opcode %s @%\"PFMT64x\" returned 0 cycles.\\n\", opcode_desc->name, op->addr);\n\t\t\t\topcode_desc->cycles = 2;\n\t\t\t}\n\t\t\top->nopcode = (op->type == R_ANAL_OP_TYPE_UNK);\n\n\t\t\t// remove trailing coma (COMETE LA COMA)\n\t\t\tt = r_strbuf_get (&op->esil);\n\t\t\tif (t && strlen (t) > 1) {\n\t\t\t\tt += strlen (t) - 1;\n\t\t\t\tif (*t == ',') {\n\t\t\t\t\t*t = '\\0';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn opcode_desc;\n\t\t}\n\t}\n\n\t// ignore reserved opcodes (if they have not been caught by the previous loop)\n\tif ((ins & 0xff00) == 0xff00 && (ins & 0xf) > 7) {\n\t\tgoto INVALID_OP;\n\t}\n\nINVALID_OP:\n\t// An unknown or invalid option has appeared.\n\t//  -- Throw pokeball!\n\top->family = R_ANAL_OP_FAMILY_UNKNOWN;\n\top->type = R_ANAL_OP_TYPE_UNK;\n\top->addr = addr;\n\top->fail = UT64_MAX;\n\top->jump = UT64_MAX;\n\top->ptr = UT64_MAX;\n\top->val = UT64_MAX;\n\top->nopcode = 1;\n\top->cycles = 1;\n\top->size = 2;\n\t// launch esil trap (for communicating upper layers about this weird\n\t// and stinky situation\n\tr_strbuf_set (&op->esil, \"1,$\");\n\n\treturn NULL;\n}\n\nstatic int avr_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len) {\n\tCPU_MODEL *cpu;\n\tut64 offset;\n\n\t// init op\n\tif (!op) {\n\t\treturn 2;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (anal->cpu);\n\n\t// set memory layout registers\n\tif (anal->esil) {\n\t\toffset = 0;\n\t\tr_anal_esil_reg_write (anal->esil, \"_prog\", offset);\n\n\t\toffset += (1 << cpu->pc);\n\t\tr_anal_esil_reg_write (anal->esil, \"_io\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_start\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_sram\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"sram_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_eeprom\", offset);\n\n\t\toffset += const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"eeprom_size\"));\n\t\tr_anal_esil_reg_write (anal->esil, \"_page\", offset);\n\t}\n\t// process opcode\n\tavr_op_analyze (anal, op, addr, buf, len, cpu);\n\n\treturn op->size;\n}\n\nstatic int avr_custom_des (RAnalEsil *esil) {\n\tut64 key, encrypt, text,des_round;\n\tut32 key_lo, key_hi, buf_lo, buf_hi;\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\tif (!__esil_pop_argument (esil, &des_round)) {\n\t\treturn false;\n\t}\n\tr_anal_esil_reg_read (esil, \"hf\", &encrypt, NULL);\n\tr_anal_esil_reg_read (esil, \"deskey\", &key, NULL);\n\tr_anal_esil_reg_read (esil, \"text\", &text, NULL);\n\n\tkey_lo = key & UT32_MAX;\n\tkey_hi = key >> 32;\n\tbuf_lo = text & UT32_MAX;\n\tbuf_hi = text >> 32;\n\n\tif (des_round != desctx.round) {\n\t\tdesctx.round = des_round;\n\t}\n\n\tif (!desctx.round) {\n\t\tint i;\n\t\t//generating all round keys\n\t\tr_des_permute_key (&key_lo, &key_hi);\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tr_des_round_key (i, &desctx.round_key_lo[i], &desctx.round_key_hi[i], &key_lo, &key_hi);\n\t\t}\n\t\tr_des_permute_block0 (&buf_lo, &buf_hi);\n\t}\n\n\tif (encrypt) {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[desctx.round], &desctx.round_key_hi[desctx.round]);\n\t} else {\n\t\tr_des_round (&buf_lo, &buf_hi, &desctx.round_key_lo[15 - desctx.round], &desctx.round_key_hi[15 - desctx.round]);\n\t}\n\n\tif (desctx.round == 15) {\n\t\tr_des_permute_block1 (&buf_hi, &buf_lo);\n\t\tdesctx.round = 0;\n\t} else {\n\t\tdesctx.round++;\n\t}\n\n\tr_anal_esil_reg_write (esil, \"text\", text);\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_ERASE\nstatic int avr_custom_spm_page_erase(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut8 c;\n\tut64 addr, page_size_bits, i;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align base address to page_size_bits\n\taddr &= ~(MASK (page_size_bits));\n\n\t// perform erase\n\t//eprintf (\"SPM_PAGE_ERASE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tc = 0xff;\n\tfor (i = 0; i < (1ULL << page_size_bits); i++) {\n\t\tr_anal_esil_mem_write (\n\t\t\tesil, (addr + i) & CPU_PC_MASK (cpu), &c, 1);\n\t}\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_FILL\nstatic int avr_custom_spm_page_fill(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tut64 addr, page_size_bits, i;\n\tut8 r0, r1;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address, r0, r1\n\tif (!__esil_pop_argument(esil, &addr)) {\n\t\treturn false;\n\t}\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr0 = i;\n\n\tif (!__esil_pop_argument (esil, &i)) {\n\t\treturn false;\n\t}\n\tr1 = i;\n\n\t// get details about current MCU and fix input address\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\n\t// align and crop base address\n\taddr &= (MASK (page_size_bits) ^ 1);\n\n\t// perform write to temporary page\n\t//eprintf (\"SPM_PAGE_FILL bytes (%02x, %02x) @ 0x%08\" PFMT64x \".\\n\", r1, r0, addr);\n\tr_anal_esil_mem_write (esil, addr++, &r0, 1);\n\tr_anal_esil_mem_write (esil, addr++, &r1, 1);\n\n\treturn true;\n}\n\n// ESIL operation SPM_PAGE_WRITE\nstatic int avr_custom_spm_page_write(RAnalEsil *esil) {\n\tCPU_MODEL *cpu;\n\tchar *t = NULL;\n\tut64 addr, page_size_bits, tmp_page;\n\n\t// sanity check\n\tif (!esil || !esil->anal || !esil->anal->reg) {\n\t\treturn false;\n\t}\n\n\t// get target address\n\tif (!__esil_pop_argument (esil, &addr)) {\n\t\treturn false;\n\t}\n\n\t// get details about current MCU and fix input address and base address\n\t// of the internal temporary page\n\tcpu = get_cpu_model (esil->anal->cpu);\n\tpage_size_bits = const_get_value (const_by_name (cpu, CPU_CONST_PARAM, \"page_size\"));\n\tr_anal_esil_reg_read (esil, \"_page\", &tmp_page, NULL);\n\n\t// align base address to page_size_bits\n\taddr &= (~(MASK (page_size_bits)) & CPU_PC_MASK (cpu));\n\n\t// perform writing\n\t//eprintf (\"SPM_PAGE_WRITE %ld bytes @ 0x%08\" PFMT64x \".\\n\", page_size, addr);\n\tif (!(t = malloc (1 << page_size_bits))) {\n\t\teprintf (\"Cannot alloc a buffer for copying the temporary page.\\n\");\n\t\treturn false;\n\t}\n\tr_anal_esil_mem_read (esil, tmp_page, (ut8 *) t, 1 << page_size_bits);\n\tr_anal_esil_mem_write (esil, addr, (ut8 *) t, 1 << page_size_bits);\n\n\treturn true;\n}\n\nstatic int esil_avr_hook_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tCPU_MODEL *cpu;\n\n\tif (!esil || !esil->anal) {\n\t\treturn 0;\n\t}\n\n\t// select cpu info\n\tcpu = get_cpu_model (esil->anal->cpu);\n\n\t// crop registers and force certain values\n\tif (!strcmp (name, \"pc\")) {\n\t\t*val &= CPU_PC_MASK (cpu);\n\t} else if (!strcmp (name, \"pcl\")) {\n\t\tif (cpu->pc < 8) {\n\t\t\t*val &= MASK (8);\n\t\t}\n\t} else if (!strcmp (name, \"pch\")) {\n\t\t*val = cpu->pc > 8\n\t\t\t? *val & MASK (cpu->pc - 8)\n\t\t\t: 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int esil_avr_init(RAnalEsil *esil) {\n\tif (!esil) {\n\t\treturn false;\n\t}\n\tdesctx.round = 0;\n\tr_anal_esil_set_op (esil, \"des\", avr_custom_des);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_ERASE\", avr_custom_spm_page_erase);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_FILL\", avr_custom_spm_page_fill);\n\tr_anal_esil_set_op (esil, \"SPM_PAGE_WRITE\", avr_custom_spm_page_write);\n\tesil->cb.hook_reg_write = esil_avr_hook_reg_write;\n\n\treturn true;\n}\n\nstatic int esil_avr_fini(RAnalEsil *esil) {\n\treturn true;\n}\n\nstatic int set_reg_profile(RAnal *anal) {\n\tconst char *p =\n\t\t\"=PC\tpcl\\n\"\n\t\t\"=SP\tsp\\n\"\n// explained in http://www.nongnu.org/avr-libc/user-manual/FAQ.html\n// and http://www.avrfreaks.net/forum/function-calling-convention-gcc-generated-assembly-file\n\t\t\"=A0\tr25\\n\"\n\t\t\"=A1\tr24\\n\"\n\t\t\"=A2\tr23\\n\"\n\t\t\"=A3\tr22\\n\"\n\t\t\"=R0\tr24\\n\"\n#if 0\nPC: 16- or 22-bit program counter\nSP: 8- or 16-bit stack pointer\nSREG: 8-bit status register\nRAMPX, RAMPY, RAMPZ, RAMPD and EIND:\n#endif\n// 8bit registers x 32\n\t\t\"gpr\tr0\t.8\t0\t0\\n\"\n\t\t\"gpr\tr1\t.8\t1\t0\\n\"\n\t\t\"gpr\tr2\t.8\t2\t0\\n\"\n\t\t\"gpr\tr3\t.8\t3\t0\\n\"\n\t\t\"gpr\tr4\t.8\t4\t0\\n\"\n\t\t\"gpr\tr5\t.8\t5\t0\\n\"\n\t\t\"gpr\tr6\t.8\t6\t0\\n\"\n\t\t\"gpr\tr7\t.8\t7\t0\\n\"\n\t\t\"gpr\ttext\t.64\t0\t0\\n\"\n\t\t\"gpr\tr8\t.8\t8\t0\\n\"\n\t\t\"gpr\tr9\t.8\t9\t0\\n\"\n\t\t\"gpr\tr10\t.8\t10\t0\\n\"\n\t\t\"gpr\tr11\t.8\t11\t0\\n\"\n\t\t\"gpr\tr12\t.8\t12\t0\\n\"\n\t\t\"gpr\tr13\t.8\t13\t0\\n\"\n\t\t\"gpr\tr14\t.8\t14\t0\\n\"\n\t\t\"gpr\tr15\t.8\t15\t0\\n\"\n\t\t\"gpr\tdeskey\t.64\t8\t0\\n\"\n\t\t\"gpr\tr16\t.8\t16\t0\\n\"\n\t\t\"gpr\tr17\t.8\t17\t0\\n\"\n\t\t\"gpr\tr18\t.8\t18\t0\\n\"\n\t\t\"gpr\tr19\t.8\t19\t0\\n\"\n\t\t\"gpr\tr20\t.8\t20\t0\\n\"\n\t\t\"gpr\tr21\t.8\t21\t0\\n\"\n\t\t\"gpr\tr22\t.8\t22\t0\\n\"\n\t\t\"gpr\tr23\t.8\t23\t0\\n\"\n\t\t\"gpr\tr24\t.8\t24\t0\\n\"\n\t\t\"gpr\tr25\t.8\t25\t0\\n\"\n\t\t\"gpr\tr26\t.8\t26\t0\\n\"\n\t\t\"gpr\tr27\t.8\t27\t0\\n\"\n\t\t\"gpr\tr28\t.8\t28\t0\\n\"\n\t\t\"gpr\tr29\t.8\t29\t0\\n\"\n\t\t\"gpr\tr30\t.8\t30\t0\\n\"\n\t\t\"gpr\tr31\t.8\t31\t0\\n\"\n\n// 16 bit overlapped registers for 16 bit math\n\t\t\"gpr\tr17:r16\t.16\t16\t0\\n\"\n\t\t\"gpr\tr19:r18\t.16\t18\t0\\n\"\n\t\t\"gpr\tr21:r20\t.16\t20\t0\\n\"\n\t\t\"gpr\tr23:r22\t.16\t22\t0\\n\"\n\t\t\"gpr\tr25:r24\t.16\t24\t0\\n\"\n\t\t\"gpr\tr27:r26\t.16\t26\t0\\n\"\n\t\t\"gpr\tr29:r28\t.16\t28\t0\\n\"\n\t\t\"gpr\tr31:r30\t.16\t30\t0\\n\"\n\n// 16 bit overlapped registers for memory addressing\n\t\t\"gpr\tx\t.16\t26\t0\\n\"\n\t\t\"gpr\ty\t.16\t28\t0\\n\"\n\t\t\"gpr\tz\t.16\t30\t0\\n\"\n// program counter\n// NOTE: program counter size in AVR depends on the CPU model. It seems that\n// the PC may range from 16 bits to 22 bits.\n\t\t\"gpr\tpc\t.32\t32\t0\\n\"\n\t\t\"gpr\tpcl\t.16\t32\t0\\n\"\n\t\t\"gpr\tpch\t.16\t34\t0\\n\"\n// special purpose registers\n\t\t\"gpr\tsp\t.16\t36\t0\\n\"\n\t\t\"gpr\tspl\t.8\t36\t0\\n\"\n\t\t\"gpr\tsph\t.8\t37\t0\\n\"\n// status bit register (SREG)\n\t\t\"gpr\tsreg\t.8\t38\t0\\n\"\n\t\t\"gpr\tcf\t.1\t38.0\t0\\n\" // Carry. This is a borrow flag on subtracts.\n\t\t\"gpr\tzf\t.1\t38.1\t0\\n\" // Zero. Set to 1 when an arithmetic result is zero.\n\t\t\"gpr\tnf\t.1\t38.2\t0\\n\" // Negative. Set to a copy of the most significant bit of an arithmetic result.\n\t\t\"gpr\tvf\t.1\t38.3\t0\\n\" // Overflow flag. Set in case of two's complement overflow.\n\t\t\"gpr\tsf\t.1\t38.4\t0\\n\" // Sign flag. Unique to AVR, this is always (N ^ V) (xor), and shows the true sign of a comparison.\n\t\t\"gpr\thf\t.1\t38.5\t0\\n\" // Half carry. This is an internal carry from additions and is used to support BCD arithmetic.\n\t\t\"gpr\ttf\t.1\t38.6\t0\\n\" // Bit copy. Special bit load and bit store instructions use this bit.\n\t\t\"gpr\tif\t.1\t38.7\t0\\n\" // Interrupt flag. Set when interrupts are enabled.\n// 8bit segment registers to be added to X, Y, Z to get 24bit offsets\n\t\t\"gpr\trampx\t.8\t39\t0\\n\"\n\t\t\"gpr\trampy\t.8\t40\t0\\n\"\n\t\t\"gpr\trampz\t.8\t41\t0\\n\"\n\t\t\"gpr\trampd\t.8\t42\t0\\n\"\n\t\t\"gpr\teind\t.8\t43\t0\\n\"\n// memory mapping emulator registers\n//      _prog\n//\t\tthe program flash. It has its own address space.\n//\t_ram\n//\t_io\n//\t\tstart of the data addres space. It is the same address of IO,\n//\t\tbecause IO is the first memory space addressable in the AVR.\n//\t_sram\n//\t\tstart of the SRAM (this offset depends on IO size, and it is\n//\t\tinside the _ram address space)\n//      _eeprom\n//              this is another address space, outside ram and flash\n//      _page\n//              this is the temporary page used by the SPM instruction. This\n//              memory is not directly addressable and it is used internally by\n//              the CPU when autoflashing.\n\t\t\"gpr\t_prog\t.32\t44\t0\\n\"\n\t\t\"gpr    _page   .32     48\t0\\n\"\n\t\t\"gpr\t_eeprom\t.32\t52\t0\\n\"\n\t\t\"gpr\t_ram\t.32\t56\t0\\n\"\n\t\t\"gpr\t_io\t.32\t56\t0\\n\"\n\t\t\"gpr\t_sram\t.32\t60\t0\\n\"\n// other important MCU registers\n//\tspmcsr/spmcr\n//\t\tStore Program Memory Control and Status Register (SPMCSR)\n\t\t\"gpr    spmcsr  .8      64      0\\n\"\n\t\t;\n\n\treturn r_reg_set_profile_string (anal->reg, p);\n}\n\nstatic int archinfo(RAnal *anal, int q) {\n\tif (q == R_ANAL_ARCHINFO_ALIGN)\n\t\treturn 2;\n\tif (q == R_ANAL_ARCHINFO_MAX_OP_SIZE)\n\t\treturn 4;\n\tif (q == R_ANAL_ARCHINFO_MIN_OP_SIZE)\n\t\treturn 2;\n\treturn 2; // XXX\n}\n\n\nstatic ut8 *anal_mask_avr(RAnal *anal, int size, const ut8 *data, ut64 at) {\n\tRAnalOp *op = NULL;\n\tut8 *ret = NULL;\n\tint idx;\n\n\tif (!(op = r_anal_op_new ())) {\n\t\treturn NULL;\n\t}\n\n\tif (!(ret = malloc (size))) {\n\t\tr_anal_op_free (op);\n\t\treturn NULL;\n\t}\n\n\tmemset (ret, 0xff, size);\n\n\tCPU_MODEL *cpu = get_cpu_model (anal->cpu);\n\n\tfor (idx = 0; idx + 1 < size; idx += op->size) {\n\t\tOPCODE_DESC* opcode_desc = avr_op_analyze (anal, op, at + idx, data + idx, size - idx, cpu);\n\n\t\tif (op->size < 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!opcode_desc) { // invalid instruction\n\t\t\tcontinue;\n\t\t}\n\n\t\t// the additional data for \"long\" opcodes (4 bytes) is usually something we want to ignore for matching\n\t\t// (things like memory offsets or jump addresses)\n\t\tif (op->size == 4) {\n\t\t\tret[idx + 2] = 0;\n\t\t\tret[idx + 3] = 0;\n\t\t}\n\n\t\tif (op->ptr != UT64_MAX || op->jump != UT64_MAX) {\n\t\t\tret[idx] = opcode_desc->mask;\n\t\t\tret[idx + 1] = opcode_desc->mask >> 8;\n\t\t}\n\t}\n\n\tr_anal_op_free (op);\n\n\treturn ret;\n}\n\nRAnalPlugin r_anal_plugin_avr = {\n\t.name = \"avr\",\n\t.desc = \"AVR code analysis plugin\",\n\t.license = \"LGPL3\",\n\t.arch = \"avr\",\n\t.esil = true,\n\t.archinfo = archinfo,\n\t.bits = 8 | 16, // 24 big regs conflicts\n\t.op = &avr_op,\n\t.set_reg_profile = &set_reg_profile,\n\t.esil_init = esil_avr_init,\n\t.esil_fini = esil_avr_fini,\n\t.anal_mask = anal_mask_avr,\n};\n\n#ifndef CORELIB\nRLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_avr,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/anal/p/anal_avr.c"], "buggy_code_start_loc": [914], "buggy_code_end_loc": [914], "fixing_code_start_loc": [915], "fixing_code_end_loc": [918], "type": "CWE-125", "message": "The _inst__lds() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file.", "other": {"cve": {"id": "CVE-2018-11375", "sourceIdentifier": "cve@mitre.org", "published": "2018-05-22T19:29:00.207", "lastModified": "2018-06-27T17:52:38.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The _inst__lds() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted binary file."}, {"lang": "es", "value": "La funci\u00f3n _inst__lds() en radare2 2.5.0 permite que atacantes remotos provoquen una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites basada en memoria din\u00e1mica o heap y cierre inesperado de la aplicaci\u00f3n) mediante un archivo binario manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:2.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "81E40EFA-5307-45F3-9722-CB499D21141F"}]}]}], "references": [{"url": "https://github.com/radare/radare2/commit/041e53cab7ca33481ae45ecd65ad596976d78e68", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/radare/radare2/issues/9928", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radare/radare2/commit/041e53cab7ca33481ae45ecd65ad596976d78e68"}}