{"buggy_code": ["/*\n * cros_ec_dev - expose the Chrome OS Embedded Controller to user-space\n *\n * Copyright (C) 2014 Google, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"cros_ec_dev.h\"\n\n/* Device variables */\n#define CROS_MAX_DEV 128\nstatic int ec_major;\n\nstatic const struct attribute_group *cros_ec_groups[] = {\n\t&cros_ec_attr_group,\n\t&cros_ec_lightbar_attr_group,\n\t&cros_ec_vbc_attr_group,\n\tNULL,\n};\n\nstatic struct class cros_class = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"chromeos\",\n\t.dev_groups     = cros_ec_groups,\n};\n\n/* Basic communication */\nstatic int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)\n{\n\tstruct ec_response_get_version *resp;\n\tstatic const char * const current_image_name[] = {\n\t\t\"unknown\", \"read-only\", \"read-write\", \"invalid\",\n\t};\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\n\tmsg->insize = sizeof(*resp);\n\tmsg->outsize = 0;\n\n\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (msg->result != EC_RES_SUCCESS) {\n\t\tsnprintf(str, maxlen,\n\t\t\t \"%s\\nUnknown EC version: EC returned %d\\n\",\n\t\t\t CROS_EC_DEV_VERSION, msg->result);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tresp = (struct ec_response_get_version *)msg->data;\n\tif (resp->current_image >= ARRAY_SIZE(current_image_name))\n\t\tresp->current_image = 3; /* invalid */\n\n\tsnprintf(str, maxlen, \"%s\\n%s\\n%s\\n%s\\n\", CROS_EC_DEV_VERSION,\n\t\t resp->version_string_ro, resp->version_string_rw,\n\t\t current_image_name[resp->current_image]);\n\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\n/* Device file ops */\nstatic int ec_device_open(struct inode *inode, struct file *filp)\n{\n\tstruct cros_ec_dev *ec = container_of(inode->i_cdev,\n\t\t\t\t\t      struct cros_ec_dev, cdev);\n\tfilp->private_data = ec;\n\tnonseekable_open(inode, filp);\n\treturn 0;\n}\n\nstatic int ec_device_release(struct inode *inode, struct file *filp)\n{\n\treturn 0;\n}\n\nstatic ssize_t ec_device_read(struct file *filp, char __user *buffer,\n\t\t\t      size_t length, loff_t *offset)\n{\n\tstruct cros_ec_dev *ec = filp->private_data;\n\tchar msg[sizeof(struct ec_response_get_version) +\n\t\t sizeof(CROS_EC_DEV_VERSION)];\n\tsize_t count;\n\tint ret;\n\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tret = ec_get_version(ec, msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\n\tcount = min(length, strlen(msg));\n\n\tif (copy_to_user(buffer, msg, count))\n\t\treturn -EFAULT;\n\n\t*offset = count;\n\treturn count;\n}\n\n/* Ioctls */\nstatic long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\t/* Only copy data to userland if data was received. */\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}\n\nstatic long ec_device_ioctl_readmem(struct cros_ec_dev *ec, void __user *arg)\n{\n\tstruct cros_ec_device *ec_dev = ec->ec_dev;\n\tstruct cros_ec_readmem s_mem = { };\n\tlong num;\n\n\t/* Not every platform supports direct reads */\n\tif (!ec_dev->cmd_readmem)\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&s_mem, arg, sizeof(s_mem)))\n\t\treturn -EFAULT;\n\n\tnum = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,\n\t\t\t\t  s_mem.buffer);\n\tif (num <= 0)\n\t\treturn num;\n\n\tif (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long ec_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct cros_ec_dev *ec = filp->private_data;\n\n\tif (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase CROS_EC_DEV_IOCXCMD:\n\t\treturn ec_device_ioctl_xcmd(ec, (void __user *)arg);\n\tcase CROS_EC_DEV_IOCRDMEM:\n\t\treturn ec_device_ioctl_readmem(ec, (void __user *)arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n/* Module initialization */\nstatic const struct file_operations fops = {\n\t.open = ec_device_open,\n\t.release = ec_device_release,\n\t.read = ec_device_read,\n\t.unlocked_ioctl = ec_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = ec_device_ioctl,\n#endif\n};\n\nstatic void __remove(struct device *dev)\n{\n\tstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\n\t\t\t\t\t      class_dev);\n\tkfree(ec);\n}\n\nstatic int ec_device_probe(struct platform_device *pdev)\n{\n\tint retval = -ENOMEM;\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_platform *ec_platform = dev_get_platdata(dev);\n\tdev_t devno = MKDEV(ec_major, pdev->id);\n\tstruct cros_ec_dev *ec = kzalloc(sizeof(*ec), GFP_KERNEL);\n\n\tif (!ec)\n\t\treturn retval;\n\n\tdev_set_drvdata(dev, ec);\n\tec->ec_dev = dev_get_drvdata(dev->parent);\n\tec->dev = dev;\n\tec->cmd_offset = ec_platform->cmd_offset;\n\tdevice_initialize(&ec->class_dev);\n\tcdev_init(&ec->cdev, &fops);\n\n\t/*\n\t * Add the character device\n\t * Link cdev to the class device to be sure device is not used\n\t * before unbinding it.\n\t */\n\tec->cdev.kobj.parent = &ec->class_dev.kobj;\n\tretval = cdev_add(&ec->cdev, devno, 1);\n\tif (retval) {\n\t\tdev_err(dev, \": failed to add character device\\n\");\n\t\tgoto cdev_add_failed;\n\t}\n\n\t/*\n\t * Add the class device\n\t * Link to the character device for creating the /dev entry\n\t * in devtmpfs.\n\t */\n\tec->class_dev.devt = ec->cdev.dev;\n\tec->class_dev.class = &cros_class;\n\tec->class_dev.parent = dev;\n\tec->class_dev.release = __remove;\n\n\tretval = dev_set_name(&ec->class_dev, \"%s\", ec_platform->ec_name);\n\tif (retval) {\n\t\tdev_err(dev, \"dev_set_name failed => %d\\n\", retval);\n\t\tgoto set_named_failed;\n\t}\n\n\tretval = device_add(&ec->class_dev);\n\tif (retval) {\n\t\tdev_err(dev, \"device_register failed => %d\\n\", retval);\n\t\tgoto dev_reg_failed;\n\t}\n\n\treturn 0;\n\ndev_reg_failed:\nset_named_failed:\n\tdev_set_drvdata(dev, NULL);\n\tcdev_del(&ec->cdev);\ncdev_add_failed:\n\tkfree(ec);\n\treturn retval;\n}\n\nstatic int ec_device_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(&pdev->dev);\n\tcdev_del(&ec->cdev);\n\tdevice_unregister(&ec->class_dev);\n\treturn 0;\n}\n\nstatic const struct platform_device_id cros_ec_id[] = {\n\t{ \"cros-ec-ctl\", 0 },\n\t{ /* sentinel */ },\n};\nMODULE_DEVICE_TABLE(platform, cros_ec_id);\n\nstatic struct platform_driver cros_ec_dev_driver = {\n\t.driver = {\n\t\t.name = \"cros-ec-ctl\",\n\t},\n\t.probe = ec_device_probe,\n\t.remove = ec_device_remove,\n};\n\nstatic int __init cros_ec_dev_init(void)\n{\n\tint ret;\n\tdev_t dev = 0;\n\n\tret  = class_register(&cros_class);\n\tif (ret) {\n\t\tpr_err(CROS_EC_DEV_NAME \": failed to register device class\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Get a range of minor numbers (starting with 0) to work with */\n\tret = alloc_chrdev_region(&dev, 0, CROS_MAX_DEV, CROS_EC_DEV_NAME);\n\tif (ret < 0) {\n\t\tpr_err(CROS_EC_DEV_NAME \": alloc_chrdev_region() failed\\n\");\n\t\tgoto failed_chrdevreg;\n\t}\n\tec_major = MAJOR(dev);\n\n\t/* Register the driver */\n\tret = platform_driver_register(&cros_ec_dev_driver);\n\tif (ret < 0) {\n\t\tpr_warn(CROS_EC_DEV_NAME \": can't register driver: %d\\n\", ret);\n\t\tgoto failed_devreg;\n\t}\n\treturn 0;\n\nfailed_devreg:\n\tunregister_chrdev_region(MKDEV(ec_major, 0), CROS_MAX_DEV);\nfailed_chrdevreg:\n\tclass_unregister(&cros_class);\n\treturn ret;\n}\n\nstatic void __exit cros_ec_dev_exit(void)\n{\n\tplatform_driver_unregister(&cros_ec_dev_driver);\n\tunregister_chrdev(ec_major, CROS_EC_DEV_NAME);\n\tclass_unregister(&cros_class);\n}\n\nmodule_init(cros_ec_dev_init);\nmodule_exit(cros_ec_dev_exit);\n\nMODULE_AUTHOR(\"Bill Richardson <wfrichar@chromium.org>\");\nMODULE_DESCRIPTION(\"Userspace interface to the Chrome OS Embedded Controller\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * cros_ec_dev - expose the Chrome OS Embedded Controller to user-space\n *\n * Copyright (C) 2014 Google, Inc.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"cros_ec_dev.h\"\n\n/* Device variables */\n#define CROS_MAX_DEV 128\nstatic int ec_major;\n\nstatic const struct attribute_group *cros_ec_groups[] = {\n\t&cros_ec_attr_group,\n\t&cros_ec_lightbar_attr_group,\n\t&cros_ec_vbc_attr_group,\n\tNULL,\n};\n\nstatic struct class cros_class = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"chromeos\",\n\t.dev_groups     = cros_ec_groups,\n};\n\n/* Basic communication */\nstatic int ec_get_version(struct cros_ec_dev *ec, char *str, int maxlen)\n{\n\tstruct ec_response_get_version *resp;\n\tstatic const char * const current_image_name[] = {\n\t\t\"unknown\", \"read-only\", \"read-write\", \"invalid\",\n\t};\n\tstruct cros_ec_command *msg;\n\tint ret;\n\n\tmsg = kmalloc(sizeof(*msg) + sizeof(*resp), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->version = 0;\n\tmsg->command = EC_CMD_GET_VERSION + ec->cmd_offset;\n\tmsg->insize = sizeof(*resp);\n\tmsg->outsize = 0;\n\n\tret = cros_ec_cmd_xfer(ec->ec_dev, msg);\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (msg->result != EC_RES_SUCCESS) {\n\t\tsnprintf(str, maxlen,\n\t\t\t \"%s\\nUnknown EC version: EC returned %d\\n\",\n\t\t\t CROS_EC_DEV_VERSION, msg->result);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tresp = (struct ec_response_get_version *)msg->data;\n\tif (resp->current_image >= ARRAY_SIZE(current_image_name))\n\t\tresp->current_image = 3; /* invalid */\n\n\tsnprintf(str, maxlen, \"%s\\n%s\\n%s\\n%s\\n\", CROS_EC_DEV_VERSION,\n\t\t resp->version_string_ro, resp->version_string_rw,\n\t\t current_image_name[resp->current_image]);\n\n\tret = 0;\nexit:\n\tkfree(msg);\n\treturn ret;\n}\n\n/* Device file ops */\nstatic int ec_device_open(struct inode *inode, struct file *filp)\n{\n\tstruct cros_ec_dev *ec = container_of(inode->i_cdev,\n\t\t\t\t\t      struct cros_ec_dev, cdev);\n\tfilp->private_data = ec;\n\tnonseekable_open(inode, filp);\n\treturn 0;\n}\n\nstatic int ec_device_release(struct inode *inode, struct file *filp)\n{\n\treturn 0;\n}\n\nstatic ssize_t ec_device_read(struct file *filp, char __user *buffer,\n\t\t\t      size_t length, loff_t *offset)\n{\n\tstruct cros_ec_dev *ec = filp->private_data;\n\tchar msg[sizeof(struct ec_response_get_version) +\n\t\t sizeof(CROS_EC_DEV_VERSION)];\n\tsize_t count;\n\tint ret;\n\n\tif (*offset != 0)\n\t\treturn 0;\n\n\tret = ec_get_version(ec, msg, sizeof(msg));\n\tif (ret)\n\t\treturn ret;\n\n\tcount = min(length, strlen(msg));\n\n\tif (copy_to_user(buffer, msg, count))\n\t\treturn -EFAULT;\n\n\t*offset = count;\n\treturn count;\n}\n\n/* Ioctls */\nstatic long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg)\n{\n\tlong ret;\n\tstruct cros_ec_command u_cmd;\n\tstruct cros_ec_command *s_cmd;\n\n\tif (copy_from_user(&u_cmd, arg, sizeof(u_cmd)))\n\t\treturn -EFAULT;\n\n\tif ((u_cmd.outsize > EC_MAX_MSG_BYTES) ||\n\t    (u_cmd.insize > EC_MAX_MSG_BYTES))\n\t\treturn -EINVAL;\n\n\ts_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize),\n\t\t\tGFP_KERNEL);\n\tif (!s_cmd)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif (u_cmd.outsize != s_cmd->outsize ||\n\t    u_cmd.insize != s_cmd->insize) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\ts_cmd->command += ec->cmd_offset;\n\tret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd);\n\t/* Only copy data to userland if data was received. */\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + s_cmd->insize))\n\t\tret = -EFAULT;\nexit:\n\tkfree(s_cmd);\n\treturn ret;\n}\n\nstatic long ec_device_ioctl_readmem(struct cros_ec_dev *ec, void __user *arg)\n{\n\tstruct cros_ec_device *ec_dev = ec->ec_dev;\n\tstruct cros_ec_readmem s_mem = { };\n\tlong num;\n\n\t/* Not every platform supports direct reads */\n\tif (!ec_dev->cmd_readmem)\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&s_mem, arg, sizeof(s_mem)))\n\t\treturn -EFAULT;\n\n\tnum = ec_dev->cmd_readmem(ec_dev, s_mem.offset, s_mem.bytes,\n\t\t\t\t  s_mem.buffer);\n\tif (num <= 0)\n\t\treturn num;\n\n\tif (copy_to_user((void __user *)arg, &s_mem, sizeof(s_mem)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic long ec_device_ioctl(struct file *filp, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct cros_ec_dev *ec = filp->private_data;\n\n\tif (_IOC_TYPE(cmd) != CROS_EC_DEV_IOC)\n\t\treturn -ENOTTY;\n\n\tswitch (cmd) {\n\tcase CROS_EC_DEV_IOCXCMD:\n\t\treturn ec_device_ioctl_xcmd(ec, (void __user *)arg);\n\tcase CROS_EC_DEV_IOCRDMEM:\n\t\treturn ec_device_ioctl_readmem(ec, (void __user *)arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n/* Module initialization */\nstatic const struct file_operations fops = {\n\t.open = ec_device_open,\n\t.release = ec_device_release,\n\t.read = ec_device_read,\n\t.unlocked_ioctl = ec_device_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = ec_device_ioctl,\n#endif\n};\n\nstatic void __remove(struct device *dev)\n{\n\tstruct cros_ec_dev *ec = container_of(dev, struct cros_ec_dev,\n\t\t\t\t\t      class_dev);\n\tkfree(ec);\n}\n\nstatic int ec_device_probe(struct platform_device *pdev)\n{\n\tint retval = -ENOMEM;\n\tstruct device *dev = &pdev->dev;\n\tstruct cros_ec_platform *ec_platform = dev_get_platdata(dev);\n\tdev_t devno = MKDEV(ec_major, pdev->id);\n\tstruct cros_ec_dev *ec = kzalloc(sizeof(*ec), GFP_KERNEL);\n\n\tif (!ec)\n\t\treturn retval;\n\n\tdev_set_drvdata(dev, ec);\n\tec->ec_dev = dev_get_drvdata(dev->parent);\n\tec->dev = dev;\n\tec->cmd_offset = ec_platform->cmd_offset;\n\tdevice_initialize(&ec->class_dev);\n\tcdev_init(&ec->cdev, &fops);\n\n\t/*\n\t * Add the character device\n\t * Link cdev to the class device to be sure device is not used\n\t * before unbinding it.\n\t */\n\tec->cdev.kobj.parent = &ec->class_dev.kobj;\n\tretval = cdev_add(&ec->cdev, devno, 1);\n\tif (retval) {\n\t\tdev_err(dev, \": failed to add character device\\n\");\n\t\tgoto cdev_add_failed;\n\t}\n\n\t/*\n\t * Add the class device\n\t * Link to the character device for creating the /dev entry\n\t * in devtmpfs.\n\t */\n\tec->class_dev.devt = ec->cdev.dev;\n\tec->class_dev.class = &cros_class;\n\tec->class_dev.parent = dev;\n\tec->class_dev.release = __remove;\n\n\tretval = dev_set_name(&ec->class_dev, \"%s\", ec_platform->ec_name);\n\tif (retval) {\n\t\tdev_err(dev, \"dev_set_name failed => %d\\n\", retval);\n\t\tgoto set_named_failed;\n\t}\n\n\tretval = device_add(&ec->class_dev);\n\tif (retval) {\n\t\tdev_err(dev, \"device_register failed => %d\\n\", retval);\n\t\tgoto dev_reg_failed;\n\t}\n\n\treturn 0;\n\ndev_reg_failed:\nset_named_failed:\n\tdev_set_drvdata(dev, NULL);\n\tcdev_del(&ec->cdev);\ncdev_add_failed:\n\tkfree(ec);\n\treturn retval;\n}\n\nstatic int ec_device_remove(struct platform_device *pdev)\n{\n\tstruct cros_ec_dev *ec = dev_get_drvdata(&pdev->dev);\n\tcdev_del(&ec->cdev);\n\tdevice_unregister(&ec->class_dev);\n\treturn 0;\n}\n\nstatic const struct platform_device_id cros_ec_id[] = {\n\t{ \"cros-ec-ctl\", 0 },\n\t{ /* sentinel */ },\n};\nMODULE_DEVICE_TABLE(platform, cros_ec_id);\n\nstatic struct platform_driver cros_ec_dev_driver = {\n\t.driver = {\n\t\t.name = \"cros-ec-ctl\",\n\t},\n\t.probe = ec_device_probe,\n\t.remove = ec_device_remove,\n};\n\nstatic int __init cros_ec_dev_init(void)\n{\n\tint ret;\n\tdev_t dev = 0;\n\n\tret  = class_register(&cros_class);\n\tif (ret) {\n\t\tpr_err(CROS_EC_DEV_NAME \": failed to register device class\\n\");\n\t\treturn ret;\n\t}\n\n\t/* Get a range of minor numbers (starting with 0) to work with */\n\tret = alloc_chrdev_region(&dev, 0, CROS_MAX_DEV, CROS_EC_DEV_NAME);\n\tif (ret < 0) {\n\t\tpr_err(CROS_EC_DEV_NAME \": alloc_chrdev_region() failed\\n\");\n\t\tgoto failed_chrdevreg;\n\t}\n\tec_major = MAJOR(dev);\n\n\t/* Register the driver */\n\tret = platform_driver_register(&cros_ec_dev_driver);\n\tif (ret < 0) {\n\t\tpr_warn(CROS_EC_DEV_NAME \": can't register driver: %d\\n\", ret);\n\t\tgoto failed_devreg;\n\t}\n\treturn 0;\n\nfailed_devreg:\n\tunregister_chrdev_region(MKDEV(ec_major, 0), CROS_MAX_DEV);\nfailed_chrdevreg:\n\tclass_unregister(&cros_class);\n\treturn ret;\n}\n\nstatic void __exit cros_ec_dev_exit(void)\n{\n\tplatform_driver_unregister(&cros_ec_dev_driver);\n\tunregister_chrdev(ec_major, CROS_EC_DEV_NAME);\n\tclass_unregister(&cros_class);\n}\n\nmodule_init(cros_ec_dev_init);\nmodule_exit(cros_ec_dev_exit);\n\nMODULE_AUTHOR(\"Bill Richardson <wfrichar@chromium.org>\");\nMODULE_DESCRIPTION(\"Userspace interface to the Chrome OS Embedded Controller\");\nMODULE_VERSION(\"1.0\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/platform/chrome/cros_ec_dev.c"], "buggy_code_start_loc": [153], "buggy_code_end_loc": [161], "fixing_code_start_loc": [154], "fixing_code_end_loc": [167], "type": "CWE-362", "message": "Race condition in the ec_device_ioctl_xcmd function in drivers/platform/chrome/cros_ec_dev.c in the Linux kernel before 4.7 allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a \"double fetch\" vulnerability.", "other": {"cve": {"id": "CVE-2016-6156", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-06T20:59:08.050", "lastModified": "2016-11-28T20:30:47.683", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Race condition in the ec_device_ioctl_xcmd function in drivers/platform/chrome/cros_ec_dev.c in the Linux kernel before 4.7 allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a \"double fetch\" vulnerability."}, {"lang": "es", "value": "Condici\u00f3n de carrera en la funci\u00f3n ec_device_ioctl_xcmd en drivers/platform/chrome/cros_ec_dev.c en el kernel de Linux en versiones anteriores a 4.7 permite a usuarios locales provocar una denegaci\u00f3n de servicio (acceso al array fuera de rango) cambiando un cierto valor de tama\u00f1o, tambi\u00e9n conocido como una vulnerabilidad de \"doble recuperaci\u00f3n\"."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.4, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.6.6", "matchCriteriaId": "52847A0D-725D-40BB-B852-8937D886C0E1"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=096cdc6f52225835ff503f987a0d68ef770bb78e", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://seclists.org/bugtraq/2016/Jul/20", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securityfocus.com/bid/91553", "source": "cve@mitre.org"}, {"url": "https://bugzilla.kernel.org/show_bug.cgi?id=120131", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1353490", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/096cdc6f52225835ff503f987a0d68ef770bb78e", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/096cdc6f52225835ff503f987a0d68ef770bb78e"}}