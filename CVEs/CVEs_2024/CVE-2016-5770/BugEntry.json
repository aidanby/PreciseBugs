{"buggy_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Author: Marcus Boerger <helly@php.net>                               |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\"\n#include \"zend_compile.h\"\n#include \"zend_exceptions.h\"\n#include \"zend_interfaces.h\"\n\n#include \"php_spl.h\"\n#include \"spl_functions.h\"\n#include \"spl_engine.h\"\n#include \"spl_iterators.h\"\n#include \"spl_directory.h\"\n#include \"spl_exceptions.h\"\n\n#include \"php.h\"\n#include \"fopen_wrappers.h\"\n\n#include \"ext/standard/basic_functions.h\"\n#include \"ext/standard/php_filestat.h\"\n\n#define SPL_HAS_FLAG(flags, test_flag) ((flags & test_flag) ? 1 : 0)\n\n/* declare the class handlers */\nstatic zend_object_handlers spl_filesystem_object_handlers;\n/* includes handler to validate object state when retrieving methods */\nstatic zend_object_handlers spl_filesystem_object_check_handlers;\n\n/* decalre the class entry */\nPHPAPI zend_class_entry *spl_ce_SplFileInfo;\nPHPAPI zend_class_entry *spl_ce_DirectoryIterator;\nPHPAPI zend_class_entry *spl_ce_FilesystemIterator;\nPHPAPI zend_class_entry *spl_ce_RecursiveDirectoryIterator;\nPHPAPI zend_class_entry *spl_ce_GlobIterator;\nPHPAPI zend_class_entry *spl_ce_SplFileObject;\nPHPAPI zend_class_entry *spl_ce_SplTempFileObject;\n\nstatic void spl_filesystem_file_free_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (intern->u.file.current_line) {\n\t\tefree(intern->u.file.current_line);\n\t\tintern->u.file.current_line = NULL;\n\t}\n\tif (intern->u.file.current_zval) {\n\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\tintern->u.file.current_zval = NULL;\n\t}\n} /* }}} */\n\nstatic void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n\tif (intern->oth_handler && intern->oth_handler->dtor) {\n\t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n\t}\n\t\n\tzend_object_std_dtor(&intern->std TSRMLS_CC);\n\t\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n\t\t}\n\t\tif (intern->u.dir.sub_path) {\n\t\t\tefree(intern->u.dir.sub_path);\n\t\t}\t\t\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n} /* }}} */\n\n/* {{{ spl_ce_dir_object_new */\n/* creates the object by \n   - allocating memory \n   - initializing the object members\n   - storing the object\n   - setting it's handlers\n\n   called from \n   - clone\n   - new\n */\nstatic zend_object_value spl_filesystem_object_new_ex(zend_class_entry *class_type, spl_filesystem_object **obj TSRMLS_DC)\n{\n\tzend_object_value retval;\n\tspl_filesystem_object *intern;\n\n\tintern = emalloc(sizeof(spl_filesystem_object));\n\tmemset(intern, 0, sizeof(spl_filesystem_object));\n\t/* intern->type = SPL_FS_INFO; done by set 0 */\n\tintern->file_class = spl_ce_SplFileObject;\n\tintern->info_class = spl_ce_SplFileInfo;\n\tif (obj) *obj = intern;\n\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) spl_filesystem_object_free_storage, NULL TSRMLS_CC);\n\tretval.handlers = &spl_filesystem_object_handlers;\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_object_new */\n/* See spl_filesystem_object_new_ex */\nstatic zend_object_value spl_filesystem_object_new(zend_class_entry *class_type TSRMLS_DC)\n{\n\treturn spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ spl_filesystem_object_new_ex */\nstatic zend_object_value spl_filesystem_object_new_check(zend_class_entry *class_type TSRMLS_DC)\n{\n\tzend_object_value ret = spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);\n\tret.handlers = &spl_filesystem_object_check_handlers;\n\treturn ret;\n}\n/* }}} */\n\n\nPHPAPI char* spl_filesystem_object_get_path(spl_filesystem_object *intern, int *len TSRMLS_DC) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tif (intern->type == SPL_FS_DIR) {\n\t\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\t\treturn php_glob_stream_get_path(intern->u.dir.dirp, 0, len);\n\t\t}\n\t}\n#endif\n\tif (len) {\n\t\t*len = intern->_path_len;\n\t}\n\treturn intern->_path;\n} /* }}} */\n\nstatic inline void spl_filesystem_object_get_file_name(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\n\tswitch (intern->type) {\n\t\tcase SPL_FS_INFO:\n\t\tcase SPL_FS_FILE:\n\t\t\tif (!intern->file_name) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Object not initialized\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SPL_FS_DIR:\n\t\t\tif (intern->file_name) {\n\t\t\t\tefree(intern->file_name);\n\t\t\t}\n\t\t\tintern->file_name_len = spprintf(&intern->file_name, 0, \"%s%c%s\",\n\t\t\t                                 spl_filesystem_object_get_path(intern, NULL TSRMLS_CC),\n\t\t\t                                 slash, intern->u.dir.entry.d_name);\n\t\t\tbreak;\n\t}\n} /* }}} */\n\nstatic int spl_filesystem_dir_read(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (!intern->u.dir.dirp || !php_stream_readdir(intern->u.dir.dirp, &intern->u.dir.entry)) {\n\t\tintern->u.dir.entry.d_name[0] = '\\0';\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\n#define IS_SLASH_AT(zs, pos) (IS_SLASH(zs[pos]))\n\nstatic inline int spl_filesystem_is_dot(const char * d_name) /* {{{ */\n{\n\treturn !strcmp(d_name, \".\") || !strcmp(d_name, \"..\");\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_open */\n/* open a directory resource */\nstatic void spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC)\n{\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\n\tintern->type = SPL_FS_DIR;\n\tintern->_path_len = strlen(path);\n\tintern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, FG(default_context));\n\n\tif (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) {\n\t\tintern->_path = estrndup(path, --intern->_path_len);\n\t} else {\n\t\tintern->_path = estrndup(path, intern->_path_len);\n\t}\n\tintern->u.dir.index = 0;\n\n\tif (EG(exception) || intern->u.dir.dirp == NULL) {\n\t\tintern->u.dir.entry.d_name[0] = '\\0';\n\t\tif (!EG(exception)) {\n\t\t\t/* open failed w/out notice (turned to exception due to EH_THROW) */\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0\n\t\t\t\tTSRMLS_CC, \"Failed to open directory \\\"%s\\\"\", path);\n\t\t}\n\t} else {\n\t\tdo {\n\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t}\n}\n/* }}} */\n\nstatic int spl_filesystem_file_open(spl_filesystem_object *intern, int use_include_path, int silent TSRMLS_DC) /* {{{ */\n{\n\tzval  tmp;\n\n\tintern->type = SPL_FS_FILE;\n\n\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_DIR, &tmp TSRMLS_CC);\n\tif (Z_LVAL(tmp)) {\n\t\tintern->u.file.open_mode = NULL;\n\t\tintern->file_name = NULL;\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Cannot use SplFileObject with directories\");\n\t\treturn FAILURE;\n\t}\n\n\tintern->u.file.context = php_stream_context_from_zval(intern->u.file.zcontext, 0);\n\tintern->u.file.stream = php_stream_open_wrapper_ex(intern->file_name, intern->u.file.open_mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, intern->u.file.context);\n\n\tif (!intern->file_name_len || !intern->u.file.stream) {\n\t\tif (!EG(exception)) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot open file '%s'\", intern->file_name_len ? intern->file_name : \"\");\n\t\t}\n\t\tintern->file_name = NULL; /* until here it is not a copy */\n\t\tintern->u.file.open_mode = NULL;\n\t\treturn FAILURE;\n\t}\n\n\tif (intern->u.file.zcontext) {\n\t\tzend_list_addref(Z_RESVAL_P(intern->u.file.zcontext));\n\t}\n\n\tif (intern->file_name_len > 1 && IS_SLASH_AT(intern->file_name, intern->file_name_len-1)) {\n\t\tintern->file_name_len--;\n\t}\n\n\tintern->orig_path = estrndup(intern->u.file.stream->orig_path, strlen(intern->u.file.stream->orig_path));\n\n\tintern->file_name = estrndup(intern->file_name, intern->file_name_len);\n\tintern->u.file.open_mode = estrndup(intern->u.file.open_mode, intern->u.file.open_mode_len);\n\n\t/* avoid reference counting in debug mode, thus do it manually */\n\tZVAL_RESOURCE(&intern->u.file.zresource, php_stream_get_resource_id(intern->u.file.stream));\n\tZ_SET_REFCOUNT(intern->u.file.zresource, 1);\n\t\n\tintern->u.file.delimiter = ',';\n\tintern->u.file.enclosure = '\"';\n\tintern->u.file.escape = '\\\\';\n\n\tzend_hash_find(&intern->std.ce->function_table, \"getcurrentline\", sizeof(\"getcurrentline\"), (void **) &intern->u.file.func_getCurr);\n\n\treturn SUCCESS;\n} /* }}} */\n\n/* {{{ spl_filesystem_object_clone */\n/* Local zend_object_value creation (on stack)\n   Load the 'other' object \n   Create a new empty object (See spl_filesystem_object_new_ex)\n   Open the directory\n   Clone other members (properties)\n */\nstatic zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)\n{\n\tzend_object_value new_obj_val;\n\tzend_object *old_object;\n\tzend_object *new_object;\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tspl_filesystem_object *intern;\n\tspl_filesystem_object *source;\n\tint index, skip_dots;\n\n\told_object = zend_objects_get_address(zobject TSRMLS_CC);\n\tsource = (spl_filesystem_object*)old_object;\n\n\tnew_obj_val = spl_filesystem_object_new_ex(old_object->ce, &intern TSRMLS_CC);\n\tnew_object = &intern->std;\n\n\tintern->flags = source->flags;\n\n\tswitch (source->type) {\n\tcase SPL_FS_INFO:\n\t\tintern->_path_len = source->_path_len;\n\t\tintern->_path = estrndup(source->_path, source->_path_len);\n\t\tintern->file_name_len = source->file_name_len;\n\t\tintern->file_name = estrndup(source->file_name, intern->file_name_len);\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tspl_filesystem_dir_open(intern, source->_path TSRMLS_CC);\n\t\t/* read until we hit the position in which we were before */\n\t\tskip_dots = SPL_HAS_FLAG(source->flags, SPL_FILE_DIR_SKIPDOTS);\n\t\tfor(index = 0; index < source->u.dir.index; ++index) {\n\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\t\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}\n\n\treturn new_obj_val;\n}\n/* }}} */\n\nvoid spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) /* {{{ */\n{\n\tchar *p1, *p2;\n\t\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\n\tintern->file_name = use_copy ? estrndup(path, len) : path;\n\tintern->file_name_len = len;\n\n\twhile(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len > 1) {\n\t\tintern->file_name[intern->file_name_len-1] = 0;\n\t\tintern->file_name_len--;\n\t}\n\n\tp1 = strrchr(intern->file_name, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\tp2 = strrchr(intern->file_name, '\\\\');\n#else\n\tp2 = 0;\n#endif\n\tif (p1 || p2) {\n\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;\n\t} else {\n\t\tintern->_path_len = 0;\n\t}\n\t\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tintern->_path = estrndup(path, intern->_path_len);\n} /* }}} */\n\nstatic spl_filesystem_object * spl_filesystem_object_create_info(spl_filesystem_object *source, char *file_path, int file_path_len, int use_copy, zend_class_entry *ce, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tzval *arg1;\n\tzend_error_handling error_handling;\n\n\tif (!file_path || !file_path_len) {\n#if defined(PHP_WIN32)\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot create SplFileInfo for empty path\");\n\t\tif (file_path && !use_copy) {\n\t\t\tefree(file_path);\n\t\t}\n#else\n\t\tif (file_path && !use_copy) {\n\t\t\tefree(file_path);\n\t\t}\n\t\tfile_path_len = 1;\n\t\tfile_path = \"/\";\n#endif\n\t\treturn NULL;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tce = ce ? ce : source->info_class;\n\n\tzend_update_class_constants(ce TSRMLS_CC);\n\n\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\t\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} /* }}} */\n\nstatic spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_filesystem_object *source, int type, zend_class_entry *ce, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tzend_bool use_include_path = 0;\n\tzval *arg1, *arg2;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tswitch (source->type) {\n\tcase SPL_FS_INFO:\n\tcase SPL_FS_FILE:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (!source->u.dir.entry.d_name[0]) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Could not open file\");\n\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase SPL_FS_INFO:\n\t\tce = ce ? ce : source->info_class;\n\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1);\n\t\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\t\tzval_ptr_dtor(&arg1);\n\t\t} else {\n\t\t\tintern->file_name = estrndup(source->file_name, source->file_name_len);\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tce = ce ? ce : source->file_class;\n\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\t\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tMAKE_STD_ZVAL(arg2);\n\t\t\tZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1);\n\t\t\tZVAL_STRINGL(arg2, \"r\", 1, 1);\n\t\t\tzend_call_method_with_2_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1, arg2);\n\t\t\tzval_ptr_dtor(&arg1);\n\t\t\tzval_ptr_dtor(&arg2);\n\t\t} else {\n\t\t\tintern->file_name = source->file_name;\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t\n\t\t\tintern->u.file.open_mode = \"r\";\n\t\t\tintern->u.file.open_mode_len = 1;\n\t\t\n\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sbr\", \n\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n\t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tintern->u.file.open_mode = NULL;\n\t\t\t\tintern->file_name = NULL;\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_DIR:\t\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Operation not supported\");\n\t\treturn NULL;\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn NULL;\n} /* }}} */\n\nstatic int spl_filesystem_is_invalid_or_dot(const char * d_name) /* {{{ */\n{\n\treturn d_name[0] == '\\0' || spl_filesystem_is_dot(d_name);\n}\n/* }}} */\n\nstatic char *spl_filesystem_object_get_pathname(spl_filesystem_object *intern, int *len TSRMLS_DC) { /* {{{ */\n\tswitch (intern->type) {\n\tcase SPL_FS_INFO:\n\tcase SPL_FS_FILE:\n\t\t*len = intern->file_name_len;\n\t\treturn intern->file_name;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.entry.d_name[0]) {\n\t\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\t\t*len = intern->file_name_len;\n\t\t\treturn intern->file_name;\n\t\t}\n\t}\n\t*len = 0;\n\treturn NULL;\n}\n/* }}} */\n\nstatic HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(obj TSRMLS_CC);\n\tHashTable *rv;\n\tzval *tmp, zrv;\n\tchar *pnstr, *path;\n\tint  pnlen, path_len;\n\tchar stmp[2];\n\n\t*is_temp = 1;\n\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\n\tALLOC_HASHTABLE(rv);\n\tZEND_INIT_SYMTABLE_EX(rv, zend_hash_num_elements(intern->std.properties) + 3, 0);\n\n\tINIT_PZVAL(&zrv);\n\tZ_ARRVAL(zrv) = rv;\n\n\tzend_hash_copy(rv, intern->std.properties, (copy_ctor_func_t) zval_add_ref, (void *) &tmp, sizeof(zval *));\n\n\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, \"pathName\", sizeof(\"pathName\")-1, &pnlen TSRMLS_CC);\n\tpath = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, path, path_len, 1);\n\tefree(pnstr);\n\n\tif (intern->file_name) {\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, \"fileName\", sizeof(\"fileName\")-1, &pnlen TSRMLS_CC);\n\t\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\t\t\n\t\tif (path_len && path_len < intern->file_name_len) {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n\t\t} else {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name, intern->file_name_len, 1);\n\t\t}\n\t\tefree(pnstr);\n\t}\n\tif (intern->type == SPL_FS_DIR) {\n#ifdef HAVE_GLOB\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_DirectoryIterator, \"glob\", sizeof(\"glob\")-1, &pnlen TSRMLS_CC);\n\t\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->_path, intern->_path_len, 1);\n\t\t} else {\n\t\t\tadd_assoc_bool_ex(&zrv, pnstr, pnlen+1, 0);\n\t\t}\n\t\tefree(pnstr);\n#endif\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_RecursiveDirectoryIterator, \"subPathName\", sizeof(\"subPathName\")-1, &pnlen TSRMLS_CC);\n\t\tif (intern->u.dir.sub_path) {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t\t} else {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, \"\", 0, 1);\n\t\t}\n\t\tefree(pnstr);\n\t}\n\tif (intern->type == SPL_FS_FILE) {\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileObject, \"openMode\", sizeof(\"openMode\")-1, &pnlen TSRMLS_CC);\n\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->u.file.open_mode, intern->u.file.open_mode_len, 1);\n\t\tefree(pnstr);\n\t\tstmp[1] = '\\0';\n\t\tstmp[0] = intern->u.file.delimiter;\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileObject, \"delimiter\", sizeof(\"delimiter\")-1, &pnlen TSRMLS_CC);\n\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, stmp, 1, 1);\n\t\tefree(pnstr);\n\t\tstmp[0] = intern->u.file.enclosure;\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileObject, \"enclosure\", sizeof(\"enclosure\")-1, &pnlen TSRMLS_CC);\n\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, stmp, 1, 1);\n\t\tefree(pnstr);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n\nzend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\t\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\t\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}\n/* }}} */\n\n#define DIT_CTOR_FLAGS  0x00000001\n#define DIT_CTOR_GLOB   0x00000002\n\nvoid spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, long ctor_flags) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed, len;\n\tlong flags;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (intern->_path) {\n\t\t/* object is alreay initialized */\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob://\") != path) {\n\t\tspprintf(&path, 0, \"glob://%s\", path);\n\t\tspl_filesystem_dir_open(intern, path TSRMLS_CC);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path TSRMLS_CC);\n\n\t}\n\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator TSRMLS_CC) ? 1 : 0;\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::__construct(string path)\n Cronstructs a new dir iterator from a path. */\nSPL_METHOD(DirectoryIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::rewind()\n   Rewind dir back to the start */\nSPL_METHOD(DirectoryIterator, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index = 0;\n\tif (intern->u.dir.dirp) {\n\t\tphp_stream_rewinddir(intern->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(intern TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto string DirectoryIterator::key()\n   Return current dir entry */\nSPL_METHOD(DirectoryIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.dirp) {\n\t\tRETURN_LONG(intern->u.dir.index);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto DirectoryIterator DirectoryIterator::current()\n   Return this (needed for Iterator interface) */\nSPL_METHOD(DirectoryIterator, current)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_ZVAL(getThis(), 1, 0);\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::next()\n   Move to next entry */\nSPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::seek(int position)\n   Seek to the given position */\nSPL_METHOD(DirectoryIterator, seek)\n{\n\tspl_filesystem_object *intern    = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *retval    = NULL;\n\tlong                   pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &pos) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.index > pos) {\n\t\t/* we first rewind */\n\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.dir.func_rewind, \"rewind\", &retval);\n\t\tif (retval) {\n\t\t\tzval_ptr_dtor(&retval);\n\t\t\tretval = NULL;\n\t\t}\n\t}\n\n\twhile (intern->u.dir.index < pos) {\n\t\tint valid = 0;\n\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.dir.func_valid, \"valid\", &retval);\n\t\tif (retval) {\n\t\t\tvalid = zend_is_true(retval);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t\tretval = NULL;\n\t\t}\n\t\tif (!valid) {\n\t\t\tbreak;\n\t\t}\n\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.dir.func_next, \"next\", &retval);\n\t\tif (retval) {\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ proto string DirectoryIterator::valid()\n   Check whether dir contains more entries */\nSPL_METHOD(DirectoryIterator, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(intern->u.dir.entry.d_name[0] != '\\0');\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getPath()\n   Return the path */\nSPL_METHOD(SplFileInfo, getPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *path;\n\tint path_len;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n  \tpath = spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\tRETURN_STRINGL(path, path_len, 1);\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getFilename()\n   Return filename only */\nSPL_METHOD(SplFileInfo, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint path_len;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\t\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tRETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n\t} else {\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string DirectoryIterator::getFilename()\n   Return filename of current dir entry */\nSPL_METHOD(DirectoryIterator, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getExtension()\n   Returns file extension component of path */\nSPL_METHOD(SplFileInfo, getExtension)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *fname = NULL;\n\tconst char *p;\n\tsize_t flen;\n\tint path_len, idx;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tfname = intern->file_name + path_len + 1;\n\t\tflen = intern->file_name_len - (path_len + 1);\n\t} else {\n\t\tfname = intern->file_name;\n\t\tflen = intern->file_name_len;\n\t}\n\n\tphp_basename(fname, flen, NULL, 0, &fname, &flen TSRMLS_CC);\n\n\tp = zend_memrchr(fname, '.', flen);\n\tif (p) {\n\t\tidx = p - fname;\n\t\tRETVAL_STRINGL(fname + idx + 1, flen - idx - 1, 1);\n\t\tefree(fname);\n\t\treturn;\n\t} else {\n\t\tif (fname) {\n\t\t\tefree(fname);\n\t\t}\n\t\tRETURN_EMPTY_STRING();\n\t}\n}\n/* }}}*/\n\n/* {{{ proto string DirectoryIterator::getExtension()\n   Returns the file extension component of path */\nSPL_METHOD(DirectoryIterator, getExtension)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *fname = NULL;\n\tconst char *p;\n\tsize_t flen;\n\tint idx;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_basename(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), NULL, 0, &fname, &flen TSRMLS_CC);\n\n\tp = zend_memrchr(fname, '.', flen);\n\tif (p) {\n\t\tidx = p - fname;\n\t\tRETVAL_STRINGL(fname + idx + 1, flen - idx - 1, 1);\n\t\tefree(fname);\n\t\treturn;\n\t} else {\n\t\tif (fname) {\n\t\t\tefree(fname);\n\t\t}\n\t\tRETURN_EMPTY_STRING();\n\t}\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getBasename([string $suffix]) U\n   Returns filename component of path */\nSPL_METHOD(SplFileInfo, getBasename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *fname, *suffix = 0;\n\tsize_t flen;\n\tint slen = 0, path_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &suffix, &slen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tfname = intern->file_name + path_len + 1;\n\t\tflen = intern->file_name_len - (path_len + 1);\n\t} else {\n\t\tfname = intern->file_name;\n\t\tflen = intern->file_name_len;\n\t}\n\n\tphp_basename(fname, flen, suffix, slen, &fname, &flen TSRMLS_CC);\n\n\tRETURN_STRINGL(fname, flen, 0);\n}\n/* }}}*/   \n\n/* {{{ proto string DirectoryIterator::getBasename([string $suffix]) U\n   Returns filename component of current dir entry */\nSPL_METHOD(DirectoryIterator, getBasename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *suffix = 0, *fname;\n\tint slen = 0;\n\tsize_t flen;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &suffix, &slen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_basename(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), suffix, slen, &fname, &flen TSRMLS_CC);\n\n\tRETURN_STRINGL(fname, flen, 0);\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getPathname()\n   Return path and filename */\nSPL_METHOD(SplFileInfo, getPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *path;\n\tint path_len;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tpath = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\tif (path != NULL) {\n\t\tRETURN_STRINGL(path, path_len, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string FilesystemIterator::key()\n   Return getPathname() or getFilename() depending on flags */\nSPL_METHOD(FilesystemIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string FilesystemIterator::current()\n   Return getFilename(), getFileInfo() or $this depending on flags */\nSPL_METHOD(FilesystemIterator, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t\t/*RETURN_STRING(intern->u.dir.entry.d_name, 1);*/\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool DirectoryIterator::isDot()\n   Returns true if current entry is '.' or  '..' */\nSPL_METHOD(DirectoryIterator, isDot)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}\n/* }}} */\n\n/* {{{ proto void SplFileInfo::__construct(string file_name)\n Cronstructs a new SplFileInfo from a path. */\n/* zend_replace_error_handling() is used to throw exceptions in case\n   the constructor fails. Here we use this to ensure the object\n   has a valid directory resource.\n   \n   When the constructor gets called the object is already created \n   by the engine, so we must only call 'additional' initializations.\n */\nSPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\n\t/* intern->type = SPL_FS_INFO; already set */\n}\n/* }}} */\n\n/* {{{ FileInfoFunction */\n#define FileInfoFunction(func_name, func_num) \\\nSPL_METHOD(SplFileInfo, func_name) \\\n{ \\\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\\n\tzend_error_handling error_handling; \\\n\tif (zend_parse_parameters_none() == FAILURE) { \\\n\t\treturn; \\\n\t} \\\n \\\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\\\n\tspl_filesystem_object_get_file_name(intern TSRMLS_CC); \\\n\tphp_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC); \\\n\tzend_restore_error_handling(&error_handling TSRMLS_CC); \\\n}\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getPerms()\n   Get file permissions */\nFileInfoFunction(getPerms, FS_PERMS)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getInode()\n   Get file inode */\nFileInfoFunction(getInode, FS_INODE)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getSize()\n   Get file size */\nFileInfoFunction(getSize, FS_SIZE)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getOwner()\n   Get file owner */\nFileInfoFunction(getOwner, FS_OWNER)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getGroup()\n   Get file group */\nFileInfoFunction(getGroup, FS_GROUP)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getATime()\n   Get last access time of file */\nFileInfoFunction(getATime, FS_ATIME)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getMTime()\n   Get last modification time of file */\nFileInfoFunction(getMTime, FS_MTIME)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getCTime()\n   Get inode modification time of file */\nFileInfoFunction(getCTime, FS_CTIME)\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getType()\n   Get file type */\nFileInfoFunction(getType, FS_TYPE)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isWritable()\n   Returns true if file can be written */\nFileInfoFunction(isWritable, FS_IS_W)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isReadable()\n   Returns true if file can be read */\nFileInfoFunction(isReadable, FS_IS_R)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isExecutable()\n   Returns true if file is executable */\nFileInfoFunction(isExecutable, FS_IS_X)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isFile()\n   Returns true if file is a regular file */\nFileInfoFunction(isFile, FS_IS_FILE)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isDir()\n   Returns true if file is directory */\nFileInfoFunction(isDir, FS_IS_DIR)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isLink()\n   Returns true if file is symbolic link */\nFileInfoFunction(isLink, FS_IS_LINK)\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getLinkTarget() U\n   Return the target of a symbolic link */\nSPL_METHOD(SplFileInfo, getLinkTarget)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint ret;\n\tchar buff[MAXPATHLEN];\n\tzend_error_handling error_handling;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n#if defined(PHP_WIN32) || HAVE_SYMLINK\n\tif (intern->file_name == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename\");\n\t\tRETURN_FALSE;\n\t} else if (!IS_ABSOLUTE_PATH(intern->file_name, intern->file_name_len)) {\n\t\tchar expanded_path[MAXPATHLEN];\n\t\tif (!expand_filepath_with_mode(intern->file_name, expanded_path, NULL, 0, CWD_EXPAND  TSRMLS_CC)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No such file or directory\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tret = php_sys_readlink(expanded_path, buff, MAXPATHLEN - 1);\n\t} else {\n\t\tret = php_sys_readlink(intern->file_name, buff,  MAXPATHLEN-1);\n\t}\n#else\n\tret = -1; /* always fail if not implemented */\n#endif\n\n\tif (ret == -1) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Unable to read link %s, error: %s\", intern->file_name, strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\t/* Append NULL to the end of the string */\n\t\tbuff[ret] = '\\0';\n\n\t\tRETVAL_STRINGL(buff, ret, 1);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n/* {{{ proto string SplFileInfo::getRealPath()\n   Return the resolved path */\nSPL_METHOD(SplFileInfo, getRealPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buff[MAXPATHLEN];\n\tchar *filename;\n\tzend_error_handling error_handling;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t}\n\t\n\tif (intern->orig_path) {\n\t\tfilename = intern->orig_path;\n\t} else { \n\t\tfilename = intern->file_name;\n\t}\n\n\n\tif (filename && VCWD_REALPATH(filename, buff)) {\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(buff, F_OK)) {\n\t\t\tRETVAL_FALSE;\n\t\t} else\n#endif\n\t\tRETVAL_STRING(buff, 1);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n#endif\n\n/* {{{ proto SplFileObject SplFileInfo::openFile([string mode = 'r' [, bool use_include_path  [, resource context]]])\n   Open the current file */\nSPL_METHOD(SplFileInfo, openFile)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tspl_filesystem_object_create_type(ht, intern, SPL_FS_FILE, NULL, return_value TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void SplFileInfo::setFileClass([string class_name])\n   Class to use in openFile() */\nSPL_METHOD(SplFileInfo, setFileClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileObject;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->file_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void SplFileInfo::setInfoClass([string class_name])\n   Class to use in getFileInfo(), getPathInfo() */\nSPL_METHOD(SplFileInfo, setInfoClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileInfo;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->info_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto SplFileInfo SplFileInfo::getFileInfo([string $class_name])\n   Get/copy file info */\nSPL_METHOD(SplFileInfo, getFileInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tspl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto SplFileInfo SplFileInfo::getPathInfo([string $class_name])\n   Get/copy file info */\nSPL_METHOD(SplFileInfo, getPathInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\t\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ */\nSPL_METHOD(SplFileInfo, _bad_state_ex)\n{\n\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC,\n\t\t\"The parent constructor was not called: the object is in an \"\n\t\t\"invalid state \");\n}\n/* }}} */\n\n/* {{{ proto void FilesystemIterator::__construct(string path [, int flags])\n Cronstructs a new dir iterator from a path. */\nSPL_METHOD(FilesystemIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIT_CTOR_FLAGS | SPL_FILE_DIR_SKIPDOTS);\n}\n/* }}} */\n\n/* {{{ proto void FilesystemIterator::rewind()\n   Rewind dir back to the start */\nSPL_METHOD(FilesystemIterator, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index = 0;\n\tif (intern->u.dir.dirp) {\n\t\tphp_stream_rewinddir(intern->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}\n/* }}} */\n\n/* {{{ proto int FilesystemIterator::getFlags()\n   Get handling flags */\nSPL_METHOD(FilesystemIterator, getFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n} /* }}} */\n\n/* {{{ proto void FilesystemIterator::setFlags(long $flags)\n   Set handling flags */\nSPL_METHOD(FilesystemIterator, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong flags;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->flags &= ~(SPL_FILE_DIR_KEY_MODE_MASK|SPL_FILE_DIR_CURRENT_MODE_MASK|SPL_FILE_DIR_OTHERS_MASK);\n\tintern->flags |= ((SPL_FILE_DIR_KEY_MODE_MASK|SPL_FILE_DIR_CURRENT_MODE_MASK|SPL_FILE_DIR_OTHERS_MASK) & flags);\n} /* }}} */\n\n/* {{{ proto bool RecursiveDirectoryIterator::hasChildren([bool $allow_links = false])\n   Returns whether current entry is a directory and not '.' or '..' */\nSPL_METHOD(RecursiveDirectoryIterator, hasChildren)\n{\n\tzend_bool allow_links = 0;\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &allow_links) == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_filesystem_is_invalid_or_dot(intern->u.dir.entry.d_name)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tif (!allow_links && !(intern->flags & SPL_FILE_DIR_FOLLOW_SYMLINKS)) {\n\t\t\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_LINK, return_value TSRMLS_CC);\n\t\t\tif (zend_is_true(return_value)) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_DIR, return_value TSRMLS_CC);\n    }\n}\n/* }}} */\n\n/* {{{ proto RecursiveDirectoryIterator DirectoryIterator::getChildren()\n   Returns an iterator for the current entry if it is a directory */\nSPL_METHOD(RecursiveDirectoryIterator, getChildren)\n{\n\tzval *zpath, *zflags;\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_filesystem_object *subdir;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\n\tMAKE_STD_ZVAL(zflags);\n\tMAKE_STD_ZVAL(zpath);\n\tZVAL_LONG(zflags, intern->flags);\n\tZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n\tzval_ptr_dtor(&zpath);\n\tzval_ptr_dtor(&zflags);\n\n\tsubdir = (spl_filesystem_object*)zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (subdir) {\n\t\tif (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n\t\t\tsubdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\t} else {\n\t\t\tsubdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n\t\t\tsubdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n\t\t}\n\t\tsubdir->info_class = intern->info_class;\n\t\tsubdir->file_class = intern->file_class;\n\t\tsubdir->oth = intern->oth;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void RecursiveDirectoryIterator::getSubPath()\n   Get sub path */\nSPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void RecursiveDirectoryIterator::getSubPathname()\n   Get sub path and file name */\nSPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *sub_name;\n\tint len;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tlen = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\tRETURN_STRINGL(sub_name, len, 0);\n\t} else {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int RecursiveDirectoryIterator::__construct(string path [, int flags])\n Cronstructs a new dir iterator from a path. */\nSPL_METHOD(RecursiveDirectoryIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIT_CTOR_FLAGS);\n}\n/* }}} */\n\n#ifdef HAVE_GLOB\n/* {{{ proto int GlobIterator::__construct(string path [, int flags])\n Cronstructs a new dir iterator from a glob expression (no glob:// needed). */\nSPL_METHOD(GlobIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIT_CTOR_FLAGS|DIT_CTOR_GLOB);\n}\n/* }}} */\n\n/* {{{ proto int GlobIterator::cont()\n   Return the number of directories and files found by globbing */\nSPL_METHOD(GlobIterator, count)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t/* should not happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}\n/* }}} */\n#endif /* HAVE_GLOB */\n\n/* {{{ forward declarations to the iterator handlers */\nstatic void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC);\nstatic int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC);\nstatic void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC);\nstatic void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC);\nstatic void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC);\nstatic void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC);\n\n/* iterator handler table */\nzend_object_iterator_funcs spl_filesystem_dir_it_funcs = {\n\tspl_filesystem_dir_it_dtor,\n\tspl_filesystem_dir_it_valid,\n\tspl_filesystem_dir_it_current_data,\n\tspl_filesystem_dir_it_current_key,\n\tspl_filesystem_dir_it_move_forward,\n\tspl_filesystem_dir_it_rewind\n};\n/* }}} */\n\n/* {{{ spl_ce_dir_get_iterator */\nzend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\t/* initialize iterator if it wasn't gotten before */\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\t/* ->current must be initialized; rewind doesn't set it and valid\n\t\t * doesn't check whether it's set */\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\t\n\treturn (zend_object_iterator*)iterator;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_dtor */\nstatic void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\tif (iterator->intern.data) {\n\t\tzval *object =  iterator->intern.data;\n\t\tzval_ptr_dtor(&object);\n\t}\n\t/* Otherwise we were called from the owning object free storage handler as\n\t * it sets\n\t * iterator->intern.data to NULL.\n\t * We don't even need to destroy iterator->current as we didn't add a\n\t * reference to it in move_forward or get_iterator */\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_valid */\nstatic int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\treturn object->u.dir.entry.d_name[0] != '\\0' ? SUCCESS : FAILURE;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_current_data */\nstatic void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\t\n\t*data = &iterator->current;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_current_key */\nstatic void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tZVAL_LONG(key, object->u.dir.index);\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_move_forward */\nstatic void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\t\n\tobject->u.dir.index++;\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_rewind */\nstatic void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\t\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_dtor */\nstatic void spl_filesystem_tree_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\tif (iterator->intern.data) {\n\t\tzval *object = \titerator->intern.data;\n\t\tzval_ptr_dtor(&object);\n\t} else {\n\t\tif (iterator->current) {\n\t\t\tzval_ptr_dtor(&iterator->current);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_current_data */\nstatic void spl_filesystem_tree_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\n\tif (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tif (!iterator->current) {\n\t\t\tALLOC_INIT_ZVAL(iterator->current);\n\t\t\tspl_filesystem_object_get_file_name(object TSRMLS_CC);\n\t\t\tZVAL_STRINGL(iterator->current, object->file_name, object->file_name_len, 1);\n\t\t}\n\t\t*data = &iterator->current;\n\t} else if (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tif (!iterator->current) {\n\t\t\tALLOC_INIT_ZVAL(iterator->current);\n\t\t\tspl_filesystem_object_get_file_name(object TSRMLS_CC);\n\t\t\tspl_filesystem_object_create_type(0, object, SPL_FS_INFO, NULL, iterator->current TSRMLS_CC);\n\t\t}\n\t\t*data = &iterator->current;\n\t} else {\n\t\t*data = (zval**)&iterator->intern.data;\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_current_key */\nstatic void spl_filesystem_tree_it_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tif (SPL_FILE_DIR_KEY(object, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tZVAL_STRING(key, object->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(object TSRMLS_CC);\n\t\tZVAL_STRINGL(key, object->file_name, object->file_name_len, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_move_forward */\nstatic void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\t\n\tobject->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_rewind */\nstatic void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\t\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ iterator handler table */\nzend_object_iterator_funcs spl_filesystem_tree_it_funcs = {\n\tspl_filesystem_tree_it_dtor,\n\tspl_filesystem_dir_it_valid,\n\tspl_filesystem_tree_it_current_data,\n\tspl_filesystem_tree_it_current_key,\n\tspl_filesystem_tree_it_move_forward,\n\tspl_filesystem_tree_it_rewind\n};\n/* }}} */\n\n/* {{{ spl_ce_dir_get_iterator */\nzend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\t/* initialize iterator if wasn't gotten before */\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\t\n\treturn (zend_object_iterator*)iterator;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_object_cast */\nstatic int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TSRMLS_DC)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(readobj TSRMLS_CC);\n\n\tif (type == IS_STRING) {\n\t\tif (Z_OBJCE_P(readobj)->__tostring) {\n\t\t\treturn std_object_handlers.cast_object(readobj, writeobj, type TSRMLS_CC);\n\t\t}\n\n\t\tswitch (intern->type) {\n\t\tcase SPL_FS_INFO:\n\t\tcase SPL_FS_FILE:\n\t\t\tif (readobj == writeobj) {\n\t\t\t\tzval retval;\n\t\t\t\tzval *retval_ptr = &retval;\n\n\t\t\t\tZVAL_STRINGL(retval_ptr, intern->file_name, intern->file_name_len, 1);\n\t\t\t\tzval_dtor(readobj);\n\t\t\t\tZVAL_ZVAL(writeobj, retval_ptr, 0, 0);\n\t\t\t} else {\n\t\t\t\tZVAL_STRINGL(writeobj, intern->file_name, intern->file_name_len, 1);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\tcase SPL_FS_DIR:\n\t\t\tif (readobj == writeobj) {\n\t\t\t\tzval retval;\n\t\t\t\tzval *retval_ptr = &retval;\n\n\t\t\t\tZVAL_STRING(retval_ptr, intern->u.dir.entry.d_name, 1);\n\t\t\t\tzval_dtor(readobj);\n\t\t\t\tZVAL_ZVAL(writeobj, retval_ptr, 0, 0);\n\t\t\t} else {\n\t\t\t\tZVAL_STRING(writeobj, intern->u.dir.entry.d_name, 1);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else if (type == IS_BOOL) {\n\t\tZVAL_BOOL(writeobj, 1);\n\t\treturn SUCCESS;\n\t}\n\tif (readobj == writeobj) {\n\t\tzval_dtor(readobj);\n\t}\n\tZVAL_NULL(writeobj);\n\treturn FAILURE;\n}\n/* }}} */\n\n/* {{{ declare method parameters */\n/* supply a name and default to call by parameter */\nZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0) \n\tZEND_ARG_INFO(0, file_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_info_openFile, 0, 0, 0)\n\tZEND_ARG_INFO(0, open_mode)\n\tZEND_ARG_INFO(0, use_include_path)\n\tZEND_ARG_INFO(0, context)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_info_optinalFileClass, 0, 0, 0)\n\tZEND_ARG_INFO(0, class_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_optinalSuffix, 0, 0, 0)\n\tZEND_ARG_INFO(0, suffix)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_splfileinfo_void, 0)\nZEND_END_ARG_INFO()\n\n/* the method table */\n/* each method can have its own parameters and visibility */\nstatic const zend_function_entry spl_SplFileInfo_functions[] = {\n\tSPL_ME(SplFileInfo,       __construct,   arginfo_info___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPath,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getFilename,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getExtension,  arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getBasename,   arginfo_optinalSuffix, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPathname,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPerms,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getInode,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getSize,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getOwner,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getGroup,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getATime,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getMTime,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getCTime,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getType,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isWritable,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isReadable,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isExecutable,  arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isFile,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isDir,         arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isLink,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getLinkTarget, arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n\tSPL_ME(SplFileInfo,       getRealPath,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n#endif\n\tSPL_ME(SplFileInfo,       getFileInfo,   arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPathInfo,   arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       openFile,      arginfo_info_openFile,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       setFileClass,  arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       setInfoClass,  arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       _bad_state_ex, NULL,\t\t\t\t\t\t\tZEND_ACC_PUBLIC|ZEND_ACC_FINAL)\n\tSPL_MA(SplFileInfo,       __toString, SplFileInfo, getPathname, arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0) \n\tZEND_ARG_INFO(0, path)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0) \n\tZEND_ARG_INFO(0, position)\nZEND_END_ARG_INFO();\n\n/* the method table */\n/* each method can have its own parameters and visibility */\nstatic const zend_function_entry spl_DirectoryIterator_functions[] = {\n\tSPL_ME(DirectoryIterator, __construct,   arginfo_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, getFilename,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, getExtension,  arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, getBasename,   arginfo_optinalSuffix, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, isDot,         arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, rewind,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, valid,         arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, key,           arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, current,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, next,          arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, seek,          arginfo_dir_it_seek, ZEND_ACC_PUBLIC)\n\tSPL_MA(DirectoryIterator, __toString, DirectoryIterator, getFilename, arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1) \n\tZEND_ARG_INFO(0, path)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir_hasChildren, 0, 0, 0)\n\tZEND_ARG_INFO(0, allow_links)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir_setFlags, 0, 0, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_FilesystemIterator_functions[] = {\n\tSPL_ME(FilesystemIterator, __construct,   arginfo_r_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, rewind,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator,  next,          arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, key,           arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, current,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, getFlags,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, setFlags,      arginfo_r_dir_setFlags, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nstatic const zend_function_entry spl_RecursiveDirectoryIterator_functions[] = {\n\tSPL_ME(RecursiveDirectoryIterator, __construct,   arginfo_r_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, hasChildren,   arginfo_r_dir_hasChildren, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, getChildren,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, getSubPath,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, getSubPathname,arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\n#ifdef HAVE_GLOB\nstatic const zend_function_entry spl_GlobIterator_functions[] = {\n\tSPL_ME(GlobIterator, __construct,   arginfo_r_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(GlobIterator, count,         arginfo_splfileinfo_void,  ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n#endif\n/* }}} */\n\nstatic int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tchar *buf;\n\tsize_t line_len = 0;\n\tlong line_add = (intern->u.file.current_line || intern->u.file.current_zval) ? 1 : 0;\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\n\tif (php_stream_eof(intern->u.file.stream)) {\n\t\tif (!silent) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file %s\", intern->file_name);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (intern->u.file.max_line_len > 0) {\n\t\tbuf = safe_emalloc((intern->u.file.max_line_len + 1), sizeof(char), 0);\n\t\tif (php_stream_get_line(intern->u.file.stream, buf, intern->u.file.max_line_len + 1, &line_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tbuf = NULL;\n\t\t} else {\n\t\t\tbuf[line_len] = '\\0';\n\t\t}\n\t} else {\n\t\tbuf = php_stream_get_line(intern->u.file.stream, NULL, 0, &line_len);\n\t}\n\n\tif (!buf) {\n\t\tintern->u.file.current_line = estrdup(\"\");\n\t\tintern->u.file.current_line_len = 0;\n\t} else {\n\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_DROP_NEW_LINE)) {\n\t\t\tline_len = strcspn(buf, \"\\r\\n\");\n\t\t\tbuf[line_len] = '\\0';\n\t\t}\n\t\n\t\tintern->u.file.current_line = buf;\n\t\tintern->u.file.current_line_len = line_len;\n\t}\n\tintern->u.file.current_line_num += line_add;\n\n\treturn SUCCESS;\n} /* }}} */\n\nstatic int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function *func_ptr, int pass_num_args, zval *return_value, zval *arg2 TSRMLS_DC) /* {{{ */\n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcic;\n\tzval z_fname;\n\tzval * zresource_ptr = &intern->u.file.zresource, *retval;\n\tint result;\n\tint num_args = pass_num_args + (arg2 ? 2 : 1);\n\n\tzval ***params = (zval***)safe_emalloc(num_args, sizeof(zval**), 0);\n\n\tparams[0] = &zresource_ptr;\n\t\n\tif (arg2) {\n\t\tparams[1] = &arg2;\n\t}\n\n\tzend_get_parameters_array_ex(pass_num_args, params+(arg2 ? 2 : 1));\n\n\tZVAL_STRING(&z_fname, func_ptr->common.function_name, 0);\n\n\tfci.size = sizeof(fci);\n\tfci.function_table = EG(function_table);\n\tfci.object_ptr = NULL;\n\tfci.function_name = &z_fname;\n\tfci.retval_ptr_ptr = &retval;\n\tfci.param_count = num_args;\n\tfci.params = params;\n\tfci.no_separation = 1;\n\tfci.symbol_table = NULL;\n\n\tfcic.initialized = 1;\n\tfcic.function_handler = func_ptr;\n\tfcic.calling_scope = NULL;\n\tfcic.called_scope = NULL;\n\tfcic.object_ptr = NULL;\n\n\tresult = zend_call_function(&fci, &fcic TSRMLS_CC);\n\t\n\tif (result == FAILURE) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tZVAL_ZVAL(return_value, retval, 1, 1);\n\t}\n\n\tefree(params);\n\treturn result;\n} /* }}} */\n\n#define FileFunctionCall(func_name, pass_num_args, arg2) /* {{{ */ \\\n{ \\\n\tzend_function *func_ptr; \\\n\tint ret; \\\n\tret = zend_hash_find(EG(function_table), #func_name, sizeof(#func_name), (void **) &func_ptr); \\\n\tif (ret != SUCCESS) { \\\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Internal error, function '%s' not found. Please report\", #func_name); \\\n\t\treturn; \\\n\t} \\\n\tspl_filesystem_file_call(intern, func_ptr, pass_num_args, return_value, arg2 TSRMLS_CC); \\\n} /* }}} */\n\nstatic int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tint ret = SUCCESS;\n\t\n\tdo {\n\t\tret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);\n\t} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));\n\t\n\tif (ret == SUCCESS) {\n\t\tsize_t buf_len = intern->u.file.current_line_len;\n\t\tchar *buf = estrndup(intern->u.file.current_line, buf_len);\n\n\t\tif (intern->u.file.current_zval) {\n\t\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\t}\n\t\tALLOC_INIT_ZVAL(intern->u.file.current_zval);\n\n\t\tphp_fgetcsv(intern->u.file.stream, delimiter, enclosure, escape, buf_len, buf, intern->u.file.current_zval TSRMLS_CC);\n\t\tif (return_value) {\n\t\t\tif (Z_TYPE_P(return_value) != IS_NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZVAL_NULL(return_value);\n\t\t\t}\n\t\t\tZVAL_ZVAL(return_value, intern->u.file.current_zval, 1, 0);\n\t\t}\n\t}\n\treturn ret;\n}\n/* }}} */\n\nstatic int spl_filesystem_file_read_line_ex(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tzval *retval = NULL;\n\n\t/* 1) use fgetcsv? 2) overloaded call the function, 3) do it directly */\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || intern->u.file.func_getCurr->common.scope != spl_ce_SplFileObject) {\n\t\tif (php_stream_eof(intern->u.file.stream)) {\n\t\t\tif (!silent) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file %s\", intern->file_name);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)) {\n\t\t\treturn spl_filesystem_file_read_csv(intern, intern->u.file.delimiter, intern->u.file.enclosure, intern->u.file.escape, NULL TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.file.func_getCurr, \"getCurrentLine\", &retval);\n\t\t}\n\t\tif (retval) {\n\t\t\tif (intern->u.file.current_line || intern->u.file.current_zval) {\n\t\t\t\tintern->u.file.current_line_num++;\n\t\t\t}\n\t\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\t\tif (Z_TYPE_P(retval) == IS_STRING) {\n\t\t\t\tintern->u.file.current_line = estrndup(Z_STRVAL_P(retval), Z_STRLEN_P(retval));\n\t\t\t\tintern->u.file.current_line_len = Z_STRLEN_P(retval);\n\t\t\t} else {\n\t\t\t\tMAKE_STD_ZVAL(intern->u.file.current_zval);\n\t\t\t\tZVAL_ZVAL(intern->u.file.current_zval, retval, 1, 0);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&retval);\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\treturn spl_filesystem_file_read(intern, silent TSRMLS_CC);\n\t}\n} /* }}} */\n\nstatic int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (intern->u.file.current_line) {\n\t\treturn intern->u.file.current_line_len == 0;\n\t} else if (intern->u.file.current_zval) {\n\t\tswitch(Z_TYPE_P(intern->u.file.current_zval)) {\n\t\tcase IS_STRING:\n\t\t\treturn Z_STRLEN_P(intern->u.file.current_zval) == 0;\n\t\tcase IS_ARRAY:\n\t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n\t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n\t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n\t\t\t\t\t\n\t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n\t\t\t}\n\t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n\t\tcase IS_NULL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\t\n\treturn ret;\n}\n/* }}} */\n\nstatic void spl_filesystem_file_rewind(zval * this_ptr, spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (-1 == php_stream_rewind(intern->u.file.stream)) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot rewind file %s\", intern->file_name);\n\t} else {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tintern->u.file.current_line_num = 0;\n\t}\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(this_ptr, intern, 1 TSRMLS_CC);\n\t}\n} /* }}} */\n\n/* {{{ proto void SplFileObject::__construct(string filename [, string mode = 'r' [, bool use_include_path  [, resource context]]]])\n   Construct a new file object */\nSPL_METHOD(SplFileObject, __construct)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_bool use_include_path = 0;\n\tchar *p1, *p2;\n\tchar *tmp_path;\n\tint   tmp_path_len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tintern->u.file.open_mode = NULL;\n\tintern->u.file.open_mode_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sbr!\", \n\t\t\t&intern->file_name, &intern->file_name_len,\n\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\t\t\n\t\tintern->u.file.open_mode = NULL;\n\t\tintern->file_name = NULL;\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\t\n\tif (intern->u.file.open_mode == NULL) {\n\t\tintern->u.file.open_mode = \"r\";\n\t\tintern->u.file.open_mode_len = 1;\n\t}\n\n\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == SUCCESS) {\n\t\ttmp_path_len = strlen(intern->u.file.stream->orig_path);\n\n\t\tif (tmp_path_len > 1 && IS_SLASH_AT(intern->u.file.stream->orig_path, tmp_path_len-1)) {\n\t\t\ttmp_path_len--;\n\t\t}\n\n\t\ttmp_path = estrndup(intern->u.file.stream->orig_path, tmp_path_len);\n\n\t\tp1 = strrchr(tmp_path, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\t\tp2 = strrchr(tmp_path, '\\\\');\n#else\n\t\tp2 = 0;\n#endif\n\t\tif (p1 || p2) {\n\t\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - tmp_path;\n\t\t} else {\n\t\t\tintern->_path_len = 0;\n\t\t}\n\n\t\tefree(tmp_path);\n\n\t\tintern->_path = estrndup(intern->u.file.stream->orig_path, intern->_path_len);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n} /* }}} */\n\n/* {{{ proto void SplTempFileObject::__construct([int max_memory])\n   Construct a new temp file object */\nSPL_METHOD(SplTempFileObject, __construct)\n{\n\tlong max_memory = PHP_STREAM_MAX_MEM;\n\tchar tmp_fname[48];\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &max_memory) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (max_memory < 0) {\n\t\tintern->file_name = \"php://memory\";\n\t\tintern->file_name_len = 12;\n\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php://temp/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php://temp\";\n\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\t\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::rewind()\n   Rewind the file and read the first line */\nSPL_METHOD(SplFileObject, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::eof()\n   Return whether end of file is reached */\nSPL_METHOD(SplFileObject, eof)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(php_stream_eof(intern->u.file.stream));\n} /* }}} */\n\n/* {{{ proto void SplFileObject::valid()\n   Return !eof() */\nSPL_METHOD(SplFileObject, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgets()\n   Rturn next line from file */\nSPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} /* }}} */\n\n/* {{{ proto string SplFileObject::current()\n   Return current line from file */\nSPL_METHOD(SplFileObject, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!intern->u.file.current_line && !intern->u.file.current_zval) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tif (intern->u.file.current_line && (!SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || !intern->u.file.current_zval)) {\n\t\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n\t} else if (intern->u.file.current_zval) {\n\t\tRETURN_ZVAL(intern->u.file.current_zval, 1, 0);\n\t}\n\tRETURN_FALSE;\n} /* }}} */\n\n/* {{{ proto int SplFileObject::key()\n   Return line number */\nSPL_METHOD(SplFileObject, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n/*\tDo not read the next line to support correct counting with fgetc()\n\tif (!intern->current_line) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t} */\n\tRETURN_LONG(intern->u.file.current_line_num);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::next()\n   Read next line */\nSPL_METHOD(SplFileObject, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tintern->u.file.current_line_num++;\n} /* }}} */\n\n/* {{{ proto void SplFileObject::setFlags(int flags)\n   Set file handling flags */\nSPL_METHOD(SplFileObject, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n} /* }}} */\n\n/* {{{ proto int SplFileObject::getFlags()\n   Get file handling flags */\nSPL_METHOD(SplFileObject, getFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->flags & SPL_FILE_OBJECT_MASK);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::setMaxLineLen(int max_len)\n   Set maximum line length */\nSPL_METHOD(SplFileObject, setMaxLineLen)\n{\n\tlong max_len;\n\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &max_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (max_len < 0) {\n\t\tzend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, \"Maximum line length must be greater than or equal zero\");\n\t\treturn;\n\t}\n\t\n\tintern->u.file.max_line_len = max_len;\n} /* }}} */\n\n/* {{{ proto int SplFileObject::getMaxLineLen()\n   Get maximum line length */\nSPL_METHOD(SplFileObject, getMaxLineLen)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\t\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::hasChildren()\n   Return false */\nSPL_METHOD(SplFileObject, hasChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t\n\tRETURN_FALSE;\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::getChildren()\n   Read NULL */\nSPL_METHOD(SplFileObject, getChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t/* return NULL */\n} /* }}} */\n\n/* {{{ FileFunction */\n#define FileFunction(func_name) \\\nSPL_METHOD(SplFileObject, func_name) \\\n{ \\\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\\n\tFileFunctionCall(func_name, ZEND_NUM_ARGS(), NULL); \\\n}\n/* }}} */\n\n/* {{{ proto array SplFileObject::fgetcsv([string delimiter [, string enclosure [, escape = '\\\\']]])\n   Return current line as csv */\nSPL_METHOD(SplFileObject, fgetcsv)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sss\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 3:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t/* no break */\n\t\tcase 2:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t/* no break */\n\t\tcase 1:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t/* no break */\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tspl_filesystem_file_read_csv(intern, delimiter, enclosure, escape, return_value TSRMLS_CC);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int SplFileObject::fputcsv(array fields, [string delimiter [, string enclosure [, string escape]]])\n   Output a field array as a CSV line */\nSPL_METHOD(SplFileObject, fputcsv)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0, ret;\n\tzval *fields = NULL;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|sss\", &fields, &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 4:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t/* no break */\n\t\tcase 3:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t/* no break */\n\t\tcase 2:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t/* no break */\n\t\tcase 1:\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tret = php_fputcsv(intern->u.file.stream, fields, delimiter, enclosure, escape TSRMLS_CC);\n\t\tRETURN_LONG(ret);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void SplFileObject::setCsvControl([string delimiter = ',' [, string enclosure = '\"' [, string escape = '\\\\']]])\n   Set the delimiter and enclosure character used in fgetcsv */\nSPL_METHOD(SplFileObject, setCsvControl)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = ',', enclosure = '\"', escape='\\\\';\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sss\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 3:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t/* no break */\n\t\tcase 2:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t/* no break */\n\t\tcase 1:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t/* no break */\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tintern->u.file.delimiter = delimiter;\n\t\tintern->u.file.enclosure = enclosure;\n\t\tintern->u.file.escape    = escape;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array SplFileObject::getCsvControl()\n   Get the delimiter and enclosure character used in fgetcsv */\nSPL_METHOD(SplFileObject, getCsvControl)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter[2], enclosure[2];\n\n\tarray_init(return_value);\n\t\n\tdelimiter[0] = intern->u.file.delimiter;\n\tdelimiter[1] = '\\0';\n\tenclosure[0] = intern->u.file.enclosure;\n\tenclosure[1] = '\\0';\n\n\tadd_next_index_string(return_value, delimiter, 1);\n\tadd_next_index_string(return_value, enclosure, 1);\n}\n/* }}} */\n\n/* {{{ proto bool SplFileObject::flock(int operation [, int &wouldblock])\n   Portable file locking */\nFileFunction(flock)\n/* }}} */\n\n/* {{{ proto bool SplFileObject::fflush()\n   Flush the file */\nSPL_METHOD(SplFileObject, fflush)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tRETURN_BOOL(!php_stream_flush(intern->u.file.stream));\n} /* }}} */\n\n/* {{{ proto int SplFileObject::ftell()\n   Return current file position */\nSPL_METHOD(SplFileObject, ftell)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\t\n\tlong ret = php_stream_tell(intern->u.file.stream);\n\n\tif (ret == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_LONG(ret);\n\t}\n} /* }}} */\n\n/* {{{ proto int SplFileObject::fseek(int pos [, int whence = SEEK_SET])\n   Return current file position */\nSPL_METHOD(SplFileObject, fseek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong pos, whence = SEEK_SET;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &pos, &whence) == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tRETURN_LONG(php_stream_seek(intern->u.file.stream, pos, whence));\n} /* }}} */\n\n/* {{{ proto int SplFileObject::fgetc()\n   Get a character form the file */\nSPL_METHOD(SplFileObject, fgetc)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buf[2];\n\tint result;\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\n\tresult = php_stream_getc(intern->u.file.stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (result == '\\n') {\n\t\t\tintern->u.file.current_line_num++;\n\t\t}\n\t\tbuf[0] = result;\n\t\tbuf[1] = '\\0';\n\n\t\tRETURN_STRINGL(buf, 1, 1);\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgetss([string allowable_tags])\n   Get a line from file pointer and strip HTML tags */\nSPL_METHOD(SplFileObject, fgetss)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval *arg2 = NULL;\n\tMAKE_STD_ZVAL(arg2);\n\n\tif (intern->u.file.max_line_len > 0) {\n\t\tZVAL_LONG(arg2, intern->u.file.max_line_len);\n\t} else {\n\t\tZVAL_LONG(arg2, 1024);\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tintern->u.file.current_line_num++;\n\n\tFileFunctionCall(fgetss, ZEND_NUM_ARGS(), arg2);\n\n\tzval_ptr_dtor(&arg2);\n} /* }}} */\n\n/* {{{ proto int SplFileObject::fpassthru()\n   Output all remaining data from a file pointer */\nSPL_METHOD(SplFileObject, fpassthru)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tRETURN_LONG(php_stream_passthru(intern->u.file.stream));\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::fscanf(string format [, string ...])\n   Implements a mostly ANSI compatible fscanf() */\nSPL_METHOD(SplFileObject, fscanf)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tintern->u.file.current_line_num++;\n\n\tFileFunctionCall(fscanf, ZEND_NUM_ARGS(), NULL);\n}\n/* }}} */\n\n/* {{{ proto mixed SplFileObject::fwrite(string str [, int length])\n   Binary-safe file write */\nSPL_METHOD(SplFileObject, fwrite)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *str;\n\tint str_len;\n\tlong length = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &str, &str_len, &length) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() > 1) {\n\t\tstr_len = MAX(0, MIN(length, str_len));\n\t}\n\tif (!str_len) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tRETURN_LONG(php_stream_write(intern->u.file.stream, str, str_len));\n} /* }}} */\n\nSPL_METHOD(SplFileObject, fread)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong length = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (length <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(length + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n\n/* {{{ proto bool SplFileObject::fstat()\n   Stat() on a filehandle */\nFileFunction(fstat)\n/* }}} */\n\n/* {{{ proto bool SplFileObject::ftruncate(int size)\n   Truncate file to 'size' length */\nSPL_METHOD(SplFileObject, ftruncate)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong size;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!php_stream_truncate_supported(intern->u.file.stream)) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't truncate file %s\", intern->file_name);\n\t\tRETURN_FALSE;\n\t}\n\t\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n} /* }}} */\n\n/* {{{ proto void SplFileObject::seek(int line_pos)\n   Seek to specified line */\nSPL_METHOD(SplFileObject, seek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong line_pos;\n\t\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (line_pos < 0) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\t\t\n\t}\n\t\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n\t\n\twhile(intern->u.file.current_line_num < line_pos) {\n\t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ Function/Class/Method definitions */\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object___construct, 0, 0, 1)\n\tZEND_ARG_INFO(0, file_name)\n\tZEND_ARG_INFO(0, open_mode)\n\tZEND_ARG_INFO(0, use_include_path)\n\tZEND_ARG_INFO(0, context)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_file_object_setFlags, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_file_object_setMaxLineLen, 0)\n\tZEND_ARG_INFO(0, max_len)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetcsv, 0, 0, 0)\n\tZEND_ARG_INFO(0, delimiter)\n\tZEND_ARG_INFO(0, enclosure)\n\tZEND_ARG_INFO(0, escape)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)\n\tZEND_ARG_INFO(0, fields)\n\tZEND_ARG_INFO(0, delimiter)\n\tZEND_ARG_INFO(0, enclosure)\n\tZEND_ARG_INFO(0, escape)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1) \n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(1, wouldblock)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1) \n\tZEND_ARG_INFO(0, pos)\n\tZEND_ARG_INFO(0, whence)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0) \n\tZEND_ARG_INFO(0, allowable_tags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1) \n\tZEND_ARG_INFO(0, format)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1) \n\tZEND_ARG_INFO(0, str)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fread, 0, 0, 1)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1) \n\tZEND_ARG_INFO(0, size)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1) \n\tZEND_ARG_INFO(0, line_pos)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_SplFileObject_functions[] = {\n\tSPL_ME(SplFileObject, __construct,    arginfo_file_object___construct,   ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, rewind,         arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, eof,            arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, valid,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgets,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgetcsv,        arginfo_file_object_fgetcsv,       ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fputcsv,        arginfo_file_object_fputcsv,       ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, setCsvControl,  arginfo_file_object_fgetcsv,       ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getCsvControl,  arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, flock,          arginfo_file_object_flock,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fflush,         arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, ftell,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fseek,          arginfo_file_object_fseek,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgetc,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fpassthru,      arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgetss,         arginfo_file_object_fgetss,        ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fscanf,         arginfo_file_object_fscanf,        ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fwrite,         arginfo_file_object_fwrite,        ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fread,          arginfo_file_object_fread,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fstat,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, ftruncate,      arginfo_file_object_ftruncate,     ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, current,        arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, key,            arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, next,           arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, setFlags,       arginfo_file_object_setFlags,      ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getFlags,       arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, setMaxLineLen,  arginfo_file_object_setMaxLineLen, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getMaxLineLen,  arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, hasChildren,    arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getChildren,    arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, seek,           arginfo_file_object_seek,          ZEND_ACC_PUBLIC)\n\t/* mappings */\n\tSPL_MA(SplFileObject, getCurrentLine, SplFileObject, fgets,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_MA(SplFileObject, __toString,     SplFileObject, current,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_temp_file_object___construct, 0, 0, 0)\n\tZEND_ARG_INFO(0, max_memory)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_SplTempFileObject_functions[] = {\n\tSPL_ME(SplTempFileObject, __construct, arginfo_temp_file_object___construct,  ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n/* }}} */\n\n/* {{{ PHP_MINIT_FUNCTION(spl_directory)\n */\nPHP_MINIT_FUNCTION(spl_directory)\n{\n\tREGISTER_SPL_STD_CLASS_EX(SplFileInfo, spl_filesystem_object_new, spl_SplFileInfo_functions);\n\tmemcpy(&spl_filesystem_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_filesystem_object_handlers.clone_obj       = spl_filesystem_object_clone;\n\tspl_filesystem_object_handlers.cast_object     = spl_filesystem_object_cast;\n\tspl_filesystem_object_handlers.get_debug_info  = spl_filesystem_object_get_debug_info;\n\tspl_ce_SplFileInfo->serialize = zend_class_serialize_deny;\n\tspl_ce_SplFileInfo->unserialize = zend_class_unserialize_deny;\n\n\tREGISTER_SPL_SUB_CLASS_EX(DirectoryIterator, SplFileInfo, spl_filesystem_object_new, spl_DirectoryIterator_functions);\n\tzend_class_implements(spl_ce_DirectoryIterator TSRMLS_CC, 1, zend_ce_iterator);\n\tREGISTER_SPL_IMPLEMENTS(DirectoryIterator, SeekableIterator);\n\n\tspl_ce_DirectoryIterator->get_iterator = spl_filesystem_dir_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(FilesystemIterator, DirectoryIterator, spl_filesystem_object_new, spl_FilesystemIterator_functions);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_MODE_MASK\",   SPL_FILE_DIR_CURRENT_MODE_MASK);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_AS_PATHNAME\", SPL_FILE_DIR_CURRENT_AS_PATHNAME);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_AS_FILEINFO\", SPL_FILE_DIR_CURRENT_AS_FILEINFO);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_AS_SELF\",     SPL_FILE_DIR_CURRENT_AS_SELF);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"KEY_MODE_MASK\",       SPL_FILE_DIR_KEY_MODE_MASK);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"KEY_AS_PATHNAME\",     SPL_FILE_DIR_KEY_AS_PATHNAME);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"FOLLOW_SYMLINKS\",     SPL_FILE_DIR_FOLLOW_SYMLINKS);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"KEY_AS_FILENAME\",     SPL_FILE_DIR_KEY_AS_FILENAME);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"NEW_CURRENT_AND_KEY\", SPL_FILE_DIR_KEY_AS_FILENAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"OTHER_MODE_MASK\",     SPL_FILE_DIR_OTHERS_MASK);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"SKIP_DOTS\",           SPL_FILE_DIR_SKIPDOTS);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"UNIX_PATHS\",          SPL_FILE_DIR_UNIXPATHS);\n\n\tspl_ce_FilesystemIterator->get_iterator = spl_filesystem_tree_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveDirectoryIterator, FilesystemIterator, spl_filesystem_object_new, spl_RecursiveDirectoryIterator_functions);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveDirectoryIterator, RecursiveIterator);\n\t\n\tmemcpy(&spl_filesystem_object_check_handlers, &spl_filesystem_object_handlers, sizeof(zend_object_handlers));\n\tspl_filesystem_object_check_handlers.get_method = spl_filesystem_object_get_method_check;\n\n#ifdef HAVE_GLOB\n\tREGISTER_SPL_SUB_CLASS_EX(GlobIterator, FilesystemIterator, spl_filesystem_object_new_check, spl_GlobIterator_functions);\n\tREGISTER_SPL_IMPLEMENTS(GlobIterator, Countable);\n#endif\n\n\tREGISTER_SPL_SUB_CLASS_EX(SplFileObject, SplFileInfo, spl_filesystem_object_new_check, spl_SplFileObject_functions);\n\tREGISTER_SPL_IMPLEMENTS(SplFileObject, RecursiveIterator);\n\tREGISTER_SPL_IMPLEMENTS(SplFileObject, SeekableIterator);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"DROP_NEW_LINE\", SPL_FILE_OBJECT_DROP_NEW_LINE);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"READ_AHEAD\",    SPL_FILE_OBJECT_READ_AHEAD);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"SKIP_EMPTY\",    SPL_FILE_OBJECT_SKIP_EMPTY);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"READ_CSV\",      SPL_FILE_OBJECT_READ_CSV);\n\t\n\tREGISTER_SPL_SUB_CLASS_EX(SplTempFileObject, SplFileObject, spl_filesystem_object_new_check, spl_SplTempFileObject_functions);\n\treturn SUCCESS;\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"], "fixing_code": ["/*\n   +----------------------------------------------------------------------+\n   | PHP Version 5                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) 1997-2015 The PHP Group                                |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Author: Marcus Boerger <helly@php.net>                               |\n   +----------------------------------------------------------------------+\n */\n\n/* $Id$ */\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"php.h\"\n#include \"php_ini.h\"\n#include \"ext/standard/info.h\"\n#include \"ext/standard/file.h\"\n#include \"ext/standard/php_string.h\"\n#include \"zend_compile.h\"\n#include \"zend_exceptions.h\"\n#include \"zend_interfaces.h\"\n\n#include \"php_spl.h\"\n#include \"spl_functions.h\"\n#include \"spl_engine.h\"\n#include \"spl_iterators.h\"\n#include \"spl_directory.h\"\n#include \"spl_exceptions.h\"\n\n#include \"php.h\"\n#include \"fopen_wrappers.h\"\n\n#include \"ext/standard/basic_functions.h\"\n#include \"ext/standard/php_filestat.h\"\n\n#define SPL_HAS_FLAG(flags, test_flag) ((flags & test_flag) ? 1 : 0)\n\n/* declare the class handlers */\nstatic zend_object_handlers spl_filesystem_object_handlers;\n/* includes handler to validate object state when retrieving methods */\nstatic zend_object_handlers spl_filesystem_object_check_handlers;\n\n/* decalre the class entry */\nPHPAPI zend_class_entry *spl_ce_SplFileInfo;\nPHPAPI zend_class_entry *spl_ce_DirectoryIterator;\nPHPAPI zend_class_entry *spl_ce_FilesystemIterator;\nPHPAPI zend_class_entry *spl_ce_RecursiveDirectoryIterator;\nPHPAPI zend_class_entry *spl_ce_GlobIterator;\nPHPAPI zend_class_entry *spl_ce_SplFileObject;\nPHPAPI zend_class_entry *spl_ce_SplTempFileObject;\n\nstatic void spl_filesystem_file_free_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (intern->u.file.current_line) {\n\t\tefree(intern->u.file.current_line);\n\t\tintern->u.file.current_line = NULL;\n\t}\n\tif (intern->u.file.current_zval) {\n\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\tintern->u.file.current_zval = NULL;\n\t}\n} /* }}} */\n\nstatic void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)object;\n\n\tif (intern->oth_handler && intern->oth_handler->dtor) {\n\t\tintern->oth_handler->dtor(intern TSRMLS_CC);\n\t}\n\n\tzend_object_std_dtor(&intern->std TSRMLS_CC);\n\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\tswitch(intern->type) {\n\tcase SPL_FS_INFO:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.dirp) {\n\t\t\tphp_stream_close(intern->u.dir.dirp);\n\t\t\tintern->u.dir.dirp = NULL;\n\t\t}\n\t\tif (intern->u.dir.sub_path) {\n\t\t\tefree(intern->u.dir.sub_path);\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tif (intern->u.file.stream) {\n\t\t\tif (intern->u.file.zcontext) {\n/*\t\t\t\tzend_list_delref(Z_RESVAL_P(intern->zcontext));*/\n\t\t\t}\n\t\t\tif (!intern->u.file.stream->is_persistent) {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);\n\t\t\t} else {\n\t\t\t\tphp_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);\n\t\t\t}\n\t\t\tif (intern->u.file.open_mode) {\n\t\t\t\tefree(intern->u.file.open_mode);\n\t\t\t}\n\t\t\tif (intern->orig_path) {\n\t\t\t\tefree(intern->orig_path);\n\t\t\t}\n\t\t}\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tbreak;\n\t}\n\n\t{\n\t\tzend_object_iterator *iterator;\n\t\titerator = (zend_object_iterator*)\n\t\t\t\tspl_filesystem_object_to_iterator(intern);\n\t\tif (iterator->data != NULL) {\n\t\t\titerator->data = NULL;\n\t\t\titerator->funcs->dtor(iterator TSRMLS_CC);\n\t\t}\n\t}\n\tefree(object);\n} /* }}} */\n\n/* {{{ spl_ce_dir_object_new */\n/* creates the object by\n   - allocating memory\n   - initializing the object members\n   - storing the object\n   - setting it's handlers\n\n   called from\n   - clone\n   - new\n */\nstatic zend_object_value spl_filesystem_object_new_ex(zend_class_entry *class_type, spl_filesystem_object **obj TSRMLS_DC)\n{\n\tzend_object_value retval;\n\tspl_filesystem_object *intern;\n\n\tintern = emalloc(sizeof(spl_filesystem_object));\n\tmemset(intern, 0, sizeof(spl_filesystem_object));\n\t/* intern->type = SPL_FS_INFO; done by set 0 */\n\tintern->file_class = spl_ce_SplFileObject;\n\tintern->info_class = spl_ce_SplFileInfo;\n\tif (obj) *obj = intern;\n\n\tzend_object_std_init(&intern->std, class_type TSRMLS_CC);\n\tobject_properties_init(&intern->std, class_type);\n\n\tretval.handle = zend_objects_store_put(intern, (zend_objects_store_dtor_t) zend_objects_destroy_object, (zend_objects_free_object_storage_t) spl_filesystem_object_free_storage, NULL TSRMLS_CC);\n\tretval.handlers = &spl_filesystem_object_handlers;\n\treturn retval;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_object_new */\n/* See spl_filesystem_object_new_ex */\nstatic zend_object_value spl_filesystem_object_new(zend_class_entry *class_type TSRMLS_DC)\n{\n\treturn spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ spl_filesystem_object_new_ex */\nstatic zend_object_value spl_filesystem_object_new_check(zend_class_entry *class_type TSRMLS_DC)\n{\n\tzend_object_value ret = spl_filesystem_object_new_ex(class_type, NULL TSRMLS_CC);\n\tret.handlers = &spl_filesystem_object_check_handlers;\n\treturn ret;\n}\n/* }}} */\n\n\nPHPAPI char* spl_filesystem_object_get_path(spl_filesystem_object *intern, int *len TSRMLS_DC) /* {{{ */\n{\n#ifdef HAVE_GLOB\n\tif (intern->type == SPL_FS_DIR) {\n\t\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\t\treturn php_glob_stream_get_path(intern->u.dir.dirp, 0, len);\n\t\t}\n\t}\n#endif\n\tif (len) {\n\t\t*len = intern->_path_len;\n\t}\n\treturn intern->_path;\n} /* }}} */\n\nstatic inline void spl_filesystem_object_get_file_name(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\n\tswitch (intern->type) {\n\t\tcase SPL_FS_INFO:\n\t\tcase SPL_FS_FILE:\n\t\t\tif (!intern->file_name) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"Object not initialized\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SPL_FS_DIR:\n\t\t\tif (intern->file_name) {\n\t\t\t\tefree(intern->file_name);\n\t\t\t}\n\t\t\tintern->file_name_len = spprintf(&intern->file_name, 0, \"%s%c%s\",\n\t\t\t                                 spl_filesystem_object_get_path(intern, NULL TSRMLS_CC),\n\t\t\t                                 slash, intern->u.dir.entry.d_name);\n\t\t\tbreak;\n\t}\n} /* }}} */\n\nstatic int spl_filesystem_dir_read(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (!intern->u.dir.dirp || !php_stream_readdir(intern->u.dir.dirp, &intern->u.dir.entry)) {\n\t\tintern->u.dir.entry.d_name[0] = '\\0';\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\n#define IS_SLASH_AT(zs, pos) (IS_SLASH(zs[pos]))\n\nstatic inline int spl_filesystem_is_dot(const char * d_name) /* {{{ */\n{\n\treturn !strcmp(d_name, \".\") || !strcmp(d_name, \"..\");\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_open */\n/* open a directory resource */\nstatic void spl_filesystem_dir_open(spl_filesystem_object* intern, char *path TSRMLS_DC)\n{\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\n\tintern->type = SPL_FS_DIR;\n\tintern->_path_len = strlen(path);\n\tintern->u.dir.dirp = php_stream_opendir(path, REPORT_ERRORS, FG(default_context));\n\n\tif (intern->_path_len > 1 && IS_SLASH_AT(path, intern->_path_len-1)) {\n\t\tintern->_path = estrndup(path, --intern->_path_len);\n\t} else {\n\t\tintern->_path = estrndup(path, intern->_path_len);\n\t}\n\tintern->u.dir.index = 0;\n\n\tif (EG(exception) || intern->u.dir.dirp == NULL) {\n\t\tintern->u.dir.entry.d_name[0] = '\\0';\n\t\tif (!EG(exception)) {\n\t\t\t/* open failed w/out notice (turned to exception due to EH_THROW) */\n\t\t\tzend_throw_exception_ex(spl_ce_UnexpectedValueException, 0\n\t\t\t\tTSRMLS_CC, \"Failed to open directory \\\"%s\\\"\", path);\n\t\t}\n\t} else {\n\t\tdo {\n\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t}\n}\n/* }}} */\n\nstatic int spl_filesystem_file_open(spl_filesystem_object *intern, int use_include_path, int silent TSRMLS_DC) /* {{{ */\n{\n\tzval  tmp;\n\n\tintern->type = SPL_FS_FILE;\n\n\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_DIR, &tmp TSRMLS_CC);\n\tif (Z_LVAL(tmp)) {\n\t\tintern->u.file.open_mode = NULL;\n\t\tintern->file_name = NULL;\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Cannot use SplFileObject with directories\");\n\t\treturn FAILURE;\n\t}\n\n\tintern->u.file.context = php_stream_context_from_zval(intern->u.file.zcontext, 0);\n\tintern->u.file.stream = php_stream_open_wrapper_ex(intern->file_name, intern->u.file.open_mode, (use_include_path ? USE_PATH : 0) | REPORT_ERRORS, NULL, intern->u.file.context);\n\n\tif (!intern->file_name_len || !intern->u.file.stream) {\n\t\tif (!EG(exception)) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot open file '%s'\", intern->file_name_len ? intern->file_name : \"\");\n\t\t}\n\t\tintern->file_name = NULL; /* until here it is not a copy */\n\t\tintern->u.file.open_mode = NULL;\n\t\treturn FAILURE;\n\t}\n\n\tif (intern->u.file.zcontext) {\n\t\tzend_list_addref(Z_RESVAL_P(intern->u.file.zcontext));\n\t}\n\n\tif (intern->file_name_len > 1 && IS_SLASH_AT(intern->file_name, intern->file_name_len-1)) {\n\t\tintern->file_name_len--;\n\t}\n\n\tintern->orig_path = estrndup(intern->u.file.stream->orig_path, strlen(intern->u.file.stream->orig_path));\n\n\tintern->file_name = estrndup(intern->file_name, intern->file_name_len);\n\tintern->u.file.open_mode = estrndup(intern->u.file.open_mode, intern->u.file.open_mode_len);\n\n\t/* avoid reference counting in debug mode, thus do it manually */\n\tZVAL_RESOURCE(&intern->u.file.zresource, php_stream_get_resource_id(intern->u.file.stream));\n\tZ_SET_REFCOUNT(intern->u.file.zresource, 1);\n\n\tintern->u.file.delimiter = ',';\n\tintern->u.file.enclosure = '\"';\n\tintern->u.file.escape = '\\\\';\n\n\tzend_hash_find(&intern->std.ce->function_table, \"getcurrentline\", sizeof(\"getcurrentline\"), (void **) &intern->u.file.func_getCurr);\n\n\treturn SUCCESS;\n} /* }}} */\n\n/* {{{ spl_filesystem_object_clone */\n/* Local zend_object_value creation (on stack)\n   Load the 'other' object\n   Create a new empty object (See spl_filesystem_object_new_ex)\n   Open the directory\n   Clone other members (properties)\n */\nstatic zend_object_value spl_filesystem_object_clone(zval *zobject TSRMLS_DC)\n{\n\tzend_object_value new_obj_val;\n\tzend_object *old_object;\n\tzend_object *new_object;\n\tzend_object_handle handle = Z_OBJ_HANDLE_P(zobject);\n\tspl_filesystem_object *intern;\n\tspl_filesystem_object *source;\n\tint index, skip_dots;\n\n\told_object = zend_objects_get_address(zobject TSRMLS_CC);\n\tsource = (spl_filesystem_object*)old_object;\n\n\tnew_obj_val = spl_filesystem_object_new_ex(old_object->ce, &intern TSRMLS_CC);\n\tnew_object = &intern->std;\n\n\tintern->flags = source->flags;\n\n\tswitch (source->type) {\n\tcase SPL_FS_INFO:\n\t\tintern->_path_len = source->_path_len;\n\t\tintern->_path = estrndup(source->_path, source->_path_len);\n\t\tintern->file_name_len = source->file_name_len;\n\t\tintern->file_name = estrndup(source->file_name, intern->file_name_len);\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tspl_filesystem_dir_open(intern, source->_path TSRMLS_CC);\n\t\t/* read until we hit the position in which we were before */\n\t\tskip_dots = SPL_HAS_FLAG(source->flags, SPL_FILE_DIR_SKIPDOTS);\n\t\tfor(index = 0; index < source->u.dir.index; ++index) {\n\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}\n\n\treturn new_obj_val;\n}\n/* }}} */\n\nvoid spl_filesystem_info_set_filename(spl_filesystem_object *intern, char *path, int len, int use_copy TSRMLS_DC) /* {{{ */\n{\n\tchar *p1, *p2;\n\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t}\n\n\tintern->file_name = use_copy ? estrndup(path, len) : path;\n\tintern->file_name_len = len;\n\n\twhile(IS_SLASH_AT(intern->file_name, intern->file_name_len-1) && intern->file_name_len > 1) {\n\t\tintern->file_name[intern->file_name_len-1] = 0;\n\t\tintern->file_name_len--;\n\t}\n\n\tp1 = strrchr(intern->file_name, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\tp2 = strrchr(intern->file_name, '\\\\');\n#else\n\tp2 = 0;\n#endif\n\tif (p1 || p2) {\n\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - intern->file_name;\n\t} else {\n\t\tintern->_path_len = 0;\n\t}\n\n\tif (intern->_path) {\n\t\tefree(intern->_path);\n\t}\n\tintern->_path = estrndup(path, intern->_path_len);\n} /* }}} */\n\nstatic spl_filesystem_object * spl_filesystem_object_create_info(spl_filesystem_object *source, char *file_path, int file_path_len, int use_copy, zend_class_entry *ce, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tzval *arg1;\n\tzend_error_handling error_handling;\n\n\tif (!file_path || !file_path_len) {\n#if defined(PHP_WIN32)\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot create SplFileInfo for empty path\");\n\t\tif (file_path && !use_copy) {\n\t\t\tefree(file_path);\n\t\t}\n#else\n\t\tif (file_path && !use_copy) {\n\t\t\tefree(file_path);\n\t\t}\n\t\tfile_path_len = 1;\n\t\tfile_path = \"/\";\n#endif\n\t\treturn NULL;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tce = ce ? ce : source->info_class;\n\n\tzend_update_class_constants(ce TSRMLS_CC);\n\n\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} /* }}} */\n\nstatic spl_filesystem_object * spl_filesystem_object_create_type(int ht, spl_filesystem_object *source, int type, zend_class_entry *ce, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tzend_bool use_include_path = 0;\n\tzval *arg1, *arg2;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tswitch (source->type) {\n\tcase SPL_FS_INFO:\n\tcase SPL_FS_FILE:\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tif (!source->u.dir.entry.d_name[0]) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Could not open file\");\n\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase SPL_FS_INFO:\n\t\tce = ce ? ce : source->info_class;\n\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1);\n\t\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\t\tzval_ptr_dtor(&arg1);\n\t\t} else {\n\t\t\tintern->file_name = estrndup(source->file_name, source->file_name_len);\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tce = ce ? ce : source->file_class;\n\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tMAKE_STD_ZVAL(arg2);\n\t\t\tZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1);\n\t\t\tZVAL_STRINGL(arg2, \"r\", 1, 1);\n\t\t\tzend_call_method_with_2_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1, arg2);\n\t\t\tzval_ptr_dtor(&arg1);\n\t\t\tzval_ptr_dtor(&arg2);\n\t\t} else {\n\t\t\tintern->file_name = source->file_name;\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\n\t\t\tintern->u.file.open_mode = \"r\";\n\t\t\tintern->u.file.open_mode_len = 1;\n\n\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sbr\",\n\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len,\n\t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tintern->u.file.open_mode = NULL;\n\t\t\t\tintern->file_name = NULL;\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Operation not supported\");\n\t\treturn NULL;\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn NULL;\n} /* }}} */\n\nstatic int spl_filesystem_is_invalid_or_dot(const char * d_name) /* {{{ */\n{\n\treturn d_name[0] == '\\0' || spl_filesystem_is_dot(d_name);\n}\n/* }}} */\n\nstatic char *spl_filesystem_object_get_pathname(spl_filesystem_object *intern, int *len TSRMLS_DC) { /* {{{ */\n\tswitch (intern->type) {\n\tcase SPL_FS_INFO:\n\tcase SPL_FS_FILE:\n\t\t*len = intern->file_name_len;\n\t\treturn intern->file_name;\n\tcase SPL_FS_DIR:\n\t\tif (intern->u.dir.entry.d_name[0]) {\n\t\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\t\t*len = intern->file_name_len;\n\t\t\treturn intern->file_name;\n\t\t}\n\t}\n\t*len = 0;\n\treturn NULL;\n}\n/* }}} */\n\nstatic HashTable* spl_filesystem_object_get_debug_info(zval *obj, int *is_temp TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(obj TSRMLS_CC);\n\tHashTable *rv;\n\tzval *tmp, zrv;\n\tchar *pnstr, *path;\n\tint  pnlen, path_len;\n\tchar stmp[2];\n\n\t*is_temp = 1;\n\n\tif (!intern->std.properties) {\n\t\trebuild_object_properties(&intern->std);\n\t}\n\n\tALLOC_HASHTABLE(rv);\n\tZEND_INIT_SYMTABLE_EX(rv, zend_hash_num_elements(intern->std.properties) + 3, 0);\n\n\tINIT_PZVAL(&zrv);\n\tZ_ARRVAL(zrv) = rv;\n\n\tzend_hash_copy(rv, intern->std.properties, (copy_ctor_func_t) zval_add_ref, (void *) &tmp, sizeof(zval *));\n\n\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, \"pathName\", sizeof(\"pathName\")-1, &pnlen TSRMLS_CC);\n\tpath = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, path, path_len, 1);\n\tefree(pnstr);\n\n\tif (intern->file_name) {\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileInfo, \"fileName\", sizeof(\"fileName\")-1, &pnlen TSRMLS_CC);\n\t\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\t\tif (path_len && path_len < intern->file_name_len) {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n\t\t} else {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->file_name, intern->file_name_len, 1);\n\t\t}\n\t\tefree(pnstr);\n\t}\n\tif (intern->type == SPL_FS_DIR) {\n#ifdef HAVE_GLOB\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_DirectoryIterator, \"glob\", sizeof(\"glob\")-1, &pnlen TSRMLS_CC);\n\t\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->_path, intern->_path_len, 1);\n\t\t} else {\n\t\t\tadd_assoc_bool_ex(&zrv, pnstr, pnlen+1, 0);\n\t\t}\n\t\tefree(pnstr);\n#endif\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_RecursiveDirectoryIterator, \"subPathName\", sizeof(\"subPathName\")-1, &pnlen TSRMLS_CC);\n\t\tif (intern->u.dir.sub_path) {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t\t} else {\n\t\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, \"\", 0, 1);\n\t\t}\n\t\tefree(pnstr);\n\t}\n\tif (intern->type == SPL_FS_FILE) {\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileObject, \"openMode\", sizeof(\"openMode\")-1, &pnlen TSRMLS_CC);\n\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, intern->u.file.open_mode, intern->u.file.open_mode_len, 1);\n\t\tefree(pnstr);\n\t\tstmp[1] = '\\0';\n\t\tstmp[0] = intern->u.file.delimiter;\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileObject, \"delimiter\", sizeof(\"delimiter\")-1, &pnlen TSRMLS_CC);\n\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, stmp, 1, 1);\n\t\tefree(pnstr);\n\t\tstmp[0] = intern->u.file.enclosure;\n\t\tpnstr = spl_gen_private_prop_name(spl_ce_SplFileObject, \"enclosure\", sizeof(\"enclosure\")-1, &pnlen TSRMLS_CC);\n\t\tadd_assoc_stringl_ex(&zrv, pnstr, pnlen+1, stmp, 1, 1);\n\t\tefree(pnstr);\n\t}\n\n\treturn rv;\n}\n/* }}} */\n\nzend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}\n/* }}} */\n\n#define DIT_CTOR_FLAGS  0x00000001\n#define DIT_CTOR_GLOB   0x00000002\n\nvoid spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, long ctor_flags) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed, len;\n\tlong flags;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tif (intern->_path) {\n\t\t/* object is alreay initialized */\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob://\") != path) {\n\t\tspprintf(&path, 0, \"glob://%s\", path);\n\t\tspl_filesystem_dir_open(intern, path TSRMLS_CC);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path TSRMLS_CC);\n\n\t}\n\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator TSRMLS_CC) ? 1 : 0;\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::__construct(string path)\n Cronstructs a new dir iterator from a path. */\nSPL_METHOD(DirectoryIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::rewind()\n   Rewind dir back to the start */\nSPL_METHOD(DirectoryIterator, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index = 0;\n\tif (intern->u.dir.dirp) {\n\t\tphp_stream_rewinddir(intern->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(intern TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto string DirectoryIterator::key()\n   Return current dir entry */\nSPL_METHOD(DirectoryIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.dirp) {\n\t\tRETURN_LONG(intern->u.dir.index);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto DirectoryIterator DirectoryIterator::current()\n   Return this (needed for Iterator interface) */\nSPL_METHOD(DirectoryIterator, current)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tRETURN_ZVAL(getThis(), 1, 0);\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::next()\n   Move to next entry */\nSPL_METHOD(DirectoryIterator, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\tif (intern->file_name) {\n\t\tefree(intern->file_name);\n\t\tintern->file_name = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void DirectoryIterator::seek(int position)\n   Seek to the given position */\nSPL_METHOD(DirectoryIterator, seek)\n{\n\tspl_filesystem_object *intern    = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval                  *retval    = NULL;\n\tlong                   pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &pos) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.index > pos) {\n\t\t/* we first rewind */\n\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.dir.func_rewind, \"rewind\", &retval);\n\t\tif (retval) {\n\t\t\tzval_ptr_dtor(&retval);\n\t\t\tretval = NULL;\n\t\t}\n\t}\n\n\twhile (intern->u.dir.index < pos) {\n\t\tint valid = 0;\n\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.dir.func_valid, \"valid\", &retval);\n\t\tif (retval) {\n\t\t\tvalid = zend_is_true(retval);\n\t\t\tzval_ptr_dtor(&retval);\n\t\t\tretval = NULL;\n\t\t}\n\t\tif (!valid) {\n\t\t\tbreak;\n\t\t}\n\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.dir.func_next, \"next\", &retval);\n\t\tif (retval) {\n\t\t\tzval_ptr_dtor(&retval);\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ proto string DirectoryIterator::valid()\n   Check whether dir contains more entries */\nSPL_METHOD(DirectoryIterator, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(intern->u.dir.entry.d_name[0] != '\\0');\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getPath()\n   Return the path */\nSPL_METHOD(SplFileInfo, getPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *path;\n\tint path_len;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n  \tpath = spl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\tRETURN_STRINGL(path, path_len, 1);\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getFilename()\n   Return filename only */\nSPL_METHOD(SplFileInfo, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint path_len;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tRETURN_STRINGL(intern->file_name + path_len + 1, intern->file_name_len - (path_len + 1), 1);\n\t} else {\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string DirectoryIterator::getFilename()\n   Return filename of current dir entry */\nSPL_METHOD(DirectoryIterator, getFilename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getExtension()\n   Returns file extension component of path */\nSPL_METHOD(SplFileInfo, getExtension)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *fname = NULL;\n\tconst char *p;\n\tsize_t flen;\n\tint path_len, idx;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tfname = intern->file_name + path_len + 1;\n\t\tflen = intern->file_name_len - (path_len + 1);\n\t} else {\n\t\tfname = intern->file_name;\n\t\tflen = intern->file_name_len;\n\t}\n\n\tphp_basename(fname, flen, NULL, 0, &fname, &flen TSRMLS_CC);\n\n\tp = zend_memrchr(fname, '.', flen);\n\tif (p) {\n\t\tidx = p - fname;\n\t\tRETVAL_STRINGL(fname + idx + 1, flen - idx - 1, 1);\n\t\tefree(fname);\n\t\treturn;\n\t} else {\n\t\tif (fname) {\n\t\t\tefree(fname);\n\t\t}\n\t\tRETURN_EMPTY_STRING();\n\t}\n}\n/* }}}*/\n\n/* {{{ proto string DirectoryIterator::getExtension()\n   Returns the file extension component of path */\nSPL_METHOD(DirectoryIterator, getExtension)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *fname = NULL;\n\tconst char *p;\n\tsize_t flen;\n\tint idx;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_basename(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), NULL, 0, &fname, &flen TSRMLS_CC);\n\n\tp = zend_memrchr(fname, '.', flen);\n\tif (p) {\n\t\tidx = p - fname;\n\t\tRETVAL_STRINGL(fname + idx + 1, flen - idx - 1, 1);\n\t\tefree(fname);\n\t\treturn;\n\t} else {\n\t\tif (fname) {\n\t\t\tefree(fname);\n\t\t}\n\t\tRETURN_EMPTY_STRING();\n\t}\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getBasename([string $suffix]) U\n   Returns filename component of path */\nSPL_METHOD(SplFileInfo, getBasename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *fname, *suffix = 0;\n\tsize_t flen;\n\tint slen = 0, path_len;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &suffix, &slen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_path(intern, &path_len TSRMLS_CC);\n\n\tif (path_len && path_len < intern->file_name_len) {\n\t\tfname = intern->file_name + path_len + 1;\n\t\tflen = intern->file_name_len - (path_len + 1);\n\t} else {\n\t\tfname = intern->file_name;\n\t\tflen = intern->file_name_len;\n\t}\n\n\tphp_basename(fname, flen, suffix, slen, &fname, &flen TSRMLS_CC);\n\n\tRETURN_STRINGL(fname, flen, 0);\n}\n/* }}}*/\n\n/* {{{ proto string DirectoryIterator::getBasename([string $suffix]) U\n   Returns filename component of current dir entry */\nSPL_METHOD(DirectoryIterator, getBasename)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *suffix = 0, *fname;\n\tint slen = 0;\n\tsize_t flen;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|s\", &suffix, &slen) == FAILURE) {\n\t\treturn;\n\t}\n\n\tphp_basename(intern->u.dir.entry.d_name, strlen(intern->u.dir.entry.d_name), suffix, slen, &fname, &flen TSRMLS_CC);\n\n\tRETURN_STRINGL(fname, flen, 0);\n}\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getPathname()\n   Return path and filename */\nSPL_METHOD(SplFileInfo, getPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *path;\n\tint path_len;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\tpath = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\tif (path != NULL) {\n\t\tRETURN_STRINGL(path, path_len, 1);\n\t} else {\n\t\tRETURN_FALSE;\n\t}\n}\n/* }}} */\n\n/* {{{ proto string FilesystemIterator::key()\n   Return getPathname() or getFilename() depending on flags */\nSPL_METHOD(FilesystemIterator, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_KEY(intern, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto string FilesystemIterator::current()\n   Return getFilename(), getFileInfo() or $this depending on flags */\nSPL_METHOD(FilesystemIterator, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tRETURN_STRINGL(intern->file_name, intern->file_name_len, 1);\n\t} else if (SPL_FILE_DIR_CURRENT(intern, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tspl_filesystem_object_create_type(0, intern, SPL_FS_INFO, NULL, return_value TSRMLS_CC);\n\t} else {\n\t\tRETURN_ZVAL(getThis(), 1, 0);\n\t\t/*RETURN_STRING(intern->u.dir.entry.d_name, 1);*/\n\t}\n}\n/* }}} */\n\n/* {{{ proto bool DirectoryIterator::isDot()\n   Returns true if current entry is '.' or  '..' */\nSPL_METHOD(DirectoryIterator, isDot)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}\n/* }}} */\n\n/* {{{ proto void SplFileInfo::__construct(string file_name)\n Cronstructs a new SplFileInfo from a path. */\n/* zend_replace_error_handling() is used to throw exceptions in case\n   the constructor fails. Here we use this to ensure the object\n   has a valid directory resource.\n\n   When the constructor gets called the object is already created\n   by the engine, so we must only call 'additional' initializations.\n */\nSPL_METHOD(SplFileInfo, __construct)\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &path, &len) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tintern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tspl_filesystem_info_set_filename(intern, path, len, 1 TSRMLS_CC);\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n\t/* intern->type = SPL_FS_INFO; already set */\n}\n/* }}} */\n\n/* {{{ FileInfoFunction */\n#define FileInfoFunction(func_name, func_num) \\\nSPL_METHOD(SplFileInfo, func_name) \\\n{ \\\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\\n\tzend_error_handling error_handling; \\\n\tif (zend_parse_parameters_none() == FAILURE) { \\\n\t\treturn; \\\n\t} \\\n \\\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\\\n\tspl_filesystem_object_get_file_name(intern TSRMLS_CC); \\\n\tphp_stat(intern->file_name, intern->file_name_len, func_num, return_value TSRMLS_CC); \\\n\tzend_restore_error_handling(&error_handling TSRMLS_CC); \\\n}\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getPerms()\n   Get file permissions */\nFileInfoFunction(getPerms, FS_PERMS)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getInode()\n   Get file inode */\nFileInfoFunction(getInode, FS_INODE)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getSize()\n   Get file size */\nFileInfoFunction(getSize, FS_SIZE)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getOwner()\n   Get file owner */\nFileInfoFunction(getOwner, FS_OWNER)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getGroup()\n   Get file group */\nFileInfoFunction(getGroup, FS_GROUP)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getATime()\n   Get last access time of file */\nFileInfoFunction(getATime, FS_ATIME)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getMTime()\n   Get last modification time of file */\nFileInfoFunction(getMTime, FS_MTIME)\n/* }}} */\n\n/* {{{ proto int SplFileInfo::getCTime()\n   Get inode modification time of file */\nFileInfoFunction(getCTime, FS_CTIME)\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getType()\n   Get file type */\nFileInfoFunction(getType, FS_TYPE)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isWritable()\n   Returns true if file can be written */\nFileInfoFunction(isWritable, FS_IS_W)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isReadable()\n   Returns true if file can be read */\nFileInfoFunction(isReadable, FS_IS_R)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isExecutable()\n   Returns true if file is executable */\nFileInfoFunction(isExecutable, FS_IS_X)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isFile()\n   Returns true if file is a regular file */\nFileInfoFunction(isFile, FS_IS_FILE)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isDir()\n   Returns true if file is directory */\nFileInfoFunction(isDir, FS_IS_DIR)\n/* }}} */\n\n/* {{{ proto bool SplFileInfo::isLink()\n   Returns true if file is symbolic link */\nFileInfoFunction(isLink, FS_IS_LINK)\n/* }}} */\n\n/* {{{ proto string SplFileInfo::getLinkTarget() U\n   Return the target of a symbolic link */\nSPL_METHOD(SplFileInfo, getLinkTarget)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint ret;\n\tchar buff[MAXPATHLEN];\n\tzend_error_handling error_handling;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n#if defined(PHP_WIN32) || HAVE_SYMLINK\n\tif (intern->file_name == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename\");\n\t\tRETURN_FALSE;\n\t} else if (!IS_ABSOLUTE_PATH(intern->file_name, intern->file_name_len)) {\n\t\tchar expanded_path[MAXPATHLEN];\n\t\tif (!expand_filepath_with_mode(intern->file_name, expanded_path, NULL, 0, CWD_EXPAND  TSRMLS_CC)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"No such file or directory\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tret = php_sys_readlink(expanded_path, buff, MAXPATHLEN - 1);\n\t} else {\n\t\tret = php_sys_readlink(intern->file_name, buff,  MAXPATHLEN-1);\n\t}\n#else\n\tret = -1; /* always fail if not implemented */\n#endif\n\n\tif (ret == -1) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Unable to read link %s, error: %s\", intern->file_name, strerror(errno));\n\t\tRETVAL_FALSE;\n\t} else {\n\t\t/* Append NULL to the end of the string */\n\t\tbuff[ret] = '\\0';\n\n\t\tRETVAL_STRINGL(buff, ret, 1);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n/* {{{ proto string SplFileInfo::getRealPath()\n   Return the resolved path */\nSPL_METHOD(SplFileInfo, getRealPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buff[MAXPATHLEN];\n\tchar *filename;\n\tzend_error_handling error_handling;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (intern->type == SPL_FS_DIR && !intern->file_name && intern->u.dir.entry.d_name[0]) {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t}\n\n\tif (intern->orig_path) {\n\t\tfilename = intern->orig_path;\n\t} else {\n\t\tfilename = intern->file_name;\n\t}\n\n\n\tif (filename && VCWD_REALPATH(filename, buff)) {\n#ifdef ZTS\n\t\tif (VCWD_ACCESS(buff, F_OK)) {\n\t\t\tRETVAL_FALSE;\n\t\t} else\n#endif\n\t\tRETVAL_STRING(buff, 1);\n\t} else {\n\t\tRETVAL_FALSE;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n#endif\n\n/* {{{ proto SplFileObject SplFileInfo::openFile([string mode = 'r' [, bool use_include_path  [, resource context]]])\n   Open the current file */\nSPL_METHOD(SplFileInfo, openFile)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tspl_filesystem_object_create_type(ht, intern, SPL_FS_FILE, NULL, return_value TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void SplFileInfo::setFileClass([string class_name])\n   Class to use in openFile() */\nSPL_METHOD(SplFileInfo, setFileClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileObject;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->file_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto void SplFileInfo::setInfoClass([string class_name])\n   Class to use in getFileInfo(), getPathInfo() */\nSPL_METHOD(SplFileInfo, setInfoClass)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = spl_ce_SplFileInfo;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tintern->info_class = ce;\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto SplFileInfo SplFileInfo::getFileInfo([string $class_name])\n   Get/copy file info */\nSPL_METHOD(SplFileInfo, getFileInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tspl_filesystem_object_create_type(ht, intern, SPL_FS_INFO, ce, return_value TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ proto SplFileInfo SplFileInfo::getPathInfo([string $class_name])\n   Get/copy file info */\nSPL_METHOD(SplFileInfo, getPathInfo)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_class_entry *ce = intern->info_class;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|C\", &ce) == SUCCESS) {\n\t\tint path_len;\n\t\tchar *path = spl_filesystem_object_get_pathname(intern, &path_len TSRMLS_CC);\n\t\tif (path) {\n\t\t\tchar *dpath = estrndup(path, path_len);\n\t\t\tpath_len = php_dirname(dpath, path_len);\n\t\t\tspl_filesystem_object_create_info(intern, dpath, path_len, 1, ce, return_value TSRMLS_CC);\n\t\t\tefree(dpath);\n\t\t}\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ */\nSPL_METHOD(SplFileInfo, _bad_state_ex)\n{\n\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC,\n\t\t\"The parent constructor was not called: the object is in an \"\n\t\t\"invalid state \");\n}\n/* }}} */\n\n/* {{{ proto void FilesystemIterator::__construct(string path [, int flags])\n Cronstructs a new dir iterator from a path. */\nSPL_METHOD(FilesystemIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIT_CTOR_FLAGS | SPL_FILE_DIR_SKIPDOTS);\n}\n/* }}} */\n\n/* {{{ proto void FilesystemIterator::rewind()\n   Rewind dir back to the start */\nSPL_METHOD(FilesystemIterator, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tint skip_dots = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_SKIPDOTS);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->u.dir.index = 0;\n\tif (intern->u.dir.dirp) {\n\t\tphp_stream_rewinddir(intern->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n}\n/* }}} */\n\n/* {{{ proto int FilesystemIterator::getFlags()\n   Get handling flags */\nSPL_METHOD(FilesystemIterator, getFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->flags & (SPL_FILE_DIR_KEY_MODE_MASK | SPL_FILE_DIR_CURRENT_MODE_MASK | SPL_FILE_DIR_OTHERS_MASK));\n} /* }}} */\n\n/* {{{ proto void FilesystemIterator::setFlags(long $flags)\n   Set handling flags */\nSPL_METHOD(FilesystemIterator, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong flags;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &flags) == FAILURE) {\n\t\treturn;\n\t}\n\n\tintern->flags &= ~(SPL_FILE_DIR_KEY_MODE_MASK|SPL_FILE_DIR_CURRENT_MODE_MASK|SPL_FILE_DIR_OTHERS_MASK);\n\tintern->flags |= ((SPL_FILE_DIR_KEY_MODE_MASK|SPL_FILE_DIR_CURRENT_MODE_MASK|SPL_FILE_DIR_OTHERS_MASK) & flags);\n} /* }}} */\n\n/* {{{ proto bool RecursiveDirectoryIterator::hasChildren([bool $allow_links = false])\n   Returns whether current entry is a directory and not '.' or '..' */\nSPL_METHOD(RecursiveDirectoryIterator, hasChildren)\n{\n\tzend_bool allow_links = 0;\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|b\", &allow_links) == FAILURE) {\n\t\treturn;\n\t}\n\tif (spl_filesystem_is_invalid_or_dot(intern->u.dir.entry.d_name)) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\t\tif (!allow_links && !(intern->flags & SPL_FILE_DIR_FOLLOW_SYMLINKS)) {\n\t\t\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_LINK, return_value TSRMLS_CC);\n\t\t\tif (zend_is_true(return_value)) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\t\tphp_stat(intern->file_name, intern->file_name_len, FS_IS_DIR, return_value TSRMLS_CC);\n    }\n}\n/* }}} */\n\n/* {{{ proto RecursiveDirectoryIterator DirectoryIterator::getChildren()\n   Returns an iterator for the current entry if it is a directory */\nSPL_METHOD(RecursiveDirectoryIterator, getChildren)\n{\n\tzval *zpath, *zflags;\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tspl_filesystem_object *subdir;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_object_get_file_name(intern TSRMLS_CC);\n\n\tMAKE_STD_ZVAL(zflags);\n\tMAKE_STD_ZVAL(zpath);\n\tZVAL_LONG(zflags, intern->flags);\n\tZVAL_STRINGL(zpath, intern->file_name, intern->file_name_len, 1);\n\tspl_instantiate_arg_ex2(Z_OBJCE_P(getThis()), &return_value, 0, zpath, zflags TSRMLS_CC);\n\tzval_ptr_dtor(&zpath);\n\tzval_ptr_dtor(&zflags);\n\n\tsubdir = (spl_filesystem_object*)zend_object_store_get_object(return_value TSRMLS_CC);\n\tif (subdir) {\n\t\tif (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {\n\t\t\tsubdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\t} else {\n\t\t\tsubdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);\n\t\t\tsubdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);\n\t\t}\n\t\tsubdir->info_class = intern->info_class;\n\t\tsubdir->file_class = intern->file_class;\n\t\tsubdir->oth = intern->oth;\n\t}\n}\n/* }}} */\n\n/* {{{ proto void RecursiveDirectoryIterator::getSubPath()\n   Get sub path */\nSPL_METHOD(RecursiveDirectoryIterator, getSubPath)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tRETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);\n\t} else {\n\t\tRETURN_STRINGL(\"\", 0, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void RecursiveDirectoryIterator::getSubPathname()\n   Get sub path and file name */\nSPL_METHOD(RecursiveDirectoryIterator, getSubPathname)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *sub_name;\n\tint len;\n\tchar slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (intern->u.dir.sub_path) {\n\t\tlen = spprintf(&sub_name, 0, \"%s%c%s\", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);\n\t\tRETURN_STRINGL(sub_name, len, 0);\n\t} else {\n\t\tRETURN_STRING(intern->u.dir.entry.d_name, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int RecursiveDirectoryIterator::__construct(string path [, int flags])\n Cronstructs a new dir iterator from a path. */\nSPL_METHOD(RecursiveDirectoryIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIT_CTOR_FLAGS);\n}\n/* }}} */\n\n#ifdef HAVE_GLOB\n/* {{{ proto int GlobIterator::__construct(string path [, int flags])\n Cronstructs a new dir iterator from a glob expression (no glob:// needed). */\nSPL_METHOD(GlobIterator, __construct)\n{\n\tspl_filesystem_object_construct(INTERNAL_FUNCTION_PARAM_PASSTHRU, DIT_CTOR_FLAGS|DIT_CTOR_GLOB);\n}\n/* }}} */\n\n/* {{{ proto int GlobIterator::cont()\n   Return the number of directories and files found by globbing */\nSPL_METHOD(GlobIterator, count)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (php_stream_is(intern->u.dir.dirp ,&php_glob_stream_ops)) {\n\t\tRETURN_LONG(php_glob_stream_get_count(intern->u.dir.dirp, NULL));\n\t} else {\n\t\t/* should not happen */\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"GlobIterator lost glob state\");\n\t}\n}\n/* }}} */\n#endif /* HAVE_GLOB */\n\n/* {{{ forward declarations to the iterator handlers */\nstatic void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC);\nstatic int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC);\nstatic void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC);\nstatic void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC);\nstatic void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC);\nstatic void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC);\n\n/* iterator handler table */\nzend_object_iterator_funcs spl_filesystem_dir_it_funcs = {\n\tspl_filesystem_dir_it_dtor,\n\tspl_filesystem_dir_it_valid,\n\tspl_filesystem_dir_it_current_data,\n\tspl_filesystem_dir_it_current_key,\n\tspl_filesystem_dir_it_move_forward,\n\tspl_filesystem_dir_it_rewind\n};\n/* }}} */\n\n/* {{{ spl_ce_dir_get_iterator */\nzend_object_iterator *spl_filesystem_dir_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object   *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\t/* initialize iterator if it wasn't gotten before */\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_dir_it_funcs;\n\t\t/* ->current must be initialized; rewind doesn't set it and valid\n\t\t * doesn't check whether it's set */\n\t\titerator->current = object;\n\t}\n\tzval_add_ref(&object);\n\n\treturn (zend_object_iterator*)iterator;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_dtor */\nstatic void spl_filesystem_dir_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\tif (iterator->intern.data) {\n\t\tzval *object =  iterator->intern.data;\n\t\tzval_ptr_dtor(&object);\n\t}\n\t/* Otherwise we were called from the owning object free storage handler as\n\t * it sets\n\t * iterator->intern.data to NULL.\n\t * We don't even need to destroy iterator->current as we didn't add a\n\t * reference to it in move_forward or get_iterator */\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_valid */\nstatic int spl_filesystem_dir_it_valid(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\treturn object->u.dir.entry.d_name[0] != '\\0' ? SUCCESS : FAILURE;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_current_data */\nstatic void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\t*data = &iterator->current;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_current_key */\nstatic void spl_filesystem_dir_it_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tZVAL_LONG(key, object->u.dir.index);\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_move_forward */\nstatic void spl_filesystem_dir_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tobject->u.dir.index++;\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_dir_it_rewind */\nstatic void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tspl_filesystem_dir_read(object TSRMLS_CC);\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_dtor */\nstatic void spl_filesystem_tree_it_dtor(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\n\tif (iterator->intern.data) {\n\t\tzval *object = \titerator->intern.data;\n\t\tzval_ptr_dtor(&object);\n\t} else {\n\t\tif (iterator->current) {\n\t\t\tzval_ptr_dtor(&iterator->current);\n\t\t}\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_current_data */\nstatic void spl_filesystem_tree_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\n\tif (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_PATHNAME)) {\n\t\tif (!iterator->current) {\n\t\t\tALLOC_INIT_ZVAL(iterator->current);\n\t\t\tspl_filesystem_object_get_file_name(object TSRMLS_CC);\n\t\t\tZVAL_STRINGL(iterator->current, object->file_name, object->file_name_len, 1);\n\t\t}\n\t\t*data = &iterator->current;\n\t} else if (SPL_FILE_DIR_CURRENT(object, SPL_FILE_DIR_CURRENT_AS_FILEINFO)) {\n\t\tif (!iterator->current) {\n\t\t\tALLOC_INIT_ZVAL(iterator->current);\n\t\t\tspl_filesystem_object_get_file_name(object TSRMLS_CC);\n\t\t\tspl_filesystem_object_create_type(0, object, SPL_FS_INFO, NULL, iterator->current TSRMLS_CC);\n\t\t}\n\t\t*data = &iterator->current;\n\t} else {\n\t\t*data = (zval**)&iterator->intern.data;\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_current_key */\nstatic void spl_filesystem_tree_it_current_key(zend_object_iterator *iter, zval *key TSRMLS_DC)\n{\n\tspl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);\n\n\tif (SPL_FILE_DIR_KEY(object, SPL_FILE_DIR_KEY_AS_FILENAME)) {\n\t\tZVAL_STRING(key, object->u.dir.entry.d_name, 1);\n\t} else {\n\t\tspl_filesystem_object_get_file_name(object TSRMLS_CC);\n\t\tZVAL_STRINGL(key, object->file_name, object->file_name_len, 1);\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_move_forward */\nstatic void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\n\tobject->u.dir.index++;\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (object->file_name) {\n\t\tefree(object->file_name);\n\t\tobject->file_name = NULL;\n\t}\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ spl_filesystem_tree_it_rewind */\nstatic void spl_filesystem_tree_it_rewind(zend_object_iterator *iter TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;\n\tspl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);\n\n\tobject->u.dir.index = 0;\n\tif (object->u.dir.dirp) {\n\t\tphp_stream_rewinddir(object->u.dir.dirp);\n\t}\n\tdo {\n\t\tspl_filesystem_dir_read(object TSRMLS_CC);\n\t} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));\n\tif (iterator->current) {\n\t\tzval_ptr_dtor(&iterator->current);\n\t\titerator->current = NULL;\n\t}\n}\n/* }}} */\n\n/* {{{ iterator handler table */\nzend_object_iterator_funcs spl_filesystem_tree_it_funcs = {\n\tspl_filesystem_tree_it_dtor,\n\tspl_filesystem_dir_it_valid,\n\tspl_filesystem_tree_it_current_data,\n\tspl_filesystem_tree_it_current_key,\n\tspl_filesystem_tree_it_move_forward,\n\tspl_filesystem_tree_it_rewind\n};\n/* }}} */\n\n/* {{{ spl_ce_dir_get_iterator */\nzend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC)\n{\n\tspl_filesystem_iterator *iterator;\n\tspl_filesystem_object *dir_object;\n\n\tif (by_ref) {\n\t\tzend_error(E_ERROR, \"An iterator cannot be used with foreach by reference\");\n\t}\n\tdir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC);\n\titerator   = spl_filesystem_object_to_iterator(dir_object);\n\n\t/* initialize iterator if wasn't gotten before */\n\tif (iterator->intern.data == NULL) {\n\t\titerator->intern.data = object;\n\t\titerator->intern.funcs = &spl_filesystem_tree_it_funcs;\n\t}\n\tzval_add_ref(&object);\n\n\treturn (zend_object_iterator*)iterator;\n}\n/* }}} */\n\n/* {{{ spl_filesystem_object_cast */\nstatic int spl_filesystem_object_cast(zval *readobj, zval *writeobj, int type TSRMLS_DC)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(readobj TSRMLS_CC);\n\n\tif (type == IS_STRING) {\n\t\tif (Z_OBJCE_P(readobj)->__tostring) {\n\t\t\treturn std_object_handlers.cast_object(readobj, writeobj, type TSRMLS_CC);\n\t\t}\n\n\t\tswitch (intern->type) {\n\t\tcase SPL_FS_INFO:\n\t\tcase SPL_FS_FILE:\n\t\t\tif (readobj == writeobj) {\n\t\t\t\tzval retval;\n\t\t\t\tzval *retval_ptr = &retval;\n\n\t\t\t\tZVAL_STRINGL(retval_ptr, intern->file_name, intern->file_name_len, 1);\n\t\t\t\tzval_dtor(readobj);\n\t\t\t\tZVAL_ZVAL(writeobj, retval_ptr, 0, 0);\n\t\t\t} else {\n\t\t\t\tZVAL_STRINGL(writeobj, intern->file_name, intern->file_name_len, 1);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\tcase SPL_FS_DIR:\n\t\t\tif (readobj == writeobj) {\n\t\t\t\tzval retval;\n\t\t\t\tzval *retval_ptr = &retval;\n\n\t\t\t\tZVAL_STRING(retval_ptr, intern->u.dir.entry.d_name, 1);\n\t\t\t\tzval_dtor(readobj);\n\t\t\t\tZVAL_ZVAL(writeobj, retval_ptr, 0, 0);\n\t\t\t} else {\n\t\t\t\tZVAL_STRING(writeobj, intern->u.dir.entry.d_name, 1);\n\t\t\t}\n\t\t\treturn SUCCESS;\n\t\t}\n\t} else if (type == IS_BOOL) {\n\t\tZVAL_BOOL(writeobj, 1);\n\t\treturn SUCCESS;\n\t}\n\tif (readobj == writeobj) {\n\t\tzval_dtor(readobj);\n\t}\n\tZVAL_NULL(writeobj);\n\treturn FAILURE;\n}\n/* }}} */\n\n/* {{{ declare method parameters */\n/* supply a name and default to call by parameter */\nZEND_BEGIN_ARG_INFO(arginfo_info___construct, 0)\n\tZEND_ARG_INFO(0, file_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_info_openFile, 0, 0, 0)\n\tZEND_ARG_INFO(0, open_mode)\n\tZEND_ARG_INFO(0, use_include_path)\n\tZEND_ARG_INFO(0, context)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_info_optinalFileClass, 0, 0, 0)\n\tZEND_ARG_INFO(0, class_name)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_optinalSuffix, 0, 0, 0)\n\tZEND_ARG_INFO(0, suffix)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_splfileinfo_void, 0)\nZEND_END_ARG_INFO()\n\n/* the method table */\n/* each method can have its own parameters and visibility */\nstatic const zend_function_entry spl_SplFileInfo_functions[] = {\n\tSPL_ME(SplFileInfo,       __construct,   arginfo_info___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPath,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getFilename,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getExtension,  arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getBasename,   arginfo_optinalSuffix, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPathname,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPerms,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getInode,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getSize,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getOwner,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getGroup,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getATime,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getMTime,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getCTime,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getType,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isWritable,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isReadable,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isExecutable,  arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isFile,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isDir,         arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       isLink,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getLinkTarget, arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n#if (!defined(__BEOS__) && !defined(NETWARE) && HAVE_REALPATH) || defined(ZTS)\n\tSPL_ME(SplFileInfo,       getRealPath,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n#endif\n\tSPL_ME(SplFileInfo,       getFileInfo,   arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       getPathInfo,   arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       openFile,      arginfo_info_openFile,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       setFileClass,  arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       setInfoClass,  arginfo_info_optinalFileClass, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileInfo,       _bad_state_ex, NULL,\t\t\t\t\t\t\tZEND_ACC_PUBLIC|ZEND_ACC_FINAL)\n\tSPL_MA(SplFileInfo,       __toString, SplFileInfo, getPathname, arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nZEND_BEGIN_ARG_INFO(arginfo_dir___construct, 0)\n\tZEND_ARG_INFO(0, path)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_dir_it_seek, 0)\n\tZEND_ARG_INFO(0, position)\nZEND_END_ARG_INFO();\n\n/* the method table */\n/* each method can have its own parameters and visibility */\nstatic const zend_function_entry spl_DirectoryIterator_functions[] = {\n\tSPL_ME(DirectoryIterator, __construct,   arginfo_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, getFilename,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, getExtension,  arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, getBasename,   arginfo_optinalSuffix, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, isDot,         arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, rewind,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, valid,         arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, key,           arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, current,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, next,          arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator, seek,          arginfo_dir_it_seek, ZEND_ACC_PUBLIC)\n\tSPL_MA(DirectoryIterator, __toString, DirectoryIterator, getFilename, arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir___construct, 0, 0, 1)\n\tZEND_ARG_INFO(0, path)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir_hasChildren, 0, 0, 0)\n\tZEND_ARG_INFO(0, allow_links)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_r_dir_setFlags, 0, 0, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_FilesystemIterator_functions[] = {\n\tSPL_ME(FilesystemIterator, __construct,   arginfo_r_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, rewind,        arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(DirectoryIterator,  next,          arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, key,           arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, current,       arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, getFlags,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(FilesystemIterator, setFlags,      arginfo_r_dir_setFlags, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nstatic const zend_function_entry spl_RecursiveDirectoryIterator_functions[] = {\n\tSPL_ME(RecursiveDirectoryIterator, __construct,   arginfo_r_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, hasChildren,   arginfo_r_dir_hasChildren, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, getChildren,   arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, getSubPath,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_ME(RecursiveDirectoryIterator, getSubPathname,arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\n#ifdef HAVE_GLOB\nstatic const zend_function_entry spl_GlobIterator_functions[] = {\n\tSPL_ME(GlobIterator, __construct,   arginfo_r_dir___construct, ZEND_ACC_PUBLIC)\n\tSPL_ME(GlobIterator, count,         arginfo_splfileinfo_void,  ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n#endif\n/* }}} */\n\nstatic int spl_filesystem_file_read(spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tchar *buf;\n\tsize_t line_len = 0;\n\tlong line_add = (intern->u.file.current_line || intern->u.file.current_zval) ? 1 : 0;\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\n\tif (php_stream_eof(intern->u.file.stream)) {\n\t\tif (!silent) {\n\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file %s\", intern->file_name);\n\t\t}\n\t\treturn FAILURE;\n\t}\n\n\tif (intern->u.file.max_line_len > 0) {\n\t\tbuf = safe_emalloc((intern->u.file.max_line_len + 1), sizeof(char), 0);\n\t\tif (php_stream_get_line(intern->u.file.stream, buf, intern->u.file.max_line_len + 1, &line_len) == NULL) {\n\t\t\tefree(buf);\n\t\t\tbuf = NULL;\n\t\t} else {\n\t\t\tbuf[line_len] = '\\0';\n\t\t}\n\t} else {\n\t\tbuf = php_stream_get_line(intern->u.file.stream, NULL, 0, &line_len);\n\t}\n\n\tif (!buf) {\n\t\tintern->u.file.current_line = estrdup(\"\");\n\t\tintern->u.file.current_line_len = 0;\n\t} else {\n\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_DROP_NEW_LINE)) {\n\t\t\tline_len = strcspn(buf, \"\\r\\n\");\n\t\t\tbuf[line_len] = '\\0';\n\t\t}\n\n\t\tintern->u.file.current_line = buf;\n\t\tintern->u.file.current_line_len = line_len;\n\t}\n\tintern->u.file.current_line_num += line_add;\n\n\treturn SUCCESS;\n} /* }}} */\n\nstatic int spl_filesystem_file_call(spl_filesystem_object *intern, zend_function *func_ptr, int pass_num_args, zval *return_value, zval *arg2 TSRMLS_DC) /* {{{ */\n{\n\tzend_fcall_info fci;\n\tzend_fcall_info_cache fcic;\n\tzval z_fname;\n\tzval * zresource_ptr = &intern->u.file.zresource, *retval;\n\tint result;\n\tint num_args = pass_num_args + (arg2 ? 2 : 1);\n\n\tzval ***params = (zval***)safe_emalloc(num_args, sizeof(zval**), 0);\n\n\tparams[0] = &zresource_ptr;\n\n\tif (arg2) {\n\t\tparams[1] = &arg2;\n\t}\n\n\tzend_get_parameters_array_ex(pass_num_args, params+(arg2 ? 2 : 1));\n\n\tZVAL_STRING(&z_fname, func_ptr->common.function_name, 0);\n\n\tfci.size = sizeof(fci);\n\tfci.function_table = EG(function_table);\n\tfci.object_ptr = NULL;\n\tfci.function_name = &z_fname;\n\tfci.retval_ptr_ptr = &retval;\n\tfci.param_count = num_args;\n\tfci.params = params;\n\tfci.no_separation = 1;\n\tfci.symbol_table = NULL;\n\n\tfcic.initialized = 1;\n\tfcic.function_handler = func_ptr;\n\tfcic.calling_scope = NULL;\n\tfcic.called_scope = NULL;\n\tfcic.object_ptr = NULL;\n\n\tresult = zend_call_function(&fci, &fcic TSRMLS_CC);\n\n\tif (result == FAILURE) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tZVAL_ZVAL(return_value, retval, 1, 1);\n\t}\n\n\tefree(params);\n\treturn result;\n} /* }}} */\n\n#define FileFunctionCall(func_name, pass_num_args, arg2) /* {{{ */ \\\n{ \\\n\tzend_function *func_ptr; \\\n\tint ret; \\\n\tret = zend_hash_find(EG(function_table), #func_name, sizeof(#func_name), (void **) &func_ptr); \\\n\tif (ret != SUCCESS) { \\\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Internal error, function '%s' not found. Please report\", #func_name); \\\n\t\treturn; \\\n\t} \\\n\tspl_filesystem_file_call(intern, func_ptr, pass_num_args, return_value, arg2 TSRMLS_CC); \\\n} /* }}} */\n\nstatic int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC) /* {{{ */\n{\n\tint ret = SUCCESS;\n\n\tdo {\n\t\tret = spl_filesystem_file_read(intern, 1 TSRMLS_CC);\n\t} while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY));\n\n\tif (ret == SUCCESS) {\n\t\tsize_t buf_len = intern->u.file.current_line_len;\n\t\tchar *buf = estrndup(intern->u.file.current_line, buf_len);\n\n\t\tif (intern->u.file.current_zval) {\n\t\t\tzval_ptr_dtor(&intern->u.file.current_zval);\n\t\t}\n\t\tALLOC_INIT_ZVAL(intern->u.file.current_zval);\n\n\t\tphp_fgetcsv(intern->u.file.stream, delimiter, enclosure, escape, buf_len, buf, intern->u.file.current_zval TSRMLS_CC);\n\t\tif (return_value) {\n\t\t\tif (Z_TYPE_P(return_value) != IS_NULL) {\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZVAL_NULL(return_value);\n\t\t\t}\n\t\t\tZVAL_ZVAL(return_value, intern->u.file.current_zval, 1, 0);\n\t\t}\n\t}\n\treturn ret;\n}\n/* }}} */\n\nstatic int spl_filesystem_file_read_line_ex(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tzval *retval = NULL;\n\n\t/* 1) use fgetcsv? 2) overloaded call the function, 3) do it directly */\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || intern->u.file.func_getCurr->common.scope != spl_ce_SplFileObject) {\n\t\tif (php_stream_eof(intern->u.file.stream)) {\n\t\t\tif (!silent) {\n\t\t\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot read from file %s\", intern->file_name);\n\t\t\t}\n\t\t\treturn FAILURE;\n\t\t}\n\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)) {\n\t\t\treturn spl_filesystem_file_read_csv(intern, intern->u.file.delimiter, intern->u.file.enclosure, intern->u.file.escape, NULL TSRMLS_CC);\n\t\t} else {\n\t\t\tzend_call_method_with_0_params(&this_ptr, Z_OBJCE_P(getThis()), &intern->u.file.func_getCurr, \"getCurrentLine\", &retval);\n\t\t}\n\t\tif (retval) {\n\t\t\tif (intern->u.file.current_line || intern->u.file.current_zval) {\n\t\t\t\tintern->u.file.current_line_num++;\n\t\t\t}\n\t\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\t\tif (Z_TYPE_P(retval) == IS_STRING) {\n\t\t\t\tintern->u.file.current_line = estrndup(Z_STRVAL_P(retval), Z_STRLEN_P(retval));\n\t\t\t\tintern->u.file.current_line_len = Z_STRLEN_P(retval);\n\t\t\t} else {\n\t\t\t\tMAKE_STD_ZVAL(intern->u.file.current_zval);\n\t\t\t\tZVAL_ZVAL(intern->u.file.current_zval, retval, 1, 0);\n\t\t\t}\n\t\t\tzval_ptr_dtor(&retval);\n\t\t\treturn SUCCESS;\n\t\t} else {\n\t\t\treturn FAILURE;\n\t\t}\n\t} else {\n\t\treturn spl_filesystem_file_read(intern, silent TSRMLS_CC);\n\t}\n} /* }}} */\n\nstatic int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (intern->u.file.current_line) {\n\t\treturn intern->u.file.current_line_len == 0;\n\t} else if (intern->u.file.current_zval) {\n\t\tswitch(Z_TYPE_P(intern->u.file.current_zval)) {\n\t\tcase IS_STRING:\n\t\t\treturn Z_STRLEN_P(intern->u.file.current_zval) == 0;\n\t\tcase IS_ARRAY:\n\t\t\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)\n\t\t\t&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {\n\t\t\t\tzval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;\n\n\t\t\t\treturn Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;\n\t\t\t}\n\t\t\treturn zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;\n\t\tcase IS_NULL:\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\treturn 1;\n\t}\n}\n/* }}} */\n\nstatic int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */\n{\n\tint ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\n\twhile (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);\n\t}\n\n\treturn ret;\n}\n/* }}} */\n\nstatic void spl_filesystem_file_rewind(zval * this_ptr, spl_filesystem_object *intern TSRMLS_DC) /* {{{ */\n{\n\tif (-1 == php_stream_rewind(intern->u.file.stream)) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Cannot rewind file %s\", intern->file_name);\n\t} else {\n\t\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\t\tintern->u.file.current_line_num = 0;\n\t}\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(this_ptr, intern, 1 TSRMLS_CC);\n\t}\n} /* }}} */\n\n/* {{{ proto void SplFileObject::__construct(string filename [, string mode = 'r' [, bool use_include_path  [, resource context]]]])\n   Construct a new file object */\nSPL_METHOD(SplFileObject, __construct)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_bool use_include_path = 0;\n\tchar *p1, *p2;\n\tchar *tmp_path;\n\tint   tmp_path_len;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tintern->u.file.open_mode = NULL;\n\tintern->u.file.open_mode_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|sbr!\",\n\t\t\t&intern->file_name, &intern->file_name_len,\n\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len,\n\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\tintern->u.file.open_mode = NULL;\n\t\tintern->file_name = NULL;\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (intern->u.file.open_mode == NULL) {\n\t\tintern->u.file.open_mode = \"r\";\n\t\tintern->u.file.open_mode_len = 1;\n\t}\n\n\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == SUCCESS) {\n\t\ttmp_path_len = strlen(intern->u.file.stream->orig_path);\n\n\t\tif (tmp_path_len > 1 && IS_SLASH_AT(intern->u.file.stream->orig_path, tmp_path_len-1)) {\n\t\t\ttmp_path_len--;\n\t\t}\n\n\t\ttmp_path = estrndup(intern->u.file.stream->orig_path, tmp_path_len);\n\n\t\tp1 = strrchr(tmp_path, '/');\n#if defined(PHP_WIN32) || defined(NETWARE)\n\t\tp2 = strrchr(tmp_path, '\\\\');\n#else\n\t\tp2 = 0;\n#endif\n\t\tif (p1 || p2) {\n\t\t\tintern->_path_len = (p1 > p2 ? p1 : p2) - tmp_path;\n\t\t} else {\n\t\t\tintern->_path_len = 0;\n\t\t}\n\n\t\tefree(tmp_path);\n\n\t\tintern->_path = estrndup(intern->u.file.stream->orig_path, intern->_path_len);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\n} /* }}} */\n\n/* {{{ proto void SplTempFileObject::__construct([int max_memory])\n   Construct a new temp file object */\nSPL_METHOD(SplTempFileObject, __construct)\n{\n\tlong max_memory = PHP_STREAM_MAX_MEM;\n\tchar tmp_fname[48];\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_RuntimeException, &error_handling TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|l\", &max_memory) == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\treturn;\n\t}\n\n\tif (max_memory < 0) {\n\t\tintern->file_name = \"php://memory\";\n\t\tintern->file_name_len = 12;\n\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php://temp/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php://temp\";\n\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::rewind()\n   Rewind the file and read the first line */\nSPL_METHOD(SplFileObject, rewind)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::eof()\n   Return whether end of file is reached */\nSPL_METHOD(SplFileObject, eof)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_BOOL(php_stream_eof(intern->u.file.stream));\n} /* }}} */\n\n/* {{{ proto void SplFileObject::valid()\n   Return !eof() */\nSPL_METHOD(SplFileObject, valid)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tRETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);\n\t} else {\n\t\tRETVAL_BOOL(!php_stream_eof(intern->u.file.stream));\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgets()\n   Rturn next line from file */\nSPL_METHOD(SplFileObject, fgets)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {\n\t\tRETURN_FALSE;\n\t}\n\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n} /* }}} */\n\n/* {{{ proto string SplFileObject::current()\n   Return current line from file */\nSPL_METHOD(SplFileObject, current)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!intern->u.file.current_line && !intern->u.file.current_zval) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tif (intern->u.file.current_line && (!SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV) || !intern->u.file.current_zval)) {\n\t\tRETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);\n\t} else if (intern->u.file.current_zval) {\n\t\tRETURN_ZVAL(intern->u.file.current_zval, 1, 0);\n\t}\n\tRETURN_FALSE;\n} /* }}} */\n\n/* {{{ proto int SplFileObject::key()\n   Return line number */\nSPL_METHOD(SplFileObject, key)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n/*\tDo not read the next line to support correct counting with fgetc()\n\tif (!intern->current_line) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t} */\n\tRETURN_LONG(intern->u.file.current_line_num);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::next()\n   Read next line */\nSPL_METHOD(SplFileObject, next)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tif (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {\n\t\tspl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC);\n\t}\n\tintern->u.file.current_line_num++;\n} /* }}} */\n\n/* {{{ proto void SplFileObject::setFlags(int flags)\n   Set file handling flags */\nSPL_METHOD(SplFileObject, setFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &intern->flags) == FAILURE) {\n\t\treturn;\n\t}\n} /* }}} */\n\n/* {{{ proto int SplFileObject::getFlags()\n   Get file handling flags */\nSPL_METHOD(SplFileObject, getFlags)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG(intern->flags & SPL_FILE_OBJECT_MASK);\n} /* }}} */\n\n/* {{{ proto void SplFileObject::setMaxLineLen(int max_len)\n   Set maximum line length */\nSPL_METHOD(SplFileObject, setMaxLineLen)\n{\n\tlong max_len;\n\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &max_len) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (max_len < 0) {\n\t\tzend_throw_exception_ex(spl_ce_DomainException, 0 TSRMLS_CC, \"Maximum line length must be greater than or equal zero\");\n\t\treturn;\n\t}\n\n\tintern->u.file.max_line_len = max_len;\n} /* }}} */\n\n/* {{{ proto int SplFileObject::getMaxLineLen()\n   Get maximum line length */\nSPL_METHOD(SplFileObject, getMaxLineLen)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_LONG((long)intern->u.file.max_line_len);\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::hasChildren()\n   Return false */\nSPL_METHOD(SplFileObject, hasChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\n\tRETURN_FALSE;\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::getChildren()\n   Read NULL */\nSPL_METHOD(SplFileObject, getChildren)\n{\n\tif (zend_parse_parameters_none() == FAILURE) {\n\t\treturn;\n\t}\n\t/* return NULL */\n} /* }}} */\n\n/* {{{ FileFunction */\n#define FileFunction(func_name) \\\nSPL_METHOD(SplFileObject, func_name) \\\n{ \\\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC); \\\n\tFileFunctionCall(func_name, ZEND_NUM_ARGS(), NULL); \\\n}\n/* }}} */\n\n/* {{{ proto array SplFileObject::fgetcsv([string delimiter [, string enclosure [, escape = '\\\\']]])\n   Return current line as csv */\nSPL_METHOD(SplFileObject, fgetcsv)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sss\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 3:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t/* no break */\n\t\tcase 2:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t/* no break */\n\t\tcase 1:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t/* no break */\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tspl_filesystem_file_read_csv(intern, delimiter, enclosure, escape, return_value TSRMLS_CC);\n\t}\n}\n/* }}} */\n\n/* {{{ proto int SplFileObject::fputcsv(array fields, [string delimiter [, string enclosure [, string escape]]])\n   Output a field array as a CSV line */\nSPL_METHOD(SplFileObject, fputcsv)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = intern->u.file.delimiter, enclosure = intern->u.file.enclosure, escape = intern->u.file.escape;\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0, ret;\n\tzval *fields = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"a|sss\", &fields, &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 4:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t/* no break */\n\t\tcase 3:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t/* no break */\n\t\tcase 2:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t/* no break */\n\t\tcase 1:\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tret = php_fputcsv(intern->u.file.stream, fields, delimiter, enclosure, escape TSRMLS_CC);\n\t\tRETURN_LONG(ret);\n\t}\n}\n/* }}} */\n\n/* {{{ proto void SplFileObject::setCsvControl([string delimiter = ',' [, string enclosure = '\"' [, string escape = '\\\\']]])\n   Set the delimiter and enclosure character used in fgetcsv */\nSPL_METHOD(SplFileObject, setCsvControl)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter = ',', enclosure = '\"', escape='\\\\';\n\tchar *delim = NULL, *enclo = NULL, *esc = NULL;\n\tint d_len = 0, e_len = 0, esc_len = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sss\", &delim, &d_len, &enclo, &e_len, &esc, &esc_len) == SUCCESS) {\n\t\tswitch(ZEND_NUM_ARGS())\n\t\t{\n\t\tcase 3:\n\t\t\tif (esc_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"escape must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tescape = esc[0];\n\t\t\t/* no break */\n\t\tcase 2:\n\t\t\tif (e_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"enclosure must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tenclosure = enclo[0];\n\t\t\t/* no break */\n\t\tcase 1:\n\t\t\tif (d_len != 1) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"delimiter must be a character\");\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tdelimiter = delim[0];\n\t\t\t/* no break */\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\tintern->u.file.delimiter = delimiter;\n\t\tintern->u.file.enclosure = enclosure;\n\t\tintern->u.file.escape    = escape;\n\t}\n}\n/* }}} */\n\n/* {{{ proto array SplFileObject::getCsvControl()\n   Get the delimiter and enclosure character used in fgetcsv */\nSPL_METHOD(SplFileObject, getCsvControl)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar delimiter[2], enclosure[2];\n\n\tarray_init(return_value);\n\n\tdelimiter[0] = intern->u.file.delimiter;\n\tdelimiter[1] = '\\0';\n\tenclosure[0] = intern->u.file.enclosure;\n\tenclosure[1] = '\\0';\n\n\tadd_next_index_string(return_value, delimiter, 1);\n\tadd_next_index_string(return_value, enclosure, 1);\n}\n/* }}} */\n\n/* {{{ proto bool SplFileObject::flock(int operation [, int &wouldblock])\n   Portable file locking */\nFileFunction(flock)\n/* }}} */\n\n/* {{{ proto bool SplFileObject::fflush()\n   Flush the file */\nSPL_METHOD(SplFileObject, fflush)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tRETURN_BOOL(!php_stream_flush(intern->u.file.stream));\n} /* }}} */\n\n/* {{{ proto int SplFileObject::ftell()\n   Return current file position */\nSPL_METHOD(SplFileObject, ftell)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong ret = php_stream_tell(intern->u.file.stream);\n\n\tif (ret == -1) {\n\t\tRETURN_FALSE;\n\t} else {\n\t\tRETURN_LONG(ret);\n\t}\n} /* }}} */\n\n/* {{{ proto int SplFileObject::fseek(int pos [, int whence = SEEK_SET])\n   Return current file position */\nSPL_METHOD(SplFileObject, fseek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong pos, whence = SEEK_SET;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l|l\", &pos, &whence) == FAILURE) {\n\t\treturn;\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tRETURN_LONG(php_stream_seek(intern->u.file.stream, pos, whence));\n} /* }}} */\n\n/* {{{ proto int SplFileObject::fgetc()\n   Get a character form the file */\nSPL_METHOD(SplFileObject, fgetc)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar buf[2];\n\tint result;\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\n\tresult = php_stream_getc(intern->u.file.stream);\n\n\tif (result == EOF) {\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tif (result == '\\n') {\n\t\t\tintern->u.file.current_line_num++;\n\t\t}\n\t\tbuf[0] = result;\n\t\tbuf[1] = '\\0';\n\n\t\tRETURN_STRINGL(buf, 1, 1);\n\t}\n} /* }}} */\n\n/* {{{ proto string SplFileObject::fgetss([string allowable_tags])\n   Get a line from file pointer and strip HTML tags */\nSPL_METHOD(SplFileObject, fgetss)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tzval *arg2 = NULL;\n\tMAKE_STD_ZVAL(arg2);\n\n\tif (intern->u.file.max_line_len > 0) {\n\t\tZVAL_LONG(arg2, intern->u.file.max_line_len);\n\t} else {\n\t\tZVAL_LONG(arg2, 1024);\n\t}\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tintern->u.file.current_line_num++;\n\n\tFileFunctionCall(fgetss, ZEND_NUM_ARGS(), arg2);\n\n\tzval_ptr_dtor(&arg2);\n} /* }}} */\n\n/* {{{ proto int SplFileObject::fpassthru()\n   Output all remaining data from a file pointer */\nSPL_METHOD(SplFileObject, fpassthru)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tRETURN_LONG(php_stream_passthru(intern->u.file.stream));\n} /* }}} */\n\n/* {{{ proto bool SplFileObject::fscanf(string format [, string ...])\n   Implements a mostly ANSI compatible fscanf() */\nSPL_METHOD(SplFileObject, fscanf)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\n\tspl_filesystem_file_free_line(intern TSRMLS_CC);\n\tintern->u.file.current_line_num++;\n\n\tFileFunctionCall(fscanf, ZEND_NUM_ARGS(), NULL);\n}\n/* }}} */\n\n/* {{{ proto mixed SplFileObject::fwrite(string str [, int length])\n   Binary-safe file write */\nSPL_METHOD(SplFileObject, fwrite)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tchar *str;\n\tint str_len;\n\tlong length = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &str, &str_len, &length) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (ZEND_NUM_ARGS() > 1) {\n\t\tstr_len = MAX(0, MIN(length, str_len));\n\t}\n\tif (!str_len) {\n\t\tRETURN_LONG(0);\n\t}\n\n\tRETURN_LONG(php_stream_write(intern->u.file.stream, str, str_len));\n} /* }}} */\n\nSPL_METHOD(SplFileObject, fread)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong length = 0;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &length) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (length <= 0) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be greater than 0\");\n\t\tRETURN_FALSE;\n\t}\n\tif (length > INT_MAX) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Length parameter must be no more than %d\", INT_MAX);\n\t\tRETURN_FALSE;\n\t}\n\n\tZ_STRVAL_P(return_value) = emalloc(length + 1);\n\tZ_STRLEN_P(return_value) = php_stream_read(intern->u.file.stream, Z_STRVAL_P(return_value), length);\n\n\t/* needed because recv/read/gzread doesnt put a null at the end*/\n\tZ_STRVAL_P(return_value)[Z_STRLEN_P(return_value)] = 0;\n\tZ_TYPE_P(return_value) = IS_STRING;\n}\n\n/* {{{ proto bool SplFileObject::fstat()\n   Stat() on a filehandle */\nFileFunction(fstat)\n/* }}} */\n\n/* {{{ proto bool SplFileObject::ftruncate(int size)\n   Truncate file to 'size' length */\nSPL_METHOD(SplFileObject, ftruncate)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong size;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &size) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!php_stream_truncate_supported(intern->u.file.stream)) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't truncate file %s\", intern->file_name);\n\t\tRETURN_FALSE;\n\t}\n\n\tRETURN_BOOL(0 == php_stream_truncate_set_size(intern->u.file.stream, size));\n} /* }}} */\n\n/* {{{ proto void SplFileObject::seek(int line_pos)\n   Seek to specified line */\nSPL_METHOD(SplFileObject, seek)\n{\n\tspl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);\n\tlong line_pos;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"l\", &line_pos) == FAILURE) {\n\t\treturn;\n\t}\n\tif (line_pos < 0) {\n\t\tzend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, \"Can't seek file %s to negative line %ld\", intern->file_name, line_pos);\n\t\tRETURN_FALSE;\n\t}\n\n\tspl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);\n\n\twhile(intern->u.file.current_line_num < line_pos) {\n\t\tif (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {\n\t\t\tbreak;\n\t\t}\n\t}\n} /* }}} */\n\n/* {{{ Function/Class/Method definitions */\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object___construct, 0, 0, 1)\n\tZEND_ARG_INFO(0, file_name)\n\tZEND_ARG_INFO(0, open_mode)\n\tZEND_ARG_INFO(0, use_include_path)\n\tZEND_ARG_INFO(0, context)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_file_object_setFlags, 0)\n\tZEND_ARG_INFO(0, flags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_file_object_setMaxLineLen, 0)\n\tZEND_ARG_INFO(0, max_len)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetcsv, 0, 0, 0)\n\tZEND_ARG_INFO(0, delimiter)\n\tZEND_ARG_INFO(0, enclosure)\n\tZEND_ARG_INFO(0, escape)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fputcsv, 0, 0, 1)\n\tZEND_ARG_INFO(0, fields)\n\tZEND_ARG_INFO(0, delimiter)\n\tZEND_ARG_INFO(0, enclosure)\n\tZEND_ARG_INFO(0, escape)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_flock, 0, 0, 1)\n\tZEND_ARG_INFO(0, operation)\n\tZEND_ARG_INFO(1, wouldblock)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fseek, 0, 0, 1)\n\tZEND_ARG_INFO(0, pos)\n\tZEND_ARG_INFO(0, whence)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fgetss, 0, 0, 0)\n\tZEND_ARG_INFO(0, allowable_tags)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fscanf, 1, 0, 1)\n\tZEND_ARG_INFO(0, format)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fwrite, 0, 0, 1)\n\tZEND_ARG_INFO(0, str)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_fread, 0, 0, 1)\n\tZEND_ARG_INFO(0, length)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_ftruncate, 0, 0, 1)\n\tZEND_ARG_INFO(0, size)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_file_object_seek, 0, 0, 1)\n\tZEND_ARG_INFO(0, line_pos)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_SplFileObject_functions[] = {\n\tSPL_ME(SplFileObject, __construct,    arginfo_file_object___construct,   ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, rewind,         arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, eof,            arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, valid,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgets,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgetcsv,        arginfo_file_object_fgetcsv,       ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fputcsv,        arginfo_file_object_fputcsv,       ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, setCsvControl,  arginfo_file_object_fgetcsv,       ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getCsvControl,  arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, flock,          arginfo_file_object_flock,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fflush,         arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, ftell,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fseek,          arginfo_file_object_fseek,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgetc,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fpassthru,      arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fgetss,         arginfo_file_object_fgetss,        ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fscanf,         arginfo_file_object_fscanf,        ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fwrite,         arginfo_file_object_fwrite,        ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fread,          arginfo_file_object_fread,         ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, fstat,          arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, ftruncate,      arginfo_file_object_ftruncate,     ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, current,        arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, key,            arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, next,           arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, setFlags,       arginfo_file_object_setFlags,      ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getFlags,       arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, setMaxLineLen,  arginfo_file_object_setMaxLineLen, ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getMaxLineLen,  arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, hasChildren,    arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, getChildren,    arginfo_splfileinfo_void,          ZEND_ACC_PUBLIC)\n\tSPL_ME(SplFileObject, seek,           arginfo_file_object_seek,          ZEND_ACC_PUBLIC)\n\t/* mappings */\n\tSPL_MA(SplFileObject, getCurrentLine, SplFileObject, fgets,      arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tSPL_MA(SplFileObject, __toString,     SplFileObject, current,    arginfo_splfileinfo_void, ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n\nZEND_BEGIN_ARG_INFO_EX(arginfo_temp_file_object___construct, 0, 0, 0)\n\tZEND_ARG_INFO(0, max_memory)\nZEND_END_ARG_INFO()\n\nstatic const zend_function_entry spl_SplTempFileObject_functions[] = {\n\tSPL_ME(SplTempFileObject, __construct, arginfo_temp_file_object___construct,  ZEND_ACC_PUBLIC)\n\tPHP_FE_END\n};\n/* }}} */\n\n/* {{{ PHP_MINIT_FUNCTION(spl_directory)\n */\nPHP_MINIT_FUNCTION(spl_directory)\n{\n\tREGISTER_SPL_STD_CLASS_EX(SplFileInfo, spl_filesystem_object_new, spl_SplFileInfo_functions);\n\tmemcpy(&spl_filesystem_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));\n\tspl_filesystem_object_handlers.clone_obj       = spl_filesystem_object_clone;\n\tspl_filesystem_object_handlers.cast_object     = spl_filesystem_object_cast;\n\tspl_filesystem_object_handlers.get_debug_info  = spl_filesystem_object_get_debug_info;\n\tspl_ce_SplFileInfo->serialize = zend_class_serialize_deny;\n\tspl_ce_SplFileInfo->unserialize = zend_class_unserialize_deny;\n\n\tREGISTER_SPL_SUB_CLASS_EX(DirectoryIterator, SplFileInfo, spl_filesystem_object_new, spl_DirectoryIterator_functions);\n\tzend_class_implements(spl_ce_DirectoryIterator TSRMLS_CC, 1, zend_ce_iterator);\n\tREGISTER_SPL_IMPLEMENTS(DirectoryIterator, SeekableIterator);\n\n\tspl_ce_DirectoryIterator->get_iterator = spl_filesystem_dir_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(FilesystemIterator, DirectoryIterator, spl_filesystem_object_new, spl_FilesystemIterator_functions);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_MODE_MASK\",   SPL_FILE_DIR_CURRENT_MODE_MASK);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_AS_PATHNAME\", SPL_FILE_DIR_CURRENT_AS_PATHNAME);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_AS_FILEINFO\", SPL_FILE_DIR_CURRENT_AS_FILEINFO);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"CURRENT_AS_SELF\",     SPL_FILE_DIR_CURRENT_AS_SELF);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"KEY_MODE_MASK\",       SPL_FILE_DIR_KEY_MODE_MASK);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"KEY_AS_PATHNAME\",     SPL_FILE_DIR_KEY_AS_PATHNAME);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"FOLLOW_SYMLINKS\",     SPL_FILE_DIR_FOLLOW_SYMLINKS);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"KEY_AS_FILENAME\",     SPL_FILE_DIR_KEY_AS_FILENAME);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"NEW_CURRENT_AND_KEY\", SPL_FILE_DIR_KEY_AS_FILENAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"OTHER_MODE_MASK\",     SPL_FILE_DIR_OTHERS_MASK);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"SKIP_DOTS\",           SPL_FILE_DIR_SKIPDOTS);\n\tREGISTER_SPL_CLASS_CONST_LONG(FilesystemIterator, \"UNIX_PATHS\",          SPL_FILE_DIR_UNIXPATHS);\n\n\tspl_ce_FilesystemIterator->get_iterator = spl_filesystem_tree_get_iterator;\n\n\tREGISTER_SPL_SUB_CLASS_EX(RecursiveDirectoryIterator, FilesystemIterator, spl_filesystem_object_new, spl_RecursiveDirectoryIterator_functions);\n\tREGISTER_SPL_IMPLEMENTS(RecursiveDirectoryIterator, RecursiveIterator);\n\n\tmemcpy(&spl_filesystem_object_check_handlers, &spl_filesystem_object_handlers, sizeof(zend_object_handlers));\n\tspl_filesystem_object_check_handlers.get_method = spl_filesystem_object_get_method_check;\n\n#ifdef HAVE_GLOB\n\tREGISTER_SPL_SUB_CLASS_EX(GlobIterator, FilesystemIterator, spl_filesystem_object_new_check, spl_GlobIterator_functions);\n\tREGISTER_SPL_IMPLEMENTS(GlobIterator, Countable);\n#endif\n\n\tREGISTER_SPL_SUB_CLASS_EX(SplFileObject, SplFileInfo, spl_filesystem_object_new_check, spl_SplFileObject_functions);\n\tREGISTER_SPL_IMPLEMENTS(SplFileObject, RecursiveIterator);\n\tREGISTER_SPL_IMPLEMENTS(SplFileObject, SeekableIterator);\n\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"DROP_NEW_LINE\", SPL_FILE_OBJECT_DROP_NEW_LINE);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"READ_AHEAD\",    SPL_FILE_OBJECT_READ_AHEAD);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"SKIP_EMPTY\",    SPL_FILE_OBJECT_SKIP_EMPTY);\n\tREGISTER_SPL_CLASS_CONST_LONG(SplFileObject, \"READ_CSV\",      SPL_FILE_OBJECT_READ_CSV);\n\n\tREGISTER_SPL_SUB_CLASS_EX(SplTempFileObject, SplFileObject, spl_filesystem_object_new_check, spl_SplTempFileObject_functions);\n\treturn SUCCESS;\n}\n/* }}} */\n\n/*\n * Local variables:\n * tab-width: 4\n * c-basic-offset: 4\n * End:\n * vim600: noet sw=4 ts=4 fdm=marker\n * vim<600: noet sw=4 ts=4\n */\n"], "filenames": ["ext/spl/spl_directory.c"], "buggy_code_start_loc": [82], "buggy_code_end_loc": [3099], "fixing_code_start_loc": [82], "fixing_code_end_loc": [3103], "type": "CWE-190", "message": "Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096.", "other": {"cve": {"id": "CVE-2016-5770", "sourceIdentifier": "cve@mitre.org", "published": "2016-08-07T10:59:18.150", "lastModified": "2022-07-20T16:54:27.483", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096."}, {"lang": "es", "value": "Desbordamiento de entero en la funci\u00f3n SplFileObject::fread en spl_directory.c en la extensi\u00f3n SPL en PHP en versiones anteriores a 5.5.37 y 5.6.x en versiones anteriores 5.6.23 permite a atacantes remotos provocar una denegaci\u00f3n de servicio o posiblemente tener otro impacto no especificado a trav\u00e9s de un argumento de entero grande, un problema relacionado con CVE-2016-5096."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.5.37", "matchCriteriaId": "10C889AC-EEC6-4BD3-9302-628FB7DEF0CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.6.0", "versionEndExcluding": "5.6.23", "matchCriteriaId": "610F5BCE-2990-470F-8B54-FD3AC222B70B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0", "versionEndExcluding": "7.0.8", "matchCriteriaId": "3325587F-EF6F-46ED-B3D6-A7DE522AF10F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:42.1:*:*:*:*:*:*:*", "matchCriteriaId": "4863BE36-D16A-4D75-90D9-FD76DB5B48B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://github.com/php/php-src/commit/7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://lists.apple.com/archives/security-announce/2016/Sep/msg00006.html", "source": "cve@mitre.org", "tags": ["Broken Link", "Mailing List"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2016-08/msg00003.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://php.net/ChangeLog-5.php", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2750.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3618", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/06/23/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91403", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.php.net/bug.php?id=72262", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://h20566.www2.hpe.com/portal/site/hpsc/public/kb/docDisplay?docId=emr_na-c05240731", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.apple.com/HT207170", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "http://github.com/php/php-src/commit/7245bff300d3fa8bacbef7897ff080a6f1c23eba?w=1"}}