{"buggy_code": ["/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup bn Multiple precision integer arithmetic\n */\n\n/**\n * @file\n *\n * Interface of the module for multiple precision integer arithmetic.\n *\n * @ingroup bn\n */\n\n#ifndef RLC_BN_H\n#define RLC_BN_H\n\n#include \"relic_conf.h\"\n#include \"relic_util.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a multiple precision integer.\n *\n * If the library is built with support for dynamic allocation, this constant\n * represents the size in bits of the memory block allocated each time a\n * multiple precision integer must grow. Otherwise, it represents the fixed\n * fixed precision.\n */\n#define RLC_BN_BITS \t((int)BN_PRECI)\n\n/**\n * Size in digits of a block sufficient to store the required precision.\n */\n#define RLC_BN_DIGS\t\t((int)RLC_CEIL(BN_PRECI, RLC_DIG))\n\n/**\n * Size in digits of a block sufficient to store a multiple precision integer.\n */\n#if BN_MAGNI == DOUBLE\n#define RLC_BN_SIZE\t\t((int)(2 * RLC_BN_DIGS + 2))\n#elif BN_MAGNI == CARRY\n#define RLC_BN_SIZE\t\t((int)(RLC_BN_DIGS + 1))\n#elif BN_MAGNI == SINGLE\n#define RLC_BN_SIZE\t\t((int)RLC_BN_DIGS)\n#endif\n\n/**\n * Positive sign of a multiple precision integer.\n */\n#define RLC_POS\t\t0\n\n/**\n * Negative sign of a multiple precision integer.\n */\n#define RLC_NEG\t\t1\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a multiple precision integer.\n *\n * The field dp points to a vector of digits. These digits are organized\n * in little-endian format, that is, the least significant digits are\n * stored in the first positions of the vector.\n */\ntypedef struct {\n\t/** The number of digits allocated to this multiple precision integer. */\n\tint alloc;\n\t/** The number of digits actually used. */\n\tint used;\n\t/** The sign of this multiple precision integer. */\n\tint sign;\n#if ALLOC == DYNAMIC\n\t/** The sequence of contiguous digits that forms this integer. */\n\tdig_t *dp;\n#elif ALLOC == AUTO\n\t/** The sequence of contiguous digits that forms this integer. */\n\trlc_align dig_t dp[RLC_BN_SIZE];\n#endif\n} bn_st;\n\n/**\n * Pointer to a multiple precision integer structure.\n */\n#if ALLOC == AUTO\ntypedef bn_st bn_t[1];\n#elif ALLOC == DYNAMIC\n#ifdef CHECK\ntypedef bn_st *volatile bn_t;\n#else\ntypedef bn_st *bn_t;\n#endif\n#endif\n\n/**\n * Represents a pair of moduli for using the Chinese Remainder Theorem (CRT).\n */\ntypedef struct {\n\t/** The modulus n = pq. */\n\tbn_t n;\n\t/** The first prime p. */\n\tbn_t p;\n\t/** The second prime q. */\n\tbn_t q;\n\t/** The precomputed constant for the first prime. */\n\tbn_t dp;\n\t/** The precomputed constant for the second prime. */\n\tbn_t dq;\n\t/** The inverse of q modulo p. */\n\tbn_t qi;\n} crt_st;\n\n#if ALLOC == AUTO\ntypedef crt_st crt_t[1];\n#else\ntypedef crt_st *crt_t;\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a multiple precision integer with a null value.\n *\n * @param[out] A\t\t\t- the multiple precision integer to initialize.\n */\n#if ALLOC == AUTO\n#define bn_null(A)\t\t\t/* empty */\n#elif ALLOC == DYNAMIC\n#define bn_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif ((A) == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer\n * with the required precision in digits.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @param[in] D\t\t\t\t- the precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\n#if ALLOC == DYNAMIC\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to free.\n */\n#if ALLOC == DYNAMIC\n#define bn_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_clean(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree((void *)A);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bn_free(A)\t\t\t/* empty */\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Initializes a CRT moduli set with a null value.\n *\n * @param[out] A\t\t\t- the moduli to initialize.\n */\n#define crt_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Rabin key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (crt_t)calloc(1, sizeof(crt_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Rabin key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define crt_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define crt_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Multiples two multiple precision integers. Computes c = a * b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] B\t\t\t\t- the second multiple precision integer to multiply.\n */\n#if BN_KARAT > 0\n#define bn_mul(C, A, B)\t\tbn_mul_karat(C, A, B)\n#elif BN_MUL == BASIC\n#define bn_mul(C, A, B)\t\tbn_mul_basic(C, A, B)\n#elif BN_MUL == COMBA\n#define bn_mul(C, A, B)\t\tbn_mul_comba(C, A, B)\n#endif\n\n/**\n * Computes the square of a multiple precision integer. Computes c = a * a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to square.\n */\n#if BN_KARAT > 0\n#define bn_sqr(C, A)\t\tbn_sqr_karat(C, A)\n#elif BN_SQR == BASIC\n#define bn_sqr(C, A)\t\tbn_sqr_basic(C, A)\n#elif BN_SQR == COMBA\n#define bn_sqr(C, A)\t\tbn_sqr_comba(C, A)\n#elif BN_SQR == MULTP\n#define bn_sqr(C, A)\t\tbn_mul(C, A, A)\n#endif\n\n/**\n * Computes the auxiliar value derived from the modulus to be used during\n * modular reduction.\n *\n * @param[out] U\t\t\t- the result.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_pre(U, M)\t(void)(U), (void)(M)\n#elif BN_MOD == BARRT\n#define bn_mod_pre(U, M)\tbn_mod_pre_barrt(U, M)\n#elif BN_MOD == MONTY\n#define bn_mod_pre(U, M)\tbn_mod_pre_monty(U, M)\n#elif BN_MOD == PMERS\n#define bn_mod_pre(U, M)\tbn_mod_pre_pmers(U, M)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo another integer. If the number\n * of arguments is 3, then simple division is used. If the number of arguments\n * is 4, then a modular reduction algorithm is used and the fourth argument\n * is an auxiliary value derived from the modulus. The variant with 4 arguments\n * should be used when several modular reductions are computed with the same\n * modulus. Computes c = a mod m.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] ...\t\t\t- the modulus and an optional argument.\n */\n#define bn_mod(C, A, ...)\tRLC_CAT(bn_mod, RLC_OPT(__VA_ARGS__))(C, A, __VA_ARGS__)\n\n/**\n * Reduces a multiple precision integer modulo another integer. This macro\n * should not be called directly. Use bn_mod with 4 arguments instead.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the auxiliar value derived from the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_imp(C, A, M, U)\tbn_mod_basic(C, A, M)\n#elif BN_MOD == BARRT\n#define bn_mod_imp(C, A, M, U)\tbn_mod_barrt(C, A, M, U)\n#elif BN_MOD == MONTY\n#define bn_mod_imp(C, A, M, U)\tbn_mod_monty(C, A, M, U)\n#elif BN_MOD == PMERS\n#define bn_mod_imp(C, A, M, U)\tbn_mod_pmers(C, A, M, U)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction. Computes c = a * u^(-1) (mod m).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the reciprocal of the modulus.\n */\n#if BN_MUL == BASIC\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_basic(C, A, M, U)\n#elif BN_MUL == COMBA\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_comba(C, A, M, U)\n#endif\n\n/**\n * Exponentiates a multiple precision integer modulo another multiple precision\n * integer. Computes c = a^b mod m. If Montgomery reduction is used, the basis\n * must not be in Montgomery form.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MXP == BASIC\n#define bn_mxp(C, A, B, M)\tbn_mxp_basic(C, A, B, M)\n#elif BN_MXP == SLIDE\n#define bn_mxp(C, A, B, M)\tbn_mxp_slide(C, A, B, M)\n#elif BN_MXP == MONTY\n#define bn_mxp(C, A, B, M)\tbn_mxp_monty(C, A, B, M)\n#endif\n\n/**\n * Computes the greatest common divisor of two multiple precision integers.\n * Computes c = gcd(a, b).\n *\n * @param[out] C\t\t\t- the result;\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd(C, A, B)\t\tbn_gcd_basic(C, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd(C, A, B)\t\tbn_gcd_lehme(C, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd(C, A, B)\t\tbn_gcd_binar(C, A, B)\n#endif\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers. This function can be used to compute multiplicative inverses.\n * Computes c = gcd(a, b) and c = a * d + b * e.\n *\n * @param[out] C\t\t\t- the result;\n * @param[out] D\t\t\t- the cofactor of the first operand, cannot be NULL.\n * @param[out] E\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_basic(C, D, E, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_lehme(C, D, E, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_binar(C, D, E, A, B)\n#endif\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] A\t\t\t- the result.\n * @param[in] B\t\t\t\t- the length of the number in bits.\n */\n#if BN_GEN == BASIC\n#define bn_gen_prime(A, B)\tbn_gen_prime_basic(A, B)\n#elif BN_GEN == SAFEP\n#define bn_gen_prime(A, B)\tbn_gen_prime_safep(A, B)\n#elif BN_GEN == STRON\n#define bn_gen_prime(A, B)\tbn_gen_prime_stron(A, B)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes a previously allocated multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to initialize.\n * @param[in] digits\t\t- the required precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_make(bn_t a, int digits);\n\n/**\n * Cleans a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to free.\n */\nvoid bn_clean(bn_t a);\n\n/**\n * Checks the current precision of a multiple precision integer and optionally\n * expands its precision to a given size in digits.\n *\n * @param[out] a\t\t\t- the multiple precision integer to expand.\n * @param[in] digits\t\t- the number of digits to expand.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_grow(bn_t a, int digits);\n\n/**\n * Adjust the number of valid digits of a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to adjust.\n */\nvoid bn_trim(bn_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to copy.\n */\nvoid bn_copy(bn_t c, const bn_t a);\n\n/**\n * Returns the absolute value of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the argument of the absolute function.\n */\nvoid bn_abs(bn_t c, const bn_t a);\n\n/**\n * Inverts the sign of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the multiple precision integer to negate.\n */\nvoid bn_neg(bn_t c, const bn_t a);\n\n/**\n * Returns the sign of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return RLC_POS if the argument is positive and RLC_NEG otherwise.\n */\nint bn_sign(const bn_t a);\n\n/**\n * Assigns zero to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n */\nvoid bn_zero(bn_t a);\n\n/**\n * Tests if a multiple precision integer is zero or not.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint bn_is_zero(const bn_t a);\n\n/**\n * Tests if a multiple precision integer is even or odd.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is even, 0 otherwise.\n */\nint bn_is_even(const bn_t a);\n\n/**\n * Returns the number of bits of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return number of bits.\n */\nint bn_bits(const bn_t a);\n\n/**\n * Returns the bit stored in the given position on a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to read.\n * @return the bit value.\n */\nint bn_get_bit(const bn_t a, int bit);\n\n/**\n * Stores a bit in a given position on a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to store.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid bn_set_bit(bn_t a, int bit, int value);\n\n/**\n * Returns the Hamming weight of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of non-zero bits.\n */\nint bn_ham(const bn_t a);\n\n/**\n * Reads the first digit in a multiple precision integer.\n *\n * @param[out] digit\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n */\nvoid bn_get_dig(dig_t *digit, const bn_t a);\n\n/**\n * Assigns a small positive constant to a multiple precision integer.\n *\n * The constant must fit on a multiple precision digit, or dig_t type using\n * only the number of bits specified on RLC_DIG.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] digit\t\t\t- the constant to assign.\n */\nvoid bn_set_dig(bn_t a, dig_t digit);\n\n/**\n * Assigns a multiple precision integer to 2^b.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] b\t\t\t\t- the power of 2 to assign.\n */\nvoid bn_set_2b(bn_t a, int b);\n\n/**\n * Assigns a random value to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] sign\t\t\t- the sign to be assigned (RLC_NEG or RLC_POS).\n * @param[in] bits\t\t\t- the number of bits.\n */\nvoid bn_rand(bn_t a, int sign, int bits);\n\n/**\n * Assigns a non-zero random value to a multiple precision integer with absolute\n * value smaller than a given modulus.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] b\t\t\t\t- the modulus.\n */\nvoid bn_rand_mod(bn_t a, const bn_t b);\n\n/**\n * Prints a multiple precision integer to standard output.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to print.\n */\nvoid bn_print(const bn_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a multiple precision\n * integer. The radix must be included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nint bn_size_str(const bn_t a, int radix);\n\n/**\n * Reads a multiple precision integer from a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_read_str(bn_t a, const char *str, int len, int radix);\n\n/**\n * Writes a multiple precision integer to a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_write_str(char *str, int len, const bn_t a, int radix);\n\n/**\n * Returns the number of bytes necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of bytes.\n */\nint bn_size_bin(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n */\nvoid bn_read_bin(bn_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_bin(uint8_t *bin, int len, const bn_t a);\n\n/**\n * Returns the number of digits necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of digits.\n */\nint bn_size_raw(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a digit vector.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the size of the string.\n */\nvoid bn_read_raw(bn_t a, const dig_t *raw, int len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector.\n *\n * @param[out] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_raw(dig_t *raw, int len, const bn_t a);\n\n/**\n * Returns the result of an unsigned comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_abs(const bn_t a, const bn_t b);\n\n/**\n * Returns the result of a signed comparison between a multiple precision\n * integer and a digit.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_dig(const bn_t a, dig_t b);\n\n/**\n * Returns the result of a signed comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp(const bn_t a, const bn_t b);\n\n/**\n * Adds two multiple precision integers. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to add.\n * @param[in] b\t\t\t\t- the second multiple precision integer to add.\n */\nvoid bn_add(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Adds a multiple precision integers and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to add.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid bn_add_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Subtracts a multiple precision integer from another, that is, computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the multiple precision integer to subtract.\n */\nvoid bn_sub(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Subtracts a digit from a multiple precision integer. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid bn_sub_dig(bn_t c, const bn_t a, const dig_t b);\n\n/**\n * Multiplies a multiple precision integer by a digit. Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid bn_mul_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Multiplies two multiple precision integers using Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_comba(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_karat(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the square of a multiple precision integer using Schoolbook\n * squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_basic(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Comba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_comba(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Karatsuba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_karat(bn_t c, const bn_t a);\n\n/**\n * Doubles a multiple precision. Computes c = a + a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to double.\n */\nvoid bn_dbl(bn_t c, const bn_t a);\n\n/**\n * Halves a multiple precision. Computes c = floor(a / 2)\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to halve.\n */\nvoid bn_hlv(bn_t c, const bn_t a);\n\n/**\n * Shifts a multiple precision number to the left. Computes c = a * 2^bits.\n * c = a * 2^bits.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_lsh(bn_t c, const bn_t a, int bits);\n\n/**\n * Shifts a multiple precision number to the right. Computes\n * c = floor(a / 2^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_rsh(bn_t c, const bn_t a, int bits);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * without producing the positive remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * and produces a positive remainder. Computes c = floor(a / b) and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the positive remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem(bn_t c, bn_t d, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integers by a digit without computing the\n * remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Divides a multiple precision integers by a digit. Computes c = floor(a / b)\n * and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem_dig(bn_t c, dig_t *d, const bn_t a, const dig_t b);\n\n/**\n * Computes the modular inverse of a multiple precision integer. Computes c such\n * that a*c mod b = 1.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a\t\t\t\t- the element to invert.\n * param[in] b\t\t\t\t- the modulus.\n *\n */\nvoid bn_mod_inv(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the modular inverse of multiple precision integers simultaneously.\n * Computes c_i such that a_i * c_i mod b = 1.\n *\n * @param[out] c\t\t\t- the results.\n * @param[in] a\t\t\t\t- the elements to invert.\n * param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid bn_mod_inv_sim(bn_t *c, const bn_t *a, const bn_t b, int n);\n\n/**\n * Reduces a multiple precision integer modulo a power of 2. Computes\n * c = a mod 2^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the exponent of the divisor.\n */\nvoid bn_mod_2b(bn_t c, const bn_t a, int b);\n\n/**\n * Reduces a multiple precision integer modulo a digit. Computes c = a mod b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n */\nvoid bn_mod_dig(dig_t *c, const bn_t a, dig_t b);\n\n/**\n * Reduces a multiple precision integer modulo an integer using straightforward\n * division.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_basic(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Barrett modular\n * reduction algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_barrt(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using Barrett\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_barrt(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Montgomery reduction\n * algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n * @throw ERR_NO_VALID\t\t- if the modulus is even.\n */\nvoid bn_mod_pre_monty(bn_t u, const bn_t m);\n\n/**\n * Converts a multiple precision integer to Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_conv(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Converts a multiple precision integer from Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_back(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_basic(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_comba(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes u if the modulus has the form 2^b - u.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_pmers(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * pseudo-Mersenne modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the auxiliar value derived from the modulus.\n */\nvoid bn_mod_pmers(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the constant-time Montgomery powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_monty(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer by a small power modulo a positive\n * integer using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_dig(bn_t c, const bn_t a, dig_t b, const bn_t m);\n\n/*\n * Computes a modular exponentiation of a multiple precision integer using the\n * Chinese Remainder Theorem, given the moduli.\n *\n * @param[out] d \t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent modulo p.\n * @param[in] c\t\t\t\t- the exponent modulo q.\n * @param[in] crt \t\t\t- the set of moduli.\n * @param[in] sqr \t\t\t- the flag to indicate if modulo n or n^2.\n */\nvoid bn_mxp_crt(bn_t d, const bn_t a, const bn_t b, const bn_t c,\n\tconst crt_t crt, int sqr);\n\n/**\n * Extracts an approximate integer square-root of a multiple precision integer.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a \t\t\t- the multiple precision integer to extract.\n *\n * @throw ERR_NO_VALID\t\t- if the argument is negative.\n */\nvoid bn_srt(bn_t c, bn_t a);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the standard Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_binar(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of a multiple precision integer and a\n * digit.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integer using the Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_basic(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers halfway through the algorithm. Returns also two short vectors\n * v1 = (c, d), v2 = (-e, f) useful to decompose an integer k into k0, k1 such\n * that k = k_0 + k_1 * a (mod b).\n *\n * @param[out] c\t\t\t- the first component of the first vector.\n * @param[out] d\t\t\t- the second component of the first vector.\n * @param[out] e\t\t\t- the first component of the second vector.\n * @param[out] f\t\t\t- the second component of the second vector.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_mid(bn_t c, bn_t d, bn_t e, bn_t f, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of a multiple precision integer\n * and a digit.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_ext_dig(bn_t c, bn_t d, bn_t e, const bn_t a, dig_t b);\n\n/**\n * Computes the last common multiple of two multiple precision integers.\n * Computes c = lcm(a, b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first integer.\n * @param[in] b\t\t\t\t- the second integer.\n */\nvoid bn_lcm(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the Legendre symbol c = (a|b), b prime.\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is negative.\n * @return the result.\n */\nint bn_smb_leg(const bn_t a, const bn_t b);\n\n/**\n * Computes the Jacobi symbol c = (a|b).\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is even or negative.\n * @return the result.\n */\nint bn_smb_jac(const bn_t a, const bn_t b);\n\n/**\n * Returns a small precomputed prime from a given position in the list of prime\n * numbers.\n *\n * @param[in] pos\t\t\t- the position in the prime sequence.\n * @return a prime if the position is lower than 512, 0 otherwise.\n */\ndig_t bn_get_prime(int pos);\n\n/**\n * Tests if a number is a probable prime.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if a is prime, 0 otherwise.\n */\nint bn_is_prime(const bn_t a);\n\n/**\n * Tests if a number is prime using a series of trial divisions.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_basic(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Miller-Rabin test with probability\n * 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_rabin(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Solovay-Strassen test with\n * probability 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_solov(const bn_t a);\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_basic(bn_t a, int bits);\n\n/**\n * Generates a probable prime number a with (a - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_safep(bn_t a, int bits);\n\n/**\n * Generates a probable prime number with (a - 1)/2, (a + 1)/2 and\n * ((a - 1)/2 - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_stron(bn_t a, int bits);\n\n/**\n * Generates a probable prime number b, with (b-1) divisible by a probable large\n * prime a.\n *\n * @param[out] a\t\t\t- the prime factor of (b-1).\n * @param[out] b\t\t\t- the prime result b.\n * @param[in] abits\t\t\t- the length of the factor a in bits.\n * @param[in] bbits\t\t\t- the length of the result in bits.\n */\nint bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits);\n\n\n/**\n * Tries to factorize an integer using Pollard (p - 1) factoring algorithm.\n * The maximum length of the returned factor is 16 bits.\n *\n * @param[out] c\t\t\t- the resulting factor.\n * @param[in] a\t\t\t\t- the integer to fatorize.\n * @return 1 if a factor is found and stored into c; 0 otherwise.\n */\nint bn_factor(bn_t c, const bn_t a);\n\n/**\n * Tests if an integer divides other integer.\n *\n * @param[in] c\t\t\t\t- the factor.\n * @param[in] a\t\t\t\t- the integer.\n * @return 1 if the first integer is a factor; 0 otherwise.\n */\nint bn_is_factor(bn_t c, const bn_t a);\n\n/**\n * Recodes a positive integer in window form. If a negative integer is given\n * instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in sliding window form. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in width-w Non-Adjacent Form. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in width-w \\tau-NAF. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w \\tau-NAF.\n * If a negative integer is given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n\n/**\n * Write the constants needed for \\tau-NAF recoding as a set of \\alpha_u =\n * \\beta_u + \\gamma_u * \\tau elements.\n *\n * @param[out] t \t\t- the integer corresponding to \\tau.\n * @param[out] beta\t\t- the first coefficients of the constants.\n * @param[out] gama\t\t- the second coefficients of the constants.\n * @param[in] u \t\t- the u curve parameter.\n * @param[in] w \t\t- the window size in bits.\n */\nvoid bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);\n\n/**\n * Computes the partial reduction k partmod d = r0 + r1 * t, where\n * d = (t^m - 1)/(t - 1).\n *\n * @param[out] r0\t\t- the first half of the result.\n * @param[out] r1\t\t- the second half of the result.\n * @param[in] k\t\t\t- the number to reduce.\n * @param[in] u\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t- the extension degree of the binary field.\n */\nvoid bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w NAF. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the length of the recoding.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);\n\n/**\n * Recodes of a pair of positive integers in Joint Sparse Form. If negative\n * integers are given instead, takes their absolute value.\n *\n * @param[out] jsf\t\t\t- the recoded pair of integers.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the first integer to recode.\n * @param[in] l\t\t\t\t- the second integer to recode.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l);\n\n/**\n * Recodes a positive integer into two parts k0,k1 such that k = k0 + phi(k1),\n * where phi is an efficient curve endomorphism. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] k0\t\t\t- the first part of the result.\n * @param[out] k1\t\t\t- the second part of the result.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the group order.\n * @param[in] v1\t\t\t- the set of parameters v1 for the GLV method.\n * @param[in] v2\t\t\t- the set of parameters v2 for the GLV method.\n */\nvoid bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t v1[],\n\t\tconst bn_t v2[]);\n\n/**\n * Recodes a scalar in subscalars according to Frobenius endomorphism.\n *\n * @param[out] ki\t\t\t- the recoded subscalars.\n * @param[in] sub \t\t\t- the number of subscalars.\n * @param[in] k\t\t\t\t- the scalar to recode.\n * @param[in] x \t\t\t- the elliptic curve parameter.\n * @param[in] n\t\t\t\t- the elliptic curve group order.\n * @param[in] cof \t\t\t- flag to indicate if it is a curve with cofactor 1.\n */\nvoid bn_rec_frb(bn_t *ki, int sub, const bn_t k, const bn_t x, const bn_t n,\n\tint bls);\n\n/**\n * Computes the coefficients of the polynomial representing the Lagrange\n * interpolation for a modulus and a given set of roots.\n * Computes c(x) = \\prod_{0 <= i < n}(x - ai) mod q.\n *\n * @param[out] c \t\t\t- the coefficients of the polynomial.\n * @param[in] a\t\t\t\t- the set of roots.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of roots to interpolate.\n */\nvoid bn_lag(bn_t *c, const bn_t *a, const bn_t b, size_t n);\n\n/**\n * Evaluates an interpolated n-degree polynomial over a value in a modular way,\n * given the (n+1) coefficients of the polynomial and the modulus.\n * Computes c = a(x) mod q.\n *\n * @param[out] c \t\t\t- the result of the evaluation.\n * @param[in] a \t\t\t- the coefficients of the polynomial.\n * @param[in] x\t\t\t\t- the value to evaluate.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the degree of the polynomial.\n */\nvoid bn_evl(bn_t c, const bn_t *a, const bn_t x, const bn_t b, size_t n);\n\n#endif /* !RLC_BN_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Symbol renaming to a#undef clashes when simultaneous linking multiple builds.\n *\n * @ingroup core\n */\n\n#ifndef RLC_LABEL_H\n#define RLC_LABEL_H\n\n#include \"relic_conf.h\"\n\n#define RLC_PREFIX(F)\t\t\t_RLC_PREFIX(LABEL, F)\n#define _RLC_PREFIX(A, B)\t\t__RLC_PREFIX(A, B)\n#define __RLC_PREFIX(A, B)\t\tA ## _ ## B\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n#ifdef LABEL\n\n#undef first_ctx\n#define first_ctx     RLC_PREFIX(first_ctx)\n#undef core_ctx\n#define core_ctx      RLC_PREFIX(core_ctx)\n\n#undef core_init\n#undef core_clean\n#undef core_get\n#undef core_set\n#undef core_set_thread_initializer\n\n#define core_init \tRLC_PREFIX(core_init)\n#define core_clean \tRLC_PREFIX(core_clean)\n#define core_get \tRLC_PREFIX(core_get)\n#define core_set \tRLC_PREFIX(core_set)\n#define core_set_thread_initializer \tRLC_PREFIX(core_set_thread_initializer)\n\n#undef arch_init\n#undef arch_clean\n#undef arch_cycles\n#undef arch_lzcnt\n#undef arch_copy_rom\n\n#define arch_init \tRLC_PREFIX(arch_init)\n#define arch_clean \tRLC_PREFIX(arch_clean)\n#define arch_cycles \tRLC_PREFIX(arch_cycles)\n#define arch_lzcnt \tRLC_PREFIX(arch_lzcnt)\n#define arch_copy_rom \tRLC_PREFIX(arch_copy_rom)\n\n#undef bench_init\n#undef bench_clean\n#undef bench_overhead\n#undef bench_reset\n#undef bench_before\n#undef bench_after\n#undef bench_compute\n#undef bench_print\n#undef bench_total\n\n#define bench_init \tRLC_PREFIX(bench_init)\n#define bench_clean \tRLC_PREFIX(bench_clean)\n#define bench_overhead \tRLC_PREFIX(bench_overhead)\n#define bench_reset \tRLC_PREFIX(bench_reset)\n#define bench_before \tRLC_PREFIX(bench_before)\n#define bench_after \tRLC_PREFIX(bench_after)\n#define bench_compute \tRLC_PREFIX(bench_compute)\n#define bench_print \tRLC_PREFIX(bench_print)\n#define bench_total \tRLC_PREFIX(bench_total)\n\n#undef err_simple_msg\n#undef err_full_msg\n#undef err_get_msg\n#undef err_get_code\n\n#define err_simple_msg \tRLC_PREFIX(err_simple_msg)\n#define err_full_msg \tRLC_PREFIX(err_full_msg)\n#define err_get_msg \tRLC_PREFIX(err_get_msg)\n#define err_get_code \tRLC_PREFIX(err_get_code)\n\n#undef rand_init\n#undef rand_clean\n#undef rand_seed\n#undef rand_seed\n#undef rand_check\n#undef rand_bytes\n\n#define rand_init \tRLC_PREFIX(rand_init)\n#define rand_clean \tRLC_PREFIX(rand_clean)\n#define rand_seed \tRLC_PREFIX(rand_seed)\n#define rand_seed \tRLC_PREFIX(rand_seed)\n#define rand_check \tRLC_PREFIX(rand_check)\n#define rand_bytes \tRLC_PREFIX(rand_bytes)\n\n#undef test_fail\n#undef test_pass\n\n#define test_fail \tRLC_PREFIX(test_fail)\n#define test_pass \tRLC_PREFIX(test_pass)\n\n#undef util_conv_endian\n#undef util_conv_big\n#undef util_conv_little\n#undef util_conv_char\n#undef util_bits_dig\n#undef util_cmp_const\n#undef util_perm\n#undef util_printf\n#undef util_print_dig\n\n#define util_conv_endian \tRLC_PREFIX(util_conv_endian)\n#define util_conv_big \tRLC_PREFIX(util_conv_big)\n#define util_conv_little \tRLC_PREFIX(util_conv_little)\n#define util_conv_char \tRLC_PREFIX(util_conv_char)\n#define util_bits_dig \tRLC_PREFIX(util_bits_dig)\n#define util_cmp_const \tRLC_PREFIX(util_cmp_const)\n#define util_perm \tRLC_PREFIX(util_perm)\n#define util_printf \tRLC_PREFIX(util_printf)\n#define util_print_dig \tRLC_PREFIX(util_print_dig)\n\n#undef conf_print\n#define conf_print    RLC_PREFIX(conf_print)\n\n#undef dv_t\n#define dv_t          RLC_PREFIX(dv_t)\n\n#undef dv_print\n#undef dv_zero\n#undef dv_copy\n#undef dv_copy_cond\n#undef dv_swap_cond\n#undef dv_cmp\n#undef dv_cmp_const\n#undef dv_new_dynam\n#undef dv_free_dynam\n#undef dv_lshd\n#undef dv_rshd\n\n#define dv_print \tRLC_PREFIX(dv_print)\n#define dv_zero \tRLC_PREFIX(dv_zero)\n#define dv_copy \tRLC_PREFIX(dv_copy)\n#define dv_copy_cond \tRLC_PREFIX(dv_copy_cond)\n#define dv_swap_cond \tRLC_PREFIX(dv_swap_cond)\n#define dv_cmp \tRLC_PREFIX(dv_cmp)\n#define dv_cmp_const \tRLC_PREFIX(dv_cmp_const)\n#define dv_new_dynam \tRLC_PREFIX(dv_new_dynam)\n#define dv_free_dynam \tRLC_PREFIX(dv_free_dynam)\n#define dv_lshd \tRLC_PREFIX(dv_lshd)\n#define dv_rshd \tRLC_PREFIX(dv_rshd)\n\n\n\n#undef bn_st\n#undef bn_t\n#define bn_st     \tRLC_PREFIX(bn_st)\n#define bn_t      \tRLC_PREFIX(bn_t)\n\n#undef bn_make\n#undef bn_clean\n#undef bn_grow\n#undef bn_trim\n#undef bn_copy\n#undef bn_abs\n#undef bn_neg\n#undef bn_sign\n#undef bn_zero\n#undef bn_is_zero\n#undef bn_is_even\n#undef bn_bits\n#undef bn_get_bit\n#undef bn_set_bit\n#undef bn_ham\n#undef bn_get_dig\n#undef bn_set_dig\n#undef bn_set_2b\n#undef bn_rand\n#undef bn_rand_mod\n#undef bn_print\n#undef bn_size_str\n#undef bn_read_str\n#undef bn_write_str\n#undef bn_size_bin\n#undef bn_read_bin\n#undef bn_write_bin\n#undef bn_size_raw\n#undef bn_read_raw\n#undef bn_write_raw\n#undef bn_cmp_abs\n#undef bn_cmp_dig\n#undef bn_cmp\n#undef bn_add\n#undef bn_add_dig\n#undef bn_sub\n#undef bn_sub_dig\n#undef bn_mul_dig\n#undef bn_mul_basic\n#undef bn_mul_comba\n#undef bn_mul_karat\n#undef bn_sqr_basic\n#undef bn_sqr_comba\n#undef bn_sqr_karat\n#undef bn_dbl\n#undef bn_hlv\n#undef bn_lsh\n#undef bn_rsh\n#undef bn_div\n#undef bn_div_rem\n#undef bn_div_dig\n#undef bn_div_rem_dig\n#undef bn_mod_inv\n#undef bn_mod_inv_sim\n#undef bn_mod_2b\n#undef bn_mod_dig\n#undef bn_mod_basic\n#undef bn_mod_pre_barrt\n#undef bn_mod_barrt\n#undef bn_mod_pre_monty\n#undef bn_mod_monty_conv\n#undef bn_mod_monty_back\n#undef bn_mod_monty_basic\n#undef bn_mod_monty_comba\n#undef bn_mod_pre_pmers\n#undef bn_mod_pmers\n#undef bn_mxp_basic\n#undef bn_mxp_slide\n#undef bn_mxp_monty\n#undef bn_mxp_dig\n#undef bn_mxp_crt\n#undef bn_srt\n#undef bn_gcd_basic\n#undef bn_gcd_lehme\n#undef bn_gcd_binar\n#undef bn_gcd_dig\n#undef bn_gcd_ext_basic\n#undef bn_gcd_ext_lehme\n#undef bn_gcd_ext_binar\n#undef bn_gcd_ext_mid\n#undef bn_gcd_ext_dig\n#undef bn_lcm\n#undef bn_smb_leg\n#undef bn_smb_jac\n#undef bn_get_prime\n#undef bn_is_prime\n#undef bn_is_prime_basic\n#undef bn_is_prime_rabin\n#undef bn_is_prime_solov\n#undef bn_gen_prime_basic\n#undef bn_gen_prime_safep\n#undef bn_gen_prime_stron\n#undef bn_gen_prime_factor\n#undef bn_factor\n#undef bn_is_factor\n#undef bn_rec_win\n#undef bn_rec_slw\n#undef bn_rec_naf\n#undef bn_rec_tnaf\n#undef bn_rec_rtnaf\n#undef bn_rec_tnaf_get\n#undef bn_rec_tnaf_mod\n#undef bn_rec_reg\n#undef bn_rec_jsf\n#undef bn_rec_glv\n#undef bn_rec_frb\n#undef bn_lag\n#undef bn_evl\n\n#define bn_make \tRLC_PREFIX(bn_make)\n#define bn_clean \tRLC_PREFIX(bn_clean)\n#define bn_grow \tRLC_PREFIX(bn_grow)\n#define bn_trim \tRLC_PREFIX(bn_trim)\n#define bn_copy \tRLC_PREFIX(bn_copy)\n#define bn_abs \tRLC_PREFIX(bn_abs)\n#define bn_neg \tRLC_PREFIX(bn_neg)\n#define bn_sign \tRLC_PREFIX(bn_sign)\n#define bn_zero \tRLC_PREFIX(bn_zero)\n#define bn_is_zero \tRLC_PREFIX(bn_is_zero)\n#define bn_is_even \tRLC_PREFIX(bn_is_even)\n#define bn_bits \tRLC_PREFIX(bn_bits)\n#define bn_get_bit \tRLC_PREFIX(bn_get_bit)\n#define bn_set_bit \tRLC_PREFIX(bn_set_bit)\n#define bn_ham \tRLC_PREFIX(bn_ham)\n#define bn_get_dig \tRLC_PREFIX(bn_get_dig)\n#define bn_set_dig \tRLC_PREFIX(bn_set_dig)\n#define bn_set_2b \tRLC_PREFIX(bn_set_2b)\n#define bn_rand \tRLC_PREFIX(bn_rand)\n#define bn_rand_mod \tRLC_PREFIX(bn_rand_mod)\n#define bn_print \tRLC_PREFIX(bn_print)\n#define bn_size_str \tRLC_PREFIX(bn_size_str)\n#define bn_read_str \tRLC_PREFIX(bn_read_str)\n#define bn_write_str \tRLC_PREFIX(bn_write_str)\n#define bn_size_bin \tRLC_PREFIX(bn_size_bin)\n#define bn_read_bin \tRLC_PREFIX(bn_read_bin)\n#define bn_write_bin \tRLC_PREFIX(bn_write_bin)\n#define bn_size_raw \tRLC_PREFIX(bn_size_raw)\n#define bn_read_raw \tRLC_PREFIX(bn_read_raw)\n#define bn_write_raw \tRLC_PREFIX(bn_write_raw)\n#define bn_cmp_abs \tRLC_PREFIX(bn_cmp_abs)\n#define bn_cmp_dig \tRLC_PREFIX(bn_cmp_dig)\n#define bn_cmp \tRLC_PREFIX(bn_cmp)\n#define bn_add \tRLC_PREFIX(bn_add)\n#define bn_add_dig \tRLC_PREFIX(bn_add_dig)\n#define bn_sub \tRLC_PREFIX(bn_sub)\n#define bn_sub_dig \tRLC_PREFIX(bn_sub_dig)\n#define bn_mul_dig \tRLC_PREFIX(bn_mul_dig)\n#define bn_mul_basic \tRLC_PREFIX(bn_mul_basic)\n#define bn_mul_comba \tRLC_PREFIX(bn_mul_comba)\n#define bn_mul_karat \tRLC_PREFIX(bn_mul_karat)\n#define bn_sqr_basic \tRLC_PREFIX(bn_sqr_basic)\n#define bn_sqr_comba \tRLC_PREFIX(bn_sqr_comba)\n#define bn_sqr_karat \tRLC_PREFIX(bn_sqr_karat)\n#define bn_dbl \tRLC_PREFIX(bn_dbl)\n#define bn_hlv \tRLC_PREFIX(bn_hlv)\n#define bn_lsh \tRLC_PREFIX(bn_lsh)\n#define bn_rsh \tRLC_PREFIX(bn_rsh)\n#define bn_div \tRLC_PREFIX(bn_div)\n#define bn_div_rem \tRLC_PREFIX(bn_div_rem)\n#define bn_div_dig \tRLC_PREFIX(bn_div_dig)\n#define bn_div_rem_dig \tRLC_PREFIX(bn_div_rem_dig)\n#define bn_mod_inv \tRLC_PREFIX(bn_mod_inv)\n#define bn_mod_inv_sim \tRLC_PREFIX(bn_mod_inv_sim)\n#define bn_mod_2b \tRLC_PREFIX(bn_mod_2b)\n#define bn_mod_dig \tRLC_PREFIX(bn_mod_dig)\n#define bn_mod_basic \tRLC_PREFIX(bn_mod_basic)\n#define bn_mod_pre_barrt \tRLC_PREFIX(bn_mod_pre_barrt)\n#define bn_mod_barrt \tRLC_PREFIX(bn_mod_barrt)\n#define bn_mod_pre_monty \tRLC_PREFIX(bn_mod_pre_monty)\n#define bn_mod_monty_conv \tRLC_PREFIX(bn_mod_monty_conv)\n#define bn_mod_monty_back \tRLC_PREFIX(bn_mod_monty_back)\n#define bn_mod_monty_basic \tRLC_PREFIX(bn_mod_monty_basic)\n#define bn_mod_monty_comba \tRLC_PREFIX(bn_mod_monty_comba)\n#define bn_mod_pre_pmers \tRLC_PREFIX(bn_mod_pre_pmers)\n#define bn_mod_pmers \tRLC_PREFIX(bn_mod_pmers)\n#define bn_mxp_basic \tRLC_PREFIX(bn_mxp_basic)\n#define bn_mxp_slide \tRLC_PREFIX(bn_mxp_slide)\n#define bn_mxp_monty \tRLC_PREFIX(bn_mxp_monty)\n#define bn_mxp_dig \tRLC_PREFIX(bn_mxp_dig)\n#define bn_mxp_crt \tRLC_PREFIX(bn_mxp_crt)\n#define bn_srt \tRLC_PREFIX(bn_srt)\n#define bn_gcd_basic \tRLC_PREFIX(bn_gcd_basic)\n#define bn_gcd_lehme \tRLC_PREFIX(bn_gcd_lehme)\n#define bn_gcd_binar \tRLC_PREFIX(bn_gcd_binar)\n#define bn_gcd_dig \tRLC_PREFIX(bn_gcd_dig)\n#define bn_gcd_ext_basic \tRLC_PREFIX(bn_gcd_ext_basic)\n#define bn_gcd_ext_lehme \tRLC_PREFIX(bn_gcd_ext_lehme)\n#define bn_gcd_ext_binar \tRLC_PREFIX(bn_gcd_ext_binar)\n#define bn_gcd_ext_mid \tRLC_PREFIX(bn_gcd_ext_mid)\n#define bn_gcd_ext_dig \tRLC_PREFIX(bn_gcd_ext_dig)\n#define bn_lcm \tRLC_PREFIX(bn_lcm)\n#define bn_smb_leg \tRLC_PREFIX(bn_smb_leg)\n#define bn_smb_jac \tRLC_PREFIX(bn_smb_jac)\n#define bn_get_prime \tRLC_PREFIX(bn_get_prime)\n#define bn_is_prime \tRLC_PREFIX(bn_is_prime)\n#define bn_is_prime_basic \tRLC_PREFIX(bn_is_prime_basic)\n#define bn_is_prime_rabin \tRLC_PREFIX(bn_is_prime_rabin)\n#define bn_is_prime_solov \tRLC_PREFIX(bn_is_prime_solov)\n#define bn_gen_prime_basic \tRLC_PREFIX(bn_gen_prime_basic)\n#define bn_gen_prime_safep \tRLC_PREFIX(bn_gen_prime_safep)\n#define bn_gen_prime_stron \tRLC_PREFIX(bn_gen_prime_stron)\n#define bn_gen_prime_factor \tRLC_PREFIX(bn_gen_prime_factor)\n#define bn_factor \tRLC_PREFIX(bn_factor)\n#define bn_is_factor \tRLC_PREFIX(bn_is_factor)\n#define bn_rec_win \tRLC_PREFIX(bn_rec_win)\n#define bn_rec_slw \tRLC_PREFIX(bn_rec_slw)\n#define bn_rec_naf \tRLC_PREFIX(bn_rec_naf)\n#define bn_rec_tnaf \tRLC_PREFIX(bn_rec_tnaf)\n#define bn_rec_rtnaf \tRLC_PREFIX(bn_rec_rtnaf)\n#define bn_rec_tnaf_get \tRLC_PREFIX(bn_rec_tnaf_get)\n#define bn_rec_tnaf_mod \tRLC_PREFIX(bn_rec_tnaf_mod)\n#define bn_rec_reg \tRLC_PREFIX(bn_rec_reg)\n#define bn_rec_jsf \tRLC_PREFIX(bn_rec_jsf)\n#define bn_rec_glv \tRLC_PREFIX(bn_rec_glv)\n#define bn_rec_frb \tRLC_PREFIX(bn_rec_frb)\n#define bn_lag \tRLC_PREFIX(bn_lag)\n#define bn_evl \tRLC_PREFIX(bn_evl)\n\n#undef bn_add1_low\n#undef bn_addn_low\n#undef bn_sub1_low\n#undef bn_subn_low\n#undef bn_cmp1_low\n#undef bn_cmpn_low\n#undef bn_lsh1_low\n#undef bn_lshb_low\n#undef bn_rsh1_low\n#undef bn_rshb_low\n#undef bn_rshs_low\n#undef bn_mula_low\n#undef bn_mul1_low\n#undef bn_muls_low\n#undef bn_muln_low\n#undef bn_muld_low\n#undef bn_sqra_low\n#undef bn_sqrn_low\n#undef bn_divn_low\n#undef bn_div1_low\n#undef bn_modn_low\n\n#define bn_add1_low \tRLC_PREFIX(bn_add1_low)\n#define bn_addn_low \tRLC_PREFIX(bn_addn_low)\n#define bn_sub1_low \tRLC_PREFIX(bn_sub1_low)\n#define bn_subn_low \tRLC_PREFIX(bn_subn_low)\n#define bn_cmp1_low \tRLC_PREFIX(bn_cmp1_low)\n#define bn_cmpn_low \tRLC_PREFIX(bn_cmpn_low)\n#define bn_lsh1_low \tRLC_PREFIX(bn_lsh1_low)\n#define bn_lshb_low \tRLC_PREFIX(bn_lshb_low)\n#define bn_rsh1_low \tRLC_PREFIX(bn_rsh1_low)\n#define bn_rshb_low \tRLC_PREFIX(bn_rshb_low)\n#define bn_rshs_low \tRLC_PREFIX(bn_rshs_low)\n#define bn_mula_low \tRLC_PREFIX(bn_mula_low)\n#define bn_mul1_low \tRLC_PREFIX(bn_mul1_low)\n#define bn_muls_low \tRLC_PREFIX(bn_muls_low)\n#define bn_muln_low \tRLC_PREFIX(bn_muln_low)\n#define bn_muld_low \tRLC_PREFIX(bn_muld_low)\n#define bn_sqra_low \tRLC_PREFIX(bn_sqra_low)\n#define bn_sqrn_low \tRLC_PREFIX(bn_sqrn_low)\n#define bn_divn_low \tRLC_PREFIX(bn_divn_low)\n#define bn_div1_low \tRLC_PREFIX(bn_div1_low)\n#define bn_modn_low \tRLC_PREFIX(bn_modn_low)\n\n#undef fp_st\n#undef fp_t\n#define fp_st\t        RLC_PREFIX(fp_st)\n#define fp_t          RLC_PREFIX(fp_t)\n\n#undef fp_prime_init\n#undef fp_prime_clean\n#undef fp_prime_get\n#undef fp_prime_get_rdc\n#undef fp_prime_get_conv\n#undef fp_prime_get_mod8\n#undef fp_prime_get_sps\n#undef fp_prime_get_qnr\n#undef fp_prime_get_cnr\n#undef fp_prime_get_2ad\n#undef fp_param_get\n#undef fp_prime_set_dense\n#undef fp_prime_set_pmers\n#undef fp_prime_set_pairf\n#undef fp_prime_calc\n#undef fp_prime_conv\n#undef fp_prime_conv_dig\n#undef fp_prime_back\n#undef fp_param_set\n#undef fp_param_set_any\n#undef fp_param_set_any_dense\n#undef fp_param_set_any_pmers\n#undef fp_param_set_any_tower\n#undef fp_param_set_any_h2adc\n#undef fp_param_print\n#undef fp_prime_get_par\n#undef fp_prime_get_par_sps\n#undef fp_param_get_sps\n#undef fp_copy\n#undef fp_zero\n#undef fp_is_zero\n#undef fp_is_even\n#undef fp_get_bit\n#undef fp_set_bit\n#undef fp_set_dig\n#undef fp_bits\n#undef fp_rand\n#undef fp_print\n#undef fp_size_str\n#undef fp_read_str\n#undef fp_write_str\n#undef fp_read_bin\n#undef fp_write_bin\n#undef fp_cmp\n#undef fp_cmp_dig\n#undef fp_add_basic\n#undef fp_add_integ\n#undef fp_add_dig\n#undef fp_sub_basic\n#undef fp_sub_integ\n#undef fp_sub_dig\n#undef fp_neg_basic\n#undef fp_neg_integ\n#undef fp_dbl_basic\n#undef fp_dbl_integ\n#undef fp_hlv_basic\n#undef fp_hlv_integ\n#undef fp_mul_basic\n#undef fp_mul_comba\n#undef fp_mul_integ\n#undef fp_mul_karat\n#undef fp_mul_dig\n#undef fp_sqr_basic\n#undef fp_sqr_comba\n#undef fp_sqr_integ\n#undef fp_sqr_karat\n#undef fp_lsh\n#undef fp_rsh\n#undef fp_rdc_basic\n#undef fp_rdc_monty_basic\n#undef fp_rdc_monty_comba\n#undef fp_rdc_quick\n#undef fp_inv_basic\n#undef fp_inv_binar\n#undef fp_inv_monty\n#undef fp_inv_exgcd\n#undef fp_inv_divst\n#undef fp_inv_jmpds\n#undef fp_inv_lower\n#undef fp_inv_sim\n#undef fp_smb_basic\n#undef fp_smb_binar\n#undef fp_smb_divst\n#undef fp_smb_jmpds\n#undef fp_smb_lower\n#undef fp_exp_basic\n#undef fp_exp_slide\n#undef fp_exp_monty\n#undef fp_srt\n\n#define fp_prime_init \tRLC_PREFIX(fp_prime_init)\n#define fp_prime_clean \tRLC_PREFIX(fp_prime_clean)\n#define fp_prime_get \tRLC_PREFIX(fp_prime_get)\n#define fp_prime_get_rdc \tRLC_PREFIX(fp_prime_get_rdc)\n#define fp_prime_get_conv \tRLC_PREFIX(fp_prime_get_conv)\n#define fp_prime_get_mod8 \tRLC_PREFIX(fp_prime_get_mod8)\n#define fp_prime_get_sps \tRLC_PREFIX(fp_prime_get_sps)\n#define fp_prime_get_qnr \tRLC_PREFIX(fp_prime_get_qnr)\n#define fp_prime_get_cnr \tRLC_PREFIX(fp_prime_get_cnr)\n#define fp_prime_get_2ad \tRLC_PREFIX(fp_prime_get_2ad)\n#define fp_param_get \tRLC_PREFIX(fp_param_get)\n#define fp_prime_set_dense \tRLC_PREFIX(fp_prime_set_dense)\n#define fp_prime_set_pmers \tRLC_PREFIX(fp_prime_set_pmers)\n#define fp_prime_set_pairf \tRLC_PREFIX(fp_prime_set_pairf)\n#define fp_prime_calc \tRLC_PREFIX(fp_prime_calc)\n#define fp_prime_conv \tRLC_PREFIX(fp_prime_conv)\n#define fp_prime_conv_dig \tRLC_PREFIX(fp_prime_conv_dig)\n#define fp_prime_back \tRLC_PREFIX(fp_prime_back)\n#define fp_param_set \tRLC_PREFIX(fp_param_set)\n#define fp_param_set_any \tRLC_PREFIX(fp_param_set_any)\n#define fp_param_set_any_dense \tRLC_PREFIX(fp_param_set_any_dense)\n#define fp_param_set_any_pmers \tRLC_PREFIX(fp_param_set_any_pmers)\n#define fp_param_set_any_tower \tRLC_PREFIX(fp_param_set_any_tower)\n#define fp_param_set_any_h2adc \tRLC_PREFIX(fp_param_set_any_h2adc)\n#define fp_param_print \tRLC_PREFIX(fp_param_print)\n#define fp_prime_get_par \tRLC_PREFIX(fp_prime_get_par)\n#define fp_prime_get_par_sps \tRLC_PREFIX(fp_prime_get_par_sps)\n#define fp_param_get_sps \tRLC_PREFIX(fp_param_get_sps)\n#define fp_copy \tRLC_PREFIX(fp_copy)\n#define fp_zero \tRLC_PREFIX(fp_zero)\n#define fp_is_zero \tRLC_PREFIX(fp_is_zero)\n#define fp_is_even \tRLC_PREFIX(fp_is_even)\n#define fp_get_bit \tRLC_PREFIX(fp_get_bit)\n#define fp_set_bit \tRLC_PREFIX(fp_set_bit)\n#define fp_set_dig \tRLC_PREFIX(fp_set_dig)\n#define fp_bits \tRLC_PREFIX(fp_bits)\n#define fp_rand \tRLC_PREFIX(fp_rand)\n#define fp_print \tRLC_PREFIX(fp_print)\n#define fp_size_str \tRLC_PREFIX(fp_size_str)\n#define fp_read_str \tRLC_PREFIX(fp_read_str)\n#define fp_write_str \tRLC_PREFIX(fp_write_str)\n#define fp_read_bin \tRLC_PREFIX(fp_read_bin)\n#define fp_write_bin \tRLC_PREFIX(fp_write_bin)\n#define fp_cmp \tRLC_PREFIX(fp_cmp)\n#define fp_cmp_dig \tRLC_PREFIX(fp_cmp_dig)\n#define fp_add_basic \tRLC_PREFIX(fp_add_basic)\n#define fp_add_integ \tRLC_PREFIX(fp_add_integ)\n#define fp_add_dig \tRLC_PREFIX(fp_add_dig)\n#define fp_sub_basic \tRLC_PREFIX(fp_sub_basic)\n#define fp_sub_integ \tRLC_PREFIX(fp_sub_integ)\n#define fp_sub_dig \tRLC_PREFIX(fp_sub_dig)\n#define fp_neg_basic \tRLC_PREFIX(fp_neg_basic)\n#define fp_neg_integ \tRLC_PREFIX(fp_neg_integ)\n#define fp_dbl_basic \tRLC_PREFIX(fp_dbl_basic)\n#define fp_dbl_integ \tRLC_PREFIX(fp_dbl_integ)\n#define fp_hlv_basic \tRLC_PREFIX(fp_hlv_basic)\n#define fp_hlv_integ \tRLC_PREFIX(fp_hlv_integ)\n#define fp_mul_basic \tRLC_PREFIX(fp_mul_basic)\n#define fp_mul_comba \tRLC_PREFIX(fp_mul_comba)\n#define fp_mul_integ \tRLC_PREFIX(fp_mul_integ)\n#define fp_mul_karat \tRLC_PREFIX(fp_mul_karat)\n#define fp_mul_dig \tRLC_PREFIX(fp_mul_dig)\n#define fp_sqr_basic \tRLC_PREFIX(fp_sqr_basic)\n#define fp_sqr_comba \tRLC_PREFIX(fp_sqr_comba)\n#define fp_sqr_integ \tRLC_PREFIX(fp_sqr_integ)\n#define fp_sqr_karat \tRLC_PREFIX(fp_sqr_karat)\n#define fp_lsh \tRLC_PREFIX(fp_lsh)\n#define fp_rsh \tRLC_PREFIX(fp_rsh)\n#define fp_rdc_basic \tRLC_PREFIX(fp_rdc_basic)\n#define fp_rdc_monty_basic \tRLC_PREFIX(fp_rdc_monty_basic)\n#define fp_rdc_monty_comba \tRLC_PREFIX(fp_rdc_monty_comba)\n#define fp_rdc_quick \tRLC_PREFIX(fp_rdc_quick)\n#define fp_inv_basic \tRLC_PREFIX(fp_inv_basic)\n#define fp_inv_binar \tRLC_PREFIX(fp_inv_binar)\n#define fp_inv_monty \tRLC_PREFIX(fp_inv_monty)\n#define fp_inv_exgcd \tRLC_PREFIX(fp_inv_exgcd)\n#define fp_inv_divst \tRLC_PREFIX(fp_inv_divst)\n#define fp_inv_jmpds \tRLC_PREFIX(fp_inv_jmpds)\n#define fp_inv_lower \tRLC_PREFIX(fp_inv_lower)\n#define fp_inv_sim \tRLC_PREFIX(fp_inv_sim)\n#define fp_smb_basic \tRLC_PREFIX(fp_smb_basic)\n#define fp_smb_binar \tRLC_PREFIX(fp_smb_binar)\n#define fp_smb_divst \tRLC_PREFIX(fp_smb_divst)\n#define fp_smb_jmpds \tRLC_PREFIX(fp_smb_jmpds)\n#define fp_smb_lower \tRLC_PREFIX(fp_smb_lower)\n#define fp_exp_basic \tRLC_PREFIX(fp_exp_basic)\n#define fp_exp_slide \tRLC_PREFIX(fp_exp_slide)\n#define fp_exp_monty \tRLC_PREFIX(fp_exp_monty)\n#define fp_srt \tRLC_PREFIX(fp_srt)\n\n#undef fp_add1_low\n#undef fp_addn_low\n#undef fp_addm_low\n#undef fp_addd_low\n#undef fp_addc_low\n#undef fp_sub1_low\n#undef fp_subn_low\n#undef fp_subm_low\n#undef fp_subd_low\n#undef fp_subc_low\n#undef fp_negm_low\n#undef fp_dbln_low\n#undef fp_dblm_low\n#undef fp_hlvm_low\n#undef fp_hlvd_low\n#undef fp_lsh1_low\n#undef fp_lshb_low\n#undef fp_rsh1_low\n#undef fp_rshb_low\n#undef fp_mula_low\n#undef fp_mul1_low\n#undef fp_muln_low\n#undef fp_mulm_low\n#undef fp_sqrn_low\n#undef fp_sqrm_low\n#undef fp_rdcs_low\n#undef fp_rdcn_low\n#undef fp_invm_low\n#undef fp_smbm_low\n\n#define fp_add1_low \tRLC_PREFIX(fp_add1_low)\n#define fp_addn_low \tRLC_PREFIX(fp_addn_low)\n#define fp_addm_low \tRLC_PREFIX(fp_addm_low)\n#define fp_addd_low \tRLC_PREFIX(fp_addd_low)\n#define fp_addc_low \tRLC_PREFIX(fp_addc_low)\n#define fp_sub1_low \tRLC_PREFIX(fp_sub1_low)\n#define fp_subn_low \tRLC_PREFIX(fp_subn_low)\n#define fp_subm_low \tRLC_PREFIX(fp_subm_low)\n#define fp_subd_low \tRLC_PREFIX(fp_subd_low)\n#define fp_subc_low \tRLC_PREFIX(fp_subc_low)\n#define fp_negm_low \tRLC_PREFIX(fp_negm_low)\n#define fp_dbln_low \tRLC_PREFIX(fp_dbln_low)\n#define fp_dblm_low \tRLC_PREFIX(fp_dblm_low)\n#define fp_hlvm_low \tRLC_PREFIX(fp_hlvm_low)\n#define fp_hlvd_low \tRLC_PREFIX(fp_hlvd_low)\n#define fp_lsh1_low \tRLC_PREFIX(fp_lsh1_low)\n#define fp_lshb_low \tRLC_PREFIX(fp_lshb_low)\n#define fp_rsh1_low \tRLC_PREFIX(fp_rsh1_low)\n#define fp_rshb_low \tRLC_PREFIX(fp_rshb_low)\n#define fp_mula_low \tRLC_PREFIX(fp_mula_low)\n#define fp_mul1_low \tRLC_PREFIX(fp_mul1_low)\n#define fp_muln_low \tRLC_PREFIX(fp_muln_low)\n#define fp_mulm_low \tRLC_PREFIX(fp_mulm_low)\n#define fp_sqrn_low \tRLC_PREFIX(fp_sqrn_low)\n#define fp_sqrm_low \tRLC_PREFIX(fp_sqrm_low)\n#define fp_rdcs_low \tRLC_PREFIX(fp_rdcs_low)\n#define fp_rdcn_low \tRLC_PREFIX(fp_rdcn_low)\n#define fp_invm_low \tRLC_PREFIX(fp_invm_low)\n#define fp_smbm_low \tRLC_PREFIX(fp_smbm_low)\n\n#undef fp_st\n#undef fp_t\n#define fp_st\t        RLC_PREFIX(fp_st)\n#define fp_t          RLC_PREFIX(fp_t)\n\n#undef fb_poly_init\n#undef fb_poly_clean\n#undef fb_poly_get\n#undef fb_poly_set_dense\n#undef fb_poly_set_trino\n#undef fb_poly_set_penta\n#undef fb_poly_get_srz\n#undef fb_poly_tab_srz\n#undef fb_poly_tab_sqr\n#undef fb_poly_get_chain\n#undef fb_poly_get_rdc\n#undef fb_poly_get_trc\n#undef fb_poly_get_slv\n#undef fb_param_set\n#undef fb_param_set_any\n#undef fb_param_print\n#undef fb_poly_add\n#undef fb_copy\n#undef fb_neg\n#undef fb_zero\n#undef fb_is_zero\n#undef fb_get_bit\n#undef fb_set_bit\n#undef fb_set_dig\n#undef fb_bits\n#undef fb_rand\n#undef fb_print\n#undef fb_size_str\n#undef fb_read_str\n#undef fb_write_str\n#undef fb_read_bin\n#undef fb_write_bin\n#undef fb_cmp\n#undef fb_cmp_dig\n#undef fb_add\n#undef fb_add_dig\n#undef fb_mul_basic\n#undef fb_mul_integ\n#undef fb_mul_lodah\n#undef fb_mul_dig\n#undef fb_mul_karat\n#undef fb_sqr_basic\n#undef fb_sqr_integ\n#undef fb_sqr_quick\n#undef fb_lsh\n#undef fb_rsh\n#undef fb_rdc_basic\n#undef fb_rdc_quick\n#undef fb_srt_basic\n#undef fb_srt_quick\n#undef fb_trc_basic\n#undef fb_trc_quick\n#undef fb_inv_basic\n#undef fb_inv_binar\n#undef fb_inv_exgcd\n#undef fb_inv_almos\n#undef fb_inv_itoht\n#undef fb_inv_bruch\n#undef fb_inv_ctaia\n#undef fb_inv_lower\n#undef fb_inv_sim\n#undef fb_exp_2b\n#undef fb_exp_basic\n#undef fb_exp_slide\n#undef fb_exp_monty\n#undef fb_slv_basic\n#undef fb_slv_quick\n#undef fb_itr_basic\n#undef fb_itr_pre_quick\n#undef fb_itr_quick\n\n#define fb_poly_init \tRLC_PREFIX(fb_poly_init)\n#define fb_poly_clean \tRLC_PREFIX(fb_poly_clean)\n#define fb_poly_get \tRLC_PREFIX(fb_poly_get)\n#define fb_poly_set_dense \tRLC_PREFIX(fb_poly_set_dense)\n#define fb_poly_set_trino \tRLC_PREFIX(fb_poly_set_trino)\n#define fb_poly_set_penta \tRLC_PREFIX(fb_poly_set_penta)\n#define fb_poly_get_srz \tRLC_PREFIX(fb_poly_get_srz)\n#define fb_poly_tab_srz \tRLC_PREFIX(fb_poly_tab_srz)\n#define fb_poly_tab_sqr \tRLC_PREFIX(fb_poly_tab_sqr)\n#define fb_poly_get_chain \tRLC_PREFIX(fb_poly_get_chain)\n#define fb_poly_get_rdc \tRLC_PREFIX(fb_poly_get_rdc)\n#define fb_poly_get_trc \tRLC_PREFIX(fb_poly_get_trc)\n#define fb_poly_get_slv \tRLC_PREFIX(fb_poly_get_slv)\n#define fb_param_set \tRLC_PREFIX(fb_param_set)\n#define fb_param_set_any \tRLC_PREFIX(fb_param_set_any)\n#define fb_param_print \tRLC_PREFIX(fb_param_print)\n#define fb_poly_add \tRLC_PREFIX(fb_poly_add)\n#define fb_copy \tRLC_PREFIX(fb_copy)\n#define fb_neg \tRLC_PREFIX(fb_neg)\n#define fb_zero \tRLC_PREFIX(fb_zero)\n#define fb_is_zero \tRLC_PREFIX(fb_is_zero)\n#define fb_get_bit \tRLC_PREFIX(fb_get_bit)\n#define fb_set_bit \tRLC_PREFIX(fb_set_bit)\n#define fb_set_dig \tRLC_PREFIX(fb_set_dig)\n#define fb_bits \tRLC_PREFIX(fb_bits)\n#define fb_rand \tRLC_PREFIX(fb_rand)\n#define fb_print \tRLC_PREFIX(fb_print)\n#define fb_size_str \tRLC_PREFIX(fb_size_str)\n#define fb_read_str \tRLC_PREFIX(fb_read_str)\n#define fb_write_str \tRLC_PREFIX(fb_write_str)\n#define fb_read_bin \tRLC_PREFIX(fb_read_bin)\n#define fb_write_bin \tRLC_PREFIX(fb_write_bin)\n#define fb_cmp \tRLC_PREFIX(fb_cmp)\n#define fb_cmp_dig \tRLC_PREFIX(fb_cmp_dig)\n#define fb_add \tRLC_PREFIX(fb_add)\n#define fb_add_dig \tRLC_PREFIX(fb_add_dig)\n#define fb_mul_basic \tRLC_PREFIX(fb_mul_basic)\n#define fb_mul_integ \tRLC_PREFIX(fb_mul_integ)\n#define fb_mul_lodah \tRLC_PREFIX(fb_mul_lodah)\n#define fb_mul_dig \tRLC_PREFIX(fb_mul_dig)\n#define fb_mul_karat \tRLC_PREFIX(fb_mul_karat)\n#define fb_sqr_basic \tRLC_PREFIX(fb_sqr_basic)\n#define fb_sqr_integ \tRLC_PREFIX(fb_sqr_integ)\n#define fb_sqr_quick \tRLC_PREFIX(fb_sqr_quick)\n#define fb_lsh \tRLC_PREFIX(fb_lsh)\n#define fb_rsh \tRLC_PREFIX(fb_rsh)\n#define fb_rdc_basic \tRLC_PREFIX(fb_rdc_basic)\n#define fb_rdc_quick \tRLC_PREFIX(fb_rdc_quick)\n#define fb_srt_basic \tRLC_PREFIX(fb_srt_basic)\n#define fb_srt_quick \tRLC_PREFIX(fb_srt_quick)\n#define fb_trc_basic \tRLC_PREFIX(fb_trc_basic)\n#define fb_trc_quick \tRLC_PREFIX(fb_trc_quick)\n#define fb_inv_basic \tRLC_PREFIX(fb_inv_basic)\n#define fb_inv_binar \tRLC_PREFIX(fb_inv_binar)\n#define fb_inv_exgcd \tRLC_PREFIX(fb_inv_exgcd)\n#define fb_inv_almos \tRLC_PREFIX(fb_inv_almos)\n#define fb_inv_itoht \tRLC_PREFIX(fb_inv_itoht)\n#define fb_inv_bruch \tRLC_PREFIX(fb_inv_bruch)\n#define fb_inv_ctaia \tRLC_PREFIX(fb_inv_ctaia)\n#define fb_inv_lower \tRLC_PREFIX(fb_inv_lower)\n#define fb_inv_sim \tRLC_PREFIX(fb_inv_sim)\n#define fb_exp_2b \tRLC_PREFIX(fb_exp_2b)\n#define fb_exp_basic \tRLC_PREFIX(fb_exp_basic)\n#define fb_exp_slide \tRLC_PREFIX(fb_exp_slide)\n#define fb_exp_monty \tRLC_PREFIX(fb_exp_monty)\n#define fb_slv_basic \tRLC_PREFIX(fb_slv_basic)\n#define fb_slv_quick \tRLC_PREFIX(fb_slv_quick)\n#define fb_itr_basic \tRLC_PREFIX(fb_itr_basic)\n#define fb_itr_pre_quick \tRLC_PREFIX(fb_itr_pre_quick)\n#define fb_itr_quick \tRLC_PREFIX(fb_itr_quick)\n\n#undef fb_add1_low\n#undef fb_addn_low\n#undef fb_addd_low\n#undef fb_lsh1_low\n#undef fb_lshb_low\n#undef fb_rsh1_low\n#undef fb_rshb_low\n#undef fb_lsha_low\n#undef fb_mul1_low\n#undef fb_muln_low\n#undef fb_muld_low\n#undef fb_mulm_low\n#undef fb_sqrn_low\n#undef fb_sqrl_low\n#undef fb_sqrm_low\n#undef fb_itrn_low\n#undef fb_srtn_low\n#undef fb_slvn_low\n#undef fb_trcn_low\n#undef fb_rdcn_low\n#undef fb_rdc1_low\n#undef fb_invn_low\n\n#define fb_add1_low \tRLC_PREFIX(fb_add1_low)\n#define fb_addn_low \tRLC_PREFIX(fb_addn_low)\n#define fb_addd_low \tRLC_PREFIX(fb_addd_low)\n#define fb_lsh1_low \tRLC_PREFIX(fb_lsh1_low)\n#define fb_lshb_low \tRLC_PREFIX(fb_lshb_low)\n#define fb_rsh1_low \tRLC_PREFIX(fb_rsh1_low)\n#define fb_rshb_low \tRLC_PREFIX(fb_rshb_low)\n#define fb_lsha_low \tRLC_PREFIX(fb_lsha_low)\n#define fb_mul1_low \tRLC_PREFIX(fb_mul1_low)\n#define fb_muln_low \tRLC_PREFIX(fb_muln_low)\n#define fb_muld_low \tRLC_PREFIX(fb_muld_low)\n#define fb_mulm_low \tRLC_PREFIX(fb_mulm_low)\n#define fb_sqrn_low \tRLC_PREFIX(fb_sqrn_low)\n#define fb_sqrl_low \tRLC_PREFIX(fb_sqrl_low)\n#define fb_sqrm_low \tRLC_PREFIX(fb_sqrm_low)\n#define fb_itrn_low \tRLC_PREFIX(fb_itrn_low)\n#define fb_srtn_low \tRLC_PREFIX(fb_srtn_low)\n#define fb_slvn_low \tRLC_PREFIX(fb_slvn_low)\n#define fb_trcn_low \tRLC_PREFIX(fb_trcn_low)\n#define fb_rdcn_low \tRLC_PREFIX(fb_rdcn_low)\n#define fb_rdc1_low \tRLC_PREFIX(fb_rdc1_low)\n#define fb_invn_low \tRLC_PREFIX(fb_invn_low)\n\n#undef ep_st\n#undef ep_t\n#define ep_st         RLC_PREFIX(ep_st)\n#define ep_t          RLC_PREFIX(ep_t)\n\n#undef ep_curve_init\n#undef ep_curve_clean\n#undef ep_curve_get_a\n#undef ep_curve_get_b\n#undef ep_curve_get_b3\n#undef ep_curve_get_beta\n#undef ep_curve_get_v1\n#undef ep_curve_get_v2\n#undef ep_curve_opt_a\n#undef ep_curve_opt_b\n#undef ep_curve_opt_b3\n#undef ep_curve_mul_a\n#undef ep_curve_mul_b\n#undef ep_curve_mul_b3\n#undef ep_curve_is_endom\n#undef ep_curve_is_super\n#undef ep_curve_is_pairf\n#undef ep_curve_is_ctmap\n#undef ep_curve_get_gen\n#undef ep_curve_get_tab\n#undef ep_curve_get_ord\n#undef ep_curve_get_cof\n#undef ep_curve_get_iso\n#undef ep_curve_set_plain\n#undef ep_curve_set_super\n#undef ep_curve_set_endom\n#undef ep_param_set\n#undef ep_param_set_any\n#undef ep_param_set_any_plain\n#undef ep_param_set_any_endom\n#undef ep_param_set_any_super\n#undef ep_param_set_any_pairf\n#undef ep_param_get\n#undef ep_param_print\n#undef ep_param_level\n#undef ep_param_embed\n#undef ep_is_infty\n#undef ep_set_infty\n#undef ep_copy\n#undef ep_cmp\n#undef ep_rand\n#undef ep_blind\n#undef ep_rhs\n#undef ep_on_curve\n#undef ep_tab\n#undef ep_print\n#undef ep_size_bin\n#undef ep_read_bin\n#undef ep_write_bin\n#undef ep_neg\n#undef ep_add_basic\n#undef ep_add_slp_basic\n#undef ep_add_projc\n#undef ep_add_jacob\n#undef ep_sub\n#undef ep_dbl_basic\n#undef ep_dbl_slp_basic\n#undef ep_dbl_projc\n#undef ep_dbl_jacob\n#undef ep_psi\n#undef ep_mul_basic\n#undef ep_mul_slide\n#undef ep_mul_monty\n#undef ep_mul_lwnaf\n#undef ep_mul_lwreg\n#undef ep_mul_gen\n#undef ep_mul_dig\n#undef ep_mul_pre_basic\n#undef ep_mul_pre_yaowi\n#undef ep_mul_pre_nafwi\n#undef ep_mul_pre_combs\n#undef ep_mul_pre_combd\n#undef ep_mul_pre_lwnaf\n#undef ep_mul_fix_basic\n#undef ep_mul_fix_yaowi\n#undef ep_mul_fix_nafwi\n#undef ep_mul_fix_combs\n#undef ep_mul_fix_combd\n#undef ep_mul_fix_lwnaf\n#undef ep_mul_sim_basic\n#undef ep_mul_sim_trick\n#undef ep_mul_sim_inter\n#undef ep_mul_sim_joint\n#undef ep_mul_sim_lot\n#undef ep_mul_sim_gen\n#undef ep_mul_sim_dig\n#undef ep_norm\n#undef ep_norm_sim\n#undef ep_map_from_field\n#undef ep_map\n#undef ep_map_dst\n#undef ep_pck\n#undef ep_upk\n\n#define ep_curve_init \tRLC_PREFIX(ep_curve_init)\n#define ep_curve_clean \tRLC_PREFIX(ep_curve_clean)\n#define ep_curve_get_a \tRLC_PREFIX(ep_curve_get_a)\n#define ep_curve_get_b \tRLC_PREFIX(ep_curve_get_b)\n#define ep_curve_get_b3 \tRLC_PREFIX(ep_curve_get_b3)\n#define ep_curve_get_beta \tRLC_PREFIX(ep_curve_get_beta)\n#define ep_curve_get_v1 \tRLC_PREFIX(ep_curve_get_v1)\n#define ep_curve_get_v2 \tRLC_PREFIX(ep_curve_get_v2)\n#define ep_curve_opt_a \tRLC_PREFIX(ep_curve_opt_a)\n#define ep_curve_opt_b \tRLC_PREFIX(ep_curve_opt_b)\n#define ep_curve_opt_b3 \tRLC_PREFIX(ep_curve_opt_b3)\n#define ep_curve_mul_a \tRLC_PREFIX(ep_curve_mul_a)\n#define ep_curve_mul_b \tRLC_PREFIX(ep_curve_mul_b)\n#define ep_curve_mul_b3 \tRLC_PREFIX(ep_curve_mul_b3)\n#define ep_curve_is_endom \tRLC_PREFIX(ep_curve_is_endom)\n#define ep_curve_is_super \tRLC_PREFIX(ep_curve_is_super)\n#define ep_curve_is_pairf \tRLC_PREFIX(ep_curve_is_pairf)\n#define ep_curve_is_ctmap \tRLC_PREFIX(ep_curve_is_ctmap)\n#define ep_curve_get_gen \tRLC_PREFIX(ep_curve_get_gen)\n#define ep_curve_get_tab \tRLC_PREFIX(ep_curve_get_tab)\n#define ep_curve_get_ord \tRLC_PREFIX(ep_curve_get_ord)\n#define ep_curve_get_cof \tRLC_PREFIX(ep_curve_get_cof)\n#define ep_curve_get_iso \tRLC_PREFIX(ep_curve_get_iso)\n#define ep_curve_set_plain \tRLC_PREFIX(ep_curve_set_plain)\n#define ep_curve_set_super \tRLC_PREFIX(ep_curve_set_super)\n#define ep_curve_set_endom \tRLC_PREFIX(ep_curve_set_endom)\n#define ep_param_set \tRLC_PREFIX(ep_param_set)\n#define ep_param_set_any \tRLC_PREFIX(ep_param_set_any)\n#define ep_param_set_any_plain \tRLC_PREFIX(ep_param_set_any_plain)\n#define ep_param_set_any_endom \tRLC_PREFIX(ep_param_set_any_endom)\n#define ep_param_set_any_super \tRLC_PREFIX(ep_param_set_any_super)\n#define ep_param_set_any_pairf \tRLC_PREFIX(ep_param_set_any_pairf)\n#define ep_param_get \tRLC_PREFIX(ep_param_get)\n#define ep_param_print \tRLC_PREFIX(ep_param_print)\n#define ep_param_level \tRLC_PREFIX(ep_param_level)\n#define ep_param_embed \tRLC_PREFIX(ep_param_embed)\n#define ep_is_infty \tRLC_PREFIX(ep_is_infty)\n#define ep_set_infty \tRLC_PREFIX(ep_set_infty)\n#define ep_copy \tRLC_PREFIX(ep_copy)\n#define ep_cmp \tRLC_PREFIX(ep_cmp)\n#define ep_rand \tRLC_PREFIX(ep_rand)\n#define ep_blind \tRLC_PREFIX(ep_blind)\n#define ep_rhs \tRLC_PREFIX(ep_rhs)\n#define ep_on_curve \tRLC_PREFIX(ep_on_curve)\n#define ep_tab \tRLC_PREFIX(ep_tab)\n#define ep_print \tRLC_PREFIX(ep_print)\n#define ep_size_bin \tRLC_PREFIX(ep_size_bin)\n#define ep_read_bin \tRLC_PREFIX(ep_read_bin)\n#define ep_write_bin \tRLC_PREFIX(ep_write_bin)\n#define ep_neg \tRLC_PREFIX(ep_neg)\n#define ep_add_basic \tRLC_PREFIX(ep_add_basic)\n#define ep_add_slp_basic \tRLC_PREFIX(ep_add_slp_basic)\n#define ep_add_projc \tRLC_PREFIX(ep_add_projc)\n#define ep_add_jacob \tRLC_PREFIX(ep_add_jacob)\n#define ep_sub \tRLC_PREFIX(ep_sub)\n#define ep_dbl_basic \tRLC_PREFIX(ep_dbl_basic)\n#define ep_dbl_slp_basic \tRLC_PREFIX(ep_dbl_slp_basic)\n#define ep_dbl_projc \tRLC_PREFIX(ep_dbl_projc)\n#define ep_dbl_jacob \tRLC_PREFIX(ep_dbl_jacob)\n#define ep_psi \tRLC_PREFIX(ep_psi)\n#define ep_mul_basic \tRLC_PREFIX(ep_mul_basic)\n#define ep_mul_slide \tRLC_PREFIX(ep_mul_slide)\n#define ep_mul_monty \tRLC_PREFIX(ep_mul_monty)\n#define ep_mul_lwnaf \tRLC_PREFIX(ep_mul_lwnaf)\n#define ep_mul_lwreg \tRLC_PREFIX(ep_mul_lwreg)\n#define ep_mul_gen \tRLC_PREFIX(ep_mul_gen)\n#define ep_mul_dig \tRLC_PREFIX(ep_mul_dig)\n#define ep_mul_pre_basic \tRLC_PREFIX(ep_mul_pre_basic)\n#define ep_mul_pre_yaowi \tRLC_PREFIX(ep_mul_pre_yaowi)\n#define ep_mul_pre_nafwi \tRLC_PREFIX(ep_mul_pre_nafwi)\n#define ep_mul_pre_combs \tRLC_PREFIX(ep_mul_pre_combs)\n#define ep_mul_pre_combd \tRLC_PREFIX(ep_mul_pre_combd)\n#define ep_mul_pre_lwnaf \tRLC_PREFIX(ep_mul_pre_lwnaf)\n#define ep_mul_fix_basic \tRLC_PREFIX(ep_mul_fix_basic)\n#define ep_mul_fix_yaowi \tRLC_PREFIX(ep_mul_fix_yaowi)\n#define ep_mul_fix_nafwi \tRLC_PREFIX(ep_mul_fix_nafwi)\n#define ep_mul_fix_combs \tRLC_PREFIX(ep_mul_fix_combs)\n#define ep_mul_fix_combd \tRLC_PREFIX(ep_mul_fix_combd)\n#define ep_mul_fix_lwnaf \tRLC_PREFIX(ep_mul_fix_lwnaf)\n#define ep_mul_sim_basic \tRLC_PREFIX(ep_mul_sim_basic)\n#define ep_mul_sim_trick \tRLC_PREFIX(ep_mul_sim_trick)\n#define ep_mul_sim_inter \tRLC_PREFIX(ep_mul_sim_inter)\n#define ep_mul_sim_joint \tRLC_PREFIX(ep_mul_sim_joint)\n#define ep_mul_sim_lot \tRLC_PREFIX(ep_mul_sim_lot)\n#define ep_mul_sim_gen \tRLC_PREFIX(ep_mul_sim_gen)\n#define ep_mul_sim_dig \tRLC_PREFIX(ep_mul_sim_dig)\n#define ep_norm \tRLC_PREFIX(ep_norm)\n#define ep_norm_sim \tRLC_PREFIX(ep_norm_sim)\n#define ep_map_from_field \tRLC_PREFIX(ep_map_from_field)\n#define ep_map \tRLC_PREFIX(ep_map)\n#define ep_map_dst \tRLC_PREFIX(ep_map_dst)\n#define ep_pck \tRLC_PREFIX(ep_pck)\n#define ep_upk \tRLC_PREFIX(ep_upk)\n\n#undef ed_st\n#undef ed_t\n#define ed_st         RLC_PREFIX(ed_st)\n#define ed_t          RLC_PREFIX(ed_t)\n\n#undef ed_param_set\n#undef ed_param_set_any\n#undef ed_param_get\n#undef ed_curve_get_ord\n#undef ed_curve_get_gen\n#undef ed_curve_get_tab\n#undef ed_curve_get_cof\n#undef ed_param_print\n#undef ed_param_level\n#undef ed_projc_to_extnd\n#undef ed_rand\n#undef ed_blind\n#undef ed_rhs\n#undef ed_copy\n#undef ed_cmp\n#undef ed_set_infty\n#undef ed_is_infty\n#undef ed_neg_basic\n#undef ed_neg_projc\n#undef ed_add_basic\n#undef ed_add_projc\n#undef ed_add_extnd\n#undef ed_sub_basic\n#undef ed_sub_projc\n#undef ed_sub_extnd\n#undef ed_dbl_basic\n#undef ed_dbl_projc\n#undef ed_dbl_extnd\n#undef ed_norm\n#undef ed_norm_sim\n#undef ed_map\n#undef ed_map_dst\n#undef ed_curve_init\n#undef ed_curve_clean\n#undef ed_mul_pre_basic\n#undef ed_mul_pre_yaowi\n#undef ed_mul_pre_nafwi\n#undef ed_mul_pre_combs\n#undef ed_mul_pre_combd\n#undef ed_mul_pre_lwnaf\n#undef ed_mul_fix_basic\n#undef ed_mul_fix_yaowi\n#undef ed_mul_fix_nafwi\n#undef ed_mul_fix_combs\n#undef ed_mul_fix_combd\n#undef ed_mul_fix_lwnaf\n#undef ed_mul_fix_lwnaf_mixed\n#undef ed_mul_gen\n#undef ed_mul_dig\n#undef ed_mul_sim_basic\n#undef ed_mul_sim_trick\n#undef ed_mul_sim_inter\n#undef ed_mul_sim_joint\n#undef ed_mul_sim_lot\n#undef ed_mul_sim_gen\n#undef ed_tab\n#undef ed_print\n#undef ed_on_curve\n#undef ed_size_bin\n#undef ed_read_bin\n#undef ed_write_bin\n#undef ed_mul_basic\n#undef ed_mul_slide\n#undef ed_mul_monty\n#undef ed_mul_lwnaf\n#undef ed_mul_lwreg\n#undef ed_pck\n#undef ed_upk\n\n#define ed_param_set \tRLC_PREFIX(ed_param_set)\n#define ed_param_set_any \tRLC_PREFIX(ed_param_set_any)\n#define ed_param_get \tRLC_PREFIX(ed_param_get)\n#define ed_curve_get_ord \tRLC_PREFIX(ed_curve_get_ord)\n#define ed_curve_get_gen \tRLC_PREFIX(ed_curve_get_gen)\n#define ed_curve_get_tab \tRLC_PREFIX(ed_curve_get_tab)\n#define ed_curve_get_cof \tRLC_PREFIX(ed_curve_get_cof)\n#define ed_param_print \tRLC_PREFIX(ed_param_print)\n#define ed_param_level \tRLC_PREFIX(ed_param_level)\n#define ed_projc_to_extnd \tRLC_PREFIX(ed_projc_to_extnd)\n#define ed_rand \tRLC_PREFIX(ed_rand)\n#define ed_blind \tRLC_PREFIX(ed_blind)\n#define ed_rhs \tRLC_PREFIX(ed_rhs)\n#define ed_copy \tRLC_PREFIX(ed_copy)\n#define ed_cmp \tRLC_PREFIX(ed_cmp)\n#define ed_set_infty \tRLC_PREFIX(ed_set_infty)\n#define ed_is_infty \tRLC_PREFIX(ed_is_infty)\n#define ed_neg_basic \tRLC_PREFIX(ed_neg_basic)\n#define ed_neg_projc \tRLC_PREFIX(ed_neg_projc)\n#define ed_add_basic \tRLC_PREFIX(ed_add_basic)\n#define ed_add_projc \tRLC_PREFIX(ed_add_projc)\n#define ed_add_extnd \tRLC_PREFIX(ed_add_extnd)\n#define ed_sub_basic \tRLC_PREFIX(ed_sub_basic)\n#define ed_sub_projc \tRLC_PREFIX(ed_sub_projc)\n#define ed_sub_extnd \tRLC_PREFIX(ed_sub_extnd)\n#define ed_dbl_basic \tRLC_PREFIX(ed_dbl_basic)\n#define ed_dbl_projc \tRLC_PREFIX(ed_dbl_projc)\n#define ed_dbl_extnd \tRLC_PREFIX(ed_dbl_extnd)\n#define ed_norm \tRLC_PREFIX(ed_norm)\n#define ed_norm_sim \tRLC_PREFIX(ed_norm_sim)\n#define ed_map \tRLC_PREFIX(ed_map)\n#define ed_map_dst \tRLC_PREFIX(ed_map_dst)\n#define ed_curve_init \tRLC_PREFIX(ed_curve_init)\n#define ed_curve_clean \tRLC_PREFIX(ed_curve_clean)\n#define ed_mul_pre_basic \tRLC_PREFIX(ed_mul_pre_basic)\n#define ed_mul_pre_yaowi \tRLC_PREFIX(ed_mul_pre_yaowi)\n#define ed_mul_pre_nafwi \tRLC_PREFIX(ed_mul_pre_nafwi)\n#define ed_mul_pre_combs \tRLC_PREFIX(ed_mul_pre_combs)\n#define ed_mul_pre_combd \tRLC_PREFIX(ed_mul_pre_combd)\n#define ed_mul_pre_lwnaf \tRLC_PREFIX(ed_mul_pre_lwnaf)\n#define ed_mul_fix_basic \tRLC_PREFIX(ed_mul_fix_basic)\n#define ed_mul_fix_yaowi \tRLC_PREFIX(ed_mul_fix_yaowi)\n#define ed_mul_fix_nafwi \tRLC_PREFIX(ed_mul_fix_nafwi)\n#define ed_mul_fix_combs \tRLC_PREFIX(ed_mul_fix_combs)\n#define ed_mul_fix_combd \tRLC_PREFIX(ed_mul_fix_combd)\n#define ed_mul_fix_lwnaf \tRLC_PREFIX(ed_mul_fix_lwnaf)\n#define ed_mul_fix_lwnaf_mixed \tRLC_PREFIX(ed_mul_fix_lwnaf_mixed)\n#define ed_mul_gen \tRLC_PREFIX(ed_mul_gen)\n#define ed_mul_dig \tRLC_PREFIX(ed_mul_dig)\n#define ed_mul_sim_basic \tRLC_PREFIX(ed_mul_sim_basic)\n#define ed_mul_sim_trick \tRLC_PREFIX(ed_mul_sim_trick)\n#define ed_mul_sim_inter \tRLC_PREFIX(ed_mul_sim_inter)\n#define ed_mul_sim_joint \tRLC_PREFIX(ed_mul_sim_joint)\n#define ed_mul_sim_lot \tRLC_PREFIX(ed_mul_sim_lot)\n#define ed_mul_sim_gen \tRLC_PREFIX(ed_mul_sim_gen)\n#define ed_tab \tRLC_PREFIX(ed_tab)\n#define ed_print \tRLC_PREFIX(ed_print)\n#define ed_on_curve \tRLC_PREFIX(ed_on_curve)\n#define ed_size_bin \tRLC_PREFIX(ed_size_bin)\n#define ed_read_bin \tRLC_PREFIX(ed_read_bin)\n#define ed_write_bin \tRLC_PREFIX(ed_write_bin)\n#define ed_mul_basic \tRLC_PREFIX(ed_mul_basic)\n#define ed_mul_slide \tRLC_PREFIX(ed_mul_slide)\n#define ed_mul_monty \tRLC_PREFIX(ed_mul_monty)\n#define ed_mul_lwnaf \tRLC_PREFIX(ed_mul_lwnaf)\n#define ed_mul_lwreg \tRLC_PREFIX(ed_mul_lwreg)\n#define ed_pck \tRLC_PREFIX(ed_pck)\n#define ed_upk \tRLC_PREFIX(ed_upk)\n\n#undef eb_st\n#undef eb_t\n#define eb_st         RLC_PREFIX(eb_st)\n#define eb_t          RLC_PREFIX(eb_t)\n\n#undef eb_curve_init\n#undef eb_curve_clean\n#undef eb_curve_get_a\n#undef eb_curve_get_b\n#undef eb_curve_opt_a\n#undef eb_curve_opt_b\n#undef eb_curve_is_kbltz\n#undef eb_curve_get_gen\n#undef eb_curve_get_tab\n#undef eb_curve_get_ord\n#undef eb_curve_get_cof\n#undef eb_curve_set\n#undef eb_param_set\n#undef eb_param_set_any\n#undef eb_param_set_any_plain\n#undef eb_param_set_any_kbltz\n#undef eb_param_get\n#undef eb_param_print\n#undef eb_param_level\n#undef eb_is_infty\n#undef eb_set_infty\n#undef eb_copy\n#undef eb_cmp\n#undef eb_rand\n#undef eb_blind\n#undef eb_rhs\n#undef eb_on_curve\n#undef eb_tab\n#undef eb_print\n#undef eb_size_bin\n#undef eb_read_bin\n#undef eb_write_bin\n#undef eb_neg_basic\n#undef eb_neg_projc\n#undef eb_add_basic\n#undef eb_add_projc\n#undef eb_sub_basic\n#undef eb_sub_projc\n#undef eb_dbl_basic\n#undef eb_dbl_projc\n#undef eb_hlv\n#undef eb_frb\n#undef eb_mul_basic\n#undef eb_mul_lodah\n#undef eb_mul_lwnaf\n#undef eb_mul_rwnaf\n#undef eb_mul_halve\n#undef eb_mul_gen\n#undef eb_mul_dig\n#undef eb_mul_pre_basic\n#undef eb_mul_pre_yaowi\n#undef eb_mul_pre_nafwi\n#undef eb_mul_pre_combs\n#undef eb_mul_pre_combd\n#undef eb_mul_pre_lwnaf\n#undef eb_mul_fix_basic\n#undef eb_mul_fix_yaowi\n#undef eb_mul_fix_nafwi\n#undef eb_mul_fix_combs\n#undef eb_mul_fix_combd\n#undef eb_mul_fix_lwnaf\n#undef eb_mul_sim_basic\n#undef eb_mul_sim_trick\n#undef eb_mul_sim_inter\n#undef eb_mul_sim_joint\n#undef eb_mul_sim_gen\n#undef eb_norm\n#undef eb_norm_sim\n#undef eb_map\n#undef eb_pck\n#undef eb_upk\n\n#define eb_curve_init \tRLC_PREFIX(eb_curve_init)\n#define eb_curve_clean \tRLC_PREFIX(eb_curve_clean)\n#define eb_curve_get_a \tRLC_PREFIX(eb_curve_get_a)\n#define eb_curve_get_b \tRLC_PREFIX(eb_curve_get_b)\n#define eb_curve_opt_a \tRLC_PREFIX(eb_curve_opt_a)\n#define eb_curve_opt_b \tRLC_PREFIX(eb_curve_opt_b)\n#define eb_curve_is_kbltz \tRLC_PREFIX(eb_curve_is_kbltz)\n#define eb_curve_get_gen \tRLC_PREFIX(eb_curve_get_gen)\n#define eb_curve_get_tab \tRLC_PREFIX(eb_curve_get_tab)\n#define eb_curve_get_ord \tRLC_PREFIX(eb_curve_get_ord)\n#define eb_curve_get_cof \tRLC_PREFIX(eb_curve_get_cof)\n#define eb_curve_set \tRLC_PREFIX(eb_curve_set)\n#define eb_param_set \tRLC_PREFIX(eb_param_set)\n#define eb_param_set_any \tRLC_PREFIX(eb_param_set_any)\n#define eb_param_set_any_plain \tRLC_PREFIX(eb_param_set_any_plain)\n#define eb_param_set_any_kbltz \tRLC_PREFIX(eb_param_set_any_kbltz)\n#define eb_param_get \tRLC_PREFIX(eb_param_get)\n#define eb_param_print \tRLC_PREFIX(eb_param_print)\n#define eb_param_level \tRLC_PREFIX(eb_param_level)\n#define eb_is_infty \tRLC_PREFIX(eb_is_infty)\n#define eb_set_infty \tRLC_PREFIX(eb_set_infty)\n#define eb_copy \tRLC_PREFIX(eb_copy)\n#define eb_cmp \tRLC_PREFIX(eb_cmp)\n#define eb_rand \tRLC_PREFIX(eb_rand)\n#define eb_blind \tRLC_PREFIX(eb_blind)\n#define eb_rhs \tRLC_PREFIX(eb_rhs)\n#define eb_on_curve \tRLC_PREFIX(eb_on_curve)\n#define eb_tab \tRLC_PREFIX(eb_tab)\n#define eb_print \tRLC_PREFIX(eb_print)\n#define eb_size_bin \tRLC_PREFIX(eb_size_bin)\n#define eb_read_bin \tRLC_PREFIX(eb_read_bin)\n#define eb_write_bin \tRLC_PREFIX(eb_write_bin)\n#define eb_neg_basic \tRLC_PREFIX(eb_neg_basic)\n#define eb_neg_projc \tRLC_PREFIX(eb_neg_projc)\n#define eb_add_basic \tRLC_PREFIX(eb_add_basic)\n#define eb_add_projc \tRLC_PREFIX(eb_add_projc)\n#define eb_sub_basic \tRLC_PREFIX(eb_sub_basic)\n#define eb_sub_projc \tRLC_PREFIX(eb_sub_projc)\n#define eb_dbl_basic \tRLC_PREFIX(eb_dbl_basic)\n#define eb_dbl_projc \tRLC_PREFIX(eb_dbl_projc)\n#define eb_hlv \tRLC_PREFIX(eb_hlv)\n#define eb_frb \tRLC_PREFIX(eb_frb)\n#define eb_mul_basic \tRLC_PREFIX(eb_mul_basic)\n#define eb_mul_lodah \tRLC_PREFIX(eb_mul_lodah)\n#define eb_mul_lwnaf \tRLC_PREFIX(eb_mul_lwnaf)\n#define eb_mul_rwnaf \tRLC_PREFIX(eb_mul_rwnaf)\n#define eb_mul_halve \tRLC_PREFIX(eb_mul_halve)\n#define eb_mul_gen \tRLC_PREFIX(eb_mul_gen)\n#define eb_mul_dig \tRLC_PREFIX(eb_mul_dig)\n#define eb_mul_pre_basic \tRLC_PREFIX(eb_mul_pre_basic)\n#define eb_mul_pre_yaowi \tRLC_PREFIX(eb_mul_pre_yaowi)\n#define eb_mul_pre_nafwi \tRLC_PREFIX(eb_mul_pre_nafwi)\n#define eb_mul_pre_combs \tRLC_PREFIX(eb_mul_pre_combs)\n#define eb_mul_pre_combd \tRLC_PREFIX(eb_mul_pre_combd)\n#define eb_mul_pre_lwnaf \tRLC_PREFIX(eb_mul_pre_lwnaf)\n#define eb_mul_fix_basic \tRLC_PREFIX(eb_mul_fix_basic)\n#define eb_mul_fix_yaowi \tRLC_PREFIX(eb_mul_fix_yaowi)\n#define eb_mul_fix_nafwi \tRLC_PREFIX(eb_mul_fix_nafwi)\n#define eb_mul_fix_combs \tRLC_PREFIX(eb_mul_fix_combs)\n#define eb_mul_fix_combd \tRLC_PREFIX(eb_mul_fix_combd)\n#define eb_mul_fix_lwnaf \tRLC_PREFIX(eb_mul_fix_lwnaf)\n#define eb_mul_sim_basic \tRLC_PREFIX(eb_mul_sim_basic)\n#define eb_mul_sim_trick \tRLC_PREFIX(eb_mul_sim_trick)\n#define eb_mul_sim_inter \tRLC_PREFIX(eb_mul_sim_inter)\n#define eb_mul_sim_joint \tRLC_PREFIX(eb_mul_sim_joint)\n#define eb_mul_sim_gen \tRLC_PREFIX(eb_mul_sim_gen)\n#define eb_norm \tRLC_PREFIX(eb_norm)\n#define eb_norm_sim \tRLC_PREFIX(eb_norm_sim)\n#define eb_map \tRLC_PREFIX(eb_map)\n#define eb_pck \tRLC_PREFIX(eb_pck)\n#define eb_upk \tRLC_PREFIX(eb_upk)\n\n#undef ep2_st\n#undef ep2_t\n#define ep2_st        RLC_PREFIX(ep2_st)\n#define ep2_t         RLC_PREFIX(ep2_t)\n\n#undef ep2_curve_init\n#undef ep2_curve_clean\n#undef ep2_curve_get_a\n#undef ep2_curve_get_b\n#undef ep2_curve_get_vs\n#undef ep2_curve_opt_a\n#undef ep2_curve_opt_b\n#undef ep2_curve_is_twist\n#undef ep2_curve_is_ctmap\n#undef ep2_curve_get_gen\n#undef ep2_curve_get_tab\n#undef ep2_curve_get_ord\n#undef ep2_curve_get_cof\n#undef ep2_curve_get_iso\n#undef ep2_curve_set\n#undef ep2_curve_set_twist\n#undef ep2_is_infty\n#undef ep2_set_infty\n#undef ep2_copy\n#undef ep2_cmp\n#undef ep2_rand\n#undef ep2_blind\n#undef ep2_rhs\n#undef ep2_on_curve\n#undef ep2_tab\n#undef ep2_print\n#undef ep2_size_bin\n#undef ep2_read_bin\n#undef ep2_write_bin\n#undef ep2_neg\n#undef ep2_add_basic\n#undef ep2_add_slp_basic\n#undef ep2_add_projc\n#undef ep2_sub\n#undef ep2_dbl_basic\n#undef ep2_dbl_slp_basic\n#undef ep2_dbl_projc\n#undef ep2_mul_basic\n#undef ep2_mul_slide\n#undef ep2_mul_monty\n#undef ep2_mul_lwnaf\n#undef ep2_mul_lwreg\n#undef ep2_mul_gen\n#undef ep2_mul_dig\n#undef ep2_mul_cof\n#undef ep2_mul_pre_basic\n#undef ep2_mul_pre_yaowi\n#undef ep2_mul_pre_nafwi\n#undef ep2_mul_pre_combs\n#undef ep2_mul_pre_combd\n#undef ep2_mul_pre_lwnaf\n#undef ep2_mul_fix_basic\n#undef ep2_mul_fix_yaowi\n#undef ep2_mul_fix_nafwi\n#undef ep2_mul_fix_combs\n#undef ep2_mul_fix_combd\n#undef ep2_mul_fix_lwnaf\n#undef ep2_mul_sim_basic\n#undef ep2_mul_sim_trick\n#undef ep2_mul_sim_inter\n#undef ep2_mul_sim_joint\n#undef ep2_mul_sim_lot\n#undef ep2_mul_sim_gen\n#undef ep2_mul_sim_dig\n#undef ep2_norm\n#undef ep2_norm_sim\n#undef ep2_map_from_field\n#undef ep2_map\n#undef ep2_map_dst\n#undef ep2_frb\n#undef ep2_pck\n#undef ep2_upk\n\n#define ep2_curve_init \tRLC_PREFIX(ep2_curve_init)\n#define ep2_curve_clean \tRLC_PREFIX(ep2_curve_clean)\n#define ep2_curve_get_a \tRLC_PREFIX(ep2_curve_get_a)\n#define ep2_curve_get_b \tRLC_PREFIX(ep2_curve_get_b)\n#define ep2_curve_get_vs \tRLC_PREFIX(ep2_curve_get_vs)\n#define ep2_curve_opt_a \tRLC_PREFIX(ep2_curve_opt_a)\n#define ep2_curve_opt_b \tRLC_PREFIX(ep2_curve_opt_b)\n#define ep2_curve_is_twist \tRLC_PREFIX(ep2_curve_is_twist)\n#define ep2_curve_is_ctmap \tRLC_PREFIX(ep2_curve_is_ctmap)\n#define ep2_curve_get_gen \tRLC_PREFIX(ep2_curve_get_gen)\n#define ep2_curve_get_tab \tRLC_PREFIX(ep2_curve_get_tab)\n#define ep2_curve_get_ord \tRLC_PREFIX(ep2_curve_get_ord)\n#define ep2_curve_get_cof \tRLC_PREFIX(ep2_curve_get_cof)\n#define ep2_curve_get_iso \tRLC_PREFIX(ep2_curve_get_iso)\n#define ep2_curve_set \tRLC_PREFIX(ep2_curve_set)\n#define ep2_curve_set_twist \tRLC_PREFIX(ep2_curve_set_twist)\n#define ep2_is_infty \tRLC_PREFIX(ep2_is_infty)\n#define ep2_set_infty \tRLC_PREFIX(ep2_set_infty)\n#define ep2_copy \tRLC_PREFIX(ep2_copy)\n#define ep2_cmp \tRLC_PREFIX(ep2_cmp)\n#define ep2_rand \tRLC_PREFIX(ep2_rand)\n#define ep2_blind \tRLC_PREFIX(ep2_blind)\n#define ep2_rhs \tRLC_PREFIX(ep2_rhs)\n#define ep2_on_curve \tRLC_PREFIX(ep2_on_curve)\n#define ep2_tab \tRLC_PREFIX(ep2_tab)\n#define ep2_print \tRLC_PREFIX(ep2_print)\n#define ep2_size_bin \tRLC_PREFIX(ep2_size_bin)\n#define ep2_read_bin \tRLC_PREFIX(ep2_read_bin)\n#define ep2_write_bin \tRLC_PREFIX(ep2_write_bin)\n#define ep2_neg \tRLC_PREFIX(ep2_neg)\n#define ep2_add_basic \tRLC_PREFIX(ep2_add_basic)\n#define ep2_add_slp_basic \tRLC_PREFIX(ep2_add_slp_basic)\n#define ep2_add_projc \tRLC_PREFIX(ep2_add_projc)\n#define ep2_sub \tRLC_PREFIX(ep2_sub)\n#define ep2_dbl_basic \tRLC_PREFIX(ep2_dbl_basic)\n#define ep2_dbl_slp_basic \tRLC_PREFIX(ep2_dbl_slp_basic)\n#define ep2_dbl_projc \tRLC_PREFIX(ep2_dbl_projc)\n#define ep2_mul_basic \tRLC_PREFIX(ep2_mul_basic)\n#define ep2_mul_slide \tRLC_PREFIX(ep2_mul_slide)\n#define ep2_mul_monty \tRLC_PREFIX(ep2_mul_monty)\n#define ep2_mul_lwnaf \tRLC_PREFIX(ep2_mul_lwnaf)\n#define ep2_mul_lwreg \tRLC_PREFIX(ep2_mul_lwreg)\n#define ep2_mul_gen \tRLC_PREFIX(ep2_mul_gen)\n#define ep2_mul_dig \tRLC_PREFIX(ep2_mul_dig)\n#define ep2_mul_cof \tRLC_PREFIX(ep2_mul_cof)\n#define ep2_mul_pre_basic \tRLC_PREFIX(ep2_mul_pre_basic)\n#define ep2_mul_pre_yaowi \tRLC_PREFIX(ep2_mul_pre_yaowi)\n#define ep2_mul_pre_nafwi \tRLC_PREFIX(ep2_mul_pre_nafwi)\n#define ep2_mul_pre_combs \tRLC_PREFIX(ep2_mul_pre_combs)\n#define ep2_mul_pre_combd \tRLC_PREFIX(ep2_mul_pre_combd)\n#define ep2_mul_pre_lwnaf \tRLC_PREFIX(ep2_mul_pre_lwnaf)\n#define ep2_mul_fix_basic \tRLC_PREFIX(ep2_mul_fix_basic)\n#define ep2_mul_fix_yaowi \tRLC_PREFIX(ep2_mul_fix_yaowi)\n#define ep2_mul_fix_nafwi \tRLC_PREFIX(ep2_mul_fix_nafwi)\n#define ep2_mul_fix_combs \tRLC_PREFIX(ep2_mul_fix_combs)\n#define ep2_mul_fix_combd \tRLC_PREFIX(ep2_mul_fix_combd)\n#define ep2_mul_fix_lwnaf \tRLC_PREFIX(ep2_mul_fix_lwnaf)\n#define ep2_mul_sim_basic \tRLC_PREFIX(ep2_mul_sim_basic)\n#define ep2_mul_sim_trick \tRLC_PREFIX(ep2_mul_sim_trick)\n#define ep2_mul_sim_inter \tRLC_PREFIX(ep2_mul_sim_inter)\n#define ep2_mul_sim_joint \tRLC_PREFIX(ep2_mul_sim_joint)\n#define ep2_mul_sim_lot \tRLC_PREFIX(ep2_mul_sim_lot)\n#define ep2_mul_sim_gen \tRLC_PREFIX(ep2_mul_sim_gen)\n#define ep2_mul_sim_dig \tRLC_PREFIX(ep2_mul_sim_dig)\n#define ep2_norm \tRLC_PREFIX(ep2_norm)\n#define ep2_norm_sim \tRLC_PREFIX(ep2_norm_sim)\n#define ep2_map_from_field \tRLC_PREFIX(ep2_map_from_field)\n#define ep2_map \tRLC_PREFIX(ep2_map)\n#define ep2_map_dst \tRLC_PREFIX(ep2_map_dst)\n#define ep2_frb \tRLC_PREFIX(ep2_frb)\n#define ep2_pck \tRLC_PREFIX(ep2_pck)\n#define ep2_upk \tRLC_PREFIX(ep2_upk)\n\n#undef ep4_st\n#undef ep4_t\n#define ep4_st        RLC_PREFIX(ep4_st)\n#define ep4_t         RLC_PREFIX(ep4_t)\n\n#undef ep4_curve_init\n#undef ep4_curve_clean\n#undef ep4_curve_get_a\n#undef ep4_curve_get_b\n#undef ep4_curve_get_vs\n#undef ep4_curve_opt_a\n#undef ep4_curve_opt_b\n#undef ep4_curve_is_twist\n#undef ep4_curve_get_gen\n#undef ep4_curve_get_tab\n#undef ep4_curve_get_ord\n#undef ep4_curve_get_cof\n#undef ep4_curve_set\n#undef ep4_curve_set_twist\n#undef ep4_is_infty\n#undef ep4_set_infty\n#undef ep4_copy\n#undef ep4_cmp\n#undef ep4_rand\n#undef ep4_blind\n#undef ep4_rhs\n#undef ep4_on_curve\n#undef ep4_tab\n#undef ep4_print\n#undef ep4_size_bin\n#undef ep4_read_bin\n#undef ep4_write_bin\n#undef ep4_neg\n#undef ep4_add_basic\n#undef ep4_add_slp_basic\n#undef ep4_add_projc\n#undef ep4_sub\n#undef ep4_dbl_basic\n#undef ep4_dbl_slp_basic\n#undef ep4_dbl_projc\n#undef ep4_mul_basic\n#undef ep4_mul_slide\n#undef ep4_mul_monty\n#undef ep4_mul_lwnaf\n#undef ep4_mul_lwreg\n#undef ep4_mul_gen\n#undef ep4_mul_dig\n#undef ep4_mul_cof\n#undef ep4_mul_pre_basic\n#undef ep4_mul_pre_yaowi\n#undef ep4_mul_pre_nafwi\n#undef ep4_mul_pre_combs\n#undef ep4_mul_pre_combd\n#undef ep4_mul_pre_lwnaf\n#undef ep4_mul_fix_basic\n#undef ep4_mul_fix_yaowi\n#undef ep4_mul_fix_nafwi\n#undef ep4_mul_fix_combs\n#undef ep4_mul_fix_combd\n#undef ep4_mul_fix_lwnaf\n#undef ep4_mul_sim_basic\n#undef ep4_mul_sim_trick\n#undef ep4_mul_sim_inter\n#undef ep4_mul_sim_joint\n#undef ep4_mul_sim_lot\n#undef ep4_mul_sim_gen\n#undef ep4_mul_sim_dig\n#undef ep4_norm\n#undef ep4_norm_sim\n#undef ep4_map\n#undef ep4_map_dst\n#undef ep4_frb\n#undef ep4_pck\n#undef ep4_upk\n\n#define ep4_curve_init \tRLC_PREFIX(ep4_curve_init)\n#define ep4_curve_clean \tRLC_PREFIX(ep4_curve_clean)\n#define ep4_curve_get_a \tRLC_PREFIX(ep4_curve_get_a)\n#define ep4_curve_get_b \tRLC_PREFIX(ep4_curve_get_b)\n#define ep4_curve_get_vs \tRLC_PREFIX(ep4_curve_get_vs)\n#define ep4_curve_opt_a \tRLC_PREFIX(ep4_curve_opt_a)\n#define ep4_curve_opt_b \tRLC_PREFIX(ep4_curve_opt_b)\n#define ep4_curve_is_twist \tRLC_PREFIX(ep4_curve_is_twist)\n#define ep4_curve_get_gen \tRLC_PREFIX(ep4_curve_get_gen)\n#define ep4_curve_get_tab \tRLC_PREFIX(ep4_curve_get_tab)\n#define ep4_curve_get_ord \tRLC_PREFIX(ep4_curve_get_ord)\n#define ep4_curve_get_cof \tRLC_PREFIX(ep4_curve_get_cof)\n#define ep4_curve_set \tRLC_PREFIX(ep4_curve_set)\n#define ep4_curve_set_twist \tRLC_PREFIX(ep4_curve_set_twist)\n#define ep4_is_infty \tRLC_PREFIX(ep4_is_infty)\n#define ep4_set_infty \tRLC_PREFIX(ep4_set_infty)\n#define ep4_copy \tRLC_PREFIX(ep4_copy)\n#define ep4_cmp \tRLC_PREFIX(ep4_cmp)\n#define ep4_rand \tRLC_PREFIX(ep4_rand)\n#define ep4_blind \tRLC_PREFIX(ep4_blind)\n#define ep4_rhs \tRLC_PREFIX(ep4_rhs)\n#define ep4_on_curve \tRLC_PREFIX(ep4_on_curve)\n#define ep4_tab \tRLC_PREFIX(ep4_tab)\n#define ep4_print \tRLC_PREFIX(ep4_print)\n#define ep4_size_bin \tRLC_PREFIX(ep4_size_bin)\n#define ep4_read_bin \tRLC_PREFIX(ep4_read_bin)\n#define ep4_write_bin \tRLC_PREFIX(ep4_write_bin)\n#define ep4_neg \tRLC_PREFIX(ep4_neg)\n#define ep4_add_basic \tRLC_PREFIX(ep4_add_basic)\n#define ep4_add_slp_basic \tRLC_PREFIX(ep4_add_slp_basic)\n#define ep4_add_projc \tRLC_PREFIX(ep4_add_projc)\n#define ep4_sub \tRLC_PREFIX(ep4_sub)\n#define ep4_dbl_basic \tRLC_PREFIX(ep4_dbl_basic)\n#define ep4_dbl_slp_basic \tRLC_PREFIX(ep4_dbl_slp_basic)\n#define ep4_dbl_projc \tRLC_PREFIX(ep4_dbl_projc)\n#define ep4_mul_basic \tRLC_PREFIX(ep4_mul_basic)\n#define ep4_mul_slide \tRLC_PREFIX(ep4_mul_slide)\n#define ep4_mul_monty \tRLC_PREFIX(ep4_mul_monty)\n#define ep4_mul_lwnaf \tRLC_PREFIX(ep4_mul_lwnaf)\n#define ep4_mul_lwreg \tRLC_PREFIX(ep4_mul_lwreg)\n#define ep4_mul_gen \tRLC_PREFIX(ep4_mul_gen)\n#define ep4_mul_dig \tRLC_PREFIX(ep4_mul_dig)\n#define ep4_mul_cof \tRLC_PREFIX(ep4_mul_cof)\n#define ep4_mul_pre_basic \tRLC_PREFIX(ep4_mul_pre_basic)\n#define ep4_mul_pre_yaowi \tRLC_PREFIX(ep4_mul_pre_yaowi)\n#define ep4_mul_pre_nafwi \tRLC_PREFIX(ep4_mul_pre_nafwi)\n#define ep4_mul_pre_combs \tRLC_PREFIX(ep4_mul_pre_combs)\n#define ep4_mul_pre_combd \tRLC_PREFIX(ep4_mul_pre_combd)\n#define ep4_mul_pre_lwnaf \tRLC_PREFIX(ep4_mul_pre_lwnaf)\n#define ep4_mul_fix_basic \tRLC_PREFIX(ep4_mul_fix_basic)\n#define ep4_mul_fix_yaowi \tRLC_PREFIX(ep4_mul_fix_yaowi)\n#define ep4_mul_fix_nafwi \tRLC_PREFIX(ep4_mul_fix_nafwi)\n#define ep4_mul_fix_combs \tRLC_PREFIX(ep4_mul_fix_combs)\n#define ep4_mul_fix_combd \tRLC_PREFIX(ep4_mul_fix_combd)\n#define ep4_mul_fix_lwnaf \tRLC_PREFIX(ep4_mul_fix_lwnaf)\n#define ep4_mul_sim_basic \tRLC_PREFIX(ep4_mul_sim_basic)\n#define ep4_mul_sim_trick \tRLC_PREFIX(ep4_mul_sim_trick)\n#define ep4_mul_sim_inter \tRLC_PREFIX(ep4_mul_sim_inter)\n#define ep4_mul_sim_joint \tRLC_PREFIX(ep4_mul_sim_joint)\n#define ep4_mul_sim_lot \tRLC_PREFIX(ep4_mul_sim_lot)\n#define ep4_mul_sim_gen \tRLC_PREFIX(ep4_mul_sim_gen)\n#define ep4_mul_sim_dig \tRLC_PREFIX(ep4_mul_sim_dig)\n#define ep4_norm \tRLC_PREFIX(ep4_norm)\n#define ep4_norm_sim \tRLC_PREFIX(ep4_norm_sim)\n#define ep4_map \tRLC_PREFIX(ep4_map)\n#define ep4_map_dst \tRLC_PREFIX(ep4_map_dst)\n#define ep4_frb \tRLC_PREFIX(ep4_frb)\n#define ep4_pck \tRLC_PREFIX(ep4_pck)\n#define ep4_upk \tRLC_PREFIX(ep4_upk)\n\n#undef fp2_st\n#undef fp2_t\n#undef dv2_t\n#define fp2_st        RLC_PREFIX(fp2_st)\n#define fp2_t         RLC_PREFIX(fp2_t)\n#define dv2_t         RLC_PREFIX(dv2_t)\n#undef fp3_st\n#undef fp3_t\n#undef dv3_t\n#define fp3_st        RLC_PREFIX(fp3_st)\n#define fp3_t         RLC_PREFIX(fp3_t)\n#define dv3_t         RLC_PREFIX(dv3_t)\n#undef fp6_st\n#undef fp6_t\n#undef dv6_t\n#define fp6_st        RLC_PREFIX(fp6_st)\n#define fp6_t         RLC_PREFIX(fp6_t)\n#define dv6_t         RLC_PREFIX(dv6_t)\n#undef fp9_st\n#undef fp8_t\n#undef dv8_t\n#define fp8_st        RLC_PREFIX(fp8_st)\n#define fp8_t         RLC_PREFIX(fp8_t)\n#define dv8_t         RLC_PREFIX(dv8_t)\n#undef fp9_st\n#undef fp9_t\n#undef dv9_t\n#define fp9_st        RLC_PREFIX(fp9_st)\n#define fp9_t         RLC_PREFIX(fp9_t)\n#define dv9_t         RLC_PREFIX(dv9_t)\n#undef fp12_st\n#undef fp12_t\n#undef dv12_t\n#define fp12_st        RLC_PREFIX(fp12_st)\n#define fp12_t         RLC_PREFIX(fp12_t)\n#define dv12_t         RLC_PREFIX(dv12_t)\n#undef fp18_st\n#undef fp18_t\n#undef dv18_t\n#define fp18_st        RLC_PREFIX(fp18_st)\n#define fp18_t         RLC_PREFIX(fp18_t)\n#define dv18_t         RLC_PREFIX(dv18_t)\n#undef fp24_st\n#undef fp24_t\n#undef dv24_t\n#define fp24_st        RLC_PREFIX(fp24_st)\n#define fp24_t         RLC_PREFIX(fp24_t)\n#define dv24_t         RLC_PREFIX(dv24_t)\n#undef fp48_st\n#undef fp48_t\n#undef dv48_t\n#define fp48_st        RLC_PREFIX(fp48_st)\n#define fp48_t         RLC_PREFIX(fp48_t)\n#define dv48_t         RLC_PREFIX(dv48_t)\n#undef fp54_st\n#undef fp54_t\n#undef dv54_t\n#define fp54_st        RLC_PREFIX(fp54_st)\n#define fp54_t         RLC_PREFIX(fp54_t)\n#define dv54_t         RLC_PREFIX(dv54_t)\n\n#undef fp2_add_dig\n#undef fp2_sub_dig\n#undef fp2_field_init\n#undef fp2_field_get_qnr\n#undef fp2_copy\n#undef fp2_zero\n#undef fp2_is_zero\n#undef fp2_rand\n#undef fp2_print\n#undef fp2_size_bin\n#undef fp2_read_bin\n#undef fp2_write_bin\n#undef fp2_cmp\n#undef fp2_cmp_dig\n#undef fp2_set_dig\n#undef fp2_add_basic\n#undef fp2_add_integ\n#undef fp2_sub_basic\n#undef fp2_sub_integ\n#undef fp2_neg\n#undef fp2_dbl_basic\n#undef fp2_dbl_integ\n#undef fp2_mul_basic\n#undef fp2_mul_integ\n#undef fp2_mul_art\n#undef fp2_mul_nor_basic\n#undef fp2_mul_nor_integ\n#undef fp2_mul_frb\n#undef fp2_mul_dig\n#undef fp2_sqr_basic\n#undef fp2_sqr_integ\n#undef fp2_inv\n#undef fp2_inv_cyc\n#undef fp2_inv_sim\n#undef fp2_test_cyc\n#undef fp2_conv_cyc\n#undef fp2_exp\n#undef fp2_exp_dig\n#undef fp2_exp_cyc\n#undef fp2_frb\n#undef fp2_srt\n#undef fp2_pck\n#undef fp2_upk\n#undef fp2_exp_cyc_sim\n\n#define fp2_add_dig \tRLC_PREFIX(fp2_add_dig)\n#define fp2_sub_dig \tRLC_PREFIX(fp2_sub_dig)\n#define fp2_field_init \tRLC_PREFIX(fp2_field_init)\n#define fp2_field_get_qnr \tRLC_PREFIX(fp2_field_get_qnr)\n#define fp2_copy \tRLC_PREFIX(fp2_copy)\n#define fp2_zero \tRLC_PREFIX(fp2_zero)\n#define fp2_is_zero \tRLC_PREFIX(fp2_is_zero)\n#define fp2_rand \tRLC_PREFIX(fp2_rand)\n#define fp2_print \tRLC_PREFIX(fp2_print)\n#define fp2_size_bin \tRLC_PREFIX(fp2_size_bin)\n#define fp2_read_bin \tRLC_PREFIX(fp2_read_bin)\n#define fp2_write_bin \tRLC_PREFIX(fp2_write_bin)\n#define fp2_cmp \tRLC_PREFIX(fp2_cmp)\n#define fp2_cmp_dig \tRLC_PREFIX(fp2_cmp_dig)\n#define fp2_set_dig \tRLC_PREFIX(fp2_set_dig)\n#define fp2_add_basic \tRLC_PREFIX(fp2_add_basic)\n#define fp2_add_integ \tRLC_PREFIX(fp2_add_integ)\n#define fp2_sub_basic \tRLC_PREFIX(fp2_sub_basic)\n#define fp2_sub_integ \tRLC_PREFIX(fp2_sub_integ)\n#define fp2_neg \tRLC_PREFIX(fp2_neg)\n#define fp2_dbl_basic \tRLC_PREFIX(fp2_dbl_basic)\n#define fp2_dbl_integ \tRLC_PREFIX(fp2_dbl_integ)\n#define fp2_mul_basic \tRLC_PREFIX(fp2_mul_basic)\n#define fp2_mul_integ \tRLC_PREFIX(fp2_mul_integ)\n#define fp2_mul_art \tRLC_PREFIX(fp2_mul_art)\n#define fp2_mul_nor_basic \tRLC_PREFIX(fp2_mul_nor_basic)\n#define fp2_mul_nor_integ \tRLC_PREFIX(fp2_mul_nor_integ)\n#define fp2_mul_frb \tRLC_PREFIX(fp2_mul_frb)\n#define fp2_mul_dig \tRLC_PREFIX(fp2_mul_dig)\n#define fp2_sqr_basic \tRLC_PREFIX(fp2_sqr_basic)\n#define fp2_sqr_integ \tRLC_PREFIX(fp2_sqr_integ)\n#define fp2_inv \tRLC_PREFIX(fp2_inv)\n#define fp2_inv_cyc \tRLC_PREFIX(fp2_inv_cyc)\n#define fp2_inv_sim \tRLC_PREFIX(fp2_inv_sim)\n#define fp2_test_cyc \tRLC_PREFIX(fp2_test_cyc)\n#define fp2_conv_cyc \tRLC_PREFIX(fp2_conv_cyc)\n#define fp2_exp \tRLC_PREFIX(fp2_exp)\n#define fp2_exp_dig \tRLC_PREFIX(fp2_exp_dig)\n#define fp2_exp_cyc \tRLC_PREFIX(fp2_exp_cyc)\n#define fp2_frb \tRLC_PREFIX(fp2_frb)\n#define fp2_srt \tRLC_PREFIX(fp2_srt)\n#define fp2_pck \tRLC_PREFIX(fp2_pck)\n#define fp2_upk \tRLC_PREFIX(fp2_upk)\n#define fp2_exp_cyc_sim \tRLC_PREFIX(fp2_exp_cyc_sim)\n\n#undef fp2_addn_low\n#undef fp2_addm_low\n#undef fp2_addd_low\n#undef fp2_addc_low\n#undef fp2_subn_low\n#undef fp2_subm_low\n#undef fp2_subd_low\n#undef fp2_subc_low\n#undef fp2_dbln_low\n#undef fp2_dblm_low\n#undef fp2_norm_low\n#undef fp2_norh_low\n#undef fp2_nord_low\n#undef fp2_muln_low\n#undef fp2_mulm_low\n#undef fp2_sqrn_low\n#undef fp2_sqrm_low\n#undef fp2_rdcn_low\n\n#define fp2_addn_low \tRLC_PREFIX(fp2_addn_low)\n#define fp2_addm_low \tRLC_PREFIX(fp2_addm_low)\n#define fp2_addd_low \tRLC_PREFIX(fp2_addd_low)\n#define fp2_addc_low \tRLC_PREFIX(fp2_addc_low)\n#define fp2_subn_low \tRLC_PREFIX(fp2_subn_low)\n#define fp2_subm_low \tRLC_PREFIX(fp2_subm_low)\n#define fp2_subd_low \tRLC_PREFIX(fp2_subd_low)\n#define fp2_subc_low \tRLC_PREFIX(fp2_subc_low)\n#define fp2_dbln_low \tRLC_PREFIX(fp2_dbln_low)\n#define fp2_dblm_low \tRLC_PREFIX(fp2_dblm_low)\n#define fp2_norm_low \tRLC_PREFIX(fp2_norm_low)\n#define fp2_norh_low \tRLC_PREFIX(fp2_norh_low)\n#define fp2_nord_low \tRLC_PREFIX(fp2_nord_low)\n#define fp2_muln_low \tRLC_PREFIX(fp2_muln_low)\n#define fp2_mulm_low \tRLC_PREFIX(fp2_mulm_low)\n#define fp2_sqrn_low \tRLC_PREFIX(fp2_sqrn_low)\n#define fp2_sqrm_low \tRLC_PREFIX(fp2_sqrm_low)\n#define fp2_rdcn_low \tRLC_PREFIX(fp2_rdcn_low)\n\n#undef fp3_field_init\n#undef fp3_copy\n#undef fp3_zero\n#undef fp3_is_zero\n#undef fp3_rand\n#undef fp3_print\n#undef fp3_size_bin\n#undef fp3_read_bin\n#undef fp3_write_bin\n#undef fp3_cmp\n#undef fp3_cmp_dig\n#undef fp3_set_dig\n#undef fp3_add_basic\n#undef fp3_add_integ\n#undef fp3_sub_basic\n#undef fp3_sub_integ\n#undef fp3_neg\n#undef fp3_dbl_basic\n#undef fp3_dbl_integ\n#undef fp3_mul_basic\n#undef fp3_mul_integ\n#undef fp3_mul_nor\n#undef fp3_mul_frb\n#undef fp3_sqr_basic\n#undef fp3_sqr_integ\n#undef fp3_inv\n#undef fp3_inv_sim\n#undef fp3_exp\n#undef fp3_frb\n#undef fp3_srt\n\n#define fp3_field_init \tRLC_PREFIX(fp3_field_init)\n#define fp3_copy \tRLC_PREFIX(fp3_copy)\n#define fp3_zero \tRLC_PREFIX(fp3_zero)\n#define fp3_is_zero \tRLC_PREFIX(fp3_is_zero)\n#define fp3_rand \tRLC_PREFIX(fp3_rand)\n#define fp3_print \tRLC_PREFIX(fp3_print)\n#define fp3_size_bin \tRLC_PREFIX(fp3_size_bin)\n#define fp3_read_bin \tRLC_PREFIX(fp3_read_bin)\n#define fp3_write_bin \tRLC_PREFIX(fp3_write_bin)\n#define fp3_cmp \tRLC_PREFIX(fp3_cmp)\n#define fp3_cmp_dig \tRLC_PREFIX(fp3_cmp_dig)\n#define fp3_set_dig \tRLC_PREFIX(fp3_set_dig)\n#define fp3_add_basic \tRLC_PREFIX(fp3_add_basic)\n#define fp3_add_integ \tRLC_PREFIX(fp3_add_integ)\n#define fp3_sub_basic \tRLC_PREFIX(fp3_sub_basic)\n#define fp3_sub_integ \tRLC_PREFIX(fp3_sub_integ)\n#define fp3_neg \tRLC_PREFIX(fp3_neg)\n#define fp3_dbl_basic \tRLC_PREFIX(fp3_dbl_basic)\n#define fp3_dbl_integ \tRLC_PREFIX(fp3_dbl_integ)\n#define fp3_mul_basic \tRLC_PREFIX(fp3_mul_basic)\n#define fp3_mul_integ \tRLC_PREFIX(fp3_mul_integ)\n#define fp3_mul_nor \tRLC_PREFIX(fp3_mul_nor)\n#define fp3_mul_frb \tRLC_PREFIX(fp3_mul_frb)\n#define fp3_sqr_basic \tRLC_PREFIX(fp3_sqr_basic)\n#define fp3_sqr_integ \tRLC_PREFIX(fp3_sqr_integ)\n#define fp3_inv \tRLC_PREFIX(fp3_inv)\n#define fp3_inv_sim \tRLC_PREFIX(fp3_inv_sim)\n#define fp3_exp \tRLC_PREFIX(fp3_exp)\n#define fp3_frb \tRLC_PREFIX(fp3_frb)\n#define fp3_srt \tRLC_PREFIX(fp3_srt)\n\n#undef fp3_addn_low\n#undef fp3_addm_low\n#undef fp3_addd_low\n#undef fp3_addc_low\n#undef fp3_subn_low\n#undef fp3_subm_low\n#undef fp3_subd_low\n#undef fp3_subc_low\n#undef fp3_dbln_low\n#undef fp3_dblm_low\n#undef fp3_nord_low\n#undef fp3_muln_low\n#undef fp3_mulc_low\n#undef fp3_mulm_low\n#undef fp3_sqrn_low\n#undef fp3_sqrm_low\n#undef fp3_rdcn_low\n\n#define fp3_addn_low \tRLC_PREFIX(fp3_addn_low)\n#define fp3_addm_low \tRLC_PREFIX(fp3_addm_low)\n#define fp3_addd_low \tRLC_PREFIX(fp3_addd_low)\n#define fp3_addc_low \tRLC_PREFIX(fp3_addc_low)\n#define fp3_subn_low \tRLC_PREFIX(fp3_subn_low)\n#define fp3_subm_low \tRLC_PREFIX(fp3_subm_low)\n#define fp3_subd_low \tRLC_PREFIX(fp3_subd_low)\n#define fp3_subc_low \tRLC_PREFIX(fp3_subc_low)\n#define fp3_dbln_low \tRLC_PREFIX(fp3_dbln_low)\n#define fp3_dblm_low \tRLC_PREFIX(fp3_dblm_low)\n#define fp3_nord_low \tRLC_PREFIX(fp3_nord_low)\n#define fp3_muln_low \tRLC_PREFIX(fp3_muln_low)\n#define fp3_mulc_low \tRLC_PREFIX(fp3_mulc_low)\n#define fp3_mulm_low \tRLC_PREFIX(fp3_mulm_low)\n#define fp3_sqrn_low \tRLC_PREFIX(fp3_sqrn_low)\n#define fp3_sqrm_low \tRLC_PREFIX(fp3_sqrm_low)\n#define fp3_rdcn_low \tRLC_PREFIX(fp3_rdcn_low)\n\n#undef fp4_field_init\n#undef fp4_copy\n#undef fp4_zero\n#undef fp4_is_zero\n#undef fp4_rand\n#undef fp4_print\n#undef fp4_size_bin\n#undef fp4_read_bin\n#undef fp4_write_bin\n#undef fp4_cmp\n#undef fp4_cmp_dig\n#undef fp4_set_dig\n#undef fp4_add\n#undef fp4_sub\n#undef fp4_neg\n#undef fp4_dbl\n#undef fp4_mul_unr\n#undef fp4_mul_basic\n#undef fp4_mul_lazyr\n#undef fp4_mul_art\n#undef fp4_mul_frb\n#undef fp4_mul_dxs\n#undef fp4_sqr_unr\n#undef fp4_sqr_basic\n#undef fp4_sqr_lazyr\n#undef fp4_inv\n#undef fp4_inv_sim\n#undef fp4_inv_cyc\n#undef fp4_exp\n#undef fp4_frb\n#undef fp4_srt\n\n#define fp4_field_init \tRLC_PREFIX(fp4_field_init)\n#define fp4_copy \tRLC_PREFIX(fp4_copy)\n#define fp4_zero \tRLC_PREFIX(fp4_zero)\n#define fp4_is_zero \tRLC_PREFIX(fp4_is_zero)\n#define fp4_rand \tRLC_PREFIX(fp4_rand)\n#define fp4_print \tRLC_PREFIX(fp4_print)\n#define fp4_size_bin \tRLC_PREFIX(fp4_size_bin)\n#define fp4_read_bin \tRLC_PREFIX(fp4_read_bin)\n#define fp4_write_bin \tRLC_PREFIX(fp4_write_bin)\n#define fp4_cmp \tRLC_PREFIX(fp4_cmp)\n#define fp4_cmp_dig \tRLC_PREFIX(fp4_cmp_dig)\n#define fp4_set_dig \tRLC_PREFIX(fp4_set_dig)\n#define fp4_add \tRLC_PREFIX(fp4_add)\n#define fp4_sub \tRLC_PREFIX(fp4_sub)\n#define fp4_neg \tRLC_PREFIX(fp4_neg)\n#define fp4_dbl \tRLC_PREFIX(fp4_dbl)\n#define fp4_mul_unr \tRLC_PREFIX(fp4_mul_unr)\n#define fp4_mul_basic \tRLC_PREFIX(fp4_mul_basic)\n#define fp4_mul_lazyr \tRLC_PREFIX(fp4_mul_lazyr)\n#define fp4_mul_art \tRLC_PREFIX(fp4_mul_art)\n#define fp4_mul_frb \tRLC_PREFIX(fp4_mul_frb)\n#define fp4_mul_dxs \tRLC_PREFIX(fp4_mul_dxs)\n#define fp4_sqr_unr \tRLC_PREFIX(fp4_sqr_unr)\n#define fp4_sqr_basic \tRLC_PREFIX(fp4_sqr_basic)\n#define fp4_sqr_lazyr \tRLC_PREFIX(fp4_sqr_lazyr)\n#define fp4_inv \tRLC_PREFIX(fp4_inv)\n#define fp4_inv_sim \tRLC_PREFIX(fp4_inv_sim)\n#define fp4_inv_cyc \tRLC_PREFIX(fp4_inv_cyc)\n#define fp4_exp \tRLC_PREFIX(fp4_exp)\n#define fp4_frb \tRLC_PREFIX(fp4_frb)\n#define fp4_srt \tRLC_PREFIX(fp4_srt)\n\n#undef fp6_copy\n#undef fp6_zero\n#undef fp6_is_zero\n#undef fp6_rand\n#undef fp6_print\n#undef fp6_size_bin\n#undef fp6_read_bin\n#undef fp6_write_bin\n#undef fp6_cmp\n#undef fp6_cmp_dig\n#undef fp6_set_dig\n#undef fp6_add\n#undef fp6_sub\n#undef fp6_neg\n#undef fp6_dbl\n#undef fp6_mul_unr\n#undef fp6_mul_basic\n#undef fp6_mul_lazyr\n#undef fp6_mul_art\n#undef fp6_mul_dxs\n#undef fp6_sqr_unr\n#undef fp6_sqr_basic\n#undef fp6_sqr_lazyr\n#undef fp6_inv\n#undef fp6_exp\n#undef fp6_frb\n\n#define fp6_copy \tRLC_PREFIX(fp6_copy)\n#define fp6_zero \tRLC_PREFIX(fp6_zero)\n#define fp6_is_zero \tRLC_PREFIX(fp6_is_zero)\n#define fp6_rand \tRLC_PREFIX(fp6_rand)\n#define fp6_print \tRLC_PREFIX(fp6_print)\n#define fp6_size_bin \tRLC_PREFIX(fp6_size_bin)\n#define fp6_read_bin \tRLC_PREFIX(fp6_read_bin)\n#define fp6_write_bin \tRLC_PREFIX(fp6_write_bin)\n#define fp6_cmp \tRLC_PREFIX(fp6_cmp)\n#define fp6_cmp_dig \tRLC_PREFIX(fp6_cmp_dig)\n#define fp6_set_dig \tRLC_PREFIX(fp6_set_dig)\n#define fp6_add \tRLC_PREFIX(fp6_add)\n#define fp6_sub \tRLC_PREFIX(fp6_sub)\n#define fp6_neg \tRLC_PREFIX(fp6_neg)\n#define fp6_dbl \tRLC_PREFIX(fp6_dbl)\n#define fp6_mul_unr \tRLC_PREFIX(fp6_mul_unr)\n#define fp6_mul_basic \tRLC_PREFIX(fp6_mul_basic)\n#define fp6_mul_lazyr \tRLC_PREFIX(fp6_mul_lazyr)\n#define fp6_mul_art \tRLC_PREFIX(fp6_mul_art)\n#define fp6_mul_dxs \tRLC_PREFIX(fp6_mul_dxs)\n#define fp6_sqr_unr \tRLC_PREFIX(fp6_sqr_unr)\n#define fp6_sqr_basic \tRLC_PREFIX(fp6_sqr_basic)\n#define fp6_sqr_lazyr \tRLC_PREFIX(fp6_sqr_lazyr)\n#define fp6_inv \tRLC_PREFIX(fp6_inv)\n#define fp6_exp \tRLC_PREFIX(fp6_exp)\n#define fp6_frb \tRLC_PREFIX(fp6_frb)\n\n#undef fp8_copy\n#undef fp8_zero\n#undef fp8_is_zero\n#undef fp8_rand\n#undef fp8_print\n#undef fp8_size_bin\n#undef fp8_read_bin\n#undef fp8_write_bin\n#undef fp8_cmp\n#undef fp8_cmp_dig\n#undef fp8_set_dig\n#undef fp8_add\n#undef fp8_sub\n#undef fp8_neg\n#undef fp8_dbl\n#undef fp8_mul_unr\n#undef fp8_mul_basic\n#undef fp8_mul_lazyr\n#undef fp8_mul_art\n#undef fp8_mul_dxs\n#undef fp8_sqr_unr\n#undef fp8_sqr_basic\n#undef fp8_sqr_lazyr\n#undef fp8_sqr_cyc\n#undef fp8_inv\n#undef fp8_inv_cyc\n#undef fp8_inv_sim\n#undef fp8_test_cyc\n#undef fp8_conv_cyc\n#undef fp8_exp\n#undef fp8_exp_cyc\n#undef fp8_frb\n\n#define fp8_copy \tRLC_PREFIX(fp8_copy)\n#define fp8_zero \tRLC_PREFIX(fp8_zero)\n#define fp8_is_zero \tRLC_PREFIX(fp8_is_zero)\n#define fp8_rand \tRLC_PREFIX(fp8_rand)\n#define fp8_print \tRLC_PREFIX(fp8_print)\n#define fp8_size_bin \tRLC_PREFIX(fp8_size_bin)\n#define fp8_read_bin \tRLC_PREFIX(fp8_read_bin)\n#define fp8_write_bin \tRLC_PREFIX(fp8_write_bin)\n#define fp8_cmp \tRLC_PREFIX(fp8_cmp)\n#define fp8_cmp_dig \tRLC_PREFIX(fp8_cmp_dig)\n#define fp8_set_dig \tRLC_PREFIX(fp8_set_dig)\n#define fp8_add \tRLC_PREFIX(fp8_add)\n#define fp8_sub \tRLC_PREFIX(fp8_sub)\n#define fp8_neg \tRLC_PREFIX(fp8_neg)\n#define fp8_dbl \tRLC_PREFIX(fp8_dbl)\n#define fp8_mul_unr \tRLC_PREFIX(fp8_mul_unr)\n#define fp8_mul_basic \tRLC_PREFIX(fp8_mul_basic)\n#define fp8_mul_lazyr \tRLC_PREFIX(fp8_mul_lazyr)\n#define fp8_mul_art \tRLC_PREFIX(fp8_mul_art)\n#define fp8_mul_dxs \tRLC_PREFIX(fp8_mul_dxs)\n#define fp8_sqr_unr \tRLC_PREFIX(fp8_sqr_unr)\n#define fp8_sqr_basic \tRLC_PREFIX(fp8_sqr_basic)\n#define fp8_sqr_lazyr \tRLC_PREFIX(fp8_sqr_lazyr)\n#define fp8_sqr_cyc \tRLC_PREFIX(fp8_sqr_cyc)\n#define fp8_inv \tRLC_PREFIX(fp8_inv)\n#define fp8_inv_cyc \tRLC_PREFIX(fp8_inv_cyc)\n#define fp8_inv_sim \tRLC_PREFIX(fp8_inv_sim)\n#define fp8_test_cyc \tRLC_PREFIX(fp8_test_cyc)\n#define fp8_conv_cyc \tRLC_PREFIX(fp8_conv_cyc)\n#define fp8_exp \tRLC_PREFIX(fp8_exp)\n#define fp8_exp_cyc \tRLC_PREFIX(fp8_exp_cyc)\n#define fp8_frb \tRLC_PREFIX(fp8_frb)\n\n#undef fp9_copy\n#undef fp9_zero\n#undef fp9_is_zero\n#undef fp9_rand\n#undef fp9_print\n#undef fp9_size_bin\n#undef fp9_read_bin\n#undef fp9_write_bin\n#undef fp9_cmp\n#undef fp9_cmp_dig\n#undef fp9_set_dig\n#undef fp9_add\n#undef fp9_sub\n#undef fp9_neg\n#undef fp9_dbl\n#undef fp9_mul_unr\n#undef fp9_mul_basic\n#undef fp9_mul_lazyr\n#undef fp9_mul_art\n#undef fp9_mul_dxs\n#undef fp9_sqr_unr\n#undef fp9_sqr_basic\n#undef fp9_sqr_lazyr\n#undef fp9_inv\n#undef fp9_inv_sim\n#undef fp9_exp\n#undef fp9_frb\n\n#define fp9_copy \tRLC_PREFIX(fp9_copy)\n#define fp9_zero \tRLC_PREFIX(fp9_zero)\n#define fp9_is_zero \tRLC_PREFIX(fp9_is_zero)\n#define fp9_rand \tRLC_PREFIX(fp9_rand)\n#define fp9_print \tRLC_PREFIX(fp9_print)\n#define fp9_size_bin \tRLC_PREFIX(fp9_size_bin)\n#define fp9_read_bin \tRLC_PREFIX(fp9_read_bin)\n#define fp9_write_bin \tRLC_PREFIX(fp9_write_bin)\n#define fp9_cmp \tRLC_PREFIX(fp9_cmp)\n#define fp9_cmp_dig \tRLC_PREFIX(fp9_cmp_dig)\n#define fp9_set_dig \tRLC_PREFIX(fp9_set_dig)\n#define fp9_add \tRLC_PREFIX(fp9_add)\n#define fp9_sub \tRLC_PREFIX(fp9_sub)\n#define fp9_neg \tRLC_PREFIX(fp9_neg)\n#define fp9_dbl \tRLC_PREFIX(fp9_dbl)\n#define fp9_mul_unr \tRLC_PREFIX(fp9_mul_unr)\n#define fp9_mul_basic \tRLC_PREFIX(fp9_mul_basic)\n#define fp9_mul_lazyr \tRLC_PREFIX(fp9_mul_lazyr)\n#define fp9_mul_art \tRLC_PREFIX(fp9_mul_art)\n#define fp9_mul_dxs \tRLC_PREFIX(fp9_mul_dxs)\n#define fp9_sqr_unr \tRLC_PREFIX(fp9_sqr_unr)\n#define fp9_sqr_basic \tRLC_PREFIX(fp9_sqr_basic)\n#define fp9_sqr_lazyr \tRLC_PREFIX(fp9_sqr_lazyr)\n#define fp9_inv \tRLC_PREFIX(fp9_inv)\n#define fp9_inv_sim \tRLC_PREFIX(fp9_inv_sim)\n#define fp9_exp \tRLC_PREFIX(fp9_exp)\n#define fp9_frb \tRLC_PREFIX(fp9_frb)\n\n#undef fp12_copy\n#undef fp12_zero\n#undef fp12_is_zero\n#undef fp12_rand\n#undef fp12_print\n#undef fp12_size_bin\n#undef fp12_read_bin\n#undef fp12_write_bin\n#undef fp12_cmp\n#undef fp12_cmp_dig\n#undef fp12_set_dig\n#undef fp12_add\n#undef fp12_sub\n#undef fp12_neg\n#undef fp12_dbl\n#undef fp12_mul_unr\n#undef fp12_mul_basic\n#undef fp12_mul_lazyr\n#undef fp12_mul_art\n#undef fp12_mul_dxs_basic\n#undef fp12_mul_dxs_lazyr\n#undef fp12_sqr_unr\n#undef fp12_sqr_basic\n#undef fp12_sqr_lazyr\n#undef fp12_sqr_cyc_basic\n#undef fp12_sqr_cyc_lazyr\n#undef fp12_sqr_pck_basic\n#undef fp12_sqr_pck_lazyr\n#undef fp12_test_cyc\n#undef fp12_conv_cyc\n#undef fp12_back_cyc\n#undef fp12_back_cyc_sim\n#undef fp12_inv\n#undef fp12_inv_cyc\n#undef fp12_frb\n#undef fp12_exp\n#undef fp12_exp_dig\n#undef fp12_exp_cyc\n#undef fp12_exp_cyc_sim\n#undef fp12_exp_cyc_sps\n#undef fp12_pck\n#undef fp12_upk\n#undef fp12_pck_max\n#undef fp12_upk_max\n\n#define fp12_copy \tRLC_PREFIX(fp12_copy)\n#define fp12_zero \tRLC_PREFIX(fp12_zero)\n#define fp12_is_zero \tRLC_PREFIX(fp12_is_zero)\n#define fp12_rand \tRLC_PREFIX(fp12_rand)\n#define fp12_print \tRLC_PREFIX(fp12_print)\n#define fp12_size_bin \tRLC_PREFIX(fp12_size_bin)\n#define fp12_read_bin \tRLC_PREFIX(fp12_read_bin)\n#define fp12_write_bin \tRLC_PREFIX(fp12_write_bin)\n#define fp12_cmp \tRLC_PREFIX(fp12_cmp)\n#define fp12_cmp_dig \tRLC_PREFIX(fp12_cmp_dig)\n#define fp12_set_dig \tRLC_PREFIX(fp12_set_dig)\n#define fp12_add \tRLC_PREFIX(fp12_add)\n#define fp12_sub \tRLC_PREFIX(fp12_sub)\n#define fp12_neg \tRLC_PREFIX(fp12_neg)\n#define fp12_dbl \tRLC_PREFIX(fp12_dbl)\n#define fp12_mul_unr \tRLC_PREFIX(fp12_mul_unr)\n#define fp12_mul_basic \tRLC_PREFIX(fp12_mul_basic)\n#define fp12_mul_lazyr \tRLC_PREFIX(fp12_mul_lazyr)\n#define fp12_mul_art \tRLC_PREFIX(fp12_mul_art)\n#define fp12_mul_dxs_basic \tRLC_PREFIX(fp12_mul_dxs_basic)\n#define fp12_mul_dxs_lazyr \tRLC_PREFIX(fp12_mul_dxs_lazyr)\n#define fp12_sqr_unr \tRLC_PREFIX(fp12_sqr_unr)\n#define fp12_sqr_basic \tRLC_PREFIX(fp12_sqr_basic)\n#define fp12_sqr_lazyr \tRLC_PREFIX(fp12_sqr_lazyr)\n#define fp12_sqr_cyc_basic \tRLC_PREFIX(fp12_sqr_cyc_basic)\n#define fp12_sqr_cyc_lazyr \tRLC_PREFIX(fp12_sqr_cyc_lazyr)\n#define fp12_sqr_pck_basic \tRLC_PREFIX(fp12_sqr_pck_basic)\n#define fp12_sqr_pck_lazyr \tRLC_PREFIX(fp12_sqr_pck_lazyr)\n#define fp12_test_cyc \tRLC_PREFIX(fp12_test_cyc)\n#define fp12_conv_cyc \tRLC_PREFIX(fp12_conv_cyc)\n#define fp12_back_cyc \tRLC_PREFIX(fp12_back_cyc)\n#define fp12_back_cyc_sim \tRLC_PREFIX(fp12_back_cyc_sim)\n#define fp12_inv \tRLC_PREFIX(fp12_inv)\n#define fp12_inv_cyc \tRLC_PREFIX(fp12_inv_cyc)\n#define fp12_frb \tRLC_PREFIX(fp12_frb)\n#define fp12_exp \tRLC_PREFIX(fp12_exp)\n#define fp12_exp_dig \tRLC_PREFIX(fp12_exp_dig)\n#define fp12_exp_cyc \tRLC_PREFIX(fp12_exp_cyc)\n#define fp12_exp_cyc_sim \tRLC_PREFIX(fp12_exp_cyc_sim)\n#define fp12_exp_cyc_sps \tRLC_PREFIX(fp12_exp_cyc_sps)\n#define fp12_pck \tRLC_PREFIX(fp12_pck)\n#define fp12_upk \tRLC_PREFIX(fp12_upk)\n#define fp12_pck_max \tRLC_PREFIX(fp12_pck_max)\n#define fp12_upk_max \tRLC_PREFIX(fp12_upk_max)\n\n#undef fp18_copy\n#undef fp18_zero\n#undef fp18_is_zero\n#undef fp18_rand\n#undef fp18_print\n#undef fp18_size_bin\n#undef fp18_read_bin\n#undef fp18_write_bin\n#undef fp18_cmp\n#undef fp18_cmp_dig\n#undef fp18_set_dig\n#undef fp18_add\n#undef fp18_sub\n#undef fp18_neg\n#undef fp18_dbl\n#undef fp18_mul_unr\n#undef fp18_mul_basic\n#undef fp18_mul_lazyr\n#undef fp18_mul_art\n#undef fp18_mul_dxs_basic\n#undef fp18_mul_dxs_lazyr\n#undef fp18_sqr_unr\n#undef fp18_sqr_basic\n#undef fp18_sqr_lazyr\n#undef fp18_inv\n#undef fp18_inv_cyc\n#undef fp18_conv_cyc\n#undef fp18_frb\n#undef fp18_exp\n\n#define fp18_copy \tRLC_PREFIX(fp18_copy)\n#define fp18_zero \tRLC_PREFIX(fp18_zero)\n#define fp18_is_zero \tRLC_PREFIX(fp18_is_zero)\n#define fp18_rand \tRLC_PREFIX(fp18_rand)\n#define fp18_print \tRLC_PREFIX(fp18_print)\n#define fp18_size_bin \tRLC_PREFIX(fp18_size_bin)\n#define fp18_read_bin \tRLC_PREFIX(fp18_read_bin)\n#define fp18_write_bin \tRLC_PREFIX(fp18_write_bin)\n#define fp18_cmp \tRLC_PREFIX(fp18_cmp)\n#define fp18_cmp_dig \tRLC_PREFIX(fp18_cmp_dig)\n#define fp18_set_dig \tRLC_PREFIX(fp18_set_dig)\n#define fp18_add \tRLC_PREFIX(fp18_add)\n#define fp18_sub \tRLC_PREFIX(fp18_sub)\n#define fp18_neg \tRLC_PREFIX(fp18_neg)\n#define fp18_dbl \tRLC_PREFIX(fp18_dbl)\n#define fp18_mul_unr \tRLC_PREFIX(fp18_mul_unr)\n#define fp18_mul_basic \tRLC_PREFIX(fp18_mul_basic)\n#define fp18_mul_lazyr \tRLC_PREFIX(fp18_mul_lazyr)\n#define fp18_mul_art \tRLC_PREFIX(fp18_mul_art)\n#define fp18_mul_dxs_basic \tRLC_PREFIX(fp18_mul_dxs_basic)\n#define fp18_mul_dxs_lazyr \tRLC_PREFIX(fp18_mul_dxs_lazyr)\n#define fp18_sqr_unr \tRLC_PREFIX(fp18_sqr_unr)\n#define fp18_sqr_basic \tRLC_PREFIX(fp18_sqr_basic)\n#define fp18_sqr_lazyr \tRLC_PREFIX(fp18_sqr_lazyr)\n#define fp18_inv \tRLC_PREFIX(fp18_inv)\n#define fp18_inv_cyc \tRLC_PREFIX(fp18_inv_cyc)\n#define fp18_conv_cyc \tRLC_PREFIX(fp18_conv_cyc)\n#define fp18_frb \tRLC_PREFIX(fp18_frb)\n#define fp18_exp \tRLC_PREFIX(fp18_exp)\n\n#undef fp24_copy\n#undef fp24_zero\n#undef fp24_is_zero\n#undef fp24_rand\n#undef fp24_print\n#undef fp24_size_bin\n#undef fp24_read_bin\n#undef fp24_write_bin\n#undef fp24_cmp\n#undef fp24_cmp_dig\n#undef fp24_set_dig\n#undef fp24_add\n#undef fp24_sub\n#undef fp24_neg\n#undef fp24_dbl\n#undef fp24_mul_unr\n#undef fp24_mul_basic\n#undef fp24_mul_lazyr\n#undef fp24_mul_art\n#undef fp24_mul_dxs\n#undef fp24_sqr_unr\n#undef fp24_sqr_basic\n#undef fp24_sqr_lazyr\n#undef fp24_sqr_cyc_basic\n#undef fp24_sqr_cyc_lazyr\n#undef fp24_sqr_pck_basic\n#undef fp24_sqr_pck_lazyr\n#undef fp24_test_cyc\n#undef fp24_conv_cyc\n#undef fp24_back_cyc\n#undef fp24_back_cyc_sim\n#undef fp24_inv\n#undef fp24_inv_cyc\n#undef fp24_frb\n#undef fp24_exp\n#undef fp24_exp_dig\n#undef fp24_exp_cyc\n#undef fp24_exp_cyc_sim\n#undef fp24_exp_cyc_sps\n#undef fp24_pck\n#undef fp24_upk\n\n#define fp24_copy \tRLC_PREFIX(fp24_copy)\n#define fp24_zero \tRLC_PREFIX(fp24_zero)\n#define fp24_is_zero \tRLC_PREFIX(fp24_is_zero)\n#define fp24_rand \tRLC_PREFIX(fp24_rand)\n#define fp24_print \tRLC_PREFIX(fp24_print)\n#define fp24_size_bin \tRLC_PREFIX(fp24_size_bin)\n#define fp24_read_bin \tRLC_PREFIX(fp24_read_bin)\n#define fp24_write_bin \tRLC_PREFIX(fp24_write_bin)\n#define fp24_cmp \tRLC_PREFIX(fp24_cmp)\n#define fp24_cmp_dig \tRLC_PREFIX(fp24_cmp_dig)\n#define fp24_set_dig \tRLC_PREFIX(fp24_set_dig)\n#define fp24_add \tRLC_PREFIX(fp24_add)\n#define fp24_sub \tRLC_PREFIX(fp24_sub)\n#define fp24_neg \tRLC_PREFIX(fp24_neg)\n#define fp24_dbl \tRLC_PREFIX(fp24_dbl)\n#define fp24_mul_unr \tRLC_PREFIX(fp24_mul_unr)\n#define fp24_mul_basic \tRLC_PREFIX(fp24_mul_basic)\n#define fp24_mul_lazyr \tRLC_PREFIX(fp24_mul_lazyr)\n#define fp24_mul_art \tRLC_PREFIX(fp24_mul_art)\n#define fp24_mul_dxs \tRLC_PREFIX(fp24_mul_dxs)\n#define fp24_sqr_unr \tRLC_PREFIX(fp24_sqr_unr)\n#define fp24_sqr_basic \tRLC_PREFIX(fp24_sqr_basic)\n#define fp24_sqr_lazyr \tRLC_PREFIX(fp24_sqr_lazyr)\n#define fp24_sqr_cyc_basic \tRLC_PREFIX(fp24_sqr_cyc_basic)\n#define fp24_sqr_cyc_lazyr \tRLC_PREFIX(fp24_sqr_cyc_lazyr)\n#define fp24_sqr_pck_basic \tRLC_PREFIX(fp24_sqr_pck_basic)\n#define fp24_sqr_pck_lazyr \tRLC_PREFIX(fp24_sqr_pck_lazyr)\n#define fp24_test_cyc \tRLC_PREFIX(fp24_test_cyc)\n#define fp24_conv_cyc \tRLC_PREFIX(fp24_conv_cyc)\n#define fp24_back_cyc \tRLC_PREFIX(fp24_back_cyc)\n#define fp24_back_cyc_sim \tRLC_PREFIX(fp24_back_cyc_sim)\n#define fp24_inv \tRLC_PREFIX(fp24_inv)\n#define fp24_inv_cyc \tRLC_PREFIX(fp24_inv_cyc)\n#define fp24_frb \tRLC_PREFIX(fp24_frb)\n#define fp24_exp \tRLC_PREFIX(fp24_exp)\n#define fp24_exp_dig \tRLC_PREFIX(fp24_exp_dig)\n#define fp24_exp_cyc \tRLC_PREFIX(fp24_exp_cyc)\n#define fp24_exp_cyc_sim \tRLC_PREFIX(fp24_exp_cyc_sim)\n#define fp24_exp_cyc_sps \tRLC_PREFIX(fp24_exp_cyc_sps)\n#define fp24_pck \tRLC_PREFIX(fp24_pck)\n#define fp24_upk \tRLC_PREFIX(fp24_upk)\n\n#undef fp48_copy\n#undef fp48_zero\n#undef fp48_is_zero\n#undef fp48_rand\n#undef fp48_print\n#undef fp48_size_bin\n#undef fp48_read_bin\n#undef fp48_write_bin\n#undef fp48_cmp\n#undef fp48_cmp_dig\n#undef fp48_set_dig\n#undef fp48_add\n#undef fp48_sub\n#undef fp48_neg\n#undef fp48_dbl\n#undef fp48_mul_basic\n#undef fp48_mul_lazyr\n#undef fp48_mul_art\n#undef fp48_mul_dxs\n#undef fp48_sqr_basic\n#undef fp48_sqr_lazyr\n#undef fp48_sqr_cyc_basic\n#undef fp48_sqr_cyc_lazyr\n#undef fp48_sqr_pck_basic\n#undef fp48_sqr_pck_lazyr\n#undef fp48_test_cyc\n#undef fp48_conv_cyc\n#undef fp48_back_cyc\n#undef fp48_back_cyc_sim\n#undef fp48_inv\n#undef fp48_inv_cyc\n#undef fp48_frb\n#undef fp48_exp\n#undef fp48_exp_dig\n#undef fp48_exp_cyc\n#undef fp48_exp_cyc_sps\n#undef fp48_pck\n#undef fp48_upk\n\n#define fp48_copy \tRLC_PREFIX(fp48_copy)\n#define fp48_zero \tRLC_PREFIX(fp48_zero)\n#define fp48_is_zero \tRLC_PREFIX(fp48_is_zero)\n#define fp48_rand \tRLC_PREFIX(fp48_rand)\n#define fp48_print \tRLC_PREFIX(fp48_print)\n#define fp48_size_bin \tRLC_PREFIX(fp48_size_bin)\n#define fp48_read_bin \tRLC_PREFIX(fp48_read_bin)\n#define fp48_write_bin \tRLC_PREFIX(fp48_write_bin)\n#define fp48_cmp \tRLC_PREFIX(fp48_cmp)\n#define fp48_cmp_dig \tRLC_PREFIX(fp48_cmp_dig)\n#define fp48_set_dig \tRLC_PREFIX(fp48_set_dig)\n#define fp48_add \tRLC_PREFIX(fp48_add)\n#define fp48_sub \tRLC_PREFIX(fp48_sub)\n#define fp48_neg \tRLC_PREFIX(fp48_neg)\n#define fp48_dbl \tRLC_PREFIX(fp48_dbl)\n#define fp48_mul_basic \tRLC_PREFIX(fp48_mul_basic)\n#define fp48_mul_lazyr \tRLC_PREFIX(fp48_mul_lazyr)\n#define fp48_mul_art \tRLC_PREFIX(fp48_mul_art)\n#define fp48_mul_dxs \tRLC_PREFIX(fp48_mul_dxs)\n#define fp48_sqr_basic \tRLC_PREFIX(fp48_sqr_basic)\n#define fp48_sqr_lazyr \tRLC_PREFIX(fp48_sqr_lazyr)\n#define fp48_sqr_cyc_basic \tRLC_PREFIX(fp48_sqr_cyc_basic)\n#define fp48_sqr_cyc_lazyr \tRLC_PREFIX(fp48_sqr_cyc_lazyr)\n#define fp48_sqr_pck_basic \tRLC_PREFIX(fp48_sqr_pck_basic)\n#define fp48_sqr_pck_lazyr \tRLC_PREFIX(fp48_sqr_pck_lazyr)\n#define fp48_test_cyc \tRLC_PREFIX(fp48_test_cyc)\n#define fp48_conv_cyc \tRLC_PREFIX(fp48_conv_cyc)\n#define fp48_back_cyc \tRLC_PREFIX(fp48_back_cyc)\n#define fp48_back_cyc_sim \tRLC_PREFIX(fp48_back_cyc_sim)\n#define fp48_inv \tRLC_PREFIX(fp48_inv)\n#define fp48_inv_cyc \tRLC_PREFIX(fp48_inv_cyc)\n#define fp48_frb \tRLC_PREFIX(fp48_frb)\n#define fp48_exp \tRLC_PREFIX(fp48_exp)\n#define fp48_exp_dig \tRLC_PREFIX(fp48_exp_dig)\n#define fp48_exp_cyc \tRLC_PREFIX(fp48_exp_cyc)\n#define fp48_exp_cyc_sps \tRLC_PREFIX(fp48_exp_cyc_sps)\n#define fp48_pck \tRLC_PREFIX(fp48_pck)\n#define fp48_upk \tRLC_PREFIX(fp48_upk)\n\n#undef fp54_copy\n#undef fp54_zero\n#undef fp54_is_zero\n#undef fp54_rand\n#undef fp54_print\n#undef fp54_size_bin\n#undef fp54_read_bin\n#undef fp54_write_bin\n#undef fp54_cmp\n#undef fp54_cmp_dig\n#undef fp54_set_dig\n#undef fp54_add\n#undef fp54_sub\n#undef fp54_neg\n#undef fp54_dbl\n#undef fp54_mul_basic\n#undef fp54_mul_lazyr\n#undef fp54_mul_art\n#undef fp54_mul_dxs\n#undef fp54_sqr_basic\n#undef fp54_sqr_lazyr\n#undef fp54_sqr_cyc_basic\n#undef fp54_sqr_cyc_lazyr\n#undef fp54_sqr_pck_basic\n#undef fp54_sqr_pck_lazyr\n#undef fp54_test_cyc\n#undef fp54_conv_cyc\n#undef fp54_back_cyc\n#undef fp54_back_cyc_sim\n#undef fp54_inv\n#undef fp54_inv_cyc\n#undef fp54_frb\n#undef fp54_exp\n#undef fp54_exp_dig\n#undef fp54_exp_cyc\n#undef fp54_exp_cyc_sps\n#undef fp54_pck\n#undef fp54_upk\n\n#define fp54_copy \tRLC_PREFIX(fp54_copy)\n#define fp54_zero \tRLC_PREFIX(fp54_zero)\n#define fp54_is_zero \tRLC_PREFIX(fp54_is_zero)\n#define fp54_rand \tRLC_PREFIX(fp54_rand)\n#define fp54_print \tRLC_PREFIX(fp54_print)\n#define fp54_size_bin \tRLC_PREFIX(fp54_size_bin)\n#define fp54_read_bin \tRLC_PREFIX(fp54_read_bin)\n#define fp54_write_bin \tRLC_PREFIX(fp54_write_bin)\n#define fp54_cmp \tRLC_PREFIX(fp54_cmp)\n#define fp54_cmp_dig \tRLC_PREFIX(fp54_cmp_dig)\n#define fp54_set_dig \tRLC_PREFIX(fp54_set_dig)\n#define fp54_add \tRLC_PREFIX(fp54_add)\n#define fp54_sub \tRLC_PREFIX(fp54_sub)\n#define fp54_neg \tRLC_PREFIX(fp54_neg)\n#define fp54_dbl \tRLC_PREFIX(fp54_dbl)\n#define fp54_mul_basic \tRLC_PREFIX(fp54_mul_basic)\n#define fp54_mul_lazyr \tRLC_PREFIX(fp54_mul_lazyr)\n#define fp54_mul_art \tRLC_PREFIX(fp54_mul_art)\n#define fp54_mul_dxs \tRLC_PREFIX(fp54_mul_dxs)\n#define fp54_sqr_basic \tRLC_PREFIX(fp54_sqr_basic)\n#define fp54_sqr_lazyr \tRLC_PREFIX(fp54_sqr_lazyr)\n#define fp54_sqr_cyc_basic \tRLC_PREFIX(fp54_sqr_cyc_basic)\n#define fp54_sqr_cyc_lazyr \tRLC_PREFIX(fp54_sqr_cyc_lazyr)\n#define fp54_sqr_pck_basic \tRLC_PREFIX(fp54_sqr_pck_basic)\n#define fp54_sqr_pck_lazyr \tRLC_PREFIX(fp54_sqr_pck_lazyr)\n#define fp54_test_cyc \tRLC_PREFIX(fp54_test_cyc)\n#define fp54_conv_cyc \tRLC_PREFIX(fp54_conv_cyc)\n#define fp54_back_cyc \tRLC_PREFIX(fp54_back_cyc)\n#define fp54_back_cyc_sim \tRLC_PREFIX(fp54_back_cyc_sim)\n#define fp54_inv \tRLC_PREFIX(fp54_inv)\n#define fp54_inv_cyc \tRLC_PREFIX(fp54_inv_cyc)\n#define fp54_frb \tRLC_PREFIX(fp54_frb)\n#define fp54_exp \tRLC_PREFIX(fp54_exp)\n#define fp54_exp_dig \tRLC_PREFIX(fp54_exp_dig)\n#define fp54_exp_cyc \tRLC_PREFIX(fp54_exp_cyc)\n#define fp54_exp_cyc_sps \tRLC_PREFIX(fp54_exp_cyc_sps)\n#define fp54_pck \tRLC_PREFIX(fp54_pck)\n#define fp54_upk \tRLC_PREFIX(fp54_upk)\n\n#undef fb2_mul\n #undef fb2_mul_nor\n#undef fb2_sqr\n#undef fb2_slv\n#undef fb2_inv\n\n#define fb2_mul \tRLC_PREFIX(fb2_mul)\n #define fb2_mul_nor \tRLC_PREFIX(fb2_mul_nor)\n#define fb2_sqr \tRLC_PREFIX(fb2_sqr)\n#define fb2_slv \tRLC_PREFIX(fb2_slv)\n#define fb2_inv \tRLC_PREFIX(fb2_inv)\n\n\n\n#undef pp_map_init\n#undef pp_map_clean\n#undef pp_add_k2_basic\n#undef pp_add_k2_projc_basic\n#undef pp_add_k2_projc_lazyr\n#undef pp_add_k8_basic\n#undef pp_add_k8_projc_basic\n#undef pp_add_k8_projc_lazyr\n#undef pp_add_k12_basic\n#undef pp_add_k12_projc_basic\n#undef pp_add_k12_projc_lazyr\n#undef pp_add_lit_k12\n#undef pp_add_k24_basic\n#undef pp_add_k24_projc\n#undef pp_add_k48_basic\n#undef pp_add_k48_projc\n#undef pp_add_k54_basic\n#undef pp_add_k54_projc\n#undef pp_dbl_k2_basic\n#undef pp_dbl_k2_projc_basic\n#undef pp_dbl_k2_projc_lazyr\n#undef pp_dbl_k8_basic\n#undef pp_dbl_k8_projc_basic\n#undef pp_dbl_k8_projc_lazyr\n#undef pp_dbl_k12_basic\n#undef pp_dbl_k12_projc_basic\n#undef pp_dbl_k12_projc_lazyr\n#undef pp_dbl_k24_basic\n#undef pp_dbl_k24_projc\n#undef pp_dbl_k48_basic\n#undef pp_dbl_k48_projc\n#undef pp_dbl_k54_basic\n#undef pp_dbl_k54_projc\n#undef pp_dbl_lit_k12\n#undef pp_exp_k2\n#undef pp_exp_k8\n#undef pp_exp_k12\n#undef pp_exp_k24\n#undef pp_exp_k48\n#undef pp_exp_k54\n#undef pp_norm_k2\n#undef pp_norm_k8\n#undef pp_norm_k12\n#undef pp_norm_k24\n#undef pp_map_tatep_k2\n#undef pp_map_sim_tatep_k2\n#undef pp_map_weilp_k2\n#undef pp_map_oatep_k8\n#undef pp_map_sim_weilp_k2\n#undef pp_map_tatep_k12\n#undef pp_map_sim_tatep_k12\n#undef pp_map_weilp_k12\n#undef pp_map_sim_weilp_k12\n#undef pp_map_oatep_k12\n#undef pp_map_sim_oatep_k12\n#undef pp_map_k24\n#undef pp_map_sim_k24\n#undef pp_map_k48\n#undef pp_map_k54\n\n#define pp_map_init \tRLC_PREFIX(pp_map_init)\n#define pp_map_clean \tRLC_PREFIX(pp_map_clean)\n#define pp_add_k2_basic \tRLC_PREFIX(pp_add_k2_basic)\n#define pp_add_k2_projc_basic \tRLC_PREFIX(pp_add_k2_projc_basic)\n#define pp_add_k2_projc_lazyr \tRLC_PREFIX(pp_add_k2_projc_lazyr)\n#define pp_add_k8_basic \tRLC_PREFIX(pp_add_k8_basic)\n#define pp_add_k8_projc_basic \tRLC_PREFIX(pp_add_k8_projc_basic)\n#define pp_add_k8_projc_lazyr \tRLC_PREFIX(pp_add_k8_projc_lazyr)\n#define pp_add_k12_basic \tRLC_PREFIX(pp_add_k12_basic)\n#define pp_add_k12_projc_basic \tRLC_PREFIX(pp_add_k12_projc_basic)\n#define pp_add_k12_projc_lazyr \tRLC_PREFIX(pp_add_k12_projc_lazyr)\n#define pp_add_lit_k12 \tRLC_PREFIX(pp_add_lit_k12)\n#define pp_add_k24_basic \tRLC_PREFIX(pp_add_k24_basic)\n#define pp_add_k24_projc \tRLC_PREFIX(pp_add_k24_projc)\n#define pp_add_k48_basic \tRLC_PREFIX(pp_add_k48_basic)\n#define pp_add_k48_projc \tRLC_PREFIX(pp_add_k48_projc)\n#define pp_add_k54_basic \tRLC_PREFIX(pp_add_k54_basic)\n#define pp_add_k54_projc \tRLC_PREFIX(pp_add_k54_projc)\n#define pp_dbl_k2_basic \tRLC_PREFIX(pp_dbl_k2_basic)\n#define pp_dbl_k2_projc_basic \tRLC_PREFIX(pp_dbl_k2_projc_basic)\n#define pp_dbl_k2_projc_lazyr \tRLC_PREFIX(pp_dbl_k2_projc_lazyr)\n#define pp_dbl_k8_basic \tRLC_PREFIX(pp_dbl_k8_basic)\n#define pp_dbl_k8_projc_basic \tRLC_PREFIX(pp_dbl_k8_projc_basic)\n#define pp_dbl_k8_projc_lazyr \tRLC_PREFIX(pp_dbl_k8_projc_lazyr)\n#define pp_dbl_k12_basic \tRLC_PREFIX(pp_dbl_k12_basic)\n#define pp_dbl_k12_projc_basic \tRLC_PREFIX(pp_dbl_k12_projc_basic)\n#define pp_dbl_k12_projc_lazyr \tRLC_PREFIX(pp_dbl_k12_projc_lazyr)\n#define pp_dbl_k24_basic \tRLC_PREFIX(pp_dbl_k24_basic)\n#define pp_dbl_k24_projc \tRLC_PREFIX(pp_dbl_k24_projc)\n#define pp_dbl_k48_basic \tRLC_PREFIX(pp_dbl_k48_basic)\n#define pp_dbl_k48_projc \tRLC_PREFIX(pp_dbl_k48_projc)\n#define pp_dbl_k54_basic \tRLC_PREFIX(pp_dbl_k54_basic)\n#define pp_dbl_k54_projc \tRLC_PREFIX(pp_dbl_k54_projc)\n#define pp_dbl_lit_k12 \tRLC_PREFIX(pp_dbl_lit_k12)\n#define pp_exp_k2 \tRLC_PREFIX(pp_exp_k2)\n#define pp_exp_k8 \tRLC_PREFIX(pp_exp_k8)\n#define pp_exp_k12 \tRLC_PREFIX(pp_exp_k12)\n#define pp_exp_k24 \tRLC_PREFIX(pp_exp_k24)\n#define pp_exp_k48 \tRLC_PREFIX(pp_exp_k48)\n#define pp_exp_k54 \tRLC_PREFIX(pp_exp_k54)\n#define pp_norm_k2 \tRLC_PREFIX(pp_norm_k2)\n#define pp_norm_k8 \tRLC_PREFIX(pp_norm_k8)\n#define pp_norm_k12 \tRLC_PREFIX(pp_norm_k12)\n#define pp_norm_k24 \tRLC_PREFIX(pp_norm_k24)\n#define pp_map_tatep_k2 \tRLC_PREFIX(pp_map_tatep_k2)\n#define pp_map_sim_tatep_k2 \tRLC_PREFIX(pp_map_sim_tatep_k2)\n#define pp_map_weilp_k2 \tRLC_PREFIX(pp_map_weilp_k2)\n#define pp_map_oatep_k8 \tRLC_PREFIX(pp_map_oatep_k8)\n#define pp_map_sim_weilp_k2 \tRLC_PREFIX(pp_map_sim_weilp_k2)\n#define pp_map_tatep_k12 \tRLC_PREFIX(pp_map_tatep_k12)\n#define pp_map_sim_tatep_k12 \tRLC_PREFIX(pp_map_sim_tatep_k12)\n#define pp_map_weilp_k12 \tRLC_PREFIX(pp_map_weilp_k12)\n#define pp_map_sim_weilp_k12 \tRLC_PREFIX(pp_map_sim_weilp_k12)\n#define pp_map_oatep_k12 \tRLC_PREFIX(pp_map_oatep_k12)\n#define pp_map_sim_oatep_k12 \tRLC_PREFIX(pp_map_sim_oatep_k12)\n#define pp_map_k24 \tRLC_PREFIX(pp_map_k24)\n#define pp_map_sim_k24 \tRLC_PREFIX(pp_map_sim_k24)\n#define pp_map_k48 \tRLC_PREFIX(pp_map_k48)\n#define pp_map_k54 \tRLC_PREFIX(pp_map_k54)\n\n#undef pc_core_init\n#undef pc_core_calc\n#undef pc_core_clean\n\n#define pc_core_init \tRLC_PREFIX(pc_core_init)\n#define pc_core_calc \tRLC_PREFIX(pc_core_calc)\n#define pc_core_clean \tRLC_PREFIX(pc_core_clean)\n\n#undef mpc_mt_gen\n#undef mpc_mt_lcl\n#undef mpc_mt_bct\n#undef mpc_mt_mul\n#undef mpc_sss_gen\n#undef mpc_sss_key\n\n#define mpc_mt_gen \tRLC_PREFIX(mpc_mt_gen)\n#define mpc_mt_lcl \tRLC_PREFIX(mpc_mt_lcl)\n#define mpc_mt_bct \tRLC_PREFIX(mpc_mt_bct)\n#define mpc_mt_mul \tRLC_PREFIX(mpc_mt_mul)\n#define mpc_sss_gen \tRLC_PREFIX(mpc_sss_gen)\n#define mpc_sss_key \tRLC_PREFIX(mpc_sss_key)\n\n#undef crt_t\n#undef rsa_t\n#undef rabin_t\n#undef phpe_t\n#undef bdpe_t\n#undef sokaka_t\n#define crt_t\tRLC_PREFIX(crt_t)\n#define rsa_t\tRLC_PREFIX(rsa_t)\n#define rabin_t\tRLC_PREFIX(rabin_t)\n#define phpe_t\tRLC_PREFIX(phpe_t)\n#define bdpe_t\tRLC_PREFIX(bdpe_t)\n#define sokaka_t\tRLC_PREFIX(sokaka_t)\n\n#undef cp_rsa_gen\n#undef cp_rsa_enc\n#undef cp_rsa_dec\n#undef cp_rsa_sig\n#undef cp_rsa_ver\n#undef cp_rabin_gen\n#undef cp_rabin_enc\n#undef cp_rabin_dec\n#undef cp_bdpe_gen\n#undef cp_bdpe_enc\n#undef cp_bdpe_dec\n#undef cp_phpe_gen\n#undef cp_phpe_enc\n#undef cp_phpe_add\n#undef cp_phpe_dec\n#undef cp_shpe_gen\n#undef cp_shpe_enc\n#undef cp_shpe_enc_prv\n#undef cp_shpe_dec\n#undef cp_ghpe_gen\n#undef cp_ghpe_enc\n#undef cp_ghpe_dec\n#undef cp_ecdh_gen\n#undef cp_ecdh_key\n#undef cp_ecmqv_gen\n#undef cp_ecmqv_key\n#undef cp_ecies_gen\n#undef cp_ecies_enc\n#undef cp_ecies_dec\n#undef cp_ecdsa_gen\n#undef cp_ecdsa_sig\n#undef cp_ecdsa_ver\n#undef cp_ecss_gen\n#undef cp_ecss_sig\n#undef cp_ecss_ver\n#undef cp_pdpub_gen\n#undef cp_pdpub_ask\n#undef cp_pdpub_ans\n#undef cp_pdpub_ver\n#undef cp_pdprv_gen\n#undef cp_pdprv_ask\n#undef cp_pdprv_ans\n#undef cp_pdprv_ver\n#undef cp_lvpub_gen\n#undef cp_lvpub_ask\n#undef cp_lvpub_ans\n#undef cp_lvpub_ver\n#undef cp_lvprv_gen\n#undef cp_lvprv_ask\n#undef cp_lvprv_ans\n#undef cp_lvprv_ver\n#undef cp_sokaka_gen\n#undef cp_sokaka_gen_prv\n#undef cp_sokaka_key\n#undef cp_bgn_gen\n#undef cp_bgn_enc1\n#undef cp_bgn_dec1\n#undef cp_bgn_enc2\n#undef cp_bgn_dec2\n#undef cp_bgn_add\n#undef cp_bgn_mul\n#undef cp_bgn_dec\n#undef cp_ibe_gen\n#undef cp_ibe_gen_prv\n#undef cp_ibe_enc\n#undef cp_ibe_dec\n#undef cp_bls_gen\n#undef cp_bls_sig\n#undef cp_bls_ver\n#undef cp_bbs_gen\n#undef cp_bbs_sig\n#undef cp_bbs_ver\n#undef cp_cls_gen\n#undef cp_cls_sig\n#undef cp_cls_ver\n#undef cp_cli_gen\n#undef cp_cli_sig\n#undef cp_cli_ver\n#undef cp_clb_gen\n#undef cp_clb_sig\n#undef cp_clb_ver\n#undef cp_pss_gen\n#undef cp_pss_sig\n#undef cp_pss_ver\n#undef cp_mpss_gen\n#undef cp_mpss_sig\n#undef cp_mpss_bct\n#undef cp_mpss_ver\n#undef cp_psb_gen\n#undef cp_psb_sig\n#undef cp_psb_ver\n#undef cp_mpsb_gen\n#undef cp_mpsb_sig\n#undef cp_mpsb_bct\n#undef cp_mpsb_ver\n#undef cp_zss_gen\n#undef cp_zss_sig\n#undef cp_zss_ver\n#undef cp_vbnn_gen\n#undef cp_vbnn_gen_prv\n#undef cp_vbnn_sig\n#undef cp_vbnn_ver\n#undef cp_pokdl_prv\n#undef cp_pokdl_ver\n#undef cp_pokor_prv\n#undef cp_pokor_ver\n#undef cp_sokdl_sig\n#undef cp_sokdl_ver\n#undef cp_sokor_sig\n#undef cp_sokor_ver\n#undef cp_ers_gen\n#undef cp_ers_gen_key\n#undef cp_ers_sig\n#undef cp_ers_ver\n#undef cp_ers_ext\n#undef cp_smlers_sig\n#undef cp_smlers_ver\n#undef cp_smlers_ext\n#undef cp_etrs_sig\n#undef cp_etrs_ver\n#undef cp_etrs_ext\n#undef cp_etrs_uni\n#undef cp_cmlhs_init\n#undef cp_cmlhs_gen\n#undef cp_cmlhs_sig\n#undef cp_cmlhs_fun\n#undef cp_cmlhs_evl\n#undef cp_cmlhs_ver\n#undef cp_cmlhs_off\n#undef cp_cmlhs_onv\n#undef cp_mklhs_gen\n#undef cp_mklhs_sig\n#undef cp_mklhs_fun\n#undef cp_mklhs_evl\n#undef cp_mklhs_ver\n#undef cp_mklhs_off\n#undef cp_mklhs_onv\n#undef cp_rsapsi_gen\n#undef cp_rsapsi_ask\n#undef cp_rsapsi_ans\n#undef cp_rsapsi_int\n#undef cp_shipsi_gen\n#undef cp_shipsi_ask\n#undef cp_shipsi_ans\n#undef cp_shipsi_int\n#undef cp_pbpsi_gen\n#undef cp_pbpsi_ask\n#undef cp_pbpsi_ans\n#undef cp_pbpsi_int\n\n#define cp_rsa_gen \tRLC_PREFIX(cp_rsa_gen)\n#define cp_rsa_enc \tRLC_PREFIX(cp_rsa_enc)\n#define cp_rsa_dec \tRLC_PREFIX(cp_rsa_dec)\n#define cp_rsa_sig \tRLC_PREFIX(cp_rsa_sig)\n#define cp_rsa_ver \tRLC_PREFIX(cp_rsa_ver)\n#define cp_rabin_gen \tRLC_PREFIX(cp_rabin_gen)\n#define cp_rabin_enc \tRLC_PREFIX(cp_rabin_enc)\n#define cp_rabin_dec \tRLC_PREFIX(cp_rabin_dec)\n#define cp_bdpe_gen \tRLC_PREFIX(cp_bdpe_gen)\n#define cp_bdpe_enc \tRLC_PREFIX(cp_bdpe_enc)\n#define cp_bdpe_dec \tRLC_PREFIX(cp_bdpe_dec)\n#define cp_phpe_gen \tRLC_PREFIX(cp_phpe_gen)\n#define cp_phpe_enc \tRLC_PREFIX(cp_phpe_enc)\n#define cp_phpe_add \tRLC_PREFIX(cp_phpe_add)\n#define cp_phpe_dec \tRLC_PREFIX(cp_phpe_dec)\n#define cp_shpe_gen \tRLC_PREFIX(cp_shpe_gen)\n#define cp_shpe_enc \tRLC_PREFIX(cp_shpe_enc)\n#define cp_shpe_enc_prv \tRLC_PREFIX(cp_shpe_enc_prv)\n#define cp_shpe_dec \tRLC_PREFIX(cp_shpe_dec)\n#define cp_ghpe_gen \tRLC_PREFIX(cp_ghpe_gen)\n#define cp_ghpe_enc \tRLC_PREFIX(cp_ghpe_enc)\n#define cp_ghpe_dec \tRLC_PREFIX(cp_ghpe_dec)\n#define cp_ecdh_gen \tRLC_PREFIX(cp_ecdh_gen)\n#define cp_ecdh_key \tRLC_PREFIX(cp_ecdh_key)\n#define cp_ecmqv_gen \tRLC_PREFIX(cp_ecmqv_gen)\n#define cp_ecmqv_key \tRLC_PREFIX(cp_ecmqv_key)\n#define cp_ecies_gen \tRLC_PREFIX(cp_ecies_gen)\n#define cp_ecies_enc \tRLC_PREFIX(cp_ecies_enc)\n#define cp_ecies_dec \tRLC_PREFIX(cp_ecies_dec)\n#define cp_ecdsa_gen \tRLC_PREFIX(cp_ecdsa_gen)\n#define cp_ecdsa_sig \tRLC_PREFIX(cp_ecdsa_sig)\n#define cp_ecdsa_ver \tRLC_PREFIX(cp_ecdsa_ver)\n#define cp_ecss_gen \tRLC_PREFIX(cp_ecss_gen)\n#define cp_ecss_sig \tRLC_PREFIX(cp_ecss_sig)\n#define cp_ecss_ver \tRLC_PREFIX(cp_ecss_ver)\n#define cp_pdpub_gen \tRLC_PREFIX(cp_pdpub_gen)\n#define cp_pdpub_ask \tRLC_PREFIX(cp_pdpub_ask)\n#define cp_pdpub_ans \tRLC_PREFIX(cp_pdpub_ans)\n#define cp_pdpub_ver \tRLC_PREFIX(cp_pdpub_ver)\n#define cp_pdprv_gen \tRLC_PREFIX(cp_pdprv_gen)\n#define cp_pdprv_ask \tRLC_PREFIX(cp_pdprv_ask)\n#define cp_pdprv_ans \tRLC_PREFIX(cp_pdprv_ans)\n#define cp_pdprv_ver \tRLC_PREFIX(cp_pdprv_ver)\n#define cp_lvpub_gen \tRLC_PREFIX(cp_lvpub_gen)\n#define cp_lvpub_ask \tRLC_PREFIX(cp_lvpub_ask)\n#define cp_lvpub_ans \tRLC_PREFIX(cp_lvpub_ans)\n#define cp_lvpub_ver \tRLC_PREFIX(cp_lvpub_ver)\n#define cp_lvprv_gen \tRLC_PREFIX(cp_lvprv_gen)\n#define cp_lvprv_ask \tRLC_PREFIX(cp_lvprv_ask)\n#define cp_lvprv_ans \tRLC_PREFIX(cp_lvprv_ans)\n#define cp_lvprv_ver \tRLC_PREFIX(cp_lvprv_ver)\n#define cp_sokaka_gen \tRLC_PREFIX(cp_sokaka_gen)\n#define cp_sokaka_gen_prv \tRLC_PREFIX(cp_sokaka_gen_prv)\n#define cp_sokaka_key \tRLC_PREFIX(cp_sokaka_key)\n#define cp_bgn_gen \tRLC_PREFIX(cp_bgn_gen)\n#define cp_bgn_enc1 \tRLC_PREFIX(cp_bgn_enc1)\n#define cp_bgn_dec1 \tRLC_PREFIX(cp_bgn_dec1)\n#define cp_bgn_enc2 \tRLC_PREFIX(cp_bgn_enc2)\n#define cp_bgn_dec2 \tRLC_PREFIX(cp_bgn_dec2)\n#define cp_bgn_add \tRLC_PREFIX(cp_bgn_add)\n#define cp_bgn_mul \tRLC_PREFIX(cp_bgn_mul)\n#define cp_bgn_dec \tRLC_PREFIX(cp_bgn_dec)\n#define cp_ibe_gen \tRLC_PREFIX(cp_ibe_gen)\n#define cp_ibe_gen_prv \tRLC_PREFIX(cp_ibe_gen_prv)\n#define cp_ibe_enc \tRLC_PREFIX(cp_ibe_enc)\n#define cp_ibe_dec \tRLC_PREFIX(cp_ibe_dec)\n#define cp_bls_gen \tRLC_PREFIX(cp_bls_gen)\n#define cp_bls_sig \tRLC_PREFIX(cp_bls_sig)\n#define cp_bls_ver \tRLC_PREFIX(cp_bls_ver)\n#define cp_bbs_gen \tRLC_PREFIX(cp_bbs_gen)\n#define cp_bbs_sig \tRLC_PREFIX(cp_bbs_sig)\n#define cp_bbs_ver \tRLC_PREFIX(cp_bbs_ver)\n#define cp_cls_gen \tRLC_PREFIX(cp_cls_gen)\n#define cp_cls_sig \tRLC_PREFIX(cp_cls_sig)\n#define cp_cls_ver \tRLC_PREFIX(cp_cls_ver)\n#define cp_cli_gen \tRLC_PREFIX(cp_cli_gen)\n#define cp_cli_sig \tRLC_PREFIX(cp_cli_sig)\n#define cp_cli_ver \tRLC_PREFIX(cp_cli_ver)\n#define cp_clb_gen \tRLC_PREFIX(cp_clb_gen)\n#define cp_clb_sig \tRLC_PREFIX(cp_clb_sig)\n#define cp_clb_ver \tRLC_PREFIX(cp_clb_ver)\n#define cp_pss_gen \tRLC_PREFIX(cp_pss_gen)\n#define cp_pss_sig \tRLC_PREFIX(cp_pss_sig)\n#define cp_pss_ver \tRLC_PREFIX(cp_pss_ver)\n#define cp_mpss_gen \tRLC_PREFIX(cp_mpss_gen)\n#define cp_mpss_sig \tRLC_PREFIX(cp_mpss_sig)\n#define cp_mpss_bct \tRLC_PREFIX(cp_mpss_bct)\n#define cp_mpss_ver \tRLC_PREFIX(cp_mpss_ver)\n#define cp_psb_gen \tRLC_PREFIX(cp_psb_gen)\n#define cp_psb_sig \tRLC_PREFIX(cp_psb_sig)\n#define cp_psb_ver \tRLC_PREFIX(cp_psb_ver)\n#define cp_mpsb_gen \tRLC_PREFIX(cp_mpsb_gen)\n#define cp_mpsb_sig \tRLC_PREFIX(cp_mpsb_sig)\n#define cp_mpsb_bct \tRLC_PREFIX(cp_mpsb_bct)\n#define cp_mpsb_ver \tRLC_PREFIX(cp_mpsb_ver)\n#define cp_zss_gen \tRLC_PREFIX(cp_zss_gen)\n#define cp_zss_sig \tRLC_PREFIX(cp_zss_sig)\n#define cp_zss_ver \tRLC_PREFIX(cp_zss_ver)\n#define cp_vbnn_gen \tRLC_PREFIX(cp_vbnn_gen)\n#define cp_vbnn_gen_prv \tRLC_PREFIX(cp_vbnn_gen_prv)\n#define cp_vbnn_sig \tRLC_PREFIX(cp_vbnn_sig)\n#define cp_vbnn_ver \tRLC_PREFIX(cp_vbnn_ver)\n#define cp_pokdl_prv \tRLC_PREFIX(cp_pokdl_prv)\n#define cp_pokdl_ver \tRLC_PREFIX(cp_pokdl_ver)\n#define cp_pokor_prv \tRLC_PREFIX(cp_pokor_prv)\n#define cp_pokor_ver \tRLC_PREFIX(cp_pokor_ver)\n#define cp_sokdl_sig \tRLC_PREFIX(cp_sokdl_sig)\n#define cp_sokdl_ver \tRLC_PREFIX(cp_sokdl_ver)\n#define cp_sokor_sig \tRLC_PREFIX(cp_sokor_sig)\n#define cp_sokor_ver \tRLC_PREFIX(cp_sokor_ver)\n#define cp_ers_gen \tRLC_PREFIX(cp_ers_gen)\n#define cp_ers_gen_key \tRLC_PREFIX(cp_ers_gen_key)\n#define cp_ers_sig \tRLC_PREFIX(cp_ers_sig)\n#define cp_ers_ver \tRLC_PREFIX(cp_ers_ver)\n#define cp_ers_ext \tRLC_PREFIX(cp_ers_ext)\n#define cp_smlers_sig \tRLC_PREFIX(cp_smlers_sig)\n#define cp_smlers_ver \tRLC_PREFIX(cp_smlers_ver)\n#define cp_smlers_ext \tRLC_PREFIX(cp_smlers_ext)\n#define cp_etrs_sig \tRLC_PREFIX(cp_etrs_sig)\n#define cp_etrs_ver \tRLC_PREFIX(cp_etrs_ver)\n#define cp_etrs_ext \tRLC_PREFIX(cp_etrs_ext)\n#define cp_etrs_uni \tRLC_PREFIX(cp_etrs_uni)\n#define cp_cmlhs_init \tRLC_PREFIX(cp_cmlhs_init)\n#define cp_cmlhs_gen \tRLC_PREFIX(cp_cmlhs_gen)\n#define cp_cmlhs_sig \tRLC_PREFIX(cp_cmlhs_sig)\n#define cp_cmlhs_fun \tRLC_PREFIX(cp_cmlhs_fun)\n#define cp_cmlhs_evl \tRLC_PREFIX(cp_cmlhs_evl)\n#define cp_cmlhs_ver \tRLC_PREFIX(cp_cmlhs_ver)\n#define cp_cmlhs_off \tRLC_PREFIX(cp_cmlhs_off)\n#define cp_cmlhs_onv \tRLC_PREFIX(cp_cmlhs_onv)\n#define cp_mklhs_gen \tRLC_PREFIX(cp_mklhs_gen)\n#define cp_mklhs_sig \tRLC_PREFIX(cp_mklhs_sig)\n#define cp_mklhs_fun \tRLC_PREFIX(cp_mklhs_fun)\n#define cp_mklhs_evl \tRLC_PREFIX(cp_mklhs_evl)\n#define cp_mklhs_ver \tRLC_PREFIX(cp_mklhs_ver)\n#define cp_mklhs_off \tRLC_PREFIX(cp_mklhs_off)\n#define cp_mklhs_onv \tRLC_PREFIX(cp_mklhs_onv)\n#define cp_rsapsi_gen \tRLC_PREFIX(cp_rsapsi_gen)\n#define cp_rsapsi_ask \tRLC_PREFIX(cp_rsapsi_ask)\n#define cp_rsapsi_ans \tRLC_PREFIX(cp_rsapsi_ans)\n#define cp_rsapsi_int \tRLC_PREFIX(cp_rsapsi_int)\n#define cp_shipsi_gen \tRLC_PREFIX(cp_shipsi_gen)\n#define cp_shipsi_ask \tRLC_PREFIX(cp_shipsi_ask)\n#define cp_shipsi_ans \tRLC_PREFIX(cp_shipsi_ans)\n#define cp_shipsi_int \tRLC_PREFIX(cp_shipsi_int)\n#define cp_pbpsi_gen \tRLC_PREFIX(cp_pbpsi_gen)\n#define cp_pbpsi_ask \tRLC_PREFIX(cp_pbpsi_ask)\n#define cp_pbpsi_ans \tRLC_PREFIX(cp_pbpsi_ans)\n#define cp_pbpsi_int \tRLC_PREFIX(cp_pbpsi_int)\n\n#undef md_map_sh224\n#undef md_map_sh256\n#undef md_map_sh384\n#undef md_map_sh512\n#undef md_map_b2s160\n#undef md_map_b2s256\n#undef md_kdf\n#undef md_mgf\n#undef md_hmac\n#undef md_xmd_sh224\n#undef md_xmd_sh256\n#undef md_xmd_sh384\n#undef md_xmd_sh512\n\n#define md_map_sh224 \tRLC_PREFIX(md_map_sh224)\n#define md_map_sh256 \tRLC_PREFIX(md_map_sh256)\n#define md_map_sh384 \tRLC_PREFIX(md_map_sh384)\n#define md_map_sh512 \tRLC_PREFIX(md_map_sh512)\n#define md_map_b2s160 \tRLC_PREFIX(md_map_b2s160)\n#define md_map_b2s256 \tRLC_PREFIX(md_map_b2s256)\n#define md_kdf \tRLC_PREFIX(md_kdf)\n#define md_mgf \tRLC_PREFIX(md_mgf)\n#define md_hmac \tRLC_PREFIX(md_hmac)\n#define md_xmd_sh224 \tRLC_PREFIX(md_xmd_sh224)\n#define md_xmd_sh256 \tRLC_PREFIX(md_xmd_sh256)\n#define md_xmd_sh384 \tRLC_PREFIX(md_xmd_sh384)\n#define md_xmd_sh512 \tRLC_PREFIX(md_xmd_sh512)\n\n#endif /* LABEL */\n\n#endif /* !RLC_LABEL_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime number generation and testing functions.\n *\n * Strong prime generation is based on Gordon's Algorithm, taken from Handbook\n * of Applied Cryptography.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Number of trial division tests.\n */\n#define BASIC_TESTS\t((int)(sizeof(primes)/sizeof(dig_t)))\n\n/**\n * Small prime numbers table.\n */\nstatic const dig_t primes[] = {\n\t0x0002, 0x0003, 0x0005, 0x0007, 0x000B, 0x000D, 0x0011, 0x0013,\n\t0x0017, 0x001D, 0x001F, 0x0025, 0x0029, 0x002B, 0x002F, 0x0035,\n\t0x003B, 0x003D, 0x0043, 0x0047, 0x0049, 0x004F, 0x0053, 0x0059,\n\t0x0061, 0x0065, 0x0067, 0x006B, 0x006D, 0x0071, 0x007F, 0x0083,\n\t0x0089, 0x008B, 0x0095, 0x0097, 0x009D, 0x00A3, 0x00A7, 0x00AD,\n\t0x00B3, 0x00B5, 0x00BF, 0x00C1, 0x00C5, 0x00C7, 0x00D3, 0x00DF,\n#if WSIZE > 8\n\t0x00E3, 0x00E5, 0x00E9, 0x00EF, 0x00F1, 0x00FB, 0x0101, 0x0107,\n\t0x010D, 0x010F, 0x0115, 0x0119, 0x011B, 0x0125, 0x0133, 0x0137,\n\n\t0x0139, 0x013D, 0x014B, 0x0151, 0x015B, 0x015D, 0x0161, 0x0167,\n\t0x016F, 0x0175, 0x017B, 0x017F, 0x0185, 0x018D, 0x0191, 0x0199,\n\t0x01A3, 0x01A5, 0x01AF, 0x01B1, 0x01B7, 0x01BB, 0x01C1, 0x01C9,\n\t0x01CD, 0x01CF, 0x01D3, 0x01DF, 0x01E7, 0x01EB, 0x01F3, 0x01F7,\n\t0x01FD, 0x0209, 0x020B, 0x021D, 0x0223, 0x022D, 0x0233, 0x0239,\n\t0x023B, 0x0241, 0x024B, 0x0251, 0x0257, 0x0259, 0x025F, 0x0265,\n\t0x0269, 0x026B, 0x0277, 0x0281, 0x0283, 0x0287, 0x028D, 0x0293,\n\t0x0295, 0x02A1, 0x02A5, 0x02AB, 0x02B3, 0x02BD, 0x02C5, 0x02CF,\n\n\t0x02D7, 0x02DD, 0x02E3, 0x02E7, 0x02EF, 0x02F5, 0x02F9, 0x0301,\n\t0x0305, 0x0313, 0x031D, 0x0329, 0x032B, 0x0335, 0x0337, 0x033B,\n\t0x033D, 0x0347, 0x0355, 0x0359, 0x035B, 0x035F, 0x036D, 0x0371,\n\t0x0373, 0x0377, 0x038B, 0x038F, 0x0397, 0x03A1, 0x03A9, 0x03AD,\n\t0x03B3, 0x03B9, 0x03C7, 0x03CB, 0x03D1, 0x03D7, 0x03DF, 0x03E5,\n\t0x03F1, 0x03F5, 0x03FB, 0x03FD, 0x0407, 0x0409, 0x040F, 0x0419,\n\t0x041B, 0x0425, 0x0427, 0x042D, 0x043F, 0x0443, 0x0445, 0x0449,\n\t0x044F, 0x0455, 0x045D, 0x0463, 0x0469, 0x047F, 0x0481, 0x048B,\n\n\t0x0493, 0x049D, 0x04A3, 0x04A9, 0x04B1, 0x04BD, 0x04C1, 0x04C7,\n\t0x04CD, 0x04CF, 0x04D5, 0x04E1, 0x04EB, 0x04FD, 0x04FF, 0x0503,\n\t0x0509, 0x050B, 0x0511, 0x0515, 0x0517, 0x051B, 0x0527, 0x0529,\n\t0x052F, 0x0551, 0x0557, 0x055D, 0x0565, 0x0577, 0x0581, 0x058F,\n\t0x0593, 0x0595, 0x0599, 0x059F, 0x05A7, 0x05AB, 0x05AD, 0x05B3,\n\t0x05BF, 0x05C9, 0x05CB, 0x05CF, 0x05D1, 0x05D5, 0x05DB, 0x05E7,\n\t0x05F3, 0x05FB, 0x0607, 0x060D, 0x0611, 0x0617, 0x061F, 0x0623,\n\t0x062B, 0x062F, 0x063D, 0x0641, 0x0647, 0x0649, 0x064D, 0x0653,\n\n\t0x0655, 0x065B, 0x0665, 0x0679, 0x067F, 0x0683, 0x0685, 0x069D,\n\t0x06A1, 0x06A3, 0x06AD, 0x06B9, 0x06BB, 0x06C5, 0x06CD, 0x06D3,\n\t0x06D9, 0x06DF, 0x06F1, 0x06F7, 0x06FB, 0x06FD, 0x0709, 0x0713,\n\t0x071F, 0x0727, 0x0737, 0x0745, 0x074B, 0x074F, 0x0751, 0x0755,\n\t0x0757, 0x0761, 0x076D, 0x0773, 0x0779, 0x078B, 0x078D, 0x079D,\n\t0x079F, 0x07B5, 0x07BB, 0x07C3, 0x07C9, 0x07CD, 0x07CF, 0x07D3,\n\t0x07DB, 0x07E1, 0x07EB, 0x07ED, 0x07F7, 0x0805, 0x080F, 0x0815,\n\t0x0821, 0x0823, 0x0827, 0x0829, 0x0833, 0x083F, 0x0841, 0x0851,\n\n\t0x0853, 0x0859, 0x085D, 0x085F, 0x0869, 0x0871, 0x0883, 0x089B,\n\t0x089F, 0x08A5, 0x08AD, 0x08BD, 0x08BF, 0x08C3, 0x08CB, 0x08DB,\n\t0x08DD, 0x08E1, 0x08E9, 0x08EF, 0x08F5, 0x08F9, 0x0905, 0x0907,\n\t0x091D, 0x0923, 0x0925, 0x092B, 0x092F, 0x0935, 0x0943, 0x0949,\n\t0x094D, 0x094F, 0x0955, 0x0959, 0x095F, 0x096B, 0x0971, 0x0977,\n\t0x0985, 0x0989, 0x098F, 0x099B, 0x09A3, 0x09A9, 0x09AD, 0x09C7,\n\t0x09D9, 0x09E3, 0x09EB, 0x09EF, 0x09F5, 0x09F7, 0x09FD, 0x0A13,\n\t0x0A1F, 0x0A21, 0x0A31, 0x0A39, 0x0A3D, 0x0A49, 0x0A57, 0x0A61,\n\n\t0x0A63, 0x0A67, 0x0A6F, 0x0A75, 0x0A7B, 0x0A7F, 0x0A81, 0x0A85,\n\t0x0A8B, 0x0A93, 0x0A97, 0x0A99, 0x0A9F, 0x0AA9, 0x0AAB, 0x0AB5,\n\t0x0ABD, 0x0AC1, 0x0ACF, 0x0AD9, 0x0AE5, 0x0AE7, 0x0AED, 0x0AF1,\n\t0x0AF3, 0x0B03, 0x0B11, 0x0B15, 0x0B1B, 0x0B23, 0x0B29, 0x0B2D,\n\t0x0B3F, 0x0B47, 0x0B51, 0x0B57, 0x0B5D, 0x0B65, 0x0B6F, 0x0B7B,\n\t0x0B89, 0x0B8D, 0x0B93, 0x0B99, 0x0B9B, 0x0BB7, 0x0BB9, 0x0BC3,\n\t0x0BCB, 0x0BCF, 0x0BDD, 0x0BE1, 0x0BE9, 0x0BF5, 0x0BFB, 0x0C07,\n\t0x0C0B, 0x0C11, 0x0C25, 0x0C2F, 0x0C31, 0x0C41, 0x0C5B, 0x0C5F,\n\n\t0x0C61, 0x0C6D, 0x0C73, 0x0C77, 0x0C83, 0x0C89, 0x0C91, 0x0C95,\n\t0x0C9D, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBB, 0x0CC7, 0x0CE3, 0x0CE5,\n\t0x0CEB, 0x0CF1, 0x0CF7, 0x0CFB, 0x0D01, 0x0D03, 0x0D0F, 0x0D13,\n\t0x0D1F, 0x0D21, 0x0D2B, 0x0D2D, 0x0D3D, 0x0D3F, 0x0D4F, 0x0D55,\n\t0x0D69, 0x0D79, 0x0D81, 0x0D85, 0x0D87, 0x0D8B, 0x0D8D, 0x0DA3,\n\t0x0DAB, 0x0DB7, 0x0DBD, 0x0DC7, 0x0DC9, 0x0DCD, 0x0DD3, 0x0DD5,\n\t0x0DDB, 0x0DE5, 0x0DE7, 0x0DF3, 0x0DFD, 0x0DFF, 0x0E09, 0x0E17,\n\t0x0E1D, 0x0E21, 0x0E27, 0x0E2F, 0x0E35, 0x0E3B, 0x0E4B, 0x0E57,\n#endif\n};\n\n#if BN_MOD == PMERS\n\n/**\n * Computes c = a ^ b mod m.\n *\n * @param c\t\t\t\t- the result.\n * @param a\t\t\t\t- the basis.\n * @param b\t\t\t\t- the exponent.\n * @param m\t\t\t\t- the modulus.\n */\nstatic void bn_exp(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tl = bn_bits(b);\n\n\t\tbn_copy(t, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(t, t);\n\t\t\tbn_mod(t, t, m);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tbn_mul(t, t, a);\n\t\t\t\tbn_mod(t, t, m);\n\t\t\t}\n\t\t}\n\n\t\tbn_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\ndig_t bn_get_prime(int pos) {\n\tif (pos >= BASIC_TESTS) {\n\t\treturn 0;\n\t}\n\treturn primes[pos];\n}\n\nint bn_is_prime(const bn_t a) {\n\tint result;\n\n\tresult = 0;\n\tif (!bn_is_prime_basic(a)) {\n\t\tgoto end;\n\t}\n\n\tif (!bn_is_prime_rabin(a)) {\n\t\tgoto end;\n\t}\n\n\tresult = 1;\n  end:\n\treturn result;\n}\n\nint bn_is_prime_basic(const bn_t a) {\n\tdig_t t;\n\tint i, result;\n\n\tresult = 1;\n\n\tif (bn_cmp_dig(a, 1) == RLC_EQ) {\n\t\treturn 0;\n\t}\n\n\t/* Trial division. */\n\tfor (i = 0; i < BASIC_TESTS; i++) {\n\t\tbn_mod_dig(&t, a, primes[i]);\n\t\tif (t == 0 && bn_cmp_dig(a, primes[i]) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nint bn_is_prime_rabin(const bn_t a) {\n\tbn_t t, n1, y, r;\n\tint i, s, j, result, b, tests = 0, cmp2;\n\n\ttests = 0;\n\tresult = 1;\n\n\tbn_null(t);\n\tbn_null(n1);\n\tbn_null(y);\n\tbn_null(r);\n\n\tcmp2 = bn_cmp_dig(a, 2);\n\tif (cmp2 == RLC_LT) {\n\t\t/* Numbers 1 or smaller are not prime */\n\t\treturn 0;\n\t}\n\tif (cmp2 == RLC_EQ) {\n\t\t/* The number 2 is prime */\n\t\treturn 1;\n\t}\n\n\tif (bn_is_even(a) == 1) {\n\t\t/* Even numbers > 2 are not prime */\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\t/*\n\t\t * These values are taken from Table 4.4 inside Handbook of Applied\n\t\t * Cryptography.\n\t\t */\n\t\tb = bn_bits(a);\n\t\tif (b >= 1300) {\n\t\t\ttests = 2;\n\t\t} else if (b >= 850) {\n\t\t\ttests = 3;\n\t\t} else if (b >= 650) {\n\t\t\ttests = 4;\n\t\t} else if (b >= 550) {\n\t\t\ttests = 5;\n\t\t} else if (b >= 450) {\n\t\t\ttests = 6;\n\t\t} else if (b >= 400) {\n\t\t\ttests = 7;\n\t\t} else if (b >= 350) {\n\t\t\ttests = 8;\n\t\t} else if (b >= 300) {\n\t\t\ttests = 9;\n\t\t} else if (b >= 250) {\n\t\t\ttests = 12;\n\t\t} else if (b >= 200) {\n\t\t\ttests = 15;\n\t\t} else if (b >= 150) {\n\t\t\ttests = 18;\n\t\t} else {\n\t\t\ttests = 27;\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(n1);\n\t\tbn_new(y);\n\t\tbn_new(r);\n\n\t\t/* r = (n - 1)/2^s. */\n\t\tbn_sub_dig(n1, a, 1);\n\t\tbn_copy(r, n1);\n\t\ts = 0;\n\t\twhile (bn_is_even(r)) {\n\t\t\ts++;\n\t\t\tbn_rsh(r, r, 1);\n\t\t}\n\n\t\tfor (i = 0; i < tests; i++) {\n\t\t\t/* Fix the basis as the first few primes. */\n\t\t\tbn_set_dig(t, primes[i]);\n\n\t\t\t/* Ensure t <= n - 2 as per HAC */\n\t\t\tif( bn_cmp(t, n1) != RLC_LT ) {\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* y = b^r mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(y, t, r, a);\n#else\n\t\t\tbn_exp(y, t, r, a);\n#endif\n\n\t\t\tif (bn_cmp_dig(y, 1) != RLC_EQ && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\tj = 1;\n\t\t\t\twhile ((j <= (s - 1)) && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tbn_sqr(y, y);\n\t\t\t\t\tbn_mod(y, y, a);\n\n\t\t\t\t\t/* If y == 1 then composite. */\n\t\t\t\t\tif (bn_cmp_dig(y, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++j;\n\t\t\t\t}\n\n\t\t\t\t/* If y != n1 then composite. */\n\t\t\t\tif (bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(y);\n\t\tbn_free(n1);\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\nint bn_is_prime_solov(const bn_t a) {\n\tbn_t t0, t1, t2;\n\tint i, result;\n\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\n\tresult = 1;\n\n\tRLC_TRY {\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\t/* Generate t0, 2 <= t0, <= a - 2. */\n\t\t\tdo {\n\t\t\t\tbn_rand(t0, RLC_POS, bn_bits(a));\n\t\t\t\tbn_mod(t0, t0, a);\n\t\t\t} while (bn_cmp_dig(t0, 2) == RLC_LT);\n\t\t\t/* t2 = a - 1. */\n\t\t\tbn_copy(t2, a);\n\t\t\tbn_sub_dig(t2, t2, 1);\n\t\t\t/* t1 = (a - 1)/2. */\n\t\t\tbn_rsh(t1, t2, 1);\n\t\t\t/* t1 = t0^(a - 1)/2 mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t1, t0, t1, a);\n#else\n\t\t\tbn_exp(t1, t0, t1, a);\n#endif\n\t\t\t/* If t1 != 1 and t1 != n - 1 return 0 */\n\t\t\tif (bn_cmp_dig(t1, 1) != RLC_EQ && bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Lend result here, but restore afterwards, for t2 = (t0|a). */\n\t\t\tresult = bn_smb_jac(t0, a);\n\t\t\tbn_set_dig(t2, (result < 0 ? -result : result));\n\t\t\tif (result < 0) {\n\t\t\t\tbn_neg(t2, t2);\n\t\t\t}\n\t\t\tresult = 1;\n\t\t\t/* If t1 != t2 (mod a) return 0. */\n\t\t\tbn_mod(t1, t1, a);\n\t\t\tbn_mod(t2, t2, a);\n\t\t\tif (bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t}\n\treturn result;\n}\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\nvoid bn_gen_prime_basic(bn_t a, int bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\tif (bn_is_prime(a)) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\nvoid bn_gen_prime_safep(bn_t a, int bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\t/* Check if (a - 1)/2 is prime. */\n\t\tbn_sub_dig(a, a, 1);\n\t\tbn_rsh(a, a, 1);\n\t\tif (bn_is_prime(a)) {\n\t\t\t/* Restore a. */\n\t\t\tbn_lsh(a, a, 1);\n\t\t\tbn_add_dig(a, a, 1);\n\t\t\tif (bn_is_prime(a)) {\n\t\t\t\t/* Should be prime now. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\nvoid bn_gen_prime_stron(bn_t a, int bits) {\n\tdig_t i, j;\n\tint found, k;\n\tbn_t r, s, t;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tbn_new(t);\n\n\t\tdo {\n\t\t\tdo {\n\t\t\t\t/* Generate two large primes r and s. */\n\t\t\t\tbn_rand(s, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t\tbn_rand(t, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t} while (!bn_is_prime(s) || !bn_is_prime(t));\n\t\t\tfound = 1;\n\t\t\tbn_rand(a, RLC_POS, bits / 2 - bn_bits(t) - 1);\n\t\t\ti = a->dp[0];\n\t\t\tbn_dbl(t, t);\n\t\t\tdo {\n\t\t\t\t/* Find first prime r = 2 * i * t + 1. */\n\t\t\t\tbn_mul_dig(r, t, i);\n\t\t\t\tbn_add_dig(r, r, 1);\n\t\t\t\ti++;\n\t\t\t\tif (bn_bits(r) > bits / 2 - 1) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(r));\n\t\t\tif (found == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Compute t = 2 * (s^(r-2) mod r) * s - 1. */\n\t\t\tbn_sub_dig(t, r, 2);\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t, s, t, r);\n#else\n\t\t\tbn_exp(t, s, t, r);\n#endif\n\n\t\t\tbn_mul(t, t, s);\n\t\t\tbn_dbl(t, t);\n\t\t\tbn_sub_dig(t, t, 1);\n\n\t\t\tk = bits - bn_bits(r);\n\t\t\tk -= bn_bits(s);\n\t\t\tbn_rand(a, RLC_POS, k);\n\t\t\tj = a->dp[0];\n\t\t\tdo {\n\t\t\t\t/* Find first prime a = t + 2 * j * r * s. */\n\t\t\t\tbn_mul(a, r, s);\n\t\t\t\tbn_mul_dig(a, a, j);\n\t\t\t\tbn_dbl(a, a);\n\t\t\t\tbn_add(a, a, t);\n\t\t\t\tj++;\n\t\t\t\tif (bn_bits(a) > bits) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(a));\n\t\t} while (found == 0 && bn_bits(a) != bits);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(s);\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\nint bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;\n    }\n\n    bn_null(t);\n\n    RLC_TRY {\n        bn_new(t);\n\t\tbn_gen_prime(a, abits);\n        do {\n            bn_rand(t, RLC_POS, bbits - bn_bits(a));\n            do {\n                bn_mul(b, a, t);\n                bn_add_dig(b, b, 1);\n                bn_add_dig(t, t, 1);\n            } while(! bn_is_prime(b));\n        } while (bn_bits(b) != bbits);\n    }\n    RLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n    }\n    RLC_FINALLY {\n        bn_free(t);\n    }\n\n    return result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for implementation of cryptographic protocols.\n *\n * @version $Id$\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\nstatic int rsa(void) {\n\tint code = RLC_ERR;\n\trsa_t pub, prv;\n\tuint8_t in[10], out[RLC_BN_BITS / 8 + 1], h[RLC_MD_LEN];\n\tsize_t il, ol;\n\tint result;\n\n\trsa_null(pub);\n\trsa_null(prv);\n\n\tRLC_TRY {\n\t\trsa_new(pub);\n\t\trsa_new(prv);\n\n\t\tresult = cp_rsa_gen(pub, prv, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"rsa encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\til = 10;\n\t\t\tol = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(in, il);\n\t\t\tTEST_ASSERT(cp_rsa_enc(out, &ol, in, il, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_rsa_dec(out, &ol, out, ol, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(in, out, ol) == 0, end);\n\t\t} TEST_END;\n\n\t\tresult = cp_rsa_gen(pub, prv, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"rsa signature/verification is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\til = 10;\n\t\t\tol = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(in, il);\n\t\t\tTEST_ASSERT(cp_rsa_sig(out, &ol, in, il, 0, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_rsa_ver(out, ol, in, il, 0, pub) == 1, end);\n\t\t\tmd_map(h, in, il);\n\t\t\tTEST_ASSERT(cp_rsa_sig(out, &ol, h, RLC_MD_LEN, 1, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_rsa_ver(out, ol, h, RLC_MD_LEN, 1, pub) == 1, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\trsa_free(pub);\n\trsa_free(prv);\n\treturn code;\n}\n\nstatic int rabin(void) {\n\tint code = RLC_ERR;\n\trabin_t pub, prv;\n\tuint8_t in[10];\n\tuint8_t out[RLC_BN_BITS / 8 + 1];\n\tsize_t in_len, out_len;\n\tint result;\n\n\trabin_null(pub);\n\trabin_null(prv);\n\n\tRLC_TRY {\n\t\trabin_new(pub);\n\t\trabin_new(prv);\n\n\t\tresult = cp_rabin_gen(pub, prv, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"rabin encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tin_len = 10;\n\t\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(in, in_len);\n\t\t\tTEST_ASSERT(cp_rabin_enc(out, &out_len, in, in_len, pub) == RLC_OK,\n\t\t\t\t\tend);\n\t\t\tTEST_ASSERT(cp_rabin_dec(out, &out_len, out, out_len,\n\t\t\t\t\t\t\tprv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(in, out, out_len) == 0, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\trabin_free(pub);\n\trabin_free(prv);\n\treturn code;\n}\n\nstatic int benaloh(void) {\n\tint code = RLC_ERR;\n\tbdpe_t pub, prv;\n\tbn_t a, b;\n\tdig_t in, out;\n\tuint8_t buf[RLC_BN_BITS / 8 + 1];\n\tsize_t len;\n\tint result;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbdpe_null(pub);\n\tbdpe_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbdpe_new(pub);\n\t\tbdpe_new(prv);\n\n\t\tresult = cp_bdpe_gen(pub, prv, bn_get_prime(47), RLC_BN_BITS);\n\n\t\tTEST_CASE(\"benaloh encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tlen = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(buf, 1);\n\t\t\tin = buf[0] % bn_get_prime(47);\n\t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bdpe_dec(&out, buf, len, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"benaloh encryption/decryption is homomorphic\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tlen = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(buf, 1);\n\t\t\tin = buf[0] % bn_get_prime(47);\n\t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, in, pub) == RLC_OK, end);\n\t\t\tbn_read_bin(a, buf, len);\n\t\t\trand_bytes(buf, 1);\n\t\t\tout = (buf[0] % bn_get_prime(47));\n\t\t\tin = (in + out) % bn_get_prime(47);\n\t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, out, pub) == RLC_OK, end);\n\t\t\tbn_read_bin(b, buf, len);\n\t\t\tbn_mul(a, a, b);\n\t\t\tbn_mod(a, a, pub->n);\n\t\t\tlen = bn_size_bin(pub->n);\n\t\t\tbn_write_bin(buf, len, a);\n\t\t\tTEST_ASSERT(cp_bdpe_dec(&out, buf, len, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbdpe_free(pub);\n\tbdpe_free(prv);\n\treturn code;\n}\n\nstatic int paillier(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, s, pub;\n\tphpe_t prv;\n\tint result;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(s);\n\tbn_null(pub);\n\tphpe_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(s);\n\t\tbn_new(pub);\n\t\tphpe_new(prv);\n\n\t\tresult = cp_phpe_gen(pub, prv, RLC_BN_BITS / 2);\n\n\t\tTEST_CASE(\"paillier encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tbn_rand_mod(a, pub);\n\t\t\tTEST_ASSERT(cp_phpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_dec(b, c, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"paillier encryption/decryption is homomorphic\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tbn_rand_mod(a, pub);\n\t\t\tbn_rand_mod(b, pub);\n\t\t\tTEST_ASSERT(cp_phpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_enc(d, b, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_add(c, c, d, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_dec(d, c, prv) == RLC_OK, end);\n\t\t\tbn_add(a, a, b);\n\t\t\tbn_mod(a, a, pub);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tfor (int k = 1; k <= 2; k++) {\n\t\t\tresult = cp_ghpe_gen(pub, s, RLC_BN_BITS / (2 * k));\n\t\t\tutil_print(\"(s = %d) \", k);\n\t\t\tTEST_CASE(\"general paillier encryption/decryption is correct\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand(a, RLC_POS, k * (bn_bits(pub) - 1));\n\t\t\t\tTEST_ASSERT(cp_ghpe_enc(c, a, pub, k) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ghpe_dec(b, c, pub, s, k) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}  TEST_END;\n\n\t\t\tutil_print(\"(s = %d) \", k);\n\t\t\tTEST_CASE(\"general paillier encryption/decryption is homomorphic\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand(a, RLC_POS, k * (bn_bits(pub) - 1));\n\t\t\t\tbn_rand(b, RLC_POS, k * (bn_bits(pub) - 1));\n\t\t\t\tTEST_ASSERT(cp_ghpe_enc(c, a, pub, k) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ghpe_enc(d, b, pub, k) == RLC_OK, end);\n\t\t\t\tbn_mul(c, c, d);\n\t\t\t\tbn_sqr(d, pub);\n\t\t\t\tif (k == 2) {\n\t\t\t\t\tbn_mul(d, d, pub);\n\t\t\t\t}\n\t\t\t\tbn_mod(c, c, d);\n\t\t\t\tTEST_ASSERT(cp_ghpe_dec(c, c, pub, s, k) == RLC_OK, end);\n\t\t\t\tbn_add(a, a, b);\n\t\t\t\tbn_copy(d, pub);\n\t\t\t\tif (k == 2) {\n\t\t\t\t\tbn_mul(d, d, pub);\n\t\t\t\t}\n\t\t\t\tbn_mod(a, a, d);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(s);\n\tbn_free(pub);\n\tphpe_free(prv);\n\treturn code;\n}\n\n\nstatic int subgroup_paillier() {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d;\n\tshpe_t pub, prv;\n\tint result, bits;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tshpe_null(pub);\n\tshpe_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n        shpe_new(pub);\n\t\tshpe_new(prv);\n\n\t\tfor (bits = 3; bits < 6; bits++) {\n\t\t\tresult = cp_shpe_gen(pub, prv, RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\n\t\t\tutil_print(\"(o = %d, |n| = %d) \", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\t\t\tTEST_CASE(\"subgroup paillier encryption/decryption is correct\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand_mod(a, pub->crt->n);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_shpe_dec(b, c, prv) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\n\t\t\tutil_print(\"(o = %d, |n| = %d) \", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\t\t\tTEST_CASE(\"subgroup paillier faster encryption with private key is correct\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand_mod(a, pub->crt->n);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc_prv(c, a, prv) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_shpe_dec(b, c, prv) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\n\t\t\tutil_print(\"(o = %d, |n| = %d) \", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\t\t\tTEST_CASE(\"subgroup paillier encryption/decryption is homomorphic\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand_mod(a, pub->crt->n);\n\t\t\t\tbn_rand_mod(b, pub->crt->n);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc(d, b, pub) == RLC_OK, end);\n\t\t\t\tbn_mul(c, c, d);\n\t\t\t\tbn_sqr(d, pub->crt->n);\n\t\t\t\tbn_mod(c, c, d);\n\t\t\t\tTEST_ASSERT(cp_shpe_dec(d, c, prv) == RLC_OK, end);\n\t\t\t\tbn_add(a, a, b);\n\t\t\t\tbn_mod(a, a, pub->crt->n);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tshpe_free(pub);\n\tshpe_free(prv);\n\treturn code;\n}\n\n#if defined(WITH_EC)\n\n/* Test vectors generated by BouncyCastle. */\n\n#if defined(EP_PLAIN) && FP_PRIME == 256\n\n#define NIST_P256_A\t\t\"DA818E65859F3997D4CD287945363B14A0030665B8ABD19719D57952E3A2BEAD\"\n#define NIST_P256_B\t\t\"66BF67EDF1ABDC8178C8A07644FDD5C88EFD4954FD6D2691933B5F0EA0AE2153\"\n#define NIST_P256_A_X\t\"9A2E9583CCBDD502933709D3ED1764E79D1C2EE601DF75A40C486BE3DAB3CDCA\"\n#define NIST_P256_A_Y\t\"D025EA9D9BDA94C0DC7F3813ECA72B369F52CA87E92948BCD76984F44D319F8F\"\n#define NIST_P256_B_X\t\"B8F245FC8A1C7E933D5CAD6E77102C72B0C1F393F779F3F504DA1CA776434B10\"\n#define NIST_P256_B_Y\t\"5373FA01BC13FF5843D4A31E40833785C598C0BBC2F6AF7317C327BE09883799\"\n\nuint8_t result[] = {\n\t0xC0, 0xEC, 0x2B, 0xAC, 0xEB, 0x3C, 0x6E, 0xE3, 0x21, 0x96, 0xD5, 0x43,\n\t0x0E, 0xE6, 0xDA, 0xBB, 0x50, 0xAE, 0xEE, 0xBE, 0xBA, 0xCE, 0x6B, 0x86,\n\t0x09, 0xD7, 0xEB, 0x07, 0xD6, 0x45, 0xF6, 0x34, 0xD4, 0xE0, 0xD1, 0x9A,\n\t0xAB, 0xA0, 0xD2, 0x90, 0x2F, 0x4A, 0xDC, 0x20, 0x1B, 0x0F, 0x35, 0x8D\n};\n\n#endif\n\n#define ASSIGNP(CURVE)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A, sizeof(CURVE##_A));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(da, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_X, sizeof(CURVE##_A_X));\t\t\t\t\t\t\t\\\n\tfp_read_str(qa->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_Y, sizeof(CURVE##_A_Y));\t\t\t\t\t\t\t\\\n\tfp_read_str(qa->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfp_set_dig(qa->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B, sizeof(CURVE##_B));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(d_b, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_X, sizeof(CURVE##_B_X));\t\t\t\t\t\t\t\\\n\tfp_read_str(q_b->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_Y, sizeof(CURVE##_B_Y));\t\t\t\t\t\t\t\\\n\tfp_read_str(q_b->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfp_set_dig(q_b->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tqa->coord = q_b->coord = BASIC;\t\t\t\t\t\t\t\t\t\t\t\\\n\n#define ASSIGNK(CURVE)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A, sizeof(CURVE##_A));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(da, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_X, sizeof(CURVE##_A_X));\t\t\t\t\t\t\t\\\n\tfb_read_str(qa->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_Y, sizeof(CURVE##_A_Y));\t\t\t\t\t\t\t\\\n\tfb_read_str(qa->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfb_set_dig(qa->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B, sizeof(CURVE##_B));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(d_b, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_X, sizeof(CURVE##_B_X));\t\t\t\t\t\t\t\\\n\tfb_read_str(q_b->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_Y, sizeof(CURVE##_B_Y));\t\t\t\t\t\t\t\\\n\tfb_read_str(q_b->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfb_set_dig(q_b->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tqa->coord = q_b->coord = BASIC;\t\t\t\t\t\t\t\t\t\t\t\\\n\nstatic int ecdh(void) {\n\tint code = RLC_ERR;\n\tbn_t da, d_b;\n\tec_t qa, q_b;\n\tuint8_t k1[RLC_MD_LEN], k2[RLC_MD_LEN];\n\n\tbn_null(da);\n\tbn_null(d_b);\n\tec_null(qa);\n\tec_null(q_b);\n\n\tRLC_TRY {\n\t\tbn_new(da);\n\t\tbn_new(d_b);\n\t\tec_new(qa);\n\t\tec_new(q_b);\n\n\t\tTEST_CASE(\"ecdh key agreement is correct\") {\n\t\t\tTEST_ASSERT(cp_ecdh_gen(da, qa) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdh_gen(d_b, q_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdh_key(k1, RLC_MD_LEN, d_b, qa) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdh_key(k2, RLC_MD_LEN, da, q_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(k1, k2, RLC_MD_LEN) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(da);\n\tbn_free(d_b);\n\tec_free(qa);\n\tec_free(q_b);\n\treturn code;\n}\n\nstatic int ecmqv(void) {\n\tint code = RLC_ERR;\n\tbn_t d1a, d1_b;\n\tbn_t d2a, d2_b;\n\tec_t q1a, q1_b;\n\tec_t q2a, q2_b;\n\tuint8_t key1[RLC_MD_LEN], key2[RLC_MD_LEN];\n\n\tbn_null(d1a);\n\tbn_null(d1_b);\n\tec_null(q1a);\n\tec_null(q1_b);\n\tbn_null(d2a);\n\tbn_null(d2_b);\n\tec_null(q2a);\n\tec_null(q2_b);\n\n\tRLC_TRY {\n\t\tbn_new(d1a);\n\t\tbn_new(d1_b);\n\t\tec_new(q1a);\n\t\tec_new(q1_b);\n\t\tbn_new(d2a);\n\t\tbn_new(d2_b);\n\t\tec_new(q2a);\n\t\tec_new(q2_b);\n\n\t\tTEST_CASE(\"ecmqv authenticated key agreement is correct\") {\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d1a, q1a) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d2a, q2a) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d1_b, q1_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d2_b, q2_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_key(key1, RLC_MD_LEN, d1_b, d2_b, q2_b, q1a,\n\t\t\t\t\t\t\tq2a) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_key(key2, RLC_MD_LEN, d1a, d2a, q2a, q1_b,\n\t\t\t\t\t\t\tq2_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(key1, key2, RLC_MD_LEN) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d1a);\n\tbn_free(d1_b);\n\tec_free(q1a);\n\tec_free(q1_b);\n\tbn_free(d2a);\n\tbn_free(d2_b);\n\tec_free(q2a);\n\tec_free(q2_b);\n\treturn code;\n}\n\nstatic int ecies(void) {\n\tint code = RLC_ERR;\n\tec_t r;\n\tbn_t da, d_b;\n\tec_t qa, q_b;\n\tsize_t l, in_len, out_len;\n\tuint8_t in[RLC_BC_LEN - 1], out[RLC_BC_LEN + RLC_MD_LEN];\n\n\tec_null(r);\n\tbn_null(da);\n\tbn_null(d_b);\n\tec_null(qa);\n\tec_null(q_b);\n\n\tRLC_TRY {\n\t\tec_new(r);\n\t\tbn_new(da);\n\t\tbn_new(d_b);\n\t\tec_new(qa);\n\t\tec_new(q_b);\n\n\t\tl = ec_param_level();\n\t\tif (l == 80 || l == 128 || l == 192 || l == 256) {\n\t\t\tTEST_CASE(\"ecies encryption/decryption is correct\") {\n\t\t\t\tTEST_ASSERT(cp_ecies_gen(da, qa) == RLC_OK, end);\n\t\t\t\tin_len = RLC_BC_LEN - 1;\n\t\t\t\tout_len = RLC_BC_LEN + RLC_MD_LEN;\n\t\t\t\trand_bytes(in, in_len);\n\t\t\t\tTEST_ASSERT(cp_ecies_enc(r, out, &out_len, in, in_len, qa)\n\t\t\t\t\t\t== RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ecies_dec(out, &out_len, r, out, out_len, da)\n\t\t\t\t\t\t== RLC_OK, end);\n\t\t\t\tTEST_ASSERT(memcmp(in, out, out_len) == 0, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n#if MD_MAP == SH256\n\t\tuint8_t msg[RLC_BC_LEN + RLC_MD_LEN];\n\t\tchar str[2 * RLC_FC_BYTES + 1];\n\n\t\tswitch (ec_param_get()) {\n\n#if defined(EP_PLAIN) && FP_PRIME == 256\n\t\t\tcase NIST_P256:\n\t\t\t\tASSIGNP(NIST_P256);\n\t\t\t\tmemcpy(msg, result, sizeof(result));\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\t(void)str;\n\t\t\t\tcode = RLC_OK;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (code != RLC_OK) {\n\n\t\t\tTEST_ONCE(\"ecies satisfies test vectors\") {\n\t\t\t\tuint8_t in[] = {\n\t\t\t\t\t0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF\n\t\t\t\t};\n\t\t\t\tTEST_ASSERT(ec_on_curve(qa) == 1, end);\n\t\t\t\tTEST_ASSERT(ec_on_curve(q_b) == 1, end);\n\t\t\t\tout_len = 16;\n\t\t\t\tTEST_ASSERT(cp_ecies_dec(out, &out_len, q_b, msg, sizeof(msg),\n\t\t\t\t\t\t\t\tda) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(out_len == sizeof(in), end);\n\t\t\t\tTEST_ASSERT(memcmp(out, in, sizeof(in)) == RLC_OK, end);\n\t\t\t\tout_len = 16;\n\t\t\t\tTEST_ASSERT(cp_ecies_dec(out, &out_len, qa, msg, sizeof(msg),\n\t\t\t\t\t\t\t\td_b) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(out_len == sizeof(in), end);\n\t\t\t\tTEST_ASSERT(memcmp(out, in, sizeof(in)) == RLC_OK, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tec_free(r);\n\tbn_free(da);\n\tbn_free(d_b);\n\tec_free(qa);\n\tec_free(q_b);\n\treturn code;\n}\n\nstatic int ecdsa(void) {\n\tint code = RLC_ERR;\n\tbn_t d, r, s;\n\tec_t q;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\n\tbn_null(d);\n\tbn_null(r);\n\tbn_null(s);\n\tec_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tec_new(q);\n\n\t\tTEST_CASE(\"ecdsa signature is correct\") {\n\t\t\tTEST_ASSERT(cp_ecdsa_gen(d, q) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdsa_sig(r, s, m, sizeof(m), 0, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, m, sizeof(m), 0, q) == 1, end);\n\t\t\tm[0] ^= 1;\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, m, sizeof(m), 0, q) == 0, end);\n\t\t\tmd_map(h, m, sizeof(m));\n\t\t\tTEST_ASSERT(cp_ecdsa_sig(r, s, h, RLC_MD_LEN, 1, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, q) == 1, end);\n\t\t\th[0] ^= 1;\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, q) == 0, end);\n\t\t\tmemset(h, 0, RLC_MD_LEN);\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, q) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tbn_free(r);\n\tbn_free(s);\n\tec_free(q);\n\treturn code;\n}\n\nstatic int ecss(void) {\n\tint code = RLC_ERR;\n\tbn_t d, r;\n\tec_t q;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(d);\n\tbn_null(r);\n\tec_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tbn_new(r);\n\t\tec_new(q);\n\n\t\tTEST_CASE(\"ecss signature is correct\") {\n\t\t\tTEST_ASSERT(cp_ecss_gen(d, q) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecss_sig(r, d, m, sizeof(m), d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecss_ver(r, d, m, sizeof(m), q) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tbn_free(r);\n\tec_free(q);\n\treturn code;\n}\n\nstatic int vbnn(void) {\n\tint code = RLC_ERR;\n\tuint8_t ida[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tuint8_t idb[] = { 5, 6, 7, 8, 9, 0, 1, 2, 3, 4 };\n\tbn_t ska, skb;\n\tec_t pka, pkb;\n\tbn_t msk, z, h;\n\tec_t r, mpk;\n\n\tuint8_t m[] = \"Thrice the brinded cat hath mew'd.\";\n\n\tbn_null(z);\n\tbn_null(h);\n\tbn_null(msk);\n\tbn_null(ska);\n\tbn_null(skb);\n\tec_null(r);\n\tec_null(mpk);\n\tbn_null(pka);\n\tbn_null(pkb);\n\n\tRLC_TRY {\n\t\tbn_new(z);\n\t\tbn_new(h);\n\t\tbn_new(msk);\n\t\tbn_new(ska);\n\t\tbn_new(skb);\n\t\tec_new(r);\n\t\tec_new(mpk);\n\t\tec_new(pka);\n\t\tec_new(pkb);\n\n\t\tTEST_CASE(\"vbnn signature is correct\") {\n\t\t\tTEST_ASSERT(cp_vbnn_gen(msk, mpk) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_gen_prv(ska, pka, msk, ida, sizeof(ida)) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_gen_prv(skb, pkb, msk, idb, sizeof(idb)) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_sig(r, z, h, ida, sizeof(ida), m, sizeof(m), ska, pka) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_ver(r, z, h, ida, sizeof(ida), m, sizeof(m), mpk) == 1, end);\n\t\t\tTEST_ASSERT(cp_vbnn_ver(r, z, h, idb, sizeof(idb), m, sizeof(m), mpk) == 0, end);\n\t\t\tTEST_ASSERT(cp_vbnn_sig(r, z, h, ida, sizeof(ida), m, sizeof(m), skb, pkb) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_ver(r, z, h, ida, sizeof(ida), m, sizeof(m), mpk) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(z);\n\tbn_free(h);\n\tbn_free(msk);\n\tbn_free(ska);\n\tbn_free(skb);\n\tec_free(r);\n\tec_free(mpk);\n\tec_free(pka);\n\tec_free(pkb);\n\treturn code;\n}\n\nstatic int pok(void) {\n\tint code = RLC_ERR;\n\tbn_t c[2], n, r[2], x;\n\tec_t y[2];\n\n\tbn_null(n);\n\tbn_null(x);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(x);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tbn_null(c[i]);\n\t\t\tbn_null(r[i]);\n\t\t\tec_null(y[i]);\n\t\t\tbn_new(c[i]);\n\t\t\tbn_new(r[i]);\n\t\t\tec_new(y[i]);\n\t\t}\n\t\tec_curve_get_ord(n);\n\n\t\tTEST_CASE(\"proof of knowledge of discrete logarithm is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tec_mul_gen(y[0], x);\n\t\t\tTEST_ASSERT(cp_pokdl_prv(c[0], r[0], y[0], x) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pokdl_ver(c[0], r[0], y[0]) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_pokdl_ver(c[0], r[0], y[0]) == 0, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"proof of knowledge of disjunction is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tdo {\n\t\t\t\tec_rand(y[0]);\n\t\t\t\tec_mul_gen(y[1], x);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_pokor_prv(c, r, y, x) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pokor_ver(c, r, y) == 1, end);\n\t\t\tec_dbl(y[1], y[1]);\n\t\t\tec_norm(y[1], y[1]);\n\t\t\tTEST_ASSERT(cp_pokor_ver(c, r, y) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(n);\n\tbn_free(x);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_free(c[i]);\n\t\tbn_free(r[i]);\n\t\tec_free(y[i]);\n\t}\n\treturn code;\n}\n\nstatic int sok(void) {\n\tint code = RLC_ERR;\n\tbn_t c[2], n, r[2], x;\n\tec_t g[2], y[2];\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(n);\n\tbn_null(x);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(x);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tbn_null(c[i]);\n\t\t\tbn_null(r[i]);\n\t\t\tec_null(g[i]);\n\t\t\tec_null(y[i]);\n\t\t\tbn_new(c[i]);\n\t\t\tbn_new(r[i]);\n\t\t\tec_new(g[i]);\n\t\t\tec_new(y[i]);\n\t\t}\n\t\tec_curve_get_ord(n);\n\n\t\tTEST_CASE(\"signature of knowledge of discrete logarithm is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tec_mul_gen(y[0], x);\n\t\t\tTEST_ASSERT(cp_sokdl_sig(c[0], r[0], m, 5, y[0], x) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokdl_ver(c[0], r[0], m, 5, y[0]) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_sokdl_ver(c[0], r[0], m, 5, y[0]) == 0, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"signature of knowledge of disjunction is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tdo {\n\t\t\t\tec_rand(y[0]);\n\t\t\t\tec_mul_gen(y[1], x);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, NULL, x, 0) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 1, end);\n\t\t\tec_dbl(y[1], y[1]);\n\t\t\tec_norm(y[1], y[1]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 0, end);\n\t\t\tdo {\n\t\t\t\tec_mul_gen(y[0], x);\n\t\t\t\tec_rand(y[1]);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, NULL, x, 1) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 0, end);\n\t\t\tdo {\n\t\t\t\tec_curve_get_gen(g[0]);\n\t\t\t\tec_rand(g[1]);\n\t\t\t\tec_rand(y[0]);\n\t\t\t\tec_mul(y[1], g[1], x);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, g, x, 0) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 1, end);\n\t\t\tec_dbl(y[1], y[1]);\n\t\t\tec_norm(y[1], y[1]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 0, end);\n\t\t\tdo {\n\t\t\t\tec_rand(g[0]);\n\t\t\t\tec_mul(y[0], g[0], x);\n\t\t\t\tec_curve_get_gen(g[1]);\n\t\t\t\tec_rand(y[1]);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, g, x, 1) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(n);\n\tbn_free(x);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_free(c[i]);\n\t\tbn_free(r[i]);\n\t\tec_free(g[i]);\n\t\tec_free(y[i]);\n\t}\n\treturn code;\n}\n\nstatic int ers(void) {\n\tint code = RLC_ERR;\n\tec_t pp, pk[4];\n\tbn_t sk[4], td;\n\ters_t ring[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tsize_t size;\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tRLC_TRY {\n\t\tbn_new(td);\n\t\tec_new(pp);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_new(sk[i]);\n\t\t\tec_null(pk[i]);\n\t\t\tec_new(pk[i]);\n\t\t\ters_null(ring[i]);\n\t\t\ters_new(ring[i]);\n\t\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t\t}\n\n\t\tcp_ers_gen(pp);\n\n\t\tTEST_CASE(\"extendable ring signature scheme is correct\") {\n\t\t\tTEST_ASSERT(cp_ers_sig(td, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, 1, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, 1, m, 0, pp) == 0, end);\n\t\t\tsize = 1;\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_ers_ext(td, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, size, m, 0, pp) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i < 4; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\ters_free(ring[i])\n\t}\n\treturn code;\n}\n\nstatic int smlers(void) {\n\tint code = RLC_ERR;\n\tec_t pp, pk[4];\n\tbn_t sk[4], td;\n\tsmlers_t ring[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tsize_t size;\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tRLC_TRY {\n\t\tbn_new(td);\n\t\tec_new(pp);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_new(sk[i]);\n\t\t\tec_null(pk[i]);\n\t\t\tec_new(pk[i]);\n\t\t\tsmlers_null(ring[i]);\n\t\t\tsmlers_new(ring[i]);\n\t\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t\t}\n\n\t\tcp_ers_gen(pp);\n\n\t\tTEST_CASE(\"same-message linkable ext. ring signature scheme is correct\") {\n\t\t\tTEST_ASSERT(cp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, 1, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, 1, m, 0, pp) == 0, end);\n\t\t\tsize = 1;\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_smlers_ext(td, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, size, m, 0, pp) == 0, end);\n\t\t\t\tTEST_ASSERT(ec_cmp(ring[0]->tau, ring[j]->tau) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i < 4; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tsmlers_free(ring[i])\n\t}\n\treturn code;\n}\n\nstatic int etrs(void) {\n\tint code = RLC_ERR;\n\tec_t pp, pk[4];\n\tbn_t sk[4], td[4], y[4];\n\tetrs_t ring[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tsize_t size;\n\n\tec_null(pp);\n\n\tRLC_TRY {\n\t\tec_new(pp);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(td[i]);\n\t\t\tbn_new(td[i]);\n\t\t\tbn_null(y[i]);\n\t\t\tbn_new(y[i]);\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_new(sk[i]);\n\t\t\tec_null(pk[i]);\n\t\t\tec_new(pk[i]);\n\t\t\tetrs_null(ring[i]);\n\t\t\tetrs_new(ring[i]);\n\t\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t\t}\n\n\t\tcp_ers_gen(pp);\n\n\t\tTEST_CASE(\"extendable threshold ring signature scheme is correct\") {\n\t\t\tTEST_ASSERT(cp_etrs_sig(td, y, 4, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(0, td, y, 4, ring, 1, m, 5, pp) == 0, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(1, td, y, 4, ring, 1, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(1, td, y, 4, ring, 1, m, 0, pp) == 0, end);\n\t\t\tsize = 1;\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_etrs_ext(td, y, 4, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(0, td+j, y+j, 4-j, ring, size, m, 5, pp) == 0, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(1, td+j, y+j, 4-j, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(1, td+j, y+j, 4-j, ring, size, m, 0, pp) == 0, end);\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cp_etrs_sig(td, y, 4, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tsize = 1;\n\t\t\tTEST_ASSERT(cp_etrs_uni(1, td, y, 4, ring, &size, m, 5, sk[1], pk[1], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(1, td, y, 4, ring, size, m, 5, pp) == 0, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(2, td, y, 4, ring, size, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(2, td, y, 4, ring, size, m, 0, pp) == 0, end);\n\t\t\tfor (int j = 2; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_etrs_ext(td, y, 4, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(1, td+j-1, y+j-1, 4-j+1, ring, size, m, 5, pp) == 0, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(2, td+j-1, y+j-1, 4-j+1, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(2, td+j-1, y+j-1, 4-j+1, ring, size, m, 0, pp) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tec_free(pp);\n\tfor (int i = 0; i < 4; i++) {\n\t\tbn_free(td[i]);\n\t\tbn_free(y[i]);\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tetrs_free(ring[i])\n\t}\n\treturn code;\n}\n\n#endif /* WITH_EC */\n\n#if defined(WITH_PC)\n\nstatic int pdpub(void) {\n\tint code = RLC_ERR;\n\tbn_t r1, r2;\n\tg1_t p, u1, v1;\n\tg2_t q, u2, v2, w2;\n\tgt_t e, r, g[3];\n\n\tbn_null(r1);\n\tbn_null(r2);\n\tg1_null(p);\n\tg1_null(u1);\n\tg1_null(v1);\n\tg2_null(q);\n\tg2_null(u2);\n\tg2_null(v2);\n\tg2_null(w2);\n\tgt_null(e);\n\tgt_null(r);\n\tgt_null(g[0]);\n\tgt_null(g[1]);\n\tgt_null(g[2]);\n\n\tRLC_TRY {\n\t\tbn_new(r1);\n\t\tbn_new(r2);\n\t\tg1_new(p);\n\t\tg1_new(u1);\n\t\tg1_new(v1);\n\t\tg2_new(q);\n\t\tg2_new(u2);\n\t\tg2_new(v2);\n\t\tg2_new(w2);\n\t\tgt_new(e);\n\t\tgt_new(r);\n\t\tgt_new(g[0]);\n\t\tgt_new(g[1]);\n\t\tgt_new(g[2]);\n\n\t\tTEST_CASE(\"delegated pairing computation with public inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_pdpub_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_pdpub_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdpub_ans(g, p, q, v1, v2, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdpub_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e, p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"faster delegated pairing with public inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_lvpub_gen(r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_lvpub_ask(r1, v1, w2, p, q, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvpub_ans(g, p, q, v1, v2, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvpub_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e, p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(r1);\n\tbn_free(r2);\n\tg1_free(p);\n\tg1_free(u1);\n\tg1_free(v1);\n\tg2_free(q);\n\tg2_free(u2);\n\tg2_free(v2);\n\tg2_free(w2);\n\tgt_free(e);\n\tgt_free(r);\n\tgt_free(g[0]);\n\tgt_free(g[1]);\n\tgt_free(g[2]);\n\treturn code;\n}\n\nstatic int pdprv(void) {\n\tint code = RLC_ERR;\n\tbn_t r1, r2[3];\n\tg1_t p, u1[2], v1[3];\n\tg2_t q, u2[2], v2[4], w2[4];\n\tgt_t e[2], r, g[4];\n\n\tbn_null(r1);\n\tg1_null(p);\n\tg2_null(q);\n\tgt_null(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_null(u1[i]);\n\t\tg2_null(u2[i]);\n\t\tgt_null(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_null(v1[i]);\n\t\tbn_null(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_null(v2[i]);\n\t\tg2_null(w2[i]);\n\t\tgt_null(g[i]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r1);\n\t\tg1_new(p);\n\t\tg2_new(q);\n\t\tgt_new(r);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg1_new(u1[i]);\n\t\t\tg2_new(u2[i]);\n\t\t\tgt_new(e[i]);\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tg1_new(v1[i]);\n\t\t\tbn_new(r2[i]);\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tg2_new(v2[i]);\n\t\t\tg2_new(w2[i]);\n\t\t\tgt_new(g[i]);\n\t\t}\n\n\t\tTEST_CASE(\"delegated pairing computation with private inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_pdprv_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_pdprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdprv_ans(g, v1, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdprv_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e[0], p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e[0]) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"faster delegated pairing with private inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_pdprv_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_lvprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvprv_ans(g, v1, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvprv_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e[0], p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e[0]) == RLC_EQ, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(r1);\n\tg1_free(p);\n\tg2_free(q);\n\tgt_free(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_free(u1[i]);\n\t\tg2_free(u2[i]);\n\t\tgt_free(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_free(v1[i]);\n\t\tbn_free(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_free(v2[i]);\n\t\tg2_free(w2[i]);\n\t\tgt_free(g[i]);\n\t}\n\treturn code;\n}\n\nstatic int sokaka(void) {\n\tint code = RLC_ERR, l = RLC_MD_LEN;\n\tsokaka_t k;\n\tbn_t s;\n\tuint8_t k1[RLC_MD_LEN], k2[RLC_MD_LEN];\n\tchar *ia = \"Alice\";\n\tchar *ib = \"Bob\";\n\n\tsokaka_null(k);\n\tbn_null(s);\n\n\tRLC_TRY {\n\t\tsokaka_new(k);\n\t\tbn_new(s);\n\n\t\tcp_sokaka_gen(s);\n\n\t\tTEST_CASE\n\t\t\t\t(\"sakai-ohgishi-kasahara authenticated key agreement is correct\")\n\t\t{\n\t\t\tTEST_ASSERT(cp_sokaka_gen_prv(k, ia, s) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokaka_key(k1, l, ia, k, ib) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokaka_gen_prv(k, ib, s) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokaka_key(k2, l, ib, k, ia) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(k1, k2, l) == 0, end);\n\t\t} TEST_END;\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tsokaka_free(k);\n\tbn_free(s);\n\treturn code;\n}\n\nstatic int ibe(void) {\n\tint code = RLC_ERR;\n\tbn_t s;\n\tg1_t pub;\n\tg2_t prv;\n\tuint8_t in[10], out[10 + 2 * RLC_FP_BYTES + 1];\n\tchar *id = \"Alice\";\n\tsize_t il, ol;\n\tint result;\n\n\tbn_null(s);\n\tg1_null(pub);\n\tg2_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(s);\n\t\tg1_new(pub);\n\t\tg2_new(prv);\n\n\t\tresult = cp_ibe_gen(s, pub);\n\n\t\tTEST_CASE(\"boneh-franklin identity-based encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\til = 10;\n\t\t\tol = il + 2 * RLC_FP_BYTES + 1;\n\t\t\trand_bytes(in, il);\n\t\t\tTEST_ASSERT(cp_ibe_gen_prv(prv, id, s) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ibe_enc(out, &ol, in, il, id, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ibe_dec(out, &il, out, ol, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(in, out, il) == 0, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(s);\n\tg1_free(pub);\n\tg2_free(prv);\n\treturn code;\n}\n\nstatic int bgn(void) {\n\tint result, code = RLC_ERR;\n\tg1_t c[2], d[2];\n\tg2_t e[2], f[2];\n\tgt_t g[4];\n\tbgn_t pub, prv;\n\tdig_t in, out, t;\n\n\tg1_null(c[0]);\n\tg1_null(c[1]);\n\tg1_null(d[0]);\n\tg1_null(d[1]);\n\tg2_null(e[0]);\n\tg2_null(e[1]);\n\tg2_null(f[0]);\n\tg2_null(f[1]);\n\tbgn_null(pub);\n\tbgn_null(prv);\n\n\tRLC_TRY {\n\t\tg1_new(c[0]);\n\t\tg1_new(c[1]);\n\t\tg1_new(d[0]);\n\t\tg1_new(d[1]);\n\t\tg2_new(e[0]);\n\t\tg2_new(e[1]);\n\t\tg2_new(f[0]);\n\t\tg2_new(f[1]);\n\t\tbgn_new(pub);\n\t\tbgn_new(prv);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tgt_null(g[i]);\n\t\t\tgt_new(g[i]);\n\t\t}\n\n\t\tresult = cp_bgn_gen(pub, prv);\n\n\t\tTEST_CASE(\"boneh-go-nissim encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\n\t\t\trand_bytes((unsigned char *)&in, sizeof(dig_t));\n\t\t\tin = in % 11;\n\n\t\t\tTEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec1(&out, c, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(e, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec2(&out, e, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"boneh-go-nissim encryption is additively homomorphic\") {\n\t\t\trand_bytes((unsigned char *)&in, sizeof(dig_t));\n\t\t\tin = in % 11;\n\t\t\tout = in % 7;\n\t\t\tTEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc1(d, out, pub) == RLC_OK, end);\n\t\t\tg1_add(c[0], c[0], d[0]);\n\t\t\tg1_add(c[1], c[1], d[1]);\n\t\t\tg1_norm(c[0], c[0]);\n\t\t\tg1_norm(c[1], c[1]);\n\t\t\tTEST_ASSERT(cp_bgn_dec1(&t, c, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in + out == t, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(e, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(f, out, pub) == RLC_OK, end);\n\t\t\tg2_add(e[0], e[0], f[0]);\n\t\t\tg2_add(e[1], e[1], f[1]);\n\t\t\tg2_norm(e[0], e[0]);\n\t\t\tg2_norm(e[1], e[1]);\n\t\t\tTEST_ASSERT(cp_bgn_dec2(&t, e, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in + out == t, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"boneh-go-nissim encryption is multiplicatively homomorphic\") {\n\t\t\trand_bytes((unsigned char *)&in, sizeof(dig_t));\n\t\t\tin = in % 11;\n\t\t\tout = in % 17;\n\t\t\tTEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(e, out, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc1(d, out, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(f, in, pub) == RLC_OK, end);\n\t\t\tin = in * out;\n\t\t\tTEST_ASSERT(cp_bgn_mul(g, c, e) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == t, end);\n\t\t\tTEST_ASSERT(cp_bgn_mul(g, d, f) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == t, end);\n\t\t\tTEST_ASSERT(cp_bgn_add(g, g, g) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in + in == t, end);\n\t\t} TEST_END;\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tg1_free(c[0]);\n\tg1_free(c[1]);\n\tg1_free(d[0]);\n\tg1_free(d[1]);\n\tg2_free(e[0]);\n\tg2_free(e[1]);\n\tg2_free(f[0]);\n\tg2_free(f[1]);\n\tbgn_free(pub);\n\tbgn_free(prv);\n\tfor (int i = 0; i < 4; i++) {\n\t\tgt_free(g[i]);\n\t}\n\treturn code;\n}\n\nstatic int bls(void) {\n\tint code = RLC_ERR;\n\tbn_t d;\n\tg1_t s;\n\tg2_t q;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(d);\n\tg1_null(s);\n\tg2_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tg1_new(s);\n\t\tg2_new(q);\n\n\t\tTEST_CASE(\"boneh-lynn-schacham short signature is correct\") {\n\t\t\tTEST_ASSERT(cp_bls_gen(d, q) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bls_sig(s, m, sizeof(m), d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bls_ver(s, m, sizeof(m), q) == 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tmemset(m, 0, sizeof(m));\n\t\t\tg2_set_infty(q);\n\t\t\tTEST_ASSERT(cp_bls_ver(s, m, sizeof(m), q) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tg1_free(s);\n\tg2_free(q);\n\treturn code;\n}\n\nstatic int bbs(void) {\n\tint code = RLC_ERR;\n\tbn_t d;\n\tg1_t s;\n\tg2_t q;\n\tgt_t z;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\n\tbn_null(d);\n\tg1_null(s);\n\tg2_null(q);\n\tgt_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tg1_new(s);\n\t\tg2_new(q);\n\t\tgt_new(z);\n\n\t\tTEST_CASE(\"boneh-boyen short signature is correct\") {\n\t\t\tTEST_ASSERT(cp_bbs_gen(d, q, z) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bbs_sig(s, m, sizeof(m), 0, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bbs_ver(s, m, sizeof(m), 0, q, z) == 1, end);\n\t\t\tmd_map(h, m, sizeof(m));\n\t\t\tTEST_ASSERT(cp_bbs_sig(s, m, sizeof(m), 1, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bbs_ver(s, m, sizeof(m), 1, q, z) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tg1_free(s);\n\tg2_free(q);\n\tgt_free(z);\n\treturn code;\n}\n\nstatic int cls(void) {\n\tint i, code = RLC_ERR;\n\tbn_t r, t, u, v, vs[4];\n\tg1_t a, A, b, B, c, As[4], Bs[4];\n\tg2_t x, y, z, zs[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tconst uint8_t *ms[5] = {m, m, m, m, m};\n\tconst size_t ls[5] = {sizeof(m), sizeof(m), sizeof(m), sizeof(m), sizeof(m)};\n\n\tbn_null(r);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(A);\n\tg1_null(b);\n\tg1_null(B);\n\tg1_null(c);\n\tg2_null(x);\n\tg2_null(y);\n\tg2_null(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_null(vs[i]);\n\t\tg1_null(As[i]);\n\t\tg1_null(Bs[i]);\n\t\tg2_null(zs[i]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r);\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tg1_new(a);\n\t\tg1_new(A);\n\t\tg1_new(b);\n\t\tg1_new(B);\n\t\tg1_new(c);\n\t\tg2_new(x);\n\t\tg2_new(y);\n\t\tg2_new(z);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_new(vs[i]);\n\t\t\tg1_new(As[i]);\n\t\t\tg1_new(Bs[i]);\n\t\t\tg2_new(zs[i]);\n\t\t}\n\n\t\tTEST_CASE(\"camenisch-lysyanskaya simple signature is correct\") {\n\t\t\tTEST_ASSERT(cp_cls_gen(u, v, x, y) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cls_sig(a, b, c, m, sizeof(m), u, v) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cls_ver(a, b, c, m, sizeof(m), x, y) == 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tg1_set_infty(a);\n\t\t\tg1_set_infty(b);\n\t\t\tg1_set_infty(c);\n\t\t\tTEST_ASSERT(cp_cls_ver(a, b, c, m, sizeof(m), x, y) == 0, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"camenisch-lysyanskaya message-independent signature is correct\") {\n\t\t\tbn_rand(r, RLC_POS, 2 * pc_param_level());\n\t\t\tTEST_ASSERT(cp_cli_gen(t, u, v, x, y, z) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cli_sig(a, A, b, B, c, m, sizeof(m), r, t, u, v)\n\t\t\t\t\t== RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z)\n\t\t\t\t\t== 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tg1_set_infty(a);\n\t\t\tg1_set_infty(A);\n\t\t\tg1_set_infty(b);\n\t\t\tg1_set_infty(B);\n\t\t\tg1_set_infty(c);\n\t\t\tTEST_ASSERT(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z) == 0, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"camenisch-lysyanskaya message-block signature is correct\") {\n\t\t\tTEST_ASSERT(cp_clb_gen(t, u, vs, x, y, zs, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_clb_sig(a, As, b, Bs, c, ms, ls, t, u, vs, 5)\n\t\t\t\t\t== RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_clb_ver(a, As, b, Bs, c, ms, ls, x, y, zs, 5)\n\t\t\t\t\t== 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(r);\n\tbn_free(t);\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(A);\n\tg1_free(b);\n\tg1_free(B);\n\tg1_free(c);\n\tg2_free(x);\n\tg2_free(y);\n\tg2_free(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_free(vs[i]);\n\t\tg1_free(As[i]);\n\t\tg1_free(Bs[i]);\n\t\tg2_free(zs[i]);\n\t}\n\treturn code;\n}\n\nstatic int pss(void) {\n\tint i, code = RLC_ERR;\n\tbn_t ms[5], n, u, v, _v[5];\n\tg1_t a, b;\n\tg2_t g, x, y, _y[5];\n\n\tbn_null(n);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(b);\n\tg2_null(g);\n\tg2_null(x);\n\tg2_null(y);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg2_new(g);\n\t\tg2_new(x);\n\t\tg2_new(y);\n\n\t\tg1_get_ord(n);\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tbn_null(ms[i]);\n\t\t\tbn_null(_v[i]);\n\t\t\tg2_null(_y[i]);\n\t\t\tbn_new(ms[i]);\n\t\t\tbn_rand_mod(ms[i], n);\n\t\t\tbn_new(_v[i]);\n\t\t\tg2_new(_y[i]);\n\t\t}\n\n\t\tTEST_CASE(\"pointcheval-sanders simple signature is correct\") {\n\t\t\tTEST_ASSERT(cp_pss_gen(u, v, g, x, y) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pss_sig(a, b, ms[0], u, v) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pss_ver(a, b, ms[0], g, x, y) == 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tg1_set_infty(a);\n\t\t\tg1_set_infty(b);\n\t\t\tTEST_ASSERT(cp_pss_ver(a, b, ms[0], g, x, y) == 0, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"pointcheval-sanders block signature is correct\") {\n\t\t\tTEST_ASSERT(cp_psb_gen(u, _v, g, x, _y, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_psb_sig(a, b, ms, u, _v, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_psb_ver(a, b, ms, g, x, _y, 5) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(n);\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(b);\n\tg2_free(g);\n\tg2_free(x);\n\tg2_free(y);\n\tfor (i = 0; i < 5; i++) {\n\t\tbn_free(ms[i]);\n\t\tbn_free(_v[i]);\n\t\tg2_free(_y[i]);\n\t}\n\treturn code;\n}\n\n#if defined(WITH_MPC)\n\nstatic int mpss(void) {\n\tint i, j, code = RLC_ERR;\n\tbn_t m[2], n, u[2], v[2], ms[5][2], _v[5][2];\n\tg1_t g, s[2];\n\tg2_t h, x[2], y[2], _y[5][2];\n\tgt_t e[2], f[2];\n\tmt_t tri[3][2];\n\tpt_t t[2];\n\n\tbn_null(n);\n\tg1_null(g);\n\tg2_null(h);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tg1_new(g);\n\t\tg2_new(h);\n\t\tg1_get_ord(n);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tbn_null(m[i]);\n\t\t\tbn_null(u[i]);\n\t\t\tbn_null(v[i]);\n\t\t\tg1_null(s[i]);\n\t\t\tg2_null(x[i]);\n\t\t\tg2_null(y[i]);\n\t\t\tgt_null(e[i]);\n\t\t\tgt_null(f[i]);\n\t\t\tmt_null(tri[0][i]);\n\t\t\tmt_null(tri[1][i]);\n\t\t\tmt_null(tri[2][i]);\n\t\t\tpt_null(t[i]);\n\t\t\tbn_new(m[i]);\n\t\t\tbn_rand_mod(m[i], n);\n\t\t\tbn_new(u[i]);\n\t\t\tbn_new(v[i]);\n\t\t\tg1_new(s[i]);\n\t\t\tg2_new(x[i]);\n\t\t\tg2_new(y[i]);\n\t\t\tgt_new(e[i]);\n\t\t\tgt_new(f[i]);\n\t\t\tmt_new(tri[0][i]);\n\t\t\tmt_new(tri[1][i]);\n\t\t\tmt_new(tri[2][i]);\n\t\t\tpt_new(t[i]);\n\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\tbn_null(ms[j][i]);\n\t\t\t\tbn_null(_v[j][i]);\n\t\t\t\tg2_null(_y[j][i]);\n\t\t\t\tbn_new(ms[j][i]);\n\t\t\t\tbn_rand_mod(ms[j][i], n);\n\t\t\t\tbn_new(_v[j][i]);\n\t\t\t\tg2_new(_y[j][i]);\n\t\t\t}\n\t\t}\n\n\t\tTEST_CASE(\"multi-party pointcheval-sanders simple signature is correct\") {\n\t\t\tpc_map_tri(t);\n\t\t\tmpc_mt_gen(tri[0], n);\n\t\t\tmpc_mt_gen(tri[1], n);\n\t\t\tmpc_mt_gen(tri[2], n);\n\t\t\tgt_exp_gen(e[0], tri[2][0]->b);\n\t\t\tgt_exp_gen(e[1], tri[2][1]->b);\n\t\t\tgt_exp_gen(f[0], tri[2][0]->c);\n\t\t\tgt_exp_gen(f[1], tri[2][1]->c);\n\t\t\ttri[2][0]->bt = &e[0];\n\t\t\ttri[2][1]->bt = &e[1];\n\t\t\ttri[2][0]->ct = &f[0];\n\t\t\ttri[2][1]->ct = &f[1];\n\t\t\tTEST_ASSERT(cp_mpss_gen(u, v, h, x, y) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_mpss_bct(x, y) == RLC_OK, end);\n\t\t\t/* Compute signature in MPC. */\n\t\t\tTEST_ASSERT(cp_mpss_sig(g, s, m, u, v, tri[0], tri[1]) == RLC_OK, end);\n\t\t\t/* Verify signature in MPC. */\n\t\t\tcp_mpss_ver(e[0], g, s, m, h, x[0], y[0], tri[2], t);\n\t\t\tTEST_ASSERT(gt_is_unity(e[0]) == 1, end);\n\t\t\t/* Check that signature is also valid for conventional scheme. */\n\t\t\tbn_add(m[0], m[0], m[1]);\n\t\t\tbn_mod(m[0], m[0], n);\n\t\t\tg1_add(s[0], s[0], s[1]);\n\t\t\tg1_norm(s[0], s[0]);\n\t\t\tTEST_ASSERT(cp_pss_ver(g, s[0], m[0], h, x[0], y[0]) == 1, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"multi-party pointcheval-sanders block signature is correct\") {\n\t\t\tg1_get_ord(n);\n\t\t\tpc_map_tri(t);\n\t\t\tmpc_mt_gen(tri[0], n);\n\t\t\tmpc_mt_gen(tri[1], n);\n\t\t\tmpc_mt_gen(tri[2], n);\n\t\t\tgt_exp_gen(e[0], tri[2][0]->b);\n\t\t\tgt_exp_gen(e[1], tri[2][1]->b);\n\t\t\tgt_exp_gen(f[0], tri[2][0]->c);\n\t\t\tgt_exp_gen(f[1], tri[2][1]->c);\n\t\t\ttri[2][0]->bt = &e[0];\n\t\t\ttri[2][1]->bt = &e[1];\n\t\t\ttri[2][0]->ct = &f[0];\n\t\t\ttri[2][1]->ct = &f[1];\n\t\t\tTEST_ASSERT(cp_mpsb_gen(u, _v, h, x, _y, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_mpsb_bct(x, _y, 5) == RLC_OK, end);\n\t\t\t/* Compute signature in MPC. */\n\t\t\tTEST_ASSERT(cp_mpsb_sig(g, s, ms, u, _v, tri[0], tri[1], 5) == RLC_OK, end);\n\t\t\t/* Verify signature in MPC. */\n\t\t\tcp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, NULL, tri[2], t, 5);\n\t\t\tTEST_ASSERT(gt_is_unity(e[1]) == 1, end);\n\t\t\tgt_exp_gen(e[0], tri[2][0]->b);\n\t\t\tgt_exp_gen(e[1], tri[2][1]->b);\n\t\t\tcp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 5);\n\t\t\tTEST_ASSERT(gt_is_unity(e[1]) == 1, end);\n\t\t\tbn_sub_dig(ms[0][0], ms[0][0], 1);\n\t\t\tcp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 5);\n\t\t\tTEST_ASSERT(gt_is_unity(e[1]) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(n);\n\tg1_free(g);\n\tg2_free(h);\n\tfor (i = 0; i < 2; i++) {\n\t\tbn_free(m[i]);\n\t\tbn_free(u[i]);\n\t\tbn_free(v[i]);\n\t\tg1_free(s[i]);\n\t\tg2_free(x[i]);\n\t\tg2_free(y[i]);\n\t\tgt_free(e[i]);\n\t\tgt_free(f[i]);\n\t\tmt_free(tri[0][i]);\n\t\tmt_free(tri[1][i]);\n\t\tmt_free(tri[2][i]);\n\t\tpt_free(t[i]);\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tbn_free(ms[j][i]);\n\t\t\tbn_free(_v[j][i]);\n\t\t\tg2_free(_y[j][i]);\n\t\t}\n\t}\n\treturn code;\n}\n\n#endif\n\nstatic int zss(void) {\n\tint code = RLC_ERR;\n\tbn_t d;\n\tg1_t q;\n\tg2_t s;\n\tgt_t z;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\n\tbn_null(d);\n\tg1_null(q);\n\tg2_null(s);\n\tgt_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tg1_new(q);\n\t\tg2_new(s);\n\t\tgt_new(z);\n\n\t\tTEST_CASE(\"zhang-safavi-naini-susilo signature is correct\") {\n\t\t\tTEST_ASSERT(cp_zss_gen(d, q, z) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_zss_sig(s, m, sizeof(m), 0, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_zss_ver(s, m, sizeof(m), 0, q, z) == 1, end);\n\t\t\tmd_map(h, m, sizeof(m));\n\t\t\tTEST_ASSERT(cp_zss_sig(s, m, sizeof(m), 1, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_zss_ver(s, m, sizeof(m), 1, q, z) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tg1_free(q);\n\tg2_free(s);\n\tgt_free(z);\n\treturn code;\n}\n\n#define S\t2\t\t\t/* Number of signers. */\n#define L\t4\t\t\t/* Number of labels. */\n#define K\tRLC_MD_LEN\t/* Size of PRF key. */\n\nstatic int lhs(void) {\n\tint code = RLC_ERR;\n\tuint8_t k[S][K];\n\tbn_t m, n, msg[S][L], sk[S], d[S], x[S][L];\n\tg1_t _r, h, as[S], cs[S], sig[S];\n\tg1_t a[S][L], c[S][L], r[S][L];\n\tg2_t _s, s[S][L], pk[S], y[S], z[S];\n\tgt_t *hs[S], vk;\n\tconst char *data = \"database-identifier\";\n\tconst char *id[S] = { \"Alice\", \"Bob\" };\n\tdig_t ft[S], *f[S] = { NULL };\n\tsize_t flen[S];\n\tchar *ls[L] = { NULL };\n\n\tbn_null(m);\n\tbn_null(n);\n\tg1_null(h);\n\tg1_null(_r);\n\tg2_null(_s);\n\tgt_null(vk);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(n);\n\t\tg1_new(h);\n\t\tg1_new(_r);\n\t\tg2_new(_s);\n\t\tgt_new(vk);\n\n\t\tfor (int i = 0; i < S; i++) {\n\t\t\ths[i] = RLC_ALLOCA(gt_t, RLC_TERMS);\n\t\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\t\tgt_null(hs[i][j]);\n\t\t\t\tgt_new(hs[i][j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < L; j++) {\n\t\t\t\tbn_null(x[i][j]);\n\t\t\t\tbn_null(msg[i][j]);\n\t\t\t\tg1_null(a[i][j]);\n\t\t\t\tg1_null(c[i][j]);\n\t\t\t\tg1_null(r[i][j]);\n\t\t\t\tg2_null(s[i][j]);\n\t\t\t\tbn_new(x[i][j]);\n\t\t\t\tbn_new(msg[i][j]);\n\t\t\t\tg1_new(a[i][j]);\n\t\t\t\tg1_new(c[i][j]);\n\t\t\t\tg1_new(r[i][j]);\n\t\t\t\tg2_new(s[i][j]);\n\t\t\t}\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_null(d[i]);\n\t\t\tg1_null(sig[i]);\n\t\t\tg1_null(as[i]);\n\t\t\tg1_null(cs[i]);\n\t\t\tg2_null(y[i]);\n\t\t\tg2_null(z[i]);\n\t\t\tg2_null(pk[i]);\n\n\t\t\tbn_new(sk[i]);\n\t\t\tbn_new(d[i]);\n\t\t\tg1_new(sig[i]);\n\t\t\tg1_new(as[i]);\n\t\t\tg1_new(cs[i]);\n\t\t\tg2_new(y[i]);\n\t\t\tg2_new(z[i]);\n\t\t\tg2_new(pk[i]);\n\t\t}\n\n\t\t/* Define linear function. */\n\t\tfor (int i = 0; i < S; i++) {\n\t\t\tf[i] = RLC_ALLOCA(dig_t, RLC_TERMS);\n\t\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\t\tdig_t t;\n\t\t\t\trand_bytes((uint8_t *)&t, sizeof(dig_t));\n\t\t\t\tf[i][j] = t & RLC_MASK(RLC_DIG / 2);\n\t\t\t}\n\t\t\tflen[i] = L;\n\t\t}\n\n\t\t/* Initialize scheme for messages of single components. */\n\t\tg1_get_ord(n);\n\t\tcp_cmlhs_init(h);\n\n\t\tTEST_CASE(\"context-hiding linear homomorphic signature is correct\") {\n\t\t\tint label[L], b = i % 2;\n\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], b);\n\t\t\t}\n\t\t\t/* Compute all signatures (ECDSA if b = 0; BLS if b = 1). */\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tlabel[l] = l;\n\t\t\t\t\tbn_rand_mod(msg[j][l], n);\n\t\t\t\t\tcp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l],\n\t\t\t\t\t\ts[j][l], msg[j][l], data, label[l], x[j][l], h, k[j], K,\n\t\t\t\t\t\td[j], sk[j], b);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Apply linear function over signatures. */\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], flen[j]);\n\t\t\t}\n\n\t\t\tcp_cmlhs_evl(_r, _s, r[0], s[0], f[0], flen[0]);\n\t\t\tfor (int j = 1; j < S; j++) {\n\t\t\t\tcp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], flen[j]);\n\t\t\t\tg1_add(_r, _r, r[0][0]);\n\t\t\t\tg2_add(_s, _s, s[0][0]);\n\t\t\t}\n\t\t\tg1_norm(_r, _r);\n\t\t\tg2_norm(_s, _s);\n\t\t\t/* We share messages between users to simplify tests. */\n\t\t\tbn_zero(m);\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tbn_mul_dig(msg[j][l], msg[j][l], f[j][l]);\n\t\t\t\t\tbn_add(m, m, msg[j][l]);\n\t\t\t\t\tbn_mod(m, m, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t\t(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, b), end);\n\n\t\t\tcp_cmlhs_off(vk, h, label, (const gt_t **)hs, (const dig_t **)f,\n\t\t\t\tflen, S);\n\t\t\tTEST_ASSERT(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk,\n\t\t\t\ty, pk, S, b) == 1, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"simple linear multi-key homomorphic signature is correct\") {\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_mklhs_gen(sk[j], pk[j]);\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tls[l] = \"l\";\n\t\t\t\t\tbn_rand_mod(msg[j][l], n);\n\t\t\t\t\tcp_mklhs_sig(a[j][l], msg[j][l], data, id[j], ls[l], sk[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_mklhs_fun(d[j], msg[j], f[j], L);\n\t\t\t}\n\n\t\t\tg1_set_infty(_r);\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_mklhs_evl(r[0][j], a[j], f[j], L);\n\t\t\t\tg1_add(_r, _r, r[0][j]);\n\t\t\t}\n\t\t\tg1_norm(_r, _r);\n\n\t\t\tbn_zero(m);\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tbn_mul_dig(msg[j][l], msg[j][l], f[j][l]);\n\t\t\t\t\tbn_add(m, m, msg[j][l]);\n\t\t\t\t\tbn_mod(m, m, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cp_mklhs_ver(_r, m, d, data, id, (const char **)ls,\n\t\t\t\t\t(const dig_t **)f, flen, pk, S), end);\n\n\t\t\tcp_mklhs_off(as, ft, id, (const char **)ls, (const dig_t **)f,\n\t\t\t\t\tflen, S);\n\t\t\tTEST_ASSERT(cp_mklhs_onv(_r, m, d, data, id, as, ft, pk, S), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(n);\n\tbn_free(m);\n\tg1_free(h);\n\tg1_free(_r);\n\tg2_free(_s);\n\tgt_free(vk);\n\n\tfor (int i = 0; i < S; i++) {\n\t\tRLC_FREE(f[i]);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\t  gt_free(hs[i][j]);\n\t\t}\n\t\tRLC_FREE(hs[i]);\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tbn_free(x[i][j]);\n\t\t\tbn_free(msg[i][j]);\n\t\t\tg1_free(a[i][j]);\n\t\t\tg1_free(c[i][j]);\n\t\t\tg1_free(r[i][j]);\n\t\t\tg2_free(s[i][j]);\n\t\t}\n\t\tbn_free(sk[i]);\n\t\tbn_free(d[i]);\n\t\tg1_free(sig[i]);\n\t\tg1_free(as[i]);\n\t\tg1_free(cs[i]);\n\t\tg2_free(y[i]);\n\t\tg2_free(z[i]);\n\t\tg2_free(pk[i]);\n\t}\n\treturn code;\n}\n\n#define M\t5\t\t\t/* Number of server messages (larger). */\n#define N\t2\t\t\t/* Number of client messages. */\n\nstatic int psi(void) {\n\tint result, code = RLC_ERR;\n\tbn_t g, n, q, r, p[M], x[M], v[N], w[N], y[N], z[M];\n\tg1_t u[M], ss;\n\tg2_t d[M + 1], s[M + 1];\n\tgt_t t[M];\n\tcrt_t crt;\n\tsize_t l;\n\n\tbn_null(g);\n\tbn_null(n);\n\tbn_null(q);\n\tbn_null(r);\n\tg1_null(ss);\n\tcrt_null(crt);\n\n\tRLC_TRY {\n\t\tbn_new(g);\n\t\tbn_new(n);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\t\tg1_new(ss);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tbn_null(p[i]);\n\t\t\tbn_null(x[i]);\n\t\t\tbn_null(z[i]);\n\t\t\tg2_null(d[i]);\n\t\t\tg2_null(s[i]);\n\t\t\tbn_new(p[i]);\n\t\t\tbn_new(x[i]);\n\t\t\tbn_new(z[i]);\n\t\t\tg2_new(d[i]);\n\t\t\tg2_new(s[i]);\n\t\t}\n\t\tg2_null(s[M]);\n\t\tg2_new(s[M]);\n\t\tg2_null(d[M]);\n\t\tg2_new(d[M]);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tbn_null(v[i]);\n\t\t\tbn_null(w[i]);\n\t\t\tbn_null(y[i]);\n\t\t\tg1_null(u[i]);\n\t\t\tgt_null(t[i]);\n\t\t\tbn_new(v[i]);\n\t\t\tbn_new(w[i]);\n\t\t\tbn_new(y[i]);\n\t\t\tg1_new(u[i]);\n\t\t\tgt_new(t[i]);\n\t\t}\n\t\tcrt_new(crt);\n\n\t\tresult = cp_rsapsi_gen(g, n, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"factoring-based laconic private set intersection is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tbn_rand_mod(x[j], n);\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tbn_rand_mod(y[j], n);\n\t\t\t}\n\t\t\tTEST_ASSERT(cp_rsapsi_ask(q, r, p, g, n, x, M) == RLC_OK, end);\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tbn_copy(y[j], x[j]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(cp_rsapsi_ans(v, w, q, g, n, y, N) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_rsapsi_int(z, &l, r, p, n, x, M, v, w, N) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(l == k, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tresult = cp_shipsi_gen(g, crt, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"factoring-based size-hiding private set intersection is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tbn_rand_mod(x[j], crt->n);\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tbn_rand_mod(y[j], crt->n);\n\t\t\t}\n\t\t\tTEST_ASSERT(cp_shipsi_ask(q, r, p, g, crt->n, x, M) == RLC_OK, end);\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tbn_copy(y[j], x[j]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(cp_shipsi_ans(v, w[0], q, g, crt, y, N) == RLC_OK,\n\t\t\t\t\tend);\n\t\t\t\tTEST_ASSERT(cp_shipsi_int(z, &l, r, p, crt->n, x, M, v, w[0],\n\t\t\t\t\tN) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(l == k, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"pairing-based laconic private set intersection is correct\") {\n\t\t\tpc_get_ord(q);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tbn_rand_mod(x[j], q);\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tbn_rand_mod(y[j], q);\n\t\t\t}\n\t\t\tTEST_ASSERT(cp_pbpsi_gen(q, ss, s, M) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pbpsi_ask(d, r, x, s, M) == RLC_OK, end);\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tbn_copy(y[j], x[j]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(cp_pbpsi_ans(t, u, ss, d[0], y, N) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_pbpsi_int(z, &l, d, x, M, t, u, N) == RLC_OK,\n\t\t\t\t\tend);\n\t\t\t\tTEST_ASSERT(l == k, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n  \tbn_free(g);\n\tbn_free(n);\n    bn_free(q);\n\tbn_free(r);\n\tg1_free(ss);\n\tfor (int i = 0; i < M; i++) {\n\t\tbn_free(p[i]);\n\t\tbn_free(x[i]);\n\t\tbn_free(z[i]);\n\t\tg2_free(d[i]);\n\t\tg2_free(s[i]);\n\t}\n\tg2_free(d[M]);\n\tg2_free(s[M]);\n\tfor (int i = 0; i < N; i++) {\n\t\tbn_free(v[i]);\n\t\tbn_free(w[i]);\n\t\tbn_free(y[i]);\n\t\tg1_free(u[i]);\n\t\tgt_free(t[i]);\n\t}\n\tcrt_free(crt);\n\treturn code;\n}\n\n#endif /* WITH_PC */\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the CP module\", 0);\n\n\t#if defined(WITH_BN) && defined(WITH_PC)\n\t\tutil_banner(\"Protocols based on accumulators:\\n\", 0);\n\t\tif (pc_param_set_any() == RLC_OK) {\n\t\t\tif (psi() != RLC_OK) {\n\t\t\t\tcore_clean();\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t#endif\n\n#if defined(WITH_BN)\n\tutil_banner(\"Protocols based on integer factorization:\\n\", 0);\n\tif (rsa() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (rabin() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (benaloh() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (paillier() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (subgroup_paillier() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n#endif\n\n#if defined(WITH_EC)\n\tutil_banner(\"Protocols based on elliptic curves:\\n\", 0);\n\tif (ec_param_set_any() == RLC_OK) {\n\n\t\tif (ecdh() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ecmqv() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n#if defined(WITH_BC)\n\t\tif (ecies() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n#endif\n\n\t\tif (ecdsa() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ecss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (vbnn() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (pok() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sok() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ers() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (smlers() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (etrs() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n#if defined(WITH_PC)\n\tutil_banner(\"Protocols based on pairings:\\n\", 0);\n\tif (pc_param_set_any() == RLC_OK) {\n\n\t\tif (pdpub() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (pdprv() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sokaka() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ibe() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bgn() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bls() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bbs() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (cls() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (pss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n#if defined(WITH_MPC)\n\t\tif (mpss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n#endif\n\n\t\tif (zss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (lhs() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup bn Multiple precision integer arithmetic\n */\n\n/**\n * @file\n *\n * Interface of the module for multiple precision integer arithmetic.\n *\n * @ingroup bn\n */\n\n#ifndef RLC_BN_H\n#define RLC_BN_H\n\n#include \"relic_conf.h\"\n#include \"relic_util.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a multiple precision integer.\n *\n * If the library is built with support for dynamic allocation, this constant\n * represents the size in bits of the memory block allocated each time a\n * multiple precision integer must grow. Otherwise, it represents the fixed\n * fixed precision.\n */\n#define RLC_BN_BITS \t((int)BN_PRECI)\n\n/**\n * Size in digits of a block sufficient to store the required precision.\n */\n#define RLC_BN_DIGS\t\t((int)RLC_CEIL(BN_PRECI, RLC_DIG))\n\n/**\n * Size in digits of a block sufficient to store a multiple precision integer.\n */\n#if BN_MAGNI == DOUBLE\n#define RLC_BN_SIZE\t\t((int)(2 * RLC_BN_DIGS + 2))\n#elif BN_MAGNI == CARRY\n#define RLC_BN_SIZE\t\t((int)(RLC_BN_DIGS + 1))\n#elif BN_MAGNI == SINGLE\n#define RLC_BN_SIZE\t\t((int)RLC_BN_DIGS)\n#endif\n\n/**\n * Positive sign of a multiple precision integer.\n */\n#define RLC_POS\t\t0\n\n/**\n * Negative sign of a multiple precision integer.\n */\n#define RLC_NEG\t\t1\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a multiple precision integer.\n *\n * The field dp points to a vector of digits. These digits are organized\n * in little-endian format, that is, the least significant digits are\n * stored in the first positions of the vector.\n */\ntypedef struct {\n\t/** The number of digits allocated to this multiple precision integer. */\n\tint alloc;\n\t/** The number of digits actually used. */\n\tint used;\n\t/** The sign of this multiple precision integer. */\n\tint sign;\n#if ALLOC == DYNAMIC\n\t/** The sequence of contiguous digits that forms this integer. */\n\tdig_t *dp;\n#elif ALLOC == AUTO\n\t/** The sequence of contiguous digits that forms this integer. */\n\trlc_align dig_t dp[RLC_BN_SIZE];\n#endif\n} bn_st;\n\n/**\n * Pointer to a multiple precision integer structure.\n */\n#if ALLOC == AUTO\ntypedef bn_st bn_t[1];\n#elif ALLOC == DYNAMIC\n#ifdef CHECK\ntypedef bn_st *volatile bn_t;\n#else\ntypedef bn_st *bn_t;\n#endif\n#endif\n\n/**\n * Represents a pair of moduli for using the Chinese Remainder Theorem (CRT).\n */\ntypedef struct {\n\t/** The modulus n = pq. */\n\tbn_t n;\n\t/** The first prime p. */\n\tbn_t p;\n\t/** The second prime q. */\n\tbn_t q;\n\t/** The precomputed constant for the first prime. */\n\tbn_t dp;\n\t/** The precomputed constant for the second prime. */\n\tbn_t dq;\n\t/** The inverse of q modulo p. */\n\tbn_t qi;\n} crt_st;\n\n#if ALLOC == AUTO\ntypedef crt_st crt_t[1];\n#else\ntypedef crt_st *crt_t;\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a multiple precision integer with a null value.\n *\n * @param[out] A\t\t\t- the multiple precision integer to initialize.\n */\n#if ALLOC == AUTO\n#define bn_null(A)\t\t\t/* empty */\n#elif ALLOC == DYNAMIC\n#define bn_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif ((A) == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer\n * with the required precision in digits.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @param[in] D\t\t\t\t- the precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\n#if ALLOC == DYNAMIC\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to free.\n */\n#if ALLOC == DYNAMIC\n#define bn_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_clean(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree((void *)A);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bn_free(A)\t\t\t/* empty */\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Initializes a CRT moduli set with a null value.\n *\n * @param[out] A\t\t\t- the moduli to initialize.\n */\n#define crt_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Rabin key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (crt_t)calloc(1, sizeof(crt_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Rabin key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define crt_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define crt_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Multiples two multiple precision integers. Computes c = a * b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] B\t\t\t\t- the second multiple precision integer to multiply.\n */\n#if BN_KARAT > 0\n#define bn_mul(C, A, B)\t\tbn_mul_karat(C, A, B)\n#elif BN_MUL == BASIC\n#define bn_mul(C, A, B)\t\tbn_mul_basic(C, A, B)\n#elif BN_MUL == COMBA\n#define bn_mul(C, A, B)\t\tbn_mul_comba(C, A, B)\n#endif\n\n/**\n * Computes the square of a multiple precision integer. Computes c = a * a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to square.\n */\n#if BN_KARAT > 0\n#define bn_sqr(C, A)\t\tbn_sqr_karat(C, A)\n#elif BN_SQR == BASIC\n#define bn_sqr(C, A)\t\tbn_sqr_basic(C, A)\n#elif BN_SQR == COMBA\n#define bn_sqr(C, A)\t\tbn_sqr_comba(C, A)\n#elif BN_SQR == MULTP\n#define bn_sqr(C, A)\t\tbn_mul(C, A, A)\n#endif\n\n/**\n * Computes the auxiliar value derived from the modulus to be used during\n * modular reduction.\n *\n * @param[out] U\t\t\t- the result.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_pre(U, M)\t(void)(U), (void)(M)\n#elif BN_MOD == BARRT\n#define bn_mod_pre(U, M)\tbn_mod_pre_barrt(U, M)\n#elif BN_MOD == MONTY\n#define bn_mod_pre(U, M)\tbn_mod_pre_monty(U, M)\n#elif BN_MOD == PMERS\n#define bn_mod_pre(U, M)\tbn_mod_pre_pmers(U, M)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo another integer. If the number\n * of arguments is 3, then simple division is used. If the number of arguments\n * is 4, then a modular reduction algorithm is used and the fourth argument\n * is an auxiliary value derived from the modulus. The variant with 4 arguments\n * should be used when several modular reductions are computed with the same\n * modulus. Computes c = a mod m.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] ...\t\t\t- the modulus and an optional argument.\n */\n#define bn_mod(C, A, ...)\tRLC_CAT(bn_mod, RLC_OPT(__VA_ARGS__))(C, A, __VA_ARGS__)\n\n/**\n * Reduces a multiple precision integer modulo another integer. This macro\n * should not be called directly. Use bn_mod with 4 arguments instead.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the auxiliar value derived from the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_imp(C, A, M, U)\tbn_mod_basic(C, A, M)\n#elif BN_MOD == BARRT\n#define bn_mod_imp(C, A, M, U)\tbn_mod_barrt(C, A, M, U)\n#elif BN_MOD == MONTY\n#define bn_mod_imp(C, A, M, U)\tbn_mod_monty(C, A, M, U)\n#elif BN_MOD == PMERS\n#define bn_mod_imp(C, A, M, U)\tbn_mod_pmers(C, A, M, U)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction. Computes c = a * u^(-1) (mod m).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the reciprocal of the modulus.\n */\n#if BN_MUL == BASIC\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_basic(C, A, M, U)\n#elif BN_MUL == COMBA\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_comba(C, A, M, U)\n#endif\n\n/**\n * Exponentiates a multiple precision integer modulo another multiple precision\n * integer. Computes c = a^b mod m. If Montgomery reduction is used, the basis\n * must not be in Montgomery form.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MXP == BASIC\n#define bn_mxp(C, A, B, M)\tbn_mxp_basic(C, A, B, M)\n#elif BN_MXP == SLIDE\n#define bn_mxp(C, A, B, M)\tbn_mxp_slide(C, A, B, M)\n#elif BN_MXP == MONTY\n#define bn_mxp(C, A, B, M)\tbn_mxp_monty(C, A, B, M)\n#endif\n\n/**\n * Computes the greatest common divisor of two multiple precision integers.\n * Computes c = gcd(a, b).\n *\n * @param[out] C\t\t\t- the result;\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd(C, A, B)\t\tbn_gcd_basic(C, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd(C, A, B)\t\tbn_gcd_lehme(C, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd(C, A, B)\t\tbn_gcd_binar(C, A, B)\n#endif\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers. This function can be used to compute multiplicative inverses.\n * Computes c = gcd(a, b) and c = a * d + b * e.\n *\n * @param[out] C\t\t\t- the result;\n * @param[out] D\t\t\t- the cofactor of the first operand, cannot be NULL.\n * @param[out] E\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_basic(C, D, E, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_lehme(C, D, E, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_binar(C, D, E, A, B)\n#endif\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] A\t\t\t- the result.\n * @param[in] B\t\t\t\t- the length of the number in bits.\n */\n#if BN_GEN == BASIC\n#define bn_gen_prime(A, B)\tbn_gen_prime_basic(A, B)\n#elif BN_GEN == SAFEP\n#define bn_gen_prime(A, B)\tbn_gen_prime_safep(A, B)\n#elif BN_GEN == STRON\n#define bn_gen_prime(A, B)\tbn_gen_prime_stron(A, B)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes a previously allocated multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to initialize.\n * @param[in] digits\t\t- the required precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_make(bn_t a, int digits);\n\n/**\n * Cleans a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to free.\n */\nvoid bn_clean(bn_t a);\n\n/**\n * Checks the current precision of a multiple precision integer and optionally\n * expands its precision to a given size in digits.\n *\n * @param[out] a\t\t\t- the multiple precision integer to expand.\n * @param[in] digits\t\t- the number of digits to expand.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_grow(bn_t a, int digits);\n\n/**\n * Adjust the number of valid digits of a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to adjust.\n */\nvoid bn_trim(bn_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to copy.\n */\nvoid bn_copy(bn_t c, const bn_t a);\n\n/**\n * Returns the absolute value of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the argument of the absolute function.\n */\nvoid bn_abs(bn_t c, const bn_t a);\n\n/**\n * Inverts the sign of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the multiple precision integer to negate.\n */\nvoid bn_neg(bn_t c, const bn_t a);\n\n/**\n * Returns the sign of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return RLC_POS if the argument is positive and RLC_NEG otherwise.\n */\nint bn_sign(const bn_t a);\n\n/**\n * Assigns zero to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n */\nvoid bn_zero(bn_t a);\n\n/**\n * Tests if a multiple precision integer is zero or not.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint bn_is_zero(const bn_t a);\n\n/**\n * Tests if a multiple precision integer is even or odd.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is even, 0 otherwise.\n */\nint bn_is_even(const bn_t a);\n\n/**\n * Returns the number of bits of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return number of bits.\n */\nint bn_bits(const bn_t a);\n\n/**\n * Returns the bit stored in the given position on a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to read.\n * @return the bit value.\n */\nint bn_get_bit(const bn_t a, int bit);\n\n/**\n * Stores a bit in a given position on a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to store.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid bn_set_bit(bn_t a, int bit, int value);\n\n/**\n * Returns the Hamming weight of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of non-zero bits.\n */\nint bn_ham(const bn_t a);\n\n/**\n * Reads the first digit in a multiple precision integer.\n *\n * @param[out] digit\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n */\nvoid bn_get_dig(dig_t *digit, const bn_t a);\n\n/**\n * Assigns a small positive constant to a multiple precision integer.\n *\n * The constant must fit on a multiple precision digit, or dig_t type using\n * only the number of bits specified on RLC_DIG.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] digit\t\t\t- the constant to assign.\n */\nvoid bn_set_dig(bn_t a, dig_t digit);\n\n/**\n * Assigns a multiple precision integer to 2^b.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] b\t\t\t\t- the power of 2 to assign.\n */\nvoid bn_set_2b(bn_t a, int b);\n\n/**\n * Assigns a random value to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] sign\t\t\t- the sign to be assigned (RLC_NEG or RLC_POS).\n * @param[in] bits\t\t\t- the number of bits.\n */\nvoid bn_rand(bn_t a, int sign, int bits);\n\n/**\n * Assigns a non-zero random value to a multiple precision integer with absolute\n * value smaller than a given modulus.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] b\t\t\t\t- the modulus.\n */\nvoid bn_rand_mod(bn_t a, const bn_t b);\n\n/**\n * Prints a multiple precision integer to standard output.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to print.\n */\nvoid bn_print(const bn_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a multiple precision\n * integer. The radix must be included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nint bn_size_str(const bn_t a, int radix);\n\n/**\n * Reads a multiple precision integer from a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_read_str(bn_t a, const char *str, int len, int radix);\n\n/**\n * Writes a multiple precision integer to a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_write_str(char *str, int len, const bn_t a, int radix);\n\n/**\n * Returns the number of bytes necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of bytes.\n */\nint bn_size_bin(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n */\nvoid bn_read_bin(bn_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_bin(uint8_t *bin, int len, const bn_t a);\n\n/**\n * Returns the number of digits necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of digits.\n */\nint bn_size_raw(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a digit vector.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the size of the string.\n */\nvoid bn_read_raw(bn_t a, const dig_t *raw, int len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector.\n *\n * @param[out] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_raw(dig_t *raw, int len, const bn_t a);\n\n/**\n * Returns the result of an unsigned comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_abs(const bn_t a, const bn_t b);\n\n/**\n * Returns the result of a signed comparison between a multiple precision\n * integer and a digit.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_dig(const bn_t a, dig_t b);\n\n/**\n * Returns the result of a signed comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp(const bn_t a, const bn_t b);\n\n/**\n * Adds two multiple precision integers. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to add.\n * @param[in] b\t\t\t\t- the second multiple precision integer to add.\n */\nvoid bn_add(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Adds a multiple precision integers and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to add.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid bn_add_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Subtracts a multiple precision integer from another, that is, computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the multiple precision integer to subtract.\n */\nvoid bn_sub(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Subtracts a digit from a multiple precision integer. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid bn_sub_dig(bn_t c, const bn_t a, const dig_t b);\n\n/**\n * Multiplies a multiple precision integer by a digit. Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid bn_mul_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Multiplies two multiple precision integers using Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_comba(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_karat(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the square of a multiple precision integer using Schoolbook\n * squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_basic(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Comba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_comba(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Karatsuba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_karat(bn_t c, const bn_t a);\n\n/**\n * Doubles a multiple precision. Computes c = a + a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to double.\n */\nvoid bn_dbl(bn_t c, const bn_t a);\n\n/**\n * Halves a multiple precision. Computes c = floor(a / 2)\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to halve.\n */\nvoid bn_hlv(bn_t c, const bn_t a);\n\n/**\n * Shifts a multiple precision number to the left. Computes c = a * 2^bits.\n * c = a * 2^bits.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_lsh(bn_t c, const bn_t a, int bits);\n\n/**\n * Shifts a multiple precision number to the right. Computes\n * c = floor(a / 2^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_rsh(bn_t c, const bn_t a, int bits);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * without producing the positive remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * and produces a positive remainder. Computes c = floor(a / b) and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the positive remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem(bn_t c, bn_t d, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integers by a digit without computing the\n * remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Divides a multiple precision integers by a digit. Computes c = floor(a / b)\n * and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem_dig(bn_t c, dig_t *d, const bn_t a, const dig_t b);\n\n/**\n * Computes the modular inverse of a multiple precision integer. Computes c such\n * that a*c mod b = 1.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a\t\t\t\t- the element to invert.\n * param[in] b\t\t\t\t- the modulus.\n *\n */\nvoid bn_mod_inv(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the modular inverse of multiple precision integers simultaneously.\n * Computes c_i such that a_i * c_i mod b = 1.\n *\n * @param[out] c\t\t\t- the results.\n * @param[in] a\t\t\t\t- the elements to invert.\n * param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid bn_mod_inv_sim(bn_t *c, const bn_t *a, const bn_t b, int n);\n\n/**\n * Reduces a multiple precision integer modulo a power of 2. Computes\n * c = a mod 2^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the exponent of the divisor.\n */\nvoid bn_mod_2b(bn_t c, const bn_t a, int b);\n\n/**\n * Reduces a multiple precision integer modulo a digit. Computes c = a mod b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n */\nvoid bn_mod_dig(dig_t *c, const bn_t a, dig_t b);\n\n/**\n * Reduces a multiple precision integer modulo an integer using straightforward\n * division.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_basic(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Barrett modular\n * reduction algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_barrt(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using Barrett\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_barrt(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Montgomery reduction\n * algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n * @throw ERR_NO_VALID\t\t- if the modulus is even.\n */\nvoid bn_mod_pre_monty(bn_t u, const bn_t m);\n\n/**\n * Converts a multiple precision integer to Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_conv(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Converts a multiple precision integer from Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_back(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_basic(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_comba(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes u if the modulus has the form 2^b - u.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_pmers(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * pseudo-Mersenne modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the auxiliar value derived from the modulus.\n */\nvoid bn_mod_pmers(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the constant-time Montgomery powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_monty(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer by a small power modulo a positive\n * integer using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_dig(bn_t c, const bn_t a, dig_t b, const bn_t m);\n\n/*\n * Computes a modular exponentiation of a multiple precision integer using the\n * Chinese Remainder Theorem, given the moduli.\n *\n * @param[out] d \t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent modulo p.\n * @param[in] c\t\t\t\t- the exponent modulo q.\n * @param[in] crt \t\t\t- the set of moduli.\n * @param[in] sqr \t\t\t- the flag to indicate if modulo n or n^2.\n */\nvoid bn_mxp_crt(bn_t d, const bn_t a, const bn_t b, const bn_t c,\n\tconst crt_t crt, int sqr);\n\n/**\n * Extracts an approximate integer square-root of a multiple precision integer.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a \t\t\t- the multiple precision integer to extract.\n *\n * @throw ERR_NO_VALID\t\t- if the argument is negative.\n */\nvoid bn_srt(bn_t c, bn_t a);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the standard Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_binar(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of a multiple precision integer and a\n * digit.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integer using the Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_basic(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers halfway through the algorithm. Returns also two short vectors\n * v1 = (c, d), v2 = (-e, f) useful to decompose an integer k into k0, k1 such\n * that k = k_0 + k_1 * a (mod b).\n *\n * @param[out] c\t\t\t- the first component of the first vector.\n * @param[out] d\t\t\t- the second component of the first vector.\n * @param[out] e\t\t\t- the first component of the second vector.\n * @param[out] f\t\t\t- the second component of the second vector.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_mid(bn_t c, bn_t d, bn_t e, bn_t f, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of a multiple precision integer\n * and a digit.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_ext_dig(bn_t c, bn_t d, bn_t e, const bn_t a, dig_t b);\n\n/**\n * Computes the last common multiple of two multiple precision integers.\n * Computes c = lcm(a, b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first integer.\n * @param[in] b\t\t\t\t- the second integer.\n */\nvoid bn_lcm(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the Legendre symbol c = (a|b), b prime.\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is negative.\n * @return the result.\n */\nint bn_smb_leg(const bn_t a, const bn_t b);\n\n/**\n * Computes the Jacobi symbol c = (a|b).\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is even or negative.\n * @return the result.\n */\nint bn_smb_jac(const bn_t a, const bn_t b);\n\n/**\n * Tests if a number is a probable prime.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if a is prime, 0 otherwise.\n */\nint bn_is_prime(const bn_t a);\n\n/**\n * Tests if a number is prime using a series of trial divisions.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_basic(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Miller-Rabin test with probability\n * 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_rabin(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Solovay-Strassen test with\n * probability 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_solov(const bn_t a);\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_basic(bn_t a, int bits);\n\n/**\n * Generates a probable prime number a with (a - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_safep(bn_t a, int bits);\n\n/**\n * Generates a probable prime number with (a - 1)/2, (a + 1)/2 and\n * ((a - 1)/2 - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_stron(bn_t a, int bits);\n\n/**\n * Generates a probable prime number b, with (b-1) divisible by a probable large\n * prime a.\n *\n * @param[out] a\t\t\t- the prime factor of (b-1).\n * @param[out] b\t\t\t- the prime result b.\n * @param[in] abits\t\t\t- the length of the factor a in bits.\n * @param[in] bbits\t\t\t- the length of the result in bits.\n */\nint bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits);\n\n\n/**\n * Tries to factorize an integer using Pollard (p - 1) factoring algorithm.\n * The maximum length of the returned factor is 16 bits.\n *\n * @param[out] c\t\t\t- the resulting factor.\n * @param[in] a\t\t\t\t- the integer to fatorize.\n * @return 1 if a factor is found and stored into c; 0 otherwise.\n */\nint bn_factor(bn_t c, const bn_t a);\n\n/**\n * Tests if an integer divides other integer.\n *\n * @param[in] c\t\t\t\t- the factor.\n * @param[in] a\t\t\t\t- the integer.\n * @return 1 if the first integer is a factor; 0 otherwise.\n */\nint bn_is_factor(bn_t c, const bn_t a);\n\n/**\n * Recodes a positive integer in window form. If a negative integer is given\n * instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in sliding window form. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in width-w Non-Adjacent Form. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in width-w \\tau-NAF. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w \\tau-NAF.\n * If a negative integer is given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n\n/**\n * Write the constants needed for \\tau-NAF recoding as a set of \\alpha_u =\n * \\beta_u + \\gamma_u * \\tau elements.\n *\n * @param[out] t \t\t- the integer corresponding to \\tau.\n * @param[out] beta\t\t- the first coefficients of the constants.\n * @param[out] gama\t\t- the second coefficients of the constants.\n * @param[in] u \t\t- the u curve parameter.\n * @param[in] w \t\t- the window size in bits.\n */\nvoid bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);\n\n/**\n * Computes the partial reduction k partmod d = r0 + r1 * t, where\n * d = (t^m - 1)/(t - 1).\n *\n * @param[out] r0\t\t- the first half of the result.\n * @param[out] r1\t\t- the second half of the result.\n * @param[in] k\t\t\t- the number to reduce.\n * @param[in] u\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t- the extension degree of the binary field.\n */\nvoid bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w NAF. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the length of the recoding.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);\n\n/**\n * Recodes of a pair of positive integers in Joint Sparse Form. If negative\n * integers are given instead, takes their absolute value.\n *\n * @param[out] jsf\t\t\t- the recoded pair of integers.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the first integer to recode.\n * @param[in] l\t\t\t\t- the second integer to recode.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l);\n\n/**\n * Recodes a positive integer into two parts k0,k1 such that k = k0 + phi(k1),\n * where phi is an efficient curve endomorphism. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] k0\t\t\t- the first part of the result.\n * @param[out] k1\t\t\t- the second part of the result.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the group order.\n * @param[in] v1\t\t\t- the set of parameters v1 for the GLV method.\n * @param[in] v2\t\t\t- the set of parameters v2 for the GLV method.\n */\nvoid bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t v1[],\n\t\tconst bn_t v2[]);\n\n/**\n * Recodes a scalar in subscalars according to Frobenius endomorphism.\n *\n * @param[out] ki\t\t\t- the recoded subscalars.\n * @param[in] sub \t\t\t- the number of subscalars.\n * @param[in] k\t\t\t\t- the scalar to recode.\n * @param[in] x \t\t\t- the elliptic curve parameter.\n * @param[in] n\t\t\t\t- the elliptic curve group order.\n * @param[in] cof \t\t\t- flag to indicate if it is a curve with cofactor 1.\n */\nvoid bn_rec_frb(bn_t *ki, int sub, const bn_t k, const bn_t x, const bn_t n,\n\tint bls);\n\n/**\n * Computes the coefficients of the polynomial representing the Lagrange\n * interpolation for a modulus and a given set of roots.\n * Computes c(x) = \\prod_{0 <= i < n}(x - ai) mod q.\n *\n * @param[out] c \t\t\t- the coefficients of the polynomial.\n * @param[in] a\t\t\t\t- the set of roots.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of roots to interpolate.\n */\nvoid bn_lag(bn_t *c, const bn_t *a, const bn_t b, size_t n);\n\n/**\n * Evaluates an interpolated n-degree polynomial over a value in a modular way,\n * given the (n+1) coefficients of the polynomial and the modulus.\n * Computes c = a(x) mod q.\n *\n * @param[out] c \t\t\t- the result of the evaluation.\n * @param[in] a \t\t\t- the coefficients of the polynomial.\n * @param[in] x\t\t\t\t- the value to evaluate.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the degree of the polynomial.\n */\nvoid bn_evl(bn_t c, const bn_t *a, const bn_t x, const bn_t b, size_t n);\n\n#endif /* !RLC_BN_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Symbol renaming to a#undef clashes when simultaneous linking multiple builds.\n *\n * @ingroup core\n */\n\n#ifndef RLC_LABEL_H\n#define RLC_LABEL_H\n\n#include \"relic_conf.h\"\n\n#define RLC_PREFIX(F)\t\t\t_RLC_PREFIX(LABEL, F)\n#define _RLC_PREFIX(A, B)\t\t__RLC_PREFIX(A, B)\n#define __RLC_PREFIX(A, B)\t\tA ## _ ## B\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n#ifdef LABEL\n\n#undef first_ctx\n#define first_ctx     RLC_PREFIX(first_ctx)\n#undef core_ctx\n#define core_ctx      RLC_PREFIX(core_ctx)\n\n#undef core_init\n#undef core_clean\n#undef core_get\n#undef core_set\n#undef core_set_thread_initializer\n\n#define core_init \tRLC_PREFIX(core_init)\n#define core_clean \tRLC_PREFIX(core_clean)\n#define core_get \tRLC_PREFIX(core_get)\n#define core_set \tRLC_PREFIX(core_set)\n#define core_set_thread_initializer \tRLC_PREFIX(core_set_thread_initializer)\n\n#undef arch_init\n#undef arch_clean\n#undef arch_cycles\n#undef arch_lzcnt\n#undef arch_copy_rom\n\n#define arch_init \tRLC_PREFIX(arch_init)\n#define arch_clean \tRLC_PREFIX(arch_clean)\n#define arch_cycles \tRLC_PREFIX(arch_cycles)\n#define arch_lzcnt \tRLC_PREFIX(arch_lzcnt)\n#define arch_copy_rom \tRLC_PREFIX(arch_copy_rom)\n\n#undef bench_init\n#undef bench_clean\n#undef bench_overhead\n#undef bench_reset\n#undef bench_before\n#undef bench_after\n#undef bench_compute\n#undef bench_print\n#undef bench_total\n\n#define bench_init \tRLC_PREFIX(bench_init)\n#define bench_clean \tRLC_PREFIX(bench_clean)\n#define bench_overhead \tRLC_PREFIX(bench_overhead)\n#define bench_reset \tRLC_PREFIX(bench_reset)\n#define bench_before \tRLC_PREFIX(bench_before)\n#define bench_after \tRLC_PREFIX(bench_after)\n#define bench_compute \tRLC_PREFIX(bench_compute)\n#define bench_print \tRLC_PREFIX(bench_print)\n#define bench_total \tRLC_PREFIX(bench_total)\n\n#undef err_simple_msg\n#undef err_full_msg\n#undef err_get_msg\n#undef err_get_code\n\n#define err_simple_msg \tRLC_PREFIX(err_simple_msg)\n#define err_full_msg \tRLC_PREFIX(err_full_msg)\n#define err_get_msg \tRLC_PREFIX(err_get_msg)\n#define err_get_code \tRLC_PREFIX(err_get_code)\n\n#undef rand_init\n#undef rand_clean\n#undef rand_seed\n#undef rand_seed\n#undef rand_check\n#undef rand_bytes\n\n#define rand_init \tRLC_PREFIX(rand_init)\n#define rand_clean \tRLC_PREFIX(rand_clean)\n#define rand_seed \tRLC_PREFIX(rand_seed)\n#define rand_seed \tRLC_PREFIX(rand_seed)\n#define rand_check \tRLC_PREFIX(rand_check)\n#define rand_bytes \tRLC_PREFIX(rand_bytes)\n\n#undef test_fail\n#undef test_pass\n\n#define test_fail \tRLC_PREFIX(test_fail)\n#define test_pass \tRLC_PREFIX(test_pass)\n\n#undef util_conv_endian\n#undef util_conv_big\n#undef util_conv_little\n#undef util_conv_char\n#undef util_bits_dig\n#undef util_cmp_const\n#undef util_perm\n#undef util_printf\n#undef util_print_dig\n\n#define util_conv_endian \tRLC_PREFIX(util_conv_endian)\n#define util_conv_big \tRLC_PREFIX(util_conv_big)\n#define util_conv_little \tRLC_PREFIX(util_conv_little)\n#define util_conv_char \tRLC_PREFIX(util_conv_char)\n#define util_bits_dig \tRLC_PREFIX(util_bits_dig)\n#define util_cmp_const \tRLC_PREFIX(util_cmp_const)\n#define util_perm \tRLC_PREFIX(util_perm)\n#define util_printf \tRLC_PREFIX(util_printf)\n#define util_print_dig \tRLC_PREFIX(util_print_dig)\n\n#undef conf_print\n#define conf_print    RLC_PREFIX(conf_print)\n\n#undef dv_t\n#define dv_t          RLC_PREFIX(dv_t)\n\n#undef dv_print\n#undef dv_zero\n#undef dv_copy\n#undef dv_copy_cond\n#undef dv_swap_cond\n#undef dv_cmp\n#undef dv_cmp_const\n#undef dv_new_dynam\n#undef dv_free_dynam\n#undef dv_lshd\n#undef dv_rshd\n\n#define dv_print \tRLC_PREFIX(dv_print)\n#define dv_zero \tRLC_PREFIX(dv_zero)\n#define dv_copy \tRLC_PREFIX(dv_copy)\n#define dv_copy_cond \tRLC_PREFIX(dv_copy_cond)\n#define dv_swap_cond \tRLC_PREFIX(dv_swap_cond)\n#define dv_cmp \tRLC_PREFIX(dv_cmp)\n#define dv_cmp_const \tRLC_PREFIX(dv_cmp_const)\n#define dv_new_dynam \tRLC_PREFIX(dv_new_dynam)\n#define dv_free_dynam \tRLC_PREFIX(dv_free_dynam)\n#define dv_lshd \tRLC_PREFIX(dv_lshd)\n#define dv_rshd \tRLC_PREFIX(dv_rshd)\n\n\n\n#undef bn_st\n#undef bn_t\n#define bn_st     \tRLC_PREFIX(bn_st)\n#define bn_t      \tRLC_PREFIX(bn_t)\n\n#undef bn_make\n#undef bn_clean\n#undef bn_grow\n#undef bn_trim\n#undef bn_copy\n#undef bn_abs\n#undef bn_neg\n#undef bn_sign\n#undef bn_zero\n#undef bn_is_zero\n#undef bn_is_even\n#undef bn_bits\n#undef bn_get_bit\n#undef bn_set_bit\n#undef bn_ham\n#undef bn_get_dig\n#undef bn_set_dig\n#undef bn_set_2b\n#undef bn_rand\n#undef bn_rand_mod\n#undef bn_print\n#undef bn_size_str\n#undef bn_read_str\n#undef bn_write_str\n#undef bn_size_bin\n#undef bn_read_bin\n#undef bn_write_bin\n#undef bn_size_raw\n#undef bn_read_raw\n#undef bn_write_raw\n#undef bn_cmp_abs\n#undef bn_cmp_dig\n#undef bn_cmp\n#undef bn_add\n#undef bn_add_dig\n#undef bn_sub\n#undef bn_sub_dig\n#undef bn_mul_dig\n#undef bn_mul_basic\n#undef bn_mul_comba\n#undef bn_mul_karat\n#undef bn_sqr_basic\n#undef bn_sqr_comba\n#undef bn_sqr_karat\n#undef bn_dbl\n#undef bn_hlv\n#undef bn_lsh\n#undef bn_rsh\n#undef bn_div\n#undef bn_div_rem\n#undef bn_div_dig\n#undef bn_div_rem_dig\n#undef bn_mod_inv\n#undef bn_mod_inv_sim\n#undef bn_mod_2b\n#undef bn_mod_dig\n#undef bn_mod_basic\n#undef bn_mod_pre_barrt\n#undef bn_mod_barrt\n#undef bn_mod_pre_monty\n#undef bn_mod_monty_conv\n#undef bn_mod_monty_back\n#undef bn_mod_monty_basic\n#undef bn_mod_monty_comba\n#undef bn_mod_pre_pmers\n#undef bn_mod_pmers\n#undef bn_mxp_basic\n#undef bn_mxp_slide\n#undef bn_mxp_monty\n#undef bn_mxp_dig\n#undef bn_mxp_crt\n#undef bn_srt\n#undef bn_gcd_basic\n#undef bn_gcd_lehme\n#undef bn_gcd_binar\n#undef bn_gcd_dig\n#undef bn_gcd_ext_basic\n#undef bn_gcd_ext_lehme\n#undef bn_gcd_ext_binar\n#undef bn_gcd_ext_mid\n#undef bn_gcd_ext_dig\n#undef bn_lcm\n#undef bn_smb_leg\n#undef bn_smb_jac\n#undef bn_is_prime\n#undef bn_is_prime_basic\n#undef bn_is_prime_rabin\n#undef bn_is_prime_solov\n#undef bn_gen_prime_basic\n#undef bn_gen_prime_safep\n#undef bn_gen_prime_stron\n#undef bn_gen_prime_factor\n#undef bn_factor\n#undef bn_is_factor\n#undef bn_rec_win\n#undef bn_rec_slw\n#undef bn_rec_naf\n#undef bn_rec_tnaf\n#undef bn_rec_rtnaf\n#undef bn_rec_tnaf_get\n#undef bn_rec_tnaf_mod\n#undef bn_rec_reg\n#undef bn_rec_jsf\n#undef bn_rec_glv\n#undef bn_rec_frb\n#undef bn_lag\n#undef bn_evl\n\n#define bn_make \tRLC_PREFIX(bn_make)\n#define bn_clean \tRLC_PREFIX(bn_clean)\n#define bn_grow \tRLC_PREFIX(bn_grow)\n#define bn_trim \tRLC_PREFIX(bn_trim)\n#define bn_copy \tRLC_PREFIX(bn_copy)\n#define bn_abs \tRLC_PREFIX(bn_abs)\n#define bn_neg \tRLC_PREFIX(bn_neg)\n#define bn_sign \tRLC_PREFIX(bn_sign)\n#define bn_zero \tRLC_PREFIX(bn_zero)\n#define bn_is_zero \tRLC_PREFIX(bn_is_zero)\n#define bn_is_even \tRLC_PREFIX(bn_is_even)\n#define bn_bits \tRLC_PREFIX(bn_bits)\n#define bn_get_bit \tRLC_PREFIX(bn_get_bit)\n#define bn_set_bit \tRLC_PREFIX(bn_set_bit)\n#define bn_ham \tRLC_PREFIX(bn_ham)\n#define bn_get_dig \tRLC_PREFIX(bn_get_dig)\n#define bn_set_dig \tRLC_PREFIX(bn_set_dig)\n#define bn_set_2b \tRLC_PREFIX(bn_set_2b)\n#define bn_rand \tRLC_PREFIX(bn_rand)\n#define bn_rand_mod \tRLC_PREFIX(bn_rand_mod)\n#define bn_print \tRLC_PREFIX(bn_print)\n#define bn_size_str \tRLC_PREFIX(bn_size_str)\n#define bn_read_str \tRLC_PREFIX(bn_read_str)\n#define bn_write_str \tRLC_PREFIX(bn_write_str)\n#define bn_size_bin \tRLC_PREFIX(bn_size_bin)\n#define bn_read_bin \tRLC_PREFIX(bn_read_bin)\n#define bn_write_bin \tRLC_PREFIX(bn_write_bin)\n#define bn_size_raw \tRLC_PREFIX(bn_size_raw)\n#define bn_read_raw \tRLC_PREFIX(bn_read_raw)\n#define bn_write_raw \tRLC_PREFIX(bn_write_raw)\n#define bn_cmp_abs \tRLC_PREFIX(bn_cmp_abs)\n#define bn_cmp_dig \tRLC_PREFIX(bn_cmp_dig)\n#define bn_cmp \tRLC_PREFIX(bn_cmp)\n#define bn_add \tRLC_PREFIX(bn_add)\n#define bn_add_dig \tRLC_PREFIX(bn_add_dig)\n#define bn_sub \tRLC_PREFIX(bn_sub)\n#define bn_sub_dig \tRLC_PREFIX(bn_sub_dig)\n#define bn_mul_dig \tRLC_PREFIX(bn_mul_dig)\n#define bn_mul_basic \tRLC_PREFIX(bn_mul_basic)\n#define bn_mul_comba \tRLC_PREFIX(bn_mul_comba)\n#define bn_mul_karat \tRLC_PREFIX(bn_mul_karat)\n#define bn_sqr_basic \tRLC_PREFIX(bn_sqr_basic)\n#define bn_sqr_comba \tRLC_PREFIX(bn_sqr_comba)\n#define bn_sqr_karat \tRLC_PREFIX(bn_sqr_karat)\n#define bn_dbl \tRLC_PREFIX(bn_dbl)\n#define bn_hlv \tRLC_PREFIX(bn_hlv)\n#define bn_lsh \tRLC_PREFIX(bn_lsh)\n#define bn_rsh \tRLC_PREFIX(bn_rsh)\n#define bn_div \tRLC_PREFIX(bn_div)\n#define bn_div_rem \tRLC_PREFIX(bn_div_rem)\n#define bn_div_dig \tRLC_PREFIX(bn_div_dig)\n#define bn_div_rem_dig \tRLC_PREFIX(bn_div_rem_dig)\n#define bn_mod_inv \tRLC_PREFIX(bn_mod_inv)\n#define bn_mod_inv_sim \tRLC_PREFIX(bn_mod_inv_sim)\n#define bn_mod_2b \tRLC_PREFIX(bn_mod_2b)\n#define bn_mod_dig \tRLC_PREFIX(bn_mod_dig)\n#define bn_mod_basic \tRLC_PREFIX(bn_mod_basic)\n#define bn_mod_pre_barrt \tRLC_PREFIX(bn_mod_pre_barrt)\n#define bn_mod_barrt \tRLC_PREFIX(bn_mod_barrt)\n#define bn_mod_pre_monty \tRLC_PREFIX(bn_mod_pre_monty)\n#define bn_mod_monty_conv \tRLC_PREFIX(bn_mod_monty_conv)\n#define bn_mod_monty_back \tRLC_PREFIX(bn_mod_monty_back)\n#define bn_mod_monty_basic \tRLC_PREFIX(bn_mod_monty_basic)\n#define bn_mod_monty_comba \tRLC_PREFIX(bn_mod_monty_comba)\n#define bn_mod_pre_pmers \tRLC_PREFIX(bn_mod_pre_pmers)\n#define bn_mod_pmers \tRLC_PREFIX(bn_mod_pmers)\n#define bn_mxp_basic \tRLC_PREFIX(bn_mxp_basic)\n#define bn_mxp_slide \tRLC_PREFIX(bn_mxp_slide)\n#define bn_mxp_monty \tRLC_PREFIX(bn_mxp_monty)\n#define bn_mxp_dig \tRLC_PREFIX(bn_mxp_dig)\n#define bn_mxp_crt \tRLC_PREFIX(bn_mxp_crt)\n#define bn_srt \tRLC_PREFIX(bn_srt)\n#define bn_gcd_basic \tRLC_PREFIX(bn_gcd_basic)\n#define bn_gcd_lehme \tRLC_PREFIX(bn_gcd_lehme)\n#define bn_gcd_binar \tRLC_PREFIX(bn_gcd_binar)\n#define bn_gcd_dig \tRLC_PREFIX(bn_gcd_dig)\n#define bn_gcd_ext_basic \tRLC_PREFIX(bn_gcd_ext_basic)\n#define bn_gcd_ext_lehme \tRLC_PREFIX(bn_gcd_ext_lehme)\n#define bn_gcd_ext_binar \tRLC_PREFIX(bn_gcd_ext_binar)\n#define bn_gcd_ext_mid \tRLC_PREFIX(bn_gcd_ext_mid)\n#define bn_gcd_ext_dig \tRLC_PREFIX(bn_gcd_ext_dig)\n#define bn_lcm \tRLC_PREFIX(bn_lcm)\n#define bn_smb_leg \tRLC_PREFIX(bn_smb_leg)\n#define bn_smb_jac \tRLC_PREFIX(bn_smb_jac)\n#define bn_is_prime \tRLC_PREFIX(bn_is_prime)\n#define bn_is_prime_basic \tRLC_PREFIX(bn_is_prime_basic)\n#define bn_is_prime_rabin \tRLC_PREFIX(bn_is_prime_rabin)\n#define bn_is_prime_solov \tRLC_PREFIX(bn_is_prime_solov)\n#define bn_gen_prime_basic \tRLC_PREFIX(bn_gen_prime_basic)\n#define bn_gen_prime_safep \tRLC_PREFIX(bn_gen_prime_safep)\n#define bn_gen_prime_stron \tRLC_PREFIX(bn_gen_prime_stron)\n#define bn_gen_prime_factor \tRLC_PREFIX(bn_gen_prime_factor)\n#define bn_factor \tRLC_PREFIX(bn_factor)\n#define bn_is_factor \tRLC_PREFIX(bn_is_factor)\n#define bn_rec_win \tRLC_PREFIX(bn_rec_win)\n#define bn_rec_slw \tRLC_PREFIX(bn_rec_slw)\n#define bn_rec_naf \tRLC_PREFIX(bn_rec_naf)\n#define bn_rec_tnaf \tRLC_PREFIX(bn_rec_tnaf)\n#define bn_rec_rtnaf \tRLC_PREFIX(bn_rec_rtnaf)\n#define bn_rec_tnaf_get \tRLC_PREFIX(bn_rec_tnaf_get)\n#define bn_rec_tnaf_mod \tRLC_PREFIX(bn_rec_tnaf_mod)\n#define bn_rec_reg \tRLC_PREFIX(bn_rec_reg)\n#define bn_rec_jsf \tRLC_PREFIX(bn_rec_jsf)\n#define bn_rec_glv \tRLC_PREFIX(bn_rec_glv)\n#define bn_rec_frb \tRLC_PREFIX(bn_rec_frb)\n#define bn_lag \tRLC_PREFIX(bn_lag)\n#define bn_evl \tRLC_PREFIX(bn_evl)\n\n#undef bn_add1_low\n#undef bn_addn_low\n#undef bn_sub1_low\n#undef bn_subn_low\n#undef bn_cmp1_low\n#undef bn_cmpn_low\n#undef bn_lsh1_low\n#undef bn_lshb_low\n#undef bn_rsh1_low\n#undef bn_rshb_low\n#undef bn_rshs_low\n#undef bn_mula_low\n#undef bn_mul1_low\n#undef bn_muls_low\n#undef bn_muln_low\n#undef bn_muld_low\n#undef bn_sqra_low\n#undef bn_sqrn_low\n#undef bn_divn_low\n#undef bn_div1_low\n#undef bn_modn_low\n\n#define bn_add1_low \tRLC_PREFIX(bn_add1_low)\n#define bn_addn_low \tRLC_PREFIX(bn_addn_low)\n#define bn_sub1_low \tRLC_PREFIX(bn_sub1_low)\n#define bn_subn_low \tRLC_PREFIX(bn_subn_low)\n#define bn_cmp1_low \tRLC_PREFIX(bn_cmp1_low)\n#define bn_cmpn_low \tRLC_PREFIX(bn_cmpn_low)\n#define bn_lsh1_low \tRLC_PREFIX(bn_lsh1_low)\n#define bn_lshb_low \tRLC_PREFIX(bn_lshb_low)\n#define bn_rsh1_low \tRLC_PREFIX(bn_rsh1_low)\n#define bn_rshb_low \tRLC_PREFIX(bn_rshb_low)\n#define bn_rshs_low \tRLC_PREFIX(bn_rshs_low)\n#define bn_mula_low \tRLC_PREFIX(bn_mula_low)\n#define bn_mul1_low \tRLC_PREFIX(bn_mul1_low)\n#define bn_muls_low \tRLC_PREFIX(bn_muls_low)\n#define bn_muln_low \tRLC_PREFIX(bn_muln_low)\n#define bn_muld_low \tRLC_PREFIX(bn_muld_low)\n#define bn_sqra_low \tRLC_PREFIX(bn_sqra_low)\n#define bn_sqrn_low \tRLC_PREFIX(bn_sqrn_low)\n#define bn_divn_low \tRLC_PREFIX(bn_divn_low)\n#define bn_div1_low \tRLC_PREFIX(bn_div1_low)\n#define bn_modn_low \tRLC_PREFIX(bn_modn_low)\n\n#undef fp_st\n#undef fp_t\n#define fp_st\t        RLC_PREFIX(fp_st)\n#define fp_t          RLC_PREFIX(fp_t)\n\n#undef fp_prime_init\n#undef fp_prime_clean\n#undef fp_prime_get\n#undef fp_prime_get_rdc\n#undef fp_prime_get_conv\n#undef fp_prime_get_mod8\n#undef fp_prime_get_sps\n#undef fp_prime_get_qnr\n#undef fp_prime_get_cnr\n#undef fp_prime_get_2ad\n#undef fp_param_get\n#undef fp_prime_set_dense\n#undef fp_prime_set_pmers\n#undef fp_prime_set_pairf\n#undef fp_prime_calc\n#undef fp_prime_conv\n#undef fp_prime_conv_dig\n#undef fp_prime_back\n#undef fp_param_set\n#undef fp_param_set_any\n#undef fp_param_set_any_dense\n#undef fp_param_set_any_pmers\n#undef fp_param_set_any_tower\n#undef fp_param_set_any_h2adc\n#undef fp_param_print\n#undef fp_prime_get_par\n#undef fp_prime_get_par_sps\n#undef fp_param_get_sps\n#undef fp_copy\n#undef fp_zero\n#undef fp_is_zero\n#undef fp_is_even\n#undef fp_get_bit\n#undef fp_set_bit\n#undef fp_set_dig\n#undef fp_bits\n#undef fp_rand\n#undef fp_print\n#undef fp_size_str\n#undef fp_read_str\n#undef fp_write_str\n#undef fp_read_bin\n#undef fp_write_bin\n#undef fp_cmp\n#undef fp_cmp_dig\n#undef fp_add_basic\n#undef fp_add_integ\n#undef fp_add_dig\n#undef fp_sub_basic\n#undef fp_sub_integ\n#undef fp_sub_dig\n#undef fp_neg_basic\n#undef fp_neg_integ\n#undef fp_dbl_basic\n#undef fp_dbl_integ\n#undef fp_hlv_basic\n#undef fp_hlv_integ\n#undef fp_mul_basic\n#undef fp_mul_comba\n#undef fp_mul_integ\n#undef fp_mul_karat\n#undef fp_mul_dig\n#undef fp_sqr_basic\n#undef fp_sqr_comba\n#undef fp_sqr_integ\n#undef fp_sqr_karat\n#undef fp_lsh\n#undef fp_rsh\n#undef fp_rdc_basic\n#undef fp_rdc_monty_basic\n#undef fp_rdc_monty_comba\n#undef fp_rdc_quick\n#undef fp_inv_basic\n#undef fp_inv_binar\n#undef fp_inv_monty\n#undef fp_inv_exgcd\n#undef fp_inv_divst\n#undef fp_inv_jmpds\n#undef fp_inv_lower\n#undef fp_inv_sim\n#undef fp_smb_basic\n#undef fp_smb_binar\n#undef fp_smb_divst\n#undef fp_smb_jmpds\n#undef fp_smb_lower\n#undef fp_exp_basic\n#undef fp_exp_slide\n#undef fp_exp_monty\n#undef fp_srt\n\n#define fp_prime_init \tRLC_PREFIX(fp_prime_init)\n#define fp_prime_clean \tRLC_PREFIX(fp_prime_clean)\n#define fp_prime_get \tRLC_PREFIX(fp_prime_get)\n#define fp_prime_get_rdc \tRLC_PREFIX(fp_prime_get_rdc)\n#define fp_prime_get_conv \tRLC_PREFIX(fp_prime_get_conv)\n#define fp_prime_get_mod8 \tRLC_PREFIX(fp_prime_get_mod8)\n#define fp_prime_get_sps \tRLC_PREFIX(fp_prime_get_sps)\n#define fp_prime_get_qnr \tRLC_PREFIX(fp_prime_get_qnr)\n#define fp_prime_get_cnr \tRLC_PREFIX(fp_prime_get_cnr)\n#define fp_prime_get_2ad \tRLC_PREFIX(fp_prime_get_2ad)\n#define fp_param_get \tRLC_PREFIX(fp_param_get)\n#define fp_prime_set_dense \tRLC_PREFIX(fp_prime_set_dense)\n#define fp_prime_set_pmers \tRLC_PREFIX(fp_prime_set_pmers)\n#define fp_prime_set_pairf \tRLC_PREFIX(fp_prime_set_pairf)\n#define fp_prime_calc \tRLC_PREFIX(fp_prime_calc)\n#define fp_prime_conv \tRLC_PREFIX(fp_prime_conv)\n#define fp_prime_conv_dig \tRLC_PREFIX(fp_prime_conv_dig)\n#define fp_prime_back \tRLC_PREFIX(fp_prime_back)\n#define fp_param_set \tRLC_PREFIX(fp_param_set)\n#define fp_param_set_any \tRLC_PREFIX(fp_param_set_any)\n#define fp_param_set_any_dense \tRLC_PREFIX(fp_param_set_any_dense)\n#define fp_param_set_any_pmers \tRLC_PREFIX(fp_param_set_any_pmers)\n#define fp_param_set_any_tower \tRLC_PREFIX(fp_param_set_any_tower)\n#define fp_param_set_any_h2adc \tRLC_PREFIX(fp_param_set_any_h2adc)\n#define fp_param_print \tRLC_PREFIX(fp_param_print)\n#define fp_prime_get_par \tRLC_PREFIX(fp_prime_get_par)\n#define fp_prime_get_par_sps \tRLC_PREFIX(fp_prime_get_par_sps)\n#define fp_param_get_sps \tRLC_PREFIX(fp_param_get_sps)\n#define fp_copy \tRLC_PREFIX(fp_copy)\n#define fp_zero \tRLC_PREFIX(fp_zero)\n#define fp_is_zero \tRLC_PREFIX(fp_is_zero)\n#define fp_is_even \tRLC_PREFIX(fp_is_even)\n#define fp_get_bit \tRLC_PREFIX(fp_get_bit)\n#define fp_set_bit \tRLC_PREFIX(fp_set_bit)\n#define fp_set_dig \tRLC_PREFIX(fp_set_dig)\n#define fp_bits \tRLC_PREFIX(fp_bits)\n#define fp_rand \tRLC_PREFIX(fp_rand)\n#define fp_print \tRLC_PREFIX(fp_print)\n#define fp_size_str \tRLC_PREFIX(fp_size_str)\n#define fp_read_str \tRLC_PREFIX(fp_read_str)\n#define fp_write_str \tRLC_PREFIX(fp_write_str)\n#define fp_read_bin \tRLC_PREFIX(fp_read_bin)\n#define fp_write_bin \tRLC_PREFIX(fp_write_bin)\n#define fp_cmp \tRLC_PREFIX(fp_cmp)\n#define fp_cmp_dig \tRLC_PREFIX(fp_cmp_dig)\n#define fp_add_basic \tRLC_PREFIX(fp_add_basic)\n#define fp_add_integ \tRLC_PREFIX(fp_add_integ)\n#define fp_add_dig \tRLC_PREFIX(fp_add_dig)\n#define fp_sub_basic \tRLC_PREFIX(fp_sub_basic)\n#define fp_sub_integ \tRLC_PREFIX(fp_sub_integ)\n#define fp_sub_dig \tRLC_PREFIX(fp_sub_dig)\n#define fp_neg_basic \tRLC_PREFIX(fp_neg_basic)\n#define fp_neg_integ \tRLC_PREFIX(fp_neg_integ)\n#define fp_dbl_basic \tRLC_PREFIX(fp_dbl_basic)\n#define fp_dbl_integ \tRLC_PREFIX(fp_dbl_integ)\n#define fp_hlv_basic \tRLC_PREFIX(fp_hlv_basic)\n#define fp_hlv_integ \tRLC_PREFIX(fp_hlv_integ)\n#define fp_mul_basic \tRLC_PREFIX(fp_mul_basic)\n#define fp_mul_comba \tRLC_PREFIX(fp_mul_comba)\n#define fp_mul_integ \tRLC_PREFIX(fp_mul_integ)\n#define fp_mul_karat \tRLC_PREFIX(fp_mul_karat)\n#define fp_mul_dig \tRLC_PREFIX(fp_mul_dig)\n#define fp_sqr_basic \tRLC_PREFIX(fp_sqr_basic)\n#define fp_sqr_comba \tRLC_PREFIX(fp_sqr_comba)\n#define fp_sqr_integ \tRLC_PREFIX(fp_sqr_integ)\n#define fp_sqr_karat \tRLC_PREFIX(fp_sqr_karat)\n#define fp_lsh \tRLC_PREFIX(fp_lsh)\n#define fp_rsh \tRLC_PREFIX(fp_rsh)\n#define fp_rdc_basic \tRLC_PREFIX(fp_rdc_basic)\n#define fp_rdc_monty_basic \tRLC_PREFIX(fp_rdc_monty_basic)\n#define fp_rdc_monty_comba \tRLC_PREFIX(fp_rdc_monty_comba)\n#define fp_rdc_quick \tRLC_PREFIX(fp_rdc_quick)\n#define fp_inv_basic \tRLC_PREFIX(fp_inv_basic)\n#define fp_inv_binar \tRLC_PREFIX(fp_inv_binar)\n#define fp_inv_monty \tRLC_PREFIX(fp_inv_monty)\n#define fp_inv_exgcd \tRLC_PREFIX(fp_inv_exgcd)\n#define fp_inv_divst \tRLC_PREFIX(fp_inv_divst)\n#define fp_inv_jmpds \tRLC_PREFIX(fp_inv_jmpds)\n#define fp_inv_lower \tRLC_PREFIX(fp_inv_lower)\n#define fp_inv_sim \tRLC_PREFIX(fp_inv_sim)\n#define fp_smb_basic \tRLC_PREFIX(fp_smb_basic)\n#define fp_smb_binar \tRLC_PREFIX(fp_smb_binar)\n#define fp_smb_divst \tRLC_PREFIX(fp_smb_divst)\n#define fp_smb_jmpds \tRLC_PREFIX(fp_smb_jmpds)\n#define fp_smb_lower \tRLC_PREFIX(fp_smb_lower)\n#define fp_exp_basic \tRLC_PREFIX(fp_exp_basic)\n#define fp_exp_slide \tRLC_PREFIX(fp_exp_slide)\n#define fp_exp_monty \tRLC_PREFIX(fp_exp_monty)\n#define fp_srt \tRLC_PREFIX(fp_srt)\n\n#undef fp_add1_low\n#undef fp_addn_low\n#undef fp_addm_low\n#undef fp_addd_low\n#undef fp_addc_low\n#undef fp_sub1_low\n#undef fp_subn_low\n#undef fp_subm_low\n#undef fp_subd_low\n#undef fp_subc_low\n#undef fp_negm_low\n#undef fp_dbln_low\n#undef fp_dblm_low\n#undef fp_hlvm_low\n#undef fp_hlvd_low\n#undef fp_lsh1_low\n#undef fp_lshb_low\n#undef fp_rsh1_low\n#undef fp_rshb_low\n#undef fp_mula_low\n#undef fp_mul1_low\n#undef fp_muln_low\n#undef fp_mulm_low\n#undef fp_sqrn_low\n#undef fp_sqrm_low\n#undef fp_rdcs_low\n#undef fp_rdcn_low\n#undef fp_invm_low\n#undef fp_smbm_low\n\n#define fp_add1_low \tRLC_PREFIX(fp_add1_low)\n#define fp_addn_low \tRLC_PREFIX(fp_addn_low)\n#define fp_addm_low \tRLC_PREFIX(fp_addm_low)\n#define fp_addd_low \tRLC_PREFIX(fp_addd_low)\n#define fp_addc_low \tRLC_PREFIX(fp_addc_low)\n#define fp_sub1_low \tRLC_PREFIX(fp_sub1_low)\n#define fp_subn_low \tRLC_PREFIX(fp_subn_low)\n#define fp_subm_low \tRLC_PREFIX(fp_subm_low)\n#define fp_subd_low \tRLC_PREFIX(fp_subd_low)\n#define fp_subc_low \tRLC_PREFIX(fp_subc_low)\n#define fp_negm_low \tRLC_PREFIX(fp_negm_low)\n#define fp_dbln_low \tRLC_PREFIX(fp_dbln_low)\n#define fp_dblm_low \tRLC_PREFIX(fp_dblm_low)\n#define fp_hlvm_low \tRLC_PREFIX(fp_hlvm_low)\n#define fp_hlvd_low \tRLC_PREFIX(fp_hlvd_low)\n#define fp_lsh1_low \tRLC_PREFIX(fp_lsh1_low)\n#define fp_lshb_low \tRLC_PREFIX(fp_lshb_low)\n#define fp_rsh1_low \tRLC_PREFIX(fp_rsh1_low)\n#define fp_rshb_low \tRLC_PREFIX(fp_rshb_low)\n#define fp_mula_low \tRLC_PREFIX(fp_mula_low)\n#define fp_mul1_low \tRLC_PREFIX(fp_mul1_low)\n#define fp_muln_low \tRLC_PREFIX(fp_muln_low)\n#define fp_mulm_low \tRLC_PREFIX(fp_mulm_low)\n#define fp_sqrn_low \tRLC_PREFIX(fp_sqrn_low)\n#define fp_sqrm_low \tRLC_PREFIX(fp_sqrm_low)\n#define fp_rdcs_low \tRLC_PREFIX(fp_rdcs_low)\n#define fp_rdcn_low \tRLC_PREFIX(fp_rdcn_low)\n#define fp_invm_low \tRLC_PREFIX(fp_invm_low)\n#define fp_smbm_low \tRLC_PREFIX(fp_smbm_low)\n\n#undef fp_st\n#undef fp_t\n#define fp_st\t        RLC_PREFIX(fp_st)\n#define fp_t          RLC_PREFIX(fp_t)\n\n#undef fb_poly_init\n#undef fb_poly_clean\n#undef fb_poly_get\n#undef fb_poly_set_dense\n#undef fb_poly_set_trino\n#undef fb_poly_set_penta\n#undef fb_poly_get_srz\n#undef fb_poly_tab_srz\n#undef fb_poly_tab_sqr\n#undef fb_poly_get_chain\n#undef fb_poly_get_rdc\n#undef fb_poly_get_trc\n#undef fb_poly_get_slv\n#undef fb_param_set\n#undef fb_param_set_any\n#undef fb_param_print\n#undef fb_poly_add\n#undef fb_copy\n#undef fb_neg\n#undef fb_zero\n#undef fb_is_zero\n#undef fb_get_bit\n#undef fb_set_bit\n#undef fb_set_dig\n#undef fb_bits\n#undef fb_rand\n#undef fb_print\n#undef fb_size_str\n#undef fb_read_str\n#undef fb_write_str\n#undef fb_read_bin\n#undef fb_write_bin\n#undef fb_cmp\n#undef fb_cmp_dig\n#undef fb_add\n#undef fb_add_dig\n#undef fb_mul_basic\n#undef fb_mul_integ\n#undef fb_mul_lodah\n#undef fb_mul_dig\n#undef fb_mul_karat\n#undef fb_sqr_basic\n#undef fb_sqr_integ\n#undef fb_sqr_quick\n#undef fb_lsh\n#undef fb_rsh\n#undef fb_rdc_basic\n#undef fb_rdc_quick\n#undef fb_srt_basic\n#undef fb_srt_quick\n#undef fb_trc_basic\n#undef fb_trc_quick\n#undef fb_inv_basic\n#undef fb_inv_binar\n#undef fb_inv_exgcd\n#undef fb_inv_almos\n#undef fb_inv_itoht\n#undef fb_inv_bruch\n#undef fb_inv_ctaia\n#undef fb_inv_lower\n#undef fb_inv_sim\n#undef fb_exp_2b\n#undef fb_exp_basic\n#undef fb_exp_slide\n#undef fb_exp_monty\n#undef fb_slv_basic\n#undef fb_slv_quick\n#undef fb_itr_basic\n#undef fb_itr_pre_quick\n#undef fb_itr_quick\n\n#define fb_poly_init \tRLC_PREFIX(fb_poly_init)\n#define fb_poly_clean \tRLC_PREFIX(fb_poly_clean)\n#define fb_poly_get \tRLC_PREFIX(fb_poly_get)\n#define fb_poly_set_dense \tRLC_PREFIX(fb_poly_set_dense)\n#define fb_poly_set_trino \tRLC_PREFIX(fb_poly_set_trino)\n#define fb_poly_set_penta \tRLC_PREFIX(fb_poly_set_penta)\n#define fb_poly_get_srz \tRLC_PREFIX(fb_poly_get_srz)\n#define fb_poly_tab_srz \tRLC_PREFIX(fb_poly_tab_srz)\n#define fb_poly_tab_sqr \tRLC_PREFIX(fb_poly_tab_sqr)\n#define fb_poly_get_chain \tRLC_PREFIX(fb_poly_get_chain)\n#define fb_poly_get_rdc \tRLC_PREFIX(fb_poly_get_rdc)\n#define fb_poly_get_trc \tRLC_PREFIX(fb_poly_get_trc)\n#define fb_poly_get_slv \tRLC_PREFIX(fb_poly_get_slv)\n#define fb_param_set \tRLC_PREFIX(fb_param_set)\n#define fb_param_set_any \tRLC_PREFIX(fb_param_set_any)\n#define fb_param_print \tRLC_PREFIX(fb_param_print)\n#define fb_poly_add \tRLC_PREFIX(fb_poly_add)\n#define fb_copy \tRLC_PREFIX(fb_copy)\n#define fb_neg \tRLC_PREFIX(fb_neg)\n#define fb_zero \tRLC_PREFIX(fb_zero)\n#define fb_is_zero \tRLC_PREFIX(fb_is_zero)\n#define fb_get_bit \tRLC_PREFIX(fb_get_bit)\n#define fb_set_bit \tRLC_PREFIX(fb_set_bit)\n#define fb_set_dig \tRLC_PREFIX(fb_set_dig)\n#define fb_bits \tRLC_PREFIX(fb_bits)\n#define fb_rand \tRLC_PREFIX(fb_rand)\n#define fb_print \tRLC_PREFIX(fb_print)\n#define fb_size_str \tRLC_PREFIX(fb_size_str)\n#define fb_read_str \tRLC_PREFIX(fb_read_str)\n#define fb_write_str \tRLC_PREFIX(fb_write_str)\n#define fb_read_bin \tRLC_PREFIX(fb_read_bin)\n#define fb_write_bin \tRLC_PREFIX(fb_write_bin)\n#define fb_cmp \tRLC_PREFIX(fb_cmp)\n#define fb_cmp_dig \tRLC_PREFIX(fb_cmp_dig)\n#define fb_add \tRLC_PREFIX(fb_add)\n#define fb_add_dig \tRLC_PREFIX(fb_add_dig)\n#define fb_mul_basic \tRLC_PREFIX(fb_mul_basic)\n#define fb_mul_integ \tRLC_PREFIX(fb_mul_integ)\n#define fb_mul_lodah \tRLC_PREFIX(fb_mul_lodah)\n#define fb_mul_dig \tRLC_PREFIX(fb_mul_dig)\n#define fb_mul_karat \tRLC_PREFIX(fb_mul_karat)\n#define fb_sqr_basic \tRLC_PREFIX(fb_sqr_basic)\n#define fb_sqr_integ \tRLC_PREFIX(fb_sqr_integ)\n#define fb_sqr_quick \tRLC_PREFIX(fb_sqr_quick)\n#define fb_lsh \tRLC_PREFIX(fb_lsh)\n#define fb_rsh \tRLC_PREFIX(fb_rsh)\n#define fb_rdc_basic \tRLC_PREFIX(fb_rdc_basic)\n#define fb_rdc_quick \tRLC_PREFIX(fb_rdc_quick)\n#define fb_srt_basic \tRLC_PREFIX(fb_srt_basic)\n#define fb_srt_quick \tRLC_PREFIX(fb_srt_quick)\n#define fb_trc_basic \tRLC_PREFIX(fb_trc_basic)\n#define fb_trc_quick \tRLC_PREFIX(fb_trc_quick)\n#define fb_inv_basic \tRLC_PREFIX(fb_inv_basic)\n#define fb_inv_binar \tRLC_PREFIX(fb_inv_binar)\n#define fb_inv_exgcd \tRLC_PREFIX(fb_inv_exgcd)\n#define fb_inv_almos \tRLC_PREFIX(fb_inv_almos)\n#define fb_inv_itoht \tRLC_PREFIX(fb_inv_itoht)\n#define fb_inv_bruch \tRLC_PREFIX(fb_inv_bruch)\n#define fb_inv_ctaia \tRLC_PREFIX(fb_inv_ctaia)\n#define fb_inv_lower \tRLC_PREFIX(fb_inv_lower)\n#define fb_inv_sim \tRLC_PREFIX(fb_inv_sim)\n#define fb_exp_2b \tRLC_PREFIX(fb_exp_2b)\n#define fb_exp_basic \tRLC_PREFIX(fb_exp_basic)\n#define fb_exp_slide \tRLC_PREFIX(fb_exp_slide)\n#define fb_exp_monty \tRLC_PREFIX(fb_exp_monty)\n#define fb_slv_basic \tRLC_PREFIX(fb_slv_basic)\n#define fb_slv_quick \tRLC_PREFIX(fb_slv_quick)\n#define fb_itr_basic \tRLC_PREFIX(fb_itr_basic)\n#define fb_itr_pre_quick \tRLC_PREFIX(fb_itr_pre_quick)\n#define fb_itr_quick \tRLC_PREFIX(fb_itr_quick)\n\n#undef fb_add1_low\n#undef fb_addn_low\n#undef fb_addd_low\n#undef fb_lsh1_low\n#undef fb_lshb_low\n#undef fb_rsh1_low\n#undef fb_rshb_low\n#undef fb_lsha_low\n#undef fb_mul1_low\n#undef fb_muln_low\n#undef fb_muld_low\n#undef fb_mulm_low\n#undef fb_sqrn_low\n#undef fb_sqrl_low\n#undef fb_sqrm_low\n#undef fb_itrn_low\n#undef fb_srtn_low\n#undef fb_slvn_low\n#undef fb_trcn_low\n#undef fb_rdcn_low\n#undef fb_rdc1_low\n#undef fb_invn_low\n\n#define fb_add1_low \tRLC_PREFIX(fb_add1_low)\n#define fb_addn_low \tRLC_PREFIX(fb_addn_low)\n#define fb_addd_low \tRLC_PREFIX(fb_addd_low)\n#define fb_lsh1_low \tRLC_PREFIX(fb_lsh1_low)\n#define fb_lshb_low \tRLC_PREFIX(fb_lshb_low)\n#define fb_rsh1_low \tRLC_PREFIX(fb_rsh1_low)\n#define fb_rshb_low \tRLC_PREFIX(fb_rshb_low)\n#define fb_lsha_low \tRLC_PREFIX(fb_lsha_low)\n#define fb_mul1_low \tRLC_PREFIX(fb_mul1_low)\n#define fb_muln_low \tRLC_PREFIX(fb_muln_low)\n#define fb_muld_low \tRLC_PREFIX(fb_muld_low)\n#define fb_mulm_low \tRLC_PREFIX(fb_mulm_low)\n#define fb_sqrn_low \tRLC_PREFIX(fb_sqrn_low)\n#define fb_sqrl_low \tRLC_PREFIX(fb_sqrl_low)\n#define fb_sqrm_low \tRLC_PREFIX(fb_sqrm_low)\n#define fb_itrn_low \tRLC_PREFIX(fb_itrn_low)\n#define fb_srtn_low \tRLC_PREFIX(fb_srtn_low)\n#define fb_slvn_low \tRLC_PREFIX(fb_slvn_low)\n#define fb_trcn_low \tRLC_PREFIX(fb_trcn_low)\n#define fb_rdcn_low \tRLC_PREFIX(fb_rdcn_low)\n#define fb_rdc1_low \tRLC_PREFIX(fb_rdc1_low)\n#define fb_invn_low \tRLC_PREFIX(fb_invn_low)\n\n#undef ep_st\n#undef ep_t\n#define ep_st         RLC_PREFIX(ep_st)\n#define ep_t          RLC_PREFIX(ep_t)\n\n#undef ep_curve_init\n#undef ep_curve_clean\n#undef ep_curve_get_a\n#undef ep_curve_get_b\n#undef ep_curve_get_b3\n#undef ep_curve_get_beta\n#undef ep_curve_get_v1\n#undef ep_curve_get_v2\n#undef ep_curve_opt_a\n#undef ep_curve_opt_b\n#undef ep_curve_opt_b3\n#undef ep_curve_mul_a\n#undef ep_curve_mul_b\n#undef ep_curve_mul_b3\n#undef ep_curve_is_endom\n#undef ep_curve_is_super\n#undef ep_curve_is_pairf\n#undef ep_curve_is_ctmap\n#undef ep_curve_get_gen\n#undef ep_curve_get_tab\n#undef ep_curve_get_ord\n#undef ep_curve_get_cof\n#undef ep_curve_get_iso\n#undef ep_curve_set_plain\n#undef ep_curve_set_super\n#undef ep_curve_set_endom\n#undef ep_param_set\n#undef ep_param_set_any\n#undef ep_param_set_any_plain\n#undef ep_param_set_any_endom\n#undef ep_param_set_any_super\n#undef ep_param_set_any_pairf\n#undef ep_param_get\n#undef ep_param_print\n#undef ep_param_level\n#undef ep_param_embed\n#undef ep_is_infty\n#undef ep_set_infty\n#undef ep_copy\n#undef ep_cmp\n#undef ep_rand\n#undef ep_blind\n#undef ep_rhs\n#undef ep_on_curve\n#undef ep_tab\n#undef ep_print\n#undef ep_size_bin\n#undef ep_read_bin\n#undef ep_write_bin\n#undef ep_neg\n#undef ep_add_basic\n#undef ep_add_slp_basic\n#undef ep_add_projc\n#undef ep_add_jacob\n#undef ep_sub\n#undef ep_dbl_basic\n#undef ep_dbl_slp_basic\n#undef ep_dbl_projc\n#undef ep_dbl_jacob\n#undef ep_psi\n#undef ep_mul_basic\n#undef ep_mul_slide\n#undef ep_mul_monty\n#undef ep_mul_lwnaf\n#undef ep_mul_lwreg\n#undef ep_mul_gen\n#undef ep_mul_dig\n#undef ep_mul_pre_basic\n#undef ep_mul_pre_yaowi\n#undef ep_mul_pre_nafwi\n#undef ep_mul_pre_combs\n#undef ep_mul_pre_combd\n#undef ep_mul_pre_lwnaf\n#undef ep_mul_fix_basic\n#undef ep_mul_fix_yaowi\n#undef ep_mul_fix_nafwi\n#undef ep_mul_fix_combs\n#undef ep_mul_fix_combd\n#undef ep_mul_fix_lwnaf\n#undef ep_mul_sim_basic\n#undef ep_mul_sim_trick\n#undef ep_mul_sim_inter\n#undef ep_mul_sim_joint\n#undef ep_mul_sim_lot\n#undef ep_mul_sim_gen\n#undef ep_mul_sim_dig\n#undef ep_norm\n#undef ep_norm_sim\n#undef ep_map_from_field\n#undef ep_map\n#undef ep_map_dst\n#undef ep_pck\n#undef ep_upk\n\n#define ep_curve_init \tRLC_PREFIX(ep_curve_init)\n#define ep_curve_clean \tRLC_PREFIX(ep_curve_clean)\n#define ep_curve_get_a \tRLC_PREFIX(ep_curve_get_a)\n#define ep_curve_get_b \tRLC_PREFIX(ep_curve_get_b)\n#define ep_curve_get_b3 \tRLC_PREFIX(ep_curve_get_b3)\n#define ep_curve_get_beta \tRLC_PREFIX(ep_curve_get_beta)\n#define ep_curve_get_v1 \tRLC_PREFIX(ep_curve_get_v1)\n#define ep_curve_get_v2 \tRLC_PREFIX(ep_curve_get_v2)\n#define ep_curve_opt_a \tRLC_PREFIX(ep_curve_opt_a)\n#define ep_curve_opt_b \tRLC_PREFIX(ep_curve_opt_b)\n#define ep_curve_opt_b3 \tRLC_PREFIX(ep_curve_opt_b3)\n#define ep_curve_mul_a \tRLC_PREFIX(ep_curve_mul_a)\n#define ep_curve_mul_b \tRLC_PREFIX(ep_curve_mul_b)\n#define ep_curve_mul_b3 \tRLC_PREFIX(ep_curve_mul_b3)\n#define ep_curve_is_endom \tRLC_PREFIX(ep_curve_is_endom)\n#define ep_curve_is_super \tRLC_PREFIX(ep_curve_is_super)\n#define ep_curve_is_pairf \tRLC_PREFIX(ep_curve_is_pairf)\n#define ep_curve_is_ctmap \tRLC_PREFIX(ep_curve_is_ctmap)\n#define ep_curve_get_gen \tRLC_PREFIX(ep_curve_get_gen)\n#define ep_curve_get_tab \tRLC_PREFIX(ep_curve_get_tab)\n#define ep_curve_get_ord \tRLC_PREFIX(ep_curve_get_ord)\n#define ep_curve_get_cof \tRLC_PREFIX(ep_curve_get_cof)\n#define ep_curve_get_iso \tRLC_PREFIX(ep_curve_get_iso)\n#define ep_curve_set_plain \tRLC_PREFIX(ep_curve_set_plain)\n#define ep_curve_set_super \tRLC_PREFIX(ep_curve_set_super)\n#define ep_curve_set_endom \tRLC_PREFIX(ep_curve_set_endom)\n#define ep_param_set \tRLC_PREFIX(ep_param_set)\n#define ep_param_set_any \tRLC_PREFIX(ep_param_set_any)\n#define ep_param_set_any_plain \tRLC_PREFIX(ep_param_set_any_plain)\n#define ep_param_set_any_endom \tRLC_PREFIX(ep_param_set_any_endom)\n#define ep_param_set_any_super \tRLC_PREFIX(ep_param_set_any_super)\n#define ep_param_set_any_pairf \tRLC_PREFIX(ep_param_set_any_pairf)\n#define ep_param_get \tRLC_PREFIX(ep_param_get)\n#define ep_param_print \tRLC_PREFIX(ep_param_print)\n#define ep_param_level \tRLC_PREFIX(ep_param_level)\n#define ep_param_embed \tRLC_PREFIX(ep_param_embed)\n#define ep_is_infty \tRLC_PREFIX(ep_is_infty)\n#define ep_set_infty \tRLC_PREFIX(ep_set_infty)\n#define ep_copy \tRLC_PREFIX(ep_copy)\n#define ep_cmp \tRLC_PREFIX(ep_cmp)\n#define ep_rand \tRLC_PREFIX(ep_rand)\n#define ep_blind \tRLC_PREFIX(ep_blind)\n#define ep_rhs \tRLC_PREFIX(ep_rhs)\n#define ep_on_curve \tRLC_PREFIX(ep_on_curve)\n#define ep_tab \tRLC_PREFIX(ep_tab)\n#define ep_print \tRLC_PREFIX(ep_print)\n#define ep_size_bin \tRLC_PREFIX(ep_size_bin)\n#define ep_read_bin \tRLC_PREFIX(ep_read_bin)\n#define ep_write_bin \tRLC_PREFIX(ep_write_bin)\n#define ep_neg \tRLC_PREFIX(ep_neg)\n#define ep_add_basic \tRLC_PREFIX(ep_add_basic)\n#define ep_add_slp_basic \tRLC_PREFIX(ep_add_slp_basic)\n#define ep_add_projc \tRLC_PREFIX(ep_add_projc)\n#define ep_add_jacob \tRLC_PREFIX(ep_add_jacob)\n#define ep_sub \tRLC_PREFIX(ep_sub)\n#define ep_dbl_basic \tRLC_PREFIX(ep_dbl_basic)\n#define ep_dbl_slp_basic \tRLC_PREFIX(ep_dbl_slp_basic)\n#define ep_dbl_projc \tRLC_PREFIX(ep_dbl_projc)\n#define ep_dbl_jacob \tRLC_PREFIX(ep_dbl_jacob)\n#define ep_psi \tRLC_PREFIX(ep_psi)\n#define ep_mul_basic \tRLC_PREFIX(ep_mul_basic)\n#define ep_mul_slide \tRLC_PREFIX(ep_mul_slide)\n#define ep_mul_monty \tRLC_PREFIX(ep_mul_monty)\n#define ep_mul_lwnaf \tRLC_PREFIX(ep_mul_lwnaf)\n#define ep_mul_lwreg \tRLC_PREFIX(ep_mul_lwreg)\n#define ep_mul_gen \tRLC_PREFIX(ep_mul_gen)\n#define ep_mul_dig \tRLC_PREFIX(ep_mul_dig)\n#define ep_mul_pre_basic \tRLC_PREFIX(ep_mul_pre_basic)\n#define ep_mul_pre_yaowi \tRLC_PREFIX(ep_mul_pre_yaowi)\n#define ep_mul_pre_nafwi \tRLC_PREFIX(ep_mul_pre_nafwi)\n#define ep_mul_pre_combs \tRLC_PREFIX(ep_mul_pre_combs)\n#define ep_mul_pre_combd \tRLC_PREFIX(ep_mul_pre_combd)\n#define ep_mul_pre_lwnaf \tRLC_PREFIX(ep_mul_pre_lwnaf)\n#define ep_mul_fix_basic \tRLC_PREFIX(ep_mul_fix_basic)\n#define ep_mul_fix_yaowi \tRLC_PREFIX(ep_mul_fix_yaowi)\n#define ep_mul_fix_nafwi \tRLC_PREFIX(ep_mul_fix_nafwi)\n#define ep_mul_fix_combs \tRLC_PREFIX(ep_mul_fix_combs)\n#define ep_mul_fix_combd \tRLC_PREFIX(ep_mul_fix_combd)\n#define ep_mul_fix_lwnaf \tRLC_PREFIX(ep_mul_fix_lwnaf)\n#define ep_mul_sim_basic \tRLC_PREFIX(ep_mul_sim_basic)\n#define ep_mul_sim_trick \tRLC_PREFIX(ep_mul_sim_trick)\n#define ep_mul_sim_inter \tRLC_PREFIX(ep_mul_sim_inter)\n#define ep_mul_sim_joint \tRLC_PREFIX(ep_mul_sim_joint)\n#define ep_mul_sim_lot \tRLC_PREFIX(ep_mul_sim_lot)\n#define ep_mul_sim_gen \tRLC_PREFIX(ep_mul_sim_gen)\n#define ep_mul_sim_dig \tRLC_PREFIX(ep_mul_sim_dig)\n#define ep_norm \tRLC_PREFIX(ep_norm)\n#define ep_norm_sim \tRLC_PREFIX(ep_norm_sim)\n#define ep_map_from_field \tRLC_PREFIX(ep_map_from_field)\n#define ep_map \tRLC_PREFIX(ep_map)\n#define ep_map_dst \tRLC_PREFIX(ep_map_dst)\n#define ep_pck \tRLC_PREFIX(ep_pck)\n#define ep_upk \tRLC_PREFIX(ep_upk)\n\n#undef ed_st\n#undef ed_t\n#define ed_st         RLC_PREFIX(ed_st)\n#define ed_t          RLC_PREFIX(ed_t)\n\n#undef ed_param_set\n#undef ed_param_set_any\n#undef ed_param_get\n#undef ed_curve_get_ord\n#undef ed_curve_get_gen\n#undef ed_curve_get_tab\n#undef ed_curve_get_cof\n#undef ed_param_print\n#undef ed_param_level\n#undef ed_projc_to_extnd\n#undef ed_rand\n#undef ed_blind\n#undef ed_rhs\n#undef ed_copy\n#undef ed_cmp\n#undef ed_set_infty\n#undef ed_is_infty\n#undef ed_neg_basic\n#undef ed_neg_projc\n#undef ed_add_basic\n#undef ed_add_projc\n#undef ed_add_extnd\n#undef ed_sub_basic\n#undef ed_sub_projc\n#undef ed_sub_extnd\n#undef ed_dbl_basic\n#undef ed_dbl_projc\n#undef ed_dbl_extnd\n#undef ed_norm\n#undef ed_norm_sim\n#undef ed_map\n#undef ed_map_dst\n#undef ed_curve_init\n#undef ed_curve_clean\n#undef ed_mul_pre_basic\n#undef ed_mul_pre_yaowi\n#undef ed_mul_pre_nafwi\n#undef ed_mul_pre_combs\n#undef ed_mul_pre_combd\n#undef ed_mul_pre_lwnaf\n#undef ed_mul_fix_basic\n#undef ed_mul_fix_yaowi\n#undef ed_mul_fix_nafwi\n#undef ed_mul_fix_combs\n#undef ed_mul_fix_combd\n#undef ed_mul_fix_lwnaf\n#undef ed_mul_fix_lwnaf_mixed\n#undef ed_mul_gen\n#undef ed_mul_dig\n#undef ed_mul_sim_basic\n#undef ed_mul_sim_trick\n#undef ed_mul_sim_inter\n#undef ed_mul_sim_joint\n#undef ed_mul_sim_lot\n#undef ed_mul_sim_gen\n#undef ed_tab\n#undef ed_print\n#undef ed_on_curve\n#undef ed_size_bin\n#undef ed_read_bin\n#undef ed_write_bin\n#undef ed_mul_basic\n#undef ed_mul_slide\n#undef ed_mul_monty\n#undef ed_mul_lwnaf\n#undef ed_mul_lwreg\n#undef ed_pck\n#undef ed_upk\n\n#define ed_param_set \tRLC_PREFIX(ed_param_set)\n#define ed_param_set_any \tRLC_PREFIX(ed_param_set_any)\n#define ed_param_get \tRLC_PREFIX(ed_param_get)\n#define ed_curve_get_ord \tRLC_PREFIX(ed_curve_get_ord)\n#define ed_curve_get_gen \tRLC_PREFIX(ed_curve_get_gen)\n#define ed_curve_get_tab \tRLC_PREFIX(ed_curve_get_tab)\n#define ed_curve_get_cof \tRLC_PREFIX(ed_curve_get_cof)\n#define ed_param_print \tRLC_PREFIX(ed_param_print)\n#define ed_param_level \tRLC_PREFIX(ed_param_level)\n#define ed_projc_to_extnd \tRLC_PREFIX(ed_projc_to_extnd)\n#define ed_rand \tRLC_PREFIX(ed_rand)\n#define ed_blind \tRLC_PREFIX(ed_blind)\n#define ed_rhs \tRLC_PREFIX(ed_rhs)\n#define ed_copy \tRLC_PREFIX(ed_copy)\n#define ed_cmp \tRLC_PREFIX(ed_cmp)\n#define ed_set_infty \tRLC_PREFIX(ed_set_infty)\n#define ed_is_infty \tRLC_PREFIX(ed_is_infty)\n#define ed_neg_basic \tRLC_PREFIX(ed_neg_basic)\n#define ed_neg_projc \tRLC_PREFIX(ed_neg_projc)\n#define ed_add_basic \tRLC_PREFIX(ed_add_basic)\n#define ed_add_projc \tRLC_PREFIX(ed_add_projc)\n#define ed_add_extnd \tRLC_PREFIX(ed_add_extnd)\n#define ed_sub_basic \tRLC_PREFIX(ed_sub_basic)\n#define ed_sub_projc \tRLC_PREFIX(ed_sub_projc)\n#define ed_sub_extnd \tRLC_PREFIX(ed_sub_extnd)\n#define ed_dbl_basic \tRLC_PREFIX(ed_dbl_basic)\n#define ed_dbl_projc \tRLC_PREFIX(ed_dbl_projc)\n#define ed_dbl_extnd \tRLC_PREFIX(ed_dbl_extnd)\n#define ed_norm \tRLC_PREFIX(ed_norm)\n#define ed_norm_sim \tRLC_PREFIX(ed_norm_sim)\n#define ed_map \tRLC_PREFIX(ed_map)\n#define ed_map_dst \tRLC_PREFIX(ed_map_dst)\n#define ed_curve_init \tRLC_PREFIX(ed_curve_init)\n#define ed_curve_clean \tRLC_PREFIX(ed_curve_clean)\n#define ed_mul_pre_basic \tRLC_PREFIX(ed_mul_pre_basic)\n#define ed_mul_pre_yaowi \tRLC_PREFIX(ed_mul_pre_yaowi)\n#define ed_mul_pre_nafwi \tRLC_PREFIX(ed_mul_pre_nafwi)\n#define ed_mul_pre_combs \tRLC_PREFIX(ed_mul_pre_combs)\n#define ed_mul_pre_combd \tRLC_PREFIX(ed_mul_pre_combd)\n#define ed_mul_pre_lwnaf \tRLC_PREFIX(ed_mul_pre_lwnaf)\n#define ed_mul_fix_basic \tRLC_PREFIX(ed_mul_fix_basic)\n#define ed_mul_fix_yaowi \tRLC_PREFIX(ed_mul_fix_yaowi)\n#define ed_mul_fix_nafwi \tRLC_PREFIX(ed_mul_fix_nafwi)\n#define ed_mul_fix_combs \tRLC_PREFIX(ed_mul_fix_combs)\n#define ed_mul_fix_combd \tRLC_PREFIX(ed_mul_fix_combd)\n#define ed_mul_fix_lwnaf \tRLC_PREFIX(ed_mul_fix_lwnaf)\n#define ed_mul_fix_lwnaf_mixed \tRLC_PREFIX(ed_mul_fix_lwnaf_mixed)\n#define ed_mul_gen \tRLC_PREFIX(ed_mul_gen)\n#define ed_mul_dig \tRLC_PREFIX(ed_mul_dig)\n#define ed_mul_sim_basic \tRLC_PREFIX(ed_mul_sim_basic)\n#define ed_mul_sim_trick \tRLC_PREFIX(ed_mul_sim_trick)\n#define ed_mul_sim_inter \tRLC_PREFIX(ed_mul_sim_inter)\n#define ed_mul_sim_joint \tRLC_PREFIX(ed_mul_sim_joint)\n#define ed_mul_sim_lot \tRLC_PREFIX(ed_mul_sim_lot)\n#define ed_mul_sim_gen \tRLC_PREFIX(ed_mul_sim_gen)\n#define ed_tab \tRLC_PREFIX(ed_tab)\n#define ed_print \tRLC_PREFIX(ed_print)\n#define ed_on_curve \tRLC_PREFIX(ed_on_curve)\n#define ed_size_bin \tRLC_PREFIX(ed_size_bin)\n#define ed_read_bin \tRLC_PREFIX(ed_read_bin)\n#define ed_write_bin \tRLC_PREFIX(ed_write_bin)\n#define ed_mul_basic \tRLC_PREFIX(ed_mul_basic)\n#define ed_mul_slide \tRLC_PREFIX(ed_mul_slide)\n#define ed_mul_monty \tRLC_PREFIX(ed_mul_monty)\n#define ed_mul_lwnaf \tRLC_PREFIX(ed_mul_lwnaf)\n#define ed_mul_lwreg \tRLC_PREFIX(ed_mul_lwreg)\n#define ed_pck \tRLC_PREFIX(ed_pck)\n#define ed_upk \tRLC_PREFIX(ed_upk)\n\n#undef eb_st\n#undef eb_t\n#define eb_st         RLC_PREFIX(eb_st)\n#define eb_t          RLC_PREFIX(eb_t)\n\n#undef eb_curve_init\n#undef eb_curve_clean\n#undef eb_curve_get_a\n#undef eb_curve_get_b\n#undef eb_curve_opt_a\n#undef eb_curve_opt_b\n#undef eb_curve_is_kbltz\n#undef eb_curve_get_gen\n#undef eb_curve_get_tab\n#undef eb_curve_get_ord\n#undef eb_curve_get_cof\n#undef eb_curve_set\n#undef eb_param_set\n#undef eb_param_set_any\n#undef eb_param_set_any_plain\n#undef eb_param_set_any_kbltz\n#undef eb_param_get\n#undef eb_param_print\n#undef eb_param_level\n#undef eb_is_infty\n#undef eb_set_infty\n#undef eb_copy\n#undef eb_cmp\n#undef eb_rand\n#undef eb_blind\n#undef eb_rhs\n#undef eb_on_curve\n#undef eb_tab\n#undef eb_print\n#undef eb_size_bin\n#undef eb_read_bin\n#undef eb_write_bin\n#undef eb_neg_basic\n#undef eb_neg_projc\n#undef eb_add_basic\n#undef eb_add_projc\n#undef eb_sub_basic\n#undef eb_sub_projc\n#undef eb_dbl_basic\n#undef eb_dbl_projc\n#undef eb_hlv\n#undef eb_frb\n#undef eb_mul_basic\n#undef eb_mul_lodah\n#undef eb_mul_lwnaf\n#undef eb_mul_rwnaf\n#undef eb_mul_halve\n#undef eb_mul_gen\n#undef eb_mul_dig\n#undef eb_mul_pre_basic\n#undef eb_mul_pre_yaowi\n#undef eb_mul_pre_nafwi\n#undef eb_mul_pre_combs\n#undef eb_mul_pre_combd\n#undef eb_mul_pre_lwnaf\n#undef eb_mul_fix_basic\n#undef eb_mul_fix_yaowi\n#undef eb_mul_fix_nafwi\n#undef eb_mul_fix_combs\n#undef eb_mul_fix_combd\n#undef eb_mul_fix_lwnaf\n#undef eb_mul_sim_basic\n#undef eb_mul_sim_trick\n#undef eb_mul_sim_inter\n#undef eb_mul_sim_joint\n#undef eb_mul_sim_gen\n#undef eb_norm\n#undef eb_norm_sim\n#undef eb_map\n#undef eb_pck\n#undef eb_upk\n\n#define eb_curve_init \tRLC_PREFIX(eb_curve_init)\n#define eb_curve_clean \tRLC_PREFIX(eb_curve_clean)\n#define eb_curve_get_a \tRLC_PREFIX(eb_curve_get_a)\n#define eb_curve_get_b \tRLC_PREFIX(eb_curve_get_b)\n#define eb_curve_opt_a \tRLC_PREFIX(eb_curve_opt_a)\n#define eb_curve_opt_b \tRLC_PREFIX(eb_curve_opt_b)\n#define eb_curve_is_kbltz \tRLC_PREFIX(eb_curve_is_kbltz)\n#define eb_curve_get_gen \tRLC_PREFIX(eb_curve_get_gen)\n#define eb_curve_get_tab \tRLC_PREFIX(eb_curve_get_tab)\n#define eb_curve_get_ord \tRLC_PREFIX(eb_curve_get_ord)\n#define eb_curve_get_cof \tRLC_PREFIX(eb_curve_get_cof)\n#define eb_curve_set \tRLC_PREFIX(eb_curve_set)\n#define eb_param_set \tRLC_PREFIX(eb_param_set)\n#define eb_param_set_any \tRLC_PREFIX(eb_param_set_any)\n#define eb_param_set_any_plain \tRLC_PREFIX(eb_param_set_any_plain)\n#define eb_param_set_any_kbltz \tRLC_PREFIX(eb_param_set_any_kbltz)\n#define eb_param_get \tRLC_PREFIX(eb_param_get)\n#define eb_param_print \tRLC_PREFIX(eb_param_print)\n#define eb_param_level \tRLC_PREFIX(eb_param_level)\n#define eb_is_infty \tRLC_PREFIX(eb_is_infty)\n#define eb_set_infty \tRLC_PREFIX(eb_set_infty)\n#define eb_copy \tRLC_PREFIX(eb_copy)\n#define eb_cmp \tRLC_PREFIX(eb_cmp)\n#define eb_rand \tRLC_PREFIX(eb_rand)\n#define eb_blind \tRLC_PREFIX(eb_blind)\n#define eb_rhs \tRLC_PREFIX(eb_rhs)\n#define eb_on_curve \tRLC_PREFIX(eb_on_curve)\n#define eb_tab \tRLC_PREFIX(eb_tab)\n#define eb_print \tRLC_PREFIX(eb_print)\n#define eb_size_bin \tRLC_PREFIX(eb_size_bin)\n#define eb_read_bin \tRLC_PREFIX(eb_read_bin)\n#define eb_write_bin \tRLC_PREFIX(eb_write_bin)\n#define eb_neg_basic \tRLC_PREFIX(eb_neg_basic)\n#define eb_neg_projc \tRLC_PREFIX(eb_neg_projc)\n#define eb_add_basic \tRLC_PREFIX(eb_add_basic)\n#define eb_add_projc \tRLC_PREFIX(eb_add_projc)\n#define eb_sub_basic \tRLC_PREFIX(eb_sub_basic)\n#define eb_sub_projc \tRLC_PREFIX(eb_sub_projc)\n#define eb_dbl_basic \tRLC_PREFIX(eb_dbl_basic)\n#define eb_dbl_projc \tRLC_PREFIX(eb_dbl_projc)\n#define eb_hlv \tRLC_PREFIX(eb_hlv)\n#define eb_frb \tRLC_PREFIX(eb_frb)\n#define eb_mul_basic \tRLC_PREFIX(eb_mul_basic)\n#define eb_mul_lodah \tRLC_PREFIX(eb_mul_lodah)\n#define eb_mul_lwnaf \tRLC_PREFIX(eb_mul_lwnaf)\n#define eb_mul_rwnaf \tRLC_PREFIX(eb_mul_rwnaf)\n#define eb_mul_halve \tRLC_PREFIX(eb_mul_halve)\n#define eb_mul_gen \tRLC_PREFIX(eb_mul_gen)\n#define eb_mul_dig \tRLC_PREFIX(eb_mul_dig)\n#define eb_mul_pre_basic \tRLC_PREFIX(eb_mul_pre_basic)\n#define eb_mul_pre_yaowi \tRLC_PREFIX(eb_mul_pre_yaowi)\n#define eb_mul_pre_nafwi \tRLC_PREFIX(eb_mul_pre_nafwi)\n#define eb_mul_pre_combs \tRLC_PREFIX(eb_mul_pre_combs)\n#define eb_mul_pre_combd \tRLC_PREFIX(eb_mul_pre_combd)\n#define eb_mul_pre_lwnaf \tRLC_PREFIX(eb_mul_pre_lwnaf)\n#define eb_mul_fix_basic \tRLC_PREFIX(eb_mul_fix_basic)\n#define eb_mul_fix_yaowi \tRLC_PREFIX(eb_mul_fix_yaowi)\n#define eb_mul_fix_nafwi \tRLC_PREFIX(eb_mul_fix_nafwi)\n#define eb_mul_fix_combs \tRLC_PREFIX(eb_mul_fix_combs)\n#define eb_mul_fix_combd \tRLC_PREFIX(eb_mul_fix_combd)\n#define eb_mul_fix_lwnaf \tRLC_PREFIX(eb_mul_fix_lwnaf)\n#define eb_mul_sim_basic \tRLC_PREFIX(eb_mul_sim_basic)\n#define eb_mul_sim_trick \tRLC_PREFIX(eb_mul_sim_trick)\n#define eb_mul_sim_inter \tRLC_PREFIX(eb_mul_sim_inter)\n#define eb_mul_sim_joint \tRLC_PREFIX(eb_mul_sim_joint)\n#define eb_mul_sim_gen \tRLC_PREFIX(eb_mul_sim_gen)\n#define eb_norm \tRLC_PREFIX(eb_norm)\n#define eb_norm_sim \tRLC_PREFIX(eb_norm_sim)\n#define eb_map \tRLC_PREFIX(eb_map)\n#define eb_pck \tRLC_PREFIX(eb_pck)\n#define eb_upk \tRLC_PREFIX(eb_upk)\n\n#undef ep2_st\n#undef ep2_t\n#define ep2_st        RLC_PREFIX(ep2_st)\n#define ep2_t         RLC_PREFIX(ep2_t)\n\n#undef ep2_curve_init\n#undef ep2_curve_clean\n#undef ep2_curve_get_a\n#undef ep2_curve_get_b\n#undef ep2_curve_get_vs\n#undef ep2_curve_opt_a\n#undef ep2_curve_opt_b\n#undef ep2_curve_is_twist\n#undef ep2_curve_is_ctmap\n#undef ep2_curve_get_gen\n#undef ep2_curve_get_tab\n#undef ep2_curve_get_ord\n#undef ep2_curve_get_cof\n#undef ep2_curve_get_iso\n#undef ep2_curve_set\n#undef ep2_curve_set_twist\n#undef ep2_is_infty\n#undef ep2_set_infty\n#undef ep2_copy\n#undef ep2_cmp\n#undef ep2_rand\n#undef ep2_blind\n#undef ep2_rhs\n#undef ep2_on_curve\n#undef ep2_tab\n#undef ep2_print\n#undef ep2_size_bin\n#undef ep2_read_bin\n#undef ep2_write_bin\n#undef ep2_neg\n#undef ep2_add_basic\n#undef ep2_add_slp_basic\n#undef ep2_add_projc\n#undef ep2_sub\n#undef ep2_dbl_basic\n#undef ep2_dbl_slp_basic\n#undef ep2_dbl_projc\n#undef ep2_mul_basic\n#undef ep2_mul_slide\n#undef ep2_mul_monty\n#undef ep2_mul_lwnaf\n#undef ep2_mul_lwreg\n#undef ep2_mul_gen\n#undef ep2_mul_dig\n#undef ep2_mul_cof\n#undef ep2_mul_pre_basic\n#undef ep2_mul_pre_yaowi\n#undef ep2_mul_pre_nafwi\n#undef ep2_mul_pre_combs\n#undef ep2_mul_pre_combd\n#undef ep2_mul_pre_lwnaf\n#undef ep2_mul_fix_basic\n#undef ep2_mul_fix_yaowi\n#undef ep2_mul_fix_nafwi\n#undef ep2_mul_fix_combs\n#undef ep2_mul_fix_combd\n#undef ep2_mul_fix_lwnaf\n#undef ep2_mul_sim_basic\n#undef ep2_mul_sim_trick\n#undef ep2_mul_sim_inter\n#undef ep2_mul_sim_joint\n#undef ep2_mul_sim_lot\n#undef ep2_mul_sim_gen\n#undef ep2_mul_sim_dig\n#undef ep2_norm\n#undef ep2_norm_sim\n#undef ep2_map_from_field\n#undef ep2_map\n#undef ep2_map_dst\n#undef ep2_frb\n#undef ep2_pck\n#undef ep2_upk\n\n#define ep2_curve_init \tRLC_PREFIX(ep2_curve_init)\n#define ep2_curve_clean \tRLC_PREFIX(ep2_curve_clean)\n#define ep2_curve_get_a \tRLC_PREFIX(ep2_curve_get_a)\n#define ep2_curve_get_b \tRLC_PREFIX(ep2_curve_get_b)\n#define ep2_curve_get_vs \tRLC_PREFIX(ep2_curve_get_vs)\n#define ep2_curve_opt_a \tRLC_PREFIX(ep2_curve_opt_a)\n#define ep2_curve_opt_b \tRLC_PREFIX(ep2_curve_opt_b)\n#define ep2_curve_is_twist \tRLC_PREFIX(ep2_curve_is_twist)\n#define ep2_curve_is_ctmap \tRLC_PREFIX(ep2_curve_is_ctmap)\n#define ep2_curve_get_gen \tRLC_PREFIX(ep2_curve_get_gen)\n#define ep2_curve_get_tab \tRLC_PREFIX(ep2_curve_get_tab)\n#define ep2_curve_get_ord \tRLC_PREFIX(ep2_curve_get_ord)\n#define ep2_curve_get_cof \tRLC_PREFIX(ep2_curve_get_cof)\n#define ep2_curve_get_iso \tRLC_PREFIX(ep2_curve_get_iso)\n#define ep2_curve_set \tRLC_PREFIX(ep2_curve_set)\n#define ep2_curve_set_twist \tRLC_PREFIX(ep2_curve_set_twist)\n#define ep2_is_infty \tRLC_PREFIX(ep2_is_infty)\n#define ep2_set_infty \tRLC_PREFIX(ep2_set_infty)\n#define ep2_copy \tRLC_PREFIX(ep2_copy)\n#define ep2_cmp \tRLC_PREFIX(ep2_cmp)\n#define ep2_rand \tRLC_PREFIX(ep2_rand)\n#define ep2_blind \tRLC_PREFIX(ep2_blind)\n#define ep2_rhs \tRLC_PREFIX(ep2_rhs)\n#define ep2_on_curve \tRLC_PREFIX(ep2_on_curve)\n#define ep2_tab \tRLC_PREFIX(ep2_tab)\n#define ep2_print \tRLC_PREFIX(ep2_print)\n#define ep2_size_bin \tRLC_PREFIX(ep2_size_bin)\n#define ep2_read_bin \tRLC_PREFIX(ep2_read_bin)\n#define ep2_write_bin \tRLC_PREFIX(ep2_write_bin)\n#define ep2_neg \tRLC_PREFIX(ep2_neg)\n#define ep2_add_basic \tRLC_PREFIX(ep2_add_basic)\n#define ep2_add_slp_basic \tRLC_PREFIX(ep2_add_slp_basic)\n#define ep2_add_projc \tRLC_PREFIX(ep2_add_projc)\n#define ep2_sub \tRLC_PREFIX(ep2_sub)\n#define ep2_dbl_basic \tRLC_PREFIX(ep2_dbl_basic)\n#define ep2_dbl_slp_basic \tRLC_PREFIX(ep2_dbl_slp_basic)\n#define ep2_dbl_projc \tRLC_PREFIX(ep2_dbl_projc)\n#define ep2_mul_basic \tRLC_PREFIX(ep2_mul_basic)\n#define ep2_mul_slide \tRLC_PREFIX(ep2_mul_slide)\n#define ep2_mul_monty \tRLC_PREFIX(ep2_mul_monty)\n#define ep2_mul_lwnaf \tRLC_PREFIX(ep2_mul_lwnaf)\n#define ep2_mul_lwreg \tRLC_PREFIX(ep2_mul_lwreg)\n#define ep2_mul_gen \tRLC_PREFIX(ep2_mul_gen)\n#define ep2_mul_dig \tRLC_PREFIX(ep2_mul_dig)\n#define ep2_mul_cof \tRLC_PREFIX(ep2_mul_cof)\n#define ep2_mul_pre_basic \tRLC_PREFIX(ep2_mul_pre_basic)\n#define ep2_mul_pre_yaowi \tRLC_PREFIX(ep2_mul_pre_yaowi)\n#define ep2_mul_pre_nafwi \tRLC_PREFIX(ep2_mul_pre_nafwi)\n#define ep2_mul_pre_combs \tRLC_PREFIX(ep2_mul_pre_combs)\n#define ep2_mul_pre_combd \tRLC_PREFIX(ep2_mul_pre_combd)\n#define ep2_mul_pre_lwnaf \tRLC_PREFIX(ep2_mul_pre_lwnaf)\n#define ep2_mul_fix_basic \tRLC_PREFIX(ep2_mul_fix_basic)\n#define ep2_mul_fix_yaowi \tRLC_PREFIX(ep2_mul_fix_yaowi)\n#define ep2_mul_fix_nafwi \tRLC_PREFIX(ep2_mul_fix_nafwi)\n#define ep2_mul_fix_combs \tRLC_PREFIX(ep2_mul_fix_combs)\n#define ep2_mul_fix_combd \tRLC_PREFIX(ep2_mul_fix_combd)\n#define ep2_mul_fix_lwnaf \tRLC_PREFIX(ep2_mul_fix_lwnaf)\n#define ep2_mul_sim_basic \tRLC_PREFIX(ep2_mul_sim_basic)\n#define ep2_mul_sim_trick \tRLC_PREFIX(ep2_mul_sim_trick)\n#define ep2_mul_sim_inter \tRLC_PREFIX(ep2_mul_sim_inter)\n#define ep2_mul_sim_joint \tRLC_PREFIX(ep2_mul_sim_joint)\n#define ep2_mul_sim_lot \tRLC_PREFIX(ep2_mul_sim_lot)\n#define ep2_mul_sim_gen \tRLC_PREFIX(ep2_mul_sim_gen)\n#define ep2_mul_sim_dig \tRLC_PREFIX(ep2_mul_sim_dig)\n#define ep2_norm \tRLC_PREFIX(ep2_norm)\n#define ep2_norm_sim \tRLC_PREFIX(ep2_norm_sim)\n#define ep2_map_from_field \tRLC_PREFIX(ep2_map_from_field)\n#define ep2_map \tRLC_PREFIX(ep2_map)\n#define ep2_map_dst \tRLC_PREFIX(ep2_map_dst)\n#define ep2_frb \tRLC_PREFIX(ep2_frb)\n#define ep2_pck \tRLC_PREFIX(ep2_pck)\n#define ep2_upk \tRLC_PREFIX(ep2_upk)\n\n#undef ep4_st\n#undef ep4_t\n#define ep4_st        RLC_PREFIX(ep4_st)\n#define ep4_t         RLC_PREFIX(ep4_t)\n\n#undef ep4_curve_init\n#undef ep4_curve_clean\n#undef ep4_curve_get_a\n#undef ep4_curve_get_b\n#undef ep4_curve_get_vs\n#undef ep4_curve_opt_a\n#undef ep4_curve_opt_b\n#undef ep4_curve_is_twist\n#undef ep4_curve_get_gen\n#undef ep4_curve_get_tab\n#undef ep4_curve_get_ord\n#undef ep4_curve_get_cof\n#undef ep4_curve_set\n#undef ep4_curve_set_twist\n#undef ep4_is_infty\n#undef ep4_set_infty\n#undef ep4_copy\n#undef ep4_cmp\n#undef ep4_rand\n#undef ep4_blind\n#undef ep4_rhs\n#undef ep4_on_curve\n#undef ep4_tab\n#undef ep4_print\n#undef ep4_size_bin\n#undef ep4_read_bin\n#undef ep4_write_bin\n#undef ep4_neg\n#undef ep4_add_basic\n#undef ep4_add_slp_basic\n#undef ep4_add_projc\n#undef ep4_sub\n#undef ep4_dbl_basic\n#undef ep4_dbl_slp_basic\n#undef ep4_dbl_projc\n#undef ep4_mul_basic\n#undef ep4_mul_slide\n#undef ep4_mul_monty\n#undef ep4_mul_lwnaf\n#undef ep4_mul_lwreg\n#undef ep4_mul_gen\n#undef ep4_mul_dig\n#undef ep4_mul_cof\n#undef ep4_mul_pre_basic\n#undef ep4_mul_pre_yaowi\n#undef ep4_mul_pre_nafwi\n#undef ep4_mul_pre_combs\n#undef ep4_mul_pre_combd\n#undef ep4_mul_pre_lwnaf\n#undef ep4_mul_fix_basic\n#undef ep4_mul_fix_yaowi\n#undef ep4_mul_fix_nafwi\n#undef ep4_mul_fix_combs\n#undef ep4_mul_fix_combd\n#undef ep4_mul_fix_lwnaf\n#undef ep4_mul_sim_basic\n#undef ep4_mul_sim_trick\n#undef ep4_mul_sim_inter\n#undef ep4_mul_sim_joint\n#undef ep4_mul_sim_lot\n#undef ep4_mul_sim_gen\n#undef ep4_mul_sim_dig\n#undef ep4_norm\n#undef ep4_norm_sim\n#undef ep4_map\n#undef ep4_map_dst\n#undef ep4_frb\n#undef ep4_pck\n#undef ep4_upk\n\n#define ep4_curve_init \tRLC_PREFIX(ep4_curve_init)\n#define ep4_curve_clean \tRLC_PREFIX(ep4_curve_clean)\n#define ep4_curve_get_a \tRLC_PREFIX(ep4_curve_get_a)\n#define ep4_curve_get_b \tRLC_PREFIX(ep4_curve_get_b)\n#define ep4_curve_get_vs \tRLC_PREFIX(ep4_curve_get_vs)\n#define ep4_curve_opt_a \tRLC_PREFIX(ep4_curve_opt_a)\n#define ep4_curve_opt_b \tRLC_PREFIX(ep4_curve_opt_b)\n#define ep4_curve_is_twist \tRLC_PREFIX(ep4_curve_is_twist)\n#define ep4_curve_get_gen \tRLC_PREFIX(ep4_curve_get_gen)\n#define ep4_curve_get_tab \tRLC_PREFIX(ep4_curve_get_tab)\n#define ep4_curve_get_ord \tRLC_PREFIX(ep4_curve_get_ord)\n#define ep4_curve_get_cof \tRLC_PREFIX(ep4_curve_get_cof)\n#define ep4_curve_set \tRLC_PREFIX(ep4_curve_set)\n#define ep4_curve_set_twist \tRLC_PREFIX(ep4_curve_set_twist)\n#define ep4_is_infty \tRLC_PREFIX(ep4_is_infty)\n#define ep4_set_infty \tRLC_PREFIX(ep4_set_infty)\n#define ep4_copy \tRLC_PREFIX(ep4_copy)\n#define ep4_cmp \tRLC_PREFIX(ep4_cmp)\n#define ep4_rand \tRLC_PREFIX(ep4_rand)\n#define ep4_blind \tRLC_PREFIX(ep4_blind)\n#define ep4_rhs \tRLC_PREFIX(ep4_rhs)\n#define ep4_on_curve \tRLC_PREFIX(ep4_on_curve)\n#define ep4_tab \tRLC_PREFIX(ep4_tab)\n#define ep4_print \tRLC_PREFIX(ep4_print)\n#define ep4_size_bin \tRLC_PREFIX(ep4_size_bin)\n#define ep4_read_bin \tRLC_PREFIX(ep4_read_bin)\n#define ep4_write_bin \tRLC_PREFIX(ep4_write_bin)\n#define ep4_neg \tRLC_PREFIX(ep4_neg)\n#define ep4_add_basic \tRLC_PREFIX(ep4_add_basic)\n#define ep4_add_slp_basic \tRLC_PREFIX(ep4_add_slp_basic)\n#define ep4_add_projc \tRLC_PREFIX(ep4_add_projc)\n#define ep4_sub \tRLC_PREFIX(ep4_sub)\n#define ep4_dbl_basic \tRLC_PREFIX(ep4_dbl_basic)\n#define ep4_dbl_slp_basic \tRLC_PREFIX(ep4_dbl_slp_basic)\n#define ep4_dbl_projc \tRLC_PREFIX(ep4_dbl_projc)\n#define ep4_mul_basic \tRLC_PREFIX(ep4_mul_basic)\n#define ep4_mul_slide \tRLC_PREFIX(ep4_mul_slide)\n#define ep4_mul_monty \tRLC_PREFIX(ep4_mul_monty)\n#define ep4_mul_lwnaf \tRLC_PREFIX(ep4_mul_lwnaf)\n#define ep4_mul_lwreg \tRLC_PREFIX(ep4_mul_lwreg)\n#define ep4_mul_gen \tRLC_PREFIX(ep4_mul_gen)\n#define ep4_mul_dig \tRLC_PREFIX(ep4_mul_dig)\n#define ep4_mul_cof \tRLC_PREFIX(ep4_mul_cof)\n#define ep4_mul_pre_basic \tRLC_PREFIX(ep4_mul_pre_basic)\n#define ep4_mul_pre_yaowi \tRLC_PREFIX(ep4_mul_pre_yaowi)\n#define ep4_mul_pre_nafwi \tRLC_PREFIX(ep4_mul_pre_nafwi)\n#define ep4_mul_pre_combs \tRLC_PREFIX(ep4_mul_pre_combs)\n#define ep4_mul_pre_combd \tRLC_PREFIX(ep4_mul_pre_combd)\n#define ep4_mul_pre_lwnaf \tRLC_PREFIX(ep4_mul_pre_lwnaf)\n#define ep4_mul_fix_basic \tRLC_PREFIX(ep4_mul_fix_basic)\n#define ep4_mul_fix_yaowi \tRLC_PREFIX(ep4_mul_fix_yaowi)\n#define ep4_mul_fix_nafwi \tRLC_PREFIX(ep4_mul_fix_nafwi)\n#define ep4_mul_fix_combs \tRLC_PREFIX(ep4_mul_fix_combs)\n#define ep4_mul_fix_combd \tRLC_PREFIX(ep4_mul_fix_combd)\n#define ep4_mul_fix_lwnaf \tRLC_PREFIX(ep4_mul_fix_lwnaf)\n#define ep4_mul_sim_basic \tRLC_PREFIX(ep4_mul_sim_basic)\n#define ep4_mul_sim_trick \tRLC_PREFIX(ep4_mul_sim_trick)\n#define ep4_mul_sim_inter \tRLC_PREFIX(ep4_mul_sim_inter)\n#define ep4_mul_sim_joint \tRLC_PREFIX(ep4_mul_sim_joint)\n#define ep4_mul_sim_lot \tRLC_PREFIX(ep4_mul_sim_lot)\n#define ep4_mul_sim_gen \tRLC_PREFIX(ep4_mul_sim_gen)\n#define ep4_mul_sim_dig \tRLC_PREFIX(ep4_mul_sim_dig)\n#define ep4_norm \tRLC_PREFIX(ep4_norm)\n#define ep4_norm_sim \tRLC_PREFIX(ep4_norm_sim)\n#define ep4_map \tRLC_PREFIX(ep4_map)\n#define ep4_map_dst \tRLC_PREFIX(ep4_map_dst)\n#define ep4_frb \tRLC_PREFIX(ep4_frb)\n#define ep4_pck \tRLC_PREFIX(ep4_pck)\n#define ep4_upk \tRLC_PREFIX(ep4_upk)\n\n#undef fp2_st\n#undef fp2_t\n#undef dv2_t\n#define fp2_st        RLC_PREFIX(fp2_st)\n#define fp2_t         RLC_PREFIX(fp2_t)\n#define dv2_t         RLC_PREFIX(dv2_t)\n#undef fp3_st\n#undef fp3_t\n#undef dv3_t\n#define fp3_st        RLC_PREFIX(fp3_st)\n#define fp3_t         RLC_PREFIX(fp3_t)\n#define dv3_t         RLC_PREFIX(dv3_t)\n#undef fp6_st\n#undef fp6_t\n#undef dv6_t\n#define fp6_st        RLC_PREFIX(fp6_st)\n#define fp6_t         RLC_PREFIX(fp6_t)\n#define dv6_t         RLC_PREFIX(dv6_t)\n#undef fp9_st\n#undef fp8_t\n#undef dv8_t\n#define fp8_st        RLC_PREFIX(fp8_st)\n#define fp8_t         RLC_PREFIX(fp8_t)\n#define dv8_t         RLC_PREFIX(dv8_t)\n#undef fp9_st\n#undef fp9_t\n#undef dv9_t\n#define fp9_st        RLC_PREFIX(fp9_st)\n#define fp9_t         RLC_PREFIX(fp9_t)\n#define dv9_t         RLC_PREFIX(dv9_t)\n#undef fp12_st\n#undef fp12_t\n#undef dv12_t\n#define fp12_st        RLC_PREFIX(fp12_st)\n#define fp12_t         RLC_PREFIX(fp12_t)\n#define dv12_t         RLC_PREFIX(dv12_t)\n#undef fp18_st\n#undef fp18_t\n#undef dv18_t\n#define fp18_st        RLC_PREFIX(fp18_st)\n#define fp18_t         RLC_PREFIX(fp18_t)\n#define dv18_t         RLC_PREFIX(dv18_t)\n#undef fp24_st\n#undef fp24_t\n#undef dv24_t\n#define fp24_st        RLC_PREFIX(fp24_st)\n#define fp24_t         RLC_PREFIX(fp24_t)\n#define dv24_t         RLC_PREFIX(dv24_t)\n#undef fp48_st\n#undef fp48_t\n#undef dv48_t\n#define fp48_st        RLC_PREFIX(fp48_st)\n#define fp48_t         RLC_PREFIX(fp48_t)\n#define dv48_t         RLC_PREFIX(dv48_t)\n#undef fp54_st\n#undef fp54_t\n#undef dv54_t\n#define fp54_st        RLC_PREFIX(fp54_st)\n#define fp54_t         RLC_PREFIX(fp54_t)\n#define dv54_t         RLC_PREFIX(dv54_t)\n\n#undef fp2_add_dig\n#undef fp2_sub_dig\n#undef fp2_field_init\n#undef fp2_field_get_qnr\n#undef fp2_copy\n#undef fp2_zero\n#undef fp2_is_zero\n#undef fp2_rand\n#undef fp2_print\n#undef fp2_size_bin\n#undef fp2_read_bin\n#undef fp2_write_bin\n#undef fp2_cmp\n#undef fp2_cmp_dig\n#undef fp2_set_dig\n#undef fp2_add_basic\n#undef fp2_add_integ\n#undef fp2_sub_basic\n#undef fp2_sub_integ\n#undef fp2_neg\n#undef fp2_dbl_basic\n#undef fp2_dbl_integ\n#undef fp2_mul_basic\n#undef fp2_mul_integ\n#undef fp2_mul_art\n#undef fp2_mul_nor_basic\n#undef fp2_mul_nor_integ\n#undef fp2_mul_frb\n#undef fp2_mul_dig\n#undef fp2_sqr_basic\n#undef fp2_sqr_integ\n#undef fp2_inv\n#undef fp2_inv_cyc\n#undef fp2_inv_sim\n#undef fp2_test_cyc\n#undef fp2_conv_cyc\n#undef fp2_exp\n#undef fp2_exp_dig\n#undef fp2_exp_cyc\n#undef fp2_frb\n#undef fp2_srt\n#undef fp2_pck\n#undef fp2_upk\n#undef fp2_exp_cyc_sim\n\n#define fp2_add_dig \tRLC_PREFIX(fp2_add_dig)\n#define fp2_sub_dig \tRLC_PREFIX(fp2_sub_dig)\n#define fp2_field_init \tRLC_PREFIX(fp2_field_init)\n#define fp2_field_get_qnr \tRLC_PREFIX(fp2_field_get_qnr)\n#define fp2_copy \tRLC_PREFIX(fp2_copy)\n#define fp2_zero \tRLC_PREFIX(fp2_zero)\n#define fp2_is_zero \tRLC_PREFIX(fp2_is_zero)\n#define fp2_rand \tRLC_PREFIX(fp2_rand)\n#define fp2_print \tRLC_PREFIX(fp2_print)\n#define fp2_size_bin \tRLC_PREFIX(fp2_size_bin)\n#define fp2_read_bin \tRLC_PREFIX(fp2_read_bin)\n#define fp2_write_bin \tRLC_PREFIX(fp2_write_bin)\n#define fp2_cmp \tRLC_PREFIX(fp2_cmp)\n#define fp2_cmp_dig \tRLC_PREFIX(fp2_cmp_dig)\n#define fp2_set_dig \tRLC_PREFIX(fp2_set_dig)\n#define fp2_add_basic \tRLC_PREFIX(fp2_add_basic)\n#define fp2_add_integ \tRLC_PREFIX(fp2_add_integ)\n#define fp2_sub_basic \tRLC_PREFIX(fp2_sub_basic)\n#define fp2_sub_integ \tRLC_PREFIX(fp2_sub_integ)\n#define fp2_neg \tRLC_PREFIX(fp2_neg)\n#define fp2_dbl_basic \tRLC_PREFIX(fp2_dbl_basic)\n#define fp2_dbl_integ \tRLC_PREFIX(fp2_dbl_integ)\n#define fp2_mul_basic \tRLC_PREFIX(fp2_mul_basic)\n#define fp2_mul_integ \tRLC_PREFIX(fp2_mul_integ)\n#define fp2_mul_art \tRLC_PREFIX(fp2_mul_art)\n#define fp2_mul_nor_basic \tRLC_PREFIX(fp2_mul_nor_basic)\n#define fp2_mul_nor_integ \tRLC_PREFIX(fp2_mul_nor_integ)\n#define fp2_mul_frb \tRLC_PREFIX(fp2_mul_frb)\n#define fp2_mul_dig \tRLC_PREFIX(fp2_mul_dig)\n#define fp2_sqr_basic \tRLC_PREFIX(fp2_sqr_basic)\n#define fp2_sqr_integ \tRLC_PREFIX(fp2_sqr_integ)\n#define fp2_inv \tRLC_PREFIX(fp2_inv)\n#define fp2_inv_cyc \tRLC_PREFIX(fp2_inv_cyc)\n#define fp2_inv_sim \tRLC_PREFIX(fp2_inv_sim)\n#define fp2_test_cyc \tRLC_PREFIX(fp2_test_cyc)\n#define fp2_conv_cyc \tRLC_PREFIX(fp2_conv_cyc)\n#define fp2_exp \tRLC_PREFIX(fp2_exp)\n#define fp2_exp_dig \tRLC_PREFIX(fp2_exp_dig)\n#define fp2_exp_cyc \tRLC_PREFIX(fp2_exp_cyc)\n#define fp2_frb \tRLC_PREFIX(fp2_frb)\n#define fp2_srt \tRLC_PREFIX(fp2_srt)\n#define fp2_pck \tRLC_PREFIX(fp2_pck)\n#define fp2_upk \tRLC_PREFIX(fp2_upk)\n#define fp2_exp_cyc_sim \tRLC_PREFIX(fp2_exp_cyc_sim)\n\n#undef fp2_addn_low\n#undef fp2_addm_low\n#undef fp2_addd_low\n#undef fp2_addc_low\n#undef fp2_subn_low\n#undef fp2_subm_low\n#undef fp2_subd_low\n#undef fp2_subc_low\n#undef fp2_dbln_low\n#undef fp2_dblm_low\n#undef fp2_norm_low\n#undef fp2_norh_low\n#undef fp2_nord_low\n#undef fp2_muln_low\n#undef fp2_mulm_low\n#undef fp2_sqrn_low\n#undef fp2_sqrm_low\n#undef fp2_rdcn_low\n\n#define fp2_addn_low \tRLC_PREFIX(fp2_addn_low)\n#define fp2_addm_low \tRLC_PREFIX(fp2_addm_low)\n#define fp2_addd_low \tRLC_PREFIX(fp2_addd_low)\n#define fp2_addc_low \tRLC_PREFIX(fp2_addc_low)\n#define fp2_subn_low \tRLC_PREFIX(fp2_subn_low)\n#define fp2_subm_low \tRLC_PREFIX(fp2_subm_low)\n#define fp2_subd_low \tRLC_PREFIX(fp2_subd_low)\n#define fp2_subc_low \tRLC_PREFIX(fp2_subc_low)\n#define fp2_dbln_low \tRLC_PREFIX(fp2_dbln_low)\n#define fp2_dblm_low \tRLC_PREFIX(fp2_dblm_low)\n#define fp2_norm_low \tRLC_PREFIX(fp2_norm_low)\n#define fp2_norh_low \tRLC_PREFIX(fp2_norh_low)\n#define fp2_nord_low \tRLC_PREFIX(fp2_nord_low)\n#define fp2_muln_low \tRLC_PREFIX(fp2_muln_low)\n#define fp2_mulm_low \tRLC_PREFIX(fp2_mulm_low)\n#define fp2_sqrn_low \tRLC_PREFIX(fp2_sqrn_low)\n#define fp2_sqrm_low \tRLC_PREFIX(fp2_sqrm_low)\n#define fp2_rdcn_low \tRLC_PREFIX(fp2_rdcn_low)\n\n#undef fp3_field_init\n#undef fp3_copy\n#undef fp3_zero\n#undef fp3_is_zero\n#undef fp3_rand\n#undef fp3_print\n#undef fp3_size_bin\n#undef fp3_read_bin\n#undef fp3_write_bin\n#undef fp3_cmp\n#undef fp3_cmp_dig\n#undef fp3_set_dig\n#undef fp3_add_basic\n#undef fp3_add_integ\n#undef fp3_sub_basic\n#undef fp3_sub_integ\n#undef fp3_neg\n#undef fp3_dbl_basic\n#undef fp3_dbl_integ\n#undef fp3_mul_basic\n#undef fp3_mul_integ\n#undef fp3_mul_nor\n#undef fp3_mul_frb\n#undef fp3_sqr_basic\n#undef fp3_sqr_integ\n#undef fp3_inv\n#undef fp3_inv_sim\n#undef fp3_exp\n#undef fp3_frb\n#undef fp3_srt\n\n#define fp3_field_init \tRLC_PREFIX(fp3_field_init)\n#define fp3_copy \tRLC_PREFIX(fp3_copy)\n#define fp3_zero \tRLC_PREFIX(fp3_zero)\n#define fp3_is_zero \tRLC_PREFIX(fp3_is_zero)\n#define fp3_rand \tRLC_PREFIX(fp3_rand)\n#define fp3_print \tRLC_PREFIX(fp3_print)\n#define fp3_size_bin \tRLC_PREFIX(fp3_size_bin)\n#define fp3_read_bin \tRLC_PREFIX(fp3_read_bin)\n#define fp3_write_bin \tRLC_PREFIX(fp3_write_bin)\n#define fp3_cmp \tRLC_PREFIX(fp3_cmp)\n#define fp3_cmp_dig \tRLC_PREFIX(fp3_cmp_dig)\n#define fp3_set_dig \tRLC_PREFIX(fp3_set_dig)\n#define fp3_add_basic \tRLC_PREFIX(fp3_add_basic)\n#define fp3_add_integ \tRLC_PREFIX(fp3_add_integ)\n#define fp3_sub_basic \tRLC_PREFIX(fp3_sub_basic)\n#define fp3_sub_integ \tRLC_PREFIX(fp3_sub_integ)\n#define fp3_neg \tRLC_PREFIX(fp3_neg)\n#define fp3_dbl_basic \tRLC_PREFIX(fp3_dbl_basic)\n#define fp3_dbl_integ \tRLC_PREFIX(fp3_dbl_integ)\n#define fp3_mul_basic \tRLC_PREFIX(fp3_mul_basic)\n#define fp3_mul_integ \tRLC_PREFIX(fp3_mul_integ)\n#define fp3_mul_nor \tRLC_PREFIX(fp3_mul_nor)\n#define fp3_mul_frb \tRLC_PREFIX(fp3_mul_frb)\n#define fp3_sqr_basic \tRLC_PREFIX(fp3_sqr_basic)\n#define fp3_sqr_integ \tRLC_PREFIX(fp3_sqr_integ)\n#define fp3_inv \tRLC_PREFIX(fp3_inv)\n#define fp3_inv_sim \tRLC_PREFIX(fp3_inv_sim)\n#define fp3_exp \tRLC_PREFIX(fp3_exp)\n#define fp3_frb \tRLC_PREFIX(fp3_frb)\n#define fp3_srt \tRLC_PREFIX(fp3_srt)\n\n#undef fp3_addn_low\n#undef fp3_addm_low\n#undef fp3_addd_low\n#undef fp3_addc_low\n#undef fp3_subn_low\n#undef fp3_subm_low\n#undef fp3_subd_low\n#undef fp3_subc_low\n#undef fp3_dbln_low\n#undef fp3_dblm_low\n#undef fp3_nord_low\n#undef fp3_muln_low\n#undef fp3_mulc_low\n#undef fp3_mulm_low\n#undef fp3_sqrn_low\n#undef fp3_sqrm_low\n#undef fp3_rdcn_low\n\n#define fp3_addn_low \tRLC_PREFIX(fp3_addn_low)\n#define fp3_addm_low \tRLC_PREFIX(fp3_addm_low)\n#define fp3_addd_low \tRLC_PREFIX(fp3_addd_low)\n#define fp3_addc_low \tRLC_PREFIX(fp3_addc_low)\n#define fp3_subn_low \tRLC_PREFIX(fp3_subn_low)\n#define fp3_subm_low \tRLC_PREFIX(fp3_subm_low)\n#define fp3_subd_low \tRLC_PREFIX(fp3_subd_low)\n#define fp3_subc_low \tRLC_PREFIX(fp3_subc_low)\n#define fp3_dbln_low \tRLC_PREFIX(fp3_dbln_low)\n#define fp3_dblm_low \tRLC_PREFIX(fp3_dblm_low)\n#define fp3_nord_low \tRLC_PREFIX(fp3_nord_low)\n#define fp3_muln_low \tRLC_PREFIX(fp3_muln_low)\n#define fp3_mulc_low \tRLC_PREFIX(fp3_mulc_low)\n#define fp3_mulm_low \tRLC_PREFIX(fp3_mulm_low)\n#define fp3_sqrn_low \tRLC_PREFIX(fp3_sqrn_low)\n#define fp3_sqrm_low \tRLC_PREFIX(fp3_sqrm_low)\n#define fp3_rdcn_low \tRLC_PREFIX(fp3_rdcn_low)\n\n#undef fp4_field_init\n#undef fp4_copy\n#undef fp4_zero\n#undef fp4_is_zero\n#undef fp4_rand\n#undef fp4_print\n#undef fp4_size_bin\n#undef fp4_read_bin\n#undef fp4_write_bin\n#undef fp4_cmp\n#undef fp4_cmp_dig\n#undef fp4_set_dig\n#undef fp4_add\n#undef fp4_sub\n#undef fp4_neg\n#undef fp4_dbl\n#undef fp4_mul_unr\n#undef fp4_mul_basic\n#undef fp4_mul_lazyr\n#undef fp4_mul_art\n#undef fp4_mul_frb\n#undef fp4_mul_dxs\n#undef fp4_sqr_unr\n#undef fp4_sqr_basic\n#undef fp4_sqr_lazyr\n#undef fp4_inv\n#undef fp4_inv_sim\n#undef fp4_inv_cyc\n#undef fp4_exp\n#undef fp4_frb\n#undef fp4_srt\n\n#define fp4_field_init \tRLC_PREFIX(fp4_field_init)\n#define fp4_copy \tRLC_PREFIX(fp4_copy)\n#define fp4_zero \tRLC_PREFIX(fp4_zero)\n#define fp4_is_zero \tRLC_PREFIX(fp4_is_zero)\n#define fp4_rand \tRLC_PREFIX(fp4_rand)\n#define fp4_print \tRLC_PREFIX(fp4_print)\n#define fp4_size_bin \tRLC_PREFIX(fp4_size_bin)\n#define fp4_read_bin \tRLC_PREFIX(fp4_read_bin)\n#define fp4_write_bin \tRLC_PREFIX(fp4_write_bin)\n#define fp4_cmp \tRLC_PREFIX(fp4_cmp)\n#define fp4_cmp_dig \tRLC_PREFIX(fp4_cmp_dig)\n#define fp4_set_dig \tRLC_PREFIX(fp4_set_dig)\n#define fp4_add \tRLC_PREFIX(fp4_add)\n#define fp4_sub \tRLC_PREFIX(fp4_sub)\n#define fp4_neg \tRLC_PREFIX(fp4_neg)\n#define fp4_dbl \tRLC_PREFIX(fp4_dbl)\n#define fp4_mul_unr \tRLC_PREFIX(fp4_mul_unr)\n#define fp4_mul_basic \tRLC_PREFIX(fp4_mul_basic)\n#define fp4_mul_lazyr \tRLC_PREFIX(fp4_mul_lazyr)\n#define fp4_mul_art \tRLC_PREFIX(fp4_mul_art)\n#define fp4_mul_frb \tRLC_PREFIX(fp4_mul_frb)\n#define fp4_mul_dxs \tRLC_PREFIX(fp4_mul_dxs)\n#define fp4_sqr_unr \tRLC_PREFIX(fp4_sqr_unr)\n#define fp4_sqr_basic \tRLC_PREFIX(fp4_sqr_basic)\n#define fp4_sqr_lazyr \tRLC_PREFIX(fp4_sqr_lazyr)\n#define fp4_inv \tRLC_PREFIX(fp4_inv)\n#define fp4_inv_sim \tRLC_PREFIX(fp4_inv_sim)\n#define fp4_inv_cyc \tRLC_PREFIX(fp4_inv_cyc)\n#define fp4_exp \tRLC_PREFIX(fp4_exp)\n#define fp4_frb \tRLC_PREFIX(fp4_frb)\n#define fp4_srt \tRLC_PREFIX(fp4_srt)\n\n#undef fp6_copy\n#undef fp6_zero\n#undef fp6_is_zero\n#undef fp6_rand\n#undef fp6_print\n#undef fp6_size_bin\n#undef fp6_read_bin\n#undef fp6_write_bin\n#undef fp6_cmp\n#undef fp6_cmp_dig\n#undef fp6_set_dig\n#undef fp6_add\n#undef fp6_sub\n#undef fp6_neg\n#undef fp6_dbl\n#undef fp6_mul_unr\n#undef fp6_mul_basic\n#undef fp6_mul_lazyr\n#undef fp6_mul_art\n#undef fp6_mul_dxs\n#undef fp6_sqr_unr\n#undef fp6_sqr_basic\n#undef fp6_sqr_lazyr\n#undef fp6_inv\n#undef fp6_exp\n#undef fp6_frb\n\n#define fp6_copy \tRLC_PREFIX(fp6_copy)\n#define fp6_zero \tRLC_PREFIX(fp6_zero)\n#define fp6_is_zero \tRLC_PREFIX(fp6_is_zero)\n#define fp6_rand \tRLC_PREFIX(fp6_rand)\n#define fp6_print \tRLC_PREFIX(fp6_print)\n#define fp6_size_bin \tRLC_PREFIX(fp6_size_bin)\n#define fp6_read_bin \tRLC_PREFIX(fp6_read_bin)\n#define fp6_write_bin \tRLC_PREFIX(fp6_write_bin)\n#define fp6_cmp \tRLC_PREFIX(fp6_cmp)\n#define fp6_cmp_dig \tRLC_PREFIX(fp6_cmp_dig)\n#define fp6_set_dig \tRLC_PREFIX(fp6_set_dig)\n#define fp6_add \tRLC_PREFIX(fp6_add)\n#define fp6_sub \tRLC_PREFIX(fp6_sub)\n#define fp6_neg \tRLC_PREFIX(fp6_neg)\n#define fp6_dbl \tRLC_PREFIX(fp6_dbl)\n#define fp6_mul_unr \tRLC_PREFIX(fp6_mul_unr)\n#define fp6_mul_basic \tRLC_PREFIX(fp6_mul_basic)\n#define fp6_mul_lazyr \tRLC_PREFIX(fp6_mul_lazyr)\n#define fp6_mul_art \tRLC_PREFIX(fp6_mul_art)\n#define fp6_mul_dxs \tRLC_PREFIX(fp6_mul_dxs)\n#define fp6_sqr_unr \tRLC_PREFIX(fp6_sqr_unr)\n#define fp6_sqr_basic \tRLC_PREFIX(fp6_sqr_basic)\n#define fp6_sqr_lazyr \tRLC_PREFIX(fp6_sqr_lazyr)\n#define fp6_inv \tRLC_PREFIX(fp6_inv)\n#define fp6_exp \tRLC_PREFIX(fp6_exp)\n#define fp6_frb \tRLC_PREFIX(fp6_frb)\n\n#undef fp8_copy\n#undef fp8_zero\n#undef fp8_is_zero\n#undef fp8_rand\n#undef fp8_print\n#undef fp8_size_bin\n#undef fp8_read_bin\n#undef fp8_write_bin\n#undef fp8_cmp\n#undef fp8_cmp_dig\n#undef fp8_set_dig\n#undef fp8_add\n#undef fp8_sub\n#undef fp8_neg\n#undef fp8_dbl\n#undef fp8_mul_unr\n#undef fp8_mul_basic\n#undef fp8_mul_lazyr\n#undef fp8_mul_art\n#undef fp8_mul_dxs\n#undef fp8_sqr_unr\n#undef fp8_sqr_basic\n#undef fp8_sqr_lazyr\n#undef fp8_sqr_cyc\n#undef fp8_inv\n#undef fp8_inv_cyc\n#undef fp8_inv_sim\n#undef fp8_test_cyc\n#undef fp8_conv_cyc\n#undef fp8_exp\n#undef fp8_exp_cyc\n#undef fp8_frb\n\n#define fp8_copy \tRLC_PREFIX(fp8_copy)\n#define fp8_zero \tRLC_PREFIX(fp8_zero)\n#define fp8_is_zero \tRLC_PREFIX(fp8_is_zero)\n#define fp8_rand \tRLC_PREFIX(fp8_rand)\n#define fp8_print \tRLC_PREFIX(fp8_print)\n#define fp8_size_bin \tRLC_PREFIX(fp8_size_bin)\n#define fp8_read_bin \tRLC_PREFIX(fp8_read_bin)\n#define fp8_write_bin \tRLC_PREFIX(fp8_write_bin)\n#define fp8_cmp \tRLC_PREFIX(fp8_cmp)\n#define fp8_cmp_dig \tRLC_PREFIX(fp8_cmp_dig)\n#define fp8_set_dig \tRLC_PREFIX(fp8_set_dig)\n#define fp8_add \tRLC_PREFIX(fp8_add)\n#define fp8_sub \tRLC_PREFIX(fp8_sub)\n#define fp8_neg \tRLC_PREFIX(fp8_neg)\n#define fp8_dbl \tRLC_PREFIX(fp8_dbl)\n#define fp8_mul_unr \tRLC_PREFIX(fp8_mul_unr)\n#define fp8_mul_basic \tRLC_PREFIX(fp8_mul_basic)\n#define fp8_mul_lazyr \tRLC_PREFIX(fp8_mul_lazyr)\n#define fp8_mul_art \tRLC_PREFIX(fp8_mul_art)\n#define fp8_mul_dxs \tRLC_PREFIX(fp8_mul_dxs)\n#define fp8_sqr_unr \tRLC_PREFIX(fp8_sqr_unr)\n#define fp8_sqr_basic \tRLC_PREFIX(fp8_sqr_basic)\n#define fp8_sqr_lazyr \tRLC_PREFIX(fp8_sqr_lazyr)\n#define fp8_sqr_cyc \tRLC_PREFIX(fp8_sqr_cyc)\n#define fp8_inv \tRLC_PREFIX(fp8_inv)\n#define fp8_inv_cyc \tRLC_PREFIX(fp8_inv_cyc)\n#define fp8_inv_sim \tRLC_PREFIX(fp8_inv_sim)\n#define fp8_test_cyc \tRLC_PREFIX(fp8_test_cyc)\n#define fp8_conv_cyc \tRLC_PREFIX(fp8_conv_cyc)\n#define fp8_exp \tRLC_PREFIX(fp8_exp)\n#define fp8_exp_cyc \tRLC_PREFIX(fp8_exp_cyc)\n#define fp8_frb \tRLC_PREFIX(fp8_frb)\n\n#undef fp9_copy\n#undef fp9_zero\n#undef fp9_is_zero\n#undef fp9_rand\n#undef fp9_print\n#undef fp9_size_bin\n#undef fp9_read_bin\n#undef fp9_write_bin\n#undef fp9_cmp\n#undef fp9_cmp_dig\n#undef fp9_set_dig\n#undef fp9_add\n#undef fp9_sub\n#undef fp9_neg\n#undef fp9_dbl\n#undef fp9_mul_unr\n#undef fp9_mul_basic\n#undef fp9_mul_lazyr\n#undef fp9_mul_art\n#undef fp9_mul_dxs\n#undef fp9_sqr_unr\n#undef fp9_sqr_basic\n#undef fp9_sqr_lazyr\n#undef fp9_inv\n#undef fp9_inv_sim\n#undef fp9_exp\n#undef fp9_frb\n\n#define fp9_copy \tRLC_PREFIX(fp9_copy)\n#define fp9_zero \tRLC_PREFIX(fp9_zero)\n#define fp9_is_zero \tRLC_PREFIX(fp9_is_zero)\n#define fp9_rand \tRLC_PREFIX(fp9_rand)\n#define fp9_print \tRLC_PREFIX(fp9_print)\n#define fp9_size_bin \tRLC_PREFIX(fp9_size_bin)\n#define fp9_read_bin \tRLC_PREFIX(fp9_read_bin)\n#define fp9_write_bin \tRLC_PREFIX(fp9_write_bin)\n#define fp9_cmp \tRLC_PREFIX(fp9_cmp)\n#define fp9_cmp_dig \tRLC_PREFIX(fp9_cmp_dig)\n#define fp9_set_dig \tRLC_PREFIX(fp9_set_dig)\n#define fp9_add \tRLC_PREFIX(fp9_add)\n#define fp9_sub \tRLC_PREFIX(fp9_sub)\n#define fp9_neg \tRLC_PREFIX(fp9_neg)\n#define fp9_dbl \tRLC_PREFIX(fp9_dbl)\n#define fp9_mul_unr \tRLC_PREFIX(fp9_mul_unr)\n#define fp9_mul_basic \tRLC_PREFIX(fp9_mul_basic)\n#define fp9_mul_lazyr \tRLC_PREFIX(fp9_mul_lazyr)\n#define fp9_mul_art \tRLC_PREFIX(fp9_mul_art)\n#define fp9_mul_dxs \tRLC_PREFIX(fp9_mul_dxs)\n#define fp9_sqr_unr \tRLC_PREFIX(fp9_sqr_unr)\n#define fp9_sqr_basic \tRLC_PREFIX(fp9_sqr_basic)\n#define fp9_sqr_lazyr \tRLC_PREFIX(fp9_sqr_lazyr)\n#define fp9_inv \tRLC_PREFIX(fp9_inv)\n#define fp9_inv_sim \tRLC_PREFIX(fp9_inv_sim)\n#define fp9_exp \tRLC_PREFIX(fp9_exp)\n#define fp9_frb \tRLC_PREFIX(fp9_frb)\n\n#undef fp12_copy\n#undef fp12_zero\n#undef fp12_is_zero\n#undef fp12_rand\n#undef fp12_print\n#undef fp12_size_bin\n#undef fp12_read_bin\n#undef fp12_write_bin\n#undef fp12_cmp\n#undef fp12_cmp_dig\n#undef fp12_set_dig\n#undef fp12_add\n#undef fp12_sub\n#undef fp12_neg\n#undef fp12_dbl\n#undef fp12_mul_unr\n#undef fp12_mul_basic\n#undef fp12_mul_lazyr\n#undef fp12_mul_art\n#undef fp12_mul_dxs_basic\n#undef fp12_mul_dxs_lazyr\n#undef fp12_sqr_unr\n#undef fp12_sqr_basic\n#undef fp12_sqr_lazyr\n#undef fp12_sqr_cyc_basic\n#undef fp12_sqr_cyc_lazyr\n#undef fp12_sqr_pck_basic\n#undef fp12_sqr_pck_lazyr\n#undef fp12_test_cyc\n#undef fp12_conv_cyc\n#undef fp12_back_cyc\n#undef fp12_back_cyc_sim\n#undef fp12_inv\n#undef fp12_inv_cyc\n#undef fp12_frb\n#undef fp12_exp\n#undef fp12_exp_dig\n#undef fp12_exp_cyc\n#undef fp12_exp_cyc_sim\n#undef fp12_exp_cyc_sps\n#undef fp12_pck\n#undef fp12_upk\n#undef fp12_pck_max\n#undef fp12_upk_max\n\n#define fp12_copy \tRLC_PREFIX(fp12_copy)\n#define fp12_zero \tRLC_PREFIX(fp12_zero)\n#define fp12_is_zero \tRLC_PREFIX(fp12_is_zero)\n#define fp12_rand \tRLC_PREFIX(fp12_rand)\n#define fp12_print \tRLC_PREFIX(fp12_print)\n#define fp12_size_bin \tRLC_PREFIX(fp12_size_bin)\n#define fp12_read_bin \tRLC_PREFIX(fp12_read_bin)\n#define fp12_write_bin \tRLC_PREFIX(fp12_write_bin)\n#define fp12_cmp \tRLC_PREFIX(fp12_cmp)\n#define fp12_cmp_dig \tRLC_PREFIX(fp12_cmp_dig)\n#define fp12_set_dig \tRLC_PREFIX(fp12_set_dig)\n#define fp12_add \tRLC_PREFIX(fp12_add)\n#define fp12_sub \tRLC_PREFIX(fp12_sub)\n#define fp12_neg \tRLC_PREFIX(fp12_neg)\n#define fp12_dbl \tRLC_PREFIX(fp12_dbl)\n#define fp12_mul_unr \tRLC_PREFIX(fp12_mul_unr)\n#define fp12_mul_basic \tRLC_PREFIX(fp12_mul_basic)\n#define fp12_mul_lazyr \tRLC_PREFIX(fp12_mul_lazyr)\n#define fp12_mul_art \tRLC_PREFIX(fp12_mul_art)\n#define fp12_mul_dxs_basic \tRLC_PREFIX(fp12_mul_dxs_basic)\n#define fp12_mul_dxs_lazyr \tRLC_PREFIX(fp12_mul_dxs_lazyr)\n#define fp12_sqr_unr \tRLC_PREFIX(fp12_sqr_unr)\n#define fp12_sqr_basic \tRLC_PREFIX(fp12_sqr_basic)\n#define fp12_sqr_lazyr \tRLC_PREFIX(fp12_sqr_lazyr)\n#define fp12_sqr_cyc_basic \tRLC_PREFIX(fp12_sqr_cyc_basic)\n#define fp12_sqr_cyc_lazyr \tRLC_PREFIX(fp12_sqr_cyc_lazyr)\n#define fp12_sqr_pck_basic \tRLC_PREFIX(fp12_sqr_pck_basic)\n#define fp12_sqr_pck_lazyr \tRLC_PREFIX(fp12_sqr_pck_lazyr)\n#define fp12_test_cyc \tRLC_PREFIX(fp12_test_cyc)\n#define fp12_conv_cyc \tRLC_PREFIX(fp12_conv_cyc)\n#define fp12_back_cyc \tRLC_PREFIX(fp12_back_cyc)\n#define fp12_back_cyc_sim \tRLC_PREFIX(fp12_back_cyc_sim)\n#define fp12_inv \tRLC_PREFIX(fp12_inv)\n#define fp12_inv_cyc \tRLC_PREFIX(fp12_inv_cyc)\n#define fp12_frb \tRLC_PREFIX(fp12_frb)\n#define fp12_exp \tRLC_PREFIX(fp12_exp)\n#define fp12_exp_dig \tRLC_PREFIX(fp12_exp_dig)\n#define fp12_exp_cyc \tRLC_PREFIX(fp12_exp_cyc)\n#define fp12_exp_cyc_sim \tRLC_PREFIX(fp12_exp_cyc_sim)\n#define fp12_exp_cyc_sps \tRLC_PREFIX(fp12_exp_cyc_sps)\n#define fp12_pck \tRLC_PREFIX(fp12_pck)\n#define fp12_upk \tRLC_PREFIX(fp12_upk)\n#define fp12_pck_max \tRLC_PREFIX(fp12_pck_max)\n#define fp12_upk_max \tRLC_PREFIX(fp12_upk_max)\n\n#undef fp18_copy\n#undef fp18_zero\n#undef fp18_is_zero\n#undef fp18_rand\n#undef fp18_print\n#undef fp18_size_bin\n#undef fp18_read_bin\n#undef fp18_write_bin\n#undef fp18_cmp\n#undef fp18_cmp_dig\n#undef fp18_set_dig\n#undef fp18_add\n#undef fp18_sub\n#undef fp18_neg\n#undef fp18_dbl\n#undef fp18_mul_unr\n#undef fp18_mul_basic\n#undef fp18_mul_lazyr\n#undef fp18_mul_art\n#undef fp18_mul_dxs_basic\n#undef fp18_mul_dxs_lazyr\n#undef fp18_sqr_unr\n#undef fp18_sqr_basic\n#undef fp18_sqr_lazyr\n#undef fp18_inv\n#undef fp18_inv_cyc\n#undef fp18_conv_cyc\n#undef fp18_frb\n#undef fp18_exp\n\n#define fp18_copy \tRLC_PREFIX(fp18_copy)\n#define fp18_zero \tRLC_PREFIX(fp18_zero)\n#define fp18_is_zero \tRLC_PREFIX(fp18_is_zero)\n#define fp18_rand \tRLC_PREFIX(fp18_rand)\n#define fp18_print \tRLC_PREFIX(fp18_print)\n#define fp18_size_bin \tRLC_PREFIX(fp18_size_bin)\n#define fp18_read_bin \tRLC_PREFIX(fp18_read_bin)\n#define fp18_write_bin \tRLC_PREFIX(fp18_write_bin)\n#define fp18_cmp \tRLC_PREFIX(fp18_cmp)\n#define fp18_cmp_dig \tRLC_PREFIX(fp18_cmp_dig)\n#define fp18_set_dig \tRLC_PREFIX(fp18_set_dig)\n#define fp18_add \tRLC_PREFIX(fp18_add)\n#define fp18_sub \tRLC_PREFIX(fp18_sub)\n#define fp18_neg \tRLC_PREFIX(fp18_neg)\n#define fp18_dbl \tRLC_PREFIX(fp18_dbl)\n#define fp18_mul_unr \tRLC_PREFIX(fp18_mul_unr)\n#define fp18_mul_basic \tRLC_PREFIX(fp18_mul_basic)\n#define fp18_mul_lazyr \tRLC_PREFIX(fp18_mul_lazyr)\n#define fp18_mul_art \tRLC_PREFIX(fp18_mul_art)\n#define fp18_mul_dxs_basic \tRLC_PREFIX(fp18_mul_dxs_basic)\n#define fp18_mul_dxs_lazyr \tRLC_PREFIX(fp18_mul_dxs_lazyr)\n#define fp18_sqr_unr \tRLC_PREFIX(fp18_sqr_unr)\n#define fp18_sqr_basic \tRLC_PREFIX(fp18_sqr_basic)\n#define fp18_sqr_lazyr \tRLC_PREFIX(fp18_sqr_lazyr)\n#define fp18_inv \tRLC_PREFIX(fp18_inv)\n#define fp18_inv_cyc \tRLC_PREFIX(fp18_inv_cyc)\n#define fp18_conv_cyc \tRLC_PREFIX(fp18_conv_cyc)\n#define fp18_frb \tRLC_PREFIX(fp18_frb)\n#define fp18_exp \tRLC_PREFIX(fp18_exp)\n\n#undef fp24_copy\n#undef fp24_zero\n#undef fp24_is_zero\n#undef fp24_rand\n#undef fp24_print\n#undef fp24_size_bin\n#undef fp24_read_bin\n#undef fp24_write_bin\n#undef fp24_cmp\n#undef fp24_cmp_dig\n#undef fp24_set_dig\n#undef fp24_add\n#undef fp24_sub\n#undef fp24_neg\n#undef fp24_dbl\n#undef fp24_mul_unr\n#undef fp24_mul_basic\n#undef fp24_mul_lazyr\n#undef fp24_mul_art\n#undef fp24_mul_dxs\n#undef fp24_sqr_unr\n#undef fp24_sqr_basic\n#undef fp24_sqr_lazyr\n#undef fp24_sqr_cyc_basic\n#undef fp24_sqr_cyc_lazyr\n#undef fp24_sqr_pck_basic\n#undef fp24_sqr_pck_lazyr\n#undef fp24_test_cyc\n#undef fp24_conv_cyc\n#undef fp24_back_cyc\n#undef fp24_back_cyc_sim\n#undef fp24_inv\n#undef fp24_inv_cyc\n#undef fp24_frb\n#undef fp24_exp\n#undef fp24_exp_dig\n#undef fp24_exp_cyc\n#undef fp24_exp_cyc_sim\n#undef fp24_exp_cyc_sps\n#undef fp24_pck\n#undef fp24_upk\n\n#define fp24_copy \tRLC_PREFIX(fp24_copy)\n#define fp24_zero \tRLC_PREFIX(fp24_zero)\n#define fp24_is_zero \tRLC_PREFIX(fp24_is_zero)\n#define fp24_rand \tRLC_PREFIX(fp24_rand)\n#define fp24_print \tRLC_PREFIX(fp24_print)\n#define fp24_size_bin \tRLC_PREFIX(fp24_size_bin)\n#define fp24_read_bin \tRLC_PREFIX(fp24_read_bin)\n#define fp24_write_bin \tRLC_PREFIX(fp24_write_bin)\n#define fp24_cmp \tRLC_PREFIX(fp24_cmp)\n#define fp24_cmp_dig \tRLC_PREFIX(fp24_cmp_dig)\n#define fp24_set_dig \tRLC_PREFIX(fp24_set_dig)\n#define fp24_add \tRLC_PREFIX(fp24_add)\n#define fp24_sub \tRLC_PREFIX(fp24_sub)\n#define fp24_neg \tRLC_PREFIX(fp24_neg)\n#define fp24_dbl \tRLC_PREFIX(fp24_dbl)\n#define fp24_mul_unr \tRLC_PREFIX(fp24_mul_unr)\n#define fp24_mul_basic \tRLC_PREFIX(fp24_mul_basic)\n#define fp24_mul_lazyr \tRLC_PREFIX(fp24_mul_lazyr)\n#define fp24_mul_art \tRLC_PREFIX(fp24_mul_art)\n#define fp24_mul_dxs \tRLC_PREFIX(fp24_mul_dxs)\n#define fp24_sqr_unr \tRLC_PREFIX(fp24_sqr_unr)\n#define fp24_sqr_basic \tRLC_PREFIX(fp24_sqr_basic)\n#define fp24_sqr_lazyr \tRLC_PREFIX(fp24_sqr_lazyr)\n#define fp24_sqr_cyc_basic \tRLC_PREFIX(fp24_sqr_cyc_basic)\n#define fp24_sqr_cyc_lazyr \tRLC_PREFIX(fp24_sqr_cyc_lazyr)\n#define fp24_sqr_pck_basic \tRLC_PREFIX(fp24_sqr_pck_basic)\n#define fp24_sqr_pck_lazyr \tRLC_PREFIX(fp24_sqr_pck_lazyr)\n#define fp24_test_cyc \tRLC_PREFIX(fp24_test_cyc)\n#define fp24_conv_cyc \tRLC_PREFIX(fp24_conv_cyc)\n#define fp24_back_cyc \tRLC_PREFIX(fp24_back_cyc)\n#define fp24_back_cyc_sim \tRLC_PREFIX(fp24_back_cyc_sim)\n#define fp24_inv \tRLC_PREFIX(fp24_inv)\n#define fp24_inv_cyc \tRLC_PREFIX(fp24_inv_cyc)\n#define fp24_frb \tRLC_PREFIX(fp24_frb)\n#define fp24_exp \tRLC_PREFIX(fp24_exp)\n#define fp24_exp_dig \tRLC_PREFIX(fp24_exp_dig)\n#define fp24_exp_cyc \tRLC_PREFIX(fp24_exp_cyc)\n#define fp24_exp_cyc_sim \tRLC_PREFIX(fp24_exp_cyc_sim)\n#define fp24_exp_cyc_sps \tRLC_PREFIX(fp24_exp_cyc_sps)\n#define fp24_pck \tRLC_PREFIX(fp24_pck)\n#define fp24_upk \tRLC_PREFIX(fp24_upk)\n\n#undef fp48_copy\n#undef fp48_zero\n#undef fp48_is_zero\n#undef fp48_rand\n#undef fp48_print\n#undef fp48_size_bin\n#undef fp48_read_bin\n#undef fp48_write_bin\n#undef fp48_cmp\n#undef fp48_cmp_dig\n#undef fp48_set_dig\n#undef fp48_add\n#undef fp48_sub\n#undef fp48_neg\n#undef fp48_dbl\n#undef fp48_mul_basic\n#undef fp48_mul_lazyr\n#undef fp48_mul_art\n#undef fp48_mul_dxs\n#undef fp48_sqr_basic\n#undef fp48_sqr_lazyr\n#undef fp48_sqr_cyc_basic\n#undef fp48_sqr_cyc_lazyr\n#undef fp48_sqr_pck_basic\n#undef fp48_sqr_pck_lazyr\n#undef fp48_test_cyc\n#undef fp48_conv_cyc\n#undef fp48_back_cyc\n#undef fp48_back_cyc_sim\n#undef fp48_inv\n#undef fp48_inv_cyc\n#undef fp48_frb\n#undef fp48_exp\n#undef fp48_exp_dig\n#undef fp48_exp_cyc\n#undef fp48_exp_cyc_sps\n#undef fp48_pck\n#undef fp48_upk\n\n#define fp48_copy \tRLC_PREFIX(fp48_copy)\n#define fp48_zero \tRLC_PREFIX(fp48_zero)\n#define fp48_is_zero \tRLC_PREFIX(fp48_is_zero)\n#define fp48_rand \tRLC_PREFIX(fp48_rand)\n#define fp48_print \tRLC_PREFIX(fp48_print)\n#define fp48_size_bin \tRLC_PREFIX(fp48_size_bin)\n#define fp48_read_bin \tRLC_PREFIX(fp48_read_bin)\n#define fp48_write_bin \tRLC_PREFIX(fp48_write_bin)\n#define fp48_cmp \tRLC_PREFIX(fp48_cmp)\n#define fp48_cmp_dig \tRLC_PREFIX(fp48_cmp_dig)\n#define fp48_set_dig \tRLC_PREFIX(fp48_set_dig)\n#define fp48_add \tRLC_PREFIX(fp48_add)\n#define fp48_sub \tRLC_PREFIX(fp48_sub)\n#define fp48_neg \tRLC_PREFIX(fp48_neg)\n#define fp48_dbl \tRLC_PREFIX(fp48_dbl)\n#define fp48_mul_basic \tRLC_PREFIX(fp48_mul_basic)\n#define fp48_mul_lazyr \tRLC_PREFIX(fp48_mul_lazyr)\n#define fp48_mul_art \tRLC_PREFIX(fp48_mul_art)\n#define fp48_mul_dxs \tRLC_PREFIX(fp48_mul_dxs)\n#define fp48_sqr_basic \tRLC_PREFIX(fp48_sqr_basic)\n#define fp48_sqr_lazyr \tRLC_PREFIX(fp48_sqr_lazyr)\n#define fp48_sqr_cyc_basic \tRLC_PREFIX(fp48_sqr_cyc_basic)\n#define fp48_sqr_cyc_lazyr \tRLC_PREFIX(fp48_sqr_cyc_lazyr)\n#define fp48_sqr_pck_basic \tRLC_PREFIX(fp48_sqr_pck_basic)\n#define fp48_sqr_pck_lazyr \tRLC_PREFIX(fp48_sqr_pck_lazyr)\n#define fp48_test_cyc \tRLC_PREFIX(fp48_test_cyc)\n#define fp48_conv_cyc \tRLC_PREFIX(fp48_conv_cyc)\n#define fp48_back_cyc \tRLC_PREFIX(fp48_back_cyc)\n#define fp48_back_cyc_sim \tRLC_PREFIX(fp48_back_cyc_sim)\n#define fp48_inv \tRLC_PREFIX(fp48_inv)\n#define fp48_inv_cyc \tRLC_PREFIX(fp48_inv_cyc)\n#define fp48_frb \tRLC_PREFIX(fp48_frb)\n#define fp48_exp \tRLC_PREFIX(fp48_exp)\n#define fp48_exp_dig \tRLC_PREFIX(fp48_exp_dig)\n#define fp48_exp_cyc \tRLC_PREFIX(fp48_exp_cyc)\n#define fp48_exp_cyc_sps \tRLC_PREFIX(fp48_exp_cyc_sps)\n#define fp48_pck \tRLC_PREFIX(fp48_pck)\n#define fp48_upk \tRLC_PREFIX(fp48_upk)\n\n#undef fp54_copy\n#undef fp54_zero\n#undef fp54_is_zero\n#undef fp54_rand\n#undef fp54_print\n#undef fp54_size_bin\n#undef fp54_read_bin\n#undef fp54_write_bin\n#undef fp54_cmp\n#undef fp54_cmp_dig\n#undef fp54_set_dig\n#undef fp54_add\n#undef fp54_sub\n#undef fp54_neg\n#undef fp54_dbl\n#undef fp54_mul_basic\n#undef fp54_mul_lazyr\n#undef fp54_mul_art\n#undef fp54_mul_dxs\n#undef fp54_sqr_basic\n#undef fp54_sqr_lazyr\n#undef fp54_sqr_cyc_basic\n#undef fp54_sqr_cyc_lazyr\n#undef fp54_sqr_pck_basic\n#undef fp54_sqr_pck_lazyr\n#undef fp54_test_cyc\n#undef fp54_conv_cyc\n#undef fp54_back_cyc\n#undef fp54_back_cyc_sim\n#undef fp54_inv\n#undef fp54_inv_cyc\n#undef fp54_frb\n#undef fp54_exp\n#undef fp54_exp_dig\n#undef fp54_exp_cyc\n#undef fp54_exp_cyc_sps\n#undef fp54_pck\n#undef fp54_upk\n\n#define fp54_copy \tRLC_PREFIX(fp54_copy)\n#define fp54_zero \tRLC_PREFIX(fp54_zero)\n#define fp54_is_zero \tRLC_PREFIX(fp54_is_zero)\n#define fp54_rand \tRLC_PREFIX(fp54_rand)\n#define fp54_print \tRLC_PREFIX(fp54_print)\n#define fp54_size_bin \tRLC_PREFIX(fp54_size_bin)\n#define fp54_read_bin \tRLC_PREFIX(fp54_read_bin)\n#define fp54_write_bin \tRLC_PREFIX(fp54_write_bin)\n#define fp54_cmp \tRLC_PREFIX(fp54_cmp)\n#define fp54_cmp_dig \tRLC_PREFIX(fp54_cmp_dig)\n#define fp54_set_dig \tRLC_PREFIX(fp54_set_dig)\n#define fp54_add \tRLC_PREFIX(fp54_add)\n#define fp54_sub \tRLC_PREFIX(fp54_sub)\n#define fp54_neg \tRLC_PREFIX(fp54_neg)\n#define fp54_dbl \tRLC_PREFIX(fp54_dbl)\n#define fp54_mul_basic \tRLC_PREFIX(fp54_mul_basic)\n#define fp54_mul_lazyr \tRLC_PREFIX(fp54_mul_lazyr)\n#define fp54_mul_art \tRLC_PREFIX(fp54_mul_art)\n#define fp54_mul_dxs \tRLC_PREFIX(fp54_mul_dxs)\n#define fp54_sqr_basic \tRLC_PREFIX(fp54_sqr_basic)\n#define fp54_sqr_lazyr \tRLC_PREFIX(fp54_sqr_lazyr)\n#define fp54_sqr_cyc_basic \tRLC_PREFIX(fp54_sqr_cyc_basic)\n#define fp54_sqr_cyc_lazyr \tRLC_PREFIX(fp54_sqr_cyc_lazyr)\n#define fp54_sqr_pck_basic \tRLC_PREFIX(fp54_sqr_pck_basic)\n#define fp54_sqr_pck_lazyr \tRLC_PREFIX(fp54_sqr_pck_lazyr)\n#define fp54_test_cyc \tRLC_PREFIX(fp54_test_cyc)\n#define fp54_conv_cyc \tRLC_PREFIX(fp54_conv_cyc)\n#define fp54_back_cyc \tRLC_PREFIX(fp54_back_cyc)\n#define fp54_back_cyc_sim \tRLC_PREFIX(fp54_back_cyc_sim)\n#define fp54_inv \tRLC_PREFIX(fp54_inv)\n#define fp54_inv_cyc \tRLC_PREFIX(fp54_inv_cyc)\n#define fp54_frb \tRLC_PREFIX(fp54_frb)\n#define fp54_exp \tRLC_PREFIX(fp54_exp)\n#define fp54_exp_dig \tRLC_PREFIX(fp54_exp_dig)\n#define fp54_exp_cyc \tRLC_PREFIX(fp54_exp_cyc)\n#define fp54_exp_cyc_sps \tRLC_PREFIX(fp54_exp_cyc_sps)\n#define fp54_pck \tRLC_PREFIX(fp54_pck)\n#define fp54_upk \tRLC_PREFIX(fp54_upk)\n\n#undef fb2_mul\n #undef fb2_mul_nor\n#undef fb2_sqr\n#undef fb2_slv\n#undef fb2_inv\n\n#define fb2_mul \tRLC_PREFIX(fb2_mul)\n #define fb2_mul_nor \tRLC_PREFIX(fb2_mul_nor)\n#define fb2_sqr \tRLC_PREFIX(fb2_sqr)\n#define fb2_slv \tRLC_PREFIX(fb2_slv)\n#define fb2_inv \tRLC_PREFIX(fb2_inv)\n\n\n\n#undef pp_map_init\n#undef pp_map_clean\n#undef pp_add_k2_basic\n#undef pp_add_k2_projc_basic\n#undef pp_add_k2_projc_lazyr\n#undef pp_add_k8_basic\n#undef pp_add_k8_projc_basic\n#undef pp_add_k8_projc_lazyr\n#undef pp_add_k12_basic\n#undef pp_add_k12_projc_basic\n#undef pp_add_k12_projc_lazyr\n#undef pp_add_lit_k12\n#undef pp_add_k24_basic\n#undef pp_add_k24_projc\n#undef pp_add_k48_basic\n#undef pp_add_k48_projc\n#undef pp_add_k54_basic\n#undef pp_add_k54_projc\n#undef pp_dbl_k2_basic\n#undef pp_dbl_k2_projc_basic\n#undef pp_dbl_k2_projc_lazyr\n#undef pp_dbl_k8_basic\n#undef pp_dbl_k8_projc_basic\n#undef pp_dbl_k8_projc_lazyr\n#undef pp_dbl_k12_basic\n#undef pp_dbl_k12_projc_basic\n#undef pp_dbl_k12_projc_lazyr\n#undef pp_dbl_k24_basic\n#undef pp_dbl_k24_projc\n#undef pp_dbl_k48_basic\n#undef pp_dbl_k48_projc\n#undef pp_dbl_k54_basic\n#undef pp_dbl_k54_projc\n#undef pp_dbl_lit_k12\n#undef pp_exp_k2\n#undef pp_exp_k8\n#undef pp_exp_k12\n#undef pp_exp_k24\n#undef pp_exp_k48\n#undef pp_exp_k54\n#undef pp_norm_k2\n#undef pp_norm_k8\n#undef pp_norm_k12\n#undef pp_norm_k24\n#undef pp_map_tatep_k2\n#undef pp_map_sim_tatep_k2\n#undef pp_map_weilp_k2\n#undef pp_map_oatep_k8\n#undef pp_map_sim_weilp_k2\n#undef pp_map_tatep_k12\n#undef pp_map_sim_tatep_k12\n#undef pp_map_weilp_k12\n#undef pp_map_sim_weilp_k12\n#undef pp_map_oatep_k12\n#undef pp_map_sim_oatep_k12\n#undef pp_map_k24\n#undef pp_map_sim_k24\n#undef pp_map_k48\n#undef pp_map_k54\n\n#define pp_map_init \tRLC_PREFIX(pp_map_init)\n#define pp_map_clean \tRLC_PREFIX(pp_map_clean)\n#define pp_add_k2_basic \tRLC_PREFIX(pp_add_k2_basic)\n#define pp_add_k2_projc_basic \tRLC_PREFIX(pp_add_k2_projc_basic)\n#define pp_add_k2_projc_lazyr \tRLC_PREFIX(pp_add_k2_projc_lazyr)\n#define pp_add_k8_basic \tRLC_PREFIX(pp_add_k8_basic)\n#define pp_add_k8_projc_basic \tRLC_PREFIX(pp_add_k8_projc_basic)\n#define pp_add_k8_projc_lazyr \tRLC_PREFIX(pp_add_k8_projc_lazyr)\n#define pp_add_k12_basic \tRLC_PREFIX(pp_add_k12_basic)\n#define pp_add_k12_projc_basic \tRLC_PREFIX(pp_add_k12_projc_basic)\n#define pp_add_k12_projc_lazyr \tRLC_PREFIX(pp_add_k12_projc_lazyr)\n#define pp_add_lit_k12 \tRLC_PREFIX(pp_add_lit_k12)\n#define pp_add_k24_basic \tRLC_PREFIX(pp_add_k24_basic)\n#define pp_add_k24_projc \tRLC_PREFIX(pp_add_k24_projc)\n#define pp_add_k48_basic \tRLC_PREFIX(pp_add_k48_basic)\n#define pp_add_k48_projc \tRLC_PREFIX(pp_add_k48_projc)\n#define pp_add_k54_basic \tRLC_PREFIX(pp_add_k54_basic)\n#define pp_add_k54_projc \tRLC_PREFIX(pp_add_k54_projc)\n#define pp_dbl_k2_basic \tRLC_PREFIX(pp_dbl_k2_basic)\n#define pp_dbl_k2_projc_basic \tRLC_PREFIX(pp_dbl_k2_projc_basic)\n#define pp_dbl_k2_projc_lazyr \tRLC_PREFIX(pp_dbl_k2_projc_lazyr)\n#define pp_dbl_k8_basic \tRLC_PREFIX(pp_dbl_k8_basic)\n#define pp_dbl_k8_projc_basic \tRLC_PREFIX(pp_dbl_k8_projc_basic)\n#define pp_dbl_k8_projc_lazyr \tRLC_PREFIX(pp_dbl_k8_projc_lazyr)\n#define pp_dbl_k12_basic \tRLC_PREFIX(pp_dbl_k12_basic)\n#define pp_dbl_k12_projc_basic \tRLC_PREFIX(pp_dbl_k12_projc_basic)\n#define pp_dbl_k12_projc_lazyr \tRLC_PREFIX(pp_dbl_k12_projc_lazyr)\n#define pp_dbl_k24_basic \tRLC_PREFIX(pp_dbl_k24_basic)\n#define pp_dbl_k24_projc \tRLC_PREFIX(pp_dbl_k24_projc)\n#define pp_dbl_k48_basic \tRLC_PREFIX(pp_dbl_k48_basic)\n#define pp_dbl_k48_projc \tRLC_PREFIX(pp_dbl_k48_projc)\n#define pp_dbl_k54_basic \tRLC_PREFIX(pp_dbl_k54_basic)\n#define pp_dbl_k54_projc \tRLC_PREFIX(pp_dbl_k54_projc)\n#define pp_dbl_lit_k12 \tRLC_PREFIX(pp_dbl_lit_k12)\n#define pp_exp_k2 \tRLC_PREFIX(pp_exp_k2)\n#define pp_exp_k8 \tRLC_PREFIX(pp_exp_k8)\n#define pp_exp_k12 \tRLC_PREFIX(pp_exp_k12)\n#define pp_exp_k24 \tRLC_PREFIX(pp_exp_k24)\n#define pp_exp_k48 \tRLC_PREFIX(pp_exp_k48)\n#define pp_exp_k54 \tRLC_PREFIX(pp_exp_k54)\n#define pp_norm_k2 \tRLC_PREFIX(pp_norm_k2)\n#define pp_norm_k8 \tRLC_PREFIX(pp_norm_k8)\n#define pp_norm_k12 \tRLC_PREFIX(pp_norm_k12)\n#define pp_norm_k24 \tRLC_PREFIX(pp_norm_k24)\n#define pp_map_tatep_k2 \tRLC_PREFIX(pp_map_tatep_k2)\n#define pp_map_sim_tatep_k2 \tRLC_PREFIX(pp_map_sim_tatep_k2)\n#define pp_map_weilp_k2 \tRLC_PREFIX(pp_map_weilp_k2)\n#define pp_map_oatep_k8 \tRLC_PREFIX(pp_map_oatep_k8)\n#define pp_map_sim_weilp_k2 \tRLC_PREFIX(pp_map_sim_weilp_k2)\n#define pp_map_tatep_k12 \tRLC_PREFIX(pp_map_tatep_k12)\n#define pp_map_sim_tatep_k12 \tRLC_PREFIX(pp_map_sim_tatep_k12)\n#define pp_map_weilp_k12 \tRLC_PREFIX(pp_map_weilp_k12)\n#define pp_map_sim_weilp_k12 \tRLC_PREFIX(pp_map_sim_weilp_k12)\n#define pp_map_oatep_k12 \tRLC_PREFIX(pp_map_oatep_k12)\n#define pp_map_sim_oatep_k12 \tRLC_PREFIX(pp_map_sim_oatep_k12)\n#define pp_map_k24 \tRLC_PREFIX(pp_map_k24)\n#define pp_map_sim_k24 \tRLC_PREFIX(pp_map_sim_k24)\n#define pp_map_k48 \tRLC_PREFIX(pp_map_k48)\n#define pp_map_k54 \tRLC_PREFIX(pp_map_k54)\n\n#undef pc_core_init\n#undef pc_core_calc\n#undef pc_core_clean\n\n#define pc_core_init \tRLC_PREFIX(pc_core_init)\n#define pc_core_calc \tRLC_PREFIX(pc_core_calc)\n#define pc_core_clean \tRLC_PREFIX(pc_core_clean)\n\n#undef mpc_mt_gen\n#undef mpc_mt_lcl\n#undef mpc_mt_bct\n#undef mpc_mt_mul\n#undef mpc_sss_gen\n#undef mpc_sss_key\n\n#define mpc_mt_gen \tRLC_PREFIX(mpc_mt_gen)\n#define mpc_mt_lcl \tRLC_PREFIX(mpc_mt_lcl)\n#define mpc_mt_bct \tRLC_PREFIX(mpc_mt_bct)\n#define mpc_mt_mul \tRLC_PREFIX(mpc_mt_mul)\n#define mpc_sss_gen \tRLC_PREFIX(mpc_sss_gen)\n#define mpc_sss_key \tRLC_PREFIX(mpc_sss_key)\n\n#undef crt_t\n#undef rsa_t\n#undef rabin_t\n#undef phpe_t\n#undef bdpe_t\n#undef sokaka_t\n#define crt_t\tRLC_PREFIX(crt_t)\n#define rsa_t\tRLC_PREFIX(rsa_t)\n#define rabin_t\tRLC_PREFIX(rabin_t)\n#define phpe_t\tRLC_PREFIX(phpe_t)\n#define bdpe_t\tRLC_PREFIX(bdpe_t)\n#define sokaka_t\tRLC_PREFIX(sokaka_t)\n\n#undef cp_rsa_gen\n#undef cp_rsa_enc\n#undef cp_rsa_dec\n#undef cp_rsa_sig\n#undef cp_rsa_ver\n#undef cp_rabin_gen\n#undef cp_rabin_enc\n#undef cp_rabin_dec\n#undef cp_bdpe_gen\n#undef cp_bdpe_enc\n#undef cp_bdpe_dec\n#undef cp_phpe_gen\n#undef cp_phpe_enc\n#undef cp_phpe_add\n#undef cp_phpe_dec\n#undef cp_shpe_gen\n#undef cp_shpe_enc\n#undef cp_shpe_enc_prv\n#undef cp_shpe_dec\n#undef cp_ghpe_gen\n#undef cp_ghpe_enc\n#undef cp_ghpe_dec\n#undef cp_ecdh_gen\n#undef cp_ecdh_key\n#undef cp_ecmqv_gen\n#undef cp_ecmqv_key\n#undef cp_ecies_gen\n#undef cp_ecies_enc\n#undef cp_ecies_dec\n#undef cp_ecdsa_gen\n#undef cp_ecdsa_sig\n#undef cp_ecdsa_ver\n#undef cp_ecss_gen\n#undef cp_ecss_sig\n#undef cp_ecss_ver\n#undef cp_pdpub_gen\n#undef cp_pdpub_ask\n#undef cp_pdpub_ans\n#undef cp_pdpub_ver\n#undef cp_pdprv_gen\n#undef cp_pdprv_ask\n#undef cp_pdprv_ans\n#undef cp_pdprv_ver\n#undef cp_lvpub_gen\n#undef cp_lvpub_ask\n#undef cp_lvpub_ans\n#undef cp_lvpub_ver\n#undef cp_lvprv_gen\n#undef cp_lvprv_ask\n#undef cp_lvprv_ans\n#undef cp_lvprv_ver\n#undef cp_sokaka_gen\n#undef cp_sokaka_gen_prv\n#undef cp_sokaka_key\n#undef cp_bgn_gen\n#undef cp_bgn_enc1\n#undef cp_bgn_dec1\n#undef cp_bgn_enc2\n#undef cp_bgn_dec2\n#undef cp_bgn_add\n#undef cp_bgn_mul\n#undef cp_bgn_dec\n#undef cp_ibe_gen\n#undef cp_ibe_gen_prv\n#undef cp_ibe_enc\n#undef cp_ibe_dec\n#undef cp_bls_gen\n#undef cp_bls_sig\n#undef cp_bls_ver\n#undef cp_bbs_gen\n#undef cp_bbs_sig\n#undef cp_bbs_ver\n#undef cp_cls_gen\n#undef cp_cls_sig\n#undef cp_cls_ver\n#undef cp_cli_gen\n#undef cp_cli_sig\n#undef cp_cli_ver\n#undef cp_clb_gen\n#undef cp_clb_sig\n#undef cp_clb_ver\n#undef cp_pss_gen\n#undef cp_pss_sig\n#undef cp_pss_ver\n#undef cp_mpss_gen\n#undef cp_mpss_sig\n#undef cp_mpss_bct\n#undef cp_mpss_ver\n#undef cp_psb_gen\n#undef cp_psb_sig\n#undef cp_psb_ver\n#undef cp_mpsb_gen\n#undef cp_mpsb_sig\n#undef cp_mpsb_bct\n#undef cp_mpsb_ver\n#undef cp_zss_gen\n#undef cp_zss_sig\n#undef cp_zss_ver\n#undef cp_vbnn_gen\n#undef cp_vbnn_gen_prv\n#undef cp_vbnn_sig\n#undef cp_vbnn_ver\n#undef cp_pokdl_prv\n#undef cp_pokdl_ver\n#undef cp_pokor_prv\n#undef cp_pokor_ver\n#undef cp_sokdl_sig\n#undef cp_sokdl_ver\n#undef cp_sokor_sig\n#undef cp_sokor_ver\n#undef cp_ers_gen\n#undef cp_ers_gen_key\n#undef cp_ers_sig\n#undef cp_ers_ver\n#undef cp_ers_ext\n#undef cp_smlers_sig\n#undef cp_smlers_ver\n#undef cp_smlers_ext\n#undef cp_etrs_sig\n#undef cp_etrs_ver\n#undef cp_etrs_ext\n#undef cp_etrs_uni\n#undef cp_cmlhs_init\n#undef cp_cmlhs_gen\n#undef cp_cmlhs_sig\n#undef cp_cmlhs_fun\n#undef cp_cmlhs_evl\n#undef cp_cmlhs_ver\n#undef cp_cmlhs_off\n#undef cp_cmlhs_onv\n#undef cp_mklhs_gen\n#undef cp_mklhs_sig\n#undef cp_mklhs_fun\n#undef cp_mklhs_evl\n#undef cp_mklhs_ver\n#undef cp_mklhs_off\n#undef cp_mklhs_onv\n#undef cp_rsapsi_gen\n#undef cp_rsapsi_ask\n#undef cp_rsapsi_ans\n#undef cp_rsapsi_int\n#undef cp_shipsi_gen\n#undef cp_shipsi_ask\n#undef cp_shipsi_ans\n#undef cp_shipsi_int\n#undef cp_pbpsi_gen\n#undef cp_pbpsi_ask\n#undef cp_pbpsi_ans\n#undef cp_pbpsi_int\n\n#define cp_rsa_gen \tRLC_PREFIX(cp_rsa_gen)\n#define cp_rsa_enc \tRLC_PREFIX(cp_rsa_enc)\n#define cp_rsa_dec \tRLC_PREFIX(cp_rsa_dec)\n#define cp_rsa_sig \tRLC_PREFIX(cp_rsa_sig)\n#define cp_rsa_ver \tRLC_PREFIX(cp_rsa_ver)\n#define cp_rabin_gen \tRLC_PREFIX(cp_rabin_gen)\n#define cp_rabin_enc \tRLC_PREFIX(cp_rabin_enc)\n#define cp_rabin_dec \tRLC_PREFIX(cp_rabin_dec)\n#define cp_bdpe_gen \tRLC_PREFIX(cp_bdpe_gen)\n#define cp_bdpe_enc \tRLC_PREFIX(cp_bdpe_enc)\n#define cp_bdpe_dec \tRLC_PREFIX(cp_bdpe_dec)\n#define cp_phpe_gen \tRLC_PREFIX(cp_phpe_gen)\n#define cp_phpe_enc \tRLC_PREFIX(cp_phpe_enc)\n#define cp_phpe_add \tRLC_PREFIX(cp_phpe_add)\n#define cp_phpe_dec \tRLC_PREFIX(cp_phpe_dec)\n#define cp_shpe_gen \tRLC_PREFIX(cp_shpe_gen)\n#define cp_shpe_enc \tRLC_PREFIX(cp_shpe_enc)\n#define cp_shpe_enc_prv \tRLC_PREFIX(cp_shpe_enc_prv)\n#define cp_shpe_dec \tRLC_PREFIX(cp_shpe_dec)\n#define cp_ghpe_gen \tRLC_PREFIX(cp_ghpe_gen)\n#define cp_ghpe_enc \tRLC_PREFIX(cp_ghpe_enc)\n#define cp_ghpe_dec \tRLC_PREFIX(cp_ghpe_dec)\n#define cp_ecdh_gen \tRLC_PREFIX(cp_ecdh_gen)\n#define cp_ecdh_key \tRLC_PREFIX(cp_ecdh_key)\n#define cp_ecmqv_gen \tRLC_PREFIX(cp_ecmqv_gen)\n#define cp_ecmqv_key \tRLC_PREFIX(cp_ecmqv_key)\n#define cp_ecies_gen \tRLC_PREFIX(cp_ecies_gen)\n#define cp_ecies_enc \tRLC_PREFIX(cp_ecies_enc)\n#define cp_ecies_dec \tRLC_PREFIX(cp_ecies_dec)\n#define cp_ecdsa_gen \tRLC_PREFIX(cp_ecdsa_gen)\n#define cp_ecdsa_sig \tRLC_PREFIX(cp_ecdsa_sig)\n#define cp_ecdsa_ver \tRLC_PREFIX(cp_ecdsa_ver)\n#define cp_ecss_gen \tRLC_PREFIX(cp_ecss_gen)\n#define cp_ecss_sig \tRLC_PREFIX(cp_ecss_sig)\n#define cp_ecss_ver \tRLC_PREFIX(cp_ecss_ver)\n#define cp_pdpub_gen \tRLC_PREFIX(cp_pdpub_gen)\n#define cp_pdpub_ask \tRLC_PREFIX(cp_pdpub_ask)\n#define cp_pdpub_ans \tRLC_PREFIX(cp_pdpub_ans)\n#define cp_pdpub_ver \tRLC_PREFIX(cp_pdpub_ver)\n#define cp_pdprv_gen \tRLC_PREFIX(cp_pdprv_gen)\n#define cp_pdprv_ask \tRLC_PREFIX(cp_pdprv_ask)\n#define cp_pdprv_ans \tRLC_PREFIX(cp_pdprv_ans)\n#define cp_pdprv_ver \tRLC_PREFIX(cp_pdprv_ver)\n#define cp_lvpub_gen \tRLC_PREFIX(cp_lvpub_gen)\n#define cp_lvpub_ask \tRLC_PREFIX(cp_lvpub_ask)\n#define cp_lvpub_ans \tRLC_PREFIX(cp_lvpub_ans)\n#define cp_lvpub_ver \tRLC_PREFIX(cp_lvpub_ver)\n#define cp_lvprv_gen \tRLC_PREFIX(cp_lvprv_gen)\n#define cp_lvprv_ask \tRLC_PREFIX(cp_lvprv_ask)\n#define cp_lvprv_ans \tRLC_PREFIX(cp_lvprv_ans)\n#define cp_lvprv_ver \tRLC_PREFIX(cp_lvprv_ver)\n#define cp_sokaka_gen \tRLC_PREFIX(cp_sokaka_gen)\n#define cp_sokaka_gen_prv \tRLC_PREFIX(cp_sokaka_gen_prv)\n#define cp_sokaka_key \tRLC_PREFIX(cp_sokaka_key)\n#define cp_bgn_gen \tRLC_PREFIX(cp_bgn_gen)\n#define cp_bgn_enc1 \tRLC_PREFIX(cp_bgn_enc1)\n#define cp_bgn_dec1 \tRLC_PREFIX(cp_bgn_dec1)\n#define cp_bgn_enc2 \tRLC_PREFIX(cp_bgn_enc2)\n#define cp_bgn_dec2 \tRLC_PREFIX(cp_bgn_dec2)\n#define cp_bgn_add \tRLC_PREFIX(cp_bgn_add)\n#define cp_bgn_mul \tRLC_PREFIX(cp_bgn_mul)\n#define cp_bgn_dec \tRLC_PREFIX(cp_bgn_dec)\n#define cp_ibe_gen \tRLC_PREFIX(cp_ibe_gen)\n#define cp_ibe_gen_prv \tRLC_PREFIX(cp_ibe_gen_prv)\n#define cp_ibe_enc \tRLC_PREFIX(cp_ibe_enc)\n#define cp_ibe_dec \tRLC_PREFIX(cp_ibe_dec)\n#define cp_bls_gen \tRLC_PREFIX(cp_bls_gen)\n#define cp_bls_sig \tRLC_PREFIX(cp_bls_sig)\n#define cp_bls_ver \tRLC_PREFIX(cp_bls_ver)\n#define cp_bbs_gen \tRLC_PREFIX(cp_bbs_gen)\n#define cp_bbs_sig \tRLC_PREFIX(cp_bbs_sig)\n#define cp_bbs_ver \tRLC_PREFIX(cp_bbs_ver)\n#define cp_cls_gen \tRLC_PREFIX(cp_cls_gen)\n#define cp_cls_sig \tRLC_PREFIX(cp_cls_sig)\n#define cp_cls_ver \tRLC_PREFIX(cp_cls_ver)\n#define cp_cli_gen \tRLC_PREFIX(cp_cli_gen)\n#define cp_cli_sig \tRLC_PREFIX(cp_cli_sig)\n#define cp_cli_ver \tRLC_PREFIX(cp_cli_ver)\n#define cp_clb_gen \tRLC_PREFIX(cp_clb_gen)\n#define cp_clb_sig \tRLC_PREFIX(cp_clb_sig)\n#define cp_clb_ver \tRLC_PREFIX(cp_clb_ver)\n#define cp_pss_gen \tRLC_PREFIX(cp_pss_gen)\n#define cp_pss_sig \tRLC_PREFIX(cp_pss_sig)\n#define cp_pss_ver \tRLC_PREFIX(cp_pss_ver)\n#define cp_mpss_gen \tRLC_PREFIX(cp_mpss_gen)\n#define cp_mpss_sig \tRLC_PREFIX(cp_mpss_sig)\n#define cp_mpss_bct \tRLC_PREFIX(cp_mpss_bct)\n#define cp_mpss_ver \tRLC_PREFIX(cp_mpss_ver)\n#define cp_psb_gen \tRLC_PREFIX(cp_psb_gen)\n#define cp_psb_sig \tRLC_PREFIX(cp_psb_sig)\n#define cp_psb_ver \tRLC_PREFIX(cp_psb_ver)\n#define cp_mpsb_gen \tRLC_PREFIX(cp_mpsb_gen)\n#define cp_mpsb_sig \tRLC_PREFIX(cp_mpsb_sig)\n#define cp_mpsb_bct \tRLC_PREFIX(cp_mpsb_bct)\n#define cp_mpsb_ver \tRLC_PREFIX(cp_mpsb_ver)\n#define cp_zss_gen \tRLC_PREFIX(cp_zss_gen)\n#define cp_zss_sig \tRLC_PREFIX(cp_zss_sig)\n#define cp_zss_ver \tRLC_PREFIX(cp_zss_ver)\n#define cp_vbnn_gen \tRLC_PREFIX(cp_vbnn_gen)\n#define cp_vbnn_gen_prv \tRLC_PREFIX(cp_vbnn_gen_prv)\n#define cp_vbnn_sig \tRLC_PREFIX(cp_vbnn_sig)\n#define cp_vbnn_ver \tRLC_PREFIX(cp_vbnn_ver)\n#define cp_pokdl_prv \tRLC_PREFIX(cp_pokdl_prv)\n#define cp_pokdl_ver \tRLC_PREFIX(cp_pokdl_ver)\n#define cp_pokor_prv \tRLC_PREFIX(cp_pokor_prv)\n#define cp_pokor_ver \tRLC_PREFIX(cp_pokor_ver)\n#define cp_sokdl_sig \tRLC_PREFIX(cp_sokdl_sig)\n#define cp_sokdl_ver \tRLC_PREFIX(cp_sokdl_ver)\n#define cp_sokor_sig \tRLC_PREFIX(cp_sokor_sig)\n#define cp_sokor_ver \tRLC_PREFIX(cp_sokor_ver)\n#define cp_ers_gen \tRLC_PREFIX(cp_ers_gen)\n#define cp_ers_gen_key \tRLC_PREFIX(cp_ers_gen_key)\n#define cp_ers_sig \tRLC_PREFIX(cp_ers_sig)\n#define cp_ers_ver \tRLC_PREFIX(cp_ers_ver)\n#define cp_ers_ext \tRLC_PREFIX(cp_ers_ext)\n#define cp_smlers_sig \tRLC_PREFIX(cp_smlers_sig)\n#define cp_smlers_ver \tRLC_PREFIX(cp_smlers_ver)\n#define cp_smlers_ext \tRLC_PREFIX(cp_smlers_ext)\n#define cp_etrs_sig \tRLC_PREFIX(cp_etrs_sig)\n#define cp_etrs_ver \tRLC_PREFIX(cp_etrs_ver)\n#define cp_etrs_ext \tRLC_PREFIX(cp_etrs_ext)\n#define cp_etrs_uni \tRLC_PREFIX(cp_etrs_uni)\n#define cp_cmlhs_init \tRLC_PREFIX(cp_cmlhs_init)\n#define cp_cmlhs_gen \tRLC_PREFIX(cp_cmlhs_gen)\n#define cp_cmlhs_sig \tRLC_PREFIX(cp_cmlhs_sig)\n#define cp_cmlhs_fun \tRLC_PREFIX(cp_cmlhs_fun)\n#define cp_cmlhs_evl \tRLC_PREFIX(cp_cmlhs_evl)\n#define cp_cmlhs_ver \tRLC_PREFIX(cp_cmlhs_ver)\n#define cp_cmlhs_off \tRLC_PREFIX(cp_cmlhs_off)\n#define cp_cmlhs_onv \tRLC_PREFIX(cp_cmlhs_onv)\n#define cp_mklhs_gen \tRLC_PREFIX(cp_mklhs_gen)\n#define cp_mklhs_sig \tRLC_PREFIX(cp_mklhs_sig)\n#define cp_mklhs_fun \tRLC_PREFIX(cp_mklhs_fun)\n#define cp_mklhs_evl \tRLC_PREFIX(cp_mklhs_evl)\n#define cp_mklhs_ver \tRLC_PREFIX(cp_mklhs_ver)\n#define cp_mklhs_off \tRLC_PREFIX(cp_mklhs_off)\n#define cp_mklhs_onv \tRLC_PREFIX(cp_mklhs_onv)\n#define cp_rsapsi_gen \tRLC_PREFIX(cp_rsapsi_gen)\n#define cp_rsapsi_ask \tRLC_PREFIX(cp_rsapsi_ask)\n#define cp_rsapsi_ans \tRLC_PREFIX(cp_rsapsi_ans)\n#define cp_rsapsi_int \tRLC_PREFIX(cp_rsapsi_int)\n#define cp_shipsi_gen \tRLC_PREFIX(cp_shipsi_gen)\n#define cp_shipsi_ask \tRLC_PREFIX(cp_shipsi_ask)\n#define cp_shipsi_ans \tRLC_PREFIX(cp_shipsi_ans)\n#define cp_shipsi_int \tRLC_PREFIX(cp_shipsi_int)\n#define cp_pbpsi_gen \tRLC_PREFIX(cp_pbpsi_gen)\n#define cp_pbpsi_ask \tRLC_PREFIX(cp_pbpsi_ask)\n#define cp_pbpsi_ans \tRLC_PREFIX(cp_pbpsi_ans)\n#define cp_pbpsi_int \tRLC_PREFIX(cp_pbpsi_int)\n\n#undef md_map_sh224\n#undef md_map_sh256\n#undef md_map_sh384\n#undef md_map_sh512\n#undef md_map_b2s160\n#undef md_map_b2s256\n#undef md_kdf\n#undef md_mgf\n#undef md_hmac\n#undef md_xmd_sh224\n#undef md_xmd_sh256\n#undef md_xmd_sh384\n#undef md_xmd_sh512\n\n#define md_map_sh224 \tRLC_PREFIX(md_map_sh224)\n#define md_map_sh256 \tRLC_PREFIX(md_map_sh256)\n#define md_map_sh384 \tRLC_PREFIX(md_map_sh384)\n#define md_map_sh512 \tRLC_PREFIX(md_map_sh512)\n#define md_map_b2s160 \tRLC_PREFIX(md_map_b2s160)\n#define md_map_b2s256 \tRLC_PREFIX(md_map_b2s256)\n#define md_kdf \tRLC_PREFIX(md_kdf)\n#define md_mgf \tRLC_PREFIX(md_mgf)\n#define md_hmac \tRLC_PREFIX(md_hmac)\n#define md_xmd_sh224 \tRLC_PREFIX(md_xmd_sh224)\n#define md_xmd_sh256 \tRLC_PREFIX(md_xmd_sh256)\n#define md_xmd_sh384 \tRLC_PREFIX(md_xmd_sh384)\n#define md_xmd_sh512 \tRLC_PREFIX(md_xmd_sh512)\n\n#endif /* LABEL */\n\n#endif /* !RLC_LABEL_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime number generation and testing functions.\n *\n * Strong prime generation is based on Gordon's Algorithm, taken from Handbook\n * of Applied Cryptography.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Number of trial division tests.\n */\n#define BASIC_TESTS\t((int)(sizeof(primes)/sizeof(dig_t)))\n\n/**\n * Small prime numbers table.\n */\nstatic const dig_t primes[] = {\n\t0x0002, 0x0003, 0x0005, 0x0007, 0x000B, 0x000D, 0x0011, 0x0013,\n\t0x0017, 0x001D, 0x001F, 0x0025, 0x0029, 0x002B, 0x002F, 0x0035,\n\t0x003B, 0x003D, 0x0043, 0x0047, 0x0049, 0x004F, 0x0053, 0x0059,\n\t0x0061, 0x0065, 0x0067, 0x006B, 0x006D, 0x0071, 0x007F, 0x0083,\n\t0x0089, 0x008B, 0x0095, 0x0097, 0x009D, 0x00A3, 0x00A7, 0x00AD,\n\t0x00B3, 0x00B5, 0x00BF, 0x00C1, 0x00C5, 0x00C7, 0x00D3, 0x00DF,\n#if WSIZE > 8\n\t0x00E3, 0x00E5, 0x00E9, 0x00EF, 0x00F1, 0x00FB, 0x0101, 0x0107,\n\t0x010D, 0x010F, 0x0115, 0x0119, 0x011B, 0x0125, 0x0133, 0x0137,\n\n\t0x0139, 0x013D, 0x014B, 0x0151, 0x015B, 0x015D, 0x0161, 0x0167,\n\t0x016F, 0x0175, 0x017B, 0x017F, 0x0185, 0x018D, 0x0191, 0x0199,\n\t0x01A3, 0x01A5, 0x01AF, 0x01B1, 0x01B7, 0x01BB, 0x01C1, 0x01C9,\n\t0x01CD, 0x01CF, 0x01D3, 0x01DF, 0x01E7, 0x01EB, 0x01F3, 0x01F7,\n\t0x01FD, 0x0209, 0x020B, 0x021D, 0x0223, 0x022D, 0x0233, 0x0239,\n\t0x023B, 0x0241, 0x024B, 0x0251, 0x0257, 0x0259, 0x025F, 0x0265,\n\t0x0269, 0x026B, 0x0277, 0x0281, 0x0283, 0x0287, 0x028D, 0x0293,\n\t0x0295, 0x02A1, 0x02A5, 0x02AB, 0x02B3, 0x02BD, 0x02C5, 0x02CF,\n\n\t0x02D7, 0x02DD, 0x02E3, 0x02E7, 0x02EF, 0x02F5, 0x02F9, 0x0301,\n\t0x0305, 0x0313, 0x031D, 0x0329, 0x032B, 0x0335, 0x0337, 0x033B,\n\t0x033D, 0x0347, 0x0355, 0x0359, 0x035B, 0x035F, 0x036D, 0x0371,\n\t0x0373, 0x0377, 0x038B, 0x038F, 0x0397, 0x03A1, 0x03A9, 0x03AD,\n\t0x03B3, 0x03B9, 0x03C7, 0x03CB, 0x03D1, 0x03D7, 0x03DF, 0x03E5,\n\t0x03F1, 0x03F5, 0x03FB, 0x03FD, 0x0407, 0x0409, 0x040F, 0x0419,\n\t0x041B, 0x0425, 0x0427, 0x042D, 0x043F, 0x0443, 0x0445, 0x0449,\n\t0x044F, 0x0455, 0x045D, 0x0463, 0x0469, 0x047F, 0x0481, 0x048B,\n\n\t0x0493, 0x049D, 0x04A3, 0x04A9, 0x04B1, 0x04BD, 0x04C1, 0x04C7,\n\t0x04CD, 0x04CF, 0x04D5, 0x04E1, 0x04EB, 0x04FD, 0x04FF, 0x0503,\n\t0x0509, 0x050B, 0x0511, 0x0515, 0x0517, 0x051B, 0x0527, 0x0529,\n\t0x052F, 0x0551, 0x0557, 0x055D, 0x0565, 0x0577, 0x0581, 0x058F,\n\t0x0593, 0x0595, 0x0599, 0x059F, 0x05A7, 0x05AB, 0x05AD, 0x05B3,\n\t0x05BF, 0x05C9, 0x05CB, 0x05CF, 0x05D1, 0x05D5, 0x05DB, 0x05E7,\n\t0x05F3, 0x05FB, 0x0607, 0x060D, 0x0611, 0x0617, 0x061F, 0x0623,\n\t0x062B, 0x062F, 0x063D, 0x0641, 0x0647, 0x0649, 0x064D, 0x0653,\n\n\t0x0655, 0x065B, 0x0665, 0x0679, 0x067F, 0x0683, 0x0685, 0x069D,\n\t0x06A1, 0x06A3, 0x06AD, 0x06B9, 0x06BB, 0x06C5, 0x06CD, 0x06D3,\n\t0x06D9, 0x06DF, 0x06F1, 0x06F7, 0x06FB, 0x06FD, 0x0709, 0x0713,\n\t0x071F, 0x0727, 0x0737, 0x0745, 0x074B, 0x074F, 0x0751, 0x0755,\n\t0x0757, 0x0761, 0x076D, 0x0773, 0x0779, 0x078B, 0x078D, 0x079D,\n\t0x079F, 0x07B5, 0x07BB, 0x07C3, 0x07C9, 0x07CD, 0x07CF, 0x07D3,\n\t0x07DB, 0x07E1, 0x07EB, 0x07ED, 0x07F7, 0x0805, 0x080F, 0x0815,\n\t0x0821, 0x0823, 0x0827, 0x0829, 0x0833, 0x083F, 0x0841, 0x0851,\n\n\t0x0853, 0x0859, 0x085D, 0x085F, 0x0869, 0x0871, 0x0883, 0x089B,\n\t0x089F, 0x08A5, 0x08AD, 0x08BD, 0x08BF, 0x08C3, 0x08CB, 0x08DB,\n\t0x08DD, 0x08E1, 0x08E9, 0x08EF, 0x08F5, 0x08F9, 0x0905, 0x0907,\n\t0x091D, 0x0923, 0x0925, 0x092B, 0x092F, 0x0935, 0x0943, 0x0949,\n\t0x094D, 0x094F, 0x0955, 0x0959, 0x095F, 0x096B, 0x0971, 0x0977,\n\t0x0985, 0x0989, 0x098F, 0x099B, 0x09A3, 0x09A9, 0x09AD, 0x09C7,\n\t0x09D9, 0x09E3, 0x09EB, 0x09EF, 0x09F5, 0x09F7, 0x09FD, 0x0A13,\n\t0x0A1F, 0x0A21, 0x0A31, 0x0A39, 0x0A3D, 0x0A49, 0x0A57, 0x0A61,\n\n\t0x0A63, 0x0A67, 0x0A6F, 0x0A75, 0x0A7B, 0x0A7F, 0x0A81, 0x0A85,\n\t0x0A8B, 0x0A93, 0x0A97, 0x0A99, 0x0A9F, 0x0AA9, 0x0AAB, 0x0AB5,\n\t0x0ABD, 0x0AC1, 0x0ACF, 0x0AD9, 0x0AE5, 0x0AE7, 0x0AED, 0x0AF1,\n\t0x0AF3, 0x0B03, 0x0B11, 0x0B15, 0x0B1B, 0x0B23, 0x0B29, 0x0B2D,\n\t0x0B3F, 0x0B47, 0x0B51, 0x0B57, 0x0B5D, 0x0B65, 0x0B6F, 0x0B7B,\n\t0x0B89, 0x0B8D, 0x0B93, 0x0B99, 0x0B9B, 0x0BB7, 0x0BB9, 0x0BC3,\n\t0x0BCB, 0x0BCF, 0x0BDD, 0x0BE1, 0x0BE9, 0x0BF5, 0x0BFB, 0x0C07,\n\t0x0C0B, 0x0C11, 0x0C25, 0x0C2F, 0x0C31, 0x0C41, 0x0C5B, 0x0C5F,\n\n\t0x0C61, 0x0C6D, 0x0C73, 0x0C77, 0x0C83, 0x0C89, 0x0C91, 0x0C95,\n\t0x0C9D, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBB, 0x0CC7, 0x0CE3, 0x0CE5,\n\t0x0CEB, 0x0CF1, 0x0CF7, 0x0CFB, 0x0D01, 0x0D03, 0x0D0F, 0x0D13,\n\t0x0D1F, 0x0D21, 0x0D2B, 0x0D2D, 0x0D3D, 0x0D3F, 0x0D4F, 0x0D55,\n\t0x0D69, 0x0D79, 0x0D81, 0x0D85, 0x0D87, 0x0D8B, 0x0D8D, 0x0DA3,\n\t0x0DAB, 0x0DB7, 0x0DBD, 0x0DC7, 0x0DC9, 0x0DCD, 0x0DD3, 0x0DD5,\n\t0x0DDB, 0x0DE5, 0x0DE7, 0x0DF3, 0x0DFD, 0x0DFF, 0x0E09, 0x0E17,\n\t0x0E1D, 0x0E21, 0x0E27, 0x0E2F, 0x0E35, 0x0E3B, 0x0E4B, 0x0E57,\n#endif\n};\n\n#if BN_MOD == PMERS\n\n/**\n * Computes c = a ^ b mod m.\n *\n * @param c\t\t\t\t- the result.\n * @param a\t\t\t\t- the basis.\n * @param b\t\t\t\t- the exponent.\n * @param m\t\t\t\t- the modulus.\n */\nstatic void bn_exp(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tl = bn_bits(b);\n\n\t\tbn_copy(t, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(t, t);\n\t\t\tbn_mod(t, t, m);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tbn_mul(t, t, a);\n\t\t\t\tbn_mod(t, t, m);\n\t\t\t}\n\t\t}\n\n\t\tbn_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint bn_is_prime(const bn_t a) {\n\tint result;\n\n\tresult = 0;\n\tif (!bn_is_prime_basic(a)) {\n\t\tgoto end;\n\t}\n\n\tif (!bn_is_prime_rabin(a)) {\n\t\tgoto end;\n\t}\n\n\tresult = 1;\n  end:\n\treturn result;\n}\n\nint bn_is_prime_basic(const bn_t a) {\n\tdig_t t;\n\tint i, result;\n\n\tresult = 1;\n\n\tif (bn_cmp_dig(a, 1) == RLC_EQ) {\n\t\treturn 0;\n\t}\n\n\t/* Trial division. */\n\tfor (i = 0; i < BASIC_TESTS; i++) {\n\t\tbn_mod_dig(&t, a, primes[i]);\n\t\tif (t == 0 && bn_cmp_dig(a, primes[i]) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nint bn_is_prime_rabin(const bn_t a) {\n\tbn_t t, n1, y, r;\n\tint i, s, j, result, b, tests = 0, cmp2;\n\n\ttests = 0;\n\tresult = 1;\n\n\tbn_null(t);\n\tbn_null(n1);\n\tbn_null(y);\n\tbn_null(r);\n\n\tcmp2 = bn_cmp_dig(a, 2);\n\tif (cmp2 == RLC_LT) {\n\t\t/* Numbers 1 or smaller are not prime */\n\t\treturn 0;\n\t}\n\tif (cmp2 == RLC_EQ) {\n\t\t/* The number 2 is prime */\n\t\treturn 1;\n\t}\n\n\tif (bn_is_even(a) == 1) {\n\t\t/* Even numbers > 2 are not prime */\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\t/*\n\t\t * These values are taken from Table 4.4 inside Handbook of Applied\n\t\t * Cryptography.\n\t\t */\n\t\tb = bn_bits(a);\n\t\tif (b >= 1300) {\n\t\t\ttests = 2;\n\t\t} else if (b >= 850) {\n\t\t\ttests = 3;\n\t\t} else if (b >= 650) {\n\t\t\ttests = 4;\n\t\t} else if (b >= 550) {\n\t\t\ttests = 5;\n\t\t} else if (b >= 450) {\n\t\t\ttests = 6;\n\t\t} else if (b >= 400) {\n\t\t\ttests = 7;\n\t\t} else if (b >= 350) {\n\t\t\ttests = 8;\n\t\t} else if (b >= 300) {\n\t\t\ttests = 9;\n\t\t} else if (b >= 250) {\n\t\t\ttests = 12;\n\t\t} else if (b >= 200) {\n\t\t\ttests = 15;\n\t\t} else if (b >= 150) {\n\t\t\ttests = 18;\n\t\t} else {\n\t\t\ttests = 27;\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(n1);\n\t\tbn_new(y);\n\t\tbn_new(r);\n\n\t\t/* r = (n - 1)/2^s. */\n\t\tbn_sub_dig(n1, a, 1);\n\t\tbn_copy(r, n1);\n\t\ts = 0;\n\t\twhile (bn_is_even(r)) {\n\t\t\ts++;\n\t\t\tbn_rsh(r, r, 1);\n\t\t}\n\n\t\tfor (i = 0; i < tests; i++) {\n\t\t\t/* Fix the basis as the first few primes. */\n\t\t\tbn_set_dig(t, primes[i]);\n\n\t\t\t/* Ensure t <= n - 2 as per HAC */\n\t\t\tif( bn_cmp(t, n1) != RLC_LT ) {\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* y = b^r mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(y, t, r, a);\n#else\n\t\t\tbn_exp(y, t, r, a);\n#endif\n\n\t\t\tif (bn_cmp_dig(y, 1) != RLC_EQ && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\tj = 1;\n\t\t\t\twhile ((j <= (s - 1)) && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tbn_sqr(y, y);\n\t\t\t\t\tbn_mod(y, y, a);\n\n\t\t\t\t\t/* If y == 1 then composite. */\n\t\t\t\t\tif (bn_cmp_dig(y, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++j;\n\t\t\t\t}\n\n\t\t\t\t/* If y != n1 then composite. */\n\t\t\t\tif (bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(y);\n\t\tbn_free(n1);\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\nint bn_is_prime_solov(const bn_t a) {\n\tbn_t t0, t1, t2;\n\tint i, result;\n\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\n\tresult = 1;\n\n\tRLC_TRY {\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\t/* Generate t0, 2 <= t0, <= a - 2. */\n\t\t\tdo {\n\t\t\t\tbn_rand(t0, RLC_POS, bn_bits(a));\n\t\t\t\tbn_mod(t0, t0, a);\n\t\t\t} while (bn_cmp_dig(t0, 2) == RLC_LT);\n\t\t\t/* t2 = a - 1. */\n\t\t\tbn_copy(t2, a);\n\t\t\tbn_sub_dig(t2, t2, 1);\n\t\t\t/* t1 = (a - 1)/2. */\n\t\t\tbn_rsh(t1, t2, 1);\n\t\t\t/* t1 = t0^(a - 1)/2 mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t1, t0, t1, a);\n#else\n\t\t\tbn_exp(t1, t0, t1, a);\n#endif\n\t\t\t/* If t1 != 1 and t1 != n - 1 return 0 */\n\t\t\tif (bn_cmp_dig(t1, 1) != RLC_EQ && bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Lend result here, but restore afterwards, for t2 = (t0|a). */\n\t\t\tresult = bn_smb_jac(t0, a);\n\t\t\tbn_set_dig(t2, (result < 0 ? -result : result));\n\t\t\tif (result < 0) {\n\t\t\t\tbn_neg(t2, t2);\n\t\t\t}\n\t\t\tresult = 1;\n\t\t\t/* If t1 != t2 (mod a) return 0. */\n\t\t\tbn_mod(t1, t1, a);\n\t\t\tbn_mod(t2, t2, a);\n\t\t\tif (bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t}\n\treturn result;\n}\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\nvoid bn_gen_prime_basic(bn_t a, int bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\tif (bn_is_prime(a)) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\nvoid bn_gen_prime_safep(bn_t a, int bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\t/* Check if (a - 1)/2 is prime. */\n\t\tbn_sub_dig(a, a, 1);\n\t\tbn_rsh(a, a, 1);\n\t\tif (bn_is_prime(a)) {\n\t\t\t/* Restore a. */\n\t\t\tbn_lsh(a, a, 1);\n\t\t\tbn_add_dig(a, a, 1);\n\t\t\tif (bn_is_prime(a)) {\n\t\t\t\t/* Should be prime now. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\nvoid bn_gen_prime_stron(bn_t a, int bits) {\n\tdig_t i, j;\n\tint found, k;\n\tbn_t r, s, t;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tbn_new(t);\n\n\t\tdo {\n\t\t\tdo {\n\t\t\t\t/* Generate two large primes r and s. */\n\t\t\t\tbn_rand(s, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t\tbn_rand(t, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t} while (!bn_is_prime(s) || !bn_is_prime(t));\n\t\t\tfound = 1;\n\t\t\tbn_rand(a, RLC_POS, bits / 2 - bn_bits(t) - 1);\n\t\t\ti = a->dp[0];\n\t\t\tbn_dbl(t, t);\n\t\t\tdo {\n\t\t\t\t/* Find first prime r = 2 * i * t + 1. */\n\t\t\t\tbn_mul_dig(r, t, i);\n\t\t\t\tbn_add_dig(r, r, 1);\n\t\t\t\ti++;\n\t\t\t\tif (bn_bits(r) > bits / 2 - 1) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(r));\n\t\t\tif (found == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Compute t = 2 * (s^(r-2) mod r) * s - 1. */\n\t\t\tbn_sub_dig(t, r, 2);\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t, s, t, r);\n#else\n\t\t\tbn_exp(t, s, t, r);\n#endif\n\n\t\t\tbn_mul(t, t, s);\n\t\t\tbn_dbl(t, t);\n\t\t\tbn_sub_dig(t, t, 1);\n\n\t\t\tk = bits - bn_bits(r);\n\t\t\tk -= bn_bits(s);\n\t\t\tbn_rand(a, RLC_POS, k);\n\t\t\tj = a->dp[0];\n\t\t\tdo {\n\t\t\t\t/* Find first prime a = t + 2 * j * r * s. */\n\t\t\t\tbn_mul(a, r, s);\n\t\t\t\tbn_mul_dig(a, a, j);\n\t\t\t\tbn_dbl(a, a);\n\t\t\t\tbn_add(a, a, t);\n\t\t\t\tj++;\n\t\t\t\tif (bn_bits(a) > bits) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(a));\n\t\t} while (found == 0 && bn_bits(a) != bits);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(s);\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\nint bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;\n    }\n\n    bn_null(t);\n\n    RLC_TRY {\n        bn_new(t);\n\t\tbn_gen_prime(a, abits);\n        do {\n            bn_rand(t, RLC_POS, bbits - bn_bits(a));\n            do {\n                bn_mul(b, a, t);\n                bn_add_dig(b, b, 1);\n                bn_add_dig(t, t, 1);\n            } while(! bn_is_prime(b));\n        } while (bn_bits(b) != bbits);\n    }\n    RLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n    }\n    RLC_FINALLY {\n        bn_free(t);\n    }\n\n    return result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for implementation of cryptographic protocols.\n *\n * @version $Id$\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\nstatic int rsa(void) {\n\tint code = RLC_ERR;\n\trsa_t pub, prv;\n\tuint8_t in[10], out[RLC_BN_BITS / 8 + 1], h[RLC_MD_LEN];\n\tsize_t il, ol;\n\tint result;\n\n\trsa_null(pub);\n\trsa_null(prv);\n\n\tRLC_TRY {\n\t\trsa_new(pub);\n\t\trsa_new(prv);\n\n\t\tresult = cp_rsa_gen(pub, prv, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"rsa encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\til = 10;\n\t\t\tol = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(in, il);\n\t\t\tTEST_ASSERT(cp_rsa_enc(out, &ol, in, il, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_rsa_dec(out, &ol, out, ol, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(in, out, ol) == 0, end);\n\t\t} TEST_END;\n\n\t\tresult = cp_rsa_gen(pub, prv, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"rsa signature/verification is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\til = 10;\n\t\t\tol = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(in, il);\n\t\t\tTEST_ASSERT(cp_rsa_sig(out, &ol, in, il, 0, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_rsa_ver(out, ol, in, il, 0, pub) == 1, end);\n\t\t\tmd_map(h, in, il);\n\t\t\tTEST_ASSERT(cp_rsa_sig(out, &ol, h, RLC_MD_LEN, 1, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_rsa_ver(out, ol, h, RLC_MD_LEN, 1, pub) == 1, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\trsa_free(pub);\n\trsa_free(prv);\n\treturn code;\n}\n\nstatic int rabin(void) {\n\tint code = RLC_ERR;\n\trabin_t pub, prv;\n\tuint8_t in[10];\n\tuint8_t out[RLC_BN_BITS / 8 + 1];\n\tsize_t in_len, out_len;\n\tint result;\n\n\trabin_null(pub);\n\trabin_null(prv);\n\n\tRLC_TRY {\n\t\trabin_new(pub);\n\t\trabin_new(prv);\n\n\t\tresult = cp_rabin_gen(pub, prv, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"rabin encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tin_len = 10;\n\t\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(in, in_len);\n\t\t\tTEST_ASSERT(cp_rabin_enc(out, &out_len, in, in_len, pub) == RLC_OK,\n\t\t\t\t\tend);\n\t\t\tTEST_ASSERT(cp_rabin_dec(out, &out_len, out, out_len,\n\t\t\t\t\t\t\tprv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(in, out, out_len) == 0, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\trabin_free(pub);\n\trabin_free(prv);\n\treturn code;\n}\n\nstatic int benaloh(void) {\n\tint code = RLC_ERR;\n\tbdpe_t pub, prv;\n\tbn_t a, b;\n\tdig_t in, out;\n\tuint8_t buf[RLC_BN_BITS / 8 + 1];\n\tsize_t len;\n\tint result;\n\tdig_t prime = 0xFB;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbdpe_null(pub);\n\tbdpe_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbdpe_new(pub);\n\t\tbdpe_new(prv);\n\n\t\tresult = cp_bdpe_gen(pub, prv, prime, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"benaloh encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tlen = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(buf, 1);\n\t\t\tin = buf[0] % prime;\n\t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bdpe_dec(&out, buf, len, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"benaloh encryption/decryption is homomorphic\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tlen = RLC_BN_BITS / 8 + 1;\n\t\t\trand_bytes(buf, 1);\n\t\t\tin = buf[0] % prime;\n\t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, in, pub) == RLC_OK, end);\n\t\t\tbn_read_bin(a, buf, len);\n\t\t\trand_bytes(buf, 1);\n\t\t\tout = (buf[0] % prime);\n\t\t\tin = (in + out) % prime;\n\t\t\tTEST_ASSERT(cp_bdpe_enc(buf, &len, out, pub) == RLC_OK, end);\n\t\t\tbn_read_bin(b, buf, len);\n\t\t\tbn_mul(a, a, b);\n\t\t\tbn_mod(a, a, pub->n);\n\t\t\tlen = bn_size_bin(pub->n);\n\t\t\tbn_write_bin(buf, len, a);\n\t\t\tTEST_ASSERT(cp_bdpe_dec(&out, buf, len, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbdpe_free(pub);\n\tbdpe_free(prv);\n\treturn code;\n}\n\nstatic int paillier(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, s, pub;\n\tphpe_t prv;\n\tint result;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(s);\n\tbn_null(pub);\n\tphpe_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(s);\n\t\tbn_new(pub);\n\t\tphpe_new(prv);\n\n\t\tresult = cp_phpe_gen(pub, prv, RLC_BN_BITS / 2);\n\n\t\tTEST_CASE(\"paillier encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tbn_rand_mod(a, pub);\n\t\t\tTEST_ASSERT(cp_phpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_dec(b, c, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"paillier encryption/decryption is homomorphic\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tbn_rand_mod(a, pub);\n\t\t\tbn_rand_mod(b, pub);\n\t\t\tTEST_ASSERT(cp_phpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_enc(d, b, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_add(c, c, d, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_phpe_dec(d, c, prv) == RLC_OK, end);\n\t\t\tbn_add(a, a, b);\n\t\t\tbn_mod(a, a, pub);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tfor (int k = 1; k <= 2; k++) {\n\t\t\tresult = cp_ghpe_gen(pub, s, RLC_BN_BITS / (2 * k));\n\t\t\tutil_print(\"(s = %d) \", k);\n\t\t\tTEST_CASE(\"general paillier encryption/decryption is correct\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand(a, RLC_POS, k * (bn_bits(pub) - 1));\n\t\t\t\tTEST_ASSERT(cp_ghpe_enc(c, a, pub, k) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ghpe_dec(b, c, pub, s, k) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}  TEST_END;\n\n\t\t\tutil_print(\"(s = %d) \", k);\n\t\t\tTEST_CASE(\"general paillier encryption/decryption is homomorphic\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand(a, RLC_POS, k * (bn_bits(pub) - 1));\n\t\t\t\tbn_rand(b, RLC_POS, k * (bn_bits(pub) - 1));\n\t\t\t\tTEST_ASSERT(cp_ghpe_enc(c, a, pub, k) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ghpe_enc(d, b, pub, k) == RLC_OK, end);\n\t\t\t\tbn_mul(c, c, d);\n\t\t\t\tbn_sqr(d, pub);\n\t\t\t\tif (k == 2) {\n\t\t\t\t\tbn_mul(d, d, pub);\n\t\t\t\t}\n\t\t\t\tbn_mod(c, c, d);\n\t\t\t\tTEST_ASSERT(cp_ghpe_dec(c, c, pub, s, k) == RLC_OK, end);\n\t\t\t\tbn_add(a, a, b);\n\t\t\t\tbn_copy(d, pub);\n\t\t\t\tif (k == 2) {\n\t\t\t\t\tbn_mul(d, d, pub);\n\t\t\t\t}\n\t\t\t\tbn_mod(a, a, d);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(s);\n\tbn_free(pub);\n\tphpe_free(prv);\n\treturn code;\n}\n\n\nstatic int subgroup_paillier() {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d;\n\tshpe_t pub, prv;\n\tint result, bits;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tshpe_null(pub);\n\tshpe_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n        shpe_new(pub);\n\t\tshpe_new(prv);\n\n\t\tfor (bits = 3; bits < 6; bits++) {\n\t\t\tresult = cp_shpe_gen(pub, prv, RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\n\t\t\tutil_print(\"(o = %d, |n| = %d) \", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\t\t\tTEST_CASE(\"subgroup paillier encryption/decryption is correct\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand_mod(a, pub->crt->n);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_shpe_dec(b, c, prv) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\n\t\t\tutil_print(\"(o = %d, |n| = %d) \", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\t\t\tTEST_CASE(\"subgroup paillier faster encryption with private key is correct\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand_mod(a, pub->crt->n);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc_prv(c, a, prv) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_shpe_dec(b, c, prv) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\n\t\t\tutil_print(\"(o = %d, |n| = %d) \", RLC_BN_BITS / (bits * 2), RLC_BN_BITS / 2);\n\t\t\tTEST_CASE(\"subgroup paillier encryption/decryption is homomorphic\") {\n\t\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\t\tbn_rand_mod(a, pub->crt->n);\n\t\t\t\tbn_rand_mod(b, pub->crt->n);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc(c, a, pub) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_shpe_enc(d, b, pub) == RLC_OK, end);\n\t\t\t\tbn_mul(c, c, d);\n\t\t\t\tbn_sqr(d, pub->crt->n);\n\t\t\t\tbn_mod(c, c, d);\n\t\t\t\tTEST_ASSERT(cp_shpe_dec(d, c, prv) == RLC_OK, end);\n\t\t\t\tbn_add(a, a, b);\n\t\t\t\tbn_mod(a, a, pub->crt->n);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tshpe_free(pub);\n\tshpe_free(prv);\n\treturn code;\n}\n\n#if defined(WITH_EC)\n\n/* Test vectors generated by BouncyCastle. */\n\n#if defined(EP_PLAIN) && FP_PRIME == 256\n\n#define NIST_P256_A\t\t\"DA818E65859F3997D4CD287945363B14A0030665B8ABD19719D57952E3A2BEAD\"\n#define NIST_P256_B\t\t\"66BF67EDF1ABDC8178C8A07644FDD5C88EFD4954FD6D2691933B5F0EA0AE2153\"\n#define NIST_P256_A_X\t\"9A2E9583CCBDD502933709D3ED1764E79D1C2EE601DF75A40C486BE3DAB3CDCA\"\n#define NIST_P256_A_Y\t\"D025EA9D9BDA94C0DC7F3813ECA72B369F52CA87E92948BCD76984F44D319F8F\"\n#define NIST_P256_B_X\t\"B8F245FC8A1C7E933D5CAD6E77102C72B0C1F393F779F3F504DA1CA776434B10\"\n#define NIST_P256_B_Y\t\"5373FA01BC13FF5843D4A31E40833785C598C0BBC2F6AF7317C327BE09883799\"\n\nuint8_t result[] = {\n\t0xC0, 0xEC, 0x2B, 0xAC, 0xEB, 0x3C, 0x6E, 0xE3, 0x21, 0x96, 0xD5, 0x43,\n\t0x0E, 0xE6, 0xDA, 0xBB, 0x50, 0xAE, 0xEE, 0xBE, 0xBA, 0xCE, 0x6B, 0x86,\n\t0x09, 0xD7, 0xEB, 0x07, 0xD6, 0x45, 0xF6, 0x34, 0xD4, 0xE0, 0xD1, 0x9A,\n\t0xAB, 0xA0, 0xD2, 0x90, 0x2F, 0x4A, 0xDC, 0x20, 0x1B, 0x0F, 0x35, 0x8D\n};\n\n#endif\n\n#define ASSIGNP(CURVE)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A, sizeof(CURVE##_A));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(da, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_X, sizeof(CURVE##_A_X));\t\t\t\t\t\t\t\\\n\tfp_read_str(qa->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_Y, sizeof(CURVE##_A_Y));\t\t\t\t\t\t\t\\\n\tfp_read_str(qa->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfp_set_dig(qa->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B, sizeof(CURVE##_B));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(d_b, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_X, sizeof(CURVE##_B_X));\t\t\t\t\t\t\t\\\n\tfp_read_str(q_b->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_Y, sizeof(CURVE##_B_Y));\t\t\t\t\t\t\t\\\n\tfp_read_str(q_b->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfp_set_dig(q_b->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tqa->coord = q_b->coord = BASIC;\t\t\t\t\t\t\t\t\t\t\t\\\n\n#define ASSIGNK(CURVE)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A, sizeof(CURVE##_A));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(da, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_X, sizeof(CURVE##_A_X));\t\t\t\t\t\t\t\\\n\tfb_read_str(qa->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_A_Y, sizeof(CURVE##_A_Y));\t\t\t\t\t\t\t\\\n\tfb_read_str(qa->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfb_set_dig(qa->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B, sizeof(CURVE##_B));\t\t\t\t\t\t\t\t\\\n\tbn_read_str(d_b, str, strlen(str), 16);\t\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_X, sizeof(CURVE##_B_X));\t\t\t\t\t\t\t\\\n\tfb_read_str(q_b->x, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tRLC_GET(str, CURVE##_B_Y, sizeof(CURVE##_B_Y));\t\t\t\t\t\t\t\\\n\tfb_read_str(q_b->y, str, strlen(str), 16);\t\t\t\t\t\t\t\t\\\n\tfb_set_dig(q_b->z, 1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tqa->coord = q_b->coord = BASIC;\t\t\t\t\t\t\t\t\t\t\t\\\n\nstatic int ecdh(void) {\n\tint code = RLC_ERR;\n\tbn_t da, d_b;\n\tec_t qa, q_b;\n\tuint8_t k1[RLC_MD_LEN], k2[RLC_MD_LEN];\n\n\tbn_null(da);\n\tbn_null(d_b);\n\tec_null(qa);\n\tec_null(q_b);\n\n\tRLC_TRY {\n\t\tbn_new(da);\n\t\tbn_new(d_b);\n\t\tec_new(qa);\n\t\tec_new(q_b);\n\n\t\tTEST_CASE(\"ecdh key agreement is correct\") {\n\t\t\tTEST_ASSERT(cp_ecdh_gen(da, qa) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdh_gen(d_b, q_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdh_key(k1, RLC_MD_LEN, d_b, qa) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdh_key(k2, RLC_MD_LEN, da, q_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(k1, k2, RLC_MD_LEN) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(da);\n\tbn_free(d_b);\n\tec_free(qa);\n\tec_free(q_b);\n\treturn code;\n}\n\nstatic int ecmqv(void) {\n\tint code = RLC_ERR;\n\tbn_t d1a, d1_b;\n\tbn_t d2a, d2_b;\n\tec_t q1a, q1_b;\n\tec_t q2a, q2_b;\n\tuint8_t key1[RLC_MD_LEN], key2[RLC_MD_LEN];\n\n\tbn_null(d1a);\n\tbn_null(d1_b);\n\tec_null(q1a);\n\tec_null(q1_b);\n\tbn_null(d2a);\n\tbn_null(d2_b);\n\tec_null(q2a);\n\tec_null(q2_b);\n\n\tRLC_TRY {\n\t\tbn_new(d1a);\n\t\tbn_new(d1_b);\n\t\tec_new(q1a);\n\t\tec_new(q1_b);\n\t\tbn_new(d2a);\n\t\tbn_new(d2_b);\n\t\tec_new(q2a);\n\t\tec_new(q2_b);\n\n\t\tTEST_CASE(\"ecmqv authenticated key agreement is correct\") {\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d1a, q1a) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d2a, q2a) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d1_b, q1_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_gen(d2_b, q2_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_key(key1, RLC_MD_LEN, d1_b, d2_b, q2_b, q1a,\n\t\t\t\t\t\t\tq2a) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecmqv_key(key2, RLC_MD_LEN, d1a, d2a, q2a, q1_b,\n\t\t\t\t\t\t\tq2_b) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(key1, key2, RLC_MD_LEN) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d1a);\n\tbn_free(d1_b);\n\tec_free(q1a);\n\tec_free(q1_b);\n\tbn_free(d2a);\n\tbn_free(d2_b);\n\tec_free(q2a);\n\tec_free(q2_b);\n\treturn code;\n}\n\nstatic int ecies(void) {\n\tint code = RLC_ERR;\n\tec_t r;\n\tbn_t da, d_b;\n\tec_t qa, q_b;\n\tsize_t l, in_len, out_len;\n\tuint8_t in[RLC_BC_LEN - 1], out[RLC_BC_LEN + RLC_MD_LEN];\n\n\tec_null(r);\n\tbn_null(da);\n\tbn_null(d_b);\n\tec_null(qa);\n\tec_null(q_b);\n\n\tRLC_TRY {\n\t\tec_new(r);\n\t\tbn_new(da);\n\t\tbn_new(d_b);\n\t\tec_new(qa);\n\t\tec_new(q_b);\n\n\t\tl = ec_param_level();\n\t\tif (l == 80 || l == 128 || l == 192 || l == 256) {\n\t\t\tTEST_CASE(\"ecies encryption/decryption is correct\") {\n\t\t\t\tTEST_ASSERT(cp_ecies_gen(da, qa) == RLC_OK, end);\n\t\t\t\tin_len = RLC_BC_LEN - 1;\n\t\t\t\tout_len = RLC_BC_LEN + RLC_MD_LEN;\n\t\t\t\trand_bytes(in, in_len);\n\t\t\t\tTEST_ASSERT(cp_ecies_enc(r, out, &out_len, in, in_len, qa)\n\t\t\t\t\t\t== RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ecies_dec(out, &out_len, r, out, out_len, da)\n\t\t\t\t\t\t== RLC_OK, end);\n\t\t\t\tTEST_ASSERT(memcmp(in, out, out_len) == 0, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n#if MD_MAP == SH256\n\t\tuint8_t msg[RLC_BC_LEN + RLC_MD_LEN];\n\t\tchar str[2 * RLC_FC_BYTES + 1];\n\n\t\tswitch (ec_param_get()) {\n\n#if defined(EP_PLAIN) && FP_PRIME == 256\n\t\t\tcase NIST_P256:\n\t\t\t\tASSIGNP(NIST_P256);\n\t\t\t\tmemcpy(msg, result, sizeof(result));\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\t(void)str;\n\t\t\t\tcode = RLC_OK;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (code != RLC_OK) {\n\n\t\t\tTEST_ONCE(\"ecies satisfies test vectors\") {\n\t\t\t\tuint8_t in[] = {\n\t\t\t\t\t0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF\n\t\t\t\t};\n\t\t\t\tTEST_ASSERT(ec_on_curve(qa) == 1, end);\n\t\t\t\tTEST_ASSERT(ec_on_curve(q_b) == 1, end);\n\t\t\t\tout_len = 16;\n\t\t\t\tTEST_ASSERT(cp_ecies_dec(out, &out_len, q_b, msg, sizeof(msg),\n\t\t\t\t\t\t\t\tda) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(out_len == sizeof(in), end);\n\t\t\t\tTEST_ASSERT(memcmp(out, in, sizeof(in)) == RLC_OK, end);\n\t\t\t\tout_len = 16;\n\t\t\t\tTEST_ASSERT(cp_ecies_dec(out, &out_len, qa, msg, sizeof(msg),\n\t\t\t\t\t\t\t\td_b) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(out_len == sizeof(in), end);\n\t\t\t\tTEST_ASSERT(memcmp(out, in, sizeof(in)) == RLC_OK, end);\n\t\t\t}\n\t\t\tTEST_END;\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tec_free(r);\n\tbn_free(da);\n\tbn_free(d_b);\n\tec_free(qa);\n\tec_free(q_b);\n\treturn code;\n}\n\nstatic int ecdsa(void) {\n\tint code = RLC_ERR;\n\tbn_t d, r, s;\n\tec_t q;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\n\tbn_null(d);\n\tbn_null(r);\n\tbn_null(s);\n\tec_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tec_new(q);\n\n\t\tTEST_CASE(\"ecdsa signature is correct\") {\n\t\t\tTEST_ASSERT(cp_ecdsa_gen(d, q) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdsa_sig(r, s, m, sizeof(m), 0, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, m, sizeof(m), 0, q) == 1, end);\n\t\t\tm[0] ^= 1;\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, m, sizeof(m), 0, q) == 0, end);\n\t\t\tmd_map(h, m, sizeof(m));\n\t\t\tTEST_ASSERT(cp_ecdsa_sig(r, s, h, RLC_MD_LEN, 1, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, q) == 1, end);\n\t\t\th[0] ^= 1;\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, q) == 0, end);\n\t\t\tmemset(h, 0, RLC_MD_LEN);\n\t\t\tTEST_ASSERT(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, q) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tbn_free(r);\n\tbn_free(s);\n\tec_free(q);\n\treturn code;\n}\n\nstatic int ecss(void) {\n\tint code = RLC_ERR;\n\tbn_t d, r;\n\tec_t q;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(d);\n\tbn_null(r);\n\tec_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tbn_new(r);\n\t\tec_new(q);\n\n\t\tTEST_CASE(\"ecss signature is correct\") {\n\t\t\tTEST_ASSERT(cp_ecss_gen(d, q) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecss_sig(r, d, m, sizeof(m), d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ecss_ver(r, d, m, sizeof(m), q) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tbn_free(r);\n\tec_free(q);\n\treturn code;\n}\n\nstatic int vbnn(void) {\n\tint code = RLC_ERR;\n\tuint8_t ida[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tuint8_t idb[] = { 5, 6, 7, 8, 9, 0, 1, 2, 3, 4 };\n\tbn_t ska, skb;\n\tec_t pka, pkb;\n\tbn_t msk, z, h;\n\tec_t r, mpk;\n\n\tuint8_t m[] = \"Thrice the brinded cat hath mew'd.\";\n\n\tbn_null(z);\n\tbn_null(h);\n\tbn_null(msk);\n\tbn_null(ska);\n\tbn_null(skb);\n\tec_null(r);\n\tec_null(mpk);\n\tbn_null(pka);\n\tbn_null(pkb);\n\n\tRLC_TRY {\n\t\tbn_new(z);\n\t\tbn_new(h);\n\t\tbn_new(msk);\n\t\tbn_new(ska);\n\t\tbn_new(skb);\n\t\tec_new(r);\n\t\tec_new(mpk);\n\t\tec_new(pka);\n\t\tec_new(pkb);\n\n\t\tTEST_CASE(\"vbnn signature is correct\") {\n\t\t\tTEST_ASSERT(cp_vbnn_gen(msk, mpk) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_gen_prv(ska, pka, msk, ida, sizeof(ida)) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_gen_prv(skb, pkb, msk, idb, sizeof(idb)) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_sig(r, z, h, ida, sizeof(ida), m, sizeof(m), ska, pka) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_ver(r, z, h, ida, sizeof(ida), m, sizeof(m), mpk) == 1, end);\n\t\t\tTEST_ASSERT(cp_vbnn_ver(r, z, h, idb, sizeof(idb), m, sizeof(m), mpk) == 0, end);\n\t\t\tTEST_ASSERT(cp_vbnn_sig(r, z, h, ida, sizeof(ida), m, sizeof(m), skb, pkb) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_vbnn_ver(r, z, h, ida, sizeof(ida), m, sizeof(m), mpk) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(z);\n\tbn_free(h);\n\tbn_free(msk);\n\tbn_free(ska);\n\tbn_free(skb);\n\tec_free(r);\n\tec_free(mpk);\n\tec_free(pka);\n\tec_free(pkb);\n\treturn code;\n}\n\nstatic int pok(void) {\n\tint code = RLC_ERR;\n\tbn_t c[2], n, r[2], x;\n\tec_t y[2];\n\n\tbn_null(n);\n\tbn_null(x);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(x);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tbn_null(c[i]);\n\t\t\tbn_null(r[i]);\n\t\t\tec_null(y[i]);\n\t\t\tbn_new(c[i]);\n\t\t\tbn_new(r[i]);\n\t\t\tec_new(y[i]);\n\t\t}\n\t\tec_curve_get_ord(n);\n\n\t\tTEST_CASE(\"proof of knowledge of discrete logarithm is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tec_mul_gen(y[0], x);\n\t\t\tTEST_ASSERT(cp_pokdl_prv(c[0], r[0], y[0], x) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pokdl_ver(c[0], r[0], y[0]) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_pokdl_ver(c[0], r[0], y[0]) == 0, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"proof of knowledge of disjunction is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tdo {\n\t\t\t\tec_rand(y[0]);\n\t\t\t\tec_mul_gen(y[1], x);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_pokor_prv(c, r, y, x) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pokor_ver(c, r, y) == 1, end);\n\t\t\tec_dbl(y[1], y[1]);\n\t\t\tec_norm(y[1], y[1]);\n\t\t\tTEST_ASSERT(cp_pokor_ver(c, r, y) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(n);\n\tbn_free(x);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_free(c[i]);\n\t\tbn_free(r[i]);\n\t\tec_free(y[i]);\n\t}\n\treturn code;\n}\n\nstatic int sok(void) {\n\tint code = RLC_ERR;\n\tbn_t c[2], n, r[2], x;\n\tec_t g[2], y[2];\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(n);\n\tbn_null(x);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(x);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tbn_null(c[i]);\n\t\t\tbn_null(r[i]);\n\t\t\tec_null(g[i]);\n\t\t\tec_null(y[i]);\n\t\t\tbn_new(c[i]);\n\t\t\tbn_new(r[i]);\n\t\t\tec_new(g[i]);\n\t\t\tec_new(y[i]);\n\t\t}\n\t\tec_curve_get_ord(n);\n\n\t\tTEST_CASE(\"signature of knowledge of discrete logarithm is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tec_mul_gen(y[0], x);\n\t\t\tTEST_ASSERT(cp_sokdl_sig(c[0], r[0], m, 5, y[0], x) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokdl_ver(c[0], r[0], m, 5, y[0]) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_sokdl_ver(c[0], r[0], m, 5, y[0]) == 0, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"signature of knowledge of disjunction is correct\") {\n\t\t\tbn_rand_mod(x, n);\n\t\t\tdo {\n\t\t\t\tec_rand(y[0]);\n\t\t\t\tec_mul_gen(y[1], x);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, NULL, x, 0) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 1, end);\n\t\t\tec_dbl(y[1], y[1]);\n\t\t\tec_norm(y[1], y[1]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 0, end);\n\t\t\tdo {\n\t\t\t\tec_mul_gen(y[0], x);\n\t\t\t\tec_rand(y[1]);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, NULL, x, 1) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, NULL) == 0, end);\n\t\t\tdo {\n\t\t\t\tec_curve_get_gen(g[0]);\n\t\t\t\tec_rand(g[1]);\n\t\t\t\tec_rand(y[0]);\n\t\t\t\tec_mul(y[1], g[1], x);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, g, x, 0) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 1, end);\n\t\t\tec_dbl(y[1], y[1]);\n\t\t\tec_norm(y[1], y[1]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 0, end);\n\t\t\tdo {\n\t\t\t\tec_rand(g[0]);\n\t\t\t\tec_mul(y[0], g[0], x);\n\t\t\t\tec_curve_get_gen(g[1]);\n\t\t\t\tec_rand(y[1]);\n\t\t\t} while (ec_cmp(y[0], y[1]) == RLC_EQ);\n\t\t\tTEST_ASSERT(cp_sokor_sig(c, r,  m, 5, y, g, x, 1) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 1, end);\n\t\t\tec_dbl(y[0], y[0]);\n\t\t\tec_norm(y[0], y[0]);\n\t\t\tTEST_ASSERT(cp_sokor_ver(c, r,  m, 5, y, g) == 0, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(n);\n\tbn_free(x);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_free(c[i]);\n\t\tbn_free(r[i]);\n\t\tec_free(g[i]);\n\t\tec_free(y[i]);\n\t}\n\treturn code;\n}\n\nstatic int ers(void) {\n\tint code = RLC_ERR;\n\tec_t pp, pk[4];\n\tbn_t sk[4], td;\n\ters_t ring[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tsize_t size;\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tRLC_TRY {\n\t\tbn_new(td);\n\t\tec_new(pp);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_new(sk[i]);\n\t\t\tec_null(pk[i]);\n\t\t\tec_new(pk[i]);\n\t\t\ters_null(ring[i]);\n\t\t\ters_new(ring[i]);\n\t\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t\t}\n\n\t\tcp_ers_gen(pp);\n\n\t\tTEST_CASE(\"extendable ring signature scheme is correct\") {\n\t\t\tTEST_ASSERT(cp_ers_sig(td, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, 1, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, 1, m, 0, pp) == 0, end);\n\t\t\tsize = 1;\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_ers_ext(td, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_ers_ver(td, ring, size, m, 0, pp) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i < 4; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\ters_free(ring[i])\n\t}\n\treturn code;\n}\n\nstatic int smlers(void) {\n\tint code = RLC_ERR;\n\tec_t pp, pk[4];\n\tbn_t sk[4], td;\n\tsmlers_t ring[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tsize_t size;\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tRLC_TRY {\n\t\tbn_new(td);\n\t\tec_new(pp);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_new(sk[i]);\n\t\t\tec_null(pk[i]);\n\t\t\tec_new(pk[i]);\n\t\t\tsmlers_null(ring[i]);\n\t\t\tsmlers_new(ring[i]);\n\t\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t\t}\n\n\t\tcp_ers_gen(pp);\n\n\t\tTEST_CASE(\"same-message linkable ext. ring signature scheme is correct\") {\n\t\t\tTEST_ASSERT(cp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, 1, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, 1, m, 0, pp) == 0, end);\n\t\t\tsize = 1;\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_smlers_ext(td, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_smlers_ver(td, ring, size, m, 0, pp) == 0, end);\n\t\t\t\tTEST_ASSERT(ec_cmp(ring[0]->tau, ring[j]->tau) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i < 4; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tsmlers_free(ring[i])\n\t}\n\treturn code;\n}\n\nstatic int etrs(void) {\n\tint code = RLC_ERR;\n\tec_t pp, pk[4];\n\tbn_t sk[4], td[4], y[4];\n\tetrs_t ring[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tsize_t size;\n\n\tec_null(pp);\n\n\tRLC_TRY {\n\t\tec_new(pp);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(td[i]);\n\t\t\tbn_new(td[i]);\n\t\t\tbn_null(y[i]);\n\t\t\tbn_new(y[i]);\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_new(sk[i]);\n\t\t\tec_null(pk[i]);\n\t\t\tec_new(pk[i]);\n\t\t\tetrs_null(ring[i]);\n\t\t\tetrs_new(ring[i]);\n\t\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t\t}\n\n\t\tcp_ers_gen(pp);\n\n\t\tTEST_CASE(\"extendable threshold ring signature scheme is correct\") {\n\t\t\tTEST_ASSERT(cp_etrs_sig(td, y, 4, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(0, td, y, 4, ring, 1, m, 5, pp) == 0, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(1, td, y, 4, ring, 1, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(1, td, y, 4, ring, 1, m, 0, pp) == 0, end);\n\t\t\tsize = 1;\n\t\t\tfor (int j = 1; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_etrs_ext(td, y, 4, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(0, td+j, y+j, 4-j, ring, size, m, 5, pp) == 0, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(1, td+j, y+j, 4-j, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(1, td+j, y+j, 4-j, ring, size, m, 0, pp) == 0, end);\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cp_etrs_sig(td, y, 4, ring[0], m, 5, sk[0], pk[0], pp) == RLC_OK, end);\n\t\t\tsize = 1;\n\t\t\tTEST_ASSERT(cp_etrs_uni(1, td, y, 4, ring, &size, m, 5, sk[1], pk[1], pp) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(1, td, y, 4, ring, size, m, 5, pp) == 0, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(2, td, y, 4, ring, size, m, 5, pp) == 1, end);\n\t\t\tTEST_ASSERT(cp_etrs_ver(2, td, y, 4, ring, size, m, 0, pp) == 0, end);\n\t\t\tfor (int j = 2; j < 4; j++) {\n\t\t\t\tTEST_ASSERT(cp_etrs_ext(td, y, 4, ring, &size, m, 5, pk[j], pp) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(1, td+j-1, y+j-1, 4-j+1, ring, size, m, 5, pp) == 0, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(2, td+j-1, y+j-1, 4-j+1, ring, size, m, 5, pp) == 1, end);\n\t\t\t\tTEST_ASSERT(cp_etrs_ver(2, td+j-1, y+j-1, 4-j+1, ring, size, m, 0, pp) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\nend:\n\tec_free(pp);\n\tfor (int i = 0; i < 4; i++) {\n\t\tbn_free(td[i]);\n\t\tbn_free(y[i]);\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tetrs_free(ring[i])\n\t}\n\treturn code;\n}\n\n#endif /* WITH_EC */\n\n#if defined(WITH_PC)\n\nstatic int pdpub(void) {\n\tint code = RLC_ERR;\n\tbn_t r1, r2;\n\tg1_t p, u1, v1;\n\tg2_t q, u2, v2, w2;\n\tgt_t e, r, g[3];\n\n\tbn_null(r1);\n\tbn_null(r2);\n\tg1_null(p);\n\tg1_null(u1);\n\tg1_null(v1);\n\tg2_null(q);\n\tg2_null(u2);\n\tg2_null(v2);\n\tg2_null(w2);\n\tgt_null(e);\n\tgt_null(r);\n\tgt_null(g[0]);\n\tgt_null(g[1]);\n\tgt_null(g[2]);\n\n\tRLC_TRY {\n\t\tbn_new(r1);\n\t\tbn_new(r2);\n\t\tg1_new(p);\n\t\tg1_new(u1);\n\t\tg1_new(v1);\n\t\tg2_new(q);\n\t\tg2_new(u2);\n\t\tg2_new(v2);\n\t\tg2_new(w2);\n\t\tgt_new(e);\n\t\tgt_new(r);\n\t\tgt_new(g[0]);\n\t\tgt_new(g[1]);\n\t\tgt_new(g[2]);\n\n\t\tTEST_CASE(\"delegated pairing computation with public inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_pdpub_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_pdpub_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdpub_ans(g, p, q, v1, v2, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdpub_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e, p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"faster delegated pairing with public inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_lvpub_gen(r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_lvpub_ask(r1, v1, w2, p, q, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvpub_ans(g, p, q, v1, v2, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvpub_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e, p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(r1);\n\tbn_free(r2);\n\tg1_free(p);\n\tg1_free(u1);\n\tg1_free(v1);\n\tg2_free(q);\n\tg2_free(u2);\n\tg2_free(v2);\n\tg2_free(w2);\n\tgt_free(e);\n\tgt_free(r);\n\tgt_free(g[0]);\n\tgt_free(g[1]);\n\tgt_free(g[2]);\n\treturn code;\n}\n\nstatic int pdprv(void) {\n\tint code = RLC_ERR;\n\tbn_t r1, r2[3];\n\tg1_t p, u1[2], v1[3];\n\tg2_t q, u2[2], v2[4], w2[4];\n\tgt_t e[2], r, g[4];\n\n\tbn_null(r1);\n\tg1_null(p);\n\tg2_null(q);\n\tgt_null(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_null(u1[i]);\n\t\tg2_null(u2[i]);\n\t\tgt_null(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_null(v1[i]);\n\t\tbn_null(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_null(v2[i]);\n\t\tg2_null(w2[i]);\n\t\tgt_null(g[i]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r1);\n\t\tg1_new(p);\n\t\tg2_new(q);\n\t\tgt_new(r);\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tg1_new(u1[i]);\n\t\t\tg2_new(u2[i]);\n\t\t\tgt_new(e[i]);\n\t\t}\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tg1_new(v1[i]);\n\t\t\tbn_new(r2[i]);\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tg2_new(v2[i]);\n\t\t\tg2_new(w2[i]);\n\t\t\tgt_new(g[i]);\n\t\t}\n\n\t\tTEST_CASE(\"delegated pairing computation with private inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_pdprv_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_pdprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdprv_ans(g, v1, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pdprv_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e[0], p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e[0]) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"faster delegated pairing with private inputs is correct\") {\n\t\t\tTEST_ASSERT(cp_pdprv_gen(r1, r2, u1, u2, v2, e) == RLC_OK, end);\n\t\t\tg1_rand(p);\n\t\t\tg2_rand(q);\n\t\t\tTEST_ASSERT(cp_lvprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvprv_ans(g, v1, w2) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_lvprv_ver(r, g, r1, e) == 1, end);\n\t\t\tpc_map(e[0], p, q);\n\t\t\tTEST_ASSERT(gt_cmp(r, e[0]) == RLC_EQ, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(r1);\n\tg1_free(p);\n\tg2_free(q);\n\tgt_free(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_free(u1[i]);\n\t\tg2_free(u2[i]);\n\t\tgt_free(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_free(v1[i]);\n\t\tbn_free(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_free(v2[i]);\n\t\tg2_free(w2[i]);\n\t\tgt_free(g[i]);\n\t}\n\treturn code;\n}\n\nstatic int sokaka(void) {\n\tint code = RLC_ERR, l = RLC_MD_LEN;\n\tsokaka_t k;\n\tbn_t s;\n\tuint8_t k1[RLC_MD_LEN], k2[RLC_MD_LEN];\n\tchar *ia = \"Alice\";\n\tchar *ib = \"Bob\";\n\n\tsokaka_null(k);\n\tbn_null(s);\n\n\tRLC_TRY {\n\t\tsokaka_new(k);\n\t\tbn_new(s);\n\n\t\tcp_sokaka_gen(s);\n\n\t\tTEST_CASE\n\t\t\t\t(\"sakai-ohgishi-kasahara authenticated key agreement is correct\")\n\t\t{\n\t\t\tTEST_ASSERT(cp_sokaka_gen_prv(k, ia, s) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokaka_key(k1, l, ia, k, ib) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokaka_gen_prv(k, ib, s) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_sokaka_key(k2, l, ib, k, ia) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(k1, k2, l) == 0, end);\n\t\t} TEST_END;\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tsokaka_free(k);\n\tbn_free(s);\n\treturn code;\n}\n\nstatic int ibe(void) {\n\tint code = RLC_ERR;\n\tbn_t s;\n\tg1_t pub;\n\tg2_t prv;\n\tuint8_t in[10], out[10 + 2 * RLC_FP_BYTES + 1];\n\tchar *id = \"Alice\";\n\tsize_t il, ol;\n\tint result;\n\n\tbn_null(s);\n\tg1_null(pub);\n\tg2_null(prv);\n\n\tRLC_TRY {\n\t\tbn_new(s);\n\t\tg1_new(pub);\n\t\tg2_new(prv);\n\n\t\tresult = cp_ibe_gen(s, pub);\n\n\t\tTEST_CASE(\"boneh-franklin identity-based encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\til = 10;\n\t\t\tol = il + 2 * RLC_FP_BYTES + 1;\n\t\t\trand_bytes(in, il);\n\t\t\tTEST_ASSERT(cp_ibe_gen_prv(prv, id, s) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ibe_enc(out, &ol, in, il, id, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_ibe_dec(out, &il, out, ol, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(memcmp(in, out, il) == 0, end);\n\t\t} TEST_END;\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(s);\n\tg1_free(pub);\n\tg2_free(prv);\n\treturn code;\n}\n\nstatic int bgn(void) {\n\tint result, code = RLC_ERR;\n\tg1_t c[2], d[2];\n\tg2_t e[2], f[2];\n\tgt_t g[4];\n\tbgn_t pub, prv;\n\tdig_t in, out, t;\n\n\tg1_null(c[0]);\n\tg1_null(c[1]);\n\tg1_null(d[0]);\n\tg1_null(d[1]);\n\tg2_null(e[0]);\n\tg2_null(e[1]);\n\tg2_null(f[0]);\n\tg2_null(f[1]);\n\tbgn_null(pub);\n\tbgn_null(prv);\n\n\tRLC_TRY {\n\t\tg1_new(c[0]);\n\t\tg1_new(c[1]);\n\t\tg1_new(d[0]);\n\t\tg1_new(d[1]);\n\t\tg2_new(e[0]);\n\t\tg2_new(e[1]);\n\t\tg2_new(f[0]);\n\t\tg2_new(f[1]);\n\t\tbgn_new(pub);\n\t\tbgn_new(prv);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tgt_null(g[i]);\n\t\t\tgt_new(g[i]);\n\t\t}\n\n\t\tresult = cp_bgn_gen(pub, prv);\n\n\t\tTEST_CASE(\"boneh-go-nissim encryption/decryption is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\n\t\t\trand_bytes((unsigned char *)&in, sizeof(dig_t));\n\t\t\tin = in % 11;\n\n\t\t\tTEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec1(&out, c, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(e, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec2(&out, e, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == out, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"boneh-go-nissim encryption is additively homomorphic\") {\n\t\t\trand_bytes((unsigned char *)&in, sizeof(dig_t));\n\t\t\tin = in % 11;\n\t\t\tout = in % 7;\n\t\t\tTEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc1(d, out, pub) == RLC_OK, end);\n\t\t\tg1_add(c[0], c[0], d[0]);\n\t\t\tg1_add(c[1], c[1], d[1]);\n\t\t\tg1_norm(c[0], c[0]);\n\t\t\tg1_norm(c[1], c[1]);\n\t\t\tTEST_ASSERT(cp_bgn_dec1(&t, c, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in + out == t, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(e, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(f, out, pub) == RLC_OK, end);\n\t\t\tg2_add(e[0], e[0], f[0]);\n\t\t\tg2_add(e[1], e[1], f[1]);\n\t\t\tg2_norm(e[0], e[0]);\n\t\t\tg2_norm(e[1], e[1]);\n\t\t\tTEST_ASSERT(cp_bgn_dec2(&t, e, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in + out == t, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"boneh-go-nissim encryption is multiplicatively homomorphic\") {\n\t\t\trand_bytes((unsigned char *)&in, sizeof(dig_t));\n\t\t\tin = in % 11;\n\t\t\tout = in % 17;\n\t\t\tTEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(e, out, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc1(d, out, pub) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_enc2(f, in, pub) == RLC_OK, end);\n\t\t\tin = in * out;\n\t\t\tTEST_ASSERT(cp_bgn_mul(g, c, e) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == t, end);\n\t\t\tTEST_ASSERT(cp_bgn_mul(g, d, f) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in == t, end);\n\t\t\tTEST_ASSERT(cp_bgn_add(g, g, g) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);\n\t\t\tTEST_ASSERT(in + in == t, end);\n\t\t} TEST_END;\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tg1_free(c[0]);\n\tg1_free(c[1]);\n\tg1_free(d[0]);\n\tg1_free(d[1]);\n\tg2_free(e[0]);\n\tg2_free(e[1]);\n\tg2_free(f[0]);\n\tg2_free(f[1]);\n\tbgn_free(pub);\n\tbgn_free(prv);\n\tfor (int i = 0; i < 4; i++) {\n\t\tgt_free(g[i]);\n\t}\n\treturn code;\n}\n\nstatic int bls(void) {\n\tint code = RLC_ERR;\n\tbn_t d;\n\tg1_t s;\n\tg2_t q;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(d);\n\tg1_null(s);\n\tg2_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tg1_new(s);\n\t\tg2_new(q);\n\n\t\tTEST_CASE(\"boneh-lynn-schacham short signature is correct\") {\n\t\t\tTEST_ASSERT(cp_bls_gen(d, q) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bls_sig(s, m, sizeof(m), d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bls_ver(s, m, sizeof(m), q) == 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tmemset(m, 0, sizeof(m));\n\t\t\tg2_set_infty(q);\n\t\t\tTEST_ASSERT(cp_bls_ver(s, m, sizeof(m), q) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tg1_free(s);\n\tg2_free(q);\n\treturn code;\n}\n\nstatic int bbs(void) {\n\tint code = RLC_ERR;\n\tbn_t d;\n\tg1_t s;\n\tg2_t q;\n\tgt_t z;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\n\tbn_null(d);\n\tg1_null(s);\n\tg2_null(q);\n\tgt_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tg1_new(s);\n\t\tg2_new(q);\n\t\tgt_new(z);\n\n\t\tTEST_CASE(\"boneh-boyen short signature is correct\") {\n\t\t\tTEST_ASSERT(cp_bbs_gen(d, q, z) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bbs_sig(s, m, sizeof(m), 0, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bbs_ver(s, m, sizeof(m), 0, q, z) == 1, end);\n\t\t\tmd_map(h, m, sizeof(m));\n\t\t\tTEST_ASSERT(cp_bbs_sig(s, m, sizeof(m), 1, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_bbs_ver(s, m, sizeof(m), 1, q, z) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tg1_free(s);\n\tg2_free(q);\n\tgt_free(z);\n\treturn code;\n}\n\nstatic int cls(void) {\n\tint i, code = RLC_ERR;\n\tbn_t r, t, u, v, vs[4];\n\tg1_t a, A, b, B, c, As[4], Bs[4];\n\tg2_t x, y, z, zs[4];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tconst uint8_t *ms[5] = {m, m, m, m, m};\n\tconst size_t ls[5] = {sizeof(m), sizeof(m), sizeof(m), sizeof(m), sizeof(m)};\n\n\tbn_null(r);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(A);\n\tg1_null(b);\n\tg1_null(B);\n\tg1_null(c);\n\tg2_null(x);\n\tg2_null(y);\n\tg2_null(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_null(vs[i]);\n\t\tg1_null(As[i]);\n\t\tg1_null(Bs[i]);\n\t\tg2_null(zs[i]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r);\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tg1_new(a);\n\t\tg1_new(A);\n\t\tg1_new(b);\n\t\tg1_new(B);\n\t\tg1_new(c);\n\t\tg2_new(x);\n\t\tg2_new(y);\n\t\tg2_new(z);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_new(vs[i]);\n\t\t\tg1_new(As[i]);\n\t\t\tg1_new(Bs[i]);\n\t\t\tg2_new(zs[i]);\n\t\t}\n\n\t\tTEST_CASE(\"camenisch-lysyanskaya simple signature is correct\") {\n\t\t\tTEST_ASSERT(cp_cls_gen(u, v, x, y) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cls_sig(a, b, c, m, sizeof(m), u, v) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cls_ver(a, b, c, m, sizeof(m), x, y) == 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tg1_set_infty(a);\n\t\t\tg1_set_infty(b);\n\t\t\tg1_set_infty(c);\n\t\t\tTEST_ASSERT(cp_cls_ver(a, b, c, m, sizeof(m), x, y) == 0, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"camenisch-lysyanskaya message-independent signature is correct\") {\n\t\t\tbn_rand(r, RLC_POS, 2 * pc_param_level());\n\t\t\tTEST_ASSERT(cp_cli_gen(t, u, v, x, y, z) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cli_sig(a, A, b, B, c, m, sizeof(m), r, t, u, v)\n\t\t\t\t\t== RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z)\n\t\t\t\t\t== 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tg1_set_infty(a);\n\t\t\tg1_set_infty(A);\n\t\t\tg1_set_infty(b);\n\t\t\tg1_set_infty(B);\n\t\t\tg1_set_infty(c);\n\t\t\tTEST_ASSERT(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z) == 0, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"camenisch-lysyanskaya message-block signature is correct\") {\n\t\t\tTEST_ASSERT(cp_clb_gen(t, u, vs, x, y, zs, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_clb_sig(a, As, b, Bs, c, ms, ls, t, u, vs, 5)\n\t\t\t\t\t== RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_clb_ver(a, As, b, Bs, c, ms, ls, x, y, zs, 5)\n\t\t\t\t\t== 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(r);\n\tbn_free(t);\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(A);\n\tg1_free(b);\n\tg1_free(B);\n\tg1_free(c);\n\tg2_free(x);\n\tg2_free(y);\n\tg2_free(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_free(vs[i]);\n\t\tg1_free(As[i]);\n\t\tg1_free(Bs[i]);\n\t\tg2_free(zs[i]);\n\t}\n\treturn code;\n}\n\nstatic int pss(void) {\n\tint i, code = RLC_ERR;\n\tbn_t ms[5], n, u, v, _v[5];\n\tg1_t a, b;\n\tg2_t g, x, y, _y[5];\n\n\tbn_null(n);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(b);\n\tg2_null(g);\n\tg2_null(x);\n\tg2_null(y);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg2_new(g);\n\t\tg2_new(x);\n\t\tg2_new(y);\n\n\t\tg1_get_ord(n);\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tbn_null(ms[i]);\n\t\t\tbn_null(_v[i]);\n\t\t\tg2_null(_y[i]);\n\t\t\tbn_new(ms[i]);\n\t\t\tbn_rand_mod(ms[i], n);\n\t\t\tbn_new(_v[i]);\n\t\t\tg2_new(_y[i]);\n\t\t}\n\n\t\tTEST_CASE(\"pointcheval-sanders simple signature is correct\") {\n\t\t\tTEST_ASSERT(cp_pss_gen(u, v, g, x, y) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pss_sig(a, b, ms[0], u, v) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_pss_ver(a, b, ms[0], g, x, y) == 1, end);\n\t\t\t/* Check adversarial signature. */\n\t\t\tg1_set_infty(a);\n\t\t\tg1_set_infty(b);\n\t\t\tTEST_ASSERT(cp_pss_ver(a, b, ms[0], g, x, y) == 0, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"pointcheval-sanders block signature is correct\") {\n\t\t\tTEST_ASSERT(cp_psb_gen(u, _v, g, x, _y, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_psb_sig(a, b, ms, u, _v, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_psb_ver(a, b, ms, g, x, _y, 5) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(n);\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(b);\n\tg2_free(g);\n\tg2_free(x);\n\tg2_free(y);\n\tfor (i = 0; i < 5; i++) {\n\t\tbn_free(ms[i]);\n\t\tbn_free(_v[i]);\n\t\tg2_free(_y[i]);\n\t}\n\treturn code;\n}\n\n#if defined(WITH_MPC)\n\nstatic int mpss(void) {\n\tint i, j, code = RLC_ERR;\n\tbn_t m[2], n, u[2], v[2], ms[5][2], _v[5][2];\n\tg1_t g, s[2];\n\tg2_t h, x[2], y[2], _y[5][2];\n\tgt_t e[2], f[2];\n\tmt_t tri[3][2];\n\tpt_t t[2];\n\n\tbn_null(n);\n\tg1_null(g);\n\tg2_null(h);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tg1_new(g);\n\t\tg2_new(h);\n\t\tg1_get_ord(n);\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tbn_null(m[i]);\n\t\t\tbn_null(u[i]);\n\t\t\tbn_null(v[i]);\n\t\t\tg1_null(s[i]);\n\t\t\tg2_null(x[i]);\n\t\t\tg2_null(y[i]);\n\t\t\tgt_null(e[i]);\n\t\t\tgt_null(f[i]);\n\t\t\tmt_null(tri[0][i]);\n\t\t\tmt_null(tri[1][i]);\n\t\t\tmt_null(tri[2][i]);\n\t\t\tpt_null(t[i]);\n\t\t\tbn_new(m[i]);\n\t\t\tbn_rand_mod(m[i], n);\n\t\t\tbn_new(u[i]);\n\t\t\tbn_new(v[i]);\n\t\t\tg1_new(s[i]);\n\t\t\tg2_new(x[i]);\n\t\t\tg2_new(y[i]);\n\t\t\tgt_new(e[i]);\n\t\t\tgt_new(f[i]);\n\t\t\tmt_new(tri[0][i]);\n\t\t\tmt_new(tri[1][i]);\n\t\t\tmt_new(tri[2][i]);\n\t\t\tpt_new(t[i]);\n\t\t\tfor (j = 0; j < 5; j++) {\n\t\t\t\tbn_null(ms[j][i]);\n\t\t\t\tbn_null(_v[j][i]);\n\t\t\t\tg2_null(_y[j][i]);\n\t\t\t\tbn_new(ms[j][i]);\n\t\t\t\tbn_rand_mod(ms[j][i], n);\n\t\t\t\tbn_new(_v[j][i]);\n\t\t\t\tg2_new(_y[j][i]);\n\t\t\t}\n\t\t}\n\n\t\tTEST_CASE(\"multi-party pointcheval-sanders simple signature is correct\") {\n\t\t\tpc_map_tri(t);\n\t\t\tmpc_mt_gen(tri[0], n);\n\t\t\tmpc_mt_gen(tri[1], n);\n\t\t\tmpc_mt_gen(tri[2], n);\n\t\t\tgt_exp_gen(e[0], tri[2][0]->b);\n\t\t\tgt_exp_gen(e[1], tri[2][1]->b);\n\t\t\tgt_exp_gen(f[0], tri[2][0]->c);\n\t\t\tgt_exp_gen(f[1], tri[2][1]->c);\n\t\t\ttri[2][0]->bt = &e[0];\n\t\t\ttri[2][1]->bt = &e[1];\n\t\t\ttri[2][0]->ct = &f[0];\n\t\t\ttri[2][1]->ct = &f[1];\n\t\t\tTEST_ASSERT(cp_mpss_gen(u, v, h, x, y) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_mpss_bct(x, y) == RLC_OK, end);\n\t\t\t/* Compute signature in MPC. */\n\t\t\tTEST_ASSERT(cp_mpss_sig(g, s, m, u, v, tri[0], tri[1]) == RLC_OK, end);\n\t\t\t/* Verify signature in MPC. */\n\t\t\tcp_mpss_ver(e[0], g, s, m, h, x[0], y[0], tri[2], t);\n\t\t\tTEST_ASSERT(gt_is_unity(e[0]) == 1, end);\n\t\t\t/* Check that signature is also valid for conventional scheme. */\n\t\t\tbn_add(m[0], m[0], m[1]);\n\t\t\tbn_mod(m[0], m[0], n);\n\t\t\tg1_add(s[0], s[0], s[1]);\n\t\t\tg1_norm(s[0], s[0]);\n\t\t\tTEST_ASSERT(cp_pss_ver(g, s[0], m[0], h, x[0], y[0]) == 1, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"multi-party pointcheval-sanders block signature is correct\") {\n\t\t\tg1_get_ord(n);\n\t\t\tpc_map_tri(t);\n\t\t\tmpc_mt_gen(tri[0], n);\n\t\t\tmpc_mt_gen(tri[1], n);\n\t\t\tmpc_mt_gen(tri[2], n);\n\t\t\tgt_exp_gen(e[0], tri[2][0]->b);\n\t\t\tgt_exp_gen(e[1], tri[2][1]->b);\n\t\t\tgt_exp_gen(f[0], tri[2][0]->c);\n\t\t\tgt_exp_gen(f[1], tri[2][1]->c);\n\t\t\ttri[2][0]->bt = &e[0];\n\t\t\ttri[2][1]->bt = &e[1];\n\t\t\ttri[2][0]->ct = &f[0];\n\t\t\ttri[2][1]->ct = &f[1];\n\t\t\tTEST_ASSERT(cp_mpsb_gen(u, _v, h, x, _y, 5) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_mpsb_bct(x, _y, 5) == RLC_OK, end);\n\t\t\t/* Compute signature in MPC. */\n\t\t\tTEST_ASSERT(cp_mpsb_sig(g, s, ms, u, _v, tri[0], tri[1], 5) == RLC_OK, end);\n\t\t\t/* Verify signature in MPC. */\n\t\t\tcp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, NULL, tri[2], t, 5);\n\t\t\tTEST_ASSERT(gt_is_unity(e[1]) == 1, end);\n\t\t\tgt_exp_gen(e[0], tri[2][0]->b);\n\t\t\tgt_exp_gen(e[1], tri[2][1]->b);\n\t\t\tcp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 5);\n\t\t\tTEST_ASSERT(gt_is_unity(e[1]) == 1, end);\n\t\t\tbn_sub_dig(ms[0][0], ms[0][0], 1);\n\t\t\tcp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 5);\n\t\t\tTEST_ASSERT(gt_is_unity(e[1]) == 0, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(n);\n\tg1_free(g);\n\tg2_free(h);\n\tfor (i = 0; i < 2; i++) {\n\t\tbn_free(m[i]);\n\t\tbn_free(u[i]);\n\t\tbn_free(v[i]);\n\t\tg1_free(s[i]);\n\t\tg2_free(x[i]);\n\t\tg2_free(y[i]);\n\t\tgt_free(e[i]);\n\t\tgt_free(f[i]);\n\t\tmt_free(tri[0][i]);\n\t\tmt_free(tri[1][i]);\n\t\tmt_free(tri[2][i]);\n\t\tpt_free(t[i]);\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tbn_free(ms[j][i]);\n\t\t\tbn_free(_v[j][i]);\n\t\t\tg2_free(_y[j][i]);\n\t\t}\n\t}\n\treturn code;\n}\n\n#endif\n\nstatic int zss(void) {\n\tint code = RLC_ERR;\n\tbn_t d;\n\tg1_t q;\n\tg2_t s;\n\tgt_t z;\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\n\tbn_null(d);\n\tg1_null(q);\n\tg2_null(s);\n\tgt_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(d);\n\t\tg1_new(q);\n\t\tg2_new(s);\n\t\tgt_new(z);\n\n\t\tTEST_CASE(\"zhang-safavi-naini-susilo signature is correct\") {\n\t\t\tTEST_ASSERT(cp_zss_gen(d, q, z) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_zss_sig(s, m, sizeof(m), 0, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_zss_ver(s, m, sizeof(m), 0, q, z) == 1, end);\n\t\t\tmd_map(h, m, sizeof(m));\n\t\t\tTEST_ASSERT(cp_zss_sig(s, m, sizeof(m), 1, d) == RLC_OK, end);\n\t\t\tTEST_ASSERT(cp_zss_ver(s, m, sizeof(m), 1, q, z) == 1, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(d);\n\tg1_free(q);\n\tg2_free(s);\n\tgt_free(z);\n\treturn code;\n}\n\n#define S\t2\t\t\t/* Number of signers. */\n#define L\t4\t\t\t/* Number of labels. */\n#define K\tRLC_MD_LEN\t/* Size of PRF key. */\n\nstatic int lhs(void) {\n\tint code = RLC_ERR;\n\tuint8_t k[S][K];\n\tbn_t m, n, msg[S][L], sk[S], d[S], x[S][L];\n\tg1_t _r, h, as[S], cs[S], sig[S];\n\tg1_t a[S][L], c[S][L], r[S][L];\n\tg2_t _s, s[S][L], pk[S], y[S], z[S];\n\tgt_t *hs[S], vk;\n\tconst char *data = \"database-identifier\";\n\tconst char *id[S] = { \"Alice\", \"Bob\" };\n\tdig_t ft[S], *f[S] = { NULL };\n\tsize_t flen[S];\n\tchar *ls[L] = { NULL };\n\n\tbn_null(m);\n\tbn_null(n);\n\tg1_null(h);\n\tg1_null(_r);\n\tg2_null(_s);\n\tgt_null(vk);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(n);\n\t\tg1_new(h);\n\t\tg1_new(_r);\n\t\tg2_new(_s);\n\t\tgt_new(vk);\n\n\t\tfor (int i = 0; i < S; i++) {\n\t\t\ths[i] = RLC_ALLOCA(gt_t, RLC_TERMS);\n\t\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\t\tgt_null(hs[i][j]);\n\t\t\t\tgt_new(hs[i][j]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < L; j++) {\n\t\t\t\tbn_null(x[i][j]);\n\t\t\t\tbn_null(msg[i][j]);\n\t\t\t\tg1_null(a[i][j]);\n\t\t\t\tg1_null(c[i][j]);\n\t\t\t\tg1_null(r[i][j]);\n\t\t\t\tg2_null(s[i][j]);\n\t\t\t\tbn_new(x[i][j]);\n\t\t\t\tbn_new(msg[i][j]);\n\t\t\t\tg1_new(a[i][j]);\n\t\t\t\tg1_new(c[i][j]);\n\t\t\t\tg1_new(r[i][j]);\n\t\t\t\tg2_new(s[i][j]);\n\t\t\t}\n\t\t\tbn_null(sk[i]);\n\t\t\tbn_null(d[i]);\n\t\t\tg1_null(sig[i]);\n\t\t\tg1_null(as[i]);\n\t\t\tg1_null(cs[i]);\n\t\t\tg2_null(y[i]);\n\t\t\tg2_null(z[i]);\n\t\t\tg2_null(pk[i]);\n\n\t\t\tbn_new(sk[i]);\n\t\t\tbn_new(d[i]);\n\t\t\tg1_new(sig[i]);\n\t\t\tg1_new(as[i]);\n\t\t\tg1_new(cs[i]);\n\t\t\tg2_new(y[i]);\n\t\t\tg2_new(z[i]);\n\t\t\tg2_new(pk[i]);\n\t\t}\n\n\t\t/* Define linear function. */\n\t\tfor (int i = 0; i < S; i++) {\n\t\t\tf[i] = RLC_ALLOCA(dig_t, RLC_TERMS);\n\t\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\t\tdig_t t;\n\t\t\t\trand_bytes((uint8_t *)&t, sizeof(dig_t));\n\t\t\t\tf[i][j] = t & RLC_MASK(RLC_DIG / 2);\n\t\t\t}\n\t\t\tflen[i] = L;\n\t\t}\n\n\t\t/* Initialize scheme for messages of single components. */\n\t\tg1_get_ord(n);\n\t\tcp_cmlhs_init(h);\n\n\t\tTEST_CASE(\"context-hiding linear homomorphic signature is correct\") {\n\t\t\tint label[L], b = i % 2;\n\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], b);\n\t\t\t}\n\t\t\t/* Compute all signatures (ECDSA if b = 0; BLS if b = 1). */\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tlabel[l] = l;\n\t\t\t\t\tbn_rand_mod(msg[j][l], n);\n\t\t\t\t\tcp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l],\n\t\t\t\t\t\ts[j][l], msg[j][l], data, label[l], x[j][l], h, k[j], K,\n\t\t\t\t\t\td[j], sk[j], b);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Apply linear function over signatures. */\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], flen[j]);\n\t\t\t}\n\n\t\t\tcp_cmlhs_evl(_r, _s, r[0], s[0], f[0], flen[0]);\n\t\t\tfor (int j = 1; j < S; j++) {\n\t\t\t\tcp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], flen[j]);\n\t\t\t\tg1_add(_r, _r, r[0][0]);\n\t\t\t\tg2_add(_s, _s, s[0][0]);\n\t\t\t}\n\t\t\tg1_norm(_r, _r);\n\t\t\tg2_norm(_s, _s);\n\t\t\t/* We share messages between users to simplify tests. */\n\t\t\tbn_zero(m);\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tbn_mul_dig(msg[j][l], msg[j][l], f[j][l]);\n\t\t\t\t\tbn_add(m, m, msg[j][l]);\n\t\t\t\t\tbn_mod(m, m, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t\t(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, b), end);\n\n\t\t\tcp_cmlhs_off(vk, h, label, (const gt_t **)hs, (const dig_t **)f,\n\t\t\t\tflen, S);\n\t\t\tTEST_ASSERT(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk,\n\t\t\t\ty, pk, S, b) == 1, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"simple linear multi-key homomorphic signature is correct\") {\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_mklhs_gen(sk[j], pk[j]);\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tls[l] = \"l\";\n\t\t\t\t\tbn_rand_mod(msg[j][l], n);\n\t\t\t\t\tcp_mklhs_sig(a[j][l], msg[j][l], data, id[j], ls[l], sk[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_mklhs_fun(d[j], msg[j], f[j], L);\n\t\t\t}\n\n\t\t\tg1_set_infty(_r);\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tcp_mklhs_evl(r[0][j], a[j], f[j], L);\n\t\t\t\tg1_add(_r, _r, r[0][j]);\n\t\t\t}\n\t\t\tg1_norm(_r, _r);\n\n\t\t\tbn_zero(m);\n\t\t\tfor (int j = 0; j < S; j++) {\n\t\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\t\tbn_mul_dig(msg[j][l], msg[j][l], f[j][l]);\n\t\t\t\t\tbn_add(m, m, msg[j][l]);\n\t\t\t\t\tbn_mod(m, m, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tTEST_ASSERT(cp_mklhs_ver(_r, m, d, data, id, (const char **)ls,\n\t\t\t\t\t(const dig_t **)f, flen, pk, S), end);\n\n\t\t\tcp_mklhs_off(as, ft, id, (const char **)ls, (const dig_t **)f,\n\t\t\t\t\tflen, S);\n\t\t\tTEST_ASSERT(cp_mklhs_onv(_r, m, d, data, id, as, ft, pk, S), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n\n  end:\n\tbn_free(n);\n\tbn_free(m);\n\tg1_free(h);\n\tg1_free(_r);\n\tg2_free(_s);\n\tgt_free(vk);\n\n\tfor (int i = 0; i < S; i++) {\n\t\tRLC_FREE(f[i]);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\t  gt_free(hs[i][j]);\n\t\t}\n\t\tRLC_FREE(hs[i]);\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tbn_free(x[i][j]);\n\t\t\tbn_free(msg[i][j]);\n\t\t\tg1_free(a[i][j]);\n\t\t\tg1_free(c[i][j]);\n\t\t\tg1_free(r[i][j]);\n\t\t\tg2_free(s[i][j]);\n\t\t}\n\t\tbn_free(sk[i]);\n\t\tbn_free(d[i]);\n\t\tg1_free(sig[i]);\n\t\tg1_free(as[i]);\n\t\tg1_free(cs[i]);\n\t\tg2_free(y[i]);\n\t\tg2_free(z[i]);\n\t\tg2_free(pk[i]);\n\t}\n\treturn code;\n}\n\n#define M\t5\t\t\t/* Number of server messages (larger). */\n#define N\t2\t\t\t/* Number of client messages. */\n\nstatic int psi(void) {\n\tint result, code = RLC_ERR;\n\tbn_t g, n, q, r, p[M], x[M], v[N], w[N], y[N], z[M];\n\tg1_t u[M], ss;\n\tg2_t d[M + 1], s[M + 1];\n\tgt_t t[M];\n\tcrt_t crt;\n\tsize_t l;\n\n\tbn_null(g);\n\tbn_null(n);\n\tbn_null(q);\n\tbn_null(r);\n\tg1_null(ss);\n\tcrt_null(crt);\n\n\tRLC_TRY {\n\t\tbn_new(g);\n\t\tbn_new(n);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\t\tg1_new(ss);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tbn_null(p[i]);\n\t\t\tbn_null(x[i]);\n\t\t\tbn_null(z[i]);\n\t\t\tg2_null(d[i]);\n\t\t\tg2_null(s[i]);\n\t\t\tbn_new(p[i]);\n\t\t\tbn_new(x[i]);\n\t\t\tbn_new(z[i]);\n\t\t\tg2_new(d[i]);\n\t\t\tg2_new(s[i]);\n\t\t}\n\t\tg2_null(s[M]);\n\t\tg2_new(s[M]);\n\t\tg2_null(d[M]);\n\t\tg2_new(d[M]);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tbn_null(v[i]);\n\t\t\tbn_null(w[i]);\n\t\t\tbn_null(y[i]);\n\t\t\tg1_null(u[i]);\n\t\t\tgt_null(t[i]);\n\t\t\tbn_new(v[i]);\n\t\t\tbn_new(w[i]);\n\t\t\tbn_new(y[i]);\n\t\t\tg1_new(u[i]);\n\t\t\tgt_new(t[i]);\n\t\t}\n\t\tcrt_new(crt);\n\n\t\tresult = cp_rsapsi_gen(g, n, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"factoring-based laconic private set intersection is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tbn_rand_mod(x[j], n);\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tbn_rand_mod(y[j], n);\n\t\t\t}\n\t\t\tTEST_ASSERT(cp_rsapsi_ask(q, r, p, g, n, x, M) == RLC_OK, end);\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tbn_copy(y[j], x[j]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(cp_rsapsi_ans(v, w, q, g, n, y, N) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_rsapsi_int(z, &l, r, p, n, x, M, v, w, N) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(l == k, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tresult = cp_shipsi_gen(g, crt, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"factoring-based size-hiding private set intersection is correct\") {\n\t\t\tTEST_ASSERT(result == RLC_OK, end);\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tbn_rand_mod(x[j], crt->n);\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tbn_rand_mod(y[j], crt->n);\n\t\t\t}\n\t\t\tTEST_ASSERT(cp_shipsi_ask(q, r, p, g, crt->n, x, M) == RLC_OK, end);\n\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\tbn_copy(y[j], x[j]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(cp_shipsi_ans(v, w[0], q, g, crt, y, N) == RLC_OK,\n\t\t\t\t\tend);\n\t\t\t\tTEST_ASSERT(cp_shipsi_int(z, &l, r, p, crt->n, x, M, v, w[0],\n\t\t\t\t\tN) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(l == k, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tif (pc_param_set_any() == RLC_OK) {\n\t\t\tTEST_CASE(\"pairing-based laconic private set intersection is correct\") {\n\t\t\t\tpc_get_ord(q);\n\t\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\t\tbn_rand_mod(x[j], q);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tbn_rand_mod(y[j], q);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(cp_pbpsi_gen(q, ss, s, M) == RLC_OK, end);\n\t\t\t\tTEST_ASSERT(cp_pbpsi_ask(d, r, x, s, M) == RLC_OK, end);\n\t\t\t\tfor (int k = 0; k <= N; k++) {\n\t\t\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\t\t\tbn_copy(y[j], x[j]);\n\t\t\t\t\t}\n\t\t\t\t\tTEST_ASSERT(cp_pbpsi_ans(t, u, ss, d[0], y, N) == RLC_OK, end);\n\t\t\t\t\tTEST_ASSERT(cp_pbpsi_int(z, &l, d, x, M, t, u, N) == RLC_OK,\n\t\t\t\t\t\tend);\n\t\t\t\t\tTEST_ASSERT(l == k, end);\n\t\t\t\t}\n\t\t\t} TEST_END;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n  \tbn_free(g);\n\tbn_free(n);\n    bn_free(q);\n\tbn_free(r);\n\tg1_free(ss);\n\tfor (int i = 0; i < M; i++) {\n\t\tbn_free(p[i]);\n\t\tbn_free(x[i]);\n\t\tbn_free(z[i]);\n\t\tg2_free(d[i]);\n\t\tg2_free(s[i]);\n\t}\n\tg2_free(d[M]);\n\tg2_free(s[M]);\n\tfor (int i = 0; i < N; i++) {\n\t\tbn_free(v[i]);\n\t\tbn_free(w[i]);\n\t\tbn_free(y[i]);\n\t\tg1_free(u[i]);\n\t\tgt_free(t[i]);\n\t}\n\tcrt_free(crt);\n\treturn code;\n}\n\n#endif /* WITH_PC */\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the CP module\", 0);\n\n#if defined(WITH_BN)\n\tutil_banner(\"Protocols based on integer factorization:\\n\", 0);\n\tif (rsa() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (rabin() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (benaloh() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (paillier() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (subgroup_paillier() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n#endif\n\n#if defined(WITH_EC)\n\tutil_banner(\"Protocols based on elliptic curves:\\n\", 0);\n\tif (ec_param_set_any() == RLC_OK) {\n\n\t\tif (ecdh() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ecmqv() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n#if defined(WITH_BC)\n\t\tif (ecies() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n#endif\n\n\t\tif (ecdsa() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ecss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (vbnn() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (pok() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sok() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ers() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (smlers() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (etrs() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n#if defined(WITH_PC)\n\tutil_banner(\"Protocols based on pairings:\\n\", 0);\n\tif (pc_param_set_any() == RLC_OK) {\n\n\t\tif (pdpub() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (pdprv() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (sokaka() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (ibe() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bgn() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bls() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (bbs() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (cls() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (pss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n#if defined(WITH_MPC)\n\t\tif (mpss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n#endif\n\n\t\tif (zss() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (lhs() != RLC_OK) {\n\t\t\tcore_clean();\n\t\t\treturn 1;\n\t\t}\n\t}\n#endif\n\n#if defined(WITH_BN) && defined(WITH_PC)\n\tutil_banner(\"Protocols based on accumulators:\\n\", 0);\n\tif (psi() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n#endif\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n"], "filenames": ["include/relic_bn.h", "include/relic_label.h", "src/bn/relic_bn_prime.c", "test/test_cp.c"], "buggy_code_start_loc": [1274, 267, 172, 134], "buggy_code_end_loc": [1283, 377, 179, 2468], "fixing_code_start_loc": [1273, 266, 171, 135], "fixing_code_end_loc": [1273, 374, 171, 2470], "type": "CWE-190", "message": "Integer Overflow vulnerability in RELIC before commit 421f2e91cf2ba42473d4d54daf24e295679e290e, allows attackers to execute arbitrary code and cause a denial of service in pos argument in bn_get_prime function.", "other": {"cve": {"id": "CVE-2023-36327", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-01T16:15:08.127", "lastModified": "2023-09-06T00:05:15.863", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer Overflow vulnerability in RELIC before commit 421f2e91cf2ba42473d4d54daf24e295679e290e, allows attackers to execute arbitrary code and cause a denial of service in pos argument in bn_get_prime function."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de enteros en RELIC antes del commit 421f2e91cf2ba42473d4d54daf24e295679e290e, permite a los atacantes ejecutar c\u00f3digo arbitrario y causar una denegaci\u00f3n de servicio en el argumento \"pos\" en la funci\u00f3n \"\"bn_get_prime\"."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:relic_project:relic:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-11-14", "matchCriteriaId": "D636CA1B-2334-4D2F-92E0-FADDA9CDF77B"}]}]}], "references": [{"url": "https://github.com/relic-toolkit/relic/commit/421f2e91cf2ba42473d4d54daf24e295679e290e", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://groups.google.com/g/relic-discuss/c/A_J2-ArVIAo/m/qgFiXsUJBQAJ?utm_medium=email&utm_source=footer", "source": "cve@mitre.org", "tags": ["Mailing List"]}]}, "github_commit_url": "https://github.com/relic-toolkit/relic/commit/421f2e91cf2ba42473d4d54daf24e295679e290e"}}