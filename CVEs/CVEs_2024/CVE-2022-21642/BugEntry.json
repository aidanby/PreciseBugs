{"buggy_code": ["# frozen_string_literal: true\n\nclass UserSearch\n\n  MAX_SIZE_PRIORITY_MENTION ||= 500\n\n  def initialize(term, opts = {})\n    @term = term.downcase\n    @term_like = @term.gsub(\"_\", \"\\\\_\") + \"%\"\n    @topic_id = opts[:topic_id]\n    @category_id = opts[:category_id]\n    @topic_allowed_users = opts[:topic_allowed_users]\n    @searching_user = opts[:searching_user]\n    @include_staged_users = opts[:include_staged_users] || false\n    @last_seen_users = opts[:last_seen_users] || false\n    @limit = opts[:limit] || 20\n    @groups = opts[:groups]\n\n    @topic = Topic.find(@topic_id) if @topic_id\n    @category = Category.find(@category_id) if @category_id\n\n    @guardian = Guardian.new(@searching_user)\n    @guardian.ensure_can_see_groups_members!(@groups) if @groups\n    @guardian.ensure_can_see_category!(@category) if @category\n    @guardian.ensure_can_see_topic!(@topic) if @topic\n  end\n\n  def scoped_users\n    users = User.where(active: true)\n    users = users.where(staged: false) unless @include_staged_users\n    users = users.not_suspended unless @searching_user&.staff?\n\n    if @groups\n      users = users\n        .joins(:group_users)\n        .where(\"group_users.group_id IN (?)\", @groups.map(&:id))\n    end\n\n    # Only show users who have access to private topic\n    if @topic_allowed_users == \"true\" && @topic&.category&.read_restricted\n      users = users\n        .references(:categories)\n        .includes(:secure_categories)\n        .where(\"users.admin OR categories.id = ?\", @topic.category_id)\n    end\n\n    users\n  end\n\n  def filtered_by_term_users\n    if @term.blank?\n      scoped_users\n    elsif SiteSetting.enable_names? && @term !~ /[_\\.-]/\n      query = Search.ts_query(term: @term, ts_config: \"simple\")\n\n      scoped_users\n        .includes(:user_search_data)\n        .where(\"user_search_data.search_data @@ #{query}\")\n        .order(DB.sql_fragment(\"CASE WHEN username_lower LIKE ? THEN 0 ELSE 1 END ASC\", @term_like))\n    else\n      scoped_users.where(\"username_lower LIKE :term_like\", term_like: @term_like)\n    end\n  end\n\n  def search_ids\n    users = Set.new\n\n    # 1. exact username matches\n    if @term.present?\n      exact_matches = scoped_users.where(username_lower: @term)\n\n      # don't pollute mentions with users who haven't shown up in over a year\n      exact_matches = exact_matches.where('last_seen_at > ?', 1.year.ago) if @topic_id || @category_id\n\n      exact_matches\n        .limit(@limit)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    return users.to_a if users.size >= @limit\n\n    # 2. in topic\n    if @topic_id\n      in_topic = filtered_by_term_users\n        .where('users.id IN (SELECT user_id FROM posts WHERE topic_id = ?)', @topic_id)\n\n      if @searching_user.present?\n        in_topic = in_topic.where('users.id <> ?', @searching_user.id)\n      end\n\n      in_topic\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    return users.to_a if users.size >= @limit\n\n    # 3. in category\n    secure_category_id =\n      if @category_id\n        DB.query_single(<<~SQL, @category_id).first\n          SELECT id\n            FROM categories\n           WHERE read_restricted\n             AND id = ?\n        SQL\n      elsif @topic_id\n        DB.query_single(<<~SQL, @topic_id).first\n          SELECT id\n            FROM categories\n           WHERE read_restricted\n             AND id IN (SELECT category_id FROM topics WHERE id = ?)\n        SQL\n      end\n\n    if secure_category_id\n      category_groups = Group.where(<<~SQL, secure_category_id, MAX_SIZE_PRIORITY_MENTION)\n        groups.id IN (\n          SELECT group_id\n            FROM category_groups\n            JOIN groups g ON group_id = g.id\n           WHERE category_id = ?\n             AND user_count < ?\n        )\n      SQL\n\n      if @searching_user.present?\n        category_groups = category_groups.members_visible_groups(@searching_user)\n      end\n\n      in_category = filtered_by_term_users\n        .where(<<~SQL, category_groups.pluck(:id))\n          users.id IN (\n            SELECT gu.user_id\n              FROM group_users gu\n             WHERE group_id IN (?)\n             LIMIT 200\n          )\n          SQL\n\n      if @searching_user.present?\n        in_category = in_category.where('users.id <> ?', @searching_user.id)\n      end\n\n      in_category\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    return users.to_a if users.size >= @limit\n\n    # 4. global matches\n    if @term.present?\n      filtered_by_term_users\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    # 5. last seen users (for search auto-suggestions)\n    if @last_seen_users\n      scoped_users\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    users.to_a\n  end\n\n  def search\n    ids = search_ids\n    return User.where(\"0=1\") if ids.empty?\n\n    User.joins(\"JOIN (SELECT unnest uid, row_number() OVER () AS rn\n      FROM unnest('{#{ids.join(\",\")}}'::int[])\n    ) x on uid = users.id\")\n      .order(\"rn\")\n  end\n\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe UserSearch do\n\n  before_all { SearchIndexer.enable } # Enable for prefabrication\n  before { SearchIndexer.enable } # Enable for each test\n\n  fab!(:topic)     { Fabricate :topic }\n  fab!(:topic2)    { Fabricate :topic }\n  fab!(:topic3)    { Fabricate :topic }\n  fab!(:topic4)    { Fabricate :topic }\n  fab!(:mr_b)      { Fabricate :user, username: \"mrb\",      name: \"Michael Madsen\",    last_seen_at: 10.days.ago }\n  fab!(:mr_blue)   { Fabricate :user, username: \"mrblue\",   name: \"Eddie Code\",        last_seen_at: 9.days.ago }\n  fab!(:mr_orange) { Fabricate :user, username: \"mrorange\", name: \"Tim Roth\",          last_seen_at: 8.days.ago }\n  fab!(:mr_pink)   { Fabricate :user, username: \"mrpink\",   name: \"Steve Buscemi\",     last_seen_at: 7.days.ago }\n  fab!(:mr_brown)  { Fabricate :user, username: \"mrbrown\",  name: \"Quentin Tarantino\", last_seen_at: 6.days.ago }\n  fab!(:mr_white)  { Fabricate :user, username: \"mrwhite\",  name: \"Harvey Keitel\",     last_seen_at: 5.days.ago }\n  fab!(:inactive)  { Fabricate :user, username: \"Ghost\", active: false }\n  fab!(:admin)     { Fabricate :admin, username: \"theadmin\" }\n  fab!(:moderator) { Fabricate :moderator, username: \"themod\" }\n  fab!(:staged)    { Fabricate :staged }\n\n  def search_for(*args)\n    # mapping \"username\" so it's easier to debug\n    UserSearch.new(*args).search.map(&:username)\n  end\n\n  context \"with a secure category\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:searching_user) { Fabricate(:user) }\n    fab!(:group) { Fabricate(:group) }\n    fab!(:category) { Fabricate(:category, read_restricted: true, user: user) }\n\n    before_all do\n      Fabricate(:category_group, category: category, group: group)\n\n      group.add(user)\n      group.add(searching_user)\n      group.save\n    end\n\n    it \"autocompletes with people in the category\" do\n      results = search_for(\"\", searching_user: searching_user, category_id: category.id)\n      expect(results).to eq [user.username]\n    end\n\n    it \"will lookup the category from the topic id\" do\n      topic = Fabricate(:topic, category: category)\n      Fabricate(:post, user: topic.user, topic: topic)\n\n      results = search_for(\"\", searching_user: searching_user, topic_id: topic.id)\n\n      expect(results).to eq [topic.user, user].map(&:username)\n    end\n\n    it \"will raise an error if the user cannot see the category\" do\n      expect do\n        search_for(\"\", searching_user: Fabricate(:user), category_id: category.id)\n      end.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it \"will respect the group member visibility setting\" do\n      group.update(members_visibility_level: Group.visibility_levels[:owners])\n      results = search_for(\"\", searching_user: searching_user, category_id: category.id)\n      expect(results).to be_blank\n\n      group.add_owner(searching_user)\n      results = search_for(\"\", searching_user: searching_user, category_id: category.id)\n      expect(results).to eq [user.username]\n    end\n\n  end\n\n  it \"allows for correct underscore searching\" do\n    Fabricate(:user, username: \"undertaker\")\n    under_score = Fabricate(:user, username: \"Under_Score\")\n\n    expect(search_for(\"under_sc\")).to eq [under_score.username]\n    expect(search_for(\"under_\")).to eq [under_score.username]\n  end\n\n  it \"allows filtering by group\" do\n    sam = Fabricate(:user, username: \"sam\")\n    Fabricate(:user, username: \"samantha\")\n\n    group = Fabricate(:group)\n    group.add(sam)\n\n    results = search_for(\"sam\", groups: [group])\n    expect(results).to eq [sam.username]\n  end\n\n  it \"allows filtering by multiple groups\" do\n    sam = Fabricate(:user, username: \"sam\")\n    samantha = Fabricate(:user, username: \"samantha\")\n\n    group_1 = Fabricate(:group)\n    group_1.add(sam)\n\n    group_2 = Fabricate(:group)\n    group_2.add(samantha)\n\n    results = search_for(\"sam\", groups: [group_1, group_2])\n    expect(results).to eq [sam, samantha].map(&:username)\n  end\n\n  context \"with seed data\" do\n    fab!(:post1) { Fabricate :post, user: mr_b, topic: topic }\n    fab!(:post2) { Fabricate :post, user: mr_blue, topic: topic2 }\n    fab!(:post3) { Fabricate :post, user: mr_orange, topic: topic }\n    fab!(:post4) { Fabricate :post, user: mr_pink, topic: topic }\n    fab!(:post5) { Fabricate :post, user: mr_brown, topic: topic3 }\n    fab!(:post6) { Fabricate :post, user: mr_white, topic: topic }\n    fab!(:post7) { Fabricate :post, user: staged, topic: topic4 }\n\n    before { mr_white.update(suspended_at: 1.day.ago, suspended_till: 1.year.from_now) }\n\n    it \"can search by name and username\" do\n      # normal search\n      results = search_for(mr_b.name.split.first)\n      expect(results).to eq [mr_b.username]\n\n      # lower case\n      results = search_for(mr_b.name.split.first.downcase)\n      expect(results).to eq [mr_b.username]\n\n      # username\n      results = search_for(mr_pink.username)\n      expect(results).to eq [mr_pink.username]\n\n      # case insensitive\n      results = search_for(mr_pink.username.upcase)\n      expect(results).to eq [mr_pink.username]\n    end\n\n    it \"handles substring search correctly\" do\n      results = search_for(\"mr\")\n      expect(results).to eq [mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(\"mr\", searching_user: mr_b)\n      expect(results).to eq [mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      # only staff members see suspended users in results\n      results = search_for(\"mr\", searching_user: moderator)\n      expect(results).to eq [mr_white, mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(\"mr\", searching_user: admin)\n      expect(results).to eq [mr_white, mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(mr_b.username, searching_user: admin)\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n\n      results = search_for(\"MR\", searching_user: admin)\n      expect(results).to eq [mr_white, mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(\"MRB\", searching_user: admin, limit: 2)\n      expect(results).to eq [mr_b, mr_brown].map(&:username)\n    end\n\n    it \"prioritises topic participants\" do\n      results = search_for(mr_b.username, topic_id: topic.id)\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n\n      results = search_for(mr_b.username, topic_id: topic2.id)\n      expect(results).to eq [mr_b, mr_blue, mr_brown].map(&:username)\n\n      results = search_for(mr_b.username, topic_id: topic3.id)\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n    end\n\n    it \"only reveals topic participants to people with permission\" do\n      pm_topic = Fabricate(:private_message_post).topic\n\n      # Anonymous, does not have access\n      expect do\n        search_for(\"\", topic_id: pm_topic.id)\n      end.to raise_error(Discourse::InvalidAccess)\n\n      # Random user, does not have access\n      expect do\n        search_for(\"\", topic_id: pm_topic.id, searching_user: mr_b)\n      end.to raise_error(Discourse::InvalidAccess)\n\n      pm_topic.invite(pm_topic.user, mr_b.username)\n\n      results = search_for(\"\", topic_id: pm_topic.id, searching_user: mr_b)\n      expect(results).to eq [pm_topic.user.username]\n    end\n\n    it \"only searches by name when enabled\" do\n      # When searching by name is enabled, it returns the record\n      SiteSetting.enable_names = true\n      results = search_for(\"Tarantino\")\n      expect(results).to eq [mr_brown.username]\n\n      results = search_for(\"coding\")\n      expect(results).to be_blank\n\n      results = search_for(\"z\")\n      expect(results).to be_blank\n\n      # When searching by name is disabled, it will not return the record\n      SiteSetting.enable_names = false\n      results = search_for(\"Tarantino\")\n      expect(results).to be_blank\n    end\n\n    it \"prioritises exact matches\" do\n      results = search_for(\"mrB\")\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n    end\n\n    it \"doesn't prioritises exact matches mentions for users who haven't been seen in over a year\" do\n      abcdef = Fabricate(:user, username: \"abcdef\", last_seen_at: 2.days.ago)\n      abcde  = Fabricate(:user, username: \"abcde\", last_seen_at: 2.weeks.ago)\n      abcd   = Fabricate(:user, username: \"abcd\", last_seen_at: 2.months.ago)\n      abc    = Fabricate(:user, username: \"abc\", last_seen_at: 2.years.ago)\n\n      results = search_for(\"abc\", topic_id: topic.id)\n      expect(results).to eq [abcdef, abcde, abcd, abc].map(&:username)\n    end\n\n    it \"does not include self, staged or inactive\" do\n      # don't return inactive users\n      results = search_for(inactive.username)\n      expect(results).to be_blank\n\n      # don't return staged users\n      results = search_for(staged.username)\n      expect(results).to be_blank\n\n      results = search_for(staged.username, include_staged_users: true)\n      expect(results).to eq [staged.username]\n\n      # mrb is omitted since they're the searching user\n      results = search_for(\"\", topic_id: topic.id, searching_user: mr_b)\n      expect(results).to eq [mr_pink, mr_orange].map(&:username)\n    end\n\n    it \"works with last_seen_users option\" do\n      results = search_for(\"\", last_seen_users: true)\n\n      expect(results).not_to be_blank\n      expect(results[0]).to eq(\"mrbrown\")\n      expect(results[1]).to eq(\"mrpink\")\n      expect(results[2]).to eq(\"mrorange\")\n    end\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nclass UserSearch\n\n  MAX_SIZE_PRIORITY_MENTION ||= 500\n\n  def initialize(term, opts = {})\n    @term = term.downcase\n    @term_like = @term.gsub(\"_\", \"\\\\_\") + \"%\"\n    @topic_id = opts[:topic_id]\n    @category_id = opts[:category_id]\n    @topic_allowed_users = opts[:topic_allowed_users]\n    @searching_user = opts[:searching_user]\n    @include_staged_users = opts[:include_staged_users] || false\n    @last_seen_users = opts[:last_seen_users] || false\n    @limit = opts[:limit] || 20\n    @groups = opts[:groups]\n\n    @topic = Topic.find(@topic_id) if @topic_id\n    @category = Category.find(@category_id) if @category_id\n\n    @guardian = Guardian.new(@searching_user)\n    @guardian.ensure_can_see_groups_members!(@groups) if @groups\n    @guardian.ensure_can_see_category!(@category) if @category\n    @guardian.ensure_can_see_topic!(@topic) if @topic\n  end\n\n  def scoped_users\n    users = User.where(active: true)\n    users = users.where(staged: false) unless @include_staged_users\n    users = users.not_suspended unless @searching_user&.staff?\n\n    if @groups\n      users = users\n        .joins(:group_users)\n        .where(\"group_users.group_id IN (?)\", @groups.map(&:id))\n    end\n\n    # Only show users who have access to private topic\n    if @topic_allowed_users == \"true\" && @topic&.category&.read_restricted\n      users = users\n        .references(:categories)\n        .includes(:secure_categories)\n        .where(\"users.admin OR categories.id = ?\", @topic.category_id)\n    end\n\n    users\n  end\n\n  def filtered_by_term_users\n    if @term.blank?\n      scoped_users\n    elsif SiteSetting.enable_names? && @term !~ /[_\\.-]/\n      query = Search.ts_query(term: @term, ts_config: \"simple\")\n\n      scoped_users\n        .includes(:user_search_data)\n        .where(\"user_search_data.search_data @@ #{query}\")\n        .order(DB.sql_fragment(\"CASE WHEN username_lower LIKE ? THEN 0 ELSE 1 END ASC\", @term_like))\n    else\n      scoped_users.where(\"username_lower LIKE :term_like\", term_like: @term_like)\n    end\n  end\n\n  def search_ids\n    users = Set.new\n\n    # 1. exact username matches\n    if @term.present?\n      exact_matches = scoped_users.where(username_lower: @term)\n\n      # don't pollute mentions with users who haven't shown up in over a year\n      exact_matches = exact_matches.where('last_seen_at > ?', 1.year.ago) if @topic_id || @category_id\n\n      exact_matches\n        .limit(@limit)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    return users.to_a if users.size >= @limit\n\n    # 2. in topic\n    if @topic_id\n      in_topic = filtered_by_term_users\n        .where('users.id IN (SELECT user_id FROM posts WHERE topic_id = ? AND post_type = ?)', @topic_id, Post.types[:regular])\n\n      if @searching_user.present?\n        in_topic = in_topic.where('users.id <> ?', @searching_user.id)\n      end\n\n      in_topic\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    return users.to_a if users.size >= @limit\n\n    # 3. in category\n    secure_category_id =\n      if @category_id\n        DB.query_single(<<~SQL, @category_id).first\n          SELECT id\n            FROM categories\n           WHERE read_restricted\n             AND id = ?\n        SQL\n      elsif @topic_id\n        DB.query_single(<<~SQL, @topic_id).first\n          SELECT id\n            FROM categories\n           WHERE read_restricted\n             AND id IN (SELECT category_id FROM topics WHERE id = ?)\n        SQL\n      end\n\n    if secure_category_id\n      category_groups = Group.where(<<~SQL, secure_category_id, MAX_SIZE_PRIORITY_MENTION)\n        groups.id IN (\n          SELECT group_id\n            FROM category_groups\n            JOIN groups g ON group_id = g.id\n           WHERE category_id = ?\n             AND user_count < ?\n        )\n      SQL\n\n      if @searching_user.present?\n        category_groups = category_groups.members_visible_groups(@searching_user)\n      end\n\n      in_category = filtered_by_term_users\n        .where(<<~SQL, category_groups.pluck(:id))\n          users.id IN (\n            SELECT gu.user_id\n              FROM group_users gu\n             WHERE group_id IN (?)\n             LIMIT 200\n          )\n          SQL\n\n      if @searching_user.present?\n        in_category = in_category.where('users.id <> ?', @searching_user.id)\n      end\n\n      in_category\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    return users.to_a if users.size >= @limit\n\n    # 4. global matches\n    if @term.present?\n      filtered_by_term_users\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    # 5. last seen users (for search auto-suggestions)\n    if @last_seen_users\n      scoped_users\n        .order('last_seen_at DESC NULLS LAST')\n        .limit(@limit - users.size)\n        .pluck(:id)\n        .each { |id| users << id }\n    end\n\n    users.to_a\n  end\n\n  def search\n    ids = search_ids\n    return User.where(\"0=1\") if ids.empty?\n\n    User.joins(\"JOIN (SELECT unnest uid, row_number() OVER () AS rn\n      FROM unnest('{#{ids.join(\",\")}}'::int[])\n    ) x on uid = users.id\")\n      .order(\"rn\")\n  end\n\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe UserSearch do\n\n  before_all { SearchIndexer.enable } # Enable for prefabrication\n  before { SearchIndexer.enable } # Enable for each test\n\n  fab!(:topic)     { Fabricate :topic }\n  fab!(:topic2)    { Fabricate :topic }\n  fab!(:topic3)    { Fabricate :topic }\n  fab!(:topic4)    { Fabricate :topic }\n  fab!(:mr_b)      { Fabricate :user, username: \"mrb\",      name: \"Michael Madsen\",    last_seen_at: 10.days.ago }\n  fab!(:mr_blue)   { Fabricate :user, username: \"mrblue\",   name: \"Eddie Code\",        last_seen_at: 9.days.ago }\n  fab!(:mr_orange) { Fabricate :user, username: \"mrorange\", name: \"Tim Roth\",          last_seen_at: 8.days.ago }\n  fab!(:mr_pink)   { Fabricate :user, username: \"mrpink\",   name: \"Steve Buscemi\",     last_seen_at: 7.days.ago }\n  fab!(:mr_brown)  { Fabricate :user, username: \"mrbrown\",  name: \"Quentin Tarantino\", last_seen_at: 6.days.ago }\n  fab!(:mr_white)  { Fabricate :user, username: \"mrwhite\",  name: \"Harvey Keitel\",     last_seen_at: 5.days.ago }\n  fab!(:inactive)  { Fabricate :user, username: \"Ghost\", active: false }\n  fab!(:admin)     { Fabricate :admin, username: \"theadmin\" }\n  fab!(:moderator) { Fabricate :moderator, username: \"themod\" }\n  fab!(:staged)    { Fabricate :staged }\n\n  def search_for(*args)\n    # mapping \"username\" so it's easier to debug\n    UserSearch.new(*args).search.map(&:username)\n  end\n\n  context \"with a secure category\" do\n    fab!(:user) { Fabricate(:user) }\n    fab!(:searching_user) { Fabricate(:user) }\n    fab!(:group) { Fabricate(:group) }\n    fab!(:category) { Fabricate(:category, read_restricted: true, user: user) }\n\n    before_all do\n      Fabricate(:category_group, category: category, group: group)\n\n      group.add(user)\n      group.add(searching_user)\n      group.save\n    end\n\n    it \"autocompletes with people in the category\" do\n      results = search_for(\"\", searching_user: searching_user, category_id: category.id)\n      expect(results).to eq [user.username]\n    end\n\n    it \"will lookup the category from the topic id\" do\n      topic = Fabricate(:topic, category: category)\n      Fabricate(:post, user: topic.user, topic: topic)\n\n      results = search_for(\"\", searching_user: searching_user, topic_id: topic.id)\n\n      expect(results).to eq [topic.user, user].map(&:username)\n    end\n\n    it \"will raise an error if the user cannot see the category\" do\n      expect do\n        search_for(\"\", searching_user: Fabricate(:user), category_id: category.id)\n      end.to raise_error(Discourse::InvalidAccess)\n    end\n\n    it \"will respect the group member visibility setting\" do\n      group.update(members_visibility_level: Group.visibility_levels[:owners])\n      results = search_for(\"\", searching_user: searching_user, category_id: category.id)\n      expect(results).to be_blank\n\n      group.add_owner(searching_user)\n      results = search_for(\"\", searching_user: searching_user, category_id: category.id)\n      expect(results).to eq [user.username]\n    end\n\n  end\n\n  it \"allows for correct underscore searching\" do\n    Fabricate(:user, username: \"undertaker\")\n    under_score = Fabricate(:user, username: \"Under_Score\")\n\n    expect(search_for(\"under_sc\")).to eq [under_score.username]\n    expect(search_for(\"under_\")).to eq [under_score.username]\n  end\n\n  it \"allows filtering by group\" do\n    sam = Fabricate(:user, username: \"sam\")\n    Fabricate(:user, username: \"samantha\")\n\n    group = Fabricate(:group)\n    group.add(sam)\n\n    results = search_for(\"sam\", groups: [group])\n    expect(results).to eq [sam.username]\n  end\n\n  it \"allows filtering by multiple groups\" do\n    sam = Fabricate(:user, username: \"sam\")\n    samantha = Fabricate(:user, username: \"samantha\")\n\n    group_1 = Fabricate(:group)\n    group_1.add(sam)\n\n    group_2 = Fabricate(:group)\n    group_2.add(samantha)\n\n    results = search_for(\"sam\", groups: [group_1, group_2])\n    expect(results).to eq [sam, samantha].map(&:username)\n  end\n\n  context \"with seed data\" do\n    fab!(:post1) { Fabricate :post, user: mr_b, topic: topic }\n    fab!(:post2) { Fabricate :post, user: mr_blue, topic: topic2 }\n    fab!(:post3) { Fabricate :post, user: mr_orange, topic: topic }\n    fab!(:post4) { Fabricate :post, user: mr_pink, topic: topic }\n    fab!(:post5) { Fabricate :post, user: mr_brown, topic: topic3 }\n    fab!(:post6) { Fabricate :post, user: mr_white, topic: topic }\n    fab!(:post7) { Fabricate :post, user: staged, topic: topic4 }\n    fab!(:post8) { Fabricate :post, user: mr_brown, topic: topic2, post_type: Post.types[:whisper] }\n\n    before { mr_white.update(suspended_at: 1.day.ago, suspended_till: 1.year.from_now) }\n\n    it \"can search by name and username\" do\n      # normal search\n      results = search_for(mr_b.name.split.first)\n      expect(results).to eq [mr_b.username]\n\n      # lower case\n      results = search_for(mr_b.name.split.first.downcase)\n      expect(results).to eq [mr_b.username]\n\n      # username\n      results = search_for(mr_pink.username)\n      expect(results).to eq [mr_pink.username]\n\n      # case insensitive\n      results = search_for(mr_pink.username.upcase)\n      expect(results).to eq [mr_pink.username]\n    end\n\n    it \"handles substring search correctly\" do\n      results = search_for(\"mr\")\n      expect(results).to eq [mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(\"mr\", searching_user: mr_b)\n      expect(results).to eq [mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      # only staff members see suspended users in results\n      results = search_for(\"mr\", searching_user: moderator)\n      expect(results).to eq [mr_white, mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(\"mr\", searching_user: admin)\n      expect(results).to eq [mr_white, mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(mr_b.username, searching_user: admin)\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n\n      results = search_for(\"MR\", searching_user: admin)\n      expect(results).to eq [mr_white, mr_brown, mr_pink, mr_orange, mr_blue, mr_b].map(&:username)\n\n      results = search_for(\"MRB\", searching_user: admin, limit: 2)\n      expect(results).to eq [mr_b, mr_brown].map(&:username)\n    end\n\n    it \"prioritises topic participants\" do\n      results = search_for(mr_b.username, topic_id: topic.id)\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n\n      results = search_for(mr_b.username, topic_id: topic2.id)\n      expect(results).to eq [mr_b, mr_blue, mr_brown].map(&:username)\n\n      results = search_for(mr_b.username, topic_id: topic3.id)\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n    end\n\n    it \"does not reveal whisper users\" do\n      results = search_for(\"\", topic_id: topic2.id)\n      expect(results).to eq [mr_blue.username]\n    end\n\n    it \"only reveals topic participants to people with permission\" do\n      pm_topic = Fabricate(:private_message_post).topic\n\n      # Anonymous, does not have access\n      expect do\n        search_for(\"\", topic_id: pm_topic.id)\n      end.to raise_error(Discourse::InvalidAccess)\n\n      # Random user, does not have access\n      expect do\n        search_for(\"\", topic_id: pm_topic.id, searching_user: mr_b)\n      end.to raise_error(Discourse::InvalidAccess)\n\n      pm_topic.invite(pm_topic.user, mr_b.username)\n\n      results = search_for(\"\", topic_id: pm_topic.id, searching_user: mr_b)\n      expect(results).to eq [pm_topic.user.username]\n    end\n\n    it \"only searches by name when enabled\" do\n      # When searching by name is enabled, it returns the record\n      SiteSetting.enable_names = true\n      results = search_for(\"Tarantino\")\n      expect(results).to eq [mr_brown.username]\n\n      results = search_for(\"coding\")\n      expect(results).to be_blank\n\n      results = search_for(\"z\")\n      expect(results).to be_blank\n\n      # When searching by name is disabled, it will not return the record\n      SiteSetting.enable_names = false\n      results = search_for(\"Tarantino\")\n      expect(results).to be_blank\n    end\n\n    it \"prioritises exact matches\" do\n      results = search_for(\"mrB\")\n      expect(results).to eq [mr_b, mr_brown, mr_blue].map(&:username)\n    end\n\n    it \"doesn't prioritises exact matches mentions for users who haven't been seen in over a year\" do\n      abcdef = Fabricate(:user, username: \"abcdef\", last_seen_at: 2.days.ago)\n      abcde  = Fabricate(:user, username: \"abcde\", last_seen_at: 2.weeks.ago)\n      abcd   = Fabricate(:user, username: \"abcd\", last_seen_at: 2.months.ago)\n      abc    = Fabricate(:user, username: \"abc\", last_seen_at: 2.years.ago)\n\n      results = search_for(\"abc\", topic_id: topic.id)\n      expect(results).to eq [abcdef, abcde, abcd, abc].map(&:username)\n    end\n\n    it \"does not include self, staged or inactive\" do\n      # don't return inactive users\n      results = search_for(inactive.username)\n      expect(results).to be_blank\n\n      # don't return staged users\n      results = search_for(staged.username)\n      expect(results).to be_blank\n\n      results = search_for(staged.username, include_staged_users: true)\n      expect(results).to eq [staged.username]\n\n      # mrb is omitted since they're the searching user\n      results = search_for(\"\", topic_id: topic.id, searching_user: mr_b)\n      expect(results).to eq [mr_pink, mr_orange].map(&:username)\n    end\n\n    it \"works with last_seen_users option\" do\n      results = search_for(\"\", last_seen_users: true)\n\n      expect(results).not_to be_blank\n      expect(results[0]).to eq(\"mrbrown\")\n      expect(results[1]).to eq(\"mrpink\")\n      expect(results[2]).to eq(\"mrorange\")\n    end\n  end\nend\n"], "filenames": ["app/models/user_search.rb", "spec/models/user_search_spec.rb"], "buggy_code_start_loc": [86, 116], "buggy_code_end_loc": [87, 170], "fixing_code_start_loc": [86, 117], "fixing_code_end_loc": [87, 177], "type": "CWE-200", "message": "Discourse is an open source platform for community discussion. In affected versions when composing a message from topic the composer user suggestions reveals whisper participants. The issue has been patched in stable version 2.7.13 and beta version 2.8.0.beta11. There is no workaround for this issue and users are advised to upgrade.", "other": {"cve": {"id": "CVE-2022-21642", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-05T19:15:09.053", "lastModified": "2022-01-12T20:17:45.500", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source platform for community discussion. In affected versions when composing a message from topic the composer user suggestions reveals whisper participants. The issue has been patched in stable version 2.7.13 and beta version 2.8.0.beta11. There is no workaround for this issue and users are advised to upgrade."}, {"lang": "es", "value": "Discourse es una plataforma de c\u00f3digo abierto para la discusi\u00f3n comunitaria. En las versiones afectadas, cuando es redactado un mensaje desde un tema, las sugerencias del usuario compositor revelan a los participantes que susurran. El problema ha sido parcheado en la versi\u00f3n estable 2.7.13 y en la versi\u00f3n beta 2.8.0.beta11. No se presentan medidas de mitigaci\u00f3n adicionales para este problema y se recomienda a usuarios que actualicen\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.13", "matchCriteriaId": "131D6FC3-2C60-4524-9B4E-F8316312A606"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "9E7F8AC4-35D1-45E5-8A3A-B0205000A5D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "7A24507D-6D4B-4992-BCFE-232AF3BFCC30"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B9AE12FE-0396-4843-8D30-D8C44FAE01DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "F101AEAB-4FB7-4BE3-931B-595702D616C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "F6878B7F-2691-4D3F-8116-CB282FDAAAC7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "76EABAB9-BEA4-48D4-ADBA-D00746B29C52"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "82A255A2-4658-41AD-A4DE-A7F8D018028D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "E5804585-2EA4-4677-8EC1-5F561D5C7D7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "082A6871-080A-4AA7-AF4A-D664EA46488A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.8.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "8A280205-A2DC-4E30-937B-5564C779FD5A"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/702685b6a06ae45a544fc702027f1e4573d94aaa", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-mx3h-vc7w-r9c6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/702685b6a06ae45a544fc702027f1e4573d94aaa"}}