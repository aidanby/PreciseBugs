{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * RNDIS MSG parser\n *\n * Authors:\tBenedikt Spranger, Pengutronix\n *\t\tRobert Schwebel, Pengutronix\n *\n *\t\tThis software was originally developed in conformance with\n *\t\tMicrosoft's Remote NDIS Specification License Agreement.\n *\n * 03/12/2004 Kai-Uwe Bloem <linux-development@auerswald.de>\n *\t\tFixed message length bug in init_response\n *\n * 03/25/2004 Kai-Uwe Bloem <linux-development@auerswald.de>\n *\t\tFixed rndis_rm_hdr length bug.\n *\n * Copyright (C) 2004 by David Brownell\n *\t\tupdates to merge with Linux 2.6, better match RNDIS spec\n */\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/idr.h>\n#include <linux/list.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/netdevice.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n#include \"u_rndis.h\"\n\n#undef\tVERBOSE_DEBUG\n\n#include \"rndis.h\"\n\n\n/* The driver for your USB chip needs to support ep0 OUT to work with\n * RNDIS, plus all three CDC Ethernet endpoints (interrupt not optional).\n *\n * Windows hosts need an INF file like Documentation/usb/linux.inf\n * and will be happier if you provide the host_addr module parameter.\n */\n\n#if 0\nstatic int rndis_debug = 0;\nmodule_param (rndis_debug, int, 0);\nMODULE_PARM_DESC (rndis_debug, \"enable debugging\");\n#else\n#define rndis_debug\t\t0\n#endif\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\n#define\tNAME_TEMPLATE \"driver/rndis-%03d\"\n\n#endif /* CONFIG_USB_GADGET_DEBUG_FILES */\n\nstatic DEFINE_IDA(rndis_ida);\n\n/* Driver Version */\nstatic const __le32 rndis_driver_version = cpu_to_le32(1);\n\n/* Function Prototypes */\nstatic rndis_resp_t *rndis_add_response(struct rndis_params *params,\n\t\t\t\t\tu32 length);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\nstatic const struct proc_ops rndis_proc_ops;\n\n#endif /* CONFIG_USB_GADGET_DEBUG_FILES */\n\n/* supported OIDs */\nstatic const u32 oid_supported_list[] = {\n\t/* the general stuff */\n\tRNDIS_OID_GEN_SUPPORTED_LIST,\n\tRNDIS_OID_GEN_HARDWARE_STATUS,\n\tRNDIS_OID_GEN_MEDIA_SUPPORTED,\n\tRNDIS_OID_GEN_MEDIA_IN_USE,\n\tRNDIS_OID_GEN_MAXIMUM_FRAME_SIZE,\n\tRNDIS_OID_GEN_LINK_SPEED,\n\tRNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE,\n\tRNDIS_OID_GEN_RECEIVE_BLOCK_SIZE,\n\tRNDIS_OID_GEN_VENDOR_ID,\n\tRNDIS_OID_GEN_VENDOR_DESCRIPTION,\n\tRNDIS_OID_GEN_VENDOR_DRIVER_VERSION,\n\tRNDIS_OID_GEN_CURRENT_PACKET_FILTER,\n\tRNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE,\n\tRNDIS_OID_GEN_MEDIA_CONNECT_STATUS,\n\tRNDIS_OID_GEN_PHYSICAL_MEDIUM,\n\n\t/* the statistical stuff */\n\tRNDIS_OID_GEN_XMIT_OK,\n\tRNDIS_OID_GEN_RCV_OK,\n\tRNDIS_OID_GEN_XMIT_ERROR,\n\tRNDIS_OID_GEN_RCV_ERROR,\n\tRNDIS_OID_GEN_RCV_NO_BUFFER,\n#ifdef\tRNDIS_OPTIONAL_STATS\n\tRNDIS_OID_GEN_DIRECTED_BYTES_XMIT,\n\tRNDIS_OID_GEN_DIRECTED_FRAMES_XMIT,\n\tRNDIS_OID_GEN_MULTICAST_BYTES_XMIT,\n\tRNDIS_OID_GEN_MULTICAST_FRAMES_XMIT,\n\tRNDIS_OID_GEN_BROADCAST_BYTES_XMIT,\n\tRNDIS_OID_GEN_BROADCAST_FRAMES_XMIT,\n\tRNDIS_OID_GEN_DIRECTED_BYTES_RCV,\n\tRNDIS_OID_GEN_DIRECTED_FRAMES_RCV,\n\tRNDIS_OID_GEN_MULTICAST_BYTES_RCV,\n\tRNDIS_OID_GEN_MULTICAST_FRAMES_RCV,\n\tRNDIS_OID_GEN_BROADCAST_BYTES_RCV,\n\tRNDIS_OID_GEN_BROADCAST_FRAMES_RCV,\n\tRNDIS_OID_GEN_RCV_CRC_ERROR,\n\tRNDIS_OID_GEN_TRANSMIT_QUEUE_LENGTH,\n#endif\t/* RNDIS_OPTIONAL_STATS */\n\n\t/* mandatory 802.3 */\n\t/* the general stuff */\n\tRNDIS_OID_802_3_PERMANENT_ADDRESS,\n\tRNDIS_OID_802_3_CURRENT_ADDRESS,\n\tRNDIS_OID_802_3_MULTICAST_LIST,\n\tRNDIS_OID_802_3_MAC_OPTIONS,\n\tRNDIS_OID_802_3_MAXIMUM_LIST_SIZE,\n\n\t/* the statistical stuff */\n\tRNDIS_OID_802_3_RCV_ERROR_ALIGNMENT,\n\tRNDIS_OID_802_3_XMIT_ONE_COLLISION,\n\tRNDIS_OID_802_3_XMIT_MORE_COLLISIONS,\n#ifdef\tRNDIS_OPTIONAL_STATS\n\tRNDIS_OID_802_3_XMIT_DEFERRED,\n\tRNDIS_OID_802_3_XMIT_MAX_COLLISIONS,\n\tRNDIS_OID_802_3_RCV_OVERRUN,\n\tRNDIS_OID_802_3_XMIT_UNDERRUN,\n\tRNDIS_OID_802_3_XMIT_HEARTBEAT_FAILURE,\n\tRNDIS_OID_802_3_XMIT_TIMES_CRS_LOST,\n\tRNDIS_OID_802_3_XMIT_LATE_COLLISIONS,\n#endif\t/* RNDIS_OPTIONAL_STATS */\n\n#ifdef\tRNDIS_PM\n\t/* PM and wakeup are \"mandatory\" for USB, but the RNDIS specs\n\t * don't say what they mean ... and the NDIS specs are often\n\t * confusing and/or ambiguous in this context.  (That is, more\n\t * so than their specs for the other OIDs.)\n\t *\n\t * FIXME someone who knows what these should do, please\n\t * implement them!\n\t */\n\n\t/* power management */\n\tOID_PNP_CAPABILITIES,\n\tOID_PNP_QUERY_POWER,\n\tOID_PNP_SET_POWER,\n\n#ifdef\tRNDIS_WAKEUP\n\t/* wake up host */\n\tOID_PNP_ENABLE_WAKE_UP,\n\tOID_PNP_ADD_WAKE_UP_PATTERN,\n\tOID_PNP_REMOVE_WAKE_UP_PATTERN,\n#endif\t/* RNDIS_WAKEUP */\n#endif\t/* RNDIS_PM */\n};\n\n\n/* NDIS Functions */\nstatic int gen_ndis_query_resp(struct rndis_params *params, u32 OID, u8 *buf,\n\t\t\t       unsigned buf_len, rndis_resp_t *r)\n{\n\tint retval = -ENOTSUPP;\n\tu32 length = 4;\t/* usually */\n\t__le32 *outbuf;\n\tint i, count;\n\trndis_query_cmplt_type *resp;\n\tstruct net_device *net;\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats;\n\n\tif (!r) return -ENOMEM;\n\tresp = (rndis_query_cmplt_type *)r->buf;\n\n\tif (!resp) return -ENOMEM;\n\n\tif (buf_len && rndis_debug > 1) {\n\t\tpr_debug(\"query OID %08x value, len %d:\\n\", OID, buf_len);\n\t\tfor (i = 0; i < buf_len; i += 16) {\n\t\t\tpr_debug(\"%03d: %08x %08x %08x %08x\\n\", i,\n\t\t\t\tget_unaligned_le32(&buf[i]),\n\t\t\t\tget_unaligned_le32(&buf[i + 4]),\n\t\t\t\tget_unaligned_le32(&buf[i + 8]),\n\t\t\t\tget_unaligned_le32(&buf[i + 12]));\n\t\t}\n\t}\n\n\t/* response goes here, right after the header */\n\toutbuf = (__le32 *)&resp[1];\n\tresp->InformationBufferOffset = cpu_to_le32(16);\n\n\tnet = params->dev;\n\tstats = dev_get_stats(net, &temp);\n\n\tswitch (OID) {\n\n\t/* general oids (table 4-1) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_SUPPORTED_LIST:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_SUPPORTED_LIST\\n\", __func__);\n\t\tlength = sizeof(oid_supported_list);\n\t\tcount  = length / sizeof(u32);\n\t\tfor (i = 0; i < count; i++)\n\t\t\toutbuf[i] = cpu_to_le32(oid_supported_list[i]);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_HARDWARE_STATUS:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_HARDWARE_STATUS\\n\", __func__);\n\t\t/* Bogus question!\n\t\t * Hardware must be ready to receive high level protocols.\n\t\t * BTW:\n\t\t * reddite ergo quae sunt Caesaris Caesari\n\t\t * et quae sunt Dei Deo!\n\t\t */\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MEDIA_SUPPORTED:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MEDIA_SUPPORTED\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(params->medium);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MEDIA_IN_USE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MEDIA_IN_USE\\n\", __func__);\n\t\t/* one medium, one transport... (maybe you do it better) */\n\t\t*outbuf = cpu_to_le32(params->medium);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\t*outbuf = cpu_to_le32(params->dev->mtu);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_LINK_SPEED:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_LINK_SPEED\\n\", __func__);\n\t\tif (params->media_state == RNDIS_MEDIA_STATE_DISCONNECTED)\n\t\t\t*outbuf = cpu_to_le32(0);\n\t\telse\n\t\t\t*outbuf = cpu_to_le32(params->speed);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\t*outbuf = cpu_to_le32(params->dev->mtu);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\t*outbuf = cpu_to_le32(params->dev->mtu);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_VENDOR_ID:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_VENDOR_ID\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(params->vendorID);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_VENDOR_DESCRIPTION:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_VENDOR_DESCRIPTION\\n\", __func__);\n\t\tif (params->vendorDescr) {\n\t\t\tlength = strlen(params->vendorDescr);\n\t\t\tmemcpy(outbuf, params->vendorDescr, length);\n\t\t} else {\n\t\t\toutbuf[0] = 0;\n\t\t}\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase RNDIS_OID_GEN_VENDOR_DRIVER_VERSION:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_VENDOR_DRIVER_VERSION\\n\", __func__);\n\t\t/* Created as LE */\n\t\t*outbuf = rndis_driver_version;\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_CURRENT_PACKET_FILTER:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_CURRENT_PACKET_FILTER\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(*params->filter);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(RNDIS_MAX_TOTAL_SIZE);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MEDIA_CONNECT_STATUS:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_MEDIA_CONNECT_STATUS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(params->media_state);\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase RNDIS_OID_GEN_PHYSICAL_MEDIUM:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_PHYSICAL_MEDIUM\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* The RNDIS specification is incomplete/wrong.   Some versions\n\t * of MS-Windows expect OIDs that aren't specified there.  Other\n\t * versions emit undefined RNDIS messages. DOCUMENT ALL THESE!\n\t */\n\tcase RNDIS_OID_GEN_MAC_OPTIONS:\t\t/* from WinME */\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MAC_OPTIONS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(\n\t\t\t  RNDIS_MAC_OPTION_RECEIVE_SERIALIZED\n\t\t\t| RNDIS_MAC_OPTION_FULL_DUPLEX);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* statistics OIDs (table 4-2) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_XMIT_OK:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_XMIT_OK\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->tx_packets\n\t\t\t\t- stats->tx_errors - stats->tx_dropped);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RCV_OK:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_RCV_OK\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_packets\n\t\t\t\t- stats->rx_errors - stats->rx_dropped);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_XMIT_ERROR:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_XMIT_ERROR\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->tx_errors);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RCV_ERROR:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_RCV_ERROR\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_errors);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RCV_NO_BUFFER:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_RCV_NO_BUFFER\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_dropped);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* ieee802.3 OIDs (table 4-3) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_PERMANENT_ADDRESS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_PERMANENT_ADDRESS\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\tlength = ETH_ALEN;\n\t\t\tmemcpy(outbuf, params->host_mac, length);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_CURRENT_ADDRESS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_CURRENT_ADDRESS\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\tlength = ETH_ALEN;\n\t\t\tmemcpy(outbuf, params->host_mac, length);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_MULTICAST_LIST:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MULTICAST_LIST\\n\", __func__);\n\t\t/* Multicast base address only */\n\t\t*outbuf = cpu_to_le32(0xE0000000);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_MAXIMUM_LIST_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MAXIMUM_LIST_SIZE\\n\", __func__);\n\t\t/* Multicast base address only */\n\t\t*outbuf = cpu_to_le32(1);\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase RNDIS_OID_802_3_MAC_OPTIONS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MAC_OPTIONS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* ieee802.3 statistics OIDs (table 4-4) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_frame_errors);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_XMIT_ONE_COLLISION:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_XMIT_ONE_COLLISION\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_XMIT_MORE_COLLISIONS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_XMIT_MORE_COLLISIONS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s: query unknown OID 0x%08X\\n\", __func__, OID);\n\t}\n\tif (retval < 0)\n\t\tlength = 0;\n\n\tresp->InformationBufferLength = cpu_to_le32(length);\n\tr->length = length + sizeof(*resp);\n\tresp->MessageLength = cpu_to_le32(r->length);\n\treturn retval;\n}\n\nstatic int gen_ndis_set_resp(struct rndis_params *params, u32 OID,\n\t\t\t     u8 *buf, u32 buf_len, rndis_resp_t *r)\n{\n\trndis_set_cmplt_type *resp;\n\tint i, retval = -ENOTSUPP;\n\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tif (buf_len && rndis_debug > 1) {\n\t\tpr_debug(\"set OID %08x value, len %d:\\n\", OID, buf_len);\n\t\tfor (i = 0; i < buf_len; i += 16) {\n\t\t\tpr_debug(\"%03d: %08x %08x %08x %08x\\n\", i,\n\t\t\t\tget_unaligned_le32(&buf[i]),\n\t\t\t\tget_unaligned_le32(&buf[i + 4]),\n\t\t\t\tget_unaligned_le32(&buf[i + 8]),\n\t\t\t\tget_unaligned_le32(&buf[i + 12]));\n\t\t}\n\t}\n\n\tswitch (OID) {\n\tcase RNDIS_OID_GEN_CURRENT_PACKET_FILTER:\n\n\t\t/* these NDIS_PACKET_TYPE_* bitflags are shared with\n\t\t * cdc_filter; it's not RNDIS-specific\n\t\t * NDIS_PACKET_TYPE_x == USB_CDC_PACKET_TYPE_x for x in:\n\t\t *\tPROMISCUOUS, DIRECTED,\n\t\t *\tMULTICAST, ALL_MULTICAST, BROADCAST\n\t\t */\n\t\t*params->filter = (u16)get_unaligned_le32(buf);\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_CURRENT_PACKET_FILTER %08x\\n\",\n\t\t\t__func__, *params->filter);\n\n\t\t/* this call has a significant side effect:  it's\n\t\t * what makes the packet flow start and stop, like\n\t\t * activating the CDC Ethernet altsetting.\n\t\t */\n\t\tretval = 0;\n\t\tif (*params->filter) {\n\t\t\tparams->state = RNDIS_DATA_INITIALIZED;\n\t\t\tnetif_carrier_on(params->dev);\n\t\t\tif (netif_running(params->dev))\n\t\t\t\tnetif_wake_queue(params->dev);\n\t\t} else {\n\t\t\tparams->state = RNDIS_INITIALIZED;\n\t\t\tnetif_carrier_off(params->dev);\n\t\t\tnetif_stop_queue(params->dev);\n\t\t}\n\t\tbreak;\n\n\tcase RNDIS_OID_802_3_MULTICAST_LIST:\n\t\t/* I think we can ignore this */\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MULTICAST_LIST\\n\", __func__);\n\t\tretval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s: set unknown OID 0x%08X, size %d\\n\",\n\t\t\t__func__, OID, buf_len);\n\t}\n\n\treturn retval;\n}\n\n/*\n * Response Functions\n */\n\nstatic int rndis_init_response(struct rndis_params *params,\n\t\t\t       rndis_init_msg_type *buf)\n{\n\trndis_init_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\tif (!params->dev)\n\t\treturn -ENOTSUPP;\n\n\tr = rndis_add_response(params, sizeof(rndis_init_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_init_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_INIT_C);\n\tresp->MessageLength = cpu_to_le32(52);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tresp->MajorVersion = cpu_to_le32(RNDIS_MAJOR_VERSION);\n\tresp->MinorVersion = cpu_to_le32(RNDIS_MINOR_VERSION);\n\tresp->DeviceFlags = cpu_to_le32(RNDIS_DF_CONNECTIONLESS);\n\tresp->Medium = cpu_to_le32(RNDIS_MEDIUM_802_3);\n\tresp->MaxPacketsPerTransfer = cpu_to_le32(1);\n\tresp->MaxTransferSize = cpu_to_le32(\n\t\t  params->dev->mtu\n\t\t+ sizeof(struct ethhdr)\n\t\t+ sizeof(struct rndis_packet_msg_type)\n\t\t+ 22);\n\tresp->PacketAlignmentFactor = cpu_to_le32(0);\n\tresp->AFListOffset = cpu_to_le32(0);\n\tresp->AFListSize = cpu_to_le32(0);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_query_response(struct rndis_params *params,\n\t\t\t\trndis_query_msg_type *buf)\n{\n\trndis_query_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\t/* pr_debug(\"%s: OID = %08X\\n\", __func__, cpu_to_le32(buf->OID)); */\n\tif (!params->dev)\n\t\treturn -ENOTSUPP;\n\n\t/*\n\t * we need more memory:\n\t * gen_ndis_query_resp expects enough space for\n\t * rndis_query_cmplt_type followed by data.\n\t * oid_supported_list is the largest data reply\n\t */\n\tr = rndis_add_response(params,\n\t\tsizeof(oid_supported_list) + sizeof(rndis_query_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_query_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_QUERY_C);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\n\tif (gen_ndis_query_resp(params, le32_to_cpu(buf->OID),\n\t\t\tle32_to_cpu(buf->InformationBufferOffset)\n\t\t\t\t\t+ 8 + (u8 *)buf,\n\t\t\tle32_to_cpu(buf->InformationBufferLength),\n\t\t\tr)) {\n\t\t/* OID not supported */\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\t\tresp->MessageLength = cpu_to_le32(sizeof *resp);\n\t\tresp->InformationBufferLength = cpu_to_le32(0);\n\t\tresp->InformationBufferOffset = cpu_to_le32(0);\n\t} else\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\n\tpr_debug(\"\\n\");\n#endif\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_reset_response(struct rndis_params *params,\n\t\t\t\trndis_reset_msg_type *buf)\n{\n\trndis_reset_cmplt_type *resp;\n\trndis_resp_t *r;\n\tu8 *xbuf;\n\tu32 length;\n\n\t/* drain the response queue */\n\twhile ((xbuf = rndis_get_next_response(params, &length)))\n\t\trndis_free_response(params, xbuf);\n\n\tr = rndis_add_response(params, sizeof(rndis_reset_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_reset_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_RESET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\t/* resent information */\n\tresp->AddressingReset = cpu_to_le32(1);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_keepalive_response(struct rndis_params *params,\n\t\t\t\t    rndis_keepalive_msg_type *buf)\n{\n\trndis_keepalive_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\t/* host \"should\" check only in RNDIS_DATA_INITIALIZED state */\n\n\tr = rndis_add_response(params, sizeof(rndis_keepalive_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_keepalive_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_KEEPALIVE_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\n\n/*\n * Device to Host Comunication\n */\nstatic int rndis_indicate_status_msg(struct rndis_params *params, u32 status)\n{\n\trndis_indicate_status_msg_type *resp;\n\trndis_resp_t *r;\n\n\tif (params->state == RNDIS_UNINITIALIZED)\n\t\treturn -ENOTSUPP;\n\n\tr = rndis_add_response(params, sizeof(rndis_indicate_status_msg_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_indicate_status_msg_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_INDICATE);\n\tresp->MessageLength = cpu_to_le32(20);\n\tresp->Status = cpu_to_le32(status);\n\tresp->StatusBufferLength = cpu_to_le32(0);\n\tresp->StatusBufferOffset = cpu_to_le32(0);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nint rndis_signal_connect(struct rndis_params *params)\n{\n\tparams->media_state = RNDIS_MEDIA_STATE_CONNECTED;\n\treturn rndis_indicate_status_msg(params, RNDIS_STATUS_MEDIA_CONNECT);\n}\nEXPORT_SYMBOL_GPL(rndis_signal_connect);\n\nint rndis_signal_disconnect(struct rndis_params *params)\n{\n\tparams->media_state = RNDIS_MEDIA_STATE_DISCONNECTED;\n\treturn rndis_indicate_status_msg(params, RNDIS_STATUS_MEDIA_DISCONNECT);\n}\nEXPORT_SYMBOL_GPL(rndis_signal_disconnect);\n\nvoid rndis_uninit(struct rndis_params *params)\n{\n\tu8 *buf;\n\tu32 length;\n\n\tif (!params)\n\t\treturn;\n\tparams->state = RNDIS_UNINITIALIZED;\n\n\t/* drain the response queue */\n\twhile ((buf = rndis_get_next_response(params, &length)))\n\t\trndis_free_response(params, buf);\n}\nEXPORT_SYMBOL_GPL(rndis_uninit);\n\nvoid rndis_set_host_mac(struct rndis_params *params, const u8 *addr)\n{\n\tparams->host_mac = addr;\n}\nEXPORT_SYMBOL_GPL(rndis_set_host_mac);\n\n/*\n * Message Parser\n */\nint rndis_msg_parser(struct rndis_params *params, u8 *buf)\n{\n\tu32 MsgType, MsgLength;\n\t__le32 *tmp;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ttmp = (__le32 *)buf;\n\tMsgType   = get_unaligned_le32(tmp++);\n\tMsgLength = get_unaligned_le32(tmp++);\n\n\tif (!params)\n\t\treturn -ENOTSUPP;\n\n\t/* NOTE: RNDIS is *EXTREMELY* chatty ... Windows constantly polls for\n\t * rx/tx statistics and link status, in addition to KEEPALIVE traffic\n\t * and normal HC level polling to see if there's any IN traffic.\n\t */\n\n\t/* For USB: responses may take up to 10 seconds */\n\tswitch (MsgType) {\n\tcase RNDIS_MSG_INIT:\n\t\tpr_debug(\"%s: RNDIS_MSG_INIT\\n\",\n\t\t\t__func__);\n\t\tparams->state = RNDIS_INITIALIZED;\n\t\treturn rndis_init_response(params, (rndis_init_msg_type *)buf);\n\n\tcase RNDIS_MSG_HALT:\n\t\tpr_debug(\"%s: RNDIS_MSG_HALT\\n\",\n\t\t\t__func__);\n\t\tparams->state = RNDIS_UNINITIALIZED;\n\t\tif (params->dev) {\n\t\t\tnetif_carrier_off(params->dev);\n\t\t\tnetif_stop_queue(params->dev);\n\t\t}\n\t\treturn 0;\n\n\tcase RNDIS_MSG_QUERY:\n\t\treturn rndis_query_response(params,\n\t\t\t\t\t(rndis_query_msg_type *)buf);\n\n\tcase RNDIS_MSG_SET:\n\t\treturn rndis_set_response(params, (rndis_set_msg_type *)buf);\n\n\tcase RNDIS_MSG_RESET:\n\t\tpr_debug(\"%s: RNDIS_MSG_RESET\\n\",\n\t\t\t__func__);\n\t\treturn rndis_reset_response(params,\n\t\t\t\t\t(rndis_reset_msg_type *)buf);\n\n\tcase RNDIS_MSG_KEEPALIVE:\n\t\t/* For USB: host does this every 5 seconds */\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_MSG_KEEPALIVE\\n\",\n\t\t\t\t__func__);\n\t\treturn rndis_keepalive_response(params,\n\t\t\t\t\t\t (rndis_keepalive_msg_type *)\n\t\t\t\t\t\t buf);\n\n\tdefault:\n\t\t/* At least Windows XP emits some undefined RNDIS messages.\n\t\t * In one case those messages seemed to relate to the host\n\t\t * suspending itself.\n\t\t */\n\t\tpr_warn(\"%s: unknown RNDIS message 0x%08X len %d\\n\",\n\t\t\t__func__, MsgType, MsgLength);\n\t\t/* Garbled message can be huge, so limit what we display */\n\t\tif (MsgLength > 16)\n\t\t\tMsgLength = 16;\n\t\tprint_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,\n\t\t\t\t     buf, MsgLength);\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(rndis_msg_parser);\n\nstatic inline int rndis_get_nr(void)\n{\n\treturn ida_simple_get(&rndis_ida, 0, 0, GFP_KERNEL);\n}\n\nstatic inline void rndis_put_nr(int nr)\n{\n\tida_simple_remove(&rndis_ida, nr);\n}\n\nstruct rndis_params *rndis_register(void (*resp_avail)(void *v), void *v)\n{\n\tstruct rndis_params *params;\n\tint i;\n\n\tif (!resp_avail)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ti = rndis_get_nr();\n\tif (i < 0) {\n\t\tpr_debug(\"failed\\n\");\n\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params) {\n\t\trndis_put_nr(i);\n\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n#ifdef\tCONFIG_USB_GADGET_DEBUG_FILES\n\t{\n\t\tstruct proc_dir_entry *proc_entry;\n\t\tchar name[20];\n\n\t\tsprintf(name, NAME_TEMPLATE, i);\n\t\tproc_entry = proc_create_data(name, 0660, NULL,\n\t\t\t\t\t      &rndis_proc_ops, params);\n\t\tif (!proc_entry) {\n\t\t\tkfree(params);\n\t\t\trndis_put_nr(i);\n\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n#endif\n\n\tparams->confignr = i;\n\tparams->used = 1;\n\tparams->state = RNDIS_UNINITIALIZED;\n\tparams->media_state = RNDIS_MEDIA_STATE_DISCONNECTED;\n\tparams->resp_avail = resp_avail;\n\tparams->v = v;\n\tINIT_LIST_HEAD(&params->resp_queue);\n\tpr_debug(\"%s: configNr = %d\\n\", __func__, i);\n\n\treturn params;\n}\nEXPORT_SYMBOL_GPL(rndis_register);\n\nvoid rndis_deregister(struct rndis_params *params)\n{\n\tint i;\n\n\tpr_debug(\"%s:\\n\", __func__);\n\n\tif (!params)\n\t\treturn;\n\n\ti = params->confignr;\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\t{\n\t\tchar name[20];\n\n\t\tsprintf(name, NAME_TEMPLATE, i);\n\t\tremove_proc_entry(name, NULL);\n\t}\n#endif\n\n\tkfree(params);\n\trndis_put_nr(i);\n}\nEXPORT_SYMBOL_GPL(rndis_deregister);\nint rndis_set_param_dev(struct rndis_params *params, struct net_device *dev,\n\t\t\tu16 *cdc_filter)\n{\n\tpr_debug(\"%s:\\n\", __func__);\n\tif (!dev)\n\t\treturn -EINVAL;\n\tif (!params)\n\t\treturn -1;\n\n\tparams->dev = dev;\n\tparams->filter = cdc_filter;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_set_param_dev);\n\nint rndis_set_param_vendor(struct rndis_params *params, u32 vendorID,\n\t\t\t   const char *vendorDescr)\n{\n\tpr_debug(\"%s:\\n\", __func__);\n\tif (!vendorDescr) return -1;\n\tif (!params)\n\t\treturn -1;\n\n\tparams->vendorID = vendorID;\n\tparams->vendorDescr = vendorDescr;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_set_param_vendor);\n\nint rndis_set_param_medium(struct rndis_params *params, u32 medium, u32 speed)\n{\n\tpr_debug(\"%s: %u %u\\n\", __func__, medium, speed);\n\tif (!params)\n\t\treturn -1;\n\n\tparams->medium = medium;\n\tparams->speed = speed;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_set_param_medium);\n\nvoid rndis_add_hdr(struct sk_buff *skb)\n{\n\tstruct rndis_packet_msg_type *header;\n\n\tif (!skb)\n\t\treturn;\n\theader = skb_push(skb, sizeof(*header));\n\tmemset(header, 0, sizeof *header);\n\theader->MessageType = cpu_to_le32(RNDIS_MSG_PACKET);\n\theader->MessageLength = cpu_to_le32(skb->len);\n\theader->DataOffset = cpu_to_le32(36);\n\theader->DataLength = cpu_to_le32(skb->len - sizeof(*header));\n}\nEXPORT_SYMBOL_GPL(rndis_add_hdr);\n\nvoid rndis_free_response(struct rndis_params *params, u8 *buf)\n{\n\trndis_resp_t *r, *n;\n\n\tlist_for_each_entry_safe(r, n, &params->resp_queue, list) {\n\t\tif (r->buf == buf) {\n\t\t\tlist_del(&r->list);\n\t\t\tkfree(r);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(rndis_free_response);\n\nu8 *rndis_get_next_response(struct rndis_params *params, u32 *length)\n{\n\trndis_resp_t *r, *n;\n\n\tif (!length) return NULL;\n\n\tlist_for_each_entry_safe(r, n, &params->resp_queue, list) {\n\t\tif (!r->send) {\n\t\t\tr->send = 1;\n\t\t\t*length = r->length;\n\t\t\treturn r->buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(rndis_get_next_response);\n\nstatic rndis_resp_t *rndis_add_response(struct rndis_params *params, u32 length)\n{\n\trndis_resp_t *r;\n\n\t/* NOTE: this gets copied into ether.c USB_BUFSIZ bytes ... */\n\tr = kmalloc(sizeof(rndis_resp_t) + length, GFP_ATOMIC);\n\tif (!r) return NULL;\n\n\tr->buf = (u8 *)(r + 1);\n\tr->length = length;\n\tr->send = 0;\n\n\tlist_add_tail(&r->list, &params->resp_queue);\n\treturn r;\n}\n\nint rndis_rm_hdr(struct gether *port,\n\t\t\tstruct sk_buff *skb,\n\t\t\tstruct sk_buff_head *list)\n{\n\t/* tmp points to a struct rndis_packet_msg_type */\n\t__le32 *tmp = (void *)skb->data;\n\n\t/* MessageType, MessageLength */\n\tif (cpu_to_le32(RNDIS_MSG_PACKET)\n\t\t\t!= get_unaligned(tmp++)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\ttmp++;\n\n\t/* DataOffset, DataLength */\n\tif (!skb_pull(skb, get_unaligned_le32(tmp++) + 8)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EOVERFLOW;\n\t}\n\tskb_trim(skb, get_unaligned_le32(tmp++));\n\n\tskb_queue_tail(list, skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_rm_hdr);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\nstatic int rndis_proc_show(struct seq_file *m, void *v)\n{\n\trndis_params *param = m->private;\n\n\tseq_printf(m,\n\t\t\t \"Config Nr. %d\\n\"\n\t\t\t \"used      : %s\\n\"\n\t\t\t \"state     : %s\\n\"\n\t\t\t \"medium    : 0x%08X\\n\"\n\t\t\t \"speed     : %d\\n\"\n\t\t\t \"cable     : %s\\n\"\n\t\t\t \"vendor ID : 0x%08X\\n\"\n\t\t\t \"vendor    : %s\\n\",\n\t\t\t param->confignr, (param->used) ? \"y\" : \"n\",\n\t\t\t ({ char *s = \"?\";\n\t\t\t switch (param->state) {\n\t\t\t case RNDIS_UNINITIALIZED:\n\t\t\t\ts = \"RNDIS_UNINITIALIZED\"; break;\n\t\t\t case RNDIS_INITIALIZED:\n\t\t\t\ts = \"RNDIS_INITIALIZED\"; break;\n\t\t\t case RNDIS_DATA_INITIALIZED:\n\t\t\t\ts = \"RNDIS_DATA_INITIALIZED\"; break;\n\t\t\t} s; }),\n\t\t\t param->medium,\n\t\t\t (param->media_state) ? 0 : param->speed*100,\n\t\t\t (param->media_state) ? \"disconnected\" : \"connected\",\n\t\t\t param->vendorID, param->vendorDescr);\n\treturn 0;\n}\n\nstatic ssize_t rndis_proc_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\trndis_params *p = pde_data(file_inode(file));\n\tu32 speed = 0;\n\tint i, fl_speed = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tchar c;\n\t\tif (get_user(c, buffer))\n\t\t\treturn -EFAULT;\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tfl_speed = 1;\n\t\t\tspeed = speed * 10 + c - '0';\n\t\t\tbreak;\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\trndis_signal_connect(p);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\trndis_signal_disconnect(p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fl_speed) p->speed = speed;\n\t\t\telse pr_debug(\"%c is not valid\\n\", c);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer++;\n\t}\n\n\treturn count;\n}\n\nstatic int rndis_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rndis_proc_show, pde_data(inode));\n}\n\nstatic const struct proc_ops rndis_proc_ops = {\n\t.proc_open\t= rndis_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= rndis_proc_write,\n};\n\n#define\tNAME_TEMPLATE \"driver/rndis-%03d\"\n\n#endif /* CONFIG_USB_GADGET_DEBUG_FILES */\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * RNDIS MSG parser\n *\n * Authors:\tBenedikt Spranger, Pengutronix\n *\t\tRobert Schwebel, Pengutronix\n *\n *\t\tThis software was originally developed in conformance with\n *\t\tMicrosoft's Remote NDIS Specification License Agreement.\n *\n * 03/12/2004 Kai-Uwe Bloem <linux-development@auerswald.de>\n *\t\tFixed message length bug in init_response\n *\n * 03/25/2004 Kai-Uwe Bloem <linux-development@auerswald.de>\n *\t\tFixed rndis_rm_hdr length bug.\n *\n * Copyright (C) 2004 by David Brownell\n *\t\tupdates to merge with Linux 2.6, better match RNDIS spec\n */\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/idr.h>\n#include <linux/list.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/netdevice.h>\n\n#include <asm/io.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n#include \"u_rndis.h\"\n\n#undef\tVERBOSE_DEBUG\n\n#include \"rndis.h\"\n\n\n/* The driver for your USB chip needs to support ep0 OUT to work with\n * RNDIS, plus all three CDC Ethernet endpoints (interrupt not optional).\n *\n * Windows hosts need an INF file like Documentation/usb/linux.inf\n * and will be happier if you provide the host_addr module parameter.\n */\n\n#if 0\nstatic int rndis_debug = 0;\nmodule_param (rndis_debug, int, 0);\nMODULE_PARM_DESC (rndis_debug, \"enable debugging\");\n#else\n#define rndis_debug\t\t0\n#endif\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\n#define\tNAME_TEMPLATE \"driver/rndis-%03d\"\n\n#endif /* CONFIG_USB_GADGET_DEBUG_FILES */\n\nstatic DEFINE_IDA(rndis_ida);\n\n/* Driver Version */\nstatic const __le32 rndis_driver_version = cpu_to_le32(1);\n\n/* Function Prototypes */\nstatic rndis_resp_t *rndis_add_response(struct rndis_params *params,\n\t\t\t\t\tu32 length);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\nstatic const struct proc_ops rndis_proc_ops;\n\n#endif /* CONFIG_USB_GADGET_DEBUG_FILES */\n\n/* supported OIDs */\nstatic const u32 oid_supported_list[] = {\n\t/* the general stuff */\n\tRNDIS_OID_GEN_SUPPORTED_LIST,\n\tRNDIS_OID_GEN_HARDWARE_STATUS,\n\tRNDIS_OID_GEN_MEDIA_SUPPORTED,\n\tRNDIS_OID_GEN_MEDIA_IN_USE,\n\tRNDIS_OID_GEN_MAXIMUM_FRAME_SIZE,\n\tRNDIS_OID_GEN_LINK_SPEED,\n\tRNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE,\n\tRNDIS_OID_GEN_RECEIVE_BLOCK_SIZE,\n\tRNDIS_OID_GEN_VENDOR_ID,\n\tRNDIS_OID_GEN_VENDOR_DESCRIPTION,\n\tRNDIS_OID_GEN_VENDOR_DRIVER_VERSION,\n\tRNDIS_OID_GEN_CURRENT_PACKET_FILTER,\n\tRNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE,\n\tRNDIS_OID_GEN_MEDIA_CONNECT_STATUS,\n\tRNDIS_OID_GEN_PHYSICAL_MEDIUM,\n\n\t/* the statistical stuff */\n\tRNDIS_OID_GEN_XMIT_OK,\n\tRNDIS_OID_GEN_RCV_OK,\n\tRNDIS_OID_GEN_XMIT_ERROR,\n\tRNDIS_OID_GEN_RCV_ERROR,\n\tRNDIS_OID_GEN_RCV_NO_BUFFER,\n#ifdef\tRNDIS_OPTIONAL_STATS\n\tRNDIS_OID_GEN_DIRECTED_BYTES_XMIT,\n\tRNDIS_OID_GEN_DIRECTED_FRAMES_XMIT,\n\tRNDIS_OID_GEN_MULTICAST_BYTES_XMIT,\n\tRNDIS_OID_GEN_MULTICAST_FRAMES_XMIT,\n\tRNDIS_OID_GEN_BROADCAST_BYTES_XMIT,\n\tRNDIS_OID_GEN_BROADCAST_FRAMES_XMIT,\n\tRNDIS_OID_GEN_DIRECTED_BYTES_RCV,\n\tRNDIS_OID_GEN_DIRECTED_FRAMES_RCV,\n\tRNDIS_OID_GEN_MULTICAST_BYTES_RCV,\n\tRNDIS_OID_GEN_MULTICAST_FRAMES_RCV,\n\tRNDIS_OID_GEN_BROADCAST_BYTES_RCV,\n\tRNDIS_OID_GEN_BROADCAST_FRAMES_RCV,\n\tRNDIS_OID_GEN_RCV_CRC_ERROR,\n\tRNDIS_OID_GEN_TRANSMIT_QUEUE_LENGTH,\n#endif\t/* RNDIS_OPTIONAL_STATS */\n\n\t/* mandatory 802.3 */\n\t/* the general stuff */\n\tRNDIS_OID_802_3_PERMANENT_ADDRESS,\n\tRNDIS_OID_802_3_CURRENT_ADDRESS,\n\tRNDIS_OID_802_3_MULTICAST_LIST,\n\tRNDIS_OID_802_3_MAC_OPTIONS,\n\tRNDIS_OID_802_3_MAXIMUM_LIST_SIZE,\n\n\t/* the statistical stuff */\n\tRNDIS_OID_802_3_RCV_ERROR_ALIGNMENT,\n\tRNDIS_OID_802_3_XMIT_ONE_COLLISION,\n\tRNDIS_OID_802_3_XMIT_MORE_COLLISIONS,\n#ifdef\tRNDIS_OPTIONAL_STATS\n\tRNDIS_OID_802_3_XMIT_DEFERRED,\n\tRNDIS_OID_802_3_XMIT_MAX_COLLISIONS,\n\tRNDIS_OID_802_3_RCV_OVERRUN,\n\tRNDIS_OID_802_3_XMIT_UNDERRUN,\n\tRNDIS_OID_802_3_XMIT_HEARTBEAT_FAILURE,\n\tRNDIS_OID_802_3_XMIT_TIMES_CRS_LOST,\n\tRNDIS_OID_802_3_XMIT_LATE_COLLISIONS,\n#endif\t/* RNDIS_OPTIONAL_STATS */\n\n#ifdef\tRNDIS_PM\n\t/* PM and wakeup are \"mandatory\" for USB, but the RNDIS specs\n\t * don't say what they mean ... and the NDIS specs are often\n\t * confusing and/or ambiguous in this context.  (That is, more\n\t * so than their specs for the other OIDs.)\n\t *\n\t * FIXME someone who knows what these should do, please\n\t * implement them!\n\t */\n\n\t/* power management */\n\tOID_PNP_CAPABILITIES,\n\tOID_PNP_QUERY_POWER,\n\tOID_PNP_SET_POWER,\n\n#ifdef\tRNDIS_WAKEUP\n\t/* wake up host */\n\tOID_PNP_ENABLE_WAKE_UP,\n\tOID_PNP_ADD_WAKE_UP_PATTERN,\n\tOID_PNP_REMOVE_WAKE_UP_PATTERN,\n#endif\t/* RNDIS_WAKEUP */\n#endif\t/* RNDIS_PM */\n};\n\n\n/* NDIS Functions */\nstatic int gen_ndis_query_resp(struct rndis_params *params, u32 OID, u8 *buf,\n\t\t\t       unsigned buf_len, rndis_resp_t *r)\n{\n\tint retval = -ENOTSUPP;\n\tu32 length = 4;\t/* usually */\n\t__le32 *outbuf;\n\tint i, count;\n\trndis_query_cmplt_type *resp;\n\tstruct net_device *net;\n\tstruct rtnl_link_stats64 temp;\n\tconst struct rtnl_link_stats64 *stats;\n\n\tif (!r) return -ENOMEM;\n\tresp = (rndis_query_cmplt_type *)r->buf;\n\n\tif (!resp) return -ENOMEM;\n\n\tif (buf_len && rndis_debug > 1) {\n\t\tpr_debug(\"query OID %08x value, len %d:\\n\", OID, buf_len);\n\t\tfor (i = 0; i < buf_len; i += 16) {\n\t\t\tpr_debug(\"%03d: %08x %08x %08x %08x\\n\", i,\n\t\t\t\tget_unaligned_le32(&buf[i]),\n\t\t\t\tget_unaligned_le32(&buf[i + 4]),\n\t\t\t\tget_unaligned_le32(&buf[i + 8]),\n\t\t\t\tget_unaligned_le32(&buf[i + 12]));\n\t\t}\n\t}\n\n\t/* response goes here, right after the header */\n\toutbuf = (__le32 *)&resp[1];\n\tresp->InformationBufferOffset = cpu_to_le32(16);\n\n\tnet = params->dev;\n\tstats = dev_get_stats(net, &temp);\n\n\tswitch (OID) {\n\n\t/* general oids (table 4-1) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_SUPPORTED_LIST:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_SUPPORTED_LIST\\n\", __func__);\n\t\tlength = sizeof(oid_supported_list);\n\t\tcount  = length / sizeof(u32);\n\t\tfor (i = 0; i < count; i++)\n\t\t\toutbuf[i] = cpu_to_le32(oid_supported_list[i]);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_HARDWARE_STATUS:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_HARDWARE_STATUS\\n\", __func__);\n\t\t/* Bogus question!\n\t\t * Hardware must be ready to receive high level protocols.\n\t\t * BTW:\n\t\t * reddite ergo quae sunt Caesaris Caesari\n\t\t * et quae sunt Dei Deo!\n\t\t */\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MEDIA_SUPPORTED:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MEDIA_SUPPORTED\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(params->medium);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MEDIA_IN_USE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MEDIA_IN_USE\\n\", __func__);\n\t\t/* one medium, one transport... (maybe you do it better) */\n\t\t*outbuf = cpu_to_le32(params->medium);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MAXIMUM_FRAME_SIZE\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\t*outbuf = cpu_to_le32(params->dev->mtu);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_LINK_SPEED:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_LINK_SPEED\\n\", __func__);\n\t\tif (params->media_state == RNDIS_MEDIA_STATE_DISCONNECTED)\n\t\t\t*outbuf = cpu_to_le32(0);\n\t\telse\n\t\t\t*outbuf = cpu_to_le32(params->speed);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_TRANSMIT_BLOCK_SIZE\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\t*outbuf = cpu_to_le32(params->dev->mtu);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_RECEIVE_BLOCK_SIZE\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\t*outbuf = cpu_to_le32(params->dev->mtu);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_VENDOR_ID:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_VENDOR_ID\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(params->vendorID);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_VENDOR_DESCRIPTION:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_VENDOR_DESCRIPTION\\n\", __func__);\n\t\tif (params->vendorDescr) {\n\t\t\tlength = strlen(params->vendorDescr);\n\t\t\tmemcpy(outbuf, params->vendorDescr, length);\n\t\t} else {\n\t\t\toutbuf[0] = 0;\n\t\t}\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase RNDIS_OID_GEN_VENDOR_DRIVER_VERSION:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_VENDOR_DRIVER_VERSION\\n\", __func__);\n\t\t/* Created as LE */\n\t\t*outbuf = rndis_driver_version;\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_CURRENT_PACKET_FILTER:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_CURRENT_PACKET_FILTER\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(*params->filter);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MAXIMUM_TOTAL_SIZE\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(RNDIS_MAX_TOTAL_SIZE);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_MEDIA_CONNECT_STATUS:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_MEDIA_CONNECT_STATUS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(params->media_state);\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase RNDIS_OID_GEN_PHYSICAL_MEDIUM:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_PHYSICAL_MEDIUM\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* The RNDIS specification is incomplete/wrong.   Some versions\n\t * of MS-Windows expect OIDs that aren't specified there.  Other\n\t * versions emit undefined RNDIS messages. DOCUMENT ALL THESE!\n\t */\n\tcase RNDIS_OID_GEN_MAC_OPTIONS:\t\t/* from WinME */\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_MAC_OPTIONS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(\n\t\t\t  RNDIS_MAC_OPTION_RECEIVE_SERIALIZED\n\t\t\t| RNDIS_MAC_OPTION_FULL_DUPLEX);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* statistics OIDs (table 4-2) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_XMIT_OK:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_XMIT_OK\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->tx_packets\n\t\t\t\t- stats->tx_errors - stats->tx_dropped);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RCV_OK:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_RCV_OK\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_packets\n\t\t\t\t- stats->rx_errors - stats->rx_dropped);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_XMIT_ERROR:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_XMIT_ERROR\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->tx_errors);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RCV_ERROR:\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_OID_GEN_RCV_ERROR\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_errors);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_GEN_RCV_NO_BUFFER:\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_RCV_NO_BUFFER\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_dropped);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* ieee802.3 OIDs (table 4-3) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_PERMANENT_ADDRESS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_PERMANENT_ADDRESS\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\tlength = ETH_ALEN;\n\t\t\tmemcpy(outbuf, params->host_mac, length);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_CURRENT_ADDRESS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_CURRENT_ADDRESS\\n\", __func__);\n\t\tif (params->dev) {\n\t\t\tlength = ETH_ALEN;\n\t\t\tmemcpy(outbuf, params->host_mac, length);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_MULTICAST_LIST:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MULTICAST_LIST\\n\", __func__);\n\t\t/* Multicast base address only */\n\t\t*outbuf = cpu_to_le32(0xE0000000);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_MAXIMUM_LIST_SIZE:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MAXIMUM_LIST_SIZE\\n\", __func__);\n\t\t/* Multicast base address only */\n\t\t*outbuf = cpu_to_le32(1);\n\t\tretval = 0;\n\t\tbreak;\n\n\tcase RNDIS_OID_802_3_MAC_OPTIONS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MAC_OPTIONS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* ieee802.3 statistics OIDs (table 4-4) */\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_RCV_ERROR_ALIGNMENT\\n\", __func__);\n\t\tif (stats) {\n\t\t\t*outbuf = cpu_to_le32(stats->rx_frame_errors);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_XMIT_ONE_COLLISION:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_XMIT_ONE_COLLISION\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\t/* mandatory */\n\tcase RNDIS_OID_802_3_XMIT_MORE_COLLISIONS:\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_XMIT_MORE_COLLISIONS\\n\", __func__);\n\t\t*outbuf = cpu_to_le32(0);\n\t\tretval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s: query unknown OID 0x%08X\\n\", __func__, OID);\n\t}\n\tif (retval < 0)\n\t\tlength = 0;\n\n\tresp->InformationBufferLength = cpu_to_le32(length);\n\tr->length = length + sizeof(*resp);\n\tresp->MessageLength = cpu_to_le32(r->length);\n\treturn retval;\n}\n\nstatic int gen_ndis_set_resp(struct rndis_params *params, u32 OID,\n\t\t\t     u8 *buf, u32 buf_len, rndis_resp_t *r)\n{\n\trndis_set_cmplt_type *resp;\n\tint i, retval = -ENOTSUPP;\n\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tif (buf_len && rndis_debug > 1) {\n\t\tpr_debug(\"set OID %08x value, len %d:\\n\", OID, buf_len);\n\t\tfor (i = 0; i < buf_len; i += 16) {\n\t\t\tpr_debug(\"%03d: %08x %08x %08x %08x\\n\", i,\n\t\t\t\tget_unaligned_le32(&buf[i]),\n\t\t\t\tget_unaligned_le32(&buf[i + 4]),\n\t\t\t\tget_unaligned_le32(&buf[i + 8]),\n\t\t\t\tget_unaligned_le32(&buf[i + 12]));\n\t\t}\n\t}\n\n\tswitch (OID) {\n\tcase RNDIS_OID_GEN_CURRENT_PACKET_FILTER:\n\n\t\t/* these NDIS_PACKET_TYPE_* bitflags are shared with\n\t\t * cdc_filter; it's not RNDIS-specific\n\t\t * NDIS_PACKET_TYPE_x == USB_CDC_PACKET_TYPE_x for x in:\n\t\t *\tPROMISCUOUS, DIRECTED,\n\t\t *\tMULTICAST, ALL_MULTICAST, BROADCAST\n\t\t */\n\t\t*params->filter = (u16)get_unaligned_le32(buf);\n\t\tpr_debug(\"%s: RNDIS_OID_GEN_CURRENT_PACKET_FILTER %08x\\n\",\n\t\t\t__func__, *params->filter);\n\n\t\t/* this call has a significant side effect:  it's\n\t\t * what makes the packet flow start and stop, like\n\t\t * activating the CDC Ethernet altsetting.\n\t\t */\n\t\tretval = 0;\n\t\tif (*params->filter) {\n\t\t\tparams->state = RNDIS_DATA_INITIALIZED;\n\t\t\tnetif_carrier_on(params->dev);\n\t\t\tif (netif_running(params->dev))\n\t\t\t\tnetif_wake_queue(params->dev);\n\t\t} else {\n\t\t\tparams->state = RNDIS_INITIALIZED;\n\t\t\tnetif_carrier_off(params->dev);\n\t\t\tnetif_stop_queue(params->dev);\n\t\t}\n\t\tbreak;\n\n\tcase RNDIS_OID_802_3_MULTICAST_LIST:\n\t\t/* I think we can ignore this */\n\t\tpr_debug(\"%s: RNDIS_OID_802_3_MULTICAST_LIST\\n\", __func__);\n\t\tretval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_warn(\"%s: set unknown OID 0x%08X, size %d\\n\",\n\t\t\t__func__, OID, buf_len);\n\t}\n\n\treturn retval;\n}\n\n/*\n * Response Functions\n */\n\nstatic int rndis_init_response(struct rndis_params *params,\n\t\t\t       rndis_init_msg_type *buf)\n{\n\trndis_init_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\tif (!params->dev)\n\t\treturn -ENOTSUPP;\n\n\tr = rndis_add_response(params, sizeof(rndis_init_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_init_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_INIT_C);\n\tresp->MessageLength = cpu_to_le32(52);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\tresp->MajorVersion = cpu_to_le32(RNDIS_MAJOR_VERSION);\n\tresp->MinorVersion = cpu_to_le32(RNDIS_MINOR_VERSION);\n\tresp->DeviceFlags = cpu_to_le32(RNDIS_DF_CONNECTIONLESS);\n\tresp->Medium = cpu_to_le32(RNDIS_MEDIUM_802_3);\n\tresp->MaxPacketsPerTransfer = cpu_to_le32(1);\n\tresp->MaxTransferSize = cpu_to_le32(\n\t\t  params->dev->mtu\n\t\t+ sizeof(struct ethhdr)\n\t\t+ sizeof(struct rndis_packet_msg_type)\n\t\t+ 22);\n\tresp->PacketAlignmentFactor = cpu_to_le32(0);\n\tresp->AFListOffset = cpu_to_le32(0);\n\tresp->AFListSize = cpu_to_le32(0);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_query_response(struct rndis_params *params,\n\t\t\t\trndis_query_msg_type *buf)\n{\n\trndis_query_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\t/* pr_debug(\"%s: OID = %08X\\n\", __func__, cpu_to_le32(buf->OID)); */\n\tif (!params->dev)\n\t\treturn -ENOTSUPP;\n\n\t/*\n\t * we need more memory:\n\t * gen_ndis_query_resp expects enough space for\n\t * rndis_query_cmplt_type followed by data.\n\t * oid_supported_list is the largest data reply\n\t */\n\tr = rndis_add_response(params,\n\t\tsizeof(oid_supported_list) + sizeof(rndis_query_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_query_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_QUERY_C);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\n\tif (gen_ndis_query_resp(params, le32_to_cpu(buf->OID),\n\t\t\tle32_to_cpu(buf->InformationBufferOffset)\n\t\t\t\t\t+ 8 + (u8 *)buf,\n\t\t\tle32_to_cpu(buf->InformationBufferLength),\n\t\t\tr)) {\n\t\t/* OID not supported */\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\t\tresp->MessageLength = cpu_to_le32(sizeof *resp);\n\t\tresp->InformationBufferLength = cpu_to_le32(0);\n\t\tresp->InformationBufferOffset = cpu_to_le32(0);\n\t} else\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_set_response(struct rndis_params *params,\n\t\t\t      rndis_set_msg_type *buf)\n{\n\tu32 BufLength, BufOffset;\n\trndis_set_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\tBufLength = le32_to_cpu(buf->InformationBufferLength);\n\tBufOffset = le32_to_cpu(buf->InformationBufferOffset);\n\tif ((BufLength > RNDIS_MAX_TOTAL_SIZE) ||\n\t    (BufOffset + 8 >= RNDIS_MAX_TOTAL_SIZE))\n\t\t    return -EINVAL;\n\n\tr = rndis_add_response(params, sizeof(rndis_set_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_set_cmplt_type *)r->buf;\n\n#ifdef\tVERBOSE_DEBUG\n\tpr_debug(\"%s: Length: %d\\n\", __func__, BufLength);\n\tpr_debug(\"%s: Offset: %d\\n\", __func__, BufOffset);\n\tpr_debug(\"%s: InfoBuffer: \", __func__);\n\n\tfor (i = 0; i < BufLength; i++) {\n\t\tpr_debug(\"%02x \", *(((u8 *) buf) + i + 8 + BufOffset));\n\t}\n\n\tpr_debug(\"\\n\");\n#endif\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_SET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tif (gen_ndis_set_resp(params, le32_to_cpu(buf->OID),\n\t\t\t((u8 *)buf) + 8 + BufOffset, BufLength, r))\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);\n\telse\n\t\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_reset_response(struct rndis_params *params,\n\t\t\t\trndis_reset_msg_type *buf)\n{\n\trndis_reset_cmplt_type *resp;\n\trndis_resp_t *r;\n\tu8 *xbuf;\n\tu32 length;\n\n\t/* drain the response queue */\n\twhile ((xbuf = rndis_get_next_response(params, &length)))\n\t\trndis_free_response(params, xbuf);\n\n\tr = rndis_add_response(params, sizeof(rndis_reset_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_reset_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_RESET_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\t/* resent information */\n\tresp->AddressingReset = cpu_to_le32(1);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nstatic int rndis_keepalive_response(struct rndis_params *params,\n\t\t\t\t    rndis_keepalive_msg_type *buf)\n{\n\trndis_keepalive_cmplt_type *resp;\n\trndis_resp_t *r;\n\n\t/* host \"should\" check only in RNDIS_DATA_INITIALIZED state */\n\n\tr = rndis_add_response(params, sizeof(rndis_keepalive_cmplt_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_keepalive_cmplt_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_KEEPALIVE_C);\n\tresp->MessageLength = cpu_to_le32(16);\n\tresp->RequestID = buf->RequestID; /* Still LE in msg buffer */\n\tresp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\n\n/*\n * Device to Host Comunication\n */\nstatic int rndis_indicate_status_msg(struct rndis_params *params, u32 status)\n{\n\trndis_indicate_status_msg_type *resp;\n\trndis_resp_t *r;\n\n\tif (params->state == RNDIS_UNINITIALIZED)\n\t\treturn -ENOTSUPP;\n\n\tr = rndis_add_response(params, sizeof(rndis_indicate_status_msg_type));\n\tif (!r)\n\t\treturn -ENOMEM;\n\tresp = (rndis_indicate_status_msg_type *)r->buf;\n\n\tresp->MessageType = cpu_to_le32(RNDIS_MSG_INDICATE);\n\tresp->MessageLength = cpu_to_le32(20);\n\tresp->Status = cpu_to_le32(status);\n\tresp->StatusBufferLength = cpu_to_le32(0);\n\tresp->StatusBufferOffset = cpu_to_le32(0);\n\n\tparams->resp_avail(params->v);\n\treturn 0;\n}\n\nint rndis_signal_connect(struct rndis_params *params)\n{\n\tparams->media_state = RNDIS_MEDIA_STATE_CONNECTED;\n\treturn rndis_indicate_status_msg(params, RNDIS_STATUS_MEDIA_CONNECT);\n}\nEXPORT_SYMBOL_GPL(rndis_signal_connect);\n\nint rndis_signal_disconnect(struct rndis_params *params)\n{\n\tparams->media_state = RNDIS_MEDIA_STATE_DISCONNECTED;\n\treturn rndis_indicate_status_msg(params, RNDIS_STATUS_MEDIA_DISCONNECT);\n}\nEXPORT_SYMBOL_GPL(rndis_signal_disconnect);\n\nvoid rndis_uninit(struct rndis_params *params)\n{\n\tu8 *buf;\n\tu32 length;\n\n\tif (!params)\n\t\treturn;\n\tparams->state = RNDIS_UNINITIALIZED;\n\n\t/* drain the response queue */\n\twhile ((buf = rndis_get_next_response(params, &length)))\n\t\trndis_free_response(params, buf);\n}\nEXPORT_SYMBOL_GPL(rndis_uninit);\n\nvoid rndis_set_host_mac(struct rndis_params *params, const u8 *addr)\n{\n\tparams->host_mac = addr;\n}\nEXPORT_SYMBOL_GPL(rndis_set_host_mac);\n\n/*\n * Message Parser\n */\nint rndis_msg_parser(struct rndis_params *params, u8 *buf)\n{\n\tu32 MsgType, MsgLength;\n\t__le32 *tmp;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\ttmp = (__le32 *)buf;\n\tMsgType   = get_unaligned_le32(tmp++);\n\tMsgLength = get_unaligned_le32(tmp++);\n\n\tif (!params)\n\t\treturn -ENOTSUPP;\n\n\t/* NOTE: RNDIS is *EXTREMELY* chatty ... Windows constantly polls for\n\t * rx/tx statistics and link status, in addition to KEEPALIVE traffic\n\t * and normal HC level polling to see if there's any IN traffic.\n\t */\n\n\t/* For USB: responses may take up to 10 seconds */\n\tswitch (MsgType) {\n\tcase RNDIS_MSG_INIT:\n\t\tpr_debug(\"%s: RNDIS_MSG_INIT\\n\",\n\t\t\t__func__);\n\t\tparams->state = RNDIS_INITIALIZED;\n\t\treturn rndis_init_response(params, (rndis_init_msg_type *)buf);\n\n\tcase RNDIS_MSG_HALT:\n\t\tpr_debug(\"%s: RNDIS_MSG_HALT\\n\",\n\t\t\t__func__);\n\t\tparams->state = RNDIS_UNINITIALIZED;\n\t\tif (params->dev) {\n\t\t\tnetif_carrier_off(params->dev);\n\t\t\tnetif_stop_queue(params->dev);\n\t\t}\n\t\treturn 0;\n\n\tcase RNDIS_MSG_QUERY:\n\t\treturn rndis_query_response(params,\n\t\t\t\t\t(rndis_query_msg_type *)buf);\n\n\tcase RNDIS_MSG_SET:\n\t\treturn rndis_set_response(params, (rndis_set_msg_type *)buf);\n\n\tcase RNDIS_MSG_RESET:\n\t\tpr_debug(\"%s: RNDIS_MSG_RESET\\n\",\n\t\t\t__func__);\n\t\treturn rndis_reset_response(params,\n\t\t\t\t\t(rndis_reset_msg_type *)buf);\n\n\tcase RNDIS_MSG_KEEPALIVE:\n\t\t/* For USB: host does this every 5 seconds */\n\t\tif (rndis_debug > 1)\n\t\t\tpr_debug(\"%s: RNDIS_MSG_KEEPALIVE\\n\",\n\t\t\t\t__func__);\n\t\treturn rndis_keepalive_response(params,\n\t\t\t\t\t\t (rndis_keepalive_msg_type *)\n\t\t\t\t\t\t buf);\n\n\tdefault:\n\t\t/* At least Windows XP emits some undefined RNDIS messages.\n\t\t * In one case those messages seemed to relate to the host\n\t\t * suspending itself.\n\t\t */\n\t\tpr_warn(\"%s: unknown RNDIS message 0x%08X len %d\\n\",\n\t\t\t__func__, MsgType, MsgLength);\n\t\t/* Garbled message can be huge, so limit what we display */\n\t\tif (MsgLength > 16)\n\t\t\tMsgLength = 16;\n\t\tprint_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,\n\t\t\t\t     buf, MsgLength);\n\t\tbreak;\n\t}\n\n\treturn -ENOTSUPP;\n}\nEXPORT_SYMBOL_GPL(rndis_msg_parser);\n\nstatic inline int rndis_get_nr(void)\n{\n\treturn ida_simple_get(&rndis_ida, 0, 0, GFP_KERNEL);\n}\n\nstatic inline void rndis_put_nr(int nr)\n{\n\tida_simple_remove(&rndis_ida, nr);\n}\n\nstruct rndis_params *rndis_register(void (*resp_avail)(void *v), void *v)\n{\n\tstruct rndis_params *params;\n\tint i;\n\n\tif (!resp_avail)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ti = rndis_get_nr();\n\tif (i < 0) {\n\t\tpr_debug(\"failed\\n\");\n\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params) {\n\t\trndis_put_nr(i);\n\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n#ifdef\tCONFIG_USB_GADGET_DEBUG_FILES\n\t{\n\t\tstruct proc_dir_entry *proc_entry;\n\t\tchar name[20];\n\n\t\tsprintf(name, NAME_TEMPLATE, i);\n\t\tproc_entry = proc_create_data(name, 0660, NULL,\n\t\t\t\t\t      &rndis_proc_ops, params);\n\t\tif (!proc_entry) {\n\t\t\tkfree(params);\n\t\t\trndis_put_nr(i);\n\n\t\t\treturn ERR_PTR(-EIO);\n\t\t}\n\t}\n#endif\n\n\tparams->confignr = i;\n\tparams->used = 1;\n\tparams->state = RNDIS_UNINITIALIZED;\n\tparams->media_state = RNDIS_MEDIA_STATE_DISCONNECTED;\n\tparams->resp_avail = resp_avail;\n\tparams->v = v;\n\tINIT_LIST_HEAD(&params->resp_queue);\n\tpr_debug(\"%s: configNr = %d\\n\", __func__, i);\n\n\treturn params;\n}\nEXPORT_SYMBOL_GPL(rndis_register);\n\nvoid rndis_deregister(struct rndis_params *params)\n{\n\tint i;\n\n\tpr_debug(\"%s:\\n\", __func__);\n\n\tif (!params)\n\t\treturn;\n\n\ti = params->confignr;\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\t{\n\t\tchar name[20];\n\n\t\tsprintf(name, NAME_TEMPLATE, i);\n\t\tremove_proc_entry(name, NULL);\n\t}\n#endif\n\n\tkfree(params);\n\trndis_put_nr(i);\n}\nEXPORT_SYMBOL_GPL(rndis_deregister);\nint rndis_set_param_dev(struct rndis_params *params, struct net_device *dev,\n\t\t\tu16 *cdc_filter)\n{\n\tpr_debug(\"%s:\\n\", __func__);\n\tif (!dev)\n\t\treturn -EINVAL;\n\tif (!params)\n\t\treturn -1;\n\n\tparams->dev = dev;\n\tparams->filter = cdc_filter;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_set_param_dev);\n\nint rndis_set_param_vendor(struct rndis_params *params, u32 vendorID,\n\t\t\t   const char *vendorDescr)\n{\n\tpr_debug(\"%s:\\n\", __func__);\n\tif (!vendorDescr) return -1;\n\tif (!params)\n\t\treturn -1;\n\n\tparams->vendorID = vendorID;\n\tparams->vendorDescr = vendorDescr;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_set_param_vendor);\n\nint rndis_set_param_medium(struct rndis_params *params, u32 medium, u32 speed)\n{\n\tpr_debug(\"%s: %u %u\\n\", __func__, medium, speed);\n\tif (!params)\n\t\treturn -1;\n\n\tparams->medium = medium;\n\tparams->speed = speed;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_set_param_medium);\n\nvoid rndis_add_hdr(struct sk_buff *skb)\n{\n\tstruct rndis_packet_msg_type *header;\n\n\tif (!skb)\n\t\treturn;\n\theader = skb_push(skb, sizeof(*header));\n\tmemset(header, 0, sizeof *header);\n\theader->MessageType = cpu_to_le32(RNDIS_MSG_PACKET);\n\theader->MessageLength = cpu_to_le32(skb->len);\n\theader->DataOffset = cpu_to_le32(36);\n\theader->DataLength = cpu_to_le32(skb->len - sizeof(*header));\n}\nEXPORT_SYMBOL_GPL(rndis_add_hdr);\n\nvoid rndis_free_response(struct rndis_params *params, u8 *buf)\n{\n\trndis_resp_t *r, *n;\n\n\tlist_for_each_entry_safe(r, n, &params->resp_queue, list) {\n\t\tif (r->buf == buf) {\n\t\t\tlist_del(&r->list);\n\t\t\tkfree(r);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(rndis_free_response);\n\nu8 *rndis_get_next_response(struct rndis_params *params, u32 *length)\n{\n\trndis_resp_t *r, *n;\n\n\tif (!length) return NULL;\n\n\tlist_for_each_entry_safe(r, n, &params->resp_queue, list) {\n\t\tif (!r->send) {\n\t\t\tr->send = 1;\n\t\t\t*length = r->length;\n\t\t\treturn r->buf;\n\t\t}\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(rndis_get_next_response);\n\nstatic rndis_resp_t *rndis_add_response(struct rndis_params *params, u32 length)\n{\n\trndis_resp_t *r;\n\n\t/* NOTE: this gets copied into ether.c USB_BUFSIZ bytes ... */\n\tr = kmalloc(sizeof(rndis_resp_t) + length, GFP_ATOMIC);\n\tif (!r) return NULL;\n\n\tr->buf = (u8 *)(r + 1);\n\tr->length = length;\n\tr->send = 0;\n\n\tlist_add_tail(&r->list, &params->resp_queue);\n\treturn r;\n}\n\nint rndis_rm_hdr(struct gether *port,\n\t\t\tstruct sk_buff *skb,\n\t\t\tstruct sk_buff_head *list)\n{\n\t/* tmp points to a struct rndis_packet_msg_type */\n\t__le32 *tmp = (void *)skb->data;\n\n\t/* MessageType, MessageLength */\n\tif (cpu_to_le32(RNDIS_MSG_PACKET)\n\t\t\t!= get_unaligned(tmp++)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EINVAL;\n\t}\n\ttmp++;\n\n\t/* DataOffset, DataLength */\n\tif (!skb_pull(skb, get_unaligned_le32(tmp++) + 8)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EOVERFLOW;\n\t}\n\tskb_trim(skb, get_unaligned_le32(tmp++));\n\n\tskb_queue_tail(list, skb);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rndis_rm_hdr);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\nstatic int rndis_proc_show(struct seq_file *m, void *v)\n{\n\trndis_params *param = m->private;\n\n\tseq_printf(m,\n\t\t\t \"Config Nr. %d\\n\"\n\t\t\t \"used      : %s\\n\"\n\t\t\t \"state     : %s\\n\"\n\t\t\t \"medium    : 0x%08X\\n\"\n\t\t\t \"speed     : %d\\n\"\n\t\t\t \"cable     : %s\\n\"\n\t\t\t \"vendor ID : 0x%08X\\n\"\n\t\t\t \"vendor    : %s\\n\",\n\t\t\t param->confignr, (param->used) ? \"y\" : \"n\",\n\t\t\t ({ char *s = \"?\";\n\t\t\t switch (param->state) {\n\t\t\t case RNDIS_UNINITIALIZED:\n\t\t\t\ts = \"RNDIS_UNINITIALIZED\"; break;\n\t\t\t case RNDIS_INITIALIZED:\n\t\t\t\ts = \"RNDIS_INITIALIZED\"; break;\n\t\t\t case RNDIS_DATA_INITIALIZED:\n\t\t\t\ts = \"RNDIS_DATA_INITIALIZED\"; break;\n\t\t\t} s; }),\n\t\t\t param->medium,\n\t\t\t (param->media_state) ? 0 : param->speed*100,\n\t\t\t (param->media_state) ? \"disconnected\" : \"connected\",\n\t\t\t param->vendorID, param->vendorDescr);\n\treturn 0;\n}\n\nstatic ssize_t rndis_proc_write(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\trndis_params *p = pde_data(file_inode(file));\n\tu32 speed = 0;\n\tint i, fl_speed = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tchar c;\n\t\tif (get_user(c, buffer))\n\t\t\treturn -EFAULT;\n\t\tswitch (c) {\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\tfl_speed = 1;\n\t\t\tspeed = speed * 10 + c - '0';\n\t\t\tbreak;\n\t\tcase 'C':\n\t\tcase 'c':\n\t\t\trndis_signal_connect(p);\n\t\t\tbreak;\n\t\tcase 'D':\n\t\tcase 'd':\n\t\t\trndis_signal_disconnect(p);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (fl_speed) p->speed = speed;\n\t\t\telse pr_debug(\"%c is not valid\\n\", c);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuffer++;\n\t}\n\n\treturn count;\n}\n\nstatic int rndis_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rndis_proc_show, pde_data(inode));\n}\n\nstatic const struct proc_ops rndis_proc_ops = {\n\t.proc_open\t= rndis_proc_open,\n\t.proc_read\t= seq_read,\n\t.proc_lseek\t= seq_lseek,\n\t.proc_release\t= single_release,\n\t.proc_write\t= rndis_proc_write,\n};\n\n#define\tNAME_TEMPLATE \"driver/rndis-%03d\"\n\n#endif /* CONFIG_USB_GADGET_DEBUG_FILES */\n"], "filenames": ["drivers/usb/gadget/function/rndis.c"], "buggy_code_start_loc": [639], "buggy_code_end_loc": [647], "fixing_code_start_loc": [640], "fixing_code_end_loc": [649], "type": "CWE-668", "message": "An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory.", "other": {"cve": {"id": "CVE-2022-25375", "sourceIdentifier": "cve@mitre.org", "published": "2022-02-20T20:15:18.117", "lastModified": "2022-05-11T13:52:27.483", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in drivers/usb/gadget/function/rndis.c in the Linux kernel before 5.16.10. The RNDIS USB gadget lacks validation of the size of the RNDIS_MSG_SET command. Attackers can obtain sensitive information from kernel memory."}, {"lang": "es", "value": "Se ha detectado un problema en el archivo drivers/usb/gadget/function/rndis.c en el kernel de Linux versiones anteriores a 5.16.10. El gadget USB RNDIS no comprueba el tama\u00f1o del comando RNDIS_MSG_SET. Los atacantes pueden obtener informaci\u00f3n confidencial de la memoria del kernel"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.16.10", "matchCriteriaId": "6FADC79F-20B6-4353-B8FF-03CDC52EFBE4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/02/21/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.16.10", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/szymonh/rndis-co", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/38ea1eac7d88072bbffb630e2b3db83ca649b826", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5092", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5096", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/38ea1eac7d88072bbffb630e2b3db83ca649b826"}}