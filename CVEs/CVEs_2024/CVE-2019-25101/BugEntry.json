{"buggy_code": ["\"\"\"Classes and methods for TurboGears controllers.\"\"\"\n\nimport logging\nimport re\nimport urllib\nimport urlparse\nimport types\nfrom itertools import izip\nfrom dispatch import generic, strategy, functions\nfrom inspect import isclass\nimport cherrypy\nfrom cherrypy import request, response\nimport turbogears.util as tg_util\nfrom turbogears import view, database, errorhandling, config\nfrom turbogears.decorator import weak_signature_decorator\nfrom turbogears.validators import Invalid\nfrom turbogears.errorhandling import error_handler, exception_handler\nfrom memory_profiler_setup import profile_expose_method\n\nlog = logging.getLogger(\"turbogears.controllers\")\n\nif config.get(\"session_filter.on\", None):\n    if config.get(\"session_filter.storage_type\", None) == \"PostgreSQL\":\n        import psycopg2\n        config.update(\n                {'session_filter.get_db': psycopg2.connect(\n                    psycopg2.get('sessions.postgres.dsn'))\n                    })\n    # support for mysql/sqlite/etc here\n\n\ndef _process_output(output, template, format, content_type,\n        mapping, fragment=False):\n    \"\"\"Produce final output form from data returned from a controller method.\n\n    See the expose() arguments for more info since they are the same.\n\n    \"\"\"\n    if isinstance(output, dict):\n        from turbogears.widgets import js_location\n\n        css = tg_util.setlike()\n        js = dict(izip(js_location, iter(tg_util.setlike, None)))\n        include_widgets = {}\n        include_widgets_lst = config.get(\"tg.include_widgets\", [])\n\n        if config.get(\"tg.mochikit_all\", False):\n            include_widgets_lst.insert(0, 'turbogears.mochikit')\n\n        for i in include_widgets_lst:\n            widget = tg_util.load_class(i)\n            if isclass(widget):\n                widget = widget()\n            include_widgets[\"tg_%s\" % i.split(\".\")[-1]] = widget\n            for script in widget.retrieve_javascript():\n                if hasattr(script, \"location\"):\n                    js[script.location].add(script)\n                else:\n                    js[js_location.head].add(script)\n            css.add_all(widget.retrieve_css())\n\n        for value in output.itervalues():\n            if hasattr(value, \"retrieve_css\"):\n                retrieve = getattr(value, \"retrieve_css\")\n                if callable(retrieve):\n                    css.add_all(value.retrieve_css())\n            if hasattr(value, \"retrieve_javascript\"):\n                retrieve = getattr(value, \"retrieve_javascript\")\n                if callable(retrieve):\n                    for script in value.retrieve_javascript():\n                        if hasattr(script, \"location\"):\n                            js[script.location].add(script)\n                        else:\n                            js[js_location.head].add(script)\n        output.update(include_widgets)\n        output[\"tg_css\"] = css\n        for location in iter(js_location):\n            output[\"tg_js_%s\" % str(location)] = js[location]\n\n        tg_flash = _get_flash()\n        if tg_flash:\n            output[\"tg_flash\"] = tg_flash\n\n        headers = {'Content-Type': content_type}\n        output = view.render(output, template=template, format=format,\n                    mapping=mapping, headers=headers,\n                    fragment=fragment)\n        content_type = headers['Content-Type']\n\n    if content_type:\n        response.headers[\"Content-Type\"] = content_type\n    else:\n        content_type = response.headers.get(\"Content-Type\", 'text/plain')\n\n    if content_type.startswith(\"text/\"):\n        if isinstance(output, unicode):\n            output = output.encode(tg_util.get_template_encoding_default())\n\n    return output\n\n\nclass BadFormatError(Exception):\n    \"\"\"Output-format exception.\"\"\"\n\n\ndef validate(form=None, validators=None,\n             failsafe_schema=errorhandling.FailsafeSchema.none,\n             failsafe_values=None, state_factory=None):\n    \"\"\"Validate input.\n\n    @param form: a form instance that must be passed throught the validation\n    process... you must give a the same form instance as the one that will\n    be used to post data on the controller you are putting the validate\n    decorator on.\n    @type form: a form instance\n\n    @param validators: individual validators to use for parameters.\n    If you use a schema for validation then the schema instance must\n    be the sole argument.\n    If you use simple validators, then you must pass a dictionary with\n    each value name to validate as a key of the dictionary and the validator\n    instance (eg: tg.validators.Int() for integer) as the value.\n    @type validators: dictionary or schema instance\n\n    @param failsafe_schema: a schema for handling failsafe values.\n    The default is 'none', but you can also use 'values', 'map_errors',\n    or 'defaults' to map erroneous inputs to values, corresponding exceptions\n    or method defaults.\n    @type failsafe_schema: errorhandling.FailsafeSchema\n\n    @param failsafe_values: replacements for erroneous inputs. You can either\n    define replacements for every parameter, or a single replacement value\n    for all parameters. This is only used when failsafe_schema is 'values'.\n    @type failsafe_values: a dictionary or a single value\n\n    @param state_factory: If this is None, the initial state for validation\n    is set to None, otherwise this must be a callable that returns the initial\n    state to be used for validation.\n    @type state_factory: callable or None\n\n    \"\"\"\n    def entangle(func):\n        if callable(form) and not hasattr(form, \"validate\"):\n            init_form = lambda self: form(self)\n        else:\n            init_form = lambda self: form\n\n        def validate(func, *args, **kw):\n            # do not validate a second time if already validated\n            if hasattr(request, 'validation_state'):\n                return func(*args, **kw)\n\n            form = init_form(args and args[0] or kw[\"self\"])\n            args, kw = tg_util.to_kw(func, args, kw)\n\n            errors = {}\n            if state_factory is not None:\n                state = state_factory()\n            else:\n                state = None\n\n            if form:\n                value = kw.copy()\n                try:\n                    kw.update(form.validate(value, state))\n                except Invalid, e:\n                    errors = e.unpack_errors()\n                    request.validation_exception = e\n                request.validated_form = form\n\n            if validators:\n                if isinstance(validators, dict):\n                    for field, validator in validators.iteritems():\n                        try:\n                            kw[field] = validator.to_python(\n                                kw.get(field, None), state)\n                        except Invalid, error:\n                            errors[field] = error\n                else:\n                    try:\n                        value = kw.copy()\n                        kw.update(validators.to_python(value, state))\n                    except Invalid, e:\n                        errors = e.unpack_errors()\n                        request.validation_exception = e\n            request.validation_errors = errors\n            request.input_values = kw.copy()\n            request.validation_state = state\n\n            if errors:\n                kw = errorhandling.dispatch_failsafe(failsafe_schema,\n                                            failsafe_values, errors, func, kw)\n            args, kw = tg_util.from_kw(func, args, kw)\n            return errorhandling.run_with_errors(errors, func, *args, **kw)\n\n        return validate\n    return weak_signature_decorator(entangle)\n\n\nclass CustomDispatch(functions.GenericFunction):\n\n    def combine(self, cases):\n        strict = [strategy.ordered_signatures, strategy.safe_methods]\n        cases = strategy.separate_qualifiers(\n            cases,\n            primary = strict,\n        )\n        primary = strategy.method_chain(cases.get('primary', []))\n        if type(primary) != types.FunctionType:\n            for i in primary:\n                for y in i:\n                    return y[1]\n        return primary\n\n\ndef _add_rule(_expose, found_default, as_format, accept_format, template,\n              rulefunc):\n    if as_format == \"default\":\n        if found_default:\n            colon = template.find(\":\")\n            if colon == -1:\n                as_format = template\n            else:\n                as_format = template[:colon]\n        else:\n            found_default = True\n    ruleparts = ['kw.get(\"tg_format\", \"default\") == \"%s\"' % as_format]\n    if accept_format:\n        ruleparts.append('(accept == \"%s\" and kw.get(\"tg_format\"'\n            ', \"default\") == \"default\")' % accept_format)\n    rule = \" or \".join(ruleparts)\n    log.debug(\"Generated rule %s\", rule)\n    _expose.when(rule)(rulefunc)\n\n    return found_default\n\n\ndef _build_rules(func):\n    [generic(CustomDispatch)]\n    def _expose(func, accept, allow_json, *args, **kw):\n        pass\n\n    if func._allow_json:\n        log.debug(\"Adding allow_json rule: \"\n            'allow_json and (kw.get(\"tg_format\", None) == \"json\"'\n            ' or accept in (\"application/json\", \"text/javascript\"))')\n        _expose.when('allow_json and (kw.get(\"tg_format\", None) == \"json\"'\n            ' or accept in (\"application/json\", \"text/javascript\"))')(\n            lambda _func, accept, allow_json, *args, **kw:\n                _execute_func(_func, \"json\", \"json\", \"application/json\",\n                    None, False, args, kw))\n\n    found_default = False\n    for ruleinfo in func._ruleinfo:\n        found_default = _add_rule(_expose, found_default, **ruleinfo)\n\n    func._expose = _expose\n\n\ndef expose(template=None, validators=None, allow_json=None, html=None,\n           format=None, content_type=None, inputform=None, fragment=False,\n           as_format=\"default\", mapping=None, accept_format=None,\n           exclude_from_memory_profiling=False):\n    \"\"\"Exposes a method to the web.\n\n    By putting the expose decorator on a method, you tell TurboGears that\n    the method should be accessible via URL traversal. Additionally, expose\n    handles the output processing (turning a dictionary into finished\n    output) and is also responsible for ensuring that the request is\n    wrapped in a database transaction.\n\n    You can apply multiple expose decorators to a method, if\n    you'd like to support multiple output formats. The decorator that's\n    listed first in your code without as_format or accept_format is\n    the default that is chosen when no format is specifically asked for.\n    Any other expose calls that are missing as_format and accept_format\n    will have as_format implicitly set to the whatever comes before\n    the \":\" in the template name (or the whole template name if there\n    is no \":\". For example, <code>expose(\"json\")</code>, if it's not\n    the default expose, will have as_format set to \"json\".\n\n    When as_format is set, passing the same value in the tg_format\n    parameter in a request will choose the options for that expose\n    decorator. Similarly, accept_format will watch for matching\n    Accept headers. You can also use both. expose(\"json\", as_format=\"json\",\n    accept_format=\"application/json\") will choose JSON output for either\n    case: tg_format=json as a parameter or Accept: application/json as a\n    request header.\n\n    Passing allow_json=True to an expose decorator\n    is equivalent to adding the decorator just mentioned.\n\n    Each expose decorator has its own set of options, and each one\n    can choose a different template or even template engine (you can\n    use Kid for HTML output and Cheetah for plain text, for example).\n    See the other expose parameters below to learn about the options\n    you can pass to the template engine.\n\n    Take a look at the\n    <a href=\"tests/test_expose-source.html\">test_expose.py</a> suite\n    for more examples.\n\n    @param template \"templateengine:dotted.reference\" reference along the\n            Python path for the template and the template engine. For\n            example, \"kid:foo.bar\" will have Kid render the bar template in\n            the foo package.\n    @keyparam format format for the template engine to output (if the\n            template engine can render different formats. Kid, for example,\n            can render \"html\", \"xml\" or \"xhtml\")\n    @keyparam content_type sets the content-type http header\n    @keyparam allow_json allow the function to be exposed as json\n    @keyparam fragment for template engines (like Kid) that generate\n            DOCTYPE declarations and the like, this is a signal to\n            just generate the immediate template fragment. Use this\n            if you're building up a page from multiple templates or\n            going to put something onto a page with .innerHTML.\n    @keyparam mapping mapping with options that are sent to the template\n            engine\n    @keyparam as_format designates which value of tg_format will choose\n            this expose.\n    @keyparam accept_format which value of an Accept: header will\n            choose this expose.\n    @keyparam html deprecated in favor of template\n    @keyparam validators deprecated. Maps argument names to validator\n            applied to that arg\n    @keyparam inputform deprecated. A form object that generates the\n            input to this method\n    @keyparam exclude_from_memory_profiling allows to exclude individual end points from memory profiling. Can be \n            used for performance or in case profiling generates errors\n    \"\"\"\n    if html:\n        template = html\n    if not template:\n        template = format\n    if format == \"json\" or (format is None and template is None):\n        template = \"json\"\n        allow_json = True\n    if content_type is None:\n        content_type = config.get(\"tg.content_type\", None)\n\n    if config.get(\"tg.session.automatic_lock\", None):\n        cherrypy.session.acquire_lock()\n\n    def entangle(func):\n        log.debug(\"Exposing %s\", func)\n        log.debug(\"template: %s, format: %s, allow_json: %s, \"\n            \"content-type: %s\", template, format, allow_json, content_type)\n        if not getattr(func, \"exposed\", False):\n            def expose(func, *args, **kw):\n                accept = request.headers.get('Accept', \"\").lower()\n                accept = tg_util.simplify_http_accept_header(accept)\n                if not hasattr(func, \"_expose\"):\n                    _build_rules(func)\n                if hasattr(request, \"in_transaction\"):\n                    output = func._expose(func, accept, func._allow_json,\n                                *args, **kw)\n                else:\n                    request.in_transaction = True\n                    output = profile_expose_method(_run_with_transaction, accept, args, func, kw,\n                                                   exclude_from_memory_profiling)\n                return output\n            func.exposed = True\n            func._ruleinfo = []\n            allow_json_from_config = config.get(\"tg.allow_json\", False)\n            func._allow_json = allow_json_from_config or template == 'json'\n        else:\n            expose = lambda func, *args, **kw: func(*args, **kw)\n\n        func._ruleinfo.insert(0, dict(as_format=as_format,\n            accept_format=accept_format, template=template,\n            rulefunc = lambda _func, accept, allow_json, *args, **kw:\n                _execute_func(_func, template, format, content_type,\n                    mapping, fragment, args, kw)))\n\n        if allow_json:\n            func._allow_json = True\n\n        if inputform or validators:\n            import warnings\n            warnings.warn(\n                \"Use a separate decorator validate() rather than passing \"\n                \"arguments validators and/or inputform to decorator \"\n                \"expose().\",\n                DeprecationWarning, 2)\n            func = validate(form=inputform, validators=validators)(func)\n\n        return expose\n    return weak_signature_decorator(entangle)\n\n\ndef _run_with_transaction(accept, args, func, kw):\n    return database.run_with_transaction(\n             func._expose, func, accept, func._allow_json,\n             *args, **kw)\n\n\ndef _execute_func(func, template, format, content_type, mapping, fragment, args, kw):\n    \"\"\"Call controller method and process it's output.\"\"\"\n    if config.get(\"tg.strict_parameters\", False):\n        tg_util.remove_keys(kw, [\"tg_random\", \"tg_format\"]\n            + config.get(\"tg.ignore_parameters\", []))\n    else:\n        # get special parameters used by upstream decorators like paginate\n        try:\n            tg_kw = dict([(k, v) for k, v in kw.items() if k in func._tg_args])\n        except AttributeError:\n            tg_kw = {}\n        # remove excessive parameters\n        args, kw = tg_util.adapt_call(func, args, kw)\n        # add special parameters again\n        kw.update(tg_kw)\n    if config.get('server.environment', 'development') == 'development':\n        # Only output this in development mode: If it's a field storage object,\n        # this means big memory usage, and we don't want that in production\n        log.debug(\"Calling %s with *(%s), **(%s)\", func, args, kw)\n    output = errorhandling.try_call(func, *args, **kw)\n    assert isinstance(output, (basestring, dict, list, types.GeneratorType)), \\\n           \"Method %s.%s() returned unexpected output. Output should \" \\\n           \"be of type basestring, dict, list or generator.\" % (\n            args[0].__class__.__name__, func.__name__)\n    if isinstance(output, dict):\n        template = output.pop(\"tg_template\", template)\n        format = output.pop(\"tg_format\", format)\n    if template and template.startswith(\".\"):\n        template = func.__module__[:func.__module__.rfind('.')]+template\n    return _process_output(output, template, format, content_type, mapping, fragment)\n\n\ndef flash(message):\n    \"\"\"Set a message to be displayed in the browser on next page display.\"\"\"\n    message = tg_util.quote_cookie(tg_util.to_utf8(message))\n    response.simple_cookie['tg_flash'] = message\n    response.simple_cookie['tg_flash']['path'] = '/'\n\n\ndef _get_flash():\n    \"\"\"Retrieve the flash message (if one is set), clearing the message.\"\"\"\n    request_cookie = request.simple_cookie\n    response_cookie = response.simple_cookie\n\n    def clearcookie():\n        response_cookie[\"tg_flash\"] = \"\"\n        response_cookie[\"tg_flash\"]['expires'] = 0\n        response_cookie['tg_flash']['path'] = '/'\n\n    if response_cookie.has_key(\"tg_flash\"):\n        message = response_cookie[\"tg_flash\"].value\n        response_cookie.pop(\"tg_flash\")\n        if request_cookie.has_key(\"tg_flash\"):\n            # New flash overrided old one sitting in cookie. Clear that old cookie.\n            clearcookie()\n    elif request_cookie.has_key(\"tg_flash\"):\n        message = request_cookie[\"tg_flash\"].value\n        if not response_cookie.has_key(\"tg_flash\"):\n            clearcookie()\n    else:\n        message = None\n    if message:\n        message = unicode(tg_util.unquote_cookie(message), 'utf-8')\n    return message\n\n\nclass Controller(object):\n    \"\"\"Base class for a web application's controller.\n\n    Currently, this provides positional parameters functionality\n    via a standard default method.\n\n    \"\"\"\n\n\nclass RootController(Controller):\n    \"\"\"Base class for the root of a web application.\n\n    Your web application should have one of these. The root of\n    your application is used to compute URLs used by your app.\n\n    \"\"\"\n    is_app_root = True\n\n    msglog = logging.getLogger('cherrypy.msg')\n    msglogfunc = {0: msglog.info, 1: msglog.warning, 2: msglog.error}\n    def _cp_log_message(self, msg, context = 'nocontext', severity = 0):\n        log = self.msglogfunc[severity]\n        text = ''.join((context, ': ', msg))\n        log(text)\n\n    accesslog = logging.getLogger(\"turbogears.access\")\n    def _cp_log_access(self):\n        tmpl = '%(h)s %(l)s %(u)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n        try:\n            username = request.user_name\n            if username:\n                if isinstance(username, unicode):\n                    # might get concatenated to non-ascii byte strings\n                    username = username.encode('utf-8')\n            else:\n                username = \"-\"\n        except AttributeError:\n            username = \"-\"\n        s = tmpl % {'h': request.remote_host,\n                   'l': '-',\n                   'u': username,\n                   'r': request.requestLine,\n                   's': response.status.split(\" \", 1)[0],\n                   'b': response.headers.get('Content-Length',\n                            '') or \"-\",\n                   'f': request.headers.get('referer', ''),\n                   'a': request.headers.get('user-agent', ''),\n        }\n        self.accesslog.info(s)\n\nRoot = RootController\n\n\ndef url(tgpath, tgparams=None, **kw):\n    \"\"\"Computes URLs.\n\n    tgpath can be a list or a string. If the path is absolute (starts\n    with a \"/\"), the server.webpath, SCRIPT_NAME and the approot of the\n    application are prepended to the path. In order for the approot to\n    be detected properly, the root object should extend\n    controllers.RootController.\n\n    Query parameters for the URL can be passed in as a dictionary in\n    the second argument *or* as keyword parameters.\n\n    Values which are a list or a tuple are used to create multiple\n    key-value pairs.\n\n    \"\"\"\n    if not isinstance(tgpath, basestring):\n        tgpath = '/'.join(list(tgpath))\n    if tgpath.startswith('/'):\n        webpath = (config.get('server.webpath') or '').rstrip('/')\n        if tg_util.request_available():\n            check_app_root()\n            tgpath = request.app_root + tgpath\n            try:\n                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')\n            except (AttributeError, KeyError):\n                pass\n        tgpath = webpath + tgpath\n    if tgparams is None:\n        tgparams = kw\n    else:\n        try:\n            tgparams = tgparams.copy()\n            tgparams.update(kw)\n        except AttributeError:\n            raise TypeError('url() expects a dictionary for query parameters')\n    args = []\n    for key, value in tgparams.iteritems():\n        if value is None:\n            continue\n        if isinstance(value, (list, tuple)):\n            pairs = [(key, v) for v in value]\n        else:\n            pairs = [(key, value)]\n        for k, v in pairs:\n            if v is None:\n                continue\n            if isinstance(v, unicode):\n                v = v.encode('utf8')\n            args.append((k, str(v)))\n    if args:\n        query_string = urllib.urlencode(args, True)\n        if '?' in tgpath:\n            tgpath += '&' + query_string\n        else:\n            tgpath += '?' + query_string\n    return tgpath\n\n\ndef check_app_root():\n    \"\"\"Sets request.app_root if needed.\"\"\"\n    if hasattr(request, 'app_root'):\n        return\n    found_root = False\n    trail = request.object_trail\n    top = len(trail) - 1\n    # compute the app_root by stepping back through the object\n    # trail and collecting up the path elements after the first\n    # root we find\n    # we can eliminate this if we find a way to use\n    # CherryPy's mounting mechanism whenever a new root\n    # is hit.\n    rootlist = []\n    for i in xrange(len(trail) - 1, -1, -1):\n        path, obj = trail[i]\n        if not found_root and isinstance(obj, RootController):\n            if i == top:\n                break\n            found_root = True\n        if found_root and i > 0:\n            rootlist.insert(0, path)\n    app_root = '/'.join(rootlist)\n    if not app_root.startswith('/'):\n        app_root = '/' + app_root\n    if app_root.endswith('/'):\n        app_root = app_root[:-1]\n    request.app_root = app_root\n\n\ndef get_server_name(): \n    \"\"\"Return name of the server this application runs on. \n \n    Respects 'Host' and 'X-Forwarded-Host' header. \n \n    See the docstring of the 'absolute_url' function for more information. \n \n    \"\"\" \n    get = config.get \n    h = request.headers \n    host = get('tg.url_domain') or h.get('X-Forwarded-Host', h.get('Host')) \n    if not host: \n        host = '%s:%s' % (get('server.socket_host', 'localhost'), \n            get('server.socket_port', 8080)) \n    return host \n\n\ndef absolute_url(tgpath='/', params=None, **kw): \n    \"\"\"Return absolute URL (including schema and host to this server). \n \n    Tries to account for 'Host' header and reverse proxying \n    ('X-Forwarded-Host'). \n \n    The host name is determined this way: \n \n    * If the config setting 'tg.url_domain' is set and non-null, use this value. \n    * Else, if the 'base_url_filter.use_x_forwarded_host' config setting is \n      True, use the value from the 'Host' or 'X-Forwarded-Host' request header. \n    * Else, if config setting 'base_url_filter.on' is True and \n      'base_url_filter.base_url' is non-null, use its value for the host AND \n      scheme part of the URL. \n    * As a last fallback, use the value of 'server.socket_host' and \n      'server.socket_port' config settings (defaults to 'localhost:8080'). \n \n    The URL scheme ('http' or 'http') used is determined in the following way: \n \n    * If 'base_url_filter.base_url' is used, use the scheme from this URL. \n    * If there is a 'X-Use-SSL' request header, use 'https'. \n    * Else, if the config setting 'tg.url_scheme' is set, use its value. \n    * Else, use the value of 'cherrypy.request.scheme'. \n \n    \"\"\" \n    get = config.get \n    use_xfh = get('base_url_filter.use_x_forwarded_host', False) \n    if request.headers.get('X-Use-SSL'): \n        scheme = 'https' \n    else: \n        scheme = get('tg.url_scheme') \n    if not scheme: \n        scheme = request.scheme \n    base_url = '%s://%s' % (scheme, get_server_name()) \n    if get('base_url_filter.on', False) and not use_xfh: \n        base_url = get('base_url_filter.base_url').rstrip('/') \n    return '%s%s' % (base_url, url(tgpath, params, **kw)) \n\n\ndef redirect(redirect_path, redirect_params=None, **kw):\n    \"\"\"Redirect (via cherrypy.HTTPRedirect).\n\n    Raises the exception instead of returning it, this to allow\n    users to both call it as a function or to raise it as an exception.\n\n    \"\"\"\n    if not isinstance(redirect_path, basestring):\n        redirect_path = '/'.join(list(redirect_path))\n    if not redirect_path.startswith('/'):\n        path = request.path_info\n        check_app_root()\n        if path.startswith(request.app_root):\n            path = path[len(request.app_root):]\n        redirect_path = urlparse.urljoin(path, redirect_path)\n    raise cherrypy.HTTPRedirect(url(tgpath=redirect_path,\n        tgparams=redirect_params, **kw))\n\n\n__all__ = [\n    \"Controller\",\n    \"error_handler\",\n    \"exception_handler\",\n    \"expose\",\n    \"flash\",\n    \"redirect\",\n    \"Root\",\n    \"RootController\",\n    \"url\",\n    \"validate\",\n]\n", "\"\"\"\\\nFront-to-back rapid web development\n===================================\n\nTurboGears brings together four major pieces to create an easy to\ninstall, easy to use web mega-framework. It covers everything from\nfront end (MochiKit JavaScript for the browser, Genshi / Kid / Mako /\nCheetah for templates in Python) to the controllers (CherryPy) to the\nback end (SQLAlchemy or SQLObject).\n\nThe TurboGears project is focused on providing documentation and\nintegration with these tools without losing touch with the communities\nthat already exist around those tools.\n\nTurboGears is easy to use for a wide range of web applications.\n\nThe latest development version is available in the `TurboGears\nsubversion repository`_.\n\nOur `mailing list`_ is lively and helpful, don't hesitate to send your\nquestions there, we will try to help you find out a solution to your\nproblem.\n\n.. _mailing list:\n    http://groups.google.com/group/turbogears\n\n.. _TurboGears subversion repository:\n    http://svn.turbogears.org/trunk#egg=turbogears-dev\n\"\"\"\n\nversion = \"1.0.11.8\"\ndescription = \"Front-to-back, open-source, rapid web development framework\"\nlong_description = __doc__\nauthor = \"Kevin Dangoor\"\nemail = \"dangoor+turbogears@gmail.com\"\nmaintainer = \"TurboGears Release Team\"\nmaintainer_email = \"turbogears@googlegroups.com\"\nurl = \"http://www.turbogears.org/\"\ndownload_url = \"http://www.turbogears.org/%s/downloads/%s/index\" % (\n    '.'.join(version.split('.', 2)[:2]), version)\ndependency_links = [download_url]\ncopyright = \"Copyright 2005 - 2011 Kevin Dangoor and contributors\"\nlicense = \"MIT\"\n", "import unittest\nimport formencode\nimport cherrypy\nimport pkg_resources\nfrom turbogears import config, controllers, database, \\\n    error_handler, exception_handler, expose, flash, redirect, \\\n    startup, testutil, url, validate, validators\n\n\nclass SubApp(controllers.RootController):\n\n    [expose()]\n    def index(self):\n        return url(\"/Foo/\")\n\n\nclass MyRoot(controllers.RootController):\n\n    [expose()]\n    def index(self):\n        pass\n\n    def validation_error_handler(self, tg_source, tg_errors, *args, **kw):\n        self.functionname = tg_source.__name__\n        self.values = kw\n        self.errors = tg_errors\n        return \"Error Message\"\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def test(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(html=\"turbogears.tests.simple\")]\n    def test_deprecated(self):\n        return dict(title=\"Oldbar\", mybool=False, someval=\"giggles\")\n\n    [expose()]\n    def invalid(self):\n        return None\n\n    [expose()]\n    def pos(self, posvalue):\n        self.posvalue = posvalue\n        return \"\"\n\n    [expose()]\n    def servefile(self, tg_exceptions=None):\n        self.servedit = True\n        self.serve_exceptions = tg_exceptions\n        return cherrypy.lib.cptools.serveFile(\n            pkg_resources.resource_filename(\n                \"turbogears.tests\", \"test_controllers.py\"))\n\n    [expose(content_type='text/plain')]\n    def basestring(self):\n        return 'hello world'\n\n    [expose(content_type='text/plain')]\n    def list(self):\n        return ['hello', 'world']\n\n    [expose(content_type='text/plain')]\n    def generator(self):\n        yield 'hello'\n        yield 'world'\n\n    [expose()]\n    def unicode(self):\n        cherrypy.response.headers[\"Content-Type\"] = \"text/html\"\n        return u'\\u00bfHabla espa\\u00f1ol?'\n\n    [expose()]\n    def returnedtemplate(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n            tg_template=\"turbogears.tests.simple\")\n\n    [expose()]\n    def returnedtemplate_short(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n            tg_template=\"turbogears.tests.simple\")\n\n    [expose(template=\"turbogears.tests.simple\")]\n    def exposetemplate_short(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\")\n\n    [expose()]\n    [validate(validators={'value': validators.StringBoolean()})]\n    def istrue(self, value):\n        self.value = value\n        return str(value)\n    istrue = error_handler(validation_error_handler)(istrue)\n\n    [expose()]\n    [validate(validators={'value': validators.StringBoolean()})]\n    def nestedcall(self, value):\n        return self.istrue(str(value))\n\n    [expose()]\n    [validate(validators={'value': validators.StringBoolean()})]\n    def errorchain(self, value):\n        return \"No Error\"\n    errorchain = error_handler(istrue)(errorchain)\n\n    [expose(format=\"json\", template=\"turbogears.tests.simple\")]\n    def returnjson(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n            tg_template=\"turbogears.tests.simple\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=False)]\n    def allowjson(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n             tg_template=\"turbogears.tests.simple\")\n\n    [expose(format=\"json\")]\n    def impliedjson(self):\n        return dict(title=\"Blah\")\n\n    [expose('json')]\n    def explicitjson(self):\n        return dict(title=\"Blub\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def jsonerror_handler(self):\n        return dict(someval=\"errors\")\n\n    [expose(allow_json=True)]\n    def jsonerror(self):\n        raise ValueError\n    jsonerror = exception_handler(jsonerror_handler)(jsonerror)\n\n    [expose(content_type=\"xml/atom\")]\n    def contenttype(self):\n        return \"Foobar\"\n\n    [expose()]\n    [validate(validators={\n        \"firstname\": validators.String(min=2, not_empty=True),\n        \"lastname\": validators.String()})]\n    def save(self, submit, firstname, lastname=\"Miller\"):\n        self.submit = submit\n        self.firstname = firstname\n        self.lastname = lastname\n        self.fullname = \"%s %s\" % (self.firstname, self.lastname)\n        return self.fullname\n    save = error_handler(validation_error_handler)(save)\n\n    class Registration(formencode.Schema):\n        allow_extra_fields = True\n        firstname = validators.String(min=2, not_empty=True)\n        lastname = validators.String()\n\n    [expose()]\n    [validate(validators=Registration())]\n    def save2(self, submit, firstname, lastname=\"Miller\"):\n        return self.save(submit, firstname, lastname)\n    save2 = error_handler(validation_error_handler)(save2)\n\n    [expose(template=\"turbogears.tests.simple\")]\n    def useother(self):\n        return dict(tg_template=\"turbogears.tests.othertemplate\")\n\n    [expose(template=\"cheetah:turbogears.tests.simplecheetah\")]\n    def usecheetah(self):\n        return dict(someval=\"chimps\")\n\n    rwt_called = 0\n    def rwt(self, func, *args, **kw):\n        self.rwt_called += 1\n        func(*args, **kw)\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_plain(self):\n        flash(\"plain\")\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_unicode(self):\n        flash(u\"\\xfcnicode\")\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_data_structure(self):\n        flash(dict(uni=u\"\\xfcnicode\", testing=[1, 2, 3]))\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_redirect(self):\n        flash(u\"redirect \\xfcnicode\")\n        redirect(\"/flash_redirected?tg_format=json\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_redirect_with_trouble_chars(self):\n        flash(u\"$foo, k\\xe4se;\\tbar!\")\n        redirect(\"/flash_redirected?tg_format=json\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_redirected(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    def exc_h_value(self, tg_exceptions=None):\n        \"\"\"Exception handler for the ValueError in raise_value_exc\"\"\"\n        return dict(handling_value=True, exception=str(tg_exceptions))\n\n    [expose()]\n    def raise_value_exc(self):\n        raise ValueError('Some Error in the controller')\n    raise_value_exc = exception_handler(exc_h_value,\n        \"isinstance(tg_exceptions, ValueError)\")(raise_value_exc)\n\n    def exc_h_key(self, tg_exceptions=None):\n        \"\"\"Exception handler for KeyErrors in  raise_all_exc\"\"\"\n        return dict(handling_key=True, exception=str(tg_exceptions))\n\n    def exc_h_index(self, tg_exceptions=None):\n        \"\"\"Exception handler for the ValueError in raise_value_exc\"\"\"\n        return dict(handling_index=True, exception=str(tg_exceptions))\n\n    [expose()]\n    def raise_index_exc(self):\n        raise IndexError('Some IndexError')\n    raise_index_exc = exception_handler(exc_h_index,\n        \"isinstance(tg_exceptions, IndexError)\")(raise_index_exc)\n\n    [expose()]\n    def raise_all_exc(self, num=2):\n        num = int(num)\n        if num < 2:\n            raise ValueError('Inferior to 2')\n        elif num == 2:\n            raise IndexError('Equals to 2')\n        elif num > 2:\n            raise KeyError('No such number 2 in the integer range')\n    raise_all_exc = exception_handler(exc_h_index,\n        \"isinstance(tg_exceptions, IndexError)\")(raise_all_exc)\n    raise_all_exc = exception_handler(exc_h_value,\n        \"isinstance(tg_exceptions, ValueError)\")(raise_all_exc)\n    raise_all_exc = exception_handler(exc_h_key,\n        \"isinstance(tg_exceptions, KeyError)\")(raise_all_exc)\n\n    [expose()]\n    def internal_redirect(self, **kwargs):\n        raise cherrypy.InternalRedirect('/internal_redirect_target')\n\n    [expose()]\n    def internal_redirect_target(self, **kwargs):\n        return \"redirected OK\"\n\n    [expose()]\n    def redirect_to_path_str(self, path):\n        raise redirect(path + '/index')\n\n    [expose()]\n    def redirect_to_path_list(self, path):\n        raise redirect([path, 'index'])\n\n    [expose()]\n    def redirect_to_path_tuple(self, path):\n        raise redirect((path, 'index'))\n\n\nclass TestRoot(unittest.TestCase):\n\n    def setUp(self):\n        cherrypy.root = None\n        cherrypy.tree.mount_points = {}\n        cherrypy.tree.mount(MyRoot(), \"/\")\n        cherrypy.tree.mount(SubApp(), \"/subthing\")\n\n    def tearDown(self):\n        cherrypy.root = None\n        cherrypy.tree.mount_points = {}\n\n    def test_js_files(self):\n        \"\"\"Can access the JavaScript files\"\"\"\n        testutil.create_request(\"/tg_js/MochiKit.js\")\n        assert cherrypy.response.headers[\"Content-Type\"] in [\n            \"application/javascript\", \"application/x-javascript\"]\n        assert cherrypy.response.status == \"200 OK\"\n\n    def test_json_output(self):\n        testutil.create_request(\"/test?tg_format=json\")\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values == dict(title=\"Foobar\", mybool=False,\n            someval=\"niggles\", tg_flash=None)\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n\n    def test_implied_json(self):\n        testutil.create_request(\"/impliedjson?tg_format=json\")\n        assert '\"title\": \"Blah\"' in cherrypy.response.body[0]\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n\n    def test_explicit_json(self):\n        testutil.create_request(\"/explicitjson\")\n        assert '\"title\": \"Blub\"' in cherrypy.response.body[0]\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n        testutil.create_request(\"/explicitjson?tg_format=json\")\n        assert '\"title\": \"Blub\"' in cherrypy.response.body[0]\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n\n    def test_allow_json(self):\n        testutil.create_request(\"/allowjson?tg_format=json\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/html\"\n\n    def test_allow_json_config(self):\n        \"\"\"JSON output can be enabled via config.\"\"\"\n        config.update({'tg.allow_json':True})\n        class JSONRoot(controllers.RootController):\n            [expose(template=\"turbogears.tests.simple\")]\n            def allowjsonconfig(self):\n                return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n                     tg_template=\"turbogears.tests.simple\")\n        cherrypy.root = JSONRoot()\n        testutil.create_request('/allowjsonconfig?tg_format=json')\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n        config.update({'tg.allow_json': False})\n\n    def test_allow_json_config_false(self):\n        \"\"\"Make sure JSON can still be restricted with a global config on.\"\"\"\n        config.update({'tg.allow_json': True})\n        class JSONRoot(controllers.RootController):\n            [expose(template=\"turbogears.tests.simple\")]\n            def allowjsonconfig(self):\n                return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n                     tg_template=\"turbogears.tests.simple\")\n        cherrypy.root = JSONRoot()\n        testutil.create_request('/allowjson?tg_format=json')\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/html\"\n        config.update({'tg.allow_json': False})\n\n    def test_json_error(self):\n        \"\"\"The error handler should return JSON if requested.\"\"\"\n        testutil.create_request(\"/jsonerror\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"\n        assert \"Paging all errors\" in cherrypy.response.body[0]\n        testutil.create_request(\"/jsonerror?tg_format=json\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n        assert '\"someval\": \"errors\"' in cherrypy.response.body[0]\n\n    def test_invalid_return(self):\n        testutil.create_request(\"/invalid\")\n        assert cherrypy.response.status.startswith(\"500\")\n\n    def test_strict_parameters(self):\n        config.update({\"tg.strict_parameters\": True})\n        testutil.create_request(\n            \"/save?submit=save&firstname=Foo&lastname=Bar&badparam=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n\n    def test_throw_out_random(self):\n        \"\"\"Can append random value to the URL to avoid caching problems.\"\"\"\n        testutil.create_request(\"/test?tg_random=1\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        config.update({\"tg.strict_parameters\": True})\n        testutil.create_request(\"/test?tg_random=1\")\n        assert cherrypy.response.status.startswith(\"200\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        testutil.create_request(\"/test?tg_not_random=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n\n    def test_ignore_parameters(self):\n        config.update({\"tg.strict_parameters\": True})\n        testutil.create_request(\"/test?ignore_me=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n        config.update({\"tg.ignore_parameters\": ['ignore_me', 'me_too']})\n        testutil.create_request(\"/test?ignore_me=1\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        testutil.create_request(\"/test?me_too=1\")\n        assert cherrypy.response.status.startswith(\"200\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        testutil.create_request(\"/test?me_not=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n\n    def test_retrieve_dict_directly(self):\n        d = testutil.call(cherrypy.root.returnjson)\n        assert d[\"title\"] == \"Foobar\"\n\n    def test_template_output(self):\n        testutil.create_request(\"/test\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n\n    def test_template_deprecated(self):\n        testutil.create_request(\"/test_deprecated\")\n        assert \"Paging all giggles\" in cherrypy.response.body[0]\n\n    def test_unicode(self):\n        testutil.create_request(\"/unicode\")\n        firstline = cherrypy.response.body[0].split('\\n')[0].decode('utf-8')\n        assert firstline == u'\\u00bfHabla espa\\u00f1ol?'\n\n    def test_default_format(self):\n        \"\"\"The default format can be set via expose\"\"\"\n        testutil.create_request(\"/returnjson\")\n        firstline = cherrypy.response.body[0]\n        assert '\"title\": \"Foobar\"' in firstline\n        testutil.create_request(\"/returnjson?tg_format=html\")\n        firstline = cherrypy.response.body[0]\n        assert '\"title\": \"Foobar\"' not in firstline\n\n    def test_content_type(self):\n        \"\"\"The content-type can be set via expose\"\"\"\n        testutil.create_request(\"/contenttype\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"xml/atom\"\n\n    def test_returned_template_name(self):\n        testutil.create_request(\"/returnedtemplate\")\n        data = cherrypy.response.body[0].lower()\n        assert \"<body>\" in data\n        assert 'groovy test template' in data\n\n    def test_returned_template_short(self):\n        testutil.create_request(\"/returnedtemplate_short\")\n        assert \"Paging all foo\" in cherrypy.response.body[0]\n\n    def test_expose_template_short(self):\n        testutil.create_request(\"/exposetemplate_short\")\n        assert \"Paging all foo\" in cherrypy.response.body[0]\n\n    def test_validation(self):\n        \"\"\"Data can be converted and validated\"\"\"\n        testutil.create_request(\"/istrue?value=true\")\n        assert cherrypy.root.value is True\n        testutil.create_request(\"/istrue?value=false\")\n        assert cherrypy.root.value is False\n        cherrypy.root = MyRoot()\n        testutil.create_request(\"/istrue?value=foo\")\n        assert not hasattr(cherrypy.root, \"value\")\n        assert cherrypy.root.functionname == \"istrue\"\n        testutil.create_request(\"/save?submit=send&firstname=John&lastname=Doe\")\n        assert cherrypy.root.fullname == \"John Doe\"\n        assert cherrypy.root.submit == \"send\"\n        testutil.create_request(\"/save?submit=send&firstname=Arthur\")\n        assert cherrypy.root.fullname == \"Arthur Miller\"\n        testutil.create_request(\"/save?submit=send&firstname=Arthur&lastname=\")\n        assert cherrypy.root.fullname == \"Arthur \"\n        testutil.create_request(\"/save?submit=send&firstname=D&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n        assert \"characters\" in cherrypy.root.errors[\"firstname\"].msg.lower()\n        testutil.create_request(\"/save?submit=send&firstname=&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n\n    def test_validation_chained(self):\n        \"\"\"Validation is not repeated if it already happened\"\"\"\n        cherrypy.root.value = None\n        testutil.create_request(\"/errorchain?value=true\")\n        assert cherrypy.root.value is None\n        testutil.create_request(\"/errorchain?value=notbool\")\n        assert cherrypy.root.value == 'notbool'\n\n    def test_validation_nested(self):\n        \"\"\"Validation is not repeated in nested method call\"\"\"\n        cherrypy.root.value = None\n        testutil.create_request(\"/nestedcall?value=true\")\n        assert cherrypy.root.value == 'True'\n        testutil.create_request(\"/nestedcall?value=false\")\n        assert cherrypy.root.value == 'False'\n\n    def test_validation_with_schema(self):\n        \"\"\"Data can be converted/validated with formencode.Schema instance\"\"\"\n        testutil.create_request(\"/save2?submit=send&firstname=Joe&lastname=Doe\")\n        assert cherrypy.root.fullname == \"Joe Doe\"\n        assert cherrypy.root.submit == \"send\"\n        testutil.create_request(\"/save2?submit=send&firstname=Arthur&lastname=\")\n        assert cherrypy.root.fullname == \"Arthur \"\n        testutil.create_request(\"/save2?submit=send&firstname=&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n        testutil.create_request(\"/save2?submit=send&firstname=D&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n\n    def test_other_template(self):\n        \"\"\"'tg_template' in a returned dict will use the template specified there\"\"\"\n        testutil.create_request(\"/useother\")\n        assert \"This is the other template\" in cherrypy.response.body[0]\n\n    def test_cheetah_template(self):\n        \"\"\"Cheetah templates can be used as well\"\"\"\n        testutil.create_request(\"/usecheetah\")\n        body = cherrypy.response.body[0]\n        assert \"This is the Cheetah test template.\" in body\n        assert \"Paging all chimps.\" in body\n\n    def test_run_with_trans(self):\n        \"\"\"run_with_transaction is called only on topmost exposed method\"\"\"\n        oldrwt = database.run_with_transaction\n        database.run_with_transaction = cherrypy.root.rwt\n        testutil.create_request(\"/nestedcall?value=true\")\n        database.run_with_transaction = oldrwt\n        assert cherrypy.root.value\n        assert cherrypy.root.rwt_called == 1\n\n    def test_positional(self):\n        \"\"\"Positional parameters should work\"\"\"\n        testutil.create_request(\"/pos/foo\")\n        assert cherrypy.root.posvalue == \"foo\"\n\n    def test_flash_plain(self):\n        \"\"\"flash with strings should work\"\"\"\n        testutil.create_request(\"/flash_plain?tg_format=json\")\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == \"plain\"\n        assert not cherrypy.response.simple_cookie.has_key(\"tg_flash\")\n\n    def test_flash_unicode(self):\n        \"\"\"flash with unicode objects should work\"\"\"\n        testutil.create_request(\"/flash_unicode?tg_format=json\")\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == u\"\\xfcnicode\"\n        assert not cherrypy.response.simple_cookie.has_key(\"tg_flash\")\n\n    def test_flash_on_redirect(self):\n        \"\"\"flash must survive a redirect\"\"\"\n        testutil.create_request(\"/flash_redirect?tg_format=json\")\n        assert cherrypy.response.status.startswith(\"302\")\n        testutil.create_request(cherrypy.response.headers[\"Location\"],\n            headers=dict(Cookie=cherrypy.response.simple_cookie.output(\n                header=\"\").strip()))\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == u\"redirect \\xfcnicode\"\n\n    def test_flash_redirect_with_trouble_chars(self):\n        \"\"\"flash redirect with chars that can cause troubles in cookies\"\"\"\n        testutil.create_request(\"/flash_redirect_with_trouble_chars?tg_format=json\")\n        assert cherrypy.response.status.startswith(\"302\")\n        value = cherrypy.response.simple_cookie[\"tg_flash\"].value\n        assert '$' not in value\n        assert ',' not in value and ';' not in value\n        assert ' ' not in value and '\\t' not in value\n        assert 'foo' in value and 'bar' in value\n        assert u'k\\xe4se'.encode('utf-8') in value\n        assert '!' in value\n        testutil.create_request(cherrypy.response.headers[\"Location\"],\n            headers=dict(Cookie=cherrypy.response.simple_cookie.output(\n                header=\"\").strip()))\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == u\"$foo, k\\xe4se;\\tbar!\"\n\n    def test_double_flash(self):\n        \"\"\"latest set flash should have precedence\"\"\"\n        # Here we are calling method that sets a flash message. However flash\n        # cookie is still there. Turbogears should discard old flash message\n        # from cookie and use new one, set by flash_plain().\n        testutil.create_request(\"/flash_plain?tg_format=json\",\n            headers=dict(Cookie='tg_flash=\"old flash\"; Path=/;'))\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == \"plain\"\n        assert cherrypy.response.simple_cookie.has_key(\"tg_flash\"), \\\n                \"Cookie clearing request should be present\"\n        flashcookie = cherrypy.response.simple_cookie['tg_flash']\n        assert flashcookie['expires'] == 0\n\n    def test_set_kid_outputformat_in_config(self):\n        \"\"\"the outputformat for kid can be set in the config\"\"\"\n        config.update({'kid.outputformat': 'xhtml'})\n        testutil.create_request('/test')\n        response = cherrypy.response.body[0]\n        assert '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML ' in response\n        config.update({'kid.outputformat': 'html'})\n        testutil.create_request('/test')\n        response = cherrypy.response.body[0]\n        assert  '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML ' in response\n        assert '    This is the groovy test ' in response\n        config.update({'kid.outputformat': 'html compact'})\n        testutil.create_request('/test')\n        response = cherrypy.response.body[0]\n        assert  '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML ' in response\n        assert 'This is the groovy test ' in response\n        assert '    ' not in response\n\n    def test_fileserving(self):\n        testutil.create_request(\"/servefile\")\n        assert cherrypy.root.servedit\n        assert not cherrypy.root.serve_exceptions\n\n    def test_basestring(self):\n        testutil.create_request(\"/basestring\")\n        assert cherrypy.response.body[0] == 'hello world'\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/plain\"\n\n    def test_list(self):\n        testutil.create_request(\"/list\")\n        assert cherrypy.response.body[0] == 'helloworld'\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/plain\"\n\n    def test_generator(self):\n        testutil.create_request(\"/generator\")\n        assert cherrypy.response.body[0] == 'helloworld'\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/plain\"\n\n    def test_internal_redirect(self):\n        \"\"\"regression test for #1022, #1407 and #1598\"\"\"\n        testutil.create_request(\"/internal_redirect\")\n        firstline = cherrypy.response.body[0]\n        assert \"redirected OK\" in firstline\n\n    def test_internal_redirect_nested_variables(self):\n        \"\"\"regression test for #1022, #1407 and #1598\"\"\"\n        testutil.create_request(\n            \"/internal_redirect?a=1&a-1.b=2&a-2.c=3&a-2.c-1=4\")\n        firstline = cherrypy.response.body[0]\n        assert \"redirected OK\" in firstline\n\n    def test_exc_value(self):\n        \"\"\"Exception is handled gracefully by the right exception handler.\"\"\"\n        testutil.create_request(\"/raise_value_exc\")\n        assert 'handling_value' in cherrypy.response.body[0]\n\n    def test_exc_index(self):\n        \"\"\"Exception is handled gracefully by the right exception handler.\"\"\"\n        testutil.create_request(\"/raise_index_exc\")\n        assert 'handling_index' in cherrypy.response.body[0]\n\n    def test_exc_all(self):\n        \"\"\"Test a controller that is protected by multiple exception handlers.\n\n        It should raise either of the 3 exceptions but all should be handled\n        by their respective handlers without problem...\n\n        \"\"\"\n        testutil.create_request(\"/raise_all_exc?num=1\")\n        assert 'handling_value' in cherrypy.response.body[0]\n        testutil.create_request(\"/raise_all_exc?num=2\")\n        assert 'handling_index' in cherrypy.response.body[0]\n        testutil.create_request(\"/raise_all_exc?num=3\")\n        assert 'handling_key' in cherrypy.response.body[0]\n\n\nclass TestURLs(unittest.TestCase):\n\n    def setUp(self):\n        cherrypy.tree.mount_points = {}\n        cherrypy.root = MyRoot()\n        cherrypy.root.subthing = SubApp()\n        cherrypy.root.subthing.subsubthing = SubApp()\n\n    def tearDown(self):\n        config.update({\"server.webpath\": \"\"})\n        startup.startTurboGears()\n\n    def test_basic_urls(self):\n        testutil.create_request(\"/\")\n        assert \"/foo\" == url(\"/foo\")\n        assert \"foo/bar\" == url([\"foo\", \"bar\"])\n        assert url(\"/foo\", bar=1, baz=2) in \\\n            [\"/foo?bar=1&baz=2\", \"/foo?baz=2&bar=1\"]\n        assert url(\"/foo\", dict(bar=1, baz=2)) in \\\n            [\"/foo?bar=1&baz=2\", \"/foo?baz=2&bar=1\"]\n        assert url(\"/foo\", dict(bar=1, baz=None)) == \"/foo?bar=1\"\n\n    def test_url_without_request_available(self):\n        cherrypy.serving.request = None\n        assert url(\"/foo\") == \"/foo\"\n\n    def test_approots(self):\n        testutil.create_request(\"/subthing/\")\n        assert cherrypy.response.status.startswith(\"200\")\n        assert url(\"foo\") == \"foo\"\n        assert url(\"/foo\") == \"/subthing/foo\"\n        testutil.create_request(\"/nosubthing/\")\n        assert cherrypy.response.status.startswith(\"404\")\n        assert url(\"foo\") == \"foo\"\n        assert url(\"/foo\") == \"/foo\"\n\n    def test_lower_approots(self):\n        testutil.create_request(\"/subthing/subsubthing/\")\n        assert url(\"/foo\") == \"/subthing/subsubthing/foo\"\n\n    def test_approots_with_path(self):\n        config.update({\"server.webpath\": \"/coolsite/root\"})\n        startup.startTurboGears()\n        testutil.create_request(\"/coolsite/root/subthing/\")\n        assert url(\"/foo\") == \"/coolsite/root/subthing/foo\"\n\n    def test_redirect(self):\n        config.update({\"server.webpath\": \"/coolsite/root\"})\n        startup.startTurboGears()\n        testutil.create_request(\"/coolsite/root/subthing/\")\n        try:\n            redirect(\"/foo\")\n            assert False, \"redirect exception should have been raised\"\n        except cherrypy.HTTPRedirect, e:\n            assert \"http://localhost/coolsite/root/subthing/foo\" in e.urls\n        try:\n            raise redirect(\"/foo\")\n            assert False, \"redirect exception should have been raised\"\n        except cherrypy.HTTPRedirect, e:\n            assert \"http://localhost/coolsite/root/subthing/foo\" in e.urls\n        try:\n            redirect(\"foo\")\n            assert False, \"redirect exception should have been raised\"\n        except cherrypy.HTTPRedirect, e:\n            assert \"http://localhost/coolsite/root/subthing/foo\" in e.urls\n\n    def test_redirect_to_path(self):\n        for path_type in ('str', 'list', 'tuple'):\n            for path in ('subthing', '/subthing'):\n                url = \"/redirect_to_path_%s?path=%s\" % (path_type, path)\n                testutil.create_request(url)\n                assert cherrypy.response.status.startswith(\"302\"), url\n                assert (cherrypy.response.headers['Location']\n                    == 'http://localhost/subthing/index'), url\n\n    def test_multi_values(self):\n        testutil.create_request(\"/\")\n        assert url(\"/foo\", bar=[1, 2]) in \\\n            [\"/foo?bar=1&bar=2\", \"/foo?bar=2&bar=1\"]\n        assert url(\"/foo\", bar=(\"asdf\", \"qwer\")) in \\\n            [\"/foo?bar=qwer&bar=asdf\", \"/foo?bar=asdf&bar=qwer\"]\n\n    def test_unicode(self):\n        \"\"\"url() can handle unicode parameters\"\"\"\n        testutil.create_request(\"/\")\n        assert url('/', x=u'\\N{LATIN SMALL LETTER A WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER E WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER I WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER O WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER U WITH GRAVE}') \\\n            == '/?x=%C3%A0%C3%A8%C3%AC%C3%B2%C3%B9'\n\n    def test_list(self):\n        \"\"\"url() can handle list parameters, with unicode too\"\"\"\n        testutil.create_request(\"/\")\n        assert url('/', foo=['bar', u'\\N{LATIN SMALL LETTER A WITH GRAVE}']\n            ) == '/?foo=bar&foo=%C3%A0'\n\n    def test_existing_query_string(self):\n        \"\"\"url() can handle URL with existing query string\"\"\"\n        testutil.create_request(\"/\")\n        test_url = url('/foo', {'first': 1})\n        assert url(test_url, {'second': 2}) == '/foo?first=1&second=2'\n\n    def test_url_kwargs_overwrite_tgparams(self):\n        \"\"\"Keys in tgparams in call to url() overwrite kw args\"\"\"\n        params = {'spamm': 'eggs'}\n        assert 'spamm=ham' in url('/foo', params, spamm='ham')\n\n    def test_url_doesnt_change_tgparams(self):\n        \"\"\"url() does not change the dict passed as second arg\"\"\"\n        params = {'spamm': 'eggs'}\n        assert 'foo' in url('/foo', params, spamm='ham')\n        assert params['spamm'] == 'eggs'\n\n    def test_index_trailing_slash(self):\n        \"\"\"If there is no trailing slash on an index method call, redirect\"\"\"\n        cherrypy.root = SubApp()\n        cherrypy.root.foo = SubApp()\n        testutil.create_request(\"/foo\")\n        assert cherrypy.response.status.startswith(\"302\")\n\n    def test_can_use_internally_defined_arguments(self):\n        \"\"\"Can use argument names that are internally used by TG in controllers\"\"\"\n\n        class App(controllers.RootController):\n\n            [expose()]\n            def index(self, **kw):\n                return \"\\n\".join([\"%s:%s\" % i for i in kw.iteritems()])\n\n        cherrypy.root = App()\n        testutil.create_request(\"/?format=foo&template=bar&fragment=boo\")\n        output = cherrypy.response.body[0]\n        assert \"format:foo\" in output\n        assert \"template:bar\" in output\n        assert \"fragment:boo\" in output\n"], "fixing_code": ["\"\"\"Classes and methods for TurboGears controllers.\"\"\"\n\nimport logging\nimport re\nimport urllib\nimport urlparse\nimport types\nfrom itertools import izip\nfrom dispatch import generic, strategy, functions\nfrom inspect import isclass\nimport cherrypy\nfrom cherrypy import request, response\nimport turbogears.util as tg_util\nfrom turbogears import view, database, errorhandling, config\nfrom turbogears.decorator import weak_signature_decorator\nfrom turbogears.validators import Invalid\nfrom turbogears.errorhandling import error_handler, exception_handler\nfrom memory_profiler_setup import profile_expose_method\n\nlog = logging.getLogger(\"turbogears.controllers\")\n\nif config.get(\"session_filter.on\", None):\n    if config.get(\"session_filter.storage_type\", None) == \"PostgreSQL\":\n        import psycopg2\n        config.update(\n                {'session_filter.get_db': psycopg2.connect(\n                    psycopg2.get('sessions.postgres.dsn'))\n                    })\n    # support for mysql/sqlite/etc here\n\n\ndef _process_output(output, template, format, content_type,\n        mapping, fragment=False):\n    \"\"\"Produce final output form from data returned from a controller method.\n\n    See the expose() arguments for more info since they are the same.\n\n    \"\"\"\n    if isinstance(output, dict):\n        from turbogears.widgets import js_location\n\n        css = tg_util.setlike()\n        js = dict(izip(js_location, iter(tg_util.setlike, None)))\n        include_widgets = {}\n        include_widgets_lst = config.get(\"tg.include_widgets\", [])\n\n        if config.get(\"tg.mochikit_all\", False):\n            include_widgets_lst.insert(0, 'turbogears.mochikit')\n\n        for i in include_widgets_lst:\n            widget = tg_util.load_class(i)\n            if isclass(widget):\n                widget = widget()\n            include_widgets[\"tg_%s\" % i.split(\".\")[-1]] = widget\n            for script in widget.retrieve_javascript():\n                if hasattr(script, \"location\"):\n                    js[script.location].add(script)\n                else:\n                    js[js_location.head].add(script)\n            css.add_all(widget.retrieve_css())\n\n        for value in output.itervalues():\n            if hasattr(value, \"retrieve_css\"):\n                retrieve = getattr(value, \"retrieve_css\")\n                if callable(retrieve):\n                    css.add_all(value.retrieve_css())\n            if hasattr(value, \"retrieve_javascript\"):\n                retrieve = getattr(value, \"retrieve_javascript\")\n                if callable(retrieve):\n                    for script in value.retrieve_javascript():\n                        if hasattr(script, \"location\"):\n                            js[script.location].add(script)\n                        else:\n                            js[js_location.head].add(script)\n        output.update(include_widgets)\n        output[\"tg_css\"] = css\n        for location in iter(js_location):\n            output[\"tg_js_%s\" % str(location)] = js[location]\n\n        tg_flash = _get_flash()\n        if tg_flash:\n            output[\"tg_flash\"] = tg_flash\n\n        headers = {'Content-Type': content_type}\n        output = view.render(output, template=template, format=format,\n                    mapping=mapping, headers=headers,\n                    fragment=fragment)\n        content_type = headers['Content-Type']\n\n    if content_type:\n        response.headers[\"Content-Type\"] = content_type\n    else:\n        content_type = response.headers.get(\"Content-Type\", 'text/plain')\n\n    if content_type.startswith(\"text/\"):\n        if isinstance(output, unicode):\n            output = output.encode(tg_util.get_template_encoding_default())\n\n    return output\n\n\nclass BadFormatError(Exception):\n    \"\"\"Output-format exception.\"\"\"\n\n\ndef validate(form=None, validators=None,\n             failsafe_schema=errorhandling.FailsafeSchema.none,\n             failsafe_values=None, state_factory=None):\n    \"\"\"Validate input.\n\n    @param form: a form instance that must be passed throught the validation\n    process... you must give a the same form instance as the one that will\n    be used to post data on the controller you are putting the validate\n    decorator on.\n    @type form: a form instance\n\n    @param validators: individual validators to use for parameters.\n    If you use a schema for validation then the schema instance must\n    be the sole argument.\n    If you use simple validators, then you must pass a dictionary with\n    each value name to validate as a key of the dictionary and the validator\n    instance (eg: tg.validators.Int() for integer) as the value.\n    @type validators: dictionary or schema instance\n\n    @param failsafe_schema: a schema for handling failsafe values.\n    The default is 'none', but you can also use 'values', 'map_errors',\n    or 'defaults' to map erroneous inputs to values, corresponding exceptions\n    or method defaults.\n    @type failsafe_schema: errorhandling.FailsafeSchema\n\n    @param failsafe_values: replacements for erroneous inputs. You can either\n    define replacements for every parameter, or a single replacement value\n    for all parameters. This is only used when failsafe_schema is 'values'.\n    @type failsafe_values: a dictionary or a single value\n\n    @param state_factory: If this is None, the initial state for validation\n    is set to None, otherwise this must be a callable that returns the initial\n    state to be used for validation.\n    @type state_factory: callable or None\n\n    \"\"\"\n    def entangle(func):\n        if callable(form) and not hasattr(form, \"validate\"):\n            init_form = lambda self: form(self)\n        else:\n            init_form = lambda self: form\n\n        def validate(func, *args, **kw):\n            # do not validate a second time if already validated\n            if hasattr(request, 'validation_state'):\n                return func(*args, **kw)\n\n            form = init_form(args and args[0] or kw[\"self\"])\n            args, kw = tg_util.to_kw(func, args, kw)\n\n            errors = {}\n            if state_factory is not None:\n                state = state_factory()\n            else:\n                state = None\n\n            if form:\n                value = kw.copy()\n                try:\n                    kw.update(form.validate(value, state))\n                except Invalid, e:\n                    errors = e.unpack_errors()\n                    request.validation_exception = e\n                request.validated_form = form\n\n            if validators:\n                if isinstance(validators, dict):\n                    for field, validator in validators.iteritems():\n                        try:\n                            kw[field] = validator.to_python(\n                                kw.get(field, None), state)\n                        except Invalid, error:\n                            errors[field] = error\n                else:\n                    try:\n                        value = kw.copy()\n                        kw.update(validators.to_python(value, state))\n                    except Invalid, e:\n                        errors = e.unpack_errors()\n                        request.validation_exception = e\n            request.validation_errors = errors\n            request.input_values = kw.copy()\n            request.validation_state = state\n\n            if errors:\n                kw = errorhandling.dispatch_failsafe(failsafe_schema,\n                                            failsafe_values, errors, func, kw)\n            args, kw = tg_util.from_kw(func, args, kw)\n            return errorhandling.run_with_errors(errors, func, *args, **kw)\n\n        return validate\n    return weak_signature_decorator(entangle)\n\n\nclass CustomDispatch(functions.GenericFunction):\n\n    def combine(self, cases):\n        strict = [strategy.ordered_signatures, strategy.safe_methods]\n        cases = strategy.separate_qualifiers(\n            cases,\n            primary = strict,\n        )\n        primary = strategy.method_chain(cases.get('primary', []))\n        if type(primary) != types.FunctionType:\n            for i in primary:\n                for y in i:\n                    return y[1]\n        return primary\n\n\ndef _add_rule(_expose, found_default, as_format, accept_format, template,\n              rulefunc):\n    if as_format == \"default\":\n        if found_default:\n            colon = template.find(\":\")\n            if colon == -1:\n                as_format = template\n            else:\n                as_format = template[:colon]\n        else:\n            found_default = True\n    ruleparts = ['kw.get(\"tg_format\", \"default\") == \"%s\"' % as_format]\n    if accept_format:\n        ruleparts.append('(accept == \"%s\" and kw.get(\"tg_format\"'\n            ', \"default\") == \"default\")' % accept_format)\n    rule = \" or \".join(ruleparts)\n    log.debug(\"Generated rule %s\", rule)\n    _expose.when(rule)(rulefunc)\n\n    return found_default\n\n\ndef _build_rules(func):\n    [generic(CustomDispatch)]\n    def _expose(func, accept, allow_json, *args, **kw):\n        pass\n\n    if func._allow_json:\n        log.debug(\"Adding allow_json rule: \"\n            'allow_json and (kw.get(\"tg_format\", None) == \"json\"'\n            ' or accept in (\"application/json\", \"text/javascript\"))')\n        _expose.when('allow_json and (kw.get(\"tg_format\", None) == \"json\"'\n            ' or accept in (\"application/json\", \"text/javascript\"))')(\n            lambda _func, accept, allow_json, *args, **kw:\n                _execute_func(_func, \"json\", \"json\", \"application/json\",\n                    None, False, args, kw))\n\n    found_default = False\n    for ruleinfo in func._ruleinfo:\n        found_default = _add_rule(_expose, found_default, **ruleinfo)\n\n    func._expose = _expose\n\n\ndef expose(template=None, validators=None, allow_json=None, html=None,\n           format=None, content_type=None, inputform=None, fragment=False,\n           as_format=\"default\", mapping=None, accept_format=None,\n           exclude_from_memory_profiling=False):\n    \"\"\"Exposes a method to the web.\n\n    By putting the expose decorator on a method, you tell TurboGears that\n    the method should be accessible via URL traversal. Additionally, expose\n    handles the output processing (turning a dictionary into finished\n    output) and is also responsible for ensuring that the request is\n    wrapped in a database transaction.\n\n    You can apply multiple expose decorators to a method, if\n    you'd like to support multiple output formats. The decorator that's\n    listed first in your code without as_format or accept_format is\n    the default that is chosen when no format is specifically asked for.\n    Any other expose calls that are missing as_format and accept_format\n    will have as_format implicitly set to the whatever comes before\n    the \":\" in the template name (or the whole template name if there\n    is no \":\". For example, <code>expose(\"json\")</code>, if it's not\n    the default expose, will have as_format set to \"json\".\n\n    When as_format is set, passing the same value in the tg_format\n    parameter in a request will choose the options for that expose\n    decorator. Similarly, accept_format will watch for matching\n    Accept headers. You can also use both. expose(\"json\", as_format=\"json\",\n    accept_format=\"application/json\") will choose JSON output for either\n    case: tg_format=json as a parameter or Accept: application/json as a\n    request header.\n\n    Passing allow_json=True to an expose decorator\n    is equivalent to adding the decorator just mentioned.\n\n    Each expose decorator has its own set of options, and each one\n    can choose a different template or even template engine (you can\n    use Kid for HTML output and Cheetah for plain text, for example).\n    See the other expose parameters below to learn about the options\n    you can pass to the template engine.\n\n    Take a look at the\n    <a href=\"tests/test_expose-source.html\">test_expose.py</a> suite\n    for more examples.\n\n    @param template \"templateengine:dotted.reference\" reference along the\n            Python path for the template and the template engine. For\n            example, \"kid:foo.bar\" will have Kid render the bar template in\n            the foo package.\n    @keyparam format format for the template engine to output (if the\n            template engine can render different formats. Kid, for example,\n            can render \"html\", \"xml\" or \"xhtml\")\n    @keyparam content_type sets the content-type http header\n    @keyparam allow_json allow the function to be exposed as json\n    @keyparam fragment for template engines (like Kid) that generate\n            DOCTYPE declarations and the like, this is a signal to\n            just generate the immediate template fragment. Use this\n            if you're building up a page from multiple templates or\n            going to put something onto a page with .innerHTML.\n    @keyparam mapping mapping with options that are sent to the template\n            engine\n    @keyparam as_format designates which value of tg_format will choose\n            this expose.\n    @keyparam accept_format which value of an Accept: header will\n            choose this expose.\n    @keyparam html deprecated in favor of template\n    @keyparam validators deprecated. Maps argument names to validator\n            applied to that arg\n    @keyparam inputform deprecated. A form object that generates the\n            input to this method\n    @keyparam exclude_from_memory_profiling allows to exclude individual end points from memory profiling. Can be\n            used for performance or in case profiling generates errors\n    \"\"\"\n    if html:\n        template = html\n    if not template:\n        template = format\n    if format == \"json\" or (format is None and template is None):\n        template = \"json\"\n        allow_json = True\n    if content_type is None:\n        content_type = config.get(\"tg.content_type\", None)\n\n    if config.get(\"tg.session.automatic_lock\", None):\n        cherrypy.session.acquire_lock()\n\n    def entangle(func):\n        log.debug(\"Exposing %s\", func)\n        log.debug(\"template: %s, format: %s, allow_json: %s, \"\n            \"content-type: %s\", template, format, allow_json, content_type)\n        if not getattr(func, \"exposed\", False):\n            def expose(func, *args, **kw):\n                accept = request.headers.get('Accept', \"\").lower()\n                accept = tg_util.simplify_http_accept_header(accept)\n                if not hasattr(func, \"_expose\"):\n                    _build_rules(func)\n                if hasattr(request, \"in_transaction\"):\n                    output = func._expose(func, accept, func._allow_json,\n                                *args, **kw)\n                else:\n                    request.in_transaction = True\n                    output = profile_expose_method(_run_with_transaction, accept, args, func, kw,\n                                                   exclude_from_memory_profiling)\n                return output\n            func.exposed = True\n            func._ruleinfo = []\n            allow_json_from_config = config.get(\"tg.allow_json\", False)\n            func._allow_json = allow_json_from_config or template == 'json'\n        else:\n            expose = lambda func, *args, **kw: func(*args, **kw)\n\n        func._ruleinfo.insert(0, dict(as_format=as_format,\n            accept_format=accept_format, template=template,\n            rulefunc = lambda _func, accept, allow_json, *args, **kw:\n                _execute_func(_func, template, format, content_type,\n                    mapping, fragment, args, kw)))\n\n        if allow_json:\n            func._allow_json = True\n\n        if inputform or validators:\n            import warnings\n            warnings.warn(\n                \"Use a separate decorator validate() rather than passing \"\n                \"arguments validators and/or inputform to decorator \"\n                \"expose().\",\n                DeprecationWarning, 2)\n            func = validate(form=inputform, validators=validators)(func)\n\n        return expose\n    return weak_signature_decorator(entangle)\n\n\ndef _run_with_transaction(accept, args, func, kw):\n    return database.run_with_transaction(\n             func._expose, func, accept, func._allow_json,\n             *args, **kw)\n\n\ndef _execute_func(func, template, format, content_type, mapping, fragment, args, kw):\n    \"\"\"Call controller method and process it's output.\"\"\"\n    if config.get(\"tg.strict_parameters\", False):\n        tg_util.remove_keys(kw, [\"tg_random\", \"tg_format\"]\n            + config.get(\"tg.ignore_parameters\", []))\n    else:\n        # get special parameters used by upstream decorators like paginate\n        try:\n            tg_kw = dict([(k, v) for k, v in kw.items() if k in func._tg_args])\n        except AttributeError:\n            tg_kw = {}\n        # remove excessive parameters\n        args, kw = tg_util.adapt_call(func, args, kw)\n        # add special parameters again\n        kw.update(tg_kw)\n    if config.get('server.environment', 'development') == 'development':\n        # Only output this in development mode: If it's a field storage object,\n        # this means big memory usage, and we don't want that in production\n        log.debug(\"Calling %s with *(%s), **(%s)\", func, args, kw)\n    output = errorhandling.try_call(func, *args, **kw)\n    assert isinstance(output, (basestring, dict, list, types.GeneratorType)), \\\n           \"Method %s.%s() returned unexpected output. Output should \" \\\n           \"be of type basestring, dict, list or generator.\" % (\n            args[0].__class__.__name__, func.__name__)\n    if isinstance(output, dict):\n        template = output.pop(\"tg_template\", template)\n        format = output.pop(\"tg_format\", format)\n    if template and template.startswith(\".\"):\n        template = func.__module__[:func.__module__.rfind('.')]+template\n    return _process_output(output, template, format, content_type, mapping, fragment)\n\n\ndef flash(message):\n    \"\"\"Set a message to be displayed in the browser on next page display.\"\"\"\n    message = tg_util.quote_cookie(tg_util.to_utf8(message))\n    response.simple_cookie['tg_flash'] = message\n    response.simple_cookie['tg_flash']['path'] = '/'\n\n\ndef _get_flash():\n    \"\"\"Retrieve the flash message (if one is set), clearing the message.\"\"\"\n    request_cookie = request.simple_cookie\n    response_cookie = response.simple_cookie\n\n    def clearcookie():\n        response_cookie[\"tg_flash\"] = \"\"\n        response_cookie[\"tg_flash\"]['expires'] = 0\n        response_cookie['tg_flash']['path'] = '/'\n\n    if response_cookie.has_key(\"tg_flash\"):\n        message = response_cookie[\"tg_flash\"].value\n        response_cookie.pop(\"tg_flash\")\n        if request_cookie.has_key(\"tg_flash\"):\n            # New flash overrided old one sitting in cookie. Clear that old cookie.\n            clearcookie()\n    elif request_cookie.has_key(\"tg_flash\"):\n        message = request_cookie[\"tg_flash\"].value\n        if not response_cookie.has_key(\"tg_flash\"):\n            clearcookie()\n    else:\n        message = None\n    if message:\n        message = unicode(tg_util.unquote_cookie(message), 'utf-8')\n    return message\n\n\nclass Controller(object):\n    \"\"\"Base class for a web application's controller.\n\n    Currently, this provides positional parameters functionality\n    via a standard default method.\n\n    \"\"\"\n\n\nclass RootController(Controller):\n    \"\"\"Base class for the root of a web application.\n\n    Your web application should have one of these. The root of\n    your application is used to compute URLs used by your app.\n\n    \"\"\"\n    is_app_root = True\n\n    msglog = logging.getLogger('cherrypy.msg')\n    msglogfunc = {0: msglog.info, 1: msglog.warning, 2: msglog.error}\n    def _cp_log_message(self, msg, context = 'nocontext', severity = 0):\n        log = self.msglogfunc[severity]\n        text = ''.join((context, ': ', msg))\n        log(text)\n\n    accesslog = logging.getLogger(\"turbogears.access\")\n    def _cp_log_access(self):\n        tmpl = '%(h)s %(l)s %(u)s \"%(r)s\" %(s)s %(b)s \"%(f)s\" \"%(a)s\"'\n        try:\n            username = request.user_name\n            if username:\n                if isinstance(username, unicode):\n                    # might get concatenated to non-ascii byte strings\n                    username = username.encode('utf-8')\n            else:\n                username = \"-\"\n        except AttributeError:\n            username = \"-\"\n        s = tmpl % {'h': request.remote_host,\n                   'l': '-',\n                   'u': username,\n                   'r': request.requestLine,\n                   's': response.status.split(\" \", 1)[0],\n                   'b': response.headers.get('Content-Length',\n                            '') or \"-\",\n                   'f': request.headers.get('referer', ''),\n                   'a': request.headers.get('user-agent', ''),\n        }\n        self.accesslog.info(s)\n\nRoot = RootController\n\n\ndef url(tgpath, tgparams=None, **kw):\n    \"\"\"Computes URLs.\n\n    tgpath can be a list or a string. If the path is absolute (starts\n    with a \"/\"), the server.webpath, SCRIPT_NAME and the approot of the\n    application are prepended to the path. In order for the approot to\n    be detected properly, the root object should extend\n    controllers.RootController.\n\n    Query parameters for the URL can be passed in as a dictionary in\n    the second argument *or* as keyword parameters.\n\n    Values which are a list or a tuple are used to create multiple\n    key-value pairs.\n\n    \"\"\"\n    if not isinstance(tgpath, basestring):\n        tgpath = '/'.join(list(tgpath))\n    if tgpath.startswith('/'):\n        webpath = (config.get('server.webpath') or '').rstrip('/')\n        if tg_util.request_available():\n            check_app_root()\n            tgpath = request.app_root + tgpath\n            try:\n                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')\n            except (AttributeError, KeyError):\n                pass\n        tgpath = webpath + tgpath\n    if tgparams is None:\n        tgparams = kw\n    else:\n        try:\n            tgparams = tgparams.copy()\n            tgparams.update(kw)\n        except AttributeError:\n            raise TypeError('url() expects a dictionary for query parameters')\n    args = []\n    for key, value in tgparams.iteritems():\n        if value is None:\n            continue\n        if isinstance(value, (list, tuple)):\n            pairs = [(key, v) for v in value]\n        else:\n            pairs = [(key, value)]\n        for k, v in pairs:\n            if v is None:\n                continue\n            if isinstance(v, unicode):\n                v = v.encode('utf8')\n            args.append((k, str(v)))\n    if args:\n        query_string = urllib.urlencode(args, True)\n        if '?' in tgpath:\n            tgpath += '&' + query_string\n        else:\n            tgpath += '?' + query_string\n    return tgpath\n\n\ndef check_app_root():\n    \"\"\"Sets request.app_root if needed.\"\"\"\n    if hasattr(request, 'app_root'):\n        return\n    found_root = False\n    trail = request.object_trail\n    top = len(trail) - 1\n    # compute the app_root by stepping back through the object\n    # trail and collecting up the path elements after the first\n    # root we find\n    # we can eliminate this if we find a way to use\n    # CherryPy's mounting mechanism whenever a new root\n    # is hit.\n    rootlist = []\n    for i in xrange(len(trail) - 1, -1, -1):\n        path, obj = trail[i]\n        if not found_root and isinstance(obj, RootController):\n            if i == top:\n                break\n            found_root = True\n        if found_root and i > 0:\n            rootlist.insert(0, path)\n    app_root = '/'.join(rootlist)\n    if not app_root.startswith('/'):\n        app_root = '/' + app_root\n    if app_root.endswith('/'):\n        app_root = app_root[:-1]\n    request.app_root = app_root\n\n\ndef get_server_name():\n    \"\"\"Return name of the server this application runs on.\n\n    Respects 'Host' and 'X-Forwarded-Host' header.\n\n    See the docstring of the 'absolute_url' function for more information.\n\n    \"\"\"\n    get = config.get\n    h = request.headers\n    host = get('tg.url_domain') or h.get('X-Forwarded-Host', h.get('Host'))\n    if not host:\n        host = '%s:%s' % (get('server.socket_host', 'localhost'),\n            get('server.socket_port', 8080))\n    return host\n\n\ndef absolute_url(tgpath='/', params=None, **kw):\n    \"\"\"Return absolute URL (including schema and host to this server).\n\n    Tries to account for 'Host' header and reverse proxying\n    ('X-Forwarded-Host').\n\n    The host name is determined this way:\n\n    * If the config setting 'tg.url_domain' is set and non-null, use this value.\n    * Else, if the 'base_url_filter.use_x_forwarded_host' config setting is\n      True, use the value from the 'Host' or 'X-Forwarded-Host' request header.\n    * Else, if config setting 'base_url_filter.on' is True and\n      'base_url_filter.base_url' is non-null, use its value for the host AND\n      scheme part of the URL.\n    * As a last fallback, use the value of 'server.socket_host' and\n      'server.socket_port' config settings (defaults to 'localhost:8080').\n\n    The URL scheme ('http' or 'http') used is determined in the following way:\n\n    * If 'base_url_filter.base_url' is used, use the scheme from this URL.\n    * If there is a 'X-Use-SSL' request header, use 'https'.\n    * Else, if the config setting 'tg.url_scheme' is set, use its value.\n    * Else, use the value of 'cherrypy.request.scheme'.\n\n    \"\"\"\n    get = config.get\n    use_xfh = get('base_url_filter.use_x_forwarded_host', False)\n    if request.headers.get('X-Use-SSL'):\n        scheme = 'https'\n    else:\n        scheme = get('tg.url_scheme')\n    if not scheme:\n        scheme = request.scheme\n    base_url = '%s://%s' % (scheme, get_server_name())\n    if get('base_url_filter.on', False) and not use_xfh:\n        base_url = get('base_url_filter.base_url').rstrip('/')\n    return '%s%s' % (base_url, url(tgpath, params, **kw))\n\n\nclass InvalidRedirectException(Exception):\n    \"\"\"\n    An invalid redirect url was provided.  Redirects cannot\n    include a carriage return (\\r) or new line (\\n) character.\n    \"\"\"\n\n\ndef redirect(redirect_path, redirect_params=None, **kw):\n    \"\"\"Redirect (via cherrypy.HTTPRedirect).\n\n    Raises the exception instead of returning it, this to allow\n    users to both call it as a function or to raise it as an exception.\n\n    \"\"\"\n    if not isinstance(redirect_path, basestring):\n        redirect_path = '/'.join(list(redirect_path))\n    if not redirect_path.startswith('/'):\n        path = request.path_info\n        check_app_root()\n        if path.startswith(request.app_root):\n            path = path[len(request.app_root):]\n        redirect_path = urlparse.urljoin(path, redirect_path)\n    if set(redirect_path).intersection({'\\r', '\\n'}):\n        raise InvalidRedirectException('Invalid redirect: {}'.format(redirect_path))\n    raise cherrypy.HTTPRedirect(url(tgpath=redirect_path,\n        tgparams=redirect_params, **kw))\n\n\n__all__ = [\n    \"Controller\",\n    \"error_handler\",\n    \"exception_handler\",\n    \"expose\",\n    \"flash\",\n    \"redirect\",\n    \"Root\",\n    \"RootController\",\n    \"url\",\n    \"validate\",\n]\n", "\"\"\"\\\nFront-to-back rapid web development\n===================================\n\nTurboGears brings together four major pieces to create an easy to\ninstall, easy to use web mega-framework. It covers everything from\nfront end (MochiKit JavaScript for the browser, Genshi / Kid / Mako /\nCheetah for templates in Python) to the controllers (CherryPy) to the\nback end (SQLAlchemy or SQLObject).\n\nThe TurboGears project is focused on providing documentation and\nintegration with these tools without losing touch with the communities\nthat already exist around those tools.\n\nTurboGears is easy to use for a wide range of web applications.\n\nThe latest development version is available in the `TurboGears\nsubversion repository`_.\n\nOur `mailing list`_ is lively and helpful, don't hesitate to send your\nquestions there, we will try to help you find out a solution to your\nproblem.\n\n.. _mailing list:\n    http://groups.google.com/group/turbogears\n\n.. _TurboGears subversion repository:\n    http://svn.turbogears.org/trunk#egg=turbogears-dev\n\"\"\"\n\nversion = \"1.0.11.9\"\ndescription = \"Front-to-back, open-source, rapid web development framework\"\nlong_description = __doc__\nauthor = \"Kevin Dangoor\"\nemail = \"dangoor+turbogears@gmail.com\"\nmaintainer = \"TurboGears Release Team\"\nmaintainer_email = \"turbogears@googlegroups.com\"\nurl = \"http://www.turbogears.org/\"\ndownload_url = \"http://www.turbogears.org/%s/downloads/%s/index\" % (\n    '.'.join(version.split('.', 2)[:2]), version)\ndependency_links = [download_url]\ncopyright = \"Copyright 2005 - 2011 Kevin Dangoor and contributors\"\nlicense = \"MIT\"\n", "import unittest\nimport formencode\nimport cherrypy\nimport pkg_resources\nfrom turbogears import config, controllers, database, \\\n    error_handler, exception_handler, expose, flash, redirect, \\\n    startup, testutil, url, validate, validators\n\n\nclass SubApp(controllers.RootController):\n\n    [expose()]\n    def index(self):\n        return url(\"/Foo/\")\n\n\nclass MyRoot(controllers.RootController):\n\n    [expose()]\n    def index(self):\n        pass\n\n    def validation_error_handler(self, tg_source, tg_errors, *args, **kw):\n        self.functionname = tg_source.__name__\n        self.values = kw\n        self.errors = tg_errors\n        return \"Error Message\"\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def test(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(html=\"turbogears.tests.simple\")]\n    def test_deprecated(self):\n        return dict(title=\"Oldbar\", mybool=False, someval=\"giggles\")\n\n    [expose()]\n    def invalid(self):\n        return None\n\n    [expose()]\n    def pos(self, posvalue):\n        self.posvalue = posvalue\n        return \"\"\n\n    [expose()]\n    def servefile(self, tg_exceptions=None):\n        self.servedit = True\n        self.serve_exceptions = tg_exceptions\n        return cherrypy.lib.cptools.serveFile(\n            pkg_resources.resource_filename(\n                \"turbogears.tests\", \"test_controllers.py\"))\n\n    [expose(content_type='text/plain')]\n    def basestring(self):\n        return 'hello world'\n\n    [expose(content_type='text/plain')]\n    def list(self):\n        return ['hello', 'world']\n\n    [expose(content_type='text/plain')]\n    def generator(self):\n        yield 'hello'\n        yield 'world'\n\n    [expose()]\n    def unicode(self):\n        cherrypy.response.headers[\"Content-Type\"] = \"text/html\"\n        return u'\\u00bfHabla espa\\u00f1ol?'\n\n    [expose()]\n    def returnedtemplate(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n            tg_template=\"turbogears.tests.simple\")\n\n    [expose()]\n    def returnedtemplate_short(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n            tg_template=\"turbogears.tests.simple\")\n\n    [expose(template=\"turbogears.tests.simple\")]\n    def exposetemplate_short(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\")\n\n    [expose()]\n    [validate(validators={'value': validators.StringBoolean()})]\n    def istrue(self, value):\n        self.value = value\n        return str(value)\n    istrue = error_handler(validation_error_handler)(istrue)\n\n    [expose()]\n    [validate(validators={'value': validators.StringBoolean()})]\n    def nestedcall(self, value):\n        return self.istrue(str(value))\n\n    [expose()]\n    [validate(validators={'value': validators.StringBoolean()})]\n    def errorchain(self, value):\n        return \"No Error\"\n    errorchain = error_handler(istrue)(errorchain)\n\n    [expose(format=\"json\", template=\"turbogears.tests.simple\")]\n    def returnjson(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n            tg_template=\"turbogears.tests.simple\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=False)]\n    def allowjson(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n             tg_template=\"turbogears.tests.simple\")\n\n    [expose(format=\"json\")]\n    def impliedjson(self):\n        return dict(title=\"Blah\")\n\n    [expose('json')]\n    def explicitjson(self):\n        return dict(title=\"Blub\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def jsonerror_handler(self):\n        return dict(someval=\"errors\")\n\n    [expose(allow_json=True)]\n    def jsonerror(self):\n        raise ValueError\n    jsonerror = exception_handler(jsonerror_handler)(jsonerror)\n\n    [expose(content_type=\"xml/atom\")]\n    def contenttype(self):\n        return \"Foobar\"\n\n    [expose()]\n    [validate(validators={\n        \"firstname\": validators.String(min=2, not_empty=True),\n        \"lastname\": validators.String()})]\n    def save(self, submit, firstname, lastname=\"Miller\"):\n        self.submit = submit\n        self.firstname = firstname\n        self.lastname = lastname\n        self.fullname = \"%s %s\" % (self.firstname, self.lastname)\n        return self.fullname\n    save = error_handler(validation_error_handler)(save)\n\n    class Registration(formencode.Schema):\n        allow_extra_fields = True\n        firstname = validators.String(min=2, not_empty=True)\n        lastname = validators.String()\n\n    [expose()]\n    [validate(validators=Registration())]\n    def save2(self, submit, firstname, lastname=\"Miller\"):\n        return self.save(submit, firstname, lastname)\n    save2 = error_handler(validation_error_handler)(save2)\n\n    [expose(template=\"turbogears.tests.simple\")]\n    def useother(self):\n        return dict(tg_template=\"turbogears.tests.othertemplate\")\n\n    [expose(template=\"cheetah:turbogears.tests.simplecheetah\")]\n    def usecheetah(self):\n        return dict(someval=\"chimps\")\n\n    rwt_called = 0\n    def rwt(self, func, *args, **kw):\n        self.rwt_called += 1\n        func(*args, **kw)\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_plain(self):\n        flash(\"plain\")\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_unicode(self):\n        flash(u\"\\xfcnicode\")\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_data_structure(self):\n        flash(dict(uni=u\"\\xfcnicode\", testing=[1, 2, 3]))\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_redirect(self):\n        flash(u\"redirect \\xfcnicode\")\n        redirect(\"/flash_redirected?tg_format=json\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_redirect_with_trouble_chars(self):\n        flash(u\"$foo, k\\xe4se;\\tbar!\")\n        redirect(\"/flash_redirected?tg_format=json\")\n\n    [expose(template=\"turbogears.tests.simple\", allow_json=True)]\n    def flash_redirected(self):\n        return dict(title=\"Foobar\", mybool=False, someval=\"niggles\")\n\n    def exc_h_value(self, tg_exceptions=None):\n        \"\"\"Exception handler for the ValueError in raise_value_exc\"\"\"\n        return dict(handling_value=True, exception=str(tg_exceptions))\n\n    [expose()]\n    def raise_value_exc(self):\n        raise ValueError('Some Error in the controller')\n    raise_value_exc = exception_handler(exc_h_value,\n        \"isinstance(tg_exceptions, ValueError)\")(raise_value_exc)\n\n    def exc_h_key(self, tg_exceptions=None):\n        \"\"\"Exception handler for KeyErrors in  raise_all_exc\"\"\"\n        return dict(handling_key=True, exception=str(tg_exceptions))\n\n    def exc_h_index(self, tg_exceptions=None):\n        \"\"\"Exception handler for the ValueError in raise_value_exc\"\"\"\n        return dict(handling_index=True, exception=str(tg_exceptions))\n\n    [expose()]\n    def raise_index_exc(self):\n        raise IndexError('Some IndexError')\n    raise_index_exc = exception_handler(exc_h_index,\n        \"isinstance(tg_exceptions, IndexError)\")(raise_index_exc)\n\n    [expose()]\n    def raise_all_exc(self, num=2):\n        num = int(num)\n        if num < 2:\n            raise ValueError('Inferior to 2')\n        elif num == 2:\n            raise IndexError('Equals to 2')\n        elif num > 2:\n            raise KeyError('No such number 2 in the integer range')\n    raise_all_exc = exception_handler(exc_h_index,\n        \"isinstance(tg_exceptions, IndexError)\")(raise_all_exc)\n    raise_all_exc = exception_handler(exc_h_value,\n        \"isinstance(tg_exceptions, ValueError)\")(raise_all_exc)\n    raise_all_exc = exception_handler(exc_h_key,\n        \"isinstance(tg_exceptions, KeyError)\")(raise_all_exc)\n\n    [expose()]\n    def internal_redirect(self, **kwargs):\n        raise cherrypy.InternalRedirect('/internal_redirect_target')\n\n    [expose()]\n    def internal_redirect_target(self, **kwargs):\n        return \"redirected OK\"\n\n    [expose()]\n    def redirect_to_path_str(self, path):\n        raise redirect(path + '/index')\n\n    [expose()]\n    def redirect_to_path_list(self, path):\n        raise redirect([path, 'index'])\n\n    [expose()]\n    def redirect_to_path_tuple(self, path):\n        raise redirect((path, 'index'))\n\n    [expose()]\n    def redirect_error(self):\n        raise redirect('/blah\\r\\n')\n\n\nclass TestRoot(unittest.TestCase):\n\n    def setUp(self):\n        cherrypy.root = None\n        cherrypy.tree.mount_points = {}\n        cherrypy.tree.mount(MyRoot(), \"/\")\n        cherrypy.tree.mount(SubApp(), \"/subthing\")\n\n    def tearDown(self):\n        cherrypy.root = None\n        cherrypy.tree.mount_points = {}\n\n    def test_js_files(self):\n        \"\"\"Can access the JavaScript files\"\"\"\n        testutil.create_request(\"/tg_js/MochiKit.js\")\n        assert cherrypy.response.headers[\"Content-Type\"] in [\n            \"application/javascript\", \"application/x-javascript\"]\n        assert cherrypy.response.status == \"200 OK\"\n\n    def test_json_output(self):\n        testutil.create_request(\"/test?tg_format=json\")\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values == dict(title=\"Foobar\", mybool=False,\n            someval=\"niggles\", tg_flash=None)\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n\n    def test_implied_json(self):\n        testutil.create_request(\"/impliedjson?tg_format=json\")\n        assert '\"title\": \"Blah\"' in cherrypy.response.body[0]\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n\n    def test_explicit_json(self):\n        testutil.create_request(\"/explicitjson\")\n        assert '\"title\": \"Blub\"' in cherrypy.response.body[0]\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n        testutil.create_request(\"/explicitjson?tg_format=json\")\n        assert '\"title\": \"Blub\"' in cherrypy.response.body[0]\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n\n    def test_allow_json(self):\n        testutil.create_request(\"/allowjson?tg_format=json\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/html\"\n\n    def test_allow_json_config(self):\n        \"\"\"JSON output can be enabled via config.\"\"\"\n        config.update({'tg.allow_json':True})\n        class JSONRoot(controllers.RootController):\n            [expose(template=\"turbogears.tests.simple\")]\n            def allowjsonconfig(self):\n                return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n                     tg_template=\"turbogears.tests.simple\")\n        cherrypy.root = JSONRoot()\n        testutil.create_request('/allowjsonconfig?tg_format=json')\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n        config.update({'tg.allow_json': False})\n\n    def test_allow_json_config_false(self):\n        \"\"\"Make sure JSON can still be restricted with a global config on.\"\"\"\n        config.update({'tg.allow_json': True})\n        class JSONRoot(controllers.RootController):\n            [expose(template=\"turbogears.tests.simple\")]\n            def allowjsonconfig(self):\n                return dict(title=\"Foobar\", mybool=False, someval=\"foo\",\n                     tg_template=\"turbogears.tests.simple\")\n        cherrypy.root = JSONRoot()\n        testutil.create_request('/allowjson?tg_format=json')\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/html\"\n        config.update({'tg.allow_json': False})\n\n    def test_json_error(self):\n        \"\"\"The error handler should return JSON if requested.\"\"\"\n        testutil.create_request(\"/jsonerror\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/html; charset=utf-8\"\n        assert \"Paging all errors\" in cherrypy.response.body[0]\n        testutil.create_request(\"/jsonerror?tg_format=json\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"application/json\"\n        assert '\"someval\": \"errors\"' in cherrypy.response.body[0]\n\n    def test_invalid_return(self):\n        testutil.create_request(\"/invalid\")\n        assert cherrypy.response.status.startswith(\"500\")\n\n    def test_strict_parameters(self):\n        config.update({\"tg.strict_parameters\": True})\n        testutil.create_request(\n            \"/save?submit=save&firstname=Foo&lastname=Bar&badparam=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n\n    def test_throw_out_random(self):\n        \"\"\"Can append random value to the URL to avoid caching problems.\"\"\"\n        testutil.create_request(\"/test?tg_random=1\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        config.update({\"tg.strict_parameters\": True})\n        testutil.create_request(\"/test?tg_random=1\")\n        assert cherrypy.response.status.startswith(\"200\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        testutil.create_request(\"/test?tg_not_random=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n\n    def test_ignore_parameters(self):\n        config.update({\"tg.strict_parameters\": True})\n        testutil.create_request(\"/test?ignore_me=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n        config.update({\"tg.ignore_parameters\": ['ignore_me', 'me_too']})\n        testutil.create_request(\"/test?ignore_me=1\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        testutil.create_request(\"/test?me_too=1\")\n        assert cherrypy.response.status.startswith(\"200\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n        testutil.create_request(\"/test?me_not=1\")\n        assert cherrypy.response.status.startswith(\"500\")\n        assert not hasattr(cherrypy.root, \"errors\")\n\n    def test_retrieve_dict_directly(self):\n        d = testutil.call(cherrypy.root.returnjson)\n        assert d[\"title\"] == \"Foobar\"\n\n    def test_template_output(self):\n        testutil.create_request(\"/test\")\n        assert \"Paging all niggles\" in cherrypy.response.body[0]\n\n    def test_template_deprecated(self):\n        testutil.create_request(\"/test_deprecated\")\n        assert \"Paging all giggles\" in cherrypy.response.body[0]\n\n    def test_unicode(self):\n        testutil.create_request(\"/unicode\")\n        firstline = cherrypy.response.body[0].split('\\n')[0].decode('utf-8')\n        assert firstline == u'\\u00bfHabla espa\\u00f1ol?'\n\n    def test_default_format(self):\n        \"\"\"The default format can be set via expose\"\"\"\n        testutil.create_request(\"/returnjson\")\n        firstline = cherrypy.response.body[0]\n        assert '\"title\": \"Foobar\"' in firstline\n        testutil.create_request(\"/returnjson?tg_format=html\")\n        firstline = cherrypy.response.body[0]\n        assert '\"title\": \"Foobar\"' not in firstline\n\n    def test_content_type(self):\n        \"\"\"The content-type can be set via expose\"\"\"\n        testutil.create_request(\"/contenttype\")\n        assert cherrypy.response.headers[\"Content-Type\"] == \"xml/atom\"\n\n    def test_returned_template_name(self):\n        testutil.create_request(\"/returnedtemplate\")\n        data = cherrypy.response.body[0].lower()\n        assert \"<body>\" in data\n        assert 'groovy test template' in data\n\n    def test_returned_template_short(self):\n        testutil.create_request(\"/returnedtemplate_short\")\n        assert \"Paging all foo\" in cherrypy.response.body[0]\n\n    def test_expose_template_short(self):\n        testutil.create_request(\"/exposetemplate_short\")\n        assert \"Paging all foo\" in cherrypy.response.body[0]\n\n    def test_validation(self):\n        \"\"\"Data can be converted and validated\"\"\"\n        testutil.create_request(\"/istrue?value=true\")\n        assert cherrypy.root.value is True\n        testutil.create_request(\"/istrue?value=false\")\n        assert cherrypy.root.value is False\n        cherrypy.root = MyRoot()\n        testutil.create_request(\"/istrue?value=foo\")\n        assert not hasattr(cherrypy.root, \"value\")\n        assert cherrypy.root.functionname == \"istrue\"\n        testutil.create_request(\"/save?submit=send&firstname=John&lastname=Doe\")\n        assert cherrypy.root.fullname == \"John Doe\"\n        assert cherrypy.root.submit == \"send\"\n        testutil.create_request(\"/save?submit=send&firstname=Arthur\")\n        assert cherrypy.root.fullname == \"Arthur Miller\"\n        testutil.create_request(\"/save?submit=send&firstname=Arthur&lastname=\")\n        assert cherrypy.root.fullname == \"Arthur \"\n        testutil.create_request(\"/save?submit=send&firstname=D&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n        assert \"characters\" in cherrypy.root.errors[\"firstname\"].msg.lower()\n        testutil.create_request(\"/save?submit=send&firstname=&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n\n    def test_validation_chained(self):\n        \"\"\"Validation is not repeated if it already happened\"\"\"\n        cherrypy.root.value = None\n        testutil.create_request(\"/errorchain?value=true\")\n        assert cherrypy.root.value is None\n        testutil.create_request(\"/errorchain?value=notbool\")\n        assert cherrypy.root.value == 'notbool'\n\n    def test_validation_nested(self):\n        \"\"\"Validation is not repeated in nested method call\"\"\"\n        cherrypy.root.value = None\n        testutil.create_request(\"/nestedcall?value=true\")\n        assert cherrypy.root.value == 'True'\n        testutil.create_request(\"/nestedcall?value=false\")\n        assert cherrypy.root.value == 'False'\n\n    def test_validation_with_schema(self):\n        \"\"\"Data can be converted/validated with formencode.Schema instance\"\"\"\n        testutil.create_request(\"/save2?submit=send&firstname=Joe&lastname=Doe\")\n        assert cherrypy.root.fullname == \"Joe Doe\"\n        assert cherrypy.root.submit == \"send\"\n        testutil.create_request(\"/save2?submit=send&firstname=Arthur&lastname=\")\n        assert cherrypy.root.fullname == \"Arthur \"\n        testutil.create_request(\"/save2?submit=send&firstname=&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n        testutil.create_request(\"/save2?submit=send&firstname=D&lastname=\")\n        assert len(cherrypy.root.errors) == 1\n        assert cherrypy.root.errors.has_key(\"firstname\")\n\n    def test_other_template(self):\n        \"\"\"'tg_template' in a returned dict will use the template specified there\"\"\"\n        testutil.create_request(\"/useother\")\n        assert \"This is the other template\" in cherrypy.response.body[0]\n\n    def test_cheetah_template(self):\n        \"\"\"Cheetah templates can be used as well\"\"\"\n        testutil.create_request(\"/usecheetah\")\n        body = cherrypy.response.body[0]\n        assert \"This is the Cheetah test template.\" in body\n        assert \"Paging all chimps.\" in body\n\n    def test_run_with_trans(self):\n        \"\"\"run_with_transaction is called only on topmost exposed method\"\"\"\n        oldrwt = database.run_with_transaction\n        database.run_with_transaction = cherrypy.root.rwt\n        testutil.create_request(\"/nestedcall?value=true\")\n        database.run_with_transaction = oldrwt\n        assert cherrypy.root.value\n        assert cherrypy.root.rwt_called == 1\n\n    def test_positional(self):\n        \"\"\"Positional parameters should work\"\"\"\n        testutil.create_request(\"/pos/foo\")\n        assert cherrypy.root.posvalue == \"foo\"\n\n    def test_flash_plain(self):\n        \"\"\"flash with strings should work\"\"\"\n        testutil.create_request(\"/flash_plain?tg_format=json\")\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == \"plain\"\n        assert not cherrypy.response.simple_cookie.has_key(\"tg_flash\")\n\n    def test_flash_unicode(self):\n        \"\"\"flash with unicode objects should work\"\"\"\n        testutil.create_request(\"/flash_unicode?tg_format=json\")\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == u\"\\xfcnicode\"\n        assert not cherrypy.response.simple_cookie.has_key(\"tg_flash\")\n\n    def test_flash_on_redirect(self):\n        \"\"\"flash must survive a redirect\"\"\"\n        testutil.create_request(\"/flash_redirect?tg_format=json\")\n        assert cherrypy.response.status.startswith(\"302\")\n        testutil.create_request(cherrypy.response.headers[\"Location\"],\n            headers=dict(Cookie=cherrypy.response.simple_cookie.output(\n                header=\"\").strip()))\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == u\"redirect \\xfcnicode\"\n\n    def test_flash_redirect_with_trouble_chars(self):\n        \"\"\"flash redirect with chars that can cause troubles in cookies\"\"\"\n        testutil.create_request(\"/flash_redirect_with_trouble_chars?tg_format=json\")\n        assert cherrypy.response.status.startswith(\"302\")\n        value = cherrypy.response.simple_cookie[\"tg_flash\"].value\n        assert '$' not in value\n        assert ',' not in value and ';' not in value\n        assert ' ' not in value and '\\t' not in value\n        assert 'foo' in value and 'bar' in value\n        assert u'k\\xe4se'.encode('utf-8') in value\n        assert '!' in value\n        testutil.create_request(cherrypy.response.headers[\"Location\"],\n            headers=dict(Cookie=cherrypy.response.simple_cookie.output(\n                header=\"\").strip()))\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == u\"$foo, k\\xe4se;\\tbar!\"\n\n    def test_double_flash(self):\n        \"\"\"latest set flash should have precedence\"\"\"\n        # Here we are calling method that sets a flash message. However flash\n        # cookie is still there. Turbogears should discard old flash message\n        # from cookie and use new one, set by flash_plain().\n        testutil.create_request(\"/flash_plain?tg_format=json\",\n            headers=dict(Cookie='tg_flash=\"old flash\"; Path=/;'))\n        import simplejson\n        values = simplejson.loads(cherrypy.response.body[0])\n        assert values[\"tg_flash\"] == \"plain\"\n        assert cherrypy.response.simple_cookie.has_key(\"tg_flash\"), \\\n                \"Cookie clearing request should be present\"\n        flashcookie = cherrypy.response.simple_cookie['tg_flash']\n        assert flashcookie['expires'] == 0\n\n    def test_set_kid_outputformat_in_config(self):\n        \"\"\"the outputformat for kid can be set in the config\"\"\"\n        config.update({'kid.outputformat': 'xhtml'})\n        testutil.create_request('/test')\n        response = cherrypy.response.body[0]\n        assert '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML ' in response\n        config.update({'kid.outputformat': 'html'})\n        testutil.create_request('/test')\n        response = cherrypy.response.body[0]\n        assert  '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML ' in response\n        assert '    This is the groovy test ' in response\n        config.update({'kid.outputformat': 'html compact'})\n        testutil.create_request('/test')\n        response = cherrypy.response.body[0]\n        assert  '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML ' in response\n        assert 'This is the groovy test ' in response\n        assert '    ' not in response\n\n    def test_fileserving(self):\n        testutil.create_request(\"/servefile\")\n        assert cherrypy.root.servedit\n        assert not cherrypy.root.serve_exceptions\n\n    def test_basestring(self):\n        testutil.create_request(\"/basestring\")\n        assert cherrypy.response.body[0] == 'hello world'\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/plain\"\n\n    def test_list(self):\n        testutil.create_request(\"/list\")\n        assert cherrypy.response.body[0] == 'helloworld'\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/plain\"\n\n    def test_generator(self):\n        testutil.create_request(\"/generator\")\n        assert cherrypy.response.body[0] == 'helloworld'\n        assert cherrypy.response.headers[\"Content-Type\"] == \"text/plain\"\n\n    def test_internal_redirect(self):\n        \"\"\"regression test for #1022, #1407 and #1598\"\"\"\n        testutil.create_request(\"/internal_redirect\")\n        firstline = cherrypy.response.body[0]\n        assert \"redirected OK\" in firstline\n\n    def test_internal_redirect_nested_variables(self):\n        \"\"\"regression test for #1022, #1407 and #1598\"\"\"\n        testutil.create_request(\n            \"/internal_redirect?a=1&a-1.b=2&a-2.c=3&a-2.c-1=4\")\n        firstline = cherrypy.response.body[0]\n        assert \"redirected OK\" in firstline\n\n    def test_exc_value(self):\n        \"\"\"Exception is handled gracefully by the right exception handler.\"\"\"\n        testutil.create_request(\"/raise_value_exc\")\n        assert 'handling_value' in cherrypy.response.body[0]\n\n    def test_exc_index(self):\n        \"\"\"Exception is handled gracefully by the right exception handler.\"\"\"\n        testutil.create_request(\"/raise_index_exc\")\n        assert 'handling_index' in cherrypy.response.body[0]\n\n    def test_exc_all(self):\n        \"\"\"Test a controller that is protected by multiple exception handlers.\n\n        It should raise either of the 3 exceptions but all should be handled\n        by their respective handlers without problem...\n\n        \"\"\"\n        testutil.create_request(\"/raise_all_exc?num=1\")\n        assert 'handling_value' in cherrypy.response.body[0]\n        testutil.create_request(\"/raise_all_exc?num=2\")\n        assert 'handling_index' in cherrypy.response.body[0]\n        testutil.create_request(\"/raise_all_exc?num=3\")\n        assert 'handling_key' in cherrypy.response.body[0]\n\n\nclass TestURLs(unittest.TestCase):\n\n    def setUp(self):\n        cherrypy.tree.mount_points = {}\n        cherrypy.root = MyRoot()\n        cherrypy.root.subthing = SubApp()\n        cherrypy.root.subthing.subsubthing = SubApp()\n\n    def tearDown(self):\n        config.update({\"server.webpath\": \"\"})\n        startup.startTurboGears()\n\n    def test_basic_urls(self):\n        testutil.create_request(\"/\")\n        assert \"/foo\" == url(\"/foo\")\n        assert \"foo/bar\" == url([\"foo\", \"bar\"])\n        assert url(\"/foo\", bar=1, baz=2) in \\\n            [\"/foo?bar=1&baz=2\", \"/foo?baz=2&bar=1\"]\n        assert url(\"/foo\", dict(bar=1, baz=2)) in \\\n            [\"/foo?bar=1&baz=2\", \"/foo?baz=2&bar=1\"]\n        assert url(\"/foo\", dict(bar=1, baz=None)) == \"/foo?bar=1\"\n\n    def test_url_without_request_available(self):\n        cherrypy.serving.request = None\n        assert url(\"/foo\") == \"/foo\"\n\n    def test_approots(self):\n        testutil.create_request(\"/subthing/\")\n        assert cherrypy.response.status.startswith(\"200\")\n        assert url(\"foo\") == \"foo\"\n        assert url(\"/foo\") == \"/subthing/foo\"\n        testutil.create_request(\"/nosubthing/\")\n        assert cherrypy.response.status.startswith(\"404\")\n        assert url(\"foo\") == \"foo\"\n        assert url(\"/foo\") == \"/foo\"\n\n    def test_lower_approots(self):\n        testutil.create_request(\"/subthing/subsubthing/\")\n        assert url(\"/foo\") == \"/subthing/subsubthing/foo\"\n\n    def test_approots_with_path(self):\n        config.update({\"server.webpath\": \"/coolsite/root\"})\n        startup.startTurboGears()\n        testutil.create_request(\"/coolsite/root/subthing/\")\n        assert url(\"/foo\") == \"/coolsite/root/subthing/foo\"\n\n    def test_redirect(self):\n        config.update({\"server.webpath\": \"/coolsite/root\"})\n        startup.startTurboGears()\n        testutil.create_request(\"/coolsite/root/subthing/\")\n        try:\n            redirect(\"/foo\")\n            assert False, \"redirect exception should have been raised\"\n        except cherrypy.HTTPRedirect, e:\n            assert \"http://localhost/coolsite/root/subthing/foo\" in e.urls\n        try:\n            raise redirect(\"/foo\")\n            assert False, \"redirect exception should have been raised\"\n        except cherrypy.HTTPRedirect, e:\n            assert \"http://localhost/coolsite/root/subthing/foo\" in e.urls\n        try:\n            redirect(\"foo\")\n            assert False, \"redirect exception should have been raised\"\n        except cherrypy.HTTPRedirect, e:\n            assert \"http://localhost/coolsite/root/subthing/foo\" in e.urls\n\n    def test_redirect_to_path(self):\n        for path_type in ('str', 'list', 'tuple'):\n            for path in ('subthing', '/subthing'):\n                url = \"/redirect_to_path_%s?path=%s\" % (path_type, path)\n                testutil.create_request(url)\n                assert cherrypy.response.status.startswith(\"302\"), url\n                assert (cherrypy.response.headers['Location']\n                    == 'http://localhost/subthing/index'), url\n\n    def test_redirect_error(self):\n        url = \"/redirect_error\"\n        testutil.create_request(url)\n        assert cherrypy.response.status.startswith(\"500\")\n\n    def test_multi_values(self):\n        testutil.create_request(\"/\")\n        assert url(\"/foo\", bar=[1, 2]) in \\\n            [\"/foo?bar=1&bar=2\", \"/foo?bar=2&bar=1\"]\n        assert url(\"/foo\", bar=(\"asdf\", \"qwer\")) in \\\n            [\"/foo?bar=qwer&bar=asdf\", \"/foo?bar=asdf&bar=qwer\"]\n\n    def test_unicode(self):\n        \"\"\"url() can handle unicode parameters\"\"\"\n        testutil.create_request(\"/\")\n        assert url('/', x=u'\\N{LATIN SMALL LETTER A WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER E WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER I WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER O WITH GRAVE}'\n            u'\\N{LATIN SMALL LETTER U WITH GRAVE}') \\\n            == '/?x=%C3%A0%C3%A8%C3%AC%C3%B2%C3%B9'\n\n    def test_list(self):\n        \"\"\"url() can handle list parameters, with unicode too\"\"\"\n        testutil.create_request(\"/\")\n        assert url('/', foo=['bar', u'\\N{LATIN SMALL LETTER A WITH GRAVE}']\n            ) == '/?foo=bar&foo=%C3%A0'\n\n    def test_existing_query_string(self):\n        \"\"\"url() can handle URL with existing query string\"\"\"\n        testutil.create_request(\"/\")\n        test_url = url('/foo', {'first': 1})\n        assert url(test_url, {'second': 2}) == '/foo?first=1&second=2'\n\n    def test_url_kwargs_overwrite_tgparams(self):\n        \"\"\"Keys in tgparams in call to url() overwrite kw args\"\"\"\n        params = {'spamm': 'eggs'}\n        assert 'spamm=ham' in url('/foo', params, spamm='ham')\n\n    def test_url_doesnt_change_tgparams(self):\n        \"\"\"url() does not change the dict passed as second arg\"\"\"\n        params = {'spamm': 'eggs'}\n        assert 'foo' in url('/foo', params, spamm='ham')\n        assert params['spamm'] == 'eggs'\n\n    def test_index_trailing_slash(self):\n        \"\"\"If there is no trailing slash on an index method call, redirect\"\"\"\n        cherrypy.root = SubApp()\n        cherrypy.root.foo = SubApp()\n        testutil.create_request(\"/foo\")\n        assert cherrypy.response.status.startswith(\"302\")\n\n    def test_can_use_internally_defined_arguments(self):\n        \"\"\"Can use argument names that are internally used by TG in controllers\"\"\"\n\n        class App(controllers.RootController):\n\n            [expose()]\n            def index(self, **kw):\n                return \"\\n\".join([\"%s:%s\" % i for i in kw.iteritems()])\n\n        cherrypy.root = App()\n        testutil.create_request(\"/?format=foo&template=bar&fragment=boo\")\n        output = cherrypy.response.body[0]\n        assert \"format:foo\" in output\n        assert \"template:bar\" in output\n        assert \"fragment:boo\" in output\n"], "filenames": ["turbogears/controllers.py", "turbogears/release.py", "turbogears/tests/test_controllers.py"], "buggy_code_start_loc": [328, 31, 258], "buggy_code_end_loc": [675, 32, 714], "fixing_code_start_loc": [328, 31, 259], "fixing_code_end_loc": [685, 32, 724], "type": "CWE-113", "message": "A vulnerability classified as critical has been found in OnShift TurboGears 1.0.11.10. This affects an unknown part of the file turbogears/controllers.py of the component HTTP Header Handler. The manipulation leads to http response splitting. It is possible to initiate the attack remotely. Upgrading to version 1.0.11.11 is able to address this issue. The name of the patch is f68bbaba47f4474e1da553aa51564a73e1d92a84. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220059.", "other": {"cve": {"id": "CVE-2019-25101", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-04T08:15:07.870", "lastModified": "2023-02-14T01:53:48.710", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical has been found in OnShift TurboGears 1.0.11.10. This affects an unknown part of the file turbogears/controllers.py of the component HTTP Header Handler. The manipulation leads to http response splitting. It is possible to initiate the attack remotely. Upgrading to version 1.0.11.11 is able to address this issue. The name of the patch is f68bbaba47f4474e1da553aa51564a73e1d92a84. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220059."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-113"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:turbogears_project:turbogears:1.0.11.10:*:*:*:*:*:*:*", "matchCriteriaId": "09896B84-5607-4F64-B2E6-E8E643165058"}]}]}], "references": [{"url": "https://github.com/OnShift/turbogears/commit/f68bbaba47f4474e1da553aa51564a73e1d92a84", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/OnShift/turbogears/pull/18", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/OnShift/turbogears/releases/tag/v1.0.11.11", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.220059", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.220059", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OnShift/turbogears/commit/f68bbaba47f4474e1da553aa51564a73e1d92a84"}}