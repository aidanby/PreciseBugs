{"buggy_code": ["<?php\nclass KapostService extends Controller implements PermissionProvider {\n    /**\n     * If set to true when the service is called the user agent of the request is checked to see if it is Kapost's XML-RPC user agent\n     * @config KapostService.check_user_agent\n     * @default true\n     */\n    private static $check_user_agent=true;\n    \n    /**\n     * Authenticator to be used for authenticating the Kapost account\n     * @config KapostService.authenticator_class\n     * @default MemberAuthenticator\n     */\n    private static $authenticator_class='MemberAuthenticator';\n    \n    /**\n     * Authenticator to be used for authenticating the Kapost account\n     * @config KapostService.authenticator_username_field\n     * @default Email\n     */\n    private static $authenticator_username_field='Email';\n    \n    /**\n     * Authenticator to be used for authenticating the Kapost account\n     * @config KapostService.kapost_media_folder\n     * @default kapost-media\n     */\n    private static $kapost_media_folder='kapost-media';\n    \n    /**\n     * Tells the service what to do with duplicate media assets\n     * Options:\n     *    smart_rename: Verifies the file is the same as the existing file and instead uses that file, otherwise it renames the file to make it unique\n     *    rename: Rename the file to make it unique\n     *    overwrite: Overwrite the duplicate resource\n     *    ignore: Ignore's the duplicate resource and returns an error to Kapost\n     * \n     * @config KapostService.duplicate_assets\n     * @default smart_rename\n     */\n    private static $duplicate_assets='smart_rename';\n    \n    /**\n     * Preview expiry window in minutes\n     * @config KapostService.preview_expiry\n     * @default 10\n     */\n    private static $preview_expiry=10;\n    \n    /**\n     * Database Character Set\n     * @config KapostService.database_charset\n     * @default UTF-8\n     */\n    private static $database_charset='UTF-8';\n    \n    /**\n     * Enables filtering of the kapost thread tags in the description field\n     * @config KapostService.filter_kapost_threads\n     * @default true\n     */\n    private static $filter_kapost_threads=false;\n    \n    \n    private $exposed_methods=array(\n                                    'blogger.getUsersBlogs',\n                                    'metaWeblog.newPost',\n                                    'metaWeblog.editPost',\n                                    'metaWeblog.getPost',\n                                    'metaWeblog.getCategories',\n                                    'metaWeblog.newMediaObject',\n                                    'kapost.getPreview'\n                                );\n    \n    private static $allowed_actions=array(\n                                        'preview'\n                                    );\n    \n    \n    /**\n     * Handles incoming requests to the kapost service\n     */\n    public function index() {\n        //If the request is not a post request 404\n        if(!$this->request->isPOST()) {\n            return ErrorPage::response_for(404);\n        }\n        \n        //If the request is not the kapost user agent 404\n        if(self::config()->check_user_agent==true && $this->request->getHeader('User-Agent')!='Kapost XMLRPC::Client') {\n            return ErrorPage::response_for(404);\n        }\n        \n        $methods=array_fill_keys($this->exposed_methods, array('function'=>array($this, 'handleRPCMethod')));\n        \n        //Disable Content Negotiator and send the text/xml header (which kapost expects)\n        ContentNegotiator::config()->enabled=false;\n        $this->response->addHeader('Content-Type', 'text/xml');\n        \n        $server=new xmlrpc_server($methods, false);\n        $server->compress_response=true;\n        \n        \n        if(Director::isDev()) {\n            $server->setDebug(3); //Base 64 encoded debug information is included in the response\n            $server->exception_handling=2; //Exception's sent to the client\n        }\n        \n        \n        //Force the internal encoding of the XMLRPC library to utf-8\n        $GLOBALS['xmlrpc_internalencoding']=self::config()->database_charset;\n        \n        \n        return $server->service($this->request->getBody(), true);\n    }\n    \n    /**\n     * Handles rendering of the preview for an object\n     * @return {string} Response to send to the object\n     */\n    public function preview() {\n        $auth=$this->request->getVar('auth');\n        $token=KapostPreviewToken::get()->filter('Code', Convert::raw2xml($auth))->first();\n        \n        //Verify the token exists and hasn't expired yet\n        if(!empty($token) && $token!==false && $token->exists() && time()-strtotime($token->Created)<self::config()->preview_expiry*60 && $token->KapostRefID==$this->urlParams['ID']) {\n            $kapostObj=KapostObject::get()->filter('KapostRefID', Convert::raw2xml($this->urlParams['ID']))->sort('\"Created\" DESC')->first();\n            if(!empty($kapostObj) && $kapostObj!==false && $kapostObj->exists()) {\n                $previewController=$kapostObj->renderPreview();\n                \n                $this->extend('updatePreviewDisplay', $kapostObj, $previewController);\n                \n                return $previewController;\n            }\n        }\n        \n        \n        //Token expired or object not found\n        $response=ErrorPage::response_for(404);\n        if(!empty($response)) {\n            return $response;\n        }\n        \n        return parent::httpError(404);\n    }\n    \n    /**\n     * Handles RPC request methods\n     * @param {xmlrpcmsg} $request XML-RPC Request Object\n     */\n    public function handleRPCMethod(xmlrpcmsg $request) {\n        $username=$request->getParam(1)->getval();\n        $password=$request->getParam(2)->getval();\n        \n        if($this->authenticate($username, $password)) {\n            $method=str_replace(array('blogger.', 'metaWeblog.', 'kapost.'), '', $request->methodname);\n            \n            if(!in_array($request->methodname, $this->exposed_methods) || !method_exists($this, $method)) {\n                return $this->httpError(403, _t('KapostService.METHOD_NOT_ALLOWED', '_Action \"{method}\" is not allowed on class Kapost Service.', array('method'=>$request->methodname)));\n            }\n            \n            \n            //Pack params into call to method if they are not the authentication parameters\n            $params=array();\n            for($i=0;$i<$request->getNumParams();$i++) {\n                if($i!=1 && $i!=2) {\n                    $params[]=php_xmlrpc_decode($request->getParam($i));\n                }\n            }\n            \n            \n            //Convert the custom fields to an associtive array\n            if(array_key_exists(1, $params) && is_array($params[1]) && array_key_exists('custom_fields', $params[1])) {\n                $params[1]['custom_fields']=$this->struct_to_assoc($params[1]['custom_fields']);\n            }\n            \n            \n            //If transactions are supported start one for newPost and editPost\n            if(($method=='newPost' || $method=='editPost') && DB::getConn()->supportsTransactions()) {\n                DB::getConn()->transactionStart();\n            }\n            \n            \n            //Call the method\n            $response=call_user_func_array(array($this, $method), $params);\n            if($response instanceof xmlrpcresp) {\n                //If transactions are supported check the response and rollback in the case of a fault\n                if(($method=='newPost' || $method=='editPost' || $method=='newMediaObject') && DB::getConn()->supportsTransactions()) {\n                    if($response->faultCode()!=0) {\n                        DB::getConn()->transactionRollback();\n                    }else {\n                        DB::getConn()->transactionEnd();\n                    }\n                }\n                \n                return $response; //Response is already encoded so return\n            }\n            \n            //Encode the response\n            $response=php_xmlrpc_encode($response);\n            if(is_object($response) && $response instanceof xmlrpcval) {\n                $response=new xmlrpcresp($response);\n                \n                if(($method=='newPost' || $method=='editPost' || $method=='newMediaObject') && DB::getConn()->supportsTransactions()) {\n                    if($response->faultCode()!=0) {\n                        DB::getConn()->transactionRollback();\n                    }else {\n                        DB::getConn()->transactionEnd();\n                    }\n                }\n                \n                return $response;\n            }\n            \n            return $this->httpError(500, _t('KapostService.INVALID_RESPONSE', '_Invalid response returned from {method}, response was: {response}', array(\n                                                                                                                                                        'method'=>$method,\n                                                                                                                                                        'response'=>print_r($response, true)\n                                                                                                                                                    )));\n        }\n        \n        \n        return $this->httpError(401, _t('KapostService.AUTH_FAIL', '_Authentication Failed, please check the App Center credentials for the SilverStripe end point.'));\n    }\n    \n    /**\n     * Checks the authentication of the api request\n     * @param {string} $username Username to look up\n     * @param {string} $password Password to match against\n     * @return {bool} Returns boolean true if authentication passes false otherwise\n     */\n    protected function authenticate($username, $password) {\n        $authenticator=$this->config()->authenticator_class;\n        \n        $member=$authenticator::authenticate(array(\n                                                $this->config()->authenticator_username_field=>$username,\n                                                'Password'=>$password\n                                            ));\n        \n        return (!empty($member) && $member!==false && $member->exists()==true && Permission::check('KAPOST_API_ACCESS', 'any', $member));\n    }\n    \n    /**\n     * Converts an error to an xmlrpc response\n     * @param {int} $errorCode Error code number for the error\n     * @param {string} $errorMessage Error message string\n     * @return {xmlrpcresp} XML-RPC response object\n     */\n    public function httpError($errorCode, $errorMessage=null) {\n        return new xmlrpcresp(0, $errorCode+10000, $errorMessage);\n    }\n    \n    /**\n     * Gets the site config or subsites for the current site\n     * @return {array} Nested array of sites\n     */\n    protected function getUsersBlogs($app_id) {\n        if(SiteConfig::has_extension('SiteConfigSubsites')) {\n            $response=array();\n            \n            //Disable subsite filter\n            Subsite::disable_subsite_filter();\n            \n            $subsites=Subsite::get();\n            foreach($subsites as $subsite) {\n                $response[]=array(\n                                'blogid'=>$subsite->ID,\n                                'blogname'=>$subsite->Title\n                            );\n            }\n            \n            //Re-enable subsite filter\n            Subsite::disable_subsite_filter(false);\n            \n            return $response;\n        }\n        \n        \n        $siteConfig=SiteConfig::current_site_config();\n        return array(\n                    array(\n                        'blogid'=>$siteConfig->ID,\n                        'blogname'=>$siteConfig->Title\n                    )\n                );\n    }\n    \n    /**\n     * Handles creation of a new post\n     * @param {mixed} $blog_id Identifier for the current site\n     * @param {array} $content Post details\n     * @param {int} $publish 0 or 1 depending on whether to publish the post or not\n     * @param {bool} $isPreview Is preview mode or not (defaults to false)\n     */\n    protected function newPost($blog_id, $content, $publish, $isPreview=false) {\n        $results=$this->extend('newPost', $blog_id, $content, $publish, $isPreview);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        if(array_key_exists('custom_fields', $content)) {\n            //Ensure the type is an extension of the KapostPage object\n            if(!class_exists('Kapost'.$content['custom_fields']['kapost_custom_type']) || !('Kapost'.$content['custom_fields']['kapost_custom_type']=='KapostPage' || is_subclass_of('Kapost'.$content['custom_fields']['kapost_custom_type'], 'KapostPage'))) {\n                return $this->httpError(400, _t('KapostService.TYPE_NOT_KNOWN', '_The type \"{type}\" is not a known type', array('type'=>$content['custom_fields']['kapost_custom_type'])));\n            }\n            \n            $className='Kapost'.$content['custom_fields']['kapost_custom_type'];\n        }else {\n            //Assume we're creating a page and set the content as such\n            $className='KapostPage';\n        }\n        \n        \n        $pageTitle=$content['title'];\n        if(array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $pageTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        $menuTitle=$content['title'];\n        if(empty($content['title']) && array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $menuTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        $obj=new $className();\n        $obj->Title=$pageTitle;\n        $obj->MenuTitle=$menuTitle;\n        $obj->Content=(self::config()->filter_kapost_threads==true ? $this->filterKapostThreads($content['description']):$content['description']);\n        $obj->MetaDescription=(array_key_exists('custom_fields', $content) && array_key_exists('SS_MetaDescription', $content['custom_fields']) ? $content['custom_fields']['SS_MetaDescription']:null);\n        $obj->KapostChangeType='new';\n        $obj->KapostAuthor=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_author']:null);\n        $obj->KapostRefID=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_post_id']:null);\n        $obj->ToPublish=$publish;\n        $obj->IsKapostPreview=$isPreview;\n        $obj->write();\n        \n        \n        //Fallback for tests where the kapost_post_id is missing\n        if(!array_key_exists('custom_fields', $content)) {\n            $obj->KapostRefID=$className.'_'.$obj->ID;\n            $obj->write();\n        }\n        \n        \n        //Allow extensions to adjust the new page\n        $this->extend('updateNewKapostPage', $obj, $blog_id, $content, $publish, $isPreview);\n        \n        return $obj->KapostRefID;\n    }\n    \n    /**\n     * Handles editing of a given post\n     * @param {mixed} $content_id Identifier for the post\n     * @param {array} $content Post details\n     * @param {int} $publish 0 or 1 depending on whether to publish the post or not\n     * @param {bool} $isPreview Is preview mode or not (defaults to false)\n     */\n    protected function editPost($content_id, $content, $publish, $isPreview=false) {\n        $results=$this->extend('editPost', $content_id, $content, $publish, $isPreview);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        //Ensure the type is an extension of the KapostPage object\n        if(array_key_exists('custom_fields', $content) && (!class_exists('Kapost'.$content['custom_fields']['kapost_custom_type']) || !('Kapost'.$content['custom_fields']['kapost_custom_type']=='KapostPage' || is_subclass_of('Kapost'.$content['custom_fields']['kapost_custom_type'], 'KapostPage')))) {\n            return $this->httpError(400, _t('KapostService.TYPE_NOT_KNOWN', '_The type \"{type}\" is not a known type', array('type'=>$content['custom_fields']['kapost_custom_type'])));\n        }\n        \n        \n        //Assume we're looking for a page\n        //Switch Versioned to stage\n        $oldReadingStage=Versioned::current_stage();\n        Versioned::set_reading_mode('stage');\n        \n        $page=SiteTree::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        \n        //Switch Versioned back\n        Versioned::set_reading_mode($oldReadingStage);\n        \n        \n        $pageTitle=$content['title'];\n        if(array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $pageTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        $menuTitle=$content['title'];\n        if(empty($content['title']) && array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $menuTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        \n        $kapostObj=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        if(!empty($kapostObj) && $kapostObj!==false && $kapostObj->exists()) {\n            $kapostObj->Title=$pageTitle;\n            $kapostObj->MenuTitle=$menuTitle;\n            $kapostObj->Content=(self::config()->filter_kapost_threads==true ? $this->filterKapostThreads($content['description']):$content['description']);\n            $kapostObj->MetaDescription=(array_key_exists('custom_fields', $content) && array_key_exists('SS_MetaDescription', $content['custom_fields']) ? $content['custom_fields']['SS_MetaDescription']:null);\n            $kapostObj->LinkedPageID=(!empty($page) && $page!==false && $page->exists() ? $page->ID:$kapostObj->LinkedPageID);\n            $kapostObj->KapostRefID=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_post_id']:null);\n            $kapostObj->KapostAuthor=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_author']:null);\n            $kapostObj->ToPublish=$publish;\n            $kapostObj->IsKapostPreview=$isPreview;\n            $kapostObj->write();\n            \n            //Allow extensions to adjust the existing object\n            $this->extend('updateEditKapostPage', $kapostObj, $content_id, $content, $publish, $isPreview);\n            \n            return true;\n        }else {\n            $className=(array_key_exists('custom_fields', $content) ? 'Kapost'.$content['custom_fields']['kapost_custom_type']:'KapostPage');\n            \n            $obj=new $className();\n            $obj->Title=$pageTitle;\n            $obj->MenuTitle=$menuTitle;\n            $obj->Content=(self::config()->filter_kapost_threads==true ? $this->filterKapostThreads($content['description']):$content['description']);\n            $obj->MetaDescription=(array_key_exists('custom_fields', $content) && array_key_exists('SS_MetaDescription', $content['custom_fields']) ? $content['custom_fields']['SS_MetaDescription']:null);\n            $obj->KapostChangeType='edit';\n            $obj->LinkedPageID=(!empty($page) && $page!==false && $page->exists() ? $page->ID:0);\n            $obj->KapostRefID=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_post_id']:null);\n            $obj->KapostAuthor=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_author']:null);\n            $obj->ToPublish=$publish;\n            $obj->IsKapostPreview=$isPreview;\n            $obj->write();\n            \n            \n            //Allow extensions to adjust the new page\n            $this->extend('updateEditKapostPage', $obj, $content_id, $content, $publish, $isPreview);\n            \n            return true;\n        }\n        \n        \n        //Can't find the object so return a 404 code\n        return new xmlrpcresp(0, 404, _t('KapostService.INVALID_POST_ID', '_Invalid post ID.'));\n    }\n    \n    /**\n     * Gets the details of a post from the system\n     * @param {mixed} $content_id ID of the post in the system\n     */\n    protected function getPost($content_id) {\n        $results=$this->extend('getPost', $content_id);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        //Switch Versioned to stage\n        $oldReadingStage=Versioned::current_stage();\n        Versioned::set_reading_mode('stage');\n        \n        $page=SiteTree::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        \n        //Switch Versioned back\n        Versioned::set_reading_mode($oldReadingStage);\n        \n        \n        if(!empty($page) && $page!==false && $page->exists()) {\n            $postMeta=array(\n                        'title'=>$page->Title,\n                        'description'=>$page->Content,\n                        'mt_keywords'=>'',\n                        'mt_excerpt'=>'',\n                        'categories'=>array('ss_page'),\n                        'permaLink'=>$page->AbsoluteLink(),\n                        'custom_fields'=>array(\n                                array('id'=>'SS_Title', 'key'=>'SS_Title', 'value'=>$page->Title),\n                                array('id'=>'SS_MetaDescription', 'key'=>'SS_MetaDescription', 'value'=>$page->MetaDescription)\n                            )\n                    );\n            \n            //Allow extensions to modify the page meta\n            $results=$this->extend('updatePageMeta', $page);\n            if(count($results)>0) {\n                for($i=0;$i<count($results);$i++) {\n                    $postMeta=$this->mergeResultArray($postMeta, $results[$i]);\n                }\n            }\n            \n            return $postMeta;\n        }else {\n            $kapostObj=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n            if(!empty($kapostObj) && $kapostObj!==false && $kapostObj->exists()) {\n                $postMeta=array(\n                            'title'=>$kapostObj->Title,\n                            'description'=>$kapostObj->Content,\n                            'mt_keywords'=>'',\n                            'mt_excerpt'=>'',\n                            'categories'=>array('ss_page'),\n                            'permaLink'=>Controller::join_links(Director::absoluteBaseURL(), 'admin/kapost/KapostObject/EditForm/field/KapostObject/item', $kapostObj->ID, 'edit'),\n                            'custom_fields'=>array(\n                                    array('id'=>'SS_Title', 'key'=>'SS_Title', 'value'=>$kapostObj->Title),\n                                    array('id'=>'SS_MetaDescription', 'key'=>'SS_MetaDescription', 'value'=>$kapostObj->MetaDescription)\n                                )\n                        );\n                \n                //Allow extensions to modify the page meta\n                $results=$this->extend('updateObjectMeta', $kapostObj);\n                if(count($results)>0) {\n                    for($i=0;$i<count($results);$i++) {\n                        $postMeta=$this->mergeResultArray($postMeta, $results[$i]);\n                    }\n                }\n                \n                return $postMeta;\n            }\n        }\n        \n        return new xmlrpcresp(0, 404, _t('KapostService.INVALID_POST_ID', '_Invalid post ID.'));\n    }\n    \n    /**\n     * Gets the categories\n     * @param {mixed} $blog_id ID of the blog\n     * @return {array} Array of categories\n     */\n    protected function getCategories($blog_id) {\n        $categories=array();\n        $pageClasses=ClassInfo::subclassesFor('SiteTree');\n        foreach($pageClasses as $class) {\n            if($class!='SiteTree') {\n                $categories[]=array(\n                                'categoryId'=>'ss_'.strtolower($class),\n                                'categoryName'=>singleton($class)->i18n_singular_name(),\n                                'parentId'=>0\n                            );\n            }\n        }\n        \n        \n        \n        $results=$this->extend('getCategories', $blog_id);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                for($i=0;$i<count($results);$i++) {\n                    $categories=array_merge($categories, $results[$i]);\n                }\n            }\n        }\n        \n        return $categories;\n    }\n    \n    /**\n     * Handles media objects from kapost\n     * @param {mixed} $blog_id Site Config related to this content object\n     * @param {array} $content Content object to be handled\n     * @return {xmlrpcresp} XML-RPC Response object\n     */\n    protected function newMediaObject($blog_id, $content) {\n        $fileName=$content['name'];\n        $validator=new Upload_Validator(array('name'=>$fileName));\n        $validator->setAllowedExtensions(File::config()->allowed_extensions);\n        \n        //Verify we have a valid extension\n        if($validator->isValidExtension()==false) {\n            return $this->httpError(403, _t('KapostService.FILE_NOT_ALLOWED', '_File extension is not allowed'));\n        }\n        \n        \n        //Generate default filename\n        $nameFilter=FileNameFilter::create();\n        $file=$nameFilter->filter($fileName);\n        while($file[0]=='_' || $file[0]=='.') {\n            $file=substr($file, 1);\n        }\n        \n        $doubleBarrelledExts=array('.gz', '.bz', '.bz2');\n        \n        $ext=\"\";\n        if(preg_match('/^(.*)(\\.[^.]+)$/', $file, $matches)) {\n            $file=$matches[1];\n            $ext=$matches[2];\n            \n            // Special case for double-barrelled \n            if(in_array($ext, $doubleBarrelledExts) && preg_match('/^(.*)(\\.[^.]+)$/', $file, $matches)) {\n                $file=$matches[1];\n                $ext=$matches[2].$ext;\n            }\n        }\n        \n        $origFile=$file;\n        \n        \n        //Find the kapost media folder\n        $kapostMediaFolder=Folder::find_or_make($this->config()->kapost_media_folder);\n        \n        if(file_exists($kapostMediaFolder->getFullPath().'/'.$file.$ext)) {\n            if(self::config()->duplicate_assets=='overwrite') {\n                $obj=File::get()->filter('Filename', Convert::raw2sql($kapostMediaFolder->Filename.$file.$ext))->first();\n                if(!empty($obj) && $obj!==false && $obj->ID>0) {\n                    //Update the Title for the image\n                    $obj->Title=(!empty($content['alt']) ? $content['alt']:str_replace(array('-','_'), ' ', preg_replace('/\\.[^.]+$/', '', $obj->Name)));\n                    $obj->write();\n                    \n                    //Write the file to the file system\n                    $f=fopen($kapostMediaFolder->getFullPath().'/'.$file.$ext, 'w');\n                    fwrite($f, $content['bits']);\n                    fclose($f);\n                \n                    return array(\n                                'id'=>$obj->ID,\n                                'url'=>$obj->getAbsoluteURL()\n                            );\n                }\n                \n                return $this->httpError(404, _t('KapostService.FILE_NOT_FOUND', '_File not found'));\n            }else if(self::config()->duplicate_assets=='ignore') {\n                return $this->httpError(409, _t('KapostService.DUPLICATE_FILE', '_Duplicate file detected, please rename the file and try again'));\n            }else {\n                if(self::config()->duplicate_assets=='smart_rename' && file_exists($kapostMediaFolder->getFullPath().'/'.$file.$ext)) {\n                    $obj=File::get()->filter('Filename', Convert::raw2sql($kapostMediaFolder->Filename.$file.$ext))->first();\n                    if(!empty($obj) && $obj!==false && $obj->ID>0) {\n                        $fileHash=sha1_file($kapostMediaFolder->getFullPath().'/'.$file.$ext);\n                        if($fileHash==sha1($content['bits'])) {\n                            return array(\n                                        'id'=>$obj->ID,\n                                        'url'=>$obj->getAbsoluteURL()\n                                    );\n                        }\n                    }\n                }\n                \n                $i = 1;\n                while(file_exists($kapostMediaFolder->getFullPath().'/'.$file.$ext)) {\n                    $i++;\n                    $oldFile=$file;\n                     \n                    if(strpos($file, '.')!==false) {\n                        $file = preg_replace('/[0-9]*(\\.[^.]+$)/', $i.'\\\\1', $file);\n                    }else if(strpos($file, '_')!==false) {\n                        $file=preg_replace('/_([^_]+$)/', '_'.$i, $file);\n                    }else {\n                        $file.='_'.$i;\n                    }\n                    \n                    if($oldFile==$file && $i > 2) {\n                        return $this->httpError(500, _t('KapostService.FILE_RENAME_FAIL', '_Could not fix {filename} with {attempts} attempts', array('filename'=>$file.$ext, 'attempts'=>$i)));\n                    }\n                }\n                \n                //Write the file to the file system\n                $f=fopen($kapostMediaFolder->getFullPath().'/'.$file.$ext, 'w');\n                fwrite($f, $content['bits']);\n                fclose($f);\n                \n                \n                //Write the file to the database\n                $className=File::get_class_for_file_extension(substr($ext, 1));\n                $obj=new $className();\n                $obj->Name=$file.$ext;\n                $obj->Title=(!empty($content['alt']) ? $content['alt']:str_replace(array('-','_'), ' ', preg_replace('/\\.[^.]+$/', '', $obj->Name)));\n                $obj->FileName=$kapostMediaFolder->getRelativePath().'/'.$file.$ext;\n                $obj->ParentID=$kapostMediaFolder->ID;\n                \n                //If subsites is enabled add it to the correct subsite\n                if(File::has_extension('FileSubsites')) {\n                    $obj->SubsiteID=$blog_id;\n                }\n                \n                $obj->write();\n                \n                \n                $this->extend('updateNewMediaAsset', $blog_id, $content, $obj);\n                \n                \n                return array(\n                            'id'=>$obj->ID,\n                            'url'=>$obj->getAbsoluteURL()\n                        );\n            }\n        }else {\n            //Write the file to the file system\n            $f=fopen($kapostMediaFolder->getFullPath().'/'.$file.$ext, 'w');\n            fwrite($f, $content['bits']);\n            fclose($f);\n            \n            \n            //Write the file to the database\n            $className=File::get_class_for_file_extension(substr($ext, 1));\n            $obj=new $className();\n            $obj->Name=$file.$ext;\n            $obj->Title=(!empty($content['alt']) ? $content['alt']:str_replace(array('-','_'), ' ', preg_replace('/\\.[^.]+$/', '', $obj->Name)));\n            $obj->FileName=$kapostMediaFolder->getRelativePath().'/'.$file.$ext;\n            $obj->ParentID=$kapostMediaFolder->ID;\n            \n            //If subsites is enabled add it to the correct subsite\n            if(File::has_extension('FileSubsites')) {\n                $obj->SubsiteID=$blog_id;\n            }\n            \n            $obj->write();\n            \n            \n            $this->extend('updateNewMediaAsset', $blog_id, $content, $obj);\n            \n            return array(\n                        'id'=>$obj->ID,\n                        'url'=>$obj->getAbsoluteURL()\n                    );\n        }\n    }\n    \n    /**\n     * Handles rendering of the preview\n     * @param {mixed} $blog_id Identifier for the current site\n     * @param {array} $content Post details\n     * @param {mixed} $content_id Identifier for the post\n     */\n    protected function getPreview($blog_id, $content, $content_id) {\n        $results=$this->extend('getPreview', $blog_id, $content, $content_id);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n        \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        //Detect if the record already exists or not so we can decide whether to create a new record or edit an existing\n        $existing=KapostObject::get()->filter('KapostRefID', Convert::raw2xml($content_id))->first();\n        if(!empty($existing) && $existing!==false && $existing->exists()) {\n            $resultID=$content_id;\n            \n            $this->editPost($content_id, $content, false, true);\n        }else {\n            $resultID=$this->newPost($blog_id, $content, false, true);\n            \n            //Find the object\n            $existing=KapostObject::get()->filter('KapostRefID', Convert::raw2xml($resultID))->first();\n        }\n        \n        //Make sure we got the kapost hash back or an id if we got an object back we assume that it's a response\n        if(is_object($resultID)) {\n            return $resultID;\n        }\n        \n        \n        //Generate a preview token record\n        $token=new KapostPreviewToken();\n        $token->Code=sha1(uniqid(time().$resultID));\n        $token->KapostRefID=$resultID;\n        $token->write();\n        \n        \n        //Return the details to kapost\n        return array(\n                    'url'=>Controller::join_links(Director::absoluteBaseURL(), 'kapost-service/preview', $resultID, '?auth='.$token->Code),\n                    'id'=>$resultID\n                );\n    }\n    \n    /**\n     * Converts a struct to an associtive array based on the key value pair in the struct\n     * @param {array} $struct Input struct to be converted\n     * @return {array} Associtive array matching the struct\n     */\n    final protected function struct_to_assoc($struct) {\n        $result=array();\n        foreach($struct as $item) {\n            if(array_key_exists('key', $item) && array_key_exists('value', $item)) {\n                if(array_key_exists($item['key'], $result)) {\n                    user_error('Duplicate key detected in struct entry, content overwritten by the last entry: [New: '.print_r($item, true).'] [Previous: '.print_r($result[$item['key']], true).']', E_USER_WARNING);\n                }\n                \n                $result[$item['key']]=$item['value'];\n            }else {\n                user_error('Key/Value pair not detected in struct entry: '.print_r($item, true), E_USER_NOTICE);\n            }\n        }\n        \n        return $result;\n    }\n    \n    /**\n     * Merges two arrays, overwriting the keys in the left array with the right array recurrsivly. Meaning that if a value in the right array is it self an array and the key exists in the left array it recurses into it.\n     * @param {array} $leftArray Left array to merge into\n     * @param {array} $rightArray Right array to merge from\n     * @return {array} Resulting array\n     */\n    private function mergeResultArray($leftArray, $rightArray) {\n        foreach($rightArray as $key=>$value) {\n            if(is_array($value) && array_key_exists($key, $leftArray)) {\n                $leftArray[$key]=array_merge($leftArray[$key], $value);\n            }else {\n                $leftArray[$key]=$value;\n            }\n        }\n        \n        return $leftArray;\n    }\n    \n    /**\n     * Filters the kapost content to remove the thread tags from a Kapost WYSIWYG\n     * @param {string} $html HTML to filter the tags from\n     * @return {string} HTML with tags filtered\n     */\n    public function filterKapostThreads($html) {\n        return preg_replace('/<span(\\s+)thread=\"(.*?)\"(\\s+)class=\"thread\">(.*?)<\\/span>/', '$4', $html);\n    }\n    \n    /**\n     * Finds a file record based on the url of the file, this is needed because Kapost doesn't seem to send anything back other than the url in the cms\n     * @param {string} $url Absolute url to the file\n     * @return {File} Returns the file instance representing the url, or boolean false if it's not found\n     */\n    public static function find_file_by_url($url) {\n        $url=Director::makeRelative($url);\n        if($url) {\n            $file=File::get()->filter('Filename', Convert::raw2sql($url))->first();\n            if(!empty($file) && $file!==false && $file->ID>0) {\n                return $file;\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Return a map of permission codes to add to the dropdown shown in the Security section of the CMS.\n     * @return {array} Map of permission codes\n     */\n    public function providePermissions() {\n        return array(\n                   'KAPOST_API_ACCESS'=>array(\n                                               'category'=>_t('KapostService.KAPOST_BRIDGE', '_Kapost Bridge'),\n                                               'name'=>_t('KapostService.PERMISSION_API_ACCESS', '_Kapost API Access'),\n                                               'help'=>_t('KapostService.PERMISSION_API_ACCESS_DESC', '_Access the XML-RPC Endpoint for Kapost to communicate with')\n                                           ),\n                );\n    }\n}\n?>"], "fixing_code": ["<?php\nclass KapostService extends Controller implements PermissionProvider {\n    /**\n     * If set to true when the service is called the user agent of the request is checked to see if it is Kapost's XML-RPC user agent\n     * @config KapostService.check_user_agent\n     * @default true\n     */\n    private static $check_user_agent=true;\n    \n    /**\n     * Authenticator to be used for authenticating the Kapost account\n     * @config KapostService.authenticator_class\n     * @default MemberAuthenticator\n     */\n    private static $authenticator_class='MemberAuthenticator';\n    \n    /**\n     * Authenticator to be used for authenticating the Kapost account\n     * @config KapostService.authenticator_username_field\n     * @default Email\n     */\n    private static $authenticator_username_field='Email';\n    \n    /**\n     * Authenticator to be used for authenticating the Kapost account\n     * @config KapostService.kapost_media_folder\n     * @default kapost-media\n     */\n    private static $kapost_media_folder='kapost-media';\n    \n    /**\n     * Tells the service what to do with duplicate media assets\n     * Options:\n     *    smart_rename: Verifies the file is the same as the existing file and instead uses that file, otherwise it renames the file to make it unique\n     *    rename: Rename the file to make it unique\n     *    overwrite: Overwrite the duplicate resource\n     *    ignore: Ignore's the duplicate resource and returns an error to Kapost\n     * \n     * @config KapostService.duplicate_assets\n     * @default smart_rename\n     */\n    private static $duplicate_assets='smart_rename';\n    \n    /**\n     * Preview expiry window in minutes\n     * @config KapostService.preview_expiry\n     * @default 10\n     */\n    private static $preview_expiry=10;\n    \n    /**\n     * Database Character Set\n     * @config KapostService.database_charset\n     * @default UTF-8\n     */\n    private static $database_charset='UTF-8';\n    \n    /**\n     * Enables filtering of the kapost thread tags in the description field\n     * @config KapostService.filter_kapost_threads\n     * @default true\n     */\n    private static $filter_kapost_threads=false;\n    \n    \n    private $exposed_methods=array(\n                                    'blogger.getUsersBlogs',\n                                    'metaWeblog.newPost',\n                                    'metaWeblog.editPost',\n                                    'metaWeblog.getPost',\n                                    'metaWeblog.getCategories',\n                                    'metaWeblog.newMediaObject',\n                                    'kapost.getPreview'\n                                );\n    \n    private static $allowed_actions=array(\n                                        'preview'\n                                    );\n    \n    \n    /**\n     * Handles incoming requests to the kapost service\n     */\n    public function index() {\n        //If the request is not a post request 404\n        if(!$this->request->isPOST()) {\n            return ErrorPage::response_for(404);\n        }\n        \n        //If the request is not the kapost user agent 404\n        if(self::config()->check_user_agent==true && $this->request->getHeader('User-Agent')!='Kapost XMLRPC::Client') {\n            return ErrorPage::response_for(404);\n        }\n        \n        $methods=array_fill_keys($this->exposed_methods, array('function'=>array($this, 'handleRPCMethod')));\n        \n        //Disable Content Negotiator and send the text/xml header (which kapost expects)\n        ContentNegotiator::config()->enabled=false;\n        $this->response->addHeader('Content-Type', 'text/xml');\n        \n        $server=new xmlrpc_server($methods, false);\n        $server->compress_response=true;\n        \n        \n        if(Director::isDev()) {\n            $server->setDebug(3); //Base 64 encoded debug information is included in the response\n            $server->exception_handling=2; //Exception's sent to the client\n        }\n        \n        \n        //Force the internal encoding of the XMLRPC library to utf-8\n        $GLOBALS['xmlrpc_internalencoding']=self::config()->database_charset;\n        \n        \n        return $server->service($this->request->getBody(), true);\n    }\n    \n    /**\n     * Handles rendering of the preview for an object\n     * @return {string} Response to send to the object\n     */\n    public function preview() {\n        $auth=$this->request->getVar('auth');\n        $token=KapostPreviewToken::get()->filter('Code', Convert::raw2sql($auth))->first();\n        \n        //Verify the token exists and hasn't expired yet\n        if(!empty($token) && $token!==false && $token->exists() && time()-strtotime($token->Created)<self::config()->preview_expiry*60 && $token->KapostRefID==$this->urlParams['ID']) {\n            $kapostObj=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($this->urlParams['ID']))->sort('\"Created\" DESC')->first();\n            if(!empty($kapostObj) && $kapostObj!==false && $kapostObj->exists()) {\n                $previewController=$kapostObj->renderPreview();\n                \n                $this->extend('updatePreviewDisplay', $kapostObj, $previewController);\n                \n                return $previewController;\n            }\n        }\n        \n        \n        //Token expired or object not found\n        $response=ErrorPage::response_for(404);\n        if(!empty($response)) {\n            return $response;\n        }\n        \n        return parent::httpError(404);\n    }\n    \n    /**\n     * Handles RPC request methods\n     * @param {xmlrpcmsg} $request XML-RPC Request Object\n     */\n    public function handleRPCMethod(xmlrpcmsg $request) {\n        $username=$request->getParam(1)->getval();\n        $password=$request->getParam(2)->getval();\n        \n        if($this->authenticate($username, $password)) {\n            $method=str_replace(array('blogger.', 'metaWeblog.', 'kapost.'), '', $request->methodname);\n            \n            if(!in_array($request->methodname, $this->exposed_methods) || !method_exists($this, $method)) {\n                return $this->httpError(403, _t('KapostService.METHOD_NOT_ALLOWED', '_Action \"{method}\" is not allowed on class Kapost Service.', array('method'=>$request->methodname)));\n            }\n            \n            \n            //Pack params into call to method if they are not the authentication parameters\n            $params=array();\n            for($i=0;$i<$request->getNumParams();$i++) {\n                if($i!=1 && $i!=2) {\n                    $params[]=php_xmlrpc_decode($request->getParam($i));\n                }\n            }\n            \n            \n            //Convert the custom fields to an associtive array\n            if(array_key_exists(1, $params) && is_array($params[1]) && array_key_exists('custom_fields', $params[1])) {\n                $params[1]['custom_fields']=$this->struct_to_assoc($params[1]['custom_fields']);\n            }\n            \n            \n            //If transactions are supported start one for newPost and editPost\n            if(($method=='newPost' || $method=='editPost') && DB::getConn()->supportsTransactions()) {\n                DB::getConn()->transactionStart();\n            }\n            \n            \n            //Call the method\n            $response=call_user_func_array(array($this, $method), $params);\n            if($response instanceof xmlrpcresp) {\n                //If transactions are supported check the response and rollback in the case of a fault\n                if(($method=='newPost' || $method=='editPost' || $method=='newMediaObject') && DB::getConn()->supportsTransactions()) {\n                    if($response->faultCode()!=0) {\n                        DB::getConn()->transactionRollback();\n                    }else {\n                        DB::getConn()->transactionEnd();\n                    }\n                }\n                \n                return $response; //Response is already encoded so return\n            }\n            \n            //Encode the response\n            $response=php_xmlrpc_encode($response);\n            if(is_object($response) && $response instanceof xmlrpcval) {\n                $response=new xmlrpcresp($response);\n                \n                if(($method=='newPost' || $method=='editPost' || $method=='newMediaObject') && DB::getConn()->supportsTransactions()) {\n                    if($response->faultCode()!=0) {\n                        DB::getConn()->transactionRollback();\n                    }else {\n                        DB::getConn()->transactionEnd();\n                    }\n                }\n                \n                return $response;\n            }\n            \n            return $this->httpError(500, _t('KapostService.INVALID_RESPONSE', '_Invalid response returned from {method}, response was: {response}', array(\n                                                                                                                                                        'method'=>$method,\n                                                                                                                                                        'response'=>print_r($response, true)\n                                                                                                                                                    )));\n        }\n        \n        \n        return $this->httpError(401, _t('KapostService.AUTH_FAIL', '_Authentication Failed, please check the App Center credentials for the SilverStripe end point.'));\n    }\n    \n    /**\n     * Checks the authentication of the api request\n     * @param {string} $username Username to look up\n     * @param {string} $password Password to match against\n     * @return {bool} Returns boolean true if authentication passes false otherwise\n     */\n    protected function authenticate($username, $password) {\n        $authenticator=$this->config()->authenticator_class;\n        \n        $member=$authenticator::authenticate(array(\n                                                $this->config()->authenticator_username_field=>$username,\n                                                'Password'=>$password\n                                            ));\n        \n        return (!empty($member) && $member!==false && $member->exists()==true && Permission::check('KAPOST_API_ACCESS', 'any', $member));\n    }\n    \n    /**\n     * Converts an error to an xmlrpc response\n     * @param {int} $errorCode Error code number for the error\n     * @param {string} $errorMessage Error message string\n     * @return {xmlrpcresp} XML-RPC response object\n     */\n    public function httpError($errorCode, $errorMessage=null) {\n        return new xmlrpcresp(0, $errorCode+10000, $errorMessage);\n    }\n    \n    /**\n     * Gets the site config or subsites for the current site\n     * @return {array} Nested array of sites\n     */\n    protected function getUsersBlogs($app_id) {\n        if(SiteConfig::has_extension('SiteConfigSubsites')) {\n            $response=array();\n            \n            //Disable subsite filter\n            Subsite::disable_subsite_filter();\n            \n            $subsites=Subsite::get();\n            foreach($subsites as $subsite) {\n                $response[]=array(\n                                'blogid'=>$subsite->ID,\n                                'blogname'=>$subsite->Title\n                            );\n            }\n            \n            //Re-enable subsite filter\n            Subsite::disable_subsite_filter(false);\n            \n            return $response;\n        }\n        \n        \n        $siteConfig=SiteConfig::current_site_config();\n        return array(\n                    array(\n                        'blogid'=>$siteConfig->ID,\n                        'blogname'=>$siteConfig->Title\n                    )\n                );\n    }\n    \n    /**\n     * Handles creation of a new post\n     * @param {mixed} $blog_id Identifier for the current site\n     * @param {array} $content Post details\n     * @param {int} $publish 0 or 1 depending on whether to publish the post or not\n     * @param {bool} $isPreview Is preview mode or not (defaults to false)\n     */\n    protected function newPost($blog_id, $content, $publish, $isPreview=false) {\n        $results=$this->extend('newPost', $blog_id, $content, $publish, $isPreview);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        if(array_key_exists('custom_fields', $content)) {\n            //Ensure the type is an extension of the KapostPage object\n            if(!class_exists('Kapost'.$content['custom_fields']['kapost_custom_type']) || !('Kapost'.$content['custom_fields']['kapost_custom_type']=='KapostPage' || is_subclass_of('Kapost'.$content['custom_fields']['kapost_custom_type'], 'KapostPage'))) {\n                return $this->httpError(400, _t('KapostService.TYPE_NOT_KNOWN', '_The type \"{type}\" is not a known type', array('type'=>$content['custom_fields']['kapost_custom_type'])));\n            }\n            \n            $className='Kapost'.$content['custom_fields']['kapost_custom_type'];\n        }else {\n            //Assume we're creating a page and set the content as such\n            $className='KapostPage';\n        }\n        \n        \n        $pageTitle=$content['title'];\n        if(array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $pageTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        $menuTitle=$content['title'];\n        if(empty($content['title']) && array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $menuTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        $obj=new $className();\n        $obj->Title=$pageTitle;\n        $obj->MenuTitle=$menuTitle;\n        $obj->Content=(self::config()->filter_kapost_threads==true ? $this->filterKapostThreads($content['description']):$content['description']);\n        $obj->MetaDescription=(array_key_exists('custom_fields', $content) && array_key_exists('SS_MetaDescription', $content['custom_fields']) ? $content['custom_fields']['SS_MetaDescription']:null);\n        $obj->KapostChangeType='new';\n        $obj->KapostAuthor=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_author']:null);\n        $obj->KapostRefID=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_post_id']:null);\n        $obj->ToPublish=$publish;\n        $obj->IsKapostPreview=$isPreview;\n        $obj->write();\n        \n        \n        //Fallback for tests where the kapost_post_id is missing\n        if(!array_key_exists('custom_fields', $content)) {\n            $obj->KapostRefID=$className.'_'.$obj->ID;\n            $obj->write();\n        }\n        \n        \n        //Allow extensions to adjust the new page\n        $this->extend('updateNewKapostPage', $obj, $blog_id, $content, $publish, $isPreview);\n        \n        return $obj->KapostRefID;\n    }\n    \n    /**\n     * Handles editing of a given post\n     * @param {mixed} $content_id Identifier for the post\n     * @param {array} $content Post details\n     * @param {int} $publish 0 or 1 depending on whether to publish the post or not\n     * @param {bool} $isPreview Is preview mode or not (defaults to false)\n     */\n    protected function editPost($content_id, $content, $publish, $isPreview=false) {\n        $results=$this->extend('editPost', $content_id, $content, $publish, $isPreview);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        //Ensure the type is an extension of the KapostPage object\n        if(array_key_exists('custom_fields', $content) && (!class_exists('Kapost'.$content['custom_fields']['kapost_custom_type']) || !('Kapost'.$content['custom_fields']['kapost_custom_type']=='KapostPage' || is_subclass_of('Kapost'.$content['custom_fields']['kapost_custom_type'], 'KapostPage')))) {\n            return $this->httpError(400, _t('KapostService.TYPE_NOT_KNOWN', '_The type \"{type}\" is not a known type', array('type'=>$content['custom_fields']['kapost_custom_type'])));\n        }\n        \n        \n        //Assume we're looking for a page\n        //Switch Versioned to stage\n        $oldReadingStage=Versioned::current_stage();\n        Versioned::set_reading_mode('stage');\n        \n        $page=SiteTree::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        \n        //Switch Versioned back\n        Versioned::set_reading_mode($oldReadingStage);\n        \n        \n        $pageTitle=$content['title'];\n        if(array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $pageTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        $menuTitle=$content['title'];\n        if(empty($content['title']) && array_key_exists('custom_fields', $content) && array_key_exists('SS_Title', $content['custom_fields']) && !empty($content['custom_fields']['SS_Title'])) {\n            $menuTitle=$content['custom_fields']['SS_Title'];\n        }\n        \n        \n        $kapostObj=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        if(!empty($kapostObj) && $kapostObj!==false && $kapostObj->exists()) {\n            $kapostObj->Title=$pageTitle;\n            $kapostObj->MenuTitle=$menuTitle;\n            $kapostObj->Content=(self::config()->filter_kapost_threads==true ? $this->filterKapostThreads($content['description']):$content['description']);\n            $kapostObj->MetaDescription=(array_key_exists('custom_fields', $content) && array_key_exists('SS_MetaDescription', $content['custom_fields']) ? $content['custom_fields']['SS_MetaDescription']:null);\n            $kapostObj->LinkedPageID=(!empty($page) && $page!==false && $page->exists() ? $page->ID:$kapostObj->LinkedPageID);\n            $kapostObj->KapostRefID=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_post_id']:null);\n            $kapostObj->KapostAuthor=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_author']:null);\n            $kapostObj->ToPublish=$publish;\n            $kapostObj->IsKapostPreview=$isPreview;\n            $kapostObj->write();\n            \n            //Allow extensions to adjust the existing object\n            $this->extend('updateEditKapostPage', $kapostObj, $content_id, $content, $publish, $isPreview);\n            \n            return true;\n        }else {\n            $className=(array_key_exists('custom_fields', $content) ? 'Kapost'.$content['custom_fields']['kapost_custom_type']:'KapostPage');\n            \n            $obj=new $className();\n            $obj->Title=$pageTitle;\n            $obj->MenuTitle=$menuTitle;\n            $obj->Content=(self::config()->filter_kapost_threads==true ? $this->filterKapostThreads($content['description']):$content['description']);\n            $obj->MetaDescription=(array_key_exists('custom_fields', $content) && array_key_exists('SS_MetaDescription', $content['custom_fields']) ? $content['custom_fields']['SS_MetaDescription']:null);\n            $obj->KapostChangeType='edit';\n            $obj->LinkedPageID=(!empty($page) && $page!==false && $page->exists() ? $page->ID:0);\n            $obj->KapostRefID=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_post_id']:null);\n            $obj->KapostAuthor=(array_key_exists('custom_fields', $content) ? $content['custom_fields']['kapost_author']:null);\n            $obj->ToPublish=$publish;\n            $obj->IsKapostPreview=$isPreview;\n            $obj->write();\n            \n            \n            //Allow extensions to adjust the new page\n            $this->extend('updateEditKapostPage', $obj, $content_id, $content, $publish, $isPreview);\n            \n            return true;\n        }\n        \n        \n        //Can't find the object so return a 404 code\n        return new xmlrpcresp(0, 404, _t('KapostService.INVALID_POST_ID', '_Invalid post ID.'));\n    }\n    \n    /**\n     * Gets the details of a post from the system\n     * @param {mixed} $content_id ID of the post in the system\n     */\n    protected function getPost($content_id) {\n        $results=$this->extend('getPost', $content_id);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        //Switch Versioned to stage\n        $oldReadingStage=Versioned::current_stage();\n        Versioned::set_reading_mode('stage');\n        \n        $page=SiteTree::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        \n        //Switch Versioned back\n        Versioned::set_reading_mode($oldReadingStage);\n        \n        \n        if(!empty($page) && $page!==false && $page->exists()) {\n            $postMeta=array(\n                        'title'=>$page->Title,\n                        'description'=>$page->Content,\n                        'mt_keywords'=>'',\n                        'mt_excerpt'=>'',\n                        'categories'=>array('ss_page'),\n                        'permaLink'=>$page->AbsoluteLink(),\n                        'custom_fields'=>array(\n                                array('id'=>'SS_Title', 'key'=>'SS_Title', 'value'=>$page->Title),\n                                array('id'=>'SS_MetaDescription', 'key'=>'SS_MetaDescription', 'value'=>$page->MetaDescription)\n                            )\n                    );\n            \n            //Allow extensions to modify the page meta\n            $results=$this->extend('updatePageMeta', $page);\n            if(count($results)>0) {\n                for($i=0;$i<count($results);$i++) {\n                    $postMeta=$this->mergeResultArray($postMeta, $results[$i]);\n                }\n            }\n            \n            return $postMeta;\n        }else {\n            $kapostObj=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n            if(!empty($kapostObj) && $kapostObj!==false && $kapostObj->exists()) {\n                $postMeta=array(\n                            'title'=>$kapostObj->Title,\n                            'description'=>$kapostObj->Content,\n                            'mt_keywords'=>'',\n                            'mt_excerpt'=>'',\n                            'categories'=>array('ss_page'),\n                            'permaLink'=>Controller::join_links(Director::absoluteBaseURL(), 'admin/kapost/KapostObject/EditForm/field/KapostObject/item', $kapostObj->ID, 'edit'),\n                            'custom_fields'=>array(\n                                    array('id'=>'SS_Title', 'key'=>'SS_Title', 'value'=>$kapostObj->Title),\n                                    array('id'=>'SS_MetaDescription', 'key'=>'SS_MetaDescription', 'value'=>$kapostObj->MetaDescription)\n                                )\n                        );\n                \n                //Allow extensions to modify the page meta\n                $results=$this->extend('updateObjectMeta', $kapostObj);\n                if(count($results)>0) {\n                    for($i=0;$i<count($results);$i++) {\n                        $postMeta=$this->mergeResultArray($postMeta, $results[$i]);\n                    }\n                }\n                \n                return $postMeta;\n            }\n        }\n        \n        return new xmlrpcresp(0, 404, _t('KapostService.INVALID_POST_ID', '_Invalid post ID.'));\n    }\n    \n    /**\n     * Gets the categories\n     * @param {mixed} $blog_id ID of the blog\n     * @return {array} Array of categories\n     */\n    protected function getCategories($blog_id) {\n        $categories=array();\n        $pageClasses=ClassInfo::subclassesFor('SiteTree');\n        foreach($pageClasses as $class) {\n            if($class!='SiteTree') {\n                $categories[]=array(\n                                'categoryId'=>'ss_'.strtolower($class),\n                                'categoryName'=>singleton($class)->i18n_singular_name(),\n                                'parentId'=>0\n                            );\n            }\n        }\n        \n        \n        \n        $results=$this->extend('getCategories', $blog_id);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n            \n            if(count($results)>0) {\n                for($i=0;$i<count($results);$i++) {\n                    $categories=array_merge($categories, $results[$i]);\n                }\n            }\n        }\n        \n        return $categories;\n    }\n    \n    /**\n     * Handles media objects from kapost\n     * @param {mixed} $blog_id Site Config related to this content object\n     * @param {array} $content Content object to be handled\n     * @return {xmlrpcresp} XML-RPC Response object\n     */\n    protected function newMediaObject($blog_id, $content) {\n        $fileName=$content['name'];\n        $validator=new Upload_Validator(array('name'=>$fileName));\n        $validator->setAllowedExtensions(File::config()->allowed_extensions);\n        \n        //Verify we have a valid extension\n        if($validator->isValidExtension()==false) {\n            return $this->httpError(403, _t('KapostService.FILE_NOT_ALLOWED', '_File extension is not allowed'));\n        }\n        \n        \n        //Generate default filename\n        $nameFilter=FileNameFilter::create();\n        $file=$nameFilter->filter($fileName);\n        while($file[0]=='_' || $file[0]=='.') {\n            $file=substr($file, 1);\n        }\n        \n        $doubleBarrelledExts=array('.gz', '.bz', '.bz2');\n        \n        $ext=\"\";\n        if(preg_match('/^(.*)(\\.[^.]+)$/', $file, $matches)) {\n            $file=$matches[1];\n            $ext=$matches[2];\n            \n            // Special case for double-barrelled \n            if(in_array($ext, $doubleBarrelledExts) && preg_match('/^(.*)(\\.[^.]+)$/', $file, $matches)) {\n                $file=$matches[1];\n                $ext=$matches[2].$ext;\n            }\n        }\n        \n        $origFile=$file;\n        \n        \n        //Find the kapost media folder\n        $kapostMediaFolder=Folder::find_or_make($this->config()->kapost_media_folder);\n        \n        if(file_exists($kapostMediaFolder->getFullPath().'/'.$file.$ext)) {\n            if(self::config()->duplicate_assets=='overwrite') {\n                $obj=File::get()->filter('Filename', Convert::raw2sql($kapostMediaFolder->Filename.$file.$ext))->first();\n                if(!empty($obj) && $obj!==false && $obj->ID>0) {\n                    //Update the Title for the image\n                    $obj->Title=(!empty($content['alt']) ? $content['alt']:str_replace(array('-','_'), ' ', preg_replace('/\\.[^.]+$/', '', $obj->Name)));\n                    $obj->write();\n                    \n                    //Write the file to the file system\n                    $f=fopen($kapostMediaFolder->getFullPath().'/'.$file.$ext, 'w');\n                    fwrite($f, $content['bits']);\n                    fclose($f);\n                \n                    return array(\n                                'id'=>$obj->ID,\n                                'url'=>$obj->getAbsoluteURL()\n                            );\n                }\n                \n                return $this->httpError(404, _t('KapostService.FILE_NOT_FOUND', '_File not found'));\n            }else if(self::config()->duplicate_assets=='ignore') {\n                return $this->httpError(409, _t('KapostService.DUPLICATE_FILE', '_Duplicate file detected, please rename the file and try again'));\n            }else {\n                if(self::config()->duplicate_assets=='smart_rename' && file_exists($kapostMediaFolder->getFullPath().'/'.$file.$ext)) {\n                    $obj=File::get()->filter('Filename', Convert::raw2sql($kapostMediaFolder->Filename.$file.$ext))->first();\n                    if(!empty($obj) && $obj!==false && $obj->ID>0) {\n                        $fileHash=sha1_file($kapostMediaFolder->getFullPath().'/'.$file.$ext);\n                        if($fileHash==sha1($content['bits'])) {\n                            return array(\n                                        'id'=>$obj->ID,\n                                        'url'=>$obj->getAbsoluteURL()\n                                    );\n                        }\n                    }\n                }\n                \n                $i = 1;\n                while(file_exists($kapostMediaFolder->getFullPath().'/'.$file.$ext)) {\n                    $i++;\n                    $oldFile=$file;\n                     \n                    if(strpos($file, '.')!==false) {\n                        $file = preg_replace('/[0-9]*(\\.[^.]+$)/', $i.'\\\\1', $file);\n                    }else if(strpos($file, '_')!==false) {\n                        $file=preg_replace('/_([^_]+$)/', '_'.$i, $file);\n                    }else {\n                        $file.='_'.$i;\n                    }\n                    \n                    if($oldFile==$file && $i > 2) {\n                        return $this->httpError(500, _t('KapostService.FILE_RENAME_FAIL', '_Could not fix {filename} with {attempts} attempts', array('filename'=>$file.$ext, 'attempts'=>$i)));\n                    }\n                }\n                \n                //Write the file to the file system\n                $f=fopen($kapostMediaFolder->getFullPath().'/'.$file.$ext, 'w');\n                fwrite($f, $content['bits']);\n                fclose($f);\n                \n                \n                //Write the file to the database\n                $className=File::get_class_for_file_extension(substr($ext, 1));\n                $obj=new $className();\n                $obj->Name=$file.$ext;\n                $obj->Title=(!empty($content['alt']) ? $content['alt']:str_replace(array('-','_'), ' ', preg_replace('/\\.[^.]+$/', '', $obj->Name)));\n                $obj->FileName=$kapostMediaFolder->getRelativePath().'/'.$file.$ext;\n                $obj->ParentID=$kapostMediaFolder->ID;\n                \n                //If subsites is enabled add it to the correct subsite\n                if(File::has_extension('FileSubsites')) {\n                    $obj->SubsiteID=$blog_id;\n                }\n                \n                $obj->write();\n                \n                \n                $this->extend('updateNewMediaAsset', $blog_id, $content, $obj);\n                \n                \n                return array(\n                            'id'=>$obj->ID,\n                            'url'=>$obj->getAbsoluteURL()\n                        );\n            }\n        }else {\n            //Write the file to the file system\n            $f=fopen($kapostMediaFolder->getFullPath().'/'.$file.$ext, 'w');\n            fwrite($f, $content['bits']);\n            fclose($f);\n            \n            \n            //Write the file to the database\n            $className=File::get_class_for_file_extension(substr($ext, 1));\n            $obj=new $className();\n            $obj->Name=$file.$ext;\n            $obj->Title=(!empty($content['alt']) ? $content['alt']:str_replace(array('-','_'), ' ', preg_replace('/\\.[^.]+$/', '', $obj->Name)));\n            $obj->FileName=$kapostMediaFolder->getRelativePath().'/'.$file.$ext;\n            $obj->ParentID=$kapostMediaFolder->ID;\n            \n            //If subsites is enabled add it to the correct subsite\n            if(File::has_extension('FileSubsites')) {\n                $obj->SubsiteID=$blog_id;\n            }\n            \n            $obj->write();\n            \n            \n            $this->extend('updateNewMediaAsset', $blog_id, $content, $obj);\n            \n            return array(\n                        'id'=>$obj->ID,\n                        'url'=>$obj->getAbsoluteURL()\n                    );\n        }\n    }\n    \n    /**\n     * Handles rendering of the preview\n     * @param {mixed} $blog_id Identifier for the current site\n     * @param {array} $content Post details\n     * @param {mixed} $content_id Identifier for the post\n     */\n    protected function getPreview($blog_id, $content, $content_id) {\n        $results=$this->extend('getPreview', $blog_id, $content, $content_id);\n        if($results && is_array($results)) {\n            $results=array_filter($results, function($v) {return !is_null($v);});\n        \n            if(count($results)>0) {\n                return array_shift($results);\n            }\n        }\n        \n        \n        //Detect if the record already exists or not so we can decide whether to create a new record or edit an existing\n        $existing=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($content_id))->first();\n        if(!empty($existing) && $existing!==false && $existing->exists()) {\n            $resultID=$content_id;\n            \n            $this->editPost($content_id, $content, false, true);\n        }else {\n            $resultID=$this->newPost($blog_id, $content, false, true);\n            \n            //Find the object\n            $existing=KapostObject::get()->filter('KapostRefID', Convert::raw2sql($resultID))->first();\n        }\n        \n        //Make sure we got the kapost hash back or an id if we got an object back we assume that it's a response\n        if(is_object($resultID)) {\n            return $resultID;\n        }\n        \n        \n        //Generate a preview token record\n        $token=new KapostPreviewToken();\n        $token->Code=sha1(uniqid(time().$resultID));\n        $token->KapostRefID=$resultID;\n        $token->write();\n        \n        \n        //Return the details to kapost\n        return array(\n                    'url'=>Controller::join_links(Director::absoluteBaseURL(), 'kapost-service/preview', $resultID, '?auth='.$token->Code),\n                    'id'=>$resultID\n                );\n    }\n    \n    /**\n     * Converts a struct to an associtive array based on the key value pair in the struct\n     * @param {array} $struct Input struct to be converted\n     * @return {array} Associtive array matching the struct\n     */\n    final protected function struct_to_assoc($struct) {\n        $result=array();\n        foreach($struct as $item) {\n            if(array_key_exists('key', $item) && array_key_exists('value', $item)) {\n                if(array_key_exists($item['key'], $result)) {\n                    user_error('Duplicate key detected in struct entry, content overwritten by the last entry: [New: '.print_r($item, true).'] [Previous: '.print_r($result[$item['key']], true).']', E_USER_WARNING);\n                }\n                \n                $result[$item['key']]=$item['value'];\n            }else {\n                user_error('Key/Value pair not detected in struct entry: '.print_r($item, true), E_USER_NOTICE);\n            }\n        }\n        \n        return $result;\n    }\n    \n    /**\n     * Merges two arrays, overwriting the keys in the left array with the right array recurrsivly. Meaning that if a value in the right array is it self an array and the key exists in the left array it recurses into it.\n     * @param {array} $leftArray Left array to merge into\n     * @param {array} $rightArray Right array to merge from\n     * @return {array} Resulting array\n     */\n    private function mergeResultArray($leftArray, $rightArray) {\n        foreach($rightArray as $key=>$value) {\n            if(is_array($value) && array_key_exists($key, $leftArray)) {\n                $leftArray[$key]=array_merge($leftArray[$key], $value);\n            }else {\n                $leftArray[$key]=$value;\n            }\n        }\n        \n        return $leftArray;\n    }\n    \n    /**\n     * Filters the kapost content to remove the thread tags from a Kapost WYSIWYG\n     * @param {string} $html HTML to filter the tags from\n     * @return {string} HTML with tags filtered\n     */\n    public function filterKapostThreads($html) {\n        return preg_replace('/<span(\\s+)thread=\"(.*?)\"(\\s+)class=\"thread\">(.*?)<\\/span>/', '$4', $html);\n    }\n    \n    /**\n     * Finds a file record based on the url of the file, this is needed because Kapost doesn't seem to send anything back other than the url in the cms\n     * @param {string} $url Absolute url to the file\n     * @return {File} Returns the file instance representing the url, or boolean false if it's not found\n     */\n    public static function find_file_by_url($url) {\n        $url=Director::makeRelative($url);\n        if($url) {\n            $file=File::get()->filter('Filename', Convert::raw2sql($url))->first();\n            if(!empty($file) && $file!==false && $file->ID>0) {\n                return $file;\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Return a map of permission codes to add to the dropdown shown in the Security section of the CMS.\n     * @return {array} Map of permission codes\n     */\n    public function providePermissions() {\n        return array(\n                   'KAPOST_API_ACCESS'=>array(\n                                               'category'=>_t('KapostService.KAPOST_BRIDGE', '_Kapost Bridge'),\n                                               'name'=>_t('KapostService.PERMISSION_API_ACCESS', '_Kapost API Access'),\n                                               'help'=>_t('KapostService.PERMISSION_API_ACCESS_DESC', '_Access the XML-RPC Endpoint for Kapost to communicate with')\n                                           ),\n                );\n    }\n}\n?>"], "filenames": ["code/control/KapostService.php"], "buggy_code_start_loc": [124], "buggy_code_end_loc": [747], "fixing_code_start_loc": [124], "fixing_code_end_loc": [747], "type": "CWE-89", "message": "A vulnerability was found in webbuilders-group silverstripe-kapost-bridge 0.3.3. It has been declared as critical. Affected by this vulnerability is the function index/getPreview of the file code/control/KapostService.php. The manipulation leads to sql injection. The attack can be launched remotely. Upgrading to version 0.4.0 is able to address this issue. The name of the patch is 2e14b0fd0ea35034f90890f364b130fb4645ff35. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220471.", "other": {"cve": {"id": "CVE-2015-10077", "sourceIdentifier": "cna@vuldb.com", "published": "2023-02-10T15:15:11.490", "lastModified": "2023-02-16T21:24:42.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in webbuilders-group silverstripe-kapost-bridge 0.3.3. It has been declared as critical. Affected by this vulnerability is the function index/getPreview of the file code/control/KapostService.php. The manipulation leads to sql injection. The attack can be launched remotely. Upgrading to version 0.4.0 is able to address this issue. The name of the patch is 2e14b0fd0ea35034f90890f364b130fb4645ff35. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-220471."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webbuildersgroup:silverstripe-kapost-bridge:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.0", "matchCriteriaId": "DEA4A936-AE6D-4A08-A5B4-1DC2C34046A4"}]}]}], "references": [{"url": "https://github.com/webbuilders-group/silverstripe-kapost-bridge/commit/2e14b0fd0ea35034f90890f364b130fb4645ff35", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/webbuilders-group/silverstripe-kapost-bridge/releases/tag/0.4.0", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.220471", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.220471", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webbuilders-group/silverstripe-kapost-bridge/commit/2e14b0fd0ea35034f90890f364b130fb4645ff35"}}