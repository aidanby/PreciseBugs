{"buggy_code": ["1.7.1\t2019-07-26\n\t* bugfix: Manage verification paths for OpenSSL >= 1.1.0\n\t  Thanks Marco Davids\n\t* bugfix #4106: find the SDK on MacOS X <= 10.6\n\t  Thanks Bill Cole\n\t* bugfix #4155: ldns-config contains never used variables\n\t  Thanks Petr Men\u0161\u00edk\n\t* bugfix #4221: drill -x crashes with malformed IPv4 address \n\t  Thanks Oleksandr Tymoshenko\n\t* bugfix #3437: CDS & CDNSKEY RRsets should be signed with the KSK\n\t  Thanks Tony Finch\n\t* bugfix #1566, #1568, #1569, #1570: Potential NULL Dereferences\n\t  Thanks Bill Parker\n\t* bugfix #1260: Anticipate strchr returning NULL on unfound char\n\t  Thanks Stephan Zeisberg\n\t* bugfix #1257: Free after reallocing to 0 size\n\t  Thanks Stephan Zeisberg\n\t* bugfix #1256: Check parse limit before t increment\n\t  Thanks Stephan Zeisberg\n\t* bugfix #1245: Only one signature per RRset needs to be valid with\n\t  ldns-verify-zone.  Thanks Emil Natan.\n\t* ldns-notify can use all supported hash algorithms with -y.\n\t* bugfix #1209: make install ldns.pc file\n\t  Thanks Oleksandr Natalenko\n\t* bugfix #1218: Only chase DS if signer is parent of owner.\n\t  Thanks Emil Natan\n\t* bugfix #617: Retry WKS service and protocol names lower case.\n\t  Thanks Siali Yan\n\t* Spelling errors in binaries and man pages\n\t  Thanks Andreas Schulze\n\t* removed duplicate condition in ldns_udp_send_query.\n\t* ldns_wire2pkt: fix null pointer dereference if pkt allocation fails\n\t  and fix memory leak with more EDNS sections\n\t  Thanks Jan Vcelak\n\t* bugfix #1399: ldns_pkt2wire() Python binding is broken.\n\t  Thanks James Raftery\n\t* ED25519 and ED448 support. Default is to autodetect support in\n\t  OpenSSL.  Disable with --disable-ed25519 and --disable-ed448.\n\t* ldns-notify: can have IPv6 address as argument.\n\t* Fix time sensitive TSIG compare vulnerability.\n\t* Fix that ldns-testns ignores sigpipe.\n\t* Fix that ldns-notify sets the query RR as question RR, this\n\t  removes the wrong TTL and 0 rdata from the packet printout.\n\t* Allow -T flag to be used together with drill -x\n\t* Python bindings compile with swig 4.0\n\t  Thanks Jitka Plesn\u00edkov\u00e1\n\t* bugfix #4248: drill -DT fails for CNAME domain\n\t  Thanks Thom Wiggers\n\t* bugfix #4214: Various fixes and leaks found by coverity.\n\t  Thanks Petr Men\u0161\u00edk \n\t* Feature #3394: An -I option to ldns-notify to specify a source\n\t  IP address to send to notify from.  Thanks Geert Hendrickx\n\t* Bugfix #279: New API functions ldns_udp_connect2,\n\t  ldns_tcp_connect2, ldns_udp_bgsend2 and ldns_tcp_bgsend2,\n\t  that return -1 on failure and allow socket number 0\n\t  to be returned too.  Thanks Joerg Sonnenberger\n\t* Bugfix #1447: More verbose reporting of chasing problems with\n\t  ldns-verify-zone.  Thanks Stephane Guedon\n\t* OpenSSL engine support with ldns-signzone.\n\t  See also https://penzin.net/ldns-signzone/\n\t  Many thanks Vadim Penzin.\n\t* Various improvements found with shellcheck.\n\t  Thanks Jeffrey Walton\n\t* PR #36 Update manpage of ldns-notify to mention algorithm\n\t  support with TSIG.  Thanks Anand Buddhdev\n\t* Compile warnings with signed char input to to_lower()\n\t  and is_digit() with NetBSD.  Thanks H\u00e5vard Eidnes\n\t* Missing Makefile.PL in DNS-LDNS perl module contribution.\n\t  Thanks Jaap Akkerhuis\n\n1.7.0\t2016-12-20\n\t* Fix lookup of relative names in ldns_resolver_search.\n\t* bugfix #548: Double free for answers > 4096 in ldns_resolver_send_pkt\n\t* Follow CNAME's when tracing with drill (TODO dnssec trace)\n\t* Fix #551 change Regent to Copyright holder in BSD license in\n\t  some of the headings of the file, to match the opensource.org\n\t  BSD license.\n\t* -e option makes ldns-compare-zones exit with status code 2 on difference\n\t* Filter out specified RR types with ldns-read-zone -e and -E options\n\t* bugfix #563: Correct DNSKEY from DSA private key. Thanks Peter Koch.\n\t* bugfix #562: ldns-keygen match DSA key maximum size with library.\n\t  And check keysizes with all algorithms. Thanks Peter Koch.\n\t* ldns-verify-zone accepts only one single zonefile as argument.\n\t* bugfix #573: ldns-keygen write private keys with mode 0600.\n\t  Thanks Leon Weber\n\t* Fix configure to make ldns compile with LibreSSL 2.0\n\t* drill now also accepts dig style -y option\n\t  (-y <[algo:]name:key> i.s.o. -y <name:key[:algo]>)\n\t* OPENPGPKEY draft rr types. Enable with: --enable-rrtype-openpgpkey\n\t* bugfix #608: Correct comment about escaped characters\n\t* CDS and CDNSKEY rr type from RFC 7344.\n\t  --enable-rrtype-cds configure option removed\n\t* fix: Memory leak in ldns_pkt_rr_list_by_name()\n\t  Thanks Johannes Naab\n\t* fix: Memory leak in ldns_dname2buffer_wire_compress()\n\t  Thanks Max Liebkies\n\t* bugfix #613: Allow tab as whitespace too in last rdata field of types\n\t  of variable length.  Thanks Xiali Yan\n\t* bugfix: strip trailing whitespace from $ORIGIN lines in zone files\n\t* Let ldns-keygen output .ds files only for KSK keys\n\t* Parse RFC7218 TLSA mnemonics, but do not output them\n\t* Let ldns-dane use SPKI as the default selector i.s.o. Cert\n\t* bugfix: Fit left over NSEC3s once more before adding empty non\n\t  terminals.  Thanks Stuart Browne\n\t* bugfix #605: Determine default trust anchor location at compile time\n\t  Thanks Peter Koch\n\t* bugfix #697: Double free with ldns-dane create\n\t  Thanks Carsten Strotmann\n\t* bugfix #623: Do not redefine bool type and boolean values\n\t  Thanks Jakob Petsovits\n\t* bugfix #570: Add TLSA, CDS, CDNSKEY and OPENPGPKEY RR types to ldnsx\n\t  Thanks Shussain\n\t* bugfix #575: ldns_pkt_clone() does not copy timestamp field\n\t  Thanks Calle Dybedahl \n\t* bugfix #584: ldns-update fixes.  Send update to port 53, bring manpage\n\t  in sync with the usage text, and don't alter the ldns_resolver passed\n\t  to ldns_update_soa_zone_mname().  Created a ldns_resolver_clone()\n\t  function in the process.  Thanks Nicholas Riley.\n\t* bugfix #633: ldns_pkt_clone() parameter isn't const.\n\t  Thanks Jakop Petsovits\n\t* bugfix: ldns-dane manpage correction\n\t  Thanks Erwin Lansing\n\t* Spelling fixes.  Thanks Andreas Schulze\n\t* Hyphen used as minus in manpages.  Thanks Andreas Schulze.\n\t* RFC7553 RR Type URI is supported by default.\n\t* Fix ECDSA signature generation, do not omit leading zeroes.\n\t* bugfix: Get rid of superfluous newline in ldns-keyfetcher\n\t  Thanks Jan-Piet Mens\n\t* bugfix: -U option to ldns-signzone to sign with every algorithm\n\t  Thanks Guido Kroon\n\t* const function parameters whenever possible.\n\t  Thanks Ray Bellis\n\t* bugfix #725: allow RR-types on the type bitmap window border\n\t  Thanks Pieter Lexis\n\t* bugfix #726: 2 typos in drill manpage.\n\t  Thanks Hugo Lombard\n\t* Add type CSYNC support, RFC 7477.\n\t* Prepare for ED25519, ED448 support: todo convert* routines in\n\t  dnssec.h, once openssl has support for signing with these algorithms.\n\t  The dns algorithm number is not yet allocated. These features are\n\t  not fully implemented yet, openssl (1.1) does not support the\n\t  algorithms enough to generate keys and sign and verify with them.\n\t* Fix _answerfrom comment in ldns_struct_pkt.\n\t* Fix drill axfr ipv4/ipv6 queries.\n\t* Fix comment referring to mk_query in packet.h to pkt_query_new.\n\t* Fix description of QR flag in packet.h.\n\t* Fix for openssl 1.1.0 API changes.\n\t* Remove commented out macro.  Thanks Thiago Farina\n\t* bugfix #641: Include install-sh in .gitignore\n\t* bugfix #825: Module import breaks with newer SWIG versions.\n\t  Thanks Christoph Egger\n\t* bugfix #796 - #792: Fix miscellaneous compiler warning issues.\n\t  Thanks Ngie Cooper\n\t* bugfix #769: Add support for :: in an IPv6 address\n\t  Thanks Hajimu UMEMOTO\n\t* bugfix #760: Detect superfluous text in presentation format\n\t  Thanks Xiali Yan\n\t* bugfix #708: warnings and errors with xcode 6.1/7.0\n\t* bugfix #754: Memory leak in ldns_str2rdf_ipseckey\n\t  Thanks Xiali Yan\n\t* bugfix #661: Fail NSEC3 signing when NSEC domainname length\n\t  would overflow.  Thanks Jan-Piet Mens.\n\t* bugfix #771: hmac-sha224, hmac-sha384 and hmac-sha512 keys.\n\t  Thanks Harald Jenny\n\t* bugfix #680: ldns fails to reject invalidly formatted\n\t  RFC 7553 URI RRs.  Thanks Robert Edmonds\n\t* bugfix #678: Use poll i.s.o. select to support > 1024 fds\n\t  Thanks William King\n\t* Use OpenSSL DANE functions for verification (unless explicitly\n\t  disabled with --disable-dane-ta-usage).\n\t* Bumb .so version\n\t* Include OPENPGPKEY RR type by default\n\t* rdata processing for SMIMEA RR type\n\t* Fix crash in displaying TLSA RR's.\n\t  Thanks Andreas Schulze\n\t* Update ldns-key2ds man page to mention GOST and SHA384 hash\n\t  functions.  Thanks Harald Jenny\n\t* Add sha384 and sha512 tsig algorithm. Thanks Michael Weiser\n\t* Clarify data ownership with consts for tsig parameters.\n\t  Thanks Michael Weiser\n\t* bugfix: Fix detection of DSA support with OpenSSL >= 1.1.0\n\t* bugfix #1160: Provide sha256 for release tarballs\n\t* --enable-gost-anyway compiles GOST support with OpenSSL >= 1.1.0\n\t  even when the GOST engine is not available.\n\n1.6.17\t2014-01-10\n\t* Fix ldns_dnssec_zone_new_frm_fp_l to allow the last parsed line of a\n\t  zone to be an NSEC3 (or its RRSIG) covering an empty non terminal.\n\t* Add --disable-dane option to configure and check availability of the\n\t  for dane needed X509_check_ca function in openssl.\n\t* bugfix #490: Get rid of type-punned pointer warnings.\n\t  Thanks Adam Tkac.\n\t* Make sure executables are linked against libcrypto with the \n\t  LIBSSL_LDFLAGS. Thanks Leo Baltus.\n\t* Miscellaneous prototype fixes. Thanks Dag-Erling Sm\u00f8rgrav.\n\t* README now shows preferred way to configure for examples and drill.\n\t* Bind to source address for resolvers. drill binds to source with -I.\n\t  Thanks Bryan Duff.\n\t* -T option for ldns-dane that has specific exit status for PKIX\n\t  validated connections without (secure) TLSA records.\n\t* Fix b{32,64}_{ntop,pton} detection and handling.\n\t* New RR type TKEY, but without operational practice.\n\t* New RR types HIP, NINFO, RKEY, CDS, EUI48, EUI64, URI, CAA and TA.\n\t* New output format flag (and accompanying functions) to print certain\n\t  RR's as unknown type\n\t* -u and -U parameter for ldns-read-zone to mark/unmark a RR type\n\t  for printing as unknown type\n\t* bugfix #504: GPOS RR has three rdata fields. Thanks Jelte Jansen.\n\t* bugfix #497: Properly test for EOF when reading key files with drill.\n\t* New functions: ldns_pkt_ixfr_request_new and\n\t  ldns_pkt_ixfr_request_new_frm_str.\n\t* Use SNI with ldns-dane\n\t* bugfix #507: ldnsx Fix use of non-existent variables and not\n\t  properly referring to instance variable.  Patch from shussain.\n\t* bugfix #508: ldnsx Adding NSEC3PARAM to known/allowable RR type\n\t  dictionary.  Patch from shussain.\n\t* bugfix #517: ldns_resolver_new_frm_fp error when invoked using a NULL\n\t  file pointer.\n\t* Fix memory leak in contrib/python: ldns_pkt.new_query.\n\t* Fix buffer overflow in fget_token and bget_token.\n\t* ldns-verify-zone NSEC3 checking from quadratic to linear performance.\n\t  Thanks NIC MX (nicmexico.mx)\n\t* ldns-dane setup new ssl session for each new connect to prevent hangs\n\t* bugfix #521: drill trace continue on empty non-terminals with NSEC3\n\t* bugfix #525: Fix documentation of ldns_resolver_set_retry\n\t* Remove unused LDNS_RDF_TYPE_TSIG and associated functions.\n\t* Fix ldns_nsec_covers_name for zones with an apex only. Thanks Miek.\n\t* Configure option to build perl bindings: --with-p5-dns-ldns\n\t  (DNS::LDNS is a contribution from Erik Ostlyngen)\n\t* bugfix #527: Move -lssl before -lcrypto when linking\n\t* Optimize TSIG digest function name comparison (Thanks Marc Buijsman)\n\t* Compare names case insensitive with ldns_pkt_rr_list_by_name and\n\t  ldns_pkt_rr_list_by_name_and_type (thanks Johannes Naab)\n\t* A separate --enable for each draft RR type: --enable-rrtype-ninfo,\n\t  --enable-rrtype-rkey, --enable-rrtype-cds, --enable-rrtype-uri and\n\t  --enable-rrtype-ta\n\t* bugfix #530: Don't sign and verify duplicate RRs (Thanks Jelte Jansen)\n\t* bugfix #505: Manpage and usage output fixes (Thanks Tomas Hozza)\n\t* Adjust ldns_sha1() so that the input data is not modified (Thanks\n\t  Marc Buijsman)\n\t* Messages to stderr are now off by default and can be reenabled with\n\t  the --enable-stderr-msgs configure option.\n\n1.6.16\t2012-11-13\n\t* Fix Makefile to build pyldns with BSD make\n\t* Fix typo in exporting b32_* symbols to make pyldns load again\n\t* Allow leaving the RR owner name empty in ldns-testns datafiles.\n\t* Fix fail to create NSEC3 bitmap for empty non-terminal (bug\n\t  introduced in 1.6.14).\n\n1.6.15\t2012-10-25\n\t* Remove LDNS_STATUS_EXISTS_ERR from ldns/error.h to make ldns\n\t  binary compatible with earlier releases again.\n\n1.6.14\t2012-10-23\n\t* DANE support (RFC6698), including ldns-dane example tool.\n\t* Configurable default CA certificate repository for ldns-dane with\n\t  --with-ca-file=CAFILE and --with-ca-path=CAPATH\n\t* Configurable default trust anchor with --with-trust-anchor=FILE\n\t  for drill, ldns-verify-zone and ldns-dane\n\t* bugfix #474: Define socklen_t when undefined (like in Win32)\n\t* bugfix #473: Dead code removal and resource leak fix in drill\n\t* bugfix #471: Let ldns_resolver_push_dnssec_anchor accept DS RR's too.\n\t* Various bugfixes from code reviews from CZ.NIC and Paul Wouters\n\t* ldns-notify TSIG option argument checking\n\t* Let ldns_resolver_nameservers_randomize keep nameservers and rtt's\n\t  in sync.\n\t* Let ldns_pkt_push_rr now return false on (memory) errors.\n\t* Make buffer_export comply to documentation and fix buffer2str\n\t* Various improvements and fixes of pyldns from Katel Slany\n\t  now documented in their own Changelog.\n\t* bugfix: Make ldns_resolver_pop_nameserver clear the array when\n\t  there was only one.\n\t* bugfix #459: Remove ldns_symbols and export symbols based on regex\n\t* bugfix #458: Track all newly created signatures when signing.\n\t* bugfix #454: Only set -g and -O2 CFLAGS when no CFLAGS was given.\n\t* bugfix #457: Memory leak fix for ldns_key_new_frm_algorithm.\n\t* pyldns memory handling fixes and the python3/ldns-signzone.py\n\t  examples script contribution from Karel Slany.\n\t* bugfix #450: Base # bytes for P, G and Y (T) on the guaranteed\n\t  to be bigger (or equal) P in ldns_key_dsa2bin.\n\t* bugfix #449: Deep free cloned rdf's in ldns_tsig_mac_new.\n\t* bugfix #448: Copy nameserver value (in stead of reference) of the\n\t  answering nameserver to the answer packet in ldns_send_buffer, so\n\t  the original value may be deep freed with the ldns_resolver struct.\n\t* New -0 option for ldns-read-zone to replace inception, expiration\n\t  and signature rdata fields with (null). Thanks Paul Wouters.\n\t* New -p option for ldns-read-zone to prepend-pad SOA serial to take\n\t  up ten characters.\n\t* Return error if printing RR fails due to unknown/null RDATA.\n\n1.6.13\t2012-05-21\n\t* New -S option for ldns-verify-zone to chase signatures online.\n\t* New -k option for ldns-verify-zone to validate using a trusted key.\n\t* New inception and expiration margin options (-i and -e) to \n\t  ldns-verify-zone.\n\t* New ldns_dnssec_zone_new_frm_fp and ldns_dnssec_zone_new_frm_fp_l\n\t  functions.\n\t* New ldns_duration* functions (copied from OpenDNSSEC source)\n\t* fix ldns-verify-zone to allow NSEC3 signatures to come before\n\t  the NSEC3 RR in all cases. Thanks Wolfgang Nagele.\n\t* Zero the correct flag (opt-out) when creating NSEC3PARAMS.\n\t  Thanks Peter van Dijk.\n\t* Canonicalize RRSIG's Signer's name too when validating, because \n\t  bind and unbound do that too. Thanks Peter van Dijk.\n\t* bugfix #433: Allocate rdf using ldns_rdf_new in ldns_dname_label\n\t* bugfix #432: Use LDNS_MALLOC & LDNS_FREE i.s.o. malloc & free\n\t* bugfix #431: Added error message for LDNS_STATUS_INVALID_B32_EXT\n\t* bugfix #427: Explicitely link ssl with the programs that use it.\n\t* Fix reading \\DDD: Error on values that are outside range (>255).\n\t* bugfix #429: fix doxyparse.pl fails on NetBSD because specified\n\t  path to perl.\n\t* New ECDSA support (RFC 6605), use --disable-ecdsa for older openssl.\n\t* fix verifying denial of existence for DS's in NSEC3 Opt-Out zones.\n\t  Thanks John Barnitz\n\n1.6.12\t2012-01-11\n\t* bugfix #413: Fix manpage source for srcdir != builddir\n\t* Canonicalize the signers name rdata field in RRSIGs when signing\n\t* Ignore minor version of Private-key-format (so v1.3 may be used)\n\t* Allow a check_time to be given in stead of always checking against\n\t  the current time. With ldns-verify-zone the check_time can be set\n\t  with the -t option.\n\t* Added functions for updating and manipulating SOA serial numbers.\n\t  ldns-read-zone has an option -S for updating and manipulating the\n\t  serial numbers.\n\t* The library Makefile is now GNU and BSD make compatible.\n\t* bugfix #419: NSEC3 validation of a name covered by a wildcard with\n\t  no data.\n\t* Two new options (--with-drill and --with-examples) to the main\n\t  configure script (in the root of the source tree) to build drill\n\t  and examples too.\n\t* Fix days_since_epoch to year_yday calculation on 32bits systems.\n\n1.6.11\t2011-09-29\n\t* bugfix #394: Fix socket leak on errors\n\t* bugfix #392: Apex only and percentage checks for ldns-verify-zone\n\t  (thanks Miek Gieben)\n\t* bugfix #398: Allow NSEC RRSIGs before the NSEC3 in ldns-verify-zone\n\t* Fix python site package path from sitelib to sitearch for pyldns.\n\t* Fix python api to support python2 and python3 (thanks Karel Slany).\n\t* bugfix #401: Correction of date/time functions algorithm and\n\t  prevention of an infinite loop therein\n\t* bugfix #402: Correct the minimum and maximum number of rdata fields\n\t  in TSIG. (thanks David Keeler)\n\t* bugfix #403: Fix heap overflow (thanks David Keeler)\n\t* bugfix #404: Make parsing APL strings more robust\n\t  (thanks David Keeler)\n\t* bugfix #391: Complete library assessment to prevent assertion errors\n\t  through ldns_rdf_size usage.\n\t* Slightly more specific error messaging on wrong number of rdata\n\t  fields with the LDNS_STATUS_MISSING_RDATA_FIELDS_RRSIG and\n\t  LDNS_STATUS_MISSING_RDATA_FIELDS_KEY result codes.\n\t* bugfix #406: More rigorous openssl result code handling to prevent\n\t  future crashes within openssl.\n\t* Fix ldns_fetch_valid_domain_keys to search deeper than just one level\n\t  for a DNSKEY that signed a DS RR. (this function was used in the\n\t  check_dnssec_trace nagios module)\n\t* bugfix #407: Canonicalize TSIG dnames and algorithm fields\n\t* A new output specifier to accommodate configuration of what to show\n\t  in comment texts when converting host and/or wire-format data to\n\t  string. All conversion to string and printing functions have a new\n\t  version that have such a format specifier as an extra argument.\n\t  The default is changed so that only DNSKEY RR's are annotated with\n\t  an comment show the Key Tag of the DNSKEY.\n\t* Fixed the ldns resolver to not mark a nameserver unreachable when\n\t  edns0 is tried unsuccessfully with size 4096 (no return packet came),\n\t  but to still try TCP. A big UDP packet might have been corrupted by\n\t  fragments dropping firewalls.\n\t* Update of libdns.vim (thanks Miek Gieben)\n\t* Added the ldnsx Python module to our contrib section, which adds even\n\t  more pythonisticism to the usage of ldns with  Python. (Many thanks\n\t  to Christpher Olah and Paul Wouters)\n\t  The ldnsx module is automatically installed when --with-pyldns is\n\t  used with configuring, but may explicitly be excluded with the\n\t  --without-pyldnsx option to configure.\n\t* bugfix #410: Fix clearing out temporary data on stack in sha2.c\n\t* bugfix #411: Don't let empty non-terminal NSEC3s cause assertion failure.\n\n1.6.10\t2011-05-31\n\t* New example tool added: ldns-gen-zone.\n\t* bugfix #359: Serial-arithmetic for the inception and expiration\n\t  fields of a RRSIG and correctly converting them to broken-out time\n\t  information.\n\t* bugfix #364: Slight performance increase of ldns-verifyzone.\n\t* bugfix #367: Fix to allow glue records with the same name as the\n\t  delegation.\n\t* Fix ldns-verifyzone to allow NSEC3-less records for NS rrsets *and*\n\t  glue when the zone is opt-out.\n\t* bugfix #376: Adapt ldns_nsec3_salt, ldns_nsec3_iterations,\n\t  ldns_nsec3_flags and ldns_nsec3_algorithm to work for NSEC3PARAMS too.\n\t* pyldns memory leaks fixed by Bedrich Kosata (at the cost of a bit\n\t  performance)\n\t* Better handling of reference variables in ldns_rr_new_frm_fp_l from\n\t  pyldns, with a very nice generator function by Bedrich Kosata.\n\t* Decoupling of the rdfs in rrs in the python wrappers to enable\n\t  the python garbage collector by Bedrich Kosata.\n\t* bugfix #380: Minimizing effect of discrepancies in sizeof(bool) at\n\t  build time and when used.\n\t* bugfix #383: Fix detection of empty nonterminals of multiple labels.\n\t* Fixed the ommission of rrsets in nsec(3)s and rrsigs to all occluded\n\t  names (in stead of just the ones that contain glue only) and all\n\t  occluded records on the delegation points (in stead of just the glue).\n\t* Clarify the operation of ldns_dnssec_mark_glue and the usage of\n\t  ldns_dnssec_node_next_nonglue functions in the documentation.\n\t* Added function ldns_dnssec_mark_and_get_glue as an real fast\n\t  alternative for ldns_zone_glue_rr_list.\n\t* Fix parse buffer overflow for max length domain names.\n\t* Fix Makefile for U in environment, since wrong U is more common than\n\t  deansification necessity.\n\n1.6.9\t2011-03-16\n\t* Fix creating NSEC(3) bitmaps: make array size 65536,\n\t  don't add doubles.\n\t* Fix printout of escaped binary in TXT records.\n\t* Parsing TXT records: don't skip starting whitespace that is quoted.\n\t* bugfix #358: Check if memory was successfully allocated in\n\t  ldns_rdf2str().\n\t* Added more memory allocation checks in host2str.c\n\t* python wrapper for ldns_fetch_valid_domain_keys by Bedrich Kosata.\n\t* fix to compile python wrapper with swig 2.0.2.\n\t* Don't fallback to SHA-1 when creating NSEC3 hash with another\n\t  algorithm identifier, fail instead (no other algorithm identifiers\n\t  are assigned yet).\n\n1.6.8\t2011-01-24\n\t* Fix ldns zone, so that $TTL definition match RFC 2308.\n\t* Fix lots of missing checks on allocation failures and parse of\n\t  NSEC with many types and max parse length in hosts_frm_fp routine\n\t  and off by one in read_anchor_file routine (thanks Dan Kaminsky and\n\t  Justin Ferguson).\n\t* bugfix #335: Drill: Print both SHA-1 and SHA-256 corresponding DS\n\t  records.\n\t* Print correct WHEN in query packet (is not always 1-1-1970)\n\t* ldns-test-edns: new example tool that detects EDNS support.\n\t* fix ldns_resolver_send without openssl.\n\t* bugfix #342: patch for support for more CERT key types (RFC4398).\n\t* bugfix #351: fix udp_send hang if UDP checksum error.\n\t* fix set_bit (from NSEC3 sign) patch from Jan Komissar.\n\n1.6.7\t2010-11-08\n\t* EXPERIMENTAL ecdsa implementation, please do not enable on real\n\t  servers.\n\t* GOST code enabled by default (RFC 5933).\n\t* bugfix #326: ignore whitespace between directives and their values.\n\t* Header comment to advertise ldns_axfr_complete to check for\n\t  successfully completed zone transfers.\n\t* read resolv.conf skips interface labels, e.g. %eth0.\n\t* Fix drill verify NSEC3 denials.\n\t* Use closesocket() on windows.\n\t* Add ldns_get_signing_algorithm_by_name that understand aliases,\n\t  names changed to RFC names and aliases for compatibility added.\n\t* bugfix: don't print final dot if the domain is relative.\n\t* bugfix: resolver search continue when packet rcode != NOERROR.\n\t* bugfix: resolver push all domains in search directive to list.\n\t* bugfix: resolver search by default includes the root domain.\n\t* bugfix: tcp read could fail on single octet recv.\n\t* bugfix: read of RR in unknown syntax with missing fields.\n\t* added ldns_pkt_tsig_sign_next() and ldns_pkt_tsig_verify_next()\n\t  to sign and verify TSIG RRs on subsequent messages\n\t  (section 4.4, RFC 2845, thanks to Michael Sheldon).\n\t* bugfix: signer sigs nsecs with zsks only.\n\t* bugfix #333: fix ldns_dname_absolute for name ending with backslash.\n\n1.6.6\t2010-08-09\n\t* Fix ldns_rr_clone to copy question rrs properly.\n\t* Fix ldns_sign_zone(_nsec3) to clone the soa for the new zone.\n\t* Fix ldns_wire2dname size check from reading 1 byte beyond buffer end.\n\t* Fix ldns_wire2dname from reading 1 byte beyond end for pointer.\n\t* Fix crash using GOST for particular platform configurations.\n\t* extern C declarations used in the header file.\n\t* Removed debug fprintf from resolver.c.\n\t* ldns-signzone checks if public key file is for the right zone.\n\t* NETLDNS, .NET port of ldns functionality, by Alex Nicoll, in contrib.\n\t* Fix handling of comments in resolv.conf parse.\n\t* GOST code enabled if SSL recent, RFC 5933.\n\t* bugfix #317: segfault util.c ldns_init_random() fixed.\n\t* Fix ldns_tsig_mac_new: allocate enough memory for the hash, fix use of\n\t  b64_pton_calculate_size.\n\t* Fix ldns_dname_cat: size calculation and handling of realloc().\n\t* Fix ldns_rr_pop_rdf: fix handling of realloc().\n\t* Fix ldns-signzone for single type key scheme: sign whole zone if there\n\t  are only KSKs.\n\t* Fix ldns_resolver: also close socket if AXFR failed (if you don't,\n          it would block subsequent transfers (thanks Roland van Rijswijk).\n        * Fix drill: allow for a secure trace if you use DS records as trust\n\t  anchors (thanks Jan Komissar).\n\n1.6.5\t2010-06-15\n\t* Catch \\X where X is a digit as an error.\n\t* Fix segfault when ip6 ldns resolver only has ip4 servers.\n\t* Fix NSEC record after DNSKEY at zone apex not properly signed.\n\t* Fix syntax error if last label too long and no dot at end of domain.\n\t* Fix parse of \\# syntax with space for type LOC.\n\t* Fix ldns_dname_absolute for escape sequences, fixes some parse errs.\n\t* bugfix #297: linking ssl, bug due to patch submitted as #296.\n\t* bugfix #299: added missing declarations to host2str.h\n\t* ldns-compare-zones -s to not exclude SOA record from comparison.\n\t* --disable-rpath fix\n\t* fix ldns_pkt_empty(), reported by Alex Nicoll.\n\t* fix ldns_resolver_new_frm_fp not ignore lines after a comment.\n\t* python code for ldns_rr.new_question_frm_str()\n\t* Fix ldns_dnssec_verify_denial: the signature selection routine.\n\t* Type TALINK parsed (draft-ietf-dnsop-trust-history).\n\t* bugfix #304: fixed dead loop in ldns_tcp_read_wire() and\n\t  ldns_tcp_read_wire_timeout().\n\t* GOST support with correct algorithm numbers.  The plan is to make it\n\t  enabled if openssl support is detected, but it is disabled by\n\t  default in this release because the RFC is not ready.\n\t* Fixed comment in rbtree.h about being first member and data ptr.\n\t* Fixed possibly leak in case of out of memory in ldns_native2rdf...\n\t* ldns_dname_is_wildcard added.\n\t* Fixed: signatures over wildcards had the wrong labelcount.\n\t* Fixed ldns_verify() inconsistent return values.\n\t* Fixed ldns_resolver to copy and free tsig name, data and algorithm.\n\t* Fixed ldns_resolver to push search onto searchlist.\n\t* A ldns resolver now defaults to a non-recursive resolver that handles\n\t  the TC bit.\n\t* ldns_resolver_print() prints more details.\n\t* Fixed ldns_rdf2buffer_str_time(), which did not print timestamps\n\t  on 64bit systems.\n\t* Make ldns_resolver_nameservers_randomize() more random.\n\t* bugfix #310: POSIX specifies NULL second argument of gettimeofday.\n\t* fix compiler warnings from llvm clang compiler.\n\t* bugfix #309: ldns_pkt_clone did not clone the tsig_rr.\n\t* Fix gentoo ebuild for drill, 'no m4 directory'.\n\t* bugfix #313: drill trace on an empty nonterminal continuation.\n\n1.6.4\t2010-01-20\n\t* Imported pyldns contribution by Zdenek Vasicek and Karel Slany.\n\t  Changed its configure and Makefile to fit into ldns.\n\t  Added its dname_* methods to the rdf_* class (as is the ldns API).\n\t  Changed swig destroy of ldns_buffer class to ldns_buffer_free.\n\t  Declared ldns_pkt_all and ldns_pkt_all_noquestion so swig sees them.\n\t* Bugfix: parse PTR target of .tomhendrikx.nl with error not crash.\n\t* Bugfix: handle escaped characters in TXT rdata.\n\t* bug292: no longer crash on malformed domain names where a label is\n\t  on position 255, which was a buffer overflow by one.\n\t* Fix ldns_get_rr_list_hosts_frm_fp_l (strncpy to strlcpy change),\n\t  which fixes resolv.conf reading badly terminated string buffers.\n\t* Fix ldns_pkt_set_random_id to be more random, and a little faster,\n\t  it did not do value 0 statistically correctly.\n\t* Fix ldns_rdf2native_sockaddr_storage to set sockaddr type to zeroes,\n\t  for portability.\n\t* bug295: nsec3-hash routine no longer case sensitive.\n\t* bug298: drill failed nsec3 denial of existence proof.\n\n1.6.3\t2009-12-04\n\t* Bugfix: allow for unknown resource records in zonefile with rdlen=0.\n\t* Bugfix: also mark an RR as question if it comes from the wire\n\t* Bugfix: NSEC3 bitmap contained NSEC\n\t* Bugfix: Inherit class when creating signatures\n\n1.6.2\t2009-11-12\n\t* Fix Makefile patch from Havard Eidnes, better install.sh usage.\n\t* Fix parse error on SOA serial of 2910532839.\n\t  Fix print of ';' and readback of '\\;' in names, also for '\\\\'.\n\t  Fix parse of '\\(' and '\\)' in names.  Also for file read. Also '\\.'\n\t* Fix signature creation when TTLs are different for RRs in RRset.\n\t* bug273: fix so EDNS rdata is included in pkt to wire conversion.\n\t* bug274: fix use of c++ keyword 'class' for RR class in the code.\n\t* bug275: fix memory leak of packet edns rdata.\n\t* Fix timeout procedure for TCP and AXFR on Solaris.\n\t* Fix occasional NSEC bitmap bogus\n\t* Fix rr comparing (was in reversed order since 1.6.0)\n\t* bug278: fix parsing HINFO rdata (and other cases).\n\t* Fix previous owner name: also pick up if owner name is @.\n\t* RFC5702: enabled sha2 functions by default. This requires OpenSSL 0.9.8 or higher.\n      Reason for this default is the root to be signed with RSASHA256.\n\t* Fix various LDNS RR parsing issues: IPSECKEY, WKS, NSAP, very long lines\n\t* Fix: Make ldns_dname_is_subdomain case insensitive.\n\t* Fix ldns-verify-zone so that address records at zone NS set are not considered glue\n\t\t(Or glue records fall below delegation)\n    * Fix LOC RR altitude printing.\n\t* Feature: Added period (e.g. '3m6d') support at explicit TTLs.\n    * Feature: DNSKEY rrset by default signed with minimal signatures\n\t\tbut -A option for ldns-signzone to sign it with all keys.\n\t\tThis makes the DNSKEY responses smaller for signed domains.\n\n1.6.1   2009-09-14\n\t* --enable-gost : use the GOST algorithm (experimental).\n\t* Added some missing options to drill manpage\n\t* Some fixes to --without-ssl option\n\t* Fixed quote parsing withing strings\n\t* Bitmask fix in EDNS handling\n\t* Fixed non-fqdn domain name completion for rdata field domain\n\t  names of length 1\n\t* Fixed chain validation with SHA256 DS records\n\n1.6.0\n\tAdditions:\n\t* Addition of an ldns-config script which gives cflags and libs\n\t  values, for use in configure scripts for applications that use\n\t  use ldns. Can be disabled with ./configure --disable-ldns-config\n\t* Added direct sha1, sha256, and sha512 support in ldns.\n\t  With these functions, all NSEC3 functionality can still be\n\t  used, even if ldns is built without OpenSSL. Thanks to OpenBSD,\n\t  Steve Reid, and Aaron D. Gifford for the code.\n\t* Added reading/writing support for the SPF Resource Record\n\t* Base32 functions are now exported\n\tBugfixes:\n\t* ldns_is_rrset did not go through the complete rrset, but\n\t  only compared the first two records. Thanks to Olafur\n\t  Gudmundsson for report and patch\n\t* Fixed a small memory bug in ldns_rr_list_subtype_by_rdf(),\n\t  thanks to Marius Rieder for finding an patching this.\n\t* --without-ssl should now work. Make sure that examples/ and\n\t  drill also get the --without-ssl flag on their configure, if\n\t  this is used.\n\t* Some malloc() return value checks have been added\n\t* NSEC3 creation has been improved wrt to empty nonterminals,\n\t  and opt-out.\n\t* Fixed a bug in the parser when reading large NSEC3 salt\n\t  values.\n\t* Made the allowed length for domain names on wire\n\t  and presentation format the same.\n\tExample tools:\n\t* ldns-key2ds can now also generate DS records for keys without\n\t  the SEP flag\n\t* ldns-signzone now equalizes the TTL of the DNSKEY RRset (to\n\t  the first non-default DNSKEY TTL value it sees)\n\n1.5.1\n\tExample tools:\n\t* ldns-signzone was broken in 1.5.0 for multiple keys, this\n\t  has been repaired\n\n\tBuild system:\n\t* Removed a small erroneous output warning in\n\t  examples/configure and drill/configure\n\n1.5.0\n\tBug fixes:\n\t* fixed a possible memory overflow in the RR parser\n\t* build flag fix for Sun Studio\n\t* fixed a building race condition in the copying of header\n\t  files\n\t* EDNS0 extended rcode; the correct assembled code number\n\t  is now printed (still in the EDNS0 field, though)\n\t* ldns_pkt_rr no longer leaks memory (in fact, it no longer\n\t  copies anything all)\n\n\tAPI addition:\n\t* ldns_key now has support for 'external' data, in which\n\t  case the OpenSSL EVP structures are not used;\n\t  ldns_key_set_external_key() and ldns_key_external_key()\n\t* added ldns_key_get_file_base_name() which creates a\n\t  'default' filename base string for key storage, of the\n\t  form \"K<zone>+<algorithm>+<keytag>\"\n\t* the ldns_dnssec_* family of structures now have deep_free()\n\t  functions, which also free the ldns_rr's contained in them\n\t* there is now an ldns_match_wildcard() function, which checks\n\t  whether a domain name matches a wildcard name\n\t* ldns_sign_public has been split up; this resulted in the\n\t  addition of ldns_create_empty_rrsig() and\n\t  ldns_sign_public_buffer()\n\n\tExamples:\n\t* ldns-signzone can now automatically add DNSKEY records when\n\t  using an OpenSSL engine, as it already did when using key\n\t  files\n\t* added new example tool: ldns-nsec3-hash\n\t* ldns-dpa can now filter on specific query name and types\n\t* ldnsd has fixes for the zone name, a fix for the return\n\t  value of recvfrom(), and an memory initialization fix\n\t  (Thanks to Colm MacC\u00e1rthaigh for the patch)\n\t* Fixed memory leaks in ldnsd\n\n\n\n1.4.1\n\tBug fixes:\n\t* fixed a build issue where ldns lib existence was done too early\n\t* removed unnecessary check for pcap.h\n\t* NSEC3 optout flag now correctly printed in string output\n\t* inttypes.h moved to configured inclusion\n\t* fixed NSEC3 type bitmaps for empty nonterminals and unsigned\n\t  delegations\n\n\tAPI addition:\n\t* for that last fix, we added a new function\n\t  ldns_dname_add_from() that can clone parts of a dname\n\n1.4.0\n\tBug fixes:\n\t* sig chase return code fix (patch from Rafael Justo, bug id 189)\n\t* rdata.c memory leaks on error and allocation checks fixed (patch\n\t  from Shane Kerr, bug id 188)\n\t* zone.c memory leaks on error and allocation checks fixed (patch\n\tfrom Shane Kerr, bug id 189)\n\t* ldns-zplit output and error messages fixed (patch from Shane Kerr,\n\t  bug id 190)\n\t* Fixed potential buffer overflow in ldns_str2rdf_dname\n\t* Signing code no longer signs delegation NS rrsets\n\t* Some minor configure/makefile updates\n\t* Fixed a bug in the randomness initialization\n\t* Fixed a bug in the reading of resolv.conf\n\t* Fixed a bug concerning whitespace in zone data (with patch from Ondrej\n\t  Sury, bug 213)\n\t* Fixed a small fallback problem in axfr client code\n\n\tAPI CHANGES:\n\t* added 2str convenience functions:\n\t\t- ldns_rr_type2str\n\t\t- ldns_rr_class2str\n\t\t- ldns_rr_type2buffer_str\n\t\t- ldns_rr_class2buffer_str\n\t* buffer2str() is now called ldns_buffer2str\n\t* base32 and base64 function names are now also prepended with ldns_\n\t* ldns_rr_new_frm_str() now returns an error on missing RDATA fields.\n\t  Since you cannot read QUESTION section RRs with this anymore,\n\t  there is now a function called ldns_rr_new_question_frm_str()\n\n\tLIBRARY FEATURES:\n\t* DS RRs string representation now add bubblebabble in a comment\n\t  (patch from Jakob Schlyter)\n\t* DLV RR type added\n\t* TCP fallback system has been improved\n\t* HMAC-SHA256 TSIG support has been added.\n\t* TTLS are now correcly set in NSEC(3) records when signing zones\n\n\tEXAMPLE TOOLS:\n\t* New example: ldns-revoke to revoke DNSKEYs according to RFC5011\n\t* ldns-testpkts has been fixed and updated\n\t* ldns-signzone now has the option to not add the DNSKEY\n\t* ldns-signzone now has an (full zone only) opt-out option for\n\t                NSEC3\n\t* ldns-keygen can create HMAC-SHA1 and HMAC-SHA256 symmetric keys\n\t* ldns-walk output has been fixed\n\t* ldns-compare-zones has been fixed, and now has an option\n\t  to show all differences (-a)\n\t* ldns-read-zone now has an option to print DNSSEC records only\n\n1.3\n\tBase library:\n\n\t* Added a new family of functions based around ldns_dnssec_zone,\n\twhich is a new structure that keeps a zone sorted through an\n\trbtree and links signatures and NSEC(3) records directly to their\n\tRRset. These functions all start with ldns_dnssec_\n\n\t* ldns_zone_sign and ldns_zone_sign_nsec3 are now deprecated, but\n\thave been changed to internally use the new\n\tldns_dnssec_zone_sign(_nsec3)\n\n\t* Moved some ldns_buffer functions inline, so a clean rebuild of\n\tapplications relying on those is needed (otherwise you'll get\n\tlinker errors)\n\t* ldns_dname_label now returns one extra (zero)\n\tbyte, so it can be seen as an fqdn.\n\t* NSEC3 type code update for signing algorithms.\n\t* DSA key generation of DNSKEY RRs fixed (one byte too small).\n\n\t* Added support for RSA/SHA256 and RSA/SHA512, as specified in\n\tdraft-ietf-dnsext-dnssec-rsasha256-04. The typecodes are not\n\tfinal, and this feature is not enabled by default. It can be\n\tenabled at compilation time with the flag --with-sha2\n\n\t* Added 2wire_canonical family of functions that lowercase dnames\n\tin rdata fields in resource records of the types in the list in\n\trfc3597\n\n\t* Added base32 conversion functions.\n\n\t* Fixed DSA RRSIG conversion when calling OpenSSL\n\n\tDrill:\n\n\t* Chase output is completely different, it shows, in ascii, the\n\trelations in the trust hierarchy.\n\n\tExamples:\n\t* Added ldns-verify-zone, that can verify the internal DNSSEC records\n\tof a signed BIND-style zone file\n\n\t* ldns-keygen now takes an -a argument specifying the algorithm,\n\tinstead of -R or -D. -a list show a list of supported algorithms\n\n\t* ldns-keygen now defaults to the exponent RSA_F4 instead of RSA_3\n\tfor RSA key generation\n\n\t* ldns-signzone now has support for HSMs\n\t* ldns-signzone uses the new ldns_dnssec_ structures and functions\n\twhich improves its speed, and output; RRSIGS are now placed\n\tdirectly after their RRset, NSEC(3) records directly after the\n\tname they handle\n\n\tContrib:\n\t* new contrib/ dir with user contributions\n\t* added compilation script for solaris (thanks to Jakob Schlyter)\n\n28 Nov 2007 1.2.2:\n\t* Added support for HMAC-MD5 keys in generator\n\t* Added a new example tool (written by Ondrej Sury): ldns-compare-zones\n\t* ldns-keygen now checks key sizes for rfc conformancy\n\t* ldns-signzone outputs SSL error if present\n\t* Fixed manpages (thanks to Ondrej Sury)\n\t* Fixed Makefile for -j <x>\n\t* Fixed a $ORIGIN error when reading zones\n\t* Fixed another off-by-one error\n\n03 Oct 2007 1.2.1:\n\t* Fixed an offset error in rr comparison\n\t* Fixed ldns-read-zone exit code\n\t* Added check for availability of SHA256 hashing algorithm\n\t* Fixed ldns-key2ds -2 argument\n\t* Fixed $ORIGIN bug in .key files\n\t* Output algorithms as an integer instead of their mnemonic\n\t* Fixed a memory leak in dnssec code when SHA256 is not available\n\t* Updated fedora .spec file\n\n11 Apr 2007 1.2.0:\n\t* canonicalization of rdata in DNSSEC functions now adheres to the\n\t  rr type list in rfc3597, not rfc4035, which will be updated\n\t  (see http://www.ops.ietf.org/lists/namedroppers/namedroppers.2007/msg00183.html)\n\t* ldns-walk now support dnames with maximum label length\n\t* ldnsd now takes an extra argument containing the address to listen on\n\t* signing no longer signs every rrset with KSK's, but only the DNSKEY rrset\n\t* ported to Solaris 10\n\t* added ldns_send_buffer() function\n\t* added ldns-testpkts fake packet server\n\t* added ldns-notify to send NOTIFY packets\n\t* ldns-dpa can now accurately calculate the number of matches per\n\t  second\n\t* libtool is now used for compilation too (still gcc, but not directly)\n\t* Bugfixes:\n\t\t- TSIG signing buffer size\n\t\t- resolv.conf reading (comments)\n\t\t- dname comparison off by one error\n\t\t- typo in keyfetchers output file name fixed (a . too much)\n\t\t- fixed zone file parser when comments contain ( or )\n\t\t- fixed LOC RR type\n\t\t- fixed CERT RR type\n\n\tDrill:\n\t* drill prints error on failed axfr.\n\t* drill now accepts mangled packets with -f\n\t* old -c option (use tcp) changed to -t\n\t* -c option to specify alternative resolv.conf file added\n\t* feedback of signature chase improved\n\t* chaser now stops at root when no trusted keys are found\n\t  instead of looping forever trying to find the DS for .\n\t* Fixed bugs:\n\t\t- wildcard on multiple labels signature verification\n\t\t- error in -f packet writing for malformed packets\n\t\t- made KSK check more resilient\n\n7 Jul 2006: 1.1.0: ldns-team\n\t* Added tutorials and an introduction to the documentation\n\t* Added include/ and lib/ dirs so that you can compile against ldns\n\t  without installing ldns on your system\n\t* Makefile updates\n\t* Starting usage of assert throughout the library to catch illegal calls\n\t* Solaris 9 testing was carried out. Ldns now compiles on that\n\t  platform; some gnuism were identified and fixed.\n\t* The ldns_zone structure was stress tested. The current setup\n\t (ie. just a list of rrs) can scale to zone file in order of\n\t  megabytes. Sorting such zone is still difficult.\n\t* Reading multiline b64 encoded rdata works.\n\t* OpenSSL was made optional, configure --without-ssl.\n\t  Ofcourse all dnssec/tsig related functions are disabled\n\t* Building of examples and drill now happens with the same\n\t  defines as the building of ldns itself.\n\t* Preliminary sha-256 support was added. Currently is your\n\t  OpenSSL supports it, it is supported in the DS creation.\n\t* ldns_resolver_search was implemented\n\t* Fixed a lot of bugs\n\n\tDrill:\n\t* -r was killed in favor of -o <header bit mnemonic> which\n\t  allows for a header bits setting (and maybe more in the\n\t  future)\n\t* DNSSEC is never automaticaly set, even when you query\n\t  for DNSKEY/RRSIG or DS.\n\t* Implement a crude RTT check, it now distinguishes between\n\t  reachable and unreachable.\n\t* A form of secure tracing was added\n\t* Secure Chasing has been improved\n\t* -x does a reverse lookup for the given IP address\n\n\tExamples:\n\t* ldns-dpa was added to the examples - this is the Dns Packet\n\t  Analyzer tool.\n\t* ldnsd - as very, very simple nameserver impl.\n\t* ldns-zsplit - split zones for parrallel signing\n\t* ldns-zcat - cat split zones back together\n\t* ldns-keyfetcher - Fetches DNSKEY records with a few (non-strong,\n\t  non-DNSSEC) anti-spoofing techniques.\n\t* ldns-walk - 'Walks' a DNSSEC signed zone\n\t* Added an all-static target to the makefile so you can use examples\n\t  without installing the library\n\t* When building in the source tree or in a direct subdirectory of\n\t  the build dir, configure does not need --with-ldns=../ anymore\n\n\tCode:\n\t* All networking code was moved to net.c\n\t* rdata.c: added asserts to the rdf set/get functions\n\t* const keyword was added to pointer arguments that\n\t  aren't changed\n\n\tAPI:\n\tChanged:\n\t* renamed ldns/dns.h to ldns/ldns.h\n\t* ldns_rr_new_frm_str() is extented with an extra variable which\n\t  in common use may be NULL. This trickles through to:\n\t  o ldns_rr_new_frm_fp\n\t  o ldns_rr_new_frm_fp_l\n\t  Which also get an extra variable\n\t  Also the function has been changed to return a status message.\n\t  The compiled RR is returned in the first argument.\n\t* ldns_zone_new_frm_fp_l()  and ldns_zone_new_frm_fp() are\n\t  changed to return a status msg.\n\t* ldns_key_new_frm_fp is changed to return ldns_status and\n\t  the actual key list in the first argument\n\t* ldns_rdata_new_frm_fp[_l]() are changed to return a status.\n\t  the rdf is return in the first argument\n\t* ldns_resolver_new_frm_fp: same treatment: return status and\n\t  the new resolver in the first argument\n\t* ldns_pkt_query_new_frm_str(): same: return status and the\n\t  packet in the first arg\n\t* tsig.h: internal used functions are now static:\n\t  ldns_digest_name and ldns_tsig_mac_new\n\t* ldns_key_rr2ds has an extra argument to specify the hash to\n\t  use.\n\t* ldns_pkt_rcode() is renamed to ldns_pkt_get_rcode, ldns_pkt_rcode\n\t  is now the rcode type, like ldns_pkt_opcode\n\tNew:\n\t* ldns_resolver_searchlist_count: return the searchlist counter\n\t* ldns_zone_sort: Sort a zone\n\t* ldns_bgsend(): background send, returns a socket.\n\t* ldns_pkt_empty(): check is a packet is empty\n\t* ldns_rr_list_pop_rr_list(): pop multiple rr's from another rr_list\n\t* ldns_rr_list_push_rr_list(): push multiple rr's to an rr_list\n\t* ldns_rr_list_compare(): compare 2 ldns_rr_lists\n\t* ldns_pkt_push_rr_list: rr_list equiv for rr\n\t* ldns_pkt_safe_push_rr_list: rr_list equiv for rr\n\tRemoved:\n\t* ldns_resolver_bgsend(): was not used in 1.0.0 and is not used now\n\t* ldns_udp_server_connect(): was faulty and isn't really part of\n\t  the core ldns idea any how.\n\t* ldns_rr_list_insert_rr(): obsoleted, because not used.\n\t* char *_when was removed from the ldns_pkt structure\n\n18 Oct 2005: 1.0.0: ldns-team\n\t* Commited a patch from H\u00e5kan Olsson\n\t* Added UPDATE support (Jakob Schlyter and H\u00e5kan Olsson)\n\t* License change: ldns is now BSD licensed\n\t* ldns now depends on SSL\n\t* Networking code cleanup, added (some) server udp/tcp support\n\t* A zone type is introduced. Currently this is a list\n\t  of RRs, so it will not scale well.\n\t* [beta] Zonefile parsing was added\n\t* [tools] Drill was added to ldns - see drill/\n\t* [tools] experimental signer was added\n\t* [building] better check for ssl\n\t* [building] major revision of build system\n\t* [building] added rpm .spec in packaging/ (thanks to Paul Wouters)\n\t* [building] A lot of cleanup in the build scripts (thanks to Jakob Schlyter\n\tand Paul Wouters)\n\n28 Jul 2005: 0.70: ldns-team\n\t* [func] ldns_pkt_get_section now returns copies from the rrlists\n\t  in the packet. This can be freed by the user program\n\t* [code] added ldns_ prefixes to function from util.h\n\t* [inst] removed documentation from default make install\n\t* Usual fixes in documentation and code\n\n20 Jun 2005: 0.66: ldns-team\n\tRel. Focus: drill-pre2 uses some functions which are\n\tnot in 0.65\n\t* dnssec_cd bit function was added\n\t* Zone infrastructure was added\n\t* Usual fixes in documentation and code\n\n13 Jun 2005: 0.65: ldns-team\n\t* Repository is online at:\n\t  http://www.nlnetlabs.nl/ldns/svn/\n\t* Apply reference copying throuhgout ldns, except in 2\n\t  places in the ldns_resolver structure (._domain and\n\t ._nameservers)\n\t* Usual array of bugfixes\n\t* Documentation added\n\t* keygen.c added as an example for DNSSEC programming\n\n23 May 2005: 0.60: ldns-team\n\t* Removed config.h from the header installed files\n\t  (you're not supposed to include that in a libary)\n\t* Further tweaking\n\t  - DNSSEC signing/verification works\n\t  - Assorted bug fixes and tweaks (memory management)\n\nMay 2005: 0.50: ldns-team\n\t* First usable release\n\t* Basic DNS functionality works\n\t* DNSSEC validation works\n", "/* rr.c\n *\n * access functions for ldns_rr -\n * a Net::DNS like library for C\n * LibDNS Team @ NLnet Labs\n *\n * (c) NLnet Labs, 2004-2006\n * See the file LICENSE for the license\n */\n#include <ldns/config.h>\n\n#include <ldns/ldns.h>\n\n#include <strings.h>\n#include <limits.h>\n\n#include <errno.h>\n\n#define LDNS_SYNTAX_DATALEN 16\n#define LDNS_TTL_DATALEN    21\n#define LDNS_RRLIST_INIT    8\n\nldns_rr *\nldns_rr_new(void)\n{\n\tldns_rr *rr;\n\trr = LDNS_MALLOC(ldns_rr);\n        if (!rr) {\n                return NULL;\n\t}\n\n\tldns_rr_set_owner(rr, NULL);\n\tldns_rr_set_question(rr, false);\n\tldns_rr_set_rd_count(rr, 0);\n\trr->_rdata_fields = NULL;\n\tldns_rr_set_class(rr, LDNS_RR_CLASS_IN);\n\tldns_rr_set_ttl(rr, LDNS_DEFAULT_TTL);\n        return rr;\n}\n\nldns_rr *\nldns_rr_new_frm_type(ldns_rr_type t)\n{\n\tldns_rr *rr;\n\tconst ldns_rr_descriptor *desc;\n\tsize_t i;\n\n\trr = LDNS_MALLOC(ldns_rr);\n        if (!rr) {\n                return NULL;\n\t}\n\n\tdesc = ldns_rr_descript(t);\n\n\trr->_rdata_fields = LDNS_XMALLOC(ldns_rdf *, ldns_rr_descriptor_minimum(desc));\n        if(!rr->_rdata_fields) {\n                LDNS_FREE(rr);\n                return NULL;\n        }\n\tfor (i = 0; i < ldns_rr_descriptor_minimum(desc); i++) {\n\t\trr->_rdata_fields[i] = NULL;\n\t}\n\n\tldns_rr_set_owner(rr, NULL);\n\tldns_rr_set_question(rr, false);\n\t/* set the count to minimum */\n\tldns_rr_set_rd_count(rr, ldns_rr_descriptor_minimum(desc));\n\tldns_rr_set_class(rr, LDNS_RR_CLASS_IN);\n\tldns_rr_set_ttl(rr, LDNS_DEFAULT_TTL);\n\tldns_rr_set_type(rr, t);\n\treturn rr;\n}\n\nvoid\nldns_rr_free(ldns_rr *rr)\n{\n\tsize_t i;\n\tif (rr) {\n\t\tif (ldns_rr_owner(rr)) {\n\t\t\tldns_rdf_deep_free(ldns_rr_owner(rr));\n\t\t}\n\t\tfor (i = 0; i < ldns_rr_rd_count(rr); i++) {\n\t\t\tldns_rdf_deep_free(ldns_rr_rdf(rr, i));\n\t\t}\n\t\tLDNS_FREE(rr->_rdata_fields);\n\t\tLDNS_FREE(rr);\n\t}\n}\n\n/* Syntactic sugar for ldns_rr_new_frm_str_internal */\nINLINE bool\nldns_rdf_type_maybe_quoted(ldns_rdf_type rdf_type)\n{\n\treturn  rdf_type == LDNS_RDF_TYPE_STR ||\n\t\trdf_type == LDNS_RDF_TYPE_LONG_STR;\n}\n\n/*\n * trailing spaces are allowed\n * leading spaces are not allowed\n * allow ttl to be optional\n * class is optional too\n * if ttl is missing, and default_ttl is 0, use DEF_TTL\n * allow ttl to be written as 1d3h\n * So the RR should look like. e.g.\n * miek.nl. 3600 IN MX 10 elektron.atoom.net\n * or\n * miek.nl. 1h IN MX 10 elektron.atoom.net\n * or\n * miek.nl. IN MX 10 elektron.atoom.net\n */\nstatic ldns_status\nldns_rr_new_frm_str_internal(ldns_rr **newrr, const char *str,\n\t\t\t\t\t\t\t uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t\t\t\t ldns_rdf **prev, bool question)\n{\n\tldns_rr *new;\n\tconst ldns_rr_descriptor *desc;\n\tldns_rr_type rr_type;\n\tldns_buffer *rr_buf = NULL;\n\tldns_buffer *rd_buf = NULL;\n\tuint32_t ttl_val;\n\tchar  *owner = NULL;\n\tchar  *ttl = NULL;\n\tldns_rr_class clas_val;\n\tchar  *clas = NULL;\n\tchar  *type = NULL;\n\tsize_t type_sz;\n\tchar  *rdata = NULL;\n\tchar  *rd = NULL;\n\tchar  *xtok = NULL; /* For RDF types with spaces (i.e. extra tokens) */\n\tsize_t rd_strlen;\n\tconst char *delimiters;\n\tssize_t c;\n\tldns_rdf *owner_dname;\n        const char* endptr;\n        int was_unknown_rr_format = 0;\n\tldns_status status = LDNS_STATUS_OK;\n\n\t/* used for types with unknown number of rdatas */\n\tbool done;\n\tbool quoted;\n\n\tldns_rdf *r = NULL;\n\tuint16_t r_cnt;\n\tuint16_t r_min;\n\tuint16_t r_max;\n        size_t pre_data_pos;\n\n\tuint16_t hex_data_size;\n\tchar *hex_data_str = NULL;\n\tuint16_t cur_hex_data_size;\n\tsize_t hex_pos = 0;\n\tuint8_t *hex_data = NULL;\n\n\tnew = ldns_rr_new();\n\n\towner = LDNS_XMALLOC(char, LDNS_MAX_DOMAINLEN + 1);\n\tttl = LDNS_XMALLOC(char, LDNS_TTL_DATALEN);\n\tclas = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\trdata = LDNS_XMALLOC(char, LDNS_MAX_PACKETLEN + 1);\n\trr_buf = LDNS_MALLOC(ldns_buffer);\n\trd_buf = LDNS_MALLOC(ldns_buffer);\n\trd = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\txtok = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\tif (rr_buf) {\n\t\trr_buf->_data = NULL;\n\t}\n\tif (rd_buf) {\n\t\trd_buf->_data = NULL;\n\t}\n\tif (!new || !owner || !ttl || !clas || !rdata ||\n\t\t\t!rr_buf || !rd_buf || !rd || !xtok) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(rr_buf, (char*)str, strlen(str));\n\n\t/* split the rr in its parts -1 signals trouble */\n\tif (ldns_bget_token(rr_buf, owner, \"\\t\\n \", LDNS_MAX_DOMAINLEN) == -1){\n\n\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(rr_buf, ttl, \"\\t\\n \", LDNS_TTL_DATALEN) == -1) {\n\n\t\tstatus = LDNS_STATUS_SYNTAX_TTL_ERR;\n\t\tgoto error;\n\t}\n\tttl_val = (uint32_t) ldns_str2period(ttl, &endptr);\n\n\tif (strlen(ttl) > 0 && !isdigit((int) ttl[0])) {\n\t\t/* ah, it's not there or something */\n\t\tif (default_ttl == 0) {\n\t\t\tttl_val = LDNS_DEFAULT_TTL;\n\t\t} else {\n\t\t\tttl_val = default_ttl;\n\t\t}\n\t\t/* we not ASSUMING the TTL is missing and that\n\t\t * the rest of the RR is still there. That is\n\t\t * CLASS TYPE RDATA\n\t\t * so ttl value we read is actually the class\n\t\t */\n\t\tclas_val = ldns_get_rr_class_by_name(ttl);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(ttl) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, ttl, type_sz);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, clas, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_CLASS_ERR;\n\t\t\tgoto error;\n\t\t}\n\t\tclas_val = ldns_get_rr_class_by_name(clas);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(clas) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, clas, type_sz);\n\t\t}\n\t}\n\t/* the rest should still be waiting for us */\n\n\tif (!type) {\n\t\ttype = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\t\tif (!type) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, type, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_TYPE_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(rr_buf, rdata, \"\\0\", LDNS_MAX_PACKETLEN) == -1) {\n\t\t/* apparently we are done, and it's only a question RR\n\t\t * so do not set status and go to ldnserror here\n\t\t */\n\t}\n\tldns_buffer_new_frm_data(rd_buf, rdata, strlen(rdata));\n\n\tif (strlen(owner) <= 1 && strncmp(owner, \"@\", 1) == 0) {\n\t\tif (origin) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t} else if (prev && *prev) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t} else {\n\t\t\t/* default to root */\n\t\t\tldns_rr_set_owner(new, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* @ also overrides prev */\n\t\tif (prev) {\n\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\tif (!*prev) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(owner) == 0) {\n\t\t\t/* no ownername was given, try prev, if that fails\n\t\t\t * origin, else default to root */\n\t\t\tif (prev && *prev) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t\t} else if (origin) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(new,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(new)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\towner_dname = ldns_dname_new_frm_str(owner);\n\t\t\tif (!owner_dname) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(new, owner_dname);\n\t\t\tif (!ldns_dname_str_absolute(owner) && origin) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(new), origin)\n\t\t\t\t\t\t!= LDNS_STATUS_OK) {\n\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev) {\n\t\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\t\tif (!*prev) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(owner);\n\n\tldns_rr_set_question(new, question);\n\n\tldns_rr_set_ttl(new, ttl_val);\n\tLDNS_FREE(ttl);\n\n\tldns_rr_set_class(new, clas_val);\n\tLDNS_FREE(clas);\n\n\trr_type = ldns_get_rr_type_by_name(type);\n\tLDNS_FREE(type);\n\n\tdesc = ldns_rr_descript((uint16_t)rr_type);\n\tldns_rr_set_type(new, rr_type);\n\tif (desc) {\n\t\t/* only the rdata remains */\n\t\tr_max = ldns_rr_descriptor_maximum(desc);\n\t\tr_min = ldns_rr_descriptor_minimum(desc);\n\t} else {\n\t\tr_min = 0;\n\t\tr_max = 1;\n\t}\n\n\tfor (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) {\n\t\tquoted = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\t\tcase LDNS_RDF_TYPE_B64        :\n\t\tcase LDNS_RDF_TYPE_HEX        : /* These rdf types may con- */\n\t\tcase LDNS_RDF_TYPE_LOC        : /* tain whitespace, only if */\n\t\tcase LDNS_RDF_TYPE_WKS        : /* it is the last rd field. */\n\t\tcase LDNS_RDF_TYPE_IPSECKEY   :\n\t\tcase LDNS_RDF_TYPE_AMTRELAY   :\n\t\tcase LDNS_RDF_TYPE_NSEC       :\tif (r_cnt == r_max - 1) {\n\t\t\t\t\t\t\tdelimiters = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fallthrough */\n\t\tdefault                       :\tdelimiters = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tdesc, r_cnt)) &&\n\t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n\n\t\t\t/* skip spaces */\n\t\t\twhile (*(ldns_buffer_current(rd_buf)) == ' ') {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t}\n\n\t\t\tif (*(ldns_buffer_current(rd_buf)) == '\\\"') {\n\t\t\t\tdelimiters = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t\tquoted = true;\n\t\t\t} else if (ldns_rr_descriptor_field_type(desc, r_cnt)\n\t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* because number of fields can be variable, we can't rely on\n\t\t * _maximum() only\n\t\t */\n\n\t\t/* skip spaces */\n\t\twhile (ldns_buffer_position(rd_buf) < ldns_buffer_limit(rd_buf)\n\t\t\t\t&& *(ldns_buffer_current(rd_buf)) == ' '\n\t\t\t\t&& !quoted) {\n\n\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t}\n\n\t\tpre_data_pos = ldns_buffer_position(rd_buf);\n\t\tif (-1 == (c = ldns_bget_token(\n\t\t\t\trd_buf, rd, delimiters, LDNS_MAX_RDFLEN))) {\n\n\t\t\tdone = true;\n\t\t\t(void)done; /* we're breaking, so done not read anymore */\n\t\t\tbreak;\n\t\t}\n\t\t/* hmmz, rfc3597 specifies that any type can be represented \n\t\t * with \\# method, which can contain spaces...\n\t\t * it does specify size though...\n\t\t */\n\t\trd_strlen = strlen(rd);\n\n\t\t/* unknown RR data */\n\t\tif (strncmp(rd, \"\\\\#\", 2) == 0 && !quoted &&\n\t\t\t\t(rd_strlen == 2 || rd[2]==' ')) {\n\n\t\t\twas_unknown_rr_format = 1;\n\t\t\t/* go back to before \\#\n\t\t\t * and skip it while setting delimiters better\n\t\t\t */\n\t\t\tldns_buffer_set_position(rd_buf, pre_data_pos);\n\t\t\tdelimiters = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t/* read rdata octet length */\n\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\tif (c == -1) {\n\t\t\t\t/* something goes very wrong here */\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\thex_data_size = (uint16_t) atoi(rd);\n\t\t\t/* copy hex chars into hex str (2 chars per byte) */\n\t\t\thex_data_str = LDNS_XMALLOC(char, 2*hex_data_size + 1);\n\t\t\tif (!hex_data_str) {\n\t\t\t\t/* malloc error */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tcur_hex_data_size = 0;\n\t\t\twhile(cur_hex_data_size < 2 * hex_data_size) {\n\t\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t\tif (c == -1) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\trd_strlen = strlen(rd);\n\t\t\t\tif ((size_t)cur_hex_data_size + rd_strlen >\n\t\t\t\t    2 * (size_t)hex_data_size) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(hex_data_str + cur_hex_data_size, rd,\n\t\t\t\t\t\trd_strlen + 1);\n\n\t\t\t\tcur_hex_data_size += rd_strlen;\n\t\t\t}\n\t\t\thex_data_str[cur_hex_data_size] = '\\0';\n\n\t\t\t/* correct the rdf type */\n\t\t\t/* if *we* know the type, interpret it as wireformat */\n\t\t\tif (desc) {\n\t\t\t\thex_pos = 0;\n\t\t\t\thex_data =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, hex_data_size+2);\n\n\t\t\t\tif (!hex_data) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(hex_data, hex_data_size);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\thex_data + 2, hex_data_str);\n\t\t\t\tstatus = ldns_wire2rdf(new, hex_data,\n\t\t\t\t\t\thex_data_size + 2, &hex_pos);\n\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(hex_data);\n\t\t\t} else {\n\t\t\t\tr = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_HEX,\n\t\t\t\t\t\thex_data_str);\n\t\t\t\tif (!r) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(r, LDNS_RDF_TYPE_UNKNOWN);\n\t\t\t\tif (!ldns_rr_push_rdf(new, r)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(hex_data_str);\n\n\t\t} else if(rd_strlen > 0 || quoted) {\n\t\t\t/* Normal RR */\n\t\t\tswitch(ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\n\t\t\tcase LDNS_RDF_TYPE_HEX:\n\t\t\tcase LDNS_RDF_TYPE_B64:\n\t\t\t\t/* When this is the last rdata field, then the\n\t\t\t\t * rest should be read in (cause then these\n\t\t\t\t * rdf types may contain spaces).\n\t\t\t\t */\n\t\t\t\tif (r_cnt == r_max - 1) {\n\t\t\t\t\tc = ldns_bget_token(rd_buf, xtok,\n\t\t\t\t\t\t\t\"\\n\", LDNS_MAX_RDFLEN);\n\t\t\t\t\tif (c != -1) {\n\t\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_HIP:\n\t\t\t\t/*\n\t\t\t\t * In presentation format this RDATA type has\n\t\t\t\t * three tokens: An algorithm byte, then a\n\t\t\t\t * variable length HIT (in hexbytes) and then\n\t\t\t\t * a variable length Public Key (in base64).\n\t\t\t\t *\n\t\t\t\t * We have just read the algorithm, so we need\n\t\t\t\t * two more tokens: HIT and Public Key.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\t/* Read and append HIT */\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\n\t\t\t\t\t/* Read and append Public Key*/\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_DNAME:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\n\t\t\t\t/* check if the origin should be used\n\t\t\t\t * or concatenated\n\t\t\t\t */\n\t\t\t\tif (r && ldns_rdf_size(r) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(r);\n\n\t\t\t\t\tr = origin ? ldns_rdf_clone(origin)\n\n\t\t\t\t\t  : ( rr_type == LDNS_RR_TYPE_SOA ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(new))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    LDNS_RDF_TYPE_DNAME, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (r && rd_strlen >= 1 && origin &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(rd)) {\n\n\t\t\t\t\tstatus = ldns_dname_cat(r, origin);\n\t\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!r) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(new, r);\n\t\t}\n\t\tif (quoted) {\n\t\t\tif (ldns_buffer_available(rd_buf, 1)) {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t} else {\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\n\t} /* for (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) */\n\tLDNS_FREE(rd);\n\tLDNS_FREE(xtok);\n\tldns_buffer_free(rr_buf);\n\tLDNS_FREE(rdata);\n\tif (ldns_buffer_remaining(rd_buf) > 0) {\n\t\tldns_buffer_free(rd_buf);\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR;\n\t}\n\tldns_buffer_free(rd_buf);\n\n\tif (!question && desc && !was_unknown_rr_format &&\n\t\t\tldns_rr_rd_count(new) < r_min) {\n\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR;\n\t}\n\n\tif (newrr) {\n\t\t*newrr = new;\n\t} else {\n\t\t/* Maybe the caller just wanted to see if it would parse? */\n\t\tldns_rr_free(new);\n\t}\n\treturn LDNS_STATUS_OK;\n\nmemerror:\n\tstatus = LDNS_STATUS_MEM_ERR;\nerror:\n\tif (rd_buf && rd_buf->_data) {\n\t\tldns_buffer_free(rd_buf);\n\t} else {\n\t\tLDNS_FREE(rd_buf);\n\t}\n\tif (rr_buf && rr_buf->_data) {\n\t\tldns_buffer_free(rr_buf);\n\t} else {\n\t\tLDNS_FREE(rr_buf);\n\t}\n\tLDNS_FREE(type);\n\tLDNS_FREE(owner);\n\tLDNS_FREE(ttl);\n\tLDNS_FREE(clas);\n\tLDNS_FREE(hex_data);\n\tLDNS_FREE(hex_data_str);\n\tLDNS_FREE(xtok);\n\tLDNS_FREE(rd);\n\tLDNS_FREE(rdata);\n\tldns_rr_free(new);\n\treturn status;\n}\n\nldns_status\nldns_rr_new_frm_str(ldns_rr **newrr, const char *str,\n                    uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t    ldns_rdf **prev)\n{\n\treturn ldns_rr_new_frm_str_internal(newrr,\n\t                                    str,\n\t                                    default_ttl,\n\t                                    origin,\n\t                                    prev,\n\t                                    false);\n}\n\nldns_status\nldns_rr_new_question_frm_str(ldns_rr **newrr, const char *str,\n                             const ldns_rdf *origin, ldns_rdf **prev)\n{\n\treturn ldns_rr_new_frm_str_internal(newrr,\n\t                                    str,\n\t                                    0,\n\t                                    origin,\n\t                                    prev,\n\t                                    true);\n}\n\n/* Strip whitespace from the start and the end of <line>.  */\nstatic char *\nldns_strip_ws(char *line)\n{\n\tchar *s = line, *e;\n\n\tfor (s = line; *s && isspace((unsigned char)*s); s++)\n\t\t;\n\n\tfor (e = strchr(s, 0); e > s+2 && isspace((unsigned char)e[-1]) && e[-2] != '\\\\'; e--)\n\t\t;\n\t*e = 0;\n\n\treturn s;\n}\n\nldns_status\nldns_rr_new_frm_fp(ldns_rr **newrr, FILE *fp, uint32_t *ttl, ldns_rdf **origin, ldns_rdf **prev)\n{\n\treturn ldns_rr_new_frm_fp_l(newrr, fp, ttl, origin, prev, NULL);\n}\n\nldns_status\nldns_rr_new_frm_fp_l(ldns_rr **newrr, FILE *fp, uint32_t *default_ttl, ldns_rdf **origin, ldns_rdf **prev, int *line_nr)\n{\n\tchar *line;\n\tconst char *endptr;  /* unused */\n\tldns_rr *rr;\n\tuint32_t ttl;\n\tldns_rdf *tmp;\n\tldns_status s;\n\tssize_t size;\n\n\tif (default_ttl) {\n\t\tttl = *default_ttl;\n\t} else {\n\t\tttl = 0;\n\t}\n\n\tline = LDNS_XMALLOC(char, LDNS_MAX_LINELEN + 1);\n\tif (!line) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\n\t/* read an entire line in from the file */\n\tif ((size = ldns_fget_token_l(fp, line, LDNS_PARSE_SKIP_SPACE, LDNS_MAX_LINELEN, line_nr)) == -1) {\n\t\tLDNS_FREE(line);\n\t\t/* if last line was empty, we are now at feof, which is not\n\t\t * always a parse error (happens when for instance last line\n\t\t * was a comment)\n\t\t */\n\t\treturn LDNS_STATUS_SYNTAX_ERR;\n\t}\n\n\t/* we can have the situation, where we've read ok, but still got\n\t * no bytes to play with, in this case size is 0\n\t */\n\tif (size == 0) {\n\t\tLDNS_FREE(line);\n\t\treturn LDNS_STATUS_SYNTAX_EMPTY;\n\t}\n\n\tif (strncmp(line, \"$ORIGIN\", 7) == 0 && isspace((unsigned char)line[7])) {\n\t\tif (*origin) {\n\t\t\tldns_rdf_deep_free(*origin);\n\t\t\t*origin = NULL;\n\t\t}\n\t\ttmp = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_DNAME,\n\t\t\t\tldns_strip_ws(line + 8));\n\t\tif (!tmp) {\n\t\t\t/* could not parse what next to $ORIGIN */\n\t\t\tLDNS_FREE(line);\n\t\t\treturn LDNS_STATUS_SYNTAX_DNAME_ERR;\n\t\t}\n\t\t*origin = tmp;\n\t\ts = LDNS_STATUS_SYNTAX_ORIGIN;\n\t} else if (strncmp(line, \"$TTL\", 4) == 0 && isspace((unsigned char)line[4])) {\n\t\tif (default_ttl) {\n\t\t\t*default_ttl = ldns_str2period(\n\t\t\t\t\tldns_strip_ws(line + 5), &endptr);\n\t\t}\n\t\ts = LDNS_STATUS_SYNTAX_TTL;\n\t} else if (strncmp(line, \"$INCLUDE\", 8) == 0) {\n\t\ts = LDNS_STATUS_SYNTAX_INCLUDE;\n\t} else if (!*ldns_strip_ws(line)) {\n\t\tLDNS_FREE(line);\n\t\treturn LDNS_STATUS_SYNTAX_EMPTY;\n\t} else {\n\t\tif (origin && *origin) {\n\t\t\ts = ldns_rr_new_frm_str(&rr, (const char*) line, ttl, *origin, prev);\n\t\t} else {\n\t\t\ts = ldns_rr_new_frm_str(&rr, (const char*) line, ttl, NULL, prev);\n\t\t}\n\t}\n\tLDNS_FREE(line);\n\tif (s == LDNS_STATUS_OK) {\n\t\tif (newrr) {\n\t\t\t*newrr = rr;\n\t\t} else {\n\t\t\t/* Just testing if it would parse? */\n\t\t\tldns_rr_free(rr);\n\t\t}\n\t}\n\treturn s;\n}\n\nvoid\nldns_rr_set_owner(ldns_rr *rr, ldns_rdf *owner)\n{\n\trr->_owner = owner;\n}\n\nvoid\nldns_rr_set_question(ldns_rr *rr, bool question)\n{\n   rr->_rr_question = question;\n}\n\nvoid\nldns_rr_set_ttl(ldns_rr *rr, uint32_t ttl)\n{\n\trr->_ttl = ttl;\n}\n\nvoid\nldns_rr_set_rd_count(ldns_rr *rr, size_t count)\n{\n\trr->_rd_count = count;\n}\n\nvoid\nldns_rr_set_type(ldns_rr *rr, ldns_rr_type rr_type)\n{\n\trr->_rr_type = rr_type;\n}\n\nvoid\nldns_rr_set_class(ldns_rr *rr, ldns_rr_class rr_class)\n{\n\trr->_rr_class = rr_class;\n}\n\nldns_rdf *\nldns_rr_set_rdf(ldns_rr *rr, const ldns_rdf *f, size_t position)\n{\n\tsize_t rd_count;\n\tldns_rdf *pop;\n\n\trd_count = ldns_rr_rd_count(rr);\n\tif (position < rd_count) {\n\t\t/* dicard the old one */\n\t\tpop = rr->_rdata_fields[position];\n\t\trr->_rdata_fields[position] = (ldns_rdf*)f;\n\t\treturn pop;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nbool\nldns_rr_push_rdf(ldns_rr *rr, const ldns_rdf *f)\n{\n\tsize_t rd_count;\n\tldns_rdf **rdata_fields;\n\n\trd_count = ldns_rr_rd_count(rr);\n\n\t/* grow the array */\n\trdata_fields = LDNS_XREALLOC(\n\t\trr->_rdata_fields, ldns_rdf *, rd_count + 1);\n\tif (!rdata_fields) {\n\t\treturn false;\n\t}\n\n\t/* add the new member */\n\trr->_rdata_fields = rdata_fields;\n\trr->_rdata_fields[rd_count] = (ldns_rdf*)f;\n\n\tldns_rr_set_rd_count(rr, rd_count + 1);\n\treturn true;\n}\n\nldns_rdf *\nldns_rr_pop_rdf(ldns_rr *rr)\n{\n\tsize_t rd_count;\n\tldns_rdf *pop;\n\tldns_rdf** newrd;\n\n\trd_count = ldns_rr_rd_count(rr);\n\n\tif (rd_count == 0) {\n\t\treturn NULL;\n\t}\n\n\tpop = rr->_rdata_fields[rd_count - 1];\n\n\t/* try to shrink the array */\n\tif(rd_count > 1) {\n\t\tnewrd = LDNS_XREALLOC(\n\t\t\trr->_rdata_fields, ldns_rdf *, rd_count - 1);\n\t\tif(newrd)\n\t\t\trr->_rdata_fields = newrd;\n\t} else {\n\t\tLDNS_FREE(rr->_rdata_fields);\n\t}\n\n\tldns_rr_set_rd_count(rr, rd_count - 1);\n\treturn pop;\n}\n\nldns_rdf *\nldns_rr_rdf(const ldns_rr *rr, size_t nr)\n{\n\tif (rr && nr < ldns_rr_rd_count(rr)) {\n\t\treturn rr->_rdata_fields[nr];\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nldns_rdf *\nldns_rr_owner(const ldns_rr *rr)\n{\n\treturn rr->_owner;\n}\n\nbool\nldns_rr_is_question(const ldns_rr *rr)\n{\n   return rr->_rr_question;\n}\n\nuint32_t\nldns_rr_ttl(const ldns_rr *rr)\n{\n\treturn rr->_ttl;\n}\n\nsize_t\nldns_rr_rd_count(const ldns_rr *rr)\n{\n\treturn rr->_rd_count;\n}\n\nldns_rr_type\nldns_rr_get_type(const ldns_rr *rr)\n{\n        return rr->_rr_type;\n}\n\nldns_rr_class\nldns_rr_get_class(const ldns_rr *rr)\n{\n        return rr->_rr_class;\n}\n\n/* rr_lists */\n\nsize_t\nldns_rr_list_rr_count(const ldns_rr_list *rr_list)\n{\n\tif (rr_list) {\n\t\treturn rr_list->_rr_count;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nldns_rr *\nldns_rr_list_set_rr(ldns_rr_list *rr_list, const ldns_rr *r, size_t count)\n{\n\tldns_rr *old;\n\n\tif (count > ldns_rr_list_rr_count(rr_list)) {\n\t\treturn NULL;\n\t}\n\n\told = ldns_rr_list_rr(rr_list, count);\n\n\t/* overwrite old's pointer */\n\trr_list->_rrs[count] = (ldns_rr*)r;\n\treturn old;\n}\n\nvoid\nldns_rr_list_set_rr_count(ldns_rr_list *rr_list, size_t count)\n{\n\tassert(count <= rr_list->_rr_capacity);\n\trr_list->_rr_count = count;\n}\n\nldns_rr *\nldns_rr_list_rr(const ldns_rr_list *rr_list, size_t nr)\n{\n\tif (nr < ldns_rr_list_rr_count(rr_list)) {\n\t\treturn rr_list->_rrs[nr];\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nldns_rr_list *\nldns_rr_list_new(void)\n{\n\tldns_rr_list *rr_list = LDNS_MALLOC(ldns_rr_list);\n        if(!rr_list) return NULL;\n\trr_list->_rr_count = 0;\n\trr_list->_rr_capacity = 0;\n\trr_list->_rrs = NULL;\n\treturn rr_list;\n}\n\nvoid\nldns_rr_list_free(ldns_rr_list *rr_list)\n{\n\tif (rr_list) {\n\t\tLDNS_FREE(rr_list->_rrs);\n\t\tLDNS_FREE(rr_list);\n\t}\n}\n\nvoid\nldns_rr_list_deep_free(ldns_rr_list *rr_list)\n{\n\tsize_t i;\n\n\tif (rr_list) {\n\t\tfor (i=0; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\t\tldns_rr_free(ldns_rr_list_rr(rr_list, i));\n\t\t}\n\t\tLDNS_FREE(rr_list->_rrs);\n\t\tLDNS_FREE(rr_list);\n\t}\n}\n\n\n/* add right to left. So we modify *left! */\nbool\nldns_rr_list_cat(ldns_rr_list *left, const ldns_rr_list *right)\n{\n\tsize_t r_rr_count;\n\tsize_t i;\n\n\tif (!left) {\n\t\treturn false;\n\t}\n\n\tif (right) {\n\t\tr_rr_count = ldns_rr_list_rr_count(right);\n\t} else {\n\t\tr_rr_count = 0;\n\t}\n\n\t/* push right to left */\n\tfor(i = 0; i < r_rr_count; i++) {\n\t\tldns_rr_list_push_rr(left, ldns_rr_list_rr(right, i));\n\t}\n\treturn true;\n}\n\nldns_rr_list *\nldns_rr_list_cat_clone(const ldns_rr_list *left, const ldns_rr_list *right)\n{\n\tsize_t l_rr_count;\n\tsize_t r_rr_count;\n\tsize_t i;\n\tldns_rr_list *cat;\n\n\tif (left) {\n\t\tl_rr_count = ldns_rr_list_rr_count(left);\n\t} else {\n\t\treturn ldns_rr_list_clone(right);\n\t}\n\n\tif (right) {\n\t\tr_rr_count = ldns_rr_list_rr_count(right);\n\t} else {\n\t\tr_rr_count = 0;\n\t}\n\n\tcat = ldns_rr_list_new();\n\n\tif (!cat) {\n\t\treturn NULL;\n\t}\n\n\t/* left */\n\tfor(i = 0; i < l_rr_count; i++) {\n\t\tldns_rr_list_push_rr(cat,\n\t\t\t\tldns_rr_clone(ldns_rr_list_rr(left, i)));\n\t}\n\t/* right */\n\tfor(i = 0; i < r_rr_count; i++) {\n\t\tldns_rr_list_push_rr(cat,\n\t\t\t\tldns_rr_clone(ldns_rr_list_rr(right, i)));\n\t}\n\treturn cat;\n}\n\nldns_rr_list *\nldns_rr_list_subtype_by_rdf(const ldns_rr_list *l, const ldns_rdf *r, size_t pos)\n{\n\tsize_t i;\n\tldns_rr_list *subtyped;\n\tldns_rdf *list_rdf;\n\n\tsubtyped = ldns_rr_list_new();\n\n\tfor(i = 0; i < ldns_rr_list_rr_count(l); i++) {\n\t\tlist_rdf = ldns_rr_rdf(\n\t\t\tldns_rr_list_rr(l, i),\n\t\t\tpos);\n\t\tif (!list_rdf) {\n\t\t\t/* pos is too large or any other error */\n\t\t\tldns_rr_list_deep_free(subtyped);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (ldns_rdf_compare(list_rdf, r) == 0) {\n\t\t\t/* a match */\n\t\t\tldns_rr_list_push_rr(subtyped,\n\t\t\t\t\tldns_rr_clone(ldns_rr_list_rr(l, i)));\n\t\t}\n\t}\n\n\tif (ldns_rr_list_rr_count(subtyped) > 0) {\n\t\treturn subtyped;\n\t} else {\n\t\tldns_rr_list_free(subtyped);\n\t\treturn NULL;\n\t}\n}\n\nbool\nldns_rr_list_push_rr(ldns_rr_list *rr_list, const ldns_rr *rr)\n{\n\tsize_t rr_count;\n\tsize_t cap;\n\n\trr_count = ldns_rr_list_rr_count(rr_list);\n\tcap = rr_list->_rr_capacity;\n\n\t/* grow the array */\n\tif(rr_count+1 > cap) {\n\t\tldns_rr **rrs;\n\n\t\tif(cap == 0)\n\t\t\tcap = LDNS_RRLIST_INIT;  /* initial list size */\n\t\telse\tcap *= 2;\n\t\trrs = LDNS_XREALLOC(rr_list->_rrs, ldns_rr *, cap);\n\t\tif (!rrs) {\n\t\t\treturn false;\n\t\t}\n\t\trr_list->_rrs = rrs;\n\t\trr_list->_rr_capacity = cap;\n\t}\n\n\t/* add the new member */\n\trr_list->_rrs[rr_count] = (ldns_rr*)rr;\n\n\tldns_rr_list_set_rr_count(rr_list, rr_count + 1);\n\treturn true;\n}\n\nbool\nldns_rr_list_push_rr_list(ldns_rr_list *rr_list, const ldns_rr_list *push_list)\n{\n\tsize_t i;\n\n\tfor(i = 0; i < ldns_rr_list_rr_count(push_list); i++) {\n\t\tif (!ldns_rr_list_push_rr(rr_list,\n\t\t\t\tldns_rr_list_rr(push_list, i))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nldns_rr *\nldns_rr_list_pop_rr(ldns_rr_list *rr_list)\n{\n\tsize_t rr_count;\n\tsize_t cap;\n\tldns_rr *pop;\n\n\trr_count = ldns_rr_list_rr_count(rr_list);\n\n\tif (rr_count == 0) {\n\t\treturn NULL;\n\t}\n\n\tcap = rr_list->_rr_capacity;\n\tpop = ldns_rr_list_rr(rr_list, rr_count - 1);\n\n\t/* shrink the array */\n\tif(cap > LDNS_RRLIST_INIT && rr_count-1 <= cap/2) {\n                ldns_rr** a;\n\t\tcap /= 2;\n                a = LDNS_XREALLOC(rr_list->_rrs, ldns_rr *, cap);\n                if(a) {\n\t\t        rr_list->_rrs = a;\n\t\t        rr_list->_rr_capacity = cap;\n                }\n\t}\n\n\tldns_rr_list_set_rr_count(rr_list, rr_count - 1);\n\n\treturn pop;\n}\n\nldns_rr_list *\nldns_rr_list_pop_rr_list(ldns_rr_list *rr_list, size_t howmany)\n{\n\t/* pop a number of rr's and put them in a rr_list */\n\tldns_rr_list *popped;\n\tldns_rr *p;\n\tsize_t i = howmany;\n\n\tpopped = ldns_rr_list_new();\n\n\tif (!popped) {\n\t\treturn NULL;\n\t}\n\n\n\twhile(i > 0 &&\n\t\t\t(p = ldns_rr_list_pop_rr(rr_list)) != NULL) {\n\t\tldns_rr_list_push_rr(popped, p);\n\t\ti--;\n\t}\n\n\tif (i == howmany) { /* so i <= 0 */\n\t\tldns_rr_list_free(popped);\n\t\treturn NULL;\n\t} else {\n\t\treturn popped;\n\t}\n}\n\n\nbool\nldns_rr_list_contains_rr(const ldns_rr_list *rr_list, const ldns_rr *rr)\n{\n\tsize_t i;\n\n\tif (!rr_list || !rr || ldns_rr_list_rr_count(rr_list) == 0) {\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\tif (rr == ldns_rr_list_rr(rr_list, i)) {\n\t\t\treturn true;\n\t\t} else if (ldns_rr_compare(rr, ldns_rr_list_rr(rr_list, i)) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool\nldns_is_rrset(const ldns_rr_list *rr_list)\n{\n\tldns_rr_type t;\n\tldns_rr_class c;\n\tldns_rdf *o;\n\tldns_rr *tmp;\n\tsize_t i;\n\n\tif (!rr_list || ldns_rr_list_rr_count(rr_list) == 0) {\n\t\treturn false;\n\t}\n\n\ttmp = ldns_rr_list_rr(rr_list, 0);\n\n\tt = ldns_rr_get_type(tmp);\n\tc = ldns_rr_get_class(tmp);\n\to = ldns_rr_owner(tmp);\n\n\t/* compare these with the rest of the rr_list, start with 1 */\n\tfor (i = 1; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\ttmp = ldns_rr_list_rr(rr_list, i);\n\t\tif (t != ldns_rr_get_type(tmp)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (c != ldns_rr_get_class(tmp)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ldns_rdf_compare(o, ldns_rr_owner(tmp)) != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool\nldns_rr_set_push_rr(ldns_rr_list *rr_list, ldns_rr *rr)\n{\n\tsize_t rr_count;\n\tsize_t i;\n\tldns_rr *last;\n\n\tassert(rr != NULL);\n\n\trr_count = ldns_rr_list_rr_count(rr_list);\n\n\tif (rr_count == 0) {\n\t\t/* nothing there, so checking it is\n\t\t * not needed */\n\t\treturn ldns_rr_list_push_rr(rr_list, rr);\n\t} else {\n\t\t/* check with the final rr in the rr_list */\n\t\tlast = ldns_rr_list_rr(rr_list, rr_count - 1);\n\n\t\tif (ldns_rr_get_class(last) != ldns_rr_get_class(rr)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ldns_rr_get_type(last) != ldns_rr_get_type(rr)) {\n\t\t\treturn false;\n\t\t}\n\t\t/* only check if not equal to RRSIG */\n\t\tif (ldns_rr_get_type(rr) != LDNS_RR_TYPE_RRSIG) {\n\t\t\tif (ldns_rr_ttl(last) != ldns_rr_ttl(rr)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (ldns_rdf_compare(ldns_rr_owner(last),\n\t\t\t\t\tldns_rr_owner(rr)) != 0) {\n\t\t\treturn false;\n\t\t}\n\t\t/* ok, still alive - check if the rr already\n\t\t * exists - if so, dont' add it */\n\t\tfor(i = 0; i < rr_count; i++) {\n\t\t\tif(ldns_rr_compare(\n\t\t\t\t\tldns_rr_list_rr(rr_list, i), rr) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/* it's safe, push it */\n\t\treturn ldns_rr_list_push_rr(rr_list, rr);\n\t}\n}\n\nldns_rr *\nldns_rr_set_pop_rr(ldns_rr_list *rr_list)\n{\n\treturn ldns_rr_list_pop_rr(rr_list);\n}\n\nldns_rr_list *\nldns_rr_list_pop_rrset(ldns_rr_list *rr_list)\n{\n\tldns_rr_list *rrset;\n\tldns_rr *last_rr = NULL;\n\tldns_rr *next_rr;\n\n\tif (!rr_list) {\n\t\treturn NULL;\n\t}\n\n\trrset = ldns_rr_list_new();\n\tif (!last_rr) {\n\t\tlast_rr = ldns_rr_list_pop_rr(rr_list);\n\t\tif (!last_rr) {\n\t\t\tldns_rr_list_free(rrset);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tldns_rr_list_push_rr(rrset, last_rr);\n\t\t}\n\t}\n\n\tif (ldns_rr_list_rr_count(rr_list) > 0) {\n\t\tnext_rr = ldns_rr_list_rr(rr_list, ldns_rr_list_rr_count(rr_list) - 1);\n\t} else {\n\t\tnext_rr = NULL;\n\t}\n\n\twhile (next_rr) {\n\t\tif (\n\t\t\tldns_rdf_compare(ldns_rr_owner(next_rr),\n\t\t\t\t\t ldns_rr_owner(last_rr)) == 0\n\t\t\t&&\n\t\t\tldns_rr_get_type(next_rr) == ldns_rr_get_type(last_rr)\n\t\t\t&&\n\t\t\tldns_rr_get_class(next_rr) == ldns_rr_get_class(last_rr)\n\t\t   ) {\n\t\t\tldns_rr_list_push_rr(rrset, ldns_rr_list_pop_rr(rr_list));\n\t\t\tif (ldns_rr_list_rr_count(rr_list) > 0) {\n\t\t\t\tlast_rr = next_rr;\n\t\t\t\tnext_rr = ldns_rr_list_rr(rr_list, ldns_rr_list_rr_count(rr_list) - 1);\n\t\t\t} else {\n\t\t\t\tnext_rr = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnext_rr = NULL;\n\t\t}\n\t}\n\n\treturn rrset;\n}\n\nldns_rr *\nldns_rr_clone(const ldns_rr *rr)\n{\n\tsize_t i;\n\tldns_rr *new_rr;\n\n\tif (!rr) {\n\t\treturn NULL;\n\t}\n\n\tnew_rr = ldns_rr_new();\n\tif (!new_rr) {\n\t\treturn NULL;\n\t}\n\tif (ldns_rr_owner(rr)) {\n\t\tldns_rr_set_owner(new_rr, ldns_rdf_clone(ldns_rr_owner(rr)));\n  \t}\n\tldns_rr_set_ttl(new_rr, ldns_rr_ttl(rr));\n\tldns_rr_set_type(new_rr, ldns_rr_get_type(rr));\n\tldns_rr_set_class(new_rr, ldns_rr_get_class(rr));\n\tldns_rr_set_question(new_rr, ldns_rr_is_question(rr));\n\n\tfor (i = 0; i < ldns_rr_rd_count(rr); i++) {\n        \tif (ldns_rr_rdf(rr,i)) {\n        \t\tldns_rr_push_rdf(new_rr, ldns_rdf_clone(ldns_rr_rdf(rr, i)));\n                }\n\t}\n\n\treturn new_rr;\n}\n\nldns_rr_list *\nldns_rr_list_clone(const ldns_rr_list *rrlist)\n{\n\tsize_t i;\n\tldns_rr_list *new_list;\n\tldns_rr *r;\n\n\tif (!rrlist) {\n\t\treturn NULL;\n\t}\n\n\tnew_list = ldns_rr_list_new();\n\tif (!new_list) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < ldns_rr_list_rr_count(rrlist); i++) {\n\t\tr = ldns_rr_clone(\n\t\t\tldns_rr_list_rr(rrlist, i)\n\t\t    );\n\t\tif (!r) {\n\t\t\t/* huh, failure in cloning */\n\t\t\tldns_rr_list_deep_free(new_list);\n\t\t\treturn NULL;\n\t\t}\n\t\tldns_rr_list_push_rr(new_list, r);\n\t}\n\treturn new_list;\n}\n\n\nstatic int\nqsort_schwartz_rr_compare(const void *a, const void *b)\n{\n\tint result = 0;\n\tldns_rr *rr1, *rr2;\n\tldns_buffer *rr1_buf, *rr2_buf;\n\tstruct ldns_schwartzian_compare_struct *sa = *(struct ldns_schwartzian_compare_struct **) a;\n\tstruct ldns_schwartzian_compare_struct *sb = *(struct ldns_schwartzian_compare_struct **) b;\n\t/* if we are doing 2wire, we need to do lowercasing on the dname (and maybe on the rdata)\n\t * this must be done for comparison only, so we need to have a temp var for both buffers,\n\t * which is only used when the transformed object value isn't there yet\n\t */\n\tldns_rr *canonical_a, *canonical_b;\n\n\trr1 = (ldns_rr *) sa->original_object;\n\trr2 = (ldns_rr *) sb->original_object;\n\n\tresult = ldns_rr_compare_no_rdata(rr1, rr2);\n\n\tif (result == 0) {\n\t\tif (!sa->transformed_object) {\n\t\t\tcanonical_a = ldns_rr_clone(sa->original_object);\n\t\t\tldns_rr2canonical(canonical_a);\n\t\t\tsa->transformed_object = ldns_buffer_new(ldns_rr_uncompressed_size(canonical_a));\n\t\t\tif (ldns_rr2buffer_wire(sa->transformed_object, canonical_a, LDNS_SECTION_ANY) != LDNS_STATUS_OK) {\n\t\t                ldns_buffer_free((ldns_buffer *)sa->transformed_object);\n                                sa->transformed_object = NULL;\n\t\t\t\tldns_rr_free(canonical_a);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tldns_rr_free(canonical_a);\n\t\t}\n\t\tif (!sb->transformed_object) {\n\t\t\tcanonical_b = ldns_rr_clone(sb->original_object);\n\t\t\tldns_rr2canonical(canonical_b);\n\t\t\tsb->transformed_object = ldns_buffer_new(ldns_rr_uncompressed_size(canonical_b));\n\t\t\tif (ldns_rr2buffer_wire(sb->transformed_object, canonical_b, LDNS_SECTION_ANY) != LDNS_STATUS_OK) {\n\t\t                ldns_buffer_free((ldns_buffer *)sa->transformed_object);\n\t\t                ldns_buffer_free((ldns_buffer *)sb->transformed_object);\n                                sa->transformed_object = NULL;\n                                sb->transformed_object = NULL;\n\t\t\t\tldns_rr_free(canonical_b);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tldns_rr_free(canonical_b);\n\t\t}\n\t\trr1_buf = (ldns_buffer *) sa->transformed_object;\n\t\trr2_buf = (ldns_buffer *) sb->transformed_object;\n\n\t\tresult = ldns_rr_compare_wire(rr1_buf, rr2_buf);\n\t}\n\n\treturn result;\n}\n\nvoid\nldns_rr_list_sort(ldns_rr_list *unsorted)\n{\n\tstruct ldns_schwartzian_compare_struct **sortables;\n\tsize_t item_count;\n\tsize_t i;\n\n\tif (unsorted) {\n\t\titem_count = ldns_rr_list_rr_count(unsorted);\n\n\t\tsortables = LDNS_XMALLOC(struct ldns_schwartzian_compare_struct *,\n\t\t\t\t\t item_count);\n                if(!sortables) return; /* no way to return error */\n\t\tfor (i = 0; i < item_count; i++) {\n\t\t\tsortables[i] = LDNS_XMALLOC(struct ldns_schwartzian_compare_struct, 1);\n                        if(!sortables[i]) {\n                                /* free the allocated parts */\n                                while(i>0) {\n                                        i--;\n                                        LDNS_FREE(sortables[i]);\n                                }\n                                /* no way to return error */\n\t\t\t\tLDNS_FREE(sortables);\n                                return;\n                        }\n\t\t\tsortables[i]->original_object = ldns_rr_list_rr(unsorted, i);\n\t\t\tsortables[i]->transformed_object = NULL;\n\t\t}\n\t\tqsort(sortables,\n\t\t      item_count,\n\t\t      sizeof(struct ldns_schwartzian_compare_struct *),\n\t\t      qsort_schwartz_rr_compare);\n\t\tfor (i = 0; i < item_count; i++) {\n\t\t\tunsorted->_rrs[i] = sortables[i]->original_object;\n\t\t\tif (sortables[i]->transformed_object) {\n\t\t\t\tldns_buffer_free(sortables[i]->transformed_object);\n\t\t\t}\n\t\t\tLDNS_FREE(sortables[i]);\n\t\t}\n\t\tLDNS_FREE(sortables);\n\t}\n}\n\nint\nldns_rr_compare_no_rdata(const ldns_rr *rr1, const ldns_rr *rr2)\n{\n\tsize_t rr1_len;\n\tsize_t rr2_len;\n        size_t offset;\n\n\tassert(rr1 != NULL);\n\tassert(rr2 != NULL);\n\n\trr1_len = ldns_rr_uncompressed_size(rr1);\n\trr2_len = ldns_rr_uncompressed_size(rr2);\n\n\tif (ldns_dname_compare(ldns_rr_owner(rr1), ldns_rr_owner(rr2)) < 0) {\n\t\treturn -1;\n\t} else if (ldns_dname_compare(ldns_rr_owner(rr1), ldns_rr_owner(rr2)) > 0) {\n\t\treturn 1;\n\t}\n\n        /* should return -1 if rr1 comes before rr2, so need to do rr1 - rr2, not rr2 - rr1 */\n        if (ldns_rr_get_class(rr1) != ldns_rr_get_class(rr2)) {\n            return ldns_rr_get_class(rr1) - ldns_rr_get_class(rr2);\n        }\n\n        /* should return -1 if rr1 comes before rr2, so need to do rr1 - rr2, not rr2 - rr1 */\n        if (ldns_rr_get_type(rr1) != ldns_rr_get_type(rr2)) {\n            return ldns_rr_get_type(rr1) - ldns_rr_get_type(rr2);\n        }\n\n        /* offset is the owername length + ttl + type + class + rdlen == start of wire format rdata */\n        offset = ldns_rdf_size(ldns_rr_owner(rr1)) + 4 + 2 + 2 + 2;\n        /* if either record doesn't have any RDATA... */\n        if (offset > rr1_len || offset > rr2_len) {\n            if (rr1_len == rr2_len) {\n              return 0;\n            }\n            return ((int) rr2_len - (int) rr1_len);\n        }\n\n\treturn 0;\n}\n\nint ldns_rr_compare_wire(const ldns_buffer *rr1_buf, const ldns_buffer *rr2_buf)\n{\n        size_t rr1_len, rr2_len, min_len, i, offset;\n\n        rr1_len = ldns_buffer_capacity(rr1_buf);\n        rr2_len = ldns_buffer_capacity(rr2_buf);\n\n        /* jump past dname (checked in earlier part)\n         * and especially past TTL */\n        offset = 0;\n        while (offset < rr1_len && *ldns_buffer_at(rr1_buf, offset) != 0) {\n          offset += *ldns_buffer_at(rr1_buf, offset) + 1;\n        }\n        /* jump to rdata section (PAST the rdata length field, otherwise\n           rrs with different lengths might be sorted erroneously */\n        offset += 11;\n\t   min_len = (rr1_len < rr2_len) ? rr1_len : rr2_len;\n        /* Compare RRs RDATA byte for byte. */\n        for(i = offset; i < min_len; i++) {\n                if (*ldns_buffer_at(rr1_buf,i) < *ldns_buffer_at(rr2_buf,i)) {\n                        return -1;\n                } else if (*ldns_buffer_at(rr1_buf,i) > *ldns_buffer_at(rr2_buf,i)) {\n                        return +1;\n                }\n        }\n\n        /* If both RDATAs are the same up to min_len, then the shorter one sorts first. */\n        if (rr1_len < rr2_len) {\n                return -1;\n        } else if (rr1_len > rr2_len) {\n                return +1;\n\t}\n        /* The RDATAs are equal. */\n        return 0;\n\n}\n\nint\nldns_rr_compare(const ldns_rr *rr1, const ldns_rr *rr2)\n{\n\tint result;\n\tsize_t rr1_len, rr2_len;\n\n\tldns_buffer *rr1_buf;\n\tldns_buffer *rr2_buf;\n\n\tresult = ldns_rr_compare_no_rdata(rr1, rr2);\n\tif (result == 0) {\n\t\trr1_len = ldns_rr_uncompressed_size(rr1);\n\t\trr2_len = ldns_rr_uncompressed_size(rr2);\n\n\t\trr1_buf = ldns_buffer_new(rr1_len);\n\t\trr2_buf = ldns_buffer_new(rr2_len);\n\n\t\tif (ldns_rr2buffer_wire_canonical(rr1_buf,\n\t\t\t\t\t\t\t\t    rr1,\n\t\t\t\t\t\t\t\t    LDNS_SECTION_ANY)\n\t\t    != LDNS_STATUS_OK) {\n\t\t\tldns_buffer_free(rr1_buf);\n\t\t\tldns_buffer_free(rr2_buf);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ldns_rr2buffer_wire_canonical(rr2_buf,\n\t\t\t\t\t\t\t\t    rr2,\n\t\t\t\t\t\t\t\t    LDNS_SECTION_ANY)\n\t\t    != LDNS_STATUS_OK) {\n\t\t\tldns_buffer_free(rr1_buf);\n\t\t\tldns_buffer_free(rr2_buf);\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult = ldns_rr_compare_wire(rr1_buf, rr2_buf);\n\n\t\tldns_buffer_free(rr1_buf);\n\t\tldns_buffer_free(rr2_buf);\n\t}\n\n\treturn result;\n}\n\n/* convert dnskey to a ds with the given algorithm,\n * then compare the result with the given ds */\nstatic int\nldns_rr_compare_ds_dnskey(ldns_rr *ds,\n                          ldns_rr *dnskey)\n{\n\tldns_rr *ds_gen;\n\tbool result = false;\n\tldns_hash algo;\n\n\tif (!dnskey || !ds ||\n\t    ldns_rr_get_type(ds) != LDNS_RR_TYPE_DS ||\n\t    ldns_rr_get_type(dnskey) != LDNS_RR_TYPE_DNSKEY) {\n\t\treturn false;\n\t}\n\n\tif (ldns_rr_rdf(ds, 2) == NULL) {\n\t\treturn false;\n\t}\n\talgo = ldns_rdf2native_int8(ldns_rr_rdf(ds, 2));\n\n\tds_gen = ldns_key_rr2ds(dnskey, algo);\n\tif (ds_gen) {\n\t\tresult = ldns_rr_compare(ds, ds_gen) == 0;\n\t\tldns_rr_free(ds_gen);\n\t}\n\treturn result;\n}\n\nbool\nldns_rr_compare_ds(const ldns_rr *orr1, const ldns_rr *orr2)\n{\n\tbool result;\n\tldns_rr *rr1 = ldns_rr_clone(orr1);\n\tldns_rr *rr2 = ldns_rr_clone(orr2);\n\n\t/* set ttls to zero */\n\tldns_rr_set_ttl(rr1, 0);\n\tldns_rr_set_ttl(rr2, 0);\n\n\tif (ldns_rr_get_type(rr1) == LDNS_RR_TYPE_DS &&\n\t    ldns_rr_get_type(rr2) == LDNS_RR_TYPE_DNSKEY) {\n\t\tresult = ldns_rr_compare_ds_dnskey(rr1, rr2);\n\t} else if (ldns_rr_get_type(rr1) == LDNS_RR_TYPE_DNSKEY &&\n\t    ldns_rr_get_type(rr2) == LDNS_RR_TYPE_DS) {\n\t\tresult = ldns_rr_compare_ds_dnskey(rr2, rr1);\n\t} else {\n\t\tresult = (ldns_rr_compare(rr1, rr2) == 0);\n\t}\n\n\tldns_rr_free(rr1);\n\tldns_rr_free(rr2);\n\n\treturn result;\n}\n\nint\nldns_rr_list_compare(const ldns_rr_list *rrl1, const ldns_rr_list *rrl2)\n{\n\tsize_t i = 0;\n\tint rr_cmp;\n\n\tassert(rrl1 != NULL);\n\tassert(rrl2 != NULL);\n\n\tfor (i = 0; i < ldns_rr_list_rr_count(rrl1) && i < ldns_rr_list_rr_count(rrl2); i++) {\n\t\trr_cmp = ldns_rr_compare(ldns_rr_list_rr(rrl1, i), ldns_rr_list_rr(rrl2, i));\n\t\tif (rr_cmp != 0) {\n\t\t\treturn rr_cmp;\n\t\t}\n\t}\n\n\tif (i == ldns_rr_list_rr_count(rrl1) &&\n\t    i != ldns_rr_list_rr_count(rrl2)) {\n\t\treturn 1;\n\t} else if (i == ldns_rr_list_rr_count(rrl2) &&\n\t           i != ldns_rr_list_rr_count(rrl1)) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nsize_t\nldns_rr_uncompressed_size(const ldns_rr *r)\n{\n\tsize_t rrsize;\n\tsize_t i;\n\n\trrsize = 0;\n\t/* add all the rdf sizes */\n\tfor(i = 0; i < ldns_rr_rd_count(r); i++) {\n\t\trrsize += ldns_rdf_size(ldns_rr_rdf(r, i));\n\t}\n\t/* ownername */\n\trrsize += ldns_rdf_size(ldns_rr_owner(r));\n\trrsize += LDNS_RR_OVERHEAD;\n\treturn rrsize;\n}\n\nvoid\nldns_rr2canonical(ldns_rr *rr)\n{\n\tuint16_t i;\n\n\tif (!rr) {\n\t  return;\n        }\n\n        ldns_dname2canonical(ldns_rr_owner(rr));\n\n\t/*\n\t * lowercase the rdata dnames if the rr type is one\n\t * of the list in chapter 7 of RFC3597\n\t * Also added RRSIG, because a \"Signer's Name\" should be canonicalized\n\t * too. See dnssec-bis-updates-16. We can add it to this list because\n\t * the \"Signer's Name\"  is the only dname type rdata field in a RRSIG.\n\t */\n\tswitch(ldns_rr_get_type(rr)) {\n        \tcase LDNS_RR_TYPE_NS:\n        \tcase LDNS_RR_TYPE_MD:\n        \tcase LDNS_RR_TYPE_MF:\n        \tcase LDNS_RR_TYPE_CNAME:\n        \tcase LDNS_RR_TYPE_SOA:\n        \tcase LDNS_RR_TYPE_MB:\n        \tcase LDNS_RR_TYPE_MG:\n        \tcase LDNS_RR_TYPE_MR:\n        \tcase LDNS_RR_TYPE_PTR:\n        \tcase LDNS_RR_TYPE_MINFO:\n        \tcase LDNS_RR_TYPE_MX:\n        \tcase LDNS_RR_TYPE_RP:\n        \tcase LDNS_RR_TYPE_AFSDB:\n        \tcase LDNS_RR_TYPE_RT:\n        \tcase LDNS_RR_TYPE_SIG:\n        \tcase LDNS_RR_TYPE_PX:\n        \tcase LDNS_RR_TYPE_NXT:\n        \tcase LDNS_RR_TYPE_NAPTR:\n        \tcase LDNS_RR_TYPE_KX:\n        \tcase LDNS_RR_TYPE_SRV:\n        \tcase LDNS_RR_TYPE_DNAME:\n        \tcase LDNS_RR_TYPE_A6:\n        \tcase LDNS_RR_TYPE_RRSIG:\n\t\t\tfor (i = 0; i < ldns_rr_rd_count(rr); i++) {\n\t\t\t\tldns_dname2canonical(ldns_rr_rdf(rr, i));\n\t\t\t}\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* do nothing */\n\t\t\treturn;\n\t}\n}\n\nvoid\nldns_rr_list2canonical(const ldns_rr_list *rr_list)\n{\n\tsize_t i;\n\tfor (i = 0; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\tldns_rr2canonical(ldns_rr_list_rr(rr_list, i));\n\t}\n}\n\nuint8_t\nldns_rr_label_count(const ldns_rr *rr)\n{\n\tif (!rr) {\n\t\treturn 0;\n\t}\n\treturn ldns_dname_label_count(\n\t\t\tldns_rr_owner(rr));\n}\n\n/** \\cond */\nstatic const ldns_rdf_type type_0_wireformat[] = { LDNS_RDF_TYPE_UNKNOWN };\nstatic const ldns_rdf_type type_a_wireformat[] = { LDNS_RDF_TYPE_A };\nstatic const ldns_rdf_type type_ns_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_md_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_mf_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_cname_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_soa_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_INT32, \n\tLDNS_RDF_TYPE_PERIOD, LDNS_RDF_TYPE_PERIOD, LDNS_RDF_TYPE_PERIOD,\n\tLDNS_RDF_TYPE_PERIOD\n};\nstatic const ldns_rdf_type type_mb_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_mg_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_mr_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_wks_wireformat[] = {\n\tLDNS_RDF_TYPE_A, LDNS_RDF_TYPE_WKS\n};\nstatic const ldns_rdf_type type_ptr_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_hinfo_wireformat[] = {\n\tLDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_minfo_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_mx_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_rp_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_afsdb_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_x25_wireformat[] = { LDNS_RDF_TYPE_STR };\nstatic const ldns_rdf_type type_isdn_wireformat[] = {\n\tLDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_rt_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_nsap_wireformat[] = {\n\tLDNS_RDF_TYPE_NSAP\n};\nstatic const ldns_rdf_type type_nsap_ptr_wireformat[] = {\n\tLDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_sig_wireformat[] = {\n\tLDNS_RDF_TYPE_TYPE, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_key_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_px_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_gpos_wireformat[] = {\n\tLDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_aaaa_wireformat[] = { LDNS_RDF_TYPE_AAAA };\nstatic const ldns_rdf_type type_loc_wireformat[] = { LDNS_RDF_TYPE_LOC };\nstatic const ldns_rdf_type type_nxt_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_UNKNOWN\n};\nstatic const ldns_rdf_type type_eid_wireformat[] = {\n\tLDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_nimloc_wireformat[] = {\n\tLDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_srv_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_atma_wireformat[] = {\n\tLDNS_RDF_TYPE_ATMA\n};\nstatic const ldns_rdf_type type_naptr_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_kx_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_cert_wireformat[] = {\n\t LDNS_RDF_TYPE_CERT_ALG, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_a6_wireformat[] = { LDNS_RDF_TYPE_UNKNOWN };\nstatic const ldns_rdf_type type_dname_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_sink_wireformat[] = { LDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_apl_wireformat[] = {\n\tLDNS_RDF_TYPE_APL\n};\nstatic const ldns_rdf_type type_ds_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_sshfp_wireformat[] = {\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_ipseckey_wireformat[] = {\n\tLDNS_RDF_TYPE_IPSECKEY\n};\nstatic const ldns_rdf_type type_rrsig_wireformat[] = {\n\tLDNS_RDF_TYPE_TYPE, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_nsec_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_NSEC\n};\nstatic const ldns_rdf_type type_dhcid_wireformat[] = {\n\tLDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_talink_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\n#ifdef RRTYPE_OPENPGPKEY\nstatic const ldns_rdf_type type_openpgpkey_wireformat[] = {\n\tLDNS_RDF_TYPE_B64\n};\n#endif\nstatic const ldns_rdf_type type_csync_wireformat[] = {\n\tLDNS_RDF_TYPE_INT32, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_NSEC\n};\nstatic const ldns_rdf_type type_zonemd_wireformat[] = {\n\tLDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_HEX\n};\n\n/* nsec3 is some vars, followed by same type of data of nsec */\nstatic const ldns_rdf_type type_nsec3_wireformat[] = {\n/*\tLDNS_RDF_TYPE_NSEC3_VARS, LDNS_RDF_TYPE_NSEC3_NEXT_OWNER, LDNS_RDF_TYPE_NSEC*/\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_NSEC3_SALT, LDNS_RDF_TYPE_NSEC3_NEXT_OWNER, LDNS_RDF_TYPE_NSEC\n};\n\nstatic const ldns_rdf_type type_nsec3param_wireformat[] = {\n/*\tLDNS_RDF_TYPE_NSEC3_PARAMS_VARS*/\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_NSEC3_SALT\n};\n\nstatic const ldns_rdf_type type_dnskey_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_ALG,\n\tLDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_tkey_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME,\n\tLDNS_RDF_TYPE_TIME,\n\tLDNS_RDF_TYPE_TIME,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16_DATA,\n\tLDNS_RDF_TYPE_INT16_DATA,\n};\nstatic const ldns_rdf_type type_tsig_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME,\n\tLDNS_RDF_TYPE_TSIGTIME,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16_DATA,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16_DATA\n};\nstatic const ldns_rdf_type type_tlsa_wireformat[] = {\n\tLDNS_RDF_TYPE_CERTIFICATE_USAGE,\n\tLDNS_RDF_TYPE_SELECTOR,\n\tLDNS_RDF_TYPE_MATCHING_TYPE,\n\tLDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_hip_wireformat[] = {\n\tLDNS_RDF_TYPE_HIP\n};\nstatic const ldns_rdf_type type_nid_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_ILNP64\n};\nstatic const ldns_rdf_type type_l32_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_A\n};\nstatic const ldns_rdf_type type_l64_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_ILNP64\n};\nstatic const ldns_rdf_type type_lp_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_eui48_wireformat[] = {\n\tLDNS_RDF_TYPE_EUI48\n};\nstatic const ldns_rdf_type type_eui64_wireformat[] = {\n\tLDNS_RDF_TYPE_EUI64\n};\nstatic const ldns_rdf_type type_uri_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_LONG_STR\n};\nstatic const ldns_rdf_type type_caa_wireformat[] = {\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_TAG,\n\tLDNS_RDF_TYPE_LONG_STR\n};\n#ifdef RRTYPE_DOA\nstatic const ldns_rdf_type type_doa_wireformat[] = {\n\tLDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_STR,\n\tLDNS_RDF_TYPE_B64\n};\n#endif\n#ifdef RRTYPE_AMTRELAY\nstatic const ldns_rdf_type type_amtrelay_wireformat[] = {\n\tLDNS_RDF_TYPE_AMTRELAY\n};\n#endif\n\n\n/** \\endcond */\n\n/** \\cond */\n/* All RR's defined in 1035 are well known and can thus\n * be compressed. See RFC3597. These RR's are:\n * CNAME HINFO MB MD MF MG MINFO MR MX NULL NS PTR SOA TXT\n */\nstatic ldns_rr_descriptor rdata_field_descriptors[] = {\n\t/* 0 */\n\t{ 0, NULL, 0, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 1 */\n\t{LDNS_RR_TYPE_A, \"A\", 1, 1, type_a_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 2 */\n\t{LDNS_RR_TYPE_NS, \"NS\", 1, 1, type_ns_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 3 */\n\t{LDNS_RR_TYPE_MD, \"MD\", 1, 1, type_md_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 4 */\n\t{LDNS_RR_TYPE_MF, \"MF\", 1, 1, type_mf_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 5 */\n\t{LDNS_RR_TYPE_CNAME, \"CNAME\", 1, 1, type_cname_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 6 */\n\t{LDNS_RR_TYPE_SOA, \"SOA\", 7, 7, type_soa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 2 },\n\t/* 7 */\n\t{LDNS_RR_TYPE_MB, \"MB\", 1, 1, type_mb_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 8 */\n\t{LDNS_RR_TYPE_MG, \"MG\", 1, 1, type_mg_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 9 */\n\t{LDNS_RR_TYPE_MR, \"MR\", 1, 1, type_mr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 10 */\n\t{LDNS_RR_TYPE_NULL, \"NULL\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 11 */\n\t{LDNS_RR_TYPE_WKS, \"WKS\", 2, 2, type_wks_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 12 */\n\t{LDNS_RR_TYPE_PTR, \"PTR\", 1, 1, type_ptr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 13 */\n\t{LDNS_RR_TYPE_HINFO, \"HINFO\", 2, 2, type_hinfo_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 14 */\n\t{LDNS_RR_TYPE_MINFO, \"MINFO\", 2, 2, type_minfo_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 2 },\n\t/* 15 */\n\t{LDNS_RR_TYPE_MX, \"MX\", 2, 2, type_mx_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 16 */\n\t{LDNS_RR_TYPE_TXT, \"TXT\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 17 */\n\t{LDNS_RR_TYPE_RP, \"RP\", 2, 2, type_rp_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 2 },\n\t/* 18 */\n\t{LDNS_RR_TYPE_AFSDB, \"AFSDB\", 2, 2, type_afsdb_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 19 */\n\t{LDNS_RR_TYPE_X25, \"X25\", 1, 1, type_x25_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 20 */\n\t{LDNS_RR_TYPE_ISDN, \"ISDN\", 1, 2, type_isdn_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 21 */\n\t{LDNS_RR_TYPE_RT, \"RT\", 2, 2, type_rt_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 22 */\n\t{LDNS_RR_TYPE_NSAP, \"NSAP\", 1, 1, type_nsap_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 23 */\n\t{LDNS_RR_TYPE_NSAP_PTR, \"NSAP-PTR\", 1, 1, type_nsap_ptr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 24 */\n\t{LDNS_RR_TYPE_SIG, \"SIG\", 9, 9, type_sig_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 25 */\n\t{LDNS_RR_TYPE_KEY, \"KEY\", 4, 4, type_key_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 26 */\n\t{LDNS_RR_TYPE_PX, \"PX\", 3, 3, type_px_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 2 },\n\t/* 27 */\n\t{LDNS_RR_TYPE_GPOS, \"GPOS\", 3, 3, type_gpos_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 28 */\n\t{LDNS_RR_TYPE_AAAA, \"AAAA\", 1, 1, type_aaaa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 29 */\n\t{LDNS_RR_TYPE_LOC, \"LOC\", 1, 1, type_loc_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 30 */\n\t{LDNS_RR_TYPE_NXT, \"NXT\", 2, 2, type_nxt_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 31 */\n\t{LDNS_RR_TYPE_EID, \"EID\", 1, 1, type_eid_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 32 */\n\t{LDNS_RR_TYPE_NIMLOC, \"NIMLOC\", 1, 1, type_nimloc_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 33 */\n\t{LDNS_RR_TYPE_SRV, \"SRV\", 4, 4, type_srv_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 34 */\n\t{LDNS_RR_TYPE_ATMA, \"ATMA\", 1, 1, type_atma_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 35 */\n\t{LDNS_RR_TYPE_NAPTR, \"NAPTR\", 6, 6, type_naptr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 36 */\n\t{LDNS_RR_TYPE_KX, \"KX\", 2, 2, type_kx_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 37 */\n\t{LDNS_RR_TYPE_CERT, \"CERT\", 4, 4, type_cert_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 38 */\n\t{LDNS_RR_TYPE_A6, \"A6\", 1, 1, type_a6_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 39 */\n\t{LDNS_RR_TYPE_DNAME, \"DNAME\", 1, 1, type_dname_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 40 */\n\t{LDNS_RR_TYPE_SINK, \"SINK\", 1, 1, type_sink_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 41 */\n\t{LDNS_RR_TYPE_OPT, \"OPT\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 42 */\n\t{LDNS_RR_TYPE_APL, \"APL\", 0, 0, type_apl_wireformat, LDNS_RDF_TYPE_APL, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 43 */\n\t{LDNS_RR_TYPE_DS, \"DS\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 44 */\n\t{LDNS_RR_TYPE_SSHFP, \"SSHFP\", 3, 3, type_sshfp_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 45 */\n\t{LDNS_RR_TYPE_IPSECKEY, \"IPSECKEY\", 1, 1, type_ipseckey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 46 */\n\t{LDNS_RR_TYPE_RRSIG, \"RRSIG\", 9, 9, type_rrsig_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 47 */\n\t{LDNS_RR_TYPE_NSEC, \"NSEC\", 1, 2, type_nsec_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 48 */\n\t{LDNS_RR_TYPE_DNSKEY, \"DNSKEY\", 4, 4, type_dnskey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 49 */\n\t{LDNS_RR_TYPE_DHCID, \"DHCID\", 1, 1, type_dhcid_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 50 */\n\t{LDNS_RR_TYPE_NSEC3, \"NSEC3\", 5, 6, type_nsec3_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 51 */\n\t{LDNS_RR_TYPE_NSEC3PARAM, \"NSEC3PARAM\", 4, 4, type_nsec3param_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 52 */\n\t{LDNS_RR_TYPE_TLSA, \"TLSA\", 4, 4, type_tlsa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t{LDNS_RR_TYPE_SMIMEA, \"SMIMEA\", 4, 4, type_tlsa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE54\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 55\n\t * Hip ends with 0 or more Rendezvous Servers represented as dname's.\n\t * Hence the LDNS_RDF_TYPE_DNAME _variable field and the _maximum field\n\t * set to 0.\n\t */\n\t{LDNS_RR_TYPE_HIP, \"HIP\", 1, 1, type_hip_wireformat, LDNS_RDF_TYPE_DNAME, LDNS_RR_NO_COMPRESS, 0 },\n\n#ifdef RRTYPE_NINFO\n\t/* 56 */\n\t{LDNS_RR_TYPE_NINFO, \"NINFO\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE56\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n#ifdef RRTYPE_RKEY\n\t/* 57 */\n\t{LDNS_RR_TYPE_RKEY, \"RKEY\", 4, 4, type_key_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE57\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\t/* 58 */\n\t{LDNS_RR_TYPE_TALINK, \"TALINK\", 2, 2, type_talink_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 2 },\n\n\t/* 59 */\n\t{LDNS_RR_TYPE_CDS, \"CDS\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 60 */\n\t{LDNS_RR_TYPE_CDNSKEY, \"CDNSKEY\", 4, 4, type_dnskey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n#ifdef RRTYPE_OPENPGPKEY\n\t/* 61 */\n\t{LDNS_RR_TYPE_OPENPGPKEY, \"OPENPGPKEY\", 1, 1, type_openpgpkey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE61\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\n{LDNS_RR_TYPE_CSYNC, \"CSYNC\", 3, 3, type_csync_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_ZONEMD, \"ZONEMD\", 4, 4, type_zonemd_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE64\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE65\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE66\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE67\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE68\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE69\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE70\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE71\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE72\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE73\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE74\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE75\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE76\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE77\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE78\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE79\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE80\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE81\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE82\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE83\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE84\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE85\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE86\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE87\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE88\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE89\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE90\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE91\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE92\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE93\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE94\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE95\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE96\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE97\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE98\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 99 */\n\t{LDNS_RR_TYPE_SPF,  \"SPF\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* UINFO  [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE100\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* UID    [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE101\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* GID    [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE102\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* UNSPEC [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE103\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 104 */\n\t{LDNS_RR_TYPE_NID, \"NID\", 2, 2, type_nid_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 105 */\n\t{LDNS_RR_TYPE_L32, \"L32\", 2, 2, type_l32_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 106 */\n\t{LDNS_RR_TYPE_L64, \"L64\", 2, 2, type_l64_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 107 */\n\t{LDNS_RR_TYPE_LP, \"LP\", 2, 2, type_lp_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 108 */\n\t{LDNS_RR_TYPE_EUI48, \"EUI48\", 1, 1, type_eui48_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 109 */\n\t{LDNS_RR_TYPE_EUI64, \"EUI64\", 1, 1, type_eui64_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n{LDNS_RR_TYPE_NULL, \"TYPE110\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE111\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE112\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE113\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE114\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE115\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE116\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE117\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE118\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE119\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE120\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE121\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE122\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE123\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE124\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE125\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE126\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE127\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE128\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE129\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE130\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE131\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE132\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE133\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE134\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE135\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE136\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE137\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE138\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE139\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE140\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE141\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE142\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE143\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE144\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE145\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE146\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE147\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE148\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE149\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE150\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE151\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE152\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE153\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE154\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE155\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE156\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE157\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE158\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE159\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE160\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE161\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE162\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE163\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE164\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE165\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE166\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE167\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE168\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE169\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE170\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE171\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE172\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE173\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE174\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE175\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE176\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE177\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE178\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE179\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE180\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE181\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE182\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE183\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE184\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE185\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE186\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE187\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE188\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE189\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE190\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE191\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE192\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE193\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE194\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE195\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE196\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE197\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE198\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE199\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE200\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE201\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE202\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE203\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE204\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE205\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE206\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE207\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE208\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE209\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE210\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE211\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE212\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE213\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE214\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE215\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE216\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE217\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE218\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE219\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE220\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE221\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE222\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE223\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE224\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE225\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE226\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE227\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE228\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE229\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE230\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE231\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE232\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE233\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE234\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE235\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE236\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE237\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE238\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE239\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE240\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE241\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE242\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE243\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE244\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE245\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE246\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE247\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE248\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* LDNS_RDF_TYPE_INT16_DATA takes two fields (length and data) as one.\n\t * So, unlike RFC 2930 spec, we have 7 min/max rdf's i.s.o. 8/9.\n\t */\n\t/* 249 */\n\t{LDNS_RR_TYPE_TKEY, \"TKEY\", 7, 7, type_tkey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* LDNS_RDF_TYPE_INT16_DATA takes two fields (length and data) as one.\n\t * So, unlike RFC 2930 spec, we have 7 min/max rdf's i.s.o. 8/9.\n\t */\n\t/* 250 */\n\t{LDNS_RR_TYPE_TSIG, \"TSIG\", 7, 7, type_tsig_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\n\t/* IXFR: A request for a transfer of an incremental zone transfer */\n{LDNS_RR_TYPE_NULL, \"TYPE251\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* AXFR: A request for a transfer of an entire zone */\n{LDNS_RR_TYPE_NULL, \"TYPE252\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* MAILB: A request for mailbox-related records (MB, MG or MR) */\n{LDNS_RR_TYPE_NULL, \"TYPE253\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* MAILA: A request for mail agent RRs (Obsolete - see MX) */\n{LDNS_RR_TYPE_NULL, \"TYPE254\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* ANY: A request for all (available) records */\n{LDNS_RR_TYPE_NULL, \"TYPE255\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 256 */\n\t{LDNS_RR_TYPE_URI, \"URI\", 3, 3, type_uri_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 257 */\n\t{LDNS_RR_TYPE_CAA, \"CAA\", 3, 3, type_caa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n#ifdef RRTYPE_AVC\n\t/* 258 */\n\t{LDNS_RR_TYPE_AVC, \"AVC\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE258\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n#ifdef RRTYPE_DOA\n\t/* 259 */\n\t{LDNS_RR_TYPE_DOA, \"DOA\", 5, 5, type_doa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE259\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n#ifdef RRTYPE_AMTRELAY\n\t/* 260 */\n\t{LDNS_RR_TYPE_AMTRELAY, \"AMTRELAY\", 1, 1, type_amtrelay_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE260\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\n/* split in array, no longer contiguous */\n\n#ifdef RRTYPE_TA\n\t/* 32768 */\n\t{LDNS_RR_TYPE_TA, \"TA\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE32768\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\t/* 32769 */\n\t{LDNS_RR_TYPE_DLV, \"DLV\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 }\n};\n/** \\endcond */\n\n/**\n * \\def LDNS_RDATA_FIELD_DESCRIPTORS_COUNT\n * computes the number of rdata fields\n */\n#define LDNS_RDATA_FIELD_DESCRIPTORS_COUNT \\\n\t(sizeof(rdata_field_descriptors)/sizeof(rdata_field_descriptors[0]))\n\n\n/*---------------------------------------------------------------------------*\n * The functions below return an bitmap RDF with the space required to set\n * or unset all known RR types. Arguably these functions are better situated\n * in rdata.c, however for the space calculation it is necesarry to walk\n * through rdata_field_descriptors which is not easily possible from anywhere\n * other than rr.c where it is declared static.\n *\n * Alternatively rr.c could have provided an iterator for rr_type or \n * rdf_descriptors, but this seemed overkill for internal use only.\n */\nstatic ldns_rr_descriptor* rdata_field_descriptors_end =\n\t&rdata_field_descriptors[LDNS_RDATA_FIELD_DESCRIPTORS_COUNT];\n\n/* From RFC3845:\n *\n * 2.1.2.  The List of Type Bit Map(s) Field\n * \n *    The RR type space is split into 256 window blocks, each representing\n *    the low-order 8 bits of the 16-bit RR type space.  Each block that\n *    has at least one active RR type is encoded using a single octet\n *    window number (from 0 to 255), a single octet bitmap length (from 1\n *    to 32) indicating the number of octets used for the window block's\n *    bitmap, and up to 32 octets (256 bits) of bitmap.\n * \n *    Window blocks are present in the NSEC RR RDATA in increasing\n *    numerical order.\n * \n *    \"|\" denotes concatenation\n * \n *    Type Bit Map(s) Field = ( Window Block # | Bitmap Length | Bitmap ) +\n * \n *    <cut>\n * \n *    Blocks with no types present MUST NOT be included.  Trailing zero\n *    octets in the bitmap MUST be omitted.  The length of each block's\n *    bitmap is determined by the type code with the largest numerical\n *    value within that block, among the set of RR types present at the\n *    NSEC RR's owner name.  Trailing zero octets not specified MUST be\n *    interpreted as zero octets.\n */\nstatic ldns_status\nldns_rdf_bitmap_known_rr_types_set(ldns_rdf** rdf, int value)\n{\n\tuint8_t  window;\t\t/*  most significant octet of type */\n\tuint8_t  subtype;\t\t/* least significant octet of type */\n\tuint16_t windows[256]\t\t/* Max subtype per window */\n#ifndef S_SPLINT_S\n\t                      = { 0 }\n#endif\n\t                             ;\n\tldns_rr_descriptor* d;\t/* used to traverse rdata_field_descriptors */\n\tsize_t i;\t\t/* used to traverse windows array */\n\n\tsize_t sz;\t\t\t/* size needed for type bitmap rdf */\n\tuint8_t* data = NULL;\t\t/* rdf data */\n\tuint8_t* dptr;\t\t\t/* used to itraverse rdf data */\n\n\tassert(rdf != NULL);\n\n\t/* Which windows need to be in the bitmap rdf?\n\t */\n\tfor (d=rdata_field_descriptors; d < rdata_field_descriptors_end; d++) {\n\t\twindow  = d->_type >> 8;\n\t\tsubtype = d->_type & 0xff;\n\t\tif (windows[window] < subtype) {\n\t\t\twindows[window] = subtype;\n\t\t}\n\t}\n\n\t/* How much space do we need in the rdf for those windows?\n\t */\n\tsz = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (windows[i]) {\n\t\t\tsz += windows[i] / 8 + 3;\n\t\t}\n\t}\n\tif (sz > 0) {\n\t\t/* Format rdf data according RFC3845 Section 2.1.2 (see above)\n\t\t */\n\t\tdptr = data = LDNS_XMALLOC(uint8_t, sz);\n\t\tif (!data) {\n\t\t\treturn LDNS_STATUS_MEM_ERR;\n\t\t}\n\t\tmemset(data, value, sz);\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (windows[i]) {\n\t\t\t\t*dptr++ = (uint8_t)i;\n\t\t\t\t*dptr++ = (uint8_t)(windows[i] / 8 + 1);\n\t\t\t\tdptr += dptr[-1];\n\t\t\t}\n\t\t}\n\t}\n\t/* Allocate and return rdf structure for the data\n\t */\n\t*rdf = ldns_rdf_new(LDNS_RDF_TYPE_BITMAP, sz, data);\n\tif (!*rdf) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}\n\nldns_status\nldns_rdf_bitmap_known_rr_types_space(ldns_rdf** rdf)\n{\n\treturn ldns_rdf_bitmap_known_rr_types_set(rdf, 0);\n}\n\nldns_status\nldns_rdf_bitmap_known_rr_types(ldns_rdf** rdf)\n{\n\treturn ldns_rdf_bitmap_known_rr_types_set(rdf, 255);\n}\n/* End of RDF bitmap functions\n *---------------------------------------------------------------------------*/\n\n\nconst ldns_rr_descriptor *\nldns_rr_descript(uint16_t type)\n{\n\tsize_t i;\n\tif (type < LDNS_RDATA_FIELD_DESCRIPTORS_COMMON) {\n\t\treturn &rdata_field_descriptors[type];\n\t} else {\n\t\t/* because not all array index equals type code */\n\t\tfor (i = LDNS_RDATA_FIELD_DESCRIPTORS_COMMON;\n\t\t     i < LDNS_RDATA_FIELD_DESCRIPTORS_COUNT;\n\t\t     i++) {\n\t\t        if (rdata_field_descriptors[i]._type == type) {\n\t\t     \t\treturn &rdata_field_descriptors[i];\n\t\t\t}\n\t\t}\n                return &rdata_field_descriptors[0];\n\t}\n}\n\nsize_t\nldns_rr_descriptor_minimum(const ldns_rr_descriptor *descriptor)\n{\n\tif (descriptor) {\n\t\treturn descriptor->_minimum;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nsize_t\nldns_rr_descriptor_maximum(const ldns_rr_descriptor *descriptor)\n{\n\tif (descriptor) {\n\t\tif (descriptor->_variable != LDNS_RDF_TYPE_NONE) {\n\t\t\t/* Should really be SIZE_MAX... bad FreeBSD.  */\n\t\t\treturn UINT_MAX;\n\t\t} else {\n\t\t\treturn descriptor->_maximum;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nldns_rdf_type\nldns_rr_descriptor_field_type(const ldns_rr_descriptor *descriptor,\n                              size_t index)\n{\n\tassert(descriptor != NULL);\n\tassert(index < descriptor->_maximum\n\t       || descriptor->_variable != LDNS_RDF_TYPE_NONE);\n\tif (index < descriptor->_maximum) {\n\t\treturn descriptor->_wireformat[index];\n\t} else {\n\t\treturn descriptor->_variable;\n\t}\n}\n\nldns_rr_type\nldns_get_rr_type_by_name(const char *name)\n{\n\tunsigned int i;\n\tconst char *desc_name;\n\tconst ldns_rr_descriptor *desc;\n\n\t/* TYPEXX representation */\n\tif (strlen(name) > 4 && strncasecmp(name, \"TYPE\", 4) == 0) {\n\t\treturn atoi(name + 4);\n\t}\n\n\t/* Normal types */\n\tfor (i = 0; i < (unsigned int) LDNS_RDATA_FIELD_DESCRIPTORS_COUNT; i++) {\n\t\tdesc = &rdata_field_descriptors[i];\n\t\tdesc_name = desc->_name;\n\t\tif(desc_name &&\n\t\t   strlen(name) == strlen(desc_name) &&\n\t\t   strncasecmp(name, desc_name, strlen(desc_name)) == 0) {\n\t\t\t/* because not all array index equals type code */\n\t\t\treturn desc->_type;\n\t\t}\n\t}\n\n\t/* special cases for query types */\n\tif (strlen(name) == 4 && strncasecmp(name, \"IXFR\", 4) == 0) {\n\t\treturn 251;\n\t} else if (strlen(name) == 4 && strncasecmp(name, \"AXFR\", 4) == 0) {\n\t\treturn 252;\n\t} else if (strlen(name) == 5 && strncasecmp(name, \"MAILB\", 5) == 0) {\n\t\treturn 253;\n\t} else if (strlen(name) == 5 && strncasecmp(name, \"MAILA\", 5) == 0) {\n\t\treturn 254;\n\t} else if (strlen(name) == 3 && strncasecmp(name, \"ANY\", 3) == 0) {\n\t\treturn 255;\n\t}\n\n\treturn 0;\n}\n\nldns_rr_class\nldns_get_rr_class_by_name(const char *name)\n{\n\tldns_lookup_table *lt;\n\n\t/* CLASSXX representation */\n\tif (strlen(name) > 5 && strncasecmp(name, \"CLASS\", 5) == 0) {\n\t\treturn atoi(name + 5);\n\t}\n\n\t/* Normal types */\n\tlt = ldns_lookup_by_name(ldns_rr_classes, name);\n\n\tif (lt) {\n\t\treturn lt->id;\n\t}\n\treturn 0;\n}\n\n\nldns_rr_type\nldns_rdf2rr_type(const ldns_rdf *rd)\n{\n        ldns_rr_type r;\n\n        if (!rd) {\n                return 0;\n        }\n\n        if (ldns_rdf_get_type(rd) != LDNS_RDF_TYPE_TYPE) {\n                return 0;\n        }\n\n        r = (ldns_rr_type) ldns_rdf2native_int16(rd);\n        return r;\n}\n\nldns_rr_type\nldns_rr_list_type(const ldns_rr_list *rr_list)\n{\n\tif (rr_list && ldns_rr_list_rr_count(rr_list) > 0) {\n\t\treturn ldns_rr_get_type(ldns_rr_list_rr(rr_list, 0));\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nldns_rdf *\nldns_rr_list_owner(const ldns_rr_list *rr_list)\n{\n\tif (rr_list && ldns_rr_list_rr_count(rr_list) > 0) {\n\t\treturn ldns_rr_owner(ldns_rr_list_rr(rr_list, 0));\n\t} else {\n\t\treturn NULL;\n\t}\n}\n"], "fixing_code": ["...\n\t* bugfix #70: heap Out-of-bound Read vulnerability in\n\t  rr_frm_str_internal reported by pokerfacett.\n\n1.7.1\t2019-07-26\n\t* bugfix: Manage verification paths for OpenSSL >= 1.1.0\n\t  Thanks Marco Davids\n\t* bugfix #4106: find the SDK on MacOS X <= 10.6\n\t  Thanks Bill Cole\n\t* bugfix #4155: ldns-config contains never used variables\n\t  Thanks Petr Men\u0161\u00edk\n\t* bugfix #4221: drill -x crashes with malformed IPv4 address \n\t  Thanks Oleksandr Tymoshenko\n\t* bugfix #3437: CDS & CDNSKEY RRsets should be signed with the KSK\n\t  Thanks Tony Finch\n\t* bugfix #1566, #1568, #1569, #1570: Potential NULL Dereferences\n\t  Thanks Bill Parker\n\t* bugfix #1260: Anticipate strchr returning NULL on unfound char\n\t  Thanks Stephan Zeisberg\n\t* bugfix #1257: Free after reallocing to 0 size\n\t  Thanks Stephan Zeisberg\n\t* bugfix #1256: Check parse limit before t increment\n\t  Thanks Stephan Zeisberg\n\t* bugfix #1245: Only one signature per RRset needs to be valid with\n\t  ldns-verify-zone.  Thanks Emil Natan.\n\t* ldns-notify can use all supported hash algorithms with -y.\n\t* bugfix #1209: make install ldns.pc file\n\t  Thanks Oleksandr Natalenko\n\t* bugfix #1218: Only chase DS if signer is parent of owner.\n\t  Thanks Emil Natan\n\t* bugfix #617: Retry WKS service and protocol names lower case.\n\t  Thanks Siali Yan\n\t* Spelling errors in binaries and man pages\n\t  Thanks Andreas Schulze\n\t* removed duplicate condition in ldns_udp_send_query.\n\t* ldns_wire2pkt: fix null pointer dereference if pkt allocation fails\n\t  and fix memory leak with more EDNS sections\n\t  Thanks Jan Vcelak\n\t* bugfix #1399: ldns_pkt2wire() Python binding is broken.\n\t  Thanks James Raftery\n\t* ED25519 and ED448 support. Default is to autodetect support in\n\t  OpenSSL.  Disable with --disable-ed25519 and --disable-ed448.\n\t* ldns-notify: can have IPv6 address as argument.\n\t* Fix time sensitive TSIG compare vulnerability.\n\t* Fix that ldns-testns ignores sigpipe.\n\t* Fix that ldns-notify sets the query RR as question RR, this\n\t  removes the wrong TTL and 0 rdata from the packet printout.\n\t* Allow -T flag to be used together with drill -x\n\t* Python bindings compile with swig 4.0\n\t  Thanks Jitka Plesn\u00edkov\u00e1\n\t* bugfix #4248: drill -DT fails for CNAME domain\n\t  Thanks Thom Wiggers\n\t* bugfix #4214: Various fixes and leaks found by coverity.\n\t  Thanks Petr Men\u0161\u00edk \n\t* Feature #3394: An -I option to ldns-notify to specify a source\n\t  IP address to send to notify from.  Thanks Geert Hendrickx\n\t* Bugfix #279: New API functions ldns_udp_connect2,\n\t  ldns_tcp_connect2, ldns_udp_bgsend2 and ldns_tcp_bgsend2,\n\t  that return -1 on failure and allow socket number 0\n\t  to be returned too.  Thanks Joerg Sonnenberger\n\t* Bugfix #1447: More verbose reporting of chasing problems with\n\t  ldns-verify-zone.  Thanks Stephane Guedon\n\t* OpenSSL engine support with ldns-signzone.\n\t  See also https://penzin.net/ldns-signzone/\n\t  Many thanks Vadim Penzin.\n\t* Various improvements found with shellcheck.\n\t  Thanks Jeffrey Walton\n\t* PR #36 Update manpage of ldns-notify to mention algorithm\n\t  support with TSIG.  Thanks Anand Buddhdev\n\t* Compile warnings with signed char input to to_lower()\n\t  and is_digit() with NetBSD.  Thanks H\u00e5vard Eidnes\n\t* Missing Makefile.PL in DNS-LDNS perl module contribution.\n\t  Thanks Jaap Akkerhuis\n\n1.7.0\t2016-12-20\n\t* Fix lookup of relative names in ldns_resolver_search.\n\t* bugfix #548: Double free for answers > 4096 in ldns_resolver_send_pkt\n\t* Follow CNAME's when tracing with drill (TODO dnssec trace)\n\t* Fix #551 change Regent to Copyright holder in BSD license in\n\t  some of the headings of the file, to match the opensource.org\n\t  BSD license.\n\t* -e option makes ldns-compare-zones exit with status code 2 on difference\n\t* Filter out specified RR types with ldns-read-zone -e and -E options\n\t* bugfix #563: Correct DNSKEY from DSA private key. Thanks Peter Koch.\n\t* bugfix #562: ldns-keygen match DSA key maximum size with library.\n\t  And check keysizes with all algorithms. Thanks Peter Koch.\n\t* ldns-verify-zone accepts only one single zonefile as argument.\n\t* bugfix #573: ldns-keygen write private keys with mode 0600.\n\t  Thanks Leon Weber\n\t* Fix configure to make ldns compile with LibreSSL 2.0\n\t* drill now also accepts dig style -y option\n\t  (-y <[algo:]name:key> i.s.o. -y <name:key[:algo]>)\n\t* OPENPGPKEY draft rr types. Enable with: --enable-rrtype-openpgpkey\n\t* bugfix #608: Correct comment about escaped characters\n\t* CDS and CDNSKEY rr type from RFC 7344.\n\t  --enable-rrtype-cds configure option removed\n\t* fix: Memory leak in ldns_pkt_rr_list_by_name()\n\t  Thanks Johannes Naab\n\t* fix: Memory leak in ldns_dname2buffer_wire_compress()\n\t  Thanks Max Liebkies\n\t* bugfix #613: Allow tab as whitespace too in last rdata field of types\n\t  of variable length.  Thanks Xiali Yan\n\t* bugfix: strip trailing whitespace from $ORIGIN lines in zone files\n\t* Let ldns-keygen output .ds files only for KSK keys\n\t* Parse RFC7218 TLSA mnemonics, but do not output them\n\t* Let ldns-dane use SPKI as the default selector i.s.o. Cert\n\t* bugfix: Fit left over NSEC3s once more before adding empty non\n\t  terminals.  Thanks Stuart Browne\n\t* bugfix #605: Determine default trust anchor location at compile time\n\t  Thanks Peter Koch\n\t* bugfix #697: Double free with ldns-dane create\n\t  Thanks Carsten Strotmann\n\t* bugfix #623: Do not redefine bool type and boolean values\n\t  Thanks Jakob Petsovits\n\t* bugfix #570: Add TLSA, CDS, CDNSKEY and OPENPGPKEY RR types to ldnsx\n\t  Thanks Shussain\n\t* bugfix #575: ldns_pkt_clone() does not copy timestamp field\n\t  Thanks Calle Dybedahl \n\t* bugfix #584: ldns-update fixes.  Send update to port 53, bring manpage\n\t  in sync with the usage text, and don't alter the ldns_resolver passed\n\t  to ldns_update_soa_zone_mname().  Created a ldns_resolver_clone()\n\t  function in the process.  Thanks Nicholas Riley.\n\t* bugfix #633: ldns_pkt_clone() parameter isn't const.\n\t  Thanks Jakop Petsovits\n\t* bugfix: ldns-dane manpage correction\n\t  Thanks Erwin Lansing\n\t* Spelling fixes.  Thanks Andreas Schulze\n\t* Hyphen used as minus in manpages.  Thanks Andreas Schulze.\n\t* RFC7553 RR Type URI is supported by default.\n\t* Fix ECDSA signature generation, do not omit leading zeroes.\n\t* bugfix: Get rid of superfluous newline in ldns-keyfetcher\n\t  Thanks Jan-Piet Mens\n\t* bugfix: -U option to ldns-signzone to sign with every algorithm\n\t  Thanks Guido Kroon\n\t* const function parameters whenever possible.\n\t  Thanks Ray Bellis\n\t* bugfix #725: allow RR-types on the type bitmap window border\n\t  Thanks Pieter Lexis\n\t* bugfix #726: 2 typos in drill manpage.\n\t  Thanks Hugo Lombard\n\t* Add type CSYNC support, RFC 7477.\n\t* Prepare for ED25519, ED448 support: todo convert* routines in\n\t  dnssec.h, once openssl has support for signing with these algorithms.\n\t  The dns algorithm number is not yet allocated. These features are\n\t  not fully implemented yet, openssl (1.1) does not support the\n\t  algorithms enough to generate keys and sign and verify with them.\n\t* Fix _answerfrom comment in ldns_struct_pkt.\n\t* Fix drill axfr ipv4/ipv6 queries.\n\t* Fix comment referring to mk_query in packet.h to pkt_query_new.\n\t* Fix description of QR flag in packet.h.\n\t* Fix for openssl 1.1.0 API changes.\n\t* Remove commented out macro.  Thanks Thiago Farina\n\t* bugfix #641: Include install-sh in .gitignore\n\t* bugfix #825: Module import breaks with newer SWIG versions.\n\t  Thanks Christoph Egger\n\t* bugfix #796 - #792: Fix miscellaneous compiler warning issues.\n\t  Thanks Ngie Cooper\n\t* bugfix #769: Add support for :: in an IPv6 address\n\t  Thanks Hajimu UMEMOTO\n\t* bugfix #760: Detect superfluous text in presentation format\n\t  Thanks Xiali Yan\n\t* bugfix #708: warnings and errors with xcode 6.1/7.0\n\t* bugfix #754: Memory leak in ldns_str2rdf_ipseckey\n\t  Thanks Xiali Yan\n\t* bugfix #661: Fail NSEC3 signing when NSEC domainname length\n\t  would overflow.  Thanks Jan-Piet Mens.\n\t* bugfix #771: hmac-sha224, hmac-sha384 and hmac-sha512 keys.\n\t  Thanks Harald Jenny\n\t* bugfix #680: ldns fails to reject invalidly formatted\n\t  RFC 7553 URI RRs.  Thanks Robert Edmonds\n\t* bugfix #678: Use poll i.s.o. select to support > 1024 fds\n\t  Thanks William King\n\t* Use OpenSSL DANE functions for verification (unless explicitly\n\t  disabled with --disable-dane-ta-usage).\n\t* Bumb .so version\n\t* Include OPENPGPKEY RR type by default\n\t* rdata processing for SMIMEA RR type\n\t* Fix crash in displaying TLSA RR's.\n\t  Thanks Andreas Schulze\n\t* Update ldns-key2ds man page to mention GOST and SHA384 hash\n\t  functions.  Thanks Harald Jenny\n\t* Add sha384 and sha512 tsig algorithm. Thanks Michael Weiser\n\t* Clarify data ownership with consts for tsig parameters.\n\t  Thanks Michael Weiser\n\t* bugfix: Fix detection of DSA support with OpenSSL >= 1.1.0\n\t* bugfix #1160: Provide sha256 for release tarballs\n\t* --enable-gost-anyway compiles GOST support with OpenSSL >= 1.1.0\n\t  even when the GOST engine is not available.\n\n1.6.17\t2014-01-10\n\t* Fix ldns_dnssec_zone_new_frm_fp_l to allow the last parsed line of a\n\t  zone to be an NSEC3 (or its RRSIG) covering an empty non terminal.\n\t* Add --disable-dane option to configure and check availability of the\n\t  for dane needed X509_check_ca function in openssl.\n\t* bugfix #490: Get rid of type-punned pointer warnings.\n\t  Thanks Adam Tkac.\n\t* Make sure executables are linked against libcrypto with the \n\t  LIBSSL_LDFLAGS. Thanks Leo Baltus.\n\t* Miscellaneous prototype fixes. Thanks Dag-Erling Sm\u00f8rgrav.\n\t* README now shows preferred way to configure for examples and drill.\n\t* Bind to source address for resolvers. drill binds to source with -I.\n\t  Thanks Bryan Duff.\n\t* -T option for ldns-dane that has specific exit status for PKIX\n\t  validated connections without (secure) TLSA records.\n\t* Fix b{32,64}_{ntop,pton} detection and handling.\n\t* New RR type TKEY, but without operational practice.\n\t* New RR types HIP, NINFO, RKEY, CDS, EUI48, EUI64, URI, CAA and TA.\n\t* New output format flag (and accompanying functions) to print certain\n\t  RR's as unknown type\n\t* -u and -U parameter for ldns-read-zone to mark/unmark a RR type\n\t  for printing as unknown type\n\t* bugfix #504: GPOS RR has three rdata fields. Thanks Jelte Jansen.\n\t* bugfix #497: Properly test for EOF when reading key files with drill.\n\t* New functions: ldns_pkt_ixfr_request_new and\n\t  ldns_pkt_ixfr_request_new_frm_str.\n\t* Use SNI with ldns-dane\n\t* bugfix #507: ldnsx Fix use of non-existent variables and not\n\t  properly referring to instance variable.  Patch from shussain.\n\t* bugfix #508: ldnsx Adding NSEC3PARAM to known/allowable RR type\n\t  dictionary.  Patch from shussain.\n\t* bugfix #517: ldns_resolver_new_frm_fp error when invoked using a NULL\n\t  file pointer.\n\t* Fix memory leak in contrib/python: ldns_pkt.new_query.\n\t* Fix buffer overflow in fget_token and bget_token.\n\t* ldns-verify-zone NSEC3 checking from quadratic to linear performance.\n\t  Thanks NIC MX (nicmexico.mx)\n\t* ldns-dane setup new ssl session for each new connect to prevent hangs\n\t* bugfix #521: drill trace continue on empty non-terminals with NSEC3\n\t* bugfix #525: Fix documentation of ldns_resolver_set_retry\n\t* Remove unused LDNS_RDF_TYPE_TSIG and associated functions.\n\t* Fix ldns_nsec_covers_name for zones with an apex only. Thanks Miek.\n\t* Configure option to build perl bindings: --with-p5-dns-ldns\n\t  (DNS::LDNS is a contribution from Erik Ostlyngen)\n\t* bugfix #527: Move -lssl before -lcrypto when linking\n\t* Optimize TSIG digest function name comparison (Thanks Marc Buijsman)\n\t* Compare names case insensitive with ldns_pkt_rr_list_by_name and\n\t  ldns_pkt_rr_list_by_name_and_type (thanks Johannes Naab)\n\t* A separate --enable for each draft RR type: --enable-rrtype-ninfo,\n\t  --enable-rrtype-rkey, --enable-rrtype-cds, --enable-rrtype-uri and\n\t  --enable-rrtype-ta\n\t* bugfix #530: Don't sign and verify duplicate RRs (Thanks Jelte Jansen)\n\t* bugfix #505: Manpage and usage output fixes (Thanks Tomas Hozza)\n\t* Adjust ldns_sha1() so that the input data is not modified (Thanks\n\t  Marc Buijsman)\n\t* Messages to stderr are now off by default and can be reenabled with\n\t  the --enable-stderr-msgs configure option.\n\n1.6.16\t2012-11-13\n\t* Fix Makefile to build pyldns with BSD make\n\t* Fix typo in exporting b32_* symbols to make pyldns load again\n\t* Allow leaving the RR owner name empty in ldns-testns datafiles.\n\t* Fix fail to create NSEC3 bitmap for empty non-terminal (bug\n\t  introduced in 1.6.14).\n\n1.6.15\t2012-10-25\n\t* Remove LDNS_STATUS_EXISTS_ERR from ldns/error.h to make ldns\n\t  binary compatible with earlier releases again.\n\n1.6.14\t2012-10-23\n\t* DANE support (RFC6698), including ldns-dane example tool.\n\t* Configurable default CA certificate repository for ldns-dane with\n\t  --with-ca-file=CAFILE and --with-ca-path=CAPATH\n\t* Configurable default trust anchor with --with-trust-anchor=FILE\n\t  for drill, ldns-verify-zone and ldns-dane\n\t* bugfix #474: Define socklen_t when undefined (like in Win32)\n\t* bugfix #473: Dead code removal and resource leak fix in drill\n\t* bugfix #471: Let ldns_resolver_push_dnssec_anchor accept DS RR's too.\n\t* Various bugfixes from code reviews from CZ.NIC and Paul Wouters\n\t* ldns-notify TSIG option argument checking\n\t* Let ldns_resolver_nameservers_randomize keep nameservers and rtt's\n\t  in sync.\n\t* Let ldns_pkt_push_rr now return false on (memory) errors.\n\t* Make buffer_export comply to documentation and fix buffer2str\n\t* Various improvements and fixes of pyldns from Katel Slany\n\t  now documented in their own Changelog.\n\t* bugfix: Make ldns_resolver_pop_nameserver clear the array when\n\t  there was only one.\n\t* bugfix #459: Remove ldns_symbols and export symbols based on regex\n\t* bugfix #458: Track all newly created signatures when signing.\n\t* bugfix #454: Only set -g and -O2 CFLAGS when no CFLAGS was given.\n\t* bugfix #457: Memory leak fix for ldns_key_new_frm_algorithm.\n\t* pyldns memory handling fixes and the python3/ldns-signzone.py\n\t  examples script contribution from Karel Slany.\n\t* bugfix #450: Base # bytes for P, G and Y (T) on the guaranteed\n\t  to be bigger (or equal) P in ldns_key_dsa2bin.\n\t* bugfix #449: Deep free cloned rdf's in ldns_tsig_mac_new.\n\t* bugfix #448: Copy nameserver value (in stead of reference) of the\n\t  answering nameserver to the answer packet in ldns_send_buffer, so\n\t  the original value may be deep freed with the ldns_resolver struct.\n\t* New -0 option for ldns-read-zone to replace inception, expiration\n\t  and signature rdata fields with (null). Thanks Paul Wouters.\n\t* New -p option for ldns-read-zone to prepend-pad SOA serial to take\n\t  up ten characters.\n\t* Return error if printing RR fails due to unknown/null RDATA.\n\n1.6.13\t2012-05-21\n\t* New -S option for ldns-verify-zone to chase signatures online.\n\t* New -k option for ldns-verify-zone to validate using a trusted key.\n\t* New inception and expiration margin options (-i and -e) to \n\t  ldns-verify-zone.\n\t* New ldns_dnssec_zone_new_frm_fp and ldns_dnssec_zone_new_frm_fp_l\n\t  functions.\n\t* New ldns_duration* functions (copied from OpenDNSSEC source)\n\t* fix ldns-verify-zone to allow NSEC3 signatures to come before\n\t  the NSEC3 RR in all cases. Thanks Wolfgang Nagele.\n\t* Zero the correct flag (opt-out) when creating NSEC3PARAMS.\n\t  Thanks Peter van Dijk.\n\t* Canonicalize RRSIG's Signer's name too when validating, because \n\t  bind and unbound do that too. Thanks Peter van Dijk.\n\t* bugfix #433: Allocate rdf using ldns_rdf_new in ldns_dname_label\n\t* bugfix #432: Use LDNS_MALLOC & LDNS_FREE i.s.o. malloc & free\n\t* bugfix #431: Added error message for LDNS_STATUS_INVALID_B32_EXT\n\t* bugfix #427: Explicitely link ssl with the programs that use it.\n\t* Fix reading \\DDD: Error on values that are outside range (>255).\n\t* bugfix #429: fix doxyparse.pl fails on NetBSD because specified\n\t  path to perl.\n\t* New ECDSA support (RFC 6605), use --disable-ecdsa for older openssl.\n\t* fix verifying denial of existence for DS's in NSEC3 Opt-Out zones.\n\t  Thanks John Barnitz\n\n1.6.12\t2012-01-11\n\t* bugfix #413: Fix manpage source for srcdir != builddir\n\t* Canonicalize the signers name rdata field in RRSIGs when signing\n\t* Ignore minor version of Private-key-format (so v1.3 may be used)\n\t* Allow a check_time to be given in stead of always checking against\n\t  the current time. With ldns-verify-zone the check_time can be set\n\t  with the -t option.\n\t* Added functions for updating and manipulating SOA serial numbers.\n\t  ldns-read-zone has an option -S for updating and manipulating the\n\t  serial numbers.\n\t* The library Makefile is now GNU and BSD make compatible.\n\t* bugfix #419: NSEC3 validation of a name covered by a wildcard with\n\t  no data.\n\t* Two new options (--with-drill and --with-examples) to the main\n\t  configure script (in the root of the source tree) to build drill\n\t  and examples too.\n\t* Fix days_since_epoch to year_yday calculation on 32bits systems.\n\n1.6.11\t2011-09-29\n\t* bugfix #394: Fix socket leak on errors\n\t* bugfix #392: Apex only and percentage checks for ldns-verify-zone\n\t  (thanks Miek Gieben)\n\t* bugfix #398: Allow NSEC RRSIGs before the NSEC3 in ldns-verify-zone\n\t* Fix python site package path from sitelib to sitearch for pyldns.\n\t* Fix python api to support python2 and python3 (thanks Karel Slany).\n\t* bugfix #401: Correction of date/time functions algorithm and\n\t  prevention of an infinite loop therein\n\t* bugfix #402: Correct the minimum and maximum number of rdata fields\n\t  in TSIG. (thanks David Keeler)\n\t* bugfix #403: Fix heap overflow (thanks David Keeler)\n\t* bugfix #404: Make parsing APL strings more robust\n\t  (thanks David Keeler)\n\t* bugfix #391: Complete library assessment to prevent assertion errors\n\t  through ldns_rdf_size usage.\n\t* Slightly more specific error messaging on wrong number of rdata\n\t  fields with the LDNS_STATUS_MISSING_RDATA_FIELDS_RRSIG and\n\t  LDNS_STATUS_MISSING_RDATA_FIELDS_KEY result codes.\n\t* bugfix #406: More rigorous openssl result code handling to prevent\n\t  future crashes within openssl.\n\t* Fix ldns_fetch_valid_domain_keys to search deeper than just one level\n\t  for a DNSKEY that signed a DS RR. (this function was used in the\n\t  check_dnssec_trace nagios module)\n\t* bugfix #407: Canonicalize TSIG dnames and algorithm fields\n\t* A new output specifier to accommodate configuration of what to show\n\t  in comment texts when converting host and/or wire-format data to\n\t  string. All conversion to string and printing functions have a new\n\t  version that have such a format specifier as an extra argument.\n\t  The default is changed so that only DNSKEY RR's are annotated with\n\t  an comment show the Key Tag of the DNSKEY.\n\t* Fixed the ldns resolver to not mark a nameserver unreachable when\n\t  edns0 is tried unsuccessfully with size 4096 (no return packet came),\n\t  but to still try TCP. A big UDP packet might have been corrupted by\n\t  fragments dropping firewalls.\n\t* Update of libdns.vim (thanks Miek Gieben)\n\t* Added the ldnsx Python module to our contrib section, which adds even\n\t  more pythonisticism to the usage of ldns with  Python. (Many thanks\n\t  to Christpher Olah and Paul Wouters)\n\t  The ldnsx module is automatically installed when --with-pyldns is\n\t  used with configuring, but may explicitly be excluded with the\n\t  --without-pyldnsx option to configure.\n\t* bugfix #410: Fix clearing out temporary data on stack in sha2.c\n\t* bugfix #411: Don't let empty non-terminal NSEC3s cause assertion failure.\n\n1.6.10\t2011-05-31\n\t* New example tool added: ldns-gen-zone.\n\t* bugfix #359: Serial-arithmetic for the inception and expiration\n\t  fields of a RRSIG and correctly converting them to broken-out time\n\t  information.\n\t* bugfix #364: Slight performance increase of ldns-verifyzone.\n\t* bugfix #367: Fix to allow glue records with the same name as the\n\t  delegation.\n\t* Fix ldns-verifyzone to allow NSEC3-less records for NS rrsets *and*\n\t  glue when the zone is opt-out.\n\t* bugfix #376: Adapt ldns_nsec3_salt, ldns_nsec3_iterations,\n\t  ldns_nsec3_flags and ldns_nsec3_algorithm to work for NSEC3PARAMS too.\n\t* pyldns memory leaks fixed by Bedrich Kosata (at the cost of a bit\n\t  performance)\n\t* Better handling of reference variables in ldns_rr_new_frm_fp_l from\n\t  pyldns, with a very nice generator function by Bedrich Kosata.\n\t* Decoupling of the rdfs in rrs in the python wrappers to enable\n\t  the python garbage collector by Bedrich Kosata.\n\t* bugfix #380: Minimizing effect of discrepancies in sizeof(bool) at\n\t  build time and when used.\n\t* bugfix #383: Fix detection of empty nonterminals of multiple labels.\n\t* Fixed the ommission of rrsets in nsec(3)s and rrsigs to all occluded\n\t  names (in stead of just the ones that contain glue only) and all\n\t  occluded records on the delegation points (in stead of just the glue).\n\t* Clarify the operation of ldns_dnssec_mark_glue and the usage of\n\t  ldns_dnssec_node_next_nonglue functions in the documentation.\n\t* Added function ldns_dnssec_mark_and_get_glue as an real fast\n\t  alternative for ldns_zone_glue_rr_list.\n\t* Fix parse buffer overflow for max length domain names.\n\t* Fix Makefile for U in environment, since wrong U is more common than\n\t  deansification necessity.\n\n1.6.9\t2011-03-16\n\t* Fix creating NSEC(3) bitmaps: make array size 65536,\n\t  don't add doubles.\n\t* Fix printout of escaped binary in TXT records.\n\t* Parsing TXT records: don't skip starting whitespace that is quoted.\n\t* bugfix #358: Check if memory was successfully allocated in\n\t  ldns_rdf2str().\n\t* Added more memory allocation checks in host2str.c\n\t* python wrapper for ldns_fetch_valid_domain_keys by Bedrich Kosata.\n\t* fix to compile python wrapper with swig 2.0.2.\n\t* Don't fallback to SHA-1 when creating NSEC3 hash with another\n\t  algorithm identifier, fail instead (no other algorithm identifiers\n\t  are assigned yet).\n\n1.6.8\t2011-01-24\n\t* Fix ldns zone, so that $TTL definition match RFC 2308.\n\t* Fix lots of missing checks on allocation failures and parse of\n\t  NSEC with many types and max parse length in hosts_frm_fp routine\n\t  and off by one in read_anchor_file routine (thanks Dan Kaminsky and\n\t  Justin Ferguson).\n\t* bugfix #335: Drill: Print both SHA-1 and SHA-256 corresponding DS\n\t  records.\n\t* Print correct WHEN in query packet (is not always 1-1-1970)\n\t* ldns-test-edns: new example tool that detects EDNS support.\n\t* fix ldns_resolver_send without openssl.\n\t* bugfix #342: patch for support for more CERT key types (RFC4398).\n\t* bugfix #351: fix udp_send hang if UDP checksum error.\n\t* fix set_bit (from NSEC3 sign) patch from Jan Komissar.\n\n1.6.7\t2010-11-08\n\t* EXPERIMENTAL ecdsa implementation, please do not enable on real\n\t  servers.\n\t* GOST code enabled by default (RFC 5933).\n\t* bugfix #326: ignore whitespace between directives and their values.\n\t* Header comment to advertise ldns_axfr_complete to check for\n\t  successfully completed zone transfers.\n\t* read resolv.conf skips interface labels, e.g. %eth0.\n\t* Fix drill verify NSEC3 denials.\n\t* Use closesocket() on windows.\n\t* Add ldns_get_signing_algorithm_by_name that understand aliases,\n\t  names changed to RFC names and aliases for compatibility added.\n\t* bugfix: don't print final dot if the domain is relative.\n\t* bugfix: resolver search continue when packet rcode != NOERROR.\n\t* bugfix: resolver push all domains in search directive to list.\n\t* bugfix: resolver search by default includes the root domain.\n\t* bugfix: tcp read could fail on single octet recv.\n\t* bugfix: read of RR in unknown syntax with missing fields.\n\t* added ldns_pkt_tsig_sign_next() and ldns_pkt_tsig_verify_next()\n\t  to sign and verify TSIG RRs on subsequent messages\n\t  (section 4.4, RFC 2845, thanks to Michael Sheldon).\n\t* bugfix: signer sigs nsecs with zsks only.\n\t* bugfix #333: fix ldns_dname_absolute for name ending with backslash.\n\n1.6.6\t2010-08-09\n\t* Fix ldns_rr_clone to copy question rrs properly.\n\t* Fix ldns_sign_zone(_nsec3) to clone the soa for the new zone.\n\t* Fix ldns_wire2dname size check from reading 1 byte beyond buffer end.\n\t* Fix ldns_wire2dname from reading 1 byte beyond end for pointer.\n\t* Fix crash using GOST for particular platform configurations.\n\t* extern C declarations used in the header file.\n\t* Removed debug fprintf from resolver.c.\n\t* ldns-signzone checks if public key file is for the right zone.\n\t* NETLDNS, .NET port of ldns functionality, by Alex Nicoll, in contrib.\n\t* Fix handling of comments in resolv.conf parse.\n\t* GOST code enabled if SSL recent, RFC 5933.\n\t* bugfix #317: segfault util.c ldns_init_random() fixed.\n\t* Fix ldns_tsig_mac_new: allocate enough memory for the hash, fix use of\n\t  b64_pton_calculate_size.\n\t* Fix ldns_dname_cat: size calculation and handling of realloc().\n\t* Fix ldns_rr_pop_rdf: fix handling of realloc().\n\t* Fix ldns-signzone for single type key scheme: sign whole zone if there\n\t  are only KSKs.\n\t* Fix ldns_resolver: also close socket if AXFR failed (if you don't,\n          it would block subsequent transfers (thanks Roland van Rijswijk).\n        * Fix drill: allow for a secure trace if you use DS records as trust\n\t  anchors (thanks Jan Komissar).\n\n1.6.5\t2010-06-15\n\t* Catch \\X where X is a digit as an error.\n\t* Fix segfault when ip6 ldns resolver only has ip4 servers.\n\t* Fix NSEC record after DNSKEY at zone apex not properly signed.\n\t* Fix syntax error if last label too long and no dot at end of domain.\n\t* Fix parse of \\# syntax with space for type LOC.\n\t* Fix ldns_dname_absolute for escape sequences, fixes some parse errs.\n\t* bugfix #297: linking ssl, bug due to patch submitted as #296.\n\t* bugfix #299: added missing declarations to host2str.h\n\t* ldns-compare-zones -s to not exclude SOA record from comparison.\n\t* --disable-rpath fix\n\t* fix ldns_pkt_empty(), reported by Alex Nicoll.\n\t* fix ldns_resolver_new_frm_fp not ignore lines after a comment.\n\t* python code for ldns_rr.new_question_frm_str()\n\t* Fix ldns_dnssec_verify_denial: the signature selection routine.\n\t* Type TALINK parsed (draft-ietf-dnsop-trust-history).\n\t* bugfix #304: fixed dead loop in ldns_tcp_read_wire() and\n\t  ldns_tcp_read_wire_timeout().\n\t* GOST support with correct algorithm numbers.  The plan is to make it\n\t  enabled if openssl support is detected, but it is disabled by\n\t  default in this release because the RFC is not ready.\n\t* Fixed comment in rbtree.h about being first member and data ptr.\n\t* Fixed possibly leak in case of out of memory in ldns_native2rdf...\n\t* ldns_dname_is_wildcard added.\n\t* Fixed: signatures over wildcards had the wrong labelcount.\n\t* Fixed ldns_verify() inconsistent return values.\n\t* Fixed ldns_resolver to copy and free tsig name, data and algorithm.\n\t* Fixed ldns_resolver to push search onto searchlist.\n\t* A ldns resolver now defaults to a non-recursive resolver that handles\n\t  the TC bit.\n\t* ldns_resolver_print() prints more details.\n\t* Fixed ldns_rdf2buffer_str_time(), which did not print timestamps\n\t  on 64bit systems.\n\t* Make ldns_resolver_nameservers_randomize() more random.\n\t* bugfix #310: POSIX specifies NULL second argument of gettimeofday.\n\t* fix compiler warnings from llvm clang compiler.\n\t* bugfix #309: ldns_pkt_clone did not clone the tsig_rr.\n\t* Fix gentoo ebuild for drill, 'no m4 directory'.\n\t* bugfix #313: drill trace on an empty nonterminal continuation.\n\n1.6.4\t2010-01-20\n\t* Imported pyldns contribution by Zdenek Vasicek and Karel Slany.\n\t  Changed its configure and Makefile to fit into ldns.\n\t  Added its dname_* methods to the rdf_* class (as is the ldns API).\n\t  Changed swig destroy of ldns_buffer class to ldns_buffer_free.\n\t  Declared ldns_pkt_all and ldns_pkt_all_noquestion so swig sees them.\n\t* Bugfix: parse PTR target of .tomhendrikx.nl with error not crash.\n\t* Bugfix: handle escaped characters in TXT rdata.\n\t* bug292: no longer crash on malformed domain names where a label is\n\t  on position 255, which was a buffer overflow by one.\n\t* Fix ldns_get_rr_list_hosts_frm_fp_l (strncpy to strlcpy change),\n\t  which fixes resolv.conf reading badly terminated string buffers.\n\t* Fix ldns_pkt_set_random_id to be more random, and a little faster,\n\t  it did not do value 0 statistically correctly.\n\t* Fix ldns_rdf2native_sockaddr_storage to set sockaddr type to zeroes,\n\t  for portability.\n\t* bug295: nsec3-hash routine no longer case sensitive.\n\t* bug298: drill failed nsec3 denial of existence proof.\n\n1.6.3\t2009-12-04\n\t* Bugfix: allow for unknown resource records in zonefile with rdlen=0.\n\t* Bugfix: also mark an RR as question if it comes from the wire\n\t* Bugfix: NSEC3 bitmap contained NSEC\n\t* Bugfix: Inherit class when creating signatures\n\n1.6.2\t2009-11-12\n\t* Fix Makefile patch from Havard Eidnes, better install.sh usage.\n\t* Fix parse error on SOA serial of 2910532839.\n\t  Fix print of ';' and readback of '\\;' in names, also for '\\\\'.\n\t  Fix parse of '\\(' and '\\)' in names.  Also for file read. Also '\\.'\n\t* Fix signature creation when TTLs are different for RRs in RRset.\n\t* bug273: fix so EDNS rdata is included in pkt to wire conversion.\n\t* bug274: fix use of c++ keyword 'class' for RR class in the code.\n\t* bug275: fix memory leak of packet edns rdata.\n\t* Fix timeout procedure for TCP and AXFR on Solaris.\n\t* Fix occasional NSEC bitmap bogus\n\t* Fix rr comparing (was in reversed order since 1.6.0)\n\t* bug278: fix parsing HINFO rdata (and other cases).\n\t* Fix previous owner name: also pick up if owner name is @.\n\t* RFC5702: enabled sha2 functions by default. This requires OpenSSL 0.9.8 or higher.\n      Reason for this default is the root to be signed with RSASHA256.\n\t* Fix various LDNS RR parsing issues: IPSECKEY, WKS, NSAP, very long lines\n\t* Fix: Make ldns_dname_is_subdomain case insensitive.\n\t* Fix ldns-verify-zone so that address records at zone NS set are not considered glue\n\t\t(Or glue records fall below delegation)\n    * Fix LOC RR altitude printing.\n\t* Feature: Added period (e.g. '3m6d') support at explicit TTLs.\n    * Feature: DNSKEY rrset by default signed with minimal signatures\n\t\tbut -A option for ldns-signzone to sign it with all keys.\n\t\tThis makes the DNSKEY responses smaller for signed domains.\n\n1.6.1   2009-09-14\n\t* --enable-gost : use the GOST algorithm (experimental).\n\t* Added some missing options to drill manpage\n\t* Some fixes to --without-ssl option\n\t* Fixed quote parsing withing strings\n\t* Bitmask fix in EDNS handling\n\t* Fixed non-fqdn domain name completion for rdata field domain\n\t  names of length 1\n\t* Fixed chain validation with SHA256 DS records\n\n1.6.0\n\tAdditions:\n\t* Addition of an ldns-config script which gives cflags and libs\n\t  values, for use in configure scripts for applications that use\n\t  use ldns. Can be disabled with ./configure --disable-ldns-config\n\t* Added direct sha1, sha256, and sha512 support in ldns.\n\t  With these functions, all NSEC3 functionality can still be\n\t  used, even if ldns is built without OpenSSL. Thanks to OpenBSD,\n\t  Steve Reid, and Aaron D. Gifford for the code.\n\t* Added reading/writing support for the SPF Resource Record\n\t* Base32 functions are now exported\n\tBugfixes:\n\t* ldns_is_rrset did not go through the complete rrset, but\n\t  only compared the first two records. Thanks to Olafur\n\t  Gudmundsson for report and patch\n\t* Fixed a small memory bug in ldns_rr_list_subtype_by_rdf(),\n\t  thanks to Marius Rieder for finding an patching this.\n\t* --without-ssl should now work. Make sure that examples/ and\n\t  drill also get the --without-ssl flag on their configure, if\n\t  this is used.\n\t* Some malloc() return value checks have been added\n\t* NSEC3 creation has been improved wrt to empty nonterminals,\n\t  and opt-out.\n\t* Fixed a bug in the parser when reading large NSEC3 salt\n\t  values.\n\t* Made the allowed length for domain names on wire\n\t  and presentation format the same.\n\tExample tools:\n\t* ldns-key2ds can now also generate DS records for keys without\n\t  the SEP flag\n\t* ldns-signzone now equalizes the TTL of the DNSKEY RRset (to\n\t  the first non-default DNSKEY TTL value it sees)\n\n1.5.1\n\tExample tools:\n\t* ldns-signzone was broken in 1.5.0 for multiple keys, this\n\t  has been repaired\n\n\tBuild system:\n\t* Removed a small erroneous output warning in\n\t  examples/configure and drill/configure\n\n1.5.0\n\tBug fixes:\n\t* fixed a possible memory overflow in the RR parser\n\t* build flag fix for Sun Studio\n\t* fixed a building race condition in the copying of header\n\t  files\n\t* EDNS0 extended rcode; the correct assembled code number\n\t  is now printed (still in the EDNS0 field, though)\n\t* ldns_pkt_rr no longer leaks memory (in fact, it no longer\n\t  copies anything all)\n\n\tAPI addition:\n\t* ldns_key now has support for 'external' data, in which\n\t  case the OpenSSL EVP structures are not used;\n\t  ldns_key_set_external_key() and ldns_key_external_key()\n\t* added ldns_key_get_file_base_name() which creates a\n\t  'default' filename base string for key storage, of the\n\t  form \"K<zone>+<algorithm>+<keytag>\"\n\t* the ldns_dnssec_* family of structures now have deep_free()\n\t  functions, which also free the ldns_rr's contained in them\n\t* there is now an ldns_match_wildcard() function, which checks\n\t  whether a domain name matches a wildcard name\n\t* ldns_sign_public has been split up; this resulted in the\n\t  addition of ldns_create_empty_rrsig() and\n\t  ldns_sign_public_buffer()\n\n\tExamples:\n\t* ldns-signzone can now automatically add DNSKEY records when\n\t  using an OpenSSL engine, as it already did when using key\n\t  files\n\t* added new example tool: ldns-nsec3-hash\n\t* ldns-dpa can now filter on specific query name and types\n\t* ldnsd has fixes for the zone name, a fix for the return\n\t  value of recvfrom(), and an memory initialization fix\n\t  (Thanks to Colm MacC\u00e1rthaigh for the patch)\n\t* Fixed memory leaks in ldnsd\n\n\n\n1.4.1\n\tBug fixes:\n\t* fixed a build issue where ldns lib existence was done too early\n\t* removed unnecessary check for pcap.h\n\t* NSEC3 optout flag now correctly printed in string output\n\t* inttypes.h moved to configured inclusion\n\t* fixed NSEC3 type bitmaps for empty nonterminals and unsigned\n\t  delegations\n\n\tAPI addition:\n\t* for that last fix, we added a new function\n\t  ldns_dname_add_from() that can clone parts of a dname\n\n1.4.0\n\tBug fixes:\n\t* sig chase return code fix (patch from Rafael Justo, bug id 189)\n\t* rdata.c memory leaks on error and allocation checks fixed (patch\n\t  from Shane Kerr, bug id 188)\n\t* zone.c memory leaks on error and allocation checks fixed (patch\n\tfrom Shane Kerr, bug id 189)\n\t* ldns-zplit output and error messages fixed (patch from Shane Kerr,\n\t  bug id 190)\n\t* Fixed potential buffer overflow in ldns_str2rdf_dname\n\t* Signing code no longer signs delegation NS rrsets\n\t* Some minor configure/makefile updates\n\t* Fixed a bug in the randomness initialization\n\t* Fixed a bug in the reading of resolv.conf\n\t* Fixed a bug concerning whitespace in zone data (with patch from Ondrej\n\t  Sury, bug 213)\n\t* Fixed a small fallback problem in axfr client code\n\n\tAPI CHANGES:\n\t* added 2str convenience functions:\n\t\t- ldns_rr_type2str\n\t\t- ldns_rr_class2str\n\t\t- ldns_rr_type2buffer_str\n\t\t- ldns_rr_class2buffer_str\n\t* buffer2str() is now called ldns_buffer2str\n\t* base32 and base64 function names are now also prepended with ldns_\n\t* ldns_rr_new_frm_str() now returns an error on missing RDATA fields.\n\t  Since you cannot read QUESTION section RRs with this anymore,\n\t  there is now a function called ldns_rr_new_question_frm_str()\n\n\tLIBRARY FEATURES:\n\t* DS RRs string representation now add bubblebabble in a comment\n\t  (patch from Jakob Schlyter)\n\t* DLV RR type added\n\t* TCP fallback system has been improved\n\t* HMAC-SHA256 TSIG support has been added.\n\t* TTLS are now correcly set in NSEC(3) records when signing zones\n\n\tEXAMPLE TOOLS:\n\t* New example: ldns-revoke to revoke DNSKEYs according to RFC5011\n\t* ldns-testpkts has been fixed and updated\n\t* ldns-signzone now has the option to not add the DNSKEY\n\t* ldns-signzone now has an (full zone only) opt-out option for\n\t                NSEC3\n\t* ldns-keygen can create HMAC-SHA1 and HMAC-SHA256 symmetric keys\n\t* ldns-walk output has been fixed\n\t* ldns-compare-zones has been fixed, and now has an option\n\t  to show all differences (-a)\n\t* ldns-read-zone now has an option to print DNSSEC records only\n\n1.3\n\tBase library:\n\n\t* Added a new family of functions based around ldns_dnssec_zone,\n\twhich is a new structure that keeps a zone sorted through an\n\trbtree and links signatures and NSEC(3) records directly to their\n\tRRset. These functions all start with ldns_dnssec_\n\n\t* ldns_zone_sign and ldns_zone_sign_nsec3 are now deprecated, but\n\thave been changed to internally use the new\n\tldns_dnssec_zone_sign(_nsec3)\n\n\t* Moved some ldns_buffer functions inline, so a clean rebuild of\n\tapplications relying on those is needed (otherwise you'll get\n\tlinker errors)\n\t* ldns_dname_label now returns one extra (zero)\n\tbyte, so it can be seen as an fqdn.\n\t* NSEC3 type code update for signing algorithms.\n\t* DSA key generation of DNSKEY RRs fixed (one byte too small).\n\n\t* Added support for RSA/SHA256 and RSA/SHA512, as specified in\n\tdraft-ietf-dnsext-dnssec-rsasha256-04. The typecodes are not\n\tfinal, and this feature is not enabled by default. It can be\n\tenabled at compilation time with the flag --with-sha2\n\n\t* Added 2wire_canonical family of functions that lowercase dnames\n\tin rdata fields in resource records of the types in the list in\n\trfc3597\n\n\t* Added base32 conversion functions.\n\n\t* Fixed DSA RRSIG conversion when calling OpenSSL\n\n\tDrill:\n\n\t* Chase output is completely different, it shows, in ascii, the\n\trelations in the trust hierarchy.\n\n\tExamples:\n\t* Added ldns-verify-zone, that can verify the internal DNSSEC records\n\tof a signed BIND-style zone file\n\n\t* ldns-keygen now takes an -a argument specifying the algorithm,\n\tinstead of -R or -D. -a list show a list of supported algorithms\n\n\t* ldns-keygen now defaults to the exponent RSA_F4 instead of RSA_3\n\tfor RSA key generation\n\n\t* ldns-signzone now has support for HSMs\n\t* ldns-signzone uses the new ldns_dnssec_ structures and functions\n\twhich improves its speed, and output; RRSIGS are now placed\n\tdirectly after their RRset, NSEC(3) records directly after the\n\tname they handle\n\n\tContrib:\n\t* new contrib/ dir with user contributions\n\t* added compilation script for solaris (thanks to Jakob Schlyter)\n\n28 Nov 2007 1.2.2:\n\t* Added support for HMAC-MD5 keys in generator\n\t* Added a new example tool (written by Ondrej Sury): ldns-compare-zones\n\t* ldns-keygen now checks key sizes for rfc conformancy\n\t* ldns-signzone outputs SSL error if present\n\t* Fixed manpages (thanks to Ondrej Sury)\n\t* Fixed Makefile for -j <x>\n\t* Fixed a $ORIGIN error when reading zones\n\t* Fixed another off-by-one error\n\n03 Oct 2007 1.2.1:\n\t* Fixed an offset error in rr comparison\n\t* Fixed ldns-read-zone exit code\n\t* Added check for availability of SHA256 hashing algorithm\n\t* Fixed ldns-key2ds -2 argument\n\t* Fixed $ORIGIN bug in .key files\n\t* Output algorithms as an integer instead of their mnemonic\n\t* Fixed a memory leak in dnssec code when SHA256 is not available\n\t* Updated fedora .spec file\n\n11 Apr 2007 1.2.0:\n\t* canonicalization of rdata in DNSSEC functions now adheres to the\n\t  rr type list in rfc3597, not rfc4035, which will be updated\n\t  (see http://www.ops.ietf.org/lists/namedroppers/namedroppers.2007/msg00183.html)\n\t* ldns-walk now support dnames with maximum label length\n\t* ldnsd now takes an extra argument containing the address to listen on\n\t* signing no longer signs every rrset with KSK's, but only the DNSKEY rrset\n\t* ported to Solaris 10\n\t* added ldns_send_buffer() function\n\t* added ldns-testpkts fake packet server\n\t* added ldns-notify to send NOTIFY packets\n\t* ldns-dpa can now accurately calculate the number of matches per\n\t  second\n\t* libtool is now used for compilation too (still gcc, but not directly)\n\t* Bugfixes:\n\t\t- TSIG signing buffer size\n\t\t- resolv.conf reading (comments)\n\t\t- dname comparison off by one error\n\t\t- typo in keyfetchers output file name fixed (a . too much)\n\t\t- fixed zone file parser when comments contain ( or )\n\t\t- fixed LOC RR type\n\t\t- fixed CERT RR type\n\n\tDrill:\n\t* drill prints error on failed axfr.\n\t* drill now accepts mangled packets with -f\n\t* old -c option (use tcp) changed to -t\n\t* -c option to specify alternative resolv.conf file added\n\t* feedback of signature chase improved\n\t* chaser now stops at root when no trusted keys are found\n\t  instead of looping forever trying to find the DS for .\n\t* Fixed bugs:\n\t\t- wildcard on multiple labels signature verification\n\t\t- error in -f packet writing for malformed packets\n\t\t- made KSK check more resilient\n\n7 Jul 2006: 1.1.0: ldns-team\n\t* Added tutorials and an introduction to the documentation\n\t* Added include/ and lib/ dirs so that you can compile against ldns\n\t  without installing ldns on your system\n\t* Makefile updates\n\t* Starting usage of assert throughout the library to catch illegal calls\n\t* Solaris 9 testing was carried out. Ldns now compiles on that\n\t  platform; some gnuism were identified and fixed.\n\t* The ldns_zone structure was stress tested. The current setup\n\t (ie. just a list of rrs) can scale to zone file in order of\n\t  megabytes. Sorting such zone is still difficult.\n\t* Reading multiline b64 encoded rdata works.\n\t* OpenSSL was made optional, configure --without-ssl.\n\t  Ofcourse all dnssec/tsig related functions are disabled\n\t* Building of examples and drill now happens with the same\n\t  defines as the building of ldns itself.\n\t* Preliminary sha-256 support was added. Currently is your\n\t  OpenSSL supports it, it is supported in the DS creation.\n\t* ldns_resolver_search was implemented\n\t* Fixed a lot of bugs\n\n\tDrill:\n\t* -r was killed in favor of -o <header bit mnemonic> which\n\t  allows for a header bits setting (and maybe more in the\n\t  future)\n\t* DNSSEC is never automaticaly set, even when you query\n\t  for DNSKEY/RRSIG or DS.\n\t* Implement a crude RTT check, it now distinguishes between\n\t  reachable and unreachable.\n\t* A form of secure tracing was added\n\t* Secure Chasing has been improved\n\t* -x does a reverse lookup for the given IP address\n\n\tExamples:\n\t* ldns-dpa was added to the examples - this is the Dns Packet\n\t  Analyzer tool.\n\t* ldnsd - as very, very simple nameserver impl.\n\t* ldns-zsplit - split zones for parrallel signing\n\t* ldns-zcat - cat split zones back together\n\t* ldns-keyfetcher - Fetches DNSKEY records with a few (non-strong,\n\t  non-DNSSEC) anti-spoofing techniques.\n\t* ldns-walk - 'Walks' a DNSSEC signed zone\n\t* Added an all-static target to the makefile so you can use examples\n\t  without installing the library\n\t* When building in the source tree or in a direct subdirectory of\n\t  the build dir, configure does not need --with-ldns=../ anymore\n\n\tCode:\n\t* All networking code was moved to net.c\n\t* rdata.c: added asserts to the rdf set/get functions\n\t* const keyword was added to pointer arguments that\n\t  aren't changed\n\n\tAPI:\n\tChanged:\n\t* renamed ldns/dns.h to ldns/ldns.h\n\t* ldns_rr_new_frm_str() is extented with an extra variable which\n\t  in common use may be NULL. This trickles through to:\n\t  o ldns_rr_new_frm_fp\n\t  o ldns_rr_new_frm_fp_l\n\t  Which also get an extra variable\n\t  Also the function has been changed to return a status message.\n\t  The compiled RR is returned in the first argument.\n\t* ldns_zone_new_frm_fp_l()  and ldns_zone_new_frm_fp() are\n\t  changed to return a status msg.\n\t* ldns_key_new_frm_fp is changed to return ldns_status and\n\t  the actual key list in the first argument\n\t* ldns_rdata_new_frm_fp[_l]() are changed to return a status.\n\t  the rdf is return in the first argument\n\t* ldns_resolver_new_frm_fp: same treatment: return status and\n\t  the new resolver in the first argument\n\t* ldns_pkt_query_new_frm_str(): same: return status and the\n\t  packet in the first arg\n\t* tsig.h: internal used functions are now static:\n\t  ldns_digest_name and ldns_tsig_mac_new\n\t* ldns_key_rr2ds has an extra argument to specify the hash to\n\t  use.\n\t* ldns_pkt_rcode() is renamed to ldns_pkt_get_rcode, ldns_pkt_rcode\n\t  is now the rcode type, like ldns_pkt_opcode\n\tNew:\n\t* ldns_resolver_searchlist_count: return the searchlist counter\n\t* ldns_zone_sort: Sort a zone\n\t* ldns_bgsend(): background send, returns a socket.\n\t* ldns_pkt_empty(): check is a packet is empty\n\t* ldns_rr_list_pop_rr_list(): pop multiple rr's from another rr_list\n\t* ldns_rr_list_push_rr_list(): push multiple rr's to an rr_list\n\t* ldns_rr_list_compare(): compare 2 ldns_rr_lists\n\t* ldns_pkt_push_rr_list: rr_list equiv for rr\n\t* ldns_pkt_safe_push_rr_list: rr_list equiv for rr\n\tRemoved:\n\t* ldns_resolver_bgsend(): was not used in 1.0.0 and is not used now\n\t* ldns_udp_server_connect(): was faulty and isn't really part of\n\t  the core ldns idea any how.\n\t* ldns_rr_list_insert_rr(): obsoleted, because not used.\n\t* char *_when was removed from the ldns_pkt structure\n\n18 Oct 2005: 1.0.0: ldns-team\n\t* Commited a patch from H\u00e5kan Olsson\n\t* Added UPDATE support (Jakob Schlyter and H\u00e5kan Olsson)\n\t* License change: ldns is now BSD licensed\n\t* ldns now depends on SSL\n\t* Networking code cleanup, added (some) server udp/tcp support\n\t* A zone type is introduced. Currently this is a list\n\t  of RRs, so it will not scale well.\n\t* [beta] Zonefile parsing was added\n\t* [tools] Drill was added to ldns - see drill/\n\t* [tools] experimental signer was added\n\t* [building] better check for ssl\n\t* [building] major revision of build system\n\t* [building] added rpm .spec in packaging/ (thanks to Paul Wouters)\n\t* [building] A lot of cleanup in the build scripts (thanks to Jakob Schlyter\n\tand Paul Wouters)\n\n28 Jul 2005: 0.70: ldns-team\n\t* [func] ldns_pkt_get_section now returns copies from the rrlists\n\t  in the packet. This can be freed by the user program\n\t* [code] added ldns_ prefixes to function from util.h\n\t* [inst] removed documentation from default make install\n\t* Usual fixes in documentation and code\n\n20 Jun 2005: 0.66: ldns-team\n\tRel. Focus: drill-pre2 uses some functions which are\n\tnot in 0.65\n\t* dnssec_cd bit function was added\n\t* Zone infrastructure was added\n\t* Usual fixes in documentation and code\n\n13 Jun 2005: 0.65: ldns-team\n\t* Repository is online at:\n\t  http://www.nlnetlabs.nl/ldns/svn/\n\t* Apply reference copying throuhgout ldns, except in 2\n\t  places in the ldns_resolver structure (._domain and\n\t ._nameservers)\n\t* Usual array of bugfixes\n\t* Documentation added\n\t* keygen.c added as an example for DNSSEC programming\n\n23 May 2005: 0.60: ldns-team\n\t* Removed config.h from the header installed files\n\t  (you're not supposed to include that in a libary)\n\t* Further tweaking\n\t  - DNSSEC signing/verification works\n\t  - Assorted bug fixes and tweaks (memory management)\n\nMay 2005: 0.50: ldns-team\n\t* First usable release\n\t* Basic DNS functionality works\n\t* DNSSEC validation works\n", "/* rr.c\n *\n * access functions for ldns_rr -\n * a Net::DNS like library for C\n * LibDNS Team @ NLnet Labs\n *\n * (c) NLnet Labs, 2004-2006\n * See the file LICENSE for the license\n */\n#include <ldns/config.h>\n\n#include <ldns/ldns.h>\n\n#include <strings.h>\n#include <limits.h>\n\n#include <errno.h>\n\n#define LDNS_SYNTAX_DATALEN 16\n#define LDNS_TTL_DATALEN    21\n#define LDNS_RRLIST_INIT    8\n\nldns_rr *\nldns_rr_new(void)\n{\n\tldns_rr *rr;\n\trr = LDNS_MALLOC(ldns_rr);\n        if (!rr) {\n                return NULL;\n\t}\n\n\tldns_rr_set_owner(rr, NULL);\n\tldns_rr_set_question(rr, false);\n\tldns_rr_set_rd_count(rr, 0);\n\trr->_rdata_fields = NULL;\n\tldns_rr_set_class(rr, LDNS_RR_CLASS_IN);\n\tldns_rr_set_ttl(rr, LDNS_DEFAULT_TTL);\n        return rr;\n}\n\nldns_rr *\nldns_rr_new_frm_type(ldns_rr_type t)\n{\n\tldns_rr *rr;\n\tconst ldns_rr_descriptor *desc;\n\tsize_t i;\n\n\trr = LDNS_MALLOC(ldns_rr);\n        if (!rr) {\n                return NULL;\n\t}\n\n\tdesc = ldns_rr_descript(t);\n\n\trr->_rdata_fields = LDNS_XMALLOC(ldns_rdf *, ldns_rr_descriptor_minimum(desc));\n        if(!rr->_rdata_fields) {\n                LDNS_FREE(rr);\n                return NULL;\n        }\n\tfor (i = 0; i < ldns_rr_descriptor_minimum(desc); i++) {\n\t\trr->_rdata_fields[i] = NULL;\n\t}\n\n\tldns_rr_set_owner(rr, NULL);\n\tldns_rr_set_question(rr, false);\n\t/* set the count to minimum */\n\tldns_rr_set_rd_count(rr, ldns_rr_descriptor_minimum(desc));\n\tldns_rr_set_class(rr, LDNS_RR_CLASS_IN);\n\tldns_rr_set_ttl(rr, LDNS_DEFAULT_TTL);\n\tldns_rr_set_type(rr, t);\n\treturn rr;\n}\n\nvoid\nldns_rr_free(ldns_rr *rr)\n{\n\tsize_t i;\n\tif (rr) {\n\t\tif (ldns_rr_owner(rr)) {\n\t\t\tldns_rdf_deep_free(ldns_rr_owner(rr));\n\t\t}\n\t\tfor (i = 0; i < ldns_rr_rd_count(rr); i++) {\n\t\t\tldns_rdf_deep_free(ldns_rr_rdf(rr, i));\n\t\t}\n\t\tLDNS_FREE(rr->_rdata_fields);\n\t\tLDNS_FREE(rr);\n\t}\n}\n\n/* Syntactic sugar for ldns_rr_new_frm_str_internal */\nINLINE bool\nldns_rdf_type_maybe_quoted(ldns_rdf_type rdf_type)\n{\n\treturn  rdf_type == LDNS_RDF_TYPE_STR ||\n\t\trdf_type == LDNS_RDF_TYPE_LONG_STR;\n}\n\n/*\n * trailing spaces are allowed\n * leading spaces are not allowed\n * allow ttl to be optional\n * class is optional too\n * if ttl is missing, and default_ttl is 0, use DEF_TTL\n * allow ttl to be written as 1d3h\n * So the RR should look like. e.g.\n * miek.nl. 3600 IN MX 10 elektron.atoom.net\n * or\n * miek.nl. 1h IN MX 10 elektron.atoom.net\n * or\n * miek.nl. IN MX 10 elektron.atoom.net\n */\nstatic ldns_status\nldns_rr_new_frm_str_internal(ldns_rr **newrr, const char *str,\n\t\t\t\t\t\t\t uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t\t\t\t ldns_rdf **prev, bool question)\n{\n\tldns_rr *new;\n\tconst ldns_rr_descriptor *desc;\n\tldns_rr_type rr_type;\n\tldns_buffer *rr_buf = NULL;\n\tldns_buffer *rd_buf = NULL;\n\tuint32_t ttl_val;\n\tchar  *owner = NULL;\n\tchar  *ttl = NULL;\n\tldns_rr_class clas_val;\n\tchar  *clas = NULL;\n\tchar  *type = NULL;\n\tsize_t type_sz;\n\tchar  *rdata = NULL;\n\tchar  *rd = NULL;\n\tchar  *xtok = NULL; /* For RDF types with spaces (i.e. extra tokens) */\n\tsize_t rd_strlen;\n\tconst char *delimiters;\n\tssize_t c;\n\tldns_rdf *owner_dname;\n        const char* endptr;\n        int was_unknown_rr_format = 0;\n\tldns_status status = LDNS_STATUS_OK;\n\n\t/* used for types with unknown number of rdatas */\n\tbool done;\n\tbool quoted;\n\n\tldns_rdf *r = NULL;\n\tuint16_t r_cnt;\n\tuint16_t r_min;\n\tuint16_t r_max;\n        size_t pre_data_pos;\n\n\tuint16_t hex_data_size;\n\tchar *hex_data_str = NULL;\n\tuint16_t cur_hex_data_size;\n\tsize_t hex_pos = 0;\n\tuint8_t *hex_data = NULL;\n\n\tnew = ldns_rr_new();\n\n\towner = LDNS_XMALLOC(char, LDNS_MAX_DOMAINLEN + 1);\n\tttl = LDNS_XMALLOC(char, LDNS_TTL_DATALEN);\n\tclas = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\trdata = LDNS_XMALLOC(char, LDNS_MAX_PACKETLEN + 1);\n\trr_buf = LDNS_MALLOC(ldns_buffer);\n\trd_buf = LDNS_MALLOC(ldns_buffer);\n\trd = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\txtok = LDNS_XMALLOC(char, LDNS_MAX_RDFLEN);\n\tif (rr_buf) {\n\t\trr_buf->_data = NULL;\n\t}\n\tif (rd_buf) {\n\t\trd_buf->_data = NULL;\n\t}\n\tif (!new || !owner || !ttl || !clas || !rdata ||\n\t\t\t!rr_buf || !rd_buf || !rd || !xtok) {\n\n\t\tgoto memerror;\n\t}\n\n\tldns_buffer_new_frm_data(rr_buf, (char*)str, strlen(str));\n\n\t/* split the rr in its parts -1 signals trouble */\n\tif (ldns_bget_token(rr_buf, owner, \"\\t\\n \", LDNS_MAX_DOMAINLEN) == -1){\n\n\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\tgoto error;\n\t}\n\n\tif (ldns_bget_token(rr_buf, ttl, \"\\t\\n \", LDNS_TTL_DATALEN) == -1) {\n\n\t\tstatus = LDNS_STATUS_SYNTAX_TTL_ERR;\n\t\tgoto error;\n\t}\n\tttl_val = (uint32_t) ldns_str2period(ttl, &endptr);\n\n\tif (strlen(ttl) > 0 && !isdigit((int) ttl[0])) {\n\t\t/* ah, it's not there or something */\n\t\tif (default_ttl == 0) {\n\t\t\tttl_val = LDNS_DEFAULT_TTL;\n\t\t} else {\n\t\t\tttl_val = default_ttl;\n\t\t}\n\t\t/* we not ASSUMING the TTL is missing and that\n\t\t * the rest of the RR is still there. That is\n\t\t * CLASS TYPE RDATA\n\t\t * so ttl value we read is actually the class\n\t\t */\n\t\tclas_val = ldns_get_rr_class_by_name(ttl);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(ttl) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, ttl, type_sz);\n\t\t}\n\t} else {\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, clas, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_CLASS_ERR;\n\t\t\tgoto error;\n\t\t}\n\t\tclas_val = ldns_get_rr_class_by_name(clas);\n\t\t/* class can be left out too, assume IN, current\n\t\t * token must be type\n\t\t */\n\t\tif (clas_val == 0) {\n\t\t\tclas_val = LDNS_RR_CLASS_IN;\n\t\t\ttype_sz = strlen(clas) + 1;\n\t\t\ttype = LDNS_XMALLOC(char, type_sz);\n\t\t\tif (!type) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tstrlcpy(type, clas, type_sz);\n\t\t}\n\t}\n\t/* the rest should still be waiting for us */\n\n\tif (!type) {\n\t\ttype = LDNS_XMALLOC(char, LDNS_SYNTAX_DATALEN);\n\t\tif (!type) {\n\t\t\tgoto memerror;\n\t\t}\n\t\tif (-1 == ldns_bget_token(\n\t\t\t\trr_buf, type, \"\\t\\n \", LDNS_SYNTAX_DATALEN)) {\n\n\t\t\tstatus = LDNS_STATUS_SYNTAX_TYPE_ERR;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ldns_bget_token(rr_buf, rdata, \"\\0\", LDNS_MAX_PACKETLEN) == -1) {\n\t\t/* apparently we are done, and it's only a question RR\n\t\t * so do not set status and go to ldnserror here\n\t\t */\n\t}\n\tldns_buffer_new_frm_data(rd_buf, rdata, strlen(rdata));\n\n\tif (strlen(owner) <= 1 && strncmp(owner, \"@\", 1) == 0) {\n\t\tif (origin) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t} else if (prev && *prev) {\n\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t} else {\n\t\t\t/* default to root */\n\t\t\tldns_rr_set_owner(new, ldns_dname_new_frm_str(\".\"));\n\t\t}\n\n\t\t/* @ also overrides prev */\n\t\tif (prev) {\n\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\tif (!*prev) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (strlen(owner) == 0) {\n\t\t\t/* no ownername was given, try prev, if that fails\n\t\t\t * origin, else default to root */\n\t\t\tif (prev && *prev) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(*prev));\n\t\t\t} else if (origin) {\n\t\t\t\tldns_rr_set_owner(new, ldns_rdf_clone(origin));\n\t\t\t} else {\n\t\t\t\tldns_rr_set_owner(new,\n\t\t\t\t\t\tldns_dname_new_frm_str(\".\"));\n\t\t\t}\n\t\t\tif(!ldns_rr_owner(new)) {\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t} else {\n\t\t\towner_dname = ldns_dname_new_frm_str(owner);\n\t\t\tif (!owner_dname) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tldns_rr_set_owner(new, owner_dname);\n\t\t\tif (!ldns_dname_str_absolute(owner) && origin) {\n\t\t\t\tif(ldns_dname_cat(ldns_rr_owner(new), origin)\n\t\t\t\t\t\t!= LDNS_STATUS_OK) {\n\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (prev) {\n\t\t\t\tldns_rdf_deep_free(*prev);\n\t\t\t\t*prev = ldns_rdf_clone(ldns_rr_owner(new));\n\t\t\t\tif (!*prev) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLDNS_FREE(owner);\n\n\tldns_rr_set_question(new, question);\n\n\tldns_rr_set_ttl(new, ttl_val);\n\tLDNS_FREE(ttl);\n\n\tldns_rr_set_class(new, clas_val);\n\tLDNS_FREE(clas);\n\n\trr_type = ldns_get_rr_type_by_name(type);\n\tLDNS_FREE(type);\n\n\tdesc = ldns_rr_descript((uint16_t)rr_type);\n\tldns_rr_set_type(new, rr_type);\n\tif (desc) {\n\t\t/* only the rdata remains */\n\t\tr_max = ldns_rr_descriptor_maximum(desc);\n\t\tr_min = ldns_rr_descriptor_minimum(desc);\n\t} else {\n\t\tr_min = 0;\n\t\tr_max = 1;\n\t}\n\n\tfor (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) {\n\t\tquoted = false;\n\n\t\tswitch (ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\t\tcase LDNS_RDF_TYPE_B64        :\n\t\tcase LDNS_RDF_TYPE_HEX        : /* These rdf types may con- */\n\t\tcase LDNS_RDF_TYPE_LOC        : /* tain whitespace, only if */\n\t\tcase LDNS_RDF_TYPE_WKS        : /* it is the last rd field. */\n\t\tcase LDNS_RDF_TYPE_IPSECKEY   :\n\t\tcase LDNS_RDF_TYPE_AMTRELAY   :\n\t\tcase LDNS_RDF_TYPE_NSEC       :\tif (r_cnt == r_max - 1) {\n\t\t\t\t\t\t\tdelimiters = \"\\n\";\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* fallthrough */\n\t\tdefault                       :\tdelimiters = \"\\n\\t \"; \n\t\t}\n\n\t\tif (ldns_rdf_type_maybe_quoted(\n\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\tdesc, r_cnt)) &&\n\t\t\t\tldns_buffer_remaining(rd_buf) > 0){\n\n\t\t\t/* skip spaces */\n\t\t\twhile (sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t\t*(ldns_buffer_current(rd_buf)) == ' ') {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t}\n\n\t\t\tif (sldns_buffer_remaining(strbuf) > 0 &&\n\t\t\t\t*(ldns_buffer_current(rd_buf)) == '\\\"') {\n\t\t\t\tdelimiters = \"\\\"\\0\";\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t\tquoted = true;\n\t\t\t}\n\t\t\tif (!quoted && ldns_rr_descriptor_field_type(desc, r_cnt)\n\t\t\t\t\t== LDNS_RDF_TYPE_LONG_STR) {\n\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t/* because number of fields can be variable, we can't rely on\n\t\t * _maximum() only\n\t\t */\n\n\t\t/* skip spaces */\n\t\twhile (ldns_buffer_position(rd_buf) < ldns_buffer_limit(rd_buf)\n\t\t\t\t&& *(ldns_buffer_current(rd_buf)) == ' '\n\t\t\t\t&& !quoted) {\n\n\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t}\n\n\t\tpre_data_pos = ldns_buffer_position(rd_buf);\n\t\tif (-1 == (c = ldns_bget_token(\n\t\t\t\trd_buf, rd, delimiters, LDNS_MAX_RDFLEN))) {\n\n\t\t\tdone = true;\n\t\t\t(void)done; /* we're breaking, so done not read anymore */\n\t\t\tbreak;\n\t\t}\n\t\t/* hmmz, rfc3597 specifies that any type can be represented \n\t\t * with \\# method, which can contain spaces...\n\t\t * it does specify size though...\n\t\t */\n\t\trd_strlen = strlen(rd);\n\n\t\t/* unknown RR data */\n\t\tif (strncmp(rd, \"\\\\#\", 2) == 0 && !quoted &&\n\t\t\t\t(rd_strlen == 2 || rd[2]==' ')) {\n\n\t\t\twas_unknown_rr_format = 1;\n\t\t\t/* go back to before \\#\n\t\t\t * and skip it while setting delimiters better\n\t\t\t */\n\t\t\tldns_buffer_set_position(rd_buf, pre_data_pos);\n\t\t\tdelimiters = \"\\n\\t \";\n\t\t\t(void)ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t/* read rdata octet length */\n\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\tif (c == -1) {\n\t\t\t\t/* something goes very wrong here */\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\thex_data_size = (uint16_t) atoi(rd);\n\t\t\t/* copy hex chars into hex str (2 chars per byte) */\n\t\t\thex_data_str = LDNS_XMALLOC(char, 2*hex_data_size + 1);\n\t\t\tif (!hex_data_str) {\n\t\t\t\t/* malloc error */\n\t\t\t\tgoto memerror;\n\t\t\t}\n\t\t\tcur_hex_data_size = 0;\n\t\t\twhile(cur_hex_data_size < 2 * hex_data_size) {\n\t\t\t\tc = ldns_bget_token(rd_buf, rd,\n\t\t\t\t\t\tdelimiters, LDNS_MAX_RDFLEN);\n\t\t\t\tif (c == -1) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\trd_strlen = strlen(rd);\n\t\t\t\tif ((size_t)cur_hex_data_size + rd_strlen >\n\t\t\t\t    2 * (size_t)hex_data_size) {\n\t\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tstrlcpy(hex_data_str + cur_hex_data_size, rd,\n\t\t\t\t\t\trd_strlen + 1);\n\n\t\t\t\tcur_hex_data_size += rd_strlen;\n\t\t\t}\n\t\t\thex_data_str[cur_hex_data_size] = '\\0';\n\n\t\t\t/* correct the rdf type */\n\t\t\t/* if *we* know the type, interpret it as wireformat */\n\t\t\tif (desc) {\n\t\t\t\thex_pos = 0;\n\t\t\t\thex_data =\n\t\t\t\t\tLDNS_XMALLOC(uint8_t, hex_data_size+2);\n\n\t\t\t\tif (!hex_data) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_write_uint16(hex_data, hex_data_size);\n\t\t\t\tldns_hexstring_to_data(\n\t\t\t\t\t\thex_data + 2, hex_data_str);\n\t\t\t\tstatus = ldns_wire2rdf(new, hex_data,\n\t\t\t\t\t\thex_data_size + 2, &hex_pos);\n\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tLDNS_FREE(hex_data);\n\t\t\t} else {\n\t\t\t\tr = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_HEX,\n\t\t\t\t\t\thex_data_str);\n\t\t\t\tif (!r) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t\tldns_rdf_set_type(r, LDNS_RDF_TYPE_UNKNOWN);\n\t\t\t\tif (!ldns_rr_push_rdf(new, r)) {\n\t\t\t\t\tgoto memerror;\n\t\t\t\t}\n\t\t\t}\n\t\t\tLDNS_FREE(hex_data_str);\n\n\t\t} else if(rd_strlen > 0 || quoted) {\n\t\t\t/* Normal RR */\n\t\t\tswitch(ldns_rr_descriptor_field_type(desc, r_cnt)) {\n\n\t\t\tcase LDNS_RDF_TYPE_HEX:\n\t\t\tcase LDNS_RDF_TYPE_B64:\n\t\t\t\t/* When this is the last rdata field, then the\n\t\t\t\t * rest should be read in (cause then these\n\t\t\t\t * rdf types may contain spaces).\n\t\t\t\t */\n\t\t\t\tif (r_cnt == r_max - 1) {\n\t\t\t\t\tc = ldns_bget_token(rd_buf, xtok,\n\t\t\t\t\t\t\t\"\\n\", LDNS_MAX_RDFLEN);\n\t\t\t\t\tif (c != -1) {\n\t\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_HIP:\n\t\t\t\t/*\n\t\t\t\t * In presentation format this RDATA type has\n\t\t\t\t * three tokens: An algorithm byte, then a\n\t\t\t\t * variable length HIT (in hexbytes) and then\n\t\t\t\t * a variable length Public Key (in base64).\n\t\t\t\t *\n\t\t\t\t * We have just read the algorithm, so we need\n\t\t\t\t * two more tokens: HIT and Public Key.\n\t\t\t\t */\n\t\t\t\tdo {\n\t\t\t\t\t/* Read and append HIT */\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\n\t\t\t\t\t/* Read and append Public Key*/\n\t\t\t\t\tif (ldns_bget_token(rd_buf,\n\t\t\t\t\t\t\txtok, delimiters,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN) == -1)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t(void) strncat(rd, \" \",\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t\t(void) strncat(rd, xtok,\n\t\t\t\t\t\t\tLDNS_MAX_RDFLEN -\n\t\t\t\t\t\t\tstrlen(rd) - 1);\n\t\t\t\t} while (false);\n\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\n\t\t\tcase LDNS_RDF_TYPE_DNAME:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\n\t\t\t\t/* check if the origin should be used\n\t\t\t\t * or concatenated\n\t\t\t\t */\n\t\t\t\tif (r && ldns_rdf_size(r) > 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[0] == 1 &&\n\t\t\t\t\t\tldns_rdf_data(r)[1] == '@') {\n\n\t\t\t\t\tldns_rdf_deep_free(r);\n\n\t\t\t\t\tr = origin ? ldns_rdf_clone(origin)\n\n\t\t\t\t\t  : ( rr_type == LDNS_RR_TYPE_SOA ?\n\n\t\t\t\t\t      ldns_rdf_clone(\n\t\t\t\t\t\t      ldns_rr_owner(new))\n\n\t\t\t\t\t    : ldns_rdf_new_frm_str(\n\t\t\t\t\t\t    LDNS_RDF_TYPE_DNAME, \".\")\n\t\t\t\t\t    );\n\n\t\t\t\t} else if (r && rd_strlen >= 1 && origin &&\n\t\t\t\t\t\t!ldns_dname_str_absolute(rd)) {\n\n\t\t\t\t\tstatus = ldns_dname_cat(r, origin);\n\t\t\t\t\tif (status != LDNS_STATUS_OK) {\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tr = ldns_rdf_new_frm_str(\n\t\t\t\t\t\tldns_rr_descriptor_field_type(\n\t\t\t\t\t\t\tdesc, r_cnt), rd);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!r) {\n\t\t\t\tstatus = LDNS_STATUS_SYNTAX_RDATA_ERR;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tldns_rr_push_rdf(new, r);\n\t\t}\n\t\tif (quoted) {\n\t\t\tif (ldns_buffer_available(rd_buf, 1)) {\n\t\t\t\tldns_buffer_skip(rd_buf, 1);\n\t\t\t} else {\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\n\t} /* for (done = false, r_cnt = 0; !done && r_cnt < r_max; r_cnt++) */\n\tLDNS_FREE(rd);\n\tLDNS_FREE(xtok);\n\tldns_buffer_free(rr_buf);\n\tLDNS_FREE(rdata);\n\tif (ldns_buffer_remaining(rd_buf) > 0) {\n\t\tldns_buffer_free(rd_buf);\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_SUPERFLUOUS_TEXT_ERR;\n\t}\n\tldns_buffer_free(rd_buf);\n\n\tif (!question && desc && !was_unknown_rr_format &&\n\t\t\tldns_rr_rd_count(new) < r_min) {\n\n\t\tldns_rr_free(new);\n\t\treturn LDNS_STATUS_SYNTAX_MISSING_VALUE_ERR;\n\t}\n\n\tif (newrr) {\n\t\t*newrr = new;\n\t} else {\n\t\t/* Maybe the caller just wanted to see if it would parse? */\n\t\tldns_rr_free(new);\n\t}\n\treturn LDNS_STATUS_OK;\n\nmemerror:\n\tstatus = LDNS_STATUS_MEM_ERR;\nerror:\n\tif (rd_buf && rd_buf->_data) {\n\t\tldns_buffer_free(rd_buf);\n\t} else {\n\t\tLDNS_FREE(rd_buf);\n\t}\n\tif (rr_buf && rr_buf->_data) {\n\t\tldns_buffer_free(rr_buf);\n\t} else {\n\t\tLDNS_FREE(rr_buf);\n\t}\n\tLDNS_FREE(type);\n\tLDNS_FREE(owner);\n\tLDNS_FREE(ttl);\n\tLDNS_FREE(clas);\n\tLDNS_FREE(hex_data);\n\tLDNS_FREE(hex_data_str);\n\tLDNS_FREE(xtok);\n\tLDNS_FREE(rd);\n\tLDNS_FREE(rdata);\n\tldns_rr_free(new);\n\treturn status;\n}\n\nldns_status\nldns_rr_new_frm_str(ldns_rr **newrr, const char *str,\n                    uint32_t default_ttl, const ldns_rdf *origin,\n\t\t\t\t    ldns_rdf **prev)\n{\n\treturn ldns_rr_new_frm_str_internal(newrr,\n\t                                    str,\n\t                                    default_ttl,\n\t                                    origin,\n\t                                    prev,\n\t                                    false);\n}\n\nldns_status\nldns_rr_new_question_frm_str(ldns_rr **newrr, const char *str,\n                             const ldns_rdf *origin, ldns_rdf **prev)\n{\n\treturn ldns_rr_new_frm_str_internal(newrr,\n\t                                    str,\n\t                                    0,\n\t                                    origin,\n\t                                    prev,\n\t                                    true);\n}\n\n/* Strip whitespace from the start and the end of <line>.  */\nstatic char *\nldns_strip_ws(char *line)\n{\n\tchar *s = line, *e;\n\n\tfor (s = line; *s && isspace((unsigned char)*s); s++)\n\t\t;\n\n\tfor (e = strchr(s, 0); e > s+2 && isspace((unsigned char)e[-1]) && e[-2] != '\\\\'; e--)\n\t\t;\n\t*e = 0;\n\n\treturn s;\n}\n\nldns_status\nldns_rr_new_frm_fp(ldns_rr **newrr, FILE *fp, uint32_t *ttl, ldns_rdf **origin, ldns_rdf **prev)\n{\n\treturn ldns_rr_new_frm_fp_l(newrr, fp, ttl, origin, prev, NULL);\n}\n\nldns_status\nldns_rr_new_frm_fp_l(ldns_rr **newrr, FILE *fp, uint32_t *default_ttl, ldns_rdf **origin, ldns_rdf **prev, int *line_nr)\n{\n\tchar *line;\n\tconst char *endptr;  /* unused */\n\tldns_rr *rr;\n\tuint32_t ttl;\n\tldns_rdf *tmp;\n\tldns_status s;\n\tssize_t size;\n\n\tif (default_ttl) {\n\t\tttl = *default_ttl;\n\t} else {\n\t\tttl = 0;\n\t}\n\n\tline = LDNS_XMALLOC(char, LDNS_MAX_LINELEN + 1);\n\tif (!line) {\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\n\t/* read an entire line in from the file */\n\tif ((size = ldns_fget_token_l(fp, line, LDNS_PARSE_SKIP_SPACE, LDNS_MAX_LINELEN, line_nr)) == -1) {\n\t\tLDNS_FREE(line);\n\t\t/* if last line was empty, we are now at feof, which is not\n\t\t * always a parse error (happens when for instance last line\n\t\t * was a comment)\n\t\t */\n\t\treturn LDNS_STATUS_SYNTAX_ERR;\n\t}\n\n\t/* we can have the situation, where we've read ok, but still got\n\t * no bytes to play with, in this case size is 0\n\t */\n\tif (size == 0) {\n\t\tLDNS_FREE(line);\n\t\treturn LDNS_STATUS_SYNTAX_EMPTY;\n\t}\n\n\tif (strncmp(line, \"$ORIGIN\", 7) == 0 && isspace((unsigned char)line[7])) {\n\t\tif (*origin) {\n\t\t\tldns_rdf_deep_free(*origin);\n\t\t\t*origin = NULL;\n\t\t}\n\t\ttmp = ldns_rdf_new_frm_str(LDNS_RDF_TYPE_DNAME,\n\t\t\t\tldns_strip_ws(line + 8));\n\t\tif (!tmp) {\n\t\t\t/* could not parse what next to $ORIGIN */\n\t\t\tLDNS_FREE(line);\n\t\t\treturn LDNS_STATUS_SYNTAX_DNAME_ERR;\n\t\t}\n\t\t*origin = tmp;\n\t\ts = LDNS_STATUS_SYNTAX_ORIGIN;\n\t} else if (strncmp(line, \"$TTL\", 4) == 0 && isspace((unsigned char)line[4])) {\n\t\tif (default_ttl) {\n\t\t\t*default_ttl = ldns_str2period(\n\t\t\t\t\tldns_strip_ws(line + 5), &endptr);\n\t\t}\n\t\ts = LDNS_STATUS_SYNTAX_TTL;\n\t} else if (strncmp(line, \"$INCLUDE\", 8) == 0) {\n\t\ts = LDNS_STATUS_SYNTAX_INCLUDE;\n\t} else if (!*ldns_strip_ws(line)) {\n\t\tLDNS_FREE(line);\n\t\treturn LDNS_STATUS_SYNTAX_EMPTY;\n\t} else {\n\t\tif (origin && *origin) {\n\t\t\ts = ldns_rr_new_frm_str(&rr, (const char*) line, ttl, *origin, prev);\n\t\t} else {\n\t\t\ts = ldns_rr_new_frm_str(&rr, (const char*) line, ttl, NULL, prev);\n\t\t}\n\t}\n\tLDNS_FREE(line);\n\tif (s == LDNS_STATUS_OK) {\n\t\tif (newrr) {\n\t\t\t*newrr = rr;\n\t\t} else {\n\t\t\t/* Just testing if it would parse? */\n\t\t\tldns_rr_free(rr);\n\t\t}\n\t}\n\treturn s;\n}\n\nvoid\nldns_rr_set_owner(ldns_rr *rr, ldns_rdf *owner)\n{\n\trr->_owner = owner;\n}\n\nvoid\nldns_rr_set_question(ldns_rr *rr, bool question)\n{\n   rr->_rr_question = question;\n}\n\nvoid\nldns_rr_set_ttl(ldns_rr *rr, uint32_t ttl)\n{\n\trr->_ttl = ttl;\n}\n\nvoid\nldns_rr_set_rd_count(ldns_rr *rr, size_t count)\n{\n\trr->_rd_count = count;\n}\n\nvoid\nldns_rr_set_type(ldns_rr *rr, ldns_rr_type rr_type)\n{\n\trr->_rr_type = rr_type;\n}\n\nvoid\nldns_rr_set_class(ldns_rr *rr, ldns_rr_class rr_class)\n{\n\trr->_rr_class = rr_class;\n}\n\nldns_rdf *\nldns_rr_set_rdf(ldns_rr *rr, const ldns_rdf *f, size_t position)\n{\n\tsize_t rd_count;\n\tldns_rdf *pop;\n\n\trd_count = ldns_rr_rd_count(rr);\n\tif (position < rd_count) {\n\t\t/* dicard the old one */\n\t\tpop = rr->_rdata_fields[position];\n\t\trr->_rdata_fields[position] = (ldns_rdf*)f;\n\t\treturn pop;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nbool\nldns_rr_push_rdf(ldns_rr *rr, const ldns_rdf *f)\n{\n\tsize_t rd_count;\n\tldns_rdf **rdata_fields;\n\n\trd_count = ldns_rr_rd_count(rr);\n\n\t/* grow the array */\n\trdata_fields = LDNS_XREALLOC(\n\t\trr->_rdata_fields, ldns_rdf *, rd_count + 1);\n\tif (!rdata_fields) {\n\t\treturn false;\n\t}\n\n\t/* add the new member */\n\trr->_rdata_fields = rdata_fields;\n\trr->_rdata_fields[rd_count] = (ldns_rdf*)f;\n\n\tldns_rr_set_rd_count(rr, rd_count + 1);\n\treturn true;\n}\n\nldns_rdf *\nldns_rr_pop_rdf(ldns_rr *rr)\n{\n\tsize_t rd_count;\n\tldns_rdf *pop;\n\tldns_rdf** newrd;\n\n\trd_count = ldns_rr_rd_count(rr);\n\n\tif (rd_count == 0) {\n\t\treturn NULL;\n\t}\n\n\tpop = rr->_rdata_fields[rd_count - 1];\n\n\t/* try to shrink the array */\n\tif(rd_count > 1) {\n\t\tnewrd = LDNS_XREALLOC(\n\t\t\trr->_rdata_fields, ldns_rdf *, rd_count - 1);\n\t\tif(newrd)\n\t\t\trr->_rdata_fields = newrd;\n\t} else {\n\t\tLDNS_FREE(rr->_rdata_fields);\n\t}\n\n\tldns_rr_set_rd_count(rr, rd_count - 1);\n\treturn pop;\n}\n\nldns_rdf *\nldns_rr_rdf(const ldns_rr *rr, size_t nr)\n{\n\tif (rr && nr < ldns_rr_rd_count(rr)) {\n\t\treturn rr->_rdata_fields[nr];\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nldns_rdf *\nldns_rr_owner(const ldns_rr *rr)\n{\n\treturn rr->_owner;\n}\n\nbool\nldns_rr_is_question(const ldns_rr *rr)\n{\n   return rr->_rr_question;\n}\n\nuint32_t\nldns_rr_ttl(const ldns_rr *rr)\n{\n\treturn rr->_ttl;\n}\n\nsize_t\nldns_rr_rd_count(const ldns_rr *rr)\n{\n\treturn rr->_rd_count;\n}\n\nldns_rr_type\nldns_rr_get_type(const ldns_rr *rr)\n{\n        return rr->_rr_type;\n}\n\nldns_rr_class\nldns_rr_get_class(const ldns_rr *rr)\n{\n        return rr->_rr_class;\n}\n\n/* rr_lists */\n\nsize_t\nldns_rr_list_rr_count(const ldns_rr_list *rr_list)\n{\n\tif (rr_list) {\n\t\treturn rr_list->_rr_count;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nldns_rr *\nldns_rr_list_set_rr(ldns_rr_list *rr_list, const ldns_rr *r, size_t count)\n{\n\tldns_rr *old;\n\n\tif (count > ldns_rr_list_rr_count(rr_list)) {\n\t\treturn NULL;\n\t}\n\n\told = ldns_rr_list_rr(rr_list, count);\n\n\t/* overwrite old's pointer */\n\trr_list->_rrs[count] = (ldns_rr*)r;\n\treturn old;\n}\n\nvoid\nldns_rr_list_set_rr_count(ldns_rr_list *rr_list, size_t count)\n{\n\tassert(count <= rr_list->_rr_capacity);\n\trr_list->_rr_count = count;\n}\n\nldns_rr *\nldns_rr_list_rr(const ldns_rr_list *rr_list, size_t nr)\n{\n\tif (nr < ldns_rr_list_rr_count(rr_list)) {\n\t\treturn rr_list->_rrs[nr];\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nldns_rr_list *\nldns_rr_list_new(void)\n{\n\tldns_rr_list *rr_list = LDNS_MALLOC(ldns_rr_list);\n        if(!rr_list) return NULL;\n\trr_list->_rr_count = 0;\n\trr_list->_rr_capacity = 0;\n\trr_list->_rrs = NULL;\n\treturn rr_list;\n}\n\nvoid\nldns_rr_list_free(ldns_rr_list *rr_list)\n{\n\tif (rr_list) {\n\t\tLDNS_FREE(rr_list->_rrs);\n\t\tLDNS_FREE(rr_list);\n\t}\n}\n\nvoid\nldns_rr_list_deep_free(ldns_rr_list *rr_list)\n{\n\tsize_t i;\n\n\tif (rr_list) {\n\t\tfor (i=0; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\t\tldns_rr_free(ldns_rr_list_rr(rr_list, i));\n\t\t}\n\t\tLDNS_FREE(rr_list->_rrs);\n\t\tLDNS_FREE(rr_list);\n\t}\n}\n\n\n/* add right to left. So we modify *left! */\nbool\nldns_rr_list_cat(ldns_rr_list *left, const ldns_rr_list *right)\n{\n\tsize_t r_rr_count;\n\tsize_t i;\n\n\tif (!left) {\n\t\treturn false;\n\t}\n\n\tif (right) {\n\t\tr_rr_count = ldns_rr_list_rr_count(right);\n\t} else {\n\t\tr_rr_count = 0;\n\t}\n\n\t/* push right to left */\n\tfor(i = 0; i < r_rr_count; i++) {\n\t\tldns_rr_list_push_rr(left, ldns_rr_list_rr(right, i));\n\t}\n\treturn true;\n}\n\nldns_rr_list *\nldns_rr_list_cat_clone(const ldns_rr_list *left, const ldns_rr_list *right)\n{\n\tsize_t l_rr_count;\n\tsize_t r_rr_count;\n\tsize_t i;\n\tldns_rr_list *cat;\n\n\tif (left) {\n\t\tl_rr_count = ldns_rr_list_rr_count(left);\n\t} else {\n\t\treturn ldns_rr_list_clone(right);\n\t}\n\n\tif (right) {\n\t\tr_rr_count = ldns_rr_list_rr_count(right);\n\t} else {\n\t\tr_rr_count = 0;\n\t}\n\n\tcat = ldns_rr_list_new();\n\n\tif (!cat) {\n\t\treturn NULL;\n\t}\n\n\t/* left */\n\tfor(i = 0; i < l_rr_count; i++) {\n\t\tldns_rr_list_push_rr(cat,\n\t\t\t\tldns_rr_clone(ldns_rr_list_rr(left, i)));\n\t}\n\t/* right */\n\tfor(i = 0; i < r_rr_count; i++) {\n\t\tldns_rr_list_push_rr(cat,\n\t\t\t\tldns_rr_clone(ldns_rr_list_rr(right, i)));\n\t}\n\treturn cat;\n}\n\nldns_rr_list *\nldns_rr_list_subtype_by_rdf(const ldns_rr_list *l, const ldns_rdf *r, size_t pos)\n{\n\tsize_t i;\n\tldns_rr_list *subtyped;\n\tldns_rdf *list_rdf;\n\n\tsubtyped = ldns_rr_list_new();\n\n\tfor(i = 0; i < ldns_rr_list_rr_count(l); i++) {\n\t\tlist_rdf = ldns_rr_rdf(\n\t\t\tldns_rr_list_rr(l, i),\n\t\t\tpos);\n\t\tif (!list_rdf) {\n\t\t\t/* pos is too large or any other error */\n\t\t\tldns_rr_list_deep_free(subtyped);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (ldns_rdf_compare(list_rdf, r) == 0) {\n\t\t\t/* a match */\n\t\t\tldns_rr_list_push_rr(subtyped,\n\t\t\t\t\tldns_rr_clone(ldns_rr_list_rr(l, i)));\n\t\t}\n\t}\n\n\tif (ldns_rr_list_rr_count(subtyped) > 0) {\n\t\treturn subtyped;\n\t} else {\n\t\tldns_rr_list_free(subtyped);\n\t\treturn NULL;\n\t}\n}\n\nbool\nldns_rr_list_push_rr(ldns_rr_list *rr_list, const ldns_rr *rr)\n{\n\tsize_t rr_count;\n\tsize_t cap;\n\n\trr_count = ldns_rr_list_rr_count(rr_list);\n\tcap = rr_list->_rr_capacity;\n\n\t/* grow the array */\n\tif(rr_count+1 > cap) {\n\t\tldns_rr **rrs;\n\n\t\tif(cap == 0)\n\t\t\tcap = LDNS_RRLIST_INIT;  /* initial list size */\n\t\telse\tcap *= 2;\n\t\trrs = LDNS_XREALLOC(rr_list->_rrs, ldns_rr *, cap);\n\t\tif (!rrs) {\n\t\t\treturn false;\n\t\t}\n\t\trr_list->_rrs = rrs;\n\t\trr_list->_rr_capacity = cap;\n\t}\n\n\t/* add the new member */\n\trr_list->_rrs[rr_count] = (ldns_rr*)rr;\n\n\tldns_rr_list_set_rr_count(rr_list, rr_count + 1);\n\treturn true;\n}\n\nbool\nldns_rr_list_push_rr_list(ldns_rr_list *rr_list, const ldns_rr_list *push_list)\n{\n\tsize_t i;\n\n\tfor(i = 0; i < ldns_rr_list_rr_count(push_list); i++) {\n\t\tif (!ldns_rr_list_push_rr(rr_list,\n\t\t\t\tldns_rr_list_rr(push_list, i))) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nldns_rr *\nldns_rr_list_pop_rr(ldns_rr_list *rr_list)\n{\n\tsize_t rr_count;\n\tsize_t cap;\n\tldns_rr *pop;\n\n\trr_count = ldns_rr_list_rr_count(rr_list);\n\n\tif (rr_count == 0) {\n\t\treturn NULL;\n\t}\n\n\tcap = rr_list->_rr_capacity;\n\tpop = ldns_rr_list_rr(rr_list, rr_count - 1);\n\n\t/* shrink the array */\n\tif(cap > LDNS_RRLIST_INIT && rr_count-1 <= cap/2) {\n                ldns_rr** a;\n\t\tcap /= 2;\n                a = LDNS_XREALLOC(rr_list->_rrs, ldns_rr *, cap);\n                if(a) {\n\t\t        rr_list->_rrs = a;\n\t\t        rr_list->_rr_capacity = cap;\n                }\n\t}\n\n\tldns_rr_list_set_rr_count(rr_list, rr_count - 1);\n\n\treturn pop;\n}\n\nldns_rr_list *\nldns_rr_list_pop_rr_list(ldns_rr_list *rr_list, size_t howmany)\n{\n\t/* pop a number of rr's and put them in a rr_list */\n\tldns_rr_list *popped;\n\tldns_rr *p;\n\tsize_t i = howmany;\n\n\tpopped = ldns_rr_list_new();\n\n\tif (!popped) {\n\t\treturn NULL;\n\t}\n\n\n\twhile(i > 0 &&\n\t\t\t(p = ldns_rr_list_pop_rr(rr_list)) != NULL) {\n\t\tldns_rr_list_push_rr(popped, p);\n\t\ti--;\n\t}\n\n\tif (i == howmany) { /* so i <= 0 */\n\t\tldns_rr_list_free(popped);\n\t\treturn NULL;\n\t} else {\n\t\treturn popped;\n\t}\n}\n\n\nbool\nldns_rr_list_contains_rr(const ldns_rr_list *rr_list, const ldns_rr *rr)\n{\n\tsize_t i;\n\n\tif (!rr_list || !rr || ldns_rr_list_rr_count(rr_list) == 0) {\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\tif (rr == ldns_rr_list_rr(rr_list, i)) {\n\t\t\treturn true;\n\t\t} else if (ldns_rr_compare(rr, ldns_rr_list_rr(rr_list, i)) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool\nldns_is_rrset(const ldns_rr_list *rr_list)\n{\n\tldns_rr_type t;\n\tldns_rr_class c;\n\tldns_rdf *o;\n\tldns_rr *tmp;\n\tsize_t i;\n\n\tif (!rr_list || ldns_rr_list_rr_count(rr_list) == 0) {\n\t\treturn false;\n\t}\n\n\ttmp = ldns_rr_list_rr(rr_list, 0);\n\n\tt = ldns_rr_get_type(tmp);\n\tc = ldns_rr_get_class(tmp);\n\to = ldns_rr_owner(tmp);\n\n\t/* compare these with the rest of the rr_list, start with 1 */\n\tfor (i = 1; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\ttmp = ldns_rr_list_rr(rr_list, i);\n\t\tif (t != ldns_rr_get_type(tmp)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (c != ldns_rr_get_class(tmp)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ldns_rdf_compare(o, ldns_rr_owner(tmp)) != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool\nldns_rr_set_push_rr(ldns_rr_list *rr_list, ldns_rr *rr)\n{\n\tsize_t rr_count;\n\tsize_t i;\n\tldns_rr *last;\n\n\tassert(rr != NULL);\n\n\trr_count = ldns_rr_list_rr_count(rr_list);\n\n\tif (rr_count == 0) {\n\t\t/* nothing there, so checking it is\n\t\t * not needed */\n\t\treturn ldns_rr_list_push_rr(rr_list, rr);\n\t} else {\n\t\t/* check with the final rr in the rr_list */\n\t\tlast = ldns_rr_list_rr(rr_list, rr_count - 1);\n\n\t\tif (ldns_rr_get_class(last) != ldns_rr_get_class(rr)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (ldns_rr_get_type(last) != ldns_rr_get_type(rr)) {\n\t\t\treturn false;\n\t\t}\n\t\t/* only check if not equal to RRSIG */\n\t\tif (ldns_rr_get_type(rr) != LDNS_RR_TYPE_RRSIG) {\n\t\t\tif (ldns_rr_ttl(last) != ldns_rr_ttl(rr)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (ldns_rdf_compare(ldns_rr_owner(last),\n\t\t\t\t\tldns_rr_owner(rr)) != 0) {\n\t\t\treturn false;\n\t\t}\n\t\t/* ok, still alive - check if the rr already\n\t\t * exists - if so, dont' add it */\n\t\tfor(i = 0; i < rr_count; i++) {\n\t\t\tif(ldns_rr_compare(\n\t\t\t\t\tldns_rr_list_rr(rr_list, i), rr) == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/* it's safe, push it */\n\t\treturn ldns_rr_list_push_rr(rr_list, rr);\n\t}\n}\n\nldns_rr *\nldns_rr_set_pop_rr(ldns_rr_list *rr_list)\n{\n\treturn ldns_rr_list_pop_rr(rr_list);\n}\n\nldns_rr_list *\nldns_rr_list_pop_rrset(ldns_rr_list *rr_list)\n{\n\tldns_rr_list *rrset;\n\tldns_rr *last_rr = NULL;\n\tldns_rr *next_rr;\n\n\tif (!rr_list) {\n\t\treturn NULL;\n\t}\n\n\trrset = ldns_rr_list_new();\n\tif (!last_rr) {\n\t\tlast_rr = ldns_rr_list_pop_rr(rr_list);\n\t\tif (!last_rr) {\n\t\t\tldns_rr_list_free(rrset);\n\t\t\treturn NULL;\n\t\t} else {\n\t\t\tldns_rr_list_push_rr(rrset, last_rr);\n\t\t}\n\t}\n\n\tif (ldns_rr_list_rr_count(rr_list) > 0) {\n\t\tnext_rr = ldns_rr_list_rr(rr_list, ldns_rr_list_rr_count(rr_list) - 1);\n\t} else {\n\t\tnext_rr = NULL;\n\t}\n\n\twhile (next_rr) {\n\t\tif (\n\t\t\tldns_rdf_compare(ldns_rr_owner(next_rr),\n\t\t\t\t\t ldns_rr_owner(last_rr)) == 0\n\t\t\t&&\n\t\t\tldns_rr_get_type(next_rr) == ldns_rr_get_type(last_rr)\n\t\t\t&&\n\t\t\tldns_rr_get_class(next_rr) == ldns_rr_get_class(last_rr)\n\t\t   ) {\n\t\t\tldns_rr_list_push_rr(rrset, ldns_rr_list_pop_rr(rr_list));\n\t\t\tif (ldns_rr_list_rr_count(rr_list) > 0) {\n\t\t\t\tlast_rr = next_rr;\n\t\t\t\tnext_rr = ldns_rr_list_rr(rr_list, ldns_rr_list_rr_count(rr_list) - 1);\n\t\t\t} else {\n\t\t\t\tnext_rr = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnext_rr = NULL;\n\t\t}\n\t}\n\n\treturn rrset;\n}\n\nldns_rr *\nldns_rr_clone(const ldns_rr *rr)\n{\n\tsize_t i;\n\tldns_rr *new_rr;\n\n\tif (!rr) {\n\t\treturn NULL;\n\t}\n\n\tnew_rr = ldns_rr_new();\n\tif (!new_rr) {\n\t\treturn NULL;\n\t}\n\tif (ldns_rr_owner(rr)) {\n\t\tldns_rr_set_owner(new_rr, ldns_rdf_clone(ldns_rr_owner(rr)));\n  \t}\n\tldns_rr_set_ttl(new_rr, ldns_rr_ttl(rr));\n\tldns_rr_set_type(new_rr, ldns_rr_get_type(rr));\n\tldns_rr_set_class(new_rr, ldns_rr_get_class(rr));\n\tldns_rr_set_question(new_rr, ldns_rr_is_question(rr));\n\n\tfor (i = 0; i < ldns_rr_rd_count(rr); i++) {\n        \tif (ldns_rr_rdf(rr,i)) {\n        \t\tldns_rr_push_rdf(new_rr, ldns_rdf_clone(ldns_rr_rdf(rr, i)));\n                }\n\t}\n\n\treturn new_rr;\n}\n\nldns_rr_list *\nldns_rr_list_clone(const ldns_rr_list *rrlist)\n{\n\tsize_t i;\n\tldns_rr_list *new_list;\n\tldns_rr *r;\n\n\tif (!rrlist) {\n\t\treturn NULL;\n\t}\n\n\tnew_list = ldns_rr_list_new();\n\tif (!new_list) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < ldns_rr_list_rr_count(rrlist); i++) {\n\t\tr = ldns_rr_clone(\n\t\t\tldns_rr_list_rr(rrlist, i)\n\t\t    );\n\t\tif (!r) {\n\t\t\t/* huh, failure in cloning */\n\t\t\tldns_rr_list_deep_free(new_list);\n\t\t\treturn NULL;\n\t\t}\n\t\tldns_rr_list_push_rr(new_list, r);\n\t}\n\treturn new_list;\n}\n\n\nstatic int\nqsort_schwartz_rr_compare(const void *a, const void *b)\n{\n\tint result = 0;\n\tldns_rr *rr1, *rr2;\n\tldns_buffer *rr1_buf, *rr2_buf;\n\tstruct ldns_schwartzian_compare_struct *sa = *(struct ldns_schwartzian_compare_struct **) a;\n\tstruct ldns_schwartzian_compare_struct *sb = *(struct ldns_schwartzian_compare_struct **) b;\n\t/* if we are doing 2wire, we need to do lowercasing on the dname (and maybe on the rdata)\n\t * this must be done for comparison only, so we need to have a temp var for both buffers,\n\t * which is only used when the transformed object value isn't there yet\n\t */\n\tldns_rr *canonical_a, *canonical_b;\n\n\trr1 = (ldns_rr *) sa->original_object;\n\trr2 = (ldns_rr *) sb->original_object;\n\n\tresult = ldns_rr_compare_no_rdata(rr1, rr2);\n\n\tif (result == 0) {\n\t\tif (!sa->transformed_object) {\n\t\t\tcanonical_a = ldns_rr_clone(sa->original_object);\n\t\t\tldns_rr2canonical(canonical_a);\n\t\t\tsa->transformed_object = ldns_buffer_new(ldns_rr_uncompressed_size(canonical_a));\n\t\t\tif (ldns_rr2buffer_wire(sa->transformed_object, canonical_a, LDNS_SECTION_ANY) != LDNS_STATUS_OK) {\n\t\t                ldns_buffer_free((ldns_buffer *)sa->transformed_object);\n                                sa->transformed_object = NULL;\n\t\t\t\tldns_rr_free(canonical_a);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tldns_rr_free(canonical_a);\n\t\t}\n\t\tif (!sb->transformed_object) {\n\t\t\tcanonical_b = ldns_rr_clone(sb->original_object);\n\t\t\tldns_rr2canonical(canonical_b);\n\t\t\tsb->transformed_object = ldns_buffer_new(ldns_rr_uncompressed_size(canonical_b));\n\t\t\tif (ldns_rr2buffer_wire(sb->transformed_object, canonical_b, LDNS_SECTION_ANY) != LDNS_STATUS_OK) {\n\t\t                ldns_buffer_free((ldns_buffer *)sa->transformed_object);\n\t\t                ldns_buffer_free((ldns_buffer *)sb->transformed_object);\n                                sa->transformed_object = NULL;\n                                sb->transformed_object = NULL;\n\t\t\t\tldns_rr_free(canonical_b);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tldns_rr_free(canonical_b);\n\t\t}\n\t\trr1_buf = (ldns_buffer *) sa->transformed_object;\n\t\trr2_buf = (ldns_buffer *) sb->transformed_object;\n\n\t\tresult = ldns_rr_compare_wire(rr1_buf, rr2_buf);\n\t}\n\n\treturn result;\n}\n\nvoid\nldns_rr_list_sort(ldns_rr_list *unsorted)\n{\n\tstruct ldns_schwartzian_compare_struct **sortables;\n\tsize_t item_count;\n\tsize_t i;\n\n\tif (unsorted) {\n\t\titem_count = ldns_rr_list_rr_count(unsorted);\n\n\t\tsortables = LDNS_XMALLOC(struct ldns_schwartzian_compare_struct *,\n\t\t\t\t\t item_count);\n                if(!sortables) return; /* no way to return error */\n\t\tfor (i = 0; i < item_count; i++) {\n\t\t\tsortables[i] = LDNS_XMALLOC(struct ldns_schwartzian_compare_struct, 1);\n                        if(!sortables[i]) {\n                                /* free the allocated parts */\n                                while(i>0) {\n                                        i--;\n                                        LDNS_FREE(sortables[i]);\n                                }\n                                /* no way to return error */\n\t\t\t\tLDNS_FREE(sortables);\n                                return;\n                        }\n\t\t\tsortables[i]->original_object = ldns_rr_list_rr(unsorted, i);\n\t\t\tsortables[i]->transformed_object = NULL;\n\t\t}\n\t\tqsort(sortables,\n\t\t      item_count,\n\t\t      sizeof(struct ldns_schwartzian_compare_struct *),\n\t\t      qsort_schwartz_rr_compare);\n\t\tfor (i = 0; i < item_count; i++) {\n\t\t\tunsorted->_rrs[i] = sortables[i]->original_object;\n\t\t\tif (sortables[i]->transformed_object) {\n\t\t\t\tldns_buffer_free(sortables[i]->transformed_object);\n\t\t\t}\n\t\t\tLDNS_FREE(sortables[i]);\n\t\t}\n\t\tLDNS_FREE(sortables);\n\t}\n}\n\nint\nldns_rr_compare_no_rdata(const ldns_rr *rr1, const ldns_rr *rr2)\n{\n\tsize_t rr1_len;\n\tsize_t rr2_len;\n        size_t offset;\n\n\tassert(rr1 != NULL);\n\tassert(rr2 != NULL);\n\n\trr1_len = ldns_rr_uncompressed_size(rr1);\n\trr2_len = ldns_rr_uncompressed_size(rr2);\n\n\tif (ldns_dname_compare(ldns_rr_owner(rr1), ldns_rr_owner(rr2)) < 0) {\n\t\treturn -1;\n\t} else if (ldns_dname_compare(ldns_rr_owner(rr1), ldns_rr_owner(rr2)) > 0) {\n\t\treturn 1;\n\t}\n\n        /* should return -1 if rr1 comes before rr2, so need to do rr1 - rr2, not rr2 - rr1 */\n        if (ldns_rr_get_class(rr1) != ldns_rr_get_class(rr2)) {\n            return ldns_rr_get_class(rr1) - ldns_rr_get_class(rr2);\n        }\n\n        /* should return -1 if rr1 comes before rr2, so need to do rr1 - rr2, not rr2 - rr1 */\n        if (ldns_rr_get_type(rr1) != ldns_rr_get_type(rr2)) {\n            return ldns_rr_get_type(rr1) - ldns_rr_get_type(rr2);\n        }\n\n        /* offset is the owername length + ttl + type + class + rdlen == start of wire format rdata */\n        offset = ldns_rdf_size(ldns_rr_owner(rr1)) + 4 + 2 + 2 + 2;\n        /* if either record doesn't have any RDATA... */\n        if (offset > rr1_len || offset > rr2_len) {\n            if (rr1_len == rr2_len) {\n              return 0;\n            }\n            return ((int) rr2_len - (int) rr1_len);\n        }\n\n\treturn 0;\n}\n\nint ldns_rr_compare_wire(const ldns_buffer *rr1_buf, const ldns_buffer *rr2_buf)\n{\n        size_t rr1_len, rr2_len, min_len, i, offset;\n\n        rr1_len = ldns_buffer_capacity(rr1_buf);\n        rr2_len = ldns_buffer_capacity(rr2_buf);\n\n        /* jump past dname (checked in earlier part)\n         * and especially past TTL */\n        offset = 0;\n        while (offset < rr1_len && *ldns_buffer_at(rr1_buf, offset) != 0) {\n          offset += *ldns_buffer_at(rr1_buf, offset) + 1;\n        }\n        /* jump to rdata section (PAST the rdata length field, otherwise\n           rrs with different lengths might be sorted erroneously */\n        offset += 11;\n\t   min_len = (rr1_len < rr2_len) ? rr1_len : rr2_len;\n        /* Compare RRs RDATA byte for byte. */\n        for(i = offset; i < min_len; i++) {\n                if (*ldns_buffer_at(rr1_buf,i) < *ldns_buffer_at(rr2_buf,i)) {\n                        return -1;\n                } else if (*ldns_buffer_at(rr1_buf,i) > *ldns_buffer_at(rr2_buf,i)) {\n                        return +1;\n                }\n        }\n\n        /* If both RDATAs are the same up to min_len, then the shorter one sorts first. */\n        if (rr1_len < rr2_len) {\n                return -1;\n        } else if (rr1_len > rr2_len) {\n                return +1;\n\t}\n        /* The RDATAs are equal. */\n        return 0;\n\n}\n\nint\nldns_rr_compare(const ldns_rr *rr1, const ldns_rr *rr2)\n{\n\tint result;\n\tsize_t rr1_len, rr2_len;\n\n\tldns_buffer *rr1_buf;\n\tldns_buffer *rr2_buf;\n\n\tresult = ldns_rr_compare_no_rdata(rr1, rr2);\n\tif (result == 0) {\n\t\trr1_len = ldns_rr_uncompressed_size(rr1);\n\t\trr2_len = ldns_rr_uncompressed_size(rr2);\n\n\t\trr1_buf = ldns_buffer_new(rr1_len);\n\t\trr2_buf = ldns_buffer_new(rr2_len);\n\n\t\tif (ldns_rr2buffer_wire_canonical(rr1_buf,\n\t\t\t\t\t\t\t\t    rr1,\n\t\t\t\t\t\t\t\t    LDNS_SECTION_ANY)\n\t\t    != LDNS_STATUS_OK) {\n\t\t\tldns_buffer_free(rr1_buf);\n\t\t\tldns_buffer_free(rr2_buf);\n\t\t\treturn 0;\n\t\t}\n\t\tif (ldns_rr2buffer_wire_canonical(rr2_buf,\n\t\t\t\t\t\t\t\t    rr2,\n\t\t\t\t\t\t\t\t    LDNS_SECTION_ANY)\n\t\t    != LDNS_STATUS_OK) {\n\t\t\tldns_buffer_free(rr1_buf);\n\t\t\tldns_buffer_free(rr2_buf);\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult = ldns_rr_compare_wire(rr1_buf, rr2_buf);\n\n\t\tldns_buffer_free(rr1_buf);\n\t\tldns_buffer_free(rr2_buf);\n\t}\n\n\treturn result;\n}\n\n/* convert dnskey to a ds with the given algorithm,\n * then compare the result with the given ds */\nstatic int\nldns_rr_compare_ds_dnskey(ldns_rr *ds,\n                          ldns_rr *dnskey)\n{\n\tldns_rr *ds_gen;\n\tbool result = false;\n\tldns_hash algo;\n\n\tif (!dnskey || !ds ||\n\t    ldns_rr_get_type(ds) != LDNS_RR_TYPE_DS ||\n\t    ldns_rr_get_type(dnskey) != LDNS_RR_TYPE_DNSKEY) {\n\t\treturn false;\n\t}\n\n\tif (ldns_rr_rdf(ds, 2) == NULL) {\n\t\treturn false;\n\t}\n\talgo = ldns_rdf2native_int8(ldns_rr_rdf(ds, 2));\n\n\tds_gen = ldns_key_rr2ds(dnskey, algo);\n\tif (ds_gen) {\n\t\tresult = ldns_rr_compare(ds, ds_gen) == 0;\n\t\tldns_rr_free(ds_gen);\n\t}\n\treturn result;\n}\n\nbool\nldns_rr_compare_ds(const ldns_rr *orr1, const ldns_rr *orr2)\n{\n\tbool result;\n\tldns_rr *rr1 = ldns_rr_clone(orr1);\n\tldns_rr *rr2 = ldns_rr_clone(orr2);\n\n\t/* set ttls to zero */\n\tldns_rr_set_ttl(rr1, 0);\n\tldns_rr_set_ttl(rr2, 0);\n\n\tif (ldns_rr_get_type(rr1) == LDNS_RR_TYPE_DS &&\n\t    ldns_rr_get_type(rr2) == LDNS_RR_TYPE_DNSKEY) {\n\t\tresult = ldns_rr_compare_ds_dnskey(rr1, rr2);\n\t} else if (ldns_rr_get_type(rr1) == LDNS_RR_TYPE_DNSKEY &&\n\t    ldns_rr_get_type(rr2) == LDNS_RR_TYPE_DS) {\n\t\tresult = ldns_rr_compare_ds_dnskey(rr2, rr1);\n\t} else {\n\t\tresult = (ldns_rr_compare(rr1, rr2) == 0);\n\t}\n\n\tldns_rr_free(rr1);\n\tldns_rr_free(rr2);\n\n\treturn result;\n}\n\nint\nldns_rr_list_compare(const ldns_rr_list *rrl1, const ldns_rr_list *rrl2)\n{\n\tsize_t i = 0;\n\tint rr_cmp;\n\n\tassert(rrl1 != NULL);\n\tassert(rrl2 != NULL);\n\n\tfor (i = 0; i < ldns_rr_list_rr_count(rrl1) && i < ldns_rr_list_rr_count(rrl2); i++) {\n\t\trr_cmp = ldns_rr_compare(ldns_rr_list_rr(rrl1, i), ldns_rr_list_rr(rrl2, i));\n\t\tif (rr_cmp != 0) {\n\t\t\treturn rr_cmp;\n\t\t}\n\t}\n\n\tif (i == ldns_rr_list_rr_count(rrl1) &&\n\t    i != ldns_rr_list_rr_count(rrl2)) {\n\t\treturn 1;\n\t} else if (i == ldns_rr_list_rr_count(rrl2) &&\n\t           i != ldns_rr_list_rr_count(rrl1)) {\n\t\treturn -1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nsize_t\nldns_rr_uncompressed_size(const ldns_rr *r)\n{\n\tsize_t rrsize;\n\tsize_t i;\n\n\trrsize = 0;\n\t/* add all the rdf sizes */\n\tfor(i = 0; i < ldns_rr_rd_count(r); i++) {\n\t\trrsize += ldns_rdf_size(ldns_rr_rdf(r, i));\n\t}\n\t/* ownername */\n\trrsize += ldns_rdf_size(ldns_rr_owner(r));\n\trrsize += LDNS_RR_OVERHEAD;\n\treturn rrsize;\n}\n\nvoid\nldns_rr2canonical(ldns_rr *rr)\n{\n\tuint16_t i;\n\n\tif (!rr) {\n\t  return;\n        }\n\n        ldns_dname2canonical(ldns_rr_owner(rr));\n\n\t/*\n\t * lowercase the rdata dnames if the rr type is one\n\t * of the list in chapter 7 of RFC3597\n\t * Also added RRSIG, because a \"Signer's Name\" should be canonicalized\n\t * too. See dnssec-bis-updates-16. We can add it to this list because\n\t * the \"Signer's Name\"  is the only dname type rdata field in a RRSIG.\n\t */\n\tswitch(ldns_rr_get_type(rr)) {\n        \tcase LDNS_RR_TYPE_NS:\n        \tcase LDNS_RR_TYPE_MD:\n        \tcase LDNS_RR_TYPE_MF:\n        \tcase LDNS_RR_TYPE_CNAME:\n        \tcase LDNS_RR_TYPE_SOA:\n        \tcase LDNS_RR_TYPE_MB:\n        \tcase LDNS_RR_TYPE_MG:\n        \tcase LDNS_RR_TYPE_MR:\n        \tcase LDNS_RR_TYPE_PTR:\n        \tcase LDNS_RR_TYPE_MINFO:\n        \tcase LDNS_RR_TYPE_MX:\n        \tcase LDNS_RR_TYPE_RP:\n        \tcase LDNS_RR_TYPE_AFSDB:\n        \tcase LDNS_RR_TYPE_RT:\n        \tcase LDNS_RR_TYPE_SIG:\n        \tcase LDNS_RR_TYPE_PX:\n        \tcase LDNS_RR_TYPE_NXT:\n        \tcase LDNS_RR_TYPE_NAPTR:\n        \tcase LDNS_RR_TYPE_KX:\n        \tcase LDNS_RR_TYPE_SRV:\n        \tcase LDNS_RR_TYPE_DNAME:\n        \tcase LDNS_RR_TYPE_A6:\n        \tcase LDNS_RR_TYPE_RRSIG:\n\t\t\tfor (i = 0; i < ldns_rr_rd_count(rr); i++) {\n\t\t\t\tldns_dname2canonical(ldns_rr_rdf(rr, i));\n\t\t\t}\n\t\t\treturn;\n\t\tdefault:\n\t\t\t/* do nothing */\n\t\t\treturn;\n\t}\n}\n\nvoid\nldns_rr_list2canonical(const ldns_rr_list *rr_list)\n{\n\tsize_t i;\n\tfor (i = 0; i < ldns_rr_list_rr_count(rr_list); i++) {\n\t\tldns_rr2canonical(ldns_rr_list_rr(rr_list, i));\n\t}\n}\n\nuint8_t\nldns_rr_label_count(const ldns_rr *rr)\n{\n\tif (!rr) {\n\t\treturn 0;\n\t}\n\treturn ldns_dname_label_count(\n\t\t\tldns_rr_owner(rr));\n}\n\n/** \\cond */\nstatic const ldns_rdf_type type_0_wireformat[] = { LDNS_RDF_TYPE_UNKNOWN };\nstatic const ldns_rdf_type type_a_wireformat[] = { LDNS_RDF_TYPE_A };\nstatic const ldns_rdf_type type_ns_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_md_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_mf_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_cname_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_soa_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_INT32, \n\tLDNS_RDF_TYPE_PERIOD, LDNS_RDF_TYPE_PERIOD, LDNS_RDF_TYPE_PERIOD,\n\tLDNS_RDF_TYPE_PERIOD\n};\nstatic const ldns_rdf_type type_mb_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_mg_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_mr_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_wks_wireformat[] = {\n\tLDNS_RDF_TYPE_A, LDNS_RDF_TYPE_WKS\n};\nstatic const ldns_rdf_type type_ptr_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_hinfo_wireformat[] = {\n\tLDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_minfo_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_mx_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_rp_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_afsdb_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_x25_wireformat[] = { LDNS_RDF_TYPE_STR };\nstatic const ldns_rdf_type type_isdn_wireformat[] = {\n\tLDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_rt_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_nsap_wireformat[] = {\n\tLDNS_RDF_TYPE_NSAP\n};\nstatic const ldns_rdf_type type_nsap_ptr_wireformat[] = {\n\tLDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_sig_wireformat[] = {\n\tLDNS_RDF_TYPE_TYPE, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_key_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_px_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_gpos_wireformat[] = {\n\tLDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR\n};\nstatic const ldns_rdf_type type_aaaa_wireformat[] = { LDNS_RDF_TYPE_AAAA };\nstatic const ldns_rdf_type type_loc_wireformat[] = { LDNS_RDF_TYPE_LOC };\nstatic const ldns_rdf_type type_nxt_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_UNKNOWN\n};\nstatic const ldns_rdf_type type_eid_wireformat[] = {\n\tLDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_nimloc_wireformat[] = {\n\tLDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_srv_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_atma_wireformat[] = {\n\tLDNS_RDF_TYPE_ATMA\n};\nstatic const ldns_rdf_type type_naptr_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_STR, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_kx_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_cert_wireformat[] = {\n\t LDNS_RDF_TYPE_CERT_ALG, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_a6_wireformat[] = { LDNS_RDF_TYPE_UNKNOWN };\nstatic const ldns_rdf_type type_dname_wireformat[] = { LDNS_RDF_TYPE_DNAME };\nstatic const ldns_rdf_type type_sink_wireformat[] = { LDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_apl_wireformat[] = {\n\tLDNS_RDF_TYPE_APL\n};\nstatic const ldns_rdf_type type_ds_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_sshfp_wireformat[] = {\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_ipseckey_wireformat[] = {\n\tLDNS_RDF_TYPE_IPSECKEY\n};\nstatic const ldns_rdf_type type_rrsig_wireformat[] = {\n\tLDNS_RDF_TYPE_TYPE, LDNS_RDF_TYPE_ALG, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_TIME, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_nsec_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_NSEC\n};\nstatic const ldns_rdf_type type_dhcid_wireformat[] = {\n\tLDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_talink_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME, LDNS_RDF_TYPE_DNAME\n};\n#ifdef RRTYPE_OPENPGPKEY\nstatic const ldns_rdf_type type_openpgpkey_wireformat[] = {\n\tLDNS_RDF_TYPE_B64\n};\n#endif\nstatic const ldns_rdf_type type_csync_wireformat[] = {\n\tLDNS_RDF_TYPE_INT32, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_NSEC\n};\nstatic const ldns_rdf_type type_zonemd_wireformat[] = {\n\tLDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_HEX\n};\n\n/* nsec3 is some vars, followed by same type of data of nsec */\nstatic const ldns_rdf_type type_nsec3_wireformat[] = {\n/*\tLDNS_RDF_TYPE_NSEC3_VARS, LDNS_RDF_TYPE_NSEC3_NEXT_OWNER, LDNS_RDF_TYPE_NSEC*/\n\tLDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT8, LDNS_RDF_TYPE_INT16, LDNS_RDF_TYPE_NSEC3_SALT, LDNS_RDF_TYPE_NSEC3_NEXT_OWNER, LDNS_RDF_TYPE_NSEC\n};\n\nstatic const ldns_rdf_type type_nsec3param_wireformat[] = {\n/*\tLDNS_RDF_TYPE_NSEC3_PARAMS_VARS*/\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_NSEC3_SALT\n};\n\nstatic const ldns_rdf_type type_dnskey_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_ALG,\n\tLDNS_RDF_TYPE_B64\n};\nstatic const ldns_rdf_type type_tkey_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME,\n\tLDNS_RDF_TYPE_TIME,\n\tLDNS_RDF_TYPE_TIME,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16_DATA,\n\tLDNS_RDF_TYPE_INT16_DATA,\n};\nstatic const ldns_rdf_type type_tsig_wireformat[] = {\n\tLDNS_RDF_TYPE_DNAME,\n\tLDNS_RDF_TYPE_TSIGTIME,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16_DATA,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16_DATA\n};\nstatic const ldns_rdf_type type_tlsa_wireformat[] = {\n\tLDNS_RDF_TYPE_CERTIFICATE_USAGE,\n\tLDNS_RDF_TYPE_SELECTOR,\n\tLDNS_RDF_TYPE_MATCHING_TYPE,\n\tLDNS_RDF_TYPE_HEX\n};\nstatic const ldns_rdf_type type_hip_wireformat[] = {\n\tLDNS_RDF_TYPE_HIP\n};\nstatic const ldns_rdf_type type_nid_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_ILNP64\n};\nstatic const ldns_rdf_type type_l32_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_A\n};\nstatic const ldns_rdf_type type_l64_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_ILNP64\n};\nstatic const ldns_rdf_type type_lp_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_DNAME\n};\nstatic const ldns_rdf_type type_eui48_wireformat[] = {\n\tLDNS_RDF_TYPE_EUI48\n};\nstatic const ldns_rdf_type type_eui64_wireformat[] = {\n\tLDNS_RDF_TYPE_EUI64\n};\nstatic const ldns_rdf_type type_uri_wireformat[] = {\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_INT16,\n\tLDNS_RDF_TYPE_LONG_STR\n};\nstatic const ldns_rdf_type type_caa_wireformat[] = {\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_TAG,\n\tLDNS_RDF_TYPE_LONG_STR\n};\n#ifdef RRTYPE_DOA\nstatic const ldns_rdf_type type_doa_wireformat[] = {\n\tLDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_INT32,\n\tLDNS_RDF_TYPE_INT8,\n\tLDNS_RDF_TYPE_STR,\n\tLDNS_RDF_TYPE_B64\n};\n#endif\n#ifdef RRTYPE_AMTRELAY\nstatic const ldns_rdf_type type_amtrelay_wireformat[] = {\n\tLDNS_RDF_TYPE_AMTRELAY\n};\n#endif\n\n\n/** \\endcond */\n\n/** \\cond */\n/* All RR's defined in 1035 are well known and can thus\n * be compressed. See RFC3597. These RR's are:\n * CNAME HINFO MB MD MF MG MINFO MR MX NULL NS PTR SOA TXT\n */\nstatic ldns_rr_descriptor rdata_field_descriptors[] = {\n\t/* 0 */\n\t{ 0, NULL, 0, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 1 */\n\t{LDNS_RR_TYPE_A, \"A\", 1, 1, type_a_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 2 */\n\t{LDNS_RR_TYPE_NS, \"NS\", 1, 1, type_ns_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 3 */\n\t{LDNS_RR_TYPE_MD, \"MD\", 1, 1, type_md_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 4 */\n\t{LDNS_RR_TYPE_MF, \"MF\", 1, 1, type_mf_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 5 */\n\t{LDNS_RR_TYPE_CNAME, \"CNAME\", 1, 1, type_cname_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 6 */\n\t{LDNS_RR_TYPE_SOA, \"SOA\", 7, 7, type_soa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 2 },\n\t/* 7 */\n\t{LDNS_RR_TYPE_MB, \"MB\", 1, 1, type_mb_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 8 */\n\t{LDNS_RR_TYPE_MG, \"MG\", 1, 1, type_mg_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 9 */\n\t{LDNS_RR_TYPE_MR, \"MR\", 1, 1, type_mr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 10 */\n\t{LDNS_RR_TYPE_NULL, \"NULL\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 11 */\n\t{LDNS_RR_TYPE_WKS, \"WKS\", 2, 2, type_wks_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 12 */\n\t{LDNS_RR_TYPE_PTR, \"PTR\", 1, 1, type_ptr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 13 */\n\t{LDNS_RR_TYPE_HINFO, \"HINFO\", 2, 2, type_hinfo_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 14 */\n\t{LDNS_RR_TYPE_MINFO, \"MINFO\", 2, 2, type_minfo_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 2 },\n\t/* 15 */\n\t{LDNS_RR_TYPE_MX, \"MX\", 2, 2, type_mx_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_COMPRESS, 1 },\n\t/* 16 */\n\t{LDNS_RR_TYPE_TXT, \"TXT\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 17 */\n\t{LDNS_RR_TYPE_RP, \"RP\", 2, 2, type_rp_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 2 },\n\t/* 18 */\n\t{LDNS_RR_TYPE_AFSDB, \"AFSDB\", 2, 2, type_afsdb_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 19 */\n\t{LDNS_RR_TYPE_X25, \"X25\", 1, 1, type_x25_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 20 */\n\t{LDNS_RR_TYPE_ISDN, \"ISDN\", 1, 2, type_isdn_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 21 */\n\t{LDNS_RR_TYPE_RT, \"RT\", 2, 2, type_rt_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 22 */\n\t{LDNS_RR_TYPE_NSAP, \"NSAP\", 1, 1, type_nsap_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 23 */\n\t{LDNS_RR_TYPE_NSAP_PTR, \"NSAP-PTR\", 1, 1, type_nsap_ptr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 24 */\n\t{LDNS_RR_TYPE_SIG, \"SIG\", 9, 9, type_sig_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 25 */\n\t{LDNS_RR_TYPE_KEY, \"KEY\", 4, 4, type_key_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 26 */\n\t{LDNS_RR_TYPE_PX, \"PX\", 3, 3, type_px_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 2 },\n\t/* 27 */\n\t{LDNS_RR_TYPE_GPOS, \"GPOS\", 3, 3, type_gpos_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 28 */\n\t{LDNS_RR_TYPE_AAAA, \"AAAA\", 1, 1, type_aaaa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 29 */\n\t{LDNS_RR_TYPE_LOC, \"LOC\", 1, 1, type_loc_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 30 */\n\t{LDNS_RR_TYPE_NXT, \"NXT\", 2, 2, type_nxt_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 31 */\n\t{LDNS_RR_TYPE_EID, \"EID\", 1, 1, type_eid_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 32 */\n\t{LDNS_RR_TYPE_NIMLOC, \"NIMLOC\", 1, 1, type_nimloc_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 33 */\n\t{LDNS_RR_TYPE_SRV, \"SRV\", 4, 4, type_srv_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 34 */\n\t{LDNS_RR_TYPE_ATMA, \"ATMA\", 1, 1, type_atma_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 35 */\n\t{LDNS_RR_TYPE_NAPTR, \"NAPTR\", 6, 6, type_naptr_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 36 */\n\t{LDNS_RR_TYPE_KX, \"KX\", 2, 2, type_kx_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 37 */\n\t{LDNS_RR_TYPE_CERT, \"CERT\", 4, 4, type_cert_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 38 */\n\t{LDNS_RR_TYPE_A6, \"A6\", 1, 1, type_a6_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 39 */\n\t{LDNS_RR_TYPE_DNAME, \"DNAME\", 1, 1, type_dname_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 40 */\n\t{LDNS_RR_TYPE_SINK, \"SINK\", 1, 1, type_sink_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 41 */\n\t{LDNS_RR_TYPE_OPT, \"OPT\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 42 */\n\t{LDNS_RR_TYPE_APL, \"APL\", 0, 0, type_apl_wireformat, LDNS_RDF_TYPE_APL, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 43 */\n\t{LDNS_RR_TYPE_DS, \"DS\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 44 */\n\t{LDNS_RR_TYPE_SSHFP, \"SSHFP\", 3, 3, type_sshfp_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 45 */\n\t{LDNS_RR_TYPE_IPSECKEY, \"IPSECKEY\", 1, 1, type_ipseckey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 46 */\n\t{LDNS_RR_TYPE_RRSIG, \"RRSIG\", 9, 9, type_rrsig_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 47 */\n\t{LDNS_RR_TYPE_NSEC, \"NSEC\", 1, 2, type_nsec_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 48 */\n\t{LDNS_RR_TYPE_DNSKEY, \"DNSKEY\", 4, 4, type_dnskey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 49 */\n\t{LDNS_RR_TYPE_DHCID, \"DHCID\", 1, 1, type_dhcid_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 50 */\n\t{LDNS_RR_TYPE_NSEC3, \"NSEC3\", 5, 6, type_nsec3_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 51 */\n\t{LDNS_RR_TYPE_NSEC3PARAM, \"NSEC3PARAM\", 4, 4, type_nsec3param_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 52 */\n\t{LDNS_RR_TYPE_TLSA, \"TLSA\", 4, 4, type_tlsa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t{LDNS_RR_TYPE_SMIMEA, \"SMIMEA\", 4, 4, type_tlsa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE54\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 55\n\t * Hip ends with 0 or more Rendezvous Servers represented as dname's.\n\t * Hence the LDNS_RDF_TYPE_DNAME _variable field and the _maximum field\n\t * set to 0.\n\t */\n\t{LDNS_RR_TYPE_HIP, \"HIP\", 1, 1, type_hip_wireformat, LDNS_RDF_TYPE_DNAME, LDNS_RR_NO_COMPRESS, 0 },\n\n#ifdef RRTYPE_NINFO\n\t/* 56 */\n\t{LDNS_RR_TYPE_NINFO, \"NINFO\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE56\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n#ifdef RRTYPE_RKEY\n\t/* 57 */\n\t{LDNS_RR_TYPE_RKEY, \"RKEY\", 4, 4, type_key_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE57\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\t/* 58 */\n\t{LDNS_RR_TYPE_TALINK, \"TALINK\", 2, 2, type_talink_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 2 },\n\n\t/* 59 */\n\t{LDNS_RR_TYPE_CDS, \"CDS\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 60 */\n\t{LDNS_RR_TYPE_CDNSKEY, \"CDNSKEY\", 4, 4, type_dnskey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n#ifdef RRTYPE_OPENPGPKEY\n\t/* 61 */\n\t{LDNS_RR_TYPE_OPENPGPKEY, \"OPENPGPKEY\", 1, 1, type_openpgpkey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE61\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\n{LDNS_RR_TYPE_CSYNC, \"CSYNC\", 3, 3, type_csync_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_ZONEMD, \"ZONEMD\", 4, 4, type_zonemd_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE64\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE65\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE66\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE67\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE68\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE69\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE70\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE71\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE72\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE73\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE74\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE75\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE76\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE77\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE78\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE79\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE80\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE81\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE82\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE83\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE84\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE85\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE86\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE87\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE88\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE89\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE90\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE91\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE92\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE93\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE94\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE95\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE96\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE97\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE98\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 99 */\n\t{LDNS_RR_TYPE_SPF,  \"SPF\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* UINFO  [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE100\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* UID    [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE101\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* GID    [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE102\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* UNSPEC [IANA-Reserved] */\n{LDNS_RR_TYPE_NULL, \"TYPE103\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 104 */\n\t{LDNS_RR_TYPE_NID, \"NID\", 2, 2, type_nid_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 105 */\n\t{LDNS_RR_TYPE_L32, \"L32\", 2, 2, type_l32_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 106 */\n\t{LDNS_RR_TYPE_L64, \"L64\", 2, 2, type_l64_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 107 */\n\t{LDNS_RR_TYPE_LP, \"LP\", 2, 2, type_lp_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* 108 */\n\t{LDNS_RR_TYPE_EUI48, \"EUI48\", 1, 1, type_eui48_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 109 */\n\t{LDNS_RR_TYPE_EUI64, \"EUI64\", 1, 1, type_eui64_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n{LDNS_RR_TYPE_NULL, \"TYPE110\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE111\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE112\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE113\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE114\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE115\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE116\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE117\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE118\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE119\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE120\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE121\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE122\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE123\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE124\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE125\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE126\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE127\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE128\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE129\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE130\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE131\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE132\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE133\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE134\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE135\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE136\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE137\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE138\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE139\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE140\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE141\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE142\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE143\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE144\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE145\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE146\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE147\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE148\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE149\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE150\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE151\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE152\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE153\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE154\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE155\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE156\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE157\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE158\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE159\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE160\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE161\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE162\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE163\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE164\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE165\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE166\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE167\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE168\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE169\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE170\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE171\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE172\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE173\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE174\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE175\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE176\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE177\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE178\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE179\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE180\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE181\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE182\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE183\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE184\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE185\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE186\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE187\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE188\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE189\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE190\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE191\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE192\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE193\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE194\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE195\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE196\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE197\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE198\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE199\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE200\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE201\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE202\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE203\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE204\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE205\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE206\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE207\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE208\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE209\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE210\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE211\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE212\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE213\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE214\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE215\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE216\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE217\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE218\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE219\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE220\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE221\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE222\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE223\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE224\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE225\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE226\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE227\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE228\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE229\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE230\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE231\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE232\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE233\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE234\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE235\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE236\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE237\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE238\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE239\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE240\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE241\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE242\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE243\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE244\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE245\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE246\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE247\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n{LDNS_RR_TYPE_NULL, \"TYPE248\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* LDNS_RDF_TYPE_INT16_DATA takes two fields (length and data) as one.\n\t * So, unlike RFC 2930 spec, we have 7 min/max rdf's i.s.o. 8/9.\n\t */\n\t/* 249 */\n\t{LDNS_RR_TYPE_TKEY, \"TKEY\", 7, 7, type_tkey_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\t/* LDNS_RDF_TYPE_INT16_DATA takes two fields (length and data) as one.\n\t * So, unlike RFC 2930 spec, we have 7 min/max rdf's i.s.o. 8/9.\n\t */\n\t/* 250 */\n\t{LDNS_RR_TYPE_TSIG, \"TSIG\", 7, 7, type_tsig_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 1 },\n\n\t/* IXFR: A request for a transfer of an incremental zone transfer */\n{LDNS_RR_TYPE_NULL, \"TYPE251\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* AXFR: A request for a transfer of an entire zone */\n{LDNS_RR_TYPE_NULL, \"TYPE252\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* MAILB: A request for mailbox-related records (MB, MG or MR) */\n{LDNS_RR_TYPE_NULL, \"TYPE253\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* MAILA: A request for mail agent RRs (Obsolete - see MX) */\n{LDNS_RR_TYPE_NULL, \"TYPE254\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* ANY: A request for all (available) records */\n{LDNS_RR_TYPE_NULL, \"TYPE255\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n\t/* 256 */\n\t{LDNS_RR_TYPE_URI, \"URI\", 3, 3, type_uri_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\t/* 257 */\n\t{LDNS_RR_TYPE_CAA, \"CAA\", 3, 3, type_caa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n\n#ifdef RRTYPE_AVC\n\t/* 258 */\n\t{LDNS_RR_TYPE_AVC, \"AVC\", 1, 0, NULL, LDNS_RDF_TYPE_STR, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE258\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n#ifdef RRTYPE_DOA\n\t/* 259 */\n\t{LDNS_RR_TYPE_DOA, \"DOA\", 5, 5, type_doa_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE259\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n#ifdef RRTYPE_AMTRELAY\n\t/* 260 */\n\t{LDNS_RR_TYPE_AMTRELAY, \"AMTRELAY\", 1, 1, type_amtrelay_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE260\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\n/* split in array, no longer contiguous */\n\n#ifdef RRTYPE_TA\n\t/* 32768 */\n\t{LDNS_RR_TYPE_TA, \"TA\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#else\n{LDNS_RR_TYPE_NULL, \"TYPE32768\", 1, 1, type_0_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 },\n#endif\n\t/* 32769 */\n\t{LDNS_RR_TYPE_DLV, \"DLV\", 4, 4, type_ds_wireformat, LDNS_RDF_TYPE_NONE, LDNS_RR_NO_COMPRESS, 0 }\n};\n/** \\endcond */\n\n/**\n * \\def LDNS_RDATA_FIELD_DESCRIPTORS_COUNT\n * computes the number of rdata fields\n */\n#define LDNS_RDATA_FIELD_DESCRIPTORS_COUNT \\\n\t(sizeof(rdata_field_descriptors)/sizeof(rdata_field_descriptors[0]))\n\n\n/*---------------------------------------------------------------------------*\n * The functions below return an bitmap RDF with the space required to set\n * or unset all known RR types. Arguably these functions are better situated\n * in rdata.c, however for the space calculation it is necesarry to walk\n * through rdata_field_descriptors which is not easily possible from anywhere\n * other than rr.c where it is declared static.\n *\n * Alternatively rr.c could have provided an iterator for rr_type or \n * rdf_descriptors, but this seemed overkill for internal use only.\n */\nstatic ldns_rr_descriptor* rdata_field_descriptors_end =\n\t&rdata_field_descriptors[LDNS_RDATA_FIELD_DESCRIPTORS_COUNT];\n\n/* From RFC3845:\n *\n * 2.1.2.  The List of Type Bit Map(s) Field\n * \n *    The RR type space is split into 256 window blocks, each representing\n *    the low-order 8 bits of the 16-bit RR type space.  Each block that\n *    has at least one active RR type is encoded using a single octet\n *    window number (from 0 to 255), a single octet bitmap length (from 1\n *    to 32) indicating the number of octets used for the window block's\n *    bitmap, and up to 32 octets (256 bits) of bitmap.\n * \n *    Window blocks are present in the NSEC RR RDATA in increasing\n *    numerical order.\n * \n *    \"|\" denotes concatenation\n * \n *    Type Bit Map(s) Field = ( Window Block # | Bitmap Length | Bitmap ) +\n * \n *    <cut>\n * \n *    Blocks with no types present MUST NOT be included.  Trailing zero\n *    octets in the bitmap MUST be omitted.  The length of each block's\n *    bitmap is determined by the type code with the largest numerical\n *    value within that block, among the set of RR types present at the\n *    NSEC RR's owner name.  Trailing zero octets not specified MUST be\n *    interpreted as zero octets.\n */\nstatic ldns_status\nldns_rdf_bitmap_known_rr_types_set(ldns_rdf** rdf, int value)\n{\n\tuint8_t  window;\t\t/*  most significant octet of type */\n\tuint8_t  subtype;\t\t/* least significant octet of type */\n\tuint16_t windows[256]\t\t/* Max subtype per window */\n#ifndef S_SPLINT_S\n\t                      = { 0 }\n#endif\n\t                             ;\n\tldns_rr_descriptor* d;\t/* used to traverse rdata_field_descriptors */\n\tsize_t i;\t\t/* used to traverse windows array */\n\n\tsize_t sz;\t\t\t/* size needed for type bitmap rdf */\n\tuint8_t* data = NULL;\t\t/* rdf data */\n\tuint8_t* dptr;\t\t\t/* used to itraverse rdf data */\n\n\tassert(rdf != NULL);\n\n\t/* Which windows need to be in the bitmap rdf?\n\t */\n\tfor (d=rdata_field_descriptors; d < rdata_field_descriptors_end; d++) {\n\t\twindow  = d->_type >> 8;\n\t\tsubtype = d->_type & 0xff;\n\t\tif (windows[window] < subtype) {\n\t\t\twindows[window] = subtype;\n\t\t}\n\t}\n\n\t/* How much space do we need in the rdf for those windows?\n\t */\n\tsz = 0;\n\tfor (i = 0; i < 256; i++) {\n\t\tif (windows[i]) {\n\t\t\tsz += windows[i] / 8 + 3;\n\t\t}\n\t}\n\tif (sz > 0) {\n\t\t/* Format rdf data according RFC3845 Section 2.1.2 (see above)\n\t\t */\n\t\tdptr = data = LDNS_XMALLOC(uint8_t, sz);\n\t\tif (!data) {\n\t\t\treturn LDNS_STATUS_MEM_ERR;\n\t\t}\n\t\tmemset(data, value, sz);\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tif (windows[i]) {\n\t\t\t\t*dptr++ = (uint8_t)i;\n\t\t\t\t*dptr++ = (uint8_t)(windows[i] / 8 + 1);\n\t\t\t\tdptr += dptr[-1];\n\t\t\t}\n\t\t}\n\t}\n\t/* Allocate and return rdf structure for the data\n\t */\n\t*rdf = ldns_rdf_new(LDNS_RDF_TYPE_BITMAP, sz, data);\n\tif (!*rdf) {\n\t\tLDNS_FREE(data);\n\t\treturn LDNS_STATUS_MEM_ERR;\n\t}\n\treturn LDNS_STATUS_OK;\n}\n\nldns_status\nldns_rdf_bitmap_known_rr_types_space(ldns_rdf** rdf)\n{\n\treturn ldns_rdf_bitmap_known_rr_types_set(rdf, 0);\n}\n\nldns_status\nldns_rdf_bitmap_known_rr_types(ldns_rdf** rdf)\n{\n\treturn ldns_rdf_bitmap_known_rr_types_set(rdf, 255);\n}\n/* End of RDF bitmap functions\n *---------------------------------------------------------------------------*/\n\n\nconst ldns_rr_descriptor *\nldns_rr_descript(uint16_t type)\n{\n\tsize_t i;\n\tif (type < LDNS_RDATA_FIELD_DESCRIPTORS_COMMON) {\n\t\treturn &rdata_field_descriptors[type];\n\t} else {\n\t\t/* because not all array index equals type code */\n\t\tfor (i = LDNS_RDATA_FIELD_DESCRIPTORS_COMMON;\n\t\t     i < LDNS_RDATA_FIELD_DESCRIPTORS_COUNT;\n\t\t     i++) {\n\t\t        if (rdata_field_descriptors[i]._type == type) {\n\t\t     \t\treturn &rdata_field_descriptors[i];\n\t\t\t}\n\t\t}\n                return &rdata_field_descriptors[0];\n\t}\n}\n\nsize_t\nldns_rr_descriptor_minimum(const ldns_rr_descriptor *descriptor)\n{\n\tif (descriptor) {\n\t\treturn descriptor->_minimum;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nsize_t\nldns_rr_descriptor_maximum(const ldns_rr_descriptor *descriptor)\n{\n\tif (descriptor) {\n\t\tif (descriptor->_variable != LDNS_RDF_TYPE_NONE) {\n\t\t\t/* Should really be SIZE_MAX... bad FreeBSD.  */\n\t\t\treturn UINT_MAX;\n\t\t} else {\n\t\t\treturn descriptor->_maximum;\n\t\t}\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nldns_rdf_type\nldns_rr_descriptor_field_type(const ldns_rr_descriptor *descriptor,\n                              size_t index)\n{\n\tassert(descriptor != NULL);\n\tassert(index < descriptor->_maximum\n\t       || descriptor->_variable != LDNS_RDF_TYPE_NONE);\n\tif (index < descriptor->_maximum) {\n\t\treturn descriptor->_wireformat[index];\n\t} else {\n\t\treturn descriptor->_variable;\n\t}\n}\n\nldns_rr_type\nldns_get_rr_type_by_name(const char *name)\n{\n\tunsigned int i;\n\tconst char *desc_name;\n\tconst ldns_rr_descriptor *desc;\n\n\t/* TYPEXX representation */\n\tif (strlen(name) > 4 && strncasecmp(name, \"TYPE\", 4) == 0) {\n\t\treturn atoi(name + 4);\n\t}\n\n\t/* Normal types */\n\tfor (i = 0; i < (unsigned int) LDNS_RDATA_FIELD_DESCRIPTORS_COUNT; i++) {\n\t\tdesc = &rdata_field_descriptors[i];\n\t\tdesc_name = desc->_name;\n\t\tif(desc_name &&\n\t\t   strlen(name) == strlen(desc_name) &&\n\t\t   strncasecmp(name, desc_name, strlen(desc_name)) == 0) {\n\t\t\t/* because not all array index equals type code */\n\t\t\treturn desc->_type;\n\t\t}\n\t}\n\n\t/* special cases for query types */\n\tif (strlen(name) == 4 && strncasecmp(name, \"IXFR\", 4) == 0) {\n\t\treturn 251;\n\t} else if (strlen(name) == 4 && strncasecmp(name, \"AXFR\", 4) == 0) {\n\t\treturn 252;\n\t} else if (strlen(name) == 5 && strncasecmp(name, \"MAILB\", 5) == 0) {\n\t\treturn 253;\n\t} else if (strlen(name) == 5 && strncasecmp(name, \"MAILA\", 5) == 0) {\n\t\treturn 254;\n\t} else if (strlen(name) == 3 && strncasecmp(name, \"ANY\", 3) == 0) {\n\t\treturn 255;\n\t}\n\n\treturn 0;\n}\n\nldns_rr_class\nldns_get_rr_class_by_name(const char *name)\n{\n\tldns_lookup_table *lt;\n\n\t/* CLASSXX representation */\n\tif (strlen(name) > 5 && strncasecmp(name, \"CLASS\", 5) == 0) {\n\t\treturn atoi(name + 5);\n\t}\n\n\t/* Normal types */\n\tlt = ldns_lookup_by_name(ldns_rr_classes, name);\n\n\tif (lt) {\n\t\treturn lt->id;\n\t}\n\treturn 0;\n}\n\n\nldns_rr_type\nldns_rdf2rr_type(const ldns_rdf *rd)\n{\n        ldns_rr_type r;\n\n        if (!rd) {\n                return 0;\n        }\n\n        if (ldns_rdf_get_type(rd) != LDNS_RDF_TYPE_TYPE) {\n                return 0;\n        }\n\n        r = (ldns_rr_type) ldns_rdf2native_int16(rd);\n        return r;\n}\n\nldns_rr_type\nldns_rr_list_type(const ldns_rr_list *rr_list)\n{\n\tif (rr_list && ldns_rr_list_rr_count(rr_list) > 0) {\n\t\treturn ldns_rr_get_type(ldns_rr_list_rr(rr_list, 0));\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nldns_rdf *\nldns_rr_list_owner(const ldns_rr_list *rr_list)\n{\n\tif (rr_list && ldns_rr_list_rr_count(rr_list) > 0) {\n\t\treturn ldns_rr_owner(ldns_rr_list_rr(rr_list, 0));\n\t} else {\n\t\treturn NULL;\n\t}\n}\n"], "filenames": ["Changelog", "rr.c"], "buggy_code_start_loc": [0, 368], "buggy_code_end_loc": [0, 377], "fixing_code_start_loc": [1, 368], "fixing_code_end_loc": [5, 380], "type": "CWE-125", "message": "When ldns version 1.7.1 verifies a zone file, the ldns_rr_new_frm_str_internal function has a heap out of bounds read vulnerability. An attacker can leak information on the heap by constructing a zone file payload.", "other": {"cve": {"id": "CVE-2020-19860", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-21T14:15:07.690", "lastModified": "2022-01-27T16:36:36.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "When ldns version 1.7.1 verifies a zone file, the ldns_rr_new_frm_str_internal function has a heap out of bounds read vulnerability. An attacker can leak information on the heap by constructing a zone file payload."}, {"lang": "es", "value": "Cuando ldns versi\u00f3n 1.7.1, verifica un archivo de zona, la funci\u00f3n ldns_rr_new_frm_str_internal presenta una vulnerabilidad de lectura fuera de l\u00edmites de la pila. Un atacante puede filtrar informaci\u00f3n en la pila al construir una carga \u00fatil de archivo de zona"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nlnetlabs:ldns:1.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "861B4CD2-F963-496B-A68B-2021E8A01A3C"}]}]}], "references": [{"url": "https://github.com/NLnetLabs/ldns/commit/15d96206996bea969fbc918eb0a4a346f514b9f3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NLnetLabs/ldns/issues/50", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NLnetLabs/ldns/commit/15d96206996bea969fbc918eb0a4a346f514b9f3"}}