{"buggy_code": ["/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Benchmarks for multiple precision integer arithmetic.\n *\n * @ingroup bench\n */\n\n#include \"relic.h\"\n#include \"relic_bench.h\"\n\nstatic void memory(void) {\n\tbn_t a[BENCH];\n\n\tBENCH_FEW(\"bn_null\", bn_null(a[i]), 1);\n\n\tBENCH_FEW(\"bn_new\", bn_new(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tBENCH_FEW(\"bn_new_size\", bn_new_size(a[i], 2 * RLC_BN_DIGS), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t\tbn_clean(a[i]);\n\t}\n\tBENCH_FEW(\"bn_make\", bn_make(a[i], RLC_BN_DIGS), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t}\n\tBENCH_FEW(\"bn_clean\", bn_clean(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t}\n\tBENCH_FEW(\"bn_grow\", bn_grow(a[i], 2 * RLC_BN_DIGS), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t\tbn_grow(a[i], 2 * RLC_BN_DIGS);\n\t}\n\tBENCH_FEW(\"bn_trim\", bn_trim(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t}\n\tBENCH_FEW(\"bn_free\", bn_free(a[i]), 1);\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new_size(a[i], 2 * RLC_BN_DIGS);\n\t}\n\tBENCH_FEW(\"bn_free (size)\", bn_free(a[i]), 1);\n}\n\nstatic void util(void) {\n\tdig_t digit;\n\tchar str[RLC_CEIL(RLC_BN_BITS, 8) * 3 + 1];\n\tuint8_t bin[RLC_CEIL(RLC_BN_BITS, 8)];\n\tdig_t raw[RLC_BN_DIGS];\n\tbn_t a, b;\n\n\tbn_null(a);\n\tbn_null(b);\n\n\tbn_new(a);\n\tbn_new(b);\n\n\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\n\tBENCH_RUN(\"bn_copy\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_copy(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_abs\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_abs(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_neg\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_neg(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_sign\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sign(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_zero\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_zero(b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_is_zero\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_is_zero(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_is_even\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_is_even(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_bits\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_bits(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_get_bit\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_get_bit(a, RLC_BN_BITS / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_set_bit\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_set_bit(a, RLC_BN_BITS / 2, 1));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_ham\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_ham(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_get_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_get_dig(&digit, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_set_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_set_dig(a, 1));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_set_2b\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_set_2b(a, RLC_BN_BITS / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rand\") {\n\t\tBENCH_ADD(bn_rand(a, RLC_POS, RLC_BN_BITS));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rand_mod\") {\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_rand_mod(a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_size_str\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_size_str(a, 10));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_write_str\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_write_str(str, sizeof(str), a, 10));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_read_str\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_read_str(a, str, sizeof(str), 10));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_size_bin\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_size_bin(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_write_bin\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_write_bin(bin, bn_size_bin(a), a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_read_bin\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_read_bin(a, bin, bn_size_bin(a)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_size_raw\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_size_raw(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_write_raw\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_write_raw(raw, bn_size_raw(a), a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_read_raw\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_read_raw(a, raw, bn_size_raw(a)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_cmp_abs\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_cmp_abs(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_cmp_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_cmp_dig(a, (dig_t)0));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_cmp\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_cmp(b, a));\n\t}\n\tBENCH_END;\n\n\tbn_free(a);\n\tbn_free(b);\n}\n\nstatic void arith(void) {\n\tbn_t a, b, c, d[3], e[3];\n\tcrt_t crt;\n\tdig_t f;\n\tint len;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tcrt_null(crt);\n\n\tbn_new(a);\n\tbn_new(b);\n\tbn_new(c);\n\tfor (int j = 0; j < 3; j++) {\n\t\tbn_null(d[j]);\n\t\tbn_null(e[j]);\n\t\tbn_new(d[j]);\n\t\tbn_new(e[j]);\n\t}\n\tcrt_new(crt);\n\n\tBENCH_RUN(\"bn_add\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_add(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_add_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_add_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_sub\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sub(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_sub_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_sub_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mul\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mul_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_mul_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n#if BN_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mul_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul_basic(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MUL == COMBA || !defined(STRIP)\n\tBENCH_RUN(\"bn_mul_comba\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul_comba(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\tBENCH_RUN(\"bn_mul_karat\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul_karat(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_sqr\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr(c, a));\n\t}\n\tBENCH_END;\n\n#if BN_SQR == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_sqr_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr_basic(c, a));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_SQR == COMBA || !defined(STRIP)\n\tBENCH_RUN(\"bn_sqr_comba\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr_comba(c, a));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\tBENCH_RUN(\"bn_sqr_karat\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr_karat(c, a));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_dbl\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_dbl(c, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_hlv\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_hlv(c, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_lsh\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_lsh(c, a, RLC_BN_BITS / 2 + RLC_DIG / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rsh\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_rsh(c, a, RLC_BN_BITS / 2 + RLC_DIG / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_div(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div_rem\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_div_rem(c, d[0], a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div_dig\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tdo {\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t} while (bn_is_zero(b));\n\t\tBENCH_ADD(bn_div_dig(c, a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div_rem_dig\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tdo {\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t} while (bn_is_zero(b));\n\t\tBENCH_ADD(bn_div_rem_dig(c, &f, a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_2b\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mod_2b(c, a, RLC_BN_BITS / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tdo {\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t} while (bn_is_zero(b));\n\t\tBENCH_ADD(bn_mod_dig(&f, a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod\") {\n#if BN_MOD == PMERS\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n\t\tbn_mod_pre(d, b);\n#else\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod_pre(d[0], b);\n#endif\n\t\tBENCH_ADD(bn_mod(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n\n#if BN_MOD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_basic\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mod_basic(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == BARRT || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_pre_barrt\") {\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mod_pre_barrt(d[0], b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == BARRT || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_barrt\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_mod_pre_barrt(d[0], b);\n\t\tBENCH_ADD(bn_mod_barrt(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == MONTY || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_pre_monty\") {\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tBENCH_ADD(bn_mod_pre_monty(d[0], b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_monty_conv\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mod_monty_conv(a, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_monty\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n\n#if BN_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_monty_basic\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty_basic(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MUL == COMBA || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_monty_comba\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty_comba(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_mod_monty_back\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty_back(c, c, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == PMERS || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_pre_pmers\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n\t\tBENCH_ADD(bn_mod_pre_pmers(d[0], b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_pmers\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n\t\tbn_mod_pre_pmers(d[0], b);\n\t\tBENCH_ADD(bn_mod_pmers(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_mxp\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n#if BN_MOD != PMERS\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n#else\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n#endif\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp(c, a, b, b));\n\t}\n\tBENCH_END;\n\n#if BN_MXP == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mxp_basic\") {\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp_basic(c, a, b, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MXP == SLIDE || !defined(STRIP)\n\tBENCH_RUN(\"bn_mxp_slide\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp_slide(c, a, b, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MXP == CONST || !defined(STRIP)\n\tBENCH_RUN(\"bn_mxp_monty\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp_monty(c, a, b, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_mxp_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(d[0], RLC_POS, RLC_DIG);\n\t\tbn_get_dig(&f, d[0]);\n\t\tBENCH_ADD(bn_mxp_dig(c, a, f, b));\n\t}\n\tBENCH_END;\n\n\tbn_gen_prime(crt->p, RLC_BN_BITS / 2);\n\tbn_gen_prime(crt->q, RLC_BN_BITS / 2);\n\tbn_mul(crt->n, crt->p, crt->q);\n\tbn_mod_inv(crt->qi, crt->q, crt->p);\n\tbn_sub_dig(crt->dp, crt->p, 1);\n\tbn_sub_dig(crt->dq, crt->q, 1);\n\tBENCH_RUN(\"bn_mxp_crt\") {\n\t\tbn_rand(c, RLC_POS, RLC_BN_BITS);\n\t\tbn_mod(a, c, crt->dp);\n\t\tbn_mod(b, c, crt->dq);\n\t\tBENCH_ADD(bn_mxp_crt(c, c, a, b, crt, 0));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_srt\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_srt(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_gcd\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd(c, a, b));\n\t}\n\tBENCH_END;\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_basic(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_lehme\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_lehme(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_binar\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_binar(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_gcd_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_gcd_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_gcd_ext\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_basic(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_binar\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_binar(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_lehme\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_lehme(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_binar\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_binar(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_gcd_ext_mid\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_mid(c, c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_gcd_ext_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\tBENCH_ADD(bn_gcd_ext_dig(c, d[0], d[1], a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_lcm\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_lcm(c, a, b));\n\t}\n\tBENCH_END;\n\n\tbn_gen_prime(b, RLC_BN_BITS);\n\n\tBENCH_RUN(\"bn_smb_leg\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_smb_leg(a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_smb_jac\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tBENCH_ADD(bn_smb_jac(a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_ONE(\"bn_gen_prime\", bn_gen_prime(a, RLC_BN_BITS), 1);\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\tBENCH_ONE(\"bn_gen_prime_basic\", bn_gen_prime_basic(a, RLC_BN_BITS), 1);\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\tBENCH_ONE(\"bn_gen_prime_safep\", bn_gen_prime_safep(a, RLC_BN_BITS), 1);\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\tBENCH_ONE(\"bn_gen_prime_stron\", bn_gen_prime_stron(a, RLC_BN_BITS), 1);\n#endif\n\n\tBENCH_ONE(\"bn_is_prime\", bn_is_prime(a), 1);\n\n\tBENCH_ONE(\"bn_is_prime_basic\", bn_is_prime_basic(a), 1);\n\n\tBENCH_ONE(\"bn_is_prime_rabin\", bn_is_prime_rabin(a), 1);\n\n\tBENCH_ONE(\"bn_is_prime_solov\", bn_is_prime_solov(a), 1);\n\n\t/* It should be the case that a is prime here. */\n\tBENCH_RUN(\"bn_mod_inv\") {\n\t\tbn_rand_mod(b, a);\n\t\tBENCH_ADD(bn_mod_inv(c, b, a));\n\t}\n\tBENCH_END;\n\n\t/* It should be the case that a is prime here. */\n\tBENCH_RUN(\"bn_mod_inv_sim (2)\") {\n\t\tbn_rand_mod(d[0], a);\n\t\tbn_rand_mod(d[1], a);\n\t\tBENCH_ADD(bn_mod_inv_sim(d, d, a, 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_lag (2)\") {\n\t\tbn_rand_mod(d[0], a);\n\t\tbn_rand_mod(d[1], a);\n\t\tBENCH_ADD(bn_lag(d, d, a, 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_evl (2)\") {\n\t\tbn_rand_mod(b, a);\n\t\tbn_rand_mod(d[0], a);\n\t\tbn_rand_mod(d[1], a);\n\t\tbn_lag(d, d, a, 2);\n\t\tBENCH_ADD(bn_evl(c, d, b, a, 2));\n\t}\n\tBENCH_END;\n\n\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\n\tBENCH_ONE(\"bn_factor\", bn_factor(c, a), 1);\n\n\tBENCH_RUN(\"bn_is_factor\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_is_factor(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_win\") {\n\t\tuint8_t win[RLC_BN_BITS + 1];\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_win(win, &len, a, 4)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_slw\") {\n\t\tuint8_t win[RLC_BN_BITS + 1];\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_slw(win, &len, a, 4)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_naf\") {\n\t\tint8_t naf[RLC_BN_BITS + 1];\n\t\tint len;\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_naf(naf, &len, a, 4)));\n\t}\n\tBENCH_END;\n\n#if defined(WITH_EB) && defined(EB_KBLTZ) && (EB_MUL == LWNAF || EB_MUL == RWNAF || EB_FIX == LWNAF || EB_SIM == INTER || !defined(STRIP))\n\tif (eb_param_set_any_kbltz() == RLC_OK) {\n\t\tBENCH_RUN(\"bn_rec_tnaf\") {\n\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\tint len = RLC_BN_BITS + 1;\n\t\t\teb_curve_get_ord(b);\n\t\t\tbn_rand_mod(a, b);\n\t\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_tnaf(tnaf, &len, a, -1, RLC_FB_BITS, 4)));\n\t\t\t} else {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_tnaf(tnaf, &len, a, 1, RLC_FB_BITS, 4)));\n\t\t\t}\n\t\t}\n\t\tBENCH_END;\n\n\t\tBENCH_RUN(\"bn_rec_rtnaf\") {\n\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\teb_curve_get_ord(b);\n\t\t\tbn_rand_mod(a, b);\n\t\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_rtnaf(tnaf, &len, a, -1, RLC_FB_BITS, 4)));\n\t\t\t} else {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_rtnaf(tnaf, &len, a, 1, RLC_FB_BITS, 4)));\n\t\t\t}\n\t\t}\n\t\tBENCH_END;\n\t}\n#endif\n\n\tBENCH_RUN(\"bn_rec_reg\") {\n\t\tint8_t naf[RLC_BN_BITS + 1];\n\t\tint len = RLC_BN_BITS + 1;\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_reg(naf, &len, a, RLC_BN_BITS, 4)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_jsf\") {\n\t\tint8_t jsf[2 * (RLC_BN_BITS + 1)];\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = 2 * (RLC_BN_BITS + 1), bn_rec_jsf(jsf, &len, a, b)));\n\t}\n\tBENCH_END;\n\n#if defined(WITH_EP) && defined(EP_ENDOM) && (EP_MUL == LWNAF || EP_FIX == COMBS || EP_FIX == LWNAF || EP_SIM == INTER || !defined(STRIP))\n\tif (ep_param_set_any_endom() == RLC_OK) {\n\t\tBENCH_RUN(\"bn_rec_glv\") {\n\t\t\tep_curve_get_v1(d);\n\t\t\tep_curve_get_v2(e);\n\t\t\tep_curve_get_ord(c);\n\t\t\tbn_rand_mod(a, c);\n\t\t\tBENCH_ADD(bn_rec_glv(a, b, a, c, (const bn_t *)d, (const bn_t *)e));\n\t\t}\n\t\tBENCH_END;\n\t}\n#endif /* WITH_EP && EP_KBLTZ */\n\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tfor (int j = 0; j < 3; j++) {\n\t\tbn_free(d[j]);\n\t\tbn_free(e[j]);\n\t}\n\tcrt_free(crt);\n}\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tconf_print();\n\tutil_banner(\"Benchmarks for the BN module:\", 0);\n\tutil_banner(\"Utilities:\", 1);\n\tmemory();\n\tutil();\n\tutil_banner(\"Arithmetic:\", 1);\n\tarith();\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Benchmarks for cryptographic protocols.\n *\n * @version $Id$\n * @ingroup bench\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_bench.h\"\n\n#if defined(WITH_BN)\n\nstatic void rsa(void) {\n\trsa_t pub, prv;\n\tuint8_t in[10], new[10], h[RLC_MD_LEN], out[RLC_BN_BITS / 8 + 1];\n\tsize_t out_len, new_len;\n\n\trsa_null(pub);\n\trsa_null(prv);\n\n\trsa_new(pub);\n\trsa_new(prv);\n\n\tBENCH_ONE(\"cp_rsa_gen\", cp_rsa_gen(pub, prv, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_rsa_enc\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_rsa_enc(out, &out_len, in, sizeof(in), pub));\n\t\tcp_rsa_dec(new, &new_len, out, out_len, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_dec\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_rsa_enc(out, &out_len, in, sizeof(in), pub);\n\t\tBENCH_ADD(cp_rsa_dec(new, &new_len, out, out_len, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_sig (h = 0)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_rsa_sig(out, &out_len, in, sizeof(in), 0, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_sig (h = 1)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tmd_map(h, in, sizeof(in));\n\t\tBENCH_ADD(cp_rsa_sig(out, &out_len, h, RLC_MD_LEN, 1, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_ver (h = 0)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_rsa_sig(out, &out_len, in, sizeof(in), 0, prv);\n\t\tBENCH_ADD(cp_rsa_ver(out, out_len, in, sizeof(in), 0, pub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_ver (h = 1)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tmd_map(h, in, sizeof(in));\n\t\tcp_rsa_sig(out, &out_len, h, RLC_MD_LEN, 1, prv);\n\t\tBENCH_ADD(cp_rsa_ver(out, out_len, h, RLC_MD_LEN, 1, pub));\n\t} BENCH_END;\n\n\trsa_free(pub);\n\trsa_free(prv);\n}\n\nstatic void rabin(void) {\n\trabin_t pub, prv;\n\tuint8_t in[1000], new[1000], out[RLC_BN_BITS / 8 + 1];\n\tsize_t in_len, out_len, new_len;\n\n\trabin_null(pub);\n\trabin_null(prv);\n\n\trabin_new(pub);\n\trabin_new(prv);\n\n\tBENCH_ONE(\"cp_rabin_gen\", cp_rabin_gen(pub, prv, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_rabin_enc\") {\n\t\tin_len = bn_size_bin(pub->n) - 10;\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(in, in_len);\n\t\tBENCH_ADD(cp_rabin_enc(out, &out_len, in, in_len, pub));\n\t\tcp_rabin_dec(new, &new_len, out, out_len, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rabin_dec\") {\n\t\tin_len = bn_size_bin(pub->n) - 10;\n\t\tnew_len = in_len;\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(in, in_len);\n\t\tcp_rabin_enc(out, &out_len, in, in_len, pub);\n\t\tBENCH_ADD(cp_rabin_dec(new, &new_len, out, out_len, prv));\n\t} BENCH_END;\n\n\trabin_free(pub);\n\trabin_free(prv);\n}\n\nstatic void benaloh(void) {\n\tbdpe_t pub, prv;\n\tdig_t in, new;\n\tuint8_t out[RLC_BN_BITS / 8 + 1];\n\tsize_t out_len;\n\n\tbdpe_null(pub);\n\tbdpe_null(prv);\n\n\tbdpe_new(pub);\n\tbdpe_new(prv);\n\n\tBENCH_ONE(\"cp_bdpe_gen\", cp_bdpe_gen(pub, prv, bn_get_prime(47),\n\t\tRLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_bdpe_enc\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(out, 1);\n\t\tin = out[0] % bn_get_prime(47);\n\t\tBENCH_ADD(cp_bdpe_enc(out, &out_len, in, pub));\n\t\tcp_bdpe_dec(&new, out, out_len, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bdpe_dec\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(out, 1);\n\t\tin = out[0] % bn_get_prime(47);\n\t\tcp_bdpe_enc(out, &out_len, in, pub);\n\t\tBENCH_ADD(cp_bdpe_dec(&new, out, out_len, prv));\n\t} BENCH_END;\n\n\tbdpe_free(pub);\n\tbdpe_free(prv);\n}\n\nstatic void paillier(void) {\n\tbn_t c, m, pub;\n\tphpe_t prv;\n    shpe_t spub, sprv;\n\n\tbn_null(c);\n\tbn_null(m);\n\tbn_null(pub);\n\tphpe_null(prv);\n    shpe_null(spub);\n    shpe_null(sprv);\n\n\n\tbn_new(c);\n\tbn_new(m);\n\tbn_new(pub);\n\tphpe_new(prv);\n    shpe_new(spub);\n    shpe_new(sprv);\n\n\tBENCH_ONE(\"cp_phpe_gen\", cp_phpe_gen(pub, prv, RLC_BN_BITS / 2), 1);\n\n\tBENCH_RUN(\"cp_phpe_enc\") {\n\t\tbn_rand_mod(m, pub);\n\t\tBENCH_ADD(cp_phpe_enc(c, m, pub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_phpe_add\") {\n\t\tbn_rand_mod(m, pub);\n\t\tcp_phpe_enc(c, m, pub);\n\t\tBENCH_ADD(cp_phpe_add(c, c, c, pub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_phpe_dec\") {\n\t\tbn_rand_mod(m, pub);\n\t\tcp_phpe_enc(c, m, pub);\n\t\tBENCH_ADD(cp_phpe_dec(m, c, prv));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_shpe_gen\", cp_shpe_gen(spub, sprv, RLC_BN_BITS / 10, RLC_BN_BITS / 2), 1);\n\n\tBENCH_RUN(\"cp_shpe_enc\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tBENCH_ADD(cp_shpe_enc(c, m, spub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shpe_enc_prv\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tBENCH_ADD(cp_shpe_enc_prv(c, m, sprv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shpe_dec (1)\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tcp_shpe_enc(c, m, spub);\n\t\tBENCH_ADD(cp_shpe_dec(m, c, sprv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shpe_dec (2)\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tcp_shpe_enc_prv(c, m, sprv);\n\t\tBENCH_ADD(cp_shpe_dec(m, c, sprv));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_ghpe_gen\", cp_ghpe_gen(pub, prv->n, RLC_BN_BITS / 2), 1);\n\n\tBENCH_RUN(\"cp_ghpe_enc (1)\") {\n\t\tbn_rand_mod(m, pub);\n\t\tBENCH_ADD(cp_ghpe_enc(c, m, pub, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_ghpe_dec (1)\") {\n\t\tbn_rand_mod(m, pub);\n\t\tcp_ghpe_enc(m, c, pub, 1);\n\t\tBENCH_ADD(cp_ghpe_dec(c, m, pub, prv->n, 1));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_ghpe_gen\", cp_ghpe_gen(pub, prv->n, RLC_BN_BITS / 4), 1);\n\n\tBENCH_RUN(\"cp_ghpe_enc (2)\") {\n\t\tbn_rand(m, RLC_POS, 2 * bn_bits(pub) - 1);\n\t\tBENCH_ADD(cp_ghpe_enc(m, c, pub, 2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_ghpe_dec (2)\") {\n\t\tbn_rand(m, RLC_POS, 2 * bn_bits(pub) - 1);\n\t\tcp_ghpe_enc(m, c, pub, 2);\n\t\tBENCH_ADD(cp_ghpe_dec(c, m, pub, prv->n, 2));\n\t} BENCH_END;\n\n\tbn_free(c);\n\tbn_free(m);\n\tbn_free(pub);\n\tphpe_free(prv);\n    shpe_free(spub);\n    shpe_free(sprv);\n}\n\n#endif\n\n#if defined(WITH_EC)\n\nstatic void ecdh(void) {\n\tbn_t d;\n\tec_t p;\n\tuint8_t key[RLC_MD_LEN];\n\n\tbn_null(d);\n\tec_null(p);\n\n\tbn_new(d);\n\tec_new(p);\n\n\tBENCH_RUN(\"cp_ecdh_gen\") {\n\t\tBENCH_ADD(cp_ecdh_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdh_key\") {\n\t\tBENCH_ADD(cp_ecdh_key(key, RLC_MD_LEN, d, p));\n\t}\n\tBENCH_END;\n\n\tbn_free(d);\n\tec_free(p);\n}\n\nstatic void ecmqv(void) {\n\tbn_t d1, d2;\n\tec_t p1, p2;\n\tuint8_t key[RLC_MD_LEN];\n\n\tbn_null(d1);\n\tbn_null(d2);\n\tec_null(p1);\n\tec_null(p2);\n\n\tbn_new(d1);\n\tbn_new(d2);\n\tec_new(p1);\n\tec_new(p2);\n\n\tBENCH_RUN(\"cp_ecmqv_gen\") {\n\t\tBENCH_ADD(cp_ecmqv_gen(d1, p1));\n\t}\n\tBENCH_END;\n\n\tcp_ecmqv_gen(d2, p2);\n\n\tBENCH_RUN(\"cp_ecmqv_key\") {\n\t\tBENCH_ADD(cp_ecmqv_key(key, RLC_MD_LEN, d1, d2, p1, p1, p2));\n\t}\n\tBENCH_END;\n\n\tbn_free(d1);\n\tbn_free(d2);\n\tec_free(p1);\n\tec_free(p2);\n}\n\nstatic void ecies(void) {\n\tec_t q, r;\n\tbn_t d;\n\tuint8_t in[10], out[16 + RLC_MD_LEN];\n\tsize_t in_len, out_len;\n\n\tbn_null(d);\n\tec_null(q);\n\tec_null(r);\n\n\tec_new(q);\n\tec_new(r);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_ecies_gen\") {\n\t\tBENCH_ADD(cp_ecies_gen(d, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecies_enc\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = sizeof(out);\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_ecies_enc(r, out, &out_len, in, in_len, q));\n\t\tcp_ecies_dec(out, &out_len, r, out, out_len, d);\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecies_dec\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = sizeof(out);\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_ecies_enc(r, out, &out_len, in, in_len, q);\n\t\tBENCH_ADD(cp_ecies_dec(in, &in_len, r, out, out_len, d));\n\t}\n\tBENCH_END;\n\n\tec_free(q);\n\tec_free(r);\n\tbn_free(d);\n}\n\nstatic void ecdsa(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\tbn_t r, s, d;\n\tec_t p;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(d);\n\tec_null(p);\n\n\tbn_new(r);\n\tbn_new(s);\n\tbn_new(d);\n\tec_new(p);\n\n\tBENCH_RUN(\"cp_ecdsa_gen\") {\n\t\tBENCH_ADD(cp_ecdsa_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_sign (h = 0)\") {\n\t\tBENCH_ADD(cp_ecdsa_sig(r, s, msg, 5, 0, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_sign (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_ecdsa_sig(r, s, h, RLC_MD_LEN, 1, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_ver (h = 0)\") {\n\t\tBENCH_ADD(cp_ecdsa_ver(r, s, msg, 5, 0, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_ver (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, p));\n\t}\n\tBENCH_END;\n\n\tbn_free(r);\n\tbn_free(s);\n\tbn_free(d);\n\tec_free(p);\n}\n\nstatic void ecss(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 };\n\tbn_t r, s, d;\n\tec_t p;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(d);\n\tec_null(p);\n\n\tbn_new(r);\n\tbn_new(s);\n\tbn_new(d);\n\tec_new(p);\n\n\tBENCH_RUN(\"cp_ecss_gen\") {\n\t\tBENCH_ADD(cp_ecss_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecss_sign\") {\n\t\tBENCH_ADD(cp_ecss_sig(r, s, msg, 5, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecss_ver\") {\n\t\tBENCH_ADD(cp_ecss_ver(r, s, msg, 5, p));\n\t}\n\tBENCH_END;\n\n\tbn_free(r);\n\tbn_free(s);\n\tbn_free(d);\n\tec_free(p);\n}\n\nstatic void vbnn(void) {\n\tuint8_t ida[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tuint8_t idb[] = { 5, 6, 7, 8, 9, 0, 1, 2, 3, 4 };\n\tbn_t msk, ska, skb;\n\tec_t mpk, pka, pkb;\n\n\tuint8_t m[] = \"Thrice the brinded cat hath mew'd.\";\n\n\tec_t r;\n\tbn_t z;\n\tbn_t h;\n\n\tbn_null(z);\n\tbn_null(h);\n\tbn_null(msk);\n\tbn_null(ska);\n\tbn_null(skb);\n\tec_null(r);\n\tec_null(mpk);\n\tbn_null(pka);\n\tbn_null(pkb);\n\n\tbn_new(z);\n\tbn_new(h);\n\tbn_new(msk);\n\tbn_new(ska);\n\tbn_new(skb);\n\tec_new(r);\n\tec_new(mpk);\n\tec_new(pka);\n\tec_new(pkb);\n\n\tBENCH_RUN(\"cp_vbnn_gen\") {\n\t\tBENCH_ADD(cp_vbnn_gen(msk, mpk));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_vbnn_gen_prv\") {\n\t\tBENCH_ADD(cp_vbnn_gen_prv(ska, pka, msk, ida, sizeof(ida)));\n\t}\n\tBENCH_END;\n\n\tcp_vbnn_gen_prv(skb, pkb, msk, idb, sizeof(idb));\n\n\tBENCH_RUN(\"cp_vbnn_sig\") {\n\t\tBENCH_ADD(cp_vbnn_sig(r, z, h, ida, sizeof(ida), m, sizeof(m), ska, pka));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_vbnn_ver\") {\n\t\tBENCH_ADD(cp_vbnn_ver(r, z, h, ida, sizeof(ida), m, sizeof(m), mpk));\n\t}\n\tBENCH_END;\n\n\tbn_free(z);\n\tbn_free(h);\n\tbn_free(msk);\n\tbn_free(ska);\n\tbn_free(skb);\n\tec_free(r);\n\tec_free(mpk);\n\tec_free(pka);\n\tec_free(pkb);\n}\n\n#define MAX_KEYS\tRLC_MAX(BENCH, 16)\n#define MIN_KEYS\tRLC_MIN(BENCH, 16)\n\nstatic void ers(void) {\n\tsize_t size;\n\tec_t pp, pk[MAX_KEYS + 1];\n\tbn_t sk[MAX_KEYS + 1], td;\n\ters_t ring[MAX_KEYS + 1];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tbn_new(td);\n\tec_new(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_null(sk[i]);\n\t\tbn_new(sk[i]);\n\t\tec_null(pk[i]);\n\t\tec_new(pk[i]);\n\t\ters_null(ring[i]);\n\t\ters_new(ring[i]);\n\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t}\n\n\tcp_ers_gen(pp);\n\n\tBENCH_RUN(\"cp_ers_sig\") {\n\t\tBENCH_ADD(cp_ers_sig(td, ring[0], m, 5, sk[0], pk[0], pp));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_ers_ver\") {\n\t\tBENCH_ADD(cp_ers_ver(td, ring, 1, m, 5, pp));\n\t} BENCH_END;\n\n\tsize = 1;\n\tBENCH_FEW(\"cp_ers_ext\", cp_ers_ext(td, ring, &size, m, 5, pk[size], pp), 1);\n\n\tsize = 1;\n\tcp_ers_sig(td, ring[0], m, 5, sk[0], pk[0], pp);\n\tfor (int j = 1; j < MAX_KEYS && size < BENCH; j = j << 1) {\n\t\tfor (int k = 0; k < j && size < BENCH; k++) {\n\t\t\tcp_ers_ext(td, ring, &size, m, 5, pk[size], pp);\n\t\t}\n\t\tcp_ers_ver(td, ring, size, m, 5, pp);\n\t\tutil_print(\"(%2d exts) \", j);\n\t\tBENCH_FEW(\"cp_ers_ver\", cp_ers_ver(td, ring, size, m, 5, pp), 1);\n\t}\n\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\ters_free(ring[i])\n\t}\n}\n\nstatic void smlers(void) {\n\tsize_t size;\n\tec_t pp, pk[MAX_KEYS + 1];\n\tbn_t sk[MAX_KEYS + 1], td;\n\tsmlers_t ring[MAX_KEYS + 1];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tbn_new(td);\n\tec_new(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_null(sk[i]);\n\t\tbn_new(sk[i]);\n\t\tec_null(pk[i]);\n\t\tec_new(pk[i]);\n\t\tsmlers_null(ring[i]);\n\t\tsmlers_new(ring[i]);\n\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t}\n\n\tcp_ers_gen(pp);\n\n\tBENCH_RUN(\"cp_smlers_sig\") {\n\t\tBENCH_ADD(cp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_smlers_ver\") {\n\t\tBENCH_ADD(cp_smlers_ver(td, ring, 1, m, 5, pp));\n\t} BENCH_END;\n\n\tsize = 1;\n\tBENCH_FEW(\"cp_smlers_ext\", cp_smlers_ext(td, ring, &size, m, 5, pk[size], pp), 1);\n\n\tsize = 1;\n\tcp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp);\n\tfor (int j = 1; j < MAX_KEYS && size < BENCH; j = j << 1) {\n\t\tfor (int k = 0; k < j && size < BENCH; k++) {\n\t\t\tcp_smlers_ext(td, ring, &size, m, 5, pk[size], pp);\n\t\t}\n\t\tcp_smlers_ver(td, ring, size, m, 5, pp);\n\t\tutil_print(\"(%2d exts) \", j);\n\t\tBENCH_FEW(\"cp_smlers_ver\", cp_smlers_ver(td, ring, size, m, 5, pp), 1);\n\t}\n\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tsmlers_free(ring[i])\n\t}\n}\n\nstatic void etrs(void) {\n\tsize_t size;\n\tec_t pp, pk[MAX_KEYS + 1];\n\tbn_t sk[MAX_KEYS + 1], td[MAX_KEYS + 1], y[MAX_KEYS + 1];\n\tetrs_t ring[MAX_KEYS + 1];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tec_null(pp);\n\tec_new(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_null(td[i]);\n\t\tbn_new(td[i]);\n\t\tbn_null(y[i]);\n\t\tbn_new(y[i]);\n\t\tbn_null(sk[i]);\n\t\tbn_new(sk[i]);\n\t\tec_null(pk[i]);\n\t\tec_new(pk[i]);\n\t\tetrs_null(ring[i]);\n\t\tetrs_new(ring[i]);\n\t\tec_curve_get_ord(sk[i]);\n\t\tbn_rand_mod(td[i], sk[i]);\n\t\tbn_rand_mod(y[i], sk[i]);\n\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t}\n\n\tcp_ers_gen(pp);\n\n\tBENCH_FEW(\"cp_etrs_sig\", cp_etrs_sig(td, y, MIN_KEYS, ring[0], m, 5, sk[0], pk[0], pp), 1);\n\n\tBENCH_FEW(\"cp_etrs_ver\", cp_etrs_ver(1, td, y, MIN_KEYS, ring, 1, m, 5, pp), 1);\n\n\tsize = 1;\n\tBENCH_FEW(\"cp_etrs_ext\", (size = 1, cp_etrs_ext(td, y, MIN_KEYS, ring, &size, m, 5, pk[size], pp)), 1);\n\n\tsize = 1;\n\tcp_etrs_sig(td, y, MIN_KEYS, ring[0], m, 5, sk[0], pk[0], pp);\n\tBENCH_FEW(\"cp_etrs_uni\", cp_etrs_uni(1, td, y, MIN_KEYS, ring, &size, m, 5, sk[size], pk[size], pp), 1);\n\n\tsize = 1;\n\tcp_etrs_sig(td, y, MIN_KEYS, ring[0], m, 5, sk[0], pk[0], pp);\n\tfor (int j = 1; j < MIN_KEYS && size < MIN_KEYS; j = j << 1) {\n\t\tfor (int k = 0; k < j && size < MIN_KEYS; k++) {\n\t\t\tcp_etrs_ext(td, y, MIN_KEYS, ring, &size, m, 5, pk[size], pp);\n\t\t}\n\t\tcp_etrs_ver(1, td+size-1, y+size-1, MIN_KEYS-size+1, ring, size, m, 5, pp);\n\t\tutil_print(\"(%2d exts) \", j);\n\t\tBENCH_FEW(\"cp_etrs_ver\", cp_etrs_ver(1, td+size-1, y+size-1, MIN_KEYS-size+1, ring, size, m, 5, pp), 1);\n\t}\n\n\tec_free(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_free(td[i]);\n\t\tbn_free(y[i]);\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tetrs_free(ring[i])\n\t}\n}\n\n#endif /* WITH_EC */\n\n#if defined(WITH_PC)\n\nstatic void pdpub(void) {\n\tbn_t r1, r2;\n\tg1_t p, u1, v1;\n\tg2_t q, u2, v2, w2;\n\tgt_t e, r, g[3];\n\n\tbn_null(r1);\n\tbn_null(r2);\n\tg1_null(p);\n\tg1_null(u1);\n\tg1_null(v1);\n\tg2_null(q);\n\tg2_null(u2);\n\tg2_null(v2);\n\tg2_null(w2);\n\tgt_null(e);\n\tgt_null(r);\n\tgt_null(g[0]);\n\tgt_null(g[1]);\n\tgt_null(g[2]);\n\n\tbn_new(r1);\n\tbn_new(r2);\n\tg1_new(p);\n\tg1_new(u1);\n\tg1_new(v1);\n\tg2_new(q);\n\tg2_new(u2);\n\tg2_new(v2);\n\tg2_new(w2);\n\tgt_new(e);\n\tgt_new(r);\n\tgt_new(g[0]);\n\tgt_new(g[1]);\n\tgt_new(g[2]);\n\n\tBENCH_RUN(\"cp_pdpub_gen\") {\n\t\tBENCH_ADD(cp_pdpub_gen(r1, r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdpub_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdpub_ask(v1, w2, p, q, r1, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdpub_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdpub_ans(g, p, q, v1, v2, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdpub_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tpc_map(e, p, q);\n\t\tBENCH_ADD(cp_pdpub_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_gen\") {\n\t\tBENCH_ADD(cp_lvpub_gen(r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvpub_ask(r1, v1, w2, p, q, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvpub_ans(g, p, q, v1, v2, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tpc_map(e, p, q);\n\t\tBENCH_ADD(cp_lvpub_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tbn_free(r1);\n\tbn_free(r2);\n\tg1_free(p);\n\tg1_free(u1);\n\tg1_free(v1);\n\tg2_free(q);\n\tg2_free(u2);\n\tg2_free(v2);\n\tg2_free(w2);\n\tgt_free(e);\n\tgt_free(r);\n\tgt_free(g[0]);\n\tgt_free(g[1]);\n\tgt_free(g[2]);\n}\n\nstatic void pdprv(void) {\n\tbn_t r1, r2[3];\n\tg1_t p, u1[2], v1[3];\n\tg2_t q, u2[2], v2[4], w2[4];\n\tgt_t e[2], r, g[4];\n\n\tbn_null(r1);\n\tg1_null(p);\n\tg2_null(q);\n\tgt_null(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_null(u1[i]);\n\t\tg2_null(u2[i]);\n\t\tgt_null(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_null(v1[i]);\n\t\tbn_null(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_null(v2[i]);\n\t\tg2_null(w2[i]);\n\t\tgt_null(g[i]);\n\t}\n\n\tbn_new(r1);\n\tg1_new(p);\n\tg2_new(q);\n\tgt_new(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_new(u1[i]);\n\t\tg2_new(u2[i]);\n\t\tgt_new(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_new(v1[i]);\n\t\tbn_new(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_new(v2[i]);\n\t\tg2_new(w2[i]);\n\t\tgt_new(g[i]);\n\t}\n\n\tBENCH_RUN(\"cp_pdprv_gen\") {\n\t\tBENCH_ADD(cp_pdprv_gen(r1, r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdprv_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdprv_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdprv_ans(g, v1, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdprv_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdprv_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_gen\") {\n\t\tBENCH_ADD(cp_lvprv_gen(r1, r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvprv_ans(g, v1, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvprv_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tbn_free(r1);\n\tg1_free(p);\n\tg2_free(q);\n\tgt_free(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_free(u1[i]);\n\t\tg2_free(u2[i]);\n\t\tgt_free(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_free(v1[i]);\n\t\tbn_free(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_free(v2[i]);\n\t\tg2_free(w2[i]);\n\t\tgt_free(g[i]);\n\t}\n}\n\nstatic void sokaka(void) {\n\tsokaka_t k;\n\tbn_t s;\n\tuint8_t key1[RLC_MD_LEN];\n\tchar *id_a = \"Alice\";\n\tchar *id_b = \"Bob\";\n\n\tsokaka_null(k);\n\n\tsokaka_new(k);\n\tbn_new(s);\n\n\tBENCH_RUN(\"cp_sokaka_gen\") {\n\t\tBENCH_ADD(cp_sokaka_gen(s));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_sokaka_gen_prv\") {\n\t\tBENCH_ADD(cp_sokaka_gen_prv(k, id_b, s));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_sokaka_key (g1)\") {\n\t\tBENCH_ADD(cp_sokaka_key(key1, RLC_MD_LEN, id_b, k, id_a));\n\t}\n\tBENCH_END;\n\n\tif (pc_map_is_type3()) {\n\t\tcp_sokaka_gen_prv(k, id_a, s);\n\n\t\tBENCH_RUN(\"cp_sokaka_key (g2)\") {\n\t\t\tBENCH_ADD(cp_sokaka_key(key1, RLC_MD_LEN, id_a, k, id_b));\n\t\t}\n\t\tBENCH_END;\n\t}\n\n\tsokaka_free(k);\n\tbn_free(s);\n}\n\nstatic void ibe(void) {\n\tbn_t s;\n\tg1_t pub;\n\tg2_t prv;\n\tuint8_t in[10], out[10 + 2 * RLC_FP_BYTES + 1];\n\tchar *id = \"Alice\";\n\tsize_t in_len, out_len;\n\n\tbn_null(s);\n\tg1_null(pub);\n\tg2_null(prv);\n\n\tbn_new(s);\n\tg1_new(pub);\n\tg2_new(prv);\n\n\trand_bytes(in, sizeof(in));\n\n\tBENCH_RUN(\"cp_ibe_gen\") {\n\t\tBENCH_ADD(cp_ibe_gen(s, pub));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ibe_gen_prv\") {\n\t\tBENCH_ADD(cp_ibe_gen_prv(prv, id, s));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ibe_enc\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = in_len + 2 * RLC_FP_BYTES + 1;\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_ibe_enc(out, &out_len, in, in_len, id, pub));\n\t\tcp_ibe_dec(out, &out_len, out, out_len, prv);\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ibe_dec\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = in_len + 2 * RLC_FP_BYTES + 1;\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_ibe_enc(out, &out_len, in, in_len, id, pub);\n\t\tBENCH_ADD(cp_ibe_dec(out, &out_len, out, out_len, prv));\n\t}\n\tBENCH_END;\n\n\tbn_free(s);\n\tg1_free(pub);\n\tg2_free(prv);\n}\n\nstatic void bgn(void) {\n\tg1_t c[2];\n\tg2_t d[2];\n\tgt_t e[4];\n\tbgn_t pub, prv;\n\tdig_t in;\n\n\tg1_null(c[0]);\n\tg1_null(c[1]);\n\tg2_null(d[0]);\n\tg2_null(d[1]);\n\tbgn_null(pub);\n\tbgn_null(prv);\n\n\tg1_new(c[0]);\n\tg1_new(c[1]);\n\tg2_new(d[0]);\n\tg2_new(d[1]);\n\tbgn_new(pub);\n\tbgn_new(prv);\n\tfor (int i = 0; i < 4; i++) {\n\t\tgt_null(e[i]);\n\t\tgt_new(e[i]);\n\t}\n\n\tBENCH_RUN(\"cp_bgn_gen\") {\n\t\tBENCH_ADD(cp_bgn_gen(pub, prv));\n\t} BENCH_END;\n\n\tin = 10;\n\n\tBENCH_RUN(\"cp_bgn_enc1\") {\n\t\tBENCH_ADD(cp_bgn_enc1(c, in, pub));\n\t\tcp_bgn_dec1(&in, c, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_dec1 (10)\") {\n\t\tcp_bgn_enc1(c, in, pub);\n\t\tBENCH_ADD(cp_bgn_dec1(&in, c, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_enc2\") {\n\t\tBENCH_ADD(cp_bgn_enc2(d, in, pub));\n\t\tcp_bgn_dec2(&in, d, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_dec2 (10)\") {\n\t\tcp_bgn_enc2(d, in, pub);\n\t\tBENCH_ADD(cp_bgn_dec2(&in, d, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_mul\") {\n\t\tBENCH_ADD(cp_bgn_mul(e, c, d));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_dec (100)\") {\n\t\tBENCH_ADD(cp_bgn_dec(&in, e, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_add\") {\n\t\tBENCH_ADD(cp_bgn_add(e, e, e));\n\t} BENCH_END;\n\n\tg1_free(c[0]);\n\tg1_free(c[1]);\n\tg2_free(d[0]);\n\tg2_free(d[1]);\n\tbgn_free(pub);\n\tbgn_free(prv);\n\tfor (int i = 0; i < 4; i++) {\n\t\tgt_free(e[i]);\n\t}\n}\n\nstatic void bls(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 };\n\tg1_t s;\n\tg2_t p;\n\tbn_t d;\n\n\tg1_null(s);\n\tg2_null(p);\n\tbn_null(d);\n\n\tg1_new(s);\n\tg2_new(p);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_bls_gen\") {\n\t\tBENCH_ADD(cp_bls_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bls_sign\") {\n\t\tBENCH_ADD(cp_bls_sig(s, msg, 5, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bls_ver\") {\n\t\tBENCH_ADD(cp_bls_ver(s, msg, 5, p));\n\t}\n\tBENCH_END;\n\n\tg1_free(s);\n\tbn_free(d);\n\tg2_free(p);\n}\n\nstatic void bbs(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\tg1_t s;\n\tg2_t p;\n\tgt_t z;\n\tbn_t d;\n\n\tg1_null(s);\n\tg2_null(p);\n\tgt_null(z);\n\tbn_null(d);\n\n\tg1_new(s);\n\tg2_new(p);\n\tgt_new(z);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_bbs_gen\") {\n\t\tBENCH_ADD(cp_bbs_gen(d, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_sign (h = 0)\") {\n\t\tBENCH_ADD(cp_bbs_sig(s, msg, 5, 0, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_sign (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_bbs_sig(s, h, RLC_MD_LEN, 1, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_ver (h = 0)\") {\n\t\tBENCH_ADD(cp_bbs_ver(s, msg, 5, 0, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_ver (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_bbs_ver(s, h, RLC_MD_LEN, 1, p, z));\n\t}\n\tBENCH_END;\n\n\tg1_free(s);\n\tbn_free(d);\n\tg2_free(p);\n}\n\nstatic int cls(void) {\n\tint i, code = RLC_ERR;\n\tbn_t r, t, u, v, _v[4];\n\tg1_t a, A, b, B, c, _A[4], _B[4];\n\tg2_t x, y, z, _z[4];\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tconst uint8_t *ms[5] = {m, m, m, m, m};\n\tconst size_t ls[5] = {sizeof(m), sizeof(m), sizeof(m), sizeof(m), sizeof(m)};\n\n\tbn_null(r);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(A);\n\tg1_null(b);\n\tg1_null(B);\n\tg1_null(c);\n\tg2_null(x);\n\tg2_null(y);\n\tg2_null(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_null(_v[i]);\n\t\tg1_null(_A[i]);\n\t\tg1_null(_B[i]);\n\t\tg2_null(_z[i]);\n\t}\n\n\tbn_new(r);\n\tbn_new(t);\n\tbn_new(u);\n\tbn_new(v);\n\tg1_new(a);\n\tg1_new(A);\n\tg1_new(b);\n\tg1_new(B);\n\tg1_new(c);\n\tg2_new(x);\n\tg2_new(y);\n\tg2_new(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_new(_v[i]);\n\t\tg1_new(_A[i]);\n\t\tg1_new(_B[i]);\n\t\tg2_new(_z[i]);\n\t}\n\n\tBENCH_RUN(\"cp_cls_gen\") {\n\t\tBENCH_ADD(cp_cls_gen(u, v, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cls_sig\") {\n\t\tBENCH_ADD(cp_cls_sig(a, b, c, m, sizeof(m), u, v));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cls_ver\") {\n\t\tBENCH_ADD(cp_cls_ver(a, b, c, m, sizeof(m), x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cli_gen\") {\n\t\tBENCH_ADD(cp_cli_gen(t, u, v, x, y, z));\n\t} BENCH_END;\n\n\tbn_rand(r, RLC_POS, 2 * pc_param_level());\n\tBENCH_RUN(\"cp_cli_sig\") {\n\t\tBENCH_ADD(cp_cli_sig(a, A, b, B, c, m, sizeof(m), r, t, u, v));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cli_ver\") {\n\t\tBENCH_ADD(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_clb_gen (5)\") {\n\t\tBENCH_ADD(cp_clb_gen(t, u, _v, x, y, _z, 5));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_clb_sig (5)\") {\n\t\tBENCH_ADD(cp_clb_sig(a, _A, b, _B, c, ms, ls, t, u, _v, 5));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_clb_ver (5)\") {\n\t\tBENCH_ADD(cp_clb_ver(a, _A, b, _B, c, ms, ls, x, y, _z, 5));\n\t} BENCH_END;\n\n\tbn_free(r);\n\tbn_free(t);\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(A);\n\tg1_free(b);\n\tg1_free(B);\n\tg1_free(c);\n\tg2_free(x);\n\tg2_free(y);\n\tg2_free(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_free(_v[i]);\n\t\tg1_free(_A[i]);\n\t\tg1_free(_B[i]);\n\t\tg2_free(_z[i]);\n\t}\n\treturn code;\n}\n\nstatic void pss(void) {\n\tbn_t ms[10], n, u, v, _v[10];\n\tg1_t a, b;\n\tg2_t g, x, y, _y[10];\n\n\tbn_null(n);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(b);\n\tg2_null(g);\n\tg2_null(x);\n\tg2_null(y);\n\tbn_new(n);\n\tbn_new(u);\n\tbn_new(v);\n\tg1_new(a);\n\tg1_new(b);\n\tg2_new(g);\n\tg2_new(x);\n\tg2_new(y);\n\n\tg1_get_ord(n);\n\tfor (int i = 0; i < 10; i++) {\n\t\tbn_null(ms[i]);\n\t\tbn_null(_v[i]);\n\t\tg2_null(_y[i]);\n\t\tbn_new(ms[i]);\n\t\tbn_rand_mod(ms[i], n);\n\t\tbn_new(_v[i]);\n\t\tg2_new(_y[i]);\n\t}\n\n\tBENCH_RUN(\"cp_pss_gen\") {\n\t\tBENCH_ADD(cp_pss_gen(u, v, g, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pss_sig\") {\n\t\tBENCH_ADD(cp_pss_sig(a, b, ms[0], u, v));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pss_ver\") {\n\t\tBENCH_ADD(cp_pss_ver(a, b, ms[0], g, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_psb_gen (10)\") {\n\t\tBENCH_ADD(cp_psb_gen(u, _v, g, x, _y, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_psb_sig (10)\") {\n\t\tBENCH_ADD(cp_psb_sig(a, b, ms, u, _v, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_psb_ver (10)\") {\n\t\tBENCH_ADD(cp_psb_ver(a, b, ms, g, x, _y, 10));\n\t} BENCH_END;\n\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(b);\n\tg2_free(g);\n\tg2_free(x);\n\tg2_free(y);\n\tfor (int i = 0; i < 10; i++) {\n\t\tbn_free(ms[i]);\n\t\tbn_free(_v[i]);\n\t\tg1_free(_y[i]);\n\t}\n}\n\n#ifdef WITH_MPC\n\nstatic void mpss(void) {\n\tbn_t m[2], n, u[2], v[2], ms[10][2], _v[10][2];\n\tg1_t g, s[2];\n\tg2_t h, x[2], y[2], _y[10][2];\n\tgt_t r[2];\n\tmt_t tri[3][2];\n\tpt_t t[2];\n\n\tbn_null(n);\n\tg1_null(g);\n\tg2_null(h);\n\n\tbn_new(n);\n\tg1_new(g);\n\tg2_new(h);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_null(m[i]);\n\t\tbn_null(u[i]);\n\t\tbn_null(v[i]);\n\t\tg1_null(s[i]);\n\t\tg2_null(x[i]);\n\t\tg2_null(y[i]);\n\t\tgt_null(r[i]);\n\t\tmt_null(tri[0][i]);\n\t\tmt_null(tri[1][i]);\n\t\tmt_null(tri[2][i]);\n\t\tpt_null(t[i]);\n\t\tbn_new(m[i]);\n\t\tbn_new(u[i]);\n\t\tbn_new(v[i]);\n\t\tg1_new(s[i]);\n\t\tg2_new(x[i]);\n\t\tg2_new(y[i]);\n\t\tgt_new(r[i]);\n\t\tmt_new(tri[0][i]);\n\t\tmt_new(tri[1][i]);\n\t\tmt_new(tri[2][i]);\n\t\tpt_new(t[i]);\n\n\t\tg1_get_ord(n);\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tbn_null(ms[j][i]);\n\t\t\tbn_null(_v[j][i]);\n\t\t\tg2_null(_y[j][i]);\n\t\t\tbn_new(ms[j][i]);\n\t\t\tbn_rand_mod(ms[j][i], n);\n\t\t\tbn_new(_v[j][i]);\n\t\t\tg2_new(_y[j][i]);\n\t\t}\n\t}\n\n\tpc_map_tri(t);\n\tmpc_mt_gen(tri[0], n);\n\tmpc_mt_gen(tri[1], n);\n\tmpc_mt_gen(tri[2], n);\n\n\tbn_rand_mod(m[0], n);\n\tbn_rand_mod(m[1], n);\n\tbn_sub(m[0], m[1], m[0]);\n\tif (bn_sign(m[0]) == RLC_NEG) {\n\t\tbn_add(m[0], m[0], n);\n\t}\n\tgt_exp_gen(r[0], tri[2][0]->c);\n\tgt_exp_gen(r[1], tri[2][1]->c);\n\ttri[2][0]->bt = &r[0];\n\ttri[2][1]->bt = &r[1];\n\ttri[2][0]->ct = &r[0];\n\ttri[2][1]->ct = &r[1];\n\n\tBENCH_RUN(\"cp_mpss_gen\") {\n\t\tBENCH_ADD(cp_mpss_gen(u, v, h, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpss_bct\") {\n\t\tBENCH_ADD(cp_mpss_bct(x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpss_sig\") {\n\t\tBENCH_ADD(cp_mpss_sig(g, s, m, u, v, tri[0], tri[1]));\n\t} BENCH_DIV(2);\n\n\tBENCH_RUN(\"cp_mpss_ver\") {\n\t\tBENCH_ADD(cp_mpss_ver(r[0], g, s, m, h, x[0], y[0], tri[2], t));\n\t} BENCH_DIV(2);\n\n\tg1_get_ord(n);\n\tpc_map_tri(t);\n\tmpc_mt_gen(tri[0], n);\n\tmpc_mt_gen(tri[1], n);\n\tmpc_mt_gen(tri[2], n);\n\n\tBENCH_RUN(\"cp_mpsb_gen (10)\") {\n\t\tBENCH_ADD(cp_mpsb_gen(u, _v, h, x, _y, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpsb_bct (10)\") {\n\t\tBENCH_ADD(cp_mpsb_bct(x, _y, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpsb_sig (10)\") {\n\t\tBENCH_ADD(cp_mpsb_sig(g, s, ms, u, _v, tri[0], tri[1], 10));\n\t} BENCH_DIV(2);\n\n\tBENCH_RUN(\"cp_mpsb_ver (10)\") {\n\t\tBENCH_ADD(cp_mpsb_ver(r[1], g, s, ms, h, x[0], _y, NULL, tri[2], t, 10));\n\t} BENCH_DIV(2);\n\n\tBENCH_RUN(\"cp_mpsb_ver (10,sk)\") {\n\t\tBENCH_ADD(cp_mpsb_ver(r[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 10));\n\t} BENCH_DIV(2);\n\n\tbn_free(n);\n\tg1_free(g);\n\tg2_free(h);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_free(m[i]);\n\t\tbn_free(u[i]);\n\t\tbn_free(v[i]);\n\t\tg1_free(s[i]);\n\t\tg2_free(x[i]);\n\t\tg2_free(y[i]);\n\t\tgt_null(r[i]);\n\t\tmt_free(tri[0][i]);\n\t\tmt_free(tri[1][i]);\n\t\tmt_free(tri[2][i]);\n\t\tpt_free(t[i]);\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tbn_free(ms[j][i]);\n\t\t\tbn_free(_v[j][i]);\n\t\t\tg2_free(_y[j][i]);\n\t\t}\n\t}\n}\n\n#endif\n\nstatic void zss(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\tg1_t p;\n\tg2_t s;\n\tgt_t z;\n\tbn_t d;\n\n\tbn_null(d);\n\tg1_null(p);\n\tg2_null(s);\n\tgt_null(z);\n\n\tg1_new(p);\n\tg2_new(s);\n\tgt_new(z);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_zss_gen\") {\n\t\tBENCH_ADD(cp_zss_gen(d, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_sig (h = 0)\") {\n\t\tBENCH_ADD(cp_zss_sig(s, msg, 5, 0, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_sig (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_zss_sig(s, h, RLC_MD_LEN, 1, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_ver (h = 0)\") {\n\t\tBENCH_ADD(cp_zss_ver(s, msg, 5, 0, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_ver (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_zss_ver(s, h, RLC_MD_LEN, 1, p, z));\n\t}\n\tBENCH_END;\n\n\tbn_free(d);\n\tg1_free(p);\n\tg2_free(s);\n}\n\n/* Size of the dataset for benchmarking. */\n#define S\t10\t\t\t/* Number of signers. */\n#define L\t16\t\t\t/* Number of labels, must be <= RLC_TERMS. */\n#define K\tRLC_MD_LEN\t/* Size of PRF key. */\n//#define BENCH_LHS\t\t/* Uncomment for fine-grained benchmarking. */\n\nstatic void lhs(void) {\n\tuint8_t k[S][K];\n\tbn_t m, n, msg[L], sk[S], d[S], x[S][L];\n\tg1_t _r, h, as[S], cs[S], sig[S];\n\tg1_t a[S][L], c[S][L], r[S][L];\n\tg2_t _s, s[S][L], pk[S], y[S], z[S];\n\tgt_t *hs[S], vk;\n\tconst char *data = \"id\";\n\tconst char *id[S] = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"};\n\tdig_t ft[S], *f[S];\n\tsize_t flen[S];\n\tint label[L];\n\n\tbn_null(m);\n\tbn_null(n);\n\tg1_null(h);\n\tg1_null(_r);\n\tg2_null(_s);\n\tgt_null(vk);\n\n\tbn_new(m);\n\tbn_new(n);\n\tg1_new(h);\n\tg1_new(_r);\n\tg2_new(_s);\n\tgt_new(vk);\n\n\tpc_get_ord(n);\n\tfor (int i = 0; i < L; i++) {\n\t\tbn_null(msg[i]);\n\t\tbn_new(msg[i]);\n\t\tbn_rand_mod(msg[i], n);\n\t}\n\tfor (int i = 0; i < S; i++) {\n\t\ths[i] = RLC_ALLOCA(gt_t, RLC_TERMS);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\tgt_null(hs[i][j]);\n\t\t\tgt_new(hs[i][j]);\n\t\t}\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tbn_null(x[i][j]);\n\t\t\tg1_null(a[i][j]);\n\t\t\tg1_null(c[i][j]);\n\t\t\tg1_null(r[i][j]);\n\t\t\tg2_null(s[i][j]);\n\t\t\tbn_new(x[i][j]);\n\t\t\tg1_new(a[i][j]);\n\t\t\tg1_new(c[i][j]);\n\t\t\tg1_new(r[i][j]);\n\t\t\tg2_new(s[i][j]);\n\t\t}\n\t\tbn_null(sk[i]);\n\t\tbn_null(d[i]);\n\t\tg1_null(sig[i]);\n\t\tg1_null(as[i]);\n\t\tg1_null(cs[i]);\n\t\tg2_null(y[i]);\n\t\tg2_null(z[i]);\n\t\tg2_null(pk[i]);\n\n\t\tbn_new(sk[i]);\n\t\tbn_new(d[i]);\n\t\tg1_new(sig[i]);\n\t\tg1_new(as[i]);\n\t\tg1_new(cs[i]);\n\t\tg2_new(y[i]);\n\t\tg2_new(z[i]);\n\t\tg2_new(pk[i]);\n\t}\n\n\t/* Define linear function. */\n\tfor (int i = 0; i < S; i++) {\n\t\tf[i] = RLC_ALLOCA(dig_t, RLC_TERMS);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\tuint32_t t;\n\t\t\trand_bytes((uint8_t *)&t, sizeof(uint32_t));\n\t\t\tf[i][j] = t;\n\t\t}\n\t\tflen[i] = L;\n\t}\n\n\t/* Initialize scheme for messages of single components. */\n\tcp_cmlhs_init(h);\n\n\tBENCH_ONE(\"cp_cmlhs_gen (ecdsa)\",\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tcp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], 0);\n\t\t},\n\tS);\n\n\tBENCH_FEW(\"cp_cmlhs_sig (ecdsa)\",\n\t\t/* Compute all signatures. */\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\tlabel[l] = l;\n\t\t\t\tbn_mod(msg[l], msg[l], n);\n\t\t\t\tcp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l], s[j][l],\n\t\t\t\t\tmsg[l], data, label[l], x[j][l], h, k[j], K, d[j], sk[j], 0);\n\t\t\t}\n\t\t},\n\tS * L);\n\n\tBENCH_RUN(\"cp_cmlhs_fun\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], L));\n\t\t}\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_evl\") {\n\t\tcp_cmlhs_evl(_r, _s, r[0], s[0], f[0], L);\n\t\tfor (int j = 1; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], L));\n\t\t\tg1_add(_r, _r, r[0][0]);\n\t\t\tg2_add(_s, _s, s[0][0]);\n\t\t}\n\t\tg1_norm(_r, _r);\n\t\tg2_norm(_s, _s);\n\t} BENCH_DIV(S);\n\n\tbn_zero(m);\n\tfor (int j = 0; j < L; j++) {\n\t\tdig_t sum = 0;\n\t\tfor (int l = 0; l < S; l++) {\n\t\t\tsum += f[l][j];\n\t\t}\n\t\tbn_mul_dig(msg[j], msg[j], sum);\n\t\tbn_add(m, m, msg[j]);\n\t\tbn_mod(m, m, n);\n\t}\n\n\tBENCH_RUN(\"cp_cmlhs_ver (ecdsa)\") {\n\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, 0));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, (const gt_t **)hs,\n\t\t\t(const dig_t **)f, flen, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_onv (ecdsa)\") {\n\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\tpk, S, 0));\n\t} BENCH_DIV(S);\n\n\tBENCH_ONE(\"cp_cmlhs_gen (bls)\",\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tcp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], 1);\n\t\t},\n\tS);\n\n\tBENCH_FEW(\"cp_cmlhs_sig (bls)\",\n\t\t/* Compute all signatures. */\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\tlabel[l] = l;\n\t\t\t\tbn_mod(msg[l], msg[l], n);\n\t\t\t\tcp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l], s[j][l],\n\t\t\t\t\tmsg[l], data, label[l], x[j][l], h, k[j], K, d[j], sk[j], 1);\n\t\t\t}\n\t\t},\n\tS * L);\n\n\tBENCH_RUN(\"cp_cmlhs_fun\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], L));\n\t\t}\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_evl\") {\n\t\tcp_cmlhs_evl(_r, _s, r[0], s[0], f[0], L);\n\t\tfor (int j = 1; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], L));\n\t\t\tg1_add(_r, _r, r[0][0]);\n\t\t\tg2_add(_s, _s, s[0][0]);\n\t\t}\n\t\tg1_norm(_r, _r);\n\t\tg2_norm(_s, _s);\n\t} BENCH_DIV(S);\n\n\tbn_zero(m);\n\tfor (int j = 0; j < L; j++) {\n\t\tdig_t sum = 0;\n\t\tfor (int l = 0; l < S; l++) {\n\t\t\tsum += f[l][j];\n\t\t}\n\t\tbn_mul_dig(msg[j], msg[j], sum);\n\t\tbn_add(m, m, msg[j]);\n\t\tbn_mod(m, m, n);\n\t}\n\n\tBENCH_RUN(\"cp_cmlhs_ver (bls)\") {\n\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, 1));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, (const gt_t **)hs,\n\t\t\t(const dig_t **)f, flen, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_onv (bls)\") {\n\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\tpk, S, 1));\n\t} BENCH_DIV(S);\n\n#ifdef BENCH_LHS\n\tfor (int t = 1; t <= S; t++) {\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_ver\") {\n\t\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t\ths, f, flen, y, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, hs, f, flen, y, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_onv\") {\n\t\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\t\tpk, t));\n\t\t} BENCH_END;\n\t}\n\n\tfor (int t = 1; t <= L; t++) {\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tfor (int u = 0; u < S; u++) {\n\t\t\tflen[u] = t;\n\t\t}\n\t\tBENCH_RUN(\"cp_cmlhs_ver\") {\n\t\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t\ths,\tf, flen, y, pk, S));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, hs, f, flen, y, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_onv\") {\n\t\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\t\tpk, t));\n\t\t} BENCH_END;\n\t}\n#endif  /* BENCH_LHS */\n\n\tchar *ls[L];\n\n\tBENCH_RUN(\"cp_mklhs_gen\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_mklhs_gen(sk[j], pk[j]));\n\t\t}\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_sig\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\tls[l] = \"l\";\n\t\t\t\tbn_mod(msg[l], msg[l], n);\n\t\t\t\tBENCH_ADD(cp_mklhs_sig(a[j][l], msg[l], data,\n\t\t\t\t\tid[j], ls[l], sk[j]));\n\t\t\t}\n\t\t}\n\t} BENCH_DIV(S * L);\n\n\tBENCH_RUN(\"cp_mklhs_fun\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tbn_zero(d[j]);\n\t\t\tBENCH_ADD(cp_mklhs_fun(d[j], msg, f[j], L));\n\t\t}\n\t}\n\tBENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_evl\") {\n\t\tg1_set_infty(_r);\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_mklhs_evl(r[0][j], a[j], f[j], L));\n\t\t\tg1_add(_r, _r, r[0][j]);\n\t\t}\n\t\tg1_norm(_r, _r);\n\t}\n\tBENCH_DIV(S);\n\n\tbn_zero(m);\n\tfor (int j = 0; j < L; j++) {\n\t\tdig_t sum = 0;\n\t\tfor (int l = 0; l < S; l++) {\n\t\t\tsum += f[l][j];\n\t\t}\n\t\tbn_mul_dig(msg[j], msg[j], sum);\n\t\tbn_add(m, m, msg[j]);\n\t\tbn_mod(m, m, n);\n\t}\n\n\tBENCH_RUN(\"cp_mklhs_ver\") {\n\t\tBENCH_ADD(cp_mklhs_ver(_r, m, d, data, id, (const char **)ls,\n\t\t\t(const dig_t **)f, flen, pk, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_off\") {\n\t\tBENCH_ADD(cp_mklhs_off(cs, ft, id, (const char **)ls, (const dig_t **)f,\n\t\t\tflen, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_onv\") {\n\t\tBENCH_ADD(cp_mklhs_onv(_r, m, d, data, id, cs, ft, pk, S));\n\t} BENCH_DIV(S);\n\n#ifdef BENCH_LHS\n\tfor (int t = 1; t <= S; t++) {\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_ver\") {\n\t\t\tBENCH_ADD(cp_mklhs_ver(_r, m, d, data, id, ls, f, flen, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_off\") {\n\t\t\tBENCH_ADD(cp_mklhs_off(cs, ft, id, ls, f, flen, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_onv\") {\n\t\t\tBENCH_ADD(cp_mklhs_onv(_r, m, d, data, id, cs, ft, pk, t));\n\t\t} BENCH_END;\n\t}\n\n\tfor (int t = 1; t <= L; t++) {\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tfor (int u = 0; u < S; u++) {\n\t\t\tflen[u] = t;\n\t\t}\n\t\tBENCH_RUN(\"cp_mklhs_ver\") {\n\t\t\tBENCH_ADD(cp_mklhs_ver(_r, m, d, data, id, ls, f, flen, pk, S));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_off\") {\n\t\t\tBENCH_ADD(cp_mklhs_off(cs, ft, id, ls, f, flen, S));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_onv\") {\n\t\t\tBENCH_ADD(cp_mklhs_onv(_r, m, d, data, id, cs, ft, pk, S));\n\t\t} BENCH_END;\n\t}\n#endif /* BENCH_LHS */\n\n\tbn_free(n);\n\tbn_free(m);\n\tg1_free(h);\n\tg1_free(_r);\n\tg2_free(_s);\n\tgt_free(vk);\n\n\tfor (int i = 0; i < L; i++) {\n\t\tbn_free(msg[i]);\n\t}\n\tfor (int i = 0; i < S; i++) {\n\t\tRLC_FREE(f[i]);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\tgt_free(hs[i][j]);\n\t\t}\n\t\tRLC_FREE(hs[i]);\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tbn_free(x[i][j]);\n\t\t\tg1_free(a[i][j]);\n\t\t\tg1_free(c[i][j]);\n\t\t\tg1_free(r[i][j]);\n\t\t\tg2_free(s[i][j]);\n\t\t}\n\t\tbn_free(sk[i]);\n\t\tbn_free(d[i]);\n\t\tg1_free(sig[i]);\n\t\tg1_free(as[i]);\n\t\tg1_free(cs[i]);\n\t\tg2_free(y[i]);\n\t\tg2_free(z[i]);\n\t\tg2_free(pk[i]);\n\t}\n}\n\n#define M\t256\t\t\t/* Number of server messages (larger). */\n#define N\t8\t\t\t/* Number of client messages. */\n\nstatic void psi(void) {\n\tbn_t g, n, q, r, p[M], x[M], v[N], w[N], y[N], z[M];\n\tg1_t u[M], ss;\n\tg2_t d[M + 1], s[M + 1];\n\tgt_t t[M];\n\tcrt_t crt;\n\tsize_t len;\n\n\tbn_new(g);\n\tbn_new(n);\n\tbn_new(q);\n\tbn_new(r);\n\tg1_new(ss);\n\tfor (int i = 0; i < M; i++) {\n\t\tbn_null(p[i]);\n\t\tbn_null(x[i]);\n\t\tbn_null(z[i]);\n\t\tg2_null(d[i]);\n\t\tg2_null(s[i]);\n\t\tbn_new(p[i]);\n\t\tbn_new(x[i]);\n\t\tbn_new(z[i]);\n\t\tg2_new(d[i]);\n\t\tg2_new(s[i]);\n\t}\n\tg2_null(d[M]);\n\tg2_new(d[M]);\n\tg2_null(s[M]);\n\tg2_new(s[M]);\n\tfor (int i = 0; i < N; i++) {\n\t\tbn_null(v[i]);\n\t\tbn_null(w[i]);\n\t\tbn_null(y[i]);\n\t\tg1_null(u[i]);\n\t\tgt_null(t[i]);\n\t\tbn_new(v[i]);\n\t\tbn_new(w[i]);\n\t\tbn_new(y[i]);\n\t\tg1_new(u[i]);\n\t\tgt_new(t[i]);\n\t}\n\tcrt_new(crt);\n\n\tpc_get_ord(q);\n\tfor (int j = 0; j < M; j++) {\n\t\tbn_rand_mod(x[j], q);\n\t}\n\tfor (int j = 0; j < N; j++) {\n\t\tbn_rand_mod(y[j], q);\n\t}\n\n\tBENCH_ONE(\"cp_rsapsi_gen\", cp_rsapsi_gen(g, n, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_rsapsi_ask (M)\") {\n\t\tBENCH_ADD(cp_rsapsi_ask(q, r, p, g, n, x, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsapsi_ans (N)\") {\n\t\tBENCH_ADD(cp_rsapsi_ans(v, w, q, g, n, y, N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsapsi_int\") {\n\t\tBENCH_ADD(cp_rsapsi_int(z, &len, r, p, n, x, M, v, w, N));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_shipsi_gen\", cp_shipsi_gen(g, crt, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_shipsi_ask (M)\") {\n\t\tBENCH_ADD(cp_shipsi_ask(q, r, p, g, crt->n, x, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shipsi_ans (N)\") {\n\t\tBENCH_ADD(cp_shipsi_ans(v, w[0], q, g, crt, y, N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shipsi_int\") {\n\t\tBENCH_ADD(cp_shipsi_int(z, &len, r, p, crt->n, x, M, v, w[0], N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_gen (M)\") {\n\t\tBENCH_ADD(cp_pbpsi_gen(q, ss, s, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_ask (M)\") {\n\t\tBENCH_ADD(cp_pbpsi_ask(d, r, x, s, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_ans (N)\") {\n\t\tBENCH_ADD(cp_pbpsi_ans(t, u, ss, d[0], y, N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_int\") {\n\t\tBENCH_ADD(cp_pbpsi_int(z, &len, d, x, M, t, u, N));\n\t} BENCH_END;\n\n    bn_free(q);\n\tbn_free(r);\n\tg1_free(ss);\n\tfor (int i = 0; i < M; i++) {\n\t\tbn_free(x[i]);\n\t\tbn_free(z[i]);\n\t\tg2_free(d[i]);\n\t\tg2_free(s[i]);\n\t}\n\tg2_free(d[M]);\n\tg2_free(s[M]);\n\tfor (int i = 0; i < N; i++) {\n\t\tbn_free(y[i]);\n\t\tg1_free(u[i]);\n\t\tgt_free(t[i]);\n\t}\n}\n\n#endif /* WITH_PC */\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tconf_print();\n\n\tutil_banner(\"Benchmarks for the CP module:\", 0);\n\n#if defined(WITH_BN)\n\tutil_banner(\"Protocols based on integer factorization:\\n\", 0);\n\trsa();\n\trabin();\n\tpaillier();\n\tbenaloh();\n#endif\n\n#if defined(WITH_EC)\n\tif (ec_param_set_any() == RLC_OK) {\n\t\tutil_banner(\"Protocols based on elliptic curves:\\n\", 0);\n\t\tecdh();\n\t\tecmqv();\n\t\tecies();\n\t\tecdsa();\n\t\tecss();\n\t\tvbnn();\n\t\ters();\n\t\tsmlers();\n\t\tetrs();\n\t}\n#endif\n\n#if defined(WITH_PC)\n\tif (pc_param_set_any() == RLC_OK) {\n\t\tutil_banner(\"Protocols based on pairings:\\n\", 0);\n\t\tpdpub();\n\t\tpdprv();\n\t\tsokaka();\n\t\tibe();\n\t\tbgn();\n\t\tbls();\n\t\tbbs();\n\t\tcls();\n\t\tpss();\n#if defined(WITH_MPC)\n\t\tmpss();\n#endif\n\t\tzss();\n\t\tlhs();\n\n\t\tutil_banner(\"Protocols based on accumulators:\\n\", 0);\n\t\tpsi();\n\t}\n#endif\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Benchmarks for elliptic curves defined over extensions of prime fields.\n *\n * @ingroup bench\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_bench.h\"\n\nstatic void memory2(void) {\n\tep2_t a[BENCH];\n\n\tBENCH_FEW(\"ep2_null\", ep4_null(a[i]), 1);\n\n\tBENCH_FEW(\"ep2_new\", ep4_new(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep2_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep2_new(a[i]);\n\t}\n\tBENCH_FEW(\"ep2_free\", ep4_free(a[i]), 1);\n\n\t(void)a;\n}\n\nstatic void util2(void) {\n\tep2_t p, q, t[2];\n\tuint8_t bin[4 * RLC_FP_BYTES + 1];\n\tint l;\n\n\tep2_null(p);\n\tep2_null(q);\n\tep2_null(t[0]);\n\tep2_null(t[1]);\n\n\tep2_new(p);\n\tep2_new(q);\n\tep2_new(t[0]);\n\tep2_new(t[1]);\n\n\tBENCH_RUN(\"ep2_is_infty\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_is_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_set_infty\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_set_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_copy\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_copy(p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_cmp\") {\n\t\tep2_rand(p);\n\t\tep2_dbl(p, p);\n\t\tep2_rand(q);\n\t\tep2_dbl(q, q);\n\t\tBENCH_ADD(ep2_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_norm\") {\n\t\tep2_rand(p);\n\t\tep2_dbl(p, p);\n\t\tBENCH_ADD(ep2_norm(p, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_norm_sim (2)\") {\n\t\tep2_rand(t[0]);\n\t\tep2_rand(t[1]);\n\t\tep2_dbl(t[0], t[0]);\n\t\tep2_dbl(t[1], t[1]);\n\t\tBENCH_ADD(ep2_norm_sim(t, t, 2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_cmp (1 norm)\") {\n\t\tep2_rand(p);\n\t\tep2_dbl(p, p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_cmp (2 norm)\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_rand\") {\n\t\tBENCH_ADD(ep2_rand(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_blind\") {\n\t\tBENCH_ADD(ep2_blind(p, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_on_curve\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_on_curve(p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_size_bin (0)\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_size_bin(p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_size_bin (1)\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_size_bin(p, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_write_bin (0)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 0);\n\t\tBENCH_ADD(ep2_write_bin(bin, l, p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_write_bin (1)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 1);\n\t\tBENCH_ADD(ep2_write_bin(bin, l, p, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_read_bin (0)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 0);\n\t\tep2_write_bin(bin, l, p, 0);\n\t\tBENCH_ADD(ep2_read_bin(p, bin, l));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_read_bin (1)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 1);\n\t\tep2_write_bin(bin, l, p, 1);\n\t\tBENCH_ADD(ep2_read_bin(p, bin, l));\n\t} BENCH_END;\n\n\tep2_free(p);\n\tep2_free(q);\n\tep2_free(t[0]);\n\tep2_free(t[1]);\n}\n\nstatic void arith2(void) {\n\tep2_t p, q, r, t[RLC_EPX_TABLE_MAX];\n\tbn_t k, n, l[2];\n\tfp2_t s;\n\n\tep2_null(p);\n\tep2_null(q);\n\tep2_null(r);\n\tbn_null(k);\n\tbn_null(n);\n\tfp2_null(s);\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep2_null(t[i]);\n\t}\n\n\tep2_new(p);\n\tep2_new(q);\n\tep2_new(r);\n\tbn_new(k);\n\tbn_new(n);\n\tbn_new(l[0]);\n\tbn_new(l[1]);\n\tfp2_new(s);\n\n\tep2_curve_get_ord(n);\n\n\tBENCH_RUN(\"ep2_add\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_rand(p);\n\t\tep2_add(q, q, p);\n\t\tBENCH_ADD(ep2_add(r, p, q));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_add_basic\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_add_basic(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_add_slp_basic\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_add_slp_basic(r, s, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_add_projc\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add_projc(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_rand(p);\n\t\tep2_add_projc(q, q, p);\n\t\tBENCH_ADD(ep2_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_add_projc (z2 = 1)\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add_projc(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_norm(q, q);\n\t\tBENCH_ADD(ep2_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_add_projc (z1,z2 = 1)\") {\n\t\tep2_rand(p);\n\t\tep2_norm(p, p);\n\t\tep2_rand(q);\n\t\tep2_norm(q, q);\n\t\tBENCH_ADD(ep2_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_sub\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_rand(p);\n\t\tep2_add(q, q, p);\n\t\tBENCH_ADD(ep2_sub(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_dbl\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tBENCH_ADD(ep2_dbl(r, p));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_dbl_basic\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_dbl_basic(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_dbl_slp_basic\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_dbl_slp_basic(r, s, p));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_dbl_projc\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add_projc(p, p, q);\n\t\tBENCH_ADD(ep2_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_dbl_projc (z1 = 1)\") {\n\t\tep2_rand(p);\n\t\tep2_norm(p, p);\n\t\tBENCH_ADD(ep2_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_neg\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tBENCH_ADD(ep2_neg(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_mul\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul(q, p, k));\n\t} BENCH_END;\n\n#if EP_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul_basic(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_slide\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_slide(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_monty\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_monty(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_lwnaf(q, p, k));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_mul_gen\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul_gen(q, k));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_dig\") {\n\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul_dig(p, q, k->dp[0]));\n\t}\n\tBENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep2_new(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep2_mul_pre\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre(t, p);\n\t\tBENCH_ADD(ep2_mul_fix(q, t, k));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep2_free(t[i]);\n\t}\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_basic\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre_basic(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre_basic(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_basic(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_combs\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre_combs(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_combs\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre_combs(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_combs(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_combd\") {\n\t\tBENCH_ADD(ep2_mul_pre_combd(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_combd\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_mul_pre_combd(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_combd(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_lwnaf\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre_lwnaf(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre_lwnaf(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_lwnaf(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n\tBENCH_RUN(\"ep2_mul_sim\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_basic\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_basic(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_trick\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_trick(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_inter\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_inter(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_joint\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_joint(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_mul_sim_gen\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_gen(r, l[0], q, l[1]));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tep2_new(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep2_mul_sim_lot (2)\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(t[0]);\n\t\tep2_rand(t[1]);\n\t\tBENCH_ADD(ep2_mul_sim_lot(r, t, l, 2));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tep2_free(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep2_frb\") {\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_frb(r, q, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_map\") {\n\t\tuint8_t msg[5];\n\t\trand_bytes(msg, 5);\n\t\tBENCH_ADD(ep2_map(p, msg, 5));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_pck\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_pck(q, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_upk\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_upk(q, p));\n\t} BENCH_END;\n\n\tep2_free(p);\n\tep2_free(q);\n\tep2_free(r);\n\tbn_free(k);\n\tbn_free(n);\n\tbn_free(l[0]);\n\tbn_free(l[1]);\n\tfp2_free(s);\n}\n\nstatic void memory4(void) {\n\tep4_t a[BENCH];\n\n\tBENCH_FEW(\"ep4_null\", ep4_null(a[i]), 1);\n\n\tBENCH_FEW(\"ep4_new\", ep4_new(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep4_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep4_new(a[i]);\n\t}\n\tBENCH_FEW(\"ep4_free\", ep4_free(a[i]), 1);\n\n\t(void)a;\n}\n\nstatic void util4(void) {\n\tep4_t p, q, t[2];\n\tuint8_t bin[8 * RLC_FP_BYTES + 1];\n\tint l;\n\n\tep4_null(p);\n\tep4_null(q);\n\tep4_null(t[0]);\n\tep4_null(t[1]);\n\n\tep4_new(p);\n\tep4_new(q);\n\tep4_new(t[0]);\n\tep4_new(t[1]);\n\n\tBENCH_RUN(\"ep4_is_infty\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_is_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_set_infty\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_set_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_copy\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_copy(p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_cmp\") {\n\t\tep4_rand(p);\n\t\tep4_dbl(p, p);\n\t\tep4_rand(q);\n\t\tep4_dbl(q, q);\n\t\tBENCH_ADD(ep4_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_norm\") {\n\t\tep4_rand(p);\n\t\tep4_dbl(p, p);\n\t\tBENCH_ADD(ep4_norm(p, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_norm_sim (2)\") {\n\t\tep4_rand(t[0]);\n\t\tep4_rand(t[1]);\n\t\tep4_dbl(t[0], t[0]);\n\t\tep4_dbl(t[1], t[1]);\n\t\tBENCH_ADD(ep4_norm_sim(t, t, 2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_cmp (1 norm)\") {\n\t\tep4_rand(p);\n\t\tep4_dbl(p, p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_cmp (2 norm)\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_rand\") {\n\t\tBENCH_ADD(ep4_rand(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_blind\") {\n\t\tBENCH_ADD(ep4_blind(p, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_on_curve\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_on_curve(p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_size_bin\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_size_bin(p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_write_bin\") {\n\t\tep4_rand(p);\n\t\tl = ep4_size_bin(p, 0);\n\t\tBENCH_ADD(ep4_write_bin(bin, l, p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_read_bin\") {\n\t\tep4_rand(p);\n\t\tl = ep4_size_bin(p, 0);\n\t\tep4_write_bin(bin, l, p, 0);\n\t\tBENCH_ADD(ep4_read_bin(p, bin, l));\n\t} BENCH_END;\n\n\tep4_free(p);\n\tep4_free(q);\n\tep4_free(t[0]);\n\tep4_free(t[1]);\n}\n\nstatic void arith4(void) {\n\tep4_t p, q, r, t[RLC_EPX_TABLE_MAX];\n\tbn_t k, n, l;\n\tfp4_t s;\n\n\tep4_null(p);\n\tep4_null(q);\n\tep4_null(r);\n\tbn_null(k);\n\tbn_null(n);\n\tfp4_null(s);\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep4_null(t[i]);\n\t}\n\n\tep4_new(p);\n\tep4_new(q);\n\tep4_new(r);\n\tbn_new(k);\n\tbn_new(n);\n\tbn_new(l);\n\tfp4_new(s);\n\n\tep4_curve_get_ord(n);\n\n\tBENCH_RUN(\"ep4_add\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_rand(p);\n\t\tep4_add(q, q, p);\n\t\tBENCH_ADD(ep4_add(r, p, q));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_add_basic\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_add_basic(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_add_slp_basic\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_add_slp_basic(r, s, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_add_projc\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add_projc(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_rand(p);\n\t\tep4_add_projc(q, q, p);\n\t\tBENCH_ADD(ep4_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_add_projc (z2 = 1)\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add_projc(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_norm(q, q);\n\t\tBENCH_ADD(ep4_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_add_projc (z1,z2 = 1)\") {\n\t\tep4_rand(p);\n\t\tep4_norm(p, p);\n\t\tep4_rand(q);\n\t\tep4_norm(q, q);\n\t\tBENCH_ADD(ep4_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_sub\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_rand(p);\n\t\tep4_add(q, q, p);\n\t\tBENCH_ADD(ep4_sub(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_dbl\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tBENCH_ADD(ep4_dbl(r, p));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_dbl_basic\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_dbl_basic(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_dbl_slp_basic\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_dbl_slp_basic(r, s, p));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_dbl_projc\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add_projc(p, p, q);\n\t\tBENCH_ADD(ep4_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_dbl_projc (z1 = 1)\") {\n\t\tep4_rand(p);\n\t\tep4_norm(p, p);\n\t\tBENCH_ADD(ep4_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_neg\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tBENCH_ADD(ep4_neg(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_mul\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul(q, p, k));\n\t} BENCH_END;\n\n#if EP_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul_basic(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_slide\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_slide(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_monty\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_monty(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_lwnaf(q, p, k));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_mul_gen\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul_gen(q, k));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_dig\") {\n\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul_dig(p, q, k->dp[0]));\n\t}\n\tBENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep4_new(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep4_mul_pre\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre(t, p);\n\t\tBENCH_ADD(ep4_mul_fix(q, t, k));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep4_free(t[i]);\n\t}\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_basic\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre_basic(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre_basic(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_basic(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_combs\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre_combs(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_combs\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre_combs(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_combs(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_combd\") {\n\t\tBENCH_ADD(ep4_mul_pre_combd(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_combd\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_mul_pre_combd(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_combd(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_lwnaf\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre_lwnaf(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre_lwnaf(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_lwnaf(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n\tBENCH_RUN(\"ep4_mul_sim\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim(r, p, k, q, l));\n\t} BENCH_END;\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_basic(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_trick\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_trick(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_inter\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_inter(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_joint\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_joint(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_mul_sim_gen\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_gen(r, k, q, l));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_frb\") {\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_frb(r, q, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_map\") {\n\t\tuint8_t msg[5];\n\t\trand_bytes(msg, 5);\n\t\tBENCH_ADD(ep4_map(p, msg, 5));\n\t} BENCH_END;\n\n\tep4_free(p);\n\tep4_free(q);\n\tep4_free(r);\n\tbn_free(k);\n\tbn_free(n);\n\tbn_free(l);\n\tfp4_free(s);\n}\n\nint main(void) {\n\tint r0, r1;\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tconf_print();\n\n\tutil_banner(\"Benchmarks for the EPX module:\", 0);\n\n\tif (ep_param_set_any_pairf() != RLC_OK) {\n\t\tRLC_THROW(ERR_NO_CURVE);\n\t\tcore_clean();\n\t\treturn 0;\n\t}\n\n\tif ((r0 = ep2_curve_is_twist())) {\n\t\tep_param_print();\n\n\t\tutil_banner(\"Utilities:\", 1);\n\t\tmemory2();\n\t\tutil2();\n\n\t\tutil_banner(\"Arithmetic:\", 1);\n\t\tarith2();\n\t}\n\n\tif ((r1 = ep4_curve_is_twist())) {\n\t\tep_param_print();\n\n\t\tutil_banner(\"Utilities:\", 1);\n\t\tmemory4();\n\t\tutil4();\n\n\t\tutil_banner(\"Arithmetic:\", 1);\n\t\tarith4();\n\t}\n\n\tif (!r0 && !r1) {\n\t\tRLC_THROW(ERR_NO_CURVE);\n\t\tcore_clean();\n\t\treturn 0;\n\t}\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup bn Multiple precision integer arithmetic\n */\n\n/**\n * @file\n *\n * Interface of the module for multiple precision integer arithmetic.\n *\n * @ingroup bn\n */\n\n#ifndef RLC_BN_H\n#define RLC_BN_H\n\n#include \"relic_conf.h\"\n#include \"relic_util.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a multiple precision integer.\n *\n * If the library is built with support for dynamic allocation, this constant\n * represents the size in bits of the memory block allocated each time a\n * multiple precision integer must grow. Otherwise, it represents the fixed\n * fixed precision.\n */\n#define RLC_BN_BITS \t((int)BN_PRECI)\n\n/**\n * Size in digits of a block sufficient to store the required precision.\n */\n#define RLC_BN_DIGS\t\t((int)RLC_CEIL(BN_PRECI, RLC_DIG))\n\n/**\n * Size in digits of a block sufficient to store a multiple precision integer.\n */\n#if BN_MAGNI == DOUBLE\n#define RLC_BN_SIZE\t\t((int)(2 * RLC_BN_DIGS + 2))\n#elif BN_MAGNI == CARRY\n#define RLC_BN_SIZE\t\t((int)(RLC_BN_DIGS + 1))\n#elif BN_MAGNI == SINGLE\n#define RLC_BN_SIZE\t\t((int)RLC_BN_DIGS)\n#endif\n\n/**\n * Positive sign of a multiple precision integer.\n */\n#define RLC_POS\t\t0\n\n/**\n * Negative sign of a multiple precision integer.\n */\n#define RLC_NEG\t\t1\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a multiple precision integer.\n *\n * The field dp points to a vector of digits. These digits are organized\n * in little-endian format, that is, the least significant digits are\n * stored in the first positions of the vector.\n */\ntypedef struct {\n\t/** The number of digits allocated to this multiple precision integer. */\n\tint alloc;\n\t/** The number of digits actually used. */\n\tint used;\n\t/** The sign of this multiple precision integer. */\n\tint sign;\n#if ALLOC == DYNAMIC\n\t/** The sequence of contiguous digits that forms this integer. */\n\tdig_t *dp;\n#elif ALLOC == AUTO\n\t/** The sequence of contiguous digits that forms this integer. */\n\trlc_align dig_t dp[RLC_BN_SIZE];\n#endif\n} bn_st;\n\n/**\n * Pointer to a multiple precision integer structure.\n */\n#if ALLOC == AUTO\ntypedef bn_st bn_t[1];\n#elif ALLOC == DYNAMIC\n#ifdef CHECK\ntypedef bn_st *volatile bn_t;\n#else\ntypedef bn_st *bn_t;\n#endif\n#endif\n\n/**\n * Represents a pair of moduli for using the Chinese Remainder Theorem (CRT).\n */\ntypedef struct {\n\t/** The modulus n = pq. */\n\tbn_t n;\n\t/** The first prime p. */\n\tbn_t p;\n\t/** The second prime q. */\n\tbn_t q;\n\t/** The precomputed constant for the first prime. */\n\tbn_t dp;\n\t/** The precomputed constant for the second prime. */\n\tbn_t dq;\n\t/** The inverse of q modulo p. */\n\tbn_t qi;\n} crt_st;\n\n#if ALLOC == AUTO\ntypedef crt_st crt_t[1];\n#else\ntypedef crt_st *crt_t;\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a multiple precision integer with a null value.\n *\n * @param[out] A\t\t\t- the multiple precision integer to initialize.\n */\n#if ALLOC == AUTO\n#define bn_null(A)\t\t\t/* empty */\n#elif ALLOC == DYNAMIC\n#define bn_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif ((A) == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer\n * with the required precision in digits.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @param[in] D\t\t\t\t- the precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\n#if ALLOC == DYNAMIC\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to free.\n */\n#if ALLOC == DYNAMIC\n#define bn_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_clean(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree((void *)A);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bn_free(A)\t\t\t/* empty */\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Initializes a CRT moduli set with a null value.\n *\n * @param[out] A\t\t\t- the moduli to initialize.\n */\n#define crt_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Rabin key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (crt_t)calloc(1, sizeof(crt_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Rabin key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define crt_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define crt_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Multiples two multiple precision integers. Computes c = a * b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] B\t\t\t\t- the second multiple precision integer to multiply.\n */\n#if BN_KARAT > 0\n#define bn_mul(C, A, B)\t\tbn_mul_karat(C, A, B)\n#elif BN_MUL == BASIC\n#define bn_mul(C, A, B)\t\tbn_mul_basic(C, A, B)\n#elif BN_MUL == COMBA\n#define bn_mul(C, A, B)\t\tbn_mul_comba(C, A, B)\n#endif\n\n/**\n * Computes the square of a multiple precision integer. Computes c = a * a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to square.\n */\n#if BN_KARAT > 0\n#define bn_sqr(C, A)\t\tbn_sqr_karat(C, A)\n#elif BN_SQR == BASIC\n#define bn_sqr(C, A)\t\tbn_sqr_basic(C, A)\n#elif BN_SQR == COMBA\n#define bn_sqr(C, A)\t\tbn_sqr_comba(C, A)\n#elif BN_SQR == MULTP\n#define bn_sqr(C, A)\t\tbn_mul(C, A, A)\n#endif\n\n/**\n * Computes the auxiliar value derived from the modulus to be used during\n * modular reduction.\n *\n * @param[out] U\t\t\t- the result.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_pre(U, M)\t(void)(U), (void)(M)\n#elif BN_MOD == BARRT\n#define bn_mod_pre(U, M)\tbn_mod_pre_barrt(U, M)\n#elif BN_MOD == MONTY\n#define bn_mod_pre(U, M)\tbn_mod_pre_monty(U, M)\n#elif BN_MOD == PMERS\n#define bn_mod_pre(U, M)\tbn_mod_pre_pmers(U, M)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo another integer. If the number\n * of arguments is 3, then simple division is used. If the number of arguments\n * is 4, then a modular reduction algorithm is used and the fourth argument\n * is an auxiliary value derived from the modulus. The variant with 4 arguments\n * should be used when several modular reductions are computed with the same\n * modulus. Computes c = a mod m.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] ...\t\t\t- the modulus and an optional argument.\n */\n#define bn_mod(C, A, ...)\tRLC_CAT(bn_mod, RLC_OPT(__VA_ARGS__))(C, A, __VA_ARGS__)\n\n/**\n * Reduces a multiple precision integer modulo another integer. This macro\n * should not be called directly. Use bn_mod with 4 arguments instead.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the auxiliar value derived from the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_imp(C, A, M, U)\tbn_mod_basic(C, A, M)\n#elif BN_MOD == BARRT\n#define bn_mod_imp(C, A, M, U)\tbn_mod_barrt(C, A, M, U)\n#elif BN_MOD == MONTY\n#define bn_mod_imp(C, A, M, U)\tbn_mod_monty(C, A, M, U)\n#elif BN_MOD == PMERS\n#define bn_mod_imp(C, A, M, U)\tbn_mod_pmers(C, A, M, U)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction. Computes c = a * u^(-1) (mod m).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the reciprocal of the modulus.\n */\n#if BN_MUL == BASIC\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_basic(C, A, M, U)\n#elif BN_MUL == COMBA\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_comba(C, A, M, U)\n#endif\n\n/**\n * Exponentiates a multiple precision integer modulo another multiple precision\n * integer. Computes c = a^b mod m. If Montgomery reduction is used, the basis\n * must not be in Montgomery form.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MXP == BASIC\n#define bn_mxp(C, A, B, M)\tbn_mxp_basic(C, A, B, M)\n#elif BN_MXP == SLIDE\n#define bn_mxp(C, A, B, M)\tbn_mxp_slide(C, A, B, M)\n#elif BN_MXP == MONTY\n#define bn_mxp(C, A, B, M)\tbn_mxp_monty(C, A, B, M)\n#endif\n\n/**\n * Computes the greatest common divisor of two multiple precision integers.\n * Computes c = gcd(a, b).\n *\n * @param[out] C\t\t\t- the result;\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd(C, A, B)\t\tbn_gcd_basic(C, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd(C, A, B)\t\tbn_gcd_lehme(C, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd(C, A, B)\t\tbn_gcd_binar(C, A, B)\n#endif\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers. This function can be used to compute multiplicative inverses.\n * Computes c = gcd(a, b) and c = a * d + b * e.\n *\n * @param[out] C\t\t\t- the result;\n * @param[out] D\t\t\t- the cofactor of the first operand, cannot be NULL.\n * @param[out] E\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_basic(C, D, E, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_lehme(C, D, E, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_binar(C, D, E, A, B)\n#endif\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] A\t\t\t- the result.\n * @param[in] B\t\t\t\t- the length of the number in bits.\n */\n#if BN_GEN == BASIC\n#define bn_gen_prime(A, B)\tbn_gen_prime_basic(A, B)\n#elif BN_GEN == SAFEP\n#define bn_gen_prime(A, B)\tbn_gen_prime_safep(A, B)\n#elif BN_GEN == STRON\n#define bn_gen_prime(A, B)\tbn_gen_prime_stron(A, B)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes a previously allocated multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to initialize.\n * @param[in] digits\t\t- the required precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_make(bn_t a, int digits);\n\n/**\n * Cleans a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to free.\n */\nvoid bn_clean(bn_t a);\n\n/**\n * Checks the current precision of a multiple precision integer and optionally\n * expands its precision to a given size in digits.\n *\n * @param[out] a\t\t\t- the multiple precision integer to expand.\n * @param[in] digits\t\t- the number of digits to expand.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_grow(bn_t a, int digits);\n\n/**\n * Adjust the number of valid digits of a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to adjust.\n */\nvoid bn_trim(bn_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to copy.\n */\nvoid bn_copy(bn_t c, const bn_t a);\n\n/**\n * Returns the absolute value of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the argument of the absolute function.\n */\nvoid bn_abs(bn_t c, const bn_t a);\n\n/**\n * Inverts the sign of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the multiple precision integer to negate.\n */\nvoid bn_neg(bn_t c, const bn_t a);\n\n/**\n * Returns the sign of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return RLC_POS if the argument is positive and RLC_NEG otherwise.\n */\nint bn_sign(const bn_t a);\n\n/**\n * Assigns zero to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n */\nvoid bn_zero(bn_t a);\n\n/**\n * Tests if a multiple precision integer is zero or not.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint bn_is_zero(const bn_t a);\n\n/**\n * Tests if a multiple precision integer is even or odd.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is even, 0 otherwise.\n */\nint bn_is_even(const bn_t a);\n\n/**\n * Returns the number of bits of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return number of bits.\n */\nint bn_bits(const bn_t a);\n\n/**\n * Returns the bit stored in the given position on a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to read.\n * @return the bit value.\n */\nint bn_get_bit(const bn_t a, int bit);\n\n/**\n * Stores a bit in a given position on a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to store.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid bn_set_bit(bn_t a, int bit, int value);\n\n/**\n * Returns the Hamming weight of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of non-zero bits.\n */\nint bn_ham(const bn_t a);\n\n/**\n * Reads the first digit in a multiple precision integer.\n *\n * @param[out] digit\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n */\nvoid bn_get_dig(dig_t *digit, const bn_t a);\n\n/**\n * Assigns a small positive constant to a multiple precision integer.\n *\n * The constant must fit on a multiple precision digit, or dig_t type using\n * only the number of bits specified on RLC_DIG.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] digit\t\t\t- the constant to assign.\n */\nvoid bn_set_dig(bn_t a, dig_t digit);\n\n/**\n * Assigns a multiple precision integer to 2^b.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] b\t\t\t\t- the power of 2 to assign.\n */\nvoid bn_set_2b(bn_t a, int b);\n\n/**\n * Assigns a random value to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] sign\t\t\t- the sign to be assigned (RLC_NEG or RLC_POS).\n * @param[in] bits\t\t\t- the number of bits.\n */\nvoid bn_rand(bn_t a, int sign, int bits);\n\n/**\n * Assigns a non-zero random value to a multiple precision integer with absolute\n * value smaller than a given modulus.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] b\t\t\t\t- the modulus.\n */\nvoid bn_rand_mod(bn_t a, const bn_t b);\n\n/**\n * Prints a multiple precision integer to standard output.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to print.\n */\nvoid bn_print(const bn_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a multiple precision\n * integer. The radix must be included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nint bn_size_str(const bn_t a, int radix);\n\n/**\n * Reads a multiple precision integer from a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_read_str(bn_t a, const char *str, int len, int radix);\n\n/**\n * Writes a multiple precision integer to a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_write_str(char *str, int len, const bn_t a, int radix);\n\n/**\n * Returns the number of bytes necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of bytes.\n */\nint bn_size_bin(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n */\nvoid bn_read_bin(bn_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_bin(uint8_t *bin, int len, const bn_t a);\n\n/**\n * Returns the number of digits necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of digits.\n */\nint bn_size_raw(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a digit vector.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the size of the string.\n */\nvoid bn_read_raw(bn_t a, const dig_t *raw, int len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector.\n *\n * @param[out] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_raw(dig_t *raw, int len, const bn_t a);\n\n/**\n * Returns the result of an unsigned comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_abs(const bn_t a, const bn_t b);\n\n/**\n * Returns the result of a signed comparison between a multiple precision\n * integer and a digit.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_dig(const bn_t a, dig_t b);\n\n/**\n * Returns the result of a signed comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp(const bn_t a, const bn_t b);\n\n/**\n * Adds two multiple precision integers. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to add.\n * @param[in] b\t\t\t\t- the second multiple precision integer to add.\n */\nvoid bn_add(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Adds a multiple precision integers and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to add.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid bn_add_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Subtracts a multiple precision integer from another, that is, computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the multiple precision integer to subtract.\n */\nvoid bn_sub(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Subtracts a digit from a multiple precision integer. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid bn_sub_dig(bn_t c, const bn_t a, const dig_t b);\n\n/**\n * Multiplies a multiple precision integer by a digit. Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid bn_mul_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Multiplies two multiple precision integers using Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_comba(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_karat(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the square of a multiple precision integer using Schoolbook\n * squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_basic(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Comba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_comba(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Karatsuba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_karat(bn_t c, const bn_t a);\n\n/**\n * Doubles a multiple precision. Computes c = a + a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to double.\n */\nvoid bn_dbl(bn_t c, const bn_t a);\n\n/**\n * Halves a multiple precision. Computes c = floor(a / 2)\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to halve.\n */\nvoid bn_hlv(bn_t c, const bn_t a);\n\n/**\n * Shifts a multiple precision number to the left. Computes c = a * 2^bits.\n * c = a * 2^bits.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_lsh(bn_t c, const bn_t a, int bits);\n\n/**\n * Shifts a multiple precision number to the right. Computes\n * c = floor(a / 2^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_rsh(bn_t c, const bn_t a, int bits);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * without producing the positive remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * and produces a positive remainder. Computes c = floor(a / b) and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the positive remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem(bn_t c, bn_t d, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integers by a digit without computing the\n * remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Divides a multiple precision integers by a digit. Computes c = floor(a / b)\n * and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem_dig(bn_t c, dig_t *d, const bn_t a, const dig_t b);\n\n/**\n * Computes the modular inverse of a multiple precision integer. Computes c such\n * that a*c mod b = 1.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a\t\t\t\t- the element to invert.\n * param[in] b\t\t\t\t- the modulus.\n *\n */\nvoid bn_mod_inv(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the modular inverse of multiple precision integers simultaneously.\n * Computes c_i such that a_i * c_i mod b = 1.\n *\n * @param[out] c\t\t\t- the results.\n * @param[in] a\t\t\t\t- the elements to invert.\n * param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid bn_mod_inv_sim(bn_t *c, const bn_t *a, const bn_t b, int n);\n\n/**\n * Reduces a multiple precision integer modulo a power of 2. Computes\n * c = a mod 2^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the exponent of the divisor.\n */\nvoid bn_mod_2b(bn_t c, const bn_t a, int b);\n\n/**\n * Reduces a multiple precision integer modulo a digit. Computes c = a mod b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n */\nvoid bn_mod_dig(dig_t *c, const bn_t a, dig_t b);\n\n/**\n * Reduces a multiple precision integer modulo an integer using straightforward\n * division.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_basic(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Barrett modular\n * reduction algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_barrt(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using Barrett\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_barrt(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Montgomery reduction\n * algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n * @throw ERR_NO_VALID\t\t- if the modulus is even.\n */\nvoid bn_mod_pre_monty(bn_t u, const bn_t m);\n\n/**\n * Converts a multiple precision integer to Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_conv(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Converts a multiple precision integer from Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_back(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_basic(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_comba(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes u if the modulus has the form 2^b - u.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_pmers(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * pseudo-Mersenne modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the auxiliar value derived from the modulus.\n */\nvoid bn_mod_pmers(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the constant-time Montgomery powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_monty(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer by a small power modulo a positive\n * integer using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_dig(bn_t c, const bn_t a, dig_t b, const bn_t m);\n\n/*\n * Computes a modular exponentiation of a multiple precision integer using the\n * Chinese Remainder Theorem, given the moduli.\n *\n * @param[out] d \t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent modulo p.\n * @param[in] c\t\t\t\t- the exponent modulo q.\n * @param[in] crt \t\t\t- the set of moduli.\n * @param[in] sqr \t\t\t- the flag to indicate if modulo n or n^2.\n */\nvoid bn_mxp_crt(bn_t d, const bn_t a, const bn_t b, const bn_t c,\n\tconst crt_t crt, int sqr);\n\n/**\n * Extracts an approximate integer square-root of a multiple precision integer.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a \t\t\t- the multiple precision integer to extract.\n *\n * @throw ERR_NO_VALID\t\t- if the argument is negative.\n */\nvoid bn_srt(bn_t c, bn_t a);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the standard Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_binar(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of a multiple precision integer and a\n * digit.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integer using the Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_basic(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers halfway through the algorithm. Returns also two short vectors\n * v1 = (c, d), v2 = (-e, f) useful to decompose an integer k into k0, k1 such\n * that k = k_0 + k_1 * a (mod b).\n *\n * @param[out] c\t\t\t- the first component of the first vector.\n * @param[out] d\t\t\t- the second component of the first vector.\n * @param[out] e\t\t\t- the first component of the second vector.\n * @param[out] f\t\t\t- the second component of the second vector.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_mid(bn_t c, bn_t d, bn_t e, bn_t f, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of a multiple precision integer\n * and a digit.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_ext_dig(bn_t c, bn_t d, bn_t e, const bn_t a, dig_t b);\n\n/**\n * Computes the last common multiple of two multiple precision integers.\n * Computes c = lcm(a, b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first integer.\n * @param[in] b\t\t\t\t- the second integer.\n */\nvoid bn_lcm(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the Legendre symbol c = (a|b), b prime.\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is negative.\n * @return the result.\n */\nint bn_smb_leg(const bn_t a, const bn_t b);\n\n/**\n * Computes the Jacobi symbol c = (a|b).\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is even or negative.\n * @return the result.\n */\nint bn_smb_jac(const bn_t a, const bn_t b);\n\n/**\n * Tests if a number is a probable prime.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if a is prime, 0 otherwise.\n */\nint bn_is_prime(const bn_t a);\n\n/**\n * Tests if a number is prime using a series of trial divisions.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_basic(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Miller-Rabin test with probability\n * 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_rabin(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Solovay-Strassen test with\n * probability 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_solov(const bn_t a);\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_basic(bn_t a, int bits);\n\n/**\n * Generates a probable prime number a with (a - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_safep(bn_t a, int bits);\n\n/**\n * Generates a probable prime number with (a - 1)/2, (a + 1)/2 and\n * ((a - 1)/2 - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_stron(bn_t a, int bits);\n\n/**\n * Generates a probable prime number b, with (b-1) divisible by a probable large\n * prime a.\n *\n * @param[out] a\t\t\t- the prime factor of (b-1).\n * @param[out] b\t\t\t- the prime result b.\n * @param[in] abits\t\t\t- the length of the factor a in bits.\n * @param[in] bbits\t\t\t- the length of the result in bits.\n */\nint bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits);\n\n\n/**\n * Tries to factorize an integer using Pollard (p - 1) factoring algorithm.\n * The maximum length of the returned factor is 16 bits.\n *\n * @param[out] c\t\t\t- the resulting factor.\n * @param[in] a\t\t\t\t- the integer to fatorize.\n * @return 1 if a factor is found and stored into c; 0 otherwise.\n */\nint bn_factor(bn_t c, const bn_t a);\n\n/**\n * Tests if an integer divides other integer.\n *\n * @param[in] c\t\t\t\t- the factor.\n * @param[in] a\t\t\t\t- the integer.\n * @return 1 if the first integer is a factor; 0 otherwise.\n */\nint bn_is_factor(bn_t c, const bn_t a);\n\n/**\n * Recodes a positive integer in window form. If a negative integer is given\n * instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_win(uint8_t *win, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in sliding window form. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in width-w Non-Adjacent Form. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w);\n\n/**\n * Recodes a positive integer in width-w \\tau-NAF. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w \\tau-NAF.\n * If a negative integer is given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w);\n\n/**\n * Write the constants needed for \\tau-NAF recoding as a set of \\alpha_u =\n * \\beta_u + \\gamma_u * \\tau elements.\n *\n * @param[out] t \t\t- the integer corresponding to \\tau.\n * @param[out] beta\t\t- the first coefficients of the constants.\n * @param[out] gama\t\t- the second coefficients of the constants.\n * @param[in] u \t\t- the u curve parameter.\n * @param[in] w \t\t- the window size in bits.\n */\nvoid bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w);\n\n/**\n * Computes the partial reduction k partmod d = r0 + r1 * t, where\n * d = (t^m - 1)/(t - 1).\n *\n * @param[out] r0\t\t- the first half of the result.\n * @param[out] r1\t\t- the second half of the result.\n * @param[in] k\t\t\t- the number to reduce.\n * @param[in] u\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t- the extension degree of the binary field.\n */\nvoid bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w NAF. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the length of the recoding.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w);\n\n/**\n * Recodes of a pair of positive integers in Joint Sparse Form. If negative\n * integers are given instead, takes their absolute value.\n *\n * @param[out] jsf\t\t\t- the recoded pair of integers.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the first integer to recode.\n * @param[in] l\t\t\t\t- the second integer to recode.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l);\n\n/**\n * Recodes a positive integer into two parts k0,k1 such that k = k0 + phi(k1),\n * where phi is an efficient curve endomorphism. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] k0\t\t\t- the first part of the result.\n * @param[out] k1\t\t\t- the second part of the result.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the group order.\n * @param[in] v1\t\t\t- the set of parameters v1 for the GLV method.\n * @param[in] v2\t\t\t- the set of parameters v2 for the GLV method.\n */\nvoid bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t v1[],\n\t\tconst bn_t v2[]);\n\n/**\n * Recodes a scalar in subscalars according to Frobenius endomorphism.\n *\n * @param[out] ki\t\t\t- the recoded subscalars.\n * @param[in] sub \t\t\t- the number of subscalars.\n * @param[in] k\t\t\t\t- the scalar to recode.\n * @param[in] x \t\t\t- the elliptic curve parameter.\n * @param[in] n\t\t\t\t- the elliptic curve group order.\n * @param[in] cof \t\t\t- flag to indicate if it is a curve with cofactor 1.\n */\nvoid bn_rec_frb(bn_t *ki, int sub, const bn_t k, const bn_t x, const bn_t n,\n\tint bls);\n\n/**\n * Computes the coefficients of the polynomial representing the Lagrange\n * interpolation for a modulus and a given set of roots.\n * Computes c(x) = \\prod_{0 <= i < n}(x - ai) mod q.\n *\n * @param[out] c \t\t\t- the coefficients of the polynomial.\n * @param[in] a\t\t\t\t- the set of roots.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of roots to interpolate.\n */\nvoid bn_lag(bn_t *c, const bn_t *a, const bn_t b, size_t n);\n\n/**\n * Evaluates an interpolated n-degree polynomial over a value in a modular way,\n * given the (n+1) coefficients of the polynomial and the modulus.\n * Computes c = a(x) mod q.\n *\n * @param[out] c \t\t\t- the result of the evaluation.\n * @param[in] a \t\t\t- the coefficients of the polynomial.\n * @param[in] x\t\t\t\t- the value to evaluate.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the degree of the polynomial.\n */\nvoid bn_evl(bn_t c, const bn_t *a, const bn_t x, const bn_t b, size_t n);\n\n#endif /* !RLC_BN_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup cp Cryptographic protocols\n */\n\n/**\n * @file\n *\n * Interface of cryptographic protocols.\n *\n * @ingroup cp\n */\n\n#ifndef RLC_CP_H\n#define RLC_CP_H\n\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n#include \"relic_util.h\"\n#include \"relic_bn.h\"\n#include \"relic_ec.h\"\n#include \"relic_pc.h\"\n#include \"relic_mpc.h\"\n\n/*============================================================================*/\n/* Type definitions.                                                          */\n/*============================================================================*/\n\n/**\n * Represents an RSA key pair.\n */\ntypedef struct {\n\t/** The private exponent. */\n\tbn_t d;\n\t/** The public exponent. */\n\tbn_t e;\n\t/** The pair of moduli. */\n\tcrt_t crt;\n} _rsa_st;\n\n/**\n * Pointer to an RSA key pair.\n */\n#if ALLOC == AUTO\ntypedef _rsa_st rsa_t[1];\n#else\ntypedef _rsa_st *rsa_t;\n#endif\n\n/**\n * Pointer to a Rabin key pair.\n */\n#if ALLOC == AUTO\ntypedef crt_st rabin_t[1];\n#else\ntypedef crt_st *rabin_t;\n#endif\n\n/**\n * Pointer to a Paillier's Homomorphic Probabilistic Encryption key pair.\n */\n#if ALLOC == AUTO\ntypedef crt_st phpe_t[1];\n#else\ntypedef crt_st *phpe_t;\n#endif\n\n\n/**\n * Represents a Subgroup Paillier's Probabilistic Encryption key pair.\n */\ntypedef struct {\n\t/** The subgroup order. */\n\tbn_t a;\n\t/** The subgroup size. */\n\tbn_t b;\n\t/** The generator ((1+n)^b) mod n^2. */\n\tbn_t g;\n\t/** The precomputed ((1+n)^b)^n mod n^2. */\n\tbn_t gn;\n\t/** The CRT parameters. */\n\tcrt_t crt;\n} shpe_st;\n\n/**\n * Pointer to a Subgroup-Paillier's Homomorphic Probabilistic Encryption key pair.\n */\n#if ALLOC == AUTO\ntypedef shpe_st shpe_t[1];\n#else\ntypedef shpe_st *shpe_t;\n#endif\n\n/**\n * Represents a Benaloh's Dense Probabilistic Encryption key pair.\n */\ntypedef struct {\n\t/** The modulus n = pq. */\n\tbn_t n;\n\t/** The first prime p. */\n\tbn_t p;\n\t/** The second prime q. */\n\tbn_t q;\n\t/** The random element in {0, ..., n - 1}. */\n\tbn_t y;\n\t/** The divisor of (p-1) such that gcd(t, (p-1)/t) = gcd(t, q-1) = 1. */\n\tdig_t t;\n} bdpe_st;\n\n/**\n * Pointer to a Benaloh's Dense Probabilistic Encryption key pair.\n */\n#if ALLOC == AUTO\ntypedef bdpe_st bdpe_t[1];\n#else\ntypedef bdpe_st *bdpe_t;\n#endif\n\n/**\n * Represents a SOKAKA key pair.\n */\ntypedef struct _sokaka {\n\t/** The private key in G_1. */\n\tg1_t s1;\n\t/** The private key in G_2. */\n\tg2_t s2;\n} sokaka_st;\n\n/**\n * Pointer to SOKAKA key pair.\n */\n#if ALLOC == AUTO\ntypedef sokaka_st sokaka_t[1];\n#else\ntypedef sokaka_st *sokaka_t;\n#endif\n\n/**\n * Represents a Boneh-Goh-Nissim cryptosystem key pair.\n */\ntypedef struct {\n\t/** The first exponent. */\n\tbn_t x;\n\t/** The second exponent. */\n\tbn_t y;\n\t/** The third exponent. */\n\tbn_t z;\n\t/* The first element from the first group. */\n\tg1_t gx;\n\t/* The second element from the first group. */\n\tg1_t gy;\n\t/* The thirs element from the first group. */\n\tg1_t gz;\n\t/* The first element from the second group. */\n\tg2_t hx;\n\t/* The second element from the second group. */\n\tg2_t hy;\n\t/* The third element from the second group. */\n\tg2_t hz;\n} bgn_st;\n\n/**\n * Pointer to a Boneh-Goh-Nissim cryptosystem key pair.\n */\n#if ALLOC == AUTO\ntypedef bgn_st bgn_t[1];\n#else\ntypedef bgn_st *bgn_t;\n#endif\n\n/**\n * Represents an extendable ring signature.\n */\ntypedef struct _ers_st {\n\t/** The ephemeral public key in the signature. */\n    ec_t h;\n\t/** The public key associated to the signature. */\n\tec_t pk;\n\t/** The first component of the signature of knowledge. */\n\tbn_t c[2];\n\t/** The second component of the signature of knowledge. */\n\tbn_t r[2];\n} ers_st;\n\n/**\n * Pointer to an extendable ring signature.\n */\n#if ALLOC == AUTO\ntypedef ers_st ers_t[1];\n#else\ntypedef ers_st *ers_t;\n#endif\n\n/**\n * Represents an extendable ring signature.\n */\ntypedef struct _smlers_st {\n\t/** The extendable ring signature. */\n\ters_t sig;\n\t/** The linkability tag. */\n\tec_t tau;\n\t/** The first component of the signature of knowledge. */\n\tbn_t c[2];\n\t/** The second component of the signature of knowledge. */\n\tbn_t r[2];\n} smlers_st;\n\n/**\n * Pointer to an extendable ring signature.\n */\n#if ALLOC == AUTO\ntypedef smlers_st smlers_t[1];\n#else\ntypedef smlers_st *smlers_t;\n#endif\n\n/**\n * Represents an extendable threshold ring signature.\n */\ntypedef struct _etrs_st {\n\t/** The secret. */\n\tbn_t y;\n\t/** The ephemeral public key in the signature. */\n    ec_t h;\n\t/** The public key associated to the signature. */\n\tec_t pk;\n\t/** The first component of the signature of knowledge. */\n\tbn_t c[2];\n\t/** The second component of the signature of knowledge. */\n\tbn_t r[2];\n} etrs_st;\n\n/**\n * Pointer to an extendable ring signature.\n */\n#if ALLOC == AUTO\ntypedef etrs_st etrs_t[1];\n#else\ntypedef etrs_st *etrs_t;\n#endif\n\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a Subgroup Paillier key pair with a null value.\n *\n * @param[out] A\t\t\t- the moduli to initialize.\n */\n#define shpe_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Subgroup Paillier key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define shpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (shpe_t)calloc(1, sizeof(shpe_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->a);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->b);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->g);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->gn);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define shpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->a);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->b);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->g);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->gn);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Subgroup Paillier key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define shpe_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->a);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->b);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->g);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->gn);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tcrt_free((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define shpe_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Initializes an RSA key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define rsa_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an RSA key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define rsa_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (rsa_t)calloc(1, sizeof(_rsa_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_null((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_null((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define rsa_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free an RSA key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define rsa_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tcrt_free((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define rsa_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Initializes a Rabin key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define rabin_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Rabin key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#define rabin_new(A)\t\tcrt_new(A)\n\n/**\n * Calls a function to clean and free a Rabin key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#define rabin_free(A)\t\tcrt_free(A)\n\n/**\n * Initializes a Paillier key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define phpe_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Paillier key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#define phpe_new(A)\t\t\tcrt_new(A)\n\n/**\n * Calls a function to clean and free a Paillier key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#define phpe_free(A)\t\tcrt_free(A)\n\n/**\n * Initializes a Benaloh's key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define bdpe_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Benaloh's key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define bdpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bdpe_t)calloc(1, sizeof(bdpe_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(A)->t = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bdpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(A)->t = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Benaloh's key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define bdpe_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(A)->t = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bdpe_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a SOKAKA key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define sokaka_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a SOKAKA key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define sokaka_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (sokaka_t)calloc(1, sizeof(sokaka_st));\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->s1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->s2);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define sokaka_new(A)\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free a SOKAKA key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define sokaka_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->s1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->s2);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define sokaka_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define bgn_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a BGN key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define bgn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bgn_t)calloc(1, sizeof(bgn_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->gx);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->gy);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->gz);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->hx);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->hy);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->hz);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bgn_new(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free a BGN key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define bgn_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->gx);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->gy);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->gz);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->hx);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->hy);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->hz);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bgn_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define ers_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an extendable signature ring.\n *\n * @param[out] A\t\t\t- the new signature ring.\n */\n#if ALLOC == DYNAMIC\n#define ers_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ers_t)calloc(1, sizeof(ers_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ers_new(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free an extendable signature ring.\n *\n * @param[out] A\t\t\t- the signature ring to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define ers_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ers_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define smlers_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an extendable signature ring.\n *\n * @param[out] A\t\t\t- the new signature ring.\n */\n#if ALLOC == DYNAMIC\n#define smlers_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (smlers_t)calloc(1, sizeof(ers_st));\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\ters_new((A)->sig);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->tau);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define smlers_new(A)\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free an extendable signature ring.\n *\n * @param[out] A\t\t\t- the signature ring to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define smlers_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ters_free((A)->sig);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->tau);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define smlers_free(A)\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define etrs_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an extendable signature ring.\n *\n * @param[out] A\t\t\t- the new signature ring.\n */\n#if ALLOC == DYNAMIC\n#define etrs_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (etrs_t)calloc(1, sizeof(etrs_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define etrs_new(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free an extendable signature ring.\n *\n * @param[out] A\t\t\t- the signature ring to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define etrs_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define etrs_free(A)\t\t/* empty */\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Generates a key pair for the RSA cryptosystem. Generates additional values\n * for the CRT optimization if CP_CRT is on.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_gen(rsa_t pub, rsa_t prv, int bits);\n\n/**\n * Encrypts using the RSA cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_enc(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t pub);\n\n/**\n * Decrypts using the RSA cryptosystem. Uses the CRT optimization if\n * CP_CRT is on.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to decrypt.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t prv);\n\n/**\n * Signs using the basic RSA signature algorithm. The flag must be non-zero if\n * the message being signed is already a hash value. Uses the CRT optimization\n * if CP_CRT is on.\n *\n * @param[out] sig\t\t\t- the signature\n * @param[out] sig_len\t\t- the number of bytes written in the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] msg_len\t\t- the number of bytes to sign.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_sig(uint8_t *sig, size_t *sig_len, const uint8_t *msg,\n\t\tsize_t msg_len, int hash, const rsa_t prv);\n\n/**\n * Verifies an RSA signature. The flag must be non-zero if the message being\n * signed is already a hash value.\n *\n * @param[in] sig\t\t\t- the signature to verify.\n * @param[in] sig_len\t\t- the signature length in bytes.\n * @param[in] msg\t\t\t- the signed message.\n * @param[in] msg_len\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] pub\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_rsa_ver(uint8_t *sig, size_t sig_len, const uint8_t *msg, size_t msg_len,\n\t\tint hash, const rsa_t pub);\n\n/**\n * Generates a key pair for the Rabin cryptosystem.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key,\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rabin_gen(rabin_t pub, rabin_t prv, size_t bits);\n\n/**\n * Encrypts using the Rabin cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rabin_enc(uint8_t *out, size_t *out_len, const uint8_t *in,\n\t\tsize_t in_len, const rabin_t pub);\n\n/**\n * Decrypts using the Rabin cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to decrypt.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rabin_dec(uint8_t *out, size_t *out_len, const uint8_t *in,\n\t\tsize_t in_len, const rabin_t prv);\n\n/**\n * Generates a key pair for Benaloh's Dense Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] block\t\t\t- the block size.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bdpe_gen(bdpe_t pub, bdpe_t prv, dig_t block, size_t bits);\n\n/**\n * Encrypts using Benaloh's cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the plaintext as a small integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bdpe_enc(uint8_t *out, size_t *out_len, dig_t in, const bdpe_t pub);\n\n/**\n * Decrypts using Benaloh's cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bdpe_dec(dig_t *out, const uint8_t *in, size_t in_len, const bdpe_t prv);\n\n/**\n * Generates a key pair for Paillier's Homomorphic Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_gen(bn_t pub, phpe_t prv, size_t bits);\n\n/**\n * Encrypts using the Paillier cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext, represented as an integer.\n * @param[in] m\t\t\t\t- the plaintext as an integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_enc(bn_t c, const bn_t m, const bn_t pub);\n\n/**\n * Evaluated a homomorphic addition using the Paillier cryptosystem.\n *\n * @param[out] r\t\t\t- the resulting ciphertext.\n * @param[in] c\t\t\t\t- the first ciphertext as an integer to multiply.\n * @param[in] d\t\t\t\t- the second ciphertext as an integer to multiply.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_add(bn_t r, const bn_t c, const bn_t d, const bn_t pub);\n\n/**\n * Decrypts using the Paillier cryptosystem.\n *\n * @param[out] m\t\t\t- the plaintext, represented as an integer.\n * @param[in] c\t\t\t\t- the ciphertex as an integer.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_dec(bn_t m, const bn_t c, const phpe_t prv);\n\n/**\n * Generates a key pair for Paillier's Subgroup Homomorphic Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] sbits\t\t\t- the subgroup order in bits.\n * @param[in] nbits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_gen(shpe_t pub, shpe_t prv, size_t sbits, size_t nbits);\n\n/**\n * Encrypts using the Subgroup Paillier cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext, represented as an integer.\n * @param[in] m\t\t\t\t- the plaintext as an integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_enc(bn_t c, const bn_t m, const shpe_t pub);\n\n/**\n * Encrypts faster using the Subgroup Paillier cryptosystem if the private key is known.\n *\n * @param[out] c\t\t\t- the ciphertext represented as an integer.\n * @param[in] m\t\t\t\t- the plaintext as an integer.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_enc_prv(bn_t c, const bn_t m, const shpe_t prv);\n\n/**\n * Decrypts using the Subgroup Paillier cryptosystem.\n *\n * @param[out] m\t\t\t- the plaintext, represented as an integer.\n * @param[in] c\t\t\t\t- the ciphertex as an integer.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_dec(bn_t m, const bn_t c, const shpe_t prv);\n\n/**\n * Generates a key pair for Genealized Homomorphic Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ghpe_gen(bn_t pub, bn_t prv, size_t bits);\n\n/**\n * Encrypts using the Generalized Paillier cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext.\n * @param[in] m\t\t\t\t- the plaintext.\n * @param[in] pub\t\t\t- the public key.\n * @param[in] s\t\t\t\t- the block length parameter.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ghpe_enc(bn_t c, const bn_t m, const bn_t pub, size_t s);\n\n/**\n * Decrypts using the Generalized Paillier cryptosystem.\n *\n * @param[out] m\t\t\t- the plaintext.\n * @param[in] c\t\t\t\t- the ciphertext.\n * @param[in] pub\t\t\t- the public key.\n * @param[in] s\t\t\t\t- the block length parameter.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ghpe_dec(bn_t m, const bn_t c, const bn_t pub, const bn_t prv, size_t s);\n\n/**\n * Generates an ECDH key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdh_gen(bn_t d, ec_t q);\n\n/**\n * Derives a shared secret using ECDH.\n *\n * @param[out] key\t\t\t- the shared key.\n * @param[int] key_len\t\t- the intended shared key length in bytes.\n * @param[in] d\t\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the point received from the other party.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdh_key(uint8_t *key, size_t key_len, const bn_t d, const ec_t q);\n\n/**\n * Generate an ECMQV key pair.\n *\n * Should also be used to generate the ephemeral key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecmqv_gen(bn_t d, ec_t q);\n\n/**\n * Derives a shared secret using ECMQV.\n *\n * @param[out] key\t\t\t- the shared key.\n * @param[int] key_len\t\t- the intended shared key length in bytes.\n * @param[in] d1\t\t\t- the private key.\n * @param[in] d2\t\t\t- the ephemeral private key.\n * @param[in] q2u\t\t\t- the ephemeral public key.\n * @param[in] q1v\t\t\t- the point received from the other party.\n * @param[in] q2v\t\t\t- the ephemeral point received from the party.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecmqv_key(uint8_t *key, size_t key_len, const bn_t d1, const bn_t d2,\n\t\tconst ec_t q2u, const ec_t q1v, const ec_t q2v);\n\n/**\n * Generates an ECIES key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecies_gen(bn_t d, ec_t q);\n\n/**\n * Encrypts using the ECIES cryptosystem.\n *\n * @param[out] r\t\t\t- the resulting elliptic curve point.\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] iv\t\t\t- the block cipher initialization vector.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecies_enc(ec_t r, uint8_t *out, size_t *out_len, const uint8_t *in,\n\t\tsize_t in_len, const ec_t q);\n\n/**\n * Decrypts using the ECIES cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] iv\t\t\t- the block cipher initialization vector.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecies_dec(uint8_t *out, size_t *out_len, const ec_t r, const uint8_t *in,\n\t\tsize_t in_len, const bn_t d);\n\n/**\n * Generates an ECDSA key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdsa_gen(bn_t d, ec_t q);\n\n/**\n * Signs a message using ECDSA.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdsa_sig(bn_t r, bn_t s, const uint8_t *msg, size_t len, int hash,\n\t\tconst bn_t d);\n\n/**\n * Verifies a message signed with ECDSA using the basic method.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] q\t\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_ecdsa_ver(const bn_t r, const bn_t s, const uint8_t *msg, size_t len,\n\t\tint hash, const ec_t q);\n\n/**\n * Generates an Elliptic Curve Schnorr Signature key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecss_gen(bn_t d, ec_t q);\n\n/**\n * Signs a message using the Elliptic Curve Schnorr Signature.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecss_sig(bn_t e, bn_t s, const uint8_t *msg, size_t len, const bn_t d);\n\n/**\n * Verifies a message signed with the Elliptic Curve Schnorr Signature using the\n * basic method.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] q\t\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_ecss_ver(bn_t e, bn_t s, const uint8_t *msg, size_t len, const ec_t q);\n\n/**\n * Generate parameters for the DCKKS pairing delegation protocol described at\n * \"Secure and Efficient Delegationof Pairings with Online Inputs\" (CARDIS 2020)\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdpub_gen(bn_t c, bn_t r, g1_t u1, g2_t u2, g2_t v2, gt_t e);\n\n/**\n * Execute the client-side request for the DCKKS pairing delegation protocol.\n *\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdpub_ask(g1_t v1, g2_t w2, const g1_t p, const g2_t q, const bn_t c,\n\t\tconst bn_t r, const g1_t u1, const g2_t u2, const g2_t v2);\n\n/**\n * Execute the server-side response for the DCKKS pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdpub_ans(gt_t g[3], const g1_t p, const g2_t q, const g1_t v1,\n\t\tconst g2_t v2, const g2_t w2);\n\n/**\n * Verifies the result of the DCKKS pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_pdpub_ver(gt_t r, const gt_t g[3], const bn_t c, const gt_t e);\n\n/**\n * Generate parameters for the DCKKS pairing delegation protocol described at\n * \"Secure and Efficient Delegationof Pairings with Online Inputs\" (CARDIS 2020)\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdprv_gen(bn_t c, bn_t r[3], g1_t u1[2], g2_t u2[2], g2_t v2[4],\n\t\tgt_t e[2]);\n\n/**\n * Execute the client-side request for the DCKKS pairing delegation protocol.\n *\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdprv_ask(g1_t v1[3], g2_t w2[4], const g1_t p, const g2_t q,\n\t\tconst bn_t c, const bn_t r[3], const g1_t u1[2], const g2_t u2[2],\n\t\tconst g2_t v2[4]);\n\n/**\n * Execute the server-side response for the DCKKS pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdprv_ans(gt_t g[4], const g1_t v1[3], const g2_t w2[4]);\n\n/**\n * Verifies the result of the DCKKS pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_pdprv_ver(gt_t r, const gt_t g[4], const bn_t c, const gt_t e[2]);\n\n/**\n * Generate parameters for the LOVE pairing delegation protocol with public\n * inputs.\n *\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvpub_gen(bn_t r, g1_t u1, g2_t u2, g2_t v2, gt_t e);\n\n/**\n * Execute the client-side request for the LOVE pairing delegation protocol.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvpub_ask(bn_t c, g1_t v1, g2_t w2, const g1_t p, const g2_t q,\n\t\tconst bn_t r, const g1_t u1, const g2_t u2, const g2_t v2);\n\n/**\n * Execute the server-side response for the LOVE pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvpub_ans(gt_t g[2], const g1_t p, const g2_t q, const g1_t v1,\n\t\tconst g2_t v2, const g2_t w2);\n\n/**\n * Verifies the result of the LOVE pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_lvpub_ver(gt_t r, const gt_t g[2], const bn_t c, const gt_t e);\n\n/**\n * Generate parameters for the LOVE pairing delegation protocol with private\n * inputs.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvprv_gen(bn_t c, bn_t r[3], g1_t u1[2], g2_t u2[2], g2_t v2[4],\n\t\tgt_t e[2]);\n\n/**\n * Execute the client-side request for the LOVE pairing delegation protocol.\n *\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvprv_ask(g1_t v1[3], g2_t w2[4], const g1_t p, const g2_t q,\n\t\tconst bn_t c, const bn_t r[3], const g1_t u1[2], const g2_t u2[2],\n\t\tconst g2_t v2[4]);\n\n/**\n * Execute the server-side response for the LOVE pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvprv_ans(gt_t g[4], const g1_t v1[3], const g2_t w2[4]);\n\n/**\n * Verifies the result of the LOVE pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_lvprv_ver(gt_t r, const gt_t g[4], const bn_t c, const gt_t e[2]);\n\n/**\n * Generates a master key for the SOKAKA identity-based non-interactive\n * authenticated key agreement protocol.\n *\n * @param[out] master\t\t\t- the master key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokaka_gen(bn_t master);\n\n/**\n * Generates a private key for the SOKAKA protocol.\n *\n * @param[out] k\t\t\t- the private key.\n * @param[in] id\t\t\t- the identity.\n * @param[in] master\t\t- the master key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokaka_gen_prv(sokaka_t k, const char *id, bn_t master);\n\n/**\n * Computes a shared key between two entities.\n *\n * @param[out] key\t\t\t- the shared key.\n * @param[int] key_len\t\t- the intended shared key length in bytes.\n * @param[in] id1\t\t\t- the first identity.\n * @param[in] k\t\t\t\t- the private key of the first identity.\n * @param[in] id2\t\t\t- the second identity.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokaka_key(uint8_t *key, size_t key_len, const char *id1,\n\t\tconst sokaka_t k, const char *id2);\n\n/**\n * Generates a key pair for the Boneh-Go-Nissim (BGN) cryptosystem.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_gen(bgn_t pub, bgn_t prv);\n\n/**\n * Encrypts in G_1 using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the ciphertext.\n * @param[in] in\t\t\t- the plaintext as a small integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_enc1(g1_t out[2], const dig_t in, const bgn_t pub);\n\n/**\n * Decrypts in G_1 using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] in\t\t\t- the ciphertext.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_dec1(dig_t *out, const g1_t in[2], const bgn_t prv);\n\n/**\n * Encrypts in G_2 using the BGN cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext.\n * @param[in] m\t\t\t\t- the plaintext as a small integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_enc2(g2_t out[2], const dig_t in, const bgn_t pub);\n\n/**\n * Decrypts in G_2 using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] c\t\t\t\t- the ciphertext.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_dec2(dig_t *out, const g2_t in[2], const bgn_t prv);\n\n/**\n * Adds homomorphically two BGN ciphertexts in G_T.\n *\n * @param[out] e\t\t\t- the resulting ciphertext.\n * @param[in] c\t\t\t\t- the first ciphertext to add.\n * @param[in] d\t\t\t\t- the second ciphertext to add.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_add(gt_t e[4], const gt_t c[4], const gt_t d[4]);\n\n/**\n * Multiplies homomorphically two BGN ciphertexts in G_T.\n *\n * @param[out] e\t\t\t- the resulting ciphertext.\n * @param[in] c\t\t\t\t- the first ciphertext to add.\n * @param[in] d\t\t\t\t- the second ciphertext to add.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_mul(gt_t e[4], const g1_t c[2], const g2_t d[2]);\n\n/**\n * Decrypts in G_T using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] c\t\t\t\t- the ciphertext.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_dec(dig_t *out, const gt_t in[4], const bgn_t prv);\n\n/**\n * Generates a master key for a Private Key Generator (PKG) in the\n * Boneh-Franklin Identity-Based Encryption (BF-IBE).\n *\n * @param[out] master\t\t- the master key.\n * @param[out] pub\t\t\t- the public key of the private key generator.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_gen(bn_t master, g1_t pub);\n\n/**\n * Generates a private key for a user in the BF-IBE protocol.\n *\n * @param[out] prv\t\t\t- the private key.\n * @param[in] id\t\t\t- the identity.\n * @param[in] s\t\t\t\t- the master key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_gen_prv(g2_t prv, const char *id, const bn_t master);\n\n/**\n * Encrypts a message using the BF-IBE protocol.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] id\t\t\t- the identity.\n * @param[in] pub\t\t\t- the public key of the PKG.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_enc(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst char *id, const g1_t pub);\n\n/**\n * Decrypts a message using the BF-IBE protocol.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to decrypt.\n * @param[in] pub\t\t\t- the private key of the user.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst g2_t prv);\n\n/**\n * Generates a key pair for the Boneh-Lynn-Schacham (BLS) signature protocol.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bls_gen(bn_t d, g2_t q);\n\n/**\n * Signs a message using the BLS protocol.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bls_sig(g1_t s, const uint8_t *msg, int len, const bn_t d);\n\n/**\n * Verifies a message signed with BLS protocol.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] q\t\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_bls_ver(const g1_t s, const uint8_t *msg, size_t len, const g2_t q);\n\n/**\n * Generates a key pair for the Boneh-Boyen (BB) signature protocol.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bbs_gen(bn_t d, g2_t q, gt_t z);\n\n/**\n * Signs a message using the BB protocol.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bbs_sig(g1_t s, const uint8_t *msg, size_t len, int hash, const bn_t d);\n\n/**\n * Verifies a message signed with the BB protocol.\n *\n * @param[in] s\t\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_bbs_ver(g1_t s, const uint8_t *msg, size_t len, int hash, const g2_t q,\n\t\tconst gt_t z);\n\n/**\n * Generates a key pair for the Camenisch-Lysyanskaya simple signature (CLS)\n * protocol.\n *\n * @param[out] u\t\t\t- the first part of the private key.\n * @param[out] v\t\t\t- the second part of the private key.\n * @param[out] x\t\t\t- the first part of the public key.\n * @param[out] y\t\t\t- the second part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cls_gen(bn_t u, bn_t v, g2_t x, g2_t y);\n\n/**\n * Signs a message using the CLS protocol.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[out] c\t\t\t- the third part of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] u\t\t\t\t- the first part of the private key.\n * @param[in] v\t\t\t\t- the second part of the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cls_sig(g1_t a, g1_t b, g1_t c, const uint8_t *msg, size_t len,\n\t\tconst bn_t u, const bn_t v);\n\n/**\n ** Verifies a signature using the CLS protocol.\n *\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] c\t\t\t\t- the third part of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] u\t\t\t\t- the first part of the public key.\n * @param[in] v\t\t\t\t- the second part of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_cls_ver(const g1_t a, const g1_t b, const g1_t c, const uint8_t *msg,\n\t\tsize_t len, const g2_t x, const g2_t y);\n\n/**\n * Generates a key pair for the Camenisch-Lysyanskaya message-independent (CLI)\n * signature protocol.\n *\n * @param[out] t\t\t\t- the first part of the private key.\n * @param[out] u\t\t\t- the second part of the private key.\n * @param[out] v\t\t\t- the third part of the private key.\n * @param[out] x\t\t\t- the first part of the public key.\n * @param[out] y\t\t\t- the second part of the public key.\n * @param[out] z\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cli_gen(bn_t t, bn_t u, bn_t v, g2_t x, g2_t y, g2_t z);\n\n/**\n * Signs a message using the CLI protocol.\n *\n * @param[out] a\t\t\t- one of the components of the signature.\n * @param[out] A\t\t\t- one of the components of the signature.\n * @param[out] b\t\t\t- one of the components of the signature.\n * @param[out] B\t\t\t- one of the components of the signature.\n * @param[out] c\t\t\t- one of the components of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] r\t\t\t\t- the per-message randomness.\n * @param[in] t\t\t\t\t- the first part of the private key.\n * @param[in] u\t\t\t\t- the second part of the private key.\n * @param[in] v\t\t\t\t- the third part of the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cli_sig(g1_t a, g1_t A, g1_t b, g1_t B, g1_t c, const uint8_t *msg,\n\t\tsize_t len, const bn_t r, const bn_t t, const bn_t u, const bn_t v);\n\n/**\n * Verifies a message signed using the CLI protocol.\n *\n * @param[in] a\t\t\t\t- one of the components of the signature.\n * @param[in] A\t\t\t\t- one of the components of the signature.\n * @param[in] b\t\t\t\t- one of the components of the signature.\n * @param[in] B\t\t\t\t- one of the components of the signature.\n * @param[in] c\t\t\t\t- one of the components of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] r\t\t\t\t- the per-message randomness.\n * @param[in] x\t\t\t\t- the first part of the public key.\n * @param[in] y\t\t\t\t- the second part of the public key.\n * @param[in] z\t\t\t\t- the third part of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_cli_ver(g1_t a, g1_t A, g1_t b, g1_t B, g1_t c, const uint8_t *msg,\n\t\tsize_t len, const bn_t r, const g2_t x, const g2_t y, const g2_t z);\n\n/**\n * Generates a key pair for the Camenisch-Lysyanskaya message-block (CLB)\n * signature protocol.\n *\n * @param[out] t\t\t\t- the first part of the private key.\n * @param[out] u\t\t\t- the second part of the private key.\n * @param[out] v\t\t\t- the remaining (l - 1) parts of the private key.\n * @param[out] x\t\t\t- the first part of the public key.\n * @param[out] y\t\t\t- the second part of the public key.\n * @param[out] z\t\t\t- the remaining (l - 1) parts of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_clb_gen(bn_t t, bn_t u, bn_t v[], g2_t x, g2_t y, g2_t z[], size_t l);\n\n/**\n * Signs a block of messages using the CLB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] A\t\t\t- the (l - 1) next components of the signature.\n * @param[out] b\t\t\t- the next component of the signature.\n * @param[out] B\t\t\t- the (l - 1) next components of the signature.\n * @param[out] c\t\t\t- the last component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] ls\t\t\t- the l message lengths in bytes.\n * @param[in] t\t\t\t\t- the first part of the private key.\n * @param[in] u\t\t\t\t- the second part of the private key.\n * @param[in] v\t\t\t\t- the remaining (l - 1) parts of the private key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_clb_sig(g1_t a, g1_t A[], g1_t b, g1_t B[], g1_t c, const uint8_t *ms[],\n\t\tconst size_t ls[], const bn_t t, const bn_t u, const bn_t v[],\n\t\tconst size_t l);\n\n/**\n * Verifies a block of messages signed using the CLB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] A\t\t\t- the (l - 1) next components of the signature.\n * @param[out] b\t\t\t- the next component of the signature.\n * @param[out] B\t\t\t- the (l - 1) next components of the signature.\n * @param[out] c\t\t\t- the last component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] ls\t\t\t- the l message lengths in bytes.\n * @param[in] x\t\t\t\t- the first part of the public key.\n * @param[in] y\t\t\t\t- the second part of the public key.\n * @param[in] z\t\t\t\t- the remaining (l - 1) parts of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return a boolean value indicating the verification result.\n */\nint cp_clb_ver(const g1_t a, const g1_t A[], const g1_t b, const g1_t B[],\n \t\tconst g1_t c, const uint8_t *ms[], const size_t ls[], const g2_t x,\n \t\tconst g2_t y, const g2_t z[], size_t l);\n\n/**\n * Generates a key pair for the Pointcheval-Sanders simple signature (PSS)\n * protocol.\n *\n * @param[out] u\t\t\t- the first part of the private key.\n * @param[out] v\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the secpmd part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pss_gen(bn_t u, bn_t v, g2_t g, g2_t x, g2_t y);\n\n/**\n * Signs a message using the PSS protocol.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] u\t\t\t\t- the first part of the private key.\n * @param[in] v\t\t\t\t- the second part of the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pss_sig(g1_t a, g1_t b, const bn_t m, const bn_t u, const bn_t v);\n\n/**\n ** Verifies a signature using the PSS protocol.\n *\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] u\t\t\t\t- the second part of the public key.\n * @param[in] v\t\t\t\t- the third part of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_pss_ver(const g1_t a, const g1_t b, const bn_t m, const g2_t g,\n\t\tconst g2_t x, const g2_t y);\n\n/**\n * Generates a key pair for the multi-part version of the Pointcheval-Sanders\n * simple signature (MPSS) protocol.\n *\n * @param[out] r\t\t\t- the first part of the private key.\n * @param[out] s\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the second part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpss_gen(bn_t r[2], bn_t s[2], g2_t g, g2_t x[2], g2_t y[2]);\n\n/**\n * Signs a message using the MPSS protocol operating over shares using triples.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] r\t\t\t\t- the first part of the private key.\n * @param[in] s\t\t\t\t- the second part of the private key.\n * @param[in] mul_tri\t\t- the triple for the multiplication.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpss_sig(g1_t a, g1_t b[2], const bn_t m[2], const bn_t r[2],\n\t\tconst bn_t s[2], const mt_t mul_tri[2], const mt_t sm_tri[2]);\n\n/**\n * Opens public values in the MPSS protocols, in this case public keys.\n *\n * @param[in,out] x\t\t\t- the shares of the second part of the public key.\n * @param[in,out] y\t\t\t- the shares of the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpss_bct(g2_t x[2], g2_t y[2]);\n\n/**\n * Verifies a signature using the MPSS protocol operating over shares using\n * triples.\n *\n * @param[out] e\t\t\t- the result of the verification.\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] x\t\t\t\t- the second part of the public key.\n * @param[in] y\t\t\t\t- the third part of the public key.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @param[in] pc_tri\t\t- the triple for the pairing computation.\n * @return a boolean value indicating the verification result.\n */\nint cp_mpss_ver(gt_t e, const g1_t a, const g1_t b[2], const bn_t m[2],\n\t\tconst g2_t h, const g2_t x, const g2_t y, const mt_t sm_tri[2],\n\t\tconst pt_t pc_tri[2]);\n\n/**\n * Generates a key pair for the Pointcheval-Sanders block signature (PSB)\n * protocol.\n *\n * @param[out] r\t\t\t- the first part of the private key.\n * @param[out] s\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the secpmd part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_psb_gen(bn_t r, bn_t s[], g2_t g, g2_t x, g2_t y[], size_t l);\n\n/**\n * Signs a block of messages using the PSB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] b\t\t\t- the second component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] r\t\t\t\t- the first part of the private key.\n * @param[in] s\t\t\t\t- the remaining l part of the private key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_psb_sig(g1_t a, g1_t b, const bn_t ms[], const bn_t r, const bn_t s[],\n\t\tsize_t l);\n\n/**\n * Verifies a block of messages signed using the PSB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] b\t\t\t- the seconed component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] x\t\t\t\t- the second part of the public key.\n * @param[in] y\t\t\t\t- the remaining l parts of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return a boolean value indicating the verification result.\n */\nint cp_psb_ver(const g1_t a, const g1_t b, const bn_t ms[], const g2_t g,\n\t\tconst g2_t x, const g2_t y[], size_t l);\n\n/**\n * Generates a key pair for the multi-part version of the Pointcheval-Sanders\n * simple signature (MPSS) protocol.\n *\n * @param[out] r\t\t\t- the first part of the private key.\n * @param[out] s\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the second part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpsb_gen(bn_t r[2], bn_t s[][2], g2_t h, g2_t x[2], g2_t y[][2],\n\t\tsize_t l);\n\n/**\n * Signs a message using the MPSS protocol operating over shares using triples.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the messages to sign.\n * @param[in] r\t\t\t\t- the first part of the private key.\n * @param[in] s\t\t\t\t- the second parts of the private key.\n * @param[in] mul_tri\t\t- the triple for the multiplication.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpsb_sig(g1_t a, g1_t b[2], const bn_t m[][2], const bn_t r[2],\n\t\tconst bn_t s[][2], const mt_t mul_tri[2], const mt_t sm_tri[2],\n\t\tsize_t l);\n\n/**\n * Opens public values in the MPSS protocols, in this case public keys.\n *\n * @param[in,out] x\t\t\t- the shares of the second part of the public key.\n * @param[in,out] y\t\t\t- the shares of the third part of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpsb_bct(g2_t x[2], g2_t y[][2], size_t l);\n\n/**\n * Verifies a signature using the MPSS protocol operating over shares using\n * triples.\n *\n * @param[out] e\t\t\t- the result of the verification.\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the messages to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] x\t\t\t\t- the second part of the public key.\n * @param[in] y\t\t\t\t- the third parts of the public key.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @param[in] pc_tri\t\t- the triple for the pairing computation.\n * @param[in] v\t\t\t\t- the private keys, can be NULL.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return a boolean value indicating the verification result.\n */\nint cp_mpsb_ver(gt_t e, const g1_t a, const g1_t b[2], const bn_t m[][2],\n\t\tconst g2_t h, const g2_t x, const g2_t y[][2], const bn_t v[][2],\n\t\tconst mt_t sm_tri[2], const pt_t pc_tri[2], size_t l);\n\n/**\n * Generates a Zhang-Safavi-Naini-Susilo (ZSS) key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n */\nint cp_zss_gen(bn_t d, g1_t q, gt_t z);\n\n/**\n * Signs a message using ZSS scheme.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_zss_sig(g2_t s, const uint8_t *msg, size_t len, int hash, const bn_t d);\n\n/**\n * Verifies a message signed with ZSS scheme.\n *\n * @param[in] s\t\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_zss_ver(const g2_t s, const uint8_t *msg, size_t len, int hash,\n\t\tconst g1_t q, const gt_t z);\n\n/**\n * Generates a vBNN-IBS key generation center (KGC).\n *\n * @param[out] msk\t\t\t- the KGC master key.\n * @param[out] mpk\t\t\t- the KGC public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_gen(bn_t msk, ec_t mpk);\n\n/**\n * Extract a user key from an identity and a vBNN-IBS key generation center.\n *\n * @param[out] sk\t\t\t- the extracted vBNN-IBS user private key.\n * @param[out] pk\t\t\t- the extracted vBNN-IBS user public key.\n * @param[in] msk\t\t\t- the KGC master key.\n * @param[in] id\t\t\t- the identity used for extraction.\n * @param[in] id_len\t\t- the identity length in bytes.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,\n\t\tsize_t id_len);\n\n/**\n * Signs a message using the vBNN-IBS scheme.\n *\n * @param[out] r\t\t\t- the R value of the signature.\n * @param[out] z\t\t\t- the z value of the signature.\n * @param[out] h\t\t\t- the h value of the signature.\n * @param[in] id\t\t\t- the identity buffer.\n * @param[in] id_len\t\t- the size of identity buffer.\n * @param[in] msg\t\t\t- the message buffer to sign.\n * @param[in] msg_len\t\t- the size of message buffer.\n * @param[in] sk\t\t\t- the signer private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,\n\t\tconst uint8_t *msg, int msg_len, const bn_t sk, const ec_t pk);\n\n/**\n * Verifies a signature and message using the vBNN-IBS scheme.\n *\n * @param[in] r\t\t\t\t- the R value of the signature.\n * @param[in] z\t\t\t\t- the z value of the signature.\n * @param[in] h\t\t\t\t- the h value of the signature.\n * @param[in] id\t\t\t- the identity buffer.\n * @param[in] id_len\t\t- the size of identity buffer.\n * @param[in] msg\t\t\t- the message buffer to sign.\n * @param[in] msg_len\t\t- the size of message buffer.\n * @param[in] mpk\t\t\t- the master public key of the generation center.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_ver(const ec_t r, const bn_t z, const bn_t h, const uint8_t *id,\n\t\tsize_t id_len, const uint8_t *msg, int msg_len, const ec_t mpk);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y = [x]G.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the response.\n * @param[in] y\t\t\t\t- the elliptic curve point\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pokdl_prv(bn_t c, bn_t r, const ec_t y, const bn_t x);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the response.\n * @param[in] y\t\t\t\t- the elliptic curve point.\n * @return a boolean value indicating the verification result.\n */\nint cp_pokdl_ver(const bn_t c, const bn_t r, const ec_t y);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y0 = [x]G or y[1] = [x]G.\n *\n * @param[out] c\t\t\t- the challenges.\n * @param[out] r\t\t\t- the responses.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pokor_prv(bn_t c[2], bn_t r[2], const ec_t y[2], const bn_t x);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenges.\n * @param[in] r\t\t\t\t- the responses.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @return a boolean value indicating the verification result.\n */\nint cp_pokor_ver(const bn_t c[2], const bn_t r[2], const ec_t y[2]);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y = [x]G.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the response.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve point\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokdl_sig(bn_t c, bn_t r, const uint8_t *msg, size_t len, const ec_t y,\n\t\tconst bn_t x);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the response.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve point.\n * @return a boolean value indicating the verification result.\n */\nint cp_sokdl_ver(const bn_t c, const bn_t r, const uint8_t *msg, size_t len,\n\t\tconst ec_t y);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y0 = [x]G or y1 = [x]G.\n *\n * @param[out] c\t\t\t- the challenges.\n * @param[out] r\t\t\t- the responses.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @param[in] g\t\t\t\t- the elliptic curve generators.\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @param[in] first\t\t\t- the flag to indicate the point for which the\n *\t\t\t\t\t\t\t  discrete logarithm is known.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokor_sig(bn_t c[2], bn_t r[2], const uint8_t *msg, size_t len,\n\t\tconst ec_t y[2], const ec_t g[2], const bn_t x, int first);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenges.\n * @param[in] r\t\t\t\t- the responses.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @param[in] g\t\t\t\t- the elliptic curve generators.\n * @return a boolean value indicating the verification result.\n */\nint cp_sokor_ver(const bn_t c[2], const bn_t r[2], const uint8_t *msg,\n\t\tsize_t len, const ec_t y[2], const ec_t g[2]);\n\n/**\n * Generates the public parameters of the extendable ring signature.\n *\n * @\u00e5aram[out] pp\t\t\t- the public parameters.\n */\nint cp_ers_gen(ec_t pp);\n\n/**\n * Generates a key pair for the extendable ring signature.\n *\n * @\u00e5aram[out] sk\t\t\t- the private key.\n * @param[out] pk\t\t\t- the public key.\n */\nint cp_ers_gen_key(bn_t sk, ec_t pk);\n\n/**\n * Signs a message using the extendable ring signature scheme.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[out] p\t\t\t- the resulting signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_ers_sig(bn_t td, ers_t p, const uint8_t *msg, size_t len, const bn_t sk,\n\t\tconst ec_t pk, const ec_t pp);\n\n/**\n * Verifies an extendable ring signature scheme over some messages.\n *\n * @param[in] td\t\t\t- the signature trapdoor.\n * @param[in] s\n - the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_ers_ver(const bn_t td, const ers_t *s, size_t size, const uint8_t *msg,\n\t\tsize_t len, const ec_t pp);\n\n/**\n * Extends an extendable ring signature with a new signature.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_ers_ext(bn_t td, ers_t *p, size_t *size, const uint8_t *msg, size_t len,\n\t\tconst ec_t pk, const ec_t pp);\n\n/**\n * Signs a message using the same-message linkable extendable ring signature\n * scheme.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[out] p\t\t\t- the resulting signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_smlers_sig(bn_t td, smlers_t p, const uint8_t *msg, size_t len,\n\t\tconst bn_t sk, const ec_t pk, const ec_t pp);\n\n/**\n * Verifies a same-message linkable extendable ring signature.\n *\n * @param[in] td\t\t\t- the signature trapdoor.\n * @param[in] s\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_smlers_ver(bn_t td, smlers_t *s, size_t size, const uint8_t *msg,\n\t\tsize_t len, const ec_t pp);\n\n/**\n * Extends a same-message extendable ring signature with a new signature.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_smlers_ext(bn_t td, smlers_t *p, size_t *size, const uint8_t *msg,\n\t\tsize_t len, const ec_t pk, const ec_t pp);\n\n/**\n * Signs a message using the extendable threshold ring signature scheme.\n *\n * @param[out] td\t\t\t- the signature trapdoors.\n * @param[out] y\t\t\t- the signature randomness.\n * @param[out] max\t\t\t- the maximum number of extensions.\n * @param[out] p\t\t\t- the resulting signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_sig(bn_t *td, bn_t *y, size_t max, etrs_t p, const uint8_t *msg,\n\t\tsize_t len, const bn_t sk, const ec_t pk, const ec_t pp);\n\n/**\n * Verifies an extendable threshold ring signature scheme over some messages.\n *\n * @param[in] thres\t\t\t- the specified threshold.\n * @param[in] td\t\t\t- the signature trapdoors.\n * @param[in] y\t\t\t\t- the signature randomness.\n * @param[in] max\t\t\t- the maximum number of extensions.\n * @param[in] s\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_ver(size_t thres, const bn_t *td, const bn_t *y, size_t max,\n\t\tconst etrs_t *s, size_t size, const uint8_t *msg, size_t len,\n\t\tconst ec_t pp);\n\n/**\n * Extends an extendable threshold ring signature with a new signature.\n *\n * @param[out] td\t\t\t- the signature trapdoors.\n * @param[in] y\t\t\t\t- the signature randomness.\n * @param[in] max\t\t\t- the maximum number of extensions.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_ext(bn_t *td, bn_t *y, size_t max, etrs_t *p, size_t *size,\n\t\tconst uint8_t *msg, size_t len, const ec_t pk, const ec_t pp);\n/**\n * Joins an extendable threshold ring signature with a new signature.\n *\n * @param[in] thres\t\t\t- the specified threshold.\n * @param[in] td\t\t\t- the signature trapdoors.\n * @param[in] y\t\t\t\t- the signature randomness.\n * @param[in] max\t\t\t- the maximum number of extensions.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_uni(int thres, bn_t *td, bn_t *y, int max, etrs_t *p, size_t *size,\n\t\tconst uint8_t *msg, size_t len, const bn_t sk, const ec_t pk,\n\t\tconst ec_t pp);\n/**\n * Initialize the Context-hiding Multi-key Homomorphic Signature scheme (CMLHS).\n * The scheme due to Schabhuser et al. signs a vector of messages.\n *\n * @param[out] h\t\t\t- the random element (message as one component).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_init(g1_t h);\n\n/**\n * Generates a key pair for the CMLHS scheme using BLS as underlying signature.\n *\n * @param[out] x\t\t\t- the exponent values, one per label.\n * @param[out] hs\t\t\t- the hash values, one per label.\n * @param[in] len\t\t\t- the number of possible labels.\n * @param[out] prf\t\t\t- the key for the pseudo-random function (PRF).\n * @param[out] plen\t\t\t- the PRF key length.\n * @param[out] sk\t\t\t- the private key for the BLS signature scheme.\n * @param[out] pk\t\t\t- the public key for the BLS signature scheme.\n * @param[out] d\t\t\t- the secret exponent.\n * @param[out] y\t\t\t- the corresponding public element.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,\n\t\tbn_t sk, g2_t pk, bn_t d, g2_t y, int bls);\n\n/**\n * Signs a message vector using the CMLHS.\n *\n * @param[out] sig\t\t\t- the resulting BLS signature.\n * @param[out] z\t\t\t- the power of the output of the PRF.\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] c\t\t\t- the second component of the signature.\n * @param[out] r\t\t\t- the third component of the signature.\n * @param[out] s\t\t\t- the fourth component of the signature.\n * @param[in] msg\t\t\t- the message vector to sign (one component).\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] label\t\t\t- the integer label.\n * @param[in] x\t\t\t\t- the exponent value for the label.\n * @param[in] h\t\t\t\t- the random value (message has one component).\n * @param[in] prf\t\t\t- the key for the pseudo-random function (PRF).\n * @param[in] plen\t\t\t- the PRF key length.\n * @param[in] sk\t\t\t- the private key for the signature scheme.\n * @param[in] d\t\t\t\t- the secret exponent.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_sig(g1_t sig, g2_t z, g1_t a, g1_t c, g1_t r, g2_t s,\n\t\tconst bn_t msg, const char *data, int label, const bn_t x, const g1_t h,\n\t\tconst uint8_t prf[], size_t plen, const bn_t sk, const bn_t d, int bls);\n\n/**\n * Applies a function over a set of CMLHS signatures from the same user.\n *\n * @param[out] a\t\t\t- the resulting first component of the signature.\n * @param[out] c\t\t\t- the resulting second component of the signature.\n * @param[in] as\t\t\t- the vector of first components of the signatures.\n * @param[in] cs\t\t\t- the vector of second components of the signatures.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_fun(g1_t a, g1_t c, const g1_t as[], const g1_t cs[],\n\t\tconst dig_t f[], size_t len);\n\n/**\n * Evaluates a function over a set of CMLHS signatures.\n *\n * @param[out] r\t\t\t- the resulting third component of the signature.\n * @param[out] s\t\t\t- the resulting fourth component of the signature.\n * @param[in] rs\t\t\t- the vector of third components of the signatures.\n * @param[in] ss\t\t\t- the vector of fourth components of the signatures.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_evl(g1_t r, g2_t s, const g1_t rs[], const g2_t ss[],\n\t\tconst dig_t f[], size_t len);\n\n/**\n * Verifies a CMLHS signature over a set of messages.\n *\n * @param[in] r\t\t\t\t- the first component of the homomorphic signature.\n * @param[in] s\t\t\t\t- the second component of the homomorphic signature.\n * @param[in] sig\t\t\t- the BLS signatures.\n * @param[in] z\t\t\t\t- the powers of the outputs of the PRF.\n * @param[in] a\t\t\t\t- the vector of first components of the signatures.\n * @param[in] c\t\t\t\t- the vector of second components of the signatures.\n * @param[in] msg\t\t\t- the combined message.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] h\t\t\t\t- the random element (message has one component).\n * @param[in] label\t\t\t- the integer labels.\n * @param[in] hs\t\t\t- the hash values, one per label.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] y\t\t\t\t- the public elements of the users.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return a boolean value indicating the verification result.\n */\nint cp_cmlhs_ver(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t m, const char *data,\n\t\tconst g1_t h, const int label[], const gt_t * hs[], const dig_t *f[],\n\t\tconst size_t flen[], const g2_t y[], const g2_t pk[], size_t slen,\n\t\tint bls);\n\n/**\n * Perform the offline verification of a CMLHS signature over a set of messages.\n *\n * @param[out] vk\t\t\t- the verification key.\n * @param[in] h\t\t\t\t- the random element (message has one component).\n * @param[in] label\t\t\t- the integer labels.\n * @param[in] hs\t\t\t- the hash values, one per label.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] y\t\t\t\t- the public elements of the users.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return a boolean value indicating the verification result.\n */\nvoid cp_cmlhs_off(gt_t vk, const g1_t h, const int label[], const gt_t *hs[],\n\t\tconst dig_t *f[], const size_t flen[], size_t slen);\n\n/**\n * Perform the online verification of a CMLHS signature over a set of messages.\n *\n * @param[in] r\t\t\t\t- the first component of the homomorphic signature.\n * @param[in] s\t\t\t\t- the second component of the homomorphic signature.\n * @param[in] sig\t\t\t- the BLS signatures.\n * @param[in] z\t\t\t\t- the powers of the outputs of the PRF.\n * @param[in] a\t\t\t\t- the vector of first components of the signatures.\n * @param[in] c\t\t\t\t- the vector of second components of the signatures.\n * @param[in] msg\t\t\t- the combined message.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] h\t\t\t\t- the random element (message has one component).\n * @param[in] vk\t\t\t- the verification key.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return a boolean value indicating the verification result.\n */\nint cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls);\n/**\n * Generates a key pair for the Multi-Key Homomorphic Signature (MKLHS) scheme.\n *\n * @param[out] sk\t\t\t- the private key for the signature scheme.\n * @param[out] pk\t\t\t- the public key for the signature scheme.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_gen(bn_t sk, g2_t pk);\n\n/**\n * Signs a message using the MKLHS.\n *\n * @param[out] s\t\t\t- the resulting signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] id\t\t\t- the identity.\n * @param[in] tag\t\t\t- the tag.\n * @param[in] sk\t\t\t- the private key for the signature scheme.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_sig(g1_t s, const bn_t m, const char *data, const char *id,\n\t\tconst char *tag, const bn_t sk);\n\n/**\n * Applies a function over a set of messages from the same user.\n *\n * @param[out] mu\t\t\t- the combined message.\n * @param[in] m\t\t\t\t- the vector of individual messages.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_fun(bn_t mu, const bn_t m[], const dig_t f[], size_t len);\n\n/**\n * Evaluates a function over a set of MKLHS signatures.\n *\n * @param[out] sig\t\t\t- the resulting signature.\n * @param[in] s\t\t\t\t- the set of signatures.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_evl(g1_t sig, const g1_t s[], const dig_t f[], size_t len);\n\n/**\n * Verifies a MKLHS signature over a set of messages.\n *\n * @param[in] sig\t\t\t- the homomorphic signature to verify.\n * @param[in] m\t\t\t\t- the signed message.\n * @param[in] mu\t\t\t- the vector of signed messages per user.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] id\t\t\t- the vector of identities.\n * @param[in] tag\t\t\t- the vector of tags.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return a boolean value indicating the verification result.\n */\nint cp_mklhs_ver(const g1_t sig, const bn_t m, const bn_t mu[],\n\t\tconst char *data, const char *id[], const char *tag[], const dig_t *f[],\n\t\tconst size_t flen[], const g2_t pk[], size_t slen);\n\n/**\n * Computes the offline part of veryfying a MKLHS signature over a set of\n * messages.\n *\n * @param[out] h\t\t\t- the hashes of labels\n * @param[out] ft\t\t\t- the precomputed linear coefficients.\n * @param[in] id\t\t\t- the vector of identities.\n * @param[in] tag\t\t\t- the vector of tags.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_off(g1_t h[], dig_t ft[], const char *id[], const char *tag[],\n\t\tconst dig_t *f[], const size_t flen[], size_t slen);\n\n/**\n * Computes the online part of veryfying a MKLHS signature over a set of\n * messages.\n *\n * @param[in] sig\t\t\t- the homomorphic signature to verify.\n * @param[in] m\t\t\t\t- the signed message.\n * @param[in] mu\t\t\t- the vector of signed messages per user.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] id\t\t\t- the vector of identities.\n * @param[in] d\t\t\t\t- the hashes of labels.\n * @param[in] ft\t\t\t- the precomputed linear coefficients.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return a boolean value indicating the verification result.\n */\nint cp_mklhs_onv(const g1_t sig, const bn_t m, const bn_t mu[],\n\t\tconst char *data, const char *id[], const g1_t h[], const dig_t ft[],\n\t\tconst g2_t pk[], size_t slen);\n\n/**\n * Generates the trusted setup parameters for the factoring-based laconic\n * Private Set Intersection (RSA-PSI) protocol.\n *\n * @param[out] g\t\t\t- the generator.\n * @param[out] n\t\t\t- the modulus.\n * @param[in] bits\t\t\t- the precision in bits.\n */\nint cp_rsapsi_gen(bn_t g, bn_t n, size_t bits);\n\n/**\n * Computes the receiver part of the RSA-PSI protocol, given its input set.\n *\n * @param[out] d\t\t\t- the resulting accumulator.\n * @param[out] r\t\t\t- the random nonce.\n * @param[out] p\t\t\t- the mapping of elements to prime numbers.\n * @param[in] g\t\t\t\t- the generator given by the trusted setup.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n */\nint cp_rsapsi_ask(bn_t d, bn_t r, bn_t p[], const bn_t g, const bn_t n,\n\t\tconst bn_t x[], size_t m);\n\n/**\n * Computes the sender part of the RSA-PSI protocol, given its input set.\n *\n * @param[out] t\t\t\t- the accumulator results.\n * @param[out] u\t\t\t- the missing elements in the exponent.\n * @param[in] d\t\t\t\t- the receiver's accumulator.\n * @param[in] g\t\t\t\t- the generator given by the trusted setup.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] y\t\t\t\t- the server's input set.\n * @param[in] l\t\t\t\t- the sender's input set size.\n */\nint cp_rsapsi_ans(bn_t t[], bn_t u[], const bn_t d, const bn_t g, const bn_t n,\n\t\tconst bn_t y[], size_t l);\n\n/**\n * Computes the intersection as the final part of the RSA-PSI protocol.\n *\n * @param[out] z\t\t\t- the elements in the intersection.\n * @param[out] len\t\t\t- the cardinality of the resulting intersection.\n * @param[in] r\t\t\t\t- the random nonce.\n * @param[in] p\t\t\t\t- the mapping of elements to prime numbers.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n * @param[in] t\t\t\t\t- the accumulator results.\n * @param[in] u\t\t\t\t- the missing elements in the exponent.\n * @param[in] l\t\t\t\t- the sender's input set size.\n */\nint cp_rsapsi_int(bn_t z[], size_t *len, const bn_t r, const bn_t p[],\n\t\tconst bn_t n, const bn_t x[], const size_t m, const bn_t t[],\n\t\tconst bn_t u[], size_t l);\n\n/**\n * Generates the trusted setup parameters for the factoring-based size-hiding\n * Private Set Intersection (SHI-PSI) protocol.\n *\n * @param[out] g\t\t\t- the generator.\n * @param[in] crt\t\t\t- the parameters given by the trusted setup.\n * @param[in] bits\t\t\t- the precision in bits.\n */\nint cp_shipsi_gen(bn_t g, crt_t crt, size_t bits);\n\n/**\n * Computes the receiver part of the SHI-PSI protocol, given its input set.\n *\n * @param[out] d\t\t\t- the resulting accumulator.\n * @param[out] r\t\t\t- the random nonce.\n * @param[out] p\t\t\t- the mapping of elements to prime numbers.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] crt\t\t\t- the parameters given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n */\nint cp_shipsi_ask(bn_t d, bn_t r, bn_t p[], const bn_t g, const bn_t n,\n\t\tconst bn_t x[], size_t m);\n\n/**\n * Computes the sender part of the SHI-PSI protocol, given its input set.\n *\n * @param[out] t\t\t\t- the accumulator results.\n * @param[out] u\t\t\t- the hint in the exponent.\n * @param[in] d\t\t\t\t- the receiver's accumulator.\n * @param[in] g\t\t\t\t- the generator given by the trusted setup.\n * @param[in] crt\t\t\t- the parameters given by the trusted setup.\n * @param[in] y\t\t\t\t- the server's input set.\n * @param[in] n\t\t\t\t- the sender's input set size.\n */\nint cp_shipsi_ans(bn_t t[], bn_t u, bn_t d, const bn_t g, const crt_t crt,\n\t\tconst bn_t y[], const size_t n);\n\n/**\n * Computes the intersection as the final part of the SHI-PSI protocol.\n *\n * @param[out] z\t\t\t- the elements in the intersection.\n * @param[out] len\t\t\t- the cardinality of the resulting intersection.\n * @param[in] r\t\t\t\t- the random nonce.\n * @param[in] p\t\t\t\t- the mapping of elements to prime numbers.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n * @param[in] t\t\t\t\t- the accumulator results.\n * @param[in] u\t\t\t\t- the hint in the exponent.\n * @param[in] l\t\t\t\t- the sender's input set size.\n */\nint cp_shipsi_int(bn_t z[], size_t *len, const bn_t r, const bn_t p[],\n\t\tconst bn_t n, const bn_t x[], size_t m, const bn_t t[], const bn_t u,\n\t\tsize_t l);\n\n/**\n * Generates the secrets and consecutive powers for the pairing-based laconic\n * Private Set Intersection (PB-PSI) protocol, given the maximum set size.\n *\n * @param[out] sk\t\t\t- the sender's secret key.\n * @param[out] ss\t\t\t- the secret power in G_2.\n * @param[out] s\t\t\t- the consecutive powers in G_1.\n * @param[in] m\t\t\t\t- the maximum set size.\n */\nint cp_pbpsi_gen(bn_t sk, g1_t ss, g2_t s[], size_t m);\n\n/**\n * Computes the receiver part of the PB-PSI protocol, given its input set.\n *\n * @param[out] d\t\t\t- the polynomial interpolations in the exponent.\n * @param[out] r\t\t\t- the random nonce.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] s\t\t\t\t- the consecutive powers.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n */\nint cp_pbpsi_ask(g2_t d[], bn_t r, const bn_t x[], const g2_t s[], size_t m);\n\n/**\n * Computes the sender part of the PB-PSI protocol, given its input set.\n *\n * @param[out] t\t\t\t- the pairing results.\n * @param[out] u\t\t\t- the missing elements in the exponent.\n * @param[in] ss\t\t\t- the secret power.\n * @param[in] d\t\t\t\t- the polynomial interpolations in the exponent.\n * @param[in] y\t\t\t\t- the server's input set.\n * @param[in] n\t\t\t\t- the sender's input set size.\n */\nint cp_pbpsi_ans(gt_t t[], g1_t u[], const g1_t ss, const g2_t d,\n\t\tconst bn_t y[], size_t n);\n\n/**\n * Computes the intersection as the final part of the PB-PSI protocol.\n *\n * @param[out] z\t\t\t- the elements in the intersection.\n * @param[out] len\t\t\t- the cardinality of the resulting intersection.\n * @param[in] d\t\t\t\t- the polynomial interpolations in the exponent.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] s\t\t\t\t- the consecutive powers.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n * @param[in] t\t\t\t\t- the pairing results.\n * @param[in] u\t\t\t\t- the missing elements in the exponent.\n * @param[in] n\t\t\t\t- the sender's input set size.\n */\nint cp_pbpsi_int(bn_t z[], size_t *len, const g2_t d[], const bn_t x[], size_t m,\n\t\tconst gt_t t[], const g1_t u[], size_t n);\n\n#endif /* !RLC_CP_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup eb Elliptic curves over binary fields\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on binary elliptic curves.\n *\n * @ingroup eb\n */\n\n#ifndef RLC_EB_H\n#define RLC_EB_H\n\n#include \"relic_fb.h\"\n#include \"relic_bn.h\"\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Binary elliptic curve identifiers.\n */\nenum {\n\t/** NIST B-163 binary curve. */\n\tNIST_B163 = 1,\n\t/** NIST K-163 Koblitz curve. */\n\tNIST_K163,\n\t/** NIST B-133 binary curve. */\n\tNIST_B233,\n\t/** NIST K-233 Koblitz curve. */\n\tNIST_K233,\n\t/** Curve over 2^{251} used in eBATs. */\n\tEBACS_B251,\n\t/** Curve over 2^{257} good for halving. */\n\tHALVE_B257,\n\t/** SECG K-239 binary curve. */\n\tSECG_K239,\n\t/** NIST B-283 binary curve. */\n\tNIST_B283,\n\t/** NIST K-283 Koblitz curve. */\n\tNIST_K283,\n\t/** NIST B-409 binary curve. */\n\tNIST_B409,\n\t/** NIST K-409 Koblitz curve. */\n\tNIST_K409,\n\t/** NIST B-571 binary curve. */\n\tNIST_B571,\n\t/** NIST K-571 Koblitz curve. */\n\tNIST_K571,\n};\n\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_EB_TABLE_BASIC\t\t(RLC_FB_BITS)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_EB_TABLE_COMBS      (1 << EB_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_EB_TABLE_COMBD\t\t(1 << (EB_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_EB_TABLE_LWNAF\t\t(1 << (EB_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if EB_FIX == BASIC\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_BASIC\n#elif EB_FIX == COMBS\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_COMBS\n#elif EB_FIX == COMBD\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_COMBD\n#elif EB_FIX == LWNAF\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_EB_TABLE_MAX \t\tRLC_EB_TABLE\n#else\n#define RLC_EB_TABLE_MAX \t\tRLC_MAX(RLC_EB_TABLE_BASIC, RLC_EB_TABLE_COMBD)\n#endif\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over a binary field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfb_st x;\n\t/** The second coordinate. */\n\tfb_st y;\n\t/** The third coordinate (projective representation). */\n\tfb_st z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} eb_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef eb_st eb_t[1];\n#else\n#ifdef CHECK\ntypedef eb_st *volatile eb_t;\n#else\ntypedef eb_st *eb_t;\n#endif\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a point on a binary elliptic curve with a null value.\n *\n * @param[out] A\t\t\t- the point to initialize.\n */\n#if ALLOC == AUTO\n#define eb_null(A)\t\t\t/* empty */\n#else\n#define eb_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a point on a binary elliptic curve.\n *\n * @param[out] A\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define eb_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (eb_t)calloc(1, sizeof(eb_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define eb_new(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on a binary elliptic curve.\n *\n * @param[out] A\t\t\t- the point to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define eb_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define eb_free(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Negates a binary elliptic curve point. Computes R = -P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to negate.\n */\n#if EB_ADD == BASIC\n#define eb_neg(R, P)\t\teb_neg_basic(R, P)\n#elif EB_ADD == PROJC\n#define eb_neg(R, P)\t\teb_neg_projc(R, P)\n#endif\n\n/**\n * Adds two binary elliptic curve points. Computes R = P + Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t- the second point to add.\n */\n#if EB_ADD == BASIC\n#define eb_add(R, P, Q)\t\teb_add_basic(R, P, Q);\n#elif EB_ADD == PROJC\n#define eb_add(R, P, Q)\t\teb_add_projc(R, P, Q);\n#endif\n\n/**\n * Subtracts a binary elliptic curve point from another. Computes R = P - Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point.\n * @param[in] Q\t\t\t\t- the second point.\n */\n#if EB_ADD == BASIC\n#define eb_sub(R, P, Q)\t\teb_sub_basic(R, P, Q)\n#elif EB_ADD == PROJC\n#define eb_sub(R, P, Q)\t\teb_sub_projc(R, P, Q)\n#endif\n\n/**\n * Doubles a binary elliptic curve point. Computes R = 2P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to double.\n */\n#if EB_ADD == BASIC\n#define eb_dbl(R, P)\t\teb_dbl_basic(R, P);\n#elif EB_ADD == PROJC\n#define eb_dbl(R, P)\t\teb_dbl_projc(R, P);\n#endif\n\n\n/**\n * Multiplies a binary elliptic curve point by an integer. Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if EB_MUL == BASIC\n#define eb_mul(R, P, K)\t\teb_mul_basic(R, P, K)\n#elif EB_MUL == LODAH\n#define eb_mul(R, P, K)\t\teb_mul_lodah(R, P, K)\n#elif EB_MUL == HALVE\n#define eb_mul(R, P, K)\t\teb_mul_halve(R, P, K)\n#elif EB_MUL == LWNAF\n#define eb_mul(R, P, K)\t\teb_mul_lwnaf(R, P, K)\n#elif EB_MUL == RWNAF\n#define eb_mul(R, P, K)\t\teb_mul_rwnaf(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * point.\n *\n * @param[out] T\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t- the point to multiply.\n */\n#if EB_FIX == BASIC\n#define eb_mul_pre(T, P)\teb_mul_pre_basic(T, P)\n#elif EB_FIX == COMBS\n#define eb_mul_pre(T, P)\teb_mul_pre_combs(T, P)\n#elif EB_FIX == COMBD\n#define eb_mul_pre(T, P)\teb_mul_pre_combd(T, P)\n#elif EB_FIX == LWNAF\n#define eb_mul_pre(T, P)\teb_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] T\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if EB_FIX == BASIC\n#define eb_mul_fix(R, T, K)\teb_mul_fix_basic(R, T, K)\n#elif EB_FIX == COMBS\n#define eb_mul_fix(R, T, K)\teb_mul_fix_combs(R, T, K)\n#elif EB_FIX == COMBD\n#define eb_mul_fix(R, T, K)\teb_mul_fix_combd(R, T, K)\n#elif EB_FIX == LWNAF\n#define eb_mul_fix(R, T, K)\teb_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously. Computes\n * R = [k]P + [m]Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t- the second integer,\n */\n#if EB_SIM == BASIC\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_basic(R, P, K, Q, M)\n#elif EB_SIM == TRICK\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_trick(R, P, K, Q, M)\n#elif EB_SIM == INTER\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_inter(R, P, K, Q, M)\n#elif EB_SIM == JOINT\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the binary elliptic curve arithmetic module.\n */\nvoid eb_curve_init(void);\n\n/**\n * Finalizes the binary elliptic curve arithmetic module.\n */\nvoid eb_curve_clean(void);\n\n/**\n * Returns the a-coefficient of the currently configured binary elliptic\n * curve.\n *\n * @return the a-coefficient of the elliptic curve.\n */\ndig_t *eb_curve_get_a(void);\n\n/**\n * Returns the b-coefficient of the currently configured binary elliptic\n * curve.\n *\n * @return the b-coefficient of the elliptic curve.\n */\ndig_t *eb_curve_get_b(void);\n\n/**\n * Returns a optimization identifier based on the a-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint eb_curve_opt_a(void);\n\n/**\n * Returns a optimization identifier based on the b-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint eb_curve_opt_b(void);\n\n/**\n * Tests if the configured binary elliptic curve is a Koblitz curve.\n *\n * @return 1 if the binary elliptic curve is a Koblitz curve, 0 otherwise.\n */\nint eb_curve_is_kbltz(void);\n\n/**\n * Returns the generator of the group of points in the binary elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid eb_curve_get_gen(eb_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nconst eb_t *eb_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the binary elliptic curve.\n *\n * @param[out] n\t\t\t- the returned order.\n */\nvoid eb_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the binary elliptic curve.\n *\n * @param[out] n\t\t\t- the returned cofactor.\n */\nvoid eb_curve_get_cof(bn_t h);\n\n/**\n * Configures an ordinary binary elliptic curve by its coefficients and\n * generator.\n *\n * @param[in] a\t\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t\t- the generator.\n * @param[in] n\t\t\t\t- the order of the generator.\n * @param[in] h\t\t\t\t- the cofactor of the group order.\n */\nvoid eb_curve_set(const fb_t a, const fb_t b, const eb_t g, const bn_t n,\n\t\tconst bn_t h);\n\n/**\n * Configures a new binary elliptic curve by its parameter identifier.\n *\n * @param[in] param\t\t\t- the parameters identifier.\n */\nvoid eb_param_set(int param);\n\n/**\n * Configures some set of curve parameters for the current security level.\n */\nint eb_param_set_any(void);\n\n/**\n * Configures a set of curve parameters without endormorphisms for the current\n * security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint eb_param_set_any_plain(void);\n\n/**\n * Configures a set of Koblitz curve parameters for the current security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint eb_param_set_any_kbltz(void);\n\n/**\n * Returns the parameter identifier of the currently configured binary elliptic\n * curve.\n *\n * @return the parameter identifier.\n */\nint eb_param_get(void);\n\n/**\n * Prints the current configured binary elliptic curve.\n */\nvoid eb_param_print(void);\n\n/**\n * Returns the current security level.\n */\nint eb_param_level(void);\n\n/**\n * Tests if a point on a binary elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint eb_is_infty(const eb_t p);\n\n/**\n * Assigns a binary elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid eb_set_infty(eb_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the binary elliptic curve point to copy.\n */\nvoid eb_copy(eb_t r, const eb_t p);\n\n/**\n * Compares two binary elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first binary elliptic curve point.\n * @param[in] q\t\t\t\t- the second binary elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint eb_cmp(const eb_t p, const eb_t q);\n\n/**\n * Assigns a random value to a binary elliptic curve point.\n *\n * @param[out] p\t\t\t- the binary elliptic curve point to assign.\n */\nvoid eb_rand(eb_t p);\n\n/**\n * Randomizes coordinates of a binary elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded binary elliptic curve point.\n * @param[in] p\t\t\t\t- the binary elliptic curve point to blind.\n */\nvoid eb_blind(eb_t r, const eb_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid eb_rhs(fb_t rhs, const eb_t p);\n\n/** Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint eb_on_curve(const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a random binary elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid eb_tab(eb_t *t, const eb_t p, int w);\n\n/**\n * Prints a binary elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the binary elliptic curve point to print.\n */\nvoid eb_print(const eb_t p);\n\n/**\n * Returns the number of bytes necessary to store a binary elliptic curve point\n * with optional point compression.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint eb_size_bin(const eb_t a, int pack);\n\n/**\n * Reads a binary elliptic curve point from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid eb_read_bin(eb_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a binary field element to a byte vector in big-endian format with\n * optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the binary elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid eb_write_bin(uint8_t *bin, int len, const eb_t a, int pack);\n\n/**\n * Negates a binary elliptic curve point represented by affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid eb_neg_basic(eb_t r, const eb_t p);\n\n/**\n * Negates a binary elliptic curve point represented by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid eb_neg_projc(eb_t r, const eb_t p);\n\n/**\n * Adds two binary elliptic curve points represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid eb_add_basic(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Adds two binary elliptic curve points represented in projective coordinates.\n * Computes R = P + Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid eb_add_projc(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Subtracts a binary elliptic curve point from another, both points represented\n * by affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid eb_sub_basic(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Subtracts a binary elliptic curve point from another, both points represented\n * by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid eb_sub_projc(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Doubles a binary elliptic curve point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid eb_dbl_basic(eb_t r, const eb_t p);\n\n/**\n * Doubles a binary elliptic curve point represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid eb_dbl_projc(eb_t r, const eb_t p);\n\n/**\n * Halves a point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to halve.\n */\nvoid eb_hlv(eb_t r, const eb_t p);\n\n/**\n * Computes the Frobenius map of a binary elliptic curve point on a Koblitz\n * curve. Computes R = \\tau(P) = \\tau(x, y) = (x^2, y^2).\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid eb_frb(eb_t r, const eb_t p);\n\n/**\n * Multiplies a binary elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_basic(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the constant-time\n * Lopez-Dahab point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_lodah(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the left-to-right\n * w-NAF method. If the binary curve is a Koblitz curve, w-TNAF is used.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_lwnaf(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the right-to-left\n * w-NAF method. If the binary curve is a Koblitz curve, w-TNAF is used.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_rwnaf(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the halving method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_halve(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies the generator of a binary elliptic curve by an integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_gen(eb_t r, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by a small positive integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_dig(eb_t r, const eb_t p, const dig_t k);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_basic(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_yaowi(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_nafwi(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_combs(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_combd(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_lwnaf(eb_t *t, const eb_t p);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_basic(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_yaowi(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_nafwi(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_combs(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_combd(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_lwnaf(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_basic(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_trick(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_inter(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_joint(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds the generator and a binary elliptic curve point\n * simultaneously. Computes R = [k]G + [m]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer.\n */\nvoid eb_mul_sim_gen(eb_t r, const bn_t k, const eb_t q, const bn_t m);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid eb_norm(eb_t r, const eb_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid eb_norm_sim(eb_t *r, const eb_t *t, int n);\n\n/**\n * Maps a byte array to a point in a binary elliptic curve.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid eb_map(eb_t p, const uint8_t *msg, int len);\n\n/**\n * Compresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid eb_pck(eb_t r, const eb_t p);\n\n/**\n * Decompresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint eb_upk(eb_t r, const eb_t p);\n\n#endif /* !RLC_EB_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup ed Edwards curves over prime fields.\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on elliptic curves.\n *\n * @ingroup ed\n */\n\n#ifndef RLC_ED_H\n#define RLC_ED_H\n\n#include \"relic_fp.h\"\n#include \"relic_bn.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions\t\t\t\t\t\t\t\t\t\t\t\t\t   */\n/*============================================================================*/\n\n/**\n * Prime elliptic curve identifiers.\n */\nenum {\n\t/** ED25519 Edwards curve. */\n\tCURVE_ED25519 = 1\n};\n\n/*============================================================================*/\n/* Precomputaion table\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*============================================================================*/\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_ED_TABLE_BASIC\t  (RLC_FP_BITS + 1)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_ED_TABLE_COMBS\t  (1 << ED_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_ED_TABLE_COMBD\t  (1 << (ED_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_ED_TABLE_LWNAF\t  (1 << (ED_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if ED_FIX == BASIC\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_BASIC\n#elif ED_FIX == COMBS\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_COMBS\n#elif ED_FIX == COMBD\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_COMBD\n#elif ED_FIX == LWNAF\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_ED_TABLE_MAX\t\tRLC_ED_TABLE\n#else\n#define RLC_ED_TABLE_MAX\t\tRLC_MAX(RLC_ED_TABLE_BASIC, RLC_ED_TABLE_COMBD)\n#endif\n\n/*============================================================================*/\n/* Type definitions\t\t\t\t\t\t\t\t\t\t\t\t\t\t   */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over an Edwards field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp_st x;\n\t/** The second coordinate. */\n\tfp_st y;\n\t/** The third coordinate (projective representation). */\n\tfp_st z;\n#if ED_ADD == EXTND || !defined(STRIP)\n\t/** The forth coordinate (extended coordinates) */\n\tfp_st t;\n#endif\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ed_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ed_st ed_t[1];\n#else\n#ifdef CHECK\ntypedef ed_st *volatile ed_t;\n#else\ntypedef ed_st *ed_t;\n#endif\n#endif\n\n/*============================================================================*/\n/* Macro definitions\t\t\t\t\t\t\t\t\t\t\t\t\t\t  */\n/*============================================================================*/\n\n/**\n * Initializes a point on an Edwards curve with a null value.\n *\n * @param[out] A\t\t\t- the point to initialize.\n */\n#if ALLOC == AUTO\n#define ed_null(A)\t\t\t/* empty */\n#else\n#define ed_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a point on an Edwards curve.\n *\n * @param[out] A\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ed_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ed_t)calloc(1, sizeof(ed_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ed_new(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on an Edwards curve.\n *\n * @param[out] A\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ed_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ed_free(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Negates an Edwards elliptic curve point. Computes R = -P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to negate.\n */\n#if ED_ADD == BASIC\n#define ed_neg(R, P)\t\ted_neg_basic(R, P)\n#elif ED_ADD == PROJC || ED_ADD == EXTND\n#define ed_neg(R, P)\t\ted_neg_projc(R, P)\n#endif\n\n/**\n * Adds two Edwards elliptic curve points. Computes R = P + Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t- the second point to add.\n */\n#if ED_ADD == BASIC\n#define ed_add(R, P, Q)\t\ted_add_basic(R, P, Q)\n#elif ED_ADD == PROJC\n#define ed_add(R, P, Q)\t\ted_add_projc(R, P, Q)\n#elif ED_ADD == EXTND\n#define ed_add(R, P, Q)\t\ted_add_extnd(R, P, Q)\n#endif\n\n/**\n * Subtracts an Edwards elliptic curve point from another. Computes R = P - Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point.\n * @param[in] Q\t\t\t\t- the second point.\n */\n#if ED_ADD == BASIC\n#define ed_sub(R, P, Q)\t\ted_sub_basic(R, P, Q)\n#elif ED_ADD == PROJC\n#define ed_sub(R, P, Q)\t\ted_sub_projc(R, P, Q)\n#elif ED_ADD == EXTND\n#define ed_sub(R, P, Q)\t\ted_sub_extnd(R, P, Q)\n#endif\n\n/**\n * Doubles an Edwards elliptic curve point. Computes R = 2P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to double.\n */\n#if ED_ADD == BASIC\n#define ed_dbl(R, P)\t\ted_dbl_basic(R, P)\n#elif ED_ADD == PROJC\n#define ed_dbl(R, P)\t\ted_dbl_projc(R, P)\n#elif ED_ADD == EXTND\n#define ed_dbl(R, P)\t\ted_dbl_extnd(R, P)\n#endif\n\n\n/**\n * Configures an Edwards curve by its parameter identifier.\n *\n * @param\t\t\t\t   - the parameter identifier.\n */\nvoid ed_param_set(int param);\n\n/**\n * Configures some set of curve parameters for the current security level.\n */\nint ed_param_set_any(void);\n\n/**\n * Returns the parameter identifier of the currently configured Edwards elliptic\n * curve.\n *\n * @return the parameter identifier.\n */\nint ed_param_get(void);\n\n/**\n * Returns the order of the group of points in the Edwards curve.\n *\n * @param[out] r\t\t\t- the returned order.\n */\nvoid ed_curve_get_ord(bn_t r);\n\n/**\n * Returns the generator of the group of points in the curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ed_curve_get_gen(ed_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nconst ed_t *ed_curve_get_tab(void);\n\n/**\n * Returns the cofactor of the Edwards elliptic curve.\n *\n * @param[out] n\t\t\t- the returned cofactor.\n */\nvoid ed_curve_get_cof(bn_t h);\n\n/**\n * Prints the current configured Edwards elliptic curve.\n */\nvoid ed_param_print(void);\n\n/**\n * Returns the current security level.\n */\nint ed_param_level(void);\n\n#if ED_ADD == EXTND\n/**\n * Converts projective point into extended point.\n */\nvoid ed_projc_to_extnd(ed_t r, const fp_t x, const fp_t y, const fp_t z);\n#endif\n\n/**\n * Assigns a random value to an Edwards elliptic curve point.\n *\n * @param[out] p\t\t\t- the Edwards elliptic curve point to assign.\n */\nvoid ed_rand(ed_t p);\n\n/**\n * Randomizes coordinates of a prime elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded Edwards elliptic curve point.\n * @param[in] p\t\t\t\t- the Edwards elliptic curve point to blind.\n */\nvoid ed_blind(ed_t r, const ed_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * Edwards elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ed_rhs(fp_t rhs, const ed_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t   - the result.\n * @param[in] p\t\t\t   - the Edwards elliptic curve point to copy.\n */\nvoid ed_copy(ed_t r, const ed_t p);\n\n/**\n * Compares two Edwards elliptic curve points.\n *\n * @param[in] p\t\t\t   - the first Edwards elliptic curve point.\n * @param[in] q\t\t\t   - the second Edwards elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ed_cmp(const ed_t p, const ed_t q);\n\n/**\n * Assigns an Edwards elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t   - the point to assign.\n */\nvoid ed_set_infty(ed_t p);\n\n/**\n * Tests if a point on an Edwards elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t   - the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ed_is_infty(const ed_t p);\n\n/**\n * Negates an Edwards elliptic curve point represented by affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid ed_neg_basic(ed_t r, const ed_t p);\n\n/**\n * Negates an Edwards elliptic curve point represented by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid ed_neg_projc(ed_t r, const ed_t p);\n\n/**\n * Adds two Edwards elliptic curve points represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ed_add_basic(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Adds two Edwards elliptic curve points represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ed_add_projc(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Adds two Edwards elliptic curve points represented in exteded coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ed_add_extnd(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Subtracts an Edwards elliptic curve point from another, both points represented\n * by affine coordinates..\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ed_sub_basic(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Subtracts an Edwards elliptic curve point from another, both represented\n * by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ed_sub_projc(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Subtracts an Edwards elliptic curve point from another, both represented\n * by extended coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ed_sub_extnd(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Doubles an Edwards elliptic curve point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ed_dbl_basic(ed_t r, const ed_t p);\n\n/**\n * Doubles an Edwards elliptic curve point represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ed_dbl_projc(ed_t r, const ed_t p);\n\n/**\n * Doubles an Edwards elliptic curve point represented in extended coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ed_dbl_extnd(ed_t r, const ed_t p);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ed_norm(ed_t r, const ed_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ed_norm_sim(ed_t *r, const ed_t *t, int n);\n\n/**\n * Maps a byte array to a point in an Edwards elliptic curve.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ed_map(ed_t p, const uint8_t *msg, int len);\n\n/**\n * Maps a byte array to a point in an Edwards elliptic curve using\n * an explicit domain separation tag.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);\n\n/**\n * Multiplies an Edwards elliptic curve point by an integer. Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if ED_MUL == BASIC\n#define ed_mul(R, P, K)   ed_mul_basic(R, P, K)\n#elif ED_MUL == SLIDE\n#define ed_mul(R, P, K)   ed_mul_slide(R, P, K)\n#elif ED_MUL == MONTY\n#define ed_mul(R, P, K)   ed_mul_monty(R, P, K)\n#elif ED_MUL == LWNAF\n#define ed_mul(R, P, K)   ed_mul_lwnaf(R, P, K)\n#elif ED_MUL == LWREG\n#define ed_mul(R, P, K)   ed_mul_lwreg(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point.\n *\n * @param[out] T\t\t\t- the precomputation table.\n * @param[in] P\t\t\t \t- the point to multiply.\n */\n#if ED_FIX == BASIC\n#define ed_mul_pre(T, P)\ted_mul_pre_basic(T, P)\n#elif ED_FIX == COMBS\n#define ed_mul_pre(T, P)\ted_mul_pre_combs(T, P)\n#elif ED_FIX == COMBD\n#define ed_mul_pre(T, P)\ted_mul_pre_combd(T, P)\n#elif ED_FIX == LWNAF\n#define ed_mul_pre(T, P)\ted_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] T\t\t\t \t- the precomputation table.\n * @param[in] K\t\t\t \t- the integer.\n */\n#if ED_FIX == BASIC\n#define ed_mul_fix(R, T, K) ed_mul_fix_basic(R, T, K)\n#elif ED_FIX == COMBS\n#define ed_mul_fix(R, T, K) ed_mul_fix_combs(R, T, K)\n#elif ED_FIX == COMBD\n#define ed_mul_fix(R, T, K) ed_mul_fix_combd(R, T, K)\n#elif ED_FIX == LWNAF\n#define ed_mul_fix(R, T, K) ed_mul_fix_lwnaf(R, T, K)\n#endif\n\n /**\n * Multiplies and adds two Edwards elliptic curve points simultaneously. Computes\n * R = [k]P + [m]Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t \t- the first point to multiply.\n * @param[in] K\t\t\t \t- the first integer.\n * @param[in] Q\t\t\t \t- the second point to multiply.\n * @param[in] M\t\t\t \t- the second integer,\n */\n#if ED_SIM == BASIC\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_basic(R, P, K, Q, M)\n#elif ED_SIM == TRICK\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_trick(R, P, K, Q, M)\n#elif ED_SIM == INTER\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_inter(R, P, K, Q, M)\n#elif ED_SIM == JOINT\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*============================================================================*/\n\n/**\n * Initializes the Edwards elliptic curve arithmetic module.\n */\nvoid ed_curve_init(void);\n\n/**\n * Finalizes the Edwards elliptic curve arithmetic module.\n */\nvoid ed_curve_clean(void);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_basic(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_yaowi(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_nafwi(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_combs(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_combd(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_lwnaf(ed_t *t, const ed_t p);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_basic(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_yaowi(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_nafwi(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_combs(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_combd(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_lwnaf(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the w-(T)NAF mixed coordinate method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t \t- the precomputation table.\n * @param[in] k\t\t\t \t- the integer.\n */\nvoid ed_mul_fix_lwnaf_mixed(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies the generator of an Edwards elliptic curve by an integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t \t- the integer.\n */\nvoid ed_mul_gen(ed_t r, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic curve point by a small positive integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the point to multiply.\n * @param[in] k\t\t\t \t- the integer.\n */\nvoid ed_mul_dig(ed_t r, const ed_t p, dig_t k);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_basic(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_inter(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds multiple Edwards elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n);\n\n/**\n * Multiplies and adds the generator and an Edwards elliptic curve point\n * simultaneously. Computes R = [k]G + [m]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer.\n */\nvoid ed_mul_sim_gen(ed_t r, const bn_t k, const ed_t q, const bn_t m);\n\n/**\n * Builds a precomputation table for multiplying a random Edwards elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ed_tab(ed_t *t, const ed_t p, int w);\n\n/**\n * Prints an Edwards elliptic curve point.\n *\n * @param[in] p\t\t\t \t- the Edwards elliptic curve point to print.\n */\nvoid ed_print(const ed_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t \t- the point to test.\n */\nint ed_on_curve(const ed_t p);\n\n/**\n * Returns the number of bytes necessary to store an Edwards elliptic curve point\n * with optional point compression.\n *\n * @param[in] a\t\t\t\t- the Edwards field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ed_size_bin(const ed_t a, int pack);\n\n/**\n * Reads an Edwards elliptic curve point from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ed_read_bin(ed_t a, const uint8_t *bin, int len);\n\n/**\n * Writes an Edwards elliptic curve point to a byte vector in big-endian format\n * with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the Edwards elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ed_write_bin(uint8_t *bin, int len, const ed_t a, int pack);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_basic(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_slide(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_monty(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_lwnaf(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_lwreg(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Compresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ed_pck(ed_t r, const ed_t p);\n\n/**\n * Decompresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint ed_upk(ed_t r, const ed_t p);\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup ep Elliptic curves over prime fields\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on prime elliptic curves.\n *\n * The scalar multiplication functions are only guaranteed to work\n * in the large prime order subgroup. If you need a generic scalar\n * multiplication function, use ep_mul_basic.\n *\n * @ingroup ep\n */\n\n#ifndef RLC_EP_H\n#define RLC_EP_H\n\n#include \"relic_fp.h\"\n#include \"relic_bn.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Prime elliptic curve identifiers.\n */\nenum {\n\t/** SECG P-160 prime curve. */\n\tSECG_P160 = 1,\n\t/** SECG K-160 prime curve. */\n\tSECG_K160,\n\t/** NIST P-192 prime curve. */\n\tNIST_P192,\n\t/** SECG K-192 prime curve. */\n\tSECG_K192,\n\t/** Curve22103 prime curve. */\n\tCURVE_22103,\n\t/** NIST P-224 prime curve. */\n\tNIST_P224,\n\t/** SECG K-224 prime curve. */\n\tSECG_K224,\n\t/** Curve4417 prime curve. */\n\tCURVE_4417,\n\t/** Curve1147 prime curve. */\n\tCURVE_1174,\n\t/** Curve25519 prime curve. */\n\tCURVE_25519,\n\t/** Curve Tweedledum given by Daira Hopwoord at https://github.com/daira/tweedle */\n\tTWEEDLEDUM,\n\t/** NIST P-256 prime curve. */\n\tNIST_P256,\n\t/** Brainpool P256r1 curve. */\n\tBSI_P256,\n\t/** SECG K-256 prime curve. */\n\tSECG_K256,\n\t/** SM2 P-256 prime curve. */\n\tSM2_P256,\n\t/** Curve67254 prime curve. */\n\tCURVE_67254,\n\t/** Curve383187 prime curve. */\n\tCURVE_383187,\n\t/** NIST P-384 prime curve. */\n\tNIST_P384,\n\t/** Curve 511187 prime curve. */\n\tCURVE_511187,\n\t/** NIST P-521 prime curve. */\n\tNIST_P521,\n\t/** Barreto-Naehrig curve with positive x */\n\tBN_P158,\n\t/** Barreto-Naehrig curve with negative x (found by Nogami et al.). */\n\tBN_P254,\n\t/** Barreto-Naehrig curve with negative x. */\n\tBN_P256,\n\t/** Barreto-Naehrig curve standardized in China. */\n\tSM9_P256,\n\t/** Barreto-Lynn-Scott curve with embedding degree 24 (SNARK curve). */\n\tB24_P315,\n\t/** Barreto-Lynn-Scott curve with embedding degree 24 (SNARK curve). */\n\tB24_P317,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12 (SNARK curve). */\n\tB12_P377,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12 (ZCash curve). */\n\tB12_P381,\n\t/** Barreto-Naehrig curve with negative x. */\n\tBN_P382,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12 (GT-strong). */\n\tB12_P383,\n\t/** Barreto-Naehrig curve with embedding degree 12. */\n\tBN_P446,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12. */\n\tB12_P446,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12. */\n\tB12_P455,\n\t/** Kachisa-Schafer-Scott with negative x. */\n\tKSS_P508,\n\t/** Barreto-Lynn-Scott curve with embedding degree 24. */\n\tB24_P509,\n\t/** Optimal TNFS-secure curve with embedding degree 8. */\n\tOT8_P511,\n\t/** Cocks-pinch curve with embedding degree 8. */\n\tGMT8_P544,\n\t/** Kachisa-Scott-Schaefer curve with embedding degree 54. */\n\tK54_P569,\n\t/** Barreto-Lynn-Scott curve with embedding degree 48. */\n\tB48_P575,\n\t/** Barreto-Naehrig curve with positive x. */\n\tBN_P638,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12. */\n\tB12_P638,\n\t/** 1536-bit supersingular curve. */\n\tSS_P1536,\n\t/** 3072-bit supersingular curve. */\n\tSS_P3072,\n};\n\n/**\n * Pairing-friendly elliptic curve identifiers.\n */\nenum {\n\t/** Supersingular curves with embedding degree 1. */\n\tEP_SS1 = 1,\n\t/** Supersingular curves with embedding degree 2. */\n\tEP_SS2,\n\t/** Barreto-Naehrig. */\n\tEP_BN,\n\t/* Optimal TNFS-secure. */\n\tEP_OT8,\n\t/* Cocks-Pinch curve. */\n\tEP_GMT8,\n\t/* Barreto-Lynn-Scott with embedding degree 12. */\n\tEP_B12,\n\t/* Kachisa-Schafer-Scott with embedding degree 16. */\n\tEP_K16,\n\t/* Barreto-Lynn-Scott with embedding degree 24. */\n\tEP_B24,\n\t/* Barreto-Lynn-Scott with embedding degree 48. */\n\tEP_B48,\n\t/** Kachisa-Scott-Schaefer curve with embedding degree 54. */\n\tEP_K54,\n};\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Denotes a divisive twist.\n */\n#define RLC_EP_DTYPE\t\t\t1\n\n/**\n * Denotes a multiplicative twist.\n */\n#define RLC_EP_MTYPE\t\t\t2\n\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_EP_TABLE_BASIC\t\t(RLC_FP_BITS + 1)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_EP_TABLE_COMBS      (1 << EP_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_EP_TABLE_COMBD\t\t(1 << (EP_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_EP_TABLE_LWNAF\t\t(1 << (EP_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if EP_FIX == BASIC\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_BASIC\n#elif EP_FIX == COMBS\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_COMBS\n#elif EP_FIX == COMBD\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_COMBD\n#elif EP_FIX == LWNAF\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_EP_TABLE_MAX \t\tRLC_EP_TABLE\n#else\n#define RLC_EP_TABLE_MAX \t\tRLC_MAX(RLC_EP_TABLE_BASIC, RLC_EP_TABLE_COMBD)\n#endif\n\n/**\n * Maximum number of coefficients of an isogeny map polynomial.\n * RLC_TERMS of value 16 is sufficient for a degree-11 isogeny polynomial.\n */\n#define RLC_EP_CTMAP_MAX\t\t16\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over a prime field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp_st x;\n\t/** The second coordinate. */\n\tfp_st y;\n\t/** The third coordinate (projective representation). */\n\tfp_st z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep_st ep_t[1];\n#else\n#ifdef CHECK\ntypedef ep_st *volatile ep_t;\n#else\ntypedef ep_st *ep_t;\n#endif\n#endif\n\n/**\n * Data structure representing an isogeny map.\n */\ntypedef struct {\n\t/** The a-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp_st a;\n\t/** The b-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp_st b;\n\t/** Degree of x numerator */\n\tint deg_xn;\n\t/** Degree of x denominator */\n\tint deg_xd;\n\t/** Degree of y numerator */\n\tint deg_yn;\n\t/** Degree of y denominator */\n\tint deg_yd;\n\t/** x numerator coefficients */\n\tfp_st xn[RLC_EP_CTMAP_MAX];\n\t/** x denominator coefficients */\n\tfp_st xd[RLC_EP_CTMAP_MAX];\n\t/** y numerator coefficients */\n\tfp_st yn[RLC_EP_CTMAP_MAX];\n\t/** y denominator coefficients */\n\tfp_st yd[RLC_EP_CTMAP_MAX];\n} iso_st;\n\n/**\n * Pointer to isogeny map coefficients.\n */\ntypedef iso_st *iso_t;\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a point on a prime elliptic curve with a null value.\n *\n * @param[out] A\t\t\t- the point to initialize.\n */\n#if ALLOC == AUTO\n#define ep_null(A)\t\t\t\t/* empty */\n#else\n#define ep_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a point on a prime elliptic curve.\n *\n * @param[out] A\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ep_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ep_t)calloc(1, sizeof(ep_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep_new(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on a prime elliptic curve.\n *\n * @param[out] A\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ep_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ep_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Adds two prime elliptic curve points. Computes R = P + Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t- the second point to add.\n */\n#if EP_ADD == BASIC\n#define ep_add(R, P, Q)\t\tep_add_basic(R, P, Q)\n#elif EP_ADD == PROJC\n#define ep_add(R, P, Q)\t\tep_add_projc(R, P, Q)\n#elif EP_ADD == JACOB\n#define ep_add(R, P, Q)\t\tep_add_jacob(R, P, Q)\n#endif\n\n/**\n * Doubles a prime elliptic curve point. Computes R = 2P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to double.\n */\n#if EP_ADD == BASIC\n#define ep_dbl(R, P)\t\tep_dbl_basic(R, P)\n#elif EP_ADD == PROJC\n#define ep_dbl(R, P)\t\tep_dbl_projc(R, P)\n#elif EP_ADD == JACOB\n#define ep_dbl(R, P)\t\tep_dbl_jacob(R, P)\n#endif\n\n/**\n * Multiplies a prime elliptic curve point by an integer. Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if EP_MUL == BASIC\n#define ep_mul(R, P, K)\t\tep_mul_basic(R, P, K)\n#elif EP_MUL == SLIDE\n#define ep_mul(R, P, K)\t\tep_mul_slide(R, P, K)\n#elif EP_MUL == MONTY\n#define ep_mul(R, P, K)\t\tep_mul_monty(R, P, K)\n#elif EP_MUL == LWNAF\n#define ep_mul(R, P, K)\t\tep_mul_lwnaf(R, P, K)\n#elif EP_MUL == LWREG\n#define ep_mul(R, P, K)\t\tep_mul_lwreg(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point.\n *\n * @param[out] T\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t- the point to multiply.\n */\n#if EP_FIX == BASIC\n#define ep_mul_pre(T, P)\tep_mul_pre_basic(T, P)\n#elif EP_FIX == COMBS\n#define ep_mul_pre(T, P)\tep_mul_pre_combs(T, P)\n#elif EP_FIX == COMBD\n#define ep_mul_pre(T, P)\tep_mul_pre_combd(T, P)\n#elif EP_FIX == LWNAF\n#define ep_mul_pre(T, P)\tep_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] T\t\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_FIX == BASIC\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_basic(R, T, K)\n#elif EP_FIX == COMBS\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_combs(R, T, K)\n#elif EP_FIX == COMBD\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_combd(R, T, K)\n#elif EP_FIX == LWNAF\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously.\n * Computes R = [k]P + [m]Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t- the second integer,\n */\n#if EP_SIM == BASIC\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_basic(R, P, K, Q, M)\n#elif EP_SIM == TRICK\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_trick(R, P, K, Q, M)\n#elif EP_SIM == INTER\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_inter(R, P, K, Q, M)\n#elif EP_SIM == JOINT\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the prime elliptic curve arithmetic module.\n */\nvoid ep_curve_init(void);\n\n/**\n * Finalizes the prime elliptic curve arithmetic module.\n */\nvoid ep_curve_clean(void);\n\n/**\n * Returns the a-coefficient of the currently configured prime elliptic curve.\n *\n * @return the a-coefficient of the elliptic curve.\n */\ndig_t *ep_curve_get_a(void);\n\n/**\n * Returns the b-coefficient of the currently configured prime elliptic curve.\n *\n * @return the b-coefficient of the elliptic curve.\n */\ndig_t *ep_curve_get_b(void);\n\n/**\n * Returns the b3 = 3*b value used in elliptic curve arithmetic.\n *\n * @return the value b3 used in elliptic curve arithmetic.\n */\ndig_t *ep_curve_get_b3(void);\n\n/**\n * Returns the efficient endormorphism associated with the prime curve.\n */\ndig_t *ep_curve_get_beta(void);\n\n/**\n * Returns the parameter V1 of the prime curve.\n */\nvoid ep_curve_get_v1(bn_t v[]);\n\n/**\n * Returns the parameter V2 of the prime curve.\n */\nvoid ep_curve_get_v2(bn_t v[]);\n\n/**\n * Returns a optimization identifier based on the a-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep_curve_opt_a(void);\n\n/**\n * Returns a optimization identifier based on the b-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep_curve_opt_b(void);\n\n/**\n * Returns a optimization identifier based on the b-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep_curve_opt_b3(void);\n\n/**\n * Multiplies a field element by the a-coefficient of the curve.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n */\nvoid ep_curve_mul_a(fp_t c, const fp_t a);\n\n/**\n * Multiplies a field element by the b-coefficient of the curve.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n */\nvoid ep_curve_mul_b(fp_t c, const fp_t a);\n\n/**\n * Multiplies a field element by the b3 value of the curve.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n */\nvoid ep_curve_mul_b3(fp_t c, const fp_t a);\n/**\n * Tests if the configured prime elliptic curve is a Koblitz curve.\n *\n * @return 1 if the prime elliptic curve is a Koblitz curve, 0 otherwise.\n */\nint ep_curve_is_endom(void);\n\n/**\n * Tests if the configured prime elliptic curve is supersingular.\n *\n * @return 1 if the prime elliptic curve is supersingular, 0 otherwise.\n */\nint ep_curve_is_super(void);\n\n/**\n * Tests if the configured prime elliptic curve is pairing-friendly.\n *\n * @return 0 if the prime elliptic curve is not pairing-friendly, and the\n * family identifier otherwise.\n */\nint ep_curve_is_pairf(void);\n\n/**\n * Tests if the current curve should use an isogeny map for the SSWU map.\n *\n * @return 1 if the curve uses an isogeny, and 0 otherwise.\n */\nint ep_curve_is_ctmap(void);\n\n/**\n * Returns the generator of the group of points in the prime elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ep_curve_get_gen(ep_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nconst ep_t *ep_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the prime elliptic curve.\n *\n * @param[out] r\t\t\t- the returned order.\n */\nvoid ep_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the binary elliptic curve.\n *\n * @param[out] n\t\t\t- the returned cofactor.\n */\nvoid ep_curve_get_cof(bn_t h);\n\n/**\n * Returns the isogeny map coefficients for use with the SSWU map.\n */\niso_t ep_curve_get_iso(void);\n\n/**\n * Configures a prime elliptic curve without endomorphisms by its coefficients\n * and generator.\n *\n * @param[in] a\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n * @param[in] u\t\t\t- the non-square used for hashing to this curve.\n * @param[in] ctmap\t- true if this curve will use an isogeny for mapping.\n */\nvoid ep_curve_set_plain(const fp_t a, const fp_t b, const ep_t g, const bn_t r,\n\t\tconst bn_t h, const fp_t u, int ctmap);\n\n/**\n * Configures a supersingular prime elliptic curve by its coefficients and\n * generator.\n *\n * @param[in] a\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n * @param[in] u\t\t\t- the non-square used for hashing to this curve.\n * @param[in] ctmap\t- true if this curve will use an isogeny for mapping.\n */\nvoid ep_curve_set_super(const fp_t a, const fp_t b, const ep_t g, const bn_t r,\n\t\tconst bn_t h, const fp_t u, int ctmap);\n\n/**\n * Configures a prime elliptic curve with endomorphisms by its coefficients and\n * generator.\n *\n * @param[in] a\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] beta\t\t- the constant associated with the endomorphism.\n * @param[in] l\t\t\t- the exponent corresponding to the endomorphism.\n * @param[in] h\t\t\t- the cofactor of the group order.\n * @param[in] u\t\t\t- the non-square used for hashing to this curve.\n * @param[in] ctmap\t- true if this curve will use an isogeny for mapping.\n */\nvoid ep_curve_set_endom(const fp_t a, const fp_t b, const ep_t g, const bn_t r,\n\t\tconst bn_t h, const fp_t beta, const bn_t l, const fp_t u, int ctmap);\n\n/**\n * Configures a prime elliptic curve by its parameter identifier.\n *\n * @param\t\t\t\t- the parameter identifier.\n */\nvoid ep_param_set(int param);\n\n/**\n * Configures some set of curve parameters for the current security level.\n */\nint ep_param_set_any(void);\n\n/**\n * Configures some set of ordinary curve parameters for the current security\n * level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_plain(void);\n\n/**\n * Configures some set of Koblitz curve parameters for the current security\n * level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_endom(void);\n\n/**\n * Configures some set of supersingular curve parameters for the current\n * security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_super(void);\n\n/**\n * Configures some set of pairing-friendly curve parameters for the current\n * security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_pairf(void);\n\n/**\n * Returns the parameter identifier of the currently configured prime elliptic\n * curve.\n *\n * @return the parameter identifier.\n */\nint ep_param_get(void);\n\n/**\n * Prints the current configured prime elliptic curve.\n */\nvoid ep_param_print(void);\n\n/**\n * Returns the current security level.\n */\nint ep_param_level(void);\n\n/**\n * Returns the embedding degree of the currently configured elliptic curve.\n */\nint ep_param_embed(void);\n\n/**\n * Tests if a point on a prime elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ep_is_infty(const ep_t p);\n\n/**\n * Assigns a prime elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid ep_set_infty(ep_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t\t- the result.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to copy.\n */\nvoid ep_copy(ep_t r, const ep_t p);\n\n/**\n * Compares two prime elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first prime elliptic curve point.\n * @param[in] q\t\t\t\t- the second prime elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ep_cmp(const ep_t p, const ep_t q);\n\n/**\n * Assigns a random value to a prime elliptic curve point.\n *\n * @param[out] p\t\t\t- the prime elliptic curve point to assign.\n */\nvoid ep_rand(ep_t p);\n\n/**\n * Randomizes coordinates of a prime elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded prime elliptic curve point.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to blind.\n */\nvoid ep_blind(ep_t r, const ep_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * prime elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep_rhs(fp_t rhs, const ep_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint ep_on_curve(const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a random prime elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ep_tab(ep_t *t, const ep_t p, int w);\n\n/**\n * Prints a prime elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the prime elliptic curve point to print.\n */\nvoid ep_print(const ep_t p);\n\n/**\n * Returns the number of bytes necessary to store a prime elliptic curve point\n * with optional point compression.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ep_size_bin(const ep_t a, int pack);\n\n/**\n * Reads a prime elliptic curve point from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep_read_bin(ep_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a prime elliptic curve point to a byte vector in big-endian format\n * with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep_write_bin(uint8_t *bin, int len, const ep_t a, int pack);\n\n/**\n * Negates a prime elliptic curve point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid ep_neg(ep_t r, const ep_t p);\n\n/**\n * Adds two prime elliptic curve points represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_basic(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Adds two prime elliptic curve points represented in affine coordinates and\n * returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_slp_basic(ep_t r, fp_t s, const ep_t p, const ep_t q);\n\n/**\n * Adds two prime elliptic curve points represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_projc(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Adds two prime elliptic curve points represented in Jacobian coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_jacob(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Subtracts a prime elliptic curve point from another.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ep_sub(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Doubles a prime elliptic curve point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_basic(ep_t r, const ep_t p);\n\n/**\n * Doubles a prime elliptic curve point represented in affine coordinates and\n * returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_slp_basic(ep_t r, fp_t s, const ep_t p);\n\n/**\n * Doubles a prime elliptic curve point represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_projc(ep_t r, const ep_t p);\n\n/**\n * Doubles a prime elliptic curve point represented in Jacobian projective\n * coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_jacob(ep_t r, const ep_t p);\n\n/**\n * Computes the endomorphism map of a prime elliptic curve point.\n * Computes R = \\psi(P).\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep_psi(ep_t r, const ep_t p);\n\n/**\n * Multiplies a prime elliptic point by an integer using the binary method.\n * There is no restriction on the scalar.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_basic(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_slide(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_monty(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_lwnaf(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_lwreg(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies the generator of a prime elliptic curve by an integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_gen(ep_t r, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by a small positive integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_dig(ep_t r, const ep_t p, dig_t k);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_basic(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_yaowi(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_nafwi(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_combs(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_combd(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_lwnaf(ep_t *t, const ep_t p);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_basic(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_yaowi(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_nafwi(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_combs(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_combd(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_lwnaf(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_basic(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_trick(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_inter(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_joint(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds multiple elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep_mul_sim_lot(ep_t r, const ep_t p[], const bn_t k[], int n);\n\n/**\n * Multiplies and adds the generator and a prime elliptic curve point\n * simultaneously. Computes R = [k]G + [m]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer.\n */\nvoid ep_mul_sim_gen(ep_t r, const bn_t k, const ep_t q, const bn_t m);\n\n/**\n * Multiplies prime elliptic curve points by small scalars.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the points to multiply.\n * @param[in] k\t\t\t\t- the small scalars.\n * @param[in] n\t\t\t\t- the number of points to multiply.\n */\nvoid ep_mul_sim_dig(ep_t r, const ep_t p[], const dig_t k[], int n);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ep_norm(ep_t r, const ep_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ep_norm_sim(ep_t *r, const ep_t *t, int n);\n\n/**\n * Maps an array of uniformly random bytes to a point in a prime elliptic\n * curve.\n * That array is expected to have a length suitable for two field elements plus\n * extra bytes for uniformity.\n  *\n * @param[out] p\t\t\t- the result.\n * @param[in] uniform_bytes\t\t- the array of uniform bytes to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len);\n\n/**\n * Maps a byte array to a point in a prime elliptic curve.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep_map(ep_t p, const uint8_t *msg, int len);\n\n/**\n * Maps a byte array to a point in a prime elliptic curve with specified\n * domain separation tag (aka personalization string).\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,\n\t\tint dst_len);\n\n/**\n * Compresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ep_pck(ep_t r, const ep_t p);\n\n/**\n * Decompresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return a boolean value indicating if the decompression was successful.\n */\nint ep_upk(ep_t r, const ep_t p);\n\n#endif /* !RLC_EP_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup epx Elliptic curves defined over extensions of prime fields.\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on prime elliptic curves defined over\n * extension fields.\n\n * The scalar multiplication functions are only guaranteed to work\n * in the prime order subgroup used by pairings. If you need a generic scalar\n * multiplication function, use \\sa ep2_mul_big().\n *\n * @ingroup epx\n */\n\n#ifndef RLC_EPX_H\n#define RLC_EPX_H\n\n#include \"relic_fpx.h\"\n#include \"relic_ep.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_EPX_TABLE_BASIC\t\t(2 * RLC_FP_BITS + 1)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_EPX_TABLE_COMBS      (1 << EP_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_EPX_TABLE_COMBD\t\t(1 << (EP_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_EPX_TABLE_LWNAF\t\t(1 << (EP_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if EP_FIX == BASIC\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_BASIC\n#elif EP_FIX == COMBS\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_COMBS\n#elif EP_FIX == COMBD\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_COMBD\n#elif EP_FIX == LWNAF\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_EPX_TABLE_MAX \tRLC_EPX_TABLE\n#else\n#define RLC_EPX_TABLE_MAX \tRLC_MAX(RLC_EPX_TABLE_BASIC, RLC_EPX_TABLE_COMBD)\n#endif\n\n/**\n * Maximum number of coefficients of an isogeny map polynomial.\n * 4 is sufficient for a degree-3 isogeny polynomial.\n */\n#define RLC_EPX_CTMAP_MAX\t4\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over a quadratic extension over a prime\n * field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp2_t x;\n\t/** The second coordinate. */\n\tfp2_t y;\n\t/** The third coordinate (projective representation). */\n\tfp2_t z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep2_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep2_st ep2_t[1];\n#else\ntypedef ep2_st *ep2_t;\n#endif\n\n/**\n * Represents an elliptic curve point over a cubic extension over a prime\n * field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp3_t x;\n\t/** The second coordinate. */\n\tfp3_t y;\n\t/** The third coordinate (projective representation). */\n\tfp3_t z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep3_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep3_st ep3_t[1];\n#else\ntypedef ep3_st *ep3_t;\n#endif\n\n/**\n * Represents an elliptic curve point over a quartic extension over a prime\n * field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp4_t x;\n\t/** The second coordinate. */\n\tfp4_t y;\n\t/** The third coordinate (projective representation). */\n\tfp4_t z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep4_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep4_st ep4_t[1];\n#else\ntypedef ep4_st *ep4_t;\n#endif\n\n/**\n * Coefficients of an isogeny map for a curve over a quadratic extension.\n */\ntypedef struct {\n\t/** The a-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp2_t a;\n\t/** The b-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp2_t b;\n\t/** Degree of x numerator */\n\tint deg_xn;\n\t/** Degree of x denominator */\n\tint deg_xd;\n\t/** Degree of y numerator */\n\tint deg_yn;\n\t/** Degree of y denominator */\n\tint deg_yd;\n\t/** x numerator coefficients */\n\tfp2_t xn[RLC_EPX_CTMAP_MAX];\n\t/** x denominator coefficients */\n\tfp2_t xd[RLC_EPX_CTMAP_MAX];\n\t/** y numerator coefficients */\n\tfp2_t yn[RLC_EPX_CTMAP_MAX];\n\t/** y denominator coefficients */\n\tfp2_t yd[RLC_EPX_CTMAP_MAX];\n} iso2_st;\n\n/**\n * Pointer to isogeny map coefficients.\n */\ntypedef iso2_st *iso2_t;\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a point on an elliptic curve with a null value.\n *\n * @param[out] A\t\t\t\t- the point to initialize.\n */\n#define ep2_null(A)\t\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ep2_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ep2_t)calloc(1, sizeof(ep2_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_null((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_null((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_null((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_new((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_new((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep2_new(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ep2_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep2_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a point on an elliptic curve with a null value.\n *\n * @param[out] A\t\t\t\t- the point to initialize.\n */\n#define ep4_null(A)\t\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ep4_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ep4_t)calloc(1, sizeof(ep4_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_null((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_null((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_null((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_new((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_new((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep4_new(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ep4_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep4_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Adds two points in an elliptic curve over a quadratic extension field.\n * Computes R = P + Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t\t- the second point to add.\n */\n#if EP_ADD == BASIC\n#define ep2_add(R, P, Q)\t\tep2_add_basic(R, P, Q);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep2_add(R, P, Q)\t\tep2_add_projc(R, P, Q);\n#endif\n\n/**\n * Doubles a point in an elliptic curve over a quadratic extension field.\n * Computes R = 2P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to double.\n */\n#if EP_ADD == BASIC\n#define ep2_dbl(R, P)\t\t\tep2_dbl_basic(R, P);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep2_dbl(R, P)\t\t\tep2_dbl_projc(R, P);\n#endif\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field by\n * an unrestricted integer scalar. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#define ep2_mul_big(R, P, K)\tep2_mul_basic(R, P, K)\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_MUL == BASIC\n#define ep2_mul(R, P, K)\t\tep2_mul_basic(R, P, K)\n#elif EP_MUL == SLIDE\n#define ep2_mul(R, P, K)\t\tep2_mul_slide(R, P, K)\n#elif EP_MUL == MONTY\n#define ep2_mul(R, P, K)\t\tep2_mul_monty(R, P, K)\n#elif EP_MUL == LWNAF || EP_MUL == LWREG\n#define ep2_mul(R, P, K)\t\tep2_mul_lwnaf(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * over a quadratic extension.\n *\n * @param[out] T\t\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\n#if EP_FIX == BASIC\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_basic(T, P)\n#elif EP_FIX == COMBS\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_combs(T, P)\n#elif EP_FIX == COMBD\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_combd(T, P)\n#elif EP_FIX == LWNAF\n//TODO: implement ep2_mul_pre_glv\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed prime elliptic point over a quadratic extension using a\n * precomputation table. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] T\t\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_FIX == BASIC\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_basic(R, T, K)\n#elif EP_FIX == COMBS\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_combs(R, T, K)\n#elif EP_FIX == COMBD\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_combd(R, T, K)\n#elif EP_FIX == LWNAF\n//TODO: implement ep2_mul_fix_glv\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously. Computes\n * R = [k]P + [l]Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t\t- the second integer,\n */\n#if EP_SIM == BASIC\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_basic(R, P, K, Q, M)\n#elif EP_SIM == TRICK\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_trick(R, P, K, Q, M)\n#elif EP_SIM == INTER\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_inter(R, P, K, Q, M)\n#elif EP_SIM == JOINT\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/**\n * Adds two points in an elliptic curve over a quadratic extension field.\n * Computes R = P + Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t\t- the second point to add.\n */\n#if EP_ADD == BASIC\n#define ep4_add(R, P, Q)\t\tep4_add_basic(R, P, Q);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep4_add(R, P, Q)\t\tep4_add_projc(R, P, Q);\n#endif\n\n/**\n * Doubles a point in an elliptic curve over a quadratic extension field.\n * Computes R = 2P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to double.\n */\n#if EP_ADD == BASIC\n#define ep4_dbl(R, P)\t\t\tep4_dbl_basic(R, P);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep4_dbl(R, P)\t\t\tep4_dbl_projc(R, P);\n#endif\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field by\n * an unrestricted integer scalar. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#define ep4_mul_big(R, P, K)\tep4_mul_basic(R, P, K)\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_MUL == BASIC\n#define ep4_mul(R, P, K)\t\tep4_mul_basic(R, P, K)\n#elif EP_MUL == SLIDE\n#define ep4_mul(R, P, K)\t\tep4_mul_slide(R, P, K)\n#elif EP_MUL == MONTY\n#define ep4_mul(R, P, K)\t\tep4_mul_monty(R, P, K)\n#elif EP_MUL == LWNAF || EP_MUL == LWREG\n#define ep4_mul(R, P, K)\t\tep4_mul_lwnaf(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * over a quadratic extension.\n *\n * @param[out] T\t\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\n#if EP_FIX == BASIC\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_basic(T, P)\n#elif EP_FIX == COMBS\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_combs(T, P)\n#elif EP_FIX == COMBD\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_combd(T, P)\n#elif EP_FIX == LWNAF\n//TODO: implement ep4_mul_pre_glv\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed prime elliptic point over a quadratic extension using a\n * precomputation table. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] T\t\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_FIX == BASIC\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_basic(R, T, K)\n#elif EP_FIX == COMBS\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_combs(R, T, K)\n#elif EP_FIX == COMBD\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_combd(R, T, K)\n#elif EP_FIX == LWNAF\n//TODO: implement ep4_mul_fix_glv\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously. Computes\n * R = [k]P + [l]Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t\t- the second integer,\n */\n#if EP_SIM == BASIC\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_basic(R, P, K, Q, M)\n#elif EP_SIM == TRICK\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_trick(R, P, K, Q, M)\n#elif EP_SIM == INTER\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_inter(R, P, K, Q, M)\n#elif EP_SIM == JOINT\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the elliptic curve over quadratic extension.\n */\nvoid ep2_curve_init(void);\n\n/**\n * Finalizes the elliptic curve over quadratic extension.\n */\nvoid ep2_curve_clean(void);\n\n/**\n * Returns the 'a' coefficient of the currently configured elliptic curve.\n *\n * @return the 'a' coefficient of the elliptic curve.\n */\nfp_t *ep2_curve_get_a(void);\n\n/**\n * Returns the 'b' coefficient of the currently configured elliptic curve.\n *\n * @param[out] b\t\t\t- the 'b' coefficient of the elliptic curve.\n */\nfp_t *ep2_curve_get_b(void);\n\n/**\n * Returns the vector of coefficients required to perform GLV method.\n *\n * @param[out] b\t\t\t- the vector of coefficients.\n */\nvoid ep2_curve_get_vs(bn_t *v);\n\n/**\n * Returns a optimization identifier based on the 'a' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep2_curve_opt_a(void);\n\n/**\n * Returns b optimization identifier based on the 'b' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep2_curve_opt_b(void);\n\n/**\n * Tests if the configured elliptic curve is a twist.\n *\n * @return the type of the elliptic curve twist, 0 if non-twisted curve.\n */\nint ep2_curve_is_twist(void);\n\n/**\n * Tests if the current curve should use an isogeny map for the SSWU map.\n *\n * @return 1 if the curve uses an isogeny, and 0 otherwise.\n */\nint ep2_curve_is_ctmap(void);\n\n/**\n * Returns the generator of the group of points in the elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ep2_curve_get_gen(ep2_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nep2_t *ep2_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the elliptic curve.\n *\n * @param[out] n\t\t\t- the returned order.\n */\nvoid ep2_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the group order in the elliptic curve.\n *\n * @param[out] h\t\t\t- the returned cofactor.\n */\nvoid ep2_curve_get_cof(bn_t h);\n\n/**\n * Returns the isogeny map coefficients for use with the SSWU map.\n */\niso2_t ep2_curve_get_iso(void);\n\n/**\n * Configures an elliptic curve over a quadratic extension by its coefficients.\n *\n * @param[in] a\t\t\t- the 'a' coefficient of the curve.\n * @param[in] b\t\t\t- the 'b' coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n */\nvoid ep2_curve_set(const fp2_t a, const fp2_t b, const ep2_t g, const bn_t r, const bn_t h);\n\n/**\n * Configures an elliptic curve by twisting the curve over the base prime field.\n *\n *  @param\t\t\t\t- the type of twist (multiplicative or divisive)\n */\nvoid ep2_curve_set_twist(int type);\n\n/**\n * Tests if a point on an elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ep2_is_infty(const ep2_t p);\n\n/**\n * Assigns an elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid ep2_set_infty(ep2_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t\t- the result.\n * @param[in] p\t\t\t\t- the elliptic curve point to copy.\n */\nvoid ep2_copy(ep2_t r, const ep2_t p);\n\n/**\n * Compares two elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first elliptic curve point.\n * @param[in] q\t\t\t\t- the second elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ep2_cmp(const ep2_t p, const ep2_t q);\n\n/**\n * Assigns a random value to an elliptic curve point.\n *\n * @param[out] p\t\t\t- the elliptic curve point to assign.\n */\nvoid ep2_rand(ep2_t p);\n\n/**\n * Randomizes coordinates of an elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded prime elliptic curve point.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to blind.\n */\nvoid ep2_blind(ep2_t r, const ep2_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep2_rhs(fp2_t rhs, const ep2_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint ep2_on_curve(const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a random prime elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ep2_tab(ep2_t *t, const ep2_t p, int w);\n\n/**\n * Prints an elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the elliptic curve point to print.\n */\nvoid ep2_print(const ep2_t p);\n\n/**\n * Returns the number of bytes necessary to store a prime elliptic curve point\n * over a quadratic extension with optional point compression.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ep2_size_bin(const ep2_t a, int pack);\n\n/**\n * Reads a prime elliptic curve point over a quadratic extension from a byte\n * vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep2_read_bin(ep2_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a prime elliptic curve pointer over a quadratic extension to a byte\n * vector in big-endian format with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack);\n\n/**\n * Negates a point represented in affine coordinates in an elliptic curve over\n * a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the point to negate.\n */\nvoid ep2_neg(ep2_t r, const ep2_t p);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep2_add_basic(ep2_t r, const ep2_t p, const ep2_t q);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quadratic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep2_add_slp_basic(ep2_t r, fp2_t s, const ep2_t p, const ep2_t q);\n\n/**\n * Adds two points represented in projective coordinates in an elliptic curve\n * over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep2_add_projc(ep2_t r, const ep2_t p, const ep2_t q);\n\n /**\n  * Subtracts a point i an elliptic curve over a quadratic extension from\n  * another.\n  *\n  * @param[out] r\t\t\t- the result.\n  * @param[in] p\t\t\t- the first point.\n  * @param[in] q\t\t\t- the point to subtract.\n  */\nvoid ep2_sub(ep2_t r, const ep2_t p, const ep2_t q);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[int] p\t\t\t- the point to double.\n */\nvoid ep2_dbl_basic(ep2_t r, const ep2_t p);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quadratic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep2_dbl_slp_basic(ep2_t r, fp2_t s, const ep2_t p);\n\n/**\n * Doubles a points represented in projective coordinates in an elliptic curve\n * over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep2_dbl_projc(ep2_t r, const ep2_t p);\n\n/**\n * Multiplies a prime elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_monty(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_lwnaf(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_lwreg(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies the generator of an elliptic curve over a qaudratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_gen(ep2_t r, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by a small integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_dig(ep2_t r, const ep2_t p, const dig_t k);\n\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field by\n * the curve cofactor or a small multiple for which a short vector exists.\n * In short, it takes a point in the curve to the large prime-order subgroup.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_cof(ep2_t r, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_basic(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_yaowi(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_nafwi(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_combs(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_combd(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_lwnaf(ep2_t *t, const ep2_t p);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_basic(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_yaowi(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_nafwi(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_combs(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_combd(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_lwnaf(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_basic(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies simultaneously elements from a prime elliptic curve.\n * Computes R = \\Sum_i=0..n k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the points to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n);\n\n/**\n * Multiplies and adds the generator and a prime elliptic curve point\n * simultaneously. Computes R = [k]G + [l]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies prime elliptic curve points by small scalars.\n * Computes R = \\sum k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the points to multiply.\n * @param[in] k\t\t\t\t- the small scalars.\n * @param[in] len\t\t\t- the number of points to multiply.\n */\nvoid ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ep2_norm(ep2_t r, const ep2_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ep2_norm_sim(ep2_t *r, const ep2_t *t, int n);\n\n/**\n * Maps an array of uniformly random bytes to a point in a prime elliptic\n * curve.\n * That array is expected to have a length suitable for four field elements plus\n * extra bytes for uniformity.\n  *\n * @param[out] p\t\t\t- the result.\n * @param[in] uniform_bytes\t\t- the array of uniform bytes to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quadratic extension.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep2_map(ep2_t p, const uint8_t *msg, int len);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quadratic extension\n * using an explicit domain separation tag.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separatoin tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);\n\n/**\n * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point\n * represented in affine coordinates on a twisted elliptic curve over a\n * quadratic exension. That is, Psi^i(P) = Twist(P)(Frob^i(unTwist(P)).\n * On the trace-zero group of a quadratic twist, consists of a power of the\n * Frobenius map of a point represented in affine coordinates in an elliptic\n * curve over a quadratic exension. Computes Frob^i(P) = (p^i)P.\n *\n * @param[out] r\t\t\t- the result in affine coordinates.\n * @param[in] p\t\t\t\t- a point in affine coordinates.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid ep2_frb(ep2_t r, const ep2_t p, int i);\n\n/**\n * Compresses a point in an elliptic curve over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ep2_pck(ep2_t r, const ep2_t p);\n\n/**\n * Decompresses a point in an elliptic curve over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint ep2_upk(ep2_t r, const ep2_t p);\n\n/**\n * Initializes the elliptic curve over quartic extension.\n */\nvoid ep4_curve_init(void);\n\n/**\n * Finalizes the elliptic curve over quartic extension.\n */\nvoid ep4_curve_clean(void);\n\n/**\n * Returns the 'a' coefficient of the currently configured elliptic curve.\n *\n * @return the 'a' coefficient of the elliptic curve.\n */\nvoid ep4_curve_get_a(fp4_t a);\n\n/**\n * Returns the 'b' coefficient of the currently configured elliptic curve.\n *\n * @param[out] b\t\t\t- the 'b' coefficient of the elliptic curve.\n */\nvoid ep4_curve_get_b(fp4_t b);\n\n/**\n * Returns the vector of coefficients required to perform GLV method.\n *\n * @param[out] b\t\t\t- the vector of coefficients.\n */\nvoid ep4_curve_get_vs(bn_t *v);\n\n/**\n * Returns a optimization identifier based on the 'a' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep4_curve_opt_a(void);\n\n/**\n * Returns b optimization identifier based on the 'b' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep4_curve_opt_b(void);\n\n/**\n * Tests if the configured elliptic curve is a twist.\n *\n * @return the type of the elliptic curve twist, 0 if non-twisted curve.\n */\nint ep4_curve_is_twist(void);\n\n/**\n * Returns the generator of the group of points in the elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ep4_curve_get_gen(ep4_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nep4_t *ep4_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the elliptic curve.\n *\n * @param[out] n\t\t\t- the returned order.\n */\nvoid ep4_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the group order in the elliptic curve.\n *\n * @param[out] h\t\t\t- the returned cofactor.\n */\nvoid ep4_curve_get_cof(bn_t h);\n\n/**\n * Configures an elliptic curve over a quartic extension by its coefficients.\n *\n * @param[in] a\t\t\t- the 'a' coefficient of the curve.\n * @param[in] b\t\t\t- the 'b' coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n */\nvoid ep4_curve_set(const fp4_t a, const fp4_t b, const ep4_t g, const bn_t r, const bn_t h);\n\n/**\n * Configures an elliptic curve by twisting the curve over the base prime field.\n *\n *  @param\t\t\t\t- the type of twist (multiplicative or divisive)\n */\nvoid ep4_curve_set_twist(int type);\n\n/**\n * Tests if a point on an elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ep4_is_infty(const ep4_t p);\n\n/**\n * Assigns an elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid ep4_set_infty(ep4_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t\t- the result.\n * @param[in] p\t\t\t\t- the elliptic curve point to copy.\n */\nvoid ep4_copy(ep4_t r, const ep4_t p);\n\n/**\n * Compares two elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first elliptic curve point.\n * @param[in] q\t\t\t\t- the second elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ep4_cmp(const ep4_t p, const ep4_t q);\n\n/**\n * Assigns a random value to an elliptic curve point.\n *\n * @param[out] p\t\t\t- the elliptic curve point to assign.\n */\nvoid ep4_rand(ep4_t p);\n\n/**\n * Randomizes coordinates of an elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded prime elliptic curve point.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to blind.\n */\nvoid ep4_blind(ep4_t r, const ep4_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep4_rhs(fp4_t rhs, const ep4_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint ep4_on_curve(const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a random prime elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ep4_tab(ep4_t *t, const ep4_t p, int w);\n\n/**\n * Prints an elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the elliptic curve point to print.\n */\nvoid ep4_print(const ep4_t p);\n\n/**\n * Returns the number of bytes necessary to store a prime elliptic curve point\n * over a quartic extension with optional point compression.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ep4_size_bin(const ep4_t a, int pack);\n\n/**\n * Reads a prime elliptic curve point over a quartic extension from a byte\n * vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep4_read_bin(ep4_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a prime elliptic curve pointer over a quartic extension to a byte\n * vector in big-endian format with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack);\n\n/**\n * Negates a point represented in affine coordinates in an elliptic curve over\n * a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the point to negate.\n */\nvoid ep4_neg(ep4_t r, const ep4_t p);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep4_add_basic(ep4_t r, const ep4_t p, const ep4_t q);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quartic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep4_add_slp_basic(ep4_t r, fp4_t s, const ep4_t p, const ep4_t q);\n\n/**\n * Adds two points represented in projective coordinates in an elliptic curve\n * over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep4_add_projc(ep4_t r, const ep4_t p, const ep4_t q);\n\n /**\n  * Subtracts a point i an elliptic curve over a quartic extension from\n  * another.\n  *\n  * @param[out] r\t\t\t- the result.\n  * @param[in] p\t\t\t- the first point.\n  * @param[in] q\t\t\t- the point to subtract.\n  */\nvoid ep4_sub(ep4_t r, const ep4_t p, const ep4_t q);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[int] p\t\t\t- the point to double.\n */\nvoid ep4_dbl_basic(ep4_t r, const ep4_t p);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quartic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep4_dbl_slp_basic(ep4_t r, fp4_t s, const ep4_t p);\n\n/**\n * Doubles a points represented in projective coordinates in an elliptic curve\n * over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep4_dbl_projc(ep4_t r, const ep4_t p);\n\n/**\n * Multiplies a prime elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_basic(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_monty(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_lwnaf(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_lwreg(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies the generator of an elliptic curve over a qaudratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_gen(ep4_t r, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by a small integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_dig(ep4_t r, const ep4_t p, const dig_t k);\n\n\n/**\n * Multiplies a point in an elliptic curve over a quartic extension field by\n * the curve cofactor or a small multiple for which a short vector exists.\n * In short, it takes a point in the curve to the large prime-order subgroup.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_cof(ep4_t r, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_basic(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_yaowi(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_nafwi(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_combs(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_combd(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_lwnaf(ep4_t *t, const ep4_t p);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_basic(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_yaowi(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_nafwi(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_combs(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_combd(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_lwnaf(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_basic(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_trick(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_inter(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies simultaneously elements from a prime elliptic curve.\n * Computes R = \\Sum_i=0..n k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t- the points to multiply.\n * @param[in] k\t\t\t- the integer scalars.\n * @param[in] n\t\t\t- the number of elements to multiply.\n */\nvoid ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n);\n\n/**\n * Multiplies and adds the generator and a prime elliptic curve point\n * simultaneously. Computes R = [k]G + [l]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies prime elliptic curve points by small scalars.\n * Computes R = \\sum k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the points to multiply.\n * @param[in] k\t\t\t\t- the small scalars.\n * @param[in] len\t\t\t- the number of points to multiply.\n */\nvoid ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ep4_norm(ep4_t r, const ep4_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ep4_norm_sim(ep4_t *r, const ep4_t *t, int n);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quartic extension.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep4_map(ep4_t p, const uint8_t *msg, int len);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quartic extension\n * using an explicit domain separation tag.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separatoin tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ep4_map_dst(ep4_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len);\n\n/**\n * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point\n * represented in affine coordinates on a twisted elliptic curve over a\n * quartic exension. That is, Psi^i(P) = Twist(P)(Frob^i(unTwist(P)).\n * On the trace-zero group of a quartic twist, consists of a power of the\n * Frobenius map of a point represented in affine coordinates in an elliptic\n * curve over a quartic exension. Computes Frob^i(P) = (p^i)P.\n *\n * @param[out] r\t\t\t- the result in affine coordinates.\n * @param[in] p\t\t\t\t- a point in affine coordinates.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid ep4_frb(ep4_t r, const ep4_t p, int i);\n\n/**\n * Compresses a point in an elliptic curve over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ep4_pck(ep4_t r, const ep4_t p);\n\n/**\n * Decompresses a point in an elliptic curve over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint ep4_upk(ep4_t r, const ep4_t p);\n\n#endif /* !RLC_EPX_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup fb Binary field arithmetic\n */\n\n/**\n * @file\n *\n * Interface of module for binary field arithmetic.\n *\n * @ingroup fb\n */\n\n#ifndef RLC_FB_H\n#define RLC_FB_H\n\n#include \"relic_bn.h\"\n#include \"relic_dv.h\"\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a binary field element.\n */\n#define RLC_FB_BITS \t((int)FB_POLYN)\n\n/**\n * Size in digits of a block sufficient to store a binary field element.\n */\n#define RLC_FB_DIGS\t\t((int)RLC_CEIL(RLC_FB_BITS, RLC_DIG))\n\n/**\n * Size in bytes of a block sufficient to store a binary field element.\n */\n#define RLC_FB_BYTES \t((int)RLC_CEIL(RLC_FB_BITS, 8))\n\n/**\n * Finite field identifiers.\n */\nenum {\n\t/** AES pentaonimal. */\n\tPENTA_8 = 1,\n\t/** Toy pentanomial. */\n\tPENTA_64,\n\t/** Hankerson's trinomial for GLS curves. */\n\tTRINO_113,\n\t/** Hankerson's trinomial for GLS curves. */\n\tTRINO_127,\n\t/** GCM pentanomial */\n\tPENTA_128,\n\t/** Pentanomial for ECC2K-130 challenge. */\n\tPENTA_131,\n\t/** NIST 163-bit fast reduction polynomial. */\n\tNIST_163,\n\t/** Square-root friendly 163-bit polynomial. */\n\tSQRT_163,\n\t/** Example with 193 bits for Itoh-Tsuji. */\n\tTRINO_193,\n\t/** NIST 233-bit fast reduction polynomial. */\n\tNIST_233,\n\t/** Square-root friendly 233-bit polynomial. */\n\tSQRT_233,\n\t/** SECG 239-bit fast reduction polynomial. */\n\tSECG_239,\n\t/** Square-root friendly 239-bit polynomial. */\n\tSQRT_239,\n\t/** Square-root friendly 251-bit polynomial. */\n\tSQRT_251,\n\t/** eBATS curve_2_251 pentanomial. */\n\tPENTA_251,\n\t/** Hankerson's trinomial for halving curve. */\n\tTRINO_257,\n\t/** Scott's 271-bit pairing-friendly trinomial. */\n\tTRINO_271,\n\t/** Scott's 271-bit pairing-friendly pentanomial. */\n\tPENTA_271,\n\t/** NIST 283-bit fast reduction polynomial. */\n\tNIST_283,\n\t/** Square-root friendly 283-bit polynomial. */\n\tSQRT_283,\n\t/** Scott's 271-bit pairing-friendly trinomial. */\n\tTRINO_353,\n\t/** Detrey's trinomial for genus 2 curves. */\n\tTRINO_367,\n\t/** NIST 409-bit fast reduction polynomial. */\n\tNIST_409,\n\t/** Hankerson's trinomial for genus 2 curves. */\n\tTRINO_439,\n\t/** NIST 571-bit fast reduction polynomial. */\n\tNIST_571,\n\t/** Square-root friendly 571-bit polynomial. */\n\tSQRT_571,\n\t/** Scott's 1223-bit pairing-friendly trinomial. */\n\tTRINO_1223\n};\n\n/**\n * Size of a precomputation table for repeated squaring/square-root using the\n * trivial approach.\n */\n#define RLC_FB_TABLE_BASIC\t\t(1)\n\n/**\n * Size of a precomputation table for repeated squaring/square-root using the\n * faster approach.\n */\n#define RLC_FB_TABLE_QUICK      ((RLC_DIG / 4) * RLC_FB_DIGS * 16)\n\n/**\n * Size of a precomputation table for repeated squaring/square-root using the\n * chosen algorithm.\n */\n#if FB_ITR == BASIC\n#define RLC_FB_TABLE \t\t\tRLC_FB_TABLE_BASIC\n#else\n#define RLC_FB_TABLE\t\t\tRLC_FB_TABLE_QUICK\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_FB_TABLE_MAX \t\tRLC_FB_TABLE\n#else\n#define RLC_FB_TABLE_MAX \t\tRLC_FB_TABLE_QUICK\n#endif\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a binary field element.\n */\n#if ALLOC == AUTO\ntypedef rlc_align dig_t fb_t[RLC_FB_DIGS + RLC_PAD(RLC_FB_BYTES) / (RLC_DIG / 8)];\n#else\ntypedef dig_t *fb_t;\n#endif\n\n/**\n * Represents a binary field element with automatic memory allocation.\n */\ntypedef rlc_align dig_t fb_st[RLC_FB_DIGS + RLC_PAD(RLC_FB_BYTES) / (RLC_DIG / 8)];\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a binary field element with a null value.\n *\n * @param[out] A\t\t\t- the binary field element to initialize.\n */\n#if ALLOC == AUTO\n#define fb_null(A)\t\t\t/* empty */\n#else\n#define fb_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a binary field element.\n *\n * @param[out] A\t\t\t- the new binary field element.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define fb_new(A)\t\t\tdv_new_dynam((dv_t *)&(A), RLC_FB_DIGS)\n#elif ALLOC == AUTO\n#define fb_new(A)\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to free a binary field element.\n *\n * @param[out] A\t\t\t- the binary field element to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define fb_free(A)\t\t\tdv_free_dynam((dv_t *)&(A))\n#elif ALLOC == AUTO\n#define fb_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Multiples two binary field elements. Computes c = a * b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first binary field element to multiply.\n * @param[in] B\t\t\t\t- the second binary field element to multiply.\n */\n#if FB_KARAT > 0\n#define fb_mul(C, A, B)\t\tfb_mul_karat(C, A, B)\n#elif FB_MUL == BASIC\n#define fb_mul(C, A, B)\t\tfb_mul_basic(C, A, B)\n#elif FB_MUL == INTEG\n#define fb_mul(C, A, B)\t\tfb_mul_integ(C, A, B)\n#elif FB_MUL == LODAH\n#define fb_mul(C, A, B)\t\tfb_mul_lodah(C, A, B)\n#endif\n\n/**\n * Squares a binary field element. Computes c = a * a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element to square.\n */\n#if FB_SQR == BASIC\n#define fb_sqr(C, A)\t\tfb_sqr_basic(C, A)\n#elif FB_SQR == QUICK\n#define fb_sqr(C, A)\t\tfb_sqr_quick(C, A)\n#elif FB_SQR == INTEG\n#define fb_sqr(C, A)\t\tfb_sqr_integ(C, A)\n#endif\n\n/**\n * Extracts the square root of a binary field element. Computes c = a^(1/2).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element.\n */\n#if FB_SRT == BASIC\n#define fb_srt(C, A)\t\tfb_srt_basic(C, A)\n#elif FB_SRT == QUICK\n#define fb_srt(C, A)\t\tfb_srt_quick(C, A)\n#endif\n\n/**\n * Reduces a multiplication result modulo a binary irreducible polynomial.\n * Computes c = a mod f(z).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiplication result to reduce.\n */\n#if FB_RDC == BASIC\n#define fb_rdc(C, A)\t\tfb_rdc_basic(C, A)\n#elif FB_RDC == QUICK\n#define fb_rdc(C, A)\t\tfb_rdc_quick(C, A)\n#endif\n\n/**\n * Compute the trace of a binary field element. Computes c = Tr(a).\n *\n * @param[in] A\t\t\t\t- the binary field element.\n * @return the trace of the binary field element.\n */\n#if FB_TRC == BASIC\n#define fb_trc(A)\t\t\tfb_trc_basic(A)\n#elif FB_TRC == QUICK\n#define fb_trc(A)\t\t\tfb_trc_quick(A)\n#endif\n\n/**\n * Solves a quadratic equation for c, Tr(a) = 0. Computes c such that\n * c^2 + c = a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element.\n */\n#if FB_SLV == BASIC\n#define fb_slv(C, A)\t\tfb_slv_basic(C, A)\n#elif FB_SLV == QUICK\n#define fb_slv(C, A)\t\tfb_slv_quick(C, A)\n#endif\n\n/**\n * Inverts a binary field element. Computes c = a^{-1}.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element to invert.\n */\n#if FB_INV == BASIC\n#define fb_inv(C, A)\t\tfb_inv_basic(C, A)\n#elif FB_INV == BINAR\n#define fb_inv(C, A)\t\tfb_inv_binar(C, A)\n#elif FB_INV == EXGCD\n#define fb_inv(C, A)\t\tfb_inv_exgcd(C, A)\n#elif FB_INV == ALMOS\n#define fb_inv(C, A)\t\tfb_inv_almos(C, A)\n#elif FB_INV == ITOHT\n#define fb_inv(C, A)\t\tfb_inv_itoht(C, A)\n#elif FB_INV == BRUCH\n#define fb_inv(C, A)\t\tfb_inv_bruch(C, A)\n#elif FB_INV == CTAIA\n#define fb_inv(C, A)\t\tfb_inv_ctaia(C, A)\n#elif FB_INV == LOWER\n#define fb_inv(C, A)\t\tfb_inv_lower(C, A)\n#endif\n\n/**\n * Exponentiates a binary field element. Computes c = a^b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n */\n#if FB_EXP == BASIC\n#define fb_exp(C, A, B)\t\tfb_exp_basic(C, A, B)\n#elif FB_EXP == SLIDE\n#define fb_exp(C, A, B)\t\tfb_exp_slide(C, A, B)\n#elif FB_EXP == MONTY\n#define fb_exp(C, A, B)\t\tfb_exp_monty(C, A, B)\n#endif\n\n/**\n * Precomputed the table for repeated squaring/square-root.\n *\n * @param[out] T\t\t\t- the table.\n * @param[in] B\t\t\t\t- the exponent.\n */\n#if FB_ITR == BASIC\n#define fb_itr_pre(T, B)\t(void)(T), (void)(B)\n#elif FB_ITR == QUICK\n#define fb_itr_pre(T, B)\tfb_itr_pre_quick(T, B)\n#endif\n\n/**\n * Computes the repeated Frobenius (squaring) or inverse Frobenius (square-root)\n * of a binary field element. If the number of arguments is 3, then simple\n * consecutive squaring/square-root is used. If the number of arguments if 4,\n * then a table-based method is used and the fourth argument is\n * a pointer fo the precomputed table. The variant with 4 arguments\n * should be used when several 2^k/2^-k powers are computed with the same\n * k. Computes c = a^(2^b), where b can be positive or negative.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element to exponentiate.\n * @param[in] B\t\t\t\t- the exponent.\n * @param[in] ...\t\t\t- the modulus and an optional argument.\n */\n#define fb_itr(C, A, ...)\tRLC_CAT(fb_itr, RLC_OPT(__VA_ARGS__)) (C, A, __VA_ARGS__)\n\n/**\n * Reduces a multiple precision integer modulo another integer. This macro\n * should not be called directly. Use bn_mod() with 4 arguments instead.\n *\n * @param[out] C\t\t\t\t- the result.\n * @param[in] A\t\t\t\t\t- the binary field element to exponentiate.\n * @param[in] B\t\t\t\t\t- the exponent.\n * @param[in] T\t\t\t\t\t- the precomputed table for the exponent.\n */\n#if FB_ITR == BASIC\n#define fb_itr_imp(C, A, B, T)\t\tfb_itr_basic(C, A, B)\n#elif FB_ITR == QUICK\n#define fb_itr_imp(C, A, B, T)\t\tfb_itr_quick(C, A, T)\n#endif\n/*============================================================================*/\n\t\t/* Function prototypes                                                        */\n/*============================================================================*/\n/**\n * Initializes the binary field arithmetic layer.\n */\nvoid fb_poly_init(void);\n\n/**\n * Finalizes the binary field arithmetic layer.\n */\nvoid fb_poly_clean(void);\n\n/**\n * Returns the irreducible polynomial f(z) configured for the binary field.\n *\n * @return the irreducible polynomial.\n */\ndig_t *fb_poly_get(void);\n\n/**\n * Configures the irreducible polynomial of the binary field as a dense\n * polynomial.\n *\n * @param[in] f\t\t\t\t- the new irreducible polynomial.\n */\nvoid fb_poly_set_dense(const fb_t f);\n\n/**\n * Configures a trinomial as the irreducible polynomial by its non-zero\n * coefficients. The other coefficients are RLC_FB_BITS and 0.\n *\n * @param[in] a\t\t\t\t- the second coefficient.\n */\nvoid fb_poly_set_trino(int a);\n\n/**\n * Configures a pentanomial as the binary field modulo by its non-zero\n * coefficients. The other coefficients are RLC_FB_BITS and 0.\n *\n * @param[in] a\t\t\t\t- the second coefficient.\n * @param[in] b\t\t\t\t- the third coefficient.\n * @param[in] c\t\t\t\t- the fourth coefficient.\n */\nvoid fb_poly_set_penta(int a, int b, int c);\n\n/**\n * Returns the square root of z.\n *\n * @return the square root of z.\n */\ndig_t *fb_poly_get_srz(void);\n\n/**\n * Returns sqrt(z) * (i represented as a polynomial).\n *\n * @return the precomputed result.\n */\nconst dig_t *fb_poly_tab_srz(int i);\n\n/**\n * Returns a table for accelerating repeated squarings.\n *\n * @param the number of the table.\n * @return the precomputed result.\n */\nconst fb_st *fb_poly_tab_sqr(int i);\n\n/**\n * Returns an addition chain for (RLC_FB_BITS - 1).\n *\n * @param[out] len\t\t\t- the number of elements in the addition chain.\n *\n * @return a pointer to the addition chain.\n */\nconst int *fb_poly_get_chain(int *len);\n\n/**\n * Returns the non-zero coefficients of the configured trinomial or pentanomial.\n * If b is -1, the irreducible polynomial configured is a trinomial.\n * The other coefficients are RLC_FB_BITS and 0.\n *\n * @param[out] a\t\t\t- the second coefficient.\n * @param[out] b\t\t\t- the third coefficient.\n * @param[out] c\t\t\t- the fourth coefficient.\n */\nvoid fb_poly_get_rdc(int *a, int *b, int *c);\n\n/**\n * Returns the non-zero bits used to compute the trace function. The -1\n * coefficient is the last coefficient.\n *\n * @param[out] a\t\t\t- the first coefficient.\n * @param[out] b\t\t\t- the second coefficient.\n * @param[out] c\t\t\t- the third coefficient.\n */\nvoid fb_poly_get_trc(int *a, int *b, int *c);\n\n/**\n * Returns the table of precomputed half-traces.\n *\n * @return the table of half-traces.\n */\nconst dig_t *fb_poly_get_slv(void);\n\n/**\n * Assigns a standard irreducible polynomial as modulo of the binary field.\n *\n * @param[in] param\t\t\t- the standardized polynomial identifier.\n */\nvoid fb_param_set(int param);\n\n/**\n * Configures some finite field parameters for the current security level.\n */\nvoid fb_param_set_any(void);\n\n/**\n * Prints the currently configured irreducible polynomial.\n */\nvoid fb_param_print(void);\n\n/**\n * Adds a binary field element and the irreducible polynomial. Computes\n * c = a + f(z).\n *\n * @param[out] c\t\t\t- the destination.\n * @param[in] a\t\t\t\t- the binary field element.\n */\nvoid fb_poly_add(fb_t c, const fb_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to copy.\n */\nvoid fb_copy(fb_t c, const fb_t a);\n\n/**\n * Negates a binary field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the binary field element to negate.\n */\nvoid fb_neg(fb_t c, const fb_t a);\n\n/**\n * Assigns zero to a binary field element.\n *\n * @param[out] a\t\t\t- the binary field element to assign.\n */\nvoid fb_zero(fb_t a);\n\n/**\n * Tests if a binary field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the binary field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fb_is_zero(const fb_t a);\n\n/**\n * Reads the bit stored in the given position on a binary field element.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] bit\t\t\t- the bit position.\n * @return the bit value.\n */\nint fb_get_bit(const fb_t a, int bit);\n\n/**\n * Stores a bit in a given position on a binary field element.\n *\n * @param[out] a\t\t\t- the binary field element.\n * @param[in] bit\t\t\t- the bit position.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid fb_set_bit(fb_t a, int bit, int value);\n\n/**\n * Assigns a small positive polynomial to a binary field element.\n *\n * The degree of the polynomial must be smaller than RLC_DIG.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the small polynomial to assign.\n */\nvoid fb_set_dig(fb_t c, dig_t a);\n\n/**\n * Returns the number of bits of a binary field element.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @return the number of bits.\n */\nint fb_bits(const fb_t a);\n\n/**\n * Assigns a random value to a binary field element.\n *\n * @param[out] a\t\t\t- the binary field element to assign.\n */\nvoid fb_rand(fb_t a);\n\n/**\n * Prints a binary field element to standard output.\n *\n * @param[in] a\t\t\t\t- the binary field element to print.\n */\nvoid fb_print(const fb_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a binary field\n * element. The radix must be a power of 2 included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nint fb_size_str(const fb_t a, int radix);\n\n/**\n * Reads a binary field element from a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the string is too long.\n */\nvoid fb_read_str(fb_t a, const char *str, int len, int radix);\n\n/**\n * Writes a binary field element to a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the binary field element to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid fb_write_str(char *str, int len, const fb_t a, int radix);\n\n/**\n * Reads a binary field element from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fb_read_bin(fb_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a binary field element to a byte vector in big-endian format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the binary field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fb_write_bin(uint8_t *bin, int len, const fb_t a);\n\n/**\n * Returns the result of a comparison between two binary field elements.\n *\n * @param[in] a\t\t\t\t- the first binary field element.\n * @param[in] b\t\t\t\t- the second binary field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fb_cmp(const fb_t a, const fb_t b);\n\n/**\n * Returns the result of a comparison between a binary field element\n * and a small binary field element.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] b\t\t\t\t- the small binary field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fb_cmp_dig(const fb_t a, dig_t b);\n\n/**\n * Adds two binary field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to add.\n * @param[in] b\t\t\t\t- the second binary field element to add.\n */\nvoid fb_add(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Adds a binary field element and a small binary field element.\n * Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to add.\n * @param[in] b\t\t\t\t- the small binary field element to add.\n */\nvoid fb_add_dig(fb_t c, const fb_t a, dig_t b);\n\n/**\n * Multiples two binary field elements using Shift-and-add multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to multiply.\n * @param[in] b\t\t\t\t- the second binary field element to multiply.\n */\nvoid fb_mul_basic(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Multiples two binary field elements using multiplication integrated with\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to multiply.\n * @param[in] b\t\t\t\t- the second binary field element to multiply.\n */\nvoid fb_mul_integ(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Multiples two binary field elements using Lopez-Dahab multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to multiply.\n * @param[in] b\t\t\t\t- the second binary field element to multiply.\n */\nvoid fb_mul_lodah(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Multiplies a binary field element by a small binary field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] b\t\t\t\t- the small binary field element to multiply.\n */\nvoid fb_mul_dig(fb_t c, const fb_t a, dig_t b);\n\n/**\n * Multiples two binary field elements using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element.\n * @param[in] b\t\t\t\t- the second binary field element.\n */\nvoid fb_mul_karat(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Squares a binary field element using bit-manipulation squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fb_sqr_basic(fb_t c, const fb_t a);\n\n/**\n * Squares a binary field element with integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fb_sqr_integ(fb_t c, const fb_t a);\n\n/**\n * Squares a binary field element using table-based squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fb_sqr_quick(fb_t c, const fb_t a);\n\n/**\n * Shifts a binary field element to the left. Computes c = a * z^bits mod f(z).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fb_lsh(fb_t c, const fb_t a, int bits);\n\n/**\n* Shifts a binary field element to the right. Computes c = a / (z^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fb_rsh(fb_t c, const fb_t a, int bits);\n\n/**\n * Reduces a multiplication result modulo an irreducible polynomial using\n * shift-and-add modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fb_rdc_basic(fb_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo a trinomial or pentanomial.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fb_rdc_quick(fb_t c, dv_t a);\n\n/**\n * Extracts the square root of a binary field element using repeated squaring.\n * Computes c = a^{1/2}.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to take a square root.\n */\nvoid fb_srt_basic(fb_t c, const fb_t a);\n\n/**\n * Extracts the square root of a binary field element using a fast square root\n * extraction algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to take a square root.\n */\nvoid fb_srt_quick(fb_t c, const fb_t a);\n\n/**\n * Computes the trace of a binary field element using repeated squaring.\n * Returns Tr(a).\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @return the trace of the binary field element.\n */\ndig_t fb_trc_basic(const fb_t a);\n\n/**\n * Computes the trace of a binary field element using a fast trace computation\n * algorithm. Returns Tr(a).\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @return the trace of the binary field element.\n */\ndig_t fb_trc_quick(const fb_t a);\n\n/**\n * Inverts a binary field element using Fermat's Little Theorem.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_basic(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_binar(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the Extended Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_exgcd(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the Almost Inverse algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_almos(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using Itoh-Tsuji inversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_itoht(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the hardware-friendly\n * Brunner-Curiger-Hofstetter algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_bruch(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element in constant-time using\n * the Wu-Wu-Shieh-Hwang algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_ctaia(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using a direct call to the lower layer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_lower(fb_t c, const fb_t a);\n\n/**\n * Inverts multiple binary field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fb_inv_sim(fb_t *c, const fb_t *a, int n);\n\n/**\n * Exponentiates a binary field element through consecutive squaring. Computes\n * c = a^(2^b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_2b(fb_t c, const fb_t a, int b);\n\n/**\n * Exponentiates a binary field element using the binary\n * method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_basic(fb_t c, const fb_t a, const bn_t b);\n\n/**\n * Exponentiates a binary field element using the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_slide(fb_t c, const fb_t a, const bn_t b);\n\n/**\n * Exponentiates a binary field element using the constant-time Montgomery\n * powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_monty(fb_t c, const fb_t a, const bn_t b);\n\n/**\n * Solves a quadratic equation for a, Tr(a) = 0 by repeated squarings and\n * additions.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to solve.\n */\nvoid fb_slv_basic(fb_t c, const fb_t a);\n\n/**\n * Solves a quadratic equation for a, Tr(a) = 0 with precomputed half-traces.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to solve.\n */\nvoid fb_slv_quick(fb_t c, const fb_t a);\n\n/**\n * Computes the iterated squaring/square-root of a binary field element by\n * consecutive squaring/square-root. Computes c = a^(2^b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_itr_basic(fb_t c, const fb_t a, int b);\n\n/**\n * Precomputes a table for iterated squaring/square-root of a binary field\n * element.\n *\n * @param[out] t\t\t\t- the precomputed table.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_itr_pre_quick(fb_st *t, int b);\n\n/**\n * Computes the iterated squaring/square-root of a binary field element by\n * a table based method. Computes c = a^(2^b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] t\t\t\t\t- the precomputed table.\n */\nvoid fb_itr_quick(fb_t c, const fb_t a, const fb_st *t);\n\n#endif /* !RLC_FB_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup fp Prime field arithmetic\n */\n\n/**\n * @file\n *\n * Interface of the module for prime field arithmetic.\n *\n * @ingroup fp\n */\n\n#ifndef RLC_FP_H\n#define RLC_FP_H\n\n#include \"relic_dv.h\"\n#include \"relic_bn.h\"\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a prime field element.\n */\n#define RLC_FP_BITS \t((int)FP_PRIME)\n\n/**\n * Size in digits of a block sufficient to store a prime field element.\n */\n#define RLC_FP_DIGS \t((int)RLC_CEIL(RLC_FP_BITS, RLC_DIG))\n\n/**\n * Size in bytes of a block sufficient to store a binary field element.\n */\n#define RLC_FP_BYTES \t((int)RLC_CEIL(RLC_FP_BITS, 8))\n\n/*\n * Finite field identifiers.\n */\nenum {\n\t/** SECG 160-bit fast reduction prime. */\n\tSECG_160 = 1,\n\t/** SECG 160-bit denser reduction prime. */\n\tSECG_160D,\n\t/** NIST 192-bit fast reduction prime. */\n\tNIST_192,\n\t/** SECG 192-bit denser reduction prime. */\n\tSECG_192,\n\t/** Curve22103 221-bit prime modulus. */\n\tPRIME_22103,\n\t/** NIST 224-bit fast reduction polynomial. */\n\tNIST_224,\n\t/** SECG 224-bit denser reduction prime. */\n\tSECG_224,\n\t/** Curve4417 226-bit prime modulus. */\n\tPRIME_22605,\n\t/* Curve1174 251-bit prime modulus. */\n\tPRIME_25109,\n\t/** Prime with high 2-adicity for curve Tweedledum. */\n\tPRIME_H2ADC,\n\t/** Curve25519 255-bit prime modulus. */\n\tPRIME_25519,\n\t/** NIST 256-bit fast reduction polynomial. */\n\tNIST_256,\n\t/** Brainpool random 256-bit prime. */\n\tBSI_256,\n\t/** SECG 256-bit denser reduction prime. */\n\tSECG_256,\n\t/** SM2 256-bit prime modulus standardized in China. */\n\tSM2_256,\n\t/** Curve67254 382-bit prime modulus. */\n\tPRIME_382105,\n\t/** Curve383187 383-bit prime modulus. */\n\tPRIME_383187,\n\t/** NIST 384-bit fast reduction polynomial. */\n\tNIST_384,\n\t/** Curve448 prime. */\n\tPRIME_448,\n\t/** Curve511187 511-bit prime modulus. */\n\tPRIME_511187,\n\t/** NIST 521-bit fast reduction polynomial. */\n\tNIST_521,\n\t/** 158-bit prime for BN curve. */\n\tBN_158,\n\t/** 254-bit prime provided in Nogami et al. for BN curves. */\n\tBN_254,\n\t/** 256-bit prime provided in Barreto et al. for BN curves. */\n\tBN_256,\n\t/** 256-bit prime provided for BN curve standardized in China. */\n\tSM9_256,\n\t/** 315-bit prime for BLS curve of embedding degree 24 (SNARKs). */\n\tB24_315,\n\t/** 317-bit prime for BLS curve of embedding degree 24 (SNARKs). */\n\tB24_317,\n\t/** 381-bit prime for BLS curve of embedding degree 12 (SNARKs). */\n\tB12_377,\n\t/** 381-bit prime for BLS curve of embedding degree 12 (Zcash). */\n\tB12_381,\n\t/** 382-bit prime provided by Barreto for BN curve. */\n\tBN_382,\n\t/** 383-bit prime for GT-strong BLS curve of embedding degree 12. */\n\tB12_383,\n\t/** 446-bit prime provided by Barreto for BN curve. */\n\tBN_446,\n\t/** 446-bit prime for BLS curve of embedding degree 12. */\n\tB12_446,\n\t/** 455-bit prime for BLS curve of embedding degree 12. */\n\tB12_455,\n\t/** 477-bit prime for BLS curve of embedding degree 24. */\n\tB24_509,\n\t/** 508-bit prime for KSS16 curve. */\n\tKSS_508,\n\t/** 511-bit prime for Optimal TNFS-secure curve. */\n\tOT_511,\n\t/** Random 544-bit prime for Cocks-Pinch curve with embedding degree 8. */\n\tGMT8_544,\n\t/** 569-bit prime for KSS curve with embedding degree 54. */\n\tK54_569,\n\t/** 575-bit prime for BLS curve with embedding degree 48. */\n\tB48_575,\n\t/** 638-bit prime provided in Barreto et al. for BN curve. */\n\tBN_638,\n\t/** 638-bit prime for BLS curve with embedding degree 12. */\n\tB12_638,\n\t/** 1536-bit prime for supersingular curve with embedding degree k = 2. */\n\tSS_1536,\n\t/** 3072-bit prime for supersingular curve with embedding degree k = 1. */\n\tSS_3072,\n};\n\n/**\n * Constant used to indicate that there's some room left in the storage of\n * prime field elements. This can be used to avoid carries.\n */\n#if ((FP_PRIME % WSIZE) != 0) && ((FP_PRIME % WSIZE) <= (WSIZE - 2))\n#if ((2 * FP_PRIME % WSIZE) != 0) && ((2 * FP_PRIME % WSIZE) <= (WSIZE - 2))\n#define RLC_FP_ROOM\n#else\n#undef RLC_FP_ROOM\n#endif\n#else\n#undef RLC_FP_ROOM\n#endif\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a prime field element.\n *\n * A field element is represented as a digit vector. These digits are organized\n * in little-endian format, that is, the least significant digits are\n * stored in the first positions of the vector.\n */\n#if ALLOC == AUTO\ntypedef rlc_align dig_t fp_t[RLC_FP_DIGS + RLC_PAD(RLC_FP_BYTES)/(RLC_DIG / 8)];\n#else\ntypedef dig_t *fp_t;\n#endif\n\n/**\n * Represents a prime field element with automatic memory allocation.\n */\ntypedef rlc_align dig_t fp_st[RLC_FP_DIGS + RLC_PAD(RLC_FP_BYTES)/(RLC_DIG / 8)];\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a binary field element with a null value.\n *\n * @param[out] A\t\t\t- the binary field element to initialize.\n */\n#if ALLOC == AUTO\n#define fp_null(A)\t\t\t/* empty */\n#else\n#define fp_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate and initialize a prime field element.\n *\n * @param[out] A\t\t\t- the new prime field element.\n */\n#if ALLOC == DYNAMIC\n#define fp_new(A)\t\t\tdv_new_dynam((dv_t *)&(A), RLC_FP_DIGS)\n#elif ALLOC == AUTO\n#define fp_new(A)\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free a prime field element.\n *\n * @param[out] A\t\t\t- the prime field element to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define fp_free(A)\t\t\tdv_free_dynam((dv_t *)&(A))\n#elif ALLOC == AUTO\n#define fp_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Adds two prime field elements. Computes c = a + b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n * @param[in] B\t\t\t\t- the second prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_add(C, A, B)\t\tfp_add_basic(C, A, B)\n#elif FP_ADD == INTEG\n#define fp_add(C, A, B)\t\tfp_add_integ(C, A, B)\n#endif\n\n/**\n * Subtracts a prime field element from another. Computes C = A - B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n * @param[in] B\t\t\t\t- the second prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_sub(C, A, B)\t\tfp_sub_basic(C, A, B)\n#elif FP_ADD == INTEG\n#define fp_sub(C, A, B)\t\tfp_sub_integ(C, A, B)\n#endif\n\n/**\n * Negates a prime field element from another. Computes C = -A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to negate.\n */\n#if FP_ADD == BASIC\n#define fp_neg(C, A)\t\tfp_neg_basic(C, A)\n#elif FP_ADD == INTEG\n#define fp_neg(C, A)\t\tfp_neg_integ(C, A)\n#endif\n\n/**\n * Doubles a prime field element. Computes C = A + A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_dbl(C, A)\t\tfp_dbl_basic(C, A)\n#elif FP_ADD == INTEG\n#define fp_dbl(C, A)\t\tfp_dbl_integ(C, A)\n#endif\n\n/**\n * Halves a prime field element. Computes C = A/2.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_hlv(C, A)\t\tfp_hlv_basic(C, A)\n#elif FP_ADD == INTEG\n#define fp_hlv(C, A)\t\tfp_hlv_integ(C, A)\n#endif\n\n/**\n * Multiples two prime field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n * @param[in] B\t\t\t\t- the second prime field element.\n */\n#if FP_KARAT > 0\n#define fp_mul(C, A, B)\t\tfp_mul_karat(C, A, B)\n#elif FP_MUL == BASIC\n#define fp_mul(C, A, B)\t\tfp_mul_basic(C, A, B)\n#elif FP_MUL == COMBA\n#define fp_mul(C, A, B)\t\tfp_mul_comba(C, A, B)\n#elif FP_MUL == INTEG\n#define fp_mul(C, A, B)\t\tfp_mul_integ(C, A, B)\n#endif\n\n/**\n * Squares a prime field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to square.\n */\n#if FP_KARAT > 0\n#define fp_sqr(C, A)\t\tfp_sqr_karat(C, A)\n#elif FP_SQR == BASIC\n#define fp_sqr(C, A)\t\tfp_sqr_basic(C, A)\n#elif FP_SQR == COMBA\n#define fp_sqr(C, A)\t\tfp_sqr_comba(C, A)\n#elif FP_SQR == MULTP\n#define fp_sqr(C, A)\t\tfp_mul(C, A, A)\n#elif FP_SQR == INTEG\n#define fp_sqr(C, A)\t\tfp_sqr_integ(C, A)\n#endif\n\n/**\n * Reduces a multiplication result modulo a prime field order. Computes\n * C = A mod p.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiplication result to reduce.\n */\n#if FP_RDC == BASIC\n#define fp_rdc(C, A)\t\tfp_rdc_basic(C, A)\n#elif FP_RDC == MONTY\n#define fp_rdc(C, A)\t\tfp_rdc_monty(C, A)\n#elif FP_RDC == QUICK\n#define fp_rdc(C, A)\t\tfp_rdc_quick(C, A)\n#endif\n\n/**\n * Reduces a multiplication result modulo a prime field order using Montgomery\n * modular reduction.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiplication result to reduce.\n */\n#if FP_MUL == BASIC\n#define fp_rdc_monty(C, A)\tfp_rdc_monty_basic(C, A)\n#else\n#define fp_rdc_monty(C, A)\tfp_rdc_monty_comba(C, A)\n#endif\n\n/**\n * Inverts a prime field element. Computes C = A^{-1}.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to invert.\n */\n#if FP_INV == BASIC\n#define fp_inv(C, A)\tfp_inv_basic(C, A)\n#elif FP_INV == BINAR\n#define fp_inv(C, A)\tfp_inv_binar(C, A)\n#elif FP_INV == MONTY\n#define fp_inv(C, A)\tfp_inv_monty(C, A)\n#elif FP_INV == EXGCD\n#define fp_inv(C, A)\tfp_inv_exgcd(C, A)\n#elif FP_INV == DIVST\n#define fp_inv(C, A)\tfp_inv_divst(C, A)\n#elif FP_INV == JMPDS\n#define fp_inv(C, A)\tfp_inv_jmpds(C, A)\n#elif FP_INV == LOWER\n#define fp_inv(C, A)\tfp_inv_lower(C, A)\n#endif\n\n/**\n * Computes the Legendre symbol of a prime field element. Computes C = (A|P).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to compute.\n */\n#if FP_SMB == BASIC\n#define fp_smb(A)\t\tfp_smb_basic(A)\n#elif FP_SMB == BINAR\n#define fp_smb(A)\t\tfp_smb_binar(A)\n#elif FP_SMB == DIVST\n#define fp_smb(A)\t\tfp_smb_divst(A)\n#elif FP_SMB == JMPDS\n#define fp_smb(A)\t\tfp_smb_jmpds(A)\n#elif FP_SMB == LOWER\n#define fp_smb(A)\t\tfp_smb_lower(A)\n#endif\n\n/**\n * Exponentiates a prime field element. Computes C = A^B (mod p).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n */\n#if FP_EXP == BASIC\n#define fp_exp(C, A, B)\t\tfp_exp_basic(C, A, B)\n#elif FP_EXP == SLIDE\n#define fp_exp(C, A, B)\t\tfp_exp_slide(C, A, B)\n#elif FP_EXP == MONTY\n#define fp_exp(C, A, B)\t\tfp_exp_monty(C, A, B)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the prime field arithmetic layer.\n */\nvoid fp_prime_init(void);\n\n/**\n * Finalizes the prime field arithmetic layer.\n */\nvoid fp_prime_clean(void);\n\n/**\n * Returns the order of the prime field.\n *\n * @return the order of the prime field.\n */\nconst dig_t *fp_prime_get(void);\n\n/**\n * Returns the additional value used for modular reduction.\n *\n * @return the additional value used for modular reduction.\n */\nconst dig_t *fp_prime_get_rdc(void);\n\n/**\n * Returns the additional value used for conversion from multiple precision\n * integer to prime field element.\n *\n * @return the additional value used for importing integers.\n */\nconst dig_t *fp_prime_get_conv(void);\n\n/**\n * Returns the result of prime order mod 8.\n *\n * @return the result of prime order mod 8.\n */\ndig_t fp_prime_get_mod8(void);\n\n/**\n * Returns the prime stored in special form. The most significant bit is\n * RLC_FP_BITS.\n *\n * @param[out] len\t\t- the number of returned bits, can be NULL.\n *\n * @return the prime represented by it non-zero bits.\n */\nconst int *fp_prime_get_sps(int *len);\n\n/**\n * Returns a non-quadratic residue in the prime field.\n *\n * @return the non-quadratic residue.\n */\nint fp_prime_get_qnr(void);\n\n/**\n * Returns a non-cubic residue in the prime field.\n *\n * @return the non-cubic residue.\n */\nint fp_prime_get_cnr(void);\n\n/**\n * Returns the 2-adicity of the prime modulus.\n *\n * @return the 2-adicity of the modulus.\n */\nint fp_prime_get_2ad(void);\n\n/**\n * Returns the prime field parameter identifier.\n *\n * @return the parameter identifier.\n */\nint fp_param_get(void);\n\n/**\n * Assigns the prime field modulus to a non-sparse prime.\n *\n * @param[in] p\t\t\t- the new prime field modulus.\n */\nvoid fp_prime_set_dense(const bn_t p);\n\n/**\n * Assigns the prime field modulus to a special form sparse prime.\n *\n * @param[in] spars\t\t- the list of powers of 2 describing the prime.\n * @param[in] len\t\t- the number of powers.\n */\nvoid fp_prime_set_pmers(const int *spars, int len);\n\n/**\n* Assigns the prime field modulus to a parametrization from a family of\n * pairing-friendly curves.\n */\nvoid fp_prime_set_pairf(const bn_t x, int pairf);\n\n/**\n * Computes the constants needed for evaluating Frobenius maps in higher\n * extension fields.\n */\nvoid fp_prime_calc(void);\n\n/**\n * Imports a multiple precision integer as a prime field element, doing the\n * necessary conversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to import.\n */\nvoid fp_prime_conv(fp_t c, const bn_t a);\n\n/**\n * Imports a single digit as a prime field element, doing the necessary\n * conversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the digit to import.\n */\nvoid fp_prime_conv_dig(fp_t c, dig_t a);\n\n/**\n * Exports a prime field element as a multiple precision integer, doing the\n * necessary conversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to export.\n */\nvoid fp_prime_back(bn_t c, const fp_t a);\n\n/**\n * Assigns a prime modulus based on its identifier.\n */\nvoid fp_param_set(int param);\n\n/**\n * Assigns any pre-defined parameter as the prime modulus.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any(void);\n\n/**\n * Assigns the order of the prime field to any non-sparse prime.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_dense(void);\n\n/**\n * Assigns the order of the prime field to any sparse prime.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_pmers(void);\n\n/**\n * Assigns the order of the prime field to any towering-friendly prime.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_tower(void);\n\n/**\n * Assigns the order of the prime field to a prime with high 2-adicity..\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_h2adc(void);\n\n/**\n * Prints the currently configured prime modulus.\n */\nvoid fp_param_print(void);\n\n/**\n * Returns the variable used to parametrize the given prime modulus.\n *\n * @param[out] x\t\t\t- the integer parameter.\n */\nvoid fp_prime_get_par(bn_t x);\n\n/**\n * Returns the absolute value of the variable used to parameterize the given\n * prime modulus in sparse form.\n *\n * @param[out] len\t\t\t- the length of the representation.\n */\nconst int *fp_prime_get_par_sps(int *len);\n\n/**\n * Returns the absolute value of the variable used to parameterize the currently\n * configured prime modulus in sparse form. The first argument must be an array\n * of size (RLC_TERMS + 1).\n *\n * @param[out] s\t\t\t- the parameter in sparse form.\n * @param[out] len\t\t\t- the length of the parameter in sparse form.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the current configuration is invalid.\n * @return the integer parameter in sparse form.\n */\nvoid fp_param_get_sps(int *s, int *len);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to copy.\n */\nvoid fp_copy(fp_t c, const fp_t a);\n\n/**\n * Assigns zero to a prime field element.\n *\n * @param[out] a\t\t\t- the prime field element to asign.\n */\nvoid fp_zero(fp_t a);\n\n/**\n * Tests if a prime field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the prime field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp_is_zero(const fp_t a);\n\n/**\n * Tests if a prime field element is even or odd.\n *\n * @param[in] a\t\t\t\t- the prime field element to test.\n * @return 1 if the argument is even, 0 otherwise.\n */\nint fp_is_even(const fp_t a);\n\n/**\n * Reads the bit stored in the given position on a prime field element.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] bit\t\t\t- the bit position.\n * @return the bit value.\n */\nint fp_get_bit(const fp_t a, int bit);\n\n/**\n * Stores a bit in a given position on a prime field element.\n *\n * @param[out] a\t\t\t- the prime field element.\n * @param[in] bit\t\t\t- the bit position.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid fp_set_bit(fp_t a, int bit, int value);\n\n/**\n * Assigns a small positive constant to a prime field element.\n *\n * The constant must fit on a multiple precision digit, or dig_t type using\n * only the number of bits specified on RLC_DIG.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the constant to assign.\n */\nvoid fp_set_dig(fp_t c, dig_t a);\n\n/**\n * Returns the number of bits of a prime field element.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @return the number of bits.\n */\nint fp_bits(const fp_t a);\n\n/**\n * Assigns a random value to a prime field element.\n *\n * @param[out] a\t\t\t- the prime field element to assign.\n */\nvoid fp_rand(fp_t a);\n\n/**\n * Prints a prime field element to standard output.\n *\n * @param[in] a\t\t\t\t- the prime field element to print.\n */\nvoid fp_print(const fp_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a multiple precision\n * integer. The radix must be a power of 2 included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nint fp_size_str(const fp_t a, int radix);\n\n/**\n * Reads a prime field element from a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid fp_read_str(fp_t a, const char *str, int len, int radix);\n\n/**\n * Writes a prime field element to a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime field element to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid fp_write_str(char *str, int len, const fp_t a, int radix);\n\n/**\n * Reads a prime field element from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fp_read_bin(fp_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a prime field element to a byte vector in big-endian format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fp_write_bin(uint8_t *bin, int len, const fp_t a);\n\n/**\n * Returns the result of a comparison between two prime field elements.\n *\n * @param[in] a\t\t\t\t- the first prime field element.\n * @param[in] b\t\t\t\t- the second prime field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp_cmp(const fp_t a, const fp_t b);\n\n/**\n * Returns the result of a signed comparison between a prime field element\n * and a digit.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp_cmp_dig(const fp_t a, dig_t b);\n\n/**\n * Adds two prime field elements using basic addition. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n * @param[in] b\t\t\t\t- the second prime field element to add.\n */\nvoid fp_add_basic(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Adds two prime field elements with integrated modular reduction. Computes\n * c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n * @param[in] b\t\t\t\t- the second prime field element to add.\n */\nvoid fp_add_integ(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Adds a prime field element and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid fp_add_dig(fp_t c, const fp_t a, dig_t b);\n\n/**\n * Subtracts a prime field element from another using basic subtraction.\n * Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the prime field element to subtract.\n */\nvoid fp_sub_basic(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Subtracts a prime field element from another with integrated modular\n * reduction. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the prime field element to subtract.\n */\nvoid fp_sub_integ(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Subtracts a digit from a prime field element. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid fp_sub_dig(fp_t c, const fp_t a, dig_t b);\n\n/**\n * Negates a prime field element using basic negation.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the prime field element to negate.\n */\nvoid fp_neg_basic(fp_t c, const fp_t a);\n\n/**\n * Negates a prime field element using integrated negation.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the prime field element to negate.\n */\nvoid fp_neg_integ(fp_t c, const fp_t a);\n\n/**\n * Doubles a prime field element using basic addition.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n */\nvoid fp_dbl_basic(fp_t c, const fp_t a);\n\n/**\n * Doubles a prime field element with integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n */\nvoid fp_dbl_integ(fp_t c, const fp_t a);\n\n/**\n * Halves a prime field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to halve.\n */\nvoid fp_hlv_basic(fp_t c, const fp_t a);\n\n/**\n * Halves a prime field element with integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to halve.\n */\nvoid fp_hlv_integ(fp_t c, const fp_t a);\n\n/**\n * Multiples two prime field elements using Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_basic(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiples two prime field elements using Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_comba(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiples two prime field elements using multiplication integrated with\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_integ(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiples two prime field elements using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_karat(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiplies a prime field element by a digit. Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid fp_mul_dig(fp_t c, const fp_t a, dig_t b);\n\n/**\n * Squares a prime field element using Schoolbook squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to square.\n */\nvoid fp_sqr_basic(fp_t c, const fp_t a);\n\n/**\n * Squares a prime field element using Comba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to square.\n */\nvoid fp_sqr_comba(fp_t c, const fp_t a);\n\n/**\n * Squares two prime field elements using squaring integrated with\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fp_sqr_integ(fp_t c, const fp_t a);\n\n/**\n * Squares a prime field element using Karatsuba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to square.\n */\nvoid fp_sqr_karat(fp_t c, const fp_t a);\n\n/**\n * Shifts a prime field element number to the left. Computes\n * c = a * 2^bits.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fp_lsh(fp_t c, const fp_t a, int bits);\n\n/**\n * Shifts a prime field element to the right. Computes c = floor(a / 2^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fp_rsh(fp_t c, const fp_t a, int bits);\n\n/**\n * Reduces a multiplication result modulo the prime field modulo using\n * division-based reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_basic(fp_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo the prime field order using Shoolbook\n * Montgomery reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_monty_basic(fp_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo the prime field order using Comba\n * Montgomery reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_monty_comba(fp_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo the prime field modulo using\n * fast reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_quick(fp_t c, dv_t a);\n\n/**\n * Inverts a prime field element using Fermat's Little Theorem.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_basic(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_binar(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using Montgomery inversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_monty(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the Euclidean Extended Algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_exgcd(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the constant-time division step approach\n * by Bernstein and Bo-Yin Yang.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_divst(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the constant-time jump division step\n * by Bernstein and Bo-Yin Yang.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_jmpds(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using a direct call to the lower layer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_lower(fp_t c, const fp_t a);\n\n/**\n * Inverts multiple prime field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp_inv_sim(fp_t *c, const fp_t *a, int n);\n\n/**\n * Computes Legendre symbol of a prime field element using exponentiation.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_basic(const fp_t a);\n\n/**\n * Computes Legendre symbol of a prime field element using the binary method.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_binar(const fp_t a);\n\n/**\n * Computes Legendre symbol of a prime field element using the constant-time\n * division step approach by Bernstein and Bo-Yin Yang.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_divst(const fp_t a);\n\n/**\n * Computes Legendre symbol of a prime field element using the constant-time\n * jump division step approach by Bernstein and Bo-Yin Yang.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_jmpds(const fp_t a);\n\n/**\n * Computes Legendre symbol a prime field element using a direct call to the\n * lower layer.\n *\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @return the result.\n */\nint fp_smb_lower(const fp_t a);\n\n/**\n * Exponentiates a prime field element using the binary\n * method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp_exp_basic(fp_t c, const fp_t a, const bn_t b);\n\n/**\n * Exponentiates a prime field element using the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp_exp_slide(fp_t c, const fp_t a, const bn_t b);\n\n/**\n * Exponentiates a prime field element using the constant-time Montgomery\n * powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp_exp_monty(fp_t c, const fp_t a, const bn_t b);\n\n/**\n * Extracts the square root of a prime field element. Computes c = sqrt(a). The\n * other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp_srt(fp_t c, const fp_t a);\n\n#endif /* !RLC_FP_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup fpx Prime field extensions.\n */\n\n/**\n * @file\n *\n * Interface of the module for prime extension field arithmetic.\n *\n * @ingroup fpx\n */\n\n#ifndef RLC_FPX_H\n#define RLC_FPX_H\n\n#include \"relic_fp.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a quadratic extension prime field element.\n *\n * This extension is constructed with the basis {1, i}, where i is an adjoined\n * square root in the prime field.\n */\ntypedef fp_t fp2_t[2];\n\n/**\n * Represents a double-precision quadratic extension field element.\n */\ntypedef dv_t dv2_t[2];\n\n/**\n * Represents a quadratic extension field element with automatic memory\n * allocation.\n */\ntypedef fp_st fp2_st[2];\n\n/**\n * Represents a cubic extension prime field element.\n *\n * This extension is constructed with the basis {1, j, j^2}, where j is an\n * adjoined cube root in the prime field.\n */\ntypedef fp_t fp3_t[3];\n\n/**\n * Represents a double-precision cubic extension field element.\n */\ntypedef dv_t dv3_t[3];\n\n/**\n * Represents a cubic extension field element with automatic memory\n * allocation.\n */\ntypedef fp_st fp3_st[3];\n\n/**\n * Represents a quartic extension prime field element.\n *\n * This extension is constructed with the basis {1, s}, where s^2 = E is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp2_t fp4_t[2];\n\n/**\n * Represents a double-precision quartic extension field element.\n */\ntypedef dv2_t dv4_t[2];\n\n/**\n * Represents a quartic extension field element with automatic memory\n * allocation.\n */\ntypedef fp2_st fp4_st[2];\n\n/**\n * Represents a sextic extension field element.\n *\n * This extension is constructed with the basis {1, v, v^2}, where v^3 = E is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp2_t fp6_t[3];\n\n/**\n * Represents a double-precision sextic extension field element.\n */\ntypedef dv2_t dv6_t[3];\n\n/**\n * Represents a sextic extension field element with automatic memory allocation.\n */\ntypedef fp2_st fp6_st[3];\n\n/**\n * Represents an octic extension prime field element.\n *\n * This extension is constructed with the basis {1, v}, where v^2 = s is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp4_t fp8_t[2];\n\n/**\n * Represents a double-precision octic extension field element.\n */\ntypedef dv4_t dv8_t[2];\n\n/**\n * Represents an octic extension field element with automatic memory\n * allocation.\n */\ntypedef fp4_st fp8_st[2];\n\n/**\n * Represents an octic extension prime field element.\n *\n * This extension is constructed with the basis {1, v, v^2}, where v^3 = j is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp3_t fp9_t[3];\n\n/**\n * Represents a double-precision octic extension field element.\n */\ntypedef dv3_t dv9_t[3];\n\n/**\n * Represents an octic extension field element with automatic memory\n * allocation.\n */\ntypedef fp3_st fp9_st[3];\n\n/**\n * Represents a dodecic extension field element.\n *\n * This extension is constructed with the basis {1, w}, where w^2 = v is an\n * adjoined root in the underlying sextic extension.\n */\ntypedef fp6_t fp12_t[2];\n\n/**\n * Represents a double-precision dodecic extension field element.\n */\ntypedef dv6_t dv12_t[2];\n\n/**\n * Represents an octdecic extension field element.\n *\n * This extension is constructed with the basis {1, w}, where w^2 = v is an\n * adjoined root in the underlying sextic extension.\n */\ntypedef fp9_t fp18_t[2];\n\n/**\n * Represents a double-precision octdecic extension field element.\n */\ntypedef dv9_t dv18_t[2];\n\n/**\n * Represents a 24-degree extension field element.\n *\n * This extension is constructed with the basis {1, t, t^2}, where t^3 = w is an\n * adjoined root in the underlying dodecic extension.\n */\ntypedef fp8_t fp24_t[3];\n\n/**\n * Represents a double-precision 24-degree extension field element.\n */\ntypedef dv8_t dv24_t[3];\n\n/**\n * Represents a 48-degree extension field element.\n *\n * This extension is constructed with the basis {1, u}, where u^2 = t is an\n * adjoined root in the underlying dodecic extension.\n */\ntypedef fp24_t fp48_t[2];\n\n/**\n * Represents a 54-degree extension field element.\n *\n * This extension is constructed with the basis {1, u, u^2}, where u^3 = t is an\n * adjoined root in the underlying dodecic extension.\n */\ntypedef fp18_t fp54_t[3];\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a double-precision quadratic extension field element with null.\n *\n* @param[out] A\t\t\t- the quadratic extension element to initialize.\n */\n#define dv2_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_null(A[0]); dv_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n\n/**\n * Allocates a double-precision quadratic extension field element.\n *\n * @param[out] A\t\t\t- the new quadratic extension field element.\n */\n#define dv2_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_new(A[0]); dv_new(A[1]);\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision quadratic extension field element.\n *\n * @param[out] A\t\t\t- the quadratic extension field element to free.\n */\n#define dv2_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_free(A[0]); dv_free(A[1]); \t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a quadratic extension field element with null.\n *\n* @param[out] A\t\t\t- the quadratic extension element to initialize.\n */\n#define fp2_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_null(A[0]); fp_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a quadratic extension field element.\n *\n * @param[out] A\t\t\t- the new quadratic extension field element.\n */\n#define fp2_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_new(A[0]); fp_new(A[1]);\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a quadratic extension field element.\n *\n * @param[out] A\t\t\t- the quadratic extension field element to free.\n */\n#define fp2_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_free(A[0]); fp_free(A[1]); \t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Adds two quadratic extension field elements. Computes C = A + B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quadratic extension field element.\n * @param[in] B\t\t\t\t- the second quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_add(C, A, B)\tfp2_add_basic(C, A, B)\n#elif FPX_QDR == INTEG\n#define fp2_add(C, A, B)\tfp2_add_integ(C, A, B)\n#endif\n\n/**\n * Subtracts a quadratic extension field element from another.\n * Computes C = A - B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quadratic extension field element.\n * @param[in] B\t\t\t\t- the second quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_sub(C, A, B)\tfp2_sub_basic(C, A, B)\n#elif FPX_QDR == INTEG\n#define fp2_sub(C, A, B)\tfp2_sub_integ(C, A, B)\n#endif\n\n/**\n * Doubles a quadratic extension field element. Computes C = A + A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_dbl(C, A)\t\tfp2_dbl_basic(C, A)\n#elif FPX_QDR == INTEG\n#define fp2_dbl(C, A)\t\tfp2_dbl_integ(C, A)\n#endif\n\n/**\n * Adds a quadratic extension field element and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid fp2_add_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Subtracts a quadratic extension field element and a digit. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid fp2_sub_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Multiplies two quadratic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quadratic extension field element.\n * @param[in] B\t\t\t\t- the second quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_mul(C, A, B)\tfp2_mul_basic(C, A, B)\n#elif FPX_QDR == INTEG\n#define fp2_mul(C, A, B)\tfp2_mul_integ(C, A, B)\n#endif\n\n/**\n * Multiplies a quadratic extension field by the quadratic/cubic non-residue.\n * Computes C = A * E, where E is a non-square/non-cube in the quadratic\n * extension.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quadratic extension field element to multiply.\n */\n#if FPX_QDR == BASIC\n#define fp2_mul_nor(C, A)\tfp2_mul_nor_basic(C, A)\n#elif FPX_QDR == INTEG\n#define fp2_mul_nor(C, A)\tfp2_mul_nor_integ(C, A)\n#endif\n\n/**\n * Squares a quadratic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quadratic extension field element to square.\n */\n#if FPX_QDR == BASIC\n#define fp2_sqr(C, A)\t\tfp2_sqr_basic(C, A)\n#elif FPX_QDR == INTEG\n#define fp2_sqr(C, A)\t\tfp2_sqr_integ(C, A)\n#endif\n\n/**\n * Initializes a double-precision cubic extension field element with a null\n * value.\n *\n* @param[out] A\t\t\t- the cubic extension element to initialize.\n */\n#define dv3_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_null(A[0]); dv_null(A[1]); dv_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision cubic extension field element.\n *\n * @param[out] A\t\t\t- the new cubic extension field element.\n */\n#define dv3_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_new(A[0]); dv_new(A[1]);\tdv_new(A[2]);\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision cubic extension field element.\n *\n * @param[out] A\t\t\t- the cubic extension field element to free.\n */\n#define dv3_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_free(A[0]); dv_free(A[1]); dv_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Initializes a cubic extension field element with null.\n *\n* @param[out] A\t\t\t- the cubic extension element to initialize.\n */\n#define fp3_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_null(A[0]); fp_null(A[1]); fp_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a cubic extension field element.\n *\n * @param[out] A\t\t\t- the new cubic extension field element.\n */\n#define fp3_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_new(A[0]); fp_new(A[1]);\tfp_new(A[2]);\t\t\t\t\t\t\t\\\n\n/**\n * Frees a cubic extension field element.\n *\n * @param[out] A\t\t\t- the cubic extension field element to free.\n */\n#define fp3_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_free(A[0]); fp_free(A[1]); fp_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Adds two cubic extension field elements. Computes C = A + B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first cubic extension field element.\n * @param[in] B\t\t\t\t- the second cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_add(C, A, B)\tfp3_add_basic(C, A, B)\n#elif FPX_CBC == INTEG\n#define fp3_add(C, A, B)\tfp3_add_integ(C, A, B)\n#endif\n\n/**\n * Subtracts a cubic extension field element from another.\n * Computes C = A - B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first cubic extension field element.\n * @param[in] B\t\t\t\t- the second cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_sub(C, A, B)\tfp3_sub_basic(C, A, B)\n#elif FPX_CBC == INTEG\n#define fp3_sub(C, A, B)\tfp3_sub_integ(C, A, B)\n#endif\n\n/**\n * Doubles a cubic extension field element. Computes C = A + A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_dbl(C, A)\t\tfp3_dbl_basic(C, A)\n#elif FPX_CBC == INTEG\n#define fp3_dbl(C, A)\t\tfp3_dbl_integ(C, A)\n#endif\n\n/**\n * Multiplies two cubic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first cubic extension field element.\n * @param[in] B\t\t\t\t- the second cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_mul(C, A, B)\tfp3_mul_basic(C, A, B)\n#elif FPX_CBC == INTEG\n#define fp3_mul(C, A, B)\tfp3_mul_integ(C, A, B)\n#endif\n\n/**\n * Squares a cubic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the cubic extension field element to square.\n */\n#if FPX_CBC == BASIC\n#define fp3_sqr(C, A)\t\tfp3_sqr_basic(C, A)\n#elif FPX_CBC == INTEG\n#define fp3_sqr(C, A)\t\tfp3_sqr_integ(C, A)\n#endif\n\n/**\n * Initializes a double-precision quartic extension field with null.\n *\n * @param[out] A\t\t\t- the quartic extension element to initialize.\n */\n#define dv4_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_null(A[0]); dv2_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision quartic extension field element.\n *\n * @param[out] A\t\t\t- the new quartic extension field element.\n */\n#define dv4_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_new(A[0]); dv2_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision quartic extension field element.\n *\n * @param[out] A\t\t\t- the quartic extension field element to free.\n */\n#define dv4_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_free(A[0]); dv2_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a quartic extension field with null.\n *\n * @param[out] A\t\t\t- the quartic extension element to initialize.\n */\n#define fp4_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_null(A[0]); fp2_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a quartic extension field element.\n *\n * @param[out] A\t\t\t- the new quartic extension field element.\n */\n#define fp4_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_new(A[0]); fp2_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a quartic extension field element.\n *\n * @param[out] A\t\t\t- the quartic extension field element to free.\n */\n#define fp4_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free(A[0]); fp2_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two quartic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quartic extension field element.\n * @param[in] B\t\t\t\t- the second quartic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp4_mul(C, A, B)\tfp4_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp4_mul(C, A, B)\tfp4_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a quartic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quartic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp4_sqr(C, A)\t\tfp4_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp4_sqr(C, A)\t\tfp4_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision sextic extension field with null.\n *\n * @param[out] A\t\t\t- the sextic extension element to initialize.\n */\n#define dv6_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_null(A[0]); dv2_null(A[1]); dv2_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the new sextic extension field element.\n */\n#define dv6_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_new(A[0]); dv2_new(A[1]); dv2_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the sextic extension field element to free.\n */\n#define dv6_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_free(A[0]); dv2_free(A[1]); dv2_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Initializes a sextic extension field with null.\n *\n * @param[out] A\t\t\t- the sextic extension element to initialize.\n */\n#define fp6_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_null(A[0]); fp2_null(A[1]); fp2_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a sextic extension field element.\n *\n * @param[out] A\t\t\t- the new sextic extension field element.\n */\n#define fp6_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_new(A[0]); fp2_new(A[1]); fp2_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a sextic extension field element.\n *\n * @param[out] A\t\t\t- the sextic extension field element to free.\n */\n#define fp6_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free(A[0]); fp2_free(A[1]); fp2_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Multiplies two sextic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first sextic extension field element.\n * @param[in] B\t\t\t\t- the second sextic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp6_mul(C, A, B)\tfp6_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp6_mul(C, A, B)\tfp6_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a sextic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the sextic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp6_sqr(C, A)\t\tfp6_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp6_sqr(C, A)\t\tfp6_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision octic extension field with null.\n *\n * @param[out] A\t\t\t- the octic extension element to initialize.\n */\n#define dv8_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv4_null(A[0]); dv4_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision octic extension field element.\n *\n * @param[out] A\t\t\t- the new octic extension field element.\n */\n#define dv8_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv4_new(A[0]); dv4_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision octic extension field element.\n *\n * @param[out] A\t\t\t- the octic extension field element to free.\n */\n#define dv8_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv4_free(A[0]); dv4_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes an octic extension field with null.\n *\n * @param[out] A\t\t\t- the octic extension element to initialize.\n */\n#define fp8_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_null(A[0]); fp4_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates an octic extension field element.\n *\n * @param[out] A\t\t\t- the new octic extension field element.\n */\n#define fp8_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_new(A[0]); fp4_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees an octic extension field element.\n *\n * @param[out] A\t\t\t- the octic extension field element to free.\n */\n#define fp8_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free(A[0]); fp4_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two octic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first octic extension field element.\n * @param[in] B\t\t\t\t- the second octic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp8_mul(C, A, B)\tfp8_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp8_mul(C, A, B)\tfp8_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares an octic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the octic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp8_sqr(C, A)\t\tfp8_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp8_sqr(C, A)\t\tfp8_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision nonic extension field with null.\n *\n * @param[out] A\t\t\t- the octic extension element to initialize.\n */\n#define dv9_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv3_null(A[0]); dv3_null(A[1]);\tdv3_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision nonic extension field element.\n *\n * @param[out] A\t\t\t- the new nonic extension field element.\n */\n#define dv9_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv3_new(A[0]); dv3_new(A[1]); dv3_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision nonic extension field element.\n *\n * @param[out] A\t\t\t- the nonic extension field element to free.\n */\n#define dv9_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv3_free(A[0]); dv3_free(A[1]); dv3_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Initializes a nonic extension field with null.\n *\n * @param[out] A\t\t\t- the nonic extension element to initialize.\n */\n#define fp9_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp3_null(A[0]); fp3_null(A[1]); fp3_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a nonic extension field element.\n *\n * @param[out] A\t\t\t- the new nonic extension field element.\n */\n#define fp9_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp3_new(A[0]); fp3_new(A[1]); fp3_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a nonic extension field element.\n *\n * @param[out] A\t\t\t- the nonic extension field element to free.\n */\n#define fp9_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp3_free(A[0]); fp3_free(A[1]); fp3_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Multiplies two nonic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first nonic extension field element.\n * @param[in] B\t\t\t\t- the second nonic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp9_mul(C, A, B)\tfp9_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp9_mul(C, A, B)\tfp9_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a nonic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the nonic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp9_sqr(C, A)\t\tfp9_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp9_sqr(C, A)\t\tfp9_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision dodecic extension field with null.\n *\n * @param[out] A\t\t\t- the dodecic extension element to initialize.\n */\n#define dv12_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv6_null(A[0]); dv6_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision dodecic extension field element.\n *\n * @param[out] A\t\t\t- the new dodecic extension field element.\n */\n#define dv12_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv6_new(A[0]); dv6_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision dodecic extension field element.\n *\n * @param[out] A\t\t\t- the dodecic extension field element to free.\n */\n#define dv12_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv6_free(A[0]); dv6_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a dodecic extension field with null.\n *\n * @param[out] A\t\t\t- the dodecic extension element to initialize.\n */\n#define fp12_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp6_null(A[0]); fp6_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a dodecic extension field element.\n *\n * @param[out] A\t\t\t- the new dodecic extension field element.\n */\n#define fp12_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp6_new(A[0]); fp6_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a dodecic extension field element.\n *\n * @param[out] A\t\t\t- the dodecic extension field element to free.\n */\n#define fp12_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp6_free(A[0]); fp6_free(A[1]); \t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two dodecic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first dodecic extension field element.\n * @param[in] B\t\t\t\t- the second dodecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp12_mul(C, A, B)\t\tfp12_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp12_mul(C, A, B)\t\tfp12_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Multiplies a dense and a sparse dodecic extension field elements. Computes\n * C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dense dodecic extension field element.\n * @param[in] B\t\t\t\t- the sparse dodecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp12_mul_dxs(C, A, B)\tfp12_mul_dxs_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp12_mul_dxs(C, A, B)\tfp12_mul_dxs_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a dodecic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dodecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp12_sqr(C, A)\t\t\tfp12_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp12_sqr(C, A)\t\t\tfp12_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a dodecic extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dodecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp12_sqr_cyc(C, A)\t\tfp12_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp12_sqr_cyc(C, A)\t\tfp12_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a dodecic extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dodecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp12_sqr_pck(C, A)\t\tfp12_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp12_sqr_pck(C, A)\t\tfp12_sqr_pck_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision sextic extension field with null.\n *\n * @param[out] A\t\t\t- the sextic extension element to initialize.\n */\n#define dv18_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv9_null(A[0]); dv9_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the new sextic extension field element.\n */\n#define dv18_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv9_new(A[0]); dv9_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the sextic extension field element to free.\n */\n#define dv18_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv9_free(A[0]); dv9_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes an octdecic extension field with null.\n *\n * @param[out] A\t\t\t- the octdecic extension element to initialize.\n */\n#define fp18_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp9_null(A[0]); fp9_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates an octdecic extension field element.\n *\n * @param[out] A\t\t\t- the new octdecic extension field element.\n */\n#define fp18_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp9_new(A[0]); fp9_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees an octdecic extension field element.\n *\n * @param[out] A\t\t\t- the octdecic extension field element to free.\n */\n#define fp18_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp9_free(A[0]); fp9_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two octdecic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first octdecic extension field element.\n * @param[in] B\t\t\t\t- the second octdecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp18_mul(C, A, B)\t\tfp18_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp18_mul(C, A, B)\t\tfp18_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Multiplies a dense and a sparse octdecic extension field elements. Computes\n * C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dense octdecic extension field element.\n * @param[in] B\t\t\t\t- the sparse octdecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp18_mul_dxs(C, A, B)\tfp18_mul_dxs_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp18_mul_dxs(C, A, B)\tfp18_mul_dxs_lazyr(C, A, B)\n#endif\n\n/**\n * Squares an octdecic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the octdecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp18_sqr(C, A)\t\t\tfp18_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp18_sqr(C, A)\t\t\tfp18_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision 24-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 24-degree extension element to initialize.\n */\n#define dv24_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv8_null(A[0]); dv8_null(A[1]); dv8_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 24-degree extension field element.\n */\n#define dv24_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv8_new(A[0]); dv8_new(A[1]); dv8_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the 24-degree extension field element to free.\n */\n#define dv24_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv8_free(A[0]); dv8_free(A[1]); dv8_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Initializes a 24-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 24-degree extension element to initialize.\n */\n#define fp24_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp8_null(A[0]); fp8_null(A[1]); fp8_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 24-degree extension field element.\n */\n#define fp24_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp8_new(A[0]); fp8_new(A[1]); fp8_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the 24-degree extension field element to free.\n */\n#define fp24_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp8_free(A[0]); fp8_free(A[1]); fp8_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Multiplies two 24-degree extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first 24-degree extension field element.\n * @param[in] B\t\t\t\t- the second 24-degree extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp24_mul(C, A, B)\t\tfp24_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp24_mul(C, A, B)\t\tfp24_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a 24-degree extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 24-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp24_sqr(C, A)\t\t\tfp24_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp24_sqr(C, A)\t\t\tfp24_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a 24-degree extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 24-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp24_sqr_cyc(C, A)\t\tfp24_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp24_sqr_cyc(C, A)\t\tfp24_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a 24-degree extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 24-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp24_sqr_pck(C, A)\t\tfp24_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp24_sqr_pck(C, A)\t\tfp24_sqr_pck_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision 48-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 48-degree extension element to initialize.\n */\n#define dv48_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv24_null(A[0]); dv24_null(A[1]);\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 48-degree extension field element.\n */\n#define dv48_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv24_new(A[0]); dv24_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the 48-degree extension field element to free.\n */\n#define dv48_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv24_free(A[0]); dv24_free(A[1]);\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a 48-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 48-degree extension element to initialize.\n */\n#define fp48_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp24_null(A[0]); fp24_null(A[1]);\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 48-degree extension field element.\n */\n#define fp48_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp24_new(A[0]); fp24_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the 48-degree extension field element to free.\n */\n#define fp48_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp24_free(A[0]); fp24_free(A[1]); \t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two 48-degree extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first 48-degree extension field element.\n * @param[in] B\t\t\t\t- the second 48-degree extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp48_mul(C, A, B)\t\tfp48_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp48_mul(C, A, B)\t\tfp48_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a 48-degree extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 48-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp48_sqr(C, A)\t\t\tfp48_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp48_sqr(C, A)\t\t\tfp48_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a 48-degree extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 48-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp48_sqr_cyc(C, A)\t\tfp48_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp48_sqr_cyc(C, A)\t\tfp48_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a 48-degree extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 48-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp48_sqr_pck(C, A)\t\tfp48_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp48_sqr_pck(C, A)\t\tfp48_sqr_pck_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision 54-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 54-degree extension element to initialize.\n */\n#define dv54_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv18_null(A[0]); dv18_null(A[1]); dv18_null(A[2]);\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 54-degree extension field element.\n */\n#define dv54_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv18_new(A[0]); dv18_new(A[1]);\tdv18_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the 54-degree extension field element to free.\n */\n#define dv54_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv18_free(A[0]); dv18_free(A[1]); dv18_free(A[2]);\t\t\t\t\t\\\n\n/**\n * Initializes a 54-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 54-degree extension element to initialize.\n */\n#define fp54_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp18_null(A[0]); fp18_null(A[1]); fp18_null(A[2]);\t\t\t\t\t\\\n\n/**\n * Allocates a 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 54-degree extension field element.\n */\n#define fp54_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp18_new(A[0]); fp18_new(A[1]);\tfp18_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the 54-degree extension field element to free.\n */\n#define fp54_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp18_free(A[0]); fp18_free(A[1]); fp18_free(A[2]);\t\t\t\t\t\\\n\n/**\n * Multiplies two 54-degree extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first 54-degree extension field element.\n * @param[in] B\t\t\t\t- the second 54-degree extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp54_mul(C, A, B)\t\tfp54_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp54_mul(C, A, B)\t\tfp54_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a 54-degree extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 54-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp54_sqr(C, A)\t\t\tfp54_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp54_sqr(C, A)\t\t\tfp54_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a 54-degree extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 54-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp54_sqr_cyc(C, A)\t\tfp54_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp54_sqr_cyc(C, A)\t\tfp54_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a 54-degree extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 54-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp54_sqr_pck(C, A)\t\tfp54_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp54_sqr_pck(C, A)\t\tfp54_sqr_pck_lazyr(C, A)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the quadratic extension field arithmetic module.\n */\nvoid fp2_field_init(void);\n\n/**\n * Return the integer part (u) of the quadratic non-residue (i + u).\n */\nint fp2_field_get_qnr(void);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to copy.\n */\nvoid fp2_copy(fp2_t c, const fp2_t a);\n\n/**\n * Assigns zero to a quadratic extension field element.\n *\n * @param[out] a\t\t\t- the quadratic extension field element to zero.\n */\nvoid fp2_zero(fp2_t a);\n\n/**\n * Tests if a quadratic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp2_is_zero(const fp2_t a);\n\n/**\n * Assigns a random value to a quadratic extension field element.\n *\n * @param[out] a\t\t\t- the quadratic extension field element to assign.\n */\nvoid fp2_rand(fp2_t a);\n\n/**\n * Prints a quadratic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element to print.\n */\nvoid fp2_print(const fp2_t a);\n\n/**\n * Returns the number of bytes necessary to store a quadratic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp2_size_bin(fp2_t a, int pack);\n\n/**\n * Reads a quadratic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp2_read_bin(fp2_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a quadratic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack);\n\n/**\n * Returns the result of a comparison between two quadratic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp2_cmp(const fp2_t a, const fp2_t b);\n\n/**\n * Returns the result of a signed comparison between a quadratic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp2_cmp_dig(const fp2_t a, const dig_t b);\n\n/**\n * Assigns a quadratic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp2_set_dig(fp2_t a, const dig_t b);\n\n/**\n * Adds two quadratic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_add_basic(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Adds two quadratic extension field elements using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_add_integ(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Subtracts a quadratic extension field element from another using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_sub_basic(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Subtracts a quadratic extension field element from another using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_sub_integ(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Negates a quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the quadratic extension field element to negate.\n */\nvoid fp2_neg(fp2_t c, const fp2_t a);\n\n/**\n * Doubles a quadratic extension field element using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to double.\n */\nvoid fp2_dbl_basic(fp2_t c, const fp2_t a);\n\n/**\n * Doubles a quadratic extension field element using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to double.\n */\nvoid fp2_dbl_integ(fp2_t c, const fp2_t a);\n\n/**\n * Multiples two quadratic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_mul_basic(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Multiples two quadratic extension field elements using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_mul_integ(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Multiplies a quadratic extension field element by the adjoined root.\n * Computes c = a * i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to multiply.\n */\nvoid fp2_mul_art(fp2_t c, const fp2_t a);\n\n/**\n * Multiplies a quadratic extension field element by a quadratic/cubic\n * non-residue.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to multiply.\n */\nvoid fp2_mul_nor_basic(fp2_t c, const fp2_t a);\n\n/**\n * Multiplies a quadratic extension field element by a quadratic/cubic\n * non-residue using integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to multiply.\n */\nvoid fp2_mul_nor_integ(fp2_t c, const fp2_t a);\n\n/**\n * Multiplies a quadratic extension field element by a power of the constant\n * needed to compute a power of the Frobenius map.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n * @param[in] j\t\t\t\t- the power of the constant.\n */\nvoid fp2_mul_frb(fp2_t c, const fp2_t a, int i, int j);\n\n/**\n * Multiplies a quadratic extension field element by a digit.\n * Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid fp2_mul_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Computes the square of a quadratic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to square.\n */\nvoid fp2_sqr_basic(fp2_t c, const fp2_t a);\n\n/**\n * Computes the square of a quadratic extension field element using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to square.\n */\nvoid fp2_sqr_integ(fp2_t c, const fp2_t a);\n\n/**\n * Inverts a quadratic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to invert.\n */\nvoid fp2_inv(fp2_t c, const fp2_t a);\n\n/**\n * Computes the inverse of a cyclotomic quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to invert.\n */\nvoid fp2_inv_cyc(fp2_t c, const fp2_t a);\n\n/**\n * Inverts multiple quadratic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp2_inv_sim(fp2_t *c, const fp2_t *a, int n);\n\n/**\n * Tests if a quadratic extension field element is cyclotomic.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element to test.\n * @return 1 if the extension field element is cyclotomic, 0 otherwise.\n */\nint fp2_test_cyc(const fp2_t a);\n\n/**\n * Converts a quadratic extension field element to a cyclotomic element.\n * Computes c = a^(p - 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n */\nvoid fp2_conv_cyc(fp2_t c, const fp2_t a);\n\n/**\n * Computes a power of a quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp2_exp(fp2_t c, const fp2_t a, const bn_t b);\n\n/**\n * Computes a power of a quadratic extension field element by a small exponent.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp2_exp_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius map of a quadratic extension field element.\n * When i is odd, this is the same as computing the conjugate of the extension\n * field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension element to conjugate.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp2_frb(fp2_t c, const fp2_t a, int i);\n\n/**\n * Extracts the square root of a quadratic extension field element. Computes\n * c = sqrt(a). The other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp2_srt(fp2_t c, const fp2_t a);\n\n/**\n * Compresses an extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element to compress.\n */\nvoid fp2_pck(fp2_t c, const fp2_t a);\n\n/**\n * Decompresses a quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @return if the decompression was successful\n */\nint fp2_upk(fp2_t c, const fp2_t a);\n\n/**\n * Initializes the cubic extension field arithmetic module.\n */\nvoid fp3_field_init(void);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to copy.\n */\nvoid fp3_copy(fp3_t c, const fp3_t a);\n\n/**\n * Assigns zero to a cubic extension field element.\n *\n * @param[out] a\t\t\t- the cubic extension field element to zero.\n */\nvoid fp3_zero(fp3_t a);\n\n/**\n * Tests if a cubic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp3_is_zero(const fp3_t a);\n\n/**\n * Assigns a random value to a cubic extension field element.\n *\n * @param[out] a\t\t\t- the cubic extension field element to assign.\n */\nvoid fp3_rand(fp3_t a);\n\n/**\n * Prints a cubic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element to print.\n */\nvoid fp3_print(const fp3_t a);\n\n/**\n * Returns the number of bytes necessary to store a cubic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp3_size_bin(fp3_t a);\n\n/**\n * Reads a cubic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp3_read_bin(fp3_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a cubic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp3_write_bin(uint8_t *bin, int len, const fp3_t a);\n\n/**\n * Returns the result of a comparison between two cubic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp3_cmp(const fp3_t a, const fp3_t b);\n\n/**\n * Returns the result of a signed comparison between a cubic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp3_cmp_dig(const fp3_t a, const dig_t b);\n\n/**\n * Assigns a cubic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp3_set_dig(fp3_t a, const dig_t b);\n\n/**\n * Adds two cubic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_add_basic(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Adds two cubic extension field elements using integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_add_integ(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Subtracts a cubic extension field element from another using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_sub_basic(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Subtracts a cubic extension field element from another using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_sub_integ(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Negates a cubic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the cubic extension field element to negate.\n */\nvoid fp3_neg(fp3_t c, const fp3_t a);\n\n/**\n * Doubles a cubic extension field element using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to double.\n */\nvoid fp3_dbl_basic(fp3_t c, const fp3_t a);\n\n/**\n * Doubles a cubic extension field element using integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to double.\n */\nvoid fp3_dbl_integ(fp3_t c, const fp3_t a);\n\n/**\n * Multiples two cubic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_mul_basic(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Multiples two cubic extension field elements using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_mul_integ(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Multiplies a cubic extension field element by a cubic non-residue.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to multiply.\n */\nvoid fp3_mul_nor(fp3_t c, const fp3_t a);\n\n/**\n * Multiplies a cubic extension field element by a power of the constant\n * needed to compute a power of the Frobenius map. If the flag is zero, the map\n * is computed on the cubic extension directly; otherwise the map is computed on\n * a higher extension.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n * @param[in] j\t\t\t\t- the power of the constant.\n */\nvoid fp3_mul_frb(fp3_t c, const fp3_t a, int i, int j);\n\n/**\n * Computes the square of a cubic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to square.\n */\nvoid fp3_sqr_basic(fp3_t c, const fp3_t a);\n\n/**\n * Computes the square of a cubic extension field element using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to square.\n */\nvoid fp3_sqr_integ(fp3_t c, const fp3_t a);\n\n/**\n * Inverts a cubic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to invert.\n */\nvoid fp3_inv(fp3_t c, const fp3_t a);\n\n/**\n * Inverts multiple cubic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp3_inv_sim(fp3_t *c, const fp3_t *a, int n);\n\n/**\n * Computes a power of a cubic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp3_exp(fp3_t c, const fp3_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius map of a cubic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension element to exponentiate.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp3_frb(fp3_t c, const fp3_t a, int i);\n\n/**\n * Extracts the square root of a cubic extension field element. Computes\n * c = sqrt(a). The other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp3_srt(fp3_t c, const fp3_t a);\n\n/**\n * Initializes the quartic extension field arithmetic module.\n */\nvoid fp4_field_init(void);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to copy.\n */\nvoid fp4_copy(fp4_t c, const fp4_t a);\n\n/**\n * Assigns zero to a quartic extension field element.\n *\n * @param[out] a\t\t\t- the quartic extension field element to zero.\n */\nvoid fp4_zero(fp4_t a);\n\n/**\n * Tests if a quartic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp4_is_zero(const fp4_t a);\n\n/**\n * Assigns a random value to a quartic extension field element.\n *\n * @param[out] a\t\t\t- the quartic extension field element to assign.\n */\nvoid fp4_rand(fp4_t a);\n\n/**\n * Prints a quartic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element to print.\n */\nvoid fp4_print(const fp4_t a);\n\n/**\n * Returns the number of bytes necessary to store a quartic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp4_size_bin(fp4_t a);\n\n/**\n * Reads a quartic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp4_read_bin(fp4_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a quartic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp4_write_bin(uint8_t *bin, int len, const fp4_t a);\n\n/**\n * Returns the result of a comparison between two quartic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first quartic extension field element.\n * @param[in] b\t\t\t\t- the second quartic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp4_cmp(const fp4_t a, const fp4_t b);\n\n/**\n * Returns the result of a signed comparison between a quartic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp4_cmp_dig(const fp4_t a, const dig_t b);\n\n/**\n * Assigns a quartic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp4_set_dig(fp4_t a, const dig_t b);\n\n/**\n * Adds two quartic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quartic extension field element.\n * @param[in] b\t\t\t\t- the second quartic extension field element.\n */\nvoid fp4_add(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Subtracts a quartic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_sub(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Negates a quartic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the quartic extension field element to negate.\n */\nvoid fp4_neg(fp4_t c, const fp4_t a);\n\n/**\n * Doubles a quartic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to double.\n */\nvoid fp4_dbl(fp4_t c, const fp4_t a);\n\n/**\n * Multiples two quartic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_mul_unr(dv4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Multiples two quartic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_mul_basic(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Multiples two quartic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_mul_lazyr(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Multiplies a quartic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to multiply.\n */\nvoid fp4_mul_art(fp4_t c, const fp4_t a);\n\n/**\n * Multiplies a quartic extension field element by a power of the constant\n * needed to compute a power of the Frobenius map.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n * @param[in] j\t\t\t\t- the power of the constant.\n */\nvoid fp4_mul_frb(fp4_t c, const fp4_t a, int i, int j);\n\n/**\n * Multiples a dense quartic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a quartic extension field element.\n * @param[in] b\t\t\t\t- a sparse quartic extension field element.\n */\nvoid fp4_mul_dxs(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Computes the square of a quartic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to square.\n */\nvoid fp4_sqr_unr(dv4_t c, const fp4_t a);\n\n/**\n * Computes the squares of a quartic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to square.\n */\nvoid fp4_sqr_basic(fp4_t c, const fp4_t a);\n\n/**\n * Computes the square of a quartic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to square.\n */\nvoid fp4_sqr_lazyr(fp4_t c, const fp4_t a);\n\n/**\n * Inverts a quartic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to invert.\n */\nvoid fp4_inv(fp4_t c, const fp4_t a);\n\n/**\n * Inverts multiple quartic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp4_inv_sim(fp4_t *c, const fp4_t *a, int n);\n\n/**\n * Computes the inverse of a cyclotomic quartic extension field element.\n *\n * For cyclotomic elements, this is equivalent to computing the conjugate.\n * A cyclotomic element is one previously raised to the (p^2 - 1)-th power.\n *\n * @param[out] c                        - the result.\n * @param[in] a                         - the quartic extension field element to invert.\n */\nvoid fp4_inv_cyc(fp4_t c, const fp4_t a);\n\n/**\n * Computes a power of a quartic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp4_exp(fp4_t c, const fp4_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of a quartic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a quartic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp4_frb(fp4_t c, const fp4_t a, int i);\n\n/**\n * Extracts the square root of a quartic extension field element. Computes\n * c = sqrt(a). The other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp4_srt(fp4_t c, const fp4_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to copy.\n */\nvoid fp6_copy(fp6_t c, const fp6_t a);\n\n/**\n * Assigns zero to a sextic extension field element.\n *\n * @param[out] a\t\t\t- the sextic extension field element to zero.\n */\nvoid fp6_zero(fp6_t a);\n\n/**\n * Tests if a sextic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp6_is_zero(const fp6_t a);\n\n/**\n * Assigns a random value to a sextic extension field element.\n *\n * @param[out] a\t\t\t- the sextic extension field element to assign.\n */\nvoid fp6_rand(fp6_t a);\n\n/**\n * Prints a sextic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element to print.\n */\nvoid fp6_print(const fp6_t a);\n\n/**\n * Returns the number of bytes necessary to store a quadratic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp6_size_bin(fp6_t a);\n\n/**\n * Reads a quadratic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp6_read_bin(fp6_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a sextic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp6_write_bin(uint8_t *bin, int len, const fp6_t a);\n\n/**\n * Returns the result of a comparison between two sextic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first sextic extension field element.\n * @param[in] b\t\t\t\t- the second sextic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp6_cmp(const fp6_t a, const fp6_t b);\n\n/**\n * Returns the result of a signed comparison between a sextic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp6_cmp_dig(const fp6_t a, const dig_t b);\n\n/**\n * Assigns a sextic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp6_set_dig(fp6_t a, const dig_t b);\n\n/**\n * Adds two sextic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first sextic extension field element.\n * @param[in] b\t\t\t\t- the second sextic extension field element.\n */\nvoid fp6_add(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Subtracts a sextic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_sub(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Negates a sextic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the sextic extension field element to negate.\n */\nvoid fp6_neg(fp6_t c, const fp6_t a);\n\n/**\n * Doubles a sextic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to double.\n */\nvoid fp6_dbl(fp6_t c, const fp6_t a);\n\n/**\n * Multiples two sextic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_mul_unr(dv6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Multiples two sextic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_mul_basic(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Multiples two sextic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_mul_lazyr(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Multiplies a sextic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to multiply.\n */\nvoid fp6_mul_art(fp6_t c, const fp6_t a);\n\n/**\n * Multiples a dense sextic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a sextic extension field element.\n * @param[in] b\t\t\t\t- a sparse sextic extension field element.\n */\nvoid fp6_mul_dxs(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Computes the square of a sextic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to square.\n */\nvoid fp6_sqr_unr(dv6_t c, const fp6_t a);\n\n/**\n * Computes the squares of a sextic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to square.\n */\nvoid fp6_sqr_basic(fp6_t c, const fp6_t a);\n\n/**\n * Computes the square of a sextic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to square.\n */\nvoid fp6_sqr_lazyr(fp6_t c, const fp6_t a);\n\n/**\n * Inverts a sextic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to invert.\n */\nvoid fp6_inv(fp6_t c, const fp6_t a);\n\n/**\n * Computes a power of a sextic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp6_exp(fp6_t c, const fp6_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of a sextic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a sextic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp6_frb(fp6_t c, const fp6_t a, int i);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to copy.\n */\nvoid fp8_copy(fp8_t c, const fp8_t a);\n\n/**\n * Assigns zero to an octic extension field element.\n *\n * @param[out] a\t\t\t- the octic extension field element to zero.\n */\nvoid fp8_zero(fp8_t a);\n\n/**\n * Tests if an octic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the octic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp8_is_zero(const fp8_t a);\n\n/**\n * Assigns a random value to an octic extension field element.\n *\n * @param[out] a\t\t\t- the octic extension field element to assign.\n */\nvoid fp8_rand(fp8_t a);\n\n/**\n * Prints an octic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the octic extension field element to print.\n */\nvoid fp8_print(const fp8_t a);\n\n/**\n * Returns the number of bytes necessary to store an octic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp8_size_bin(fp8_t a, int pack);\n\n/**\n * Reads an octic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp8_read_bin(fp8_t a, const uint8_t *bin, int len);\n\n/**\n * Writes an octic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp8_write_bin(uint8_t *bin, int len, const fp8_t a);\n\n/**\n * Returns the result of a comparison between two octic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first octic extension field element.\n * @param[in] b\t\t\t\t- the second octic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp8_cmp(const fp8_t a, const fp8_t b);\n\n/**\n * Returns the result of a signed comparison between an octic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp8_cmp_dig(const fp8_t a, const dig_t b);\n\n/**\n * Assigns an octic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp8_set_dig(fp8_t a, const dig_t b);\n\n/**\n * Adds two octic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first octic extension field element.\n * @param[in] b\t\t\t\t- the second octic extension field element.\n */\nvoid fp8_add(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Subtracts an octic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_sub(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Negates an octic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the octic extension field element to negate.\n */\nvoid fp8_neg(fp8_t c, const fp8_t a);\n\n/**\n * Doubles an octic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to double.\n */\nvoid fp8_dbl(fp8_t c, const fp8_t a);\n\n/**\n * Multiples two octic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_mul_unr(dv8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Multiples two octic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_mul_basic(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Multiples two octic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_mul_lazyr(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Multiplies an octic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to multiply.\n */\nvoid fp8_mul_art(fp8_t c, const fp8_t a);\n\n/**\n * Multiples a dense octic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octic extension field element.\n * @param[in] b\t\t\t\t- a sparse octic extension field element.\n */\nvoid fp8_mul_dxs(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Computes the square of an octic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to square.\n */\nvoid fp8_sqr_unr(dv8_t c, const fp8_t a);\n\n/**\n * Computes the squares of an octic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to square.\n */\nvoid fp8_sqr_basic(fp8_t c, const fp8_t a);\n\n/**\n * Computes the square of an octic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to square.\n */\nvoid fp8_sqr_lazyr(fp8_t c, const fp8_t a);\n\n/**\n * Computes the square of a cyclotomic octic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp8_sqr_cyc(fp8_t c, const fp8_t a);\n\n/**\n * Inverts an octic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to invert.\n */\nvoid fp8_inv(fp8_t c, const fp8_t a);\n\n/**\n * Computes the inverse of a cyclotomic octic extension field element.\n *\n * For cyclotomic elements, this is equivalent to computing the conjugate.\n * A cyclotomic element is one previously raised to the (p^4 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to invert.\n */\nvoid fp8_inv_cyc(fp8_t c, const fp8_t a);\n\n/**\n * Inverts multiple octic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp8_inv_sim(fp8_t *c, const fp8_t *a, int n);\n\n/**\n * Tests if an octic extension field element is cyclotomic.\n *\n * @param[in] a\t\t\t\t- the octic extension field element to test.\n * @return 1 if the extension field element is cyclotomic, 0 otherwise.\n */\nint fp8_test_cyc(const fp8_t a);\n\n/**\n * Converts an octic extension field element to a cyclotomic element. Computes\n * c = a^(p^4 - 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n */\nvoid fp8_conv_cyc(fp8_t c, const fp8_t a);\n\n/**\n * Computes a power of an octic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp8_exp(fp8_t c, const fp8_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic octic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of an octic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp8_frb(fp8_t c, const fp8_t a, int i);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to copy.\n */\nvoid fp9_copy(fp9_t c, const fp9_t a);\n\n/**\n * Assigns zero to a nonic extension field element.\n *\n * @param[out] a\t\t\t- the nonic extension field element to zero.\n */\nvoid fp9_zero(fp9_t a);\n\n/**\n * Tests if a nonic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp9_is_zero(const fp9_t a);\n\n/**\n * Assigns a random value to a nonic extension field element.\n *\n * @param[out] a\t\t\t- the nonic extension field element to assign.\n */\nvoid fp9_rand(fp9_t a);\n\n/**\n * Prints a nonic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element to print.\n */\nvoid fp9_print(const fp9_t a);\n\n/**\n * Returns the number of bytes necessary to store a quadratic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp9_size_bin(fp9_t a);\n\n/**\n * Reads a quadratic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp9_read_bin(fp9_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a nonic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp9_write_bin(uint8_t *bin, int len, const fp9_t a);\n\n/**\n * Returns the result of a comparison between two nonic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first nonic extension field element.\n * @param[in] b\t\t\t\t- the second nonic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp9_cmp(const fp9_t a, const fp9_t b);\n\n/**\n * Returns the result of a signed comparison between a nonic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp9_cmp_dig(const fp9_t a, const dig_t b);\n\n/**\n * Assigns a nonic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp9_set_dig(fp9_t a, const dig_t b);\n\n/**\n * Adds two nonic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first nonic extension field element.\n * @param[in] b\t\t\t\t- the second nonic extension field element.\n */\nvoid fp9_add(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Subtracts a nonic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_sub(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Negates a nonic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the nonic extension field element to negate.\n */\nvoid fp9_neg(fp9_t c, const fp9_t a);\n\n/**\n * Doubles a nonic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to double.\n */\nvoid fp9_dbl(fp9_t c, const fp9_t a);\n\n/**\n * Multiples two nonic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_mul_unr(dv9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Multiples two nonic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_mul_basic(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Multiples two nonic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_mul_lazyr(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Multiplies a nonic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to multiply.\n */\nvoid fp9_mul_art(fp9_t c, const fp9_t a);\n\n/**\n * Multiples a dense nonic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a nonic extension field element.\n * @param[in] b\t\t\t\t- a sparse nonic extension field element.\n */\nvoid fp9_mul_dxs(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Computes the square of a nonic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to square.\n */\nvoid fp9_sqr_unr(dv9_t c, const fp9_t a);\n\n/**\n * Computes the squares of a nonic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to square.\n */\nvoid fp9_sqr_basic(fp9_t c, const fp9_t a);\n\n/**\n * Computes the square of a nonic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to square.\n */\nvoid fp9_sqr_lazyr(fp9_t c, const fp9_t a);\n\n/**\n * Inverts a nonic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to invert.\n */\nvoid fp9_inv(fp9_t c, const fp9_t a);\n\n/**\n * Inverts multiple noinc extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp9_inv_sim(fp9_t *c, const fp9_t *a, int n);\n\n/**\n * Computes a power of a nonic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp9_exp(fp9_t c, const fp9_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of a nonic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a nonic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp9_frb(fp9_t c, const fp9_t a, int i);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to copy.\n */\nvoid fp12_copy(fp12_t c, const fp12_t a);\n\n/**\n * Assigns zero to a dodecic extension field element.\n *\n * @param[out] a\t\t\t- the dodecic extension field element to zero.\n */\nvoid fp12_zero(fp12_t a);\n\n/**\n * Tests if a dodecic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp12_is_zero(const fp12_t a);\n\n/**\n * Assigns a random value to a dodecic extension field element.\n *\n * @param[out] a\t\t\t- the dodecic extension field element to assign.\n */\nvoid fp12_rand(fp12_t a);\n\n/**\n * Prints a dodecic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element to print.\n */\nvoid fp12_print(const fp12_t a);\n\n/**\n * Returns the number of bytes necessary to store a dodecic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp12_size_bin(fp12_t a, int pack);\n\n/**\n * Reads a dodecic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp12_read_bin(fp12_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a dodecic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp12_write_bin(uint8_t *bin, int len, const fp12_t a, int pack);\n\n/**\n * Returns the result of a comparison between two dodecic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first dodecic extension field element.\n * @param[in] b\t\t\t\t- the second dodecic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp12_cmp(const fp12_t a, const fp12_t b);\n\n/**\n * Returns the result of a signed comparison between a dodecic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp12_cmp_dig(const fp12_t a, const dig_t b);\n\n/**\n * Assigns a dodecic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp12_set_dig(fp12_t a, const dig_t b);\n\n/**\n * Adds two dodecic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first dodecic extension field element.\n * @param[in] b\t\t\t\t- the second dodecic extension field element.\n */\nvoid fp12_add(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Subtracts a dodecic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first dodecic extension field element.\n * @param[in] b\t\t\t\t- the second dodecic extension field element.\n */\nvoid fp12_sub(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Negates a dodecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the dodecic extension field element to negate.\n */\nvoid fp12_neg(fp12_t c, const fp12_t a);\n\n/**\n * Doubles a dodecic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to double.\n */\nvoid fp12_dbl(fp12_t c, const fp12_t a);\n\n/**\n * Multiples two dodecic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the dodecic extension field element.\n */\nvoid fp12_mul_unr(dv12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiples two dodecic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the dodecic extension field element.\n */\nvoid fp12_mul_basic(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiples two dodecic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the dodecic extension field element.\n */\nvoid fp12_mul_lazyr(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiplies a dodecic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to multiply.\n */\nvoid fp12_mul_art(fp12_t c, const fp12_t a);\n\n/**\n * Multiples a dense dodecic extension field element by a sparse element using\n * basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense dodecic extension field element.\n * @param[in] b\t\t\t\t- the sparse dodecic extension field element.\n */\nvoid fp12_mul_dxs_basic(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiples a dense dodecic extension field element by a sparse element using\n * lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense dodecic extension field element.\n * @param[in] b\t\t\t\t- the sparse dodecic extension field element.\n */\nvoid fp12_mul_dxs_lazyr(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Computes the square of a dodecic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to square.\n */\nvoid fp12_sqr_unr(dv12_t c, const fp12_t a);\n\n/**\n * Computes the square of a dodecic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to square.\n */\nvoid fp12_sqr_basic(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a dodecic extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to square.\n */\nvoid fp12_sqr_lazyr(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a cyclotomic dodecic extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_cyc_basic(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a cyclotomic dodecic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_cyc_lazyr(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_pck_basic(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_pck_lazyr(fp12_t c, const fp12_t a);\n\n/**\n * Tests if a dodecic extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp12_test_cyc(const fp12_t a);\n\n/**\n * Converts a dodecic extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a dodecic extension field element.\n */\nvoid fp12_conv_cyc(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to decompress.\n */\nvoid fp12_back_cyc(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp12_back_cyc_sim(fp12_t *c, const fp12_t *a, int n);\n\n/**\n * Inverts a dodecic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to invert.\n */\nvoid fp12_inv(fp12_t c, const fp12_t a);\n\n/**\n * Computes the inverse of a cyclotomic dodecic extension field element.\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^6 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to invert.\n */\nvoid fp12_inv_cyc(fp12_t c, const fp12_t a);\n\n/**\n * Computes the Frobenius endomorphism of a dodecic extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a dodecic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp12_frb(fp12_t c, const fp12_t a, int i);\n\n/**\n * Computes a power of a dodecic extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp12_exp(fp12_t c, const fp12_t a, const bn_t b);\n\n/**\n * Computes a power of a dodecic extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic quadratic extension field element.\n *\n * @param[out] e\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first element to exponentiate.\n * @param[in] b\t\t\t\t- the first exponent.\n * @param[in] c\t\t\t\t- the second element to exponentiate.\n * @param[in] d\t\t\t\t- the second exponent.\n */\nvoid fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] e\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first element to exponentiate.\n * @param[in] b\t\t\t\t- the first exponent.\n * @param[in] c\t\t\t\t- the second element to exponentiate.\n * @param[in] d\t\t\t\t- the second exponent.\n */\nvoid fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, const bn_t d);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, int l, int s);\n\n/**\n * Compresses a dodecic extension field element.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to compress.\n */\nvoid fp12_pck(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses a dodecic extension field element.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp12_upk(fp12_t c, const fp12_t a);\n\n/**\n * Compresses a dodecic extension field element at the maximum rate.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to compress.\n */\nvoid fp12_pck_max(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses a dodecic extension field element at the maximum rate.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp12_upk_max(fp12_t c, const fp12_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to copy.\n */\nvoid fp18_copy(fp18_t c, const fp18_t a);\n\n/**\n * Assigns zero to an octdecic extension field element.\n *\n * @param[out] a\t\t\t- the octdecic extension field element to zero.\n */\nvoid fp18_zero(fp18_t a);\n\n/**\n * Tests if an octdecic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the octdecic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp18_is_zero(const fp18_t a);\n\n/**\n * Assigns a random value to an octdecic extension field element.\n *\n * @param[out] a\t\t\t- the octdecic extension field element to assign.\n */\nvoid fp18_rand(fp18_t a);\n\n/**\n * Prints an octdecic extension field element to standard output.\n *\n * @param[in] A\t\t\t\t- the octdecic extension field element to print.\n */\nvoid fp18_print(const fp18_t a);\n\n/**\n * Returns the number of bytes necessary to store an octdecic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @return the number of bytes.\n */\nint fp18_size_bin(fp18_t a);\n\n/**\n * Reads an octdecic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp18_read_bin(fp18_t a, const uint8_t *bin, int len);\n\n/**\n * Writes an octdecic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp18_write_bin(uint8_t *bin, int len, const fp18_t a);\n\n/**\n * Returns the result of a comparison between two octdecic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first octdecic extension field element.\n * @param[in] b\t\t\t\t- the second octdecic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp18_cmp(const fp18_t a, const fp18_t b);\n\n/**\n * Returns the result of a signed comparison between an octdecic extension\n * field element and a digit.\n *\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp18_cmp_dig(const fp18_t a, const dig_t b);\n\n/**\n * Assigns an octdecic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp18_set_dig(fp18_t a, const dig_t b);\n\n/**\n * Adds two octdecic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first octdecic extension field element.\n * @param[in] b\t\t\t\t- the second octdecic extension field element.\n */\nvoid fp18_add(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Subtracts an octdecic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first octdecic extension field element.\n * @param[in] b\t\t\t\t- the second octdecic extension field element.\n */\nvoid fp18_sub(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Negates an octdecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the octdecic extension field element to negate.\n */\nvoid fp18_neg(fp18_t c, const fp18_t a);\n\n/**\n * Doubles an octdecic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to double.\n */\nvoid fp18_dbl(fp18_t c, const fp18_t a);\n\n/**\n * Multiples two octdecic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the octdecic extension field element.\n */\nvoid fp18_mul_unr(dv18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiples two octdecic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the octdecic extension field element.\n */\nvoid fp18_mul_basic(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiples two octdecic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the octdecic extension field element.\n */\nvoid fp18_mul_lazyr(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiplies an octdecic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to multiply.\n */\nvoid fp18_mul_art(fp18_t c, const fp18_t a);\n\n/**\n * Multiples a dense octdecic extension field element by a sparse element using\n * basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense octdecic extension field element.\n * @param[in] b\t\t\t\t- the sparse octdecic extension field element.\n */\nvoid fp18_mul_dxs_basic(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiples a dense octdecic extension field element by a sparse element using\n * lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense octdecic extension field element.\n * @param[in] b\t\t\t\t- the sparse octdecic extension field element.\n */\nvoid fp18_mul_dxs_lazyr(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Computes the square of an octdecic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to square.\n */\nvoid fp18_sqr_unr(dv18_t c, const fp18_t a);\n\n/**\n * Computes the square of an octdecic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to square.\n */\nvoid fp18_sqr_basic(fp18_t c, const fp18_t a);\n\n/**\n * Computes the square of an octdecic extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to square.\n */\nvoid fp18_sqr_lazyr(fp18_t c, const fp18_t a);\n\n/**\n * Inverts an octdecic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to invert.\n */\nvoid fp18_inv(fp18_t c, const fp18_t a);\n\n/**\n * Computes the inverse of a cyclotomic octdecic extension field element.\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^9 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to invert.\n */\nvoid fp18_inv_cyc(fp18_t c, const fp18_t a);\n\n/**\n * Converts an octdecic extension field element to a cyclotomic element.\n * Computes c = a^(p^9 - 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octdecic extension field element.\n */\nvoid fp18_conv_cyc(fp18_t c, const fp18_t a);\n\n/**\n * Computes the Frobenius endomorphism of an octdecic extension element.\n * Computes c = a^(p^i).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octdecic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp18_frb(fp18_t c, const fp18_t a, int i);\n\n/**\n * Computes a power of an octdecic extension field element.\n * Faster formulas are used if the field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp18_exp(fp18_t c, const fp18_t a, const bn_t b);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to copy.\n */\nvoid fp24_copy(fp24_t c, const fp24_t a);\n\n/**\n * Assigns zero to a 24-degree extension field element.\n *\n * @param[out] a\t\t\t- the 24-degree extension field element to zero.\n */\nvoid fp24_zero(fp24_t a);\n\n/**\n * Tests if a 24-degree extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the 24-degree extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp24_is_zero(const fp24_t a);\n\n/**\n * Assigns a random value to a 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the 24-degree extension field element to assign.\n */\nvoid fp24_rand(fp24_t a);\n\n/**\n * Prints a 24-degree extension field element to standard output.\n *\n * @param[in] A\t\t\t\t- the 24-degree extension field element to print.\n */\nvoid fp24_print(const fp24_t a);\n\n/**\n * Returns the number of bytes necessary to store a 24-degree extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp24_size_bin(fp24_t a, int pack);\n\n/**\n * Reads a 24-degree extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp24_read_bin(fp24_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a 24-degree extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp24_write_bin(uint8_t *bin, int len, const fp24_t a, int pack);\n\n/**\n * Returns the result of a comparison between two 24-degree extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first 24-degree extension field element.\n * @param[in] b\t\t\t\t- the second 24-degree extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp24_cmp(const fp24_t a, const fp24_t b);\n\n/**\n * Returns the result of a signed comparison between a 24-degree extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp24_cmp_dig(const fp24_t a, const dig_t b);\n\n/**\n * Assigns a 24-degree extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp24_set_dig(fp24_t a, const dig_t b);\n\n/**\n * Adds two 24-degree extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 24-degree extension field element.\n * @param[in] b\t\t\t\t- the second 24-degree extension field element.\n */\nvoid fp24_add(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Subtracts a 24-degree extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 24-degree extension field element.\n * @param[in] b\t\t\t\t- the second 24-degree extension field element.\n */\nvoid fp24_sub(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Negates a 24-degree extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the 24-degree extension field element to negate.\n */\nvoid fp24_neg(fp24_t c, const fp24_t a);\n\n/**\n * Doubles a 24-degree extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to double.\n */\nvoid fp24_dbl(fp24_t c, const fp24_t a);\n\n/**\n * Multiples two 24-degree extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the 24-degree extension field element.\n */\nvoid fp24_mul_unr(dv24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Multiples two 24-degree extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the 24-degree extension field element.\n */\nvoid fp24_mul_basic(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Multiples two 24-degree extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the 24-degree extension field element.\n */\nvoid fp24_mul_lazyr(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Multiplies a 24-degree extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to multiply.\n */\nvoid fp24_mul_art(fp24_t c, const fp24_t a);\n\n/**\n * Multiples a dense 24-degree extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 24-degree extension field element.\n * @param[in] b\t\t\t\t- a 24-degree quartic extension field element.\n */\nvoid fp24_mul_dxs(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Computes the square of a 24-degree extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to square.\n */\nvoid fp24_sqr_unr(dv24_t c, const fp24_t a);\n\n/**\n * Computes the square of a 24-degree extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to square.\n */\nvoid fp24_sqr_basic(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a 24-degree extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to square.\n */\nvoid fp24_sqr_lazyr(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a cyclotomic 24-extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_cyc_basic(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a cyclotomic 24-extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_cyc_lazyr(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_pck_basic(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_pck_lazyr(fp24_t c, const fp24_t a);\n\n/**\n * Tests if a 24-extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the 24-extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp24_test_cyc(const fp24_t a);\n\n/**\n * Converts a 24-extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 24-extension field element.\n */\nvoid fp24_conv_cyc(fp24_t c, const fp24_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-extension field element to decompress.\n */\nvoid fp24_back_cyc(fp24_t c, const fp24_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24 field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp24_back_cyc_sim(fp24_t *c, const fp24_t *a, int n);\n\n/**\n * Inverts a 24-degree extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to invert.\n */\nvoid fp24_inv(fp24_t c, const fp24_t a);\n\n/**\n * Computes the inverse of a cyclotomic octdecic extension field element.\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^12 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to invert.\n */\nvoid fp24_inv_cyc(fp24_t c, const fp24_t a);\n\n/**\n * Computes the Frobenius endomorphism of a 24-degree extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 24-degree extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp24_frb(fp24_t c, const fp24_t a, int i);\n\n/**\n * Computes a power of a 24-degree extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp24_exp(fp24_t c, const fp24_t a, const bn_t b);\n\n/**\n * Computes a power of a 24-extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] e\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first element to exponentiate.\n * @param[in] b\t\t\t\t- the first exponent.\n * @param[in] c\t\t\t\t- the second element to exponentiate.\n * @param[in] d\t\t\t\t- the second exponent.\n */\nvoid fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d);\n\n/**\n * Computes a power of a cyclotomic 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, int l, int s);\n\n/**\n * Compresses a 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-extension field element to compress.\n */\nvoid fp24_pck(fp24_t c, const fp24_t a);\n\n/**\n * Decompresses a 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp24_upk(fp24_t c, const fp24_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to copy.\n */\nvoid fp48_copy(fp48_t c, const fp48_t a);\n\n/**\n * Assigns zero to a 48-extension field element.\n *\n * @param[out] a\t\t\t- the 48-extension field element to zero.\n */\nvoid fp48_zero(fp48_t a);\n\n/**\n * Tests if a 48-extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp48_is_zero(const fp48_t a);\n\n/**\n * Assigns a random value to a 48-extension field element.\n *\n * @param[out] a\t\t\t- the 48-extension field element to assign.\n */\nvoid fp48_rand(fp48_t a);\n\n/**\n * Prints a 48-extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element to print.\n */\nvoid fp48_print(const fp48_t a);\n\n/**\n * Returns the number of bytes necessary to store a 48-extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp48_size_bin(fp48_t a, int pack);\n\n/**\n * Reads a 48-extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp48_read_bin(fp48_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a 48-extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp48_write_bin(uint8_t *bin, int len, const fp48_t a, int pack);\n\n/**\n * Returns the result of a comparison between two 48-extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first 48-extension field element.\n * @param[in] b\t\t\t\t- the second 48-extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp48_cmp(const fp48_t a, const fp48_t b);\n\n/**\n * Returns the result of a signed comparison between a 48-extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp48_cmp_dig(const fp48_t a, const dig_t b);\n\n/**\n * Assigns a 48-extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp48_set_dig(fp48_t a, const dig_t b);\n\n/**\n * Adds two 48-extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 48-extension field element.\n * @param[in] b\t\t\t\t- the second 48-extension field element.\n */\nvoid fp48_add(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Subtracts a 48-extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 48-extension field element.\n * @param[in] b\t\t\t\t- the second 48-extension field element.\n */\nvoid fp48_sub(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Negates a 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the 48-extension field element to negate.\n */\nvoid fp48_neg(fp48_t c, const fp48_t a);\n\n/**\n * Doubles a 48-extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to double.\n */\nvoid fp48_dbl(fp48_t c, const fp48_t a);\n\n/**\n * Multiples two 48-extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the 48-extension field element.\n */\nvoid fp48_mul_basic(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Multiples two 48-extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the 48-extension field element.\n */\nvoid fp48_mul_lazyr(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Multiplies a 48-extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to multiply.\n */\nvoid fp48_mul_art(fp48_t c, const fp48_t a);\n\n/**\n * Multiples a dense 48-extension field element by a sparse element using\n * basic arithmetic. Computes C = A * B.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense 48-extension field element.\n * @param[in] b\t\t\t\t- the sparse 48-extension field element.\n */\nvoid fp48_mul_dxs(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Computes the square of a 48-extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to square.\n */\nvoid fp48_sqr_basic(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a 48-extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to square.\n */\nvoid fp48_sqr_lazyr(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a cyclotomic 48-extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_cyc_basic(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a cyclotomic 48-extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_cyc_lazyr(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_pck_basic(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_pck_lazyr(fp48_t c, const fp48_t a);\n\n/**\n * Tests if a 48-extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp48_test_cyc(const fp48_t a);\n\n/**\n * Converts a 48-extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 48-extension field element.\n */\nvoid fp48_conv_cyc(fp48_t c, const fp48_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to decompress.\n */\nvoid fp48_back_cyc(fp48_t c, const fp48_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48 field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp48_back_cyc_sim(fp48_t *c, const fp48_t *a, int n);\n\n/**\n * Inverts a 48-extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to invert.\n */\nvoid fp48_inv(fp48_t c, const fp48_t a);\n\n/**\n * Computes the inverse of a cyclotomic 48-extension field element.\n *\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^24 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to invert.\n */\nvoid fp48_inv_cyc(fp48_t c, const fp48_t a);\n\n/**\n * Computes the Frobenius endomorphism of a 48-extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 48-extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp48_frb(fp48_t c, const fp48_t a, int i);\n\n/**\n * Computes a power of a 48-extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp48_exp(fp48_t c, const fp48_t a, const bn_t b);\n\n/**\n * Computes a power of a 48-extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp48_exp_dig(fp48_t c, const fp48_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int l, int s);\n\n/**\n * Compresses a 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to compress.\n */\nvoid fp48_pck(fp48_t c, const fp48_t a);\n\n/**\n * Decompresses a 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp48_upk(fp48_t c, const fp48_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to copy.\n */\nvoid fp54_copy(fp54_t c, const fp54_t a);\n\n/**\n * Assigns zero to a 54-extension field element.\n *\n * @param[out] a\t\t\t- the 54-extension field element to zero.\n */\nvoid fp54_zero(fp54_t a);\n\n/**\n * Tests if a 54-extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp54_is_zero(const fp54_t a);\n\n/**\n * Assigns a random value to a 54-extension field element.\n *\n * @param[out] a\t\t\t- the 54-extension field element to assign.\n */\nvoid fp54_rand(fp54_t a);\n\n/**\n * Prints a 54-extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element to print.\n */\nvoid fp54_print(const fp54_t a);\n\n/**\n * Returns the number of bytes necessary to store a 54-extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp54_size_bin(fp54_t a, int pack);\n\n/**\n * Reads a 54-extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp54_read_bin(fp54_t a, const uint8_t *bin, int len);\n\n/**\n * Writes a 54-extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp54_write_bin(uint8_t *bin, int len, const fp54_t a, int pack);\n\n/**\n * Returns the result of a comparison between two 54-extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first 54-extension field element.\n * @param[in] b\t\t\t\t- the second 54-extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp54_cmp(const fp54_t a, const fp54_t b);\n\n/**\n * Returns the result of a signed comparison between a 54-extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp54_cmp_dig(const fp54_t a, const dig_t b);\n\n/**\n * Assigns a 54-extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp54_set_dig(fp54_t a, const dig_t b);\n\n/**\n * Adds two 54-extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 54-extension field element.\n * @param[in] b\t\t\t\t- the second 54-extension field element.\n */\nvoid fp54_add(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Subtracts a 54-extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 54-extension field element.\n * @param[in] b\t\t\t\t- the second 54-extension field element.\n */\nvoid fp54_sub(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Negates a 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the 54-extension field element to negate.\n */\nvoid fp54_neg(fp54_t c, const fp54_t a);\n\n/**\n * Doubles a 54-extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to double.\n */\nvoid fp54_dbl(fp54_t c, const fp54_t a);\n\n/**\n * Multiples two 54-extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the 54-extension field element.\n */\nvoid fp54_mul_basic(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Multiples two 54-extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the 54-extension field element.\n */\nvoid fp54_mul_lazyr(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Multiplies a 54-extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to multiply.\n */\nvoid fp54_mul_art(fp54_t c, const fp54_t a);\n\n/**\n * Multiples a dense 54-extension field element by a sparse element using\n * basic arithmetic. Computes C = A * B.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense 54-extension field element.\n * @param[in] b\t\t\t\t- the sparse 54-extension field element.\n */\nvoid fp54_mul_dxs(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Computes the square of a 54-extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to square.\n */\nvoid fp54_sqr_basic(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a 54-extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to square.\n */\nvoid fp54_sqr_lazyr(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a cyclotomic 54-extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_cyc_basic(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a cyclotomic 54-extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_cyc_lazyr(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_pck_basic(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_pck_lazyr(fp54_t c, const fp54_t a);\n\n/**\n * Tests if a 54-extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp54_test_cyc(const fp54_t a);\n\n/**\n * Converts a 54-extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 54-extension field element.\n */\nvoid fp54_conv_cyc(fp54_t c, const fp54_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to decompress.\n */\nvoid fp54_back_cyc(fp54_t c, const fp54_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54 field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp54_back_cyc_sim(fp54_t *c, const fp54_t *a, int n);\n\n/**\n * Inverts a 54-extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to invert.\n */\nvoid fp54_inv(fp54_t c, const fp54_t a);\n\n/**\n * Computes the inverse of a cyclotomic 54-extension field element.\n *\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^24 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to invert.\n */\nvoid fp54_inv_cyc(fp54_t c, const fp54_t a);\n\n/**\n * Computes the Frobenius endomorphism of a 54-extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 54-extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp54_frb(fp54_t c, const fp54_t a, int i);\n\n/**\n * Computes a power of a 54-extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp54_exp(fp54_t c, const fp54_t a, const bn_t b);\n\n/**\n * Computes a power of a 54-extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int l, int s);\n\n/**\n * Compresses a 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to compress.\n */\nvoid fp54_pck(fp54_t c, const fp54_t a);\n\n/**\n * Decompresses a 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp54_upk(fp54_t c, const fp54_t a);\n\n#endif /* !RLC_FPX_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup md Hash functions\n */\n\n/**\n * @file\n *\n * Interface of the module for computing hash functions.\n *\n * @ingroup md\n */\n\n#ifndef RLC_MD_H\n#define RLC_MD_H\n\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\nenum {\n\t/** Hash length for SHA-224 function. */\n\tRLC_MD_LEN_SH224 = 28,\n\t/** Hash length for SHA-256 function. */\n\tRLC_MD_LEN_SH256 = 32,\n\t/** Hash length for SHA-384 function. */\n\tRLC_MD_LEN_SH384 = 48,\n\t/** Hash length for SHA-512 function. */\n\tRLC_MD_LEN_SH512 = 64,\n\t/** Hash length for BLAKE2s-160 function. */\n\tRLC_MD_LEN_B2S160 = 20,\n\t/** Hash length for BLAKE2s-256 function. */\n\tRLC_MD_LEN_B2S256 = 32\n};\n\n/**\n * Length in bytes of default hash function output.\n */\n#if MD_MAP == SH224\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH224\n#elif MD_MAP == SH256\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH256\n#elif MD_MAP == SH384\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH384\n#elif MD_MAP == SH512\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH512\n#elif MD_MAP == B2S160\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_B2S160\n#elif MD_MAP == B2S256\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_B2S256\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Maps a byte vector to a fixed-length byte vector using the chosen hash\n * function.\n *\n * @param[out] H\t\t\t\t- the digest.\n * @param[in] M\t\t\t\t\t- the message to hash.\n * @param[in] L\t\t\t\t\t- the message length in bytes.\n */\n#if MD_MAP == SH224\n#define md_map(H, M, L)\t\t\tmd_map_sh224(H, M, L)\n#elif MD_MAP == SH256\n#define md_map(H, M, L)\t\t\tmd_map_sh256(H, M, L)\n#elif MD_MAP == SH384\n#define md_map(H, M, L)\t\t\tmd_map_sh384(H, M, L)\n#elif MD_MAP == SH512\n#define md_map(H, M, L)\t\t\tmd_map_sh512(H, M, L)\n#elif MD_MAP == B2S160\n#define md_map(H, M, L)\t\t\tmd_map_b2s160(H, M, L)\n#elif MD_MAP == B2S256\n#define md_map(H, M, L)\t\t\tmd_map_b2s256(H, M, L)\n#endif\n\n/**\n * Maps a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the chosen hash function.\n *\n * @param[out] B\t\t\t\t\t- the output buffer.\n * @param[in] BL\t\t\t\t\t- the requested size of the output.\n * @param[in] I\t\t\t\t\t\t- the message to hash.\n * @param[in] IL\t\t\t\t\t- the message length in bytes.\n * @param[in] D\t\t\t\t\t\t- the domain separation tag.\n * @param[in] DL\t\t\t\t\t- the domain separation tag length in bytes.\n */\n#if MD_MAP == SH224\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh224(B, BL, I, IL, D, DL)\n#elif MD_MAP == SH256\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh256(B, BL, I, IL, D, DL)\n#elif MD_MAP == SH384\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh384(B, BL, I, IL, D, DL)\n#elif MD_MAP == SH512\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh512(B, BL, I, IL, D, DL)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Computes the SHA-224 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh224(uint8_t *hash, const uint8_t *msg, int len);\n\n/**\n * Computes the SHA-256 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh256(uint8_t *hash, const uint8_t *msg, int len);\n\n/**\n * Computes the SHA-384 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh384(uint8_t *hash, const uint8_t *msg, int len);\n\n/**\n * Computes the SHA-512 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh512(uint8_t *hash, const uint8_t *msg, int len);\n\n/**\n * Computes the BLAKE2s-160 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len);\n\n/**\n * Computes the BLAKE2s-256 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len);\n\n/**\n * Derives a key from shared secret material through the standardized KDF2\n * function.\n *\n * @param[out] key\t\t\t\t- the resulting key.\n * @param[in] key_len\t\t\t- the intended key length in bytes.\n * @param[in] in\t\t\t\t- the shared secret.\n * @param[in] in_len\t\t\t- the length of the shared secret in bytes.\n */\nvoid md_kdf(uint8_t *key, int key_len, const uint8_t *in, int in_len);\n\n/**\n * Derives a mask from shared secret material through the PKCS#1 2.1 MGF1\n * function. This is the same as the standardized KDF1 key derivation function.\n *\n * @param[out] key\t\t\t\t- the resulting mask.\n * @param[in] key_len\t\t\t- the intended mask length in bytes.\n * @param[in] in\t\t\t\t- the shared secret.\n * @param[in] in_len\t\t\t- the length of the shared secret in bytes.\n */\nvoid md_mgf(uint8_t *mask, int mask_len, const uint8_t *in, int in_len);\n\n/**\n * Computes a Message Authentication Code through HMAC.\n *\n * @param[out] mac\t\t\t\t- the authentication.\n * @param[in] in\t\t\t\t- the date to authenticate.\n * @param[in] in_len\t\t\t- the number of bytes to authenticate.\n * @param[in] key\t\t\t\t- the cryptographic key.\n * @param[in] key_len\t\t\t- the size of the key in bytes.\n */\nvoid md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,\n\t\tint key_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-224 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh224(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n\t\tconst uint8_t *dst, int dst_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-256 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh256(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n\t\tconst uint8_t *dst, int dst_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-384 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh384(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n\t\tconst uint8_t *dst, int dst_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-512 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh512(uint8_t *buf, int buf_len, const uint8_t *in, int in_len,\n\t\tconst uint8_t *dst, int dst_len);\n\n#endif /* !RLC_MD_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup rand Pseudo-random number generators.\n */\n\n/**\n * @file\n *\n * Interface of the module for pseudo-random number generation.\n *\n * @ingroup rand\n */\n\n#ifndef RLC_RAND_H\n#define RLC_RAND_H\n\n#include \"relic_rand.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Size of the PRNG internal state in bytes.\n */\n#if RAND == HASHD\n\n#if MD_MAP == SH224 || MD_MAP == SH256 || MD_MAP == B2S160 || MD_MAP == B2S256\n#define RLC_RAND_SIZE\t\t(1 + 2*440/8)\n#elif MD_MAP == SH384 || MD_MAP == SH512\n#define RLC_RAND_SIZE\t\t(1 + 2*888/8)\n#endif\n\n#elif RAND == UDEV\n#define RLC_RAND_SIZE\t\t(sizeof(int))\n#elif RAND == CALL\n#define RLC_RAND_SIZE\t\t(sizeof(void (*)(uint8_t *, int)))\n#elif RAND == RDRND\n#define RLC_RAND_SIZE      0\n#endif\n\n/**\n * Minimum size of the PRNG seed.\n */\n#define RLC_RAND_SEED\t    64\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the pseudo-random number generator.\n */\nvoid rand_init(void);\n\n/**\n * Finishes the pseudo-random number generator.\n */\nvoid rand_clean(void);\n\n#if RAND != CALL\n\n/**\n * Sets the initial state of the pseudo-random number generator.\n *\n * @param[in] buf\t\t\t- the buffer that represents the initial state.\n * @param[in] size\t\t\t- the number of bytes.\n * @throw ERR_NO_VALID\t\t- if the entropy length is too small or too large.\n */\nvoid rand_seed(uint8_t *buf, int size);\n\n#else\n\n/**\n * Sets the initial state of the pseudo-random number generator as a function\n * pointer.\n *\n * @param[in] callback\t\t- the callback to call.\n * @param[in] arg\t\t\t- the argument for the callback.\n */\nvoid rand_seed(void (*callback)(uint8_t *, int, void *), void *arg);\n\n#endif\n\n/**\n * Performs a basic self-test in the pseudo-random number generator output, and\n * raises an exception in case a string of identifical bytes is found.\n *\n * @param[out] buf\t\t\t- the buffer to check.\n * @param[in] size\t\t\t- the number of bytes to check.\n * @throw ERR_NO_RAND       - if the pseudo-random number generator is stuck.\n */\nint rand_check(uint8_t *buf, int size);\n\n/**\n * Gathers pseudo-random bytes from the pseudo-random number generator.\n *\n * @param[out] buf\t\t\t- the buffer to write.\n * @param[in] size\t\t\t- the number of bytes to gather.\n * @throw ERR_NO_VALID\t\t- if the required length is too large.\n * @throw ERR_NO_READ\t\t- it the pseudo-random number generator cannot\n * \t\t\t\t\t\t\tgenerate the specified number of bytes.\n */\nvoid rand_bytes(uint8_t *buf, int size);\n\n#endif /* !RLC_RAND_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup util Misc utilities\n */\n\n/**\n * @file\n *\n * Interface of misc utilitles.\n *\n * @ingroup util\n */\n\n#ifndef RLC_UTIL_H\n#define RLC_UTIL_H\n\n#include \"relic_arch.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Returns the minimum between two numbers.\n *\n * @param[in] A\t\t- the first number.\n * @param[in] B\t\t- the second number.\n */\n#define RLC_MIN(A, B)\t\t\t((A) < (B) ? (A) : (B))\n\n/**\n * Returns the maximum between two numbers.\n *\n * @param[in] A\t\t- the first number.\n * @param[in] B\t\t- the second number.\n */\n#define RLC_MAX(A, B)\t\t\t((A) > (B) ? (A) : (B))\n\n/**\n * Splits a bit count in a digit count and an updated bit count.\n *\n * @param[out] B\t\t- the resulting bit count.\n * @param[out] D\t\t- the resulting digit count.\n * @param[out] V\t\t- the bit count.\n */\n#define RLC_RIP(B, D, V)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tD = (V) >> (RLC_DIG_LOG); B = (V) - ((D) * (1 << RLC_DIG_LOG));\n\n/**\n * Computes the ceiling function of an integer division.\n *\n * @param[in] A\t\t\t- the dividend.\n * @param[in] B\t\t\t- the divisor.\n */\n#define RLC_CEIL(A, B)\t\t\t(((A) - 1) / (B) + 1)\n\n/**\n * Returns a bit mask to isolate the lowest part of a digit.\n *\n * @param[in] B\t\t\t- the number of bits to isolate.\n */\n#define RLC_MASK(B)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t((-(dig_t)((B) >= WSIZE)) | (((dig_t)1 << ((B) % WSIZE)) - 1))\n\n/**\n * Returns a bit mask to isolate the lowest half of a digit.\n */\n#define RLC_LMASK\t\t\t\t(RLC_MASK(RLC_DIG >> 1))\n\n/**\n * Returns a bit mask to isolate the highest half of a digit.\n */\n#define RLC_HMASK\t\t\t\t(RLC_LMASK << (RLC_DIG >> 1))\n\n/**\n * Bit mask used to return an entire digit.\n */\n#define RLC_DMASK\t\t\t\t(RLC_HMASK | RLC_LMASK)\n\n/**\n * Returns the lowest half of a digit.\n *\n * @param[in] D\t\t\t- the digit.\n */\n#define RLC_LOW(D)\t\t\t\t(D & RLC_LMASK)\n\n/**\n * Returns the highest half of a digit.\n *\n * @param[in] D\t\t\t- the digit.\n */\n#define RLC_HIGH(D)\t\t\t\t(D >> (RLC_DIG >> 1))\n\n/**\n * Returns the sign bit of a digit.\n *\n * @param[in] D\t\t\t- the digit.\n */\n#define RLC_SIGN(D)\t\t\t\t(((dig_t)D) >> (RLC_DIG - 1))\n\n/**\n * Selects between two values based on the value of a given flag.\n *\n * @param[in] A\t\t\t- the first argument.\n * @param[in] B\t\t\t- the second argument.\n * @param[in] C\t\t\t- the selection flag.\n */\n#define RLC_SEL(A, B, C) \t\t((-(C) & ((A) ^ (B))) ^ (A))\n\n/**\n * Swaps two values.\n *\n * @param[in] A\t\t\t- the first argument.\n * @param[in] B\t\t\t- the second argument.\n */\n#define RLC_SWAP(A, B) \t\t\t((A) ^= (B), (B) ^= (A), (A) ^= (B))\n\n/**\n * Returns the given character in upper case.\n *\n * @param[in] C\t\t\t- the character.\n */\n#define RLC_UPP(C)\t\t\t\t((C) - 0x20 * (((C) >= 'a') && ((C) <= 'z')))\n\n/**\n  *  Indirection to help some compilers expand symbols.\n  */\n#define RLC_ECHO(A) \t\t\tA\n\n/**\n * Concatenates two tokens.\n */\n/** @{ */\n#define RLC_CAT(A, B)\t\t\t_RLC_CAT(A, B)\n#define _RLC_CAT(A, B)\t\t\tA ## B\n/** @} */\n\n/**\n * Selects a basic or advanced version of a function by checking if an\n * additional argument was passed.\n */\n/** @{ */\n#define RLC_OPT(...)\t\t\t_OPT(__VA_ARGS__, _imp, _basic, _error)\n#define _OPT(...)\t\t\t\tRLC_ECHO(__OPT(__VA_ARGS__))\n#define __OPT(_1, _2, N, ...)\tN\n/** @} */\n\n/**\n * Generic macro to initialize an object to NULL.\n *\n * @param[out] A\t\t\t- the object to initialize.\n */\n#if ALLOC == AUTO\n#define RLC_NULL(A)\t\t\t/* empty */\n#else\n#define RLC_NULL(A)\t\t\tA = NULL;\n#endif\n\n\n/**\n * Accumulates a double precision digit in a triple register variable.\n *\n * @param[in,out] R2\t\t- most significant word of the triple register.\n * @param[in,out] R1\t\t- middle word of the triple register.\n * @param[in,out] R0\t\t- lowest significant word of the triple register.\n * @param[in] A\t\t\t\t- the first digit to multiply.\n * @param[in] B\t\t\t\t- the second digit to multiply.\n */\n#define RLC_COMBA_STEP_MUL(R2, R1, R0, A, B)\t\t\t\t\t\t\t\t\\\n\tdig_t _r, _r0, _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_MUL_DIG(_r1, _r0, A, B);\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_COMBA_ADD(_r, R2, R1, R0, _r0);\t\t\t\t\t\t\t\t\t\t\\\n\t(R1) += _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (R1) < _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Computes the step of a Comba squaring.\n *\n * @param[in,out] R2\t\t- most significant word of the triple register.\n * @param[in,out] R1\t\t- middle word of the triple register.\n * @param[in,out] R0\t\t- lowest significant word of the triple register.\n * @param[in] A\t\t\t\t- the first digit to multiply.\n * @param[in] B\t\t\t\t- the second digit to multiply.\n */\n#define RLC_COMBA_STEP_SQR(R2, R1, R0, A, B)\t\t\t\t\t\t\t\t\\\n\tdig_t _r, _r0, _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_MUL_DIG(_r1, _r0, A, B);\t\t\t\t\t\t\t\t\t\t\t\\\n\tdig_t _s0 = _r0 + _r0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tdig_t _s1 = _r1 + _r1 + (_s0 < _r0);\t\t\t\t\t\t\t\t\t\\\n\tRLC_COMBA_ADD(_r, R2, R1, R0, _s0);\t\t\t\t\t\t\t\t\t\t\\\n\t(R1) += _s1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (R1) < _s1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (_s1 < _r1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Accumulates a single precision digit in a triple register variable.\n *\n * @param[in,out] T\t\t\t- the temporary variable.\n * @param[in,out] R2\t\t- most significant word of the triple register.\n * @param[in,out] R1\t\t- middle word of the triple register.\n * @param[in,out] R0\t\t- lowest significant word of the triple register.\n * @param[in] A\t\t\t\t- the first digit to accumulate.\n */\n#define RLC_COMBA_ADD(T, R2, R1, R0, A)\t\t\t\t\t\t\t\t\t\t\\\n\t(T) = (R1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R0) += (A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R1) += (R0) < (A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (R1) < (T);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Selects a real or dummy printing function depending on library flags.\n *\n * @param[in] F\t\t\t- the format string.\n */\n#ifndef QUIET\n#define util_print(F, ...)\t\tutil_printf(RLC_STR(F), ##__VA_ARGS__)\n#else\n#define util_print(F, ...)\t\t/* empty */\n#endif\n\n/**\n * Prints a standard label.\n *\n * @param[in] L\t\t\t- the label of the banner.\n * @param[in] I\t\t\t- if the banner is inside an hierarchy.\n */\n#define util_banner(L, I)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!I) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tutil_print(\"\\n-- \" L \"\\n\");\t\t\t\t\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tutil_print(\"\\n** \" L \"\\n\\n\");\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Toggle endianess of a digit.\n */\nuint32_t util_conv_endian(uint32_t i);\n\n/**\n * Convert a digit to big-endian.\n */\nuint32_t util_conv_big(uint32_t i);\n\n/**\n * Convert a digit to little-endian.\n */\nuint32_t util_conv_little(uint32_t i);\n\n/**\n * Converts a small digit to a character.\n */\nchar util_conv_char(dig_t i);\n\n/**\n * Returns the highest bit set on a digit.\n *\n * @param[in] a\t\t\t\t- the digit.\n * @return the position of the highest bit set.\n */\nint util_bits_dig(dig_t a);\n\n/**\n * Compares two buffers in constant time.\n *\n * @param[in] a\t\t\t\t- the first buffer.\n * @param[in] b\t\t\t\t- the second buffer.\n * @param[in] n\t\t\t\t- the length in bytes of the buffers.\n * @return RLC_EQ if they are equal and RLC_NE otherwise.\n */\nint util_cmp_const(const void *a, const void *b, int n);\n\n/**\n * Computes a random permutation in [0, n-1].\n *\n * @param[out] p \t\t\t- the resulting permutation.\n * @param[in] n \t\t\t- the size of the permutation.\n */\nvoid util_perm(unsigned int p[], int n);\n\n/**\n * Formats and prints data following a printf-like syntax.\n *\n * @param[in] format\t\t- the format.\n * @param[in] ...\t\t\t- the list of arguments matching the format.\n */\nvoid util_printf(const char *format, ...);\n\n/**\n * Prints a digit.\n *\n * @param[in] a \t\t\t- the digit to print.\n * @param[in] pad \t\t\t- the flag to indicate if the digit must be padded\n * \t\t\t\t\t\t\twith zeroes.\n */\nvoid util_print_dig(dig_t a, int pad);\n\n#endif /* !RLC_UTIL_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision addition and subtraction functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\nvoid bn_gcd_basic(bn_t c, const bn_t a, const bn_t b) {\n\tbn_t u, v;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\n\t\tbn_abs(u, a);\n\t\tbn_abs(v, b);\n\t\twhile (!bn_is_zero(v)) {\n\t\t\tbn_copy(c, v);\n\t\t\tbn_mod(v, u, v);\n\t\t\tbn_copy(u, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t}\n}\n\nvoid bn_gcd_ext_basic(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n\tbn_t u, v, x_1, y_1, q, r;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(x_1);\n\tbn_null(y_1);\n\tbn_null(q);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(x_1);\n\t\tbn_new(y_1);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\n\t\tbn_abs(u, a);\n\t\tbn_abs(v, b);\n\n\t\tbn_zero(x_1);\n\t\tbn_set_dig(y_1, 1);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\n\t\twhile (!bn_is_zero(v)) {\n\t\t\tbn_div_rem(q, r, u, v);\n\n\t\t\tbn_copy(u, v);\n\t\t\tbn_copy(v, r);\n\n\t\t\tbn_mul(c, q, x_1);\n\t\t\tbn_sub(r, d, c);\n\t\t\tbn_copy(d, x_1);\n\t\t\tbn_copy(x_1, r);\n\n\t\t\tif (e != NULL) {\n\t\t\t\tbn_mul(c, q, y_1);\n\t\t\t\tbn_sub(r, e, c);\n\t\t\t\tbn_copy(e, y_1);\n\t\t\t\tbn_copy(y_1, r);\n\t\t\t}\n\t\t}\n\t\tbn_copy(c, u);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(x_1);\n\t\tbn_free(y_1);\n\t\tbn_free(q);\n\t\tbn_free(r);\n\t}\n}\n\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\nvoid bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {\n\tbn_t x, y, u, v, t0, t1, t2, t3;\n\tdig_t _x, _y, q, _q, t, _t;\n\tdis_t _a, _b, _c, _d;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_null(x);\n\tbn_null(y);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\tbn_null(t3);\n\n\t/*\n\t * Taken from Handbook of Hyperelliptic and Elliptic Cryptography.\n\t */\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tbn_new(y);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\t\tbn_new(t3);\n\n\t\tif (bn_cmp_abs(a, b) == RLC_GT) {\n\t\t\tbn_abs(x, a);\n\t\t\tbn_abs(y, b);\n\t\t} else {\n\t\t\tbn_abs(x, b);\n\t\t\tbn_abs(y, a);\n\t\t}\n\t\twhile (y->used > 1) {\n\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n\t\t\t_x = u->dp[0];\n\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n\t\t\t_y = v->dp[0];\n\t\t\t_a = _d = 1;\n\t\t\t_b = _c = 0;\n\t\t\tt = 0;\n\t\t\tif (_y != 0) {\n\t\t\t\tq = _x / _y;\n\t\t\t\tt = _x % _y;\n\t\t\t}\n\t\t\tif (t >= ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\twhile (1) {\n\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t_t = _y % t;\n\t\t\t\t\tif (_t < ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_x = _y;\n\t\t\t\t\t_y = t;\n\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t_a = _c;\n\t\t\t\t\t_c = t;\n\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t_b = _d;\n\t\t\t\t\t_d = t;\n\t\t\t\t\tt = _t;\n\t\t\t\t\tq = _q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_b == 0) {\n\t\t\t\tbn_mod(t0, x, y);\n\t\t\t\tbn_copy(x, y);\n\t\t\t\tbn_copy(y, t0);\n\t\t\t} else {\n\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, u, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, u, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, v, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, v, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, u, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, u, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, v, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, v, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(u, t0, t1);\n\t\t\t\tbn_add(v, t2, t3);\n\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n\t\t\t\t_x = t0->dp[0];\n\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n\t\t\t\t_y = t1->dp[0];\n\t\t\t\tt = 0;\n\t\t\t\tif (_y != 0) {\n\t\t\t\t\tq = _x / _y;\n\t\t\t\t\tt = _x % _y;\n\t\t\t\t}\n\t\t\t\tif (t >= ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t\t_t = _y % t;\n\t\t\t\t\t\tif (_t < ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_x = _y;\n\t\t\t\t\t\t_y = t;\n\t\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t\t_a = _c;\n\t\t\t\t\t\t_c = t;\n\t\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t\t_b = _d;\n\t\t\t\t\t\t_d = t;\n\t\t\t\t\t\tt = _t;\n\t\t\t\t\t\tq = _q;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, x, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, x, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, y, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, y, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, x, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, x, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, y, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, y, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(x, t0, t1);\n\t\t\t\tbn_add(y, t2, t3);\n\t\t\t}\n\t\t}\n\t\tbn_gcd_ext_dig(c, u, v, x, y->dp[0]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tbn_free(y);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t\tbn_free(t3);\n\t}\n}\n\nvoid bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n\tbn_t x, y, u, v, t0, t1, t2, t3, t4;\n\tdig_t _x, _y, q, _q, t, _t;\n\tdis_t _a, _b, _c, _d;\n\tint swap;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(x);\n\tbn_null(y);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\tbn_null(t3);\n\tbn_null(t4);\n\n\t/*\n\t * Taken from Handbook of Hyperelliptic and Elliptic Cryptography.\n\t */\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tbn_new(y);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\t\tbn_new(t3);\n\t\tbn_new(t4);\n\n\t\tif (bn_cmp_abs(a, b) != RLC_LT) {\n\t\t\tbn_abs(x, a);\n\t\t\tbn_abs(y, b);\n\t\t\tswap = 0;\n\t\t} else {\n\t\t\tbn_abs(x, b);\n\t\t\tbn_abs(y, a);\n\t\t\tswap = 1;\n\t\t}\n\n\t\tbn_zero(t4);\n\t\tbn_set_dig(d, 1);\n\n\t\twhile (y->used > 1) {\n\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n\t\t\t_x = u->dp[0];\n\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n\t\t\t_y = v->dp[0];\n\t\t\t_a = _d = 1;\n\t\t\t_b = _c = 0;\n\t\t\tt = 0;\n\t\t\tif (_y != 0) {\n\t\t\t\tq = _x / _y;\n\t\t\t\tt = _x % _y;\n\t\t\t}\n\t\t\tif (t >= ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\twhile (1) {\n\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t_t = _y % t;\n\t\t\t\t\tif (_t < ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_x = _y;\n\t\t\t\t\t_y = t;\n\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t_a = _c;\n\t\t\t\t\t_c = t;\n\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t_b = _d;\n\t\t\t\t\t_d = t;\n\t\t\t\t\tt = _t;\n\t\t\t\t\tq = _q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_b == 0) {\n\t\t\t\tbn_div_rem(t1, t0, x, y);\n\t\t\t\tbn_copy(x, y);\n\t\t\t\tbn_copy(y, t0);\n\t\t\t\tbn_mul(t1, t1, d);\n\t\t\t\tbn_sub(t1, t4, t1);\n\t\t\t\tbn_copy(t4, d);\n\t\t\t\tbn_copy(d, t1);\n\t\t\t} else {\n\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, u, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, u, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, v, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, v, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, u, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, u, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, v, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, v, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(u, t0, t1);\n\t\t\t\tbn_add(v, t2, t3);\n\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n\t\t\t\t_x = t0->dp[0];\n\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n\t\t\t\t_y = t1->dp[0];\n\t\t\t\tt = 0;\n\t\t\t\tif (_y != 0) {\n\t\t\t\t\tq = _x / _y;\n\t\t\t\t\tt = _x % _y;\n\t\t\t\t}\n\t\t\t\tif (t >= ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t\t_t = _y % t;\n\t\t\t\t\t\tif (_t < ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_x = _y;\n\t\t\t\t\t\t_y = t;\n\t\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t\t_a = _c;\n\t\t\t\t\t\t_c = t;\n\t\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t\t_b = _d;\n\t\t\t\t\t\t_d = t;\n\t\t\t\t\t\tt = _t;\n\t\t\t\t\t\tq = _q;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, x, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, x, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, y, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, y, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, x, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, x, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, y, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, y, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(x, t0, t1);\n\t\t\t\tbn_add(y, t2, t3);\n\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, t4, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, t4, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, d, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, d, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, t4, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, t4, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, d, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, d, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(t4, t0, t1);\n\t\t\t\tbn_add(d, t2, t3);\n\t\t\t}\n\t\t}\n\t\tbn_gcd_ext_dig(c, u, v, x, y->dp[0]);\n\t\tif (!swap) {\n\t\t\tbn_mul(t0, t4, u);\n\t\t\tbn_mul(t1, d, v);\n\t\t\tbn_add(t4, t0, t1);\n\t\t\tbn_mul(x, b, t4);\n\t\t\tbn_sub(x, c, x);\n\t\t\tbn_div(d, x, a);\n\t\t} else {\n\t\t\tbn_mul(t0, t4, u);\n\t\t\tbn_mul(t1, d, v);\n\t\t\tbn_add(d, t0, t1);\n\t\t\tbn_mul(x, a, d);\n\t\t\tbn_sub(x, c, x);\n\t\t\tbn_div(t4, x, b);\n\t\t}\n\t\tif (e != NULL) {\n\t\t\tbn_copy(e, t4);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tbn_free(y);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t\tbn_free(t3);\n\t\tbn_free(t4);\n\t}\n}\n\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\nvoid bn_gcd_binar(bn_t c, const bn_t a, const bn_t b) {\n\tbn_t u, v, t;\n\tint shift;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(t);\n\n\t\tbn_abs(u, a);\n\t\tbn_abs(v, b);\n\n\t\tshift = 0;\n\t\twhile (bn_is_even(u) && bn_is_even(v)) {\n\t\t\tbn_hlv(u, u);\n\t\t\tbn_hlv(v, v);\n\t\t\tshift++;\n\t\t}\n\t\twhile (!bn_is_zero(u)) {\n\t\t\twhile (bn_is_even(u)) {\n\t\t\t\tbn_hlv(u, u);\n\t\t\t}\n\t\t\twhile (bn_is_even(v)) {\n\t\t\t\tbn_hlv(v, v);\n\t\t\t}\n\t\t\tbn_sub(t, u, v);\n\t\t\tbn_abs(t, t);\n\t\t\tbn_hlv(t, t);\n\t\t\tif (bn_cmp(u, v) != RLC_LT) {\n\t\t\t\tbn_copy(u, t);\n\t\t\t} else {\n\t\t\t\tbn_copy(v, t);\n\t\t\t}\n\t\t}\n\t\tbn_lsh(c, v, shift);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n\tbn_t x, y, t, u, v, _a, _b, _e;\n\tint shift;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(x);\n\tbn_null(y);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(_a);\n\tbn_null(_b);\n\tbn_null(_e);\n\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tbn_new(y);\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(_a);\n\t\tbn_new(_b);\n\t\tbn_new(_e);\n\n\t\tbn_abs(x, a);\n\t\tbn_abs(y, b);\n\n\t\t/* g = 1. */\n\t\tshift = 0;\n\t\t/* While x and y are both even, x = x/2 and y = y/2, g = 2g. */\n\t\twhile (bn_is_even(x) && bn_is_even(y)) {\n\t\t\tbn_hlv(x, x);\n\t\t\tbn_hlv(y, y);\n\t\t\tshift++;\n\t\t}\n\n\t\tbn_copy(u, x);\n\t\tbn_copy(v, y);\n\n\t\t/* u = x, y = v, A = 1, B = 0, C = 0, D = 1. */\n\t\tbn_set_dig(_a, 1);\n\t\tbn_zero(_b);\n\t\tbn_zero(d);\n\t\tbn_set_dig(_e, 1);\n\n\t\t/* While u is even, u = u/2. */\n\t\twhile (bn_is_even(u)) {\n\t\t\tbn_hlv(u, u);\n\t\t\t/* If A = B = 0 (mod 2) then A = A/2, B = B/2. */\n\t\t\tif ((_a->dp[0] & 0x01) == 0 && (_b->dp[0] & 0x01) == 0) {\n\t\t\t\tbn_hlv(_a, _a);\n\t\t\t\tbn_hlv(_b, _b);\n\t\t\t} else {\n\t\t\t\t/* Otherwise A = (A + y)/2, B = (B - x)/2. */\n\t\t\t\tbn_add(_a, _a, y);\n\t\t\t\tbn_hlv(_a, _a);\n\t\t\t\tbn_sub(_b, _b, x);\n\t\t\t\tbn_hlv(_b, _b);\n\t\t\t}\n\t\t}\n\t\twhile (bn_cmp(u, v) != RLC_EQ) {\n\t\t\t/* If v is even, v = v/2. */\n\t\t\tif (bn_is_even(v)) {\n\t\t\t\tbn_hlv(v, v);\n\t\t\t\t/* If C = D = 0 (mod 2) then C = C/2, D = D/2. */\n\t\t\t\tif ((d->dp[0] & 0x01) == 0 && (_e->dp[0] & 0x01) == 0) {\n\t\t\t\t\tbn_hlv(d, d);\n\t\t\t\t\tbn_hlv(_e, _e);\n\t\t\t\t} else {\n\t\t\t\t\t/* Otherwise C = (C + y)/2, D = (D - x)/2. */\n\t\t\t\t\tbn_add(d, d, y);\n\t\t\t\t\tbn_hlv(d, d);\n\t\t\t\t\tbn_sub(_e, _e, x);\n\t\t\t\t\tbn_hlv(_e, _e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bn_cmp(v, u) == RLC_LT) {\n\t\t\t\t\tbn_copy(c, u);\n\t\t\t\t\tbn_copy(u, v);\n\t\t\t\t\tbn_copy(v, c);\n\t\t\t\t\tbn_copy(c, d);\n\t\t\t\t\tbn_copy(d, _a);\n\t\t\t\t\tbn_copy(_a, c);\n\t\t\t\t\tbn_copy(c, _e);\n\t\t\t\t\tbn_copy(_e, _b);\n\t\t\t\t\tbn_copy(_b, c);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub(v, v, u);\n\t\t\t\t\tbn_sub(d, d, _a);\n\t\t\t\t\tbn_sub(_e, _e, _b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* If u = 0 then d = C, e = D and return (d, e, g * v). */\n\t\tbn_lsh(c, u, shift);\n\t\t/* Now fix reciprocals. */\n\t\tbn_div(x, x, u);\n\t\tbn_div(y, y, u);\n\t\tbn_hlv(_a, x);\n\t\tbn_hlv(_b, y);\n\t\twhile (bn_cmp_abs(d, _b) == RLC_GT) {\n\t\t\tbn_div(t, d, _b);\n\t\t\tif (bn_bits(t) > 1) {\n\t\t\t\tbn_hlv(t, t);\n\t\t\t}\n\t\t\tbn_mul(v, x, t);\n\t\t\tbn_mul(u, y, t);\n\t\t\tif (bn_sign(d) != bn_sign(u)) {\n\t\t\t\tbn_add(d, d, u);\n\t\t\t\tbn_sub(_e, _e, v);\n\t\t\t} else {\n\t\t\t\tbn_sub(d, d, u);\n\t\t\t\tbn_add(_e, _e, v);\n\t\t\t}\n\t\t}\n\t\tif (e != NULL) {\n\t\t\tbn_copy(e, _e);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tbn_free(y);\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(_a);\n\t\tbn_free(_b);\n\t\tbn_free(_e);\n\t}\n}\n\n#endif\n\nvoid bn_gcd_ext_mid(bn_t c, bn_t d, bn_t e, bn_t f, const bn_t a, const bn_t b) {\n\tbn_t p, q, r, s, t, u, v, x, w, y, z;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tbn_zero(e);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tbn_set_dig(e, 1);\n\t\treturn;\n\t}\n\n\tbn_null(q);\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(x);\n\tbn_null(w);\n\tbn_null(y);\n\tbn_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(x);\n\t\tbn_new(w);\n\t\tbn_new(y);\n\t\tbn_new(z);\n\n\t\tif (bn_cmp_abs(a, b) == RLC_GT) {\n\t\t\tbn_abs(u, a);\n\t\t\tbn_abs(v, b);\n\t\t} else {\n\t\t\tbn_abs(u, b);\n\t\t\tbn_abs(v, a);\n\t\t}\n\n\t\tbn_srt(p, u);\n\n\t\tbn_set_dig(x, 1);\n\t\tbn_zero(t);\n\n\t\tint wait = 0;\n\t\twhile (!bn_is_zero(v)) {\n\t\t\tbn_div_rem(q, r, u, v);\n\n\t\t\tbn_copy(u, v);\n\t\t\tbn_copy(v, r);\n\n\t\t\tbn_mul(s, q, x);\n\t\t\tbn_sub(s, t, s);\n\t\t\tbn_copy(t, x);\n\t\t\tbn_copy(x, s);\n\n\t\t\tif (wait) {\n\t\t\t\tbn_copy(e, r);\n\t\t\t\tbn_neg(f, x);\n\t\t\t\twait = 0;\n\t\t\t}\n\t\t\tif (bn_cmp(u, p) != RLC_LT) {\n\t\t\t\tbn_copy(c, r);\n\t\t\t\tbn_neg(d, x);\n\t\t\t\tbn_copy(w, u);\n\t\t\t\tbn_neg(y, t);\n\t\t\t\twait = 1;\n\t\t\t}\n\t\t}\n\t\t/* Compute r as the norm of vector (w, y). */\n\t\tbn_sqr(s, w);\n\t\tbn_sqr(t, y);\n\t\tbn_add(t, t, s);\n\n\t\t/* Compute q as the norm of vector (e, f). */\n\t\tbn_sqr(r, e);\n\t\tbn_sqr(q, f);\n\t\tbn_add(q, q, r);\n\n\t\t/* Output (e, f) as the vector of smaller norm. */\n\t\tif (bn_cmp(t, q) == RLC_LT) {\n\t\t\tbn_copy(e, w);\n\t\t\tbn_copy(f, y);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(p);\n\t\tbn_free(q);\n\t\tbn_free(r);\n\t\tbn_free(s);\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(x);\n\t\tbn_free(w);\n\t\tbn_free(y);\n\t\tbn_free(z);\n\t}\n}\n\nvoid bn_gcd_dig(bn_t c, const bn_t a, dig_t b) {\n\tdig_t _u, _v, _t = 0;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_set_dig(c, b);\n\t\treturn;\n\t}\n\n\tif (b == 0) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_mod_dig(&(c->dp[0]), a, b);\n\t_v = c->dp[0];\n\t_u = b;\n\twhile (_v != 0) {\n\t\t_t = _v;\n\t\t_v = _u % _v;\n\t\t_u = _t;\n\t}\n\tbn_set_dig(c, _u);\n}\n\nvoid bn_gcd_ext_dig(bn_t c, bn_t d, bn_t e, const bn_t a, const dig_t b) {\n\tbn_t u, v, x1, y1, q, r;\n\tdig_t _v, _q, _t, _u;\n\n\tif (d == NULL && e == NULL) {\n\t\tbn_gcd_dig(c, a, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(a)) {\n\t\tbn_set_dig(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (b == 0) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(x1);\n\tbn_null(y1);\n\tbn_null(q);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(x1);\n\t\tbn_new(y1);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\n\t\tbn_abs(u, a);\n\t\tbn_set_dig(v, b);\n\n\t\tbn_zero(x1);\n\t\tbn_set_dig(y1, 1);\n\t\tbn_set_dig(d, 1);\n\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\n\t\tbn_div_rem(q, r, u, v);\n\n\t\tbn_copy(u, v);\n\t\tbn_copy(v, r);\n\n\t\tbn_mul(c, q, x1);\n\t\tbn_sub(r, d, c);\n\t\tbn_copy(d, x1);\n\t\tbn_copy(x1, r);\n\n\t\tif (e != NULL) {\n\t\t\tbn_mul(c, q, y1);\n\t\t\tbn_sub(r, e, c);\n\t\t\tbn_copy(e, y1);\n\t\t\tbn_copy(y1, r);\n\t\t}\n\n\t\t_v = v->dp[0];\n\t\t_u = u->dp[0];\n\t\twhile (_v != 0) {\n\t\t\t_q = _u / _v;\n\t\t\t_t = _u % _v;\n\n\t\t\t_u = _v;\n\t\t\t_v = _t;\n\n\t\t\tbn_mul_dig(c, x1, _q);\n\t\t\tbn_sub(r, d, c);\n\t\t\tbn_copy(d, x1);\n\t\t\tbn_copy(x1, r);\n\n\t\t\tif (e != NULL) {\n\t\t\t\tbn_mul_dig(c, y1, _q);\n\t\t\t\tbn_sub(r, e, c);\n\t\t\t\tbn_copy(e, y1);\n\t\t\t\tbn_copy(y1, r);\n\t\t\t}\n\t\t}\n\t\tbn_set_dig(c, _u);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(x1);\n\t\tbn_free(y1);\n\t\tbn_free(q);\n\t\tbn_free(r);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision integer memory management routines.\n *\n * @ingroup bn\n */\n\n#include <errno.h>\n\n#if ALLOC != AUTO\n#include <malloc.h>\n#endif\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_make(bn_t a, int digits) {\n\tif (digits < 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\t/* Allocate at least one digit. */\n\tdigits = RLC_MAX(digits, 1);\n\n#if ALLOC == DYNAMIC\n\tif (digits % RLC_BN_SIZE != 0) {\n\t\t/* Pad the number of digits to a multiple of the block. */\n\t\tdigits += (RLC_BN_SIZE - digits % RLC_BN_SIZE);\n\t}\n\n\tif (a != NULL) {\n\t\ta->dp = NULL;\n#if ALIGN == 1\n\t\ta->dp = (dig_t *)malloc(digits * sizeof(dig_t));\n#elif OPSYS == WINDOWS\n\t\ta->dp = _aligned_malloc(digits * sizeof(dig_t), ALIGN);\n#else\n\t\tint r = posix_memalign((void **)&a->dp, ALIGN, digits * sizeof(dig_t));\n\t\tif (r == ENOMEM) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tif (r == EINVAL) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n#endif /* ALIGN */\n\t}\n\n\tif (a->dp == NULL) {\n\t\tfree((void *)a);\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t}\n#else\n\t/* Verify if the number of digits is sane. */\n\tif (digits > RLC_BN_SIZE) {\n\t\tRLC_THROW(ERR_NO_PRECI);\n\t\treturn;\n\t} else {\n\t\tdigits = RLC_BN_SIZE;\n\t}\n#endif\n\tif (a != NULL) {\n\t\ta->used = 1;\n\t\ta->dp[0] = 0;\n\t\ta->alloc = digits;\n\t\ta->sign = RLC_POS;\n\t}\n}\n\nvoid bn_clean(bn_t a) {\n#if ALLOC == DYNAMIC\n\tif (a != NULL) {\n\t\tif (a->dp != NULL) {\n#if OPSYS == WINDOWS && ALIGN > 1\n\t\t\t_aligned_free(a->dp);\n#else\n\t\t\tfree(a->dp);\n#endif\n\t\t\ta->dp = NULL;\n\t\t}\n\t\ta->alloc = 0;\n\t}\n#endif\n\tif (a != NULL) {\n\t\ta->used = 0;\n\t\ta->sign = RLC_POS;\n\t}\n}\n\nvoid bn_grow(bn_t a, int digits) {\n#if ALLOC == DYNAMIC\n\tdig_t *t;\n\n\tif (a->alloc < digits) {\n\t\t/* At least add RLC_BN_SIZE more digits. */\n\t\tdigits += (RLC_BN_SIZE * 2) - (digits % RLC_BN_SIZE);\n\t\tt = (dig_t *)realloc(a->dp, (RLC_DIG / 8) * digits);\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\treturn;\n\t\t}\n\t\ta->dp = t;\n\t\t/* Set the newly allocated digits to zero. */\n\t\ta->alloc = digits;\n\t}\n#elif ALLOC == AUTO\n\tif (digits > RLC_BN_SIZE) {\n\t\tRLC_THROW(ERR_NO_PRECI);\n\t\treturn;\n\t}\n\t(void)a;\n#endif\n}\n\nvoid bn_trim(bn_t a) {\n\tif (a->used <= a->alloc) {\n\t\twhile (a->used > 0 && a->dp[a->used - 1] == 0) {\n\t\t\t--(a->used);\n\t\t}\n\t\t/* Zero can't be negative. */\n\t\tif (a->used <= 0) {\n\t\t\ta->used = 1;\n\t\t\ta->dp[0] = 0;\n\t\t\ta->sign = RLC_POS;\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision exponentiation functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Size of precomputation table.\n */\n#define RLC_TABLE_SIZE\t\t\t64\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if BN_MXP == BASIC || !defined(STRIP)\n\nvoid bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t, u, r;\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\n\t\tbn_mod_pre(u, m);\n\n\t\tl = bn_bits(b);\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_conv(t, a, m);\n#else\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(r, t);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(r, r);\n\t\t\tbn_mod(r, r, m, u);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tbn_mul(r, r, t);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(r, r, m);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, r, m);\n\t\t} else {\n\t\t\tbn_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(r);\n\t}\n}\n\n#endif\n\n#if BN_MXP == SLIDE || !defined(STRIP)\n\nvoid bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tbn_t tab[RLC_TABLE_SIZE], t, u, r;\n\tint i, j, l, w = 1;\n\tuint8_t *win = RLC_ALLOCA(uint8_t, bn_bits(b));\n\n\tif (win == NULL) {\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tRLC_FREE(win);\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tRLC_FREE(win);\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\t/* Initialize table. */\n\tfor (i = 0; i < RLC_TABLE_SIZE; i++) {\n\t\tbn_null(tab[i]);\n\t}\n\n\t/* Find window size. */\n\ti = bn_bits(b);\n\tif (i <= 21) {\n\t\tw = 2;\n\t} else if (i <= 32) {\n\t\tw = 3;\n\t} else if (i <= 128) {\n\t\tw = 4;\n\t} else if (i <= 256) {\n\t\tw = 5;\n\t} else if (i <= 512) {\n\t\tw = 6;\n\t} else {\n\t\tw = 7;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (w - 1)); i++) {\n\t\t\tbn_new(tab[i]);\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\t\tbn_mod_pre(u, m);\n\n#if BN_MOD == MONTY\n\t\tbn_set_dig(r, 1);\n\t\tbn_mod_monty_conv(r, r, m);\n\t\tbn_mod_monty_conv(t, a, m);\n#else /* BN_MOD == BARRT || BN_MOD == RADIX */\n\t\tbn_set_dig(r, 1);\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(tab[0], t);\n\t\tbn_sqr(t, tab[0]);\n\t\tbn_mod(t, t, m, u);\n\t\t/* Create table. */\n\t\tfor (i = 1; i < 1 << (w - 1); i++) {\n\t\t\tbn_mul(tab[i], tab[i - 1], t);\n\t\t\tbn_mod(tab[i], tab[i], m, u);\n\t\t}\n\n\t\tl = bn_bits(b);\n\t\tbn_rec_slw(win, &l, b, w);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tbn_sqr(r, r);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tbn_sqr(r, r);\n\t\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t\t}\n\t\t\t\tbn_mul(r, r, tab[win[i] >> 1]);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\t\tbn_trim(r);\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(r, r, m);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, r, m);\n\t\t} else {\n\t\t\tbn_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (w - 1)); i++) {\n\t\t\tbn_free(tab[i]);\n\t\t}\n\t\tbn_free(u);\n\t\tbn_free(t);\n\t\tbn_free(r);\n\t\tRLC_FREE(win);\n\t}\n}\n\n#endif\n\n#if BN_MXP == MONTY || !defined(STRIP)\n\nvoid bn_mxp_monty(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tbn_t tab[2], u;\n\tdig_t mask;\n\tint i, j, t;\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(tab[0]);\n\tbn_null(tab[1]);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_mod_pre(u, m);\n\n\t\tbn_new(tab[0]);\n\t\tbn_new(tab[1]);\n\n#if BN_MOD == MONTY\n\t\tbn_set_dig(tab[0], 1);\n\t\tbn_mod_monty_conv(tab[0], tab[0], m);\n\t\tbn_mod_monty_conv(tab[1], a, m);\n#else\n\t\tbn_set_dig(tab[0], 1);\n\t\tbn_mod(tab[1], a, m);\n#endif\n\n\t\tbn_grow(tab[0], m->alloc);\n\t\tbn_grow(tab[1], m->alloc);\n\t\tfor (i = bn_bits(b) - 1; i >= 0; i--) {\n\t\t\tj = bn_get_bit(b, i);\n\t\t\tdv_swap_cond(tab[0]->dp, tab[1]->dp, m->alloc, j ^ 1);\n\t\t\tmask = -(j ^ 1);\n\t\t\tt = (tab[0]->used ^ tab[1]->used) & mask;\n\t\t\ttab[0]->used ^= t;\n\t\t\ttab[1]->used ^= t;\n\t\t\tt = (tab[0]->sign ^ tab[1]->sign) & mask;\n\t\t\ttab[0]->sign ^= t;\n\t\t\ttab[1]->sign ^= t;\n\t\t\tbn_mul(tab[0], tab[0], tab[1]);\n\t\t\tbn_mod(tab[0], tab[0], m, u);\n\t\t\tbn_sqr(tab[1], tab[1]);\n\t\t\tbn_mod(tab[1], tab[1], m, u);\n\t\t\tdv_swap_cond(tab[0]->dp, tab[1]->dp, m->alloc, j ^ 1);\n\t\t\tmask = -(j ^ 1);\n\t\t\tt = (tab[0]->used ^ tab[1]->used) & mask;\n\t\t\ttab[0]->used ^= t;\n\t\t\ttab[1]->used ^= t;\n\t\t\tt = (tab[0]->sign ^ tab[1]->sign) & mask;\n\t\t\ttab[0]->sign ^= t;\n\t\t\ttab[1]->sign ^= t;\n\t\t}\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(u, tab[0], m);\n#else\n\t\tbn_copy(u, tab[0]);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, u, m);\n\t\t} else {\n\t\t\tbn_copy(c, u);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(tab[1]);\n\t\tbn_free(tab[0]);\n\t\tbn_free(u);\n\t}\n}\n\n#endif\n\nvoid bn_mxp_crt(bn_t d, const bn_t a, const bn_t b, const bn_t c,\n\t\tconst crt_t crt, int sqr) {\n\tbn_t t, u;\n\n\tbn_null(t);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(u);\n\n\t\tif (!sqr) {\n#if MULTI == OPENMP\n\t\t\tomp_set_num_threads(CORES);\n\t\t\t#pragma omp parallel copyin(core_ctx) firstprivate(crt)\n\t\t\t{\n\t\t\t\t#pragma omp sections\n\t\t\t\t{\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m1 = a^dP mod p. */\n\t\t\t\t\t\tbn_mxp(t, a, b, crt->p);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m2 = a^dQ mod q. */\n\t\t\t\t\t\tbn_mxp(u, a, c, crt->q);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n#if MULTI == OPENMP\n\t\t\tomp_set_num_threads(CORES);\n\t\t\t#pragma omp parallel copyin(core_ctx) firstprivate(crt)\n\t\t\t{\n\t\t\t\t#pragma omp sections\n\t\t\t\t{\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* Compute m_p = L(c^(p-1) mod p^2) * dp mod p. */\n\t\t\t\t\t\tbn_sqr(t, crt->p);\n\t\t\t\t\t\tbn_mxp(t, a, b, t);\n\t\t\t\t\t\tbn_sub_dig(t, t, 1);\n\t\t\t\t\t\tbn_div(t, t, crt->p);\n\t\t\t\t\t\tbn_mul(t, t, crt->dp);\n\t\t\t\t\t\tbn_mod(t, t, crt->p);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* Compute m_q = L(c^(q-1) mod q^2) * dq mod q. */\n\t\t\t\t\t\tbn_sqr(u, crt->q);\n\t\t\t\t\t\tbn_mxp(u, a, c, u);\n\t\t\t\t\t\tbn_sub_dig(u, u, 1);\n\t\t\t\t\t\tbn_div(u, u, crt->q);\n\t\t\t\t\t\tbn_mul(u, u, crt->dq);\n\t\t\t\t\t\tbn_mod(u, u, crt->q);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\t\t/* m1 = m1 - m2 mod p. */\n\t\tbn_sub(d, t, u);\n\t\twhile (bn_sign(d) == RLC_NEG) {\n\t\t\tbn_add(d, d, crt->p);\n\t\t}\n\t\t/* m1 = qInv(m1 - m2) mod p. */\n\t\tbn_mul(d, d, crt->qi);\n\t\tbn_mod(d, d, crt->p);\n\t\t/* m = m2 + m1 * q. */\n\t\tbn_mul(d, d, crt->q);\n\t\tbn_add(d, d, u);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t}\n}\n\nvoid bn_mxp_dig(bn_t c, const bn_t a, dig_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t, u, r;\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (b == 0) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\n\t\tbn_mod_pre(u, m);\n\n\t\tl = util_bits_dig(b);\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_conv(t, a, m);\n#else\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(r, t);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(r, r);\n\t\t\tbn_mod(r, r, m, u);\n\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\tbn_mul(r, r, t);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(c, r, m);\n#else\n\t\tbn_copy(c, r);\n#endif\n\t\t/* Exponent is unsigned, so no need to invert if negative. */\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(r);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime number generation and testing functions.\n *\n * Strong prime generation is based on Gordon's Algorithm, taken from Handbook\n * of Applied Cryptography.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Number of trial division tests.\n */\n#define BASIC_TESTS\t((int)(sizeof(primes)/sizeof(dig_t)))\n\n/**\n * Small prime numbers table.\n */\nstatic const dig_t primes[] = {\n\t0x0002, 0x0003, 0x0005, 0x0007, 0x000B, 0x000D, 0x0011, 0x0013,\n\t0x0017, 0x001D, 0x001F, 0x0025, 0x0029, 0x002B, 0x002F, 0x0035,\n\t0x003B, 0x003D, 0x0043, 0x0047, 0x0049, 0x004F, 0x0053, 0x0059,\n\t0x0061, 0x0065, 0x0067, 0x006B, 0x006D, 0x0071, 0x007F, 0x0083,\n\t0x0089, 0x008B, 0x0095, 0x0097, 0x009D, 0x00A3, 0x00A7, 0x00AD,\n\t0x00B3, 0x00B5, 0x00BF, 0x00C1, 0x00C5, 0x00C7, 0x00D3, 0x00DF,\n#if WSIZE > 8\n\t0x00E3, 0x00E5, 0x00E9, 0x00EF, 0x00F1, 0x00FB, 0x0101, 0x0107,\n\t0x010D, 0x010F, 0x0115, 0x0119, 0x011B, 0x0125, 0x0133, 0x0137,\n\n\t0x0139, 0x013D, 0x014B, 0x0151, 0x015B, 0x015D, 0x0161, 0x0167,\n\t0x016F, 0x0175, 0x017B, 0x017F, 0x0185, 0x018D, 0x0191, 0x0199,\n\t0x01A3, 0x01A5, 0x01AF, 0x01B1, 0x01B7, 0x01BB, 0x01C1, 0x01C9,\n\t0x01CD, 0x01CF, 0x01D3, 0x01DF, 0x01E7, 0x01EB, 0x01F3, 0x01F7,\n\t0x01FD, 0x0209, 0x020B, 0x021D, 0x0223, 0x022D, 0x0233, 0x0239,\n\t0x023B, 0x0241, 0x024B, 0x0251, 0x0257, 0x0259, 0x025F, 0x0265,\n\t0x0269, 0x026B, 0x0277, 0x0281, 0x0283, 0x0287, 0x028D, 0x0293,\n\t0x0295, 0x02A1, 0x02A5, 0x02AB, 0x02B3, 0x02BD, 0x02C5, 0x02CF,\n\n\t0x02D7, 0x02DD, 0x02E3, 0x02E7, 0x02EF, 0x02F5, 0x02F9, 0x0301,\n\t0x0305, 0x0313, 0x031D, 0x0329, 0x032B, 0x0335, 0x0337, 0x033B,\n\t0x033D, 0x0347, 0x0355, 0x0359, 0x035B, 0x035F, 0x036D, 0x0371,\n\t0x0373, 0x0377, 0x038B, 0x038F, 0x0397, 0x03A1, 0x03A9, 0x03AD,\n\t0x03B3, 0x03B9, 0x03C7, 0x03CB, 0x03D1, 0x03D7, 0x03DF, 0x03E5,\n\t0x03F1, 0x03F5, 0x03FB, 0x03FD, 0x0407, 0x0409, 0x040F, 0x0419,\n\t0x041B, 0x0425, 0x0427, 0x042D, 0x043F, 0x0443, 0x0445, 0x0449,\n\t0x044F, 0x0455, 0x045D, 0x0463, 0x0469, 0x047F, 0x0481, 0x048B,\n\n\t0x0493, 0x049D, 0x04A3, 0x04A9, 0x04B1, 0x04BD, 0x04C1, 0x04C7,\n\t0x04CD, 0x04CF, 0x04D5, 0x04E1, 0x04EB, 0x04FD, 0x04FF, 0x0503,\n\t0x0509, 0x050B, 0x0511, 0x0515, 0x0517, 0x051B, 0x0527, 0x0529,\n\t0x052F, 0x0551, 0x0557, 0x055D, 0x0565, 0x0577, 0x0581, 0x058F,\n\t0x0593, 0x0595, 0x0599, 0x059F, 0x05A7, 0x05AB, 0x05AD, 0x05B3,\n\t0x05BF, 0x05C9, 0x05CB, 0x05CF, 0x05D1, 0x05D5, 0x05DB, 0x05E7,\n\t0x05F3, 0x05FB, 0x0607, 0x060D, 0x0611, 0x0617, 0x061F, 0x0623,\n\t0x062B, 0x062F, 0x063D, 0x0641, 0x0647, 0x0649, 0x064D, 0x0653,\n\n\t0x0655, 0x065B, 0x0665, 0x0679, 0x067F, 0x0683, 0x0685, 0x069D,\n\t0x06A1, 0x06A3, 0x06AD, 0x06B9, 0x06BB, 0x06C5, 0x06CD, 0x06D3,\n\t0x06D9, 0x06DF, 0x06F1, 0x06F7, 0x06FB, 0x06FD, 0x0709, 0x0713,\n\t0x071F, 0x0727, 0x0737, 0x0745, 0x074B, 0x074F, 0x0751, 0x0755,\n\t0x0757, 0x0761, 0x076D, 0x0773, 0x0779, 0x078B, 0x078D, 0x079D,\n\t0x079F, 0x07B5, 0x07BB, 0x07C3, 0x07C9, 0x07CD, 0x07CF, 0x07D3,\n\t0x07DB, 0x07E1, 0x07EB, 0x07ED, 0x07F7, 0x0805, 0x080F, 0x0815,\n\t0x0821, 0x0823, 0x0827, 0x0829, 0x0833, 0x083F, 0x0841, 0x0851,\n\n\t0x0853, 0x0859, 0x085D, 0x085F, 0x0869, 0x0871, 0x0883, 0x089B,\n\t0x089F, 0x08A5, 0x08AD, 0x08BD, 0x08BF, 0x08C3, 0x08CB, 0x08DB,\n\t0x08DD, 0x08E1, 0x08E9, 0x08EF, 0x08F5, 0x08F9, 0x0905, 0x0907,\n\t0x091D, 0x0923, 0x0925, 0x092B, 0x092F, 0x0935, 0x0943, 0x0949,\n\t0x094D, 0x094F, 0x0955, 0x0959, 0x095F, 0x096B, 0x0971, 0x0977,\n\t0x0985, 0x0989, 0x098F, 0x099B, 0x09A3, 0x09A9, 0x09AD, 0x09C7,\n\t0x09D9, 0x09E3, 0x09EB, 0x09EF, 0x09F5, 0x09F7, 0x09FD, 0x0A13,\n\t0x0A1F, 0x0A21, 0x0A31, 0x0A39, 0x0A3D, 0x0A49, 0x0A57, 0x0A61,\n\n\t0x0A63, 0x0A67, 0x0A6F, 0x0A75, 0x0A7B, 0x0A7F, 0x0A81, 0x0A85,\n\t0x0A8B, 0x0A93, 0x0A97, 0x0A99, 0x0A9F, 0x0AA9, 0x0AAB, 0x0AB5,\n\t0x0ABD, 0x0AC1, 0x0ACF, 0x0AD9, 0x0AE5, 0x0AE7, 0x0AED, 0x0AF1,\n\t0x0AF3, 0x0B03, 0x0B11, 0x0B15, 0x0B1B, 0x0B23, 0x0B29, 0x0B2D,\n\t0x0B3F, 0x0B47, 0x0B51, 0x0B57, 0x0B5D, 0x0B65, 0x0B6F, 0x0B7B,\n\t0x0B89, 0x0B8D, 0x0B93, 0x0B99, 0x0B9B, 0x0BB7, 0x0BB9, 0x0BC3,\n\t0x0BCB, 0x0BCF, 0x0BDD, 0x0BE1, 0x0BE9, 0x0BF5, 0x0BFB, 0x0C07,\n\t0x0C0B, 0x0C11, 0x0C25, 0x0C2F, 0x0C31, 0x0C41, 0x0C5B, 0x0C5F,\n\n\t0x0C61, 0x0C6D, 0x0C73, 0x0C77, 0x0C83, 0x0C89, 0x0C91, 0x0C95,\n\t0x0C9D, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBB, 0x0CC7, 0x0CE3, 0x0CE5,\n\t0x0CEB, 0x0CF1, 0x0CF7, 0x0CFB, 0x0D01, 0x0D03, 0x0D0F, 0x0D13,\n\t0x0D1F, 0x0D21, 0x0D2B, 0x0D2D, 0x0D3D, 0x0D3F, 0x0D4F, 0x0D55,\n\t0x0D69, 0x0D79, 0x0D81, 0x0D85, 0x0D87, 0x0D8B, 0x0D8D, 0x0DA3,\n\t0x0DAB, 0x0DB7, 0x0DBD, 0x0DC7, 0x0DC9, 0x0DCD, 0x0DD3, 0x0DD5,\n\t0x0DDB, 0x0DE5, 0x0DE7, 0x0DF3, 0x0DFD, 0x0DFF, 0x0E09, 0x0E17,\n\t0x0E1D, 0x0E21, 0x0E27, 0x0E2F, 0x0E35, 0x0E3B, 0x0E4B, 0x0E57,\n#endif\n};\n\n#if BN_MOD == PMERS\n\n/**\n * Computes c = a ^ b mod m.\n *\n * @param c\t\t\t\t- the result.\n * @param a\t\t\t\t- the basis.\n * @param b\t\t\t\t- the exponent.\n * @param m\t\t\t\t- the modulus.\n */\nstatic void bn_exp(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tl = bn_bits(b);\n\n\t\tbn_copy(t, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(t, t);\n\t\t\tbn_mod(t, t, m);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tbn_mul(t, t, a);\n\t\t\t\tbn_mod(t, t, m);\n\t\t\t}\n\t\t}\n\n\t\tbn_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint bn_is_prime(const bn_t a) {\n\tint result;\n\n\tresult = 0;\n\tif (!bn_is_prime_basic(a)) {\n\t\tgoto end;\n\t}\n\n\tif (!bn_is_prime_rabin(a)) {\n\t\tgoto end;\n\t}\n\n\tresult = 1;\n  end:\n\treturn result;\n}\n\nint bn_is_prime_basic(const bn_t a) {\n\tdig_t t;\n\tint i, result;\n\n\tresult = 1;\n\n\tif (bn_cmp_dig(a, 1) == RLC_EQ) {\n\t\treturn 0;\n\t}\n\n\t/* Trial division. */\n\tfor (i = 0; i < BASIC_TESTS; i++) {\n\t\tbn_mod_dig(&t, a, primes[i]);\n\t\tif (t == 0 && bn_cmp_dig(a, primes[i]) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nint bn_is_prime_rabin(const bn_t a) {\n\tbn_t t, n1, y, r;\n\tint i, s, j, result, b, tests = 0, cmp2;\n\n\ttests = 0;\n\tresult = 1;\n\n\tbn_null(t);\n\tbn_null(n1);\n\tbn_null(y);\n\tbn_null(r);\n\n\tcmp2 = bn_cmp_dig(a, 2);\n\tif (cmp2 == RLC_LT) {\n\t\t/* Numbers 1 or smaller are not prime */\n\t\treturn 0;\n\t}\n\tif (cmp2 == RLC_EQ) {\n\t\t/* The number 2 is prime */\n\t\treturn 1;\n\t}\n\n\tif (bn_is_even(a) == 1) {\n\t\t/* Even numbers > 2 are not prime */\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\t/*\n\t\t * These values are taken from Table 4.4 inside Handbook of Applied\n\t\t * Cryptography.\n\t\t */\n\t\tb = bn_bits(a);\n\t\tif (b >= 1300) {\n\t\t\ttests = 2;\n\t\t} else if (b >= 850) {\n\t\t\ttests = 3;\n\t\t} else if (b >= 650) {\n\t\t\ttests = 4;\n\t\t} else if (b >= 550) {\n\t\t\ttests = 5;\n\t\t} else if (b >= 450) {\n\t\t\ttests = 6;\n\t\t} else if (b >= 400) {\n\t\t\ttests = 7;\n\t\t} else if (b >= 350) {\n\t\t\ttests = 8;\n\t\t} else if (b >= 300) {\n\t\t\ttests = 9;\n\t\t} else if (b >= 250) {\n\t\t\ttests = 12;\n\t\t} else if (b >= 200) {\n\t\t\ttests = 15;\n\t\t} else if (b >= 150) {\n\t\t\ttests = 18;\n\t\t} else {\n\t\t\ttests = 27;\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(n1);\n\t\tbn_new(y);\n\t\tbn_new(r);\n\n\t\t/* r = (n - 1)/2^s. */\n\t\tbn_sub_dig(n1, a, 1);\n\t\tbn_copy(r, n1);\n\t\ts = 0;\n\t\twhile (bn_is_even(r)) {\n\t\t\ts++;\n\t\t\tbn_rsh(r, r, 1);\n\t\t}\n\n\t\tfor (i = 0; i < tests; i++) {\n\t\t\t/* Fix the basis as the first few primes. */\n\t\t\tbn_set_dig(t, primes[i]);\n\n\t\t\t/* Ensure t <= n - 2 as per HAC */\n\t\t\tif( bn_cmp(t, n1) != RLC_LT ) {\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* y = b^r mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(y, t, r, a);\n#else\n\t\t\tbn_exp(y, t, r, a);\n#endif\n\n\t\t\tif (bn_cmp_dig(y, 1) != RLC_EQ && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\tj = 1;\n\t\t\t\twhile ((j <= (s - 1)) && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tbn_sqr(y, y);\n\t\t\t\t\tbn_mod(y, y, a);\n\n\t\t\t\t\t/* If y == 1 then composite. */\n\t\t\t\t\tif (bn_cmp_dig(y, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++j;\n\t\t\t\t}\n\n\t\t\t\t/* If y != n1 then composite. */\n\t\t\t\tif (bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(y);\n\t\tbn_free(n1);\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\nint bn_is_prime_solov(const bn_t a) {\n\tbn_t t0, t1, t2;\n\tint i, result;\n\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\n\tresult = 1;\n\n\tRLC_TRY {\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\t/* Generate t0, 2 <= t0, <= a - 2. */\n\t\t\tdo {\n\t\t\t\tbn_rand(t0, RLC_POS, bn_bits(a));\n\t\t\t\tbn_mod(t0, t0, a);\n\t\t\t} while (bn_cmp_dig(t0, 2) == RLC_LT);\n\t\t\t/* t2 = a - 1. */\n\t\t\tbn_copy(t2, a);\n\t\t\tbn_sub_dig(t2, t2, 1);\n\t\t\t/* t1 = (a - 1)/2. */\n\t\t\tbn_rsh(t1, t2, 1);\n\t\t\t/* t1 = t0^(a - 1)/2 mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t1, t0, t1, a);\n#else\n\t\t\tbn_exp(t1, t0, t1, a);\n#endif\n\t\t\t/* If t1 != 1 and t1 != n - 1 return 0 */\n\t\t\tif (bn_cmp_dig(t1, 1) != RLC_EQ && bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Lend result here, but restore afterwards, for t2 = (t0|a). */\n\t\t\tresult = bn_smb_jac(t0, a);\n\t\t\tbn_set_dig(t2, (result < 0 ? -result : result));\n\t\t\tif (result < 0) {\n\t\t\t\tbn_neg(t2, t2);\n\t\t\t}\n\t\t\tresult = 1;\n\t\t\t/* If t1 != t2 (mod a) return 0. */\n\t\t\tbn_mod(t1, t1, a);\n\t\t\tbn_mod(t2, t2, a);\n\t\t\tif (bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t}\n\treturn result;\n}\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\nvoid bn_gen_prime_basic(bn_t a, int bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\tif (bn_is_prime(a)) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\nvoid bn_gen_prime_safep(bn_t a, int bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\t/* Check if (a - 1)/2 is prime. */\n\t\tbn_sub_dig(a, a, 1);\n\t\tbn_rsh(a, a, 1);\n\t\tif (bn_is_prime(a)) {\n\t\t\t/* Restore a. */\n\t\t\tbn_lsh(a, a, 1);\n\t\t\tbn_add_dig(a, a, 1);\n\t\t\tif (bn_is_prime(a)) {\n\t\t\t\t/* Should be prime now. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\nvoid bn_gen_prime_stron(bn_t a, int bits) {\n\tdig_t i, j;\n\tint found, k;\n\tbn_t r, s, t;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tbn_new(t);\n\n\t\tdo {\n\t\t\tdo {\n\t\t\t\t/* Generate two large primes r and s. */\n\t\t\t\tbn_rand(s, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t\tbn_rand(t, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t} while (!bn_is_prime(s) || !bn_is_prime(t));\n\t\t\tfound = 1;\n\t\t\tbn_rand(a, RLC_POS, bits / 2 - bn_bits(t) - 1);\n\t\t\ti = a->dp[0];\n\t\t\tbn_dbl(t, t);\n\t\t\tdo {\n\t\t\t\t/* Find first prime r = 2 * i * t + 1. */\n\t\t\t\tbn_mul_dig(r, t, i);\n\t\t\t\tbn_add_dig(r, r, 1);\n\t\t\t\ti++;\n\t\t\t\tif (bn_bits(r) > bits / 2 - 1) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(r));\n\t\t\tif (found == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Compute t = 2 * (s^(r-2) mod r) * s - 1. */\n\t\t\tbn_sub_dig(t, r, 2);\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t, s, t, r);\n#else\n\t\t\tbn_exp(t, s, t, r);\n#endif\n\n\t\t\tbn_mul(t, t, s);\n\t\t\tbn_dbl(t, t);\n\t\t\tbn_sub_dig(t, t, 1);\n\n\t\t\tk = bits - bn_bits(r);\n\t\t\tk -= bn_bits(s);\n\t\t\tbn_rand(a, RLC_POS, k);\n\t\t\tj = a->dp[0];\n\t\t\tdo {\n\t\t\t\t/* Find first prime a = t + 2 * j * r * s. */\n\t\t\t\tbn_mul(a, r, s);\n\t\t\t\tbn_mul_dig(a, a, j);\n\t\t\t\tbn_dbl(a, a);\n\t\t\t\tbn_add(a, a, t);\n\t\t\t\tj++;\n\t\t\t\tif (bn_bits(a) > bits) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(a));\n\t\t} while (found == 0 && bn_bits(a) != bits);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(s);\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\nint bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;\n    }\n\n    bn_null(t);\n\n    RLC_TRY {\n        bn_new(t);\n\t\tbn_gen_prime(a, abits);\n        do {\n            bn_rand(t, RLC_POS, bbits - bn_bits(a));\n            do {\n                bn_mul(b, a, t);\n                bn_add_dig(b, b, 1);\n                bn_add_dig(t, t, 1);\n            } while(! bn_is_prime(b));\n        } while (bn_bits(b) != bbits);\n    }\n    RLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n    }\n    RLC_FINALLY {\n        bn_free(t);\n    }\n\n    return result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision integer recoding functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Returns a maximum of eight contiguous bits from a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] from\t\t\t- the first bit position.\n * @param[in] to\t\t\t- the last bit position, inclusive.\n * @return the bits in the chosen positions.\n */\nstatic char get_bits(const bn_t a, int from, int to) {\n\tint f, t;\n\tdig_t mf, mt;\n\n\tRLC_RIP(from, f, from);\n\tRLC_RIP(to, t, to);\n\n\tif (f == t) {\n\t\t/* Same digit. */\n\n\t\tmf = RLC_MASK(from);\n\t\tif (to + 1 >= RLC_DIG) {\n\t\t\tmt = RLC_DMASK;\n\t\t} else {\n\t\t\tmt = RLC_MASK(to + 1);\n\t\t}\n\n\t\tmf = mf ^ mt;\n\n\t\treturn ((a->dp[f] & (mf)) >> from);\n\t} else {\n\t\tmf = RLC_MASK(RLC_DIG - from) << from;\n\t\tmt = RLC_MASK(to + 1);\n\n\t\treturn ((a->dp[f] & mf) >> from) |\n\t\t\t\t((a->dp[t] & mt) << (RLC_DIG - from));\n\t}\n}\n\n/**\n * Constant C for the partial reduction modulo (t^m - 1)/(t - 1).\n */\n#define MOD_C\t\t8\n\n/**\n * Constant 2^C.\n */\n#define MOD_2TC\t\t(1 << MOD_C)\n\n/**\n * Mask to calculate reduction modulo 2^C.\n */\n#define MOD_CMASK\t(MOD_2TC - 1)\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_rec_win(uint8_t *win, int *len, const bn_t k, int w) {\n\tint i, j, l;\n\n\tl = bn_bits(k);\n\n\tif (*len < RLC_CEIL(l, w)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tmemset(win, 0, *len);\n\n\tj = 0;\n\tfor (i = 0; i < l - w; i += w) {\n\t\twin[j++] = get_bits(k, i, i + w - 1);\n\t}\n\twin[j++] = get_bits(k, i, bn_bits(k) - 1);\n\t*len = j;\n}\n\nvoid bn_rec_slw(uint8_t *win, int *len, const bn_t k, int w) {\n\tint i, j, l, s;\n\n\tl = bn_bits(k);\n\n\tif (*len < l) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tmemset(win, 0, *len);\n\n\ti = l - 1;\n\tj = 0;\n\twhile (i >= 0) {\n\t\tif (!bn_get_bit(k, i)) {\n\t\t\ti--;\n\t\t\twin[j++] = 0;\n\t\t} else {\n\t\t\ts = RLC_MAX(i - w + 1, 0);\n\t\t\twhile (!bn_get_bit(k, s)) {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\twin[j++] = get_bits(k, s, i);\n\t\t\ti = s - 1;\n\t\t}\n\t}\n\t*len = j;\n}\n\nvoid bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_abs(t, k);\n\n\t\tmask = RLC_MASK(w);\n\t\tl = (1 << w);\n\n\t\tmemset(naf, 0, *len);\n\n\t\ti = 0;\n\t\tif (w == 2) {\n\t\t\twhile (!bn_is_zero(t)) {\n\t\t\t\tif (!bn_is_even(t)) {\n\t\t\t\t\tbn_get_dig(&t0, t);\n\t\t\t\t\tu_i = 2 - (t0 & mask);\n\t\t\t\t\tif (u_i < 0) {\n\t\t\t\t\t\tbn_add_dig(t, t, -u_i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(t, t, u_i);\n\t\t\t\t\t}\n\t\t\t\t\t*naf = u_i;\n\t\t\t\t} else {\n\t\t\t\t\t*naf = 0;\n\t\t\t\t}\n\t\t\t\tbn_hlv(t, t);\n\t\t\t\ti++;\n\t\t\t\tnaf++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (!bn_is_zero(t)) {\n\t\t\t\tif (!bn_is_even(t)) {\n\t\t\t\t\tbn_get_dig(&t0, t);\n\t\t\t\t\tu_i = t0 & mask;\n\t\t\t\t\tif (u_i > l / 2) {\n\t\t\t\t\t\tu_i = (int8_t)(u_i - l);\n\t\t\t\t\t}\n\t\t\t\t\tif (u_i < 0) {\n\t\t\t\t\t\tbn_add_dig(t, t, -u_i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(t, t, u_i);\n\t\t\t\t\t}\n\t\t\t\t\t*naf = u_i;\n\t\t\t\t} else {\n\t\t\t\t\t*naf = 0;\n\t\t\t\t}\n\t\t\t\tbn_hlv(t, t);\n\t\t\t\ti++;\n\t\t\t\tnaf++;\n\t\t\t}\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u, int w) {\n\tif (u == -1) {\n\t\tswitch (w) {\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\t*t = 2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t*t = 10;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\t\t*t = 26;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\t\t*t = 90;\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (w) {\n\t\t\tcase 2:\n\t\t\t\t*t = 2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\t\t*t = 6;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\t\t*t = 38;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\t*t = 166;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tbeta[0] = 1;\n\tgama[0] = 0;\n\n\tif (w >= 3) {\n\t\tbeta[1] = 1;\n\t\tgama[1] = (int8_t)-u;\n\t}\n\n\tif (w >= 4) {\n\t\tbeta[1] = -3;\n\t\tbeta[2] = -1;\n\t\tbeta[3] = 1;\n\t\tgama[1] = gama[2] = gama[3] = (int8_t)u;\n\t}\n\n\tif (w >= 5) {\n\t\tbeta[4] = -3;\n\t\tbeta[5] = -1;\n\t\tbeta[6] = beta[7] = 1;\n\t\tgama[4] = gama[5] = gama[6] = (int8_t)(2 * u);\n\t\tgama[7] = (int8_t)(-3 * u);\n\t}\n\n\tif (w >= 6) {\n\t\tbeta[1] = beta[8] = beta[14] = 3;\n\t\tbeta[2] = beta[9] = beta[15] = 5;\n\t\tbeta[3] = -5;\n\t\tbeta[4] = beta[10] = beta[11] = -3;\n\t\tbeta[5] = beta[12] = -1;\n\t\tbeta[6] = beta[7] = beta[13] = 1;\n\t\tgama[1] = gama[2] = 0;\n\t\tgama[3] = gama[4] = gama[5] = gama[6] = (int8_t)(2 * u);\n\t\tgama[7] = gama[8] = gama[9] = (int8_t)(-3 * u);\n\t\tgama[10] = (int8_t)(4 * u);\n\t\tgama[11] = gama[12] = gama[13] = (int8_t)(-u);\n\t\tgama[14] = gama[15] = (int8_t)(-u);\n\t}\n\n\tif (w >= 7) {\n\t\tbeta[3] = beta[22] = beta[29] = 7;\n\t\tbeta[4] = beta[16] = beta[23] = -5;\n\t\tbeta[5] = beta[10] = beta[17] = beta[24] = -3;\n\t\tbeta[6] = beta[11] = beta[18] = beta[25] = beta[30] = -1;\n\t\tbeta[7] = beta[12] = beta[14] = beta[19] = beta[26] = beta[31] = 1;\n\t\tbeta[8] = beta[13] = beta[20] = beta[27] = 3;\n\t\tbeta[9] = beta[21] = beta[28] = 5;\n\t\tbeta[15] = -7;\n\t\tgama[3] = 0;\n\t\tgama[4] = gama[5] = gama[6] = (int8_t)(-3 * u);\n\t\tgama[11] = gama[12] = gama[13] = (int8_t)(4 * u);\n\t\tgama[14] = (int8_t)(-6 * u);\n\t\tgama[15] = gama[16] = gama[17] = gama[18] = (int8_t)u;\n\t\tgama[19] = gama[20] = gama[21] = gama[22] = (int8_t)u;\n\t\tgama[23] = gama[24] = gama[25] = gama[26] = (int8_t)(-2 * u);\n\t\tgama[27] = gama[28] = gama[29] = (int8_t)(-2 * u);\n\t\tgama[30] = gama[31] = (int8_t)(5 * u);\n\t}\n\n\tif (w == 8) {\n\t\tbeta[10] = beta[17] = beta[48] = beta[55] = beta[62] = 7;\n\t\tbeta[11] = beta[18] = beta[49] = beta[56] = beta[63] = 9;\n\t\tbeta[12] = beta[22] = beta[29] = -3;\n\t\tbeta[36] = beta[43] = beta[50] = -3;\n\t\tbeta[13] = beta[23] = beta[30] = beta[37] = -1;\n\t\tbeta[44] = beta[51] = beta[58] = -1;\n\t\tbeta[14] = beta[24] = beta[31] = beta[38] = 1;\n\t\tbeta[45] = beta[52] = beta[59] = 1;\n\t\tbeta[15] = beta[32] = beta[39] = beta[46] = beta[53] = beta[60] = 3;\n\t\tbeta[16] = beta[40] = beta[47] = beta[54] = beta[61] = 5;\n\t\tbeta[19] = beta[57] = 11;\n\t\tbeta[20] = beta[27] = beta[34] = beta[41] = -7;\n\t\tbeta[21] = beta[28] = beta[35] = beta[42] = -5;\n\t\tbeta[25] = -11;\n\t\tbeta[26] = beta[33] = -9;\n\t\tgama[10] = gama[11] = (int8_t)(-3 * u);\n\t\tgama[12] = gama[13] = gama[14] = gama[15] = (int8_t)(-6 * u);\n\t\tgama[16] = gama[17] = gama[18] = gama[19] = (int8_t)(-6 * u);\n\t\tgama[20] = gama[21] = gama[22] = (int8_t)(8 * u);\n\t\tgama[23] = gama[24] = (int8_t)(8 * u);\n\t\tgama[25] = gama[26] = gama[27] = gama[28] = (int8_t)(5 * u);\n\t\tgama[29] = gama[30] = gama[31] = gama[32] = (int8_t)(5 * u);\n\t\tgama[33] = gama[34] = gama[35] = gama[36] = (int8_t)(2 * u);\n\t\tgama[37] = gama[38] = gama[39] = gama[40] = (int8_t)(2 * u);\n\t\tgama[41] = gama[42] = gama[43] = gama[44] = (int8_t)(-1 * u);\n\t\tgama[45] = gama[46] = gama[47] = gama[48] = (int8_t)(-1 * u);\n\t\tgama[49] = (int8_t)(-1 * u);\n\t\tgama[50] = gama[51] = gama[52] = gama[53] = (int8_t)(-4 * u);\n\t\tgama[54] = gama[55] = gama[56] = gama[57] = (int8_t)(-4 * u);\n\t\tgama[58] = gama[59] = gama[60] = (int8_t)(-7 * u);\n\t\tgama[61] = gama[62] = gama[63] = (int8_t)(-7 * u);\n\t}\n}\n\nvoid bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, int m) {\n\tbn_t t, t0, t1, t2, t3;\n\n\tbn_null(t);\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\tbn_null(t3);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\t\tbn_new(t3);\n\n\t\t/* (a0, a1) = (1, 0). */\n\t\tbn_set_dig(t0, 1);\n\t\tbn_zero(t1);\n\t\t/* (b0, b1) = (0, 0). */\n\t\tbn_zero(t2);\n\t\tbn_zero(t3);\n\t\t/* (r0, r1) = (k, 0). */\n\t\tbn_abs(r0, k);\n\t\tbn_zero(r1);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!bn_is_even(r0)) {\n\t\t\t\t/* r0 = r0 - 1. */\n\t\t\t\tbn_sub_dig(r0, r0, 1);\n\t\t\t\t/* (b0, b1) = (b0 + a0, b1 + a1). */\n\t\t\t\tbn_add(t2, t2, t0);\n\t\t\t\tbn_add(t3, t3, t1);\n\t\t\t}\n\n\t\t\tbn_hlv(t, r0);\n\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\tif (u == -1) {\n\t\t\t\tbn_sub(r0, r1, t);\n\t\t\t} else {\n\t\t\t\tbn_add(r0, r1, t);\n\t\t\t}\n\t\t\t/* r1 = - r0 / 2. */\n\t\t\tbn_neg(r1, t);\n\n\t\t\tbn_dbl(t, t1);\n\t\t\t/* a1 = a0 + mu * a1. */\n\t\t\tif (u == -1) {\n\t\t\t\tbn_sub(t1, t0, t1);\n\t\t\t} else {\n\t\t\t\tbn_add(t1, t0, t1);\n\t\t\t}\n\t\t\t/* a0 = - 2 * a1. */\n\t\t\tbn_neg(t0, t);\n\t\t}\n\n\t\t/*r 0 = r0 + b0, r1 = r1 + b1. */\n\t\tbn_add(r0, r0, t2);\n\t\tbn_add(r1, r1, t3);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t\tbn_free(t3);\n\t}\n}\n\nvoid bn_rec_tnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {\n\tint i, l;\n\tbn_t tmp, r0, r1;\n\tint8_t beta[64], gama[64];\n\tuint8_t t_w;\n\tdig_t t0, t1, mask;\n\tint s, t, u_i;\n\n\tbn_null(r0);\n\tbn_null(r1);\n\tbn_null(tmp);\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r0);\n\t\tbn_new(r1);\n\t\tbn_new(tmp);\n\n\t\tmemset(tnaf, 0, *len);\n\n\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\tbn_abs(tmp, k);\n\t\tbn_rec_tnaf_mod(r0, r1, tmp, u, m);\n\n\t\tmask = RLC_MASK(w);\n\t\tl = 1 << w;\n\n\t\ti = 0;\n\t\twhile (!bn_is_zero(r0) || !bn_is_zero(r1)) {\n\t\t\twhile ((r0->dp[0] & 1) == 0) {\n\t\t\t\ttnaf[i++] = 0;\n\t\t\t\t/* tmp = r0. */\n\t\t\t\tbn_hlv(tmp, r0);\n\t\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\t\tif (u == -1) {\n\t\t\t\t\tbn_sub(r0, r1, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add(r0, r1, tmp);\n\t\t\t\t}\n\t\t\t\t/* r1 = - r0 / 2. */\n\t\t\t\tbn_copy(r1, tmp);\n\t\t\t\tr1->sign = tmp->sign ^ 1;\n\t\t\t}\n\t\t\t/* If r0 is odd. */\n\t\t\tif (w == 2) {\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = l - t0;\n\t\t\t\t}\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = l - t1;\n\t\t\t\t}\n\t\t\t\tu_i = 2 - ((t0 - 2 * t1) & mask);\n\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tbn_add_dig(r0, r0, -u_i);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(r0, r0, u_i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* t0 = r0 mod_s 2^w. */\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = l - t0;\n\t\t\t\t}\n\t\t\t\t/* t1 = r1 mod_s 2^w. */\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = l - t1;\n\t\t\t\t}\n\t\t\t\t/* u = r0 + r1 * (t_w) mod_s 2^w. */\n\t\t\t\tu_i = (t0 + t_w * t1) & mask;\n\n\t\t\t\tif (u_i >= (l / 2)) {\n\t\t\t\t\t/* If u < 0, s = -1 and u = -u. */\n\t\t\t\t\tu_i = (int8_t)(u_i - l);\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(-u_i >> 1);\n\t\t\t\t\tt = -beta[u_i];\n\t\t\t\t\ts = -gama[u_i];\n\t\t\t\t} else {\n\t\t\t\t\t/* If u > 0, s = 1. */\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(u_i >> 1);\n\t\t\t\t\tt = beta[u_i];\n\t\t\t\t\ts = gama[u_i];\n\t\t\t\t}\n\t\t\t\t/* r0 = r0 - s * beta_u. */\n\t\t\t\tif (t > 0) {\n\t\t\t\t\tbn_sub_dig(r0, r0, t);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r0, r0, -t);\n\t\t\t\t}\n\t\t\t\t/* r1 = r1 - s * gama_u. */\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tbn_sub_dig(r1, r1, s);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r1, r1, -s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* tmp = r0. */\n\t\t\tbn_hlv(tmp, r0);\n\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\tif (u == -1) {\n\t\t\t\tbn_sub(r0, r1, tmp);\n\t\t\t} else {\n\t\t\t\tbn_add(r0, r1, tmp);\n\t\t\t}\n\t\t\t/* r1 = - r0 / 2. */\n\t\t\tbn_copy(r1, tmp);\n\t\t\tr1->sign = tmp->sign ^ 1;\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r0);\n\t\tbn_free(r1);\n\t\tbn_free(tmp);\n\t}\n}\n\nvoid bn_rec_rtnaf(int8_t *tnaf, int *len, const bn_t k, int8_t u, int m, int w) {\n\tint i, l;\n\tbn_t tmp, r0, r1;\n\tint8_t beta[64], gama[64];\n\tuint8_t t_w;\n\tdig_t t0, t1, mask;\n\tint s, t, u_i;\n\n\tbn_null(r0);\n\tbn_null(r1);\n\tbn_null(tmp);\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r0);\n\t\tbn_new(r1);\n\t\tbn_new(tmp);\n\n\t\tmemset(tnaf, 0, *len);\n\n\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\tbn_abs(tmp, k);\n\t\tbn_rec_tnaf_mod(r0, r1, tmp, u, m);\n\t\tmask = RLC_MASK(w);\n\t\tl = RLC_CEIL(m + 2, (w - 1));\n\n\t\ti = 0;\n\t\twhile (i < l) {\n\t\t\t/* If r0 is odd. */\n\t\t\tif (w == 2) {\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = (1 << w) - t0;\n\t\t\t\t}\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = (1 << w) - t1;\n\t\t\t\t}\n\t\t\t\tu_i = ((t0 - 2 * t1) & mask) - 2;\n\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tbn_add_dig(r0, r0, -u_i);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(r0, r0, u_i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* t0 = r0 mod_s 2^w. */\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = (1 << w) - t0;\n\t\t\t\t}\n\t\t\t\t/* t1 = r1 mod_s 2^w. */\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = (1 << w) - t1;\n\t\t\t\t}\n\t\t\t\t/* u = r0 + r1 * (t_w) mod_s 2^w. */\n\t\t\t\tu_i = ((t0 + t_w * t1) & mask) - (1 << (w - 1));\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\t/* If u < 0, s = -1 and u = -u. */\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(-u_i >> 1);\n\t\t\t\t\tt = -beta[u_i];\n\t\t\t\t\ts = -gama[u_i];\n\t\t\t\t} else {\n\t\t\t\t\t/* If u > 0, s = 1. */\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(u_i >> 1);\n\t\t\t\t\tt = beta[u_i];\n\t\t\t\t\ts = gama[u_i];\n\t\t\t\t}\n\t\t\t\t/* r0 = r0 - s * beta_u. */\n\t\t\t\tif (t > 0) {\n\t\t\t\t\tbn_sub_dig(r0, r0, t);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r0, r0, -t);\n\t\t\t\t}\n\t\t\t\t/* r1 = r1 - s * gama_u. */\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tbn_sub_dig(r1, r1, s);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r1, r1, -s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < (w - 1); j++) {\n\t\t\t\t/* tmp = r0. */\n\t\t\t\tbn_hlv(tmp, r0);\n\t\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\t\tif (u == -1) {\n\t\t\t\t\tbn_sub(r0, r1, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add(r0, r1, tmp);\n\t\t\t\t}\n\t\t\t\t/* r1 = - r0 / 2. */\n\t\t\t\tbn_copy(r1, tmp);\n\t\t\t\tr1->sign = tmp->sign ^ 1;\n\t\t\t}\n\t\t}\n\t\ts = r0->dp[0];\n\t\tt = r1->dp[0];\n\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\ts = -s;\n\t\t}\n\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\tt = -t;\n\t\t}\n\t\tif (s != 0 && t != 0) {\n\t\t\tfor (int j = 0; j < (1 << (w - 2)); j++) {\n\t\t\t\tif (beta[j] == s && gama[j] == t) {\n\t\t\t\t\ttnaf[i++] = 2 * j + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < (1 << (w - 2)); j++) {\n\t\t\t\tif (beta[j] == -s && gama[j] == -t) {\n\t\t\t\t\ttnaf[i++] = -(2 * j + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (t != 0) {\n\t\t\t\ttnaf[i++] = t;\n\t\t\t} else {\n\t\t\t\ttnaf[i++] = s;\n\t\t\t}\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r0);\n\t\tbn_free(r1);\n\t\tbn_free(tmp);\n\t}\n}\n\nvoid bn_rec_reg(int8_t *naf, int *len, const bn_t k, int n, int w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n\n\tbn_null(t);\n\n\tmask = RLC_MASK(w);\n\tl = RLC_CEIL(n, w - 1);\n\n\tif (*len <= l) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_abs(t, k);\n\n\t\tmemset(naf, 0, *len);\n\n\t\ti = 0;\n\t\tif (w == 2) {\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tu_i = (t->dp[0] & mask) - 2;\n\t\t\t\tt->dp[0] -= u_i;\n\t\t\t\tnaf[i] = u_i;\n\t\t\t\tbn_hlv(t, t);\n\t\t\t}\n\t\t\tbn_get_dig(&t0, t);\n\t\t\tnaf[i] = t0;\n\t\t} else {\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tu_i = (t->dp[0] & mask) - (1 << (w - 1));\n\t\t\t\tt->dp[0] -= u_i;\n\t\t\t\tnaf[i] = u_i;\n\t\t\t\tbn_rsh(t, t, w - 1);\n\t\t\t}\n\t\t\tbn_get_dig(&t0, t);\n\t\t\tnaf[i] = t0;\n\t\t}\n\t\t*len = l + 1;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_rec_jsf(int8_t *jsf, int *len, const bn_t k, const bn_t l) {\n\tbn_t n0, n1;\n\tdig_t l0, l1;\n\tint8_t u0, u1, d0, d1;\n\tint i, j, offset;\n\n\tif (*len < (2 * bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tbn_null(n0);\n\tbn_null(n1);\n\n\tRLC_TRY {\n\t\tbn_new(n0);\n\t\tbn_new(n1);\n\n\t\tbn_abs(n0, k);\n\t\tbn_abs(n1, l);\n\n\t\ti = bn_bits(k);\n\t\tj = bn_bits(l);\n\t\toffset = RLC_MAX(i, j) + 1;\n\n\t\tmemset(jsf, 0, *len);\n\n\t\ti = 0;\n\t\td0 = d1 = 0;\n\t\twhile (!(bn_is_zero(n0) && d0 == 0) || !(bn_is_zero(n1) && d1 == 0)) {\n\t\t\tbn_get_dig(&l0, n0);\n\t\t\tbn_get_dig(&l1, n1);\n\t\t\t/* For reduction modulo 8. */\n\t\t\tl0 = (l0 + d0) & RLC_MASK(3);\n\t\t\tl1 = (l1 + d1) & RLC_MASK(3);\n\n\t\t\tif (l0 % 2 == 0) {\n\t\t\t\tu0 = 0;\n\t\t\t} else {\n\t\t\t\tu0 = 2 - (l0 & RLC_MASK(2));\n\t\t\t\tif ((l0 == 3 || l0 == 5) && ((l1 & RLC_MASK(2)) == 2)) {\n\t\t\t\t\tu0 = (int8_t)-u0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tjsf[i] = u0;\n\t\t\tif (l1 % 2 == 0) {\n\t\t\t\tu1 = 0;\n\t\t\t} else {\n\t\t\t\tu1 = 2 - (l1 & RLC_MASK(2));\n\t\t\t\tif ((l1 == 3 || l1 == 5) && ((l0 & RLC_MASK(2)) == 2)) {\n\t\t\t\t\tu1 = (int8_t)-u1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tjsf[i + offset] = u1;\n\n\t\t\tif (d0 + d0 == 1 + u0) {\n\t\t\t\td0 = (int8_t)(1 - d0);\n\t\t\t}\n\t\t\tif (d1 + d1 == 1 + u1) {\n\t\t\t\td1 = (int8_t)(1 - d1);\n\t\t\t}\n\n\t\t\ti++;\n\t\t\tbn_hlv(n0, n0);\n\t\t\tbn_hlv(n1, n1);\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n0);\n\t\tbn_free(n1);\n\t}\n\n}\n\nvoid bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t *v1,\n\t\tconst bn_t *v2) {\n\tbn_t t, b1, b2;\n\tint r1, r2, bits;\n\n\tbn_null(b1);\n\tbn_null(b2);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(b1);\n\t\tbn_new(b2);\n\t\tbn_new(t);\n\n\t\tbn_abs(t, k);\n\t\tbits = bn_bits(n);\n\n\t\tbn_mul(b1, t, v1[0]);\n\t\tr1 = bn_get_bit(b1, bits);\n\t\tbn_rsh(b1, b1, bits + 1);\n\t\tbn_add_dig(b1, b1, r1);\n\n\t\tbn_mul(b2, t, v2[0]);\n\t\tr2 = bn_get_bit(b2, bits);\n\t\tbn_rsh(b2, b2, bits + 1);\n\t\tbn_add_dig(b2, b2, r2);\n\n\t\tbn_mul(k0, b1, v1[1]);\n\t\tbn_mul(k1, b2, v2[1]);\n\t\tbn_add(k0, k0, k1);\n\t\tbn_sub(k0, t, k0);\n\n\t\tbn_mul(k1, b1, v1[2]);\n\t\tbn_mul(t, b2, v2[2]);\n\t\tbn_add(k1, k1, t);\n\t\tbn_neg(k1, k1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(b1);\n\t\tbn_free(b2);\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_rec_frb(bn_t *ki, int sub, const bn_t k, const bn_t x, const bn_t n,\n\t\tint cof) {\n\tint i, l, sk, sx;\n\tbn_t u[4], v[4];\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(u[i]);\n\t\t\tbn_null(v[i]);\n\t\t\tbn_new(u[i]);\n\t\t\tbn_new(v[i]);\n\t\t}\n\n\t\tif (cof == 0) {\n\t\t\tbn_abs(v[0], k);\n\t\t\tbn_abs(u[0], x);\n\n\t\t\tsk = bn_sign(k);\n\t\t\tsx = bn_sign(x);\n\n\t\t\tfor (i = 0; i < sub; i++) {\n\t\t\t\tbn_mod(ki[i], v[0], u[0]);\n\t\t\t\tbn_div(v[0], v[0], u[0]);\n\t\t\t\tif ((sx == RLC_NEG) && (i % 2 != 0)) {\n\t\t\t\t\tbn_neg(ki[i], ki[i]);\n\t\t\t\t}\n\t\t\t\tif (sk == RLC_NEG) {\n\t\t\t\t\tbn_neg(ki[i], ki[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbn_copy(v[1], x);\n\t\t\tbn_copy(v[2], x);\n\t\t\tbn_copy(v[3], x);\n\n\t\t\t/* t = 2x^2. */\n\t\t\tbn_sqr(u[3], x);\n\t\t\tbn_dbl(u[3], u[3]);\n\n\t\t\t/* v0 = 2x^2 + 3x + 1. */\n\t\t\tbn_mul_dig(v[0], x, 3);\n\t\t\tbn_add_dig(v[0], v[0], 1);\n\t\t\tbn_add(v[0], v[0], u[3]);\n\n\t\t\t/* v3 = -(2x^2 + x). */\n\t\t\tbn_add(v[3], v[3], u[3]);\n\t\t\tbn_neg(v[3], v[3]);\n\n\t\t\t/* v1 = 12x^3 + 8x^2 + x, v2 = 6x^3 + 4x^2 + x. */\n\t\t\tbn_dbl(u[3], u[3]);\n\t\t\tbn_add(v[2], v[2], u[3]);\n\t\t\tbn_dbl(u[3], u[3]);\n\t\t\tbn_add(v[1], v[1], u[3]);\n\t\t\tbn_rsh(u[3], u[3], 2);\n\t\t\tbn_mul(u[3], u[3], x);\n\t\t\tbn_mul_dig(u[3], u[3], 3);\n\t\t\tbn_add(v[2], v[2], u[3]);\n\t\t\tbn_dbl(u[3], u[3]);\n\t\t\tbn_add(v[1], v[1], u[3]);\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(v[i], v[i], k);\n\t\t\t\tbn_div(v[i], v[i], n);\n\t\t\t\tif (bn_sign(v[i]) == RLC_NEG) {\n\t\t\t\t\tbn_add_dig(v[i], v[i], 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* u0 = x + 1, u1 = 2x + 1, u2 = 2x, u3 = x - 1. */\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[1], u[2], 1);\n\t\t\tbn_sub_dig(u[3], x, 1);\n\t\t\tbn_add_dig(u[0], x, 1);\n\t\t\tbn_copy(ki[0], k);\n\t\t\tbn_zero(ki[1]);\n\t\t\tbn_zero(ki[2]);\n\t\t\tbn_zero(ki[3]);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[0], ki[0], n);\n\t\t\t\tbn_sub(ki[0], ki[0], u[i]);\n\t\t\t\tbn_mod(ki[0], ki[0], n);\n\t\t\t}\n\n\t\t\t/* u0 = x, u1 = -x, u2 = 2x + 1, u3 = 4x + 2. */\n\t\t\tbn_copy(u[0], x);\n\t\t\tbn_neg(u[1], x);\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[2], u[2], 1);\n\t\t\tbn_dbl(u[3], u[2]);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[1], ki[1], n);\n\t\t\t\tbn_sub(ki[1], ki[1], u[i]);\n\t\t\t\tbn_mod(ki[1], ki[1], n);\n\t\t\t}\n\n\t\t\t/* u0 = x, u1 = -(x + 1), u2 = 2x + 1, u3 = -(2x - 1). */\n\t\t\tbn_copy(u[0], x);\n\t\t\tbn_add_dig(u[1], x, 1);\n\t\t\tbn_neg(u[1], u[1]);\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[2], u[2], 1);\n\t\t\tbn_sub_dig(u[3], u[2], 2);\n\t\t\tbn_neg(u[3], u[3]);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[2], ki[2], n);\n\t\t\t\tbn_sub(ki[2], ki[2], u[i]);\n\t\t\t\tbn_mod(ki[2], ki[2], n);\n\t\t\t}\n\n\t\t\t/* u0 = -2x, u1 = -x, u2 = 2x + 1, u3 = x - 1. */\n\t\t\tbn_dbl(u[0], x);\n\t\t\tbn_neg(u[0], u[0]);\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[2], u[2], 1);\n\t\t\tbn_sub_dig(u[3], x, 1);\n\t\t\tbn_neg(u[1], x);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[3], ki[3], n);\n\t\t\t\tbn_sub(ki[3], ki[3], u[i]);\n\t\t\t\tbn_mod(ki[3], ki[3], n);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tl = bn_bits(ki[i]);\n\t\t\t\tbn_sub(ki[i], n, ki[i]);\n\t\t\t\tif (bn_bits(ki[i]) > l) {\n\t\t\t\t\tbn_sub(ki[i], ki[i], n);\n\t\t\t\t\tki[i]->sign = RLC_POS;\n\t\t\t\t} else {\n\t\t\t\t\tki[i]->sign = RLC_NEG;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(u[i]);\n\t\t\tbn_free(v[i]);\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision arithmetic shift functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n#include \"relic_bn_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_dbl(bn_t c, const bn_t a) {\n\tdig_t carry;\n\n\tRLC_TRY {\n\t\tbn_grow(c, a->used + 1);\n\n\t\tc->used = a->used;\n\t\tcarry = bn_lsh1_low(c->dp, a->dp, c->used);\n\n\t\t/* If there is an additional carry. */\n\t\tif (carry != 0) {\n\t\t\tc->dp[c->used] = carry;\n\t\t\t(c->used)++;\n\t\t}\n\n\t\tc->sign = a->sign;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_hlv(bn_t c, const bn_t a) {\n\tbn_copy(c, a);\n\tbn_rsh1_low(c->dp, c->dp, c->used);\n\tbn_trim(c);\n}\n\nvoid bn_lsh(bn_t c, const bn_t a, int bits) {\n\tint digits;\n\tdig_t carry;\n\n\tbn_copy(c, a);\n\n\tif (bits <= 0) {\n\t\treturn;\n\t}\n\n\tRLC_RIP(bits, digits, bits);\n\n\tRLC_TRY {\n\t\tbn_grow(c, c->used + digits + (bits > 0));\n\n\t\tc->used = a->used + digits;\n\t\tc->sign = a->sign;\n\t\tif (digits > 0) {\n\t\t\tdv_lshd(c->dp, a->dp, c->used, digits);\n\t\t}\n\n\t\tif (bits > 0) {\n\t\t\tif (c != a) {\n\t\t\t\tcarry = bn_lshb_low(c->dp + digits, a->dp, a->used, bits);\n\t\t\t} else {\n\t\t\t\tcarry = bn_lshb_low(c->dp + digits, c->dp + digits, c->used - digits, bits);\n\t\t\t}\n\t\t\tif (carry != 0) {\n\t\t\t\tc->dp[c->used] = carry;\n\t\t\t\t(c->used)++;\n\t\t\t}\n\t\t}\n\t\tbn_trim(c);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_rsh(bn_t c, const bn_t a, int bits) {\n\tint digits = 0;\n\n\tbn_copy(c, a);\n\n\tif (bits <= 0) {\n\t\treturn;\n\t}\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tdv_rshd(c->dp, a->dp, a->used, digits);\n\t}\n\tc->used = a->used - digits;\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);\n\t\t} else {\n\t\t\tbn_rshb_low(c->dp, c->dp, c->used, bits);\n\t\t}\n\t}\n\tbn_trim(c);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of Legendre and Jacobi symbols.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint bn_smb_leg(const bn_t a, const bn_t b) {\n\tbn_t t;\n\tint res;\n\n\tbn_null(t);\n\n\tif (bn_sign(b) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tif (bn_cmp(a, b) == RLC_EQ) {\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\t/* t = (b - 1)/2. */\n\t\tbn_sub_dig(t, b, 1);\n\t\tbn_rsh(t, t, 1);\n\t\tbn_mxp(t, a, t, b);\n\t\tres = 0;\n\t\tif (bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\tres = 1;\n\t\t}\n\t\tbn_sub(t, b, t);\n\t\tif (bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\tres = -1;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn res;\n}\n\nint bn_smb_jac(const bn_t a, const bn_t b) {\n\tbn_t t0, t1, r;\n\tint t, h, res;\n\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(r);\n\n\t/* Argument b must be odd. */\n\tif (bn_is_even(b) || bn_sign(b) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(r);\n\t\tt = 1;\n\n\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\tbn_add(t0, a, b);\n\t\t} else {\n\t\t\tbn_copy(t0, a);\n\t\t}\n\t\tbn_copy(t1, b);\n\n\t\twhile (1) {\n\t\t\t/* t0 = a mod b. */\n\t\t\tbn_mod(t0, t0, t1);\n\t\t\t/* If a = 0 then if n = 1 return t else return 0. */\n\t\t\tif (bn_is_zero(t0)) {\n\t\t\t\tif (bn_cmp_dig(t1, 1) == RLC_EQ) {\n\t\t\t\t\tres = 1;\n\t\t\t\t\tif (t == -1) {\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tres = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Write t0 as 2^h * t0. */\n\t\t\th = 0;\n\t\t\twhile (bn_is_even(t0)) {\n\t\t\t\th++;\n\t\t\t\tbn_rsh(t0, t0, 1);\n\t\t\t}\n\t\t\t/* If h != 0 (mod 2) and n != +-1 (mod 8) then t = -t. */\n\t\t\tbn_mod_2b(r, t1, 3);\n\t\t\tif ((h % 2 != 0) && (bn_cmp_dig(r, 1) != RLC_EQ) &&\n\t\t\t\t\t(bn_cmp_dig(r, 7) != RLC_EQ)) {\n\t\t\t\tt = -t;\n\t\t\t}\n\t\t\t/* If t0 != 1 (mod 4) and n != 1 (mod 4) then t = -t. */\n\t\t\tbn_mod_2b(r, t0, 2);\n\t\t\tif (bn_cmp_dig(r, 1) != RLC_EQ) {\n\t\t\t\tbn_mod_2b(r, t1, 2);\n\t\t\t\tif (bn_cmp_dig(r, 1) != RLC_EQ) {\n\t\t\t\t\tt = -t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbn_copy(r, t0);\n\t\t\tbn_copy(t0, t1);\n\t\t\tbn_copy(t1, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(r);\n\t}\n\n\treturn res;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2015 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision integer square root extraction.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n#include \"relic_bn_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tint bits, cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tbits = bn_bits(a);\n\tbits += (bits % 2);\n\n\tbn_null(h);\n\tbn_null(l);\n\tbn_null(m);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_set_2b(h, bits >> 1);\n\t\tbn_set_2b(l, (bits >> 1) - 1);\n\n\t\t/* Trivial binary search approach. */\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);\n\t\t\tbn_sqr(t, m);\n\t\t\tcmp = bn_cmp(t, a);\n\t\t\tbn_sub(t, h, l);\n\n\t\t\tif (cmp == RLC_GT) {\n\t\t\t\tbn_copy(h, m);\n\t\t\t} else if (cmp == RLC_LT) {\n\t\t\t\tbn_copy(l, m);\n\t\t\t}\n\t\t} while (bn_cmp_dig(t, 1) == RLC_GT && cmp != RLC_EQ);\n\n\t\tbn_copy(c, m);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(h);\n\t\tbn_free(l);\n\t\tbn_free(m);\n\t\tbn_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision utilities.\n *\n * @ingroup bn\n */\n\n#include <inttypes.h>\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Statistical distance 1/2^\\lambda between sampling and uniform distribution.\n */\n#define RAND_DIST\t\t40\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_copy(bn_t c, const bn_t a) {\n\tif (c->dp == a->dp) {\n\t\treturn;\n\t}\n\n\tbn_grow(c, a->used);\n\tdv_copy(c->dp, a->dp, a->used);\n\n\tc->used = a->used;\n\tc->sign = a->sign;\n\tbn_trim(c);\n}\n\nvoid bn_abs(bn_t c, const bn_t a) {\n\tif (c->dp != a->dp) {\n\t\tbn_copy(c, a);\n\t}\n\tc->sign = RLC_POS;\n}\n\nvoid bn_neg(bn_t c, const bn_t a) {\n\tif (c->dp != a->dp) {\n\t\tbn_copy(c, a);\n\t}\n\tif (!bn_is_zero(c)) {\n\t\tc->sign = a->sign ^ 1;\n\t}\n}\n\nint bn_sign(const bn_t a) {\n\treturn a->sign;\n}\n\nvoid bn_zero(bn_t a) {\n\ta->sign = RLC_POS;\n\ta->used = 1;\n\tdv_zero(a->dp, a->alloc);\n}\n\nint bn_is_zero(const bn_t a) {\n\tif (a->used == 0) {\n\t\treturn 1;\n\t}\n\tif ((a->used == 1) && (a->dp[0] == 0)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint bn_is_even(const bn_t a) {\n\tif (bn_is_zero(a)) {\n\t\treturn 1;\n\t}\n\tif ((a->dp[0] & 0x01) == 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint bn_bits(const bn_t a) {\n\tint bits;\n\n\tif (bn_is_zero(a)) {\n\t\treturn 0;\n\t}\n\n\t/* Bits in lower digits. */\n\tbits = (a->used - 1) * RLC_DIG;\n\n\treturn bits + util_bits_dig(a->dp[a->used - 1]);\n}\n\nint bn_get_bit(const bn_t a, int bit) {\n\tint d;\n\n\tif (bit < 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tif (bit > bn_bits(a)) {\n\t\treturn 0;\n\t}\n\n\tRLC_RIP(bit, d, bit);\n\n\tif (d >= a->used) {\n\t\treturn 0;\n\t} else {\n\t\treturn (a->dp[d] >> bit) & (dig_t)1;\n\t}\n}\n\nvoid bn_set_bit(bn_t a, int bit, int value) {\n\tint d;\n\n\tif (bit < 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tRLC_RIP(bit, d, bit);\n\n\tbn_grow(a, d);\n\n\tif (value == 1) {\n\t\ta->dp[d] |= ((dig_t)1 << bit);\n\t\tif ((d + 1) > a->used) {\n\t\t\ta->used = d + 1;\n\t\t}\n\t} else {\n\t\ta->dp[d] &= ~((dig_t)1 << bit);\n\t\tbn_trim(a);\n\t}\n}\n\nint bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}\n\nvoid bn_get_dig(dig_t *c, const bn_t a) {\n\t*c = a->dp[0];\n}\n\nvoid bn_set_dig(bn_t a, dig_t digit) {\n\tbn_zero(a);\n\ta->dp[0] = digit;\n\ta->used = 1;\n\ta->sign = RLC_POS;\n}\n\nvoid bn_set_2b(bn_t a, int b) {\n\tint i, d;\n\n\tif (b < 0) {\n\t\tbn_zero(a);\n\t} else {\n\t\tRLC_RIP(b, d, b);\n\n\t\tbn_grow(a, d + 1);\n\t\tfor (i = 0; i < d; i++) {\n\t\t\ta->dp[i] = 0;\n\t\t}\n\t\ta->used = d + 1;\n\t\ta->dp[d] = ((dig_t)1 << b);\n\t\ta->sign = RLC_POS;\n\t}\n}\n\nvoid bn_rand(bn_t a, int sign, int bits) {\n\tint digits;\n\n\tRLC_RIP(bits, digits, bits);\n\tdigits += (bits > 0 ? 1 : 0);\n\n\tbn_grow(a, digits);\n\n\trand_bytes((uint8_t *)a->dp, digits * sizeof(dig_t));\n\n\ta->used = digits;\n\ta->sign = sign;\n\tif (bits > 0) {\n\t\tdig_t mask = ((dig_t)1 << (dig_t)bits) - 1;\n\t\ta->dp[a->used - 1] &= mask;\n\t}\n\tbn_trim(a);\n}\n\nvoid bn_rand_mod(bn_t a, const bn_t b) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_copy(t, b);\n\t\tdo {\n\t\t\tbn_rand(a, bn_sign(t), bn_bits(t) + RAND_DIST);\n\t\t\tbn_mod(a, a, t);\n\t\t} while (bn_is_zero(a) || bn_cmp_abs(a, t) != RLC_LT);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_print(const bn_t a) {\n\tint i;\n\n\tif (a->sign == RLC_NEG) {\n\t\tutil_print(\"-\");\n\t}\n\tif (a->used == 0) {\n\t\tutil_print(\"0\\n\");\n\t} else {\n#if WSIZE == 64\n\t\tutil_print_dig(a->dp[a->used - 1], 0);\n\t\tfor (i = a->used - 2; i >= 0; i--) {\n\t\t\tutil_print_dig(a->dp[i], 1);\n\t\t}\n#else\n\t\tutil_print_dig(a->dp[a->used - 1], 0);\n\t\tfor (i = a->used - 2; i >= 0; i--) {\n\t\t\tutil_print_dig(a->dp[i], 1);\n\t\t}\n#endif\n\t\tutil_print(\"\\n\");\n\t}\n}\n\nint bn_size_str(const bn_t a, int radix) {\n\tint digits = 0;\n\tbn_t t;\n\n\tbn_null(t);\n\n\t/* Check the radix. */\n\tif (radix < 2 || radix > 64) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tif (bn_is_zero(a)) {\n\t\treturn 2;\n\t}\n\n\t/* Binary case requires the bits, a sign and the null terminator. */\n\tif (radix == 2) {\n\t\treturn bn_bits(a) + (a->sign == RLC_NEG ? 1 : 0) + 1;\n\t}\n\n\tif (a->sign == RLC_NEG) {\n\t\tdigits++;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_copy(t, a);\n\n\t\tt->sign = RLC_POS;\n\n\t\twhile (!bn_is_zero(t)) {\n\t\t\tbn_div_dig(t, t, (dig_t)radix);\n\t\t\tdigits++;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn digits + 1;\n}\n\nvoid bn_read_str(bn_t a, const char *str, int len, int radix) {\n\tint sign, i, j;\n\tchar c;\n\n\tbn_zero(a);\n\n\tif (radix < 2 || radix > 64) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tj = 0;\n\tif (str[0] == '-') {\n\t\tj++;\n\t\tsign = RLC_NEG;\n\t} else {\n\t\tsign = RLC_POS;\n\t}\n\n\tRLC_TRY {\n\t\tbn_grow(a, RLC_CEIL(len * util_bits_dig(radix), RLC_DIG));\n\n\t\twhile (j < len) {\n\t\t\tif (str[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = (char)((radix < 36) ? RLC_UPP(str[j]) : str[j]);\n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\tif (c == util_conv_char(i)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < radix) {\n\t\t\t\tbn_mul_dig(a, a, (dig_t)radix);\n\t\t\t\tbn_add_dig(a, a, (dig_t)i);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\ta->sign = sign;\n\t\tbn_trim(a);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_write_str(char *str, int len, const bn_t a, int radix) {\n\tbn_t t;\n\tdig_t d;\n\tint digits, l, i, j;\n\tchar c;\n\n\tbn_null(t);\n\n\tl = bn_size_str(a, radix);\n\tif (len < l) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tif (radix < 2 || radix > 64) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(a) == 1) {\n\t\t*str++ = '0';\n\t\t*str = '\\0';\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_copy(t, a);\n\n\t\tj = 0;\n\t\tif (t->sign == RLC_NEG) {\n\t\t\tstr[j] = '-';\n\t\t\tj++;\n\t\t\tt->sign = RLC_POS;\n\t\t}\n\n\t\tdigits = 0;\n\t\twhile (!bn_is_zero(t) && j < len) {\n\t\t\tbn_div_rem_dig(t, &d, t, (dig_t)radix);\n\t\t\tstr[j] = util_conv_char(d);\n\t\t\tdigits++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* Reverse the digits of the string. */\n\t\ti = 0;\n\t\tif (str[0] == '-') {\n\t\t\ti = 1;\n\t\t}\n\n\t\tj = l - 2;\n\t\twhile (i < j) {\n\t\t\tc = str[i];\n\t\t\tstr[i] = str[j];\n\t\t\tstr[j] = c;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\n\t\tstr[l - 1] = '\\0';\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nint bn_size_bin(const bn_t a) {\n\tdig_t d;\n\tint digits;\n\n\tdigits = (a->used - 1) * (RLC_DIG / 8);\n\td = a->dp[a->used - 1];\n\n\twhile (d != 0) {\n\t\td = d >> 8;\n\t\tdigits++;\n\t}\n\treturn digits;\n}\n\nvoid bn_read_bin(bn_t a, const uint8_t *bin, int len) {\n\tint i, j;\n\tdig_t d = (RLC_DIG / 8);\n\tint digs = (len % d == 0 ? len / d : len / d + 1);\n\n\tbn_grow(a, digs);\n\tbn_zero(a);\n\ta->used = digs;\n\n\tfor (i = 0; i < digs - 1; i++) {\n\t\td = 0;\n\t\tfor (j = (RLC_DIG / 8) - 1; j >= 0; j--) {\n\t\t\td = d << 8;\n\t\t\td |= bin[len - 1 - (i * (RLC_DIG / 8) + j)];\n\t\t}\n\t\ta->dp[i] = d;\n\t}\n\td = 0;\n\tfor (j = (RLC_DIG / 8) - 1; j >= 0; j--) {\n\t\tif ((int)(i * (RLC_DIG / 8) + j) < len) {\n\t\t\td = d << 8;\n\t\t\td |= bin[len - 1 - (i * (RLC_DIG / 8) + j)];\n\t\t}\n\t}\n\ta->dp[i] = d;\n\n\ta->sign = RLC_POS;\n\tbn_trim(a);\n}\n\nvoid bn_write_bin(uint8_t *bin, int len, const bn_t a) {\n\tint size, k;\n\tdig_t d;\n\n\tsize = bn_size_bin(a);\n\n\tif (len < size) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tk = 0;\n\tfor (int i = 0; i < a->used - 1; i++) {\n\t\td = a->dp[i];\n\t\tfor (int j = 0; j < (int)(RLC_DIG / 8); j++) {\n\t\t\tbin[len - 1 - k++] = d & 0xFF;\n\t\t\td = d >> 8;\n\t\t}\n\t}\n\n\td = a->dp[a->used - 1];\n\twhile (d != 0) {\n\t\tbin[len - 1 - k++] = d & 0xFF;\n\t\td = d >> 8;\n\t}\n\n\twhile (k < len) {\n\t\tbin[len - 1 - k++] = 0;\n\t}\n}\n\nint bn_size_raw(const bn_t a) {\n\treturn a->used;\n}\n\nvoid bn_read_raw(bn_t a, const dig_t *raw, int len) {\n\tRLC_TRY {\n\t\tbn_grow(a, len);\n\t\ta->used = len;\n\t\ta->sign = RLC_POS;\n\t\tdv_copy(a->dp, raw, len);\n\t\tbn_trim(a);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_write_raw(dig_t *raw, int len, const bn_t a) {\n\tint i, size;\n\n\tsize = a->used;\n\n\tif (len < size) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\traw[i] = a->dp[i];\n\t}\n\tfor (; i < len; i++) {\n\t\traw[i] = 0;\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Boneh-Lynn-Schacham short signature protocol.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_bls_gen(bn_t d, g2_t q) {\n\tbn_t n;\n\tint result = RLC_OK;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\t\tbn_rand_mod(d, n);\n\t\tg2_mul_gen(q, d);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_bls_sig(g1_t s, const uint8_t *msg, int len, const bn_t d) {\n\tg1_t p;\n\tint result = RLC_OK;\n\n\tg1_null(p);\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg1_map(p, msg, len);\n\t\tg1_mul_key(s, p, d);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(p);\n\t}\n\treturn result;\n}\n\nint cp_bls_ver(const g1_t s, const uint8_t *msg, size_t len, const g2_t q) {\n\tg1_t p[2];\n\tg2_t r[2];\n\tgt_t e;\n\tint result = 0;\n\n\tg1_null(p[0]);\n\tg1_null(p[1]);\n\tg2_null(r[0]);\n\tg2_null(r[1]);\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tg1_new(p[0]);\n\t\tg1_new(p[1]);\n\t\tg2_new(r[0]);\n\t\tg2_new(r[1]);\n\t\tgt_new(e);\n\n\t\tg1_map(p[0], msg, len);\n\t\tg1_copy(p[1], s);\n\t\tg2_copy(r[0], q);\n\t\tg2_get_gen(r[1]);\n\t\tg2_neg(r[1], r[1]);\n\n\t\tpc_map_sim(e, p, r, 2);\n\t\tif (gt_is_unity(e) && g2_is_valid(q)) {\n\t\t\tresult = 1;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(p[0]);\n\t\tg1_free(p[1]);\n\t\tg2_free(r[0]);\n\t\tg2_free(r[1]);\n\t\tgt_free(e);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of context-hiding linearly homomophic signature protocol.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_cmlhs_init(g1_t h) {\n\tg1_rand(h);\n\treturn RLC_OK;\n}\n\nint cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,\n\t\tbn_t sk, g2_t pk, bn_t d, g2_t y, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t gt;\n\tbn_t n;\n\tint result = RLC_OK;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(gt);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tgt_new(gt);\n\n\t\tpc_get_ord(n);\n\t\tg1_get_gen(g1);\n\t\tg2_get_gen(g2);\n\t\tpc_map(gt, g1, g2);\n\n\t\trand_bytes(prf, plen);\n\t\tif (bls) {\n\t\t\tcp_bls_gen(sk, pk);\n\t\t} else {\n\t\t\tcp_ecdsa_gen(sk, g1);\n\t\t\tfp_copy(pk->x[0], g1->x);\n\t\t\tfp_copy(pk->y[0], g1->y);\n\t\t}\n\n\t\t/* Generate elements for n tags. */\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tbn_rand_mod(x[i], n);\n\t\t\tgt_exp(hs[i], gt, x[i]);\n\t\t}\n\n\t\tbn_rand_mod(d, n);\n\t\tg2_mul_gen(y, d);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tgt_free(gt);\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_cmlhs_sig(g1_t sig, g2_t z, g1_t a, g1_t c, g1_t r, g2_t s,\n\t\tconst bn_t msg, const char *data, int label, const bn_t x, const g1_t h,\n\t\tconst uint8_t prf[], size_t plen, const bn_t d, const bn_t sk,\n\t\tint bls) {\n\tbn_t k, m, n;\n\tg1_t t;\n\tuint8_t mac[RLC_MD_LEN];\n\tint len, dlen = strlen(data), result = RLC_OK;\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);\n\n\tbn_null(k);\n\tbn_null(m);\n\tbn_null(n);\n\tg1_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(m);\n\t\tbn_new(n);\n\t\tg1_new(t);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tpc_get_ord(n);\n\t\t/* Generate r and s. */\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(m, n);\n\n\t\t/* Compute S = -g2^s, C = g1^s. */\n\t\tg2_mul_gen(s, m);\n\t\tg2_neg(s, s);\n\t\tg1_mul_gen(c, m);\n\t\t/* Compute R = g1^(r - ys). */\n\t\tbn_mul(m, d, m);\n\t\tbn_mod(m, m, n);\n\t\tbn_sub(m, k, m);\n\t\tbn_mod(m, m, n);\n\t\tg1_mul_gen(r, m);\n\n\t\t/* Compute A = g1^(x + r) * \\prod H_j^(y * m_j). */\n\t\tbn_add(k, x, k);\n\t\tbn_mod(k, k, n);\n\t\tg1_mul_gen(a, k);\n\t\tbn_mul(k, d, msg);\n\t\tbn_mod(k, k, n);\n\t\tg1_mul(t, h, k);\n\t\tg1_add(a, a, t);\n\t\tg1_norm(a, a);\n\t\t/* Compute z = F_K(delta), Z = g2^z, A = A^(1/z). */\n\t\tmd_hmac(mac, (const uint8_t *)data, dlen, prf, plen);\n\t\tbn_read_bin(k, mac, RLC_MD_LEN);\n\t\tbn_mod(k, k, n);\n\t\tg2_mul_gen(z, k);\n\t\tbn_mod_inv(k, k, n);\n\t\tg1_mul(a, a, k);\n\n\t\t/* Compute C = C * sum H_j^m_j. */\n\t\tbn_mod(k, msg, n);\n\t\tg1_mul(t, h, k);\n\t\tg1_add(c, c, t);\n\t\tg1_norm(c, c);\n\n\t\tlen = g2_size_bin(z, 0);\n\t\tg2_write_bin(buf, len, z, 0);\n\t\tmemcpy(buf + len, data, dlen);\n\t\tif (bls) {\n\t\t\tcp_bls_sig(sig, buf, len + dlen, sk);\n\t\t} else {\n\t\t\tcp_ecdsa_sig(m, n, buf, len + dlen, 0, sk);\n\t\t\tfp_prime_conv(sig->x, m);\n\t\t\tfp_prime_conv(sig->y, n);\n\t\t\tfp_set_dig(sig->z, 1);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(m);\n\t\tbn_free(n);\n\t\tg1_free(t);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nint cp_cmlhs_fun(g1_t a, g1_t c, const g1_t as[], const g1_t cs[],\n\t\tconst dig_t f[], size_t len) {\n\tint result = RLC_OK;\n\n\tg1_mul_sim_dig(a, as, f, len);\n\tg1_mul_sim_dig(c, cs, f, len);\n\n\treturn result;\n}\n\nint cp_cmlhs_evl(g1_t r, g2_t s, const g1_t rs[], const g2_t ss[],\n\t\tconst dig_t f[], size_t len) {\n\tint result = RLC_OK;\n\n\tg1_mul_sim_dig(r, rs, f, len);\n\tg2_mul_sim_dig(s, ss, f, len);\n\n\treturn result;\n}\n\nint cp_cmlhs_ver(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const int label[], const gt_t *hs[], const dig_t *f[],\n\t\tconst size_t flen[], const g2_t y[], const g2_t pk[], size_t slen,\n\t\tint bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tint len, dlen = strlen(data), result = 1;\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tgt_new(e);\n\t\tgt_new(u);\n\t\tgt_new(v);\n\t\tbn_new(k);\n\t\tbn_new(n);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tlen = g2_size_bin(z[i], 0);\n\t\t\tg2_write_bin(buf, len, z[i], 0);\n\t\t\tmemcpy(buf + len, data, dlen);\n\t\t\tif (bls) {\n\t\t\t\tresult &= cp_bls_ver(sig[i], buf, len + dlen, pk[i]);\n\t\t\t} else {\n\t\t\t\tfp_prime_back(k, sig[i]->x);\n\t\t\t\tfp_prime_back(n, sig[i]->y);\n\t\t\t\tfp_copy(g1->x, pk[i]->x[0]);\n\t\t\t\tfp_copy(g1->y, pk[i]->y[0]);\n\t\t\t\tfp_set_dig(g1->z, 1);\n\t\t\t\tresult &= cp_ecdsa_ver(k, n, buf, len + dlen, 0, g1);\n\t\t\t}\n\t\t}\n\n\t\tpc_get_ord(n);\n\t\tg1_get_gen(g1);\n\t\tg2_get_gen(g2);\n\n\t\tpc_map_sim(e, a, z, slen);\n\t\tpc_map_sim(u, c, y, slen);\n\t\tpc_map(v, r, g2);\n\t\tgt_mul(u, u, v);\n\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tfor (int j = 0; j < flen[i]; j++) {\n\t\t\t\tgt_exp_dig(v, hs[i][label[j]], f[i][j]);\n\t\t\t\tgt_mul(u, u, v);\n\t\t\t}\n\t\t}\n\t\tif (gt_cmp(e, u) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\n\t\tpc_map(e, g1, s);\n\t\tg1_set_infty(g1);\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tg1_add(g1, g1, c[i]);\n\t\t}\n\t\tg1_norm(g1, g1);\n\t\tpc_map(u, g1, g2);\n\t\tgt_mul(e, e, u);\n\n\t\tg1_mul(g1, h, msg);\n\t\tpc_map(v, g1, g2);\n\t\tif (gt_cmp(e, v) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tgt_free(e);\n\t\tgt_free(u);\n\t\tgt_free(v);\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nvoid cp_cmlhs_off(gt_t vk, const g1_t h, const int label[], const gt_t *hs[],\n\t\tconst dig_t *f[], const size_t flen[], size_t slen) {\n\tgt_t v;\n\n\tgt_null(v);\n\n\tRLC_TRY {\n\t\tgt_new(v);\n\n\t\tgt_set_unity(vk);\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tfor (int j = 0; j < flen[i]; j++) {\n\t\t\t\tgt_exp_dig(v, hs[i][label[j]], f[i][j]);\n\t\t\t\tgt_mul(vk, vk, v);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tgt_free(v);\n\t}\n}\n\nint cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tint len, dlen = strlen(data), result = 1;\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tgt_new(e);\n\t\tgt_new(u);\n\t\tgt_new(v);\n\t\tbn_new(k);\n\t\tbn_new(n);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tlen = g2_size_bin(z[i], 0);\n\t\t\tg2_write_bin(buf, len, z[i], 0);\n\t\t\tmemcpy(buf + len, data, dlen);\n\t\t\tif (bls) {\n\t\t\t\tresult &= cp_bls_ver(sig[i], buf, len + dlen, pk[i]);\n\t\t\t} else {\n\t\t\t\tfp_prime_back(k, sig[i]->x);\n\t\t\t\tfp_prime_back(n, sig[i]->y);\n\t\t\t\tfp_copy(g1->x, pk[i]->x[0]);\n\t\t\t\tfp_copy(g1->y, pk[i]->y[0]);\n\t\t\t\tfp_set_dig(g1->z, 1);\n\t\t\t\tresult &= cp_ecdsa_ver(k, n, buf, len + dlen, 0, g1);\n\t\t\t}\n\t\t}\n\n\t\tpc_get_ord(n);\n\t\tg1_get_gen(g1);\n\t\tg2_get_gen(g2);\n\n\t\tpc_map_sim(e, a, z, slen);\n\t\tpc_map_sim(u, c, y, slen);\n\t\tpc_map(v, r, g2);\n\t\tgt_mul(u, u, v);\n\t\tgt_mul(u, u, vk);\n\n\t\tif (gt_cmp(e, u) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\n\t\tpc_map(e, g1, s);\n\t\tg1_set_infty(g1);\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tg1_add(g1, g1, c[i]);\n\t\t}\n\t\tg1_norm(g1, g1);\n\t\tpc_map(u, g1, g2);\n\t\tgt_mul(e, e, u);\n\n\t\tg1_mul(g1, h, msg);\n\t\tpc_map(v, g1, g2);\n\t\tif (gt_cmp(e, v) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tgt_free(e);\n\t\tgt_free(u);\n\t\tgt_free(v);\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing-based laconic private set intersection protocols.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_pbpsi_gen(bn_t sk, g1_t ss, g2_t s[], size_t m) {\n\tint i, result = RLC_OK;\n\tbn_t q;\n\n\tbn_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(q);\n\n\t\tpc_get_ord(q);\n\t\tbn_rand_mod(sk, q);\n\t\tg1_mul_gen(ss, sk);\n\n\t\tg2_get_gen(s[0]);\n\t\tfor (i = 1; i <= m; i++) {\n\t\t\tg2_mul(s[i], s[i - 1], sk);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(q);\n\t}\n\treturn result;\n}\n\nint cp_pbpsi_ask(g2_t d[], bn_t r, const bn_t x[], const g2_t s[], size_t m) {\n\tint i, result = RLC_OK;\n\tbn_t t, q, *p = RLC_ALLOCA(bn_t, m + 1), *_x = RLC_ALLOCA(bn_t, m + 1);\n\n\tbn_null(q);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(q);\n\t\tbn_new(t);\n\t\tif (p == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\tbn_null(p[i]);\n\t\t\tbn_new(p[i]);\n\t\t\tbn_null(_x[i]);\n\t\t\tbn_new(_x[i]);\n\t\t}\n\n\t\tpc_get_ord(q);\n\t\tbn_rand_mod(r, q);\n\t\tif (m == 0) {\n\t\t\tg2_mul_gen(d[0], r);\n\t\t} else {\n\t\t\tbn_lag(p, x, q, m);\n\t\t\tg2_mul_sim_lot(d[0], s, p, m + 1);\n\t\t\tg2_mul(d[0], d[0], r);\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tbn_copy(_x[i], x[i]);\n\t\t\t}\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tbn_copy(t, _x[i]);\n\t\t\t\tbn_copy(_x[i], _x[m - 1]);\n\t\t\t\tbn_lag(p, _x, q, m - 1);\n\t\t\t\tg2_mul_sim_lot(d[i + 1], s, p, m);\n\t\t\t\tg2_mul(d[i + 1], d[i + 1], r);\n\t\t\t\tbn_copy(_x[i], t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(q);\n\t\tbn_free(t);\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\tbn_free(p[i]);\n\t\t\tbn_free(_x[i]);\n\t\t}\n\t\tRLC_FREE(p);\n\t}\n\treturn result;\n}\n\nint cp_pbpsi_ans(gt_t t[], g1_t u[], const g1_t ss, const g2_t d,\n\t\tconst bn_t y[], size_t n) {\n\tint j, result = RLC_OK;\n\tbn_t q, tj;\n\tg1_t g1;\n\tg2_t g2;\n\tunsigned int *shuffle = RLC_ALLOCA(unsigned int, n);\n\n\tbn_null(q);\n\tbn_null(tj);\n\tg1_null(g1);\n\tg2_null(g2);\n\n\tRLC_TRY {\n\t\tbn_new(q);\n\t\tbn_new(tj);\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tif (shuffle == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tutil_perm(shuffle, n);\n\n\t\tpc_get_ord(q);\n\t\tg2_get_gen(g2);\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tbn_rand_mod(tj, q);\n\t\t\tg1_mul_gen(g1, tj);\n\t\t\tpc_map(t[j], g1, d);\n\t\t\tg1_mul_gen(u[j], y[shuffle[j]]);\n\t\t\tg1_sub(u[j], ss, u[j]);\n\t\t\tg1_mul(u[j], u[j], tj);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(q);\n\t\tbn_free(tj);\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tRLC_FREE(shuffle);\n\t}\n\treturn result;\n}\n\nint cp_pbpsi_int(bn_t z[], size_t *len, const g2_t d[], const bn_t x[],\n\t\tsize_t m, const gt_t t[], const g1_t u[], size_t n) {\n\tint j, k, result = RLC_OK;\n\tgt_t e;\n\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tgt_new(e);\n\n\t\t*len = 0;\n\t\tif (m > 0) {\n\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tpc_map(e, u[j], d[k + 1]);\n\t\t\t\t\tif (gt_cmp(e, t[j]) == RLC_EQ && !gt_is_unity(e)) {\n\t\t\t\t\t\tbn_copy(z[*len], x[k]);\n\t\t\t\t\t\t(*len)++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tgt_free(e);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the RSA cryptosystem.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Length of chosen padding scheme.\n */\n#if CP_RSAPD == PKCS1\n#define RSA_PAD_LEN\t\t(11)\n#elif CP_RSAPD == PKCS2\n#define RSA_PAD_LEN\t\t(2 * RLC_MD_LEN + 2)\n#else\n#define RSA_PAD_LEN\t\t(2)\n#endif\n\n/**\n * Identifier for encrypted messages.\n */\n#define RSA_PUB\t\t\t\t(02)\n\n/**\n * Identifier for signed messages.\n */\n#define RSA_PRV\t\t\t\t(01)\n\n/**\n * Byte used as padding unit.\n */\n#define RSA_PAD\t\t\t\t(0xFF)\n\n/**\n * Byte used as padding unit in PSS signatures.\n */\n#define RSA_PSS\t\t\t\t(0xBC)\n\n/**\n * Identifier for encryption.\n */\n#define RSA_ENC\t\t\t\t1\n\n/**\n * Identifier for decryption.\n */\n#define RSA_DEC\t\t\t\t2\n\n/**\n * Identifier for signature.\n */\n#define RSA_SIG\t\t\t\t3\n\n/**\n * Identifier for verification.\n */\n#define RSA_VER\t\t\t\t4\n\n/**\n * Identifier for second encryption step.\n */\n#define RSA_ENC_FIN\t\t\t5\n\n/**\n * Identifier for second sining step.\n */\n#define RSA_SIG_FIN\t\t\t6\n\n/**\n * Identifier for signature of a precomputed hash.\n */\n#define RSA_SIG_HASH\t\t7\n\n/**\n * Identifier for verification of a precomputed hash.\n */\n#define RSA_VER_HASH\t\t8\n\n#if CP_RSAPD == BASIC\n\n/**\n * Applies or removes simple encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t pad = 0;\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tRLC_TRY {\n\t\tbn_null(t);\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t*p_len = 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\t(*p_len)++;\n\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t} while (pad == 0 && m_len > 0);\n\t\t\t\t\tif (pad == RSA_PAD) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS1\n\n/**\n * ASN.1 identifier of the hash function SHA-224.\n */\nstatic const uint8_t sh224_id[] = {\n\t0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c\n};\n\n/**\n * ASN.1 identifier of the hash function SHA-256.\n */\nstatic const uint8_t sh256_id[] = {\n\t0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20\n};\n\n/**\n * ASN.1 identifier of the hash function SHA-384.\n */\nstatic const uint8_t sh384_id[] = {\n\t0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30\n};\n\n/**\n * ASN.1 identifier of the hash function SHA-512.\n */\nstatic const uint8_t sh512_id[] = {\n\t0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40\n};\n\n/**\n * Returns a pointer to the ASN.1 identifier of a hash function according to the\n * PKCS#1 v1.5 padding standard.\n *\n * @param[in] md\t\t\t- the hash function.\n * @param[in, out] len\t\t- the length of the identifier.\n * @return The pointer to the hash function identifier.\n */\nstatic uint8_t *hash_id(int md, int *len) {\n\tswitch (md) {\n\t\tcase SH224:\n\t\t\t*len = sizeof(sh224_id);\n\t\t\treturn (uint8_t *)sh224_id;\n\t\tcase SH256:\n\t\t\t*len = sizeof(sh256_id);\n\t\t\treturn (uint8_t *)sh256_id;\n\t\tcase SH384:\n\t\t\t*len = sizeof(sh384_id);\n\t\t\treturn (uint8_t *)sh384_id;\n\t\tcase SH512:\n\t\t\t*len = sizeof(sh512_id);\n\t\t\treturn (uint8_t *)sh512_id;\n\t\tdefault:\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn NULL;\n\t}\n}\n\n/**\n * Applies or removes a PKCS#1 v1.5 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs1(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t *id, pad = 0;\n\tint len, result = RLC_ERR;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* EB = 00 | 02 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PUB);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tdo {\n\t\t\t\t\t\trand_bytes(&pad, 1);\n\t\t\t\t\t} while (pad == 0);\n\t\t\t\t\tbn_add_dig(m, m, pad);\n\t\t\t\t}\n\t\t\t\t/* Make room for the zero and real message. */\n\t\t\t\tbn_lsh(m, m, (m_len + 1) * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t*p_len = m_len;\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PUB) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\t*p_len -= (m_len - 1);\n\t\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\t\t\tresult = (m_len > 0 ? RLC_OK : RLC_ERR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len - len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\t/* Make room for the zero and hash id. */\n\t\t\t\tbn_lsh(m, m, 8 * (len + 1));\n\t\t\t\tbn_read_bin(t, id, len);\n\t\t\t\tbn_add(m, m, t);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\t/* Make room for the zero and hash. */\n\t\t\t\tbn_lsh(m, m, 8 * (m_len + 1));\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PRV) {\n\t\t\t\t\t\tint counter = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tbn_mod_2b(t, t, 8);\n\t\t\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t\t\tm_len -= len;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tint r = 0;\n\t\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t\t\tr |= pad ^ id[len - i - 1];\n\t\t\t\t\t\t\t\tbn_rsh(t, t, 8);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\t\t\t\tif (r == 0 && m_len == RLC_MD_LEN && counter >= 8) {\n\t\t\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PRV) {\n\t\t\t\t\t\tint counter = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tbn_mod_2b(t, t, 8);\n\t\t\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\t\t\t\tif (m_len == RLC_MD_LEN && counter >= 8) {\n\t\t\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS2\n\n/**\n * Applies or removes a PKCS#1 v2.1 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs2(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n\tuint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* DB = lHash | PS | 01 | D. */\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\t*p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len;\n\t\t\t\tbn_lsh(m, m, *p_len * 8);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0x01);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_ENC_FIN:\n\t\t\t\t/* EB = 00 | maskedSeed | maskedDB. */\n\t\t\t\trand_bytes(h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tbn_write_bin(mask, k_len - RLC_MD_LEN - 1, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tbn_read_bin(t, h1, RLC_MD_LEN);\n\t\t\t\tbn_lsh(t, t, 8 * (k_len - RLC_MD_LEN - 1));\n\t\t\t\tbn_add(t, t, m);\n\t\t\t\tbn_copy(m, t);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(mask, m_len, m);\n\t\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t\t}\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\t\tpad = 0;\n\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\t\tpad |= h1[i] ^ h2[i];\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t\t*p_len = bn_size_bin(m);\n\t\t\t\t\t(*p_len)--;\n\t\t\t\t\tbn_rsh(t, m, *p_len * 8);\n\t\t\t\t\tif (pad == 0 && bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n\t\t\t\t\t*p_len = k_len - *p_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* M' = 00 00 00 00 00 00 00 00 | H(M). */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 64);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, RLC_MD_LEN * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_FIN:\n\t\t\t\tmemset(mask, 0, 8);\n\t\t\t\tbn_write_bin(mask + 8, RLC_MD_LEN, m);\n\t\t\t\tmd_map(h1, mask, RLC_MD_LEN + 8);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tt->dp[0] ^= 0x01;\n\t\t\t\t/* m_len is now the size in bits of the modulus. */\n\t\t\t\tbn_lsh(t, t, 8 * RLC_MD_LEN);\n\t\t\t\tbn_add(m, t, m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PSS);\n\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\tbn_set_bit(m, i, 0);\n\t\t\t\t}\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tbn_mod_2b(t, m, 8);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad == RSA_PSS) {\n\t\t\t\t\tint r = 1;\n\t\t\t\t\tfor (int i = m_len; i < 8 * k_len; i++) {\n\t\t\t\t\t\tif (bn_get_bit(m, i) != 0) {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbn_rsh(m, m, 8);\n\t\t\t\t\tbn_mod_2b(t, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tbn_rsh(m, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm->dp[0] ^= 0x01;\n\t\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\t\tbn_set_bit(m, i - ((RLC_MD_LEN + 1) * 8), 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (r == 1 && bn_is_zero(m)) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_read_bin(m, h2, RLC_MD_LEN);\n\t\t\t\t\t*p_len = k_len - RLC_MD_LEN;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\tRLC_FREE(mask);\n\n\treturn result;\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_rsa_gen(rsa_t pub, rsa_t prv, int bits) {\n\tbn_t t, r;\n\tint result = RLC_OK;\n\n\tif (pub == NULL || prv == NULL || bits == 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tbn_null(t);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(r);\n\n\t\t/* Generate different primes p and q. */\n\t\tdo {\n\t\t\tbn_gen_prime(prv->crt->p, bits / 2);\n\t\t\tbn_gen_prime(prv->crt->q, bits / 2);\n\t\t} while (bn_cmp(prv->crt->p, prv->crt->q) == RLC_EQ);\n\n\t\t/* Swap p and q so that p is smaller. */\n\t\tif (bn_cmp(prv->crt->p, prv->crt->q) != RLC_LT) {\n\t\t\tbn_copy(t, prv->crt->p);\n\t\t\tbn_copy(prv->crt->p, prv->crt->q);\n\t\t\tbn_copy(prv->crt->q, t);\n\t\t}\n\n\t\t/* n = pq. */\n\t\tbn_mul(pub->crt->n, prv->crt->p, prv->crt->q);\n\t\tbn_copy(prv->crt->n, pub->crt->n);\n\t\tbn_sub_dig(prv->crt->p, prv->crt->p, 1);\n\t\tbn_sub_dig(prv->crt->q, prv->crt->q, 1);\n\n\t\t/* phi(n) = (p - 1)(q - 1). */\n\t\tbn_mul(t, prv->crt->p, prv->crt->q);\n\n\t\tbn_set_2b(pub->e, 16);\n\t\tbn_add_dig(pub->e, pub->e, 1);\n\n#if !defined(CP_CRT)\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\tresult = RLC_OK;\n\t\t}\n#else\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* dP = d mod (p - 1). */\n\t\t\tbn_mod(prv->crt->dp, prv->d, prv->crt->p);\n\t\t\t/* dQ = d mod (q - 1). */\n\t\t\tbn_mod(prv->crt->dq, prv->d, prv->crt->q);\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\t/* qInv = q^(-1) mod p. */\n\t\t\tbn_mod_inv(prv->crt->qi, prv->crt->q, prv->crt->p);\n\n\t\t\tresult = RLC_OK;\n\t\t}\n#endif /* CP_CRT */\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(r);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_enc(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(pub->crt->n);\n\n\tif (pub == NULL || in_len <= 0 || in_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#endif\n\t\t\tbn_read_bin(m, in, in_len);\n\t\t\tbn_add(eb, eb, m);\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC_FIN);\n#endif\n\t\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\t*out_len = size;\n\t\t\t\tmemset(out, 0, *out_len);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t prv) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(prv->crt->n);\n\n\tif (prv == NULL || in_len != size || in_len < RSA_PAD_LEN) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, in, in_len);\n#if !defined(CP_CRT)\n\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else\n\t\tbn_mxp_crt(eb, eb, prv->crt->dp, prv->crt->dq, prv->crt, 0);\n#endif /* CP_CRT */\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#endif\n\t\t\tsize = size - pad_len;\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\tmemset(out, 0, size);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t\t*out_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_sig(uint8_t *sig, size_t *sig_len, const uint8_t *msg,\n\t\tsize_t msg_len, int hash, const rsa_t prv) {\n\tbn_t m, eb;\n\tint pad_len, size, result = RLC_OK;\n\tuint8_t h[RLC_MD_LEN];\n\n\tif (prv == NULL || msg_len < 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(prv->crt->n) - 1;\n\tsize = (size / 8) + (size % 8 > 0);\n\tif (pad_len > (size - 2)) {\n\t\treturn RLC_ERR;\n\t}\n#else\n\tsize = bn_size_bin(prv->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n\t\tint operation = (!hash ? RSA_SIG : RSA_SIG_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#endif\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h, msg, msg_len);\n\t\t\t\tbn_read_bin(m, h, RLC_MD_LEN);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t} else {\n\t\t\t\tbn_read_bin(m, msg, msg_len);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t}\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, bn_bits(prv->crt->n), size, RSA_SIG_FIN);\n#endif\n\n\t\t\tbn_copy(m, eb);\n\n#if !defined(CP_CRT)\n\t\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else /* CP_CRT */\n\t\t\tbn_mxp_crt(eb, eb, prv->crt->dp, prv->crt->dq, prv->crt, 0);\n#endif /* CP_CRT */\n\n\t\t\tsize = bn_size_bin(prv->crt->n);\n\n\t\t\tif (size <= *sig_len) {\n\t\t\t\tmemset(sig, 0, size);\n\t\t\t\tbn_write_bin(sig, size, eb);\n\t\t\t\t*sig_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_ver(uint8_t *sig, size_t sig_len, const uint8_t *msg, size_t msg_len,\n\t\tint hash, const rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result;\n\tuint8_t *h1 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN) + 8);\n\tuint8_t *h2 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN));\n\n\t/* We suppose that the signature is invalid. */\n\tresult = 0;\n\n\tif (h1 == NULL || h2 == NULL) {\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t\treturn 0;\n\t}\n\n\tif (pub == NULL || msg_len < 0) {\n\t\treturn 0;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(pub->crt->n) - 1;\n\tif (size % 8 == 0) {\n\t\tsize = size / 8 - 1;\n\t} else {\n\t\tsize = bn_size_bin(pub->crt->n);\n\t}\n\tif (pad_len > (size - 2)) {\n\t\treturn 0;\n\t}\n#else\n\tsize = bn_size_bin(pub->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn 0;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, sig, sig_len);\n\n\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\tint operation = (!hash ? RSA_VER : RSA_VER_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, bn_bits(pub->crt->n), size,\n\t\t\t\t\t\toperation) == RLC_OK) {\n#endif\n\n#if CP_RSAPD == PKCS2\n\t\t\tmemset(h1, 0, 8);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, RLC_MD_LEN);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, msg_len);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, msg_len);\n\t\t\t}\n#else\n\t\t\tmemset(h1, 0, RLC_MAX(msg_len, RLC_MD_LEN));\n\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h2, msg, msg_len);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, msg, msg_len);\n\t\t\t}\n#endif\n\t\t\tresult = (result == RLC_EQ ? 1 : 0);\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t}\n\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Sakai-Ohgishi-Kasahara Identity-Based Non-Interactive\n * Authenticated Key Agreement scheme.\n *\n * @ingroup test\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_sokaka_gen(bn_t master) {\n\tbn_t n;\n\tint result = RLC_OK;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\t\tbn_rand_mod(master, n);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_sokaka_gen_prv(sokaka_t k, const char *id, bn_t master) {\n\tif (pc_map_is_type1()) {\n\t\tg1_map(k->s1, (uint8_t *)id, strlen(id));\n\t\tg1_mul(k->s1, k->s1, master);\n\t} else {\n\t\tg1_map(k->s1, (uint8_t *)id, strlen(id));\n\t\tg1_mul(k->s1, k->s1, master);\n\t\tg2_map(k->s2, (uint8_t *)id, strlen(id));\n\t\tg2_mul(k->s2, k->s2, master);\n\t}\n\treturn RLC_OK;\n}\n\nint cp_sokaka_key(uint8_t *key, size_t key_len, const char *id1,\n\t\tconst sokaka_t k, const char *id2) {\n\tint len1 = strlen(id1), len2 = strlen(id2);\n\tint size, first = 0, result = RLC_OK;\n\tuint8_t *buf;\n\tg1_t p;\n\tg2_t q;\n\tgt_t e;\n\n\tg1_null(p);\n\tg2_null(q);\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg2_new(q);\n\t\tgt_new(e);\n\t\tsize = gt_size_bin(e, 0);\n\t\tbuf = RLC_ALLOCA(uint8_t, size);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tif (len1 == len2) {\n\t\t\tif (strncmp(id1, id2, len1) == 0) {\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t}\n\t\t\tfirst = (strncmp(id1, id2, len1) < 0 ? 1 : 2);\n\t\t} else {\n\t\t\tif (len1 < len2) {\n\t\t\t\tif (strncmp(id1, id2, len1) == 0) {\n\t\t\t\t\tfirst = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfirst = (strncmp(id1, id2, len1) < 0 ? 1 : 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (strncmp(id1, id2, len2) == 0) {\n\t\t\t\t\tfirst = 2;\n\t\t\t\t} else {\n\t\t\t\t\tfirst = (strncmp(id1, id2, len2) < 0 ? 1 : 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pc_map_is_type1()) {\n\t\t\tg2_map(q, (uint8_t *)id2, len2);\n\t\t\tpc_map(e, k->s1, q);\n\t\t} else {\n\t\t\tif (first == 1) {\n\t\t\t\tg2_map(q, (uint8_t *)id2, len2);\n\t\t\t\tpc_map(e, k->s1, q);\n\t\t\t} else {\n\t\t\t\tg1_map(p, (uint8_t *)id2, len2);\n\t\t\t\tpc_map(e, p, k->s2);\n\t\t\t}\n\t\t}\n\n\t\t/* Allocate size for storing the output. */\n\t\tgt_write_bin(buf, size, e, 0);\n\t\tmd_kdf(key, key_len, buf, size);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(p);\n\t\tg2_free(q);\n\t\tgt_free(e);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2018 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the vBNN-IBS idenenty-based signature algorithm.\n *\n * Paper: \"IMBAS: id-based multi-user broadcast authentication in wireless sensor networks\"\n *\n * @version $Id$\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_vbnn_gen(bn_t msk, ec_t mpk) {\n\tint result = RLC_OK;\n\n\t/* order of the ECC group */\n\tbn_t n;\n\n\t/* zero variables */\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\t/* initialize variables */\n\t\tbn_new(n);\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\t/* calculate master secret key */\n\t\tbn_rand_mod(msk, n);\n\n\t\t/* calculate master public key */\n\t\tec_mul_gen(mpk, msk);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,\n\t\tsize_t id_len) {\n\tuint8_t hash[RLC_MD_LEN];\n\tint len, result = RLC_OK;\n\tuint8_t *buf = NULL;\n\tbn_t n, r;\n\n\t/* zero variables */\n\tbn_null(n);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\t/* initialize variables */\n\t\tbn_new(n);\n\t\tbn_new(r);\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\t/* extract user key from id */\n\t\tbn_rand_mod(r, n);\n\n\t\t/* calculate R part of the user key */\n\t\tec_mul_gen(pk, r);\n\n\t\t/* calculate s part of the user key */\n\t\tlen = id_len + ec_size_bin(pk, 1);\n\t\tbuf = RLC_ALLOCA(uint8_t, len);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tmemcpy(buf, id, id_len);\n\t\tec_write_bin(buf + id_len, ec_size_bin(pk, 1), pk, 1);\n\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(sk, hash, RLC_MD_LEN);\n\t\tbn_mod(sk, sk, n);\n\t\tbn_mul(sk, sk, msk);\n\t\tbn_add(sk, sk, r);\n\t\tbn_mod(sk, sk, n);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t\tbn_free(r);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nint cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,\n\t\tconst uint8_t *msg, int msg_len, const bn_t sk, const ec_t pk) {\n\tint len, result = RLC_OK;\n\tuint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];\n\tbn_t n, y;\n\tec_t t;\n\n\t/* zero variables */\n\tbn_null(n);\n\tbn_null(y);\n\tec_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(y);\n\t\tec_new(t);\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\tbn_rand_mod(y, n);\n\t\tec_mul_gen(t, y);\n\n\t\t/* calculate h part of the signature */\n\t\tlen = id_len + msg_len + ec_size_bin(t, 1) + ec_size_bin(pk, 1);\n\t\tbuf = RLC_ALLOCA(uint8_t, len);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tbuf_i = buf;\n\t\tmemcpy(buf_i, id, id_len);\n\t\tbuf_i += id_len;\n\t\tmemcpy(buf_i, msg, msg_len);\n\t\tbuf_i += msg_len;\n\t\tec_write_bin(buf_i, ec_size_bin(pk, 1), pk, 1);\n\t\tbuf_i += ec_size_bin(pk, 1);\n\t\tec_write_bin(buf_i, ec_size_bin(t, 1), t, 1);\n\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(h, hash, RLC_MD_LEN);\n\t\tbn_mod(h, h, n);\n\n\t\t/* calculate z part of the signature */\n\t\tbn_mul(z, h, sk);\n\t\tbn_add(z, z, y);\n\t\tbn_mod(z, z, n);\n\n\t\t/* calculate R part of the signature */\n\t\tec_copy(r, pk);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t\tbn_free(y);\n\t\tec_free(t);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nint cp_vbnn_ver(const ec_t r, const bn_t z, const bn_t h, const uint8_t *id,\n\t\tsize_t id_len, const uint8_t *msg, int msg_len, const ec_t mpk) {\n\tint len, result = 0;\n\tuint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];\n\tbn_t n, c, _h;\n\tec_t Z;\n\tec_t t;\n\n\t/* zero variables */\n\tbn_null(n);\n\tbn_null(c);\n\tbn_null(_h);\n\tec_null(Z);\n\tec_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(c);\n\t\tbn_new(_h);\n\t\tec_new(Z);\n\t\tec_new(t);\n\n\t\t/* calculate c */\n\t\tlen = id_len + msg_len + 2 * ec_size_bin(r, 1);\n\t\tbuf = RLC_ALLOCA(uint8_t, len);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\tbuf_i = buf;\n\t\tmemcpy(buf_i, id, id_len);\n\t\tbuf_i += id_len;\n\t\tec_write_bin(buf_i, ec_size_bin(r, 1), r, 1);\n\n\t\tlen = id_len + ec_size_bin(r, 1);\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(c, hash, RLC_MD_LEN);\n\t\tbn_mod(c, c, n);\n\n\t\t/* calculate Z */\n\t\tec_mul_gen(Z, z);\n\t\tec_mul(t, mpk, c);\n\t\tec_add(t, t, r);\n\t\tec_norm(t, t);\n\t\tec_mul(t, t, h);\n\t\tec_sub(Z, Z, t);\n\t\tec_norm(Z, Z);\n\n\t\t/* calculate h_verify */\n\t\tbuf_i = buf;\n\t\tmemcpy(buf_i, id, id_len);\n\t\tbuf_i += id_len;\n\t\tmemcpy(buf_i, msg, msg_len);\n\t\tbuf_i += msg_len;\n\t\tec_write_bin(buf_i, ec_size_bin(r, 1), r, 1);\n\t\tbuf_i += ec_size_bin(r, 1);\n\t\tec_write_bin(buf_i, ec_size_bin(Z, 1), Z, 1);\n\n\t\tlen = id_len + msg_len + ec_size_bin(r, 1) + ec_size_bin(Z, 1);\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(_h, hash, RLC_MD_LEN);\n\t\tbn_mod(_h, _h, n);\n\t\tRLC_FREE(buf);\n\n\t\tif (bn_cmp(h, _h) == RLC_EQ) {\n\t\t\tresult = 1;\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t\tbn_free(c);\n\t\tbn_free(_h);\n\t\tec_free(Z);\n\t\tec_free(t);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a binary elliptic curve.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"relic_eb.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid eb_map(eb_t p, const uint8_t *msg, int len) {\n\tbn_t k;\n\tfb_t t0, t1;\n\tint i;\n\tuint8_t digest[RLC_MD_LEN];\n\n\tbn_null(k);\n\tfb_null(t0);\n\tfb_null(t1);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tfb_new(t0);\n\t\tfb_new(t1);\n\n\t\tmd_map(digest, msg, len);\n\t\tbn_read_bin(k, digest, RLC_MIN(RLC_FB_BYTES, RLC_MD_LEN));\n\t\tfb_set_dig(p->z, 1);\n\n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tbn_add_dig(k, k, 1);\n\t\t\tbn_mod_2b(k, k, RLC_FB_BITS);\n\t\t\tdv_copy(p->x, k->dp, RLC_FB_DIGS);\n\n\t\t\teb_rhs(t1, p);\n\n\t\t\t/* t0 = 1/x1^2. */\n\t\t\tfb_sqr(t0, p->x);\n\t\t\tfb_inv(t0, t0);\n\t\t\t/* t0 = t1/x1^2. */\n\t\t\tfb_mul(t0, t0, t1);\n\t\t\t/* Solve t1^2 + t1 = t0. */\n\t\t\tif (fb_trc(t0) != 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfb_slv(t1, t0);\n\t\t\t\t/* x3 = x1, y3 = t1 * x1, z3 = 1. */\n\t\t\t\tfb_mul(p->y, t1, p->x);\n\t\t\t\tfb_set_dig(p->z, 1);\n\n\t\t\t\tp->coord = BASIC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Now, multiply by cofactor to get the correct group. */\n\t\teb_curve_get_cof(k);\n\t\tif (bn_bits(k) < RLC_DIG) {\n\t\t\teb_mul_dig(p, p, k->dp[0]);\n\t\t} else {\n\t\t\teb_mul(p, p, k);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfb_free(t0);\n\t\tfb_free(t1);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of point multiplication on binary elliptic curves.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n#include \"relic_fb_low.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EB_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EB_KBLTZ)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-TNAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_ltnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, l, n;\n\tint8_t tnaf[RLC_FB_BITS + 8], u;\n\teb_t t[1 << (EB_WIDTH - 2)];\n\n\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\tu = -1;\n\t} else {\n\t\tu = 1;\n\t}\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t, p, EB_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tl = sizeof(tnaf);\n\t\tbn_rec_tnaf(tnaf, &l, k, u, RLC_FB_BITS, EB_WIDTH);\n\n\t\tn = tnaf[l - 1];\n\t\tif (n > 0) {\n\t\t\teb_copy(r, t[n / 2]);\n\t\t} else {\n\t\t\teb_neg(r, t[-n / 2]);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\teb_frb(r, r);\n\n\t\t\tn = tnaf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\n#if defined(EB_PLAIN)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the\n * left-to-right w-NAF method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_lnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, l, n;\n\tint8_t naf[RLC_FB_BITS + 1];\n\teb_t t[1 << (EB_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t\tfb_set_dig(t[i]->z, 1);\n\t\t\tt[i]->coord = BASIC;\n\t\t}\n\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t, p, EB_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EB_WIDTH);\n\n\t\tn = naf[l - 1];\n\t\tif (n > 0) {\n\t\t\teb_copy(r, t[n / 2]);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\teb_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_PLAIN */\n#endif /* EB_MUL == LWNAF */\n\n#if EB_MUL == RWNAF || !defined(STRIP)\n\n#if defined(EB_KBLTZ)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-TNAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_rtnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, l, n;\n\tint8_t tnaf[RLC_FB_BITS + 8], u;\n\teb_t t[1 << (EB_WIDTH - 2)];\n\n\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\tu = -1;\n\t} else {\n\t\tu = 1;\n\t}\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t}\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tl = sizeof(tnaf);\n\t\tbn_rec_tnaf(tnaf, &l, k, u, RLC_FB_BITS, EB_WIDTH);\n\n\t\teb_copy(r, p);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tn = tnaf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(t[n / 2], t[n / 2], r);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(t[-n / 2], t[-n / 2], r);\n\t\t\t}\n\n\t\t\t/* We can avoid a function call here. */\n\t\t\tfb_sqr(r->x, r->x);\n\t\t\tfb_sqr(r->y, r->y);\n\t\t}\n\n\t\teb_copy(r, t[0]);\n\n#if defined(EB_MIXED) && defined(STRIP) && (EB_WIDTH > 2)\n\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (EB_WIDTH - 2)) - 1);\n#endif\n\n#if EB_WIDTH == 3\n\t\teb_frb(t[0], t[1]);\n\t\tif (u == 1) {\n\t\t\teb_sub(t[1], t[1], t[0]);\n\t\t} else {\n\t\t\teb_add(t[1], t[1], t[0]);\n\t\t}\n#endif\n\n#if EB_WIDTH == 4\n\t\teb_frb(t[0], t[3]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\n\t\tif (u == 1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[3], t[0], t[3]);\n\n\t\teb_frb(t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[1], t[0], t[1]);\n\n\t\teb_frb(t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n#endif\n\n#if EB_WIDTH == 5\n\t\teb_frb(t[0], t[3]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == 1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[3], t[0], t[3]);\n\n\t\teb_frb(t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[1], t[0], t[1]);\n\n\t\teb_frb(t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n\n\t\teb_frb(t[0], t[4]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[4]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == 1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[4], t[0], t[4]);\n\n\t\teb_frb(t[0], t[5]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[5]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_sub(t[5], t[0], t[5]);\n\n\t\teb_frb(t[0], t[6]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[6]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_add(t[6], t[0], t[6]);\n\n\t\teb_frb(t[0], t[7]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[7], t[0], t[7]);\n#endif\n\n#if EB_WIDTH == 6\n\t\teb_frb(t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[0], t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[1], t[0], t[1]);\n\n\t\teb_frb(t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[0], t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n\n\t\teb_frb(t[0], t[3]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[3]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[3], t[0], t[3]);\n\n\t\teb_frb(t[0], t[4]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[4]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[4], t[0], t[4]);\n\n\t\teb_frb(t[0], t[5]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[5]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[5], t[0], t[5]);\n\n\t\teb_frb(t[0], t[6]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[6]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[6], t[0], t[6]);\n\n\t\teb_frb(t[0], t[7]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[7], t[0], t[7]);\n\n\t\teb_frb(t[0], t[8]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[8], t[0], t[8]);\n\n\t\teb_frb(t[0], t[9]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[0], t[0], t[9]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[0], t[0], t[9]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[9]);\n\t\teb_neg(t[9], t[0]);\n\n\t\teb_frb(t[0], t[10]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[10]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[10], t[0], t[10]);\n\n\t\teb_frb(t[0], t[11]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[11], t[0], t[11]);\n\n\t\teb_frb(t[0], t[12]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[12], t[0], t[12]);\n\n\t\teb_frb(t[0], t[13]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[13]);\n\t\teb_neg(t[13], t[0]);\n\n\t\teb_frb(t[0], t[14]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_add(t[14], t[0], t[14]);\n\n\t\teb_frb(t[0], t[15]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[15], t[0], t[15]);\n#endif\n\n#if defined(EB_MIXED) && defined(STRIP) && (EB_WIDTH > 2)\n\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (EB_WIDTH - 2)) - 1);\n#endif\n\n\t\t/* Add accumulators */\n\t\tfor (i = 1; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\tif (r->coord == BASIC) {\n\t\t\t\teb_add(r, t[i], r);\n\t\t\t} else {\n\t\t\t\teb_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_KBLTZ */\n\n#if defined(EB_PLAIN)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the\n * right-to-left w-NAF method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_rnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, l, n;\n\tint8_t naf[RLC_FB_BITS + 1];\n\teb_t t[1 << (EB_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the accumulator table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t}\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EB_WIDTH);\n\n\t\teb_copy(r, p);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(t[n / 2], t[n / 2], r);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(t[-n / 2], t[-n / 2], r);\n\t\t\t}\n\n\t\t\teb_dbl(r, r);\n\t\t}\n\n\t\teb_copy(r, t[0]);\n\n#if EB_WIDTH >= 3\n\t\t/* Compute 3 * T[1]. */\n\t\teb_dbl(t[0], t[1]);\n\t\teb_add(t[1], t[0], t[1]);\n#endif\n#if EB_WIDTH >= 4\n\t\t/* Compute 5 * T[2]. */\n\t\teb_dbl(t[0], t[2]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n\n\t\t/* Compute 7 * T[3]. */\n\t\teb_dbl(t[0], t[3]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_sub(t[3], t[0], t[3]);\n#endif\n#if EB_WIDTH >= 5\n\t\t/* Compute 9 * T[4]. */\n\t\teb_dbl(t[0], t[4]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[4], t[0], t[4]);\n\n\t\t/* Compute 11 * T[5]. */\n\t\teb_dbl(t[0], t[5]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[5]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[5], t[0], t[5]);\n\n\t\t/* Compute 13 * T[6]. */\n\t\teb_dbl(t[0], t[6]);\n\t\teb_add(t[0], t[0], t[6]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[6], t[0], t[6]);\n\n\t\t/* Compute 15 * T[7]. */\n\t\teb_dbl(t[0], t[7]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_sub(t[7], t[0], t[7]);\n#endif\n#if EB_WIDTH == 6\n\t\tfor (i = 8; i < 15; i++) {\n\t\t\teb_mul_dig(t[i], t[i], 2 * i + 1);\n\t\t}\n\t\teb_dbl(t[0], t[15]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_sub(t[15], t[0], t[15]);\n#endif\n\n\t\t/* Add accumulators */\n\t\tfor (i = 1; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\tif (r->coord == BASIC) {\n\t\t\t\teb_add(r, t[i], r);\n\t\t\t} else {\n\t\t\t\teb_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the accumulator table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_PLAIN */\n#endif /* EB_MUL == RWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EB_MUL == BASIC || !defined(STRIP)\n\nvoid eb_mul_basic(eb_t r, const eb_t p, const bn_t k) {\n\teb_t t;\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\teb_null(t);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\n\t\teb_copy(t, p);\n\t\tfor (int i = bn_bits(k) - 2; i >= 0; i--) {\n\t\t\teb_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\teb_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\teb_norm(r, t);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n\n#endif\n\n#if EB_MUL == LODAH || !defined(STRIP)\n\nvoid eb_mul_lodah(eb_t r, const eb_t p, const bn_t k) {\n\tint bits, i, j;\n\tdv_t x1, z1, x2, z2, r1, r2, r3, r4, r5;\n\tconst dig_t *b;\n\tbn_t t, n;\n\n\tif (bn_is_zero(k)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(t);\n\tdv_null(x1);\n\tdv_null(z1);\n\tdv_null(x2);\n\tdv_null(z2);\n\tdv_null(r1);\n\tdv_null(r2);\n\tdv_null(r3);\n\tdv_null(r4);\n\tdv_null(r5);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(t);\n\t\tdv_new(x1);\n\t\tdv_new(z1);\n\t\tdv_new(x2);\n\t\tdv_new(z2);\n\t\tdv_new(r1);\n\t\tdv_new(r2);\n\t\tdv_new(r3);\n\t\tdv_new(r4);\n\t\tdv_new(r5);\n\n\t\tfb_sqr(z2, p->x);\n\t\tfb_sqr(x2, z2);\n\t\tdv_zero(r5, 2 * RLC_FB_DIGS);\n\n\t\tb = eb_curve_get_b();\n\t\teb_curve_get_ord(n);\n\t\tbits = bn_bits(n);\n\n\t\tbn_abs(t, k);\n\t\tbn_add(t, t, n);\n\t\tbn_add(n, t, n);\n\t\tdv_swap_cond(t->dp, n->dp, RLC_MAX(t->used, n->used),\n\t\t\tbn_get_bit(t, bits) == 0);\n\t\tt->used = RLC_SEL(t->used, n->used, bn_get_bit(t, bits) == 0);\n\n\t\tswitch (eb_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfb_add_dig(x2, x2, (dig_t)1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfb_add_dig(x2, x2, b[0]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfb_addn_low(x2, x2, b);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Blind both points independently. */\n\t\tfb_rand(z1);\n\t\tfb_mul(x1, z1, p->x);\n\t\tfb_rand(r1);\n\t\tfb_mul(z2, z2, r1);\n\t\tfb_mul(x2, x2, r1);\n\n\t\tfor (i = bits - 1; i >= 0; i--) {\n\t\t\tj = bn_get_bit(t, i);\n\t\t\tfb_mul(r1, x1, z2);\n\t\t\tfb_mul(r2, x2, z1);\n\t\t\tfb_add(r3, r1, r2);\n\t\t\tfb_muln_low(r4, r1, r2);\n\t\t\tdv_swap_cond(x1, x2, RLC_FB_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(z1, z2, RLC_FB_DIGS, j ^ 1);\n\t\t\tfb_sqr(z1, r3);\n\t\t\tfb_muln_low(r1, z1, p->x);\n\t\t\tfb_addd_low(x1, r1, r4, 2 * RLC_FB_DIGS);\n\t\t\tfb_rdcn_low(x1, x1);\n\t\t\tfb_sqr(r1, z2);\n\t\t\tfb_sqr(r2, x2);\n\t\t\tfb_mul(z2, r1, r2);\n\t\t\tswitch (eb_curve_opt_b()) {\n\t\t\t\tcase RLC_ZERO:\n\t\t\t\t\tfb_sqr(x2, r2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RLC_ONE:\n\t\t\t\t\tfb_add(r1, r1, r2);\n\t\t\t\t\tfb_sqr(x2, r1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RLC_TINY:\n\t\t\t\t\tfb_sqr(r1, r1);\n\t\t\t\t\tfb_sqrl_low(x2, r2);\n\t\t\t\t\tfb_mul1_low(r5, r1, b[0]);\n\t\t\t\t\tfb_addd_low(x2, x2, r5, RLC_FB_DIGS + 1);\n\t\t\t\t\tfb_rdcn_low(x2, x2);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfb_sqr(r1, r1);\n\t\t\t\t\tfb_sqrl_low(x2, r2);\n\t\t\t\t\tfb_muln_low(r5, r1, b);\n\t\t\t\t\tfb_addd_low(x2, x2, r5, 2 * RLC_FB_DIGS);\n\t\t\t\t\tfb_rdcn_low(x2, x2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdv_swap_cond(x1, x2, RLC_FB_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(z1, z2, RLC_FB_DIGS, j ^ 1);\n\t\t}\n\n\t\tif (fb_is_zero(z1)) {\n\t\t\t/* The point q is at infinity. */\n\t\t\teb_set_infty(r);\n\t\t} else {\n\t\t\tif (fb_is_zero(z2)) {\n\t\t\t\tfb_copy(r->x, p->x);\n\t\t\t\tfb_add(r->y, p->x, p->y);\n\t\t\t\tfb_set_dig(r->z, 1);\n\t\t\t} else {\n\t\t\t\t/* r3 = z1 * z2. */\n\t\t\t\tfb_mul(r3, z1, z2);\n\t\t\t\t/* z1 = (x1 + x * z1). */\n\t\t\t\tfb_mul(z1, z1, p->x);\n\t\t\t\tfb_add(z1, z1, x1);\n\t\t\t\t/* z2 = x * z2. */\n\t\t\t\tfb_mul(z2, z2, p->x);\n\t\t\t\t/* x1 = x1 * z2. */\n\t\t\t\tfb_mul(x1, x1, z2);\n\t\t\t\t/* z2 = (x2 + x * z2)(x1 + x * z1). */\n\t\t\t\tfb_add(z2, z2, x2);\n\t\t\t\tfb_mul(z2, z2, z1);\n\n\t\t\t\t/* r4 = (x^2 + y) * z1 * z2 + (x2 + x * z2)(x1 + x * z1). */\n\t\t\t\tfb_sqr(r4, p->x);\n\t\t\t\tfb_add(r4, r4, p->y);\n\t\t\t\tfb_mul(r4, r4, r3);\n\t\t\t\tfb_add(r4, r4, z2);\n\n\t\t\t\t/* r3 = (z1 * z2 * x)^{-1}. */\n\t\t\t\tfb_mul(r3, r3, p->x);\n\t\t\t\tfb_inv(r3, r3);\n\t\t\t\t/* r4 = (x^2 + y) * z1 * z2 + (x2 + x * z2)(x1 + x * z1) * r3. */\n\t\t\t\tfb_mul(r4, r4, r3);\n\t\t\t\t/* x2 = x1 * x * z2 * (z1 * z2 * x)^{-1} = x1/z1. */\n\t\t\t\tfb_mul(x2, x1, r3);\n\t\t\t\t/* z2 = x + x1/z1. */\n\t\t\t\tfb_add(z2, x2, p->x);\n\n\t\t\t\t/* z2 = z2 * r4 + y. */\n\t\t\t\tfb_mul(z2, z2, r4);\n\t\t\t\tfb_add(z2, z2, p->y);\n\n\t\t\t\tfb_copy(r->x, x2);\n\t\t\t\tfb_copy(r->y, z2);\n\t\t\t\tfb_set_dig(r->z, 1);\n\t\t\t}\n\t\t}\n\n\t\tr->coord = BASIC;\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(t);\n\t\tdv_free(x1);\n\t\tdv_free(z1);\n\t\tdv_free(x2);\n\t\tdv_free(z2);\n\t\tdv_free(r1);\n\t\tdv_free(r2);\n\t\tdv_free(r3);\n\t\tdv_free(r4);\n\t\tdv_free(r5);\n\t}\n}\n\n#endif /* EB_MUL == LODAH */\n\n#if EB_MUL == LWNAF || !defined(STRIP)\n\nvoid eb_mul_lwnaf(eb_t r, const eb_t p, const bn_t k) {\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\teb_mul_ltnaf_imp(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EB_PLAIN)\n\teb_mul_lnaf_imp(r, p, k);\n#endif\n}\n\n#endif\n\n#if EB_MUL == RWNAF || !defined(STRIP)\n\nvoid eb_mul_rwnaf(eb_t r, const eb_t p, const bn_t k) {\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\teb_mul_rtnaf_imp(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EB_PLAIN)\n#if defined(EB_MIXED) && defined(STRIP)\n\t/* It is impossible to run a right-to-left algorithm using ordinary curves\n\t * and only mixed additions. */\n\tRLC_THROW(ERR_NO_CONFIG);\n#else\n\teb_mul_rnaf_imp(r, p, k);\n#endif\n#endif\n}\n\n#endif\n\n#if EB_MUL == HALVE || !defined(STRIP)\n\nvoid eb_mul_halve(eb_t r, const eb_t p, const bn_t k) {\n\tint i, j, l, trc, cof;\n\tint8_t naf[RLC_FB_BITS + 1], *_k;\n\teb_t q, s, t[1 << (EB_WIDTH - 2)];\n\tbn_t n, m;\n\tfb_t u, v, w, z;\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(m);\n\tbn_null(n);\n\teb_null(q);\n\teb_null(s);\n\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t[i]);\n\t}\n\tfb_null(u);\n\tfb_null(v);\n\tfb_null(w);\n\tfb_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(m);\n\t\teb_new(q);\n\t\teb_new(s);\n\t\tfb_new(u);\n\t\tfb_new(v);\n\t\tfb_new(w);\n\t\tfb_new(z);\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t}\n\n\t\t/* Convert k to alternate representation k' = (2^{t-1}k mod n). */\n\t\teb_curve_get_ord(n);\n\t\tbn_lsh(m, k, bn_bits(n) - 1);\n\t\tbn_mod(m, m, n);\n\n\t\t/* Compute the w-NAF representation of k'. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, m, EB_WIDTH);\n\n\t\tif (naf[bn_bits(n)] == 1) {\n\t\t\teb_dbl(t[0], p);\n\t\t}\n\t\tl = bn_bits(n);\n\t\t_k = naf + l - 1;\n\n\t\teb_copy(q, p);\n\t\teb_curve_get_cof(n);\n\n\t\t/* Test if curve has a cofactor bigger than 2. */\n\t\tif (bn_cmp_dig(n, 2) == RLC_GT) {\n\t\t\tcof = 1;\n\t\t} else {\n\t\t\tcof = 0;\n\t\t}\n\n\t\ttrc = fb_trc(eb_curve_get_a());\n\n\t\tif (cof) {\n\t\t\t/* Curves with cofactor > 2, u = sqrt(a), v = Solve(u). */\n\t\t\tfb_srt(u, eb_curve_get_a());\n\t\t\tfb_slv(v, u);\n\n\t\t\tbn_rand(n, RLC_POS, l);\n\n\t\t\tfor (i = l - 1; i >= 0; i--, _k--) {\n\t\t\t\tj = *_k;\n\t\t\t\tif (j > 0) {\n\t\t\t\t\teb_norm(s, q);\n\t\t\t\t\teb_add(t[j / 2], t[j / 2], s);\n\t\t\t\t}\n\t\t\t\tif (j < 0) {\n\t\t\t\t\teb_norm(s, q);\n\t\t\t\t\teb_sub(t[-j / 2], t[-j / 2], s);\n\t\t\t\t}\n\n\t\t\t\t/* T = 1/2(Q). */\n\t\t\t\teb_hlv(s, q);\n\n\t\t\t\t/* If Tr(x_T) != Tr(a). */\n\t\t\t\tif (fb_trc(s->x) != 0) {\n\t\t\t\t\t/* z = l_t, w = sqrt(l_Q), l_T = l_T + sqrt(l_Q) + v. */\n\t\t\t\t\tfb_copy(z, s->y);\n\t\t\t\t\tfb_srt(w, q->y);\n\t\t\t\t\tfb_add(s->y, s->y, w);\n\t\t\t\t\tfb_add(s->y, s->y, v);\n\t\t\t\t\t/* z = (z + x_Q + v + sqrt(a)). */\n\t\t\t\t\tfb_add(z, z, q->x);\n\t\t\t\t\tfb_add(z, z, v);\n\t\t\t\t\tfb_add(z, z, u);\n\t\t\t\t\t/* w = sqrt(w + x_Q + l_Q + sqrt(a)). */\n\t\t\t\t\tfb_add(w, w, q->x);\n\t\t\t\t\tfb_add(w, w, q->y);\n\t\t\t\t\tfb_add(w, w, u);\n\t\t\t\t\t/* x_T = sqrt(w * z), . */\n\t\t\t\t\tfb_mul(w, w, z);\n\t\t\t\t\tfb_srt(s->x, w);\n\t\t\t\t\tfb_set_dig(s->z, 1);\n\t\t\t\t\ts->coord = HALVE;\n\t\t\t\t}\n\t\t\t\teb_copy(q, s);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = l - 1; i >= 0; i--, _k--) {\n\t\t\t\tj = *_k;\n\t\t\t\tif (j > 0) {\n\t\t\t\t\teb_norm(q, q);\n\t\t\t\t\teb_add(t[j / 2], t[j / 2], q);\n\t\t\t\t}\n\t\t\t\tif (j < 0) {\n\t\t\t\t\teb_norm(q, q);\n\t\t\t\t\teb_sub(t[-j / 2], t[-j / 2], q);\n\t\t\t\t}\n\t\t\t\teb_hlv(q, q);\n\t\t\t}\n\t\t}\n\n#if EB_WIDTH == 2\n\t\teb_norm(r, t[0]);\n#else\n\t\t/* Compute Q_i = Q_i + Q_{i+2} for i from 2^{w-1}-3 to 1. */\n\t\tfor (i = (1 << (EB_WIDTH - 1)) - 3; i >= 1; i -= 2) {\n\t\t\teb_add(t[i / 2], t[i / 2], t[(i + 2) / 2]);\n\t\t}\n\t\t/* Compute R = Q_1 + 2 * sum_{i != 1}Q_i. */\n\t\teb_copy(r, t[1]);\n\t\tfor (i = 2; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_add(r, r, t[i]);\n\t\t}\n\t\teb_dbl(r, r);\n\t\teb_add(r, r, t[0]);\n\t\teb_norm(r, r);\n#endif\n\n\t\t/* We may need to fix an error of a 2-torsion point if the curve has a\n\t\t * 4-cofactor. */\n\t\tif (cof) {\n\t\t\teb_hlv(s, r);\n\t\t\tif (fb_trc(s->x) != trc) {\n\t\t\t\tfb_zero(s->x);\n\t\t\t\tfb_srt(s->y, eb_curve_get_b());\n\t\t\t\tfb_set_dig(s->z, 1);\n\t\t\t\teb_add(r, r, s);\n\t\t\t\teb_norm(r, r);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t\tbn_free(n);\n\t\tbn_free(m);\n\t\teb_free(q);\n\t\teb_free(s);\n\t\tfb_free(u);\n\t\tfb_free(v);\n\t\tfb_free(w);\n\t\tfb_free(z);\n\t}\n}\n\n#endif\n\nvoid eb_mul_gen(eb_t r, const bn_t k) {\n#ifdef EB_PRECO\n\teb_mul_fix(r, eb_curve_get_tab(), k);\n#else\n\teb_t g;\n\n\teb_null(g);\n\n\tRLC_TRY {\n\t\teb_new(g);\n\t\teb_curve_get_gen(g);\n\t\teb_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(g);\n\t}\n#endif\n}\n\nvoid eb_mul_dig(eb_t r, const eb_t p, dig_t k) {\n\teb_t t;\n\n\tif (k == 0 || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\teb_null(t);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\n\t\teb_copy(t, p);\n\t\tfor (int i = util_bits_dig(k) - 2; i >= 0; i--) {\n\t\t\teb_dbl(t, t);\n\t\t\tif (k & ((dig_t)1 << i)) {\n\t\t\t\teb_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\teb_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on binary elliptic\n * curves.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EB_SIM == INTER || !defined(STRIP)\n\n#if defined(EB_KBLTZ)\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to a precomputed table.\n */\nstatic void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, l, l0, l1, n0, n1, w, g;\n\tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}\n\n\tRLC_TRY {\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\tu = -1;\n\t\t} else {\n\t\t\tu = 1;\n\t\t}\n\n\t\tg = (t == NULL ? 0 : 1);\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\t\teb_new(t0[i]);\n\t\t\t\teb_set_infty(t0[i]);\n\t\t\t\tfb_set_bit(t0[i]->z, 0, 1);\n\t\t\t\tt0[i]->coord = BASIC;\n\t\t\t}\n\t\t\teb_tab(t0, p, EB_WIDTH);\n\t\t\tt = (const eb_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_new(t1[i]);\n\t\t\teb_set_infty(t1[i]);\n\t\t\tfb_set_bit(t1[i]->z, 0, 1);\n\t\t\tt1[i]->coord = BASIC;\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t1, q, EB_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (g) {\n\t\t\tw = EB_DEPTH;\n\t\t} else {\n\t\t\tw = EB_WIDTH;\n\t\t}\n\n\t\tl0 = l1 = RLC_FB_BITS + 8;\n\t\tbn_rec_tnaf(tnaf0, &l0, k, u, RLC_FB_BITS, w);\n\t\tbn_rec_tnaf(tnaf1, &l1, m, u, RLC_FB_BITS, EB_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\t_k = tnaf0 + l - 1;\n\t\t_m = tnaf1 + l - 1;\n\t\tfor (i =  l0; i < l; i++) {\n\t\t\ttnaf0[i] = 0;\n\t\t}\n\t\tfor (i =  l1; i < l; i++) {\n\t\t\ttnaf1[i] = 0;\n\t\t}\n\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\ttnaf0[i] = -tnaf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\ttnaf1[i] = -tnaf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = tnaf0 + l - 1;\n\t\t_m = tnaf1 + l - 1;\n\t\teb_set_infty(r);\n\t\tfor (i =  l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\teb_frb(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\teb_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\teb_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\teb_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\teb_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\t\teb_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_KBLTZ */\n\n#if defined(EB_PLAIN)\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to a precomputed table.\n */\nstatic void eb_mul_sim_plain(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, l, l0, l1, n0, n1, w, g;\n\tint8_t naf0[RLC_FB_BITS + 1], naf1[RLC_FB_BITS + 1], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}\n\n\tRLC_TRY {\n\t\tg = (t == NULL ? 0 : 1);\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\t\teb_new(t0[i]);\n\t\t\t}\n\t\t\teb_tab(t0, p, EB_WIDTH);\n\t\t\tt = (const eb_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t1, q, EB_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tif (g) {\n\t\t\tw = EB_DEPTH;\n\t\t} else {\n\t\t\tw = EB_WIDTH;\n\t\t}\n\n\t\tl0 = l1 = RLC_FB_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EB_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\teb_set_infty(r);\n\t\tfor (i =  l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\teb_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\teb_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\teb_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\teb_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\teb_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < 1 << (EB_WIDTH - 2); i++) {\n\t\t\t\teb_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i =  0; i < 1 << (EB_WIDTH - 2); i++) {\n\t\t\teb_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_PLAIN */\n\n#endif /* EB_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EB_SIM == BASIC || !defined(STRIP)\n\nvoid eb_mul_sim_basic(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\teb_t t;\n\n\teb_null(t);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\t\teb_mul(t, q, m);\n\t\teb_mul(r, p, k);\n\t\teb_add(t, t, r);\n\t\teb_norm(r, t);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n\n#endif\n\n#if EB_SIM == TRICK || !defined(STRIP)\n\nvoid eb_mul_sim_trick(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\teb_t t0[1 << (EB_WIDTH / 2)], t1[1 << (EB_WIDTH / 2)], t[1 << EB_WIDTH];\n\tint l0, l1, w = EB_WIDTH / 2;\n\tuint8_t w0[RLC_FB_BITS], w1[RLC_FB_BITS];\n\tbn_t n;\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\teb_curve_get_ord(n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\teb_null(t0[i]);\n\t\t\teb_null(t1[i]);\n\t\t\teb_new(t0[i]);\n\t\t\teb_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EB_WIDTH); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t}\n\n\t\teb_set_infty(t0[0]);\n\t\teb_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\teb_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\teb_set_infty(t1[0]);\n\t\teb_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\teb_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\teb_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\teb_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if EB_WIDTH > 2 && defined(EB_MIXED)\n\t\teb_norm_sim(t + 1, (const eb_t *)(t + 1), (1 << EB_WIDTH) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(RLC_FB_BITS + 1, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\teb_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\teb_dbl(r, r);\n\t\t\t}\n\t\t\teb_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\teb_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\teb_free(t0[i]);\n\t\t\teb_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EB_WIDTH); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EB_SIM == INTER || !defined(STRIP)\n\nvoid eb_mul_sim_inter(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul(r, p, k);\n\t\treturn;\n\t}\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\teb_mul_sim_kbltz(r, p, k, q, m, NULL);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EB_PLAIN)\n\teb_mul_sim_plain(r, p, k, q, m, NULL);\n#endif\n}\n\n#endif\n\n#if EB_SIM == JOINT || !defined(STRIP)\n\nvoid eb_mul_sim_joint(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\teb_t t[5];\n\tint i, u_i, len, offset;\n\tint8_t jsf[2 * (RLC_FB_BITS + 1)];\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i =  0; i < 5; i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t}\n\n\t\teb_set_infty(t[0]);\n\t\teb_copy(t[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\teb_neg(t[1], t[1]);\n\t\t}\n\t\teb_copy(t[2], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(t[2], t[2]);\n\t\t}\n\t\teb_add(t[3], t[2], t[1]);\n\t\teb_sub(t[4], t[2], t[1]);\n#if defined(EB_MIXED)\n\t\teb_norm_sim(t + 3, (const eb_t*)(t + 3), 2);\n#endif\n\n\t\tlen = 2 * (RLC_FB_BITS + 1);\n\t\tbn_rec_jsf(jsf, &len, k, m);\n\n\t\teb_set_infty(r);\n\t\toffset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\teb_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\teb_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\teb_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\teb_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\teb_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\teb_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i =  0; i < 5; i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid eb_mul_sim_gen(eb_t r, const bn_t k, const eb_t q, const bn_t m) {\n\teb_t g;\n\n\teb_null(g);\n\n\tif (bn_is_zero(k)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\teb_new(g);\n\n\t\teb_curve_get_gen(g);\n\n#if defined(EB_KBLTZ)\n#if EB_SIM == INTER && EB_FIX == LWNAF && defined(EB_PRECO)\n\t\tif (eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim_kbltz(r, g, k, q, m, eb_curve_get_tab());\n\t\t}\n#else\n\t\tif (eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim(r, g, k, q, m);\n\t\t}\n#endif\n#endif\n\n#if defined(EB_PLAIN)\n#if EB_SIM == INTER && EB_FIX == LWNAF && defined(EB_PRECO)\n\t\tif (!eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim_plain(r, g, k, q, m, eb_curve_get_tab());\n\t\t}\n#else\n\t\tif (!eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim(r, g, k, q, m);\n\t\t}\n#endif\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(g);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the binary elliptic curve utilities.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n#include \"relic_eb.h\"\n#include \"relic_conf.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint eb_is_infty(const eb_t p) {\n\treturn (fb_is_zero(p->z) == 1);\n}\n\nvoid eb_set_infty(eb_t p) {\n\tfb_zero(p->x);\n\tfb_zero(p->y);\n\tfb_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid eb_copy(eb_t r, const eb_t p) {\n\tfb_copy(r->x, p->x);\n\tfb_copy(r->y, p->y);\n\tfb_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid eb_rand(eb_t p) {\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\teb_curve_get_ord(n);\n\n\t\tbn_rand_mod(k, n);\n\n\t\teb_mul_gen(p, k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid eb_rhs(fb_t rhs, const eb_t p) {\n\tfb_t t0, t1;\n\n\tfb_null(t0);\n\tfb_null(t1);\n\n\tRLC_TRY {\n\t\tfb_new(t0);\n\t\tfb_new(t1);\n\n\t\t/* t0 = x1^2. */\n\t\tfb_sqr(t0, p->x);\n\t\t/* t1 = x1^3. */\n\t\tfb_mul(t1, t0, p->x);\n\n\t\t/* t1 = x1^3 + a * x1^2 + b. */\n\t\tswitch (eb_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfb_add(t1, t1, t0);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfb_mul_dig(t0, t0, eb_curve_get_a()[0]);\n\t\t\t\tfb_add(t1, t1, t0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfb_mul(t0, t0, eb_curve_get_a());\n\t\t\t\tfb_add(t1, t1, t0);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (eb_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfb_add_dig(t1, t1, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfb_add_dig(t1, t1, eb_curve_get_b()[0]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfb_add(t1, t1, eb_curve_get_b());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfb_copy(rhs, t1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(t0);\n\t\tfb_free(t1);\n\t}\n}\n\nvoid eb_blind(eb_t r, const eb_t p) {\n\tfb_t rand;\n\n\tfb_null(rand);\n\n\tRLC_TRY {\n\t\tfb_new(rand);\n\n\t\tfb_rand(rand);\n\t\tfb_mul(r->z, p->z, rand);\n\t\tfb_mul(r->x, p->x, rand);\n\t\tfb_sqr(rand, rand);\n\t\tfb_mul(r->y, p->y, rand);\n\t\tr->coord = PROJC;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfb_free(rand);\n\t}\n}\n\nint eb_on_curve(const eb_t p) {\n\teb_t t;\n\tfb_t lhs;\n\tint r = 0;\n\n\teb_null(t);\n\tfb_null(lhs);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\t\tfb_new(lhs);\n\n\t\teb_norm(t, p);\n\n\t\tfb_mul(lhs, t->x, t->y);\n\t\teb_rhs(t->x, t);\n\t\tfb_sqr(t->y, t->y);\n\t\tfb_add(lhs, lhs, t->y);\n\t\tr = (fb_cmp(lhs, t->x) == RLC_EQ) || eb_is_infty(p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t\tfb_free(lhs);\n\t}\n\treturn r;\n}\n\nvoid eb_tab(eb_t *t, const eb_t p, int w) {\n\tint u;\n\n#if defined(EB_PLAIN)\n\tif (!eb_curve_is_kbltz()) {\n\t\tif (w > 2) {\n\t\t\teb_dbl(t[0], p);\n#if defined(EB_MIXED)\n\t\t\teb_norm(t[0], t[0]);\n#endif\n\t\t\teb_add(t[1], t[0], p);\n\t\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\t\teb_add(t[i], t[i - 1], t[0]);\n\t\t\t}\n#if defined(EB_MIXED)\n\t\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (w - 2)) - 1);\n#endif\n\t\t}\n\t\teb_copy(t[0], p);\n\t}\n#endif /* EB_PLAIN */\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\tu = (eb_curve_opt_a() == RLC_ZERO ? -1 : 1);\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (int i = 0; i < 1 << (w - 2); i++) {\n\t\t\teb_set_infty(t[i]);\n\t\t\tfb_set_dig(t[i]->z, 1);\n\t\t\tt[i]->coord = BASIC;\n\t\t}\n\n\t\tswitch (w) {\n\t\t\t/* Formulas from https://eprint.iacr.org/2014/664. */\n#if EB_DEPTH == 3 || EB_WIDTH ==  3\n\t\t\tcase 3:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\tif (u == 1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_add(t[1], t[0], p);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 4 || EB_WIDTH ==  4\n\t\t\tcase 4:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[1], t[0]);\n\t\t\t\tif (u == -1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[2], t[0], p);\n\t\t\t\teb_add(t[3], t[0], p);\n\t\t\t\teb_sub(t[1], t[1], p);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 5 || EB_WIDTH ==  5\n\t\t\tcase 5:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[1], t[0]);\n\t\t\t\tif (u == -1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[2], t[0], p);\n\t\t\t\teb_add(t[3], t[0], p);\n\t\t\t\teb_sub(t[1], t[1], p);\n\t\t\t\teb_add(t[4], t[1], t[0]);\n\t\t\t\teb_add(t[5], t[2], t[0]);\n\t\t\t\teb_add(t[6], t[3], t[0]);\n\t\t\t\teb_neg(t[7], t[5]);\n\t\t\t\teb_sub(t[7], t[7], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 6 || EB_WIDTH ==  6\n\t\t\tcase 6:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[15], t[0]);\n\t\t\t\teb_neg(t[15], t[15]);\n\t\t\t\tif (u == 1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[12], t[0], p);\n\t\t\t\teb_add(t[13], t[0], p);\n\t\t\t\teb_neg(t[6], t[12]);\n\t\t\t\teb_sub(t[6], t[6], t[0]);\n\t\t\t\teb_neg(t[5], t[13]);\n\t\t\t\teb_sub(t[5], t[5], t[0]);\n\t\t\t\teb_neg(t[7], t[5]);\n\t\t\t\teb_add(t[7], t[7], t[0]);\n\t\t\t\teb_add(t[14], t[15], p);\n\t\t\t\teb_sub(t[1], t[14], t[0]);\n\t\t\t\teb_neg(t[4], t[14]);\n\t\t\t\teb_sub(t[4], t[4], t[0]);\n\t\t\t\teb_neg(t[11], t[1]);\n\t\t\t\teb_add(t[11], t[11], t[0]);\n\t\t\t\teb_neg(t[8], t[4]);\n\t\t\t\teb_add(t[8], t[8], t[0]);\n\t\t\t\teb_neg(t[10], t[8]);\n\t\t\t\teb_sub(t[10], t[10],t[0]);\n\t\t\t\teb_add(t[15], t[1], t[15]);\n\t\t\t\teb_sub(t[2], t[15], t[0]);\n\t\t\t\teb_neg(t[3], t[15]);\n\t\t\t\teb_sub(t[3], t[3], t[0]);\n\t\t\t\teb_neg(t[9], t[3]);\n\t\t\t\teb_add(t[9], t[9], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 7 || EB_WIDTH ==  7\n\t\t\tcase 7:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[15], t[0]);\n\t\t\t\tif (u == -1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[18], t[0], p);\n\t\t\t\teb_add(t[19], t[0], p);\n\t\t\t\teb_neg(t[26], t[18]);\n\t\t\t\teb_sub(t[26], t[26], t[0]);\n\t\t\t\teb_neg(t[25], t[19]);\n\t\t\t\teb_sub(t[25], t[25], t[0]);\n\t\t\t\teb_sub(t[7], t[26], t[0]);\n\t\t\t\teb_sub(t[6], t[25], t[0]);\n\t\t\t\teb_neg(t[11], t[7]);\n\t\t\t\teb_add(t[11], t[11], t[0]);\n\t\t\t\teb_neg(t[12], t[6]);\n\t\t\t\teb_add(t[12], t[12], t[0]);\n\t\t\t\teb_add(t[30], t[11], t[0]);\n\t\t\t\teb_add(t[31], t[12], t[0]);\n\t\t\t\teb_neg(t[14], t[30]);\n\t\t\t\teb_sub(t[14], t[14], t[0]);\n\n\t\t\t\teb_sub(t[17], t[15], p);\n\t\t\t\teb_neg(t[1], t[17]);\n\t\t\t\teb_sub(t[27], t[1], t[0]);\n\t\t\t\teb_add(t[1], t[1], t[0]);\n\t\t\t\teb_add(t[20], t[1], t[0]);\n\t\t\t\teb_sub(t[8], t[27], t[0]);\n\t\t\t\teb_neg(t[24], t[20]);\n\t\t\t\teb_sub(t[24], t[24], t[0]);\n\t\t\t\teb_neg(t[10], t[8]);\n\t\t\t\teb_add(t[10], t[10], t[0]);\n\t\t\t\teb_sub(t[5], t[24], t[0]);\n\t\t\t\teb_neg(t[13], t[5]);\n\t\t\t\teb_add(t[13], t[13], t[0]);\n\t\t\t\teb_neg(t[16], t[1]);\n\t\t\t\teb_add(t[16], t[16], t[15]);\n\t\t\t\teb_neg(t[2], t[16]);\n\t\t\t\teb_sub(t[28], t[2], t[0]);\n\t\t\t\teb_add(t[2], t[2], t[0]);\n\t\t\t\teb_add(t[21], t[2], t[0]);\n\t\t\t\teb_sub(t[9], t[28], t[0]);\n\t\t\t\teb_neg(t[23], t[21]);\n\t\t\t\teb_sub(t[23], t[23], t[0]);\n\t\t\t\teb_sub(t[4], t[23], t[0]);\n\t\t\t\teb_neg(t[3], t[2]);\n\t\t\t\teb_add(t[15], t[3], t[15]);\n\t\t\t\teb_neg(t[3], t[15]);\n\t\t\t\teb_add(t[3], t[3], t[0]);\n\t\t\t\teb_neg(t[29], t[15]);\n\t\t\t\teb_sub(t[29], t[29], t[0]);\n\t\t\t\teb_add(t[22], t[3], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 8 || EB_WIDTH ==  8\n\t\t\tcase 8:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[57], t[0]);\n\t\t\t\teb_neg(t[57], t[57]);\n\t\t\t\tif (u == 1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[44], t[0], p);\n\t\t\t\teb_add(t[45], t[0], p);\n\t\t\t\teb_neg(t[38], t[44]);\n\t\t\t\teb_sub(t[38], t[38], t[0]);\n\t\t\t\teb_neg(t[37], t[45]);\n\t\t\t\teb_sub(t[37], t[37], t[0]);\n\t\t\t\teb_neg(t[6], t[38]);\n\t\t\t\teb_add(t[6], t[6], t[0]);\n\n\t\t\t\teb_neg(t[7], t[37]);\n\t\t\t\teb_add(t[7], t[7], t[0]);\n\t\t\t\teb_add(t[51], t[6], t[0]);\n\t\t\t\teb_add(t[52], t[7], t[0]);\n\t\t\t\teb_neg(t[31], t[51]);\n\t\t\t\teb_sub(t[31], t[31], t[0]);\n\t\t\t\teb_neg(t[30], t[52]);\n\t\t\t\teb_sub(t[30], t[30], t[0]);\n\t\t\t\teb_neg(t[13], t[31]);\n\t\t\t\teb_add(t[13], t[13], t[0]);\n\t\t\t\teb_neg(t[14], t[30]);\n\t\t\t\teb_add(t[14], t[14], t[0]);\n\t\t\t\teb_add(t[58], t[13], t[0]);\n\t\t\t\teb_add(t[59], t[14], t[0]);\n\t\t\t\teb_neg(t[24], t[58]);\n\t\t\t\teb_sub(t[24], t[24], t[0]);\n\t\t\t\teb_neg(t[23], t[59]);\n\t\t\t\teb_sub(t[23], t[23], t[0]);\n\t\t\t\teb_add(t[46], t[57], p);\n\t\t\t\teb_sub(t[1], t[46], t[0]);\n\t\t\t\teb_neg(t[36], t[46]);\n\t\t\t\teb_sub(t[36], t[36], t[0]);\n\t\t\t\teb_neg(t[43], t[1]);\n\t\t\t\teb_add(t[43], t[43], t[0]);\n\t\t\t\teb_neg(t[8], t[36]);\n\t\t\t\teb_add(t[8], t[8], t[0]);\n\t\t\t\teb_neg(t[39], t[43]);\n\t\t\t\teb_sub(t[39], t[39], t[0]);\n\t\t\t\teb_add(t[53], t[8], t[0]);\n\t\t\t\teb_neg(t[5], t[39]);\n\t\t\t\teb_add(t[5], t[5], t[0]);\n\t\t\t\teb_neg(t[29], t[53]);\n\t\t\t\teb_sub(t[29], t[29], t[0]);\n\t\t\t\teb_add(t[50], t[5], t[0]);\n\t\t\t\teb_neg(t[15], t[29]);\n\t\t\t\teb_add(t[15], t[15], t[0]);\n\t\t\t\teb_neg(t[32], t[50]);\n\t\t\t\teb_sub(t[32], t[32], t[0]);\n\t\t\t\teb_add(t[60], t[15], t[0]);\n\t\t\t\teb_neg(t[12], t[32]);\n\t\t\t\teb_add(t[12], t[12], t[0]);\n\t\t\t\teb_neg(t[22], t[60]);\n\t\t\t\teb_sub(t[22], t[22], t[0]);\n\t\t\t\teb_add(t[47], t[1], t[57]);\n\t\t\t\teb_sub(t[2], t[47], t[0]);\n\t\t\t\teb_neg(t[35], t[47]);\n\t\t\t\teb_sub(t[35], t[35], t[0]);\n\t\t\t\teb_neg(t[42], t[2]);\n\t\t\t\teb_add(t[42], t[42], t[0]);\n\t\t\t\teb_neg(t[9], t[35]);\n\t\t\t\teb_add(t[9], t[9], t[0]);\n\t\t\t\teb_neg(t[40], t[42]);\n\t\t\t\teb_sub(t[40], t[40], t[0]);\n\t\t\t\teb_add(t[54], t[9], t[0]);\n\t\t\t\teb_neg(t[4], t[40]);\n\t\t\t\teb_add(t[4], t[4], t[0]);\n\t\t\t\teb_neg(t[28], t[54]);\n\t\t\t\teb_sub(t[28], t[28], t[0]);\n\t\t\t\teb_neg(t[16], t[28]);\n\t\t\t\teb_add(t[16], t[16], t[0]);\n\t\t\t\teb_add(t[61], t[16], t[0]);\n\t\t\t\teb_neg(t[21], t[61]);\n\t\t\t\teb_sub(t[21], t[21], t[0]);\n\t\t\t\teb_add(t[48], t[2], t[57]);\n\t\t\t\teb_sub(t[3], t[48], t[0]);\n\t\t\t\teb_neg(t[34], t[48]);\n\t\t\t\teb_sub(t[34], t[34], t[0]);\n\t\t\t\teb_neg(t[41], t[3]);\n\t\t\t\teb_add(t[41], t[41], t[0]);\n\t\t\t\teb_neg(t[10], t[34]);\n\t\t\t\teb_add(t[10], t[10], t[0]);\n\t\t\t\teb_add(t[55], t[10], t[0]);\n\t\t\t\teb_neg(t[27], t[55]);\n\t\t\t\teb_sub(t[27], t[27], t[0]);\n\t\t\t\teb_neg(t[17], t[27]);\n\t\t\t\teb_add(t[17], t[17], t[0]);\n\t\t\t\teb_add(t[62], t[17], t[0]);\n\t\t\t\teb_neg(t[20], t[62]);\n\t\t\t\teb_sub(t[20], t[20], t[0]);\n\t\t\t\teb_add(t[49], t[3], t[57]);\n\t\t\t\teb_neg(t[33], t[49]);\n\t\t\t\teb_sub(t[33], t[33], t[0]);\n\t\t\t\teb_neg(t[11], t[33]);\n\t\t\t\teb_add(t[11], t[11], t[0]);\n\t\t\t\teb_add(t[56], t[11], t[0]);\n\t\t\t\teb_neg(t[26], t[56]);\n\t\t\t\teb_sub(t[26], t[26], t[0]);\n\t\t\t\teb_neg(t[18], t[26]);\n\t\t\t\teb_add(t[18], t[18], t[0]);\n\t\t\t\teb_add(t[63], t[18], t[0]);\n\t\t\t\teb_add(t[57], t[11], t[57]);\n\t\t\t\teb_neg(t[25], t[57]);\n\t\t\t\teb_sub(t[25], t[25], t[0]);\n\t\t\t\teb_neg(t[19], t[25]);\n\t\t\t\teb_add(t[19], t[19], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n\t\t}\n#if defined(EB_MIXED)\n\t\tif (w > 2) {\n\t\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (w - 2)) - 1);\n\t\t}\n#endif\n\t}\n#endif /* EB_KBLTZ */\n}\n\nvoid eb_print(const eb_t p) {\n\tfb_print(p->x);\n\tfb_print(p->y);\n\tfb_print(p->z);\n}\n\nint eb_size_bin(const eb_t a, int pack) {\n\tint size = 0;\n\n\tif (eb_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tsize = 1 + RLC_FB_BYTES;\n\tif (!pack) {\n\t\tsize += RLC_FB_BYTES;\n\t}\n\n\treturn size;\n}\n\nvoid eb_read_bin(eb_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\teb_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (RLC_FB_BYTES + 1) && len != (2 * RLC_FB_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfb_set_dig(a->z, 1);\n\tfb_read_bin(a->x, bin + 1, RLC_FB_BYTES);\n\tif (len == RLC_FB_BYTES + 1) {\n\t\tswitch(bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfb_zero(a->y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfb_zero(a->y);\n\t\t\t\tfb_set_bit(a->y, 0, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\teb_upk(a, a);\n\t}\n\n\tif (len == 2 * RLC_FB_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfb_read_bin(a->y, bin + RLC_FB_BYTES + 1, RLC_FB_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!eb_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\nvoid eb_write_bin(uint8_t *bin, int len, const eb_t a, int pack) {\n\teb_t t;\n\n\teb_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (eb_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\teb_new(t);\n\n\t\teb_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < RLC_FB_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\teb_pck(t, t);\n\t\t\t\tbin[0] = 2 | fb_get_bit(t->y, 0);\n\t\t\t\tfb_write_bin(bin + 1, RLC_FB_BYTES, t->x);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FB_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfb_write_bin(bin + 1, RLC_FB_BYTES, t->x);\n\t\t\t\tfb_write_bin(bin + RLC_FB_BYTES + 1, RLC_FB_BYTES, t->y);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\nvoid ed_map_ell2_5mod8(ed_t p, fp_t t) {\n\tbn_t h;\n\tfp_t tv1, tv2, tv3, tv4, tv5;\n\tbn_null(h);\n\tfp_null(tv1);\n\tfp_null(tv2);\n\tfp_null(tv3);\n\tfp_null(tv4);\n\tfp_null(tv5);\n\n\t/* aliases to make code easier to read */\n\tctx_t *ctx = core_get();\n\tdig_t *c_2exp = ctx->ed_map_c[0];\n\tdig_t *sqrt_M1 = ctx->ed_map_c[1];\n\tdig_t *sqrt_M486664 = ctx->ed_map_c[2];\n\tdig_t *c_486662 = ctx->ed_map_c[3];\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tfp_new(tv1);\n\t\tfp_new(tv2);\n\t\tfp_new(tv3);\n\t\tfp_new(tv4);\n\t\tfp_new(tv5);\n\n\t\t/* set h = (p - 5) / 8 */\n\t\th->used = RLC_FP_DIGS;\n\t\th->sign = RLC_POS;\n\t\tdv_copy(h->dp, fp_prime_get(), RLC_FP_DIGS); /* p */\n\t\tbn_sub_dig(h, h, 5);                         /* p - 5 */\n\t\tbn_rsh(h, h, 3);                             /* (p - 5) / 8 */\n\n\t\t/* start evaluating map */\n\t\tfp_sqr(tv1, t);\n\t\tfp_dbl(tv1, tv1);\n\t\tfp_add_dig(tv3, tv1, 1);\n\t\tfp_sqr(tv2, tv3);\n\t\tfp_mul(p->z, tv2, tv3);\n\n\t\t/* compute numerator of g(x1) */\n\t\tfp_sqr(tv4, c_486662);\n\t\tfp_mul(tv4, tv4, tv1);\n\t\tfp_sub(tv4, tv4, tv2);\n\t\tfp_mul(tv4, tv4, c_486662);\n\n\t\t/* compute divsrqt */\n\t\tfp_sqr(tv3, p->z);\n\t\tfp_sqr(tv2, tv3);\n\t\tfp_mul(tv3, tv3, p->z);\n\t\tfp_mul(tv3, tv3, tv4);\n\t\tfp_mul(tv2, tv2, tv3);\n\t\tfp_exp(tv2, tv2, h);\n\t\tfp_mul(tv2, tv2, tv3);\n\n\t\t/* figure out which sqrt we should keep */\n\t\tfp_mul(p->y, tv2, sqrt_M1);\n\t\tfp_sqr(p->x, tv2);\n\t\tfp_mul(p->x, p->x, p->z);\n\t\t{\n\t\t\tconst int e1 = fp_cmp(p->x, tv4);\n\t\t\tdv_copy_cond(p->y, tv2, RLC_FP_DIGS, e1 == RLC_EQ);\n\t\t} /* e1 goes out of scope */\n\n\t\t/* compute numerator of g(x2) */\n\t\tfp_mul(tv3, tv2, t);\n\t\tfp_mul(tv3, tv3, c_2exp);\n\t\tfp_mul(tv5, tv3, sqrt_M1);\n\n\t\t/* figure out which sqrt we should keep */\n\t\tfp_mul(p->x, tv4, tv1);\n\t\tfp_sqr(tv2, tv3);\n\t\tfp_mul(tv2, tv2, p->z);\n\t\t{\n\t\t\tconst int e2 = fp_cmp(p->x, tv2);\n\t\t\tdv_copy_cond(tv5, tv3, RLC_FP_DIGS, e2 == RLC_EQ);\n\t\t} /* e2 goes out of scope */\n\n\t\t/* figure out whether we wanted y1 or y2 and x1 or x2 */\n\t\tfp_sqr(tv2, p->y);\n\t\tfp_mul(tv2, tv2, p->z);\n\t\t{\n\t\t\tconst int e3 = fp_cmp(tv2, tv4);\n\t\t\tfp_set_dig(p->x, 1);\n\t\t\tdv_copy_cond(p->x, tv1, RLC_FP_DIGS, e3 != RLC_EQ);\n\t\t\tfp_mul(p->x, p->x, c_486662);\n\t\t\tfp_neg(p->x, p->x);\n\t\t\tdv_copy_cond(p->y, tv5, RLC_FP_DIGS, e3 != RLC_EQ);\n\n\t\t\t/* fix sign of y */\n\t\t\tfp_prime_back(h, p->y);\n\t\t\tconst int e4 = bn_get_bit(h, 0);\n\t\t\tfp_neg(tv2, p->y);\n\t\t\tdv_copy_cond(p->y, tv2, RLC_FP_DIGS, (e3 == RLC_EQ) ^ (e4 == 1));\n\t\t} /* e3 and e4 go out of scope */\n\t\tfp_add_dig(p->z, tv1, 1);\n\n\t\t/* convert to an Edwards point */\n\t\t/* tmp1 = xnumerator = sqrt_M486664 * x */\n\t\tfp_mul(tv1, p->x, sqrt_M486664); /* xn = sqrt(-486664) * x */\n\t\tfp_mul(tv2, p->y, p->z);         /* xd = y * z */\n\t\tfp_sub(tv3, p->x, p->z);         /* yn = x - z */\n\t\tfp_add(tv4, p->x, p->z);         /* yd = x + z */\n\n\t\tfp_mul(p->z, tv2, tv4);\n\t\tfp_mul(p->x, tv1, tv4);\n\t\tfp_mul(p->y, tv2, tv3);\n\t\t{\n\t\t\t/* exceptional case: either denominator == 0 */\n\t\t\tconst int e4 = fp_is_zero(p->z);\n\t\t\tfp_set_dig(tv5, 1);\n\t\t\tdv_copy_cond(p->x, p->z, RLC_FP_DIGS, e4); /* set x to 0 */\n\t\t\tdv_copy_cond(p->y, tv5, RLC_FP_DIGS, e4);\n\t\t\tdv_copy_cond(p->z, tv5, RLC_FP_DIGS, e4);\n\t\t} /* e4 goes out of scope */\n\n\t\t/* clear denominator / compute extended coordinates if necessary */\n#if ED_ADD == EXTND || ED_ADD == PROJC\n\t\tp->coord = PROJC;\n#if ED_ADD == EXTND\n\t\t/* extended coordinates: T * Z == X * Y */\n\t\tfp_mul(p->t, p->x, p->y);\n\t\tfp_mul(p->x, p->x, p->z);\n\t\tfp_mul(p->y, p->y, p->z);\n\t\tfp_sqr(p->z, p->z);\n#endif /* ED_ADD == EXTND */\n#else  /* ED_ADD == BASIC */\n\t\tfp_inv(tv1, p->z);\n\t\tfp_mul(p->x, p->x, tv1);\n\t\tfp_mul(p->y, p->y, tv1);\n\t\tfp_set_dig(p->z, 1);\n\t\tp->coord = BASIC;\n#endif /* ED_ADD */\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT)\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(h);\n\t\tfp_free(tv1);\n\t\tfp_free(tv2);\n\t\tfp_free(tv3);\n\t\tfp_free(tv4);\n\t\tfp_free(tv5);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ed_map_dst(ed_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len) {\n\tbn_t k;\n\tfp_t t;\n\ted_t q;\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ed_param_level() + 7) / 8;\n\tuint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 2 * len_per_elm);\n\n\tbn_null(k);\n\tfp_null(t);\n\ted_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tfp_new(t);\n\t\ted_new(q);\n\n\t\t/* pseudorandom string */\n\t\tmd_xmd(pseudo_random_bytes, 2 * len_per_elm, msg, len, dst, dst_len);\n\n#define ED_MAP_CONVERT_BYTES(IDX)                                                        \\\n\tdo {                                                                                 \\\n\t\tbn_read_bin(k, pseudo_random_bytes + IDX * len_per_elm, len_per_elm);            \\\n\t\tfp_prime_conv(t, k);                                                             \\\n\t} while (0)\n\n\t\t/* first map invocation */\n\t\tED_MAP_CONVERT_BYTES(0);\n\t\ted_map_ell2_5mod8(p, t);\n\n\t\t/* second map invocation */\n\t\tED_MAP_CONVERT_BYTES(1);\n\t\ted_map_ell2_5mod8(q, t);\n\n#undef ED_MAP_CONVERT_BYTES\n\n\t\ted_add(p, p, q);\n\n\t\t/* clear cofactor */\n\t\tswitch (ed_param_get()) {\n\t\t\tcase CURVE_ED25519:\n\t\t\t\ted_dbl(p, p);\n\t\t\t\ted_dbl(p, p);\n\t\t\t\ted_dbl(p, p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\n\t\ted_norm(p, p);\n#if ED_ADD == EXTND\n\t\tfp_mul(p->t, p->x, p->y);\n#endif\n\t\tp->coord = BASIC;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfp_free(t);\n\t\ted_free(q);\n\t\tRLC_FREE(pseudo_random_bytes);\n\t}\n}\n\nvoid ed_map(ed_t p, const uint8_t *msg, int len) {\n\ted_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the point multiplication on Twisted Edwards elliptic curves.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if ED_MUL == LWNAF || !defined(STRIP)\n\nstatic void ed_mul_naf_imp(ed_t r, const ed_t p, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\ted_t t[1 << (ED_WIDTH - 2)];\n\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\ted_tab(t, p, ED_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i > 0; i--) {\n\t\t\tn = naf[i];\n\t\t\tif (n == 0) {\n\t\t\t\t/* This point will be doubled in the next iteration. */\n#if ED_ADD == EXTND\n\t\t\t\tr->coord = EXTND;\n#endif\n\t\t\t}\n\t\t\ted_dbl(r, r);\n\t\t\tif (n > 0) {\n\t\t\t\ted_add(r, r, t[n / 2]);\n\t\t\t} else if (n < 0) {\n\t\t\t\ted_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\n\t\t/* Last iteration. */\n\t\tn = naf[0];\n\t\ted_dbl(r, r);\n\t\tif (n > 0) {\n\t\t\ted_add(r, r, t[n / 2]);\n\t\t} else if (n < 0) {\n\t\t\ted_sub(r, r, t[-n / 2]);\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* ED_MUL == LWNAF */\n\n#if ED_MUL == LWREG || !defined(STRIP)\n\nstatic void ed_mul_reg_imp(ed_t r, const ed_t p, const bn_t k) {\n\tbn_t _k;\n\tint i, j, l, n;\n\tint8_t s, reg[RLC_CEIL(RLC_FP_BITS + 1, ED_WIDTH - 1)];\n\ted_t t[1 << (ED_WIDTH - 2)], u, v;\n\n\tbn_null(_k);\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(_k);\n\t\ted_new(u);\n\t\ted_new(v);\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\ted_tab(t, p, ED_WIDTH);\n\n\t\t/* Make a copy of the scalar for processing. */\n\t\tbn_abs(_k, k);\n\t\t_k->dp[0] |= bn_is_even(_k);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = RLC_CEIL(RLC_FP_BITS + 1, ED_WIDTH - 1);\n\t\tbn_rec_reg(reg, &l, _k, RLC_FP_BITS, ED_WIDTH);\n\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tfor (j = 0; j < ED_WIDTH - 1; j++) {\n#if ED_ADD == EXTND\n\t\t\t\tr->coord = EXTND;\n#endif\n\t\t\t\ted_dbl(r, r);\n\t\t\t}\n\n\t\t\tn = reg[i];\n\t\t\ts = (n >> 7);\n\t\t\tn = ((n ^ s) - s) >> 1;\n\n\t\t\tfor (j = 0; j < (1 << (EP_WIDTH - 2)); j++) {\n\t\t\t\tdv_copy_cond(u->x, t[j]->x, RLC_FP_DIGS, j == n);\n\t\t\t\tdv_copy_cond(u->y, t[j]->y, RLC_FP_DIGS, j == n);\n\t\t\t\tdv_copy_cond(u->z, t[j]->z, RLC_FP_DIGS, j == n);\n\t\t\t}\n\t\t\ted_neg(v, u);\n\t\t\tdv_copy_cond(u->x, v->x, RLC_FP_DIGS, s != 0);\n\t\t\ted_add(r, r, u);\n\t\t}\n\n\t\t/* t[0] has an unmodified copy of p. */\n\t\ted_sub(u, r, t[0]);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, bn_is_even(k));\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t\ted_neg(u, r);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, bn_sign(k) == RLC_NEG);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t\tbn_free(_k);\n\t}\n}\n\n#endif /* ED_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if ED_MUL == BASIC || !defined(STRIP)\n\nvoid ed_mul_basic(ed_t r, const ed_t p, const bn_t k) {\n\ted_t t;\n\n\ted_null(t);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t);\n\n\t\ted_copy(t, p);\n\t\tfor (int i = bn_bits(k) - 2; i >= 0; i--) {\n\t\t\ted_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\ted_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\ted_norm(r, t);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t}\n}\n\n#endif\n\n#if ED_MUL == SLIDE || !defined(STRIP)\n\nvoid ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n\ted_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\ted_null(q);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\n\t\ted_new(q);\n\n\t\ted_copy(t[0], p);\n\t\ted_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\ted_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\ted_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\ted_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\ted_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\ted_dbl(q, q);\n\t\t\t\t}\n\t\t\t\ted_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\ted_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t\ted_free(q);\n\t}\n}\n\n#endif\n\n#if ED_MUL == MONTY || !defined(STRIP)\n\nvoid ed_mul_monty(ed_t r, const ed_t p, const bn_t k) {\n\ted_t t[2];\n\n\ted_null(t[0]);\n\ted_null(t[1]);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t[0]);\n\t\ted_new(t[1]);\n\n\t\ted_set_infty(t[0]);\n\t\ted_copy(t[1], p);\n\n\t\tfor (int i = bn_bits(k) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(k, i);\n\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n#if ED_ADD == EXTND\n\t\t\tdv_swap_cond(t[0]->t, t[1]->t, RLC_FP_DIGS, j ^ 1);\n#endif\n\t\t\ted_add(t[0], t[0], t[1]);\n\t\t\ted_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n#if ED_ADD == EXTND\n\t\t\tdv_swap_cond(t[0]->t, t[1]->t, RLC_FP_DIGS, j ^ 1);\n#endif\n\t\t}\n\n\t\ted_norm(r, t[0]);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t[1]);\n\t\ted_free(t[0]);\n\t}\n}\n\n#endif\n\n#if ED_MUL == LWNAF || !defined(STRIP)\n\nvoid ed_mul_lwnaf(ed_t r, const ed_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\ted_mul_naf_imp(r, p, k);\n}\n\n#endif\n\n#if ED_MUL == LWREG || !defined(STRIP)\n\nvoid ed_mul_lwreg(ed_t r, const ed_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\ted_mul_reg_imp(r, p, k);\n}\n\n#endif\n\nvoid ed_mul_gen(ed_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n#ifdef ED_PRECO\n\ted_mul_fix(r, ed_curve_get_tab(), k);\n#else\n\ted_t g;\n\n\ted_null(g);\n\n\tRLC_TRY {\n\t\ted_new(g);\n\t\ted_curve_get_gen(g);\n\t\ted_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(g);\n\t}\n#endif\n}\n\nvoid ed_mul_dig(ed_t r, const ed_t p, dig_t k) {\n\ted_t t;\n\tbn_t _k;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\ted_null(t);\n\tbn_null(_k);\n\n\tif (k == 0 || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t);\n\t\tbn_new(_k);\n\n\t\tbn_set_dig(_k, k);\n\n\t\tl = RLC_DIG + 1;\n\t\tbn_rec_naf(naf, &l, _k, 2);\n\n\t\ted_set_infty(t);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\ted_dbl(t, t);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\ted_add(t, t, p);\n\t\t\t} else if (u < 0) {\n\t\t\t\ted_sub(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\ted_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t\tbn_free(_k);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on prime elliptic Edwards curves.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if ED_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF mixed coordinate\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ed_mul_fix_plain(ed_t r, const ed_t * t, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1], *_k;\n\n\t/* Compute the w-TNAF representation of k. */\n\tl = RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &l, k, ED_DEPTH);\n\n\t_k = naf + l - 1;\n\ted_set_infty(r);\n\tfor (i = l - 1; i >= 0; i--, _k--) {\n\t\tn = *_k;\n\t\tif (n == 0) {\n\t\t\t/* doubling is followed by another doubling */\n\t\t\tif (i > 0) {\n\t\t\t\tr->coord = EXTND;\n\t\t\t\ted_dbl(r, r);\n\t\t\t} else {\n\t\t\t\t/* use full extended coordinate doubling for last step */\n\t\t\t\ted_dbl(r, r);\n\t\t\t}\n\t\t} else {\n\t\t\ted_dbl(r, r);\n\t\t\tif (n > 0) {\n\t\t\t\ted_add(r, r, t[n / 2]);\n\t\t\t} else if (n < 0) {\n\t\t\t\ted_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\ted_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\ted_neg(r, r);\n\t}\n}\n\n#endif /* ED_FIX == LWNAF */\n\n#if ED_FIX == COMBS || !defined(STRIP)\n\n/**\n * Multiplies a prime elliptic curve point by an integer using the COMBS\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ed_mul_combs_plain(ed_t r, const ed_t * t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % ED_DEPTH) == 0 ? (l / ED_DEPTH) : (l / ED_DEPTH) + 1);\n\n\t\tn0 = bn_bits(k);\n\n\t\tp0 = (ED_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\t\ted_copy(r, t[w]);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\ted_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\ted_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif /* ED_FIX == COMBS */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if ED_FIX == BASIC || !defined(STRIP)\n\nvoid ed_mul_pre_basic(ed_t * t, const ed_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\n\t\ted_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\ted_dbl(t[i], t[i - 1]);\n\t\t}\n\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, bn_bits(n) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_mul_fix_basic(ed_t r, const ed_t *t, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\ted_set_infty(r);\n\n\tfor (int i = 0; i < bn_bits(k); i++) {\n\t\tif (bn_get_bit(k, i)) {\n\t\t\ted_add(r, r, t[i]);\n\t\t}\n\t}\n\ted_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\ted_neg(r, r);\n\t}\n}\n\n#endif\n\n#if ED_FIX == COMBS || !defined(STRIP)\n\nvoid ed_mul_pre_combs(ed_t * t, const ed_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % ED_DEPTH) == 0 ? (l / ED_DEPTH) : (l / ED_DEPTH) + 1);\n\n\t\ted_set_infty(t[0]);\n\n\t\ted_copy(t[1], p);\n\t\tfor (j = 1; j < ED_DEPTH; j++) {\n\t\t\ted_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\ted_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(ED_MIXED)\n\t\t\ted_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\ted_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\n\t\ted_norm_sim(t + 2, (const ed_t *)t + 2, RLC_ED_TABLE_COMBS - 2);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_mul_fix_combs(ed_t r, const ed_t * t, const bn_t k) {\n\ted_mul_combs_plain(r, t, k);\n}\n#endif\n\n#if ED_FIX == COMBD || !defined(STRIP)\n\nvoid ed_mul_pre_combd(ed_t * t, const ed_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % ED_DEPTH) == 0 ? (d / ED_DEPTH) : (d / ED_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\ted_set_infty(t[0]);\n\t\ted_copy(t[1], p);\n\t\tfor (j = 1; j < ED_DEPTH; j++) {\n\t\t\ted_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\ted_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(ED_MIXED)\n\t\t\ted_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\ted_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\ted_set_infty(t[1 << ED_DEPTH]);\n\t\tfor (j = 1; j < (1 << ED_DEPTH); j++) {\n\t\t\ted_dbl(t[(1 << ED_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\ted_dbl(t[(1 << ED_DEPTH) + j], t[(1 << ED_DEPTH) + j]);\n\t\t\t}\n\t\t}\n\n\t\ted_norm_sim(t + 2, (const ed_t *)t + 2, (1 << ED_DEPTH) - 2);\n\t\ted_norm_sim(t + (1 << ED_DEPTH) + 1,\n\t\t\t\t(const ed_t *)t + (1 << ED_DEPTH) + 1, (1 << ED_DEPTH) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_mul_fix_combd(ed_t r, const ed_t * t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % ED_DEPTH) == 0 ? (d / ED_DEPTH) : (d / ED_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\ted_set_infty(r);\n\t\tn0 = bn_bits(k);\n\n\t\tp1 = (e - 1) + (ED_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ted_add(r, r, t[w0]);\n\t\t\ted_add(r, r, t[(1 << ED_DEPTH) + w1]);\n\t\t}\n\t\ted_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif\n\n#if ED_FIX == LWNAF || !defined(STRIP)\n\nvoid ed_mul_pre_lwnaf(ed_t * t, const ed_t p) {\n\ted_tab(t, p, ED_DEPTH);\n}\n\nvoid ed_mul_fix_lwnaf(ed_t r, const ed_t * t, const bn_t k) {\n\ted_mul_fix_plain(r, t, k);\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on binary elliptic\n * curves.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if ED_SIM == INTER || !defined(STRIP)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m, const ed_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\ted_t t0[1 << (ED_WIDTH - 2)];\n\ted_t t1[1 << (ED_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\t\ted_null(t0[i]);\n\t\t\t\ted_new(t0[i]);\n\t\t\t}\n\t\t\ted_tab(t0, p, ED_WIDTH);\n\t\t\tt = (const ed_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_null(t1[i]);\n\t\t\ted_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\ted_tab(t1, q, ED_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = ED_DEPTH;\n\t\t} else {\n\t\t\tw = ED_WIDTH;\n\t\t}\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, ED_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\ted_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\ted_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\ted_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\ted_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\ted_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < 1 << (ED_WIDTH - 2); i++) {\n\t\t\t\ted_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 1 << (ED_WIDTH - 2); i++) {\n\t\t\ted_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* ED_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if ED_SIM == BASIC || !defined(STRIP)\n\nvoid ed_mul_sim_basic(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t;\n\n\ted_null(t);\n\n\tRLC_TRY {\n\t\ted_new(t);\n\t\ted_mul(t, q, m);\n\t\ted_mul(r, p, k);\n\t\ted_add(t, t, r);\n\t\ted_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t}\n}\n\n#endif\n\n#if ED_SIM == TRICK || !defined(STRIP)\n\nvoid ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tint l0, l1, w = ED_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\ted_null(t0[i]);\n\t\t\ted_null(t1[i]);\n\t\t\ted_new(t0[i]);\n\t\t\ted_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << ED_WIDTH); i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\n\t\ted_set_infty(t0[0]);\n\t\ted_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\ted_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\ted_set_infty(t1[0]);\n\t\ted_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\ted_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 1; i < (1 << w); i++) {\n\t\t\ted_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\ted_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if defined(ED_MIXED)\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (ED_WIDTH)) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(RLC_FP_BITS, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\ted_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ted_dbl(r, r);\n\t\t\t}\n\t\t\ted_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\ted_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\ted_free(t0[i]);\n\t\t\ted_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << ED_WIDTH); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if ED_SIM == INTER || !defined(STRIP)\n\nvoid ed_mul_sim_inter(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);\n\t\treturn;\n\t}\n\n\ted_mul_sim_plain(r, p, k, q, m, NULL);\n}\n\n#endif\n\n#if ED_SIM == JOINT || !defined(STRIP)\n\nvoid ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t[5];\n\tint i, l, u_i, offset;\n\tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\n\t\ted_set_infty(t[0]);\n\t\ted_copy(t[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\ted_neg(t[1], t[1]);\n\t\t}\n\t\ted_copy(t[2], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(t[2], t[2]);\n\t\t}\n\t\ted_add(t[3], t[2], t[1]);\n\t\ted_sub(t[4], t[2], t[1]);\n#if defined(ED_MIXED)\n\t\ted_norm_sim(t + 3, (const ed_t *)t + 3, 2);\n#endif\n\n\t\tl = 2 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, k, m);\n\n\t\ted_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\ted_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\ted_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\ted_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\ted_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ted_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ed_mul_sim_gen(ed_t r, const bn_t k, const ed_t q, const bn_t m) {\n\ted_t g;\n\n\ted_null(g);\n\n\tif (bn_is_zero(k)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(g);\n\n\t\ted_curve_get_gen(g);\n\n#if ED_SIM == INTER && ED_FIX == LWNAF && defined(ED_PRECO)\n\t\ted_mul_sim_plain(r, g, k, q, m, ed_curve_get_tab());\n#else\n\t\ted_mul_sim(r, g, k, q, m);\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(g);\n\t}\n}\n\nvoid ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tint8_t *naf = NULL;\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ted_null(_p[i]);\n\t\t\ted_new(_p[i]);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t_l[i] = l;\n\t\t\ted_norm(_p[i], p[i]);\n\t\t\tbn_rec_naf(&naf[i*l], &_l[i], k[i], 2);\n\t\t\tif (bn_sign(k[i]) == RLC_NEG) {\n\t\t\t\ted_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t}\n\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (naf[j*l + i] > 0) {\n\t\t\t\t\ted_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf[j*l + i] < 0) {\n\t\t\t\t\ted_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ted_free(_p[i]);\n\t\t}\n\t\tRLC_FREE(_l);\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(naf);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Edwards elliptic curve utilities.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include <assert.h>\n\n#include \"relic_core.h\"\n#include \"relic_label.h\"\n#include \"relic_md.h\"\n\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ed_is_infty(const ed_t p) {\n\tfp_t t;\n\tint r = 0;\n\n\tfp_null(t);\n\n\tif (p->coord == BASIC) {\n\t\treturn (fp_is_zero(p->x) && (fp_cmp_dig(p->y, 1) == RLC_EQ));\n\t}\n\n\tif (fp_is_zero(p->z)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tfp_new(t);\n\t\tfp_inv(t, p->z);\n\t\tfp_mul(t, p->y, t);\n\t\tif (fp_is_zero(p->x) && (fp_cmp_dig(t, 1) == RLC_EQ)) {\n\t\t\tr = 1;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(t);\n\t}\n\n\treturn r;\n}\n\nvoid ed_set_infty(ed_t p) {\n\tfp_zero(p->x);\n\tfp_set_dig(p->y, 1);\n\tfp_set_dig(p->z, 1);\n#if ED_ADD == EXTND\n\tfp_zero(p->t);\n#endif\n\tp->coord = PROJC;\n}\n\nvoid ed_copy(ed_t r, const ed_t p) {\n\tfp_copy(r->x, p->x);\n\tfp_copy(r->y, p->y);\n\tfp_copy(r->z, p->z);\n#if ED_ADD == EXTND\n\tfp_copy(r->t, p->t);\n#endif\n\n\tr->coord = p->coord;\n}\n\nvoid ed_rand(ed_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\ted_mul_gen(p, k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_blind(ed_t r, const ed_t p) {\n\tfp_t rand;\n\n\tfp_null(rand);\n\n\tRLC_TRY {\n\t\tfp_new(rand);\n\t\tfp_rand(rand);\n#if ED_ADD == BASIC\n\t\t(void)rand;\n\t\ted_copy(r, p);\n#elif ED_ADD == PROJC || ED_ADD == EXTND\n\t\tfp_mul(r->x, p->x, rand);\n\t\tfp_mul(r->y, p->y, rand);\n\t\tfp_mul(r->z, p->z, rand);\n\t\tr->coord = PROJC;\n#endif\n#if ED_ADD == EXTND\n\t\tfp_mul(r->t, p->t, rand);\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(rand);\n\t}\n}\n\nvoid ed_rhs(fp_t rhs, const ed_t p) {\n\tfp_t t0, t1;\n\n\tfp_null(t0);\n\tfp_null(t1);\n\n\tRLC_TRY {\n\t\tfp_new(t0);\n\t\tfp_new(t1);\n\n\t\t// 1 = a * X^2 + Y^2 - d * X^2 * Y^2\n\t\tfp_sqr(t0, p->x);\n\t\tfp_mul(t0, t0, core_get()->ed_a);\n\t\tfp_sqr(t1, p->y);\n\t\tfp_add(t1, t1, t0);\n\t\tfp_mul(t0, p->x, p->y);\n\t\tfp_sqr(t0, t0);\n\t\tfp_mul(t0, t0, core_get()->ed_d);\n\t\tfp_sub(rhs, t1, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(t0);\n\t\tfp_free(t1);\n\t}\n}\n\nint ed_on_curve(const ed_t p) {\n\ted_t t;\n\tint r = 0;\n\n\ted_null(t);\n\n\tif (fp_is_zero(p->z)) {\n\t\tr = 0;\n\t} else {\n\t\tRLC_TRY {\n\t\t\ted_new(t);\n\t\t\ted_norm(t, p);\n\n\t\t\ted_rhs(t->z, t);\n#if ED_ADD == EXTND\n\t\t\tfp_mul(t->y, t->x, t->y);\n\t\t\tr = ((fp_cmp_dig(t->z, 1) == RLC_EQ) &&\n\t\t\t\t\t(fp_cmp(t->y, t->t) == RLC_EQ)) || ed_is_infty(p);\n#else\n\t\t\tr = (fp_cmp_dig(t->z, 1) == RLC_EQ) || ed_is_infty(p);\n#endif\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\ted_free(t);\n\t\t}\n\t}\n\treturn r;\n}\n\nvoid ed_tab(ed_t * t, const ed_t p, int w) {\n\tif (w > 2) {\n\t\ted_dbl(t[0], p);\n#if defined(ED_MIXED)\n\t\ted_norm(t[0], t[0]);\n#endif\n\t\ted_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\ted_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(ED_MIXED)\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\ted_copy(t[0], p);\n}\n\nvoid ed_print(const ed_t p) {\n\tfp_print(p->x);\n\tfp_print(p->y);\n#if ED_ADD == EXTND\n\tfp_print(p->t);\n#endif\n\tfp_print(p->z);\n}\n\nint ed_size_bin(const ed_t a, int pack) {\n\tint size = 0;\n\n\tif (ed_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tsize = 1 + RLC_FP_BYTES;\n\tif (!pack) {\n\t\tsize += RLC_FP_BYTES;\n\t}\n\n\treturn size;\n}\n\nvoid ed_read_bin(ed_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\ted_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (RLC_FP_BYTES + 1) && len != (2 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp_set_dig(a->z, 1);\n\tfp_read_bin(a->y, bin + 1, RLC_FP_BYTES);\n\tif (len == RLC_FP_BYTES + 1) {\n\t\tswitch (bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfp_zero(a->x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfp_zero(a->x);\n\t\t\t\tfp_set_bit(a->x, 0, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\ted_upk(a, a);\n\t}\n\n\tif (len == 2 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp_read_bin(a->x, bin + RLC_FP_BYTES + 1, RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n#if ED_ADD == EXTND\n\tfp_mul(a->t, a->x, a->y);\n\tfp_mul(a->x, a->x, a->z);\n\tfp_mul(a->y, a->y, a->z);\n\tfp_sqr(a->z, a->z);\n#endif\n\n\tif (!ed_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n}\n\nvoid ed_write_bin(uint8_t *bin, int len, const ed_t a, int pack) {\n\ted_t t;\n\n\ted_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ed_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t);\n\n\t\ted_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\ted_pck(t, t);\n\t\t\t\tbin[0] = 2 | fp_get_bit(t->x, 0);\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->y);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->y);\n\t\t\t\tfp_write_bin(bin + RLC_FP_BYTES + 1, RLC_FP_BYTES, t->x);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve.\n *\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"relic_tmpl_map.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#ifdef EP_CTMAP\n\n/**\n * Evaluate a polynomial represented by its coefficients over a using Horner's\n * rule. Might promove to an API if needed elsewhere in the future.\n *\n * @param[out] c\t\t- the result.\n * @param[in] a\t\t\t- the input value.\n * @param[in] coeffs\t- the vector of coefficients in the polynomial.\n * @param[in] deg \t\t- the degree of the polynomial.\n */\nTMPL_MAP_HORNER(fp, fp_st)\n/**\n * Generic isogeny map evaluation for use with SSWU map.\n */\n\t\tTMPL_MAP_ISOGENY_MAP(ep, fp, iso)\n#endif /* EP_CTMAP */\n/**\n * Simplified SWU mapping from Section 4 of\n * \"Fast and simple constant-time hashing to the BLS12-381 Elliptic Curve\"\n */\n#define EP_MAP_COPY_COND(O, I, C) dv_copy_cond(O, I, RLC_FP_DIGS, C)\n\t\tTMPL_MAP_SSWU(ep, fp, dig_t, EP_MAP_COPY_COND)\n/**\n * Shallue--van de Woestijne map, based on the definition from\n * draft-irtf-cfrg-hash-to-curve-06, Section 6.6.1\n */\nTMPL_MAP_SVDW(ep, fp, dig_t, EP_MAP_COPY_COND)\n#undef EP_MAP_COPY_COND\n/* caution: this function overwrites k, which it uses as an auxiliary variable */\nstatic inline int fp_sgn0(const fp_t t, bn_t k) {\n\tfp_prime_back(k, t);\n\treturn bn_get_bit(k, 0);\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {\n\tbn_t k;\n\tfp_t t;\n\tep_t q;\n\tint neg;\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\n\tbn_null(k);\n\tfp_null(t);\n\tep_null(q);\n\n\tRLC_TRY {\n\t\tif (len != 2 * len_per_elm) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\n\t\tbn_new(k);\n\t\tfp_new(t);\n\t\tep_new(q);\n\n\t\t/* figure out which hash function to use */\n\t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep_t, fp_t) =(ep_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n\n#define EP_MAP_CONVERT_BYTES(IDX)                                       \\\n    do {                                                                \\\n      bn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);   \\\n      fp_prime_conv(t, k);                                              \\\n    } while (0)\n\n#define EP_MAP_APPLY_MAP(PT)                                    \\\n    do {                                                        \\\n      /* check sign of t */                                     \\\n      neg = fp_sgn0(t, k);                                      \\\n      /* convert */                                             \\\n      map_fn(PT, t);                                            \\\n      /* compare sign of y and sign of t; fix if necessary */   \\\n      neg = neg != fp_sgn0(PT->y, k);                             \\\n      fp_neg(t, PT->y);                                          \\\n      dv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);                  \\\n    } while (0)\n\n\t\t/* first map invocation */\n\t\tEP_MAP_CONVERT_BYTES(0);\n\t\tEP_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, p);\n\n\t\t/* second map invocation */\n\t\tEP_MAP_CONVERT_BYTES(1);\n\t\tEP_MAP_APPLY_MAP(q);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, q);\n\n\t\t/* XXX(rsw) could add p and q and then apply isomap,\n\t\t * but need ep_add to support addition on isogeny curves */\n\n#undef EP_MAP_CONVERT_BYTES\n#undef EP_MAP_APPLY_MAP\n\n\t\t/* sum the result */\n\t\tep_add(p, p, q);\n\t\tep_norm(p, p);\n\n\t\t/* clear cofactor */\n\t\tswitch (ep_curve_is_pairf()) {\n\t\t\tcase EP_BN:\n\t\t\t\t/* h = 1 */\n\t\t\t\tbreak;\n\t\t\tcase EP_B12:\n\t\t\tcase EP_B24:\n\t\t\t\t/* Multiply by (1-x) to get the correct group, as proven in\n\t\t\t\t * Piellard. https://eprint.iacr.org/2022/352.pdf */\n\t\t\t\tfp_prime_get_par(k);\n\t\t\t\tbn_neg(k, k);\n\t\t\t\tbn_add_dig(k, k, 1);\n\t\t\t\tif (bn_bits(k) < RLC_DIG) {\n\t\t\t\t\tep_mul_dig(p, p, k->dp[0]);\n\t\t\t\t} else {\n\t\t\t\t\tep_mul(p, p, k);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* multiply by cofactor to get the correct group. */\n\t\t\t\tep_curve_get_cof(k);\n\t\t\t\tif (bn_bits(k) < RLC_DIG) {\n\t\t\t\t\tep_mul_dig(p, p, k->dp[0]);\n\t\t\t\t} else {\n\t\t\t\t\tep_mul_basic(p, p, k);\n\t\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfp_free(t);\n\t\tep_free(q);\n\t}\n}\n\nvoid ep_map_dst(ep_t p, const uint8_t *msg, int len, const uint8_t *dst,\n\t\tint dst_len) {\n\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\tuint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 2 * len_per_elm);\n\n\tRLC_TRY {\n\t\t/* for hash_to_field, need to hash to a pseudorandom string */\n\t\t/* XXX(rsw) the below assumes that we want to use MD_MAP for hashing.\n\t\t *          Consider making the hash function a per-curve option!\n\t\t */\n\t\tmd_xmd(pseudo_random_bytes, 2 * len_per_elm, msg, len, dst, dst_len);\n\t\tep_map_from_field(p, pseudo_random_bytes, 2 * len_per_elm);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tRLC_FREE(pseudo_random_bytes);\n\t}\n}\n\nvoid ep_map(ep_t p, const uint8_t *msg, int len) {\n\tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the point multiplication on prime elliptic curves.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep_mul_glv_imp(ep_t r, const ep_t p, const bn_t k) {\n\tint l, l0, l1, i, n0, n1, s0, s1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1;\n\tbn_t n, _k, k0, k1, v1[3], v2[3];\n\tep_t q, t[1 << (EP_WIDTH - 2)];\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(k0);\n\tbn_null(k1);\n\tep_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tep_new(q);\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_rec_glv(k0, k1, _k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\ts0 = bn_sign(k0);\n\t\ts1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\n\t\tif (s0 == RLC_POS) {\n\t\t\tep_tab(t, p, EP_WIDTH);\n\t\t} else {\n\t\t\tep_neg(q, p);\n\t\t\tep_tab(t, q, EP_WIDTH);\n\t\t}\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k0, EP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, k1, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tt0 = naf0 + l - 1;\n\t\tt1 = naf1 + l - 1;\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, t0--, t1--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tn0 = *t0;\n\t\t\tn1 = *t1;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep_psi(q, t[n1 / 2]);\n\t\t\t\tif (s0 != s1) {\n\t\t\t\t\tep_neg(q, q);\n\t\t\t\t}\n\t\t\t\tep_add(r, r, q);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep_psi(q, t[-n1 / 2]);\n\t\t\t\tif (s0 != s1) {\n\t\t\t\t\tep_neg(q, q);\n\t\t\t\t}\n\t\t\t\tep_sub(r, r, q);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tbn_free(n)\n\t\tep_free(q);\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\nstatic void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n\tint i, l;\n\t/* Some of the supported prime curves have order > field. */\n\tint8_t u, naf[RLC_FP_BITS + 2];\n\tep_t t[1 << (EP_WIDTH - 2)];\n\tbn_t _k, n;\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = RLC_FP_BITS + 2;\n\t\tbn_rec_naf(naf, &l, _k, EP_WIDTH);\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\tep_add(r, r, t[u / 2]);\n\t\t\t} else if (u < 0) {\n\t\t\t\tep_sub(r, r, t[-u / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n#endif /* EP_MUL == LWNAF */\n\n#if EP_MUL == LWREG || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep_mul_reg_glv(ep_t r, const ep_t p, const bn_t k) {\n\tint i, j, l, n0, n1, s0, s1, b0, b1;\n\tint8_t _s0, _s1, reg0[RLC_FP_BITS + 1], reg1[RLC_FP_BITS + 1];\n\tbn_t n, _k, k0, k1, v1[3], v2[3];\n\tep_t q, t[1 << (EP_WIDTH - 2)], u, v, w;\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(k0);\n\tbn_null(k1);\n\tep_null(q);\n\tep_null(u);\n\tep_null(v);\n\tep_null(w);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tep_new(q);\n\t\tep_new(u);\n\t\tep_new(v);\n\t\tep_new(w);\n\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\n\t\tbn_abs(_k, k);\n\t\tbn_mod(_k, _k, n);\n\n\t\tbn_rec_glv(k0, k1, _k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\ts0 = bn_sign(k0);\n\t\ts1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\t\tb0 = bn_is_even(k0);\n\t\tb1 = bn_is_even(k1);\n\t\tk0->dp[0] |= b0;\n\t\tk1->dp[0] |= b1;\n\n\t\tep_copy(q, p);\n\t\tep_neg(t[0], p);\n\t\tdv_copy_cond(q->y, t[0]->y, RLC_FP_DIGS, s0 != RLC_POS);\n\t\tep_tab(t, q, EP_WIDTH);\n\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_reg(reg0, &l, k0, bn_bits(n)/2, EP_WIDTH);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_reg(reg1, &l, k1, bn_bits(n)/2, EP_WIDTH);\n\n#if defined(EP_MIXED)\n\t\tfp_set_dig(u->z, 1);\n\t\tfp_set_dig(w->z, 1);\n\t\tu->coord = w->coord = BASIC;\n#else\n\t\tu->coord = w->coord = EP_ADD;\n#endif\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tfor (j = 0; j < EP_WIDTH - 1; j++) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t}\n\n\t\t\tn0 = reg0[i];\n\t\t\t_s0 = (n0 >> 7);\n\t\t\tn0 = ((n0 ^ _s0) - _s0) >> 1;\n\t\t\tn1 = reg1[i];\n\t\t\t_s1 = (n1 >> 7);\n\t\t\tn1 = ((n1 ^ _s1) - _s1) >> 1;\n\n\t\t\tfor (j = 0; j < (1 << (EP_WIDTH - 2)); j++) {\n\t\t\t\tdv_copy_cond(u->x, t[j]->x, RLC_FP_DIGS, j == n0);\n\t\t\t\tdv_copy_cond(w->x, t[j]->x, RLC_FP_DIGS, j == n1);\n\t\t\t\tdv_copy_cond(u->y, t[j]->y, RLC_FP_DIGS, j == n0);\n\t\t\t\tdv_copy_cond(w->y, t[j]->y, RLC_FP_DIGS, j == n1);\n#if !defined(EP_MIXED)\n\t\t\t\tdv_copy_cond(u->z, t[j]->z, RLC_FP_DIGS, j == n0);\n\t\t\t\tdv_copy_cond(w->z, t[j]->z, RLC_FP_DIGS, j == n1);\n#endif\n\t\t\t}\n\t\t\tep_neg(v, u);\n\t\t\tdv_copy_cond(u->y, v->y, RLC_FP_DIGS, _s0 != 0);\n\t\t\tep_add(r, r, u);\n\n\t\t\tep_psi(w, w);\n\t\t\tep_neg(q, w);\n\t\t\tdv_copy_cond(w->y, q->y, RLC_FP_DIGS, s0 != s1);\n\t\t\tep_neg(q, w);\n\t\t\tdv_copy_cond(w->y, q->y, RLC_FP_DIGS, _s1 != 0);\n\t\t\tep_add(r, r, w);\n\t\t}\n\n\t\t/* t[0] has an unmodified copy of p. */\n\t\tep_sub(u, r, t[0]);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, b0);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, b0);\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, b0);\n\n\t\tep_psi(w, t[0]);\n\t\tep_neg(q, w);\n\t\tdv_copy_cond(w->y, q->y, RLC_FP_DIGS, s0 != s1);\n\t\tep_sub(u, r, w);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, b1);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, b1);\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, b1);\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tep_neg(u, r);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_sign(k) == RLC_NEG);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tbn_free(n);\n\t\tep_free(q);\n\t\tep_free(u);\n\t\tep_free(v);\n\t\tep_free(w);\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\nstatic void ep_mul_reg_imp(ep_t r, const ep_t p, const bn_t k) {\n\tbn_t _k;\n\tint i, j, l, n;\n\tint8_t s, reg[1 + RLC_CEIL(RLC_FP_BITS + 1, EP_WIDTH - 1)];\n\tep_t t[1 << (EP_WIDTH - 2)], u, v;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(_k);\n\t\tep_new(u);\n\t\tep_new(v);\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(t, p, EP_WIDTH);\n\n\t\tep_curve_get_ord(_k);\n\t\tn = bn_bits(_k);\n\n\t\t/* Make a copy of the scalar for processing. */\n\t\tbn_abs(_k, k);\n\t\t_k->dp[0] |= 1;\n\n\t\t/* Compute the regular w-NAF representation of k. */\n\t\tl = RLC_CEIL(n, EP_WIDTH - 1) + 1;\n\t\tbn_rec_reg(reg, &l, _k, n, EP_WIDTH);\n\n#if defined(EP_MIXED)\n\t\tfp_set_dig(u->z, 1);\n\t\tu->coord = BASIC;\n#else\n\t\tu->coord = EP_ADD;\n#endif\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tfor (j = 0; j < EP_WIDTH - 1; j++) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t}\n\n\t\t\tn = reg[i];\n\t\t\ts = (n >> 7);\n\t\t\tn = ((n ^ s) - s) >> 1;\n\n\t\t\tfor (j = 0; j < (1 << (EP_WIDTH - 2)); j++) {\n\t\t\t\tdv_copy_cond(u->x, t[j]->x, RLC_FP_DIGS, j == n);\n\t\t\t\tdv_copy_cond(u->y, t[j]->y, RLC_FP_DIGS, j == n);\n#if !defined(EP_MIXED)\n\t\t\t\tdv_copy_cond(u->z, t[j]->z, RLC_FP_DIGS, j == n);\n#endif\n\t\t\t}\n\t\t\tep_neg(v, u);\n\t\t\tdv_copy_cond(u->y, v->y, RLC_FP_DIGS, s != 0);\n\t\t\tep_add(r, r, u);\n\t\t}\n\t\t/* t[0] has an unmodified copy of p. */\n\t\tep_sub(u, r, t[0]);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, bn_is_even(k));\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tep_neg(u, r);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_sign(k) == RLC_NEG);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tbn_free(_k);\n\t\tep_free(u);\n\t\tep_free(v);\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n#endif /* EP_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep_mul_basic(ep_t r, const ep_t p, const bn_t k) {\n\tep_t t;\n\n\tep_null(t);\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_copy(t, p);\n\t\tfor (int i = bn_bits(k) - 2; i >= 0; i--) {\n\t\t\tep_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, t);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\nvoid ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n\tbn_t _k, n;\n\tep_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tep_null(q);\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\tep_new(q);\n\n\t\tep_copy(t[0], p);\n\t\tep_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep_norm(q, q);\n#endif\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep_norm_sim(t + 1, (const ep_t *)t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, _k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, q);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tep_free(q);\n\t}\n}\n\n#endif\n#include \"assert.h\"\n#if EP_MUL == MONTY || !defined(STRIP)\n\nvoid ep_mul_monty(ep_t r, const ep_t p, const bn_t k) {\n\tint i, j, bits;\n\tep_t t[2];\n\tbn_t n, l, _k;\n\n\tbn_null(n);\n\tbn_null(l);\n\tbn_null(_k);\n\tep_null(t[0]);\n\tep_null(t[1]);\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(l);\n\t\tbn_new(_k);\n\t\tep_new(t[0]);\n\t\tep_new(t[1]);\n\n\t\tep_curve_get_ord(n);\n\t\tbits = bn_bits(n);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_abs(l, _k);\n\t\tbn_add(l, l, n);\n\t\tbn_add(n, l, n);\n\t\tdv_swap_cond(l->dp, n->dp, RLC_MAX(l->used, n->used),\n\t\t\tbn_get_bit(l, bits) == 0);\n\t\tl->used = RLC_SEL(l->used, n->used, bn_get_bit(l, bits) == 0);\n\n\t\tep_norm(t[0], p);\n\t\tep_dbl(t[1], t[0]);\n\n\t\t/* Blind both points independently. */\n\t\tep_blind(t[0], t[0]);\n\t\tep_blind(t[1], t[1]);\n\n\t\tfor (i = bits - 1; i >= 0; i--) {\n\t\t\tj = bn_get_bit(l, i);\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n\t\t\tep_add(t[0], t[0], t[1]);\n\t\t\tep_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tep_norm(r, t[0]);\n\t\tep_neg(t[0], r);\n\t\tdv_copy_cond(r->y, t[0]->y, RLC_FP_DIGS, bn_sign(_k) == RLC_NEG);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(l);\n\t\tbn_free(_k);\n\t\tep_free(t[1]);\n\t\tep_free(t[0]);\n\t}\n}\n\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\nvoid ep_mul_lwnaf(ep_t r, const ep_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_glv_imp(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep_mul_naf_imp(r, p, k);\n#endif\n}\n\n#endif\n\n#if EP_MUL == LWREG || !defined(STRIP)\n\nvoid ep_mul_lwreg(ep_t r, const ep_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_reg_glv(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep_mul_reg_imp(r, p, k);\n#endif\n}\n\n#endif\n\nvoid ep_mul_gen(ep_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#ifdef EP_PRECO\n\tep_mul_fix(r, ep_curve_get_tab(), k);\n#else\n\tep_t g;\n\n\tep_null(g);\n\n\tRLC_TRY {\n\t\tep_new(g);\n\t\tep_curve_get_gen(g);\n\t\tep_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(g);\n\t}\n#endif\n}\n\nvoid ep_mul_dig(ep_t r, const ep_t p, dig_t k) {\n\tep_t t;\n\tbn_t _k;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tep_null(t);\n\tbn_null(_k);\n\n\tif (k == 0 || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\t\tbn_new(_k);\n\n\t\tbn_set_dig(_k, k);\n\n\t\tl = RLC_DIG + 1;\n\t\tbn_rec_naf(naf, &l, _k, 2);\n\n\t\tep_set_infty(t);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(t, t);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\tep_add(t, t, p);\n\t\t\t} else if (u < 0) {\n\t\t\t\tep_sub(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t\tbn_free(_k);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on binary elliptic curves.\n *\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep_mul_fix_plain(ep_t r, const ep_t *t, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\n\t/* Compute the w-TNAF representation of k. */\n\tl = RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &l, k, EP_DEPTH);\n\n\tn = naf[l - 1];\n\tif (n > 0) {\n\t\tep_copy(r, t[n / 2]);\n\t} else {\n\t\tep_neg(r, t[-n / 2]);\n\t}\n\n\tfor (i = l - 2; i >= 0; i--) {\n\t\tep_dbl(r, r);\n\n\t\tn = naf[i];\n\t\tif (n > 0) {\n\t\t\tep_add(r, r, t[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep_sub(r, r, t[-n / 2]);\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\tep_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep_neg(r, r);\n\t}\n}\n\n#endif /* EP_FIX == LWNAF */\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\n/**\n * Multiplies a prime elliptic curve point by an integer using the COMBS\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep_mul_combs_endom(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, j, l, w0, w1, n0, n1, p0, p1, s0, s1;\n\tbn_t n, _k, k0, k1, v1[3], v2[3];\n\tep_t u;\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(k0);\n\tbn_null(k1);\n\tep_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tep_new(u);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\t\tl = RLC_CEIL(bn_bits(n), (2 * EP_DEPTH));\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_rec_glv(k0, k1, _k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\ts0 = bn_sign(k0);\n\t\ts1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\n\t\tn0 = bn_bits(k0);\n\t\tn1 = bn_bits(k1);\n\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tep_set_infty(r);\n\t\tif (n0 > p0 + 1) {\n\t\t\tep_copy(r, t[1 << (EP_DEPTH-1)]);\n\t\t}\n\t\tif (n1 > p0 + 1) {\n\t\t\tep_psi(u, t[1 << (EP_DEPTH-1)]);\n\t\t\tep_add(r, r, u);\n\t\t}\n\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tw0 = w1 = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(k0, p1)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t\tif (p1 < n1 && bn_get_bit(k1, p1)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w0 > 0) {\n\t\t\t\tif (s0 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, t[w0]);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, t[w0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w1 > 0) {\n\t\t\t\tep_psi(u, t[w1]);\n\t\t\t\tif (s1 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, u);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tep_free(u);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n/**\n * Multiplies a prime elliptic curve point by an integer using the COMBS\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep_mul_combs_plain(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n, _k;\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\tl = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\n\t\tbn_mod(_k, k, n);\n\t\tn0 = bn_bits(_k);\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\n\t\tep_copy(r, t[w]);\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\tep_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n\n#endif /* EP_FIX == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\nvoid ep_mul_pre_basic(ep_t *t, const ep_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\n\t\tep_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\tep_dbl(t[i], t[i - 1]);\n\t\t}\n\n\t\tep_norm_sim(t + 1, (const ep_t *)t + 1, bn_bits(n) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_mul_fix_basic(ep_t r, const ep_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\tep_set_infty(r);\n\t\tfor (int i = 0; i < bn_bits(_k); i++) {\n\t\t\tif (bn_get_bit(_k, i)) {\n\t\t\t\tep_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\nvoid ep_mul_pre_combs(ep_t *t, const ep_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\t\tl = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\n#if defined(EP_ENDOM)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tl = RLC_CEIL(bn_bits(n), 2 * EP_DEPTH);\n\t\t}\n#endif\n\n\t\tep_set_infty(t[0]);\n\n\t\tep_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\tep_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\n\t\tep_norm_sim(t + 2, (const ep_t *)t + 2, RLC_EP_TABLE_COMBS - 2);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_mul_fix_combs(ep_t r, const ep_t *t, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_combs_endom(r, t, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep_mul_combs_plain(r, t, k);\n#endif\n}\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\nvoid ep_mul_pre_combd(ep_t *t, const ep_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\t\td = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep_set_infty(t[0]);\n\t\tep_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\tep_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\tep_set_infty(t[1 << EP_DEPTH]);\n\t\tfor (j = 1; j < (1 << EP_DEPTH); j++) {\n\t\t\tep_dbl(t[(1 << EP_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\tep_dbl(t[(1 << EP_DEPTH) + j], t[(1 << EP_DEPTH) + j]);\n\t\t\t}\n\t\t}\n\n\t\tep_norm_sim(t + 2, (const ep_t *)t + 2, (1 << EP_DEPTH) - 2);\n\t\tep_norm_sim(t + (1 << EP_DEPTH) + 1,\n\t\t\t\t(const ep_t *)t + (1 << EP_DEPTH) + 1, (1 << EP_DEPTH) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_mul_fix_combd(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\td = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tbn_mod(_k, k, n);\n\t\tep_set_infty(r);\n\t\tn0 = bn_bits(_k);\n\n\t\tp1 = (e - 1) + (EP_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_add(r, r, t[w0]);\n\t\t\tep_add(r, r, t[(1 << EP_DEPTH) + w1]);\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\nvoid ep_mul_pre_lwnaf(ep_t *t, const ep_t p) {\n\tep_tab(t, p, EP_DEPTH);\n}\n\nvoid ep_mul_fix_lwnaf(ep_t r, const ep_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tep_mul_fix_plain(r, t, _k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on binary elliptic\n * curves.\n *\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_SIM == INTER || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m, const ep_t *t) {\n\tint i, l, l0, l1, l2, l3, sk0, sk1, sl0, sl1, w, g = 0;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1, u;\n\tint8_t naf2[RLC_FP_BITS + 1], naf3[RLC_FP_BITS + 1], *t2, *t3;\n\tbn_t n, k0, k1, m0, m1;\n\tbn_t v1[3], v2[3];\n\tep_t v;\n\tep_t tab0[1 << (EP_WIDTH - 2)];\n\tep_t tab1[1 << (EP_WIDTH - 2)];\n\n\tbn_null(n);\n\tbn_null(k0);\n\tbn_null(k1);\n\tbn_null(m0);\n\tbn_null(m1);\n\tep_null(v);\n\n\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\tep_null(tab0[i]);\n\t\tep_null(tab1[i]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tbn_new(m0);\n\t\tbn_new(m1);\n\t\tep_new(v);\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\n\t\tbn_rec_glv(k0, k1, k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\tsk0 = bn_sign(k0);\n\t\tsk1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\n\t\tbn_rec_glv(m0, m1, m, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\tsl0 = bn_sign(m0);\n\t\tsl1 = bn_sign(m1);\n\t\tbn_abs(m0, m0);\n\t\tbn_abs(m1, m1);\n\n\t\tg = (t == NULL ? 0 : 1);\n\t\tif (!g) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep_new(tab0[i]);\n\t\t\t}\n\t\t\tep_tab(tab0, p, EP_WIDTH);\n\t\t\tt = (const ep_t *)tab0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_new(tab1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(tab1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k and l */\n\t\tif (g) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = l2 = l3 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k0, w);\n\t\tbn_rec_naf(naf1, &l1, k1, w);\n\t\tbn_rec_naf(naf2, &l2, m0, EP_WIDTH);\n\t\tbn_rec_naf(naf3, &l3, m1, EP_WIDTH);\n\n\t\tl = RLC_MAX(RLC_MAX(l0, l1), RLC_MAX(l2, l3));\n\t\tt0 = naf0 + l - 1;\n\t\tt1 = naf1 + l - 1;\n\t\tt2 = naf2 + l - 1;\n\t\tt3 = naf3 + l - 1;\n\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l2; i++) {\n\t\t\t\tnaf2[i] = -naf2[i];\n\t\t\t}\n\t\t\tfor (i =  0; i < l3; i++) {\n\t\t\t\tnaf3[i] = -naf3[i];\n\t\t\t}\n\t\t}\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, t0--, t1--, t2--, t3--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tu = *t0;\n\t\t\tif (u > 0) {\n\t\t\t\tif (sk0 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, t[u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, t[u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tif (sk0 == RLC_POS) {\n\t\t\t\t\tep_sub(r, r, t[-u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, t[-u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu = *t1;\n\t\t\tif (u > 0) {\n\t\t\t\tep_psi(v, t[u / 2]);\n\t\t\t\tif (sk1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_add(r, r, v);\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tep_psi(v, t[-u / 2]);\n\t\t\t\tif (sk1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_sub(r, r, v);\n\t\t\t}\n\n\t\t\tu = *t2;\n\t\t\tif (u > 0) {\n\t\t\t\tif (sl0 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, tab1[u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, tab1[u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tif (sl0 == RLC_POS) {\n\t\t\t\t\tep_sub(r, r, tab1[-u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, tab1[-u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu = *t3;\n\t\t\tif (u > 0) {\n\t\t\t\tep_psi(v, tab1[u / 2]);\n\t\t\t\tif (sl1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_add(r, r, v);\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tep_psi(v, tab1[-u / 2]);\n\t\t\t\tif (sl1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_sub(r, r, v);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tbn_free(m0);\n\t\tbn_free(m1);\n\t\tep_free(v);\n\n\t\tif (!g) {\n\t\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\t\tep_free(tab0[i]);\n\t\t\t}\n\t\t}\n\t\t/* Free the precomputation tables. */\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(tab1[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\t}\n}\n\n/**\n * Multiplies and adds multiple elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep_mul_sim_lot_endom(ep_t r, const ep_t p[], const bn_t k[], int n) {\n\tconst int len = RLC_FP_BITS + 1;\n\tint i, j, m, l, _l[2], sk;\n\tbn_t _k[2], q, v1[3], v2[3];\n\tint8_t ptr, *naf = RLC_ALLOCA(int8_t, 2 * n * len);\n\n\tbn_null(q);\n\n\tif (n <= 10) {\n\t\tep_t *_p = RLC_ALLOCA(ep_t, 2 * n);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tbn_null(_k[j]);\n\t\t\t\tbn_new(_k[j]);\n\t\t\t}\n\t\t\tfor (i = 0; i < 2 * n; i++) {\n\t\t\t\tep_null(_p[i]);\n\t\t\t\tep_new(_p[i]);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_null(v1[i]);\n\t\t\t\tbn_null(v2[i]);\n\t\t\t\tbn_new(v1[i]);\n\t\t\t\tbn_new(v2[i]);\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep_curve_get_ord(q);\n\t\t\tep_curve_get_v1(v1);\n\t\t\tep_curve_get_v2(v2);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tep_norm(_p[2*i], p[i]);\n\t\t\t\tep_psi(_p[2*i + 1], _p[2*i]);\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tsk = bn_sign(_k[0]);\n\t\t\t\tbn_rec_glv(_k[0], _k[1], _k[0], q, (const bn_t *)v1, (const bn_t *)v2);\n\t\t\t\tif (sk == RLC_NEG) {\n\t\t\t\t\tbn_neg(_k[0], _k[0]);\n\t\t\t\t\tbn_neg(_k[1], _k[1]);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(2*i + j)*len], &_l[j], _k[j], 2);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tep_neg(_p[2*i + j], _p[2*i + j]);\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_set_infty(r);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 2; m++) {\n\t\t\t\t\t\tif (naf[(2*j + m)*len + i] > 0) {\n\t\t\t\t\t\t\tep_add(r, r, _p[2*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[(2*j + m)*len + i] < 0) {\n\t\t\t\t\t\t\tep_sub(r, r, _p[2*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tep_norm(r, r);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(_k[0]);\n\t\t\tbn_free(_k[1]);\n\t\t\tfor (i = 0; i < 2 * n; i++) {\n\t\t\t\tep_free(_p[i]);\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_free(v1[i]);\n\t\t\t\tbn_free(v2[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst int w = RLC_MAX(2, util_bits_dig(n) - 2), c = (1 << (w - 2));\n\t\tep_t s, t, u, v, *_p = RLC_ALLOCA(ep_t, 2 * c);\n\n\t\tep_null(s);\n\t\tep_null(t);\n\t\tep_null(u);\n\t\tep_null(v);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tep_new(s);\n\t\t\tep_new(t);\n\t\t\tep_new(u);\n\t\t\tep_new(v);\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tbn_null(_k[i]);\n\t\t\t\tbn_new(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep_null(_p[i*c + j]);\n\t\t\t\t\tep_new(_p[i*c + j]);\n\t\t\t\t\tep_set_infty(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_null(v1[i]);\n\t\t\t\tbn_null(v2[i]);\n\t\t\t\tbn_new(v1[i]);\n\t\t\t\tbn_new(v2[i]);\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep_curve_get_ord(q);\n\t\t\tep_curve_get_v1(v1);\n\t\t\tep_curve_get_v2(v2);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tsk = bn_sign(_k[0]);\n\t\t\t\tbn_rec_glv(_k[0], _k[1], _k[0], q, (const bn_t *)v1, (const bn_t *)v2);\n\t\t\t\tif (sk == RLC_NEG) {\n\t\t\t\t\tbn_neg(_k[0], _k[0]);\n\t\t\t\t\tbn_neg(_k[1], _k[1]);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(2*i + j)*len], &_l[j], _k[j], w);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tfor (m = 0; m < _l[j]; m++) {\n\t\t\t\t\t\t\tnaf[(2*i + j)*len + m] = -naf[(2*i + j)*len + m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_set_infty(s);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 2; m++) {\n\t\t\t\t\t\tptr = naf[(2*j + m)*len + i];\n\t\t\t\t\t\tif (ptr != 0) {\n\t\t\t\t\t\t\tep_copy(t, p[j]);\n\t\t\t\t\t\t\tif (ptr < 0) {\n\t\t\t\t\t\t\t\tptr = -ptr;\n\t\t\t\t\t\t\t\tep_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tep_add(_p[m*c + (ptr >> 1)], _p[m*c + (ptr >> 1)], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tep_set_infty(t);\n\t\t\t\tfor (m = 1; m >= 0; m--) {\n\t\t\t\t\tep_psi(t, t);\n\t\t\t\t\tep_set_infty(u);\n\t\t\t\t\tep_set_infty(v);\n\t\t\t\t\tfor (j = c - 1; j >= 0; j--) {\n\t\t\t\t\t\tep_add(u, u, _p[m*c + j]);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tep_dbl(v, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tep_add(v, v, u);\n\t\t\t\t\t\tep_set_infty(_p[m*c + j]);\n\t\t\t\t\t}\n\t\t\t\t\tep_add(t, t, v);\n\t\t\t\t}\n\t\t\t\tep_dbl(s, s);\n\t\t\t\tep_add(s, s, t);\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep_norm(r, s);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tep_free(s);\n\t\t\tep_free(t);\n\t\t\tep_free(u);\n\t\t\tep_free(v);\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tbn_free(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep_free(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_free(v1[i]);\n\t\t\t\tbn_free(v2[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep_mul_sim_plain(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m, const ep_t *t) {\n\tint i, l, l0, l1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], n0, n1, *u, *v;\n\tep_t t0[1 << (EP_WIDTH - 2)];\n\tep_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep_null(t0[i]);\n\t\t\t\tep_new(t0[i]);\n\t\t\t}\n\t\t\tep_tab(t0, p, EP_WIDTH);\n\t\t\tt = (const ep_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t1[i]);\n\t\t\tep_new(t1[i]);\n\t\t}\n\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(t1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\tu = naf0 + l - 1;\n\t\tv = naf1 + l - 1;\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, u--, v--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tn0 = *u;\n\t\t\tn1 = *v;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\t\tep_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(t1[i]);\n\t\t}\n\t}\n}\n\n/**\n * Multiplies and adds multiple elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep_mul_sim_lot_plain(ep_t r, const ep_t p[], const bn_t k[], int n) {\n\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n\tep_t *_p = RLC_ALLOCA(ep_t, n);\n\tint8_t *naf = NULL;\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep_new(_p[i]);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t_l[i] = l;\n\t\t\tep_norm(_p[i], p[i]);\n\t\t\tbn_rec_naf(&naf[i*l], &_l[i], k[i], 2);\n\t\t\tif (bn_sign(k[i]) == RLC_NEG) {\n\t\t\t\tep_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t}\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (naf[j*l + i] > 0) {\n\t\t\t\t\tep_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf[j*l + i] < 0) {\n\t\t\t\t\tep_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tep_free(_p[i]);\n\t\t}\n\t\tRLC_FREE(_l);\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(naf);\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n\n#endif /* EP_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\nvoid ep_mul_sim_basic(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tep_t t;\n\n\tep_null(t);\n\n\tRLC_TRY {\n\t\tep_new(t);\n\t\tep_mul(t, q, m);\n\t\tep_mul(r, p, k);\n\t\tep_add(t, t, r);\n\t\tep_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\nvoid ep_mul_sim_trick(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tep_t t0[1 << (EP_WIDTH / 2)], t1[1 << (EP_WIDTH / 2)], t[1 << EP_WIDTH];\n\tbn_t n, _k, _m;\n\tint l0, l1, w = EP_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep_null(t0[i]);\n\t\t\tep_null(t1[i]);\n\t\t\tep_new(t0[i]);\n\t\t\tep_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tep_set_infty(t0[0]);\n\t\tep_copy(t0[1], p);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\tep_set_infty(t1[0]);\n\t\tep_copy(t1[1], q);\n\t\tif (bn_sign(_m) == RLC_NEG) {\n\t\t\tep_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\tep_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if EP_WIDTH > 2 && defined(EP_MIXED)\n\t\tep_norm_sim(t + 1, (const ep_t *)(t + 1), (1 << EP_WIDTH) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(RLC_FP_BITS + 1, w);\n\t\tbn_rec_win(w0, &l0, _k, w);\n\t\tbn_rec_win(w1, &l1, _m, w);\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\tep_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t}\n\t\t\tep_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\tep_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep_free(t0[i]);\n\t\t\tep_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\nvoid ep_mul_sim_inter(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tint flag = 0;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\t/* Handle this here to reduce complexity of static functions. */\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep_mul_sim_endom(r, p, _k, q, _m, NULL);\n\t\t\tflag = 1;\n\t\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\t\tif (!flag) {\n\t\t\tep_mul_sim_plain(r, p, _k, q, _m, NULL);\n\t\t}\n#endif\n\t\t(void)flag;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\nvoid ep_mul_sim_joint(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tbn_t n, _k, _m;\n\tep_t t[5];\n\tint i, l, u_i, offset;\n\tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tep_set_infty(t[0]);\n\t\tep_copy(t[1], q);\n\t\tif (bn_sign(_m) == RLC_NEG) {\n\t\t\tep_neg(t[1], t[1]);\n\t\t}\n\t\tep_copy(t[2], p);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(t[2], t[2]);\n\t\t}\n\t\tep_add(t[3], t[2], t[1]);\n\t\tep_sub(t[4], t[2], t[1]);\n#if defined(EP_MIXED)\n\t\tep_norm_sim(t + 3, (const ep_t *)t + 3, 2);\n#endif\n\n\t\tl = 2 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, _k, _m);\n\n\t\tep_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(_k), bn_bits(_m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ep_mul_sim_gen(ep_t r, const bn_t k, const ep_t q, const bn_t m) {\n\tep_t g;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tep_null(g);\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tep_new(g);\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tep_curve_get_gen(g);\n\t\tep_curve_get_ord(n);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep_mul_sim_endom(r, g, _k, q, _m, ep_curve_get_tab());\n\t\t}\n#else\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep_mul_sim_plain(r, g, _k, q, _m, ep_curve_get_tab());\n\t\t}\n#else\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(g);\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\nvoid ep_mul_sim_dig(ep_t r, const ep_t p[], const dig_t k[], int n) {\n\tep_t t;\n\tint max;\n\n\tep_null(t);\n\n\tmax = util_bits_dig(k[0]);\n\tfor (int i = 1; i < n; i++) {\n\t\tmax = RLC_MAX(max, util_bits_dig(k[i]));\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_set_infty(t);\n\t\tfor (int i = max - 1; i >= 0; i--) {\n\t\t\tep_dbl(t, t);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (k[j] & ((dig_t)1 << i)) {\n\t\t\t\t\tep_add(t, t, p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n\nvoid ep_mul_sim_lot(ep_t r, const ep_t p[], const bn_t k[], int n) {\n\tint flag = 0;\n\n\tif (n == 0) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_sim_lot_endom(r, p, k, n);\n\t\tflag = 1;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tif (!flag) {\n\t\tep_mul_sim_lot_plain(r, p, k, n);\n\t}\n#endif\n\t(void)flag;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime elliptic curve utilities.\n *\n * @version $Id$\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ep_is_infty(const ep_t p) {\n\treturn (fp_is_zero(p->z) == 1);\n}\n\nvoid ep_set_infty(ep_t p) {\n\tfp_zero(p->x);\n\tfp_zero(p->y);\n\tfp_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid ep_copy(ep_t r, const ep_t p) {\n\tfp_copy(r->x, p->x);\n\tfp_copy(r->y, p->y);\n\tfp_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid ep_rand(ep_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\tep_mul_gen(p, k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_blind(ep_t r, const ep_t p) {\n\tfp_t rand;\n\n\tfp_null(rand);\n\n\tRLC_TRY {\n\t\tfp_new(rand);\n\t\tfp_rand(rand);\n#if EP_ADD == BASIC\n\t\t(void)rand;\n\t\tep_copy(r, p);\n#elif EP_ADD == PROJC\n\t\tfp_mul(r->x, p->x, rand);\n\t\tfp_mul(r->y, p->y, rand);\n\t\tfp_mul(r->z, p->z, rand);\n\t\tr->coord = PROJC;\n#elif EP_ADD == JACOB\n\t\tfp_mul(r->z, p->z, rand);\n\t\tfp_mul(r->y, p->y, rand);\n\t\tfp_sqr(rand, rand);\n\t\tfp_mul(r->x, r->x, rand);\n\t\tfp_mul(r->y, r->y, rand);\n\t\tr->coord = JACOB;\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(rand);\n\t}\n}\n\nvoid ep_rhs(fp_t rhs, const ep_t p) {\n\tfp_t t0;\n\n\tfp_null(t0);\n\n\tRLC_TRY {\n\t\tfp_new(t0);\n\n\t\t/* t0 = x1^2. */\n\t\tfp_sqr(t0, p->x);\n\n\t\t/* t0 = x1^2 + a */\n\t\tswitch (ep_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp_add_dig(t0, t0, ep_curve_get_a()[0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp_add(t0, t0, ep_curve_get_a());\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* t0 = x1^3 + a * x */\n\t\tfp_mul(t0, t0, p->x);\n\n\t\t/* t0 = x1^3 + a * x + b */\n\t\tswitch (ep_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp_add_dig(t0, t0, ep_curve_get_b()[0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp_add(t0, t0, ep_curve_get_b());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp_copy(rhs, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(t0);\n\t}\n}\n\nint ep_on_curve(const ep_t p) {\n\tep_t t;\n\tint r = 0;\n\n\tep_null(t);\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_norm(t, p);\n\t\tep_rhs(t->x, t);\n\t\tfp_sqr(t->y, t->y);\n\t\tr = (fp_cmp(t->x, t->y) == RLC_EQ) || ep_is_infty(p);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep_free(t);\n\t}\n\treturn r;\n}\n\nvoid ep_tab(ep_t *t, const ep_t p, int w) {\n\tif (w > 2) {\n\t\tep_dbl(t[0], p);\n#if defined(EP_MIXED)\n\t\tep_norm(t[0], t[0]);\n#endif\n\t\tep_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\tep_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(EP_MIXED)\n\t\tep_norm_sim(t + 1, (const ep_t *)t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\tep_copy(t[0], p);\n}\n\nvoid ep_print(const ep_t p) {\n\tfp_print(p->x);\n\tfp_print(p->y);\n\tfp_print(p->z);\n}\n\nint ep_size_bin(const ep_t a, int pack) {\n\tint size = 0;\n\n\tif (ep_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tsize = 1 + RLC_FP_BYTES;\n\tif (!pack) {\n\t\tsize += RLC_FP_BYTES;\n\t}\n\n\treturn size;\n}\n\nvoid ep_read_bin(ep_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (RLC_FP_BYTES + 1) && len != (2 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp_set_dig(a->z, 1);\n\tfp_read_bin(a->x, bin + 1, RLC_FP_BYTES);\n\tif (len == RLC_FP_BYTES + 1) {\n\t\tswitch(bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfp_zero(a->y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfp_zero(a->y);\n\t\t\t\tfp_set_bit(a->y, 0, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\tep_upk(a, a);\n\t}\n\n\tif (len == 2 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp_read_bin(a->y, bin + RLC_FP_BYTES + 1, RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ep_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\nvoid ep_write_bin(uint8_t *bin, int len, const ep_t a, int pack) {\n\tep_t t;\n\n\tep_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ep_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tep_pck(t, t);\n\t\t\t\tbin[0] = 2 | fp_get_bit(t->y, 0);\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->x);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->x);\n\t\t\t\tfp_write_bin(bin + RLC_FP_BYTES + 1, RLC_FP_BYTES, t->y);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve over a quadratic\n * extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"relic_tmpl_map.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#ifdef EP_CTMAP\n/**\n * Evaluate a polynomial represented by its coefficients using Horner's rule.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the input value.\n * @param[in] coeffs\t\t- the vector of coefficients in the polynomial.\n * @param[in] len\t\t\t- the degree of the polynomial.\n */\nTMPL_MAP_HORNER(fp2, fp2_t)\n\n/**\n * Generic isogeny map evaluation for use with SSWU map.\n */\nTMPL_MAP_ISOGENY_MAP(ep2, fp2, iso2)\n#endif /* EP_CTMAP */\n\n/**\n * Simplified SWU mapping.\n */\n#define EP2_MAP_COPY_COND(O, I, C)                                                       \\\n\tdo {                                                                                 \\\n\t\tdv_copy_cond(O[0], I[0], RLC_FP_DIGS, C);                                        \\\n\t\tdv_copy_cond(O[1], I[1], RLC_FP_DIGS, C);                                        \\\n\t} while (0)\nTMPL_MAP_SSWU(ep2, fp2, fp_t, EP2_MAP_COPY_COND)\n\n/**\n * Shallue--van de Woestijne map.\n */\nTMPL_MAP_SVDW(ep2, fp2, fp_t, EP2_MAP_COPY_COND)\n#undef EP2_MAP_COPY_COND\n\n/* caution: this function overwrites k, which it uses as an auxiliary variable */\nstatic inline int fp2_sgn0(const fp2_t t, bn_t k) {\n\tconst int t_0_zero = fp_is_zero(t[0]);\n\n\tfp_prime_back(k, t[0]);\n\tconst int t_0_neg = bn_get_bit(k, 0);\n\n\tfp_prime_back(k, t[1]);\n\tconst int t_1_neg = bn_get_bit(k, 0);\n\n\t/* t[0] == 0 ? sgn0(t[1]) : sgn0(t[0]) */\n\treturn t_0_neg | (t_0_zero & t_1_neg);\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, int len) {\n        bn_t k;\n        fp2_t t;\n        ep2_t q;\n        int neg;\n        /* enough space for two extension field elements plus extra bytes for uniformity */\n        const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\n        bn_null(k);\n        fp2_null(t);\n        ep2_null(q);\n\n        RLC_TRY {\n                if (len != 2* len_per_elm) {\n                  RLC_THROW(ERR_NO_VALID);\n                }\n\n                bn_new(k);\n                fp2_new(t);\n                ep2_new(q);\n\n                /* which hash function should we use? */\n                const int abNeq0 = (ep2_curve_opt_a() != RLC_ZERO) && (ep2_curve_opt_b() != RLC_ZERO);\n                void (*const map_fn)(ep2_t, fp2_t) = (ep2_curve_is_ctmap() || abNeq0) ? ep2_map_sswu : ep2_map_svdw;\n\n#define EP2_MAP_CONVERT_BYTES(IDX)                                                       \\\n        do {                                                                                 \\\n                bn_read_bin(k, uniform_bytes + 2 * IDX * len_per_elm, len_per_elm);        \\\n                fp_prime_conv(t[0], k);                                                          \\\n                bn_read_bin(k, uniform_bytes + (2 * IDX + 1) * len_per_elm, len_per_elm);  \\\n                fp_prime_conv(t[1], k);                                                          \\\n        } while (0)\n\n#define EP2_MAP_APPLY_MAP(PT)                                                            \\\n        do {                                                                                 \\\n                /* sign of t */                                                                  \\\n                neg = fp2_sgn0(t, k);                                                            \\\n                /* convert */                                                                    \\\n                map_fn(PT, t);                                                                   \\\n                /* compare sign of y to sign of t; fix if necessary */                           \\\n                neg = neg != fp2_sgn0(PT->y, k);                                                 \\\n                fp2_neg(t, PT->y);                                                               \\\n                dv_copy_cond(PT->y[0], t[0], RLC_FP_DIGS, neg);                                  \\\n                dv_copy_cond(PT->y[1], t[1], RLC_FP_DIGS, neg);                                  \\\n        } while (0)\n\n                /* first map invocation */\n                EP2_MAP_CONVERT_BYTES(0);\n                EP2_MAP_APPLY_MAP(p);\n                TMPL_MAP_CALL_ISOMAP(ep2, p);\n\n                /* second map invocation */\n                EP2_MAP_CONVERT_BYTES(1);\n                EP2_MAP_APPLY_MAP(q);\n                TMPL_MAP_CALL_ISOMAP(ep2, q);\n\n                /* XXX(rsw) could add p and q and then apply isomap,\n                 * but need ep_add to support addition on isogeny curves */\n\n#undef EP2_MAP_CONVERT_BYTES\n#undef EP2_MAP_APPLY_MAP\n\n                /* sum the result */\n                ep2_add(p, p, q);\n                ep2_norm(p, p);\n                ep2_mul_cof(p, p);\n        }\n        RLC_CATCH_ANY {\n                RLC_THROW(ERR_CAUGHT);\n        }\n        RLC_FINALLY {\n                bn_free(k);\n                fp2_free(t);\n                ep2_free(q);\n        }\n}\n\n\nvoid ep2_map_dst(ep2_t p, const uint8_t *msg, int len, const uint8_t *dst, int dst_len) {\n\n        /* enough space for two field elements plus extra bytes for uniformity */\n        const int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n        uint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 4 * len_per_elm);\n\n        RLC_TRY {\n\n                /* XXX(rsw) See note in ep/relic_ep_map.c about using MD_MAP. */\n                /* hash to a pseudorandom string using md_xmd */\n                md_xmd(pseudo_random_bytes, 4 * len_per_elm, msg, len, dst, dst_len);\n                ep2_map_from_field(p, pseudo_random_bytes, 2 * len_per_elm);\n        }\n        RLC_CATCH_ANY {\n                RLC_THROW(ERR_CAUGHT);\n        }\n        RLC_FINALLY {\n                RLC_FREE(pseudo_random_bytes);\n        }\n}\n\nvoid ep2_map(ep2_t p, const uint8_t *msg, int len) {\n\tep2_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of point multiplication on prime elliptic curves over\n * quadratic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tint i, j, l, _l[4];\n\tbn_t n, _k[4], u;\n\tint8_t naf[4][RLC_FP_BITS + 1];\n\tep2_t q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tep2_null(q[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tep2_new(q[i]);\n\t\t}\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tep2_norm(q[0], p);\n\t\tep2_frb(q[1], q[0], 1);\n\t\tep2_frb(q[2], q[1], 1);\n\t\tep2_frb(q[3], q[2], 1);\n\n\t\tl = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(q[i], q[i]);\n\t\t\t}\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf[i], &_l[i], _k[i], 2);\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (j = l - 1; j >= 0; j--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tif (naf[i][j] > 0) {\n\t\t\t\t\tep2_add(r, r, q[i]);\n\t\t\t\t}\n\t\t\t\tif (naf[i][j] < 0) {\n\t\t\t\t\tep2_sub(r, r, q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tep2_free(q[i]);\n\t\t}\n\n\t}\n}\n\n#endif /* EP_ENDOM */\n\nstatic void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep2_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep2_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep2_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tep2_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n\tint i, l;\n\tep2_t t;\n\n\tep2_null(t);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tl = bn_bits(k);\n\n\t\tif (bn_get_bit(k, l - 1)) {\n\t\t\tep2_copy(t, p);\n\t\t} else {\n\t\t\tep2_set_infty(t);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep2_copy(r, t);\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\nvoid ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n\n\t\tep2_copy(t[0], p);\n\t\tep2_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}\n\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\nvoid ep2_mul_monty(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[2];\n\n\tep2_null(t[0]);\n\tep2_null(t[1]);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t[0]);\n\t\tep2_new(t[1]);\n\n\t\tep2_set_infty(t[0]);\n\t\tep2_copy(t[1], p);\n\n\t\tfor (int i = bn_bits(k) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(k, i);\n\t\t\tdv_swap_cond(t[0]->x[0], t[1]->x[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1], t[1]->x[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0], t[1]->y[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1], t[1]->y[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0], t[1]->z[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1], t[1]->z[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tep2_add(t[0], t[0], t[1]);\n\t\t\tep2_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x[0], t[1]->x[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1], t[1]->x[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0], t[1]->y[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1], t[1]->y[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0], t[1]->z[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1], t[1]->z[1], RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tep2_norm(r, t[0]);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t[1]);\n\t\tep2_free(t[0]);\n\t}\n}\n\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\nvoid ep2_mul_lwnaf(ep2_t r, const ep2_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tif (ep2_curve_opt_a() == RLC_ZERO) {\n\t\t\tep2_mul_glv_imp(r, p, k);\n\t\t} else {\n\t\t\tep2_mul_naf_imp(r, p, k);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep2_mul_naf_imp(r, p, k);\n#endif\n}\n\n#endif\n\nvoid ep2_mul_gen(ep2_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n#ifdef EP_PRECO\n\tep2_mul_fix(r, ep2_curve_get_tab(), k);\n#else\n\tep2_t g;\n\n\tep2_null(g);\n\n\tRLC_TRY {\n\t\tep2_new(g);\n\t\tep2_curve_get_gen(g);\n\t\tep2_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(g);\n\t}\n#endif\n}\n\nvoid ep2_mul_dig(ep2_t r, const ep2_t p, const dig_t k) {\n\tep2_t t;\n\tbn_t _k;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tep2_null(t);\n\tbn_null(_k);\n\n\tif (k == 0 || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tbn_new(_k);\n\n\t\tbn_set_dig(_k, k);\n\n\t\tl = RLC_DIG + 1;\n\t\tbn_rec_naf(naf, &l, _k, 2);\n\n\t\tep2_set_infty(t);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t} else if (u < 0) {\n\t\t\t\tep2_sub(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t\tbn_free(_k);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on a prime elliptic curve over\n * a quadratic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {\n\tint len, i, n;\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\t/* Compute the w-TNAF representation of k. */\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep2_set_infty(r);\n\tfor (i = len - 1; i >= 0; i--, t--) {\n\t\tep2_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep2_add(r, r, table[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep2_sub(r, r, table[-n / 2]);\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\tep2_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep2_neg(r, r);\n\t}\n}\n\n#endif /* EP_FIX == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\nvoid ep2_mul_pre_basic(ep2_t *t, const ep2_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\n\t\tep2_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\tep2_dbl(t[i], t[i - 1]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_mul_fix_basic(ep2_t r, const ep2_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = 0; i < bn_bits(_k); i++) {\n\t\t\tif (bn_get_bit(_k, i)) {\n\t\t\t\tep2_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\nvoid ep2_mul_pre_combs(ep2_t *t, const ep2_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tep2_set_infty(t[0]);\n\n\t\tep2_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep2_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\tep2_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep2_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep2_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBS; i++) {\n\t\t\tep2_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_mul_fix_combs(ep2_t r, const ep2_t *t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tbn_mod(_k, k, n);\n\t\tn0 = bn_bits(_k);\n\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\t\tep2_copy(r, t[w]);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\tep2_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\nvoid ep2_mul_pre_combd(ep2_t *t, const ep2_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep2_set_infty(t[0]);\n\t\tep2_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep2_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\tep2_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep2_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep2_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\tep2_set_infty(t[1 << EP_DEPTH]);\n\t\tfor (j = 1; j < (1 << EP_DEPTH); j++) {\n\t\t\tep2_dbl(t[(1 << EP_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\tep2_dbl(t[(1 << EP_DEPTH) + j], t[(1 << EP_DEPTH) + j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBD; i++) {\n\t\t\tep2_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_mul_fix_combd(ep2_t r, const ep2_t *t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep2_set_infty(r);\n\t\tbn_mod(_k, k, n);\n\t\tn0 = bn_bits(_k);\n\n\t\tp1 = (e - 1) + (EP_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep2_add(r, r, t[w0]);\n\t\t\tep2_add(r, r, t[(1 << EP_DEPTH) + w1]);\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\nvoid ep2_mul_pre_lwnaf(ep2_t *t, const ep2_t p) {\n\tep2_tab(t, p, EP_DEPTH);\n}\n\nvoid ep2_mul_fix_lwnaf(ep2_t r, const ep2_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tep2_mul_fix_plain(r, t, _k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on a prime elliptic\n * curve over a quadratic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_SIM == INTER || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tint i, j, l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tep2_norm(_p[0], p);\n\t\tep2_frb(_p[1], _p[0], 1);\n\t\tep2_frb(_p[2], _p[1], 1);\n\t\tep2_frb(_p[3], _p[2], 1);\n\t\tep2_norm(_q[0], q);\n\t\tep2_frb(_q[1], _q[0], 1);\n\t\tep2_frb(_q[2], _q[1], 1);\n\t\tep2_frb(_q[3], _q[2], 1);\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf1[i], &_l[i], _m[i], 2);\n\t\t\tif (bn_sign(_m[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_q[i], _q[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n\t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep2_t t0[1 << (EP_WIDTH - 2)];\n\tep2_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep2_null(t0[i]);\n\t\t\t\tep2_new(t0[i]);\n\t\t\t}\n\t\t\tep2_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep2_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t1[i]);\n\t\t\tep2_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep2_tab(t1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = 2 * RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep2_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep2_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep2_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep2_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep2_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n\n#endif /* EP_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\nvoid ep2_mul_sim_basic(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t l) {\n\tep2_t t;\n\n\tep2_null(t);\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tep2_mul(t, q, l);\n\t\tep2_mul(r, p, k);\n\t\tep2_add(t, t, r);\n\t\tep2_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\nvoid ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t m) {\n\tep2_t t0[1 << (EP_WIDTH / 2)];\n\tep2_t t1[1 << (EP_WIDTH / 2)];\n\tep2_t t[1 << EP_WIDTH];\n\tbn_t n, _k, _m;\n\tint l0, l1, w = EP_WIDTH / 2;\n\tuint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep2_null(t0[i]);\n\t\t\tep2_null(t1[i]);\n\t\t\tep2_new(t0[i]);\n\t\t\tep2_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_set_infty(t0[0]);\n\t\tep2_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep2_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\tep2_set_infty(t1[0]);\n\t\tep2_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tep2_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 1; i < (1 << w); i++) {\n\t\t\tep2_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\tep2_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH)) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(2 * RLC_FP_BITS, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tep2_dbl(r, r);\n\t\t\t}\n\t\t\tep2_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep2_free(t0[i]);\n\t\t\tep2_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\nvoid ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t m) {\n\tint flag = 0;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\t/* Handle this here to reduce complexity of static functions. */\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep2_mul_sim_endom(r, p, _k, q, _m);\n\t\t\tflag = 1;\n\t\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\t\tif (!flag) {\n\t\t\tep2_mul_sim_plain(r, p, _k, q, _m, NULL);\n\t\t}\n#endif\n\t\t(void)flag;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\nvoid ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t m) {\n\tbn_t n, _k, _m;\n\tep2_t t[5];\n\tint i, l, u_i, offset;\n\tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tep2_set_infty(t[0]);\n\t\tep2_copy(t[1], q);\n\t\tif (bn_sign(_m) == RLC_NEG) {\n\t\t\tep2_neg(t[1], t[1]);\n\t\t}\n\t\tep2_copy(t[2], p);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(t[2], t[2]);\n\t\t}\n\t\tep2_add(t[3], t[2], t[1]);\n\t\tep2_sub(t[4], t[2], t[1]);\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 3, t + 3, 2);\n#endif\n\n\t\tl = 2 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, _k, _m);\n\n\t\tep2_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(_k), bn_bits(_m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep2_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\tep2_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep2_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\tep2_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m) {\n\tep2_t g;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tep2_null(g);\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tep2_new(g);\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tep2_curve_get_gen(g);\n\t\tep2_curve_get_ord(n);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep2_mul_sim_endom(r, g, _k, q, _m, ep2_curve_get_tab());\n\t\t}\n#else\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep2_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep2_mul_sim_plain(r, g, _k, q, _m, ep2_curve_get_tab());\n\t\t}\n#else\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep2_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(g);\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\nvoid ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], int len) {\n\tep2_t t;\n\tint max;\n\n\tep2_null(t);\n\n\tmax = util_bits_dig(k[0]);\n\tfor (int i = 1; i < len; i++) {\n\t\tmax = RLC_MAX(max, util_bits_dig(k[i]));\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_set_infty(t);\n\t\tfor (int i = max - 1; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tif (k[j] & ((dig_t)1 << i)) {\n\t\t\t\t\tep2_add(t, t, p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n\nvoid ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], int n) {\n\tconst int len = RLC_FP_BITS + 1;\n\tint i, j, m, l, _l[4];\n\tbn_t _k[4], q, x;\n\tint8_t ptr, *naf = RLC_ALLOCA(int8_t, 4 * n * len);\n\n\tif (n == 0) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(q);\n\tbn_null(x);\n\n\tif (n <= 10) {\n\t\tep2_t *_p = RLC_ALLOCA(ep2_t, 4 * n);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tbn_null(_k[j]);\n\t\t\t\tbn_new(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep2_null(_p[4*i + j]);\n\t\t\t\t\tep2_new(_p[4*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep2_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tep2_norm(_p[4*i], p[i]);\n\t\t\t\tep2_frb(_p[4*i + 1], _p[4*i], 1);\n\t\t\t\tep2_frb(_p[4*i + 2], _p[4*i + 1], 1);\n\t\t\t\tep2_frb(_p[4*i + 3], _p[4*i + 2], 1);\n\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tbn_rec_frb(_k, 4, _k[0], x, q, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(4*i + j)*len], &_l[j], _k[j], 2);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tep2_neg(_p[4*i + j], _p[4*i + j]);\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep2_set_infty(r);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tep2_dbl(r, r);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 4; m++) {\n\t\t\t\t\t\tif (naf[(4*j + m)*len + i] > 0) {\n\t\t\t\t\t\t\tep2_add(r, r, _p[4*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[(4*j + m)*len + i] < 0) {\n\t\t\t\t\t\t\tep2_sub(r, r, _p[4*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep2_norm(r, r);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tbn_free(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep2_free(_p[4*i + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t} else {\n\t\tconst int w = RLC_MAX(2, util_bits_dig(n) - 2), c = (1 << (w - 2));\n\t\tep2_t s, t, u, v, *_p = RLC_ALLOCA(ep2_t, 4 * c);\n\n\t\tep2_null(s);\n\t\tep2_null(t);\n\t\tep2_null(u);\n\t\tep2_null(v);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tep2_new(s);\n\t\t\tep2_new(t);\n\t\t\tep2_new(u);\n\t\t\tep2_new(v);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_null(_k[i]);\n\t\t\t\tbn_new(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep2_null(_p[i*c + j]);\n\t\t\t\t\tep2_new(_p[i*c + j]);\n\t\t\t\t\tep2_set_infty(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep2_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tbn_rec_frb(_k, 4, _k[0], x, q, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(4*i + j)*len], &_l[j], _k[j], w);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tfor (m = 0; m < _l[j]; m++) {\n\t\t\t\t\t\t\tnaf[(4*i + j)*len + m] = -naf[(4*i + j)*len + m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep2_set_infty(s);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 4; m++) {\n\t\t\t\t\t\tptr = naf[(4*j + m)*len + i];\n\t\t\t\t\t\tif (ptr != 0) {\n\t\t\t\t\t\t\tep2_copy(t, p[j]);\n\t\t\t\t\t\t\tif (ptr < 0) {\n\t\t\t\t\t\t\t\tptr = -ptr;\n\t\t\t\t\t\t\t\tep2_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tep2_add(_p[m*c + (ptr/2)], _p[m*c + (ptr/2)], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tep2_set_infty(t);\n\t\t\t\tfor (m = 3; m >= 0; m--) {\n\t\t\t\t\tep2_frb(t, t, 1);\n\t\t\t\t\tep2_set_infty(u);\n\t\t\t\t\tep2_set_infty(v);\n\t\t\t\t\tfor (j = c - 1; j >= 0; j--) {\n\t\t\t\t\t\tep2_add(u, u, _p[m*c + j]);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tep2_dbl(v, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tep2_add(v, v, u);\n\t\t\t\t\t\tep2_set_infty(_p[m*c + j]);\n\t\t\t\t\t}\n\t\t\t\t\tep2_add(t, t, v);\n\t\t\t\t}\n\t\t\t\tep2_dbl(s, s);\n\t\t\t\tep2_add(s, s, t);\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep2_norm(r, s);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tep2_free(s);\n\t\t\tep2_free(t);\n\t\t\tep2_free(u);\n\t\t\tep2_free(v);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_free(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep2_free(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of comparison for points on prime elliptic curves over\n * quadratic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ep2_is_infty(const ep2_t p) {\n\treturn (fp2_is_zero(p->z) == 1);\n}\n\nvoid ep2_set_infty(ep2_t p) {\n\tfp2_zero(p->x);\n\tfp2_zero(p->y);\n\tfp2_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid ep2_copy(ep2_t r, const ep2_t p) {\n\tfp2_copy(r->x, p->x);\n\tfp2_copy(r->y, p->y);\n\tfp2_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid ep2_rand(ep2_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\tep2_mul_gen(p, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_blind(ep2_t r, const ep2_t p) {\n\tfp2_t rand;\n\n\tfp2_null(rand);\n\n\tRLC_TRY {\n\t\tfp2_new(rand);\n\t\tfp2_rand(rand);\n#if EP_ADD == BASIC\n\t\t(void)rand;\n\t\tep2_copy(r, p);\n#else\n\t\tfp2_mul(r->z, p->z, rand);\n\t\tfp2_mul(r->y, p->y, rand);\n\t\tfp2_sqr(rand, rand);\n\t\tfp2_mul(r->x, r->x, rand);\n\t\tfp2_mul(r->y, r->y, rand);\n\t\tr->coord = EP_ADD;\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp2_free(rand);\n\t}\n}\n\nvoid ep2_rhs(fp2_t rhs, const ep2_t p) {\n\tfp2_t t0;\n\n\tfp2_null(t0);\n\n\tRLC_TRY {\n\t\tfp2_new(t0);\n\n\t\tfp2_sqr(t0, p->x);                  /* x1^2 */\n\n\t\tswitch (ep2_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp2_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp2_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp2_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp2_mul_dig(t0, t0, ep2_curve_get_a()[0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp2_add(t0, t0, ep2_curve_get_a());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp2_mul(t0, t0, p->x);\t\t\t\t/* x1^3 + a * x */\n\n\t\tswitch (ep2_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp2_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp2_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp2_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp2_mul_dig(t0, t0, ep2_curve_get_b()[0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp2_add(t0, t0, ep2_curve_get_b());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp2_copy(rhs, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp2_free(t0);\n\t}\n}\n\n\nint ep2_on_curve(const ep2_t p) {\n\tep2_t t;\n\tint r = 0;\n\n\tep2_null(t);\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_norm(t, p);\n\n\t\tep2_rhs(t->x, t);\n\t\tfp2_sqr(t->y, t->y);\n\n\t\tr = (fp2_cmp(t->x, t->y) == RLC_EQ) || ep2_is_infty(p);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep2_free(t);\n\t}\n\treturn r;\n}\n\nvoid ep2_tab(ep2_t *t, const ep2_t p, int w) {\n\tif (w > 2) {\n\t\tep2_dbl(t[0], p);\n#if defined(EP_MIXED)\n\t\tep2_norm(t[0], t[0]);\n#endif\n\t\tep2_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\tep2_copy(t[0], p);\n}\n\nvoid ep2_print(const ep2_t p) {\n\tfp2_print(p->x);\n\tfp2_print(p->y);\n\tfp2_print(p->z);\n}\n\nint ep2_size_bin(const ep2_t a, int pack) {\n\tep2_t t;\n\tint size = 0;\n\n\tep2_null(t);\n\n\tif (ep2_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_norm(t, a);\n\n\t\tsize = 1 + 2 * RLC_FP_BYTES;\n\t\tif (!pack) {\n\t\t\tsize += 2 * RLC_FP_BYTES;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep2_free(t);\n\t}\n\n\treturn size;\n}\n\nvoid ep2_read_bin(ep2_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep2_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (2 * RLC_FP_BYTES + 1) && len != (4 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp2_set_dig(a->z, 1);\n\tfp2_read_bin(a->x, bin + 1, 2 * RLC_FP_BYTES);\n\tif (len == 2 * RLC_FP_BYTES + 1) {\n\t\tswitch(bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfp2_zero(a->y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfp2_zero(a->y);\n\t\t\t\tfp_set_bit(a->y[0], 0, 1);\n\t\t\t\tfp_zero(a->y[1]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\tep2_upk(a, a);\n\t}\n\n\tif (len == 4 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp2_read_bin(a->y, bin + 2 * RLC_FP_BYTES + 1, 2 * RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ep2_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n}\n\nvoid ep2_write_bin(uint8_t *bin, int len, const ep2_t a, int pack) {\n\tep2_t t;\n\n\tep2_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ep2_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < 2 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tep2_pck(t, t);\n\t\t\t\tbin[0] = 2 | fp_get_bit(t->y[0], 0);\n\t\t\t\tfp2_write_bin(bin + 1, 2 * RLC_FP_BYTES, t->x, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 4 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfp2_write_bin(bin + 1, 2 * RLC_FP_BYTES, t->x, 0);\n\t\t\t\tfp2_write_bin(bin + 2 * RLC_FP_BYTES + 1, 2 * RLC_FP_BYTES, t->y, 0);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve over a quadratic\n * extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep4_map(ep4_t p, const uint8_t *msg, int len) {\n\tbn_t x;\n\tfp4_t t0;\n\tuint8_t digest[RLC_MD_LEN];\n\n\tbn_null(x);\n\tfp4_null(t0);\n\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tfp4_new(t0);\n\n\t\tmd_map(digest, msg, len);\n\t\tbn_read_bin(x, digest, RLC_MIN(RLC_FP_BYTES, RLC_MD_LEN));\n\n\t\tfp4_zero(p->x);\n\t\tfp_prime_conv(p->x[0][0], x);\n\t\tfp4_set_dig(p->z, 1);\n\n\t\twhile (1) {\n\t\t\tep4_rhs(t0, p);\n\n\t\t\tif (fp4_srt(p->y, t0)) {\n\t\t\t\tp->coord = BASIC;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfp_add_dig(p->x[0][0], p->x[0][0], 1);\n\t\t}\n\n\t\tep4_mul_cof(p, p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tfp4_free(t0);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of point multiplication on prime elliptic curves over\n * quadratic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep4_mul_glv_imp(ep4_t r, const ep4_t p, const bn_t k) {\n\tint sign, i, j, l, _l[8];\n\tbn_t n, _k[8], u, v;\n\tint8_t naf[8][RLC_FP_BITS + 1];\n\tep4_t q[8];\n\n\tbn_null(n);\n\tbn_null(u);\n\tbn_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tep4_null(q[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tep4_new(q[i]);\n\t\t}\n\n        bn_abs(v, k);\n\t\tep4_curve_get_ord(n);\n        if (bn_cmp_abs(v, n) == RLC_GT) {\n            bn_mod(v, v, n);\n        }\n\n\t\tfp_prime_get_par(u);\n\t\tsign = bn_sign(u);\n        bn_abs(u, u);\n\n\t\tep4_norm(q[0], p);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tbn_mod(_k[i], v, u);\n\t\t\tbn_div(v, v, u);\n\t\t\tif ((sign == RLC_NEG) && (i % 2 != 0)) {\n\t\t\t\tbn_neg(_k[i], _k[i]);\n\t\t\t}\n            if (bn_sign(k) == RLC_NEG) {\n                bn_neg(_k[i], _k[i]);\n            }\n            if (i > 0) {\n                ep4_frb(q[i], q[i - 1], 1);\n            }\n\t\t}\n\n        l = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep4_neg(q[i], q[i]);\n\t\t\t}\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf[i], &_l[i], _k[i], 2);\n            l = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep4_set_infty(r);\n\t\tfor (j = l - 1; j >= 0; j--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif (naf[i][j] > 0) {\n\t\t\t\t\tep4_add(r, r, q[i]);\n\t\t\t\t}\n\t\t\t\tif (naf[i][j] < 0) {\n\t\t\t\t\tep4_sub(r, r, q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep4_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n        bn_free(u);\n        bn_free(v);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tep4_free(q[i]);\n\t\t}\n\n\t}\n}\n\n#endif /* EP_ENDOM */\n\nstatic void ep4_mul_naf_imp(ep4_t r, const ep4_t p, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep4_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep4_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep4_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep4_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tep4_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep4_mul_basic(ep4_t r, const ep4_t p, const bn_t k) {\n\tint i, l;\n\tep4_t t;\n\n\tep4_null(t);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\t\tl = bn_bits(k);\n\n\t\tif (bn_get_bit(k, l - 1)) {\n\t\t\tep4_copy(t, p);\n\t\t} else {\n\t\t\tep4_set_infty(t);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep4_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep4_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep4_copy(r, t);\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\nvoid ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n\tep4_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tep4_null(q);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tep4_new(q);\n\n\t\tep4_copy(t[0], p);\n\t\tep4_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep4_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep4_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep4_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep4_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep4_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep4_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep4_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t\tep4_free(q);\n\t}\n}\n\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\nvoid ep4_mul_monty(ep4_t r, const ep4_t p, const bn_t k) {\n\tep4_t t[2];\n\n\tep4_null(t[0]);\n\tep4_null(t[1]);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t[0]);\n\t\tep4_new(t[1]);\n\n\t\tep4_set_infty(t[0]);\n\t\tep4_copy(t[1], p);\n\n\t\tfor (int i = bn_bits(k) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(k, i);\n\t\t\tdv_swap_cond(t[0]->x[0][0], t[1]->x[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[0][1], t[1]->x[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][0], t[1]->x[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][1], t[1]->x[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][0], t[1]->y[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][1], t[1]->y[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][0], t[1]->y[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][1], t[1]->y[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][0], t[1]->z[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][1], t[1]->z[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][0], t[1]->z[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][1], t[1]->z[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tep4_add(t[0], t[0], t[1]);\n\t\t\tep4_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x[0][0], t[1]->x[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[0][1], t[1]->x[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][0], t[1]->x[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][1], t[1]->x[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][0], t[1]->y[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][1], t[1]->y[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][0], t[1]->y[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][1], t[1]->y[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][0], t[1]->z[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][1], t[1]->z[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][0], t[1]->z[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][1], t[1]->z[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tep4_norm(r, t[0]);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t[1]);\n\t\tep4_free(t[0]);\n\t}\n}\n\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\nvoid ep4_mul_lwnaf(ep4_t r, const ep4_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tif (ep_curve_opt_a() == RLC_ZERO) {\n\t\t\tep4_mul_glv_imp(r, p, k);\n\t\t} else {\n\t\t\tep4_mul_naf_imp(r, p, k);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep4_mul_naf_imp(r, p, k);\n#endif\n}\n\n#endif\n\nvoid ep4_mul_gen(ep4_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n#ifdef EP_PRECO\n\tep4_mul_fix(r, ep4_curve_get_tab(), k);\n#else\n\tep4_t g;\n\n\tep4_null(g);\n\n\tRLC_TRY {\n\t\tep4_new(g);\n\t\tep4_curve_get_gen(g);\n\t\tep4_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(g);\n\t}\n#endif\n}\n\nvoid ep4_mul_dig(ep4_t r, const ep4_t p, const dig_t k) {\n\tint i, l;\n\tep4_t t;\n\n\tep4_null(t);\n\n\tif (k == 0 || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tl = util_bits_dig(k);\n\n\t\tep4_copy(t, p);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep4_dbl(t, t);\n\t\t\tif (k & ((dig_t)1 << i)) {\n\t\t\t\tep4_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep4_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on a prime elliptic curve over\n * a quartic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Precomputes a table for a point multiplication on an ordinary curve.\n *\n * @param[out] t\t\t\t\t- the destination table.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n */\nstatic void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {\n\tint i;\n\n\tep4_dbl(t[0], p);\n#if defined(EP_MIXED)\n\tep4_norm(t[0], t[0]);\n#endif\n\n#if EP_DEPTH > 2\n\tep4_add(t[1], t[0], p);\n\tfor (i = 2; i < (1 << (EP_DEPTH - 2)); i++) {\n\t\tep4_add(t[i], t[i - 1], t[0]);\n\t}\n\n#if defined(EP_MIXED)\n\tfor (i = 1; i < (1 << (EP_DEPTH - 2)); i++) {\n\t\tep4_norm(t[i], t[i]);\n\t}\n#endif\n\n#endif\n\tep4_copy(t[0], p);\n}\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n\tint len, i, n;\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\t/* Compute the w-TNAF representation of k. */\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep4_set_infty(r);\n\tfor (i = len - 1; i >= 0; i--, t--) {\n\t\tep4_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep4_add(r, r, table[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep4_sub(r, r, table[-n / 2]);\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\tep4_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep4_neg(r, r);\n\t}\n}\n\n#endif /* EP_FIX == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\nvoid ep4_mul_pre_basic(ep4_t *t, const ep4_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\n\t\tep4_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\tep4_dbl(t[i], t[i - 1]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_mul_fix_basic(ep4_t r, const ep4_t *t, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tep4_set_infty(r);\n\n\tfor (int i = 0; i < bn_bits(k); i++) {\n\t\tif (bn_get_bit(k, i)) {\n\t\t\tep4_add(r, r, t[i]);\n\t\t}\n\t}\n\tep4_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep4_neg(r, r);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\nvoid ep4_mul_pre_combs(ep4_t *t, const ep4_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tep4_set_infty(t[0]);\n\n\t\tep4_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep4_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\tep4_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep4_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep4_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBS; i++) {\n\t\t\tep4_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_mul_fix_combs(ep4_t r, const ep4_t *t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tn0 = bn_bits(k);\n\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\t\tep4_copy(r, t[w]);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\tep4_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\nvoid ep4_mul_pre_combd(ep4_t *t, const ep4_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep4_set_infty(t[0]);\n\t\tep4_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep4_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\tep4_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep4_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep4_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\tep4_set_infty(t[1 << EP_DEPTH]);\n\t\tfor (j = 1; j < (1 << EP_DEPTH); j++) {\n\t\t\tep4_dbl(t[(1 << EP_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\tep4_dbl(t[(1 << EP_DEPTH) + j], t[(1 << EP_DEPTH) + j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBD; i++) {\n\t\t\tep4_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_mul_fix_combd(ep4_t r, const ep4_t *t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep4_set_infty(r);\n\t\tn0 = bn_bits(k);\n\n\t\tp1 = (e - 1) + (EP_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep4_add(r, r, t[w0]);\n\t\t\tep4_add(r, r, t[(1 << EP_DEPTH) + w1]);\n\t\t}\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\nvoid ep4_mul_pre_lwnaf(ep4_t *t, const ep4_t p) {\n\tep4_mul_pre_ordin(t, p);\n}\n\nvoid ep4_mul_fix_lwnaf(ep4_t r, const ep4_t *t, const bn_t k) {\n\tep4_mul_fix_ordin(r, t, k);\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on a prime elliptic\n * curve over a quartic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_SIM == INTER || !defined(STRIP)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_null(t0[i]);\n\t\t\t\tep4_new(t0[i]);\n\t\t\t}\n\t\t\tep4_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep4_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_null(t1[i]);\n\t\t\tep4_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep4_tab(t1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = 2 * RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\tep4_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep4_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep4_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep4_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep4_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep4_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\nvoid ep4_mul_sim_basic(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t l) {\n\tep4_t t;\n\n\tep4_null(t);\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\t\tep4_mul(t, q, l);\n\t\tep4_mul(r, p, k);\n\t\tep4_add(t, t, r);\n\t\tep4_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\nvoid ep4_mul_sim_trick(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t m) {\n\tep4_t t0[1 << (EP_WIDTH / 2)];\n\tep4_t t1[1 << (EP_WIDTH / 2)];\n\tep4_t t[1 << EP_WIDTH];\n\tbn_t n;\n\tint l0, l1, w = EP_WIDTH / 2;\n\tuint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep4_null(t0[i]);\n\t\t\tep4_null(t1[i]);\n\t\t\tep4_new(t0[i]);\n\t\t\tep4_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tep4_set_infty(t0[0]);\n\t\tep4_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep4_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\tep4_set_infty(t1[0]);\n\t\tep4_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tep4_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 1; i < (1 << w); i++) {\n\t\t\tep4_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\tep4_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH)) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(2 * RLC_FP_BITS, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\tep4_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tep4_dbl(r, r);\n\t\t\t}\n\t\t\tep4_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\tep4_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep4_free(t0[i]);\n\t\t\tep4_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\nvoid ep4_mul_sim_inter(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t m) {\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tep4_mul_sim_plain(r, p, k, q, m, NULL);\n}\n\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\nvoid ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t m) {\n\tep4_t t[5];\n\tint i, l, u_i, offset;\n\tint8_t jsf[4 * (RLC_FP_BITS + 1)];\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tep4_set_infty(t[0]);\n\t\tep4_copy(t[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tep4_neg(t[1], t[1]);\n\t\t}\n\t\tep4_copy(t[2], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(t[2], t[2]);\n\t\t}\n\t\tep4_add(t[3], t[2], t[1]);\n\t\tep4_sub(t[4], t[2], t[1]);\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 3, t + 3, 2);\n#endif\n\n\t\tl = 4 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, k, m);\n\n\t\tep4_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep4_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\tep4_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep4_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\tep4_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep4_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m) {\n\tep4_t gen;\n\n\tep4_null(gen);\n\n\tif (bn_is_zero(k)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(gen);\n\n\t\tep4_curve_get_gen(gen);\n#if EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tep4_mul_sim_plain(r, gen, k, q, m, ep4_curve_get_tab());\n#else\n\t\tep4_mul_sim(r, gen, k, q, m);\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(gen);\n\t}\n}\n\nvoid ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], int len) {\n\tep4_t t;\n\tint max;\n\n\tep4_null(t);\n\n\tmax = util_bits_dig(k[0]);\n\tfor (int i = 1; i < len; i++) {\n\t\tmax = RLC_MAX(max, util_bits_dig(k[i]));\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_set_infty(t);\n\t\tfor (int i = max - 1; i >= 0; i--) {\n\t\t\tep4_dbl(t, t);\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tif (k[j] & ((dig_t)1 << i)) {\n\t\t\t\t\tep4_add(t, t, p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tep4_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n\nvoid ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], int n) {\n\tconst int len = RLC_FP_BITS + 1;\n\tint i, j, m, l, *_l = RLC_ALLOCA(int, 8 * n);\n\tbn_t _k[8], q, x;\n\tint8_t *naf = RLC_ALLOCA(int8_t, 8 * n * len);\n\n\tbn_null(q);\n\tbn_null(x);\n\n\tif (n <= 10) {\n\t\tep4_t *_p = RLC_ALLOCA(ep4_t, 8 * n);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tbn_null(_k[j]);\n\t\t\t\tbn_new(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep4_null(_p[8*i + j]);\n\t\t\t\t\tep4_new(_p[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tep4_norm(_p[8*i], p[i]);\n\t\t\t\tep4_frb(_p[8*i + 1], _p[8*i], 1);\n\t\t\t\tep4_frb(_p[8*i + 2], _p[8*i + 1], 1);\n\t\t\t\tep4_frb(_p[8*i + 3], _p[8*i + 2], 1);\n\t\t\t\tep4_frb(_p[8*i + 4], _p[8*i + 3], 1);\n\t\t\t\tep4_frb(_p[8*i + 5], _p[8*i + 4], 1);\n\t\t\t\tep4_frb(_p[8*i + 6], _p[8*i + 5], 1);\n\t\t\t\tep4_frb(_p[8*i + 7], _p[8*i + 6], 1);\n\t\t\t}\n\n\t\t\tep_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\n\t\t\tl = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_rec_frb(_k, 8, k[i], q, x, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\t_l[8*i + j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(8*i + j)*len], &_l[8*i + j], _k[j], 2);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tep4_neg(_p[8*i + j], _p[8*i + j]);\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\tfor (m = _l[8*i + j]; m < l; m++) {\n\t\t\t\t\t\tnaf[(8*i + j)*len + m] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep4_set_infty(r);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tep4_dbl(r, r);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 8; m++) {\n\t\t\t\t\t\tif (naf[(8*j + m)*len + i] > 0) {\n\t\t\t\t\t\t\tep4_add(r, r, _p[8*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[(8*j + m)*len + i] < 0) {\n\t\t\t\t\t\t\tep4_sub(r, r, _p[8*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep4_norm(r, r);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tbn_free(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep4_free(_p[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_l);\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t} else {\n\t\tconst int w = RLC_MAX(2, util_bits_dig(n) - 2), c = (1 << (w - 2));\n\t\tep4_t s, t, u, v, *_p = RLC_ALLOCA(ep4_t, 8 * c);\n\t\tint8_t ptr;\n\n\t\tep4_null(s);\n\t\tep4_null(t);\n\t\tep4_null(u);\n\t\tep4_null(v);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tep4_new(s);\n\t\t\tep4_new(t);\n\t\t\tep4_new(u);\n\t\t\tep4_new(v);\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tbn_null(_k[i]);\n\t\t\t\tbn_new(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep4_null(_p[i*c + j]);\n\t\t\t\t\tep4_new(_p[i*c + j]);\n\t\t\t\t\tep4_set_infty(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\n\t\t\tl = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_rec_frb(_k, 8, k[i], q, x, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\t_l[8*i + j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(8*i + j)*len], &_l[8*i + j], _k[j], w);\n\t\t\t\t\tl = RLC_MAX(l, _l[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\tfor (m = _l[8*i + j]; m < l; m++) {\n\t\t\t\t\t\tnaf[(8*i + j)*len + m] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep4_set_infty(s);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 8; m++) {\n\t\t\t\t\t\tptr = naf[(8*j + m)*len + i];\n\t\t\t\t\t\tif (ptr != 0) {\n\t\t\t\t\t\t\tep4_copy(t, p[j]);\n\t\t\t\t\t\t\tif (ptr < 0) {\n\t\t\t\t\t\t\t\tptr = -ptr;\n\t\t\t\t\t\t\t\tep4_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bn_sign(_k[m]) == RLC_NEG) {\n\t\t\t\t\t\t\t\tep4_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tep4_add(_p[m*c + (ptr/2)], _p[m*c + (ptr/2)], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tep4_set_infty(t);\n\t\t\t\tfor (m = 3; m >= 0; m--) {\n\t\t\t\t\tep4_frb(t, t, 1);\n\t\t\t\t\tep4_set_infty(u);\n\t\t\t\t\tep4_set_infty(v);\n\t\t\t\t\tfor (j = c - 1; j >= 0; j--) {\n\t\t\t\t\t\tep4_add(u, u, _p[m*c + j]);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tep4_dbl(v, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tep4_add(v, v, u);\n\t\t\t\t\t\tep4_set_infty(_p[m*c + j]);\n\t\t\t\t\t}\n\t\t\t\t\tep4_add(t, t, v);\n\t\t\t\t}\n\t\t\t\tep4_dbl(s, s);\n\t\t\t\tep4_add(s, s, t);\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep4_norm(r, s);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tep4_free(s);\n\t\t\tep4_free(t);\n\t\t\tep4_free(u);\n\t\t\tep4_free(v);\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tbn_free(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep4_free(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_l);\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of comparison for points on prime elliptic curves over\n * quartic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ep4_is_infty(const ep4_t p) {\n\treturn (fp4_is_zero(p->z) == 1);\n}\n\nvoid ep4_set_infty(ep4_t p) {\n\tfp4_zero(p->x);\n\tfp4_zero(p->y);\n\tfp4_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid ep4_copy(ep4_t r, const ep4_t p) {\n\tfp4_copy(r->x, p->x);\n\tfp4_copy(r->y, p->y);\n\tfp4_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid ep4_rand(ep4_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\tep4_mul_gen(p, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_blind(ep4_t r, const ep4_t p) {\n\tfp4_t rand;\n\n\tfp4_null(rand);\n\n\tRLC_TRY {\n\t\tfp4_new(rand);\n\t\tfp4_rand(rand);\n#if EP_ADD == BASIC\n\t\t(void)rand;\n\t\tep4_copy(r, p);\n#else\n\t\tfp4_mul(r->z, p->z, rand);\n\t\tfp4_mul(r->y, p->y, rand);\n\t\tfp4_sqr(rand, rand);\n\t\tfp4_mul(r->x, r->x, rand);\n\t\tfp4_mul(r->y, r->y, rand);\n\t\tr->coord = EP_ADD;\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp4_free(rand);\n\t}\n}\n\nvoid ep4_rhs(fp4_t rhs, const ep4_t p) {\n\tfp4_t t0, t1;\n\n\tfp4_null(t0);\n\tfp4_null(t1);\n\n\tRLC_TRY {\n\t\tfp4_new(t0);\n\t\tfp4_new(t1);\n\n\t\tfp4_sqr(t0, p->x);                  /* x1^2 */\n\n\t\tswitch (ep4_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0[0][0], t0[0][0], 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tep4_curve_get_a(t1);\n\t\t\t\tfp_mul_dig(t0[0][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[0][1], t0[0][1], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][1], t0[1][1], t1[0][0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tep4_curve_get_a(t1);\n\t\t\t\tfp4_add(t0, t0, t1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp4_mul(t0, t0, p->x);\t\t\t\t/* x1^3 + a * x */\n\n\t\tswitch (ep4_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0[0][0], t0[0][0], 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tep4_curve_get_b(t1);\n\t\t\t\tfp_mul_dig(t0[0][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[0][1], t0[0][1], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][1], t0[1][1], t1[0][0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tep4_curve_get_b(t1);\n\t\t\t\tfp4_add(t0, t0, t1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp4_copy(rhs, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp4_free(t0);\n\t\tfp4_free(t1);\n\t}\n}\n\n\nint ep4_on_curve(const ep4_t p) {\n\tep4_t t;\n\tint r = 0;\n\n\tep4_null(t);\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_norm(t, p);\n\n\t\tep4_rhs(t->x, t);\n\t\tfp4_sqr(t->y, t->y);\n\n\t\tr = (fp4_cmp(t->x, t->y) == RLC_EQ) || ep4_is_infty(p);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep4_free(t);\n\t}\n\treturn r;\n}\n\nvoid ep4_tab(ep4_t *t, const ep4_t p, int w) {\n\tif (w > 2) {\n\t\tep4_dbl(t[0], p);\n#if defined(EP_MIXED)\n\t\tep4_norm(t[0], t[0]);\n#endif\n\t\tep4_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\tep4_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 1, t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\tep4_copy(t[0], p);\n}\n\nvoid ep4_print(const ep4_t p) {\n\tfp4_print(p->x);\n\tfp4_print(p->y);\n\tfp4_print(p->z);\n}\n\nint ep4_size_bin(const ep4_t a, int pack) {\n\tep4_t t;\n\tint size = 0;\n\n\tep4_null(t);\n\n\tif (ep4_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_norm(t, a);\n\n\t\tsize = 1 + 8 * RLC_FP_BYTES;\n\t\t//TODO: Implement compression.\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep4_free(t);\n\t}\n\n\treturn size;\n}\n\nvoid ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep4_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (8 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp4_set_dig(a->z, 1);\n\tfp4_read_bin(a->x, bin + 1, 4 * RLC_FP_BYTES);\n\n\tif (len == 8 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp4_read_bin(a->y, bin + 4 * RLC_FP_BYTES + 1, 4 * RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ep4_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n}\n\nvoid ep4_write_bin(uint8_t *bin, int len, const ep4_t a, int pack) {\n\tep4_t t;\n\n\tep4_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ep4_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_norm(t, a);\n\n\t\tif (len < 8 * RLC_FP_BYTES + 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t} else {\n\t\t\tbin[0] = 4;\n\t\t\tfp4_write_bin(bin + 1, 4 * RLC_FP_BYTES, t->x);\n\t\t\tfp4_write_bin(bin + 4 * RLC_FP_BYTES + 1, 4 * RLC_FP_BYTES, t->y);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2011 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of prime field exponentiation functions.\n *\n * @ingroup bn\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_fb.h\"\n#include \"relic_bn.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if FB_EXP == BASIC || !defined(STRIP)\n\nvoid fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n\tint i, l;\n\tfb_t r;\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfb_null(r);\n\n\tRLC_TRY {\n\t\tfb_new(r);\n\n\t\tl = bn_bits(b);\n\n\t\tfb_copy(r, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tfb_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfb_mul(r, r, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, r);\n\t\t} else {\n\t\t\tfb_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(r);\n\t}\n}\n\n#endif\n\n#if FB_EXP == SLIDE || !defined(STRIP)\n\nvoid fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {\n\tfb_t t[1 << (FB_WIDTH - 1)], r;\n\tint i, j, l;\n\tuint8_t win[RLC_FB_BITS + 1];\n\n\tfb_null(r);\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\n\t/* Initialize table. */\n\tfor (i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n\t\tfb_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (FB_WIDTH - 1)); i ++) {\n\t\t\tfb_new(t[i]);\n\t\t}\n\t\tfb_new(r);\n\n\t\tfb_copy(t[0], a);\n\t\tfb_sqr(r, a);\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < 1 << (FB_WIDTH - 1); i++) {\n\t\t\tfb_mul(t[i], t[i - 1], r);\n\t\t}\n\n\t\tfb_set_dig(r, 1);\n\t\tl = RLC_FB_BITS + 1;\n\t\tbn_rec_slw(win, &l, b, FB_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tfb_sqr(r, r);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tfb_sqr(r, r);\n\t\t\t\t}\n\t\t\t\tfb_mul(r, r, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, r);\n\t\t} else {\n\t\t\tfb_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n\t\t\tfb_free(t[i]);\n\t\t}\n\t\tfb_free(r);\n\t}\n}\n\n#endif\n\n#if FB_EXP == MONTY || !defined(STRIP)\n\nvoid fb_exp_monty(fb_t c, const fb_t a, const bn_t b) {\n\tfb_t t[2];\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfb_null(t[0]);\n\tfb_null(t[1]);\n\n\tRLC_TRY {\n\t\tfb_new(t[0]);\n\t\tfb_new(t[1]);\n\n\t\tfb_set_dig(t[0], 1);\n\t\tfb_copy(t[1], a);\n\n\t\tfor (int i = bn_bits(b) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(b, i);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FB_DIGS, j ^ 1);\n\t\t\tfb_mul(t[0], t[0], t[1]);\n\t\t\tfb_sqr(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FB_DIGS, j ^ 1);\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, t[0]);\n\t\t} else {\n\t\t\tfb_copy(c, t[0]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(t[1]);\n\t\tfb_free(t[0]);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the basic functions to manipulate binary field elements.\n *\n * @ingroup fb\n */\n\n#include \"relic_core.h\"\n#include \"relic_fb.h\"\n#include \"relic_fb_low.h\"\n#include \"relic_rand.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Checks if a radix is a power of two.\n *\n * @param[in] radix\t\t\t\t- the radix to check.\n * @return if radix is a valid radix.\n */\nstatic int valid_radix(int radix) {\n\twhile (radix > 0) {\n\t\tif (radix != 1 && radix % 2 == 1)\n\t\t\treturn 0;\n\t\tradix = radix / 2;\n\t}\n\treturn 1;\n}\n\n/**\n * Computes the logarithm of a valid radix in basis two.\n *\n * @param[in] radix\t\t\t\t- the valid radix.\n * @return the logarithm of the radix in basis two.\n */\nstatic int log_radix(int radix) {\n\tint l = 0;\n\n\twhile (radix > 0) {\n\t\tradix = radix / 2;\n\t\tl++;\n\t}\n\treturn --l;\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fb_copy(fb_t c, const fb_t a) {\n\tdv_copy(c, a, RLC_FB_DIGS);\n}\n\nvoid fb_zero(fb_t a) {\n\tdv_zero(a, RLC_FB_DIGS);\n}\n\nint fb_is_zero(const fb_t a) {\n\tint i;\n\tdig_t t = 0;\n\n\tfor (i = 0; i < RLC_FB_DIGS; i++) {\n\t\tt |= a[i];\n\t}\n\n\treturn !t;\n}\n\nint fb_get_bit(const fb_t a, int bit) {\n\tint d;\n\n\tRLC_RIP(bit, d, bit);\n\n\treturn (a[d] >> bit) & 1;\n}\n\nvoid fb_set_bit(fb_t a, int bit, int value) {\n\tint d;\n\tdig_t mask;\n\n\tRLC_RIP(bit, d, bit);\n\n\tmask = (dig_t)1 << bit;\n\n\tif (value == 1) {\n\t\ta[d] |= mask;\n\t} else {\n\t\ta[d] &= ~mask;\n\t}\n}\n\nint fb_bits(const fb_t a) {\n\tint i = RLC_FB_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}\n\nvoid fb_set_dig(fb_t c, dig_t a) {\n\tfb_zero(c);\n\tc[0] = a;\n}\n\nvoid fb_rand(fb_t a) {\n\tint bits, digits;\n\n\trand_bytes((uint8_t *)a, RLC_FB_DIGS * sizeof(dig_t));\n\n\tRLC_RIP(bits, digits, RLC_FB_BITS);\n\tif (bits > 0) {\n\t\tdig_t mask = RLC_MASK(bits);\n\t\ta[RLC_FB_DIGS - 1] &= mask;\n\t}\n}\n\nvoid fb_print(const fb_t a) {\n\tint i;\n\n\t/* Suppress possible unused parameter warning. */\n\t(void)a;\n\tfor (i = RLC_FB_DIGS - 1; i > 0; i--) {\n\t\tutil_print_dig(a[i], 1);\n\t\tutil_print(\" \");\n\t}\n\tutil_print_dig(a[0], 1);\n\tutil_print(\"\\n\");\n}\n\nint fb_size_str(const fb_t a, int radix) {\n\tbn_t t;\n\tint digits = 0;\n\n\tbn_null(t);\n\n\tif (!valid_radix(radix)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_raw(t, a, RLC_FB_DIGS);\n\n\t\tdigits = bn_size_str(t, radix);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn digits;\n}\n\nvoid fb_read_str(fb_t a, const char *str, int len, int radix) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (!valid_radix(radix)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_str(t, str, len, radix);\n\n\t\tif (bn_bits(t) > RLC_FB_BITS) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t}\n\n\t\tfb_zero(a);\n\t\tdv_copy(a, t->dp, t->used);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fb_write_str(char *str, int len, const fb_t a, int radix) {\n\tfb_t t;\n\tint d, l, i, j;\n\tchar c;\n\n\tfb_null(t);\n\n\tl = fb_size_str(a, radix);\n\tif (len < l) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tlen = l;\n\n\tl = log_radix(radix);\n\tif (!valid_radix(radix)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tif (fb_is_zero(a) == 1) {\n\t\t*str++ = '0';\n\t\t*str = '\\0';\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfb_new(t);\n\t\tfb_copy(t, a);\n\n\t\tj = 0;\n\t\twhile (!fb_is_zero(t)) {\n\t\t\td = t[0] % radix;\n\t\t\tfb_rshb_low(t, t, l);\n\t\t\tstr[j] = util_conv_char(d);\n\t\t\tj++;\n\t\t}\n\n\t\t/* Reverse the digits of the string. */\n\t\ti = 0;\n\t\tj = len - 2;\n\t\twhile (i < j) {\n\t\t\tc = str[i];\n\t\t\tstr[i] = str[j];\n\t\t\tstr[j] = c;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\n\t\tstr[len - 1] = '\\0';\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(t);\n\t}\n}\n\nvoid fb_read_bin(fb_t a, const uint8_t *bin, int len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_bin(t, bin, len);\n\n\t\tfb_copy(a, t->dp);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fb_write_bin(uint8_t *bin, int len, const fb_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_raw(t, a, RLC_FB_DIGS);\n\n\t\tbn_write_bin(bin, len, t);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of prime field exponentiation functions.\n *\n * @ingroup fp\n */\n\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if FP_EXP == BASIC || !defined(STRIP)\n\nvoid fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {\n\tint i, l;\n\tfp_t r;\n\n\tfp_null(r);\n\n\tif (bn_is_zero(b)) {\n\t\tfp_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfp_new(r);\n\n\t\tl = bn_bits(b);\n\n\t\tfp_copy(r, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tfp_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp_mul(r, r, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp_inv(c, r);\n\t\t} else {\n\t\t\tfp_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp_free(r);\n\t}\n}\n\n#endif\n\n#if FP_EXP == SLIDE || !defined(STRIP)\n\nvoid fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {\n\tfp_t t[1 << (FP_WIDTH - 1)], r;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tfp_null(r);\n\n\tif (bn_is_zero(b)) {\n\t\tfp_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\n\t/* Initialize table. */\n\tfor (i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n\t\tfp_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 1)); i ++) {\n\t\t\tfp_new(t[i]);\n\t\t}\n\t\tfp_new(r);\n\n\t\tfp_copy(t[0], a);\n\t\tfp_sqr(r, a);\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < 1 << (FP_WIDTH - 1); i++) {\n\t\t\tfp_mul(t[i], t[i - 1], r);\n\t\t}\n\n\t\tfp_set_dig(r, 1);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, b, FP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tfp_sqr(r, r);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tfp_sqr(r, r);\n\t\t\t\t}\n\t\t\t\tfp_mul(r, r, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp_inv(c, r);\n\t\t} else {\n\t\t\tfp_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n\t\t\tfp_free(t[i]);\n\t\t}\n\t\tfp_free(r);\n\t}\n}\n\n#endif\n\n#if FP_EXP == MONTY || !defined(STRIP)\n\nvoid fp_exp_monty(fp_t c, const fp_t a, const bn_t b) {\n\tfp_t t[2];\n\n\tfp_null(t[0]);\n\tfp_null(t[1]);\n\n\tif (bn_is_zero(b)) {\n\t\tfp_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfp_new(t[0]);\n\t\tfp_new(t[1]);\n\n\t\tfp_set_dig(t[0], 1);\n\t\tfp_copy(t[1], a);\n\n\t\tfor (int i = bn_bits(b) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(b, i);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tfp_mul(t[0], t[0], t[1]);\n\t\t\tfp_sqr(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp_inv(c, t[0]);\n\t\t} else {\n\t\t\tfp_copy(c, t[0]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp_free(t[1]);\n\t\tfp_free(t[0]);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime field prime manipulation functions.\n *\n * @ingroup fp\n */\n\n#include \"relic_core.h\"\n#include \"relic_ep.h\"\n#include \"relic_fpx.h\"\n#include \"relic_bn_low.h\"\n#include \"relic_fp_low.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Assigns the prime field modulus.\n *\n * @param[in] p\t\t\t- the new prime field modulus.\n */\nstatic void fp_prime_set(const bn_t p) {\n\tbn_t t;\n\tfp_t r;\n\tctx_t *ctx = core_get();\n\n\tif (p->used != RLC_FP_DIGS) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tfp_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tfp_new(r);\n\n\t\tbn_copy(&(ctx->prime), p);\n\n#if FP_RDC == MONTY || !defined(STRIP)\n\n\t\tbn_mod_pre_monty(t, &(ctx->prime));\n\t\tctx->u = t->dp[0];\n\n\t\t/* compute R mod p */\n\t\tbn_set_dig(&(ctx->one), 1);\n\t\tbn_lsh(&(ctx->one), &(ctx->one), RLC_FP_DIGS * RLC_DIG);\n\t\tbn_mod(&(ctx->one), &(ctx->one), &(ctx->prime));\n\n\t\t/* compute the R^2 mod p */\n\t\tfp_add(r, ctx->one.dp, ctx->one.dp);\n\t\tbn_set_dig(t, RLC_FP_DIGS);\n\t\tbn_lsh(t, t, RLC_DIG_LOG);\n\t\tfp_exp(ctx->conv.dp, r, t);\n\t\tctx->conv.used = RLC_FP_DIGS;\n\t\tbn_trim(&(ctx->conv));\n\n#endif /* FP_RDC == MONTY */\n\n#if FP_INV == JUMPDS || !defined(STRIP)\n\n\t\tint d = (45907 * FP_PRIME + 26313) / 19929;\n\n#if WSIZE == 8\n\t\tbn_set_dig(t, d >> 8);\n\t\tbn_lsh(t, t, 8);\n\t\tbn_add_dig(t, t, d & 0xFF);\n#else\n\t\tbn_set_dig(t, d);\n#endif\n\t\tctx->inv.used = RLC_FP_DIGS;\n\t\tdv_copy(ctx->inv.dp, fp_prime_get(), RLC_FP_DIGS);\n\t\tfp_add_dig(ctx->inv.dp, ctx->inv.dp, 1);\n\t\tfp_hlv(ctx->inv.dp, ctx->inv.dp);\n\t\tfp_exp(ctx->inv.dp, ctx->inv.dp, t);\n\n#if FP_RDC == MONTY\n\n#if (FP_PRIME % WSIZE) != 0\n\t\tfp_mul(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);\n\t\tfp_mul(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);\n\n\t\tfor (int i = 1, j = 0; i < d / (RLC_DIG - 2); i++) {\n\t\t\tj = i % RLC_FP_DIGS;\n\t\t\tif (j == 0) {\n\t\t\t\tfp_mulm_low(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);\n\t\t\t}\n\t\t}\n#endif\n\n#endif /* FP_RDC == MONTY */\n\n#endif /* FP_INV */\n\n\t\t/* Now look for proper quadratic/cubic non-residues. */\n\t\tctx->qnr = ctx->cnr = 0;\n\t\tbn_mod_dig(&(ctx->mod8), &(ctx->prime), 8);\n\n\t\tswitch (ctx->mod8) {\n\t\t\tcase 3:\n\t\t\t\tctx->qnr = -1;\n\t\t\t\tctx->cnr = 2;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tctx->qnr = -1;\n\t\t\t\tctx->cnr = -2;\n\t\t\t\t/* TODO: implement cube root to handle this better. */\n#if FP_PRIME == 638\n\t\t\t\tctx->cnr = -3;\n#endif\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 5:\n\t\t\t\tctx->qnr = -2;\n\t\t\t\tctx->cnr = 2;\n\t\t\t\t/* Check if it is a quadratic non-residue or find another. */\n\t\t\t\tfp_set_dig(r, -ctx->qnr);\n\t\t\t\tfp_neg(r, r);\n\t\t\t\twhile (fp_srt(r, r) == 1) {\n\t\t\t\t\tctx->qnr--;\n\t\t\t\t\tfp_set_dig(r, -ctx->qnr);\n\t\t\t\t\tfp_neg(r, r);\n\t\t\t\t\t/* We cannot guarantee a cubic extension anymore. */\n\t\t\t\t\tctx->cnr = 0;\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t}\n#ifdef FP_QNRES\n\t\tif (ctx->mod8 != 3) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n#endif\n\n\t\tctx->ad2 = 0;\n\t\tbn_sub_dig(t, p, 1);\n\t\twhile (bn_is_even(t)) {\n\t\t\tctx->ad2++;\n\t\t\tbn_hlv(t, t);\n\t\t}\n\n\t\tfp_prime_calc();\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tfp_free(r);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp_prime_init(void) {\n\tctx_t *ctx = core_get();\n\tctx->fp_id = 0;\n\tbn_make(&(ctx->prime), RLC_FP_DIGS);\n\tbn_make(&(ctx->par), RLC_FP_DIGS);\n#if FP_RDC == QUICK || !defined(STRIP)\n\tctx->sps_len = 0;\n\tmemset(ctx->sps, 0, sizeof(ctx->sps));\n#endif\n#if FP_RDC == MONTY || !defined(STRIP)\n\tbn_make(&(ctx->conv), RLC_FP_DIGS);\n\tbn_make(&(ctx->one), RLC_FP_DIGS);\n#endif\n#if FP_INV == JUMPDS || !defined(STRIP)\n\tbn_make(&(ctx->inv), RLC_FP_DIGS);\n#endif /* FP_INV */\n}\n\nvoid fp_prime_clean(void) {\n\tctx_t *ctx = core_get();\n\tif (ctx != NULL) {\n\t\tctx->fp_id = 0;\n#if FP_RDC == QUICK || !defined(STRIP)\n\t\tctx->sps_len = 0;\n\t\tmemset(ctx->sps, 0, sizeof(ctx->sps));\n#endif\n#if FP_RDC == MONTY || !defined(STRIP)\n\t\tbn_clean(&(ctx->one));\n\t\tbn_clean(&(ctx->conv));\n#endif\n#if FP_INV == JUMPDS || !defined(STRIP)\n\t\tbn_clean(&(ctx->inv));\n#endif /* FP_INV */\n\t\tbn_clean(&(ctx->prime));\n\t\tbn_clean(&(ctx->par));\n\t}\n}\n\nconst dig_t *fp_prime_get(void) {\n\treturn core_get()->prime.dp;\n}\n\nconst dig_t *fp_prime_get_rdc(void) {\n\treturn &(core_get()->u);\n}\n\nvoid fp_prime_get_par(bn_t x) {\n\tbn_copy(x, &(core_get()->par));\n}\n\nconst int *fp_prime_get_par_sps(int *len) {\n\tctx_t *ctx = core_get();\n\tif (ctx->par_len > 0) {\n\t\tif (len != NULL) {\n\t\t\t*len = ctx->par_len;\n\t\t}\n\t\treturn ctx->par_sps;\n\t}\n\tif (len != NULL) {\n\t\t*len = 0;\n\t}\n\treturn NULL;\n}\n\nconst int *fp_prime_get_sps(int *len) {\n#if FP_RDC == QUICK || !defined(STRIP)\n\tctx_t *ctx = core_get();\n\tif (ctx->sps_len > 0 && ctx->sps_len < RLC_TERMS) {\n\t\tif (len != NULL) {\n\t\t\t*len = ctx->sps_len;\n\t\t}\n\t\treturn ctx->sps;\n\t} else {\n\t\tif (len != NULL) {\n\t\t\t*len = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n#else\n\treturn NULL;\n#endif\n}\n\nconst dig_t *fp_prime_get_conv(void) {\n#if FP_RDC == MONTY || !defined(STRIP)\n\treturn core_get()->conv.dp;\n#else\n\treturn NULL;\n#endif\n}\n\ndig_t fp_prime_get_mod8(void) {\n\treturn core_get()->mod8;\n}\n\nint fp_prime_get_qnr(void) {\n\treturn core_get()->qnr;\n}\n\nint fp_prime_get_cnr(void) {\n\treturn core_get()->cnr;\n}\n\nint fp_prime_get_2ad(void) {\n\treturn core_get()->ad2;\n}\n\nvoid fp_prime_set_dense(const bn_t p) {\n\tfp_prime_set(p);\n#if FP_RDC == QUICK\n\tRLC_THROW(ERR_NO_CONFIG);\n#endif\n}\n\nvoid fp_prime_set_pairf(const bn_t x, int pairf) {\n\tbn_t p, t0, t1;\n\tctx_t *ctx = core_get();\n\tint len = bn_bits(x) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tbn_null(p);\n\tbn_null(t0);\n\tbn_null(t1);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\n\t\tbn_copy(&(ctx->par), x);\n\t\tbn_copy(t0, x);\n\n\t\tswitch (pairf) {\n\t\t\tcase EP_BN:\n\t\t\t\t/* p = 36 * x^4 + 36 * x^3 + 24 * x^2 + 6 * x + 1. */\n\t\t\t\tbn_set_dig(p, 1);\n\t\t\t\tbn_mul_dig(t1, t0, 6);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t0, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 24);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t0, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 36);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t0, t0, t0);\n\t\t\t\tbn_mul(t1, t0, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 36);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_B12:\n\t\t\t\t/* p = (x^2 - 2x + 1) * (x^4 - x^2 + 1)/3 + x. */\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_sqr(p, t1);\n\t\t\t\tbn_sub(p, p, t1);\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t\tbn_sub(t1, t1, t0);\n\t\t\t\tbn_sub(t1, t1, t0);\n\t\t\t\tbn_add_dig(t1, t1, 1);\n\t\t\t\tbn_mul(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 3);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_OT8:\n\t\t\t\t/* p = (x^8 + x^6 + 5*x^4 + x^2 + 4*x + 4) / 4. */\n\t\t\t\tbn_set_dig(p, 4);\n\t\t\t\tbn_mul_dig(t1, t0, 4);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_sqr(t0, t0);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 4);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_B24:\n\t\t\t\t/* p = (x - 1)^2 * (x^8 - x^4 + 1)/3 + x. */\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_sqr(p, t1);\n\t\t\t\tbn_sub(p, p, t1);\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t\tbn_sub_dig(t1, t0, 1);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_mul(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 3);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_B48:\n\t\t\t\t/* p = (x - 1)^2*(x^16 - x^8 + 1) / 3 + x. */\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_sqr(p, t1);\n\t\t\t\tbn_sqr(t1, p);\n\t\t\t\tbn_sub(t1, t1, p);\n\t\t\t\tbn_add_dig(t1, t1, 1);\n\t\t\t\tbn_sub_dig(p, t0, 1);\n\t\t\t\tbn_sqr(p, p);\n\t\t\t\tbn_mul(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 3);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_K54:\n\t\t\t\t/* p = (1+3*x+3*x^2+(3^5)*x^9+(3^5)*x^10+(3^6)*x^10+(3^6)*x^11+(3^9)*x^18+(3^10)*x^19+(3^10)*x^20) */\n\t\t\t\tbn_set_dig(p, 1);\n\t\t\t\tbn_mul_dig(t1, t0, 3);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 243);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul_dig(t1, t1, 3);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul_dig(t1, t1, 27);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul_dig(t1, t1, 3);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Store parameter in NAF form. */\n\t\tctx->par_len = 0;\n\t\tbn_rec_naf(s, &len, &(ctx->par), 2);\n\t\t/* Fix corner case to avoid problems with sparse representation. */\n\t\tif (s[0] == -1) {\n\t\t\ts[0] = 1;\n\t\t\ts[1] = -1;\n\t\t}\n\t\tfor (int i = 0; i < len && ctx->par_len < RLC_TERMS; i++) {\n\t\t\tif (s[i] > 0) {\n\t\t\t\tctx->par_sps[ctx->par_len++] = i;\n\t\t\t}\n\t\t\tif (s[i] < 0) {\n\t\t\t\tctx->par_sps[ctx->par_len++] = -i;\n\t\t\t}\n\t\t}\n\t\tif (ctx->par_len == RLC_TERMS) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(p);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t}\n}\n\nvoid fp_prime_set_pmers(const int *f, int len) {\n\tbn_t p, t;\n\n\tbn_null(p);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(t);\n\n\t\tif (len >= RLC_TERMS) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\n\t\tbn_set_2b(p, f[len - 1]);\n\t\tfor (int i = len - 2; i > 0; i--) {\n\t\t\tif (f[i] > 0) {\n\t\t\t\tbn_set_2b(t, f[i]);\n\t\t\t\tbn_add(p, p, t);\n\t\t\t} else {\n\t\t\t\tbn_set_2b(t, -f[i]);\n\t\t\t\tbn_sub(p, p, t);\n\t\t\t}\n\t\t}\n\t\tif (f[0] > 0) {\n\t\t\tbn_add_dig(p, p, f[0]);\n\t\t} else {\n\t\t\tbn_sub_dig(p, p, -f[0]);\n\t\t}\n\n#if FP_RDC == QUICK || !defined(STRIP)\n\t\tctx_t *ctx = core_get();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tctx->sps[i] = f[i];\n\t\t}\n\t\tctx->sps[len] = 0;\n\t\tctx->sps_len = len;\n#endif /* FP_RDC == QUICK */\n\n\t\tfp_prime_set(p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(p);\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_prime_calc(void) {\n#ifdef WITH_FPX\n\tif (fp_prime_get_qnr() != 0) {\n\t\tfp2_field_init();\n\t\tfp4_field_init();\n\t}\n\tif (fp_prime_get_cnr() != 0) {\n\t\tfp3_field_init();\n\t}\n#endif\n}\n\nvoid fp_prime_conv(fp_t c, const bn_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\t/* Reduce a modulo the prime to ensure bounds. */\n\t\tbn_mod(t, a, &(core_get()->prime));\n\n\t\tif (bn_is_zero(t)) {\n\t\t\tfp_zero(c);\n\t\t} else {\n\t\t\t/* Copy used digits, fill the rest with zero. */\n\t\t\tdv_copy(c, t->dp, t->used);\n\t\t\tdv_zero(c + t->used, RLC_FP_DIGS - t->used);\n#if FP_RDC == MONTY\n\t\t\tfp_mul(c, c, core_get()->conv.dp);\n#endif\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_prime_conv_dig(fp_t c, dig_t a) {\n\tdv_t t;\n\tctx_t *ctx = core_get();\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tdv_new(t);\n\n#if FP_RDC == MONTY\n\t\tif (a != 1) {\n\t\t\tdv_zero(t, 2 * RLC_FP_DIGS + 1);\n\t\t\tt[RLC_FP_DIGS] = fp_mul1_low(t, ctx->conv.dp, a);\n\t\t\tfp_rdc(c, t);\n\t\t} else {\n\t\t\tdv_copy(c, ctx->one.dp, RLC_FP_DIGS);\n\t\t}\n#else\n\t\t(void)ctx;\n\t\tfp_zero(c);\n\t\tc[0] = a;\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tdv_free(t);\n\t}\n}\n\nvoid fp_prime_back(bn_t c, const fp_t a) {\n\tdv_t t;\n\tint i;\n\n\tdv_null(t);\n\n\tRLC_TRY {\n\t\tdv_new(t);\n\n\t\tbn_grow(c, RLC_FP_DIGS);\n\t\tfor (i = 0; i < RLC_FP_DIGS; i++) {\n\t\t\tc->dp[i] = a[i];\n\t\t}\n#if FP_RDC == MONTY\n\t\tdv_zero(t, 2 * RLC_FP_DIGS + 1);\n\t\tdv_copy(t, a, RLC_FP_DIGS);\n\t\tfp_rdc(c->dp, t);\n#endif\n\t\tc->used = RLC_FP_DIGS;\n\t\tc->sign = RLC_POS;\n\t\tbn_trim(c);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tdv_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime field utilities.\n *\n * @ingroup fp\n */\n\n#include \"relic_core.h\"\n#include \"relic_fp_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp_copy(fp_t c, const fp_t a) {\n\tdv_copy(c, a, RLC_FP_DIGS);\n}\n\nvoid fp_zero(fp_t a) {\n\tdv_zero(a, RLC_FP_DIGS);\n}\n\nint fp_is_zero(const fp_t a) {\n\tint i;\n\tdig_t t = 0;\n\n\tfor (i = 0; i < RLC_FP_DIGS; i++) {\n\t\tt |= a[i];\n\t}\n\n\treturn !t;\n}\n\nint fp_is_even(const fp_t a) {\n\tif ((a[0] & 0x01) == 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint fp_get_bit(const fp_t a, int bit) {\n\tint d;\n\n\tRLC_RIP(bit, d, bit);\n\n\treturn (a[d] >> bit) & 1;\n}\n\nvoid fp_set_bit(fp_t a, int bit, int value) {\n\tint d;\n\tdig_t mask;\n\n\tRLC_RIP(bit, d, bit);\n\n\tmask = (dig_t)1 << bit;\n\n\tif (value == 1) {\n\t\ta[d] |= mask;\n\t} else {\n\t\ta[d] &= ~mask;\n\t}\n}\n\nint fp_bits(const fp_t a) {\n\tint i = RLC_FP_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}\n\nvoid fp_set_dig(fp_t c, dig_t a) {\n\tfp_prime_conv_dig(c, a);\n}\n\nvoid fp_rand(fp_t a) {\n\tint bits, digits;\n\n\trand_bytes((uint8_t *)a, RLC_FP_DIGS * sizeof(dig_t));\n\n\tRLC_RIP(bits, digits, RLC_FP_BITS);\n\tif (bits > 0) {\n\t\tdig_t mask = ((dig_t)1 << (dig_t)bits) - 1;\n\t\ta[RLC_FP_DIGS - 1] &= mask;\n\t}\n\n\twhile (dv_cmp(a, fp_prime_get(), RLC_FP_DIGS) != RLC_LT) {\n\t\tfp_subm_low(a, a, fp_prime_get());\n\t}\n}\n\nvoid fp_print(const fp_t a) {\n\tint i;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n#if FP_RDC == MONTY\n\t\tif (a != fp_prime_get()) {\n\t\t\tfp_prime_back(t, a);\n\t\t} else {\n\t\t\tbn_read_raw(t, a, RLC_FP_DIGS);\n\t\t}\n#else\n\t\tbn_read_raw(t, a, RLC_FP_DIGS);\n#endif\n\n\t\tfor (i = RLC_FP_DIGS - 1; i > 0; i--) {\n\t\t\tif (i >= t->used) {\n\t\t\t\tutil_print_dig(0, 1);\n\t\t\t} else {\n\t\t\t\tutil_print_dig(t->dp[i], 1);\n\t\t\t}\n\t\t\tutil_print(\" \");\n\t\t}\n\t\tutil_print_dig(t->dp[0], 1);\n\t\tutil_print(\"\\n\");\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nint fp_size_str(const fp_t a, int radix) {\n\tbn_t t;\n\tint digits = 0;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tfp_prime_back(t, a);\n\n\t\tdigits = bn_size_str(t, radix);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn digits;\n}\n\nvoid fp_read_str(fp_t a, const char *str, int len, int radix) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_read_str(t, str, len, radix);\n\t\tif (bn_is_zero(t)) {\n\t\t\tfp_zero(a);\n\t\t} else {\n\t\t\tif (t->used == 1) {\n\t\t\t\tfp_prime_conv_dig(a, t->dp[0]);\n\t\t\t\tif (bn_sign(t) == RLC_NEG) {\n\t\t\t\t\tfp_neg(a, a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfp_prime_conv(a, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_write_str(char *str, int len, const fp_t a, int radix) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tfp_prime_back(t, a);\n\n\t\tbn_write_str(str, len, t, radix);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_read_bin(fp_t a, const uint8_t *bin, int len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_read_bin(t, bin, len);\n\n\t\t/* Reject values out of bounds. */\n\t\tif (bn_sign(t) == RLC_NEG || bn_cmp(t, &core_get()->prime) != RLC_LT) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t} else {\n\t\t\tif (bn_is_zero(t)) {\n\t\t\t\tfp_zero(a);\n\t\t\t} else {\n\t\t\t\tif (t->used == 1) {\n\t\t\t\t\tfp_prime_conv_dig(a, t->dp[0]);\n\t\t\t\t} else {\n\t\t\t\t\tfp_prime_conv(a, t);\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_write_bin(uint8_t *bin, int len, const fp_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tfp_prime_back(t, a);\n\n\t\tbn_write_bin(bin, len, t);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of exponentiation in cyclotomic subgroups of extensions\n * defined over prime fields.\n *\n * @ingroup fpx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp2_conv_cyc(fp2_t c, const fp2_t a) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\t/* t = a^{-1}. */\n\t\tfp2_inv(t, a);\n\t\t/* c = a^p. */\n\t\tfp2_inv_cyc(c, a);\n\t\t/* c = a^(p - 1). */\n\t\tfp2_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nint fp2_test_cyc(const fp2_t a) {\n\tfp2_t t;\n\tint result = 0;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\t\tfp2_frb(t, a, 1);\n\t\tfp2_mul(t, t, a);\n\t\tresult = ((fp2_cmp_dig(t, 1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n\n\treturn result;\n}\n\nvoid fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {\n\tfp2_t r, s, t[1 << (FP_WIDTH - 2)];\n\tint i, l;\n\tint8_t naf[RLC_FP_BITS + 1], *k;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp2_set_dig(c, 1);\n\t}\n\n\tfp2_null(r);\n\tfp2_null(s);\n\n\tRLC_TRY {\n\t\tfp2_new(r);\n\t\tfp2_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp2_null(t[i]);\n\t\t\tfp2_new(t[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp2_sqr(t[0], a);\n\t\tfp2_mul(t[1], t[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_mul(t[i], t[i - 1], t[0]);\n\t\t}\n#endif\n\t\tfp2_copy(t[0], a);\n\n\t\tl = RLC_FP_BITS + 1;\n\t\tfp2_set_dig(r, 1);\n\t\tbn_rec_naf(naf, &l, b, FP_WIDTH);\n\n\t\tk = naf + l - 1;\n\n\t\tfor (i = l - 1; i >= 0; i--, k--) {\n\t\t\tfp2_sqr(r, r);\n\n\t\t\tif (*k > 0) {\n\t\t\t\tfp2_mul(r, r, t[*k / 2]);\n\t\t\t}\n\t\t\tif (*k < 0) {\n\t\t\t\tfp2_inv_cyc(s, t[-*k / 2]);\n\t\t\t\tfp2_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp2_inv_cyc(c, r);\n\t\t} else {\n\t\t\tfp2_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(r);\n\t\tfp2_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_free(t[i]);\n\t\t}\n\t}\n}\n\nvoid fp8_conv_cyc(fp8_t c, const fp8_t a) {\n\tfp8_t t;\n\n\tfp8_null(t);\n\n\tRLC_TRY {\n\t\tfp8_new(t);\n\n\t\t/* t = a^{-1}. */\n\t\tfp8_inv(t, a);\n\t\t/* c = a^(p^4). */\n\t\tfp8_inv_cyc(c, a);\n\t\t/* c = a^(p^4 - 1). */\n\t\tfp8_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t);\n\t}\n}\n\nint fp8_test_cyc(const fp8_t a) {\n\tfp8_t t;\n\tint result = 0;\n\n\tfp8_null(t);\n\n\tRLC_TRY {\n\t\tfp8_new(t);\n\t\tfp8_inv_cyc(t, a);\n\t\tfp8_mul(t, t, a);\n\t\tresult = ((fp8_cmp_dig(t, 1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t);\n\t}\n\n\treturn result;\n}\n\nvoid fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {\n\tfp8_t r, s, t[1 << (FP_WIDTH - 2)];\n\tint i, l;\n\tint8_t naf[RLC_FP_BITS + 1], *k;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp8_set_dig(c, 1);\n\t}\n\n\tfp8_null(r);\n\tfp8_null(s);\n\n\tRLC_TRY {\n\t\tfp8_new(r);\n\t\tfp8_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp8_null(t[i]);\n\t\t\tfp8_new(t[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp8_sqr_cyc(t[0], a);\n\t\tfp8_mul(t[1], t[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp8_mul(t[i], t[i - 1], t[0]);\n\t\t}\n#endif\n\t\tfp8_copy(t[0], a);\n\n\t\tl = RLC_FP_BITS + 1;\n\t\tfp8_set_dig(r, 1);\n\t\tbn_rec_naf(naf, &l, b, FP_WIDTH);\n\n\t\tk = naf + l - 1;\n\n\t\tfor (i = l - 1; i >= 0; i--, k--) {\n\t\t\tfp8_sqr_cyc(r, r);\n\n\t\t\tif (*k > 0) {\n\t\t\t\tfp8_mul(r, r, t[*k / 2]);\n\t\t\t}\n\t\t\tif (*k < 0) {\n\t\t\t\tfp8_inv_cyc(s, t[-*k / 2]);\n\t\t\t\tfp8_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp8_inv_cyc(c, r);\n\t\t} else {\n\t\t\tfp8_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(r);\n\t\tfp8_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp8_free(t[i]);\n\t\t}\n\t}\n}\n\nvoid fp12_conv_cyc(fp12_t c, const fp12_t a) {\n\tfp12_t t;\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tfp12_new(t);\n\n\t\t/* First, compute c = a^(p^6 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp12_inv(t, a);\n\t\t/* c = a^(p^6). */\n\t\tfp12_inv_cyc(c, a);\n\t\t/* c = a^(p^6 - 1). */\n\t\tfp12_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^2 + 1). */\n\t\t/* t = c^(p^2). */\n\t\tfp12_frb(t, c, 2);\n\n\t\t/* c = c^(p^2 + 1). */\n\t\tfp12_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(t);\n\t}\n}\n\nint fp12_test_cyc(const fp12_t a) {\n\tfp12_t t0, t1;\n\tint result = 0;\n\n\tfp12_null(t0);\n\tfp12_null(t1);\n\n\tRLC_TRY {\n\t\tfp12_new(t0);\n\t\tfp12_new(t1);\n\n\t\t/* Check if a^(p^4 - p^2 + 1) == 1. */\n\t\tfp12_frb(t0, a, 4);\n\t\tfp12_mul(t0, t0, a);\n\t\tfp12_frb(t1, a, 2);\n\n\t\tresult = ((fp12_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(t0);\n\t\tfp12_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp12_back_cyc(fp12_t c, const fp12_t a) {\n\tfp2_t t0, t1, t2;\n\n\tfp2_null(t0);\n\tfp2_null(t1);\n\tfp2_null(t2);\n\n\tRLC_TRY {\n\t\tfp2_new(t0);\n\t\tfp2_new(t1);\n\t\tfp2_new(t2);\n\n\t\tif (fp2_is_zero(a[1][0])) {\n\t\t\t/* t0 = 2 * g4 * g5 */\n\t\t\tfp2_mul(t0, a[0][1], a[1][2]);\n\t\t\tfp2_dbl(t0, t0);\n\t\t\tfp2_copy(t1, a[0][2]);\n\t\t} else {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp2_sqr(t0, a[0][1]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp2_sub(t1, t0, a[0][2]);\n\t\t\tfp2_dbl(t1, t1);\n\t\t\tfp2_add(t1, t1, t0);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp2_sqr(t2, a[1][2]);\n\t\t\tfp2_mul_nor(t0, t2);\n\t\t\tfp2_add(t0, t0, t1);\n\t\t\t/* t1 = 1/(4 * g2). */\n\t\t\tfp2_dbl(t1, a[1][0]);\n\t\t\tfp2_dbl(t1, t1);\n\t\t}\n\n\t\tfp2_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp2_mul(c[1][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp2_mul(t1, a[0][2], a[0][1]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp2_sqr(t2, c[1][1]);\n\t\tfp2_sub(t2, t2, t1);\n\t\tfp2_dbl(t2, t2);\n\t\tfp2_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp2_mul(t1, a[1][0], a[1][2]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp2_add(t2, t2, t1);\n\t\tfp2_mul_nor(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0], c[0][0][0], 1);\n\n\t\tfp2_copy(c[0][1], a[0][1]);\n\t\tfp2_copy(c[0][2], a[0][2]);\n\t\tfp2_copy(c[1][0], a[1][0]);\n\t\tfp2_copy(c[1][2], a[1][2]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t0);\n\t\tfp2_free(t1);\n\t\tfp2_free(t2);\n\t}\n}\n\nvoid fp12_back_cyc_sim(fp12_t c[], const fp12_t a[], int n) {\n    fp2_t *t = RLC_ALLOCA(fp2_t, n * 3);\n    fp2_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp2_null(t0[i]);\n\t\t\tfp2_null(t1[i]);\n\t\t\tfp2_null(t2[i]);\n\t\t\tfp2_new(t0[i]);\n\t\t\tfp2_new(t1[i]);\n\t\t\tfp2_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* TODO: make this constant time. */\n\t\t\tif (fp2_is_zero(a[i][1][0])) {\n\t\t\t\t/* t0 = 2 * g4 * g5 */\n\t\t\t\tfp2_mul(t0[i], a[i][0][1], a[i][1][2]);\n\t\t\t\tfp2_dbl(t0[i], t0[i]);\n\t\t\t\tfp2_copy(t1[i], a[i][0][2]);\n\t\t\t} else {\n\t\t\t\t/* t0 = g4^2. */\n\t\t\t\tfp2_sqr(t0[i], a[i][0][1]);\n\t\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\t\tfp2_sub(t1[i], t0[i], a[i][0][2]);\n\t\t\t\tfp2_dbl(t1[i], t1[i]);\n\t\t\t\tfp2_add(t1[i], t1[i], t0[i]);\n\t\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\t\tfp2_sqr(t2[i], a[i][1][2]);\n\t\t\t\tfp2_mul_nor(t0[i], t2[i]);\n\t\t\t\tfp2_add(t0[i], t0[i], t1[i]);\n\t\t\t\t/* t1 = (4 * g2). */\n\t\t\t\tfp2_dbl(t1[i], a[i][1][0]);\n\t\t\t\tfp2_dbl(t1[i], t1[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp2_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp2_mul(c[i][1][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp2_mul(t1[i], a[i][0][2], a[i][0][1]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp2_sqr(t2[i], c[i][1][1]);\n\t\t\tfp2_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp2_dbl(t2[i], t2[i]);\n\t\t\tfp2_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp2_mul(t1[i], a[i][1][0], a[i][1][2]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp2_add(t2[i], t2[i], t1[i]);\n\t\t\tfp2_mul_nor(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0], c[i][0][0][0], 1);\n\n\t\t\tfp2_copy(c[i][0][1], a[i][0][1]);\n\t\t\tfp2_copy(c[i][0][2], a[i][0][2]);\n\t\t\tfp2_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp2_copy(c[i][1][2], a[i][1][2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp2_free(t0[i]);\n\t\t\tfp2_free(t1[i]);\n\t\t\tfp2_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n\tint i, j, k, l, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp12_set_dig(c, 1);\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tint _l[4];\n\t\tint8_t naf[4][RLC_FP_BITS + 1];\n\t\tfp12_t t[4];\n\t\tbn_t _b[4], n, u;\n\n\t\tbn_null(n);\n\t\tbn_null(u);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(n);\n\t\t\tbn_new(u);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_null(_b[i]);\n\t\t\t\tbn_new(_b[i]);\n\t\t\t\tfp12_null(t[i]);\n\t\t\t\tfp12_new(t[i]);\n\t\t\t}\n\n\t\t\tep_curve_get_ord(n);\n\t\t\tfp_prime_get_par(u);\n\t\t\tbn_rec_frb(_b, 4, b, u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\t\tif (ep_curve_is_pairf()) {\n\t\t\t\tfp12_copy(t[0], a);\n\t\t\t\tfp12_frb(t[1], t[0], 1);\n\t\t\t\tfp12_frb(t[2], t[1], 1);\n\t\t\t\tfp12_frb(t[3], t[2], 1);\n\n\t\t\t\tl = 0;\n\t\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n\t\t\t\t\t\tfp12_inv_cyc(t[i], t[i]);\n\t\t\t\t\t}\n\t\t\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\t\t\tbn_rec_naf(naf[i], &_l[i], _b[i], 2);\n\t\t\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t\t}\n\n\t\t\t\tfp12_set_dig(c, 1);\n\t\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\t\tfp12_sqr_cyc(c, c);\n\t\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t\tif (naf[j][i] > 0) {\n\t\t\t\t\t\t\tfp12_mul(c, c, t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[j][i] < 0) {\n\t\t\t\t\t\t\tfp12_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t\tfp12_mul(c, c, t[j]);\n\t\t\t\t\t\t\tfp12_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfp12_copy(t[0], a);\n\n\t\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\t\tfp12_sqr_cyc(t[0], t[0]);\n\t\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\t\tfp12_mul(t[0], t[0], a);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfp12_copy(c, t[0]);\n\t\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\t\tfp12_inv_cyc(c, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tbn_free(n);\n\t\t\tbn_free(u);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_free(_b[i]);\n\t\t\t\tfp12_free(t[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfp12_t t, *u = RLC_ALLOCA(fp12_t, w);\n\n\t\tfp12_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp12_null(u[i]);\n\t\t\t\tfp12_new(u[i]);\n\t\t\t}\n\t\t\tfp12_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp12_copy(t, a);\n\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp12_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp12_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp12_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp12_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp12_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (i = j; i < k; i++) {\n\t\t\t\tfp12_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp12_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp12_free(u[i]);\n\t\t\t}\n\t\t\tfp12_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d) {\n\tint i, l, n0, n1, l0, l1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp2_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp2_t s, t1[1 << (EP_WIDTH - 2)];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp2_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp2_exp_cyc(e, a, b);\n\t}\n\n\tfp2_null(r);\n\tfp2_null(s);\n\n\tRLC_TRY {\n\t\tfp2_new(r);\n\t\tfp2_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp2_null(t0[i]);\n\t\t\tfp2_null(t1[i]);\n\t\t\tfp2_new(t0[i]);\n\t\t\tfp2_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp2_sqr(t0[0], a);\n\t\tfp2_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_mul(t0[i], t0[i - 1], t0[0]);\n\t\t}\n\n\t\tfp2_sqr(t1[0], c);\n\t\tfp2_mul(t1[1], t1[0], c);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_mul(t1[i], t1[i - 1], t1[0]);\n\t\t}\n#endif\n\t\tfp2_copy(t0[0], a);\n\t\tfp2_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp2_set_dig(r, 1);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp2_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp2_mul(r, r, t0[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp2_inv_cyc(s, t0[-n0 / 2]);\n\t\t\t\tfp2_mul(r, r, s);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tfp2_mul(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tfp2_inv_cyc(s, t1[-n1 / 2]);\n\t\t\t\tfp2_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tfp2_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(r);\n\t\tfp2_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_free(t0[i]);\n\t\t\tfp2_free(t1[i]);\n\t\t}\n\t}\n}\n\n\nvoid fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, const bn_t d) {\n\tint i, j, l;\n\tbn_t _b[4], _d[4], n, x;\n\tfp12_t t[4], u[4];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp12_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp12_exp_cyc(e, a, b);\n\t}\n\n\tbn_null(n);\n\tbn_null(x);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(x);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_b[i]);\n\t\t\tbn_null(_d[i]);\n\t\t\tfp12_null(t[i]);\n\t\t\tfp12_null(u[i]);\n\t\t\tbn_new(_b[i]);\n\t\t\tbn_new(_d[i]);\n\t\t\tfp12_new(t[i]);\n\t\t\tfp12_new(u[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tfp_prime_get_par(x);\n\t\tbn_rec_frb(_b, 4, b, x, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_rec_frb(_d, 4, d, x, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tif (ep_curve_is_pairf()) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tfp12_frb(t[i], a, i);\n\t\t\t\tfp12_frb(u[i], c, i);\n\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n\t\t\t\t\tfp12_inv_cyc(t[i], t[i]);\n\t\t\t\t}\n\t\t\t\tif (bn_sign(_d[i]) == RLC_NEG) {\n\t\t\t\t\tfp12_inv_cyc(u[i], u[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = RLC_MAX(bn_bits(_b[0]), bn_bits(_b[1]));\n\t\t\tl = RLC_MAX(l, RLC_MAX(bn_bits(_b[2]), bn_bits(_b[3])));\n\t\t\tl = RLC_MAX(l, RLC_MAX(bn_bits(_d[0]), bn_bits(_d[1])));\n\t\t\tl = RLC_MAX(l, RLC_MAX(bn_bits(_d[2]), bn_bits(_d[3])));\n\n\t\t\tfp12_set_dig(e, 1);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfp12_sqr_cyc(e, e);\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\tif (bn_get_bit(_b[j], i)) {\n\t\t\t\t\t\tfp12_mul(e, e, t[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (bn_get_bit(_d[j], i)) {\n\t\t\t\t\t\tfp12_mul(e, e, u[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp12_inv_cyc(t[0], a);\n\t\t\t} else {\n\t\t\t\tfp12_copy(t[0], a);\n\t\t\t}\n\t\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\t\tfp12_inv_cyc(u[0], c);\n\t\t\t} else {\n\t\t\t\tfp12_copy(u[0], c);\n\t\t\t}\n\n\t\t\tfp12_set_dig(e, 1);\n\t\t\tl = RLC_MAX(bn_bits(b), bn_bits(d));\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfp12_sqr_cyc(e, e);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp12_mul(e, e, t[0]);\n\t\t\t\t}\n\t\t\t\tif (bn_get_bit(d, i)) {\n\t\t\t\t\tfp12_mul(e, e, u[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(x);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_b[i]);\n\t\t\tbn_free(_d[i]);\n\t\t\tfp12_free(t[i]);\n\t\t\tfp12_free(u[i]);\n\t\t}\n\t}\n}\n\nvoid fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp12_t t, *u = RLC_ALLOCA(fp12_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp12_null(u[i]);\n\t\t\tfp12_new(u[i]);\n\t\t}\n\t\tfp12_new(t);\n\n\t\tfp12_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp12_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp12_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp12_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp12_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp12_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp12_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp12_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp12_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp12_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp12_back_cyc_sim(u, u, w);\n\n\t\t\tfp12_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp12_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp12_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp12_free(u[i]);\n\t\t}\n\t\tfp12_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n\nvoid fp24_conv_cyc(fp24_t c, const fp24_t a) {\n\tfp24_t t;\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tfp24_new(t);\n\n\t\t/* First, compute c = a^(p^12 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp24_inv(t, a);\n\t\t/* c = a^(p^12). */\n\t\tfp24_inv_cyc(c, a);\n\t\t/* c = a^(p^12 - 1). */\n\t\tfp24_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^4 + 1). */\n\t\t/* t = c^(p^4). */\n\t\tfp24_frb(t, c, 4);\n\n\t\t/* c = c^(p^4 + 1). */\n\t\tfp24_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(t);\n\t}\n}\n\nint fp24_test_cyc(const fp24_t a) {\n\tfp24_t t0, t1;\n\tint result = 0;\n\n\tfp24_null(t0);\n\tfp24_null(t1);\n\n\tRLC_TRY {\n\t\tfp24_new(t0);\n\t\tfp24_new(t1);\n\n\t\t/* Check if a^(p^8 - p^4 + 1) == 1. */\n\t\tfp24_frb(t0, a, 8);\n\t\tfp24_mul(t0, t0, a);\n\t\tfp24_frb(t1, a, 4);\n\n\t\tresult = ((fp24_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(t0);\n\t\tfp24_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp24_back_cyc(fp24_t c, const fp24_t a) {\n\tfp4_t t0, t1, t2;\n\n\tfp4_null(t0);\n\tfp4_null(t1);\n\tfp4_null(t2);\n\n\tRLC_TRY {\n\t\tfp4_new(t0);\n\t\tfp4_new(t1);\n\t\tfp4_new(t2);\n\n\t\t/* t0 = g4^2. */\n\t\tfp4_sqr(t0, a[2][0]);\n\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\tfp4_sub(t1, t0, a[1][1]);\n\t\tfp4_dbl(t1, t1);\n\t\tfp4_add(t1, t1, t0);\n\t\t/* t0 = E * g5^2 + t1. */\n\t\tfp4_sqr(t2, a[2][1]);\n\t\tfp4_mul_art(t0, t2);\n\t\tfp4_add(t0, t0, t1);\n\t\t/* t1 = 1/(4 * g2). */\n\t\tfp4_dbl(t1, a[1][0]);\n\t\tfp4_dbl(t1, t1);\n\t\tfp4_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp4_mul(c[0][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp4_mul(t1, a[1][1], a[2][0]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp4_sqr(t2, c[0][1]);\n\t\tfp4_sub(t2, t2, t1);\n\t\tfp4_dbl(t2, t2);\n\t\tfp4_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp4_mul(t1, a[1][0], a[2][1]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp4_add(t2, t2, t1);\n\t\tfp4_mul_art(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0][0], c[0][0][0][0], 1);\n\n\t\tfp4_copy(c[1][0], a[1][0]);\n\t\tfp4_copy(c[1][1], a[1][1]);\n\t\tfp4_copy(c[2][0], a[2][0]);\n\t\tfp4_copy(c[2][1], a[2][1]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp4_free(t0);\n\t\tfp4_free(t1);\n\t\tfp4_free(t2);\n\t}\n}\n\nvoid fp24_back_cyc_sim(fp24_t c[], const fp24_t a[], int n) {\n    fp4_t *t = RLC_ALLOCA(fp4_t, n * 3);\n    fp4_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp4_null(t0[i]);\n\t\t\tfp4_null(t1[i]);\n\t\t\tfp4_null(t2[i]);\n\t\t\tfp4_new(t0[i]);\n\t\t\tfp4_new(t1[i]);\n\t\t\tfp4_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp4_sqr(t0[i], a[i][2][0]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp4_sub(t1[i], t0[i], a[i][1][1]);\n\t\t\tfp4_dbl(t1[i], t1[i]);\n\t\t\tfp4_add(t1[i], t1[i], t0[i]);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp4_sqr(t2[i], a[i][2][1]);\n\t\t\tfp4_mul_art(t0[i], t2[i]);\n\t\t\tfp4_add(t0[i], t0[i], t1[i]);\n\t\t\t/* t1 = (4 * g2). */\n\t\t\tfp4_dbl(t1[i], a[i][1][0]);\n\t\t\tfp4_dbl(t1[i], t1[i]);\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp4_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp4_mul(c[i][0][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp4_mul(t1[i], a[i][1][1], a[i][2][0]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp4_sqr(t2[i], c[i][0][1]);\n\t\t\tfp4_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp4_dbl(t2[i], t2[i]);\n\t\t\tfp4_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp4_mul(t1[i], a[i][1][0], a[i][2][1]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp4_add(t2[i], t2[i], t1[i]);\n\t\t\tfp4_mul_art(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0][0], c[i][0][0][0][0], 1);\n\n\t\t\tfp4_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp4_copy(c[i][1][1], a[i][1][1]);\n\t\t\tfp4_copy(c[i][2][0], a[i][2][0]);\n\t\t\tfp4_copy(c[i][2][1], a[i][2][1]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp4_free(t0[i]);\n\t\t\tfp4_free(t1[i]);\n\t\t\tfp4_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n\tint i, j, k, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tint l, _l[8];\n\t\tint8_t naf[8][RLC_FP_BITS + 1];\n\t\tfp24_t t[8];\n\t\tbn_t _b[8], n, x;\n\n\t\tbn_null(n);\n\t\tbn_null(x);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(n);\n\t\t\tbn_new(x);\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tbn_null(_b[i]);\n\t\t\t\tbn_new(_b[i]);\n\t\t\t\tfp24_null(t[i]);\n\t\t\t\tfp24_new(t[i]);\n\t\t\t}\n\n\t\t\tep_curve_get_ord(n);\n\t\t\tfp_prime_get_par(x);\n\t\t\tbn_rec_frb(_b, 8, b, x, n, ep_curve_is_pairf() == EP_BN);\n\n\t\t\tif (ep_curve_is_pairf()) {\n\t\t\t\tl = 0;\n\n\t\t\t\tfp24_copy(t[0], a);\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\t\t\tbn_rec_naf(naf[i], &_l[i], _b[i], 2);\n\t\t\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tfp24_frb(t[i], t[i - 1], 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n\t\t\t\t\t\tfp24_inv_cyc(t[i], t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfp24_set_dig(c, 1);\n\t\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\t\tfp24_sqr_cyc(c, c);\n\t\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\t\tif (naf[j][i] > 0) {\n\t\t\t\t\t\t\tfp24_mul(c, c, t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[j][i] < 0) {\n\t\t\t\t\t\t\tfp24_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t\tfp24_mul(c, c, t[j]);\n\t\t\t\t\t\t\tfp24_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfp24_copy(t[0], a);\n\n\t\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\t\tfp24_sqr_cyc(t[0], t[0]);\n\t\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\t\tfp24_mul(t[0], t[0], a);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfp24_copy(c, t[0]);\n\t\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\t\tfp24_inv_cyc(c, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tbn_free(n);\n\t\t\tbn_free(x);\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tbn_free(_b[i]);\n\t\t\t\tfp24_free(t[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfp24_t t, *u = RLC_ALLOCA(fp24_t, w);\n\n\t\tfp24_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp24_null(u[i]);\n\t\t\t\tfp24_new(u[i]);\n\t\t\t}\n\t\t\tfp24_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp24_copy(t, a);\n\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp24_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp24_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp24_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp24_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp24_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (i = j; i < k; i++) {\n\t\t\t\tfp24_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp24_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp24_free(u[i]);\n\t\t\t}\n\t\t\tfp24_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint i, l, n0, n1, l0, l1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp24_exp_cyc(e, a, b);\n\t}\n\n\tfp24_null(r);\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp24_sqr(t0[0], a);\n\t\tfp24_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_mul(t0[i], t0[i - 1], t0[0]);\n\t\t}\n\n\t\tfp24_sqr(t1[0], c);\n\t\tfp24_mul(t1[1], t1[0], c);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_mul(t1[i], t1[i - 1], t1[0]);\n\t\t}\n#endif\n\t\tfp24_copy(t0[0], a);\n\t\tfp24_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp24_mul(r, r, t0[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t0[-n0 / 2]);\n\t\t\t\tfp24_mul(r, r, s);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tfp24_mul(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t1[-n1 / 2]);\n\t\t\t\tfp24_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tfp24_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}\n\nvoid fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp24_t t, *u = RLC_ALLOCA(fp24_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp24_null(u[i]);\n\t\t\tfp24_new(u[i]);\n\t\t}\n\t\tfp24_new(t);\n\n\t\tfp24_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp24_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp24_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp24_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp24_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp24_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp24_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp24_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp24_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp24_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp24_back_cyc_sim(u, u, w);\n\n\t\t\tfp24_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp24_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp24_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp24_free(u[i]);\n\t\t}\n\t\tfp24_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n\nvoid fp48_conv_cyc(fp48_t c, const fp48_t a) {\n\tfp48_t t;\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tfp48_new(t);\n\n\t\t/* First, compute c = a^(p^24 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp48_inv(t, a);\n\t\t/* c = a^(p^24). */\n\t\tfp48_inv_cyc(c, a);\n\t\t/* c = a^(p^24 - 1). */\n\t\tfp48_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^8 + 1). */\n\t\t/* t = c^(p^8). */\n\t\tfp48_frb(t, c, 8);\n\n\t\t/* c = c^(p^8 + 1). */\n\t\tfp48_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(t);\n\t}\n}\n\nint fp48_test_cyc(const fp48_t a) {\n\tfp48_t t0, t1;\n\tint result = 0;\n\n\tfp48_null(t0);\n\tfp48_null(t1);\n\n\tRLC_TRY {\n\t\tfp48_new(t0);\n\t\tfp48_new(t1);\n\n\t\t/* Check if a^(p^16 - p^8 + 1) == 1. */\n\t\tfp48_frb(t0, a, 16);\n\t\tfp48_mul(t0, t0, a);\n\t\tfp48_frb(t1, a, 8);\n\n\t\tresult = ((fp48_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(t0);\n\t\tfp48_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp48_back_cyc(fp48_t c, const fp48_t a) {\n\tfp8_t t0, t1, t2;\n\n\tfp8_null(t0);\n\tfp8_null(t1);\n\tfp8_null(t2);\n\n\tRLC_TRY {\n\t\tfp8_new(t0);\n\t\tfp8_new(t1);\n\t\tfp8_new(t2);\n\n\t\t/* t0 = g4^2. */\n\t\tfp8_sqr(t0, a[0][1]);\n\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\tfp8_sub(t1, t0, a[0][2]);\n\t\tfp8_dbl(t1, t1);\n\t\tfp8_add(t1, t1, t0);\n\t\t/* t0 = E * g5^2 + t1. */\n\t\tfp8_sqr(t2, a[1][2]);\n\t\tfp8_mul_art(t0, t2);\n\t\tfp8_add(t0, t0, t1);\n\t\t/* t1 = 1/(4 * g2). */\n\t\tfp8_dbl(t1, a[1][0]);\n\t\tfp8_dbl(t1, t1);\n\t\tfp8_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp8_mul(c[1][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp8_mul(t1, a[0][2], a[0][1]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp8_sqr(t2, c[1][1]);\n\t\tfp8_sub(t2, t2, t1);\n\t\tfp8_dbl(t2, t2);\n\t\tfp8_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp8_mul(t1, a[1][0], a[1][2]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp8_add(t2, t2, t1);\n\t\tfp8_mul_art(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0][0][0], c[0][0][0][0][0], 1);\n\n\t\tfp8_copy(c[0][1], a[0][1]);\n\t\tfp8_copy(c[0][2], a[0][2]);\n\t\tfp8_copy(c[1][0], a[1][0]);\n\t\tfp8_copy(c[1][2], a[1][2]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t0);\n\t\tfp8_free(t1);\n\t\tfp8_free(t2);\n\t}\n}\n\nvoid fp48_back_cyc_sim(fp48_t c[], const fp48_t a[], int n) {\n    fp8_t *t = RLC_ALLOCA(fp8_t, n * 3);\n    fp8_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp8_null(t0[i]);\n\t\t\tfp8_null(t1[i]);\n\t\t\tfp8_null(t2[i]);\n\t\t\tfp8_new(t0[i]);\n\t\t\tfp8_new(t1[i]);\n\t\t\tfp8_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp8_sqr(t0[i], a[i][0][1]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp8_sub(t1[i], t0[i], a[i][0][2]);\n\t\t\tfp8_dbl(t1[i], t1[i]);\n\t\t\tfp8_add(t1[i], t1[i], t0[i]);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp8_sqr(t2[i], a[i][1][2]);\n\t\t\tfp8_mul_art(t0[i], t2[i]);\n\t\t\tfp8_add(t0[i], t0[i], t1[i]);\n\t\t\t/* t1 = (4 * g2). */\n\t\t\tfp8_dbl(t1[i], a[i][1][0]);\n\t\t\tfp8_dbl(t1[i], t1[i]);\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp8_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp8_mul(c[i][1][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp8_mul(t1[i], a[i][0][2], a[i][0][1]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp8_sqr(t2[i], c[i][1][1]);\n\t\t\tfp8_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp8_dbl(t2[i], t2[i]);\n\t\t\tfp8_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp8_mul(t1[i], a[i][1][0], a[i][1][2]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp8_add(t2[i], t2[i], t1[i]);\n\t\t\tfp8_mul_art(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0][0][0], c[i][0][0][0][0][0], 1);\n\n\t\t\tfp8_copy(c[i][0][1], a[i][0][1]);\n\t\t\tfp8_copy(c[i][0][2], a[i][0][2]);\n\t\t\tfp8_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp8_copy(c[i][1][2], a[i][1][2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp8_free(t0[i]);\n\t\t\tfp8_free(t1[i]);\n\t\t\tfp8_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b) {\n\tint i, j, k, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp48_set_dig(c, 1);\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tfp48_t t;\n\n\t\tfp48_null(t)\n\n\t\tRLC_TRY {\n\t\t\tfp48_new(t);\n\n\t\t\tfp48_copy(t, a);\n\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr_cyc(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp48_copy(c, t);\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp48_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfp48_free(t);\n\t\t}\n\t} else {\n\t\tfp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\t\tfp48_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp48_null(u[i]);\n\t\t\t\tfp48_new(u[i]);\n\t\t\t}\n\t\t\tfp48_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp48_copy(t, a);\n\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp48_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp48_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp48_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp48_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp48_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (i = j; i < k; i++) {\n\t\t\t\tfp48_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp48_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp48_free(u[i]);\n\t\t\t}\n\t\t\tfp48_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp48_null(u[i]);\n\t\t\tfp48_new(u[i]);\n\t\t}\n\t\tfp48_new(t);\n\n\t\tfp48_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp48_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp48_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp48_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp48_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp48_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp48_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp48_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp48_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp48_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp48_back_cyc_sim(u, u, w);\n\n\t\t\tfp48_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp48_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp48_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp48_free(u[i]);\n\t\t}\n\t\tfp48_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n\nvoid fp54_conv_cyc(fp54_t c, const fp54_t a) {\n\tfp54_t t;\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tfp54_new(t);\n\n\t\t/* First, compute c = a^(p^27 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp54_inv(t, a);\n\t\t/* c = a^(p^27). */\n\t\tfp54_inv_cyc(c, a);\n\t\t/* c = a^(p^27 - 1). */\n\t\tfp54_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^9 + 1). */\n\t\t/* t = c^(p^9). */\n\t\tfp54_frb(t, c, 9);\n\n\t\t/* c = c^(p^9 + 1). */\n\t\tfp54_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(t);\n\t}\n}\n\nint fp54_test_cyc(const fp54_t a) {\n\tfp54_t t0, t1;\n\tint result = 0;\n\n\tfp54_null(t0);\n\tfp54_null(t1);\n\n\tRLC_TRY {\n\t\tfp54_new(t0);\n\t\tfp54_new(t1);\n\n\t\t/* Check if a^(p^18 - p^9 + 1) == 1. */\n\t\tfp54_frb(t0, a, 18);\n\t\tfp54_mul(t0, t0, a);\n\t\tfp54_frb(t1, a, 9);\n\t\tresult = ((fp54_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(t0);\n\t\tfp54_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp54_back_cyc(fp54_t c, const fp54_t a) {\n\tfp9_t t0, t1, t2;\n\n\tfp9_null(t0);\n\tfp9_null(t1);\n\tfp9_null(t2);\n\n\tRLC_TRY {\n\t\tfp9_new(t0);\n\t\tfp9_new(t1);\n\t\tfp9_new(t2);\n\n\t\t/* t0 = g4^2. */\n\t\tfp9_sqr(t0, a[2][0]);\n\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\tfp9_sub(t1, t0, a[1][1]);\n\t\tfp9_dbl(t1, t1);\n\t\tfp9_add(t1, t1, t0);\n\t\t/* t0 = E * g5^2 + t1. */\n\t\tfp9_sqr(t2, a[2][1]);\n\t\tfp9_mul_art(t0, t2);\n\t\tfp9_add(t0, t0, t1);\n\t\t/* t1 = 1/(4 * g2). */\n\t\tfp9_dbl(t1, a[1][0]);\n\t\tfp9_dbl(t1, t1);\n\t\tfp9_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp9_mul(c[0][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp9_mul(t1, a[1][1], a[2][0]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp9_sqr(t2, c[0][1]);\n\t\tfp9_sub(t2, t2, t1);\n\t\tfp9_dbl(t2, t2);\n\t\tfp9_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp9_mul(t1, a[1][0], a[2][1]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp9_add(t2, t2, t1);\n\t\tfp9_mul_art(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0][0], c[0][0][0][0], 1);\n\n\t\tfp9_copy(c[1][0], a[1][0]);\n\t\tfp9_copy(c[1][1], a[1][1]);\n\t\tfp9_copy(c[2][0], a[2][0]);\n\t\tfp9_copy(c[2][1], a[2][1]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp9_free(t0);\n\t\tfp9_free(t1);\n\t\tfp9_free(t2);\n\t}\n}\n\nvoid fp54_back_cyc_sim(fp54_t c[], const fp54_t a[], int n) {\n    fp9_t *t = RLC_ALLOCA(fp9_t, n * 3);\n    fp9_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp9_null(t0[i]);\n\t\t\tfp9_null(t1[i]);\n\t\t\tfp9_null(t2[i]);\n\t\t\tfp9_new(t0[i]);\n\t\t\tfp9_new(t1[i]);\n\t\t\tfp9_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp9_sqr(t0[i], a[i][2][0]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp9_sub(t1[i], t0[i], a[i][1][1]);\n\t\t\tfp9_dbl(t1[i], t1[i]);\n\t\t\tfp9_add(t1[i], t1[i], t0[i]);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp9_sqr(t2[i], a[i][2][1]);\n\t\t\tfp9_mul_art(t0[i], t2[i]);\n\t\t\tfp9_add(t0[i], t0[i], t1[i]);\n\t\t\t/* t1 = (4 * g2). */\n\t\t\tfp9_dbl(t1[i], a[i][1][0]);\n\t\t\tfp9_dbl(t1[i], t1[i]);\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp9_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp9_mul(c[i][0][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp9_mul(t1[i], a[i][1][1], a[i][2][0]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp9_sqr(t2[i], c[i][0][1]);\n\t\t\tfp9_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp9_dbl(t2[i], t2[i]);\n\t\t\tfp9_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp9_mul(t1[i], a[i][1][0], a[i][2][1]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp9_add(t2[i], t2[i], t1[i]);\n\t\t\tfp9_mul_art(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0][0], c[i][0][0][0][0], 1);\n\n\t\t\tfp9_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp9_copy(c[i][1][1], a[i][1][1]);\n\t\t\tfp9_copy(c[i][2][0], a[i][2][0]);\n\t\t\tfp9_copy(c[i][2][1], a[i][2][1]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp9_free(t0[i]);\n\t\t\tfp9_free(t1[i]);\n\t\t\tfp9_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b) {\n\tint i, j, k, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp54_set_dig(c, 1);\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tfp54_t t;\n\n\t\tfp54_null(t)\n\n\t\tRLC_TRY {\n\t\t\tfp54_new(t);\n\n\t\t\tfp54_copy(t, a);\n\n\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp54_sqr_cyc(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp54_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp54_copy(c, t);\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp54_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfp54_free(t);\n\t\t}\n\t} else {\n\t\tfp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\t\tfp54_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY)\n\t\t\t}\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp54_null(u[i]);\n\t\t\t\tfp54_new(u[i]);\n\t\t\t}\n\t\t\tfp54_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp54_copy(t, a);\n\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp54_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp54_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp54_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp54_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp54_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (i = j; i < k; i++) {\n\t\t\t\tfp54_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp54_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp54_free(u[i]);\n\t\t\t}\n\t\t\tfp54_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp54_null(u[i]);\n\t\t\tfp54_new(u[i]);\n\t\t}\n\t\tfp54_new(t);\n\n\t\tfp54_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp54_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp54_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp54_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp54_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp54_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp54_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp54_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp54_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp54_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp54_back_cyc_sim(u, u, w);\n\n\t\t\tfp54_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp54_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp54_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp54_free(u[i]);\n\t\t}\n\t\tfp54_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of exponentiation in extensions defined over prime fields.\n *\n * @ingroup fpx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp2_exp(fp2_t c, const fp2_t a, const bn_t b) {\n\tfp2_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp2_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tfp2_copy(t, a);\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp2_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp2_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp2_inv(c, t);\n\t\t} else {\n\t\t\tfp2_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nvoid fp2_exp_dig(fp2_t c, const fp2_t a, dig_t b) {\n\tfp2_t t;\n\n\tif (b == 0) {\n\t\tfp2_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tfp2_copy(t, a);\n\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\tfp2_sqr(t, t);\n\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\tfp2_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tfp2_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nvoid fp3_exp(fp3_t c, const fp3_t a, const bn_t b) {\n\tfp3_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp3_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp3_null(t);\n\n\tRLC_TRY {\n\t\tfp3_new(t);\n\n\t\tfp3_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp3_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp3_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp3_inv(c, t);\n\t\t} else {\n\t\t\tfp3_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp3_free(t);\n\t}\n}\n\nvoid fp4_exp(fp4_t c, const fp4_t a, const bn_t b) {\n\tfp4_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp4_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp4_null(t);\n\n\tRLC_TRY {\n\t\tfp4_new(t);\n\n\t\tfp4_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp4_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp4_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp4_inv(c, t);\n\t\t} else {\n\t\t\tfp4_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp4_free(t);\n\t}\n}\n\nvoid fp6_exp(fp6_t c, const fp6_t a, const bn_t b) {\n\tfp6_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp6_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp6_null(t);\n\n\tRLC_TRY {\n\t\tfp6_new(t);\n\n\t\tfp6_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp6_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp6_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp6_inv(c, t);\n\t\t} else {\n\t\t\tfp6_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp6_free(t);\n\t}\n}\n\nvoid fp8_exp(fp8_t c, const fp8_t a, const bn_t b) {\n\tfp8_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp8_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp8_null(t);\n\n\tRLC_TRY {\n\t\tfp8_new(t);\n\n\t\tif (fp8_test_cyc(a)) {\n\t\t\tfp8_exp_cyc(c, a, b);\n\t\t} else {\n\t\t\tfp8_copy(t, a);\n\n\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp8_sqr(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp8_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp8_inv(c, t);\n\t\t\t} else {\n\t\t\t\tfp8_copy(c, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t);\n\t}\n}\n\nvoid fp9_exp(fp9_t c, const fp9_t a, const bn_t b) {\n\tfp9_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp9_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp9_null(t);\n\n\tRLC_TRY {\n\t\tfp9_new(t);\n\n\t\tfp9_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp9_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp9_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp9_inv(c, t);\n\t\t} else {\n\t\t\tfp9_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp9_free(t);\n\t}\n}\n\nvoid fp12_exp(fp12_t c, const fp12_t a, const bn_t b) {\n\tfp12_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tfp12_new(t);\n\n\t\tif (fp12_test_cyc(a)) {\n\t\t\tfp12_exp_cyc(c, a, b);\n\t\t} else {\n\t\t\tfp12_copy(t, a);\n\n\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp12_sqr(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp12_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp12_inv(c, t);\n\t\t\t} else {\n\t\t\t\tfp12_copy(c, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(t);\n\t}\n}\n\nvoid fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp12_null(t);\n\tfp12_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp12_new(t);\n\t\tfp12_new(v);\n\n\t\tfp12_copy(t, a);\n\n\t\tif (fp12_test_cyc(a)) {\n\t\t\tfp12_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp12_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp12_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp12_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp12_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp12_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp12_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp12_free(t);\n\t\tfp12_free(v);\n\t}\n}\n\nvoid fp18_exp(fp18_t c, const fp18_t a, const bn_t b) {\n\tfp18_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp18_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp18_null(t);\n\n\tRLC_TRY {\n\t\tfp18_new(t);\n\n\t\tfp18_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp18_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp18_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp18_inv(c, t);\n\t\t} else {\n\t\t\tfp18_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp18_free(t);\n\t}\n}\n\nvoid fp24_exp(fp24_t c, const fp24_t a, const bn_t b) {\n\tfp24_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tfp24_new(t);\n\n\t\tfp24_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp24_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp24_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp24_inv(c, t);\n\t\t} else {\n\t\t\tfp24_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(t);\n\t}\n}\n\nvoid fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp24_null(t);\n\tfp24_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp24_new(t);\n\t\tfp24_new(v);\n\n\t\tfp24_copy(t, a);\n\n\t\tif (fp24_test_cyc(a)) {\n\t\t\tfp24_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp24_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp24_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp24_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp24_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp24_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp24_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp24_free(t);\n\t\tfp24_free(v);\n\t}\n}\n\nvoid fp48_exp(fp48_t c, const fp48_t a, const bn_t b) {\n\tfp48_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tfp48_new(t);\n\n\t\tif (fp48_test_cyc(a)) {\n\t\t\tfp48_exp_cyc(c, a, b);\n\t\t} else {\n\t\t\tfp48_copy(t, a);\n\n\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp48_inv(c, t);\n\t\t\t} else {\n\t\t\t\tfp48_copy(c, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(t);\n\t}\n}\n\nvoid fp48_exp_dig(fp48_t c, const fp48_t a, dig_t b) {\n\tbn_t _b;\n\tfp48_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp48_null(t);\n\tfp48_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp48_new(t);\n\t\tfp48_new(v);\n\n\t\tfp48_copy(t, a);\n\n\t\tif (fp48_test_cyc(a)) {\n\t\t\tfp48_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp48_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp48_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp48_free(t);\n\t\tfp48_free(v);\n\t}\n}\n\nvoid fp54_exp(fp54_t c, const fp54_t a, const bn_t b) {\n\tfp54_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tfp54_new(t);\n\n\t\tfp54_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp54_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp54_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp54_inv(c, t);\n\t\t} else {\n\t\t\tfp54_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(t);\n\t}\n}\n\nvoid fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b) {\n\tbn_t _b;\n\tfp54_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp54_null(t);\n\tfp54_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp54_new(t);\n\t\tfp54_new(v);\n\n\t\tfp54_copy(t, a);\n\n\t\tif (fp54_test_cyc(a)) {\n\t\t\tfp54_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp54_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp54_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp54_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp54_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp54_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp54_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp54_free(t);\n\t\tfp54_free(v);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of utilities in extensions defined over prime fields.\n *\n * @ingroup fpx\n */\n\n#include \"relic_core.h\"\n#include \"relic_fpx_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp2_copy(fp2_t c, const fp2_t a) {\n\tfp_copy(c[0], a[0]);\n\tfp_copy(c[1], a[1]);\n}\n\nvoid fp2_zero(fp2_t a) {\n\tfp_zero(a[0]);\n\tfp_zero(a[1]);\n}\n\nint fp2_is_zero(const fp2_t a) {\n\treturn fp_is_zero(a[0]) && fp_is_zero(a[1]);\n}\n\nvoid fp2_rand(fp2_t a) {\n\tfp_rand(a[0]);\n\tfp_rand(a[1]);\n}\n\nvoid fp2_print(const fp2_t a) {\n\tfp_print(a[0]);\n\tfp_print(a[1]);\n}\n\nint fp2_size_bin(fp2_t a, int pack) {\n\tif (pack) {\n\t\tif (fp2_test_cyc(a)) {\n\t\t\treturn RLC_FP_BYTES + 1;\n\t\t} else {\n\t\t\treturn 2 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 2 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp2_read_bin(fp2_t a, const uint8_t *bin, int len) {\n\tif (len != RLC_FP_BYTES + 1 && len != 2 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == RLC_FP_BYTES + 1) {\n\t\tfp_read_bin(a[0], bin, RLC_FP_BYTES);\n\t\tfp_zero(a[1]);\n\t\tfp_set_bit(a[1], 0, bin[RLC_FP_BYTES]);\n\t\tfp2_upk(a, a);\n\t}\n\tif (len == 2 * RLC_FP_BYTES) {\n\t\tfp_read_bin(a[0], bin, RLC_FP_BYTES);\n\t\tfp_read_bin(a[1], bin + RLC_FP_BYTES, RLC_FP_BYTES);\n\t}\n}\n\nvoid fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tif (pack && fp2_test_cyc(a)) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfp2_pck(t, a);\n\t\t\t\tfp_write_bin(bin, RLC_FP_BYTES, t[0]);\n\t\t\t\tbin[RLC_FP_BYTES] = fp_get_bit(t[1], 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\t\t\t\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nvoid fp2_set_dig(fp2_t a, const dig_t b) {\n\tfp_set_dig(a[0], b);\n\tfp_zero(a[1]);\n}\n\nvoid fp3_copy(fp3_t c, const fp3_t a) {\n\tfp_copy(c[0], a[0]);\n\tfp_copy(c[1], a[1]);\n\tfp_copy(c[2], a[2]);\n}\n\nvoid fp3_zero(fp3_t a) {\n\tfp_zero(a[0]);\n\tfp_zero(a[1]);\n\tfp_zero(a[2]);\n}\n\nint fp3_is_zero(const fp3_t a) {\n\treturn fp_is_zero(a[0]) && fp_is_zero(a[1]) && fp_is_zero(a[2]);\n}\n\nvoid fp3_rand(fp3_t a) {\n\tfp_rand(a[0]);\n\tfp_rand(a[1]);\n\tfp_rand(a[2]);\n}\n\nvoid fp3_print(const fp3_t a) {\n\tfp_print(a[0]);\n\tfp_print(a[1]);\n\tfp_print(a[2]);\n}\n\nint fp3_size_bin(fp3_t a) {\n\treturn 3 * RLC_FP_BYTES;\n}\n\nvoid fp3_read_bin(fp3_t a, const uint8_t *bin, int len) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_read_bin(a[0], bin, RLC_FP_BYTES);\n\tfp_read_bin(a[1], bin + RLC_FP_BYTES, RLC_FP_BYTES);\n\tfp_read_bin(a[2], bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES);\n}\n\nvoid fp3_write_bin(uint8_t *bin, int len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\tfp_write_bin(bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES, a[2]);\n}\n\nvoid fp3_set_dig(fp3_t a, const dig_t b) {\n\tfp_set_dig(a[0], b);\n\tfp_zero(a[1]);\n\tfp_zero(a[2]);\n}\n\nvoid fp4_copy(fp4_t c, const fp4_t a) {\n\tfp2_copy(c[0], a[0]);\n\tfp2_copy(c[1], a[1]);\n}\n\nvoid fp4_zero(fp4_t a) {\n\tfp2_zero(a[0]);\n\tfp2_zero(a[1]);\n}\n\nint fp4_is_zero(const fp4_t a) {\n\treturn fp2_is_zero(a[0]) && fp2_is_zero(a[1]);\n}\n\nvoid fp4_rand(fp4_t a) {\n\tfp2_rand(a[0]);\n\tfp2_rand(a[1]);\n}\n\nvoid fp4_print(const fp4_t a) {\n\tfp2_print(a[0]);\n\tfp2_print(a[1]);\n}\n\nint fp4_size_bin(fp4_t a) {\n\treturn 4 * RLC_FP_BYTES;\n}\n\nvoid fp4_read_bin(fp4_t a, const uint8_t *bin, int len) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_read_bin(a[0], bin, 2 * RLC_FP_BYTES);\n\tfp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n}\n\nvoid fp4_write_bin(uint8_t *bin, int len, const fp4_t a) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);\n\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1], 0);\n}\n\nvoid fp4_set_dig(fp4_t a, const dig_t b) {\n\tfp2_set_dig(a[0], b);\n\tfp2_zero(a[1]);\n}\n\nvoid fp6_copy(fp6_t c, const fp6_t a) {\n\tfp2_copy(c[0], a[0]);\n\tfp2_copy(c[1], a[1]);\n\tfp2_copy(c[2], a[2]);\n}\n\nvoid fp6_zero(fp6_t a) {\n\tfp2_zero(a[0]);\n\tfp2_zero(a[1]);\n\tfp2_zero(a[2]);\n}\n\nint fp6_is_zero(const fp6_t a) {\n\treturn fp2_is_zero(a[0]) && fp2_is_zero(a[1]) && fp2_is_zero(a[2]);\n}\n\nvoid fp6_rand(fp6_t a) {\n\tfp2_rand(a[0]);\n\tfp2_rand(a[1]);\n\tfp2_rand(a[2]);\n}\n\nvoid fp6_print(const fp6_t a) {\n\tfp2_print(a[0]);\n\tfp2_print(a[1]);\n\tfp2_print(a[2]);\n}\n\nint fp6_size_bin(fp6_t a) {\n\treturn 6 * RLC_FP_BYTES;\n}\n\nvoid fp6_read_bin(fp6_t a, const uint8_t *bin, int len) {\n\tif (len != 6 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_read_bin(a[0], bin, 2 * RLC_FP_BYTES);\n\tfp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\tfp2_read_bin(a[2], bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n}\n\nvoid fp6_write_bin(uint8_t *bin, int len, const fp6_t a) {\n\tif (len != 6 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);\n\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1], 0);\n\tfp2_write_bin(bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[2], 0);\n}\n\nvoid fp6_set_dig(fp6_t a, const dig_t b) {\n\tfp2_set_dig(a[0], b);\n\tfp2_zero(a[1]);\n\tfp2_zero(a[2]);\n}\n\nvoid fp8_copy(fp8_t c, const fp8_t a) {\n\tfp4_copy(c[0], a[0]);\n\tfp4_copy(c[1], a[1]);\n}\n\nvoid fp8_zero(fp8_t a) {\n\tfp4_zero(a[0]);\n\tfp4_zero(a[1]);\n}\n\nint fp8_is_zero(const fp8_t a) {\n\treturn fp4_is_zero(a[0]) && fp4_is_zero(a[1]);\n}\n\nvoid fp8_rand(fp8_t a) {\n\tfp4_rand(a[0]);\n\tfp4_rand(a[1]);\n}\n\nvoid fp8_print(const fp8_t a) {\n\tfp4_print(a[0]);\n\tfp4_print(a[1]);\n}\n\nint fp8_size_bin(fp8_t a, int pack) {\n\tif (pack) {\n\t\tif (fp8_test_cyc(a)) {\n\t\t\treturn 4 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 8 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 8 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp8_read_bin(fp8_t a, const uint8_t *bin, int len) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_read_bin(a[0], bin, 4 * RLC_FP_BYTES);\n\tfp4_read_bin(a[1], bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n}\n\nvoid fp8_write_bin(uint8_t *bin, int len, const fp8_t a) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[0]);\n\tfp4_write_bin(bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[1]);\n}\n\nvoid fp8_set_dig(fp8_t a, const dig_t b) {\n\tfp4_set_dig(a[0], b);\n\tfp4_zero(a[1]);\n}\n\nvoid fp9_copy(fp9_t c, const fp9_t a) {\n\tfp3_copy(c[0], a[0]);\n\tfp3_copy(c[1], a[1]);\n\tfp3_copy(c[2], a[2]);\n}\n\nvoid fp9_zero(fp9_t a) {\n\tfp3_zero(a[0]);\n\tfp3_zero(a[1]);\n\tfp3_zero(a[2]);\n}\n\nint fp9_is_zero(const fp9_t a) {\n\treturn fp3_is_zero(a[0]) && fp3_is_zero(a[1]) && fp3_is_zero(a[2]);\n}\n\nvoid fp9_rand(fp9_t a) {\n\tfp3_rand(a[0]);\n\tfp3_rand(a[1]);\n\tfp3_rand(a[2]);\n}\n\nvoid fp9_print(const fp9_t a) {\n\tfp3_print(a[0]);\n\tfp3_print(a[1]);\n\tfp3_print(a[2]);\n}\n\nint fp9_size_bin(fp9_t a) {\n\treturn 9 * RLC_FP_BYTES;\n}\n\nvoid fp9_read_bin(fp9_t a, const uint8_t *bin, int len) {\n\tif (len != 9 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp3_read_bin(a[0], bin, 3 * RLC_FP_BYTES);\n\tfp3_read_bin(a[1], bin + 3 * RLC_FP_BYTES, 3 * RLC_FP_BYTES);\n\tfp3_read_bin(a[2], bin + 6 * RLC_FP_BYTES, 3 * RLC_FP_BYTES);\n}\n\nvoid fp9_write_bin(uint8_t *bin, int len, const fp9_t a) {\n\tif (len != 9 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp3_write_bin(bin, 3 * RLC_FP_BYTES, a[0]);\n\tfp3_write_bin(bin + 3 * RLC_FP_BYTES, 3 * RLC_FP_BYTES, a[1]);\n\tfp3_write_bin(bin + 6 * RLC_FP_BYTES, 3 * RLC_FP_BYTES, a[2]);\n}\n\nvoid fp9_set_dig(fp9_t a, const dig_t b) {\n\tfp3_set_dig(a[0], b);\n\tfp3_zero(a[1]);\n\tfp3_zero(a[2]);\n}\n\nvoid fp12_copy(fp12_t c, const fp12_t a) {\n\tfp6_copy(c[0], a[0]);\n\tfp6_copy(c[1], a[1]);\n}\n\nvoid fp12_zero(fp12_t a) {\n\tfp6_zero(a[0]);\n\tfp6_zero(a[1]);\n}\n\nint fp12_is_zero(const fp12_t a) {\n\treturn (fp6_is_zero(a[0]) && fp6_is_zero(a[1]));\n}\n\nvoid fp12_rand(fp12_t a) {\n\tfp6_rand(a[0]);\n\tfp6_rand(a[1]);\n}\n\nvoid fp12_print(const fp12_t a) {\n\tfp6_print(a[0]);\n\tfp6_print(a[1]);\n}\n\nint fp12_size_bin(fp12_t a, int pack) {\n\tif (pack) {\n\t\tif (fp12_test_cyc(a)) {\n\t\t\treturn 8 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 12 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 12 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp12_read_bin(fp12_t a, const uint8_t *bin, int len) {\n\tif (len != 8 * RLC_FP_BYTES && len != 12 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 8 * RLC_FP_BYTES) {\n\t\tfp2_zero(a[0][0]);\n\t\tfp2_read_bin(a[0][1], bin, 2 * RLC_FP_BYTES);\n\t\tfp2_read_bin(a[0][2], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\t\tfp2_read_bin(a[1][0], bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\t\tfp2_zero(a[1][1]);\n\t\tfp2_read_bin(a[1][2], bin + 6 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\t\tfp12_back_cyc(a, a);\n\t}\n\tif (len == 12 * RLC_FP_BYTES) {\n\t\tfp6_read_bin(a[0], bin, 6 * RLC_FP_BYTES);\n\t\tfp6_read_bin(a[1], bin + 6 * RLC_FP_BYTES, 6 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp12_write_bin(uint8_t *bin, int len, const fp12_t a, int pack) {\n\tfp12_t t;\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tfp12_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 8 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp12_pck(t, a);\n\t\t\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0][1], 0);\n\t\t\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[0][2], 0);\n\t\t\tfp2_write_bin(bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1][0], 0);\n\t\t\tfp2_write_bin(bin + 6 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1][2], 0);\n\t\t} else {\n\t\t\tif (len != 12 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp6_write_bin(bin, 6 * RLC_FP_BYTES, a[0]);\n\t\t\tfp6_write_bin(bin + 6 * RLC_FP_BYTES, 6 * RLC_FP_BYTES, a[1]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp12_free(t);\n\t}\n}\n\nvoid fp12_set_dig(fp12_t a, const dig_t b) {\n\tfp6_set_dig(a[0], b);\n\tfp6_zero(a[1]);\n}\n\nvoid fp18_copy(fp18_t c, const fp18_t a) {\n\tfp9_copy(c[0], a[0]);\n\tfp9_copy(c[1], a[1]);\n}\n\nvoid fp18_zero(fp18_t a) {\n\tfp9_zero(a[0]);\n\tfp9_zero(a[1]);\n}\n\nint fp18_is_zero(const fp18_t a) {\n\treturn (fp9_is_zero(a[0]) && fp9_is_zero(a[1]));\n}\n\nvoid fp18_rand(fp18_t a) {\n\tfp9_rand(a[0]);\n\tfp9_rand(a[1]);\n}\n\nvoid fp18_print(const fp18_t a) {\n\tfp9_print(a[0]);\n\tfp9_print(a[1]);\n}\n\nint fp18_size_bin(fp18_t a) {\n\treturn 18 * RLC_FP_BYTES;\n}\n\nvoid fp18_read_bin(fp18_t a, const uint8_t *bin, int len) {\n\tif (len != 18 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp9_read_bin(a[0], bin, 9 * RLC_FP_BYTES);\n\tfp9_read_bin(a[1], bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n}\n\nvoid fp18_write_bin(uint8_t *bin, int len, const fp18_t a) {\n\tif (len != 18 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp9_write_bin(bin, 9 * RLC_FP_BYTES, a[0]);\n\tfp9_write_bin(bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[1]);\n}\n\nvoid fp18_set_dig(fp18_t a, const dig_t b) {\n\tfp9_set_dig(a[0], b);\n\tfp9_zero(a[1]);\n}\n\nvoid fp24_copy(fp24_t c, const fp24_t a) {\n\tfp8_copy(c[0], a[0]);\n\tfp8_copy(c[1], a[1]);\n\tfp8_copy(c[2], a[2]);\n}\n\nvoid fp24_zero(fp24_t a) {\n\tfp8_zero(a[0]);\n\tfp8_zero(a[1]);\n\tfp8_zero(a[2]);\n}\n\nint fp24_is_zero(const fp24_t a) {\n\treturn fp8_is_zero(a[0]) && fp8_is_zero(a[1]) && fp8_is_zero(a[2]);\n}\n\nvoid fp24_rand(fp24_t a) {\n\tfp8_rand(a[0]);\n\tfp8_rand(a[1]);\n\tfp8_rand(a[2]);\n}\n\nvoid fp24_print(const fp24_t a) {\n\tfp8_print(a[0]);\n\tfp8_print(a[1]);\n\tfp8_print(a[2]);\n}\n\nint fp24_size_bin(fp24_t a, int pack) {\n\tif (pack) {\n\t\tif (fp24_test_cyc(a)) {\n\t\t\treturn 16 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 24 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 24 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp24_read_bin(fp24_t a, const uint8_t *bin, int len) {\n\tif (len != 16 * RLC_FP_BYTES && len != 24 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 16 * RLC_FP_BYTES) {\n\t\tfp4_zero(a[0][0]);\n\t\tfp4_zero(a[0][1]);\n\t\tfp4_read_bin(a[1][0], bin, 4 * RLC_FP_BYTES);\n\t\tfp4_read_bin(a[1][1], bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n\t\tfp4_read_bin(a[2][0], bin + 8 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n\t\tfp4_read_bin(a[2][1], bin + 12 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n\t\tfp24_back_cyc(a, a);\n\t}\n\tif (len == 24 * RLC_FP_BYTES) {\n\t\tfp8_read_bin(a[0], bin, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[1], bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[2], bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp24_write_bin(uint8_t *bin, int len, const fp24_t a, int pack) {\n\tfp24_t t;\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tfp24_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 16 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp24_pck(t, a);\n\t\t\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[1][0]);\n\t\t\tfp4_write_bin(bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[1][1]);\n\t\t\tfp4_write_bin(bin + 8 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[2][0]);\n\t\t\tfp4_write_bin(bin + 12 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[2][1]);\n\t\t} else {\n\t\t\tif (len != 24 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp8_write_bin(bin, 8 * RLC_FP_BYTES, a[0]);\n\t\t\tfp8_write_bin(bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[1]);\n\t\t\tfp8_write_bin(bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp24_free(t);\n\t}\n}\n\nvoid fp24_set_dig(fp24_t a, const dig_t b) {\n\tfp8_set_dig(a[0], b);\n\tfp8_zero(a[1]);\n\tfp8_zero(a[2]);\n}\n\nvoid fp48_copy(fp48_t c, const fp48_t a) {\n\tfp24_copy(c[0], a[0]);\n\tfp24_copy(c[1], a[1]);\n}\n\nvoid fp48_zero(fp48_t a) {\n\tfp24_zero(a[0]);\n\tfp24_zero(a[1]);\n}\n\nint fp48_is_zero(const fp48_t a) {\n\treturn (fp24_is_zero(a[0]) && fp24_is_zero(a[1]));\n}\n\nvoid fp48_rand(fp48_t a) {\n\tfp24_rand(a[0]);\n\tfp24_rand(a[1]);\n}\n\nvoid fp48_print(const fp48_t a) {\n\tfp24_print(a[0]);\n\tfp24_print(a[1]);\n}\n\nint fp48_size_bin(fp48_t a, int pack) {\n\tif (pack) {\n\t\tif (fp48_test_cyc(a)) {\n\t\t\treturn 32 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 48 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 48 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp48_read_bin(fp48_t a, const uint8_t *bin, int len) {\n\tif (len != 32 * RLC_FP_BYTES && len != 48 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 32 * RLC_FP_BYTES) {\n\t\tfp8_zero(a[0][0]);\n\t\tfp8_read_bin(a[0][1], bin, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[0][2], bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[1][0], bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp8_zero(a[1][1]);\n\t\tfp8_read_bin(a[1][2], bin + 24 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp48_back_cyc(a, a);\n\t}\n\tif (len == 48 * RLC_FP_BYTES) {\n\t\tfp24_read_bin(a[0], bin, 24 * RLC_FP_BYTES);\n\t\tfp24_read_bin(a[1], bin + 24 * RLC_FP_BYTES, 24 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp48_write_bin(uint8_t *bin, int len, const fp48_t a, int pack) {\n\tfp48_t t;\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tfp48_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 32 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp48_pck(t, a);\n\t\t\tfp8_write_bin(bin, 8 * RLC_FP_BYTES, a[0][1]);\n\t\t\tfp8_write_bin(bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[0][2]);\n\t\t\tfp8_write_bin(bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[1][0]);\n\t\t\tfp8_write_bin(bin + 24 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[1][2]);\n\t\t} else {\n\t\t\tif (len != 48 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp24_write_bin(bin, 24 * RLC_FP_BYTES, a[0], 0);\n\t\t\tfp24_write_bin(bin + 24 * RLC_FP_BYTES, 24 * RLC_FP_BYTES, a[1], 0);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp48_free(t);\n\t}\n}\n\nvoid fp48_set_dig(fp48_t a, const dig_t b) {\n\tfp24_set_dig(a[0], b);\n\tfp24_zero(a[1]);\n}\n\nvoid fp54_copy(fp54_t c, const fp54_t a) {\n\tfp18_copy(c[0], a[0]);\n\tfp18_copy(c[1], a[1]);\n\tfp18_copy(c[2], a[2]);\n}\n\nvoid fp54_zero(fp54_t a) {\n\tfp18_zero(a[0]);\n\tfp18_zero(a[1]);\n\tfp18_zero(a[2]);\n}\n\nint fp54_is_zero(const fp54_t a) {\n\treturn (fp18_is_zero(a[0]) && fp18_is_zero(a[1]) && fp18_is_zero(a[2]));\n}\n\nvoid fp54_rand(fp54_t a) {\n\tfp18_rand(a[0]);\n\tfp18_rand(a[1]);\n\tfp18_rand(a[2]);\n}\n\nvoid fp54_print(const fp54_t a) {\n\tfp18_print(a[0]);\n\tfp18_print(a[1]);\n\tfp18_print(a[2]);\n}\n\nint fp54_size_bin(fp54_t a, int pack) {\n\tif (pack) {\n\t\tif (fp54_test_cyc(a)) {\n\t\t\treturn 36 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 54 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 54 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp54_read_bin(fp54_t a, const uint8_t *bin, int len) {\n\tif (len != 36 * RLC_FP_BYTES && len != 54 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 36 * RLC_FP_BYTES) {\n\t\tfp9_zero(a[0][0]);\n\t\tfp9_zero(a[0][1]);\n\t\tfp9_read_bin(a[1][0], bin, 9 * RLC_FP_BYTES);\n\t\tfp9_read_bin(a[1][1], bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n\t\tfp9_read_bin(a[2][0], bin + 18 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n\t\tfp9_read_bin(a[2][1], bin + 27 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n\t\tfp54_back_cyc(a, a);\n\t}\n\tif (len == 54 * RLC_FP_BYTES) {\n\t\tfp18_read_bin(a[0], bin, 18 * RLC_FP_BYTES);\n\t\tfp18_read_bin(a[1], bin + 18 * RLC_FP_BYTES, 18 * RLC_FP_BYTES);\n\t\tfp18_read_bin(a[2], bin + 36 * RLC_FP_BYTES, 18 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp54_write_bin(uint8_t *bin, int len, const fp54_t a, int pack) {\n\tfp54_t t;\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tfp54_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 36 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp54_pck(t, a);\n\t\t\tfp9_write_bin(bin, 9 * RLC_FP_BYTES, a[1][0]);\n\t\t\tfp9_write_bin(bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[1][1]);\n\t\t\tfp9_write_bin(bin + 18 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][0]);\n\t\t\tfp9_write_bin(bin + 27 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][1]);\n\t\t} else {\n\t\t\tif (len != 54 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp18_write_bin(bin, 18 * RLC_FP_BYTES, a[0]);\n\t\t\tfp18_write_bin(bin + 18 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[1]);\n\t\t\tfp18_write_bin(bin + 36 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp54_free(t);\n\t}\n}\n\nvoid fp54_set_dig(fp54_t a, dig_t b) {\n\tfp18_set_dig(a[0], b);\n\tfp18_zero(a[1]);\n\tfp18_zero(a[2]);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2015 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the BLAKE2s hash function.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n#include \"blake2.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == B2S160 || !defined(STRIP)\n\nvoid md_map_b2s160(uint8_t *hash, const uint8_t *msg, int len) {\n\tmemset(hash, 0, RLC_MD_LEN_B2S160);\n\tblake2s(hash, RLC_MD_LEN_B2S160, msg, len, NULL, 0);\n}\n\n#endif\n\n#if MD_MAP == B2S256 || !defined(STRIP)\n\nvoid md_map_b2s256(uint8_t *hash, const uint8_t *msg, int len) {\n\tmemset(hash, 0, RLC_MD_LEN_B2S256);\n\tblake2s(hash, RLC_MD_LEN_B2S256, msg, len, NULL, 0);\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2013 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of Hash-based Message Authentication Code.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid md_hmac(uint8_t *mac, const uint8_t *in, int in_len, const uint8_t *key,\n    int key_len) {\n#if MD_MAP == SH224 || MD_MAP == SH256 || MD_MAP == B2S160 || MD_MAP == B2S256\n  #define block_size 64\n#elif MD_MAP == SH384 || MD_MAP == SH512\n  #define block_size  128\n#endif\n    uint8_t opad[block_size + RLC_MD_LEN];\n    uint8_t *ipad = RLC_ALLOCA(uint8_t, block_size + in_len);\n\tuint8_t _key[RLC_MAX(RLC_MD_LEN, block_size)];\n\n    if (ipad == NULL) {\n        RLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n    }\n\n\tif (key_len > block_size) {\n\t\tmd_map(_key, key, key_len);\n\t\tkey = _key;\n\t\tkey_len = RLC_MD_LEN;\n\t}\n\tif (key_len <= block_size) {\n\t\tmemcpy(_key, key, key_len);\n\t\tmemset(_key + key_len, 0, block_size - key_len);\n\t\tkey = _key;\n\t}\n\tfor (int i = 0; i < block_size; i++) {\n\t\topad[i] = 0x5C ^ key[i];\n\t\tipad[i] = 0x36 ^ key[i];\n\t}\n\tmemcpy(ipad + block_size, in, in_len);\n\tmd_map(opad + block_size, ipad, block_size + in_len);\n\tmd_map(mac, opad, block_size + RLC_MD_LEN);\n\n    RLC_FREE(ipad);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of a Key Derivation function.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid md_kdf(uint8_t *key, int key_len, const uint8_t *in,\n\t\tint in_len) {\n\tuint32_t i, j, d;\n\tuint8_t* buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));\n\tuint8_t* t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);\n\tif (buffer == NULL || t == NULL) {\n\t\tRLC_FREE(buffer);\n\t\tRLC_FREE(t);\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\t/* d = ceil(kLen/hLen). */\n\td = RLC_CEIL(key_len, RLC_MD_LEN);\n\tmemcpy(buffer, in, in_len);\n\tfor (i = 1; i <= d; i++) {\n\t\tj = util_conv_big(i);\n\t\t/* c = integer_to_string(c, 4). */\n\t\tmemcpy(buffer + in_len, &j, sizeof(uint32_t));\n\t\t/* t = t || hash(z || c). */\n\t\tmd_map(t + (i - 1) * RLC_MD_LEN, buffer, in_len + sizeof(uint32_t));\n\t}\n\tmemcpy(key, t, key_len);\n\n\tRLC_FREE(buffer);\n\tRLC_FREE(t);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2011 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of a Mask Generation Function.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid md_mgf(uint8_t *key, int key_len, const uint8_t *in,\n\t\tint in_len) {\n\tuint32_t i, j, d;\n\tuint8_t *buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));\n\tuint8_t *t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);\n\n\tif (buffer == NULL || t == NULL) {\n\t\tRLC_FREE(buffer);\n\t\tRLC_FREE(t);\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\t/* d = ceil(kLen/hLen). */\n\td = RLC_CEIL(key_len, RLC_MD_LEN);\n\tmemcpy(buffer, in, in_len);\n\tfor (i = 0; i < d; i++) {\n\t\tj = util_conv_big(i);\n\t\t/* c = integer_to_string(c, 4). */\n\t\tmemcpy(buffer + in_len, &j, sizeof(uint32_t));\n\t\t/* t = t || hash(z || c). */\n\t\tmd_map(t + i * RLC_MD_LEN, buffer, in_len + sizeof(uint32_t));\n\t}\n\tmemcpy(key, t, key_len);\n\n\tRLC_FREE(buffer);\n\tRLC_FREE(t);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-224 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH224 || !defined(STRIP)\n\nvoid md_map_sh224(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA224Context ctx;\n\n\tif (SHA224Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA224Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA224Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-256 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH256 || !defined(STRIP)\n\nvoid md_map_sh256(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA256Context ctx;\n\n\tif (SHA256Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA256Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA256Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-384 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH384 || !defined(STRIP)\n\nvoid md_map_sh384(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA384Context ctx;\n\n\tif (SHA384Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA384Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA384Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-512 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH512 || !defined(STRIP)\n\nvoid md_map_sh512(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA512Context ctx;\n\n\tif (SHA512Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA512Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA512Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 12.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Compute the Miller loop for pairings of type G_2 x G_1 over the bits of a\n * given parameter represented in sparse form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the vector of first arguments in affine coordinates.\n * @param[in] p\t\t\t\t- the vector of second arguments in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp12_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp12_null(l);\n\n\tRLC_TRY {\n\t\tfp12_new(l);\n\t\tif (_p == NULL || _q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_null(_p[j]);\n\t\t\tep2_null(_q[j]);\n\t\t\tep_new(_p[j]);\n\t\t\tep2_new(_q[j]);\n\t\t\tep2_copy(t[j], q[j]);\n\t\t\tep2_neg(_q[j], q[j]);\n#if EP_ADD == BASIC\n\t\t\tep_neg(_p[j], p[j]);\n#else\n\t\t\tfp_add(_p[j]->x, p[j]->x, p[j]->x);\n\t\t\tfp_add(_p[j]->x, _p[j]->x, p[j]->x);\n\t\t\tfp_neg(_p[j]->y, p[j]->y);\n#endif\n\t\t}\n\n\t\tfp12_zero(l);\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tpp_dbl_k12(r, t[0], t[0], _p[0]);\n\t\tfor (j = 1; j < m; j++) {\n\t\t\tpp_dbl_k12(l, t[j], t[j], _p[j]);\n\t\t\tfp12_mul_dxs(r, r, l);\n\t\t}\n\t\tif (s[len - 2] > 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k12(l, t[j], q[j], p[j]);\n\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t\tif (s[len - 2] < 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k12(l, t[j], _q[j], p[j]);\n\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = len - 3; i >= 0; i--) {\n\t\t\tfp12_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_k12(l, t[j], t[j], _p[j]);\n\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t\tif (s[i] > 0) {\n\t\t\t\t\tpp_add_k12(l, t[j], q[j], p[j]);\n\t\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tpp_add_k12(l, t[j], _q[j], p[j]);\n\t\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_free(_p[j]);\n\t\t\tep2_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/**\n * Compute the Miller loop for pairings of type G_1 x G_2 over the bits of a\n * given parameter.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] p\t\t\t\t- the first pairing argument in affine coordinates.\n * @param[in] q\t\t\t\t- the second pairing argument in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_mil_lit_k12(fp12_t r, ep_t *t, ep_t *p, ep2_t *q, int m, bn_t a) {\n\tfp12_t l;\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint j;\n\n\tfp12_null(l);\n\n\tRLC_TRY {\n\t\tif (_q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfp12_new(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep2_null(_q[j]);\n\t\t\tep2_new(_q[j]);\n\t\t\tep_copy(t[j], p[j]);\n\t\t\tep2_neg(_q[j], q[j]);\n\t\t}\n\n\t\tfp12_zero(l);\n\t\tfor (int i = bn_bits(a) - 2; i >= 0; i--) {\n\t\t\tfp12_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_lit_k12(l, t[j], t[j], _q[j]);\n\t\t\t\tfp12_mul(r, r, l);\n\t\t\t\tif (bn_get_bit(a, i)) {\n\t\t\t\t\tpp_add_lit_k12(l, t[j], p[j], q[j]);\n\t\t\t\t\tfp12_mul(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep2_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/**\n * Compute the final lines for optimal ate pairings.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the first point of the pairing, in G_2.\n * @param[in] p\t\t\t\t- the second point of the pairing, in G_1.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_fin_k12_oatep(fp12_t r, ep2_t t, ep2_t q, ep_t p) {\n\tep2_t q1, q2;\n\tfp12_t tmp;\n\n\tfp12_null(tmp);\n\tep2_null(q1);\n\tep2_null(q2);\n\n\tRLC_TRY {\n\t\tep2_new(q1);\n\t\tep2_new(q2);\n\t\tfp12_new(tmp);\n\t\tfp12_zero(tmp);\n\n\t\tfp2_set_dig(q1->z, 1);\n\t\tfp2_set_dig(q2->z, 1);\n\n\t\tep2_frb(q1, q, 1);\n\t\tep2_frb(q2, q, 2);\n\t\tep2_neg(q2, q2);\n\n\t\tpp_add_k12(tmp, t, q1, p);\n\t\tfp12_mul_dxs(r, r, tmp);\n\t\tpp_add_k12(tmp, t, q2, p);\n\t\tfp12_mul_dxs(r, r, tmp);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp12_free(tmp);\n\t\tep2_free(q1);\n\t\tep2_free(q2);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if PP_MAP == TATEP || !defined(STRIP)\n\nvoid pp_map_tatep_k12(fp12_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1], t[1];\n\tep2_t _q[1];\n\tbn_t n;\n\n\tep_null(_p[0]);\n\tep_null(t[0]);\n\tep2_null(_q[0]);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep_new(t[0]);\n\t\tep2_new(_q[0]);\n\t\tbn_new(n);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\t\tep_curve_get_ord(n);\n\t\tfp12_set_dig(r, 1);\n\n\t\tif (!ep_is_infty(p) && !ep2_is_infty(q)) {\n\t\t\tpp_mil_lit_k12(r, t, _p, _q, 1, n);\n\t\t\tpp_exp_k12(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep_free(t[0]);\n\t\tep2_free(_q[0]);\n\t\tbn_free(n);\n\t}\n}\n\nvoid pp_map_sim_tatep_k12(fp12_t r, const ep_t *p, const ep2_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m), *t = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tbn_t n;\n\tint i, j;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tif (_p == NULL || _q == NULL || t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep_null(t[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep_new(t[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep2_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep2_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tfp12_set_dig(r, 1);\n\t\tif (j > 0) {\n\t\t\tpp_mil_lit_k12(r, t, _p, _q, j, n);\n\t\t\tpp_exp_k12(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep_free(t[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(t);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n#endif\n\n#if PP_MAP == WEILP || !defined(STRIP)\n\nvoid pp_map_weilp_k12(fp12_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1], t0[1];\n\tep2_t _q[1], t1[1];\n\tfp12_t r0, r1;\n\tbn_t n;\n\n\tep_null(_p[0]);\n\tep_null(t0[0]);\n\tep2_null(_q[0]);\n\tep2_null(t1[0]);\n\tfp12_null(r0);\n\tfp12_null(r1);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep_new(t0[0]);\n\t\tep2_new(_q[0]);\n\t\tep2_new(t1[0]);\n\t\tfp12_new(r0);\n\t\tfp12_new(r1);\n\t\tbn_new(n);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\t\tep_curve_get_ord(n);\n\t\tbn_sub_dig(n, n, 1);\n\t\tfp12_set_dig(r0, 1);\n\t\tfp12_set_dig(r1, 1);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep2_is_infty(_q[0])) {\n\t\t\tpp_mil_lit_k12(r0, t0, _p, _q, 1, n);\n\t\t\tpp_mil_k12(r1, t1, _q, _p, 1, n);\n\t\t\tfp12_inv(r1, r1);\n\t\t\tfp12_mul(r0, r0, r1);\n\t\t\tfp12_inv(r1, r0);\n\t\t\tfp12_inv_cyc(r0, r0);\n\t\t}\n\t\tfp12_mul(r, r0, r1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep_free(t0[0]);\n\t\tep2_free(_q[0]);\n\t\tep2_free(t1[0]);\n\t\tfp12_free(r0);\n\t\tfp12_free(r1);\n\t\tbn_free(n);\n\t}\n}\n\nvoid pp_map_sim_weilp_k12(fp12_t r, const ep_t *p, const ep2_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m), *t0 = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m), *t1 = RLC_ALLOCA(ep2_t, m);\n\tfp12_t r0, r1;\n\tbn_t n;\n\tint i, j;\n\n\tfp12_null(r0);\n\tfp12_null(r1);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tfp12_new(r0);\n\t\tfp12_new(r1);\n\t\tbn_new(n);\n\t\tif (_p == NULL || _q == NULL || t0 == NULL || t1 == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep_null(t0[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_null(t1[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep_new(t0[i]);\n\t\t\tep2_new(_q[i]);\n\t\t\tep2_new(t1[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep2_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep2_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_sub_dig(n, n, 1);\n\t\tfp12_set_dig(r0, 1);\n\t\tfp12_set_dig(r1, 1);\n\n\t\tif (j > 0) {\n\t\t\tpp_mil_lit_k12(r0, t0, _p, _q, j, n);\n\t\t\tpp_mil_k12(r1, t1, _q, _p, j, n);\n\t\t\tfp12_inv(r1, r1);\n\t\t\tfp12_mul(r0, r0, r1);\n\t\t\tfp12_inv(r1, r0);\n\t\t\tfp12_inv_cyc(r0, r0);\n\t\t}\n\t\tfp12_mul(r, r0, r1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(r0);\n\t\tfp12_free(r1);\n\t\tbn_free(n);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep_free(t0[i]);\n\t\t\tep2_free(_q[i]);\n\t\t\tep2_free(t1[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t\tRLC_FREE(t0);\n\t\tRLC_FREE(t1);\n\t}\n}\n\n#endif\n\n#if PP_MAP == OATEP || !defined(STRIP)\n\nvoid pp_map_oatep_k12(fp12_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1];\n\tep2_t t[1], _q[1];\n\tbn_t a;\n\n\tep_null(_p[0]);\n\tep2_null(_q[0]);\n\tep2_null(t[0]);\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep2_new(_q[0]);\n\t\tep2_new(t[0]);\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp12_set_dig(r, 1);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep2_is_infty(_q[0])) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_BN:\n\t\t\t\t\tbn_mul_dig(a, a, 6);\n\t\t\t\t\tbn_add_dig(a, a, 2);\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, 1, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\t/* f_{-a,Q}(P) = 1/f_{a,Q}(P). */\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t\tep2_neg(t[0], t[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_fin_k12_oatep(r, t[0], _q[0], _p[0]);\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EP_B12:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, 1, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t\tep2_neg(t[0], t[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep2_free(_q[0]);\n\t\tep2_free(t[0]);\n\t\tbn_free(a);\n\t}\n}\n\nvoid pp_map_sim_oatep_k12(fp12_t r, const ep_t *p, const ep2_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *t = RLC_ALLOCA(ep2_t, m), *_q = RLC_ALLOCA(ep2_t, m);\n\tbn_t a;\n\tint i, j;\n\n\tRLC_TRY {\n\t\tbn_null(a);\n\t\tbn_new(a);\n\t\tif (_p == NULL || _q == NULL || t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_null(t[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep2_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep2_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tfp_prime_get_par(a);\n\t\tfp12_set_dig(r, 1);\n\n\t\tif (j > 0) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_BN:\n\t\t\t\t\tbn_mul_dig(a, a, 6);\n\t\t\t\t\tbn_add_dig(a, a, 2);\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, j, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\t/* f_{-a,Q}(P) = 1/f_{a,Q}(P). */\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\t\tep2_neg(t[i], t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpp_fin_k12_oatep(r, t[i], _q[i], _p[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EP_B12:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, j, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t\tRLC_FREE(t);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 12.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Compute the Miller loop for pairings of type G_2 x G_1 over the bits of a\n * given parameter represented in sparse form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the vector of first arguments in affine coordinates.\n * @param[in] p\t\t\t\t- the vector of second arguments in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n\tfp24_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp24_null(l);\n\n\tRLC_TRY {\n\t\tfp24_new(l);\n\t\tif (_p == NULL || _q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_null(_p[j]);\n\t\t\tep4_null(_q[j]);\n\t\t\tep_new(_p[j]);\n\t\t\tep4_new(_q[j]);\n\t\t\tep4_copy(t[j], q[j]);\n\t\t\tep4_neg(_q[j], q[j]);\n#if EP_ADD == BASIC\n\t\t\tep_neg(_p[j], p[j]);\n#else\n\t\t\tfp_add(_p[j]->x, p[j]->x, p[j]->x);\n\t\t\tfp_add(_p[j]->x, _p[j]->x, p[j]->x);\n\t\t\tfp_neg(_p[j]->y, p[j]->y);\n#endif\n\t\t}\n\n\t\tfp24_zero(l);\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tpp_dbl_k24(r, t[0], t[0], _p[0]);\n\t\tfor (j = 1; j < m; j++) {\n\t\t\tpp_dbl_k24(l, t[j], t[j], _p[j]);\n\t\t\tfp24_mul_dxs(r, r, l);\n\t\t}\n\t\tif (s[len - 2] > 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k24(l, t[j], q[j], p[j]);\n\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t\tif (s[len - 2] < 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k24(l, t[j], _q[j], p[j]);\n\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = len - 3; i >= 0; i--) {\n\t\t\tfp24_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_k24(l, t[j], t[j], _p[j]);\n\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t\tif (s[i] > 0) {\n\t\t\t\t\tpp_add_k24(l, t[j], q[j], p[j]);\n\t\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tpp_add_k24(l, t[j], _q[j], p[j]);\n\t\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_free(_p[j]);\n\t\t\tep4_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if PP_MAP == OATEP || !defined(STRIP)\n\nvoid pp_map_k24(fp24_t r, const ep_t p, const ep4_t q) {\n\tep_t _p[1];\n\tep4_t t[1], _q[1];\n\tbn_t a;\n\n\tep_null(_p[0]);\n\tep4_null(_q[0]);\n\tep4_null(t[0]);\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep4_new(_q[0]);\n\t\tep4_new(t[0]);\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp24_set_dig(r, 1);\n\n\t\tep_norm(_p[0], p);\n\t\tep4_norm(_q[0], q);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep4_is_infty(_q[0])) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_B24:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k24(r, t, _q, _p, 1, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp24_inv_cyc(r, r);\n\t\t\t\t\t\tep4_neg(t[0], t[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k24(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep4_free(_q[0]);\n\t\tep4_free(t[0]);\n\t\tbn_free(a);\n\t}\n}\n\nvoid pp_map_sim_k24(fp24_t r, const ep_t *p, const ep4_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *t = RLC_ALLOCA(ep4_t, m), *_q = RLC_ALLOCA(ep4_t, m);\n\tbn_t a;\n\tint i, j;\n\n\tRLC_TRY {\n\t\tbn_null(a);\n\t\tbn_new(a);\n\t\tif (_p == NULL || _q == NULL || t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep4_null(_q[i]);\n\t\t\tep4_null(t[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep4_new(_q[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep4_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep4_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tfp_prime_get_par(a);\n\t\tfp24_set_dig(r, 1);\n\n\t\tif (j > 0) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_B24:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k24(r, t, _q, _p, j, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp24_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k24(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep4_free(_q[i]);\n\t\t\tep4_free(t[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t\tRLC_FREE(t);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 48.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                         */\n/*============================================================================*/\n\nstatic void pp_mil_k48(fp48_t r, const fp8_t qx, const fp8_t qy, const ep_t p,\n\t\tconst bn_t a) {\n\tfp48_t l;\n\tep_t _p;\n\tfp8_t rx, ry, rz, qn;\n\tint i, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tfp48_null(l);\n\tep_null(_p);\n\tfp8_null(rx);\n\tfp8_null(ry);\n\tfp8_null(rz);\n\tfp8_null(qn);\n\n\tRLC_TRY {\n\t\tfp48_new(l);\n\t\tep_new(_p);\n\t\tfp8_new(rx);\n\t\tfp8_new(ry);\n\t\tfp8_new(rz);\n\t\tfp8_new(qn);\n\n\t\tfp48_zero(l);\n\t\tfp8_copy(rx, qx);\n\t\tfp8_copy(ry, qy);\n\t\tfp8_set_dig(rz, 1);\n#if EP_ADD == BASIC\n\t\tep_neg(_p, p);\n#else\n\t\tfp_add(_p->x, p->x, p->x);\n\t\tfp_add(_p->x, _p->x, p->x);\n\t\tfp_neg(_p->y, p->y);\n#endif\n\t\tfp8_neg(qn, qy);\n\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tfp48_sqr(r, r);\n\t\t\tpp_dbl_k48(l, rx, ry, rz, _p);\n\t\t\tfp48_mul_dxs(r, r, l);\n\t\t\tif (s[i] > 0) {\n\t\t\t\tpp_add_k48(l, rx, ry, rz, qx, qy, p);\n\t\t\t\tfp48_mul_dxs(r, r, l);\n\t\t\t}\n\t\t\tif (s[i] < 0) {\n\t\t\t\tpp_add_k48(l, rx, ry, rz, qx, qn, p);\n\t\t\t\tfp48_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(l);\n\t\tep_free(_p);\n\t\tfp8_free(rx);\n\t\tfp8_free(ry);\n\t\tfp8_free(rz);\n\t\tfp8_free(qn);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid pp_map_k48(fp48_t r, const ep_t p, const fp8_t qx, const fp8_t qy) {\n\tbn_t a;\n\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp48_set_dig(r, 1);\n\n\t\tif (!ep_is_infty(p) && !(fp8_is_zero(qx) && fp8_is_zero(qy))) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_B48:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k48(r, qx, qy, p, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp48_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k48(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 54.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\nstatic void pp_mil_k54(fp54_t r, const fp9_t qx, const fp9_t qy, const ep_t p,\n\t\tconst bn_t a) {\n\tfp54_t l;\n\tep_t _p;\n\tfp9_t rx, ry, rz, sx, sy, sz, qn;\n\tint i, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tfp54_null(l);\n\tep_null(_p);\n\tfp9_null(rx);\n\tfp9_null(ry);\n\tfp9_null(rz);\n\tfp9_null(sx);\n\tfp9_null(sy);\n\tfp9_null(sz);\n\n\tRLC_TRY {\n\t\tfp54_new(l);\n\t\tep_new(_p);\n\t\tfp9_new(rx);\n\t\tfp9_new(ry);\n\t\tfp9_new(rz);\n\t\tfp9_new(sx);\n\t\tfp9_new(sy);\n\t\tfp9_new(sz);\n\t\tfp9_new(qn);\n\n\t\tfp54_zero(l);\n\t\tfp9_copy(rx, qx);\n\t\tfp9_copy(ry, qy);\n\t\tfp9_set_dig(rz, 1);\n#if EP_ADD == BASIC\n\t\tep_neg(_p, p);\n#else\n\t\tfp_add(_p->x, p->x, p->x);\n\t\tfp_add(_p->x, _p->x, p->x);\n\t\tfp_neg(_p->y, p->y);\n#endif\n\t\tfp9_neg(qn, qy);\n\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tfp54_sqr(r, r);\n\t\t\tpp_dbl_k54(l, rx, ry, rz, _p);\n\t\t\tfp54_mul_dxs(r, r, l);\n\t\t\tif (s[i] > 0) {\n\t\t\t\tpp_add_k54(l, rx, ry, rz, qx, qy, p);\n\t\t\t\tfp54_mul_dxs(r, r, l);\n\t\t\t}\n\t\t\tif (s[i] < 0) {\n\t\t\t\tpp_add_k54(l, rx, ry, rz, qx, qn, p);\n\t\t\t\tfp54_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t\t/* Compute f^3. */\n\t\tfp54_sqr(l, r);\n\t\tfp54_mul(r, r, l);\n\n\t\tfp54_zero(l);\n\t\tfp9_copy(sx, rx);\n\t\tfp9_copy(sy, ry);\n\t\tfp9_copy(sz, rz);\n\t\tpp_dbl_k54(l, sx, sy, sz, _p);\n\t\tfp54_mul_dxs(r, r, l);\n#if EP_ADD == PROJC\n\t\tfp9_inv(sz, sz);\n\t\tfp9_mul(sx, sx, sz);\n\t\tfp9_mul(sy, sy, sz);\n#endif\n\t\tpp_add_k54(l, rx, ry, rz, sx, sy, p);\n\t\tfp54_mul_dxs(r, r, l);\n\t\tfp9_frb(rx, qx, 1);\n\t\tfp9_frb(ry, qy, 1);\n\t\tfp9_zero(sz);\n\t\tfp3_set_dig(sz[1], 1);\n\t\tfp9_inv(sz, sz);\n\t\tfp_copy(sz[0][0], sz[2][2]);\n\t\tfp_mul(sz[0][0], sz[0][0], core_get()->fp3_p0[1]);\n\t\tfp_mul(sz[0][0], sz[0][0], core_get()->fp3_p1[3]);\n\t\tfp_mul(sz[0][0], sz[0][0], core_get()->fp3_p1[0]);\n\t\tfp3_mul_nor(sz[0], sz[0]);\n\t\tfp3_mul_nor(sz[0], sz[0]);\n\t\tfp3_mul_nor(sz[0], sz[0]);\n\t\tfp_mul(sz[1][0], sz[0][0], core_get()->fp3_p2[1]);\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfp3_mul(ry[i], ry[i], sz[0]);\n\t\t\tfp3_mul(rx[i], rx[i], sz[1]);\n\t\t}\n\n\t\tfp9_frb(sx, qx, 10);\n\t\tfp9_frb(sy, qy, 10);\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfp3_mul(sy[i], sy[i], sz[0]);\n\t\t\t\tfp3_mul(sx[i], sx[i], sz[1]);\n\t\t\t}\n\t\t}\n\t\tfp9_set_dig(sz, 1);\n\n\t\tpp_add_k54(l, sx, sy, sz, rx, ry, p);\n\t\tfp54_mul_dxs(r, r, l);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(l);\n\t\tep_free(_p);\n\t\tfp9_free(rx);\n\t\tfp9_free(ry);\n\t\tfp9_free(rz);\n\t\tfp9_free(sx);\n\t\tfp9_free(sy);\n\t\tfp9_free(sz);\n\t\tfp9_free(qn);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid pp_map_k54(fp54_t r, const ep_t p, const fp9_t qx, const fp9_t qy) {\n\tbn_t a;\n\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp54_set_dig(r, 1);\n\n\t\tif (!ep_is_infty(p) && !(fp9_is_zero(qx) && fp9_is_zero(qy))) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_K54:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k54(r, qx, qy, p, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp54_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k54(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 8.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Compute the Miller loop for pairings of type G_2 x G_1 over the bits of a\n * given parameter represented in sparse form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the vector of first arguments in affine coordinates.\n * @param[in] p\t\t\t\t- the vector of second arguments in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] s\t\t\t\t- the loop parameter in sparse form.\n * @paramin] len\t\t\t- the length of the loop parameter.\n */\nstatic void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp8_null(l);\n\n\tRLC_TRY {\n\t\tfp8_new(l);\n\t\tif (_p == NULL || _q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_null(_p[j]);\n\t\t\tep2_null(_q[j]);\n\t\t\tep_new(_p[j]);\n\t\t\tep2_new(_q[j]);\n\t\t\tep2_copy(t[j], q[j]);\n\t\t\tep2_neg(_q[j], q[j]);\n\n#if EP_ADD == BASIC\n\t\t\tep_neg(_p[j], p[j]);\n#else\n\t\t\tfp_neg(_p[j]->x, p[j]->x);\n\t\t\tfp_copy(_p[j]->y, p[j]->y);\n#endif\n\t\t}\n\n\t\tfp8_zero(l);\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tfp8_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_k8(l, t[j], t[j], _p[j]);\n\t\t\t\tfp8_mul(r, r, l);\n\t\t\t\tif (s[i] > 0) {\n\t\t\t\t\tpp_add_k8(l, t[j], q[j], _p[j]);\n\t\t\t\t\tfp8_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tpp_add_k8(l, t[j], _q[j], _p[j]);\n\t\t\t\t\tfp8_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_free(_p[j]);\n\t\t\tep2_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid pp_map_oatep_k8(fp8_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1];\n\tep2_t t[1], _q[1];\n\tbn_t a;\n\n\tep_null(_p[0]);\n\tep2_null(_q[0]);\n\tep2_null(t[0]);\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep2_new(_q[0]);\n\t\tep2_new(t[0]);\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp8_set_dig(r, 1);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep2_is_infty(_q[0])) {\n\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\tpp_mil_k8(r, t, _q, _p, 1, a);\n\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\tfp8_inv_cyc(r, r);\n\t\t\t\tep2_neg(t[0], t[0]);\n\t\t\t}\n\t\t\tpp_exp_k8(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep2_free(_q[0]);\n\t\tep2_free(t[0]);\n\t\tbn_free(a);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2013 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of utilities for pseudo-random number generation.\n *\n * @ingroup rand\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_label.h\"\n#include \"relic_rand.h\"\n#include \"relic_md.h\"\n#include \"relic_err.h\"\n\n#if RAND == UDEV || SEED == UDEV\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#elif SEED == WCGR\n\n/* Avoid redefinition warning. */\n#undef ERROR\n#undef WSIZE\n#undef DOUBLE\n\n#include <windows.h>\n#include <wincrypt.h>\n\n#elif SEED == RDRND\n\n#include <immintrin.h>\n\n#endif\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * The path to the char device that supplies entropy.\n */\n#if SEED == DEV\n#define RLC_RAND_PATH\t\t\"/dev/random\"\n#else\n#define RLC_RAND_PATH\t\t\"/dev/urandom\"\n#endif\n\n/** The maximum number of bytes that can be repeated in the output. */\n#define RAND_REP\t\t\t6\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid rand_init(void) {\n\tuint8_t buf[RLC_RAND_SEED];\n\n#if RAND == UDEV\n\tint *fd = (int *)&(core_get()->rand);\n\n\t*fd = open(RLC_RAND_PATH, O_RDONLY);\n\tif (*fd == -1) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t\treturn;\n\t}\n#else\n\n#if !defined(SEED)\n\n\tmemset(buf, 0, RLC_RAND_SEED);\n\n#elif SEED == DEV || SEED == UDEV\n\tint fd, c, l;\n\n\tfd = open(RLC_RAND_PATH, O_RDONLY);\n\tif (fd == -1) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t\treturn;\n\t}\n\n\tl = 0;\n\tdo {\n\t\tc = read(fd, buf + l, RLC_RAND_SEED - l);\n\t\tl += c;\n\t\tif (c == -1) {\n\t\t\tRLC_THROW(ERR_NO_READ);\n\t\t\treturn;\n\t\t}\n\t} while (l < RLC_RAND_SEED);\n\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n#elif SEED == LIBC\n\n#if OPSYS == FREEBSD || OPSYS == NETBSD\n\t/* This is better than using a fixed value. */\n\tsrandomdev();\n\tfor (int i = 0; i < RLC_RAND_SEED; i++) {\n\t\tbuf[i] = (uint8_t)random();\n\t}\n#else\n\t/* This is horribly insecure, serves only for benchmarking. */\n\tsrand(1);\n\tfor (int i = 0; i < RLC_RAND_SEED; i++) {\n\t\tbuf[i] = (uint8_t)rand();\n\t}\n#endif\n\n#elif SEED == WCGR\n\n\tHCRYPTPROV hCryptProv;\n\n\tif (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n\t\t\t\t\tCRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t\treturn;\n\t}\n\tif (hCryptProv && !CryptGenRandom(hCryptProv, RLC_RAND_SEED, buf)) {\n\t\tRLC_THROW(ERR_NO_READ);\n\t\treturn;\n\t}\n\tif (hCryptProv && !CryptReleaseContext(hCryptProv, 0)) {\n\t\tRLC_THROW(ERR_NO_READ);\n\t\treturn;\n\t}\n\n#elif SEED == RDRND\n\n\tint i, j;\n\tull_t r;\n\n\twhile (i < RLC_RAND_SEED) {\n#ifdef __RDRND__\n\t\twhile (_rdrand64_step(&r) == 0);\n#else\n#error \"RdRand not available, check your compiler settings.\"\n#endif\n\t\tfor (j = 0; i < RLC_RAND_SEED && j < sizeof(ull_t); i++, j++) {\n\t\t\tbuf[i] = r & 0xFF;\n\t\t}\n\t}\n\n#endif\n\n#endif /* RAND == UDEV */\n\n#if RAND != CALL\n\tcore_get()->seeded = 0;\n\trand_seed(buf, RLC_RAND_SEED);\n#else\n\trand_seed(NULL, NULL);\n#endif\n}\n\nint rand_check(uint8_t *buf, int size) {\n\tint count = 0;\n\n\tfor (int i = 1; i < size; i++) {\n\t\tif (buf[i] == buf[i - 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tcount = 0;\n\t\t}\n\t}\n\n\tif (count > RAND_REP) {\n\t\treturn RLC_ERR;\n\t}\n\treturn RLC_OK;\n}\n\nvoid rand_clean(void) {\n\tctx_t *ctx = core_get();\n\tif (ctx != NULL) {\n#if RAND == UDEV\n\t\tint *fd = (int *)&(ctx->rand);\n\t\tclose(*fd);\n#endif\n#if RAND != CALL\n\t\tmemset(ctx->rand, 0, sizeof(ctx->rand));\n#else\n\t\tctx->rand_call = NULL;\n\t\tctx->rand_args = NULL;\n#endif\n\t\tctx->seeded = 0;\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2018 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Hash_DRBG pseudo-random number generator.\n *\n * @ingroup rand\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_label.h\"\n#include \"relic_rand.h\"\n#include \"relic_md.h\"\n#include \"relic_err.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if RAND == HASHD\n\n/*\n * Computes the hash derivation function.\n *\n * param[out] out       - the result.\n * param[in] out_len    - the number of bytes to return.\n * param[in] in         - the input string.\n * param[in] in_len     - the number of bytes in the input.\n */\nstatic void rand_hash(uint8_t *out, int out_len, uint8_t *in, int in_len) {\n\tuint32_t j = util_conv_big(8 * out_len);\n\tint len = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t* buf = RLC_ALLOCA(uint8_t, 1 + sizeof(uint32_t) + in_len);\n\tuint8_t hash[RLC_MD_LEN];\n\n\tif (buf == NULL) {\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\tbuf[0] = 1;\n\tmemcpy(buf + 1, &j, sizeof(uint32_t));\n\tmemcpy(buf + 1 + sizeof(uint32_t), in, in_len);\n\n\tfor (int i = 0; i < len; i++) {\n\t\t/* h = Hash(counter || bits_to_return || input_string) */\n\t\tmd_map(hash, buf, 1 + sizeof(uint32_t) + in_len);\n\t\t/* temp = temp || h */\n\t\tmemcpy(out, hash, RLC_MIN(RLC_MD_LEN, out_len));\n\t\tout += RLC_MD_LEN;\n\t\tout_len -= RLC_MD_LEN;\n\t\t/* counter = counter + 1 */\n\t\tbuf[0]++;\n\t}\n\n\tRLC_FREE(buf);\n}\n\n/**\n * Accumulates a small integer in the internal state.\n *\n * @param[in,out] state\t\t- the internal state.\n * @param[in] digit\t\t\t- the small integer.\n */\nstatic int rand_inc(uint8_t *data, int size, int digit) {\n\tint carry = digit;\n\tfor (int i = size - 1; i >= 0; i--) {\n\t\tint16_t s;\n\t\ts = (data[i] + carry);\n\t\tdata[i] = s & 0xFF;\n\t\tcarry = s >> 8;\n\t}\n\treturn carry;\n}\n\n/**\n * Accumulates the hash value in the internal state.\n *\n * @param[in,out] state\t\t- the internal state.\n * @param[in] hash\t\t\t- the hash value.\n */\nstatic int rand_add(uint8_t *state, uint8_t *hash, int size) {\n\tint carry = 0;\n\tfor (int i = size - 1; i >= 0; i--) {\n\t\t/* Make sure carries are detected. */\n\t\tint16_t s;\n\t\ts = (state[i] + hash[i] + carry);\n\t\tstate[i] = s & 0xFF;\n\t\tcarry = s >> 8;\n\t}\n\treturn carry;\n}\n\n/**\n * Generates pseudo-random bytes by iterating the hash function.\n *\n * @param[out] out \t\t\t- the buffer to write.\n * @param[in] out_len\t\t- the number of bytes to write.\n */\nstatic void rand_gen(uint8_t *out, int out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n\tctx_t *ctx = core_get();\n\n\t/* data = V */\n\tmemcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)/2);\n\tfor (int i = 0; i < m; i++) {\n\t\t/* w_i = Hash(data) */\n\t\tmd_map(hash, data, sizeof(data));\n\t\t/* W = W || w_i */\n\t\tmemcpy(out, hash, RLC_MIN(RLC_MD_LEN, out_len));\n\t\tout += RLC_MD_LEN;\n\t\tout_len -= RLC_MD_LEN;\n\t\t/* data = data + 1 mod 2^b. */\n\t\trand_inc(data, (RLC_RAND_SIZE - 1)/2, 1);\n\t}\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if RAND == HASHD\n\nvoid rand_bytes(uint8_t *buf, int size) {\n\tuint8_t hash[RLC_MD_LEN];\n\tint carry, len  = (RLC_RAND_SIZE - 1)/2;\n\tctx_t *ctx = core_get();\n\n\tif (sizeof(int) > 2 && size > (1 << 16)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\t/* buf = hash_gen(size) */\n\trand_gen(buf, size);\n\t/* H = hash(03 || V) */\n\tctx->rand[0] = 0x3;\n\tmd_map(hash, ctx->rand, 1 + len);\n\t/* V = V + H + C  + reseed_counter. */\n\trand_add(ctx->rand + 1, ctx->rand + 1 + len, len);\n\tcarry = rand_add(ctx->rand + 1 + (len - RLC_MD_LEN), hash, RLC_MD_LEN);\n\trand_inc(ctx->rand, len - RLC_MD_LEN + 1, carry);\n\trand_inc(ctx->rand, len + 1, ctx->counter);\n\tctx->counter = ctx->counter + 1;\n}\n\nvoid rand_seed(uint8_t *buf, int size) {\n\tctx_t *ctx = core_get();\n\tint len = (RLC_RAND_SIZE - 1) / 2;\n\n\tif (size <= 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tif (sizeof(int) > 4 && size > (1 << 32)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tctx->rand[0] = 0x0;\n\tif (ctx->seeded == 0) {\n\t\t/* V = hash_df(seed). */\n\t\trand_hash(ctx->rand + 1, len, buf, size);\n\t\t/* C = hash_df(00 || V). */\n\t\trand_hash(ctx->rand + 1 + len, len, ctx->rand, len + 1);\n\t} else {\n\t\t/* V = hash_df(01 || V || seed). */\n        int tmp_size = 1 + len + size;\n\t\tuint8_t* tmp = RLC_ALLOCA(uint8_t, tmp_size);\n\t\tif (tmp == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\treturn;\n\t\t}\n\t\ttmp[0] = 1;\n\t\tmemcpy(tmp + 1, ctx->rand + 1, len);\n\t\tmemcpy(tmp + 1 + len, buf, size);\n\t\trand_hash(ctx->rand + 1, len, tmp, tmp_size);\n\t\t/* C = hash_df(00 || V). */\n\t\trand_hash(ctx->rand + 1 + len, len, ctx->rand, len + 1);\n\t\tRLC_FREE(tmp);\n\t}\n\tctx->counter = ctx->seeded = 1;\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of useful configuration routines.\n *\n * @ingroup relic\n */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"relic_core.h\"\n#include \"relic_conf.h\"\n#include \"relic_util.h\"\n#include \"relic_types.h\"\n\n#if ARCH == ARM && OPSYS == DROID\n#include <android/log.h>\n#endif\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Buffer to hold printed messages.\n */\n#if ARCH == AVR\n\n#ifndef QUIET\nvolatile char print_buf[128 + 1];\nvolatile char *util_print_ptr;\n\n#if OPSYS == DUINO\n/**\n * Send byte to serial port.\n */\nvoid uart_putchar(char c, FILE *stream) {\n\tif (c == '\\n') {\n\t\tuart_putchar('\\r', stream);\n\t}\n\tloop_until_bit_is_set(UCSR0A, UDRE0);\n\tUDR0 = c;\n}\n\n/**\n * Stream for serial port.\n */\nFILE uart_output = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);\n\n#endif\n#endif\n\n#endif /* QUIET */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nuint32_t util_conv_endian(uint32_t i) {\n\tuint32_t i1, i2, i3, i4;\n\ti1 = i & 0xFF;\n\ti2 = (i >> 8) & 0xFF;\n\ti3 = (i >> 16) & 0xFF;\n\ti4 = (i >> 24) & 0xFF;\n\n\treturn ((uint32_t) i1 << 24) | ((uint32_t) i2 << 16) | ((uint32_t) i3 << 8)\n\t\t\t| i4;\n}\n\nuint32_t util_conv_big(uint32_t i) {\n#ifdef BIGED\n\treturn i;\n#else\n\treturn util_conv_endian(i);\n#endif\n}\n\nuint32_t util_conv_little(uint32_t i) {\n#ifndef BIGED\n\treturn util_conv_endian(i);\n#else\n\treturn i;\n#endif\n}\n\nchar util_conv_char(dig_t i) {\n#if WSIZE == 8 || WSIZE == 16\n\t/* Avoid tables to save up some memory. This is not performance-critical. */\n\tif (i < 10) {\n\t\treturn i + '0';\n\t}\n\tif (i < 36) {\n\t\treturn (i - 10) + 'A';\n\t}\n\tif (i < 62) {\n\t\treturn (i - 36) + 'a';\n\t}\n\tif (i == 62) {\n\t\treturn '+';\n\t} else {\n\t\treturn '/';\n\t}\n#else\n\t/* Use a table. */\n\tstatic const char conv_table[] =\n\t\t\t\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/\";\n\treturn conv_table[i];\n#endif\n}\n\nint util_bits_dig(dig_t a) {\n    return RLC_DIG - arch_lzcnt(a);\n}\n\nint util_cmp_const(const void *a, const void *b, int size) {\n\tconst uint8_t *_a = (const uint8_t *)a;\n\tconst uint8_t *_b = (const uint8_t *)b;\n\tuint8_t result = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tresult |= _a[i] ^ _b[i];\n\t}\n\n\treturn (result == 0 ? RLC_EQ : RLC_NE);\n}\n\nvoid util_perm(unsigned int p[], int n) {\n\tsize_t i, j, k;\n\n\tfor (i = 0; i < n; i++) {\n\t\trand_bytes((uint8_t *)&k, sizeof(size_t));\n\t\tj = k % (i+1);\n\t\tp[i] = p[j];\n\t\tp[j] = i;\n\t}\n}\n\n#ifndef QUIET\nvoid util_print(const char *format, ...) {\n#if ARCH == AVR && !defined(OPSYS)\n\tutil_print_ptr = print_buf + 1;\n\tva_list list;\n\tva_start(list, format);\n\tvsnprintf_P((char *)util_print_ptr, sizeof(print_buf) - 1, format, list);\n\tva_end(list);\n\tprint_buf[0] = (uint8_t)2;\n#elif ARCH == AVR && OPSYS == DUINO\n\tstdout = &uart_output;\n\tva_list list;\n\tva_start(list, format);\n\tvsnprintf_P((char *)print_buf, sizeof(print_buf), format, list);\n\tprintf(\"%s\", (char *)print_buf);\n\tva_end(list);\n#elif ARCH == MSP && !defined(OPSYS)\n\tva_list list;\n\tva_start(list, format);\n\tvprintf(format, list);\n\tva_end(list);\n#elif ARCH == ARM && OPSYS == DROID\n\tva_list list;\n\tva_start(list, format);\n\t__android_log_vprint(ANDROID_LOG_INFO, \"relic-toolkit\", format, list);\n\tva_end(list);\n#else\n\tva_list list;\n\tva_start(list, format);\n\tvprintf(format, list);\n\tfflush(stdout);\n\tva_end(list);\n#endif\n}\n#endif\n\nvoid util_print_dig(dig_t a, int pad) {\n#if RLC_DIG == 64\n\tif (pad) {\n\t\tutil_print(\"%.16\" PRIX64, (uint64_t) a);\n\t} else {\n\t\tutil_print(\"%\" PRIX64, (uint64_t) a);\n\t}\n#elif RLC_DIG == 32\n\tif (pad) {\n\t\tutil_print(\"%.8\" PRIX32, (uint32_t) a);\n\t} else {\n\t\tutil_print(\"%\" PRIX32, (uint32_t) a);\n\t}\n#elif RLC_DIG == 16\n\tif (pad) {\n\t\tutil_print(\"%.4\" PRIX16, (uint16_t) a);\n\t} else {\n\t\tutil_print(\"%\" PRIX16, (uint16_t) a);\n\t}\n#else\n\tif (pad) {\n\t\tutil_print(\"%.2\" PRIX8, (uint8_t)a);\n\t} else {\n\t\tutil_print(\"%\" PRIX8, (uint8_t)a);\n\t}\n#endif\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for multiple precision integer arithmetic.\n *\n * @ingroup test\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\nstatic int memory(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tbn_t a;\n\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tbn_new(a);\n\t\t\tbn_free(a);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nstatic int util(void) {\n\tint bits, code = RLC_ERR;\n\tchar str[RLC_BN_BITS + 2];\n\tdig_t digit, raw[RLC_BN_DIGS];\n\tuint8_t bin[RLC_CEIL(RLC_BN_BITS, 8)];\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tif (bn_cmp(a, b) != RLC_EQ) {\n\t\t\t\tif (bn_cmp(a, b) == RLC_GT) {\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_LT, end);\n\t\t\t\t} else {\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_GT, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS);\n\t\t\tif (bn_cmp(a, c) != RLC_EQ) {\n\t\t\t\tbn_copy(c, a);\n\t\t\t\tTEST_ASSERT(bn_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (bn_cmp(b, c) != RLC_EQ) {\n\t\t\t\tbn_copy(c, b);\n\t\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"absolute, negation and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_neg(b, a);\n\t\t\tbn_abs(a, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_abs(a, b) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_LT, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"signal test is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_sign(a) == RLC_POS, end);\n\t\t\tTEST_ASSERT(bn_sign(b) == RLC_NEG, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to zero and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_zero(c);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(c, a) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp(c, b) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, (dig_t)0) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to zero and zero test are consistent\") {\n\t\t\tbn_zero(c);\n\t\t\tTEST_ASSERT(bn_is_zero(c), end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, (dig_t)0) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"oddness test is correct\") {\n\t\t\tbn_set_dig(a, 2);\n\t\t\tbn_set_dig(b, 1);\n\t\t\tTEST_ASSERT(bn_is_even(a) == 1, end);\n\t\t\tTEST_ASSERT(bn_is_even(b) == 0, end);\n\t\t} TEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"assignment and bit counting are consistent\") {\n\t\t\tbn_set_2b(a, bits);\n\t\t\tTEST_ASSERT(bits + 1 == bn_bits(a), end);\n\t\t\tbits = (bits + 1) % RLC_BN_BITS;\n\t\t} TEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"bit setting and getting are consistent\") {\n\t\t\tbn_zero(a);\n\t\t\tbn_set_bit(a, bits, 1);\n\t\t\tTEST_ASSERT(bn_get_bit(a, bits) == 1, end);\n\t\t\tbn_set_bit(a, bits, 0);\n\t\t\tTEST_ASSERT(bn_get_bit(a, bits) == 0, end);\n\t\t\tbits = (bits + 1) % RLC_BN_BITS;\n\t\t}\n\t\tTEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"hamming weight is correct\") {\n\t\t\tbn_zero(a);\n\t\t\tfor (int j = 0; j < bits; j++) {\n\t\t\t\tbn_set_bit(a, j, 1);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_ham(a) == bits, end);\n\t\t\tbits = (bits + 1) % RLC_BN_BITS;\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"generating a random integer is consistent\") {\n\t\t\tdo {\n\t\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\t} while (bn_is_zero(b));\n\t\t\tbn_rand_mod(a, b);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(b), end);\n\t\t\tTEST_ASSERT(bn_is_zero(a) == 0, end);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_LT, end);\n\t\t\tdo {\n\t\t\t\tbn_rand(b, RLC_NEG, RLC_DIG);\n\t\t\t} while (bn_bits(b) <= 1);\n\t\t\tbn_rand_mod(a, b);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(b), end);\n\t\t\tTEST_ASSERT(bn_is_zero(a) == 0, end);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_GT, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing the first digit are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_DIG);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&digit, a);\n\t\t\tbn_set_dig(b, digit);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to a constant and comparison are consistent\") {\n\t\t\tbn_set_dig(a, 2);\n\t\t\tbn_set_dig(b, 1);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_GT, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to random and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_zero(c);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_LT, end);\n\t\t} TEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"different forms of assignment are consistent\") {\n\t\t\tbn_set_dig(a, (dig_t)(1) << (dig_t)bits);\n\t\t\tbn_set_2b(b, bits);\n\t\t\tbits++;\n\t\t\tbits %= (RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\tlen = RLC_BN_DIGS;\n\t\t\tbn_write_raw(raw, len, a);\n\t\t\tbn_read_raw(b, raw, len);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"getting the size of a positive number is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tTEST_ASSERT((bn_size_str(a, 2) - 1) == bn_bits(a), end);\n\t\t\tbits = (bn_bits(a) % 8 == 0 ? bn_bits(a) / 8 : bn_bits(a) / 8 + 1);\n\t\t\tTEST_ASSERT(bn_size_bin(a) == bits, end);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tbn_neg(b, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\tlen = RLC_BN_DIGS;\n\t\t\tbn_write_raw(raw, len, a);\n\t\t\tbn_read_raw(b, raw, len);\n\t\t\tbn_neg(b, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"getting the size of a negative number is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tTEST_ASSERT((bn_size_str(a, 2) - 2) == bn_bits(a), end);\n\t\t\tbits = (bn_bits(a) % 8 == 0 ? bn_bits(a) / 8 : bn_bits(a) / 8 + 1);\n\t\t\tTEST_ASSERT(bn_size_bin(a) == bits, end);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int addition(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\n\t\tTEST_CASE(\"addition is commutative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_add(d, a, b);\n\t\t\tbn_add(e, b, a);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"addition is associative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_add(d, a, b);\n\t\t\tbn_add(d, d, c);\n\t\t\tbn_add(e, b, c);\n\t\t\tbn_add(e, a, e);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"addition has identity\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(d);\n\t\t\tbn_add(e, a, d);\n\t\t\tTEST_ASSERT(bn_cmp(e, a) == RLC_EQ, end);\n\t\t\tbn_add(e, d, a);\n\t\t\tTEST_ASSERT(bn_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"addition has inverse\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_neg(d, a);\n\t\t\tbn_add(e, a, d);\n\t\t\tTEST_ASSERT(bn_is_zero(e), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\treturn code;\n}\n\nstatic int subtraction(void) {\n\tint code = RLC_ERR;\n\tint s;\n\tbn_t a, b, c, d;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\n\t\tTEST_CASE(\"subtraction is anti-commutative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_sub(c, a, b);\n\t\t\tbn_sub(d, b, a);\n\t\t\tTEST_ASSERT(bn_cmp_abs(c, d) == RLC_EQ, end);\n\t\t\tif (!bn_is_zero(c)) {\n\t\t\t\ts = bn_sign(d);\n\t\t\t\tTEST_ASSERT(bn_sign(c) != s, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"subtraction has identity\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(c);\n\t\t\tbn_sub(d, a, c);\n\t\t\tTEST_ASSERT(bn_cmp(d, a) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"subtraction has inverse\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_sub(c, a, a);\n\t\t\tTEST_ASSERT(bn_is_zero(c), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\treturn code;\n}\n\nstatic int multiplication(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e, f;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(f);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(f);\n\n\t\tTEST_CASE(\"multiplication is commutative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(d, a, b);\n\t\t\tbn_mul(e, b, a);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication is associative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 3);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 3);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 3);\n\t\t\tbn_mul(d, a, b);\n\t\t\tbn_mul(d, d, c);\n\t\t\tbn_mul(e, b, c);\n\t\t\tbn_mul(e, a, e);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication is distributive\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_add(d, a, b);\n\t\t\tbn_mul(d, c, d);\n\t\t\tbn_mul(e, c, a);\n\t\t\tbn_mul(f, c, b);\n\t\t\tbn_add(e, e, f);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has identity\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_set_dig(d, (dig_t)1);\n\t\t\tbn_mul(e, a, d);\n\t\t\tTEST_ASSERT(bn_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has zero property\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(d);\n\t\t\tbn_mul(e, a, d);\n\t\t\tTEST_ASSERT(bn_is_zero(e), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has negation property\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_set_dig(d, 1);\n\t\t\tbn_neg(d, d);\n\t\t\tbn_mul(e, a, d);\n\t\t\tTEST_ASSERT(bn_cmp_abs(e, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(e) == RLC_NEG, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication by a positive number preserves order\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tint t = bn_cmp(a, b);\n\t\t\tbn_mul(d, c, a);\n\t\t\tbn_mul(e, c, b);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == t, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication by a negative number reverses order\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tint t = bn_cmp(a, b);\n\t\t\tbn_neg(d, c);\n\t\t\tbn_mul(e, d, a);\n\t\t\tbn_mul(d, d, b);\n\t\t\tif (t != RLC_EQ) {\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) != t, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n#if BN_MUL == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic multiplication is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_basic(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MUL == COMBA || !defined(STRIP)\n\t\tTEST_CASE(\"comba multiplication is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_comba(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\t\tTEST_CASE(\"karatsuba multiplication is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_karat(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(f);\n\treturn code;\n}\n\nstatic int squaring(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(b, a, a);\n\t\t\tbn_sqr(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n#if BN_SQR == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_sqr(b, a);\n\t\t\tbn_sqr_basic(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_SQR == COMBA || !defined(STRIP)\n\t\tTEST_CASE(\"comba squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_sqr(b, a);\n\t\t\tbn_sqr_comba(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\t\tTEST_CASE(\"karatsuba squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_sqr(b, a);\n\t\t\tbn_sqr_karat(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int doubling_halving(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"doubling is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 1);\n\t\t\tbn_add(b, a, a);\n\t\t\tbn_dbl(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"halving is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 1);\n\t\t\tbn_dbl(b, a);\n\t\t\tbn_hlv(c, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int shifting(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"shifting by 1 bit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 1);\n\t\t\tbn_lsh(b, a, 1);\n\t\t\tbn_dbl(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\tbn_rsh(b, a, 1);\n\t\t\tbn_hlv(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\tbn_lsh(b, a, 1);\n\t\t\tbn_rsh(c, b, 1);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by 2 bits is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 2);\n\t\t\tbn_lsh(b, a, 2);\n\t\t\tbn_rsh(c, b, 2);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by half digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_lsh(b, a, RLC_DIG / 2);\n\t\t\tbn_rsh(c, b, RLC_DIG / 2);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by 1 digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_DIG);\n\t\t\tbn_lsh(b, a, RLC_DIG);\n\t\t\tbn_rsh(c, b, RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by 2 digits is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 2 * RLC_DIG);\n\t\t\tbn_lsh(b, a, 2 * RLC_DIG);\n\t\t\tbn_rsh(c, b, 2 * RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"shifting by 1 digit and half is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG - RLC_DIG / 2);\n\t\t\tbn_lsh(b, a, RLC_DIG + RLC_DIG / 2);\n\t\t\tbn_copy(c, a);\n\t\t\tfor (int j = 0; j < (int)(RLC_DIG + RLC_DIG / 2); j++)\n\t\t\t\tbn_dbl(c, c);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\tbn_rsh(b, a, (RLC_DIG + RLC_DIG / 2));\n\t\t\tbn_copy(c, a);\n\t\t\tfor (int j = 0; j < (int)(RLC_DIG + RLC_DIG / 2); j++)\n\t\t\t\tbn_hlv(c, c);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int division(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\n\t\tTEST_CASE(\"trivial division is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == RLC_POS, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"trivial negative division is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"trivial division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"negative trivial division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"division is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(d), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"negative division is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == RLC_POS, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"negative division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\treturn code;\n}\n\nstatic int reduction(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\n#if BN_MOD == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tbn_sqr(c, b);\n\t\t\tif (bn_cmp(a, c) == RLC_LT) {\n\t\t\t\tbn_mod_basic(e, a, b);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t\tbn_neg(a, a);\n\t\t\t\tbn_mod_basic(e, a, b);\n\t\t\t\tbn_sub(e, b, e);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MOD == BARRT || !defined(STRIP)\n\t\tTEST_CASE(\"barrett reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tbn_sqr(c, b);\n\t\t\tif (bn_cmp(a, c) == RLC_LT) {\n\t\t\t\tbn_mod_pre_barrt(c, b);\n\t\t\t\tbn_mod_barrt(e, a, b, c);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t\tbn_neg(a, a);\n\t\t\t\tbn_mod_barrt(e, a, b, c);\n\t\t\t\tbn_sub(e, b, e);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if (BN_MOD == MONTY && BN_MUL == BASIC) || !defined(STRIP)\n\t\tTEST_CASE(\"basic montgomery reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(b)) {\n\t\t\t\tbn_add_dig(b, b, 1);\n\t\t\t}\n\t\t\tbn_mod(a, a, b);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_pre_monty(e, b);\n\t\t\tbn_mod_monty_basic(d, c, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t\tbn_neg(a, a);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_monty_basic(d, c, b, e);\n\t\t\tbn_add(a, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if (BN_MOD == MONTY && BN_MUL == COMBA) || !defined(STRIP)\n\t\tTEST_CASE(\"comba montgomery reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(b)) {\n\t\t\t\tbn_add_dig(b, b, 1);\n\t\t\t}\n\t\t\tbn_mod(a, a, b);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_pre_monty(e, b);\n\t\t\tbn_mod_monty_comba(d, c, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t\tbn_neg(a, a);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_monty_comba(d, c, b, e);\n\t\t\tbn_add(a, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MOD == PMERS || !defined(STRIP)\n\t\tTEST_CASE(\"pseudo-mersenne reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 4);\n\t\t\tif (bn_is_zero(c)) {\n\t\t\t\tbn_set_dig(c, 1);\n\t\t\t}\n\t\t\tbn_set_2b(b, RLC_BN_BITS / 2);\n\t\t\tbn_sub(b, b, c);\n\t\t\tbn_mod(c, a, b);\n\t\t\tbn_mod_pre_pmers(e, b);\n\t\t\tbn_mod_pmers(d, a, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t\tbn_neg(a, a);\n\t\t\tbn_mod(c, a, b);\n\t\t\tbn_mod_pmers(d, a, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\treturn code;\n}\n\nstatic int exponentiation(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, p;\n\tcrt_t crt;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(p);\n\tcrt_null(crt);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(p);\n\t\tcrt_new(crt);\n\n#if BN_MOD != PMERS\n\t\tbn_gen_prime(p, RLC_BN_BITS);\n#elif BN_PRECI >= 128\n\t\t/* Let's try a Mersenne prime. */\n\t\tbn_zero(p);\n\t\tbn_set_bit(p, 127, 1);\n\t\tbn_sub_dig(p, p, 1);\n#endif\n\n\t\tTEST_CASE(\"modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"modular exponentiation with zero power is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(b);\n\t\t\tbn_mxp(a, a, b, p);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, 1) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"modular exponentiation with negative power is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\t/* Compute c = a^b mod p. */\n\t\t\tbn_mxp(c, a, b, p);\n\t\t\t/* Compute b = a^-b mod p. */\n\t\t\tbn_neg(b, b);\n\t\t\tbn_mxp(b, a, b, p);\n\t\t\t/* Check that c * b = 1 mod p. */\n\t\t\tbn_mul(c, c, b);\n\t\t\tbn_mod(c, c, p);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n#if BN_MXP == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp_basic(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MXP == SLIDE || !defined(STRIP)\n\t\tTEST_CASE(\"sliding window modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp_slide(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MXP == CONST || !defined(STRIP)\n\t\tTEST_CASE(\"powering ladder modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp_monty(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n\t\tdo {\n\t\t\tbn_gen_prime(crt->p, RLC_BN_BITS / 2);\n\t\t\tbn_gen_prime(crt->q, RLC_BN_BITS / 2);\n\t\t} while (bn_is_even(crt->p) || bn_is_even(crt->q));\n\n\t\t/* n = pq. */\n\t\tbn_mul(crt->n, crt->p, crt->q);\n\t\t/* qInv = q^(-1) mod p. */\n\t\tbn_mod_inv(crt->qi, crt->q, crt->p);\n\t\tbn_sub_dig(crt->dp, crt->p, 1);\n\t\tbn_sub_dig(crt->dq, crt->q, 1);\n\n\t\tTEST_CASE(\"chinese remainder theorem modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, crt->n);\n\t\t\tbn_mul(c, crt->dp, crt->dq);\n\t\t\tbn_mod(b, b, c);\n\t\t\tbn_mxp(p, a, b, crt->n);\n\t\t\tbn_mod(c, b, crt->dp);\n\t\t\tbn_mod(b, b, crt->dq);\n\t\t\tbn_mxp_crt(c, a, c, b, crt, 0);\n\t\t\tTEST_ASSERT(bn_cmp(c, p) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(p);\n\tcrt_free(crt);\n\treturn code;\n}\n\nstatic int square_root(void) {\n\tint bits, code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_ONCE(\"square root extraction is correct\") {\n\t\t\tfor (bits = 0; bits < RLC_BN_BITS / 2; bits++) {\n\t\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t\t\tbn_sqr(c, a);\n\t\t\t\tbn_srt(b, c);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tfor (bits = 0; bits < RLC_BN_BITS; bits++) {\n\t\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t\t\tbn_srt(b, a);\n\t\t\t\tbn_sqr(c, b);\n\t\t\t\tTEST_ASSERT(bn_cmp(c, a) != RLC_GT, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_ONCE(\"square root of powers of 2 is correct\") {\n\t\t\tfor (bits = 0; bits < RLC_BN_BITS / 2; bits++) {\n\t\t\t\tbn_set_2b(a, bits);\n\t\t\t\tbn_sqr(c, a);\n\t\t\t\tbn_srt(b, c);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int gcd(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e, f, g, h;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(f);\n\tbn_null(g);\n\tbn_null(h);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(f);\n\t\tbn_new(g);\n\t\tbn_new(h);\n\n\t\tTEST_CASE(\"greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_mod(d, a, c);\n\t\t\tbn_mod(e, b, c);\n\t\t\tTEST_ASSERT(bn_is_zero(d) && bn_is_zero(e), end);\n\t\t\tbn_div(a, a, c);\n\t\t\tbn_div(b, b, c);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(b);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tTEST_ASSERT(bn_cmp_abs(c, a) == RLC_EQ, end);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_zero(b);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tTEST_ASSERT(bn_cmp_abs(c, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tbn_gcd(f, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t} TEST_END;\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_basic(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"basic extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_basic(f, a, b);\n\t\t\tbn_gcd_ext_basic(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_gcd_ext_basic(f, g, h, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, f) == RLC_EQ && bn_cmp(d, g) == RLC_EQ\n\t\t\t\t&& bn_cmp(e, h) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\t\tTEST_CASE(\"binary greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_binar(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"binary extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_binar(f, a, b);\n\t\t\tbn_gcd_ext_binar(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_gcd_ext_binar(f, g, h, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, f) == RLC_EQ && bn_cmp(d, g) == RLC_EQ\n\t\t\t\t&& bn_cmp(e, h) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\t\tTEST_CASE(\"lehmer greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_lehme(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"lehmer extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_lehme(f, a, b);\n\t\t\tbn_gcd_ext_lehme(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_gcd_ext_lehme(f, g, h, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, f) == RLC_EQ && bn_cmp(d, g) == RLC_EQ\n\t\t\t\t&& bn_cmp(e, h) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n\t\tTEST_CASE(\"midway extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_ext_mid(c, d, e, f, a, b);\n\t\t\tbn_abs(d, d);\n\t\t\tbn_abs(f, f);\n\t\t\tbn_mul(c, c, f);\n\t\t\tbn_mul(e, e, d);\n\t\t\tbn_add(c, c, e);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ || bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(f);\n\tbn_free(g);\n\tbn_free(h);\n\treturn code;\n}\n\nstatic int lcm(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"least common multiple is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_lcm(c, a, b);\n\t\t\tbn_mod(a, c, a);\n\t\t\tbn_mod(b, c, b);\n\t\t\tTEST_ASSERT(bn_is_zero(a) && bn_is_zero(b), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int symbol(void) {\n\tint r, code = RLC_ERR;\n\tbn_t a, b, c, p, q;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(p);\n\tbn_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(p);\n\t\tbn_new(q);\n\n\t\tdo {\n\t\t\tbn_gen_prime(p, RLC_BN_BITS);\n\t\t\tbn_gen_prime(q, RLC_BN_BITS);\n\t\t} while (bn_is_even(p) || bn_is_even(q));\n\n\t\tTEST_CASE(\"legendre symbol is correct\") {\n\t\t\tTEST_ASSERT(bn_smb_leg(p, p) == 0, end);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_sqr(a, a);\n\t\t\tbn_mod(a, a, p);\n\t\t\tTEST_ASSERT(bn_smb_leg(a, p) == 1, end);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tr = bn_smb_leg(a, p);\n\t\t\tTEST_ASSERT(r == 1 || r == -1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"legendre symbol is a homomorphism\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tr = bn_smb_leg(a, p) * bn_smb_leg(b, p);\n\t\t\tTEST_ASSERT(r == bn_smb_leg(c, p), end);\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"legendre symbol satisfies quadratic reciprocity\") {\n\t\t\t/* Check the first supplement: (-1|p) = (-1)^(p-1)/2. */\n\t\t\tbn_set_dig(a, 1);\n\t\t\tbn_neg(a, a);\n\t\t\tr = bn_smb_leg(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check second supplement: (2|p) = (-1)^(p^2-1)/8. */\n\t\t\tbn_set_dig(a, 2);\n\t\t\tr = bn_smb_leg(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sqr(c, p);\n\t\t\tbn_sub_dig(c, c, 1);\n\t\t\tbn_rsh(c, c, 3);\n\t\t\tbn_set_dig(a, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check quadratic reciprocity law. */\n\t\t\tr = bn_smb_leg(q, p);\n\t\t\tbn_set_dig(a, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tr = bn_smb_leg(p, q);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_sub_dig(c, q, 1);\n\t\t\t\tbn_rsh(c, c, 1);\n\t\t\t\tif (!bn_is_even(c)) {\n\t\t\t\t\tbn_neg(b, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_smb_leg(a, p) == bn_smb_jac(a, p), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol is a homomorphism\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(p, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(p)) {\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t}\n\t\t\tbn_mul(c, a, b);\n\t\t\tr = bn_smb_jac(a, p) * bn_smb_jac(b, p);\n\t\t\tTEST_ASSERT(r == bn_smb_jac(c, p), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol is consistent with gcd\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(p, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(p)) {\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t}\n\t\t\tr = bn_smb_jac(a, p);\n\t\t\tbn_set_dig(c, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(c, c);\n\t\t\t}\n\t\t\tbn_gcd(b, a, p);\n\t\t\tif (bn_cmp_dig(b, 1) != RLC_EQ) {\n\t\t\t\tTEST_ASSERT(r == 0, end);\n\t\t\t} else {\n\t\t\t\tTEST_ASSERT(r == 1 || r == -1, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol satisfies quadratic reciprocity\") {\n\t\t\tbn_rand(p, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(p)) {\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t}\n\t\t\tbn_rand(q, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(q)) {\n\t\t\t\tbn_add_dig(q, q, 1);\n\t\t\t}\n\t\t\t/* Check the first supplement: (-1|n) = (-1)^(n-1)/2. */\n\t\t\tbn_set_dig(a, 1);\n\t\t\tbn_neg(a, a);\n\t\t\tr = bn_smb_jac(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check second supplement: (2|p) = (-1)^(p^2-1)/8. */\n\t\t\tbn_set_dig(a, 2);\n\t\t\tr = bn_smb_jac(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sqr(c, p);\n\t\t\tbn_sub_dig(c, c, 1);\n\t\t\tbn_rsh(c, c, 3);\n\t\t\tbn_set_dig(a, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check quadratic reciprocity law. */\n\t\t\tr = bn_smb_jac(p, q);\n\t\t\tbn_set_dig(a, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tr = bn_smb_jac(q, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_sub_dig(c, q, 1);\n\t\t\t\tbn_rsh(c, c, 1);\n\t\t\t\tif (!bn_is_even(c)) {\n\t\t\t\t\tbn_neg(b, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(p);\n\tbn_free(q);\n\treturn code;\n}\n\nstatic int digit(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e, f;\n\tdig_t g;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(f);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(f);\n\n\t\tTEST_CASE(\"addition of a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_add(c, a, b);\n\t\t\tbn_add_dig(d, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"subtraction of a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_sub(c, a, b);\n\t\t\tbn_sub_dig(d, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication by a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_dig(d, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"division by a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tif (bn_is_zero(b)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbn_div(d, a, b);\n\t\t\tbn_div_dig(e, a, b->dp[0]);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t\tbn_div_rem(d, c, a, b);\n\t\t\tbn_div_rem_dig(e, &g, a, b->dp[0]);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, g) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"modular reduction modulo a digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tif (b->dp[0] == 0)\n\t\t\t\tcontinue;\n\t\t\tbn_div_rem(d, c, a, b);\n\t\t\tbn_mod_dig(&g, a, b->dp[0]);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, g) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"greatest common divisor with a digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_dig(e, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, e) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"extended greatest common divisor with a digit is consistent\")\n\t\t{\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_gcd_ext_dig(c, d, e, a, g);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n#if BN_MOD != PMERS\n\t\tbn_gen_prime(d, RLC_BN_BITS);\n#elif BN_PRECI >= 128\n\t\t/* Let's try a Mersenne prime. */\n\t\tbn_zero(d);\n\t\tbn_set_bit(d, 127, 1);\n\t\tbn_sub_dig(d, d, 1);\n#endif\n\n\t\tTEST_CASE(\"modular exponentiation with a digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_mxp(c, a, b, d);\n\t\t\tbn_mxp_dig(e, a, g, d);\n\t\t\tTEST_ASSERT(bn_cmp(c, e) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(f);\n\treturn code;\n}\n\nstatic int prime(void) {\n\tint code = RLC_ERR;\n\tbn_t p, q;\n\n\tbn_null(p);\n\tbn_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(q);\n\n\t\tTEST_ONCE(\"prime generation is consistent\") {\n\t\t\tbn_gen_prime(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\t\tTEST_ONCE(\"basic prime generation is consistent\") {\n\t\t\tbn_gen_prime_basic(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\t\tTEST_ONCE(\"safe prime generation is consistent\") {\n\t\t\tbn_gen_prime_safep(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t\tbn_sub_dig(p, p, 1);\n\t\t\tbn_hlv(p, p);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\t\tTEST_ONCE(\"strong prime generation is consistent\") {\n\t\t\tbn_gen_prime_stron(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n#endif\n\t\tbn_gen_prime(p, RLC_BN_BITS);\n\n\t\tTEST_ONCE(\"basic prime testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime_basic(p) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"miller-rabin prime testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime_rabin(p) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"solovay-strassen prime testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime_solov(p) == 1, end);\n\t\t} TEST_END;\n\n\t\tbn_gen_prime_factor(q, p, RLC_BN_BITS>>1, RLC_BN_BITS);\n\t\tTEST_ONCE(\"prime with large (p-1) prime factor testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t\tTEST_ASSERT(bn_is_prime(q) == 1, end);\n\t\t\tbn_sub_dig(p, p, 1); \t// (p-1)\n\t\t\tbn_div(p, p, q);\t\t// (p-1)/q\n\t\t\tbn_mul(p, p, q);\t\t// ((p-1)/q)*q\n\t\t\tbn_add_dig(p, p, 1);\t// ((p-1)/q)*q+1\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(p);\n\tbn_free(q);\n\treturn code;\n}\n\nstatic int small_primes(void) {\n\tint code = RLC_ERR;\n\n\tint i;\n\tconst int nr_tests = 50;\n\n\tdig_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n\t\t\t47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,\n\t\t\t107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,\n\t\t\t167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\n\t\t\t229};\n\n\tdig_t non_primes[] = {1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22,\n\t\t\t24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40,\n\t\t\t42, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58,\n\t\t\t60, 62, 63, 64, 65, 66, 68, 69};\n\n\tbn_t p;\n\tbn_null(p);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\n\t\tTEST_ONCE(\"prime testing of small primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"miller-rabin testing of small primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime_rabin(p) == 1, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"prime testing of small non-primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, non_primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime(p) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"miller-rabin testing of small non-primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, non_primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime_rabin(p) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(p);\n\treturn code;\n}\n\nstatic int inversion(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d[2];\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d[0]);\n\tbn_null(d[1]);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d[0]);\n\t\tbn_new(d[1]);\n\n\t\tbn_gen_prime(a, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"modular inversion is correct\") {\n\t\t\tbn_rand_mod(b, a);\n\t\t\tbn_mod_inv(c, b, a);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) != RLC_EQ, end);\n\t\t\tbn_mul(c, b, c);\n\t\t\tbn_mod(c, c, a);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t\tbn_rand_mod(b, a);\n\t\t\tbn_rand_mod(c, a);\n\t\t\tbn_copy(d[0], b);\n\t\t\tbn_copy(d[1], c);\n\t\t\tbn_mod_inv_sim(d, d, a, 2);\n\t\t\tbn_mul(b, b, d[0]);\n\t\t\tbn_mod(b, b, a);\n\t\t\tbn_mul(c, c, d[1]);\n\t\t\tbn_mod(c, c, a);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, 1) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d[0]);\n\tbn_free(d[1]);\n\treturn code;\n}\n\nstatic int factor(void) {\n\tint code = RLC_ERR;\n\tbn_t p, q, n;\n\n\tbn_null(p);\n\tbn_null(q);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(q);\n\t\tbn_new(n);\n\n\t\tTEST_ONCE(\"integer factorization is consistent\") {\n\t\t\tbn_gen_prime(p, 16);\n\t\t\tbn_rand(n, RLC_POS, RLC_BN_BITS - 16);\n\t\t\tbn_mul(n, n, p);\n\t\t\tif (bn_factor(q, n) == 1) {\n\t\t\t\tTEST_ASSERT(bn_is_factor(q, n) == 1, end);\n\t\t\t} else {\n\t\t\t\tTEST_ASSERT(bn_is_factor(p, n) == 1, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(p);\n\tbn_free(q);\n\tbn_free(n);\n\treturn code;\n}\n\nstatic int recoding(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, v1[3], v2[3];\n\tint w, k, l;\n\tuint8_t d[RLC_BN_BITS + 1];\n\tint8_t e[2 * (RLC_BN_BITS + 1)];\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tfor (k = 0; k < 3; k++) {\n\t\tbn_null(v1[k]);\n\t\tbn_null(v2[k]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tbn_new(v1[k]);\n\t\t\tbn_new(v2[k]);\n\t\t}\n\n\t\tTEST_CASE(\"window recoding is correct\") {\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_win(d, &l, a, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\tbn_lsh(b, b, w);\n\t\t\t\t\tbn_add_dig(b, b, d[k]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"sliding window recoding is correct\") {\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_slw(d, &l, a, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = 0; k < l; k++) {\n\t\t\t\t\tif (d[k] == 0) {\n\t\t\t\t\t\tbn_dbl(b, b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_lsh(b, b, util_bits_dig(d[k]));\n\t\t\t\t\t\tbn_add_dig(b, b, d[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"naf recoding is correct\") {\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_naf(e, &l, a, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\tbn_dbl(b, b);\n\t\t\t\t\tif (e[k] >= 0) {\n\t\t\t\t\t\tbn_add_dig(b, b, e[k]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(b, b, -e[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n#if defined(WITH_EB) && defined(EB_KBLTZ) && (EB_MUL == LWNAF || EB_MUL == RWNAF || EB_FIX == LWNAF || EB_SIM == INTER || !defined(STRIP))\n\t\tif (eb_param_set_any_kbltz() == RLC_OK) {\n\t\t\teb_curve_get_ord(v1[2]);\n\t\t\tTEST_CASE(\"tnaf recoding is correct\") {\n\t\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\t\tuint8_t t_w;\n\t\t\t\t\tint8_t beta[64], gama[64];\n\t\t\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\t\t\tint8_t u = (eb_curve_opt_a() == RLC_ZERO ? -1 : 1);\n\t\t\t\t\tbn_rand_mod(a, v1[2]);\n\t\t\t\t\tl = RLC_FB_BITS + 1;\n\t\t\t\t\tbn_rec_tnaf_mod(v1[0], v1[1], a, u, RLC_FB_BITS);\n\t\t\t\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\t\t\t\tbn_rec_tnaf(tnaf, &l, a, u, RLC_FB_BITS, w);\n\t\t\t\t\tbn_zero(a);\n\t\t\t\t\tbn_zero(b);\n\t\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\t\tbn_copy(c, b);\n\t\t\t\t\t\tif (u == -1) {\n\t\t\t\t\t\t\tbn_neg(c, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbn_add(c, c, a);\n\t\t\t\t\t\tbn_dbl(a, b);\n\t\t\t\t\t\tbn_neg(a, a);\n\t\t\t\t\t\tbn_copy(b, c);\n\t\t\t\t\t\tif (w == 2) {\n\t\t\t\t\t\t\tif (tnaf[k] >= 0) {\n\t\t\t\t\t\t\t\tbn_add_dig(a, a, tnaf[k]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -tnaf[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tnaf[k] > 0) {\n\t\t\t\t\t\t\t\tif (beta[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, -gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tnaf[k] < 0) {\n\t\t\t\t\t\t\t\tif (beta[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, -beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, -gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTEST_ASSERT(bn_cmp(a, v1[0]) == RLC_EQ, end);\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, v1[1]) == RLC_EQ, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_END;\n\n\t\t\tTEST_CASE(\"regular tnaf recoding is correct\") {\n\t\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\t\tuint8_t t_w;\n\t\t\t\t\tint8_t beta[64], gama[64];\n\t\t\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\t\t\tint8_t u = (eb_curve_opt_a() == RLC_ZERO ? -1 : 1);\n\t\t\t\t\tint n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tbn_rand_mod(a, v1[2]);\n\t\t\t\t\t\tl = RLC_FB_BITS + 1;\n\t\t\t\t\t\tbn_rec_tnaf_mod(v1[0], v1[1], a, u, RLC_FB_BITS);\n\t\t\t\t\t} while (bn_is_even(v1[0]) || bn_is_even(v1[1]));\n\t\t\t\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\t\t\t\tbn_rec_rtnaf(tnaf, &l, a, u, RLC_FB_BITS, w);\n\t\t\t\t\tbn_zero(a);\n\t\t\t\t\tbn_zero(b);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\t\tfor (int m = 0; m < w - 1; m++) {\n\t\t\t\t\t\t\tbn_copy(c, b);\n\t\t\t\t\t\t\tif (u == -1) {\n\t\t\t\t\t\t\t\tbn_neg(c, c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbn_add(c, c, a);\n\t\t\t\t\t\t\tbn_dbl(a, b);\n\t\t\t\t\t\t\tbn_neg(a, a);\n\t\t\t\t\t\t\tbn_copy(b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tnaf[k] != 0) {\n\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w == 2) {\n\t\t\t\t\t\t\tif (tnaf[k] >= 0) {\n\t\t\t\t\t\t\t\tbn_add_dig(a, a, tnaf[k]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -tnaf[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tnaf[k] > 0) {\n\t\t\t\t\t\t\t\tif (beta[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, -gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tnaf[k] < 0) {\n\t\t\t\t\t\t\t\tif (beta[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, -beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, -gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTEST_ASSERT(bn_cmp(a, v1[0]) == RLC_EQ, end);\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, v1[1]) == RLC_EQ, end);\n\t\t\t\t}\n\t\t\t} TEST_END;\n\t\t}\n#endif\n\n\t\tTEST_CASE(\"regular recoding is correct\") {\n\t\t\t/* Recode same scalar with different widths. */\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tif (bn_is_even(a)) {\n\t\t\t\tbn_add_dig(a, a, 1);\n\t\t\t}\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_reg(e, &l, a, RLC_BN_BITS, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\tbn_lsh(b, b, w - 1);\n\t\t\t\t\tif (e[k] > 0) {\n\t\t\t\t\t\tbn_add_dig(b, b, e[k]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(b, b, -e[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jsf recoding is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tl = 2 * (RLC_BN_BITS + 1);\n\t\t\tbn_rec_jsf(e, &l, a, b);\n\t\t\tw = RLC_MAX(bn_bits(a), bn_bits(b)) + 1;\n\t\t\tbn_add(a, a, b);\n\t\t\tbn_zero(b);\n\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\tbn_dbl(b, b);\n\t\t\t\tif (e[k] >= 0) {\n\t\t\t\t\tbn_add_dig(b, b, e[k]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(b, b, -e[k]);\n\t\t\t\t}\n\t\t\t\tif (e[k + w] >= 0) {\n\t\t\t\t\tbn_add_dig(b, b, e[k + w]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(b, b, -e[k + w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n#if defined(WITH_EP) && defined(EP_ENDOM) && (EP_MUL == LWNAF || EP_FIX == COMBS || EP_FIX == LWNAF || EP_SIM == INTER || !defined(STRIP))\n\t\tTEST_CASE(\"glv recoding is correct\") {\n\t\t\tif (ep_param_set_any_endom() == RLC_OK) {\n\t\t\t\tep_curve_get_v1(v1);\n\t\t\t\tep_curve_get_v2(v2);\n\t\t\t\tep_curve_get_ord(b);\n\t\t\t\tbn_rand_mod(a, b);\n\t\t\t\tbn_rec_glv(b, c, a, b, (const bn_t *)v1, (const bn_t *)v2);\n\t\t\t\tep_curve_get_ord(v2[0]);\n\t\t\t\t/* Check that subscalars have the right length. */\n\t\t\t\tTEST_ASSERT(bn_bits(b) <= 1 + (bn_bits(v2[0]) >> 1), end);\n\t\t\t\tTEST_ASSERT(bn_bits(c) <= 1 + (bn_bits(v2[0]) >> 1), end);\n\t\t\t\t/* Recover lambda parameter. */\n\t\t\t\tif (bn_cmp_dig(v1[2], 1) == RLC_EQ) {\n\t\t\t\t\tbn_gcd_ext(v1[0], v2[1], NULL, v1[1], v2[0]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_gcd_ext(v1[0], v2[1], NULL, v1[2], v2[0]);\n\t\t\t\t}\n\t\t\t\tif (bn_sign(v2[1]) == RLC_NEG) {\n\t\t\t\t\t/* Negate modulo r. */\n\t\t\t\t\tbn_add(v2[1], v2[0], v2[1]);\n\t\t\t\t}\n\t\t\t\tif (bn_cmp_dig(v1[2], 1) == RLC_EQ) {\n\t\t\t\t\tbn_sub(v1[0], v2[1], v1[2]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul(v1[0], v2[1], v1[1]);\n\t\t\t\t}\n\t\t\t\tbn_mod(v1[0], v1[0], v2[0]);\n\t\t\t\tbn_sub(v1[1], v2[0], v1[0]);\n\t\t\t\tif (bn_cmp(v1[1], v1[0]) == RLC_LT) {\n\t\t\t\t\tbn_copy(v1[0], v1[1]);\n\t\t\t\t}\n\t\t\t\t/* Check if b + c * lambda = k (mod n). */\n\t\t\t\tbn_mul(c, c, v1[0]);\n\t\t\t\tbn_add(b, b, c);\n\t\t\t\tbn_mod(b, b, v2[0]);\n\t\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\t\tbn_add(b, b, v2[0]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n#endif /* WITH_EP && EP_ENDOM */\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tfor (k = 0; k < 3; k++) {\n\t\tbn_free(v1[k]);\n\t\tbn_free(v2[k]);\n\t}\n\treturn code;\n}\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the BN module\", 0);\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (addition() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (subtraction() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (multiplication() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (squaring() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (doubling_halving() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (shifting() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (division() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (reduction() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (square_root() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (gcd() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (lcm() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (symbol() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (digit() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (recoding() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (exponentiation() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (prime() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (small_primes() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (inversion() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (factor() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for configuration management.\n *\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\n#if defined(MULTI)\n#if MULTI == PTHREAD\n\nvoid *master(void *ptr) {\n\tint *code = (int *)ptr;\n\tcore_init();\n\tRLC_THROW(ERR_NO_MEMORY);\n\tif (err_get_code() != RLC_ERR) {\n\t\t*code = RLC_ERR;\n\t} else {\n\t\t*code = RLC_OK;\n\t}\n\tcore_clean();\n\treturn NULL;\n}\n\nvoid *tester(void *ptr) {\n\tint *code = (int *)ptr;\n\tcore_init();\n\tif (err_get_code() != RLC_OK) {\n\t\t*code = RLC_ERR;\n\t} else {\n\t\t*code = RLC_OK;\n\t}\n\tcore_clean();\n\treturn NULL;\n}\n\n#endif\n#endif\n\nint main(void) {\n\tint code = RLC_ERR;\n\n\t/* Initialize library with default configuration. */\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the CORE module:\\n\", 0);\n\n\tTEST_ONCE(\"the library context is consistent\") {\n\t\tTEST_ASSERT(core_get() != NULL, end);\n\t} TEST_END;\n\n\tTEST_ONCE(\"switching the library context is correct\") {\n\t\tctx_t new_ctx, *old_ctx;\n\t\t/* Backup the old context. */\n\t\told_ctx = core_get();\n\t\t/* Switch the library context. */\n\t\tcore_set(&new_ctx);\n\t\t/* Reinitialize library with new context. */\n\t\tcore_init();\n\t\t/* Run function to manipulate the library context. */\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\tcore_set(old_ctx);\n\t\tTEST_ASSERT(err_get_code() == RLC_OK, end);\n\t\tcore_set(&new_ctx);\n\t\tTEST_ASSERT(err_get_code() == RLC_ERR, end);\n\t\t/* Now we need to finalize the new context. */\n\t\tcore_clean();\n\t\t/* And restore the original context. */\n\t\tcore_set(old_ctx);\n\t} TEST_END;\n\n\tcode = RLC_OK;\n\n#if defined(MULTI)\n#if MULTI == OPENMP\n\tTEST_ONCE(\"library context is thread-safe\") {\n\t\tomp_set_num_threads(CORES);\n#pragma omp parallel shared(code)\n\t\t{\n\t\t\tif (omp_get_thread_num() == 0) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t\tif (err_get_code() != RLC_ERR) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcore_init();\n\t\t\t\tif (err_get_code() != RLC_OK) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tcore_clean();\n\t\t\t}\n\t\t}\n\t\tTEST_ASSERT(code == RLC_OK, end);\n\n\t\tcore_init();\n#pragma omp parallel copyin(core_ctx) shared(code)\n\t\t{\n\t\t\tif (core_get() == NULL) {\n\t\t\t\tcode = RLC_ERR;\n\t\t\t}\n\t\t}\n\t\tTEST_ASSERT(code == RLC_OK, end);\n\t\tcore_clean();\n\t} TEST_END;\n#endif\n\n#if MULTI == PTHREAD\n\tTEST_ONCE(\"library context is thread-safe\") {\n\t\tpthread_t thread[CORES];\n\t\tint result[CORES] = { RLC_OK };\n\t\tfor (int i = 0; i < CORES; i++) {\n\t\t\tif (i == 0) {\n\t\t\t\tif (pthread_create(&(thread[0]), NULL, master, &(result[0]))) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pthread_create(&(thread[i]), NULL, tester, &(result[i]))) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result[i] != RLC_OK) {\n\t\t\t\tcode = RLC_ERR;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < CORES; i++) {\n\t\t\tif (pthread_join(thread[i], NULL)) {\n\t\t\t\tcode = RLC_ERR;\n\t\t\t}\n\t\t}\n\t\tTEST_ASSERT(code == RLC_OK, end);\n\t} TEST_END;\n#endif\n#endif\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n  end:\n\tcore_clean();\n\treturn code;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for the Pairing-Based Cryptography module.\n *\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\nstatic int memory1(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tg1_t a;\n\n\tg1_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tg1_new(a);\n\t\t\tg1_free(a);\n\t\t} TEST_END;\n\t} RLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t(void)a;\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nint util1(void) {\n\tint l, code = RLC_ERR;\n\tg1_t a, b, c;\n\tuint8_t bin[2 * RLC_PC_BYTES + 1];\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tTEST_ASSERT(g1_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_rand(c);\n\t\t\t/* Compare points in affine coordinates. */\n\t\t\tif (g1_cmp(a, c) != RLC_EQ) {\n\t\t\t\tg1_copy(c, a);\n\t\t\t\tTEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (g1_cmp(b, c) != RLC_EQ) {\n\t\t\t\tg1_copy(c, b);\n\t\t\t\tTEST_ASSERT(g1_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t\t/* Compare with one point in projective. */\n\t\t\tg1_dbl(c, a);\n\t\t\tg1_norm(c, c);\n\t\t\tg1_dbl(a, a);\n\t\t\tTEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g1_cmp(a, c) == RLC_EQ, end);\n\t\t\t/* Compare with two points in projective. */\n\t\t\tg1_dbl(c, c);\n\t\t\tg1_dbl(a, a);\n\t\t\tTEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g1_cmp(a, c) == RLC_EQ, end);\n\t\t\tg1_neg(b, a);\n\t\t\tg1_add(a, a, b);\n\t\t\tg1_set_infty(b);\n\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"inversion and comparison are consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_neg(b, a);\n\t\t\tTEST_ASSERT(g1_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"assignment to random/infinity and comparison are consistent\")\n\t\t{\n\t\t\tg1_rand(a);\n\t\t\tg1_set_infty(c);\n\t\t\tTEST_ASSERT(g1_cmp(a, c) != RLC_EQ, end);\n\t\t\tTEST_ASSERT(g1_cmp(c, a) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"assignment to infinity and infinity test are consistent\") {\n\t\t\tg1_set_infty(a);\n\t\t\tTEST_ASSERT(g1_is_infty(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a point are consistent\") {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tg1_set_infty(a);\n\t\t\t\tl = g1_size_bin(a, j);\n\t\t\t\tg1_write_bin(bin, l, a, j);\n\t\t\t\tg1_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg1_rand(a);\n\t\t\t\tl = g1_size_bin(a, j);\n\t\t\t\tg1_write_bin(bin, l, a, j);\n\t\t\t\tg1_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg1_rand(a);\n\t\t\t\tg1_dbl(a, a);\n\t\t\t\tl = g1_size_bin(a, j);\n\t\t\t\tg1_norm(a, a);\n\t\t\t\tg1_write_bin(bin, l, a, j);\n\t\t\t\tg1_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\treturn code;\n}\n\nint addition1(void) {\n\tint code = RLC_ERR;\n\n\tg1_t a, b, c, d, e;\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\tg1_null(d);\n\tg1_null(e);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\t\tg1_new(d);\n\t\tg1_new(e);\n\n\t\tTEST_CASE(\"point addition is commutative\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_add(d, a, b);\n\t\t\tg1_add(e, b, a);\n\t\t\tTEST_ASSERT(g1_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition is associative\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_rand(c);\n\t\t\tg1_add(d, a, b);\n\t\t\tg1_add(d, d, c);\n\t\t\tg1_add(e, b, c);\n\t\t\tg1_add(e, e, a);\n\t\t\tTEST_ASSERT(g1_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has identity\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_set_infty(d);\n\t\t\tg1_add(e, a, d);\n\t\t\tTEST_ASSERT(g1_cmp(e, a) == RLC_EQ, end);\n\t\t\tg1_add(e, d, a);\n\t\t\tTEST_ASSERT(g1_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has inverse\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_neg(d, a);\n\t\t\tg1_add(e, a, d);\n\t\t\tTEST_ASSERT(g1_is_infty(e), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\tg1_free(d);\n\tg1_free(e);\n\treturn code;\n}\n\nint subtraction1(void) {\n\tint code = RLC_ERR;\n\tg1_t a, b, c, d;\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\tg1_null(d);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\t\tg1_new(d);\n\n\t\tTEST_CASE(\"point subtraction is anti-commutative\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_sub(c, a, b);\n\t\t\tg1_sub(d, b, a);\n\t\t\tg1_neg(d, d);\n\t\t\tTEST_ASSERT(g1_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has identity\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_set_infty(c);\n\t\t\tg1_sub(d, a, c);\n\t\t\tTEST_ASSERT(g1_cmp(d, a) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has inverse\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_sub(c, a, a);\n\t\t\tTEST_ASSERT(g1_is_infty(c), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\tg1_free(d);\n\treturn code;\n}\n\nint doubling1(void) {\n\tint code = RLC_ERR;\n\tg1_t a, b, c;\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\n\t\tTEST_CASE(\"point doubling is correct\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_add(b, a, a);\n\t\t\tg1_dbl(c, a);\n\t\t\tTEST_ASSERT(g1_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\treturn code;\n}\n\nstatic int multiplication1(void) {\n\tint code = RLC_ERR;\n\tg1_t p, q, r;\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg1_null(p);\n\tg1_null(q);\n\tg1_null(r);\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg1_new(q);\n\t\tg1_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg1_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"generator has the right order\") {\n\t\t\tg1_mul(r, p, n);\n\t\t\tTEST_ASSERT(g1_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"generator multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g1_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g1_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tg1_neg(r, r);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"random element has the right order\") {\n\t\t\tg1_rand(p);\n\t\t\tg1_mul(r, p, n);\n\t\t\tTEST_ASSERT(g1_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point multiplication by digit is correct\") {\n\t\t\tg1_mul_dig(r, p, 0);\n\t\t\tTEST_ASSERT(g1_is_infty(r), end);\n\t\t\tg1_mul_dig(r, p, 1);\n\t\t\tTEST_ASSERT(g1_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_dig(r, p, k->dp[0]);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(p);\n\tg1_free(q);\n\tg1_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int fixed1(void) {\n\tint code = RLC_ERR;\n\tg1_t p, q, r;\n\tg1_t t[RLC_G1_TABLE];\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg1_null(p);\n\tg1_null(q);\n\tg1_null(r);\n\n\tfor (int i = 0; i < RLC_G1_TABLE; i++) {\n\t\tg1_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg1_new(q);\n\t\tg1_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg1_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tfor (int i = 0; i < RLC_G1_TABLE; i++) {\n\t\t\tg1_new(t[i]);\n\t\t}\n\t\tTEST_CASE(\"fixed point multiplication is correct\") {\n\t\t\tg1_rand(p);\n\t\t\tg1_mul_pre(t, p);\n\t\t\tbn_zero(k);\n\t\t\tg1_mul_fix(r, (const g1_t *)t, k);\n\t\t\tTEST_ASSERT(g1_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg1_mul_fix(r, (const g1_t *)t, k);\n\t\t\tTEST_ASSERT(g1_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_fix(q, (const g1_t *)t, k);\n\t\t\tg1_mul(r, p, k);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_fix(r, (const g1_t *)t, k);\n\t\t\tg1_neg(r, r);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t\tfor (int i = 0; i < RLC_G1_TABLE; i++) {\n\t\t\tg1_free(t[i]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(p);\n\tg1_free(q);\n\tg1_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int simultaneous1(void) {\n\tint code = RLC_ERR;\n\tg1_t p, q, r;\n\tbn_t n, k, l;\n\n\tbn_null(n);\n\tbn_null(k);\n\tbn_null(l);\n\tg1_null(p);\n\tg1_null(q);\n\tg1_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(k);\n\t\tbn_new(l);\n\t\tg1_new(p);\n\t\tg1_new(q);\n\t\tg1_new(r);\n\n\t\tg1_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"simultaneous point multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul(q, p, l);\n\t\t\tg1_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul_sim(r, p, k, q, l);\n\t\t\tg1_mul(p, p, k);\n\t\t\tg1_mul(q, q, l);\n\t\t\tg1_add(q, q, p);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_sim(r, p, k, q, l);\n\t\t\tg1_mul(p, p, k);\n\t\t\tg1_mul(q, q, l);\n\t\t\tg1_add(q, q, p);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg1_mul_sim(r, p, k, q, l);\n\t\t\tg1_mul(p, p, k);\n\t\t\tg1_mul(q, q, l);\n\t\t\tg1_add(q, q, p);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"simultaneous multiplication with generator is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul(q, p, l);\n\t\t\tg1_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg1_mul_gen(q, k);\n\t\t\tg1_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul_sim_gen(r, k, q, l);\n\t\t\tg1_get_gen(p);\n\t\t\tg1_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_sim_gen(r, k, q, l);\n\t\t\tg1_get_gen(p);\n\t\t\tg1_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg1_mul_sim_gen(r, k, q, l);\n\t\t\tg1_get_gen(p);\n\t\t\tg1_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(n);\n\tbn_free(k);\n\tbn_free(l);\n\tg1_free(p);\n\tg1_free(q);\n\tg1_free(r);\n\treturn code;\n}\n\nstatic int validity1(void) {\n\tint code = RLC_ERR;\n\tg1_t a;\n\n\tg1_null(a);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\n\t\tTEST_CASE(\"validity test is correct\") {\n\t\t\tg1_set_infty(a);\n\t\t\tTEST_ASSERT(!g1_is_valid(a), end);\n\t\t\tg1_rand(a);\n\t\t\tTEST_ASSERT(g1_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"blinding is consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_blind(a, a);\n\t\t\tTEST_ASSERT(g1_is_valid(a), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\treturn code;\n}\n\nstatic int hashing1(void) {\n\tint code = RLC_ERR;\n\tg1_t a;\n\tbn_t n;\n\tuint8_t msg[5];\n\n\tg1_null(a);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"point hashing is correct\") {\n\t\t\trand_bytes(msg, sizeof(msg));\n\t\t\tg1_map(a, msg, sizeof(msg));\n\t\t\tTEST_ASSERT(g1_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tbn_free(n);\n\treturn code;\n}\n\nstatic int memory2(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tg2_t a;\n\n\tg2_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tg2_new(a);\n\t\t\tg2_free(a);\n\t\t} TEST_END;\n\t} RLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t(void)a;\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nint util2(void) {\n\tint l, code = RLC_ERR;\n\tg2_t a, b, c;\n\tuint8_t bin[8 * RLC_PC_BYTES + 1];\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tTEST_ASSERT(g2_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_rand(c);\n\t\t\t/* Compare points in affine coordinates. */\n\t\t\tif (g2_cmp(a, c) != RLC_EQ) {\n\t\t\t\tg2_copy(c, a);\n\t\t\t\tTEST_ASSERT(g2_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (g2_cmp(b, c) != RLC_EQ) {\n\t\t\t\tg2_copy(c, b);\n\t\t\t\tTEST_ASSERT(g2_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t\t/* Compare with one point in projective. */\n\t\t\tg2_dbl(c, a);\n\t\t\tg2_norm(c, c);\n\t\t\tg2_dbl(a, a);\n\t\t\tTEST_ASSERT(g2_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g2_cmp(a, c) == RLC_EQ, end);\n\t\t\t/* Compare with two points in projective. */\n\t\t\tg2_dbl(c, c);\n\t\t\tg2_dbl(a, a);\n\t\t\tTEST_ASSERT(g2_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g2_cmp(a, c) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"negation and comparison are consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_neg(b, a);\n\t\t\tTEST_ASSERT(g2_cmp(a, b) != RLC_EQ, end);\n\t\t\tg2_neg(b, a);\n\t\t\tg2_add(a, a, b);\n\t\t\tg2_set_infty(b);\n\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"assignment to random/infinity and comparison are consistent\")\n\t\t{\n\t\t\tg2_rand(a);\n\t\t\tg2_set_infty(c);\n\t\t\tTEST_ASSERT(g2_cmp(a, c) != RLC_EQ, end);\n\t\t\tTEST_ASSERT(g2_cmp(c, a) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"assignment to infinity and infinity test are consistent\") {\n\t\t\tg2_set_infty(a);\n\t\t\tTEST_ASSERT(g2_is_infty(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a point are consistent\") {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tg2_set_infty(a);\n\t\t\t\tl = g2_size_bin(a, j);\n\t\t\t\tg2_write_bin(bin, l, a, j);\n\t\t\t\tg2_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg2_rand(a);\n\t\t\t\tl = g2_size_bin(a, j);\n\t\t\t\tg2_write_bin(bin, l, a, j);\n\t\t\t\tg2_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg2_rand(a);\n\t\t\t\tg2_dbl(a, a);\n\t\t\t\tl = g2_size_bin(a, j);\n\t\t\t\tg2_norm(a, a);\n\t\t\t\tg2_write_bin(bin, l, a, j);\n\t\t\t\tg2_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\treturn code;\n}\n\nint addition2(void) {\n\tint code = RLC_ERR;\n\n\tg2_t a, b, c, d, e;\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\tg2_null(d);\n\tg2_null(e);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\t\tg2_new(d);\n\t\tg2_new(e);\n\n\t\tTEST_CASE(\"point addition is commutative\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_add(d, a, b);\n\t\t\tg2_add(e, b, a);\n\t\t\tTEST_ASSERT(g2_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition is associative\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_rand(c);\n\t\t\tg2_add(d, a, b);\n\t\t\tg2_add(d, d, c);\n\t\t\tg2_add(e, b, c);\n\t\t\tg2_add(e, e, a);\n\t\t\tTEST_ASSERT(g2_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has identity\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_set_infty(d);\n\t\t\tg2_add(e, a, d);\n\t\t\tTEST_ASSERT(g2_cmp(e, a) == RLC_EQ, end);\n\t\t\tg2_add(e, d, a);\n\t\t\tTEST_ASSERT(g2_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has inverse\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_neg(d, a);\n\t\t\tg2_add(e, a, d);\n\t\t\tTEST_ASSERT(g2_is_infty(e), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\tg2_free(d);\n\tg2_free(e);\n\treturn code;\n}\n\nint subtraction2(void) {\n\tint code = RLC_ERR;\n\tg2_t a, b, c, d;\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\tg2_null(d);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\t\tg2_new(d);\n\n\t\tTEST_CASE(\"point subtraction is anti-commutative\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_sub(c, a, b);\n\t\t\tg2_sub(d, b, a);\n\t\t\tg2_neg(d, d);\n\t\t\tTEST_ASSERT(g2_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has identity\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_set_infty(c);\n\t\t\tg2_sub(d, a, c);\n\t\t\tTEST_ASSERT(g2_cmp(d, a) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has inverse\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_sub(c, a, a);\n\t\t\tTEST_ASSERT(g2_is_infty(c), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\tg2_free(d);\n\treturn code;\n}\n\nint doubling2(void) {\n\tint code = RLC_ERR;\n\tg2_t a, b, c;\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\n\t\tTEST_CASE(\"point doubling is correct\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_add(b, a, a);\n\t\t\tg2_dbl(c, a);\n\t\t\tTEST_ASSERT(g2_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\treturn code;\n}\n\nstatic int multiplication2(void) {\n\tint code = RLC_ERR;\n\tg2_t p, q, r;\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg2_null(p);\n\tg2_null(q);\n\tg2_null(r);\n\n\tRLC_TRY {\n\t\tg2_new(p);\n\t\tg2_new(q);\n\t\tg2_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg2_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"generator has the right order\") {\n\t\t\tg2_mul(r, p, n);\n\t\t\tTEST_ASSERT(g2_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"generator multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g2_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g2_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tg2_neg(r, r);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"random element has the right order\") {\n\t\t\tg2_rand(p);\n\t\t\tg2_mul(r, p, n);\n\t\t\tTEST_ASSERT(g2_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point multiplication by digit is correct\") {\n\t\t\tg2_mul_dig(r, p, 0);\n\t\t\tTEST_ASSERT(g2_is_infty(r), end);\n\t\t\tg2_mul_dig(r, p, 1);\n\t\t\tTEST_ASSERT(g2_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_dig(r, p, k->dp[0]);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(p);\n\tg2_free(q);\n\tg2_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int fixed2(void) {\n\tint code = RLC_ERR;\n\tg2_t p, q, r;\n\tg2_t t[RLC_G2_TABLE];\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg2_null(p);\n\tg2_null(q);\n\tg2_null(r);\n\n\tfor (int i = 0; i < RLC_G2_TABLE; i++) {\n\t\tg2_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tg2_new(p);\n\t\tg2_new(q);\n\t\tg2_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg2_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tfor (int i = 0; i < RLC_G2_TABLE; i++) {\n\t\t\tg2_new(t[i]);\n\t\t}\n\t\tTEST_CASE(\"fixed point multiplication is correct\") {\n\t\t\tg2_rand(p);\n\t\t\tg2_mul_pre(t, p);\n\t\t\tbn_zero(k);\n\t\t\tg2_mul_fix(r, t, k);\n\t\t\tTEST_ASSERT(g2_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg2_mul_fix(r, t, k);\n\t\t\tTEST_ASSERT(g2_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_fix(q, t, k);\n\t\t\tg2_mul(r, p, k);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_fix(r, t, k);\n\t\t\tg2_neg(r, r);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t\tfor (int i = 0; i < RLC_G2_TABLE; i++) {\n\t\t\tg2_free(t[i]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(p);\n\tg2_free(q);\n\tg2_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int simultaneous2(void) {\n\tint code = RLC_ERR;\n\tg2_t p, q, r;\n\tbn_t n, k, l;\n\n\tbn_null(n);\n\tbn_null(k);\n\tbn_null(l);\n\tg2_null(p);\n\tg2_null(q);\n\tg2_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(k);\n\t\tbn_new(l);\n\t\tg2_new(p);\n\t\tg2_new(q);\n\t\tg2_new(r);\n\n\t\tg2_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"simultaneous point multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul(q, p, l);\n\t\t\tg2_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul_sim(r, p, k, q, l);\n\t\t\tg2_mul(p, p, k);\n\t\t\tg2_mul(q, q, l);\n\t\t\tg2_add(q, q, p);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_sim(r, p, k, q, l);\n\t\t\tg2_mul(p, p, k);\n\t\t\tg2_mul(q, q, l);\n\t\t\tg2_add(q, q, p);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg2_mul_sim(r, p, k, q, l);\n\t\t\tg2_mul(p, p, k);\n\t\t\tg2_mul(q, q, l);\n\t\t\tg2_add(q, q, p);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"simultaneous multiplication with generator is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul(q, p, l);\n\t\t\tg2_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg2_mul_gen(q, k);\n\t\t\tg2_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul_sim_gen(r, k, q, l);\n\t\t\tg2_get_gen(p);\n\t\t\tg2_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_sim_gen(r, k, q, l);\n\t\t\tg2_get_gen(p);\n\t\t\tg2_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg2_mul_sim_gen(r, k, q, l);\n\t\t\tg2_get_gen(p);\n\t\t\tg2_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(n);\n\tbn_free(k);\n\tbn_free(l);\n\tg2_free(p);\n\tg2_free(q);\n\tg2_free(r);\n\treturn code;\n}\n\nstatic int validity2(void) {\n\tint code = RLC_ERR;\n\tg2_t a;\n\n\tg2_null(a);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\n\t\tTEST_CASE(\"validity test is correct\") {\n\t\t\tg2_set_infty(a);\n\t\t\tTEST_ASSERT(!g2_is_valid(a), end);\n\t\t\tg2_rand(a);\n\t\t\tTEST_ASSERT(g2_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"blinding is consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_blind(a, a);\n\t\t\tTEST_ASSERT(g2_is_valid(a), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\treturn code;\n}\n\n#if FP_PRIME != 509\n\nstatic int hashing2(void) {\n\tint code = RLC_ERR;\n\tg2_t a;\n\tbn_t n;\n\tuint8_t msg[5];\n\n\tg2_null(a);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"point hashing is correct\") {\n\t\t\trand_bytes(msg, sizeof(msg));\n\t\t\tg2_map(a, msg, sizeof(msg));\n\t\t\tTEST_ASSERT(g2_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tbn_free(n);\n\treturn code;\n}\n\n#endif\n\nstatic int memory(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tgt_t a;\n\n\tgt_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tgt_new(a);\n\t\t\tgt_free(a);\n\t\t} TEST_END;\n\t} RLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t(void)a;\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nint util(void) {\n\tint l, code = RLC_ERR;\n\tgt_t a, b, c;\n\tuint8_t bin[24 * RLC_PC_BYTES];\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tTEST_ASSERT(gt_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tgt_rand(c);\n\t\t\tif (gt_cmp(a, c) != RLC_EQ) {\n\t\t\t\tgt_copy(c, a);\n\t\t\t\tTEST_ASSERT(gt_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (gt_cmp(b, c) != RLC_EQ) {\n\t\t\t\tgt_copy(c, b);\n\t\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"inversion and comparison are consistent\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_inv(b, a);\n\t\t\tTEST_ASSERT(gt_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"assignment to random/infinity and comparison are consistent\")\n\t\t{\n\t\t\tgt_rand(a);\n\t\t\tgt_set_unity(c);\n\t\t\tTEST_ASSERT(gt_cmp(a, c) != RLC_EQ, end);\n\t\t\tTEST_ASSERT(gt_cmp(c, a) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"assignment to unity and unity test are consistent\") {\n\t\t\tgt_set_unity(a);\n\t\t\tTEST_ASSERT(gt_is_unity(a), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\treturn code;\n}\n\nint multiplication(void) {\n\tint code = RLC_ERR;\n\n\tgt_t a, b, c, d, e;\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\tgt_null(d);\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\t\tgt_new(d);\n\t\tgt_new(e);\n\n\t\tTEST_CASE(\"multiplication is commutative\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tgt_mul(d, a, b);\n\t\t\tgt_mul(e, b, a);\n\t\t\tTEST_ASSERT(gt_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication is associative\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tgt_rand(c);\n\t\t\tgt_mul(d, a, b);\n\t\t\tgt_mul(d, d, c);\n\t\t\tgt_mul(e, b, c);\n\t\t\tgt_mul(e, e, a);\n\t\t\tTEST_ASSERT(gt_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has identity\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_set_unity(d);\n\t\t\tgt_mul(e, a, d);\n\t\t\tTEST_ASSERT(gt_cmp(e, a) == RLC_EQ, end);\n\t\t\tgt_mul(e, d, a);\n\t\t\tTEST_ASSERT(gt_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\tgt_free(d);\n\tgt_free(e);\n\treturn code;\n}\n\nint squaring(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\n\t\tTEST_CASE(\"squaring is correct\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_mul(b, a, a);\n\t\t\tgt_sqr(c, a);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\treturn code;\n}\n\nstatic int inversion(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\n\t\tTEST_CASE(\"inversion is correct\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_inv(b, a);\n\t\t\tgt_mul(c, a, b);\n\t\t\tgt_set_unity(b);\n\t\t\tTEST_ASSERT(gt_cmp(c, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\treturn code;\n}\n\nint exponentiation(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\tbn_t n, d, e;\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(n);\n\n\t\tgt_get_gen(a);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"generator has the right order\") {\n\t\t\tgt_exp(c, a, n);\n\t\t\tTEST_ASSERT(gt_is_unity(c), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"generator exponentiation is correct\") {\n\t\t\tbn_zero(d);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tTEST_ASSERT(gt_is_unity(c), end);\n\t\t\tbn_set_dig(d, 1);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tTEST_ASSERT(gt_cmp(c, a) == RLC_EQ, end);\n\t\t\tbn_add_dig(d, n, 1);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tTEST_ASSERT(gt_cmp(c, a) == RLC_EQ, end);\n\t\t\tgt_exp_gen(c, n);\n\t\t\tTEST_ASSERT(gt_is_unity(c), end);\n\t\t\tbn_rand_mod(d, n);\n\t\t\tgt_exp_gen(b, d);\n\t\t\tbn_neg(d, d);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tgt_inv(c, c);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"random element has the right order\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_exp(c, a, n);\n\t\t\tTEST_ASSERT(gt_is_unity(c) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"exponentiation is correct\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tbn_rand_mod(d, n);\n\t\t\tbn_rand_mod(e, n);\n\t\t\tgt_exp_sim(c, a, d, b, e);\n\t\t\tgt_exp(a, a, d);\n\t\t\tgt_exp(b, b, e);\n\t\t\tgt_mul(b, a, b);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t\tgt_exp_dig(b, a, 0);\n\t\t\tTEST_ASSERT(gt_is_unity(b), end);\n\t\t\tgt_exp_dig(b, a, 1);\n\t\t\tTEST_ASSERT(gt_cmp(a, b) == RLC_EQ, end);\n\t\t\tbn_rand(d, RLC_POS, RLC_DIG);\n\t\t\tgt_exp(b, a, d);\n\t\t\tgt_exp_dig(c, a, d->dp[0]);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(n);\n\treturn code;\n}\n\nstatic int validity(void) {\n\tint code = RLC_ERR;\n\tgt_t a;\n\n\tgt_null(a);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\n\t\tTEST_CASE(\"validity check is correct\") {\n\t\t\tgt_set_unity(a);\n\t\t\tTEST_ASSERT(!gt_is_valid(a), end);\n\t\t\tgt_rand(a);\n\t\t\tTEST_ASSERT(gt_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\treturn code;\n}\n\nstatic int pairing(void) {\n\tint j, code = RLC_ERR;\n\tg1_t p[2];\n\tg2_t q[2];\n\tgt_t e1, e2;\n\tbn_t k, n;\n\n\tgt_null(e1);\n\tgt_null(e2);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tgt_new(e1);\n\t\tgt_new(e2);\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tg1_null(p[j]);\n\t\t\tg2_null(q[j]);\n\t\t\tg1_new(p[j]);\n\t\t\tg2_new(q[j]);\n\t\t}\n\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"pairing non-degeneracy is correct\") {\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_rand(q[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e1, 1) != RLC_EQ, end);\n\t\t\tg1_set_infty(p[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e1, 1) == RLC_EQ, end);\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_set_infty(q[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e1, 1) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"pairing is bilinear\") {\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_rand(q[0]);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg2_mul(q[1], q[0], k);\n\t\t\tpc_map(e1, p[0], q[1]);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tgt_exp(e2, e2, k);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg1_mul(p[0], p[0], k);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg1_dbl(p[0], p[0]);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tgt_sqr(e1, e1);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg2_dbl(q[0], q[0]);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tgt_sqr(e1, e1);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multi-pairing is correct\") {\n\t\t\tg1_rand(p[i % 2]);\n\t\t\tg2_rand(q[i % 2]);\n\t\t\tpc_map(e1, p[i % 2], q[i % 2]);\n\t\t\tg1_rand(p[1 - (i % 2)]);\n\t\t\tg2_set_infty(q[1 - (i % 2)]);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg1_set_infty(p[1 - (i % 2)]);\n\t\t\tg2_rand(q[1 - (i % 2)]);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg2_set_infty(q[i % 2]);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e2, 1) == RLC_EQ, end);\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_rand(q[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tg1_rand(p[1]);\n\t\t\tg2_rand(q[1]);\n\t\t\tpc_map(e2, p[1], q[1]);\n\t\t\tgt_mul(e1, e1, e2);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(e1);\n\tgt_free(e2);\n\tbn_free(k);\n\tbn_free(n);\n\tfor (j = 0; j < 2; j++) {\n\t\tg1_free(p[j]);\n\t\tg2_free(q[j]);\n\t}\n\treturn code;\n}\n\nint test1(void) {\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory1() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (addition1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (subtraction1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (doubling1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (multiplication1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (fixed1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (simultaneous1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (validity1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (hashing1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\treturn RLC_OK;\n}\n\nint test2(void) {\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory2() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (addition2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (subtraction2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (doubling2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (multiplication2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (fixed2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (simultaneous2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (validity2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n#if FP_PRIME != 509\n\tif (hashing2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n#endif\n\n\treturn RLC_OK;\n}\n\nint test(void) {\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (multiplication() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (squaring() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (inversion() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (exponentiation() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (validity() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (pairing() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\treturn RLC_OK;\n}\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the PC module:\", 0);\n\n\tif (pc_param_set_any() != RLC_OK) {\n\t\tRLC_THROW(ERR_NO_CURVE);\n\t\tcore_clean();\n\t\treturn 0;\n\t}\n\n\tpc_param_print();\n\n\tutil_banner(\"Group G_1:\", 0);\n\tif (test1() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Group G_2:\", 0);\n\tif (test2() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Group G_T:\", 0);\n\tif (test() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for random number generation.\n *\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\n#if RAND == HASHD\n\n/*\n * Test vectors taken from:\n * - http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/Hash_DRBG.pdf\n */\n\n#if MD_MAP == SH224\n\n#define FUNCTION \"sha-224\"\n\nuint8_t seed1[62];\n\nuint8_t result1[] = {\n\t0x5E, 0x68, 0xBD, 0xE0, 0x9A, 0xAA, 0x08, 0xBC, 0x11, 0xB3,\n\t0x27, 0x90, 0x2C, 0x82, 0xF0, 0x11, 0x4C, 0xBA, 0x0F, 0x9C,\n\t0xCC, 0xA6, 0x20, 0x3B, 0xA3, 0x94, 0x00, 0x91, 0x3E, 0xCD,\n\t0x36, 0x71, 0xA5, 0xB6, 0x0E, 0xF9, 0x22, 0x99, 0x9D, 0x90,\n\t0xFC, 0xEE, 0xEC, 0x5C, 0x22, 0x7E, 0x5D, 0x25, 0xC5, 0x69,\n\t0x21, 0xEE, 0x57, 0x2E, 0xD4, 0x72, 0xDC, 0x05, 0x6F, 0xCB,\n\t0x35, 0xFF, 0x51, 0xD7, 0xD9, 0xFB, 0x72, 0xFD, 0x4F, 0xD1,\n\t0xB1, 0xD2, 0x46, 0x45, 0x1D, 0xB5, 0x6C, 0xD4, 0xF8, 0x89,\n\t0xE4, 0x32, 0xE3, 0x27, 0x3F, 0x9E, 0xD8, 0x2D, 0xE3, 0xEF,\n\t0x7C, 0xD2, 0x8B, 0x6A, 0x9C, 0x0F, 0x4D, 0x78, 0xE5, 0xC8,\n\t0x45, 0x1D, 0x36, 0x34, 0x0A, 0x2B, 0xD7, 0xE6, 0x9F, 0xAB,\n\t0x32, 0xEB\n};\n\nuint8_t result2[] = {\n\t0x3F, 0xE2, 0xAD, 0x85, 0x24, 0xCE, 0x60, 0xE7, 0xC2, 0x1C,\n\t0x38, 0xA1, 0xDA, 0xB0, 0x2F, 0x3C, 0x20, 0x50, 0x11, 0x82,\n\t0xF3, 0x89, 0xEE, 0x69, 0x9F, 0x03, 0xFD, 0x87, 0x79, 0xED,\n\t0x17, 0xC6, 0x5B, 0x87, 0xAC, 0xEE, 0xEB, 0xF1, 0xD1, 0x46,\n\t0xE7, 0xEE, 0x10, 0x6C, 0xEC, 0x89, 0x55, 0xEE, 0xAF, 0xC1,\n\t0x8A, 0xBB, 0xC5, 0x62, 0xA5, 0x66, 0x8B, 0xB4, 0x9B, 0x0B,\n\t0x9C, 0x2F, 0xC7, 0x01, 0x89, 0xB2, 0x4E, 0x02, 0x73, 0x59,\n\t0x54, 0x58, 0xCD, 0x78, 0x0F, 0xBF, 0xA5, 0xF2, 0x16, 0x12,\n\t0x24, 0x21, 0xB8, 0x0B, 0xF7, 0x73, 0xD7, 0x36, 0xE6, 0xE1,\n\t0x1D, 0xEB, 0xB4, 0x24, 0x77, 0xD6, 0x96, 0x68, 0xD2, 0xF9,\n\t0x40, 0xC6, 0x60, 0xF6, 0xA2, 0xC1, 0xC9, 0xB4, 0x17, 0x95,\n\t0x92, 0xE0\n};\n\n#elif MD_MAP == SH256\n\nuint8_t seed1[63];\n\n#define FUNCTION \"sha-256\"\n\nuint8_t result1[] = {\n\t0x77, 0xE0, 0x5A, 0x0E, 0x7D, 0xC7, 0x8A, 0xB5, 0xD8, 0x93,\n\t0x4D, 0x5E, 0x93, 0xE8, 0x2C, 0x06, 0xA0, 0x7C, 0x04, 0xCE,\n\t0xE6, 0xC9, 0xC5, 0x30, 0x45, 0xEE, 0xB4, 0x85, 0x87, 0x27,\n\t0x77, 0xCF, 0x3B, 0x3E, 0x35, 0xC4, 0x74, 0xF9, 0x76, 0xB8,\n\t0x94, 0xBF, 0x30, 0x1A, 0x86, 0xFA, 0x65, 0x1F, 0x46, 0x39,\n\t0x70, 0xE8, 0x9D, 0x4A, 0x05, 0x34, 0xB2, 0xEC, 0xAD, 0x29,\n\t0xEC, 0x04, 0x4E, 0x7E, 0x5F, 0xF4, 0xBA, 0x49, 0x3C, 0x40,\n\t0xCF, 0xFF, 0x3B, 0x01, 0xE4, 0x72, 0xC5, 0x75, 0x66, 0x8C,\n\t0xCE, 0x38, 0x80, 0xB9, 0x29, 0x0B, 0x05, 0xBF, 0xED, 0xE5,\n\t0xEC, 0x96, 0xED, 0x5E, 0x9B, 0x28, 0x98, 0x50, 0x8B, 0x09,\n\t0xBC, 0x80, 0x0E, 0xEE, 0x09, 0x9A, 0x3C, 0x90, 0x60, 0x2A,\n\t0xBD, 0x4B, 0x1D, 0x4F, 0x34, 0x3D, 0x49, 0x7C, 0x60, 0x55,\n\t0xC8, 0x7B, 0xB9, 0x56, 0xD5, 0x3B, 0xF3, 0x51\n};\n\nuint8_t result2[] = {\n\t0x92, 0x27, 0x55, 0x23, 0xC7, 0x0E, 0x56, 0x7B, 0xCF, 0x9B,\n\t0x35, 0xEC, 0x50, 0xB9, 0x33, 0xF8, 0x12, 0x61, 0x6D, 0xF5,\n\t0x86, 0xB7, 0xF7, 0x2E, 0xE1, 0xBC, 0x77, 0x35, 0xA5, 0xC2,\n\t0x65, 0x43, 0x73, 0xCB, 0xBC, 0x72, 0x31, 0x6D, 0xFF, 0x84,\n\t0x20, 0xA3, 0x3B, 0xF0, 0x2B, 0x97, 0xAC, 0x8D, 0x19, 0x52,\n\t0x58, 0x3F, 0x27, 0x0A, 0xCD, 0x70, 0x05, 0xCC, 0x02, 0x7F,\n\t0x4C, 0xF1, 0x18, 0x7E, 0x68, 0x1A, 0x46, 0xB2, 0xAA, 0x86,\n\t0x94, 0xA0, 0xFE, 0x4D, 0xEE, 0xA7, 0x20, 0x92, 0x7A, 0x84,\n\t0xEA, 0xAA, 0x98, 0x5E, 0x59, 0xC1, 0x9F, 0x8B, 0xE0, 0x98,\n\t0x4D, 0x8C, 0xBE, 0xF8, 0xC6, 0x9B, 0x75, 0x41, 0x67, 0x64,\n\t0x19, 0x46, 0xE0, 0x40, 0xEE, 0x20, 0x43, 0xE1, 0xCC, 0xB2,\n\t0x9D, 0xCF, 0x06, 0x3C, 0x0A, 0x50, 0x83, 0x0E, 0x42, 0x8E,\n\t0x6D, 0xCA, 0x26, 0x2E, 0xCD, 0x77, 0xC5, 0x42\n};\n\n#elif MD_MAP == SH384\n\n#define FUNCTION \"sha-384\"\n\nuint8_t seed1[123];\n\nuint8_t result1[] = {\n\t0x04, 0xFF, 0x23, 0xAD, 0x15, 0xE7, 0x87, 0x90, 0xAD, 0xD3,\n\t0x6B, 0x43, 0x8B, 0xBC, 0x09, 0x7C, 0x7A, 0x11, 0x74, 0x7C,\n\t0xC2, 0xCC, 0xEE, 0xDE, 0x2C, 0x97, 0x8B, 0x23, 0xB3, 0xDC,\n\t0x63, 0xB7, 0x32, 0xC9, 0x53, 0x06, 0x1D, 0x77, 0x64, 0x99,\n\t0x0A, 0xBF, 0xEF, 0xC4, 0x7A, 0x58, 0x1B, 0x92, 0x1B, 0xC0,\n\t0x42, 0x8C, 0x4F, 0x12, 0x21, 0x24, 0x60, 0xE4, 0x06, 0xA0,\n\t0xF0, 0x65, 0x1E, 0x7F, 0x0C, 0xB9, 0xA9, 0x0A, 0xBF, 0xDB,\n\t0x07, 0xB5, 0x25, 0x56, 0x5C, 0x74, 0xF0, 0xAA, 0x08, 0x50,\n\t0x82, 0xF6, 0xCF, 0x21, 0x3A, 0xAF, 0xAD, 0x0C, 0x06, 0x46,\n\t0x89, 0x50, 0x78, 0xF1, 0xE1, 0xFE, 0x4F, 0x35, 0xB8, 0x5F,\n\t0x95, 0xDE, 0xE3, 0xE8, 0x73, 0x05, 0x49, 0x05, 0xCF, 0xD0,\n\t0x23, 0x41, 0x65, 0x3E, 0x18, 0xF5, 0x29, 0x93, 0x0C, 0xBE,\n\t0x14, 0xD9, 0x09, 0xF3, 0x7F, 0xEA, 0xF2, 0xC7, 0x90, 0xD2,\n\t0x2F, 0xAE, 0x75, 0x16, 0xB4, 0x59, 0x0B, 0xE3, 0x5D, 0x53,\n\t0xE2, 0xFE, 0x1A, 0x35, 0xAF, 0xE4, 0xB6, 0x60, 0x7C, 0xB3,\n\t0x58, 0x58, 0x9C, 0x3B, 0x4D, 0x09, 0x4A, 0x1D, 0x81, 0xFE,\n\t0x07, 0x17, 0xF1, 0xDF, 0x5B, 0xDD, 0xEB, 0x3E, 0x11, 0x4F,\n\t0x13, 0x0B, 0xB7, 0x81, 0xE6, 0x6C, 0x22, 0xB5, 0xB7, 0x70,\n\t0xE8, 0xAE, 0x11, 0x5F, 0xF3, 0x9F, 0x8A, 0xDA, 0xF6, 0x6D,\n\t0xEE, 0xDF\n};\n\nuint8_t result2[] = {\n\t0x97, 0x99, 0x3B, 0x78, 0xF7, 0xC3, 0x1C, 0x0E, 0x87, 0x6D,\n\t0xC9, 0x2E, 0xB7, 0xD6, 0xC4, 0x08, 0xE0, 0x9D, 0x60, 0x8A,\n\t0xD6, 0xB9, 0x9D, 0x0E, 0xA2, 0x22, 0x9B, 0x05, 0xA5, 0x78,\n\t0xC4, 0x26, 0x33, 0x4F, 0xCC, 0x8A, 0x1C, 0x7E, 0x67, 0x6E,\n\t0xD2, 0xD8, 0x9A, 0x5B, 0x4C, 0xDF, 0x5B, 0x3F, 0x4A, 0xDF,\n\t0x11, 0x93, 0x6B, 0xF1, 0x4F, 0x4E, 0x10, 0x90, 0x9D, 0xBA,\n\t0x9C, 0x24, 0xF4, 0xFD, 0xFF, 0xDE, 0x72, 0x35, 0x1D, 0xA8,\n\t0xE2, 0xCC, 0x3B, 0x13, 0x5A, 0x39, 0x53, 0x73, 0x89, 0x9E,\n\t0x5F, 0x1A, 0x59, 0x55, 0xB8, 0x80, 0xCA, 0x9B, 0x9E, 0x9D,\n\t0xD4, 0xC9, 0xCA, 0x7F, 0xA4, 0xD4, 0xF5, 0x98, 0x39, 0x46,\n\t0x32, 0x0E, 0x36, 0xC6, 0x4E, 0xF2, 0x83, 0xCA, 0x1F, 0x65,\n\t0xD1, 0x97, 0xCF, 0x81, 0x62, 0x4E, 0xC6, 0x77, 0x8E, 0x77,\n\t0x0E, 0x78, 0x94, 0x9D, 0x84, 0xEF, 0x21, 0xA4, 0x5C, 0xDD,\n\t0x62, 0xD1, 0xDB, 0x76, 0x92, 0x0D, 0x4C, 0x28, 0x36, 0xFC,\n\t0x6A, 0xE5, 0x29, 0x9F, 0xAF, 0x13, 0x57, 0xD9, 0x70, 0x1F,\n\t0xAD, 0x10, 0xFB, 0xD8, 0x8D, 0x1E, 0x28, 0x32, 0x23, 0x94,\n\t0x36, 0xD7, 0x6E, 0xB2, 0x71, 0xBD, 0xC3, 0xCA, 0x04, 0x42,\n\t0x5E, 0xC8, 0x8B, 0xC0, 0xE8, 0x9A, 0x4D, 0x5C, 0x37, 0xFF,\n\t0xCE, 0x7C, 0x6C, 0x3A, 0xBD, 0xE9, 0xC4, 0x13, 0xAE, 0x6D,\n\t0x3F, 0xEA\n};\n\n#elif MD_MAP == SH512\n\n#define FUNCTION \"sha-512\"\n\nuint8_t seed1[127];\n\nuint8_t result1[] = {\n\t0x17, 0x0C, 0xC7, 0x07, 0xC7, 0x1C, 0x69, 0xCE, 0x45, 0xC4,\n\t0x3C, 0xBA, 0xFF, 0x52, 0x10, 0x14, 0x05, 0x72, 0xD4, 0x78,\n\t0x59, 0x52, 0x1B, 0xA1, 0x31, 0x41, 0xBA, 0xDD, 0x2E, 0x5B,\n\t0x9A, 0x7B, 0x3E, 0x80, 0x20, 0x62, 0x5C, 0xD8, 0x89, 0x3F,\n\t0xD6, 0xA4, 0x73, 0x9C, 0x58, 0x1E, 0xD5, 0xBE, 0x7F, 0xA3,\n\t0x14, 0x8A, 0x05, 0xD7, 0xF5, 0x4A, 0xE9, 0xEA, 0xDA, 0xE8,\n\t0xF1, 0xA7, 0x19, 0x4D, 0xF9, 0x4B, 0x6B, 0x75, 0x5B, 0x94,\n\t0x8E, 0x0C, 0x27, 0xE1, 0x74, 0x7F, 0x02, 0xF6, 0x63, 0xD6,\n\t0xB5, 0x14, 0xA0, 0xF5, 0x86, 0xF9, 0x4E, 0x53, 0xD3, 0x21,\n\t0x69, 0xE1, 0xCC, 0xC6, 0x21, 0x1A, 0xD0, 0x34, 0x81, 0x24,\n\t0x19, 0xB6, 0xBA, 0x8F, 0x3C, 0x82, 0x93, 0x04, 0x89, 0x83,\n\t0x93, 0xBF, 0x39, 0xE5, 0x7E, 0x2F, 0xED, 0xF7, 0x75, 0xFC,\n\t0x6E, 0x5E, 0xB0, 0xE3, 0x07, 0xED, 0xCA, 0x0B, 0xD5, 0x15,\n\t0xB9, 0x2B, 0x18, 0x11, 0xF5, 0xAA, 0xD0, 0x2A, 0xAC, 0x9B,\n\t0x39, 0xDF, 0xA5, 0xB8, 0xB1, 0xA9, 0x50, 0x48, 0x7D, 0x34,\n\t0x29, 0xB1, 0x08, 0x1D, 0x0F, 0xEC, 0x28, 0xD5, 0x76, 0x86,\n\t0xD8, 0x5B, 0xC6, 0xB4, 0x5A, 0xB8, 0xB8, 0x4C, 0x54, 0xDD,\n\t0x80, 0xB2, 0x82, 0x59, 0x1F, 0x55, 0x07, 0xED, 0x9B, 0x3F,\n\t0xB1, 0xCD, 0xEE, 0xFD, 0x58, 0xAD, 0x5A, 0x98, 0x12, 0xED,\n\t0x92, 0x9C, 0x77, 0x9B, 0x0F, 0x54, 0xBA, 0xDF, 0x2C, 0xAF,\n\t0xBA, 0xCF, 0xAC, 0xB3, 0xEC, 0xAC, 0xC1, 0x27, 0xC7, 0x64,\n\t0x0C, 0xBB, 0x67, 0x15, 0x4F, 0x54, 0x5A, 0x62, 0x2B, 0xE0,\n\t0xA9, 0xB5, 0x52, 0xA2, 0x42, 0x08, 0x31, 0x3B, 0xFA, 0x49,\n\t0x1F, 0x53, 0xAA, 0xA3, 0x07, 0x4B, 0xDC, 0x48, 0xBC, 0x5B,\n\t0xDB, 0x3F, 0xF0, 0xE2, 0xD0, 0x5B, 0xB4, 0x77, 0xB5, 0x9F,\n\t0x87, 0xE3, 0xA1, 0xEA, 0xB3, 0xE6\n};\n\nuint8_t result2[] = {\n\t0xF9, 0x3C, 0xA6, 0x85, 0x55, 0x90, 0xA7, 0x7F, 0x07, 0x35,\n\t0x40, 0x97, 0xE9, 0x0E, 0x02, 0x66, 0x48, 0xB6, 0x11, 0x5D,\n\t0xF0, 0x08, 0xFF, 0xED, 0xBD, 0x9D, 0x98, 0x11, 0xF5, 0x4E,\n\t0x82, 0x86, 0xEF, 0x00, 0xFD, 0xD6, 0xBA, 0x1E, 0x58, 0xDF,\n\t0x25, 0x35, 0xE3, 0xFB, 0xDD, 0x9A, 0x9B, 0xA3, 0x75, 0x4A,\n\t0x97, 0xF3, 0x6E, 0xE8, 0x33, 0x22, 0x15, 0x82, 0x06, 0x0A,\n\t0x1F, 0x37, 0xFC, 0xE4, 0xEE, 0x88, 0x26, 0x63, 0x6B, 0x28,\n\t0xEA, 0xD5, 0x89, 0x59, 0x3F, 0x4C, 0xA8, 0xB6, 0x47, 0x38,\n\t0x8F, 0x24, 0xEB, 0x3F, 0x0A, 0x34, 0x79, 0x69, 0x68, 0xD2,\n\t0x1B, 0xDE, 0xE6, 0xF8, 0x1F, 0xD5, 0xDF, 0x93, 0x53, 0x6F,\n\t0x93, 0x59, 0x37, 0xB8, 0x02, 0x5E, 0xC8, 0xCB, 0xF5, 0x7D,\n\t0xDB, 0x0C, 0x61, 0xF2, 0xE4, 0x14, 0x63, 0xCC, 0x15, 0x16,\n\t0xD6, 0x57, 0xDA, 0x28, 0x29, 0xC6, 0xBF, 0x90, 0x48, 0x17,\n\t0x61, 0x8F, 0x48, 0xC6, 0x0F, 0xB1, 0xCE, 0x5B, 0xFB, 0xDA,\n\t0x0C, 0xAF, 0x45, 0x91, 0x88, 0x2A, 0x31, 0xF6, 0xEE, 0x3F,\n\t0xE0, 0xF7, 0x87, 0x79, 0x99, 0x2A, 0x06, 0xEC, 0x60, 0xF3,\n\t0x7F, 0xB9, 0xA8, 0xD6, 0x10, 0x8C, 0x23, 0x1F, 0x0A, 0x92,\n\t0x77, 0x54, 0xB0, 0x59, 0x9F, 0xA4, 0xFA, 0x27, 0xA4, 0xE2,\n\t0x5E, 0x06, 0x5E, 0xF0, 0x30, 0x85, 0xB8, 0x92, 0x97, 0x9D,\n\t0xC0, 0xE7, 0xA1, 0x08, 0x08, 0x83, 0xCA, 0xEB, 0xFD, 0xFD,\n\t0x36, 0x65, 0xA8, 0xF2, 0xD0, 0x61, 0xC5, 0x21, 0xF7, 0xD6,\n\t0xE3, 0xDA, 0x2A, 0xF8, 0xB9, 0x7B, 0x6B, 0x43, 0xB6, 0xEC,\n\t0x83, 0x1A, 0xF5, 0x15, 0x07, 0x0A, 0x83, 0xBB, 0xB9, 0xAC,\n\t0x95, 0xED, 0x4E, 0xF4, 0x9B, 0x75, 0x6A, 0x23, 0x77, 0xA5,\n\t0xF0, 0x83, 0x3D, 0x84, 0x7E, 0x27, 0xA8, 0x8D, 0xDB, 0x0C,\n\t0x2C, 0xE4, 0xAD, 0x78, 0x2E, 0x7B\n};\n\n#elif MD_MAP == B2S160\n\n#define FUNCTION \"blake2s-160\"\n\nuint8_t seed1[60];\n\nuint8_t result1[] = {\n\t0x3B, 0xFB, 0x98, 0xB1, 0x75, 0x4A, 0x85, 0x1D, 0x82, 0x51,\n\t0x09, 0xE7, 0xA9, 0x7B, 0x45, 0x25, 0x3F, 0x82, 0xEC, 0xBB,\n\t0x8A, 0xF6, 0x7A, 0x15, 0x6B, 0x8D, 0x8A, 0xE7, 0x1E, 0xD9,\n\t0x17, 0xED, 0x24, 0x35, 0x00, 0x87, 0x7B, 0xE6, 0xBD, 0xEF,\n\t0xF5, 0xD7, 0xD0, 0x6C, 0x57, 0x08, 0xF6, 0x62, 0x43, 0x51,\n\t0xD6, 0x9C, 0x6A, 0x7A, 0xF1, 0xC9, 0xB3, 0xF6, 0xD9, 0x5B,\n\t0x94, 0x3C, 0xBB, 0x1A, 0xF4, 0x3C, 0xD8, 0xB4, 0x2A, 0xA3,\n\t0xE8, 0x7C, 0x62, 0x40, 0xD1, 0xBD, 0x5D, 0x6B, 0x8C, 0xF0\n};\n\nuint8_t result2[] = {\n\t0xAD, 0xF3, 0x6B, 0x2A, 0x4A, 0xAA, 0x78, 0xEC, 0x4B, 0xE7,\n\t0x50, 0xEA, 0x91, 0x08, 0xD7, 0xBC, 0x9A, 0x7B, 0x52, 0x0A,\n\t0x46, 0x0D, 0xA5, 0xD9, 0x12, 0xCC, 0xF8, 0x3C, 0x51, 0x48,\n\t0xFD, 0xD3, 0x45, 0x9E, 0xC5, 0x84, 0xF1, 0x29, 0xFD, 0x0C,\n\t0x03, 0x28, 0xD1, 0xEF, 0x0B, 0xBE, 0x73, 0x8B, 0xD4, 0x77,\n\t0xA2, 0x48, 0x05, 0xDE, 0xA3, 0xFD, 0xB2, 0x75, 0xF2, 0x9F,\n\t0xE8, 0xCA, 0xEF, 0xDB, 0x5D, 0x4F, 0xBF, 0xB6, 0x27, 0x93,\n\t0x98, 0x7B, 0x11, 0x8D, 0x9F, 0x97, 0xA1, 0x4E, 0x67, 0x82\n};\n\n#elif MD_MAP == B2S256\n\nuint8_t seed1[63];\n\n#define FUNCTION \"blake2s-256\"\n\nuint8_t result1[] = {\n\t0xD5, 0x26, 0xBD, 0x3B, 0x1A, 0x08, 0x91, 0x25, 0xB1, 0x2D,\n\t0xFF, 0x63, 0x57, 0x33, 0x85, 0x11, 0x7A, 0x1E, 0xF3, 0x7E,\n\t0xE0, 0xAE, 0xCE, 0x77, 0xAC, 0x19, 0x8B, 0x92, 0x7A, 0xDE,\n\t0x79, 0x23, 0x0E, 0xA9, 0x25, 0xF3, 0x33, 0xB4, 0x17, 0xC7,\n\t0xF7, 0x0A, 0xEB, 0x25, 0x0C, 0x9B, 0xAF, 0x38, 0xD0, 0x5C,\n\t0xCE, 0xC6, 0xB5, 0x63, 0x70, 0x15, 0xD7, 0x36, 0x4A, 0x99,\n\t0x25, 0xE9, 0xE1, 0x76, 0x75, 0xE0, 0x1C, 0x8E, 0x1E, 0x0B,\n\t0xC1, 0xE2, 0x8F, 0xB7, 0xCA, 0x56, 0x69, 0xB7, 0xAB, 0x5B,\n\t0x45, 0x6F, 0x5B, 0xA4, 0xF3, 0xAA, 0x54, 0x30, 0x3B, 0x44,\n\t0xFF, 0x35, 0xBF, 0xBB, 0xD8, 0xA3, 0xEA, 0xFA, 0x32, 0x8F,\n\t0xD0, 0x68, 0x76, 0x5B, 0x47, 0x9E, 0x61, 0x73, 0xEB, 0xF8,\n\t0x84, 0x1D, 0xF5, 0xA7, 0xEF, 0x91, 0x47, 0x19, 0x30, 0x12,\n\t0xF6, 0x7C, 0x04, 0x7A, 0x4F, 0x4F, 0x07, 0xA0\n};\n\nuint8_t result2[] = {\n\t0xAB, 0x61, 0x58, 0xF2, 0x82, 0x88, 0xAA, 0x0A, 0xD1, 0xA3,\n\t0x98, 0xAD, 0x73, 0xD5, 0xD5, 0x1D, 0x6E, 0xDE, 0xA4, 0x24,\n\t0xA7, 0x76, 0x3D, 0x77, 0xD5, 0x33, 0xB8, 0x1B, 0xE7, 0x43,\n\t0x32, 0x0A, 0xB6, 0x44, 0x4D, 0x47, 0x54, 0x68, 0x69, 0x1B,\n\t0xA7, 0x5E, 0xA4, 0x90, 0x1D, 0x21, 0xBA, 0x3B, 0xC3, 0x7B,\n\t0x60, 0x3A, 0xDB, 0xD5, 0xDC, 0xCB, 0x8B, 0x6E, 0xB6, 0x6A,\n\t0xA0, 0xA7, 0x5B, 0xBB, 0x40, 0xC4, 0x7E, 0xB9, 0xD0, 0xC9,\n\t0xDB, 0xFF, 0xAC, 0x19, 0xFA, 0xB2, 0x71, 0x41, 0xAB, 0x0A,\n\t0x41, 0xEB, 0x9C, 0xD1, 0x42, 0x08, 0x97, 0xAF, 0x17, 0x87,\n\t0x45, 0x7A, 0x2C, 0x7D, 0x8F, 0x43, 0xB3, 0x85, 0x49, 0xFF,\n\t0x28, 0x81, 0xE9, 0x5C, 0x85, 0x58, 0x06, 0x74, 0x11, 0x3A,\n\t0xDC, 0x00, 0x29, 0xA0, 0x78, 0xC8, 0xA7, 0xE4, 0xEB, 0x2D,\n\t0x9D, 0x07, 0xE1, 0x64, 0xCC, 0x0B, 0x94, 0x37\n};\n\n#endif\n\nstatic int test(void) {\n\tint i, len = 2 * RLC_MD_LEN, code = RLC_ERR;\n\tuint8_t out[2 * RLC_MD_LEN], seed2[(RLC_RAND_SIZE - 1) / 2], seed3[(RLC_RAND_SIZE - 1) / 2];\n\n\tfor (i = 0; i < (RLC_RAND_SIZE - 1) / 2; i++) {\n\t\tseed1[i] = i;\n\t\tseed2[i] = 0x80 + i;\n\t\tseed3[i] = 0xC0 + i;\n\t}\n\tfor (; i < sizeof(seed1); i++) {\n\t\tseed1[i] = 0x20 + (i - (RLC_RAND_SIZE - 1) / 2);\n\t}\n\n\tTEST_ONCE(\"hash-dbrg (\" FUNCTION \") random generator is correct\") {\n\t\trand_clean();\n\t\trand_seed(seed1, sizeof(seed1));\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result1, len) == 0, end);\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result1 + len, len) == 0, end);\n\t}\n\tTEST_END;\n\n\tTEST_ONCE(\"hash-dbrg (\" FUNCTION \") reseeding is correct\") {\n\t\trand_clean();\n\t\trand_seed(seed1, sizeof(seed1));\n\t\trand_seed(seed2, sizeof(seed2));\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result2, len) == 0, end);\n\t\trand_seed(seed3, sizeof(seed3));\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result2 + len, len) == 0, end);\n\t}\n\tTEST_END;\n\n\tcode = RLC_OK;\n\n  end:\n\treturn code;\n}\n\n#elif RAND == UDEV\n\nstatic int test(void) {\n\tuint8_t out[20], digit;\n\n\tTEST_ONCE(\"reading from /dev/urandom is correct\") {\n\t\tdigit = 0;\n\t\tmemset(out, 0, sizeof(out));\n\t\trand_bytes(out, sizeof(out));\n\t\tfor (int j = 0; j < sizeof(20); j++) {\n\t\t\tdigit ^= out[j];\n\t\t}\n\t\tTEST_ASSERT(digit != 0, end);\n\t}\n\tTEST_END;\n  end:\n\treturn RLC_OK;\n}\n\n#elif RAND == RDRND\n\nstatic int test(void) {\n\tuint8_t out[64];\n\tint len = sizeof(out) / 2, code = RLC_ERR;\n\n\tTEST_ONCE(\"rdrand hardware generator is non-trivial\") {\n\t\tmemset(out, 0, 2 * len);\n\t\trand_bytes(out, len);\n\t\t/* This fails with negligible probability. */\n\t\tTEST_ASSERT(memcmp(out, out + len, len) != 0, end);\n\t}\n\tTEST_END;\n\n\tcode = RLC_OK;\n\n  end:\n\treturn code;\n}\n\n#elif RAND == CALL\n\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nstatic void test_bytes(uint8_t *buf, int size, void *args) {\n\tint c, l, fd = *(int *)args;\n\n\tif (fd == -1) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t}\n\n\tl = 0;\n\tdo {\n\t\tc = read(fd, buf + l, size - l);\n\t\tl += c;\n\t\tif (c == -1) {\n\t\t\tRLC_THROW(ERR_NO_READ);\n\t\t}\n\t} while (l < size);\n}\n\nstatic int test(void) {\n\tuint8_t out[20], digit;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\n\tTEST_ONCE(\"callback to reading /dev/urandom is correct\") {\n\t\tdigit = 0;\n\t\tmemset(out, 0, sizeof(out));\n\t\trand_bytes(out, sizeof(out));\n\t\tfor (int j = 0; j < sizeof(20); j++) {\n\t\t\tdigit ^= out[j];\n\t\t}\n\t\tTEST_ASSERT(digit != 0, end);\n\t\trand_seed(&test_bytes, (void *)&fd);\n\t\trand_bytes(out, sizeof(out));\n\t\tfor (int j = 0; j < sizeof(20); j++) {\n\t\t\tdigit ^= out[j];\n\t\t}\n\t\tTEST_ASSERT(digit != 0, end);\n\t}\n\tTEST_END;\n  end:\n  \tclose(fd);\n\treturn RLC_OK;\n}\n\n#endif\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the RAND module:\\n\", 0);\n\n\tif (test() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n"], "fixing_code": ["/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Benchmarks for multiple precision integer arithmetic.\n *\n * @ingroup bench\n */\n\n#include \"relic.h\"\n#include \"relic_bench.h\"\n\nstatic void memory(void) {\n\tbn_t a[BENCH];\n\n\tBENCH_FEW(\"bn_null\", bn_null(a[i]), 1);\n\n\tBENCH_FEW(\"bn_new\", bn_new(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tBENCH_FEW(\"bn_new_size\", bn_new_size(a[i], 2 * RLC_BN_DIGS), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t\tbn_clean(a[i]);\n\t}\n\tBENCH_FEW(\"bn_make\", bn_make(a[i], RLC_BN_DIGS), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t}\n\tBENCH_FEW(\"bn_clean\", bn_clean(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t}\n\tBENCH_FEW(\"bn_grow\", bn_grow(a[i], 2 * RLC_BN_DIGS), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t\tbn_grow(a[i], 2 * RLC_BN_DIGS);\n\t}\n\tBENCH_FEW(\"bn_trim\", bn_trim(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new(a[i]);\n\t}\n\tBENCH_FEW(\"bn_free\", bn_free(a[i]), 1);\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tbn_new_size(a[i], 2 * RLC_BN_DIGS);\n\t}\n\tBENCH_FEW(\"bn_free (size)\", bn_free(a[i]), 1);\n}\n\nstatic void util(void) {\n\tdig_t digit;\n\tchar str[RLC_CEIL(RLC_BN_BITS, 8) * 3 + 1];\n\tuint8_t bin[RLC_CEIL(RLC_BN_BITS, 8)];\n\tdig_t raw[RLC_BN_DIGS];\n\tbn_t a, b;\n\n\tbn_null(a);\n\tbn_null(b);\n\n\tbn_new(a);\n\tbn_new(b);\n\n\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\n\tBENCH_RUN(\"bn_copy\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_copy(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_abs\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_abs(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_neg\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_neg(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_sign\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sign(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_zero\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_zero(b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_is_zero\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_is_zero(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_is_even\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_is_even(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_bits\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_bits(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_get_bit\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_get_bit(a, RLC_BN_BITS / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_set_bit\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_set_bit(a, RLC_BN_BITS / 2, 1));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_ham\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_ham(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_get_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_get_dig(&digit, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_set_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_set_dig(a, 1));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_set_2b\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_set_2b(a, RLC_BN_BITS / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rand\") {\n\t\tBENCH_ADD(bn_rand(a, RLC_POS, RLC_BN_BITS));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rand_mod\") {\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_rand_mod(a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_size_str\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_size_str(a, 10));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_write_str\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_write_str(str, sizeof(str), a, 10));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_read_str\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_read_str(a, str, sizeof(str), 10));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_size_bin\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_size_bin(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_write_bin\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_write_bin(bin, bn_size_bin(a), a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_read_bin\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_read_bin(a, bin, bn_size_bin(a)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_size_raw\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_size_raw(a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_write_raw\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_write_raw(raw, bn_size_raw(a), a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_read_raw\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_read_raw(a, raw, bn_size_raw(a)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_cmp_abs\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_cmp_abs(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_cmp_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_cmp_dig(a, (dig_t)0));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_cmp\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_cmp(b, a));\n\t}\n\tBENCH_END;\n\n\tbn_free(a);\n\tbn_free(b);\n}\n\nstatic void arith(void) {\n\tbn_t a, b, c, d[3], e[3];\n\tcrt_t crt;\n\tdig_t f;\n\tsize_t len;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tcrt_null(crt);\n\n\tbn_new(a);\n\tbn_new(b);\n\tbn_new(c);\n\tfor (int j = 0; j < 3; j++) {\n\t\tbn_null(d[j]);\n\t\tbn_null(e[j]);\n\t\tbn_new(d[j]);\n\t\tbn_new(e[j]);\n\t}\n\tcrt_new(crt);\n\n\tBENCH_RUN(\"bn_add\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_add(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_add_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_add_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_sub\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sub(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_sub_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_sub_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mul\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mul_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_mul_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n#if BN_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mul_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul_basic(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MUL == COMBA || !defined(STRIP)\n\tBENCH_RUN(\"bn_mul_comba\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul_comba(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\tBENCH_RUN(\"bn_mul_karat\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mul_karat(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_sqr\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr(c, a));\n\t}\n\tBENCH_END;\n\n#if BN_SQR == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_sqr_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr_basic(c, a));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_SQR == COMBA || !defined(STRIP)\n\tBENCH_RUN(\"bn_sqr_comba\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr_comba(c, a));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\tBENCH_RUN(\"bn_sqr_karat\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_sqr_karat(c, a));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_dbl\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_dbl(c, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_hlv\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_hlv(c, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_lsh\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_lsh(c, a, RLC_BN_BITS / 2 + RLC_DIG / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rsh\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_rsh(c, a, RLC_BN_BITS / 2 + RLC_DIG / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_div(c, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div_rem\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_div_rem(c, d[0], a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div_dig\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tdo {\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t} while (bn_is_zero(b));\n\t\tBENCH_ADD(bn_div_dig(c, a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_div_rem_dig\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tdo {\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t} while (bn_is_zero(b));\n\t\tBENCH_ADD(bn_div_rem_dig(c, &f, a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_2b\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mod_2b(c, a, RLC_BN_BITS / 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tdo {\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t} while (bn_is_zero(b));\n\t\tBENCH_ADD(bn_mod_dig(&f, a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod\") {\n#if BN_MOD == PMERS\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n\t\tbn_mod_pre(d, b);\n#else\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod_pre(d[0], b);\n#endif\n\t\tBENCH_ADD(bn_mod(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n\n#if BN_MOD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_basic\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mod_basic(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == BARRT || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_pre_barrt\") {\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_mod_pre_barrt(d[0], b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == BARRT || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_barrt\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tbn_mod_pre_barrt(d[0], b);\n\t\tBENCH_ADD(bn_mod_barrt(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == MONTY || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_pre_monty\") {\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tBENCH_ADD(bn_mod_pre_monty(d[0], b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_monty_conv\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mod_monty_conv(a, a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_monty\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n\n#if BN_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_monty_basic\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty_basic(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MUL == COMBA || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_monty_comba\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty_comba(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_mod_monty_back\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tbn_mod(a, a, b);\n\t\tbn_mod_pre_monty(d[0], b);\n\t\tBENCH_ADD(bn_mod_monty_back(c, c, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MOD == PMERS || !defined(STRIP)\n\tBENCH_RUN(\"bn_mod_pre_pmers\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n\t\tBENCH_ADD(bn_mod_pre_pmers(d[0], b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_mod_pmers\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n\t\tbn_mod_pre_pmers(d[0], b);\n\t\tBENCH_ADD(bn_mod_pmers(c, a, b, d[0]));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_mxp\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n#if BN_MOD != PMERS\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n#else\n\t\tbn_set_2b(b, RLC_BN_BITS);\n\t\tbn_rand(c, RLC_POS, RLC_DIG);\n\t\tbn_sub(b, b, c);\n#endif\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp(c, a, b, b));\n\t}\n\tBENCH_END;\n\n#if BN_MXP == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_mxp_basic\") {\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp_basic(c, a, b, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MXP == SLIDE || !defined(STRIP)\n\tBENCH_RUN(\"bn_mxp_slide\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp_slide(c, a, b, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_MXP == CONST || !defined(STRIP)\n\tBENCH_RUN(\"bn_mxp_monty\") {\n\t\tbn_rand(a, RLC_POS, 2 * RLC_BN_BITS - RLC_DIG / 2);\n\t\tbn_mod(a, a, b);\n\t\tBENCH_ADD(bn_mxp_monty(c, a, b, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_mxp_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(d[0], RLC_POS, RLC_DIG);\n\t\tbn_get_dig(&f, d[0]);\n\t\tBENCH_ADD(bn_mxp_dig(c, a, f, b));\n\t}\n\tBENCH_END;\n\n\tbn_gen_prime(crt->p, RLC_BN_BITS / 2);\n\tbn_gen_prime(crt->q, RLC_BN_BITS / 2);\n\tbn_mul(crt->n, crt->p, crt->q);\n\tbn_mod_inv(crt->qi, crt->q, crt->p);\n\tbn_sub_dig(crt->dp, crt->p, 1);\n\tbn_sub_dig(crt->dq, crt->q, 1);\n\tBENCH_RUN(\"bn_mxp_crt\") {\n\t\tbn_rand(c, RLC_POS, RLC_BN_BITS);\n\t\tbn_mod(a, c, crt->dp);\n\t\tbn_mod(b, c, crt->dq);\n\t\tBENCH_ADD(bn_mxp_crt(c, c, a, b, crt, 0));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_srt\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_srt(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_gcd\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd(c, a, b));\n\t}\n\tBENCH_END;\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_basic(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_lehme\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_lehme(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_binar\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_binar(c, a, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_gcd_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\tbn_get_dig(&f, b);\n\t\tBENCH_ADD(bn_gcd_dig(c, a, f));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_gcd_ext\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_basic\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_basic(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_binar\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_binar(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_lehme\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_lehme(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\tBENCH_RUN(\"bn_gcd_ext_binar\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_binar(c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"bn_gcd_ext_mid\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_gcd_ext_mid(c, c, d[0], d[1], a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_gcd_ext_dig\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\tBENCH_ADD(bn_gcd_ext_dig(c, d[0], d[1], a, b->dp[0]));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_lcm\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_lcm(c, a, b));\n\t}\n\tBENCH_END;\n\n\tbn_gen_prime(b, RLC_BN_BITS);\n\n\tBENCH_RUN(\"bn_smb_leg\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_smb_leg(a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_smb_jac\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tif (bn_is_even(b)) {\n\t\t\tbn_add_dig(b, b, 1);\n\t\t}\n\t\tBENCH_ADD(bn_smb_jac(a, b));\n\t}\n\tBENCH_END;\n\n\tBENCH_ONE(\"bn_gen_prime\", bn_gen_prime(a, RLC_BN_BITS), 1);\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\tBENCH_ONE(\"bn_gen_prime_basic\", bn_gen_prime_basic(a, RLC_BN_BITS), 1);\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\tBENCH_ONE(\"bn_gen_prime_safep\", bn_gen_prime_safep(a, RLC_BN_BITS), 1);\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\tBENCH_ONE(\"bn_gen_prime_stron\", bn_gen_prime_stron(a, RLC_BN_BITS), 1);\n#endif\n\n\tBENCH_ONE(\"bn_is_prime\", bn_is_prime(a), 1);\n\n\tBENCH_ONE(\"bn_is_prime_basic\", bn_is_prime_basic(a), 1);\n\n\tBENCH_ONE(\"bn_is_prime_rabin\", bn_is_prime_rabin(a), 1);\n\n\tBENCH_ONE(\"bn_is_prime_solov\", bn_is_prime_solov(a), 1);\n\n\t/* It should be the case that a is prime here. */\n\tBENCH_RUN(\"bn_mod_inv\") {\n\t\tbn_rand_mod(b, a);\n\t\tBENCH_ADD(bn_mod_inv(c, b, a));\n\t}\n\tBENCH_END;\n\n\t/* It should be the case that a is prime here. */\n\tBENCH_RUN(\"bn_mod_inv_sim (2)\") {\n\t\tbn_rand_mod(d[0], a);\n\t\tbn_rand_mod(d[1], a);\n\t\tBENCH_ADD(bn_mod_inv_sim(d, d, a, 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_lag (2)\") {\n\t\tbn_rand_mod(d[0], a);\n\t\tbn_rand_mod(d[1], a);\n\t\tBENCH_ADD(bn_lag(d, d, a, 2));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_evl (2)\") {\n\t\tbn_rand_mod(b, a);\n\t\tbn_rand_mod(d[0], a);\n\t\tbn_rand_mod(d[1], a);\n\t\tbn_lag(d, d, a, 2);\n\t\tBENCH_ADD(bn_evl(c, d, b, a, 2));\n\t}\n\tBENCH_END;\n\n\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\n\tBENCH_ONE(\"bn_factor\", bn_factor(c, a), 1);\n\n\tBENCH_RUN(\"bn_is_factor\") {\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD(bn_is_factor(b, a));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_win\") {\n\t\tuint8_t win[RLC_BN_BITS + 1];\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_win(win, &len, a, 4)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_slw\") {\n\t\tuint8_t win[RLC_BN_BITS + 1];\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_slw(win, &len, a, 4)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_naf\") {\n\t\tint8_t naf[RLC_BN_BITS + 1];\n\t\tsize_t len;\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_naf(naf, &len, a, 4)));\n\t}\n\tBENCH_END;\n\n#if defined(WITH_EB) && defined(EB_KBLTZ) && (EB_MUL == LWNAF || EB_MUL == RWNAF || EB_FIX == LWNAF || EB_SIM == INTER || !defined(STRIP))\n\tif (eb_param_set_any_kbltz() == RLC_OK) {\n\t\tBENCH_RUN(\"bn_rec_tnaf\") {\n\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\tsize_t len = RLC_BN_BITS + 1;\n\t\t\teb_curve_get_ord(b);\n\t\t\tbn_rand_mod(a, b);\n\t\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_tnaf(tnaf, &len, a, -1, RLC_FB_BITS, 4)));\n\t\t\t} else {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_tnaf(tnaf, &len, a, 1, RLC_FB_BITS, 4)));\n\t\t\t}\n\t\t}\n\t\tBENCH_END;\n\n\t\tBENCH_RUN(\"bn_rec_rtnaf\") {\n\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\teb_curve_get_ord(b);\n\t\t\tbn_rand_mod(a, b);\n\t\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_rtnaf(tnaf, &len, a, -1, RLC_FB_BITS, 4)));\n\t\t\t} else {\n\t\t\t\tBENCH_ADD((len = RLC_FB_BITS + 8, bn_rec_rtnaf(tnaf, &len, a, 1, RLC_FB_BITS, 4)));\n\t\t\t}\n\t\t}\n\t\tBENCH_END;\n\t}\n#endif\n\n\tBENCH_RUN(\"bn_rec_reg\") {\n\t\tint8_t naf[RLC_BN_BITS + 1];\n\t\tsize_t len = RLC_BN_BITS + 1;\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = RLC_BN_BITS + 1, bn_rec_reg(naf, &len, a, RLC_BN_BITS, 4)));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"bn_rec_jsf\") {\n\t\tint8_t jsf[2 * (RLC_BN_BITS + 1)];\n\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\tBENCH_ADD((len = 2 * (RLC_BN_BITS + 1), bn_rec_jsf(jsf, &len, a, b)));\n\t}\n\tBENCH_END;\n\n#if defined(WITH_EP) && defined(EP_ENDOM) && (EP_MUL == LWNAF || EP_FIX == COMBS || EP_FIX == LWNAF || EP_SIM == INTER || !defined(STRIP))\n\tif (ep_param_set_any_endom() == RLC_OK) {\n\t\tBENCH_RUN(\"bn_rec_glv\") {\n\t\t\tep_curve_get_v1(d);\n\t\t\tep_curve_get_v2(e);\n\t\t\tep_curve_get_ord(c);\n\t\t\tbn_rand_mod(a, c);\n\t\t\tBENCH_ADD(bn_rec_glv(a, b, a, c, (const bn_t *)d, (const bn_t *)e));\n\t\t}\n\t\tBENCH_END;\n\t}\n#endif /* WITH_EP && EP_KBLTZ */\n\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tfor (int j = 0; j < 3; j++) {\n\t\tbn_free(d[j]);\n\t\tbn_free(e[j]);\n\t}\n\tcrt_free(crt);\n}\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tconf_print();\n\tutil_banner(\"Benchmarks for the BN module:\", 0);\n\tutil_banner(\"Utilities:\", 1);\n\tmemory();\n\tutil();\n\tutil_banner(\"Arithmetic:\", 1);\n\tarith();\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Benchmarks for cryptographic protocols.\n *\n * @version $Id$\n * @ingroup bench\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_bench.h\"\n\n#if defined(WITH_BN)\n\nstatic void rsa(void) {\n\trsa_t pub, prv;\n\tuint8_t in[10], new[10], h[RLC_MD_LEN], out[RLC_BN_BITS / 8 + 1];\n\tsize_t out_len, new_len;\n\n\trsa_null(pub);\n\trsa_null(prv);\n\n\trsa_new(pub);\n\trsa_new(prv);\n\n\tBENCH_ONE(\"cp_rsa_gen\", cp_rsa_gen(pub, prv, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_rsa_enc\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_rsa_enc(out, &out_len, in, sizeof(in), pub));\n\t\tcp_rsa_dec(new, &new_len, out, out_len, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_dec\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_rsa_enc(out, &out_len, in, sizeof(in), pub);\n\t\tBENCH_ADD(cp_rsa_dec(new, &new_len, out, out_len, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_sig (h = 0)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_rsa_sig(out, &out_len, in, sizeof(in), 0, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_sig (h = 1)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tmd_map(h, in, sizeof(in));\n\t\tBENCH_ADD(cp_rsa_sig(out, &out_len, h, RLC_MD_LEN, 1, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_ver (h = 0)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_rsa_sig(out, &out_len, in, sizeof(in), 0, prv);\n\t\tBENCH_ADD(cp_rsa_ver(out, out_len, in, sizeof(in), 0, pub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsa_ver (h = 1)\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\tnew_len = out_len;\n\t\trand_bytes(in, sizeof(in));\n\t\tmd_map(h, in, sizeof(in));\n\t\tcp_rsa_sig(out, &out_len, h, RLC_MD_LEN, 1, prv);\n\t\tBENCH_ADD(cp_rsa_ver(out, out_len, h, RLC_MD_LEN, 1, pub));\n\t} BENCH_END;\n\n\trsa_free(pub);\n\trsa_free(prv);\n}\n\nstatic void rabin(void) {\n\trabin_t pub, prv;\n\tuint8_t in[1000], new[1000], out[RLC_BN_BITS / 8 + 1];\n\tsize_t in_len, out_len, new_len;\n\n\trabin_null(pub);\n\trabin_null(prv);\n\n\trabin_new(pub);\n\trabin_new(prv);\n\n\tBENCH_ONE(\"cp_rabin_gen\", cp_rabin_gen(pub, prv, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_rabin_enc\") {\n\t\tin_len = bn_size_bin(pub->n) - 10;\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(in, in_len);\n\t\tBENCH_ADD(cp_rabin_enc(out, &out_len, in, in_len, pub));\n\t\tcp_rabin_dec(new, &new_len, out, out_len, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rabin_dec\") {\n\t\tin_len = bn_size_bin(pub->n) - 10;\n\t\tnew_len = in_len;\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(in, in_len);\n\t\tcp_rabin_enc(out, &out_len, in, in_len, pub);\n\t\tBENCH_ADD(cp_rabin_dec(new, &new_len, out, out_len, prv));\n\t} BENCH_END;\n\n\trabin_free(pub);\n\trabin_free(prv);\n}\n\nstatic void benaloh(void) {\n\tbdpe_t pub, prv;\n\tdig_t in, new;\n\tuint8_t out[RLC_BN_BITS / 8 + 1];\n\tsize_t out_len;\n\tdig_t prime = 0xFB;\n\n\tbdpe_null(pub);\n\tbdpe_null(prv);\n\n\tbdpe_new(pub);\n\tbdpe_new(prv);\n\n\tBENCH_ONE(\"cp_bdpe_gen\", cp_bdpe_gen(pub, prv, prime, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_bdpe_enc\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(out, 1);\n\t\tin = out[0] % prime;\n\t\tBENCH_ADD(cp_bdpe_enc(out, &out_len, in, pub));\n\t\tcp_bdpe_dec(&new, out, out_len, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bdpe_dec\") {\n\t\tout_len = RLC_BN_BITS / 8 + 1;\n\t\trand_bytes(out, 1);\n\t\tin = out[0] % prime;\n\t\tcp_bdpe_enc(out, &out_len, in, pub);\n\t\tBENCH_ADD(cp_bdpe_dec(&new, out, out_len, prv));\n\t} BENCH_END;\n\n\tbdpe_free(pub);\n\tbdpe_free(prv);\n}\n\nstatic void paillier(void) {\n\tbn_t c, m, pub;\n\tphpe_t prv;\n    shpe_t spub, sprv;\n\n\tbn_null(c);\n\tbn_null(m);\n\tbn_null(pub);\n\tphpe_null(prv);\n    shpe_null(spub);\n    shpe_null(sprv);\n\n\n\tbn_new(c);\n\tbn_new(m);\n\tbn_new(pub);\n\tphpe_new(prv);\n    shpe_new(spub);\n    shpe_new(sprv);\n\n\tBENCH_ONE(\"cp_phpe_gen\", cp_phpe_gen(pub, prv, RLC_BN_BITS / 2), 1);\n\n\tBENCH_RUN(\"cp_phpe_enc\") {\n\t\tbn_rand_mod(m, pub);\n\t\tBENCH_ADD(cp_phpe_enc(c, m, pub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_phpe_add\") {\n\t\tbn_rand_mod(m, pub);\n\t\tcp_phpe_enc(c, m, pub);\n\t\tBENCH_ADD(cp_phpe_add(c, c, c, pub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_phpe_dec\") {\n\t\tbn_rand_mod(m, pub);\n\t\tcp_phpe_enc(c, m, pub);\n\t\tBENCH_ADD(cp_phpe_dec(m, c, prv));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_shpe_gen\", cp_shpe_gen(spub, sprv, RLC_BN_BITS / 10, RLC_BN_BITS / 2), 1);\n\n\tBENCH_RUN(\"cp_shpe_enc\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tBENCH_ADD(cp_shpe_enc(c, m, spub));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shpe_enc_prv\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tBENCH_ADD(cp_shpe_enc_prv(c, m, sprv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shpe_dec (1)\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tcp_shpe_enc(c, m, spub);\n\t\tBENCH_ADD(cp_shpe_dec(m, c, sprv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shpe_dec (2)\") {\n\t\tbn_rand_mod(m, spub->crt->n);\n\t\tcp_shpe_enc_prv(c, m, sprv);\n\t\tBENCH_ADD(cp_shpe_dec(m, c, sprv));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_ghpe_gen\", cp_ghpe_gen(pub, prv->n, RLC_BN_BITS / 2), 1);\n\n\tBENCH_RUN(\"cp_ghpe_enc (1)\") {\n\t\tbn_rand_mod(m, pub);\n\t\tBENCH_ADD(cp_ghpe_enc(c, m, pub, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_ghpe_dec (1)\") {\n\t\tbn_rand_mod(m, pub);\n\t\tcp_ghpe_enc(m, c, pub, 1);\n\t\tBENCH_ADD(cp_ghpe_dec(c, m, pub, prv->n, 1));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_ghpe_gen\", cp_ghpe_gen(pub, prv->n, RLC_BN_BITS / 4), 1);\n\n\tBENCH_RUN(\"cp_ghpe_enc (2)\") {\n\t\tbn_rand(m, RLC_POS, 2 * bn_bits(pub) - 1);\n\t\tBENCH_ADD(cp_ghpe_enc(m, c, pub, 2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_ghpe_dec (2)\") {\n\t\tbn_rand(m, RLC_POS, 2 * bn_bits(pub) - 1);\n\t\tcp_ghpe_enc(m, c, pub, 2);\n\t\tBENCH_ADD(cp_ghpe_dec(c, m, pub, prv->n, 2));\n\t} BENCH_END;\n\n\tbn_free(c);\n\tbn_free(m);\n\tbn_free(pub);\n\tphpe_free(prv);\n    shpe_free(spub);\n    shpe_free(sprv);\n}\n\n#endif\n\n#if defined(WITH_EC)\n\nstatic void ecdh(void) {\n\tbn_t d;\n\tec_t p;\n\tuint8_t key[RLC_MD_LEN];\n\n\tbn_null(d);\n\tec_null(p);\n\n\tbn_new(d);\n\tec_new(p);\n\n\tBENCH_RUN(\"cp_ecdh_gen\") {\n\t\tBENCH_ADD(cp_ecdh_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdh_key\") {\n\t\tBENCH_ADD(cp_ecdh_key(key, RLC_MD_LEN, d, p));\n\t}\n\tBENCH_END;\n\n\tbn_free(d);\n\tec_free(p);\n}\n\nstatic void ecmqv(void) {\n\tbn_t d1, d2;\n\tec_t p1, p2;\n\tuint8_t key[RLC_MD_LEN];\n\n\tbn_null(d1);\n\tbn_null(d2);\n\tec_null(p1);\n\tec_null(p2);\n\n\tbn_new(d1);\n\tbn_new(d2);\n\tec_new(p1);\n\tec_new(p2);\n\n\tBENCH_RUN(\"cp_ecmqv_gen\") {\n\t\tBENCH_ADD(cp_ecmqv_gen(d1, p1));\n\t}\n\tBENCH_END;\n\n\tcp_ecmqv_gen(d2, p2);\n\n\tBENCH_RUN(\"cp_ecmqv_key\") {\n\t\tBENCH_ADD(cp_ecmqv_key(key, RLC_MD_LEN, d1, d2, p1, p1, p2));\n\t}\n\tBENCH_END;\n\n\tbn_free(d1);\n\tbn_free(d2);\n\tec_free(p1);\n\tec_free(p2);\n}\n\nstatic void ecies(void) {\n\tec_t q, r;\n\tbn_t d;\n\tuint8_t in[10], out[16 + RLC_MD_LEN];\n\tsize_t in_len, out_len;\n\n\tbn_null(d);\n\tec_null(q);\n\tec_null(r);\n\n\tec_new(q);\n\tec_new(r);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_ecies_gen\") {\n\t\tBENCH_ADD(cp_ecies_gen(d, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecies_enc\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = sizeof(out);\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_ecies_enc(r, out, &out_len, in, in_len, q));\n\t\tcp_ecies_dec(out, &out_len, r, out, out_len, d);\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecies_dec\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = sizeof(out);\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_ecies_enc(r, out, &out_len, in, in_len, q);\n\t\tBENCH_ADD(cp_ecies_dec(in, &in_len, r, out, out_len, d));\n\t}\n\tBENCH_END;\n\n\tec_free(q);\n\tec_free(r);\n\tbn_free(d);\n}\n\nstatic void ecdsa(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\tbn_t r, s, d;\n\tec_t p;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(d);\n\tec_null(p);\n\n\tbn_new(r);\n\tbn_new(s);\n\tbn_new(d);\n\tec_new(p);\n\n\tBENCH_RUN(\"cp_ecdsa_gen\") {\n\t\tBENCH_ADD(cp_ecdsa_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_sign (h = 0)\") {\n\t\tBENCH_ADD(cp_ecdsa_sig(r, s, msg, 5, 0, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_sign (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_ecdsa_sig(r, s, h, RLC_MD_LEN, 1, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_ver (h = 0)\") {\n\t\tBENCH_ADD(cp_ecdsa_ver(r, s, msg, 5, 0, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecdsa_ver (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_ecdsa_ver(r, s, h, RLC_MD_LEN, 1, p));\n\t}\n\tBENCH_END;\n\n\tbn_free(r);\n\tbn_free(s);\n\tbn_free(d);\n\tec_free(p);\n}\n\nstatic void ecss(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 };\n\tbn_t r, s, d;\n\tec_t p;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(d);\n\tec_null(p);\n\n\tbn_new(r);\n\tbn_new(s);\n\tbn_new(d);\n\tec_new(p);\n\n\tBENCH_RUN(\"cp_ecss_gen\") {\n\t\tBENCH_ADD(cp_ecss_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecss_sign\") {\n\t\tBENCH_ADD(cp_ecss_sig(r, s, msg, 5, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ecss_ver\") {\n\t\tBENCH_ADD(cp_ecss_ver(r, s, msg, 5, p));\n\t}\n\tBENCH_END;\n\n\tbn_free(r);\n\tbn_free(s);\n\tbn_free(d);\n\tec_free(p);\n}\n\nstatic void vbnn(void) {\n\tuint8_t ida[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\tuint8_t idb[] = { 5, 6, 7, 8, 9, 0, 1, 2, 3, 4 };\n\tbn_t msk, ska, skb;\n\tec_t mpk, pka, pkb;\n\n\tuint8_t m[] = \"Thrice the brinded cat hath mew'd.\";\n\n\tec_t r;\n\tbn_t z;\n\tbn_t h;\n\n\tbn_null(z);\n\tbn_null(h);\n\tbn_null(msk);\n\tbn_null(ska);\n\tbn_null(skb);\n\tec_null(r);\n\tec_null(mpk);\n\tbn_null(pka);\n\tbn_null(pkb);\n\n\tbn_new(z);\n\tbn_new(h);\n\tbn_new(msk);\n\tbn_new(ska);\n\tbn_new(skb);\n\tec_new(r);\n\tec_new(mpk);\n\tec_new(pka);\n\tec_new(pkb);\n\n\tBENCH_RUN(\"cp_vbnn_gen\") {\n\t\tBENCH_ADD(cp_vbnn_gen(msk, mpk));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_vbnn_gen_prv\") {\n\t\tBENCH_ADD(cp_vbnn_gen_prv(ska, pka, msk, ida, sizeof(ida)));\n\t}\n\tBENCH_END;\n\n\tcp_vbnn_gen_prv(skb, pkb, msk, idb, sizeof(idb));\n\n\tBENCH_RUN(\"cp_vbnn_sig\") {\n\t\tBENCH_ADD(cp_vbnn_sig(r, z, h, ida, sizeof(ida), m, sizeof(m), ska, pka));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_vbnn_ver\") {\n\t\tBENCH_ADD(cp_vbnn_ver(r, z, h, ida, sizeof(ida), m, sizeof(m), mpk));\n\t}\n\tBENCH_END;\n\n\tbn_free(z);\n\tbn_free(h);\n\tbn_free(msk);\n\tbn_free(ska);\n\tbn_free(skb);\n\tec_free(r);\n\tec_free(mpk);\n\tec_free(pka);\n\tec_free(pkb);\n}\n\n#define MAX_KEYS\tRLC_MAX(BENCH, 16)\n#define MIN_KEYS\tRLC_MIN(BENCH, 16)\n\nstatic void ers(void) {\n\tsize_t size;\n\tec_t pp, pk[MAX_KEYS + 1];\n\tbn_t sk[MAX_KEYS + 1], td;\n\ters_t ring[MAX_KEYS + 1];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tbn_new(td);\n\tec_new(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_null(sk[i]);\n\t\tbn_new(sk[i]);\n\t\tec_null(pk[i]);\n\t\tec_new(pk[i]);\n\t\ters_null(ring[i]);\n\t\ters_new(ring[i]);\n\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t}\n\n\tcp_ers_gen(pp);\n\n\tBENCH_RUN(\"cp_ers_sig\") {\n\t\tBENCH_ADD(cp_ers_sig(td, ring[0], m, 5, sk[0], pk[0], pp));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_ers_ver\") {\n\t\tBENCH_ADD(cp_ers_ver(td, ring, 1, m, 5, pp));\n\t} BENCH_END;\n\n\tsize = 1;\n\tBENCH_FEW(\"cp_ers_ext\", cp_ers_ext(td, ring, &size, m, 5, pk[size], pp), 1);\n\n\tsize = 1;\n\tcp_ers_sig(td, ring[0], m, 5, sk[0], pk[0], pp);\n\tfor (int j = 1; j < MAX_KEYS && size < BENCH; j = j << 1) {\n\t\tfor (int k = 0; k < j && size < BENCH; k++) {\n\t\t\tcp_ers_ext(td, ring, &size, m, 5, pk[size], pp);\n\t\t}\n\t\tcp_ers_ver(td, ring, size, m, 5, pp);\n\t\tutil_print(\"(%2d exts) \", j);\n\t\tBENCH_FEW(\"cp_ers_ver\", cp_ers_ver(td, ring, size, m, 5, pp), 1);\n\t}\n\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\ters_free(ring[i])\n\t}\n}\n\nstatic void smlers(void) {\n\tsize_t size;\n\tec_t pp, pk[MAX_KEYS + 1];\n\tbn_t sk[MAX_KEYS + 1], td;\n\tsmlers_t ring[MAX_KEYS + 1];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tbn_null(td);\n\tec_null(pp);\n\n\tbn_new(td);\n\tec_new(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_null(sk[i]);\n\t\tbn_new(sk[i]);\n\t\tec_null(pk[i]);\n\t\tec_new(pk[i]);\n\t\tsmlers_null(ring[i]);\n\t\tsmlers_new(ring[i]);\n\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t}\n\n\tcp_ers_gen(pp);\n\n\tBENCH_RUN(\"cp_smlers_sig\") {\n\t\tBENCH_ADD(cp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_smlers_ver\") {\n\t\tBENCH_ADD(cp_smlers_ver(td, ring, 1, m, 5, pp));\n\t} BENCH_END;\n\n\tsize = 1;\n\tBENCH_FEW(\"cp_smlers_ext\", cp_smlers_ext(td, ring, &size, m, 5, pk[size], pp), 1);\n\n\tsize = 1;\n\tcp_smlers_sig(td, ring[0], m, 5, sk[0], pk[0], pp);\n\tfor (int j = 1; j < MAX_KEYS && size < BENCH; j = j << 1) {\n\t\tfor (int k = 0; k < j && size < BENCH; k++) {\n\t\t\tcp_smlers_ext(td, ring, &size, m, 5, pk[size], pp);\n\t\t}\n\t\tcp_smlers_ver(td, ring, size, m, 5, pp);\n\t\tutil_print(\"(%2d exts) \", j);\n\t\tBENCH_FEW(\"cp_smlers_ver\", cp_smlers_ver(td, ring, size, m, 5, pp), 1);\n\t}\n\n\tbn_free(td);\n\tec_free(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tsmlers_free(ring[i])\n\t}\n}\n\nstatic void etrs(void) {\n\tsize_t size;\n\tec_t pp, pk[MAX_KEYS + 1];\n\tbn_t sk[MAX_KEYS + 1], td[MAX_KEYS + 1], y[MAX_KEYS + 1];\n\tetrs_t ring[MAX_KEYS + 1];\n\tconst uint8_t m[5] = { 0, 1, 2, 3, 4 };\n\n\tec_null(pp);\n\tec_new(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_null(td[i]);\n\t\tbn_new(td[i]);\n\t\tbn_null(y[i]);\n\t\tbn_new(y[i]);\n\t\tbn_null(sk[i]);\n\t\tbn_new(sk[i]);\n\t\tec_null(pk[i]);\n\t\tec_new(pk[i]);\n\t\tetrs_null(ring[i]);\n\t\tetrs_new(ring[i]);\n\t\tec_curve_get_ord(sk[i]);\n\t\tbn_rand_mod(td[i], sk[i]);\n\t\tbn_rand_mod(y[i], sk[i]);\n\t\tcp_ers_gen_key(sk[i], pk[i]);\n\t}\n\n\tcp_ers_gen(pp);\n\n\tBENCH_FEW(\"cp_etrs_sig\", cp_etrs_sig(td, y, MIN_KEYS, ring[0], m, 5, sk[0], pk[0], pp), 1);\n\n\tBENCH_FEW(\"cp_etrs_ver\", cp_etrs_ver(1, td, y, MIN_KEYS, ring, 1, m, 5, pp), 1);\n\n\tsize = 1;\n\tBENCH_FEW(\"cp_etrs_ext\", (size = 1, cp_etrs_ext(td, y, MIN_KEYS, ring, &size, m, 5, pk[size], pp)), 1);\n\n\tsize = 1;\n\tcp_etrs_sig(td, y, MIN_KEYS, ring[0], m, 5, sk[0], pk[0], pp);\n\tBENCH_FEW(\"cp_etrs_uni\", cp_etrs_uni(1, td, y, MIN_KEYS, ring, &size, m, 5, sk[size], pk[size], pp), 1);\n\n\tsize = 1;\n\tcp_etrs_sig(td, y, MIN_KEYS, ring[0], m, 5, sk[0], pk[0], pp);\n\tfor (int j = 1; j < MIN_KEYS && size < MIN_KEYS; j = j << 1) {\n\t\tfor (int k = 0; k < j && size < MIN_KEYS; k++) {\n\t\t\tcp_etrs_ext(td, y, MIN_KEYS, ring, &size, m, 5, pk[size], pp);\n\t\t}\n\t\tcp_etrs_ver(1, td+size-1, y+size-1, MIN_KEYS-size+1, ring, size, m, 5, pp);\n\t\tutil_print(\"(%2d exts) \", j);\n\t\tBENCH_FEW(\"cp_etrs_ver\", cp_etrs_ver(1, td+size-1, y+size-1, MIN_KEYS-size+1, ring, size, m, 5, pp), 1);\n\t}\n\n\tec_free(pp);\n\tfor (int i = 0; i <= MAX_KEYS; i++) {\n\t\tbn_free(td[i]);\n\t\tbn_free(y[i]);\n\t\tbn_free(sk[i]);\n\t\tec_free(pk[i]);\n\t\tetrs_free(ring[i])\n\t}\n}\n\n#endif /* WITH_EC */\n\n#if defined(WITH_PC)\n\nstatic void pdpub(void) {\n\tbn_t r1, r2;\n\tg1_t p, u1, v1;\n\tg2_t q, u2, v2, w2;\n\tgt_t e, r, g[3];\n\n\tbn_null(r1);\n\tbn_null(r2);\n\tg1_null(p);\n\tg1_null(u1);\n\tg1_null(v1);\n\tg2_null(q);\n\tg2_null(u2);\n\tg2_null(v2);\n\tg2_null(w2);\n\tgt_null(e);\n\tgt_null(r);\n\tgt_null(g[0]);\n\tgt_null(g[1]);\n\tgt_null(g[2]);\n\n\tbn_new(r1);\n\tbn_new(r2);\n\tg1_new(p);\n\tg1_new(u1);\n\tg1_new(v1);\n\tg2_new(q);\n\tg2_new(u2);\n\tg2_new(v2);\n\tg2_new(w2);\n\tgt_new(e);\n\tgt_new(r);\n\tgt_new(g[0]);\n\tgt_new(g[1]);\n\tgt_new(g[2]);\n\n\tBENCH_RUN(\"cp_pdpub_gen\") {\n\t\tBENCH_ADD(cp_pdpub_gen(r1, r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdpub_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdpub_ask(v1, w2, p, q, r1, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdpub_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdpub_ans(g, p, q, v1, v2, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdpub_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tpc_map(e, p, q);\n\t\tBENCH_ADD(cp_pdpub_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_gen\") {\n\t\tBENCH_ADD(cp_lvpub_gen(r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvpub_ask(r1, v1, w2, p, q, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvpub_ans(g, p, q, v1, v2, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvpub_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tpc_map(e, p, q);\n\t\tBENCH_ADD(cp_lvpub_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tbn_free(r1);\n\tbn_free(r2);\n\tg1_free(p);\n\tg1_free(u1);\n\tg1_free(v1);\n\tg2_free(q);\n\tg2_free(u2);\n\tg2_free(v2);\n\tg2_free(w2);\n\tgt_free(e);\n\tgt_free(r);\n\tgt_free(g[0]);\n\tgt_free(g[1]);\n\tgt_free(g[2]);\n}\n\nstatic void pdprv(void) {\n\tbn_t r1, r2[3];\n\tg1_t p, u1[2], v1[3];\n\tg2_t q, u2[2], v2[4], w2[4];\n\tgt_t e[2], r, g[4];\n\n\tbn_null(r1);\n\tg1_null(p);\n\tg2_null(q);\n\tgt_null(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_null(u1[i]);\n\t\tg2_null(u2[i]);\n\t\tgt_null(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_null(v1[i]);\n\t\tbn_null(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_null(v2[i]);\n\t\tg2_null(w2[i]);\n\t\tgt_null(g[i]);\n\t}\n\n\tbn_new(r1);\n\tg1_new(p);\n\tg2_new(q);\n\tgt_new(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_new(u1[i]);\n\t\tg2_new(u2[i]);\n\t\tgt_new(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_new(v1[i]);\n\t\tbn_new(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_new(v2[i]);\n\t\tg2_new(w2[i]);\n\t\tgt_new(g[i]);\n\t}\n\n\tBENCH_RUN(\"cp_pdprv_gen\") {\n\t\tBENCH_ADD(cp_pdprv_gen(r1, r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdprv_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdprv_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdprv_ans(g, v1, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pdprv_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_pdprv_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_gen\") {\n\t\tBENCH_ADD(cp_lvprv_gen(r1, r2, u1, u2, v2, e));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_ask\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvprv_ask(v1, w2, p, q, r1, r2, u1, u2, v2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_ans\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvprv_ans(g, v1, w2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_lvprv_ver\") {\n\t\tg1_rand(p);\n\t\tg2_rand(q);\n\t\tBENCH_ADD(cp_lvprv_ver(r, g, r1, e));\n\t} BENCH_END;\n\n\tbn_free(r1);\n\tg1_free(p);\n\tg2_free(q);\n\tgt_free(r);\n\tfor (int i = 0; i < 2; i++) {\n\t\tg1_free(u1[i]);\n\t\tg2_free(u2[i]);\n\t\tgt_free(e[i]);\n\t}\n\tfor (int i = 0; i < 3; i++) {\n\t\tg1_free(v1[i]);\n\t\tbn_free(r2[i]);\n\t}\n\tfor (int i = 0; i < 4; i++) {\n\t\tg2_free(v2[i]);\n\t\tg2_free(w2[i]);\n\t\tgt_free(g[i]);\n\t}\n}\n\nstatic void sokaka(void) {\n\tsokaka_t k;\n\tbn_t s;\n\tuint8_t key1[RLC_MD_LEN];\n\tchar *id_a = \"Alice\";\n\tchar *id_b = \"Bob\";\n\n\tsokaka_null(k);\n\n\tsokaka_new(k);\n\tbn_new(s);\n\n\tBENCH_RUN(\"cp_sokaka_gen\") {\n\t\tBENCH_ADD(cp_sokaka_gen(s));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_sokaka_gen_prv\") {\n\t\tBENCH_ADD(cp_sokaka_gen_prv(k, id_b, s));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_sokaka_key (g1)\") {\n\t\tBENCH_ADD(cp_sokaka_key(key1, RLC_MD_LEN, id_b, k, id_a));\n\t}\n\tBENCH_END;\n\n\tif (pc_map_is_type3()) {\n\t\tcp_sokaka_gen_prv(k, id_a, s);\n\n\t\tBENCH_RUN(\"cp_sokaka_key (g2)\") {\n\t\t\tBENCH_ADD(cp_sokaka_key(key1, RLC_MD_LEN, id_a, k, id_b));\n\t\t}\n\t\tBENCH_END;\n\t}\n\n\tsokaka_free(k);\n\tbn_free(s);\n}\n\nstatic void ibe(void) {\n\tbn_t s;\n\tg1_t pub;\n\tg2_t prv;\n\tuint8_t in[10], out[10 + 2 * RLC_FP_BYTES + 1];\n\tchar *id = \"Alice\";\n\tsize_t in_len, out_len;\n\n\tbn_null(s);\n\tg1_null(pub);\n\tg2_null(prv);\n\n\tbn_new(s);\n\tg1_new(pub);\n\tg2_new(prv);\n\n\trand_bytes(in, sizeof(in));\n\n\tBENCH_RUN(\"cp_ibe_gen\") {\n\t\tBENCH_ADD(cp_ibe_gen(s, pub));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ibe_gen_prv\") {\n\t\tBENCH_ADD(cp_ibe_gen_prv(prv, id, s));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ibe_enc\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = in_len + 2 * RLC_FP_BYTES + 1;\n\t\trand_bytes(in, sizeof(in));\n\t\tBENCH_ADD(cp_ibe_enc(out, &out_len, in, in_len, id, pub));\n\t\tcp_ibe_dec(out, &out_len, out, out_len, prv);\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_ibe_dec\") {\n\t\tin_len = sizeof(in);\n\t\tout_len = in_len + 2 * RLC_FP_BYTES + 1;\n\t\trand_bytes(in, sizeof(in));\n\t\tcp_ibe_enc(out, &out_len, in, in_len, id, pub);\n\t\tBENCH_ADD(cp_ibe_dec(out, &out_len, out, out_len, prv));\n\t}\n\tBENCH_END;\n\n\tbn_free(s);\n\tg1_free(pub);\n\tg2_free(prv);\n}\n\nstatic void bgn(void) {\n\tg1_t c[2];\n\tg2_t d[2];\n\tgt_t e[4];\n\tbgn_t pub, prv;\n\tdig_t in;\n\n\tg1_null(c[0]);\n\tg1_null(c[1]);\n\tg2_null(d[0]);\n\tg2_null(d[1]);\n\tbgn_null(pub);\n\tbgn_null(prv);\n\n\tg1_new(c[0]);\n\tg1_new(c[1]);\n\tg2_new(d[0]);\n\tg2_new(d[1]);\n\tbgn_new(pub);\n\tbgn_new(prv);\n\tfor (int i = 0; i < 4; i++) {\n\t\tgt_null(e[i]);\n\t\tgt_new(e[i]);\n\t}\n\n\tBENCH_RUN(\"cp_bgn_gen\") {\n\t\tBENCH_ADD(cp_bgn_gen(pub, prv));\n\t} BENCH_END;\n\n\tin = 10;\n\n\tBENCH_RUN(\"cp_bgn_enc1\") {\n\t\tBENCH_ADD(cp_bgn_enc1(c, in, pub));\n\t\tcp_bgn_dec1(&in, c, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_dec1 (10)\") {\n\t\tcp_bgn_enc1(c, in, pub);\n\t\tBENCH_ADD(cp_bgn_dec1(&in, c, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_enc2\") {\n\t\tBENCH_ADD(cp_bgn_enc2(d, in, pub));\n\t\tcp_bgn_dec2(&in, d, prv);\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_dec2 (10)\") {\n\t\tcp_bgn_enc2(d, in, pub);\n\t\tBENCH_ADD(cp_bgn_dec2(&in, d, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_mul\") {\n\t\tBENCH_ADD(cp_bgn_mul(e, c, d));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_dec (100)\") {\n\t\tBENCH_ADD(cp_bgn_dec(&in, e, prv));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_bgn_add\") {\n\t\tBENCH_ADD(cp_bgn_add(e, e, e));\n\t} BENCH_END;\n\n\tg1_free(c[0]);\n\tg1_free(c[1]);\n\tg2_free(d[0]);\n\tg2_free(d[1]);\n\tbgn_free(pub);\n\tbgn_free(prv);\n\tfor (int i = 0; i < 4; i++) {\n\t\tgt_free(e[i]);\n\t}\n}\n\nstatic void bls(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 };\n\tg1_t s;\n\tg2_t p;\n\tbn_t d;\n\n\tg1_null(s);\n\tg2_null(p);\n\tbn_null(d);\n\n\tg1_new(s);\n\tg2_new(p);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_bls_gen\") {\n\t\tBENCH_ADD(cp_bls_gen(d, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bls_sign\") {\n\t\tBENCH_ADD(cp_bls_sig(s, msg, 5, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bls_ver\") {\n\t\tBENCH_ADD(cp_bls_ver(s, msg, 5, p));\n\t}\n\tBENCH_END;\n\n\tg1_free(s);\n\tbn_free(d);\n\tg2_free(p);\n}\n\nstatic void bbs(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\tg1_t s;\n\tg2_t p;\n\tgt_t z;\n\tbn_t d;\n\n\tg1_null(s);\n\tg2_null(p);\n\tgt_null(z);\n\tbn_null(d);\n\n\tg1_new(s);\n\tg2_new(p);\n\tgt_new(z);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_bbs_gen\") {\n\t\tBENCH_ADD(cp_bbs_gen(d, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_sign (h = 0)\") {\n\t\tBENCH_ADD(cp_bbs_sig(s, msg, 5, 0, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_sign (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_bbs_sig(s, h, RLC_MD_LEN, 1, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_ver (h = 0)\") {\n\t\tBENCH_ADD(cp_bbs_ver(s, msg, 5, 0, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_bbs_ver (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_bbs_ver(s, h, RLC_MD_LEN, 1, p, z));\n\t}\n\tBENCH_END;\n\n\tg1_free(s);\n\tbn_free(d);\n\tg2_free(p);\n}\n\nstatic int cls(void) {\n\tint i, code = RLC_ERR;\n\tbn_t r, t, u, v, _v[4];\n\tg1_t a, A, b, B, c, _A[4], _B[4];\n\tg2_t x, y, z, _z[4];\n\tuint8_t m[5] = { 0, 1, 2, 3, 4 };\n\tconst uint8_t *ms[5] = {m, m, m, m, m};\n\tconst size_t ls[5] = {sizeof(m), sizeof(m), sizeof(m), sizeof(m), sizeof(m)};\n\n\tbn_null(r);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(A);\n\tg1_null(b);\n\tg1_null(B);\n\tg1_null(c);\n\tg2_null(x);\n\tg2_null(y);\n\tg2_null(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_null(_v[i]);\n\t\tg1_null(_A[i]);\n\t\tg1_null(_B[i]);\n\t\tg2_null(_z[i]);\n\t}\n\n\tbn_new(r);\n\tbn_new(t);\n\tbn_new(u);\n\tbn_new(v);\n\tg1_new(a);\n\tg1_new(A);\n\tg1_new(b);\n\tg1_new(B);\n\tg1_new(c);\n\tg2_new(x);\n\tg2_new(y);\n\tg2_new(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_new(_v[i]);\n\t\tg1_new(_A[i]);\n\t\tg1_new(_B[i]);\n\t\tg2_new(_z[i]);\n\t}\n\n\tBENCH_RUN(\"cp_cls_gen\") {\n\t\tBENCH_ADD(cp_cls_gen(u, v, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cls_sig\") {\n\t\tBENCH_ADD(cp_cls_sig(a, b, c, m, sizeof(m), u, v));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cls_ver\") {\n\t\tBENCH_ADD(cp_cls_ver(a, b, c, m, sizeof(m), x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cli_gen\") {\n\t\tBENCH_ADD(cp_cli_gen(t, u, v, x, y, z));\n\t} BENCH_END;\n\n\tbn_rand(r, RLC_POS, 2 * pc_param_level());\n\tBENCH_RUN(\"cp_cli_sig\") {\n\t\tBENCH_ADD(cp_cli_sig(a, A, b, B, c, m, sizeof(m), r, t, u, v));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_cli_ver\") {\n\t\tBENCH_ADD(cp_cli_ver(a, A, b, B, c, m, sizeof(m), r, x, y, z));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_clb_gen (5)\") {\n\t\tBENCH_ADD(cp_clb_gen(t, u, _v, x, y, _z, 5));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_clb_sig (5)\") {\n\t\tBENCH_ADD(cp_clb_sig(a, _A, b, _B, c, ms, ls, t, u, _v, 5));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_clb_ver (5)\") {\n\t\tBENCH_ADD(cp_clb_ver(a, _A, b, _B, c, ms, ls, x, y, _z, 5));\n\t} BENCH_END;\n\n\tbn_free(r);\n\tbn_free(t);\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(A);\n\tg1_free(b);\n\tg1_free(B);\n\tg1_free(c);\n\tg2_free(x);\n\tg2_free(y);\n\tg2_free(z);\n\tfor (i = 0; i < 4; i++) {\n\t\tbn_free(_v[i]);\n\t\tg1_free(_A[i]);\n\t\tg1_free(_B[i]);\n\t\tg2_free(_z[i]);\n\t}\n\treturn code;\n}\n\nstatic void pss(void) {\n\tbn_t ms[10], n, u, v, _v[10];\n\tg1_t a, b;\n\tg2_t g, x, y, _y[10];\n\n\tbn_null(n);\n\tbn_null(u);\n\tbn_null(v);\n\tg1_null(a);\n\tg1_null(b);\n\tg2_null(g);\n\tg2_null(x);\n\tg2_null(y);\n\tbn_new(n);\n\tbn_new(u);\n\tbn_new(v);\n\tg1_new(a);\n\tg1_new(b);\n\tg2_new(g);\n\tg2_new(x);\n\tg2_new(y);\n\n\tg1_get_ord(n);\n\tfor (int i = 0; i < 10; i++) {\n\t\tbn_null(ms[i]);\n\t\tbn_null(_v[i]);\n\t\tg2_null(_y[i]);\n\t\tbn_new(ms[i]);\n\t\tbn_rand_mod(ms[i], n);\n\t\tbn_new(_v[i]);\n\t\tg2_new(_y[i]);\n\t}\n\n\tBENCH_RUN(\"cp_pss_gen\") {\n\t\tBENCH_ADD(cp_pss_gen(u, v, g, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pss_sig\") {\n\t\tBENCH_ADD(cp_pss_sig(a, b, ms[0], u, v));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pss_ver\") {\n\t\tBENCH_ADD(cp_pss_ver(a, b, ms[0], g, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_psb_gen (10)\") {\n\t\tBENCH_ADD(cp_psb_gen(u, _v, g, x, _y, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_psb_sig (10)\") {\n\t\tBENCH_ADD(cp_psb_sig(a, b, ms, u, _v, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_psb_ver (10)\") {\n\t\tBENCH_ADD(cp_psb_ver(a, b, ms, g, x, _y, 10));\n\t} BENCH_END;\n\n\tbn_free(u);\n\tbn_free(v);\n\tg1_free(a);\n\tg1_free(b);\n\tg2_free(g);\n\tg2_free(x);\n\tg2_free(y);\n\tfor (int i = 0; i < 10; i++) {\n\t\tbn_free(ms[i]);\n\t\tbn_free(_v[i]);\n\t\tg1_free(_y[i]);\n\t}\n}\n\n#ifdef WITH_MPC\n\nstatic void mpss(void) {\n\tbn_t m[2], n, u[2], v[2], ms[10][2], _v[10][2];\n\tg1_t g, s[2];\n\tg2_t h, x[2], y[2], _y[10][2];\n\tgt_t r[2];\n\tmt_t tri[3][2];\n\tpt_t t[2];\n\n\tbn_null(n);\n\tg1_null(g);\n\tg2_null(h);\n\n\tbn_new(n);\n\tg1_new(g);\n\tg2_new(h);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_null(m[i]);\n\t\tbn_null(u[i]);\n\t\tbn_null(v[i]);\n\t\tg1_null(s[i]);\n\t\tg2_null(x[i]);\n\t\tg2_null(y[i]);\n\t\tgt_null(r[i]);\n\t\tmt_null(tri[0][i]);\n\t\tmt_null(tri[1][i]);\n\t\tmt_null(tri[2][i]);\n\t\tpt_null(t[i]);\n\t\tbn_new(m[i]);\n\t\tbn_new(u[i]);\n\t\tbn_new(v[i]);\n\t\tg1_new(s[i]);\n\t\tg2_new(x[i]);\n\t\tg2_new(y[i]);\n\t\tgt_new(r[i]);\n\t\tmt_new(tri[0][i]);\n\t\tmt_new(tri[1][i]);\n\t\tmt_new(tri[2][i]);\n\t\tpt_new(t[i]);\n\n\t\tg1_get_ord(n);\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tbn_null(ms[j][i]);\n\t\t\tbn_null(_v[j][i]);\n\t\t\tg2_null(_y[j][i]);\n\t\t\tbn_new(ms[j][i]);\n\t\t\tbn_rand_mod(ms[j][i], n);\n\t\t\tbn_new(_v[j][i]);\n\t\t\tg2_new(_y[j][i]);\n\t\t}\n\t}\n\n\tpc_map_tri(t);\n\tmpc_mt_gen(tri[0], n);\n\tmpc_mt_gen(tri[1], n);\n\tmpc_mt_gen(tri[2], n);\n\n\tbn_rand_mod(m[0], n);\n\tbn_rand_mod(m[1], n);\n\tbn_sub(m[0], m[1], m[0]);\n\tif (bn_sign(m[0]) == RLC_NEG) {\n\t\tbn_add(m[0], m[0], n);\n\t}\n\tgt_exp_gen(r[0], tri[2][0]->c);\n\tgt_exp_gen(r[1], tri[2][1]->c);\n\ttri[2][0]->bt = &r[0];\n\ttri[2][1]->bt = &r[1];\n\ttri[2][0]->ct = &r[0];\n\ttri[2][1]->ct = &r[1];\n\n\tBENCH_RUN(\"cp_mpss_gen\") {\n\t\tBENCH_ADD(cp_mpss_gen(u, v, h, x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpss_bct\") {\n\t\tBENCH_ADD(cp_mpss_bct(x, y));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpss_sig\") {\n\t\tBENCH_ADD(cp_mpss_sig(g, s, m, u, v, tri[0], tri[1]));\n\t} BENCH_DIV(2);\n\n\tBENCH_RUN(\"cp_mpss_ver\") {\n\t\tBENCH_ADD(cp_mpss_ver(r[0], g, s, m, h, x[0], y[0], tri[2], t));\n\t} BENCH_DIV(2);\n\n\tg1_get_ord(n);\n\tpc_map_tri(t);\n\tmpc_mt_gen(tri[0], n);\n\tmpc_mt_gen(tri[1], n);\n\tmpc_mt_gen(tri[2], n);\n\n\tBENCH_RUN(\"cp_mpsb_gen (10)\") {\n\t\tBENCH_ADD(cp_mpsb_gen(u, _v, h, x, _y, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpsb_bct (10)\") {\n\t\tBENCH_ADD(cp_mpsb_bct(x, _y, 10));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_mpsb_sig (10)\") {\n\t\tBENCH_ADD(cp_mpsb_sig(g, s, ms, u, _v, tri[0], tri[1], 10));\n\t} BENCH_DIV(2);\n\n\tBENCH_RUN(\"cp_mpsb_ver (10)\") {\n\t\tBENCH_ADD(cp_mpsb_ver(r[1], g, s, ms, h, x[0], _y, NULL, tri[2], t, 10));\n\t} BENCH_DIV(2);\n\n\tBENCH_RUN(\"cp_mpsb_ver (10,sk)\") {\n\t\tBENCH_ADD(cp_mpsb_ver(r[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 10));\n\t} BENCH_DIV(2);\n\n\tbn_free(n);\n\tg1_free(g);\n\tg2_free(h);\n\tfor (int i = 0; i < 2; i++) {\n\t\tbn_free(m[i]);\n\t\tbn_free(u[i]);\n\t\tbn_free(v[i]);\n\t\tg1_free(s[i]);\n\t\tg2_free(x[i]);\n\t\tg2_free(y[i]);\n\t\tgt_null(r[i]);\n\t\tmt_free(tri[0][i]);\n\t\tmt_free(tri[1][i]);\n\t\tmt_free(tri[2][i]);\n\t\tpt_free(t[i]);\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tbn_free(ms[j][i]);\n\t\t\tbn_free(_v[j][i]);\n\t\t\tg2_free(_y[j][i]);\n\t\t}\n\t}\n}\n\n#endif\n\nstatic void zss(void) {\n\tuint8_t msg[5] = { 0, 1, 2, 3, 4 }, h[RLC_MD_LEN];\n\tg1_t p;\n\tg2_t s;\n\tgt_t z;\n\tbn_t d;\n\n\tbn_null(d);\n\tg1_null(p);\n\tg2_null(s);\n\tgt_null(z);\n\n\tg1_new(p);\n\tg2_new(s);\n\tgt_new(z);\n\tbn_new(d);\n\n\tBENCH_RUN(\"cp_zss_gen\") {\n\t\tBENCH_ADD(cp_zss_gen(d, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_sig (h = 0)\") {\n\t\tBENCH_ADD(cp_zss_sig(s, msg, 5, 0, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_sig (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_zss_sig(s, h, RLC_MD_LEN, 1, d));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_ver (h = 0)\") {\n\t\tBENCH_ADD(cp_zss_ver(s, msg, 5, 0, p, z));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"cp_zss_ver (h = 1)\") {\n\t\tmd_map(h, msg, 5);\n\t\tBENCH_ADD(cp_zss_ver(s, h, RLC_MD_LEN, 1, p, z));\n\t}\n\tBENCH_END;\n\n\tbn_free(d);\n\tg1_free(p);\n\tg2_free(s);\n}\n\n/* Size of the dataset for benchmarking. */\n#define S\t10\t\t\t/* Number of signers. */\n#define L\t16\t\t\t/* Number of labels, must be <= RLC_TERMS. */\n#define K\tRLC_MD_LEN\t/* Size of PRF key. */\n//#define BENCH_LHS\t\t/* Uncomment for fine-grained benchmarking. */\n\nstatic void lhs(void) {\n\tuint8_t k[S][K];\n\tbn_t m, n, msg[L], sk[S], d[S], x[S][L];\n\tg1_t _r, h, as[S], cs[S], sig[S];\n\tg1_t a[S][L], c[S][L], r[S][L];\n\tg2_t _s, s[S][L], pk[S], y[S], z[S];\n\tgt_t *hs[S], vk;\n\tconst char *data = \"id\";\n\tconst char *id[S] = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"};\n\tdig_t ft[S], *f[S];\n\tsize_t flen[S];\n\tint label[L];\n\n\tbn_null(m);\n\tbn_null(n);\n\tg1_null(h);\n\tg1_null(_r);\n\tg2_null(_s);\n\tgt_null(vk);\n\n\tbn_new(m);\n\tbn_new(n);\n\tg1_new(h);\n\tg1_new(_r);\n\tg2_new(_s);\n\tgt_new(vk);\n\n\tpc_get_ord(n);\n\tfor (int i = 0; i < L; i++) {\n\t\tbn_null(msg[i]);\n\t\tbn_new(msg[i]);\n\t\tbn_rand_mod(msg[i], n);\n\t}\n\tfor (int i = 0; i < S; i++) {\n\t\ths[i] = RLC_ALLOCA(gt_t, RLC_TERMS);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\tgt_null(hs[i][j]);\n\t\t\tgt_new(hs[i][j]);\n\t\t}\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tbn_null(x[i][j]);\n\t\t\tg1_null(a[i][j]);\n\t\t\tg1_null(c[i][j]);\n\t\t\tg1_null(r[i][j]);\n\t\t\tg2_null(s[i][j]);\n\t\t\tbn_new(x[i][j]);\n\t\t\tg1_new(a[i][j]);\n\t\t\tg1_new(c[i][j]);\n\t\t\tg1_new(r[i][j]);\n\t\t\tg2_new(s[i][j]);\n\t\t}\n\t\tbn_null(sk[i]);\n\t\tbn_null(d[i]);\n\t\tg1_null(sig[i]);\n\t\tg1_null(as[i]);\n\t\tg1_null(cs[i]);\n\t\tg2_null(y[i]);\n\t\tg2_null(z[i]);\n\t\tg2_null(pk[i]);\n\n\t\tbn_new(sk[i]);\n\t\tbn_new(d[i]);\n\t\tg1_new(sig[i]);\n\t\tg1_new(as[i]);\n\t\tg1_new(cs[i]);\n\t\tg2_new(y[i]);\n\t\tg2_new(z[i]);\n\t\tg2_new(pk[i]);\n\t}\n\n\t/* Define linear function. */\n\tfor (int i = 0; i < S; i++) {\n\t\tf[i] = RLC_ALLOCA(dig_t, RLC_TERMS);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\tuint32_t t;\n\t\t\trand_bytes((uint8_t *)&t, sizeof(uint32_t));\n\t\t\tf[i][j] = t;\n\t\t}\n\t\tflen[i] = L;\n\t}\n\n\t/* Initialize scheme for messages of single components. */\n\tcp_cmlhs_init(h);\n\n\tBENCH_ONE(\"cp_cmlhs_gen (ecdsa)\",\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tcp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], 0);\n\t\t},\n\tS);\n\n\tBENCH_FEW(\"cp_cmlhs_sig (ecdsa)\",\n\t\t/* Compute all signatures. */\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\tlabel[l] = l;\n\t\t\t\tbn_mod(msg[l], msg[l], n);\n\t\t\t\tcp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l], s[j][l],\n\t\t\t\t\tmsg[l], data, label[l], x[j][l], h, k[j], K, d[j], sk[j], 0);\n\t\t\t}\n\t\t},\n\tS * L);\n\n\tBENCH_RUN(\"cp_cmlhs_fun\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], L));\n\t\t}\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_evl\") {\n\t\tcp_cmlhs_evl(_r, _s, r[0], s[0], f[0], L);\n\t\tfor (int j = 1; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], L));\n\t\t\tg1_add(_r, _r, r[0][0]);\n\t\t\tg2_add(_s, _s, s[0][0]);\n\t\t}\n\t\tg1_norm(_r, _r);\n\t\tg2_norm(_s, _s);\n\t} BENCH_DIV(S);\n\n\tbn_zero(m);\n\tfor (int j = 0; j < L; j++) {\n\t\tdig_t sum = 0;\n\t\tfor (int l = 0; l < S; l++) {\n\t\t\tsum += f[l][j];\n\t\t}\n\t\tbn_mul_dig(msg[j], msg[j], sum);\n\t\tbn_add(m, m, msg[j]);\n\t\tbn_mod(m, m, n);\n\t}\n\n\tBENCH_RUN(\"cp_cmlhs_ver (ecdsa)\") {\n\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, 0));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, (const gt_t **)hs,\n\t\t\t(const dig_t **)f, flen, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_onv (ecdsa)\") {\n\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\tpk, S, 0));\n\t} BENCH_DIV(S);\n\n\tBENCH_ONE(\"cp_cmlhs_gen (bls)\",\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tcp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], 1);\n\t\t},\n\tS);\n\n\tBENCH_FEW(\"cp_cmlhs_sig (bls)\",\n\t\t/* Compute all signatures. */\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\tlabel[l] = l;\n\t\t\t\tbn_mod(msg[l], msg[l], n);\n\t\t\t\tcp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l], s[j][l],\n\t\t\t\t\tmsg[l], data, label[l], x[j][l], h, k[j], K, d[j], sk[j], 1);\n\t\t\t}\n\t\t},\n\tS * L);\n\n\tBENCH_RUN(\"cp_cmlhs_fun\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], L));\n\t\t}\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_evl\") {\n\t\tcp_cmlhs_evl(_r, _s, r[0], s[0], f[0], L);\n\t\tfor (int j = 1; j < S; j++) {\n\t\t\tBENCH_ADD(cp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], L));\n\t\t\tg1_add(_r, _r, r[0][0]);\n\t\t\tg2_add(_s, _s, s[0][0]);\n\t\t}\n\t\tg1_norm(_r, _r);\n\t\tg2_norm(_s, _s);\n\t} BENCH_DIV(S);\n\n\tbn_zero(m);\n\tfor (int j = 0; j < L; j++) {\n\t\tdig_t sum = 0;\n\t\tfor (int l = 0; l < S; l++) {\n\t\t\tsum += f[l][j];\n\t\t}\n\t\tbn_mul_dig(msg[j], msg[j], sum);\n\t\tbn_add(m, m, msg[j]);\n\t\tbn_mod(m, m, n);\n\t}\n\n\tBENCH_RUN(\"cp_cmlhs_ver (bls)\") {\n\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, 1));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, (const gt_t **)hs,\n\t\t\t(const dig_t **)f, flen, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_cmlhs_onv (bls)\") {\n\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\tpk, S, 1));\n\t} BENCH_DIV(S);\n\n#ifdef BENCH_LHS\n\tfor (int t = 1; t <= S; t++) {\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_ver\") {\n\t\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t\ths, f, flen, y, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, hs, f, flen, y, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_onv\") {\n\t\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\t\tpk, t));\n\t\t} BENCH_END;\n\t}\n\n\tfor (int t = 1; t <= L; t++) {\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tfor (int u = 0; u < S; u++) {\n\t\t\tflen[u] = t;\n\t\t}\n\t\tBENCH_RUN(\"cp_cmlhs_ver\") {\n\t\t\tBENCH_ADD(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,\n\t\t\t\ths,\tf, flen, y, pk, S));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_off\") {\n\t\t\tBENCH_ADD(cp_cmlhs_off(vk, h, label, hs, f, flen, y, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_cmlhs_onv\") {\n\t\t\tBENCH_ADD(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk, y,\n\t\t\t\tpk, t));\n\t\t} BENCH_END;\n\t}\n#endif  /* BENCH_LHS */\n\n\tchar *ls[L];\n\n\tBENCH_RUN(\"cp_mklhs_gen\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_mklhs_gen(sk[j], pk[j]));\n\t\t}\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_sig\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tfor (int l = 0; l < L; l++) {\n\t\t\t\tls[l] = \"l\";\n\t\t\t\tbn_mod(msg[l], msg[l], n);\n\t\t\t\tBENCH_ADD(cp_mklhs_sig(a[j][l], msg[l], data,\n\t\t\t\t\tid[j], ls[l], sk[j]));\n\t\t\t}\n\t\t}\n\t} BENCH_DIV(S * L);\n\n\tBENCH_RUN(\"cp_mklhs_fun\") {\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tbn_zero(d[j]);\n\t\t\tBENCH_ADD(cp_mklhs_fun(d[j], msg, f[j], L));\n\t\t}\n\t}\n\tBENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_evl\") {\n\t\tg1_set_infty(_r);\n\t\tfor (int j = 0; j < S; j++) {\n\t\t\tBENCH_ADD(cp_mklhs_evl(r[0][j], a[j], f[j], L));\n\t\t\tg1_add(_r, _r, r[0][j]);\n\t\t}\n\t\tg1_norm(_r, _r);\n\t}\n\tBENCH_DIV(S);\n\n\tbn_zero(m);\n\tfor (int j = 0; j < L; j++) {\n\t\tdig_t sum = 0;\n\t\tfor (int l = 0; l < S; l++) {\n\t\t\tsum += f[l][j];\n\t\t}\n\t\tbn_mul_dig(msg[j], msg[j], sum);\n\t\tbn_add(m, m, msg[j]);\n\t\tbn_mod(m, m, n);\n\t}\n\n\tBENCH_RUN(\"cp_mklhs_ver\") {\n\t\tBENCH_ADD(cp_mklhs_ver(_r, m, d, data, id, (const char **)ls,\n\t\t\t(const dig_t **)f, flen, pk, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_off\") {\n\t\tBENCH_ADD(cp_mklhs_off(cs, ft, id, (const char **)ls, (const dig_t **)f,\n\t\t\tflen, S));\n\t} BENCH_DIV(S);\n\n\tBENCH_RUN(\"cp_mklhs_onv\") {\n\t\tBENCH_ADD(cp_mklhs_onv(_r, m, d, data, id, cs, ft, pk, S));\n\t} BENCH_DIV(S);\n\n#ifdef BENCH_LHS\n\tfor (int t = 1; t <= S; t++) {\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_ver\") {\n\t\t\tBENCH_ADD(cp_mklhs_ver(_r, m, d, data, id, ls, f, flen, pk, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_off\") {\n\t\t\tBENCH_ADD(cp_mklhs_off(cs, ft, id, ls, f, flen, t));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d ids) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_onv\") {\n\t\t\tBENCH_ADD(cp_mklhs_onv(_r, m, d, data, id, cs, ft, pk, t));\n\t\t} BENCH_END;\n\t}\n\n\tfor (int t = 1; t <= L; t++) {\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tfor (int u = 0; u < S; u++) {\n\t\t\tflen[u] = t;\n\t\t}\n\t\tBENCH_RUN(\"cp_mklhs_ver\") {\n\t\t\tBENCH_ADD(cp_mklhs_ver(_r, m, d, data, id, ls, f, flen, pk, S));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_off\") {\n\t\t\tBENCH_ADD(cp_mklhs_off(cs, ft, id, ls, f, flen, S));\n\t\t} BENCH_END;\n\n\t\tutil_print(\"(%2d lbs) \", t);\n\t\tBENCH_RUN(\"cp_mklhs_onv\") {\n\t\t\tBENCH_ADD(cp_mklhs_onv(_r, m, d, data, id, cs, ft, pk, S));\n\t\t} BENCH_END;\n\t}\n#endif /* BENCH_LHS */\n\n\tbn_free(n);\n\tbn_free(m);\n\tg1_free(h);\n\tg1_free(_r);\n\tg2_free(_s);\n\tgt_free(vk);\n\n\tfor (int i = 0; i < L; i++) {\n\t\tbn_free(msg[i]);\n\t}\n\tfor (int i = 0; i < S; i++) {\n\t\tRLC_FREE(f[i]);\n\t\tfor (int j = 0; j < RLC_TERMS; j++) {\n\t\t\tgt_free(hs[i][j]);\n\t\t}\n\t\tRLC_FREE(hs[i]);\n\t\tfor (int j = 0; j < L; j++) {\n\t\t\tbn_free(x[i][j]);\n\t\t\tg1_free(a[i][j]);\n\t\t\tg1_free(c[i][j]);\n\t\t\tg1_free(r[i][j]);\n\t\t\tg2_free(s[i][j]);\n\t\t}\n\t\tbn_free(sk[i]);\n\t\tbn_free(d[i]);\n\t\tg1_free(sig[i]);\n\t\tg1_free(as[i]);\n\t\tg1_free(cs[i]);\n\t\tg2_free(y[i]);\n\t\tg2_free(z[i]);\n\t\tg2_free(pk[i]);\n\t}\n}\n\n#define M\t256\t\t\t/* Number of server messages (larger). */\n#define N\t8\t\t\t/* Number of client messages. */\n\nstatic void psi(void) {\n\tbn_t g, n, q, r, p[M], x[M], v[N], w[N], y[N], z[M];\n\tg1_t u[M], ss;\n\tg2_t d[M + 1], s[M + 1];\n\tgt_t t[M];\n\tcrt_t crt;\n\tsize_t len;\n\n\tbn_new(g);\n\tbn_new(n);\n\tbn_new(q);\n\tbn_new(r);\n\tg1_new(ss);\n\tfor (int i = 0; i < M; i++) {\n\t\tbn_null(p[i]);\n\t\tbn_null(x[i]);\n\t\tbn_null(z[i]);\n\t\tg2_null(d[i]);\n\t\tg2_null(s[i]);\n\t\tbn_new(p[i]);\n\t\tbn_new(x[i]);\n\t\tbn_new(z[i]);\n\t\tg2_new(d[i]);\n\t\tg2_new(s[i]);\n\t}\n\tg2_null(d[M]);\n\tg2_new(d[M]);\n\tg2_null(s[M]);\n\tg2_new(s[M]);\n\tfor (int i = 0; i < N; i++) {\n\t\tbn_null(v[i]);\n\t\tbn_null(w[i]);\n\t\tbn_null(y[i]);\n\t\tg1_null(u[i]);\n\t\tgt_null(t[i]);\n\t\tbn_new(v[i]);\n\t\tbn_new(w[i]);\n\t\tbn_new(y[i]);\n\t\tg1_new(u[i]);\n\t\tgt_new(t[i]);\n\t}\n\tcrt_new(crt);\n\n\tpc_get_ord(q);\n\tfor (int j = 0; j < M; j++) {\n\t\tbn_rand_mod(x[j], q);\n\t}\n\tfor (int j = 0; j < N; j++) {\n\t\tbn_rand_mod(y[j], q);\n\t}\n\n\tBENCH_ONE(\"cp_rsapsi_gen\", cp_rsapsi_gen(g, n, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_rsapsi_ask (M)\") {\n\t\tBENCH_ADD(cp_rsapsi_ask(q, r, p, g, n, x, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsapsi_ans (N)\") {\n\t\tBENCH_ADD(cp_rsapsi_ans(v, w, q, g, n, y, N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_rsapsi_int\") {\n\t\tBENCH_ADD(cp_rsapsi_int(z, &len, r, p, n, x, M, v, w, N));\n\t} BENCH_END;\n\n\tBENCH_ONE(\"cp_shipsi_gen\", cp_shipsi_gen(g, crt, RLC_BN_BITS), 1);\n\n\tBENCH_RUN(\"cp_shipsi_ask (M)\") {\n\t\tBENCH_ADD(cp_shipsi_ask(q, r, p, g, crt->n, x, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shipsi_ans (N)\") {\n\t\tBENCH_ADD(cp_shipsi_ans(v, w[0], q, g, crt, y, N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_shipsi_int\") {\n\t\tBENCH_ADD(cp_shipsi_int(z, &len, r, p, crt->n, x, M, v, w[0], N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_gen (M)\") {\n\t\tBENCH_ADD(cp_pbpsi_gen(q, ss, s, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_ask (M)\") {\n\t\tBENCH_ADD(cp_pbpsi_ask(d, r, x, s, M));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_ans (N)\") {\n\t\tBENCH_ADD(cp_pbpsi_ans(t, u, ss, d[0], y, N));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"cp_pbpsi_int\") {\n\t\tBENCH_ADD(cp_pbpsi_int(z, &len, d, x, M, t, u, N));\n\t} BENCH_END;\n\n    bn_free(q);\n\tbn_free(r);\n\tg1_free(ss);\n\tfor (int i = 0; i < M; i++) {\n\t\tbn_free(x[i]);\n\t\tbn_free(z[i]);\n\t\tg2_free(d[i]);\n\t\tg2_free(s[i]);\n\t}\n\tg2_free(d[M]);\n\tg2_free(s[M]);\n\tfor (int i = 0; i < N; i++) {\n\t\tbn_free(y[i]);\n\t\tg1_free(u[i]);\n\t\tgt_free(t[i]);\n\t}\n}\n\n#endif /* WITH_PC */\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tconf_print();\n\n\tutil_banner(\"Benchmarks for the CP module:\", 0);\n\n#if defined(WITH_BN)\n\tutil_banner(\"Protocols based on integer factorization:\\n\", 0);\n\trsa();\n\trabin();\n\tpaillier();\n\tbenaloh();\n#endif\n\n#if defined(WITH_EC)\n\tif (ec_param_set_any() == RLC_OK) {\n\t\tutil_banner(\"Protocols based on elliptic curves:\\n\", 0);\n\t\tecdh();\n\t\tecmqv();\n\t\tecies();\n\t\tecdsa();\n\t\tecss();\n\t\tvbnn();\n\t\ters();\n\t\tsmlers();\n\t\tetrs();\n\t}\n#endif\n\n#if defined(WITH_PC)\n\tif (pc_param_set_any() == RLC_OK) {\n\t\tutil_banner(\"Protocols based on pairings:\\n\", 0);\n\t\tpdpub();\n\t\tpdprv();\n\t\tsokaka();\n\t\tibe();\n\t\tbgn();\n\t\tbls();\n\t\tbbs();\n\t\tcls();\n\t\tpss();\n#if defined(WITH_MPC)\n\t\tmpss();\n#endif\n\t\tzss();\n\t\tlhs();\n\n\t\tutil_banner(\"Protocols based on accumulators:\\n\", 0);\n\t\tpsi();\n\t}\n#endif\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Benchmarks for elliptic curves defined over extensions of prime fields.\n *\n * @ingroup bench\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_bench.h\"\n\nstatic void memory2(void) {\n\tep2_t a[BENCH];\n\n\tBENCH_FEW(\"ep2_null\", ep2_null(a[i]), 1);\n\n\tBENCH_FEW(\"ep2_new\", ep2_new(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep2_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep2_new(a[i]);\n\t}\n\tBENCH_FEW(\"ep2_free\", ep2_free(a[i]), 1);\n\n\t(void)a;\n}\n\nstatic void util2(void) {\n\tep2_t p, q, t[2];\n\tuint8_t bin[4 * RLC_FP_BYTES + 1];\n\tint l;\n\n\tep2_null(p);\n\tep2_null(q);\n\tep2_null(t[0]);\n\tep2_null(t[1]);\n\n\tep2_new(p);\n\tep2_new(q);\n\tep2_new(t[0]);\n\tep2_new(t[1]);\n\n\tBENCH_RUN(\"ep2_is_infty\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_is_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_set_infty\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_set_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_copy\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_copy(p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_cmp\") {\n\t\tep2_rand(p);\n\t\tep2_dbl(p, p);\n\t\tep2_rand(q);\n\t\tep2_dbl(q, q);\n\t\tBENCH_ADD(ep2_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_norm\") {\n\t\tep2_rand(p);\n\t\tep2_dbl(p, p);\n\t\tBENCH_ADD(ep2_norm(p, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_norm_sim (2)\") {\n\t\tep2_rand(t[0]);\n\t\tep2_rand(t[1]);\n\t\tep2_dbl(t[0], t[0]);\n\t\tep2_dbl(t[1], t[1]);\n\t\tBENCH_ADD(ep2_norm_sim(t, t, 2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_cmp (1 norm)\") {\n\t\tep2_rand(p);\n\t\tep2_dbl(p, p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_cmp (2 norm)\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_rand\") {\n\t\tBENCH_ADD(ep2_rand(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_blind\") {\n\t\tBENCH_ADD(ep2_blind(p, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_on_curve\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_on_curve(p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_size_bin (0)\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_size_bin(p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_size_bin (1)\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_size_bin(p, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_write_bin (0)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 0);\n\t\tBENCH_ADD(ep2_write_bin(bin, l, p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_write_bin (1)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 1);\n\t\tBENCH_ADD(ep2_write_bin(bin, l, p, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_read_bin (0)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 0);\n\t\tep2_write_bin(bin, l, p, 0);\n\t\tBENCH_ADD(ep2_read_bin(p, bin, l));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_read_bin (1)\") {\n\t\tep2_rand(p);\n\t\tl = ep2_size_bin(p, 1);\n\t\tep2_write_bin(bin, l, p, 1);\n\t\tBENCH_ADD(ep2_read_bin(p, bin, l));\n\t} BENCH_END;\n\n\tep2_free(p);\n\tep2_free(q);\n\tep2_free(t[0]);\n\tep2_free(t[1]);\n}\n\nstatic void arith2(void) {\n\tep2_t p, q, r, t[RLC_EPX_TABLE_MAX];\n\tbn_t k, n, l[2];\n\tfp2_t s;\n\n\tep2_null(p);\n\tep2_null(q);\n\tep2_null(r);\n\tbn_null(k);\n\tbn_null(n);\n\tfp2_null(s);\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep2_null(t[i]);\n\t}\n\n\tep2_new(p);\n\tep2_new(q);\n\tep2_new(r);\n\tbn_new(k);\n\tbn_new(n);\n\tbn_new(l[0]);\n\tbn_new(l[1]);\n\tfp2_new(s);\n\n\tep2_curve_get_ord(n);\n\n\tBENCH_RUN(\"ep2_add\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_rand(p);\n\t\tep2_add(q, q, p);\n\t\tBENCH_ADD(ep2_add(r, p, q));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_add_basic\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_add_basic(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_add_slp_basic\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_add_slp_basic(r, s, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_add_projc\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add_projc(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_rand(p);\n\t\tep2_add_projc(q, q, p);\n\t\tBENCH_ADD(ep2_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_add_projc (z2 = 1)\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add_projc(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_norm(q, q);\n\t\tBENCH_ADD(ep2_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_add_projc (z1,z2 = 1)\") {\n\t\tep2_rand(p);\n\t\tep2_norm(p, p);\n\t\tep2_rand(q);\n\t\tep2_norm(q, q);\n\t\tBENCH_ADD(ep2_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_sub\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tep2_rand(q);\n\t\tep2_rand(p);\n\t\tep2_add(q, q, p);\n\t\tBENCH_ADD(ep2_sub(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_dbl\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tBENCH_ADD(ep2_dbl(r, p));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_dbl_basic\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_dbl_basic(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_dbl_slp_basic\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_dbl_slp_basic(r, s, p));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_dbl_projc\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add_projc(p, p, q);\n\t\tBENCH_ADD(ep2_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_dbl_projc (z1 = 1)\") {\n\t\tep2_rand(p);\n\t\tep2_norm(p, p);\n\t\tBENCH_ADD(ep2_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_neg\") {\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tep2_add(p, p, q);\n\t\tBENCH_ADD(ep2_neg(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep2_mul\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul(q, p, k));\n\t} BENCH_END;\n\n#if EP_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul_basic(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_slide\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_slide(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_monty\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_monty(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_lwnaf(q, p, k));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_mul_gen\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul_gen(q, k));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_dig\") {\n\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep2_mul_dig(p, q, k->dp[0]));\n\t}\n\tBENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep2_new(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep2_mul_pre\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre(t, p);\n\t\tBENCH_ADD(ep2_mul_fix(q, t, k));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep2_free(t[i]);\n\t}\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_basic\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre_basic(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre_basic(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_basic(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_combs\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre_combs(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_combs\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre_combs(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_combs(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_combd\") {\n\t\tBENCH_ADD(ep2_mul_pre_combd(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_combd\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_mul_pre_combd(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_combd(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep2_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep2_mul_pre_lwnaf\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_mul_pre_lwnaf(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_mul_fix_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep2_rand(p);\n\t\tep2_mul_pre_lwnaf(t, p);\n\t\tBENCH_ADD(ep2_mul_fix_lwnaf(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep2_free(t[i]);\n\t}\n#endif\n\n\tBENCH_RUN(\"ep2_mul_sim\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_basic\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_basic(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_trick\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_trick(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_inter\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_inter(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\tBENCH_RUN(\"ep2_mul_sim_joint\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(p);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_joint(r, p, l[0], q, l[1]));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep2_mul_sim_gen\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_mul_sim_gen(r, l[0], q, l[1]));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tep2_new(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep2_mul_sim_lot (2)\") {\n\t\tbn_rand_mod(l[0], n);\n\t\tbn_rand_mod(l[1], n);\n\t\tep2_rand(t[0]);\n\t\tep2_rand(t[1]);\n\t\tBENCH_ADD(ep2_mul_sim_lot(r, t, l, 2));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tep2_free(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep2_frb\") {\n\t\tep2_rand(q);\n\t\tBENCH_ADD(ep2_frb(r, q, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_map\") {\n\t\tuint8_t msg[5];\n\t\trand_bytes(msg, 5);\n\t\tBENCH_ADD(ep2_map(p, msg, 5));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_pck\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_pck(q, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep2_upk\") {\n\t\tep2_rand(p);\n\t\tBENCH_ADD(ep2_upk(q, p));\n\t} BENCH_END;\n\n\tep2_free(p);\n\tep2_free(q);\n\tep2_free(r);\n\tbn_free(k);\n\tbn_free(n);\n\tbn_free(l[0]);\n\tbn_free(l[1]);\n\tfp2_free(s);\n}\n\nstatic void memory4(void) {\n\tep4_t a[BENCH];\n\n\tBENCH_FEW(\"ep4_null\", ep4_null(a[i]), 1);\n\n\tBENCH_FEW(\"ep4_new\", ep4_new(a[i]), 1);\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep4_free(a[i]);\n\t}\n\n\tfor (int i = 0; i < BENCH; i++) {\n\t\tep4_new(a[i]);\n\t}\n\tBENCH_FEW(\"ep4_free\", ep4_free(a[i]), 1);\n\n\t(void)a;\n}\n\nstatic void util4(void) {\n\tep4_t p, q, t[2];\n\tuint8_t bin[8 * RLC_FP_BYTES + 1];\n\tint l;\n\n\tep4_null(p);\n\tep4_null(q);\n\tep4_null(t[0]);\n\tep4_null(t[1]);\n\n\tep4_new(p);\n\tep4_new(q);\n\tep4_new(t[0]);\n\tep4_new(t[1]);\n\n\tBENCH_RUN(\"ep4_is_infty\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_is_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_set_infty\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_set_infty(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_copy\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_copy(p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_cmp\") {\n\t\tep4_rand(p);\n\t\tep4_dbl(p, p);\n\t\tep4_rand(q);\n\t\tep4_dbl(q, q);\n\t\tBENCH_ADD(ep4_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_norm\") {\n\t\tep4_rand(p);\n\t\tep4_dbl(p, p);\n\t\tBENCH_ADD(ep4_norm(p, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_norm_sim (2)\") {\n\t\tep4_rand(t[0]);\n\t\tep4_rand(t[1]);\n\t\tep4_dbl(t[0], t[0]);\n\t\tep4_dbl(t[1], t[1]);\n\t\tBENCH_ADD(ep4_norm_sim(t, t, 2));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_cmp (1 norm)\") {\n\t\tep4_rand(p);\n\t\tep4_dbl(p, p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_cmp (2 norm)\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_cmp(p, q));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_rand\") {\n\t\tBENCH_ADD(ep4_rand(p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_blind\") {\n\t\tBENCH_ADD(ep4_blind(p, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_on_curve\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_on_curve(p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_size_bin\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_size_bin(p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_write_bin\") {\n\t\tep4_rand(p);\n\t\tl = ep4_size_bin(p, 0);\n\t\tBENCH_ADD(ep4_write_bin(bin, l, p, 0));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_read_bin\") {\n\t\tep4_rand(p);\n\t\tl = ep4_size_bin(p, 0);\n\t\tep4_write_bin(bin, l, p, 0);\n\t\tBENCH_ADD(ep4_read_bin(p, bin, l));\n\t} BENCH_END;\n\n\tep4_free(p);\n\tep4_free(q);\n\tep4_free(t[0]);\n\tep4_free(t[1]);\n}\n\nstatic void arith4(void) {\n\tep4_t p, q, r, t[RLC_EPX_TABLE_MAX];\n\tbn_t k, n, l;\n\tfp4_t s;\n\n\tep4_null(p);\n\tep4_null(q);\n\tep4_null(r);\n\tbn_null(k);\n\tbn_null(n);\n\tfp4_null(s);\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep4_null(t[i]);\n\t}\n\n\tep4_new(p);\n\tep4_new(q);\n\tep4_new(r);\n\tbn_new(k);\n\tbn_new(n);\n\tbn_new(l);\n\tfp4_new(s);\n\n\tep4_curve_get_ord(n);\n\n\tBENCH_RUN(\"ep4_add\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_rand(p);\n\t\tep4_add(q, q, p);\n\t\tBENCH_ADD(ep4_add(r, p, q));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_add_basic\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_add_basic(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_add_slp_basic\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_add_slp_basic(r, s, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_add_projc\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add_projc(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_rand(p);\n\t\tep4_add_projc(q, q, p);\n\t\tBENCH_ADD(ep4_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_add_projc (z2 = 1)\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add_projc(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_norm(q, q);\n\t\tBENCH_ADD(ep4_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_add_projc (z1,z2 = 1)\") {\n\t\tep4_rand(p);\n\t\tep4_norm(p, p);\n\t\tep4_rand(q);\n\t\tep4_norm(q, q);\n\t\tBENCH_ADD(ep4_add_projc(r, p, q));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_sub\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tep4_rand(q);\n\t\tep4_rand(p);\n\t\tep4_add(q, q, p);\n\t\tBENCH_ADD(ep4_sub(r, p, q));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_dbl\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tBENCH_ADD(ep4_dbl(r, p));\n\t}\n\tBENCH_END;\n\n#if EP_ADD == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_dbl_basic\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_dbl_basic(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_dbl_slp_basic\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_dbl_slp_basic(r, s, p));\n\t}\n\tBENCH_END;\n#endif\n\n#if EP_ADD == PROJC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_dbl_projc\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add_projc(p, p, q);\n\t\tBENCH_ADD(ep4_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_dbl_projc (z1 = 1)\") {\n\t\tep4_rand(p);\n\t\tep4_norm(p, p);\n\t\tBENCH_ADD(ep4_dbl_projc(r, p));\n\t}\n\tBENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_neg\") {\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tep4_add(p, p, q);\n\t\tBENCH_ADD(ep4_neg(r, p));\n\t}\n\tBENCH_END;\n\n\tBENCH_RUN(\"ep4_mul\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul(q, p, k));\n\t} BENCH_END;\n\n#if EP_MUL == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul_basic(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_slide\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_slide(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_monty\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_monty(q, p, k));\n\t} BENCH_END;\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_lwnaf(q, p, k));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_mul_gen\") {\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul_gen(q, k));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_dig\") {\n\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\tbn_rand_mod(k, n);\n\t\tBENCH_ADD(ep4_mul_dig(p, q, k->dp[0]));\n\t}\n\tBENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep4_new(t[i]);\n\t}\n\n\tBENCH_RUN(\"ep4_mul_pre\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre(t, p);\n\t\tBENCH_ADD(ep4_mul_fix(q, t, k));\n\t} BENCH_END;\n\n\tfor (int i = 0; i < RLC_EPX_TABLE_MAX; i++) {\n\t\tep4_free(t[i]);\n\t}\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_basic\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre_basic(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre_basic(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_basic(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_BASIC; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_combs\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre_combs(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_combs\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre_combs(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_combs(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBS; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_combd\") {\n\t\tBENCH_ADD(ep4_mul_pre_combd(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_combd\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_mul_pre_combd(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_combd(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_COMBD; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep4_new(t[i]);\n\t}\n\tBENCH_RUN(\"ep4_mul_pre_lwnaf\") {\n\t\tep4_rand(p);\n\t\tBENCH_ADD(ep4_mul_pre_lwnaf(t, p));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_mul_fix_lwnaf\") {\n\t\tbn_rand_mod(k, n);\n\t\tep4_rand(p);\n\t\tep4_mul_pre_lwnaf(t, p);\n\t\tBENCH_ADD(ep4_mul_fix_lwnaf(q, t, k));\n\t} BENCH_END;\n\tfor (int i = 0; i < RLC_EPX_TABLE_LWNAF; i++) {\n\t\tep4_free(t[i]);\n\t}\n#endif\n\n\tBENCH_RUN(\"ep4_mul_sim\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim(r, p, k, q, l));\n\t} BENCH_END;\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_basic\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_basic(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_trick\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_trick(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_inter\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_inter(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\tBENCH_RUN(\"ep4_mul_sim_joint\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(p);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_joint(r, p, k, q, l));\n\t} BENCH_END;\n#endif\n\n\tBENCH_RUN(\"ep4_mul_sim_gen\") {\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(l, n);\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_mul_sim_gen(r, k, q, l));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_frb\") {\n\t\tep4_rand(q);\n\t\tBENCH_ADD(ep4_frb(r, q, 1));\n\t} BENCH_END;\n\n\tBENCH_RUN(\"ep4_map\") {\n\t\tuint8_t msg[5];\n\t\trand_bytes(msg, 5);\n\t\tBENCH_ADD(ep4_map(p, msg, 5));\n\t} BENCH_END;\n\n\tep4_free(p);\n\tep4_free(q);\n\tep4_free(r);\n\tbn_free(k);\n\tbn_free(n);\n\tbn_free(l);\n\tfp4_free(s);\n}\n\nint main(void) {\n\tint r0, r1;\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tconf_print();\n\n\tutil_banner(\"Benchmarks for the EPX module:\", 0);\n\n\tif (ep_param_set_any_pairf() != RLC_OK) {\n\t\tRLC_THROW(ERR_NO_CURVE);\n\t\tcore_clean();\n\t\treturn 0;\n\t}\n\n\tif ((r0 = ep2_curve_is_twist())) {\n\t\tep_param_print();\n\n\t\tutil_banner(\"Utilities:\", 1);\n\t\tmemory2();\n\t\tutil2();\n\n\t\tutil_banner(\"Arithmetic:\", 1);\n\t\tarith2();\n\t}\n\n\tif ((r1 = ep4_curve_is_twist())) {\n\t\tep_param_print();\n\n\t\tutil_banner(\"Utilities:\", 1);\n\t\tmemory4();\n\t\tutil4();\n\n\t\tutil_banner(\"Arithmetic:\", 1);\n\t\tarith4();\n\t}\n\n\tif (!r0 && !r1) {\n\t\tRLC_THROW(ERR_NO_CURVE);\n\t\tcore_clean();\n\t\treturn 0;\n\t}\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup bn Multiple precision integer arithmetic\n */\n\n/**\n * @file\n *\n * Interface of the module for multiple precision integer arithmetic.\n *\n * @ingroup bn\n */\n\n#ifndef RLC_BN_H\n#define RLC_BN_H\n\n#include \"relic_conf.h\"\n#include \"relic_util.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a multiple precision integer.\n *\n * If the library is built with support for dynamic allocation, this constant\n * represents the size in bits of the memory block allocated each time a\n * multiple precision integer must grow. Otherwise, it represents the fixed\n * fixed precision.\n */\n#define RLC_BN_BITS \t((size_t)BN_PRECI)\n\n/**\n * Size in digits of a block sufficient to store the required precision.\n */\n#define RLC_BN_DIGS\t\t((size_t)RLC_CEIL(BN_PRECI, RLC_DIG))\n\n/**\n * Size in digits of a block sufficient to store a multiple precision integer.\n */\n#if BN_MAGNI == DOUBLE\n#define RLC_BN_SIZE\t\t((size_t)(2 * RLC_BN_DIGS + 2))\n#elif BN_MAGNI == CARRY\n#define RLC_BN_SIZE\t\t((size_t)(RLC_BN_DIGS + 1))\n#elif BN_MAGNI == SINGLE\n#define RLC_BN_SIZE\t\t((size_t)RLC_BN_DIGS)\n#endif\n\n/**\n * Positive sign of a multiple precision integer.\n */\n#define RLC_POS\t\t0\n\n/**\n * Negative sign of a multiple precision integer.\n */\n#define RLC_NEG\t\t1\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a multiple precision integer.\n *\n * The field dp points to a vector of digits. These digits are organized\n * in little-endian format, that is, the least significant digits are\n * stored in the first positions of the vector.\n */\ntypedef struct {\n\t/** The number of digits allocated to this multiple precision integer. */\n\tsize_t alloc;\n\t/** The number of digits actually used. */\n\tsize_t used;\n\t/** The sign of this multiple precision integer. */\n\tint sign;\n#if ALLOC == DYNAMIC\n\t/** The sequence of contiguous digits that forms this integer. */\n\tdig_t *dp;\n#elif ALLOC == AUTO\n\t/** The sequence of contiguous digits that forms this integer. */\n\trlc_align dig_t dp[RLC_BN_SIZE];\n#endif\n} bn_st;\n\n/**\n * Pointer to a multiple precision integer structure.\n */\n#if ALLOC == AUTO\ntypedef bn_st bn_t[1];\n#elif ALLOC == DYNAMIC\n#ifdef CHECK\ntypedef bn_st *volatile bn_t;\n#else\ntypedef bn_st *bn_t;\n#endif\n#endif\n\n/**\n * Represents a pair of moduli for using the Chinese Remainder Theorem (CRT).\n */\ntypedef struct {\n\t/** The modulus n = pq. */\n\tbn_t n;\n\t/** The first prime p. */\n\tbn_t p;\n\t/** The second prime q. */\n\tbn_t q;\n\t/** The precomputed constant for the first prime. */\n\tbn_t dp;\n\t/** The precomputed constant for the second prime. */\n\tbn_t dq;\n\t/** The inverse of q modulo p. */\n\tbn_t qi;\n} crt_st;\n\n#if ALLOC == AUTO\ntypedef crt_st crt_t[1];\n#else\ntypedef crt_st *crt_t;\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a multiple precision integer with a null value.\n *\n * @param[out] A\t\t\t- the multiple precision integer to initialize.\n */\n#if ALLOC == AUTO\n#define bn_null(A)\t\t\t/* empty */\n#elif ALLOC == DYNAMIC\n#define bn_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif ((A) == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, RLC_BN_SIZE);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to allocate and initialize a multiple precision integer\n * with the required precision in digits.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to initialize.\n * @param[in] D\t\t\t\t- the precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\n#if ALLOC == DYNAMIC\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bn_t)calloc(1, sizeof(bn_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bn_new_size(A, D)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_make(A, D);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a multiple precision integer.\n *\n * @param[in,out] A\t\t\t- the multiple precision integer to free.\n */\n#if ALLOC == DYNAMIC\n#define bn_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_clean(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree((void *)A);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bn_free(A)\t\t\t/* empty */\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Initializes a CRT moduli set with a null value.\n *\n * @param[out] A\t\t\t- the moduli to initialize.\n */\n#define crt_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Rabin key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (crt_t)calloc(1, sizeof(crt_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define crt_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Rabin key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define crt_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dp);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->dq);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->qi);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define crt_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Multiples two multiple precision integers. Computes c = a * b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] B\t\t\t\t- the second multiple precision integer to multiply.\n */\n#if BN_KARAT > 0\n#define bn_mul(C, A, B)\t\tbn_mul_karat(C, A, B)\n#elif BN_MUL == BASIC\n#define bn_mul(C, A, B)\t\tbn_mul_basic(C, A, B)\n#elif BN_MUL == COMBA\n#define bn_mul(C, A, B)\t\tbn_mul_comba(C, A, B)\n#endif\n\n/**\n * Computes the square of a multiple precision integer. Computes c = a * a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to square.\n */\n#if BN_KARAT > 0\n#define bn_sqr(C, A)\t\tbn_sqr_karat(C, A)\n#elif BN_SQR == BASIC\n#define bn_sqr(C, A)\t\tbn_sqr_basic(C, A)\n#elif BN_SQR == COMBA\n#define bn_sqr(C, A)\t\tbn_sqr_comba(C, A)\n#elif BN_SQR == MULTP\n#define bn_sqr(C, A)\t\tbn_mul(C, A, A)\n#endif\n\n/**\n * Computes the auxiliar value derived from the modulus to be used during\n * modular reduction.\n *\n * @param[out] U\t\t\t- the result.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_pre(U, M)\t(void)(U), (void)(M)\n#elif BN_MOD == BARRT\n#define bn_mod_pre(U, M)\tbn_mod_pre_barrt(U, M)\n#elif BN_MOD == MONTY\n#define bn_mod_pre(U, M)\tbn_mod_pre_monty(U, M)\n#elif BN_MOD == PMERS\n#define bn_mod_pre(U, M)\tbn_mod_pre_pmers(U, M)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo another integer. If the number\n * of arguments is 3, then simple division is used. If the number of arguments\n * is 4, then a modular reduction algorithm is used and the fourth argument\n * is an auxiliary value derived from the modulus. The variant with 4 arguments\n * should be used when several modular reductions are computed with the same\n * modulus. Computes c = a mod m.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] ...\t\t\t- the modulus and an optional argument.\n */\n#define bn_mod(C, A, ...)\tRLC_CAT(bn_mod, RLC_OPT(__VA_ARGS__))(C, A, __VA_ARGS__)\n\n/**\n * Reduces a multiple precision integer modulo another integer. This macro\n * should not be called directly. Use bn_mod with 4 arguments instead.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the auxiliar value derived from the modulus.\n */\n#if BN_MOD == BASIC\n#define bn_mod_imp(C, A, M, U)\tbn_mod_basic(C, A, M)\n#elif BN_MOD == BARRT\n#define bn_mod_imp(C, A, M, U)\tbn_mod_barrt(C, A, M, U)\n#elif BN_MOD == MONTY\n#define bn_mod_imp(C, A, M, U)\tbn_mod_monty(C, A, M, U)\n#elif BN_MOD == PMERS\n#define bn_mod_imp(C, A, M, U)\tbn_mod_pmers(C, A, M, U)\n#endif\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction. Computes c = a * u^(-1) (mod m).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] M\t\t\t\t- the modulus.\n * @param[in] U\t\t\t\t- the reciprocal of the modulus.\n */\n#if BN_MUL == BASIC\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_basic(C, A, M, U)\n#elif BN_MUL == COMBA\n#define bn_mod_monty(C, A, M, U)\tbn_mod_monty_comba(C, A, M, U)\n#endif\n\n/**\n * Exponentiates a multiple precision integer modulo another multiple precision\n * integer. Computes c = a^b mod m. If Montgomery reduction is used, the basis\n * must not be in Montgomery form.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n * @param[in] M\t\t\t\t- the modulus.\n */\n#if BN_MXP == BASIC\n#define bn_mxp(C, A, B, M)\tbn_mxp_basic(C, A, B, M)\n#elif BN_MXP == SLIDE\n#define bn_mxp(C, A, B, M)\tbn_mxp_slide(C, A, B, M)\n#elif BN_MXP == MONTY\n#define bn_mxp(C, A, B, M)\tbn_mxp_monty(C, A, B, M)\n#endif\n\n/**\n * Computes the greatest common divisor of two multiple precision integers.\n * Computes c = gcd(a, b).\n *\n * @param[out] C\t\t\t- the result;\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd(C, A, B)\t\tbn_gcd_basic(C, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd(C, A, B)\t\tbn_gcd_lehme(C, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd(C, A, B)\t\tbn_gcd_binar(C, A, B)\n#endif\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers. This function can be used to compute multiplicative inverses.\n * Computes c = gcd(a, b) and c = a * d + b * e.\n *\n * @param[out] C\t\t\t- the result;\n * @param[out] D\t\t\t- the cofactor of the first operand, cannot be NULL.\n * @param[out] E\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] A\t\t\t\t- the first multiple precision integer.\n * @param[in] B\t\t\t\t- the second multiple precision integer.\n */\n#if BN_GCD == BASIC\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_basic(C, D, E, A, B)\n#elif BN_GCD == LEHME\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_lehme(C, D, E, A, B)\n#elif BN_GCD == BINAR\n#define bn_gcd_ext(C, D, E, A, B)\t\tbn_gcd_ext_binar(C, D, E, A, B)\n#endif\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] A\t\t\t- the result.\n * @param[in] B\t\t\t\t- the length of the number in bits.\n */\n#if BN_GEN == BASIC\n#define bn_gen_prime(A, B)\tbn_gen_prime_basic(A, B)\n#elif BN_GEN == SAFEP\n#define bn_gen_prime(A, B)\tbn_gen_prime_safep(A, B)\n#elif BN_GEN == STRON\n#define bn_gen_prime(A, B)\tbn_gen_prime_stron(A, B)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes a previously allocated multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to initialize.\n * @param[in] digits\t\t- the required precision in digits.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_make(bn_t a, size_t digits);\n\n/**\n * Cleans a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to free.\n */\nvoid bn_clean(bn_t a);\n\n/**\n * Checks the current precision of a multiple precision integer and optionally\n * expands its precision to a given size in digits.\n *\n * @param[out] a\t\t\t- the multiple precision integer to expand.\n * @param[in] digits\t\t- the number of digits to expand.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n * @throw ERR_PRECISION\t\t- if the required precision cannot be represented\n * \t\t\t\t\t\t\tby the library.\n */\nvoid bn_grow(bn_t a, size_t digits);\n\n/**\n * Adjust the number of valid digits of a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to adjust.\n */\nvoid bn_trim(bn_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to copy.\n */\nvoid bn_copy(bn_t c, const bn_t a);\n\n/**\n * Returns the absolute value of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the argument of the absolute function.\n */\nvoid bn_abs(bn_t c, const bn_t a);\n\n/**\n * Inverts the sign of a multiple precision integer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the multiple precision integer to negate.\n */\nvoid bn_neg(bn_t c, const bn_t a);\n\n/**\n * Returns the sign of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return RLC_POS if the argument is positive and RLC_NEG otherwise.\n */\nint bn_sign(const bn_t a);\n\n/**\n * Assigns zero to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n */\nvoid bn_zero(bn_t a);\n\n/**\n * Tests if a multiple precision integer is zero or not.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint bn_is_zero(const bn_t a);\n\n/**\n * Tests if a multiple precision integer is even or odd.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if the argument is even, 0 otherwise.\n */\nint bn_is_even(const bn_t a);\n\n/**\n * Returns the number of bits of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return number of bits.\n */\nsize_t bn_bits(const bn_t a);\n\n/**\n * Returns the bit stored in the given position on a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to read.\n * @return the bit value.\n */\nint bn_get_bit(const bn_t a, size_t bit);\n\n/**\n * Stores a bit in a given position on a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer.\n * @param[in] bit\t\t\t- the bit position to store.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid bn_set_bit(bn_t a, size_t bit, int value);\n\n/**\n * Returns the Hamming weight of a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of non-zero bits.\n */\nsize_t bn_ham(const bn_t a);\n\n/**\n * Reads the first digit in a multiple precision integer.\n *\n * @param[out] digit\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n */\nvoid bn_get_dig(dig_t *digit, const bn_t a);\n\n/**\n * Assigns a small positive constant to a multiple precision integer.\n *\n * The constant must fit on a multiple precision digit, or dig_t type using\n * only the number of bits specified on RLC_DIG.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] digit\t\t\t- the constant to assign.\n */\nvoid bn_set_dig(bn_t a, dig_t digit);\n\n/**\n * Assigns a multiple precision integer to 2^b.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] b\t\t\t\t- the power of 2 to assign.\n */\nvoid bn_set_2b(bn_t a, size_t b);\n\n/**\n * Assigns a random value to a multiple precision integer.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] sign\t\t\t- the sign to be assigned (RLC_NEG or RLC_POS).\n * @param[in] bits\t\t\t- the number of bits.\n */\nvoid bn_rand(bn_t a, int sign, size_t bits);\n\n/**\n * Assigns a non-zero random value to a multiple precision integer with absolute\n * value smaller than a given modulus.\n *\n * @param[out] a\t\t\t- the multiple precision integer to assign.\n * @param[in] b\t\t\t\t- the modulus.\n */\nvoid bn_rand_mod(bn_t a, const bn_t b);\n\n/**\n * Prints a multiple precision integer to standard output.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to print.\n */\nvoid bn_print(const bn_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a multiple precision\n * integer. The radix must be included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nsize_t bn_size_str(const bn_t a, unsigned int radix);\n\n/**\n * Reads a multiple precision integer from a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_read_str(bn_t a, const char *str, size_t len, unsigned int radix);\n\n/**\n * Writes a multiple precision integer to a string in a given radix. The radix\n * must be included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid bn_write_str(char *str, size_t len, const bn_t a, unsigned radix);\n\n/**\n * Returns the number of bytes necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of bytes.\n */\nsize_t bn_size_bin(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n */\nvoid bn_read_bin(bn_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_bin(uint8_t *bin, size_t len, const bn_t a);\n\n/**\n * Returns the number of digits necessary to store a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @return the number of digits.\n */\nsize_t bn_size_raw(const bn_t a);\n\n/**\n * Reads a positive multiple precision integer from a digit vector.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the size of the string.\n */\nvoid bn_read_raw(bn_t a, const dig_t *raw, size_t len);\n\n/**\n * Writes a positive multiple precision integer to a byte vector.\n *\n * @param[out] raw\t\t\t- the digit vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the multiple integer to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_write_raw(dig_t *raw, size_t len, const bn_t a);\n\n/**\n * Returns the result of an unsigned comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_abs(const bn_t a, const bn_t b);\n\n/**\n * Returns the result of a signed comparison between a multiple precision\n * integer and a digit.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp_dig(const bn_t a, dig_t b);\n\n/**\n * Returns the result of a signed comparison between two multiple precision\n * integers.\n *\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n * @return RLC_LT if a < b, RLC_EQ if a == b and RLC_GT if a > b.\n */\nint bn_cmp(const bn_t a, const bn_t b);\n\n/**\n * Adds two multiple precision integers. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to add.\n * @param[in] b\t\t\t\t- the second multiple precision integer to add.\n */\nvoid bn_add(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Adds a multiple precision integers and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to add.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid bn_add_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Subtracts a multiple precision integer from another, that is, computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the multiple precision integer to subtract.\n */\nvoid bn_sub(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Subtracts a digit from a multiple precision integer. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid bn_sub_dig(bn_t c, const bn_t a, const dig_t b);\n\n/**\n * Multiplies a multiple precision integer by a digit. Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid bn_mul_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Multiplies two multiple precision integers using Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_comba(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Multiplies two multiple precision integers using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first multiple precision integer to multiply.\n * @param[in] b\t\t\t\t- the second multiple precision integer to multiply.\n */\nvoid bn_mul_karat(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the square of a multiple precision integer using Schoolbook\n * squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_basic(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Comba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_comba(bn_t c, const bn_t a);\n\n/**\n * Computes the square of a multiple precision integer using Karatsuba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to square.\n */\nvoid bn_sqr_karat(bn_t c, const bn_t a);\n\n/**\n * Doubles a multiple precision. Computes c = a + a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to double.\n */\nvoid bn_dbl(bn_t c, const bn_t a);\n\n/**\n * Halves a multiple precision. Computes c = floor(a / 2)\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to halve.\n */\nvoid bn_hlv(bn_t c, const bn_t a);\n\n/**\n * Shifts a multiple precision number to the left. Computes c = a * 2^bits.\n * c = a * 2^bits.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_lsh(bn_t c, const bn_t a, unsigned int bits);\n\n/**\n * Shifts a multiple precision number to the right. Computes\n * c = floor(a / 2^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid bn_rsh(bn_t c, const bn_t a, unsigned int bits);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * without producing the positive remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integer by another multiple precision integer\n * and produces a positive remainder. Computes c = floor(a / b) and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the positive remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem(bn_t c, bn_t d, const bn_t a, const bn_t b);\n\n/**\n * Divides a multiple precision integers by a digit without computing the\n * remainder. Computes c = floor(a / b).\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Divides a multiple precision integers by a digit. Computes c = floor(a / b)\n * and d = a mod b.\n *\n * @param[out] c\t\t\t- the resulting quotient.\n * @param[out] d\t\t\t- the remainder.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n * @throw ERR_NO_VALID\t\t- if the divisor is zero.\n */\nvoid bn_div_rem_dig(bn_t c, dig_t *d, const bn_t a, const dig_t b);\n\n/**\n * Computes the modular inverse of a multiple precision integer. Computes c such\n * that a*c mod b = 1.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a\t\t\t\t- the element to invert.\n * param[in] b\t\t\t\t- the modulus.\n *\n */\nvoid bn_mod_inv(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the modular inverse of multiple precision integers simultaneously.\n * Computes c_i such that a_i * c_i mod b = 1.\n *\n * @param[out] c\t\t\t- the results.\n * @param[in] a\t\t\t\t- the elements to invert.\n * param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid bn_mod_inv_sim(bn_t *c, const bn_t *a, const bn_t b, int n);\n\n/**\n * Reduces a multiple precision integer modulo a power of 2. Computes\n * c = a mod 2^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the exponent of the divisor.\n */\nvoid bn_mod_2b(bn_t c, const bn_t a, int b);\n\n/**\n * Reduces a multiple precision integer modulo a digit. Computes c = a mod b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dividend.\n * @param[in] b\t\t\t\t- the divisor.\n */\nvoid bn_mod_dig(dig_t *c, const bn_t a, dig_t b);\n\n/**\n * Reduces a multiple precision integer modulo an integer using straightforward\n * division.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_basic(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Barrett modular\n * reduction algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_barrt(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using Barrett\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_barrt(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes the reciprocal of the modulus to be used in the Montgomery reduction\n * algorithm.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n * @throw ERR_NO_VALID\t\t- if the modulus is even.\n */\nvoid bn_mod_pre_monty(bn_t u, const bn_t m);\n\n/**\n * Converts a multiple precision integer to Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_conv(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Converts a multiple precision integer from Montgomery form.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to convert.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_monty_back(bn_t c, const bn_t a, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_basic(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * Montgomery reduction with Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the reciprocal of the modulus.\n */\nvoid bn_mod_monty_comba(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Computes u if the modulus has the form 2^b - u.\n *\n * @param[out] u\t\t\t- the result.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mod_pre_pmers(bn_t u, const bn_t m);\n\n/**\n * Reduces a multiple precision integer modulo a positive integer using\n * pseudo-Mersenne modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to reduce.\n * @param[in] m\t\t\t\t- the modulus.\n * @param[in] u\t\t\t\t- the auxiliar value derived from the modulus.\n */\nvoid bn_mod_pmers(bn_t c, const bn_t a, const bn_t m, const bn_t u);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer modulo a positive integer using\n * the constant-time Montgomery powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_monty(bn_t c, const bn_t a, const bn_t b, const bn_t m);\n\n/**\n * Exponentiates a multiple precision integer by a small power modulo a positive\n * integer using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n * @param[in] m\t\t\t\t- the modulus.\n */\nvoid bn_mxp_dig(bn_t c, const bn_t a, dig_t b, const bn_t m);\n\n/*\n * Computes a modular exponentiation of a multiple precision integer using the\n * Chinese Remainder Theorem, given the moduli.\n *\n * @param[out] d \t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent modulo p.\n * @param[in] c\t\t\t\t- the exponent modulo q.\n * @param[in] crt \t\t\t- the set of moduli.\n * @param[in] sqr \t\t\t- the flag to indicate if modulo n or n^2.\n */\nvoid bn_mxp_crt(bn_t d, const bn_t a, const bn_t b, const bn_t c,\n\tconst crt_t crt, int sqr);\n\n/**\n * Extracts an approximate integer square-root of a multiple precision integer.\n *\n * @param[out] c \t\t\t- the result.\n * @param[in] a \t\t\t- the multiple precision integer to extract.\n *\n * @throw ERR_NO_VALID\t\t- if the argument is negative.\n */\nvoid bn_srt(bn_t c, bn_t a);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the standard Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_basic(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary GCD algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_binar(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of a multiple precision integer and a\n * digit.\n *\n * @param[out] c\t\t\t- the result;\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_dig(bn_t c, const bn_t a, dig_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integer using the Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_basic(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using Lehmer's algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the greatest common divisor of two multiple precision integers\n * using the Binary algorithm.\n *\n * @param[out] c\t\t\t- the result;\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of two multiple precision\n * integers halfway through the algorithm. Returns also two short vectors\n * v1 = (c, d), v2 = (-e, f) useful to decompose an integer k into k0, k1 such\n * that k = k_0 + k_1 * a (mod b).\n *\n * @param[out] c\t\t\t- the first component of the first vector.\n * @param[out] d\t\t\t- the second component of the first vector.\n * @param[out] e\t\t\t- the first component of the second vector.\n * @param[out] f\t\t\t- the second component of the second vector.\n * @param[in] a\t\t\t\t- the first multiple precision integer.\n * @param[in] b\t\t\t\t- the second multiple precision integer.\n */\nvoid bn_gcd_ext_mid(bn_t c, bn_t d, bn_t e, bn_t f, const bn_t a, const bn_t b);\n\n/**\n * Computes the extended greatest common divisor of a multiple precision integer\n * and a digit.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] d\t\t\t- the cofactor of the first operand, can be NULL.\n * @param[out] e\t\t\t- the cofactor of the second operand, can be NULL.\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid bn_gcd_ext_dig(bn_t c, bn_t d, bn_t e, const bn_t a, dig_t b);\n\n/**\n * Computes the last common multiple of two multiple precision integers.\n * Computes c = lcm(a, b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first integer.\n * @param[in] b\t\t\t\t- the second integer.\n */\nvoid bn_lcm(bn_t c, const bn_t a, const bn_t b);\n\n/**\n * Computes the Legendre symbol c = (a|b), b prime.\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is negative.\n * @return the result.\n */\nint bn_smb_leg(const bn_t a, const bn_t b);\n\n/**\n * Computes the Jacobi symbol c = (a|b).\n *\n * @param[in] a\t\t\t\t- the first parameter.\n * @param[in] b\t\t\t\t- the second parameter.\n * @throw ERR_NO_VALID\t\t- if there input is even or negative.\n * @return the result.\n */\nint bn_smb_jac(const bn_t a, const bn_t b);\n\n/**\n * Tests if a number is a probable prime.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer to test.\n * @return 1 if a is prime, 0 otherwise.\n */\nint bn_is_prime(const bn_t a);\n\n/**\n * Tests if a number is prime using a series of trial divisions.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_basic(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Miller-Rabin test with probability\n * 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_rabin(const bn_t a);\n\n/**\n * Tests if a number a > 2 is prime using the Solovay-Strassen test with\n * probability 2^(-80) of error.\n *\n * @param[in] a\t\t\t\t- the number to test.\n * @return 1 if a is a probable prime, 0 otherwise.\n */\nint bn_is_prime_solov(const bn_t a);\n\n/**\n * Generates a probable prime number.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_basic(bn_t a, size_t bits);\n\n/**\n * Generates a probable prime number a with (a - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_safep(bn_t a, size_t bits);\n\n/**\n * Generates a probable prime number with (a - 1)/2, (a + 1)/2 and\n * ((a - 1)/2 - 1)/2 also prime.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bits\t\t\t- the length of the number in bits.\n */\nvoid bn_gen_prime_stron(bn_t a, size_t bits);\n\n/**\n * Generates a probable prime number b, with (b-1) divisible by a probable large\n * prime a.\n *\n * @param[out] a\t\t\t- the prime factor of (b-1).\n * @param[out] b\t\t\t- the prime result b.\n * @param[in] abits\t\t\t- the length of the factor a in bits.\n * @param[in] bbits\t\t\t- the length of the result in bits.\n */\nint bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits);\n\n\n/**\n * Tries to factorize an integer using Pollard (p - 1) factoring algorithm.\n * The maximum length of the returned factor is 16 bits.\n *\n * @param[out] c\t\t\t- the resulting factor.\n * @param[in] a\t\t\t\t- the integer to fatorize.\n * @return 1 if a factor is found and stored into c; 0 otherwise.\n */\nint bn_factor(bn_t c, const bn_t a);\n\n/**\n * Tests if an integer divides other integer.\n *\n * @param[in] c\t\t\t\t- the factor.\n * @param[in] a\t\t\t\t- the integer.\n * @return 1 if the first integer is a factor; 0 otherwise.\n */\nint bn_is_factor(bn_t c, const bn_t a);\n\n/**\n * Recodes a positive integer in window form. If a negative integer is given\n * instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_win(uint8_t *win, size_t *len, const bn_t k, size_t w);\n\n/**\n * Recodes a positive integer in sliding window form. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] win\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_slw(uint8_t *win, size_t *len, const bn_t k, size_t w);\n\n/**\n * Recodes a positive integer in width-w Non-Adjacent Form. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w);\n\n/**\n * Recodes a positive integer in width-w \\tau-NAF. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_tnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n\t\tsize_t w);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w \\tau-NAF.\n * If a negative integer is given instead, its absolute value is taken.\n *\n * @param[out] tnaf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] u\t\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t\t- the extension degree of the binary field.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_rtnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n\t\tsize_t w);\n\n/**\n * Write the constants needed for \\tau-NAF recoding as a set of \\alpha_u =\n * \\beta_u + \\gamma_u * \\tau elements.\n *\n * @param[out] t \t\t- the integer corresponding to \\tau.\n * @param[out] beta\t\t- the first coefficients of the constants.\n * @param[out] gama\t\t- the second coefficients of the constants.\n * @param[in] u \t\t- the u curve parameter.\n * @param[in] w \t\t- the window size in bits.\n */\nvoid bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u,\n\t\tsize_t w);\n\n/**\n * Computes the partial reduction k partmod d = r0 + r1 * t, where\n * d = (t^m - 1)/(t - 1).\n *\n * @param[out] r0\t\t- the first half of the result.\n * @param[out] r1\t\t- the second half of the result.\n * @param[in] k\t\t\t- the number to reduce.\n * @param[in] u\t\t\t- the u curve parameter.\n * @param[in] m\t\t\t- the extension degree of the binary field.\n */\nvoid bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, size_t m);\n\n/**\n * Recodes a positive integer in regular fixed-length width-w NAF. If a negative\n * integer is given instead, its absolute value is taken.\n *\n * @param[out] naf\t\t\t- the recoded integer.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the length of the recoding.\n * @param[in] w\t\t\t\t- the window size in bits.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_reg(int8_t *naf, size_t *len, const bn_t k, size_t n, size_t w);\n\n/**\n * Recodes of a pair of positive integers in Joint Sparse Form. If negative\n * integers are given instead, takes their absolute value.\n *\n * @param[out] jsf\t\t\t- the recoded pair of integers.\n * @param[out] len\t\t\t- the number of bytes written.\n * @param[in] k\t\t\t\t- the first integer to recode.\n * @param[in] l\t\t\t\t- the second integer to recode.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid bn_rec_jsf(int8_t *jsf, size_t *len, const bn_t k, const bn_t l);\n\n/**\n * Recodes a positive integer into two parts k0,k1 such that k = k0 + phi(k1),\n * where phi is an efficient curve endomorphism. If a negative integer is\n * given instead, its absolute value is taken.\n *\n * @param[out] k0\t\t\t- the first part of the result.\n * @param[out] k1\t\t\t- the second part of the result.\n * @param[in] k\t\t\t\t- the integer to recode.\n * @param[in] n\t\t\t\t- the group order.\n * @param[in] v1\t\t\t- the set of parameters v1 for the GLV method.\n * @param[in] v2\t\t\t- the set of parameters v2 for the GLV method.\n */\nvoid bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t v1[],\n\t\tconst bn_t v2[]);\n\n/**\n * Recodes a scalar in subscalars according to Frobenius endomorphism.\n *\n * @param[out] ki\t\t\t- the recoded subscalars.\n * @param[in] sub \t\t\t- the number of subscalars.\n * @param[in] k\t\t\t\t- the scalar to recode.\n * @param[in] x \t\t\t- the elliptic curve parameter.\n * @param[in] n\t\t\t\t- the elliptic curve group order.\n * @param[in] cof \t\t\t- flag to indicate if it is a curve with cofactor 1.\n */\nvoid bn_rec_frb(bn_t *ki, int sub, const bn_t k, const bn_t x, const bn_t n,\n\tint bls);\n\n/**\n * Computes the coefficients of the polynomial representing the Lagrange\n * interpolation for a modulus and a given set of roots.\n * Computes c(x) = \\prod_{0 <= i < n}(x - ai) mod q.\n *\n * @param[out] c \t\t\t- the coefficients of the polynomial.\n * @param[in] a\t\t\t\t- the set of roots.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the number of roots to interpolate.\n */\nvoid bn_lag(bn_t *c, const bn_t *a, const bn_t b, size_t n);\n\n/**\n * Evaluates an interpolated n-degree polynomial over a value in a modular way,\n * given the (n+1) coefficients of the polynomial and the modulus.\n * Computes c = a(x) mod q.\n *\n * @param[out] c \t\t\t- the result of the evaluation.\n * @param[in] a \t\t\t- the coefficients of the polynomial.\n * @param[in] x\t\t\t\t- the value to evaluate.\n * @param[in] b\t\t\t\t- the modulus.\n * @param[in] n\t\t\t\t- the degree of the polynomial.\n */\nvoid bn_evl(bn_t c, const bn_t *a, const bn_t x, const bn_t b, size_t n);\n\n#endif /* !RLC_BN_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup cp Cryptographic protocols\n */\n\n/**\n * @file\n *\n * Interface of cryptographic protocols.\n *\n * @ingroup cp\n */\n\n#ifndef RLC_CP_H\n#define RLC_CP_H\n\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n#include \"relic_util.h\"\n#include \"relic_bn.h\"\n#include \"relic_ec.h\"\n#include \"relic_pc.h\"\n#include \"relic_mpc.h\"\n\n/*============================================================================*/\n/* Type definitions.                                                          */\n/*============================================================================*/\n\n/**\n * Represents an RSA key pair.\n */\ntypedef struct {\n\t/** The private exponent. */\n\tbn_t d;\n\t/** The public exponent. */\n\tbn_t e;\n\t/** The pair of moduli. */\n\tcrt_t crt;\n} _rsa_st;\n\n/**\n * Pointer to an RSA key pair.\n */\n#if ALLOC == AUTO\ntypedef _rsa_st rsa_t[1];\n#else\ntypedef _rsa_st *rsa_t;\n#endif\n\n/**\n * Pointer to a Rabin key pair.\n */\n#if ALLOC == AUTO\ntypedef crt_st rabin_t[1];\n#else\ntypedef crt_st *rabin_t;\n#endif\n\n/**\n * Pointer to a Paillier's Homomorphic Probabilistic Encryption key pair.\n */\n#if ALLOC == AUTO\ntypedef crt_st phpe_t[1];\n#else\ntypedef crt_st *phpe_t;\n#endif\n\n\n/**\n * Represents a Subgroup Paillier's Probabilistic Encryption key pair.\n */\ntypedef struct {\n\t/** The subgroup order. */\n\tbn_t a;\n\t/** The subgroup size. */\n\tbn_t b;\n\t/** The generator ((1+n)^b) mod n^2. */\n\tbn_t g;\n\t/** The precomputed ((1+n)^b)^n mod n^2. */\n\tbn_t gn;\n\t/** The CRT parameters. */\n\tcrt_t crt;\n} shpe_st;\n\n/**\n * Pointer to a Subgroup-Paillier's Homomorphic Probabilistic Encryption key pair.\n */\n#if ALLOC == AUTO\ntypedef shpe_st shpe_t[1];\n#else\ntypedef shpe_st *shpe_t;\n#endif\n\n/**\n * Represents a Benaloh's Dense Probabilistic Encryption key pair.\n */\ntypedef struct {\n\t/** The modulus n = pq. */\n\tbn_t n;\n\t/** The first prime p. */\n\tbn_t p;\n\t/** The second prime q. */\n\tbn_t q;\n\t/** The random element in {0, ..., n - 1}. */\n\tbn_t y;\n\t/** The divisor of (p-1) such that gcd(t, (p-1)/t) = gcd(t, q-1) = 1. */\n\tdig_t t;\n} bdpe_st;\n\n/**\n * Pointer to a Benaloh's Dense Probabilistic Encryption key pair.\n */\n#if ALLOC == AUTO\ntypedef bdpe_st bdpe_t[1];\n#else\ntypedef bdpe_st *bdpe_t;\n#endif\n\n/**\n * Represents a SOKAKA key pair.\n */\ntypedef struct _sokaka {\n\t/** The private key in G_1. */\n\tg1_t s1;\n\t/** The private key in G_2. */\n\tg2_t s2;\n} sokaka_st;\n\n/**\n * Pointer to SOKAKA key pair.\n */\n#if ALLOC == AUTO\ntypedef sokaka_st sokaka_t[1];\n#else\ntypedef sokaka_st *sokaka_t;\n#endif\n\n/**\n * Represents a Boneh-Goh-Nissim cryptosystem key pair.\n */\ntypedef struct {\n\t/** The first exponent. */\n\tbn_t x;\n\t/** The second exponent. */\n\tbn_t y;\n\t/** The third exponent. */\n\tbn_t z;\n\t/* The first element from the first group. */\n\tg1_t gx;\n\t/* The second element from the first group. */\n\tg1_t gy;\n\t/* The thirs element from the first group. */\n\tg1_t gz;\n\t/* The first element from the second group. */\n\tg2_t hx;\n\t/* The second element from the second group. */\n\tg2_t hy;\n\t/* The third element from the second group. */\n\tg2_t hz;\n} bgn_st;\n\n/**\n * Pointer to a Boneh-Goh-Nissim cryptosystem key pair.\n */\n#if ALLOC == AUTO\ntypedef bgn_st bgn_t[1];\n#else\ntypedef bgn_st *bgn_t;\n#endif\n\n/**\n * Represents an extendable ring signature.\n */\ntypedef struct _ers_st {\n\t/** The ephemeral public key in the signature. */\n    ec_t h;\n\t/** The public key associated to the signature. */\n\tec_t pk;\n\t/** The first component of the signature of knowledge. */\n\tbn_t c[2];\n\t/** The second component of the signature of knowledge. */\n\tbn_t r[2];\n} ers_st;\n\n/**\n * Pointer to an extendable ring signature.\n */\n#if ALLOC == AUTO\ntypedef ers_st ers_t[1];\n#else\ntypedef ers_st *ers_t;\n#endif\n\n/**\n * Represents an extendable ring signature.\n */\ntypedef struct _smlers_st {\n\t/** The extendable ring signature. */\n\ters_t sig;\n\t/** The linkability tag. */\n\tec_t tau;\n\t/** The first component of the signature of knowledge. */\n\tbn_t c[2];\n\t/** The second component of the signature of knowledge. */\n\tbn_t r[2];\n} smlers_st;\n\n/**\n * Pointer to an extendable ring signature.\n */\n#if ALLOC == AUTO\ntypedef smlers_st smlers_t[1];\n#else\ntypedef smlers_st *smlers_t;\n#endif\n\n/**\n * Represents an extendable threshold ring signature.\n */\ntypedef struct _etrs_st {\n\t/** The secret. */\n\tbn_t y;\n\t/** The ephemeral public key in the signature. */\n    ec_t h;\n\t/** The public key associated to the signature. */\n\tec_t pk;\n\t/** The first component of the signature of knowledge. */\n\tbn_t c[2];\n\t/** The second component of the signature of knowledge. */\n\tbn_t r[2];\n} etrs_st;\n\n/**\n * Pointer to an extendable ring signature.\n */\n#if ALLOC == AUTO\ntypedef etrs_st etrs_t[1];\n#else\ntypedef etrs_st *etrs_t;\n#endif\n\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a Subgroup Paillier key pair with a null value.\n *\n * @param[out] A\t\t\t- the moduli to initialize.\n */\n#define shpe_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Subgroup Paillier key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define shpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (shpe_t)calloc(1, sizeof(shpe_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->a);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->b);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->g);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->gn);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define shpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->a);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->b);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->g);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->gn);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Subgroup Paillier key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define shpe_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->a);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->b);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->g);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->gn);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tcrt_free((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define shpe_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Initializes an RSA key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define rsa_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an RSA key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define rsa_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (rsa_t)calloc(1, sizeof(_rsa_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_null((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_null((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define rsa_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tcrt_new((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free an RSA key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define rsa_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->d);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->e);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tcrt_free((A)->crt);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define rsa_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Initializes a Rabin key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define rabin_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Rabin key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#define rabin_new(A)\t\tcrt_new(A)\n\n/**\n * Calls a function to clean and free a Rabin key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#define rabin_free(A)\t\tcrt_free(A)\n\n/**\n * Initializes a Paillier key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define phpe_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Paillier key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#define phpe_new(A)\t\t\tcrt_new(A)\n\n/**\n * Calls a function to clean and free a Paillier key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#define phpe_free(A)\t\tcrt_free(A)\n\n/**\n * Initializes a Benaloh's key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define bdpe_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a Benaloh's key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define bdpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bdpe_t)calloc(1, sizeof(bdpe_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(A)->t = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bdpe_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(A)->t = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#endif\n\n/**\n * Calls a function to clean and free a Benaloh's key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define bdpe_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->n);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->p);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->q);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t(A)->t = 0;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bdpe_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a SOKAKA key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define sokaka_null(A)\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a SOKAKA key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define sokaka_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (sokaka_t)calloc(1, sizeof(sokaka_st));\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->s1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->s2);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define sokaka_new(A)\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free a SOKAKA key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define sokaka_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->s1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->s2);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define sokaka_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define bgn_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize a BGN key pair.\n *\n * @param[out] A\t\t\t- the new key pair.\n */\n#if ALLOC == DYNAMIC\n#define bgn_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (bgn_t)calloc(1, sizeof(bgn_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->gx);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->gy);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg1_new((A)->gz);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->hx);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->hy);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tg2_new((A)->hz);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define bgn_new(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free a BGN key pair.\n *\n * @param[out] A\t\t\t- the key pair to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define bgn_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->gx);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->gy);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg1_free((A)->gz);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->hx);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->hy);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tg2_free((A)->hz);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define bgn_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define ers_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an extendable signature ring.\n *\n * @param[out] A\t\t\t- the new signature ring.\n */\n#if ALLOC == DYNAMIC\n#define ers_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ers_t)calloc(1, sizeof(ers_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ers_new(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free an extendable signature ring.\n *\n * @param[out] A\t\t\t- the signature ring to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define ers_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ers_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define smlers_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an extendable signature ring.\n *\n * @param[out] A\t\t\t- the new signature ring.\n */\n#if ALLOC == DYNAMIC\n#define smlers_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (smlers_t)calloc(1, sizeof(ers_st));\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\ters_new((A)->sig);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->tau);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define smlers_new(A)\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free an extendable signature ring.\n *\n * @param[out] A\t\t\t- the signature ring to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define smlers_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\ters_free((A)->sig);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->tau);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define smlers_free(A)\t\t/* empty */\n#endif\n\n/**\n * Initializes a BGN key pair with a null value.\n *\n * @param[out] A\t\t\t- the key pair to initialize.\n */\n#define etrs_null(A)\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate and initialize an extendable signature ring.\n *\n * @param[out] A\t\t\t- the new signature ring.\n */\n#if ALLOC == DYNAMIC\n#define etrs_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (etrs_t)calloc(1, sizeof(etrs_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tec_new((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tbn_new((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define etrs_new(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free an extendable signature ring.\n *\n * @param[out] A\t\t\t- the signature ring to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define etrs_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->h);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tec_free((A)->pk);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->c[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[0]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tbn_free((A)->r[1]);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define etrs_free(A)\t\t/* empty */\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Generates a key pair for the RSA cryptosystem. Generates additional values\n * for the CRT optimization if CP_CRT is on.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits);\n\n/**\n * Encrypts using the RSA cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_enc(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t pub);\n\n/**\n * Decrypts using the RSA cryptosystem. Uses the CRT optimization if\n * CP_CRT is on.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to decrypt.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t prv);\n\n/**\n * Signs using the basic RSA signature algorithm. The flag must be non-zero if\n * the message being signed is already a hash value. Uses the CRT optimization\n * if CP_CRT is on.\n *\n * @param[out] sig\t\t\t- the signature\n * @param[out] sig_len\t\t- the number of bytes written in the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] msg_len\t\t- the number of bytes to sign.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rsa_sig(uint8_t *sig, size_t *sig_len, const uint8_t *msg,\n\t\tsize_t msg_len, int hash, const rsa_t prv);\n\n/**\n * Verifies an RSA signature. The flag must be non-zero if the message being\n * signed is already a hash value.\n *\n * @param[in] sig\t\t\t- the signature to verify.\n * @param[in] sig_len\t\t- the signature length in bytes.\n * @param[in] msg\t\t\t- the signed message.\n * @param[in] msg_len\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] pub\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_rsa_ver(uint8_t *sig, size_t sig_len, const uint8_t *msg, size_t msg_len,\n\t\tint hash, const rsa_t pub);\n\n/**\n * Generates a key pair for the Rabin cryptosystem.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key,\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rabin_gen(rabin_t pub, rabin_t prv, size_t bits);\n\n/**\n * Encrypts using the Rabin cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rabin_enc(uint8_t *out, size_t *out_len, const uint8_t *in,\n\t\tsize_t in_len, const rabin_t pub);\n\n/**\n * Decrypts using the Rabin cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to decrypt.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_rabin_dec(uint8_t *out, size_t *out_len, const uint8_t *in,\n\t\tsize_t in_len, const rabin_t prv);\n\n/**\n * Generates a key pair for Benaloh's Dense Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] block\t\t\t- the block size.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bdpe_gen(bdpe_t pub, bdpe_t prv, dig_t block, size_t bits);\n\n/**\n * Encrypts using Benaloh's cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the plaintext as a small integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bdpe_enc(uint8_t *out, size_t *out_len, dig_t in, const bdpe_t pub);\n\n/**\n * Decrypts using Benaloh's cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bdpe_dec(dig_t *out, const uint8_t *in, size_t in_len, const bdpe_t prv);\n\n/**\n * Generates a key pair for Paillier's Homomorphic Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_gen(bn_t pub, phpe_t prv, size_t bits);\n\n/**\n * Encrypts using the Paillier cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext, represented as an integer.\n * @param[in] m\t\t\t\t- the plaintext as an integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_enc(bn_t c, const bn_t m, const bn_t pub);\n\n/**\n * Evaluated a homomorphic addition using the Paillier cryptosystem.\n *\n * @param[out] r\t\t\t- the resulting ciphertext.\n * @param[in] c\t\t\t\t- the first ciphertext as an integer to multiply.\n * @param[in] d\t\t\t\t- the second ciphertext as an integer to multiply.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_add(bn_t r, const bn_t c, const bn_t d, const bn_t pub);\n\n/**\n * Decrypts using the Paillier cryptosystem.\n *\n * @param[out] m\t\t\t- the plaintext, represented as an integer.\n * @param[in] c\t\t\t\t- the ciphertex as an integer.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_phpe_dec(bn_t m, const bn_t c, const phpe_t prv);\n\n/**\n * Generates a key pair for Paillier's Subgroup Homomorphic Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] sbits\t\t\t- the subgroup order in bits.\n * @param[in] nbits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_gen(shpe_t pub, shpe_t prv, size_t sbits, size_t nbits);\n\n/**\n * Encrypts using the Subgroup Paillier cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext, represented as an integer.\n * @param[in] m\t\t\t\t- the plaintext as an integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_enc(bn_t c, const bn_t m, const shpe_t pub);\n\n/**\n * Encrypts faster using the Subgroup Paillier cryptosystem if the private key is known.\n *\n * @param[out] c\t\t\t- the ciphertext represented as an integer.\n * @param[in] m\t\t\t\t- the plaintext as an integer.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_enc_prv(bn_t c, const bn_t m, const shpe_t prv);\n\n/**\n * Decrypts using the Subgroup Paillier cryptosystem.\n *\n * @param[out] m\t\t\t- the plaintext, represented as an integer.\n * @param[in] c\t\t\t\t- the ciphertex as an integer.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_shpe_dec(bn_t m, const bn_t c, const shpe_t prv);\n\n/**\n * Generates a key pair for Genealized Homomorphic Probabilistic Encryption.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @param[in] bits\t\t\t- the key length in bits.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ghpe_gen(bn_t pub, bn_t prv, size_t bits);\n\n/**\n * Encrypts using the Generalized Paillier cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext.\n * @param[in] m\t\t\t\t- the plaintext.\n * @param[in] pub\t\t\t- the public key.\n * @param[in] s\t\t\t\t- the block length parameter.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ghpe_enc(bn_t c, const bn_t m, const bn_t pub, size_t s);\n\n/**\n * Decrypts using the Generalized Paillier cryptosystem.\n *\n * @param[out] m\t\t\t- the plaintext.\n * @param[in] c\t\t\t\t- the ciphertext.\n * @param[in] pub\t\t\t- the public key.\n * @param[in] s\t\t\t\t- the block length parameter.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ghpe_dec(bn_t m, const bn_t c, const bn_t pub, const bn_t prv, size_t s);\n\n/**\n * Generates an ECDH key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdh_gen(bn_t d, ec_t q);\n\n/**\n * Derives a shared secret using ECDH.\n *\n * @param[out] key\t\t\t- the shared key.\n * @param[int] key_len\t\t- the intended shared key length in bytes.\n * @param[in] d\t\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the point received from the other party.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdh_key(uint8_t *key, size_t key_len, const bn_t d, const ec_t q);\n\n/**\n * Generate an ECMQV key pair.\n *\n * Should also be used to generate the ephemeral key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecmqv_gen(bn_t d, ec_t q);\n\n/**\n * Derives a shared secret using ECMQV.\n *\n * @param[out] key\t\t\t- the shared key.\n * @param[int] key_len\t\t- the intended shared key length in bytes.\n * @param[in] d1\t\t\t- the private key.\n * @param[in] d2\t\t\t- the ephemeral private key.\n * @param[in] q2u\t\t\t- the ephemeral public key.\n * @param[in] q1v\t\t\t- the point received from the other party.\n * @param[in] q2v\t\t\t- the ephemeral point received from the party.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecmqv_key(uint8_t *key, size_t key_len, const bn_t d1, const bn_t d2,\n\t\tconst ec_t q2u, const ec_t q1v, const ec_t q2v);\n\n/**\n * Generates an ECIES key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecies_gen(bn_t d, ec_t q);\n\n/**\n * Encrypts using the ECIES cryptosystem.\n *\n * @param[out] r\t\t\t- the resulting elliptic curve point.\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] iv\t\t\t- the block cipher initialization vector.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecies_enc(ec_t r, uint8_t *out, size_t *out_len, const uint8_t *in,\n\t\tsize_t in_len, const ec_t q);\n\n/**\n * Decrypts using the ECIES cryptosystem.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] iv\t\t\t- the block cipher initialization vector.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecies_dec(uint8_t *out, size_t *out_len, const ec_t r, const uint8_t *in,\n\t\tsize_t in_len, const bn_t d);\n\n/**\n * Generates an ECDSA key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdsa_gen(bn_t d, ec_t q);\n\n/**\n * Signs a message using ECDSA.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecdsa_sig(bn_t r, bn_t s, const uint8_t *msg, size_t len, int hash,\n\t\tconst bn_t d);\n\n/**\n * Verifies a message signed with ECDSA using the basic method.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] q\t\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_ecdsa_ver(const bn_t r, const bn_t s, const uint8_t *msg, size_t len,\n\t\tint hash, const ec_t q);\n\n/**\n * Generates an Elliptic Curve Schnorr Signature key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[in] q\t\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecss_gen(bn_t d, ec_t q);\n\n/**\n * Signs a message using the Elliptic Curve Schnorr Signature.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ecss_sig(bn_t e, bn_t s, const uint8_t *msg, size_t len, const bn_t d);\n\n/**\n * Verifies a message signed with the Elliptic Curve Schnorr Signature using the\n * basic method.\n *\n * @param[out] r\t\t\t- the first component of the signature.\n * @param[out] s\t\t\t- the second component of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] q\t\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_ecss_ver(bn_t e, bn_t s, const uint8_t *msg, size_t len, const ec_t q);\n\n/**\n * Generate parameters for the DCKKS pairing delegation protocol described at\n * \"Secure and Efficient Delegationof Pairings with Online Inputs\" (CARDIS 2020)\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdpub_gen(bn_t c, bn_t r, g1_t u1, g2_t u2, g2_t v2, gt_t e);\n\n/**\n * Execute the client-side request for the DCKKS pairing delegation protocol.\n *\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdpub_ask(g1_t v1, g2_t w2, const g1_t p, const g2_t q, const bn_t c,\n\t\tconst bn_t r, const g1_t u1, const g2_t u2, const g2_t v2);\n\n/**\n * Execute the server-side response for the DCKKS pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdpub_ans(gt_t g[3], const g1_t p, const g2_t q, const g1_t v1,\n\t\tconst g2_t v2, const g2_t w2);\n\n/**\n * Verifies the result of the DCKKS pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_pdpub_ver(gt_t r, const gt_t g[3], const bn_t c, const gt_t e);\n\n/**\n * Generate parameters for the DCKKS pairing delegation protocol described at\n * \"Secure and Efficient Delegationof Pairings with Online Inputs\" (CARDIS 2020)\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdprv_gen(bn_t c, bn_t r[3], g1_t u1[2], g2_t u2[2], g2_t v2[4],\n\t\tgt_t e[2]);\n\n/**\n * Execute the client-side request for the DCKKS pairing delegation protocol.\n *\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdprv_ask(g1_t v1[3], g2_t w2[4], const g1_t p, const g2_t q,\n\t\tconst bn_t c, const bn_t r[3], const g1_t u1[2], const g2_t u2[2],\n\t\tconst g2_t v2[4]);\n\n/**\n * Execute the server-side response for the DCKKS pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pdprv_ans(gt_t g[4], const g1_t v1[3], const g2_t w2[4]);\n\n/**\n * Verifies the result of the DCKKS pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_pdprv_ver(gt_t r, const gt_t g[4], const bn_t c, const gt_t e[2]);\n\n/**\n * Generate parameters for the LOVE pairing delegation protocol with public\n * inputs.\n *\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvpub_gen(bn_t r, g1_t u1, g2_t u2, g2_t v2, gt_t e);\n\n/**\n * Execute the client-side request for the LOVE pairing delegation protocol.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvpub_ask(bn_t c, g1_t v1, g2_t w2, const g1_t p, const g2_t q,\n\t\tconst bn_t r, const g1_t u1, const g2_t u2, const g2_t v2);\n\n/**\n * Execute the server-side response for the LOVE pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvpub_ans(gt_t g[2], const g1_t p, const g2_t q, const g1_t v1,\n\t\tconst g2_t v2, const g2_t w2);\n\n/**\n * Verifies the result of the LOVE pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_lvpub_ver(gt_t r, const gt_t g[2], const bn_t c, const gt_t e);\n\n/**\n * Generate parameters for the LOVE pairing delegation protocol with private\n * inputs.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the randomness.\n * @param[out] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[out] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[out] v2\t\t\t- the image of the randomness in G_2.\n * @param[out] e\t\t\t- the precomputed values e(U1, U2).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvprv_gen(bn_t c, bn_t r[3], g1_t u1[2], g2_t u2[2], g2_t v2[4],\n\t\tgt_t e[2]);\n\n/**\n * Execute the client-side request for the LOVE pairing delegation protocol.\n *\n * @param[out] v1\t\t\t- the blinded element in G_1.\n * @param[out] w2\t\t\t- the blinded element in G_2.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the randomness.\n * @param[in] u1\t\t\t- the U1 precomputed value in G_1.\n * @param[in] u2\t\t\t- the U2 precomputed value in G_2.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvprv_ask(g1_t v1[3], g2_t w2[4], const g1_t p, const g2_t q,\n\t\tconst bn_t c, const bn_t r[3], const g1_t u1[2], const g2_t u2[2],\n\t\tconst g2_t v2[4]);\n\n/**\n * Execute the server-side response for the LOVE pairing delegation protocol.\n *\n * @param[out] g\t\t\t- the group elements computed by the server.\n * @param[in] p\t\t\t\t- the first argument of the pairing.\n * @param[in] q\t\t\t\t- the second argument of the pairing.\n * @param[in] v1\t\t\t- the blinded element in G_1.\n * @param[in] v2\t\t\t- the image of the randomness in G_2.\n * @param[in] w2\t\t\t- the blinded element in G_2.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_lvprv_ans(gt_t g[4], const g1_t v1[3], const g2_t w2[4]);\n\n/**\n * Verifies the result of the LOVE pairing delegation protocol.\n *\n * @param[out] r\t\t\t- the result of the computation.\n * @param[in] g\t\t\t\t- the group elements returned by the server.\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] e\t\t\t\t- the precomputed values e(U1, U2).\n * @return a boolean value indicating if the computation is correct.\n */\nint cp_lvprv_ver(gt_t r, const gt_t g[4], const bn_t c, const gt_t e[2]);\n\n/**\n * Generates a master key for the SOKAKA identity-based non-interactive\n * authenticated key agreement protocol.\n *\n * @param[out] master\t\t\t- the master key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokaka_gen(bn_t master);\n\n/**\n * Generates a private key for the SOKAKA protocol.\n *\n * @param[out] k\t\t\t- the private key.\n * @param[in] id\t\t\t- the identity.\n * @param[in] master\t\t- the master key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokaka_gen_prv(sokaka_t k, const char *id, bn_t master);\n\n/**\n * Computes a shared key between two entities.\n *\n * @param[out] key\t\t\t- the shared key.\n * @param[int] key_len\t\t- the intended shared key length in bytes.\n * @param[in] id1\t\t\t- the first identity.\n * @param[in] k\t\t\t\t- the private key of the first identity.\n * @param[in] id2\t\t\t- the second identity.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokaka_key(uint8_t *key, size_t key_len, const char *id1,\n\t\tconst sokaka_t k, const char *id2);\n\n/**\n * Generates a key pair for the Boneh-Go-Nissim (BGN) cryptosystem.\n *\n * @param[out] pub\t\t\t- the public key.\n * @param[out] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_gen(bgn_t pub, bgn_t prv);\n\n/**\n * Encrypts in G_1 using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the ciphertext.\n * @param[in] in\t\t\t- the plaintext as a small integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_enc1(g1_t out[2], const dig_t in, const bgn_t pub);\n\n/**\n * Decrypts in G_1 using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] in\t\t\t- the ciphertext.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_dec1(dig_t *out, const g1_t in[2], const bgn_t prv);\n\n/**\n * Encrypts in G_2 using the BGN cryptosystem.\n *\n * @param[out] c\t\t\t- the ciphertext.\n * @param[in] m\t\t\t\t- the plaintext as a small integer.\n * @param[in] pub\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_enc2(g2_t out[2], const dig_t in, const bgn_t pub);\n\n/**\n * Decrypts in G_2 using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] c\t\t\t\t- the ciphertext.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_dec2(dig_t *out, const g2_t in[2], const bgn_t prv);\n\n/**\n * Adds homomorphically two BGN ciphertexts in G_T.\n *\n * @param[out] e\t\t\t- the resulting ciphertext.\n * @param[in] c\t\t\t\t- the first ciphertext to add.\n * @param[in] d\t\t\t\t- the second ciphertext to add.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_add(gt_t e[4], const gt_t c[4], const gt_t d[4]);\n\n/**\n * Multiplies homomorphically two BGN ciphertexts in G_T.\n *\n * @param[out] e\t\t\t- the resulting ciphertext.\n * @param[in] c\t\t\t\t- the first ciphertext to add.\n * @param[in] d\t\t\t\t- the second ciphertext to add.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_mul(gt_t e[4], const g1_t c[2], const g2_t d[2]);\n\n/**\n * Decrypts in G_T using the BGN cryptosystem.\n *\n * @param[out] out\t\t\t- the decrypted small integer.\n * @param[in] c\t\t\t\t- the ciphertext.\n * @param[in] prv\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bgn_dec(dig_t *out, const gt_t in[4], const bgn_t prv);\n\n/**\n * Generates a master key for a Private Key Generator (PKG) in the\n * Boneh-Franklin Identity-Based Encryption (BF-IBE).\n *\n * @param[out] master\t\t- the master key.\n * @param[out] pub\t\t\t- the public key of the private key generator.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_gen(bn_t master, g1_t pub);\n\n/**\n * Generates a private key for a user in the BF-IBE protocol.\n *\n * @param[out] prv\t\t\t- the private key.\n * @param[in] id\t\t\t- the identity.\n * @param[in] s\t\t\t\t- the master key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_gen_prv(g2_t prv, const char *id, const bn_t master);\n\n/**\n * Encrypts a message using the BF-IBE protocol.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to encrypt.\n * @param[in] id\t\t\t- the identity.\n * @param[in] pub\t\t\t- the public key of the PKG.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_enc(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst char *id, const g1_t pub);\n\n/**\n * Decrypts a message using the BF-IBE protocol.\n *\n * @param[out] out\t\t\t- the output buffer.\n * @param[in, out] out_len\t- the buffer capacity and number of bytes written.\n * @param[in] in\t\t\t- the input buffer.\n * @param[in] in_len\t\t- the number of bytes to decrypt.\n * @param[in] pub\t\t\t- the private key of the user.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_ibe_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst g2_t prv);\n\n/**\n * Generates a key pair for the Boneh-Lynn-Schacham (BLS) signature protocol.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bls_gen(bn_t d, g2_t q);\n\n/**\n * Signs a message using the BLS protocol.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bls_sig(g1_t s, const uint8_t *msg, size_t len, const bn_t d);\n\n/**\n * Verifies a message signed with BLS protocol.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] q\t\t\t\t- the public key.\n * @return a boolean value indicating if the signature is valid.\n */\nint cp_bls_ver(const g1_t s, const uint8_t *msg, size_t len, const g2_t q);\n\n/**\n * Generates a key pair for the Boneh-Boyen (BB) signature protocol.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bbs_gen(bn_t d, g2_t q, gt_t z);\n\n/**\n * Signs a message using the BB protocol.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_bbs_sig(g1_t s, const uint8_t *msg, size_t len, int hash, const bn_t d);\n\n/**\n * Verifies a message signed with the BB protocol.\n *\n * @param[in] s\t\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_bbs_ver(g1_t s, const uint8_t *msg, size_t len, int hash, const g2_t q,\n\t\tconst gt_t z);\n\n/**\n * Generates a key pair for the Camenisch-Lysyanskaya simple signature (CLS)\n * protocol.\n *\n * @param[out] u\t\t\t- the first part of the private key.\n * @param[out] v\t\t\t- the second part of the private key.\n * @param[out] x\t\t\t- the first part of the public key.\n * @param[out] y\t\t\t- the second part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cls_gen(bn_t u, bn_t v, g2_t x, g2_t y);\n\n/**\n * Signs a message using the CLS protocol.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[out] c\t\t\t- the third part of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] u\t\t\t\t- the first part of the private key.\n * @param[in] v\t\t\t\t- the second part of the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cls_sig(g1_t a, g1_t b, g1_t c, const uint8_t *msg, size_t len,\n\t\tconst bn_t u, const bn_t v);\n\n/**\n ** Verifies a signature using the CLS protocol.\n *\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] c\t\t\t\t- the third part of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] u\t\t\t\t- the first part of the public key.\n * @param[in] v\t\t\t\t- the second part of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_cls_ver(const g1_t a, const g1_t b, const g1_t c, const uint8_t *msg,\n\t\tsize_t len, const g2_t x, const g2_t y);\n\n/**\n * Generates a key pair for the Camenisch-Lysyanskaya message-independent (CLI)\n * signature protocol.\n *\n * @param[out] t\t\t\t- the first part of the private key.\n * @param[out] u\t\t\t- the second part of the private key.\n * @param[out] v\t\t\t- the third part of the private key.\n * @param[out] x\t\t\t- the first part of the public key.\n * @param[out] y\t\t\t- the second part of the public key.\n * @param[out] z\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cli_gen(bn_t t, bn_t u, bn_t v, g2_t x, g2_t y, g2_t z);\n\n/**\n * Signs a message using the CLI protocol.\n *\n * @param[out] a\t\t\t- one of the components of the signature.\n * @param[out] A\t\t\t- one of the components of the signature.\n * @param[out] b\t\t\t- one of the components of the signature.\n * @param[out] B\t\t\t- one of the components of the signature.\n * @param[out] c\t\t\t- one of the components of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] r\t\t\t\t- the per-message randomness.\n * @param[in] t\t\t\t\t- the first part of the private key.\n * @param[in] u\t\t\t\t- the second part of the private key.\n * @param[in] v\t\t\t\t- the third part of the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cli_sig(g1_t a, g1_t A, g1_t b, g1_t B, g1_t c, const uint8_t *msg,\n\t\tsize_t len, const bn_t r, const bn_t t, const bn_t u, const bn_t v);\n\n/**\n * Verifies a message signed using the CLI protocol.\n *\n * @param[in] a\t\t\t\t- one of the components of the signature.\n * @param[in] A\t\t\t\t- one of the components of the signature.\n * @param[in] b\t\t\t\t- one of the components of the signature.\n * @param[in] B\t\t\t\t- one of the components of the signature.\n * @param[in] c\t\t\t\t- one of the components of the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] r\t\t\t\t- the per-message randomness.\n * @param[in] x\t\t\t\t- the first part of the public key.\n * @param[in] y\t\t\t\t- the second part of the public key.\n * @param[in] z\t\t\t\t- the third part of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_cli_ver(g1_t a, g1_t A, g1_t b, g1_t B, g1_t c, const uint8_t *msg,\n\t\tsize_t len, const bn_t r, const g2_t x, const g2_t y, const g2_t z);\n\n/**\n * Generates a key pair for the Camenisch-Lysyanskaya message-block (CLB)\n * signature protocol.\n *\n * @param[out] t\t\t\t- the first part of the private key.\n * @param[out] u\t\t\t- the second part of the private key.\n * @param[out] v\t\t\t- the remaining (l - 1) parts of the private key.\n * @param[out] x\t\t\t- the first part of the public key.\n * @param[out] y\t\t\t- the second part of the public key.\n * @param[out] z\t\t\t- the remaining (l - 1) parts of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_clb_gen(bn_t t, bn_t u, bn_t v[], g2_t x, g2_t y, g2_t z[], size_t l);\n\n/**\n * Signs a block of messages using the CLB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] A\t\t\t- the (l - 1) next components of the signature.\n * @param[out] b\t\t\t- the next component of the signature.\n * @param[out] B\t\t\t- the (l - 1) next components of the signature.\n * @param[out] c\t\t\t- the last component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] ls\t\t\t- the l message lengths in bytes.\n * @param[in] t\t\t\t\t- the first part of the private key.\n * @param[in] u\t\t\t\t- the second part of the private key.\n * @param[in] v\t\t\t\t- the remaining (l - 1) parts of the private key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_clb_sig(g1_t a, g1_t A[], g1_t b, g1_t B[], g1_t c, const uint8_t *ms[],\n\t\tconst size_t ls[], const bn_t t, const bn_t u, const bn_t v[],\n\t\tconst size_t l);\n\n/**\n * Verifies a block of messages signed using the CLB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] A\t\t\t- the (l - 1) next components of the signature.\n * @param[out] b\t\t\t- the next component of the signature.\n * @param[out] B\t\t\t- the (l - 1) next components of the signature.\n * @param[out] c\t\t\t- the last component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] ls\t\t\t- the l message lengths in bytes.\n * @param[in] x\t\t\t\t- the first part of the public key.\n * @param[in] y\t\t\t\t- the second part of the public key.\n * @param[in] z\t\t\t\t- the remaining (l - 1) parts of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return a boolean value indicating the verification result.\n */\nint cp_clb_ver(const g1_t a, const g1_t A[], const g1_t b, const g1_t B[],\n \t\tconst g1_t c, const uint8_t *ms[], const size_t ls[], const g2_t x,\n \t\tconst g2_t y, const g2_t z[], size_t l);\n\n/**\n * Generates a key pair for the Pointcheval-Sanders simple signature (PSS)\n * protocol.\n *\n * @param[out] u\t\t\t- the first part of the private key.\n * @param[out] v\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the secpmd part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pss_gen(bn_t u, bn_t v, g2_t g, g2_t x, g2_t y);\n\n/**\n * Signs a message using the PSS protocol.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] u\t\t\t\t- the first part of the private key.\n * @param[in] v\t\t\t\t- the second part of the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pss_sig(g1_t a, g1_t b, const bn_t m, const bn_t u, const bn_t v);\n\n/**\n ** Verifies a signature using the PSS protocol.\n *\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] u\t\t\t\t- the second part of the public key.\n * @param[in] v\t\t\t\t- the third part of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_pss_ver(const g1_t a, const g1_t b, const bn_t m, const g2_t g,\n\t\tconst g2_t x, const g2_t y);\n\n/**\n * Generates a key pair for the multi-part version of the Pointcheval-Sanders\n * simple signature (MPSS) protocol.\n *\n * @param[out] r\t\t\t- the first part of the private key.\n * @param[out] s\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the second part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpss_gen(bn_t r[2], bn_t s[2], g2_t g, g2_t x[2], g2_t y[2]);\n\n/**\n * Signs a message using the MPSS protocol operating over shares using triples.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] r\t\t\t\t- the first part of the private key.\n * @param[in] s\t\t\t\t- the second part of the private key.\n * @param[in] mul_tri\t\t- the triple for the multiplication.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpss_sig(g1_t a, g1_t b[2], const bn_t m[2], const bn_t r[2],\n\t\tconst bn_t s[2], const mt_t mul_tri[2], const mt_t sm_tri[2]);\n\n/**\n * Opens public values in the MPSS protocols, in this case public keys.\n *\n * @param[in,out] x\t\t\t- the shares of the second part of the public key.\n * @param[in,out] y\t\t\t- the shares of the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpss_bct(g2_t x[2], g2_t y[2]);\n\n/**\n * Verifies a signature using the MPSS protocol operating over shares using\n * triples.\n *\n * @param[out] e\t\t\t- the result of the verification.\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] x\t\t\t\t- the second part of the public key.\n * @param[in] y\t\t\t\t- the third part of the public key.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @param[in] pc_tri\t\t- the triple for the pairing computation.\n * @return a boolean value indicating the verification result.\n */\nint cp_mpss_ver(gt_t e, const g1_t a, const g1_t b[2], const bn_t m[2],\n\t\tconst g2_t h, const g2_t x, const g2_t y, const mt_t sm_tri[2],\n\t\tconst pt_t pc_tri[2]);\n\n/**\n * Generates a key pair for the Pointcheval-Sanders block signature (PSB)\n * protocol.\n *\n * @param[out] r\t\t\t- the first part of the private key.\n * @param[out] s\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the secpmd part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_psb_gen(bn_t r, bn_t s[], g2_t g, g2_t x, g2_t y[], size_t l);\n\n/**\n * Signs a block of messages using the PSB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] b\t\t\t- the second component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] r\t\t\t\t- the first part of the private key.\n * @param[in] s\t\t\t\t- the remaining l part of the private key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_psb_sig(g1_t a, g1_t b, const bn_t ms[], const bn_t r, const bn_t s[],\n\t\tsize_t l);\n\n/**\n * Verifies a block of messages signed using the PSB protocol.\n *\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] b\t\t\t- the seconed component of the signature.\n * @param[in] ms\t\t\t- the l messages to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] x\t\t\t\t- the second part of the public key.\n * @param[in] y\t\t\t\t- the remaining l parts of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return a boolean value indicating the verification result.\n */\nint cp_psb_ver(const g1_t a, const g1_t b, const bn_t ms[], const g2_t g,\n\t\tconst g2_t x, const g2_t y[], size_t l);\n\n/**\n * Generates a key pair for the multi-part version of the Pointcheval-Sanders\n * simple signature (MPSS) protocol.\n *\n * @param[out] r\t\t\t- the first part of the private key.\n * @param[out] s\t\t\t- the second part of the private key.\n * @param[out] g\t\t\t- the first part of the public key.\n * @param[out] x\t\t\t- the second part of the public key.\n * @param[out] y\t\t\t- the third part of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpsb_gen(bn_t r[2], bn_t s[][2], g2_t h, g2_t x[2], g2_t y[][2],\n\t\tsize_t l);\n\n/**\n * Signs a message using the MPSS protocol operating over shares using triples.\n *\n * @param[out] a\t\t\t- the first part of the signature.\n * @param[out] b\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the messages to sign.\n * @param[in] r\t\t\t\t- the first part of the private key.\n * @param[in] s\t\t\t\t- the second parts of the private key.\n * @param[in] mul_tri\t\t- the triple for the multiplication.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpsb_sig(g1_t a, g1_t b[2], const bn_t m[][2], const bn_t r[2],\n\t\tconst bn_t s[][2], const mt_t mul_tri[2], const mt_t sm_tri[2],\n\t\tsize_t l);\n\n/**\n * Opens public values in the MPSS protocols, in this case public keys.\n *\n * @param[in,out] x\t\t\t- the shares of the second part of the public key.\n * @param[in,out] y\t\t\t- the shares of the third part of the public key.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mpsb_bct(g2_t x[2], g2_t y[][2], size_t l);\n\n/**\n * Verifies a signature using the MPSS protocol operating over shares using\n * triples.\n *\n * @param[out] e\t\t\t- the result of the verification.\n * @param[in] a\t\t\t\t- the first part of the signature.\n * @param[in] b\t\t\t\t- the second part of the signature.\n * @param[in] m\t\t\t\t- the messages to sign.\n * @param[in] g\t\t\t\t- the first part of the public key.\n * @param[in] x\t\t\t\t- the second part of the public key.\n * @param[in] y\t\t\t\t- the third parts of the public key.\n * @param[in] sm_tri\t\t- the triple for the scalar multiplication.\n * @param[in] pc_tri\t\t- the triple for the pairing computation.\n * @param[in] v\t\t\t\t- the private keys, can be NULL.\n * @param[in] l\t\t\t\t- the number of messages to sign.\n * @return a boolean value indicating the verification result.\n */\nint cp_mpsb_ver(gt_t e, const g1_t a, const g1_t b[2], const bn_t m[][2],\n\t\tconst g2_t h, const g2_t x, const g2_t y[][2], const bn_t v[][2],\n\t\tconst mt_t sm_tri[2], const pt_t pc_tri[2], size_t l);\n\n/**\n * Generates a Zhang-Safavi-Naini-Susilo (ZSS) key pair.\n *\n * @param[out] d\t\t\t- the private key.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n */\nint cp_zss_gen(bn_t d, g1_t q, gt_t z);\n\n/**\n * Signs a message using ZSS scheme.\n *\n * @param[out] s\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[in] d\t\t\t\t- the private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_zss_sig(g2_t s, const uint8_t *msg, size_t len, int hash, const bn_t d);\n\n/**\n * Verifies a message signed with ZSS scheme.\n *\n * @param[in] s\t\t\t\t- the signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length in bytes.\n * @param[in] hash\t\t\t- the flag to indicate the message format.\n * @param[out] q\t\t\t- the first component of the public key.\n * @param[out] z\t\t\t- the second component of the public key.\n * @return a boolean value indicating the verification result.\n */\nint cp_zss_ver(const g2_t s, const uint8_t *msg, size_t len, int hash,\n\t\tconst g1_t q, const gt_t z);\n\n/**\n * Generates a vBNN-IBS key generation center (KGC).\n *\n * @param[out] msk\t\t\t- the KGC master key.\n * @param[out] mpk\t\t\t- the KGC public key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_gen(bn_t msk, ec_t mpk);\n\n/**\n * Extract a user key from an identity and a vBNN-IBS key generation center.\n *\n * @param[out] sk\t\t\t- the extracted vBNN-IBS user private key.\n * @param[out] pk\t\t\t- the extracted vBNN-IBS user public key.\n * @param[in] msk\t\t\t- the KGC master key.\n * @param[in] id\t\t\t- the identity used for extraction.\n * @param[in] id_len\t\t- the identity length in bytes.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,\n\t\tsize_t id_len);\n\n/**\n * Signs a message using the vBNN-IBS scheme.\n *\n * @param[out] r\t\t\t- the R value of the signature.\n * @param[out] z\t\t\t- the z value of the signature.\n * @param[out] h\t\t\t- the h value of the signature.\n * @param[in] id\t\t\t- the identity buffer.\n * @param[in] id_len\t\t- the size of identity buffer.\n * @param[in] msg\t\t\t- the message buffer to sign.\n * @param[in] msg_len\t\t- the size of message buffer.\n * @param[in] sk\t\t\t- the signer private key.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,\n\t\tconst uint8_t *msg, int msg_len, const bn_t sk, const ec_t pk);\n\n/**\n * Verifies a signature and message using the vBNN-IBS scheme.\n *\n * @param[in] r\t\t\t\t- the R value of the signature.\n * @param[in] z\t\t\t\t- the z value of the signature.\n * @param[in] h\t\t\t\t- the h value of the signature.\n * @param[in] id\t\t\t- the identity buffer.\n * @param[in] id_len\t\t- the size of identity buffer.\n * @param[in] msg\t\t\t- the message buffer to sign.\n * @param[in] msg_len\t\t- the size of message buffer.\n * @param[in] mpk\t\t\t- the master public key of the generation center.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_vbnn_ver(const ec_t r, const bn_t z, const bn_t h, const uint8_t *id,\n\t\tsize_t id_len, const uint8_t *msg, int msg_len, const ec_t mpk);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y = [x]G.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the response.\n * @param[in] y\t\t\t\t- the elliptic curve point\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pokdl_prv(bn_t c, bn_t r, const ec_t y, const bn_t x);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the response.\n * @param[in] y\t\t\t\t- the elliptic curve point.\n * @return a boolean value indicating the verification result.\n */\nint cp_pokdl_ver(const bn_t c, const bn_t r, const ec_t y);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y0 = [x]G or y[1] = [x]G.\n *\n * @param[out] c\t\t\t- the challenges.\n * @param[out] r\t\t\t- the responses.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_pokor_prv(bn_t c[2], bn_t r[2], const ec_t y[2], const bn_t x);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenges.\n * @param[in] r\t\t\t\t- the responses.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @return a boolean value indicating the verification result.\n */\nint cp_pokor_ver(const bn_t c[2], const bn_t r[2], const ec_t y[2]);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y = [x]G.\n *\n * @param[out] c\t\t\t- the challenge.\n * @param[out] r\t\t\t- the response.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve point\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokdl_sig(bn_t c, bn_t r, const uint8_t *msg, size_t len, const ec_t y,\n\t\tconst bn_t x);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenge.\n * @param[in] r\t\t\t\t- the response.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve point.\n * @return a boolean value indicating the verification result.\n */\nint cp_sokdl_ver(const bn_t c, const bn_t r, const uint8_t *msg, size_t len,\n\t\tconst ec_t y);\n\n/**\n * Computes the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Proves that y0 = [x]G or y1 = [x]G.\n *\n * @param[out] c\t\t\t- the challenges.\n * @param[out] r\t\t\t- the responses.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @param[in] g\t\t\t\t- the elliptic curve generators.\n * @param[in] x\t\t\t\t- the discrete logarithm to prove.\n * @param[in] first\t\t\t- the flag to indicate the point for which the\n *\t\t\t\t\t\t\t  discrete logarithm is known.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_sokor_sig(bn_t c[2], bn_t r[2], const uint8_t *msg, size_t len,\n\t\tconst ec_t y[2], const ec_t g[2], const bn_t x, int first);\n\n/**\n * Verifies the proof of knowledge of a discrete logarithm of an elliptic curve\n * point to a generator. Verifies that y = [x]G.\n *\n * @param[in] c\t\t\t\t- the challenges.\n * @param[in] r\t\t\t\t- the responses.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the length of the message.\n * @param[in] y\t\t\t\t- the elliptic curve points.\n * @param[in] g\t\t\t\t- the elliptic curve generators.\n * @return a boolean value indicating the verification result.\n */\nint cp_sokor_ver(const bn_t c[2], const bn_t r[2], const uint8_t *msg,\n\t\tsize_t len, const ec_t y[2], const ec_t g[2]);\n\n/**\n * Generates the public parameters of the extendable ring signature.\n *\n * @\u00e5aram[out] pp\t\t\t- the public parameters.\n */\nint cp_ers_gen(ec_t pp);\n\n/**\n * Generates a key pair for the extendable ring signature.\n *\n * @\u00e5aram[out] sk\t\t\t- the private key.\n * @param[out] pk\t\t\t- the public key.\n */\nint cp_ers_gen_key(bn_t sk, ec_t pk);\n\n/**\n * Signs a message using the extendable ring signature scheme.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[out] p\t\t\t- the resulting signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_ers_sig(bn_t td, ers_t p, const uint8_t *msg, size_t len, const bn_t sk,\n\t\tconst ec_t pk, const ec_t pp);\n\n/**\n * Verifies an extendable ring signature scheme over some messages.\n *\n * @param[in] td\t\t\t- the signature trapdoor.\n * @param[in] s\n - the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_ers_ver(const bn_t td, const ers_t *s, size_t size, const uint8_t *msg,\n\t\tsize_t len, const ec_t pp);\n\n/**\n * Extends an extendable ring signature with a new signature.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_ers_ext(bn_t td, ers_t *p, size_t *size, const uint8_t *msg, size_t len,\n\t\tconst ec_t pk, const ec_t pp);\n\n/**\n * Signs a message using the same-message linkable extendable ring signature\n * scheme.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[out] p\t\t\t- the resulting signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_smlers_sig(bn_t td, smlers_t p, const uint8_t *msg, size_t len,\n\t\tconst bn_t sk, const ec_t pk, const ec_t pp);\n\n/**\n * Verifies a same-message linkable extendable ring signature.\n *\n * @param[in] td\t\t\t- the signature trapdoor.\n * @param[in] s\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_smlers_ver(bn_t td, smlers_t *s, size_t size, const uint8_t *msg,\n\t\tsize_t len, const ec_t pp);\n\n/**\n * Extends a same-message extendable ring signature with a new signature.\n *\n * @param[out] td\t\t\t- the signature trapdoor.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parameters.\n */\nint cp_smlers_ext(bn_t td, smlers_t *p, size_t *size, const uint8_t *msg,\n\t\tsize_t len, const ec_t pk, const ec_t pp);\n\n/**\n * Signs a message using the extendable threshold ring signature scheme.\n *\n * @param[out] td\t\t\t- the signature trapdoors.\n * @param[out] y\t\t\t- the signature randomness.\n * @param[out] max\t\t\t- the maximum number of extensions.\n * @param[out] p\t\t\t- the resulting signature.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_sig(bn_t *td, bn_t *y, size_t max, etrs_t p, const uint8_t *msg,\n\t\tsize_t len, const bn_t sk, const ec_t pk, const ec_t pp);\n\n/**\n * Verifies an extendable threshold ring signature scheme over some messages.\n *\n * @param[in] thres\t\t\t- the specified threshold.\n * @param[in] td\t\t\t- the signature trapdoors.\n * @param[in] y\t\t\t\t- the signature randomness.\n * @param[in] max\t\t\t- the maximum number of extensions.\n * @param[in] s\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_ver(size_t thres, const bn_t *td, const bn_t *y, size_t max,\n\t\tconst etrs_t *s, size_t size, const uint8_t *msg, size_t len,\n\t\tconst ec_t pp);\n\n/**\n * Extends an extendable threshold ring signature with a new signature.\n *\n * @param[out] td\t\t\t- the signature trapdoors.\n * @param[in] y\t\t\t\t- the signature randomness.\n * @param[in] max\t\t\t- the maximum number of extensions.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_ext(bn_t *td, bn_t *y, size_t max, etrs_t *p, size_t *size,\n\t\tconst uint8_t *msg, size_t len, const ec_t pk, const ec_t pp);\n/**\n * Joins an extendable threshold ring signature with a new signature.\n *\n * @param[in] thres\t\t\t- the specified threshold.\n * @param[in] td\t\t\t- the signature trapdoors.\n * @param[in] y\t\t\t\t- the signature randomness.\n * @param[in] max\t\t\t- the maximum number of extensions.\n * @param[in] p\t\t\t\t- the ring of signatures.\n * @param[in] size\t\t\t- the number of signatures in the ring.\n * @param[in] msg\t\t\t- the message to sign.\n * @param[in] len\t\t\t- the message length.\n * @param[in] sk\t\t\t- the signer's private key.\n * @param[in] pk\t\t\t- the singer's public key.\n * @param[in] pp\t\t\t- the public parametetrs.\n */\nint cp_etrs_uni(int thres, bn_t *td, bn_t *y, int max, etrs_t *p, size_t *size,\n\t\tconst uint8_t *msg, size_t len, const bn_t sk, const ec_t pk,\n\t\tconst ec_t pp);\n/**\n * Initialize the Context-hiding Multi-key Homomorphic Signature scheme (CMLHS).\n * The scheme due to Schabhuser et al. signs a vector of messages.\n *\n * @param[out] h\t\t\t- the random element (message as one component).\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_init(g1_t h);\n\n/**\n * Generates a key pair for the CMLHS scheme using BLS as underlying signature.\n *\n * @param[out] x\t\t\t- the exponent values, one per label.\n * @param[out] hs\t\t\t- the hash values, one per label.\n * @param[in] len\t\t\t- the number of possible labels.\n * @param[out] prf\t\t\t- the key for the pseudo-random function (PRF).\n * @param[out] plen\t\t\t- the PRF key length.\n * @param[out] sk\t\t\t- the private key for the BLS signature scheme.\n * @param[out] pk\t\t\t- the public key for the BLS signature scheme.\n * @param[out] d\t\t\t- the secret exponent.\n * @param[out] y\t\t\t- the corresponding public element.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,\n\t\tbn_t sk, g2_t pk, bn_t d, g2_t y, int bls);\n\n/**\n * Signs a message vector using the CMLHS.\n *\n * @param[out] sig\t\t\t- the resulting BLS signature.\n * @param[out] z\t\t\t- the power of the output of the PRF.\n * @param[out] a\t\t\t- the first component of the signature.\n * @param[out] c\t\t\t- the second component of the signature.\n * @param[out] r\t\t\t- the third component of the signature.\n * @param[out] s\t\t\t- the fourth component of the signature.\n * @param[in] msg\t\t\t- the message vector to sign (one component).\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] label\t\t\t- the integer label.\n * @param[in] x\t\t\t\t- the exponent value for the label.\n * @param[in] h\t\t\t\t- the random value (message has one component).\n * @param[in] prf\t\t\t- the key for the pseudo-random function (PRF).\n * @param[in] plen\t\t\t- the PRF key length.\n * @param[in] sk\t\t\t- the private key for the signature scheme.\n * @param[in] d\t\t\t\t- the secret exponent.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_sig(g1_t sig, g2_t z, g1_t a, g1_t c, g1_t r, g2_t s,\n\t\tconst bn_t msg, const char *data, int label, const bn_t x, const g1_t h,\n\t\tconst uint8_t prf[], size_t plen, const bn_t sk, const bn_t d, int bls);\n\n/**\n * Applies a function over a set of CMLHS signatures from the same user.\n *\n * @param[out] a\t\t\t- the resulting first component of the signature.\n * @param[out] c\t\t\t- the resulting second component of the signature.\n * @param[in] as\t\t\t- the vector of first components of the signatures.\n * @param[in] cs\t\t\t- the vector of second components of the signatures.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_fun(g1_t a, g1_t c, const g1_t as[], const g1_t cs[],\n\t\tconst dig_t f[], size_t len);\n\n/**\n * Evaluates a function over a set of CMLHS signatures.\n *\n * @param[out] r\t\t\t- the resulting third component of the signature.\n * @param[out] s\t\t\t- the resulting fourth component of the signature.\n * @param[in] rs\t\t\t- the vector of third components of the signatures.\n * @param[in] ss\t\t\t- the vector of fourth components of the signatures.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_cmlhs_evl(g1_t r, g2_t s, const g1_t rs[], const g2_t ss[],\n\t\tconst dig_t f[], size_t len);\n\n/**\n * Verifies a CMLHS signature over a set of messages.\n *\n * @param[in] r\t\t\t\t- the first component of the homomorphic signature.\n * @param[in] s\t\t\t\t- the second component of the homomorphic signature.\n * @param[in] sig\t\t\t- the BLS signatures.\n * @param[in] z\t\t\t\t- the powers of the outputs of the PRF.\n * @param[in] a\t\t\t\t- the vector of first components of the signatures.\n * @param[in] c\t\t\t\t- the vector of second components of the signatures.\n * @param[in] msg\t\t\t- the combined message.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] h\t\t\t\t- the random element (message has one component).\n * @param[in] label\t\t\t- the integer labels.\n * @param[in] hs\t\t\t- the hash values, one per label.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] y\t\t\t\t- the public elements of the users.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return a boolean value indicating the verification result.\n */\nint cp_cmlhs_ver(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t m, const char *data,\n\t\tconst g1_t h, const int label[], const gt_t * hs[], const dig_t *f[],\n\t\tconst size_t flen[], const g2_t y[], const g2_t pk[], size_t slen,\n\t\tint bls);\n\n/**\n * Perform the offline verification of a CMLHS signature over a set of messages.\n *\n * @param[out] vk\t\t\t- the verification key.\n * @param[in] h\t\t\t\t- the random element (message has one component).\n * @param[in] label\t\t\t- the integer labels.\n * @param[in] hs\t\t\t- the hash values, one per label.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] y\t\t\t\t- the public elements of the users.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return a boolean value indicating the verification result.\n */\nvoid cp_cmlhs_off(gt_t vk, const g1_t h, const int label[], const gt_t *hs[],\n\t\tconst dig_t *f[], const size_t flen[], size_t slen);\n\n/**\n * Perform the online verification of a CMLHS signature over a set of messages.\n *\n * @param[in] r\t\t\t\t- the first component of the homomorphic signature.\n * @param[in] s\t\t\t\t- the second component of the homomorphic signature.\n * @param[in] sig\t\t\t- the BLS signatures.\n * @param[in] z\t\t\t\t- the powers of the outputs of the PRF.\n * @param[in] a\t\t\t\t- the vector of first components of the signatures.\n * @param[in] c\t\t\t\t- the vector of second components of the signatures.\n * @param[in] msg\t\t\t- the combined message.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] h\t\t\t\t- the random element (message has one component).\n * @param[in] vk\t\t\t- the verification key.\n * @param[in] bls\t\t\t- the flag for selecting BLS or ECDSA.\n * @return a boolean value indicating the verification result.\n */\nint cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls);\n/**\n * Generates a key pair for the Multi-Key Homomorphic Signature (MKLHS) scheme.\n *\n * @param[out] sk\t\t\t- the private key for the signature scheme.\n * @param[out] pk\t\t\t- the public key for the signature scheme.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_gen(bn_t sk, g2_t pk);\n\n/**\n * Signs a message using the MKLHS.\n *\n * @param[out] s\t\t\t- the resulting signature.\n * @param[in] m\t\t\t\t- the message to sign.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] id\t\t\t- the identity.\n * @param[in] tag\t\t\t- the tag.\n * @param[in] sk\t\t\t- the private key for the signature scheme.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_sig(g1_t s, const bn_t m, const char *data, const char *id,\n\t\tconst char *tag, const bn_t sk);\n\n/**\n * Applies a function over a set of messages from the same user.\n *\n * @param[out] mu\t\t\t- the combined message.\n * @param[in] m\t\t\t\t- the vector of individual messages.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_fun(bn_t mu, const bn_t m[], const dig_t f[], size_t len);\n\n/**\n * Evaluates a function over a set of MKLHS signatures.\n *\n * @param[out] sig\t\t\t- the resulting signature.\n * @param[in] s\t\t\t\t- the set of signatures.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] len\t\t\t- the number of coefficients.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_evl(g1_t sig, const g1_t s[], const dig_t f[], size_t len);\n\n/**\n * Verifies a MKLHS signature over a set of messages.\n *\n * @param[in] sig\t\t\t- the homomorphic signature to verify.\n * @param[in] m\t\t\t\t- the signed message.\n * @param[in] mu\t\t\t- the vector of signed messages per user.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] id\t\t\t- the vector of identities.\n * @param[in] tag\t\t\t- the vector of tags.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return a boolean value indicating the verification result.\n */\nint cp_mklhs_ver(const g1_t sig, const bn_t m, const bn_t mu[],\n\t\tconst char *data, const char *id[], const char *tag[], const dig_t *f[],\n\t\tconst size_t flen[], const g2_t pk[], size_t slen);\n\n/**\n * Computes the offline part of veryfying a MKLHS signature over a set of\n * messages.\n *\n * @param[out] h\t\t\t- the hashes of labels\n * @param[out] ft\t\t\t- the precomputed linear coefficients.\n * @param[in] id\t\t\t- the vector of identities.\n * @param[in] tag\t\t\t- the vector of tags.\n * @param[in] f\t\t\t\t- the linear coefficients in the function.\n * @param[in] flen\t\t\t- the number of coefficients.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return RLC_OK if no errors occurred, RLC_ERR otherwise.\n */\nint cp_mklhs_off(g1_t h[], dig_t ft[], const char *id[], const char *tag[],\n\t\tconst dig_t *f[], const size_t flen[], size_t slen);\n\n/**\n * Computes the online part of veryfying a MKLHS signature over a set of\n * messages.\n *\n * @param[in] sig\t\t\t- the homomorphic signature to verify.\n * @param[in] m\t\t\t\t- the signed message.\n * @param[in] mu\t\t\t- the vector of signed messages per user.\n * @param[in] data\t\t\t- the dataset identifier.\n * @param[in] id\t\t\t- the vector of identities.\n * @param[in] d\t\t\t\t- the hashes of labels.\n * @param[in] ft\t\t\t- the precomputed linear coefficients.\n * @param[in] pk\t\t\t- the public keys of the users.\n * @param[in] slen\t\t\t- the number of signatures.\n * @return a boolean value indicating the verification result.\n */\nint cp_mklhs_onv(const g1_t sig, const bn_t m, const bn_t mu[],\n\t\tconst char *data, const char *id[], const g1_t h[], const dig_t ft[],\n\t\tconst g2_t pk[], size_t slen);\n\n/**\n * Generates the trusted setup parameters for the factoring-based laconic\n * Private Set Intersection (RSA-PSI) protocol.\n *\n * @param[out] g\t\t\t- the generator.\n * @param[out] n\t\t\t- the modulus.\n * @param[in] bits\t\t\t- the precision in bits.\n */\nint cp_rsapsi_gen(bn_t g, bn_t n, size_t bits);\n\n/**\n * Computes the receiver part of the RSA-PSI protocol, given its input set.\n *\n * @param[out] d\t\t\t- the resulting accumulator.\n * @param[out] r\t\t\t- the random nonce.\n * @param[out] p\t\t\t- the mapping of elements to prime numbers.\n * @param[in] g\t\t\t\t- the generator given by the trusted setup.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n */\nint cp_rsapsi_ask(bn_t d, bn_t r, bn_t p[], const bn_t g, const bn_t n,\n\t\tconst bn_t x[], size_t m);\n\n/**\n * Computes the sender part of the RSA-PSI protocol, given its input set.\n *\n * @param[out] t\t\t\t- the accumulator results.\n * @param[out] u\t\t\t- the missing elements in the exponent.\n * @param[in] d\t\t\t\t- the receiver's accumulator.\n * @param[in] g\t\t\t\t- the generator given by the trusted setup.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] y\t\t\t\t- the server's input set.\n * @param[in] l\t\t\t\t- the sender's input set size.\n */\nint cp_rsapsi_ans(bn_t t[], bn_t u[], const bn_t d, const bn_t g, const bn_t n,\n\t\tconst bn_t y[], size_t l);\n\n/**\n * Computes the intersection as the final part of the RSA-PSI protocol.\n *\n * @param[out] z\t\t\t- the elements in the intersection.\n * @param[out] len\t\t\t- the cardinality of the resulting intersection.\n * @param[in] r\t\t\t\t- the random nonce.\n * @param[in] p\t\t\t\t- the mapping of elements to prime numbers.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n * @param[in] t\t\t\t\t- the accumulator results.\n * @param[in] u\t\t\t\t- the missing elements in the exponent.\n * @param[in] l\t\t\t\t- the sender's input set size.\n */\nint cp_rsapsi_int(bn_t z[], size_t *len, const bn_t r, const bn_t p[],\n\t\tconst bn_t n, const bn_t x[], const size_t m, const bn_t t[],\n\t\tconst bn_t u[], size_t l);\n\n/**\n * Generates the trusted setup parameters for the factoring-based size-hiding\n * Private Set Intersection (SHI-PSI) protocol.\n *\n * @param[out] g\t\t\t- the generator.\n * @param[in] crt\t\t\t- the parameters given by the trusted setup.\n * @param[in] bits\t\t\t- the precision in bits.\n */\nint cp_shipsi_gen(bn_t g, crt_t crt, size_t bits);\n\n/**\n * Computes the receiver part of the SHI-PSI protocol, given its input set.\n *\n * @param[out] d\t\t\t- the resulting accumulator.\n * @param[out] r\t\t\t- the random nonce.\n * @param[out] p\t\t\t- the mapping of elements to prime numbers.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] crt\t\t\t- the parameters given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n */\nint cp_shipsi_ask(bn_t d, bn_t r, bn_t p[], const bn_t g, const bn_t n,\n\t\tconst bn_t x[], size_t m);\n\n/**\n * Computes the sender part of the SHI-PSI protocol, given its input set.\n *\n * @param[out] t\t\t\t- the accumulator results.\n * @param[out] u\t\t\t- the hint in the exponent.\n * @param[in] d\t\t\t\t- the receiver's accumulator.\n * @param[in] g\t\t\t\t- the generator given by the trusted setup.\n * @param[in] crt\t\t\t- the parameters given by the trusted setup.\n * @param[in] y\t\t\t\t- the server's input set.\n * @param[in] n\t\t\t\t- the sender's input set size.\n */\nint cp_shipsi_ans(bn_t t[], bn_t u, bn_t d, const bn_t g, const crt_t crt,\n\t\tconst bn_t y[], const size_t n);\n\n/**\n * Computes the intersection as the final part of the SHI-PSI protocol.\n *\n * @param[out] z\t\t\t- the elements in the intersection.\n * @param[out] len\t\t\t- the cardinality of the resulting intersection.\n * @param[in] r\t\t\t\t- the random nonce.\n * @param[in] p\t\t\t\t- the mapping of elements to prime numbers.\n * @param[in] n\t\t\t\t- the modulus given by the trusted setup.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n * @param[in] t\t\t\t\t- the accumulator results.\n * @param[in] u\t\t\t\t- the hint in the exponent.\n * @param[in] l\t\t\t\t- the sender's input set size.\n */\nint cp_shipsi_int(bn_t z[], size_t *len, const bn_t r, const bn_t p[],\n\t\tconst bn_t n, const bn_t x[], size_t m, const bn_t t[], const bn_t u,\n\t\tsize_t l);\n\n/**\n * Generates the secrets and consecutive powers for the pairing-based laconic\n * Private Set Intersection (PB-PSI) protocol, given the maximum set size.\n *\n * @param[out] sk\t\t\t- the sender's secret key.\n * @param[out] ss\t\t\t- the secret power in G_2.\n * @param[out] s\t\t\t- the consecutive powers in G_1.\n * @param[in] m\t\t\t\t- the maximum set size.\n */\nint cp_pbpsi_gen(bn_t sk, g1_t ss, g2_t s[], size_t m);\n\n/**\n * Computes the receiver part of the PB-PSI protocol, given its input set.\n *\n * @param[out] d\t\t\t- the polynomial interpolations in the exponent.\n * @param[out] r\t\t\t- the random nonce.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] s\t\t\t\t- the consecutive powers.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n */\nint cp_pbpsi_ask(g2_t d[], bn_t r, const bn_t x[], const g2_t s[], size_t m);\n\n/**\n * Computes the sender part of the PB-PSI protocol, given its input set.\n *\n * @param[out] t\t\t\t- the pairing results.\n * @param[out] u\t\t\t- the missing elements in the exponent.\n * @param[in] ss\t\t\t- the secret power.\n * @param[in] d\t\t\t\t- the polynomial interpolations in the exponent.\n * @param[in] y\t\t\t\t- the server's input set.\n * @param[in] n\t\t\t\t- the sender's input set size.\n */\nint cp_pbpsi_ans(gt_t t[], g1_t u[], const g1_t ss, const g2_t d,\n\t\tconst bn_t y[], size_t n);\n\n/**\n * Computes the intersection as the final part of the PB-PSI protocol.\n *\n * @param[out] z\t\t\t- the elements in the intersection.\n * @param[out] len\t\t\t- the cardinality of the resulting intersection.\n * @param[in] d\t\t\t\t- the polynomial interpolations in the exponent.\n * @param[in] x\t\t\t\t- the receiver's input set.\n * @param[in] s\t\t\t\t- the consecutive powers.\n * @param[in] m\t\t\t\t- the receiver's input set size.\n * @param[in] t\t\t\t\t- the pairing results.\n * @param[in] u\t\t\t\t- the missing elements in the exponent.\n * @param[in] n\t\t\t\t- the sender's input set size.\n */\nint cp_pbpsi_int(bn_t z[], size_t *len, const g2_t d[], const bn_t x[], size_t m,\n\t\tconst gt_t t[], const g1_t u[], size_t n);\n\n#endif /* !RLC_CP_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup eb Elliptic curves over binary fields\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on binary elliptic curves.\n *\n * @ingroup eb\n */\n\n#ifndef RLC_EB_H\n#define RLC_EB_H\n\n#include \"relic_fb.h\"\n#include \"relic_bn.h\"\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Binary elliptic curve identifiers.\n */\nenum {\n\t/** NIST B-163 binary curve. */\n\tNIST_B163 = 1,\n\t/** NIST K-163 Koblitz curve. */\n\tNIST_K163,\n\t/** NIST B-133 binary curve. */\n\tNIST_B233,\n\t/** NIST K-233 Koblitz curve. */\n\tNIST_K233,\n\t/** Curve over 2^{251} used in eBATs. */\n\tEBACS_B251,\n\t/** Curve over 2^{257} good for halving. */\n\tHALVE_B257,\n\t/** SECG K-239 binary curve. */\n\tSECG_K239,\n\t/** NIST B-283 binary curve. */\n\tNIST_B283,\n\t/** NIST K-283 Koblitz curve. */\n\tNIST_K283,\n\t/** NIST B-409 binary curve. */\n\tNIST_B409,\n\t/** NIST K-409 Koblitz curve. */\n\tNIST_K409,\n\t/** NIST B-571 binary curve. */\n\tNIST_B571,\n\t/** NIST K-571 Koblitz curve. */\n\tNIST_K571,\n};\n\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_EB_TABLE_BASIC\t\t(RLC_FB_BITS)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_EB_TABLE_COMBS      (1 << EB_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_EB_TABLE_COMBD\t\t(1 << (EB_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_EB_TABLE_LWNAF\t\t(1 << (EB_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if EB_FIX == BASIC\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_BASIC\n#elif EB_FIX == COMBS\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_COMBS\n#elif EB_FIX == COMBD\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_COMBD\n#elif EB_FIX == LWNAF\n#define RLC_EB_TABLE\t\t\tRLC_EB_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_EB_TABLE_MAX \t\tRLC_EB_TABLE\n#else\n#define RLC_EB_TABLE_MAX \t\tRLC_MAX(RLC_EB_TABLE_BASIC, RLC_EB_TABLE_COMBD)\n#endif\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over a binary field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfb_st x;\n\t/** The second coordinate. */\n\tfb_st y;\n\t/** The third coordinate (projective representation). */\n\tfb_st z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} eb_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef eb_st eb_t[1];\n#else\n#ifdef CHECK\ntypedef eb_st *volatile eb_t;\n#else\ntypedef eb_st *eb_t;\n#endif\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a point on a binary elliptic curve with a null value.\n *\n * @param[out] A\t\t\t- the point to initialize.\n */\n#if ALLOC == AUTO\n#define eb_null(A)\t\t\t/* empty */\n#else\n#define eb_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a point on a binary elliptic curve.\n *\n * @param[out] A\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define eb_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (eb_t)calloc(1, sizeof(eb_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define eb_new(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on a binary elliptic curve.\n *\n * @param[out] A\t\t\t- the point to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define eb_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define eb_free(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Negates a binary elliptic curve point. Computes R = -P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to negate.\n */\n#if EB_ADD == BASIC\n#define eb_neg(R, P)\t\teb_neg_basic(R, P)\n#elif EB_ADD == PROJC\n#define eb_neg(R, P)\t\teb_neg_projc(R, P)\n#endif\n\n/**\n * Adds two binary elliptic curve points. Computes R = P + Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t- the second point to add.\n */\n#if EB_ADD == BASIC\n#define eb_add(R, P, Q)\t\teb_add_basic(R, P, Q);\n#elif EB_ADD == PROJC\n#define eb_add(R, P, Q)\t\teb_add_projc(R, P, Q);\n#endif\n\n/**\n * Subtracts a binary elliptic curve point from another. Computes R = P - Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point.\n * @param[in] Q\t\t\t\t- the second point.\n */\n#if EB_ADD == BASIC\n#define eb_sub(R, P, Q)\t\teb_sub_basic(R, P, Q)\n#elif EB_ADD == PROJC\n#define eb_sub(R, P, Q)\t\teb_sub_projc(R, P, Q)\n#endif\n\n/**\n * Doubles a binary elliptic curve point. Computes R = 2P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to double.\n */\n#if EB_ADD == BASIC\n#define eb_dbl(R, P)\t\teb_dbl_basic(R, P);\n#elif EB_ADD == PROJC\n#define eb_dbl(R, P)\t\teb_dbl_projc(R, P);\n#endif\n\n\n/**\n * Multiplies a binary elliptic curve point by an integer. Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if EB_MUL == BASIC\n#define eb_mul(R, P, K)\t\teb_mul_basic(R, P, K)\n#elif EB_MUL == LODAH\n#define eb_mul(R, P, K)\t\teb_mul_lodah(R, P, K)\n#elif EB_MUL == HALVE\n#define eb_mul(R, P, K)\t\teb_mul_halve(R, P, K)\n#elif EB_MUL == LWNAF\n#define eb_mul(R, P, K)\t\teb_mul_lwnaf(R, P, K)\n#elif EB_MUL == RWNAF\n#define eb_mul(R, P, K)\t\teb_mul_rwnaf(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * point.\n *\n * @param[out] T\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t- the point to multiply.\n */\n#if EB_FIX == BASIC\n#define eb_mul_pre(T, P)\teb_mul_pre_basic(T, P)\n#elif EB_FIX == COMBS\n#define eb_mul_pre(T, P)\teb_mul_pre_combs(T, P)\n#elif EB_FIX == COMBD\n#define eb_mul_pre(T, P)\teb_mul_pre_combd(T, P)\n#elif EB_FIX == LWNAF\n#define eb_mul_pre(T, P)\teb_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] T\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if EB_FIX == BASIC\n#define eb_mul_fix(R, T, K)\teb_mul_fix_basic(R, T, K)\n#elif EB_FIX == COMBS\n#define eb_mul_fix(R, T, K)\teb_mul_fix_combs(R, T, K)\n#elif EB_FIX == COMBD\n#define eb_mul_fix(R, T, K)\teb_mul_fix_combd(R, T, K)\n#elif EB_FIX == LWNAF\n#define eb_mul_fix(R, T, K)\teb_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously. Computes\n * R = [k]P + [m]Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t- the second integer,\n */\n#if EB_SIM == BASIC\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_basic(R, P, K, Q, M)\n#elif EB_SIM == TRICK\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_trick(R, P, K, Q, M)\n#elif EB_SIM == INTER\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_inter(R, P, K, Q, M)\n#elif EB_SIM == JOINT\n#define eb_mul_sim(R, P, K, Q, M)\teb_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the binary elliptic curve arithmetic module.\n */\nvoid eb_curve_init(void);\n\n/**\n * Finalizes the binary elliptic curve arithmetic module.\n */\nvoid eb_curve_clean(void);\n\n/**\n * Returns the a-coefficient of the currently configured binary elliptic\n * curve.\n *\n * @return the a-coefficient of the elliptic curve.\n */\ndig_t *eb_curve_get_a(void);\n\n/**\n * Returns the b-coefficient of the currently configured binary elliptic\n * curve.\n *\n * @return the b-coefficient of the elliptic curve.\n */\ndig_t *eb_curve_get_b(void);\n\n/**\n * Returns a optimization identifier based on the a-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint eb_curve_opt_a(void);\n\n/**\n * Returns a optimization identifier based on the b-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint eb_curve_opt_b(void);\n\n/**\n * Tests if the configured binary elliptic curve is a Koblitz curve.\n *\n * @return 1 if the binary elliptic curve is a Koblitz curve, 0 otherwise.\n */\nint eb_curve_is_kbltz(void);\n\n/**\n * Returns the generator of the group of points in the binary elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid eb_curve_get_gen(eb_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nconst eb_t *eb_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the binary elliptic curve.\n *\n * @param[out] n\t\t\t- the returned order.\n */\nvoid eb_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the binary elliptic curve.\n *\n * @param[out] n\t\t\t- the returned cofactor.\n */\nvoid eb_curve_get_cof(bn_t h);\n\n/**\n * Configures an ordinary binary elliptic curve by its coefficients and\n * generator.\n *\n * @param[in] a\t\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t\t- the generator.\n * @param[in] n\t\t\t\t- the order of the generator.\n * @param[in] h\t\t\t\t- the cofactor of the group order.\n */\nvoid eb_curve_set(const fb_t a, const fb_t b, const eb_t g, const bn_t n,\n\t\tconst bn_t h);\n\n/**\n * Configures a new binary elliptic curve by its parameter identifier.\n *\n * @param[in] param\t\t\t- the parameters identifier.\n */\nvoid eb_param_set(int param);\n\n/**\n * Configures some set of curve parameters for the current security level.\n */\nint eb_param_set_any(void);\n\n/**\n * Configures a set of curve parameters without endormorphisms for the current\n * security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint eb_param_set_any_plain(void);\n\n/**\n * Configures a set of Koblitz curve parameters for the current security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint eb_param_set_any_kbltz(void);\n\n/**\n * Returns the parameter identifier of the currently configured binary elliptic\n * curve.\n *\n * @return the parameter identifier.\n */\nint eb_param_get(void);\n\n/**\n * Prints the current configured binary elliptic curve.\n */\nvoid eb_param_print(void);\n\n/**\n * Returns the current security level.\n */\nint eb_param_level(void);\n\n/**\n * Tests if a point on a binary elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint eb_is_infty(const eb_t p);\n\n/**\n * Assigns a binary elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid eb_set_infty(eb_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the binary elliptic curve point to copy.\n */\nvoid eb_copy(eb_t r, const eb_t p);\n\n/**\n * Compares two binary elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first binary elliptic curve point.\n * @param[in] q\t\t\t\t- the second binary elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint eb_cmp(const eb_t p, const eb_t q);\n\n/**\n * Assigns a random value to a binary elliptic curve point.\n *\n * @param[out] p\t\t\t- the binary elliptic curve point to assign.\n */\nvoid eb_rand(eb_t p);\n\n/**\n * Randomizes coordinates of a binary elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded binary elliptic curve point.\n * @param[in] p\t\t\t\t- the binary elliptic curve point to blind.\n */\nvoid eb_blind(eb_t r, const eb_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid eb_rhs(fb_t rhs, const eb_t p);\n\n/** Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint eb_on_curve(const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a random binary elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid eb_tab(eb_t *t, const eb_t p, int w);\n\n/**\n * Prints a binary elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the binary elliptic curve point to print.\n */\nvoid eb_print(const eb_t p);\n\n/**\n * Returns the number of bytes necessary to store a binary elliptic curve point\n * with optional point compression.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint eb_size_bin(const eb_t a, int pack);\n\n/**\n * Reads a binary elliptic curve point from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid eb_read_bin(eb_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a binary field element to a byte vector in big-endian format with\n * optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the binary elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid eb_write_bin(uint8_t *bin, size_t len, const eb_t a, int pack);\n\n/**\n * Negates a binary elliptic curve point represented by affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid eb_neg_basic(eb_t r, const eb_t p);\n\n/**\n * Negates a binary elliptic curve point represented by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid eb_neg_projc(eb_t r, const eb_t p);\n\n/**\n * Adds two binary elliptic curve points represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid eb_add_basic(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Adds two binary elliptic curve points represented in projective coordinates.\n * Computes R = P + Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid eb_add_projc(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Subtracts a binary elliptic curve point from another, both points represented\n * by affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid eb_sub_basic(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Subtracts a binary elliptic curve point from another, both points represented\n * by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid eb_sub_projc(eb_t r, const eb_t p, const eb_t q);\n\n/**\n * Doubles a binary elliptic curve point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid eb_dbl_basic(eb_t r, const eb_t p);\n\n/**\n * Doubles a binary elliptic curve point represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid eb_dbl_projc(eb_t r, const eb_t p);\n\n/**\n * Halves a point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to halve.\n */\nvoid eb_hlv(eb_t r, const eb_t p);\n\n/**\n * Computes the Frobenius map of a binary elliptic curve point on a Koblitz\n * curve. Computes R = \\tau(P) = \\tau(x, y) = (x^2, y^2).\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid eb_frb(eb_t r, const eb_t p);\n\n/**\n * Multiplies a binary elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_basic(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the constant-time\n * Lopez-Dahab point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_lodah(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the left-to-right\n * w-NAF method. If the binary curve is a Koblitz curve, w-TNAF is used.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_lwnaf(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the right-to-left\n * w-NAF method. If the binary curve is a Koblitz curve, w-TNAF is used.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_rwnaf(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by an integer using the halving method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_halve(eb_t r, const eb_t p, const bn_t k);\n\n/**\n * Multiplies the generator of a binary elliptic curve by an integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_gen(eb_t r, const bn_t k);\n\n/**\n * Multiplies a binary elliptic point by a small positive integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_dig(eb_t r, const eb_t p, const dig_t k);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_basic(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_yaowi(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_nafwi(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_combs(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_combd(eb_t *t, const eb_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed binary elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid eb_mul_pre_lwnaf(eb_t *t, const eb_t p);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_basic(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_yaowi(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_nafwi(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_combs(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_combd(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed binary elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid eb_mul_fix_lwnaf(eb_t r, const eb_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_basic(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_trick(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_inter(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid eb_mul_sim_joint(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds the generator and a binary elliptic curve point\n * simultaneously. Computes R = [k]G + [m]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer.\n */\nvoid eb_mul_sim_gen(eb_t r, const bn_t k, const eb_t q, const bn_t m);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid eb_norm(eb_t r, const eb_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid eb_norm_sim(eb_t *r, const eb_t *t, int n);\n\n/**\n * Maps a byte array to a point in a binary elliptic curve.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid eb_map(eb_t p, const uint8_t *msg, size_t len);\n\n/**\n * Compresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid eb_pck(eb_t r, const eb_t p);\n\n/**\n * Decompresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint eb_upk(eb_t r, const eb_t p);\n\n#endif /* !RLC_EB_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup ed Edwards curves over prime fields.\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on elliptic curves.\n *\n * @ingroup ed\n */\n\n#ifndef RLC_ED_H\n#define RLC_ED_H\n\n#include \"relic_fp.h\"\n#include \"relic_bn.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions\t\t\t\t\t\t\t\t\t\t\t\t\t   */\n/*============================================================================*/\n\n/**\n * Prime elliptic curve identifiers.\n */\nenum {\n\t/** ED25519 Edwards curve. */\n\tCURVE_ED25519 = 1\n};\n\n/*============================================================================*/\n/* Precomputaion table\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*============================================================================*/\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_ED_TABLE_BASIC\t  (RLC_FP_BITS + 1)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_ED_TABLE_COMBS\t  (1 << ED_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_ED_TABLE_COMBD\t  (1 << (ED_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_ED_TABLE_LWNAF\t  (1 << (ED_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if ED_FIX == BASIC\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_BASIC\n#elif ED_FIX == COMBS\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_COMBS\n#elif ED_FIX == COMBD\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_COMBD\n#elif ED_FIX == LWNAF\n#define RLC_ED_TABLE\t\t\tRLC_ED_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_ED_TABLE_MAX\t\tRLC_ED_TABLE\n#else\n#define RLC_ED_TABLE_MAX\t\tRLC_MAX(RLC_ED_TABLE_BASIC, RLC_ED_TABLE_COMBD)\n#endif\n\n/*============================================================================*/\n/* Type definitions\t\t\t\t\t\t\t\t\t\t\t\t\t\t   */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over an Edwards field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp_st x;\n\t/** The second coordinate. */\n\tfp_st y;\n\t/** The third coordinate (projective representation). */\n\tfp_st z;\n#if ED_ADD == EXTND || !defined(STRIP)\n\t/** The forth coordinate (extended coordinates) */\n\tfp_st t;\n#endif\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ed_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ed_st ed_t[1];\n#else\n#ifdef CHECK\ntypedef ed_st *volatile ed_t;\n#else\ntypedef ed_st *ed_t;\n#endif\n#endif\n\n/*============================================================================*/\n/* Macro definitions\t\t\t\t\t\t\t\t\t\t\t\t\t\t  */\n/*============================================================================*/\n\n/**\n * Initializes a point on an Edwards curve with a null value.\n *\n * @param[out] A\t\t\t- the point to initialize.\n */\n#if ALLOC == AUTO\n#define ed_null(A)\t\t\t/* empty */\n#else\n#define ed_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a point on an Edwards curve.\n *\n * @param[out] A\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ed_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ed_t)calloc(1, sizeof(ed_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ed_new(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on an Edwards curve.\n *\n * @param[out] A\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ed_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ed_free(A)\t\t\t/* empty */\n\n#endif\n\n/**\n * Negates an Edwards elliptic curve point. Computes R = -P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to negate.\n */\n#if ED_ADD == BASIC\n#define ed_neg(R, P)\t\ted_neg_basic(R, P)\n#elif ED_ADD == PROJC || ED_ADD == EXTND\n#define ed_neg(R, P)\t\ted_neg_projc(R, P)\n#endif\n\n/**\n * Adds two Edwards elliptic curve points. Computes R = P + Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t- the second point to add.\n */\n#if ED_ADD == BASIC\n#define ed_add(R, P, Q)\t\ted_add_basic(R, P, Q)\n#elif ED_ADD == PROJC\n#define ed_add(R, P, Q)\t\ted_add_projc(R, P, Q)\n#elif ED_ADD == EXTND\n#define ed_add(R, P, Q)\t\ted_add_extnd(R, P, Q)\n#endif\n\n/**\n * Subtracts an Edwards elliptic curve point from another. Computes R = P - Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point.\n * @param[in] Q\t\t\t\t- the second point.\n */\n#if ED_ADD == BASIC\n#define ed_sub(R, P, Q)\t\ted_sub_basic(R, P, Q)\n#elif ED_ADD == PROJC\n#define ed_sub(R, P, Q)\t\ted_sub_projc(R, P, Q)\n#elif ED_ADD == EXTND\n#define ed_sub(R, P, Q)\t\ted_sub_extnd(R, P, Q)\n#endif\n\n/**\n * Doubles an Edwards elliptic curve point. Computes R = 2P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to double.\n */\n#if ED_ADD == BASIC\n#define ed_dbl(R, P)\t\ted_dbl_basic(R, P)\n#elif ED_ADD == PROJC\n#define ed_dbl(R, P)\t\ted_dbl_projc(R, P)\n#elif ED_ADD == EXTND\n#define ed_dbl(R, P)\t\ted_dbl_extnd(R, P)\n#endif\n\n\n/**\n * Configures an Edwards curve by its parameter identifier.\n *\n * @param\t\t\t\t   - the parameter identifier.\n */\nvoid ed_param_set(int param);\n\n/**\n * Configures some set of curve parameters for the current security level.\n */\nint ed_param_set_any(void);\n\n/**\n * Returns the parameter identifier of the currently configured Edwards elliptic\n * curve.\n *\n * @return the parameter identifier.\n */\nint ed_param_get(void);\n\n/**\n * Returns the order of the group of points in the Edwards curve.\n *\n * @param[out] r\t\t\t- the returned order.\n */\nvoid ed_curve_get_ord(bn_t r);\n\n/**\n * Returns the generator of the group of points in the curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ed_curve_get_gen(ed_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nconst ed_t *ed_curve_get_tab(void);\n\n/**\n * Returns the cofactor of the Edwards elliptic curve.\n *\n * @param[out] n\t\t\t- the returned cofactor.\n */\nvoid ed_curve_get_cof(bn_t h);\n\n/**\n * Prints the current configured Edwards elliptic curve.\n */\nvoid ed_param_print(void);\n\n/**\n * Returns the current security level.\n */\nint ed_param_level(void);\n\n#if ED_ADD == EXTND\n/**\n * Converts projective point into extended point.\n */\nvoid ed_projc_to_extnd(ed_t r, const fp_t x, const fp_t y, const fp_t z);\n#endif\n\n/**\n * Assigns a random value to an Edwards elliptic curve point.\n *\n * @param[out] p\t\t\t- the Edwards elliptic curve point to assign.\n */\nvoid ed_rand(ed_t p);\n\n/**\n * Randomizes coordinates of a prime elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded Edwards elliptic curve point.\n * @param[in] p\t\t\t\t- the Edwards elliptic curve point to blind.\n */\nvoid ed_blind(ed_t r, const ed_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * Edwards elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ed_rhs(fp_t rhs, const ed_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t   - the result.\n * @param[in] p\t\t\t   - the Edwards elliptic curve point to copy.\n */\nvoid ed_copy(ed_t r, const ed_t p);\n\n/**\n * Compares two Edwards elliptic curve points.\n *\n * @param[in] p\t\t\t   - the first Edwards elliptic curve point.\n * @param[in] q\t\t\t   - the second Edwards elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ed_cmp(const ed_t p, const ed_t q);\n\n/**\n * Assigns an Edwards elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t   - the point to assign.\n */\nvoid ed_set_infty(ed_t p);\n\n/**\n * Tests if a point on an Edwards elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t   - the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ed_is_infty(const ed_t p);\n\n/**\n * Negates an Edwards elliptic curve point represented by affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid ed_neg_basic(ed_t r, const ed_t p);\n\n/**\n * Negates an Edwards elliptic curve point represented by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid ed_neg_projc(ed_t r, const ed_t p);\n\n/**\n * Adds two Edwards elliptic curve points represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ed_add_basic(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Adds two Edwards elliptic curve points represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ed_add_projc(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Adds two Edwards elliptic curve points represented in exteded coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ed_add_extnd(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Subtracts an Edwards elliptic curve point from another, both points represented\n * by affine coordinates..\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ed_sub_basic(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Subtracts an Edwards elliptic curve point from another, both represented\n * by projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ed_sub_projc(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Subtracts an Edwards elliptic curve point from another, both represented\n * by extended coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ed_sub_extnd(ed_t r, const ed_t p, const ed_t q);\n\n/**\n * Doubles an Edwards elliptic curve point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ed_dbl_basic(ed_t r, const ed_t p);\n\n/**\n * Doubles an Edwards elliptic curve point represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ed_dbl_projc(ed_t r, const ed_t p);\n\n/**\n * Doubles an Edwards elliptic curve point represented in extended coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ed_dbl_extnd(ed_t r, const ed_t p);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ed_norm(ed_t r, const ed_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ed_norm_sim(ed_t *r, const ed_t *t, int n);\n\n/**\n * Maps a byte array to a point in an Edwards elliptic curve.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ed_map(ed_t p, const uint8_t *msg, size_t len);\n\n/**\n * Maps a byte array to a point in an Edwards elliptic curve using\n * an explicit domain separation tag.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ed_map_dst(ed_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len);\n\n/**\n * Multiplies an Edwards elliptic curve point by an integer. Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if ED_MUL == BASIC\n#define ed_mul(R, P, K)   ed_mul_basic(R, P, K)\n#elif ED_MUL == SLIDE\n#define ed_mul(R, P, K)   ed_mul_slide(R, P, K)\n#elif ED_MUL == MONTY\n#define ed_mul(R, P, K)   ed_mul_monty(R, P, K)\n#elif ED_MUL == LWNAF\n#define ed_mul(R, P, K)   ed_mul_lwnaf(R, P, K)\n#elif ED_MUL == LWREG\n#define ed_mul(R, P, K)   ed_mul_lwreg(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point.\n *\n * @param[out] T\t\t\t- the precomputation table.\n * @param[in] P\t\t\t \t- the point to multiply.\n */\n#if ED_FIX == BASIC\n#define ed_mul_pre(T, P)\ted_mul_pre_basic(T, P)\n#elif ED_FIX == COMBS\n#define ed_mul_pre(T, P)\ted_mul_pre_combs(T, P)\n#elif ED_FIX == COMBD\n#define ed_mul_pre(T, P)\ted_mul_pre_combd(T, P)\n#elif ED_FIX == LWNAF\n#define ed_mul_pre(T, P)\ted_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] T\t\t\t \t- the precomputation table.\n * @param[in] K\t\t\t \t- the integer.\n */\n#if ED_FIX == BASIC\n#define ed_mul_fix(R, T, K) ed_mul_fix_basic(R, T, K)\n#elif ED_FIX == COMBS\n#define ed_mul_fix(R, T, K) ed_mul_fix_combs(R, T, K)\n#elif ED_FIX == COMBD\n#define ed_mul_fix(R, T, K) ed_mul_fix_combd(R, T, K)\n#elif ED_FIX == LWNAF\n#define ed_mul_fix(R, T, K) ed_mul_fix_lwnaf(R, T, K)\n#endif\n\n /**\n * Multiplies and adds two Edwards elliptic curve points simultaneously. Computes\n * R = [k]P + [m]Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t \t- the first point to multiply.\n * @param[in] K\t\t\t \t- the first integer.\n * @param[in] Q\t\t\t \t- the second point to multiply.\n * @param[in] M\t\t\t \t- the second integer,\n */\n#if ED_SIM == BASIC\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_basic(R, P, K, Q, M)\n#elif ED_SIM == TRICK\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_trick(R, P, K, Q, M)\n#elif ED_SIM == INTER\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_inter(R, P, K, Q, M)\n#elif ED_SIM == JOINT\n#define ed_mul_sim(R, P, K, Q, M) ed_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes\t\t\t\t\t\t\t\t\t\t\t\t\t\t*/\n/*============================================================================*/\n\n/**\n * Initializes the Edwards elliptic curve arithmetic module.\n */\nvoid ed_curve_init(void);\n\n/**\n * Finalizes the Edwards elliptic curve arithmetic module.\n */\nvoid ed_curve_clean(void);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_basic(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_yaowi(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_nafwi(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_combs(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_combd(ed_t *t, const ed_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed Edwards elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ed_mul_pre_lwnaf(ed_t *t, const ed_t p);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_basic(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_yaowi(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_nafwi(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_combs(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_combd(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_fix_lwnaf(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed Edwards elliptic point using a precomputation table and\n * the w-(T)NAF mixed coordinate method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t \t- the precomputation table.\n * @param[in] k\t\t\t \t- the integer.\n */\nvoid ed_mul_fix_lwnaf_mixed(ed_t r, const ed_t *t, const bn_t k);\n\n/**\n * Multiplies the generator of an Edwards elliptic curve by an integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t \t- the integer.\n */\nvoid ed_mul_gen(ed_t r, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic curve point by a small positive integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the point to multiply.\n * @param[in] k\t\t\t \t- the integer.\n */\nvoid ed_mul_dig(ed_t r, const ed_t p, dig_t k);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_basic(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_inter(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds two Edwards elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t \t- the first point to multiply.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer,\n */\nvoid ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\tconst bn_t m);\n\n/**\n * Multiplies and adds multiple Edwards elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n);\n\n/**\n * Multiplies and adds the generator and an Edwards elliptic curve point\n * simultaneously. Computes R = [k]G + [m]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t \t- the first integer.\n * @param[in] q\t\t\t \t- the second point to multiply.\n * @param[in] m\t\t\t \t- the second integer.\n */\nvoid ed_mul_sim_gen(ed_t r, const bn_t k, const ed_t q, const bn_t m);\n\n/**\n * Builds a precomputation table for multiplying a random Edwards elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ed_tab(ed_t *t, const ed_t p, int w);\n\n/**\n * Prints an Edwards elliptic curve point.\n *\n * @param[in] p\t\t\t \t- the Edwards elliptic curve point to print.\n */\nvoid ed_print(const ed_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t \t- the point to test.\n */\nint ed_on_curve(const ed_t p);\n\n/**\n * Returns the number of bytes necessary to store an Edwards elliptic curve point\n * with optional point compression.\n *\n * @param[in] a\t\t\t\t- the Edwards field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ed_size_bin(const ed_t a, int pack);\n\n/**\n * Reads an Edwards elliptic curve point from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ed_read_bin(ed_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes an Edwards elliptic curve point to a byte vector in big-endian format\n * with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the Edwards elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ed_write_bin(uint8_t *bin, size_t len, const ed_t a, int pack);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_basic(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_slide(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_monty(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_lwnaf(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Multiplies an Edwards elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ed_mul_lwreg(ed_t r, const ed_t p, const bn_t k);\n\n/**\n * Compresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ed_pck(ed_t r, const ed_t p);\n\n/**\n * Decompresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint ed_upk(ed_t r, const ed_t p);\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup ep Elliptic curves over prime fields\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on prime elliptic curves.\n *\n * The scalar multiplication functions are only guaranteed to work\n * in the large prime order subgroup. If you need a generic scalar\n * multiplication function, use ep_mul_basic.\n *\n * @ingroup ep\n */\n\n#ifndef RLC_EP_H\n#define RLC_EP_H\n\n#include \"relic_fp.h\"\n#include \"relic_bn.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Prime elliptic curve identifiers.\n */\nenum {\n\t/** SECG P-160 prime curve. */\n\tSECG_P160 = 1,\n\t/** SECG K-160 prime curve. */\n\tSECG_K160,\n\t/** NIST P-192 prime curve. */\n\tNIST_P192,\n\t/** SECG K-192 prime curve. */\n\tSECG_K192,\n\t/** Curve22103 prime curve. */\n\tCURVE_22103,\n\t/** NIST P-224 prime curve. */\n\tNIST_P224,\n\t/** SECG K-224 prime curve. */\n\tSECG_K224,\n\t/** Curve4417 prime curve. */\n\tCURVE_4417,\n\t/** Curve1147 prime curve. */\n\tCURVE_1174,\n\t/** Curve25519 prime curve. */\n\tCURVE_25519,\n\t/** Curve Tweedledum given by Daira Hopwoord at https://github.com/daira/tweedle */\n\tTWEEDLEDUM,\n\t/** NIST P-256 prime curve. */\n\tNIST_P256,\n\t/** Brainpool P256r1 curve. */\n\tBSI_P256,\n\t/** SECG K-256 prime curve. */\n\tSECG_K256,\n\t/** SM2 P-256 prime curve. */\n\tSM2_P256,\n\t/** Curve67254 prime curve. */\n\tCURVE_67254,\n\t/** Curve383187 prime curve. */\n\tCURVE_383187,\n\t/** NIST P-384 prime curve. */\n\tNIST_P384,\n\t/** Curve 511187 prime curve. */\n\tCURVE_511187,\n\t/** NIST P-521 prime curve. */\n\tNIST_P521,\n\t/** Barreto-Naehrig curve with positive x */\n\tBN_P158,\n\t/** Barreto-Naehrig curve with negative x (found by Nogami et al.). */\n\tBN_P254,\n\t/** Barreto-Naehrig curve with negative x. */\n\tBN_P256,\n\t/** Barreto-Naehrig curve standardized in China. */\n\tSM9_P256,\n\t/** Barreto-Lynn-Scott curve with embedding degree 24 (SNARK curve). */\n\tB24_P315,\n\t/** Barreto-Lynn-Scott curve with embedding degree 24 (SNARK curve). */\n\tB24_P317,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12 (SNARK curve). */\n\tB12_P377,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12 (ZCash curve). */\n\tB12_P381,\n\t/** Barreto-Naehrig curve with negative x. */\n\tBN_P382,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12 (GT-strong). */\n\tB12_P383,\n\t/** Barreto-Naehrig curve with embedding degree 12. */\n\tBN_P446,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12. */\n\tB12_P446,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12. */\n\tB12_P455,\n\t/** Kachisa-Schafer-Scott with negative x. */\n\tKSS_P508,\n\t/** Barreto-Lynn-Scott curve with embedding degree 24. */\n\tB24_P509,\n\t/** Optimal TNFS-secure curve with embedding degree 8. */\n\tOT8_P511,\n\t/** Cocks-pinch curve with embedding degree 8. */\n\tGMT8_P544,\n\t/** Kachisa-Scott-Schaefer curve with embedding degree 54. */\n\tK54_P569,\n\t/** Barreto-Lynn-Scott curve with embedding degree 48. */\n\tB48_P575,\n\t/** Barreto-Naehrig curve with positive x. */\n\tBN_P638,\n\t/** Barreto-Lynn-Scott curve with embedding degree 12. */\n\tB12_P638,\n\t/** 1536-bit supersingular curve. */\n\tSS_P1536,\n\t/** 3072-bit supersingular curve. */\n\tSS_P3072,\n};\n\n/**\n * Pairing-friendly elliptic curve identifiers.\n */\nenum {\n\t/** Supersingular curves with embedding degree 1. */\n\tEP_SS1 = 1,\n\t/** Supersingular curves with embedding degree 2. */\n\tEP_SS2,\n\t/** Barreto-Naehrig. */\n\tEP_BN,\n\t/* Optimal TNFS-secure. */\n\tEP_OT8,\n\t/* Cocks-Pinch curve. */\n\tEP_GMT8,\n\t/* Barreto-Lynn-Scott with embedding degree 12. */\n\tEP_B12,\n\t/* Kachisa-Schafer-Scott with embedding degree 16. */\n\tEP_K16,\n\t/* Barreto-Lynn-Scott with embedding degree 24. */\n\tEP_B24,\n\t/* Barreto-Lynn-Scott with embedding degree 48. */\n\tEP_B48,\n\t/** Kachisa-Scott-Schaefer curve with embedding degree 54. */\n\tEP_K54,\n};\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Denotes a divisive twist.\n */\n#define RLC_EP_DTYPE\t\t\t1\n\n/**\n * Denotes a multiplicative twist.\n */\n#define RLC_EP_MTYPE\t\t\t2\n\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_EP_TABLE_BASIC\t\t(RLC_FP_BITS + 1)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_EP_TABLE_COMBS      (1 << EP_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_EP_TABLE_COMBD\t\t(1 << (EP_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_EP_TABLE_LWNAF\t\t(1 << (EP_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if EP_FIX == BASIC\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_BASIC\n#elif EP_FIX == COMBS\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_COMBS\n#elif EP_FIX == COMBD\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_COMBD\n#elif EP_FIX == LWNAF\n#define RLC_EP_TABLE\t\t\tRLC_EP_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_EP_TABLE_MAX \t\tRLC_EP_TABLE\n#else\n#define RLC_EP_TABLE_MAX \t\tRLC_MAX(RLC_EP_TABLE_BASIC, RLC_EP_TABLE_COMBD)\n#endif\n\n/**\n * Maximum number of coefficients of an isogeny map polynomial.\n * RLC_TERMS of value 16 is sufficient for a degree-11 isogeny polynomial.\n */\n#define RLC_EP_CTMAP_MAX\t\t16\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over a prime field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp_st x;\n\t/** The second coordinate. */\n\tfp_st y;\n\t/** The third coordinate (projective representation). */\n\tfp_st z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep_st ep_t[1];\n#else\n#ifdef CHECK\ntypedef ep_st *volatile ep_t;\n#else\ntypedef ep_st *ep_t;\n#endif\n#endif\n\n/**\n * Data structure representing an isogeny map.\n */\ntypedef struct {\n\t/** The a-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp_st a;\n\t/** The b-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp_st b;\n\t/** Degree of x numerator */\n\tint deg_xn;\n\t/** Degree of x denominator */\n\tint deg_xd;\n\t/** Degree of y numerator */\n\tint deg_yn;\n\t/** Degree of y denominator */\n\tint deg_yd;\n\t/** x numerator coefficients */\n\tfp_st xn[RLC_EP_CTMAP_MAX];\n\t/** x denominator coefficients */\n\tfp_st xd[RLC_EP_CTMAP_MAX];\n\t/** y numerator coefficients */\n\tfp_st yn[RLC_EP_CTMAP_MAX];\n\t/** y denominator coefficients */\n\tfp_st yd[RLC_EP_CTMAP_MAX];\n} iso_st;\n\n/**\n * Pointer to isogeny map coefficients.\n */\ntypedef iso_st *iso_t;\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a point on a prime elliptic curve with a null value.\n *\n * @param[out] A\t\t\t- the point to initialize.\n */\n#if ALLOC == AUTO\n#define ep_null(A)\t\t\t\t/* empty */\n#else\n#define ep_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a point on a prime elliptic curve.\n *\n * @param[out] A\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ep_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ep_t)calloc(1, sizeof(ep_st));\t\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep_new(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on a prime elliptic curve.\n *\n * @param[out] A\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ep_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\n\n#elif ALLOC == AUTO\n#define ep_free(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Adds two prime elliptic curve points. Computes R = P + Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t- the second point to add.\n */\n#if EP_ADD == BASIC\n#define ep_add(R, P, Q)\t\tep_add_basic(R, P, Q)\n#elif EP_ADD == PROJC\n#define ep_add(R, P, Q)\t\tep_add_projc(R, P, Q)\n#elif EP_ADD == JACOB\n#define ep_add(R, P, Q)\t\tep_add_jacob(R, P, Q)\n#endif\n\n/**\n * Doubles a prime elliptic curve point. Computes R = 2P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to double.\n */\n#if EP_ADD == BASIC\n#define ep_dbl(R, P)\t\tep_dbl_basic(R, P)\n#elif EP_ADD == PROJC\n#define ep_dbl(R, P)\t\tep_dbl_projc(R, P)\n#elif EP_ADD == JACOB\n#define ep_dbl(R, P)\t\tep_dbl_jacob(R, P)\n#endif\n\n/**\n * Multiplies a prime elliptic curve point by an integer. Computes R = [k]P.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t- the integer.\n */\n#if EP_MUL == BASIC\n#define ep_mul(R, P, K)\t\tep_mul_basic(R, P, K)\n#elif EP_MUL == SLIDE\n#define ep_mul(R, P, K)\t\tep_mul_slide(R, P, K)\n#elif EP_MUL == MONTY\n#define ep_mul(R, P, K)\t\tep_mul_monty(R, P, K)\n#elif EP_MUL == LWNAF\n#define ep_mul(R, P, K)\t\tep_mul_lwnaf(R, P, K)\n#elif EP_MUL == LWREG\n#define ep_mul(R, P, K)\t\tep_mul_lwreg(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point.\n *\n * @param[out] T\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t- the point to multiply.\n */\n#if EP_FIX == BASIC\n#define ep_mul_pre(T, P)\tep_mul_pre_basic(T, P)\n#elif EP_FIX == COMBS\n#define ep_mul_pre(T, P)\tep_mul_pre_combs(T, P)\n#elif EP_FIX == COMBD\n#define ep_mul_pre(T, P)\tep_mul_pre_combd(T, P)\n#elif EP_FIX == LWNAF\n#define ep_mul_pre(T, P)\tep_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] T\t\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_FIX == BASIC\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_basic(R, T, K)\n#elif EP_FIX == COMBS\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_combs(R, T, K)\n#elif EP_FIX == COMBD\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_combd(R, T, K)\n#elif EP_FIX == LWNAF\n#define ep_mul_fix(R, T, K)\t\tep_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously.\n * Computes R = [k]P + [m]Q.\n *\n * @param[out] R\t\t\t- the result.\n * @param[in] P\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t- the second integer,\n */\n#if EP_SIM == BASIC\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_basic(R, P, K, Q, M)\n#elif EP_SIM == TRICK\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_trick(R, P, K, Q, M)\n#elif EP_SIM == INTER\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_inter(R, P, K, Q, M)\n#elif EP_SIM == JOINT\n#define ep_mul_sim(R, P, K, Q, M)\tep_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the prime elliptic curve arithmetic module.\n */\nvoid ep_curve_init(void);\n\n/**\n * Finalizes the prime elliptic curve arithmetic module.\n */\nvoid ep_curve_clean(void);\n\n/**\n * Returns the a-coefficient of the currently configured prime elliptic curve.\n *\n * @return the a-coefficient of the elliptic curve.\n */\ndig_t *ep_curve_get_a(void);\n\n/**\n * Returns the b-coefficient of the currently configured prime elliptic curve.\n *\n * @return the b-coefficient of the elliptic curve.\n */\ndig_t *ep_curve_get_b(void);\n\n/**\n * Returns the b3 = 3*b value used in elliptic curve arithmetic.\n *\n * @return the value b3 used in elliptic curve arithmetic.\n */\ndig_t *ep_curve_get_b3(void);\n\n/**\n * Returns the efficient endormorphism associated with the prime curve.\n */\ndig_t *ep_curve_get_beta(void);\n\n/**\n * Returns the parameter V1 of the prime curve.\n */\nvoid ep_curve_get_v1(bn_t v[]);\n\n/**\n * Returns the parameter V2 of the prime curve.\n */\nvoid ep_curve_get_v2(bn_t v[]);\n\n/**\n * Returns a optimization identifier based on the a-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep_curve_opt_a(void);\n\n/**\n * Returns a optimization identifier based on the b-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep_curve_opt_b(void);\n\n/**\n * Returns a optimization identifier based on the b-coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep_curve_opt_b3(void);\n\n/**\n * Multiplies a field element by the a-coefficient of the curve.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n */\nvoid ep_curve_mul_a(fp_t c, const fp_t a);\n\n/**\n * Multiplies a field element by the b-coefficient of the curve.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n */\nvoid ep_curve_mul_b(fp_t c, const fp_t a);\n\n/**\n * Multiplies a field element by the b3 value of the curve.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n */\nvoid ep_curve_mul_b3(fp_t c, const fp_t a);\n/**\n * Tests if the configured prime elliptic curve is a Koblitz curve.\n *\n * @return 1 if the prime elliptic curve is a Koblitz curve, 0 otherwise.\n */\nint ep_curve_is_endom(void);\n\n/**\n * Tests if the configured prime elliptic curve is supersingular.\n *\n * @return 1 if the prime elliptic curve is supersingular, 0 otherwise.\n */\nint ep_curve_is_super(void);\n\n/**\n * Tests if the configured prime elliptic curve is pairing-friendly.\n *\n * @return 0 if the prime elliptic curve is not pairing-friendly, and the\n * family identifier otherwise.\n */\nint ep_curve_is_pairf(void);\n\n/**\n * Tests if the current curve should use an isogeny map for the SSWU map.\n *\n * @return 1 if the curve uses an isogeny, and 0 otherwise.\n */\nint ep_curve_is_ctmap(void);\n\n/**\n * Returns the generator of the group of points in the prime elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ep_curve_get_gen(ep_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nconst ep_t *ep_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the prime elliptic curve.\n *\n * @param[out] r\t\t\t- the returned order.\n */\nvoid ep_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the binary elliptic curve.\n *\n * @param[out] n\t\t\t- the returned cofactor.\n */\nvoid ep_curve_get_cof(bn_t h);\n\n/**\n * Returns the isogeny map coefficients for use with the SSWU map.\n */\niso_t ep_curve_get_iso(void);\n\n/**\n * Configures a prime elliptic curve without endomorphisms by its coefficients\n * and generator.\n *\n * @param[in] a\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n * @param[in] u\t\t\t- the non-square used for hashing to this curve.\n * @param[in] ctmap\t- true if this curve will use an isogeny for mapping.\n */\nvoid ep_curve_set_plain(const fp_t a, const fp_t b, const ep_t g, const bn_t r,\n\t\tconst bn_t h, const fp_t u, int ctmap);\n\n/**\n * Configures a supersingular prime elliptic curve by its coefficients and\n * generator.\n *\n * @param[in] a\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n * @param[in] u\t\t\t- the non-square used for hashing to this curve.\n * @param[in] ctmap\t- true if this curve will use an isogeny for mapping.\n */\nvoid ep_curve_set_super(const fp_t a, const fp_t b, const ep_t g, const bn_t r,\n\t\tconst bn_t h, const fp_t u, int ctmap);\n\n/**\n * Configures a prime elliptic curve with endomorphisms by its coefficients and\n * generator.\n *\n * @param[in] a\t\t\t- the a-coefficient of the curve.\n * @param[in] b\t\t\t- the b-coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] beta\t\t- the constant associated with the endomorphism.\n * @param[in] l\t\t\t- the exponent corresponding to the endomorphism.\n * @param[in] h\t\t\t- the cofactor of the group order.\n * @param[in] u\t\t\t- the non-square used for hashing to this curve.\n * @param[in] ctmap\t- true if this curve will use an isogeny for mapping.\n */\nvoid ep_curve_set_endom(const fp_t a, const fp_t b, const ep_t g, const bn_t r,\n\t\tconst bn_t h, const fp_t beta, const bn_t l, const fp_t u, int ctmap);\n\n/**\n * Configures a prime elliptic curve by its parameter identifier.\n *\n * @param\t\t\t\t- the parameter identifier.\n */\nvoid ep_param_set(int param);\n\n/**\n * Configures some set of curve parameters for the current security level.\n */\nint ep_param_set_any(void);\n\n/**\n * Configures some set of ordinary curve parameters for the current security\n * level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_plain(void);\n\n/**\n * Configures some set of Koblitz curve parameters for the current security\n * level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_endom(void);\n\n/**\n * Configures some set of supersingular curve parameters for the current\n * security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_super(void);\n\n/**\n * Configures some set of pairing-friendly curve parameters for the current\n * security level.\n *\n * @return RLC_OK if there is a curve at this security level, RLC_ERR otherwise.\n */\nint ep_param_set_any_pairf(void);\n\n/**\n * Returns the parameter identifier of the currently configured prime elliptic\n * curve.\n *\n * @return the parameter identifier.\n */\nint ep_param_get(void);\n\n/**\n * Prints the current configured prime elliptic curve.\n */\nvoid ep_param_print(void);\n\n/**\n * Returns the current security level.\n */\nint ep_param_level(void);\n\n/**\n * Returns the embedding degree of the currently configured elliptic curve.\n */\nint ep_param_embed(void);\n\n/**\n * Tests if a point on a prime elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ep_is_infty(const ep_t p);\n\n/**\n * Assigns a prime elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid ep_set_infty(ep_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t\t- the result.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to copy.\n */\nvoid ep_copy(ep_t r, const ep_t p);\n\n/**\n * Compares two prime elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first prime elliptic curve point.\n * @param[in] q\t\t\t\t- the second prime elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ep_cmp(const ep_t p, const ep_t q);\n\n/**\n * Assigns a random value to a prime elliptic curve point.\n *\n * @param[out] p\t\t\t- the prime elliptic curve point to assign.\n */\nvoid ep_rand(ep_t p);\n\n/**\n * Randomizes coordinates of a prime elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded prime elliptic curve point.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to blind.\n */\nvoid ep_blind(ep_t r, const ep_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * prime elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep_rhs(fp_t rhs, const ep_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint ep_on_curve(const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a random prime elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ep_tab(ep_t *t, const ep_t p, int w);\n\n/**\n * Prints a prime elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the prime elliptic curve point to print.\n */\nvoid ep_print(const ep_t p);\n\n/**\n * Returns the number of bytes necessary to store a prime elliptic curve point\n * with optional point compression.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ep_size_bin(const ep_t a, int pack);\n\n/**\n * Reads a prime elliptic curve point from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep_read_bin(ep_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a prime elliptic curve point to a byte vector in big-endian format\n * with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep_write_bin(uint8_t *bin, size_t len, const ep_t a, int pack);\n\n/**\n * Negates a prime elliptic curve point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to negate.\n */\nvoid ep_neg(ep_t r, const ep_t p);\n\n/**\n * Adds two prime elliptic curve points represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_basic(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Adds two prime elliptic curve points represented in affine coordinates and\n * returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_slp_basic(ep_t r, fp_t s, const ep_t p, const ep_t q);\n\n/**\n * Adds two prime elliptic curve points represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_projc(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Adds two prime elliptic curve points represented in Jacobian coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep_add_jacob(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Subtracts a prime elliptic curve point from another.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point.\n * @param[in] q\t\t\t\t- the second point.\n */\nvoid ep_sub(ep_t r, const ep_t p, const ep_t q);\n\n/**\n * Doubles a prime elliptic curve point represented in affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_basic(ep_t r, const ep_t p);\n\n/**\n * Doubles a prime elliptic curve point represented in affine coordinates and\n * returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_slp_basic(ep_t r, fp_t s, const ep_t p);\n\n/**\n * Doubles a prime elliptic curve point represented in projective coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_projc(ep_t r, const ep_t p);\n\n/**\n * Doubles a prime elliptic curve point represented in Jacobian projective\n * coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep_dbl_jacob(ep_t r, const ep_t p);\n\n/**\n * Computes the endomorphism map of a prime elliptic curve point.\n * Computes R = \\psi(P).\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep_psi(ep_t r, const ep_t p);\n\n/**\n * Multiplies a prime elliptic point by an integer using the binary method.\n * There is no restriction on the scalar.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_basic(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_slide(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_monty(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_lwnaf(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_lwreg(ep_t r, const ep_t p, const bn_t k);\n\n/**\n * Multiplies the generator of a prime elliptic curve by an integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_gen(ep_t r, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by a small positive integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_dig(ep_t r, const ep_t p, dig_t k);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_basic(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_yaowi(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_nafwi(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_combs(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_combd(ep_t *t, const ep_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep_mul_pre_lwnaf(ep_t *t, const ep_t p);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_basic(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_yaowi(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_nafwi(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_combs(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_combd(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep_mul_fix_lwnaf(ep_t r, const ep_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_basic(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_trick(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_inter(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep_mul_sim_joint(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m);\n\n/**\n * Multiplies and adds multiple elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep_mul_sim_lot(ep_t r, const ep_t p[], const bn_t k[], int n);\n\n/**\n * Multiplies and adds the generator and a prime elliptic curve point\n * simultaneously. Computes R = [k]G + [m]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer.\n */\nvoid ep_mul_sim_gen(ep_t r, const bn_t k, const ep_t q, const bn_t m);\n\n/**\n * Multiplies prime elliptic curve points by small scalars.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the points to multiply.\n * @param[in] k\t\t\t\t- the small scalars.\n * @param[in] n\t\t\t\t- the number of points to multiply.\n */\nvoid ep_mul_sim_dig(ep_t r, const ep_t p[], const dig_t k[], int n);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ep_norm(ep_t r, const ep_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ep_norm_sim(ep_t *r, const ep_t *t, int n);\n\n/**\n * Maps an array of uniformly random bytes to a point in a prime elliptic\n * curve.\n * That array is expected to have a length suitable for two field elements plus\n * extra bytes for uniformity.\n  *\n * @param[out] p\t\t\t- the result.\n * @param[in] uniform_bytes\t\t- the array of uniform bytes to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len);\n\n/**\n * Maps a byte array to a point in a prime elliptic curve.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep_map(ep_t p, const uint8_t *msg, size_t len);\n\n/**\n * Maps a byte array to a point in a prime elliptic curve with specified\n * domain separation tag (aka personalization string).\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ep_map_dst(ep_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len);\n\n/**\n * Compresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ep_pck(ep_t r, const ep_t p);\n\n/**\n * Decompresses a point.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return a boolean value indicating if the decompression was successful.\n */\nint ep_upk(ep_t r, const ep_t p);\n\n#endif /* !RLC_EP_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup epx Elliptic curves defined over extensions of prime fields.\n */\n\n/**\n * @file\n *\n * Interface of the module for arithmetic on prime elliptic curves defined over\n * extension fields.\n\n * The scalar multiplication functions are only guaranteed to work\n * in the prime order subgroup used by pairings. If you need a generic scalar\n * multiplication function, use \\sa ep2_mul_big().\n *\n * @ingroup epx\n */\n\n#ifndef RLC_EPX_H\n#define RLC_EPX_H\n\n#include \"relic_fpx.h\"\n#include \"relic_ep.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Size of a precomputation table using the binary method.\n */\n#define RLC_EPX_TABLE_BASIC\t\t(2 * RLC_FP_BITS + 1)\n\n/**\n * Size of a precomputation table using the single-table comb method.\n */\n#define RLC_EPX_TABLE_COMBS      (1 << EP_DEPTH)\n\n/**\n * Size of a precomputation table using the double-table comb method.\n */\n#define RLC_EPX_TABLE_COMBD\t\t(1 << (EP_DEPTH + 1))\n\n/**\n * Size of a precomputation table using the w-(T)NAF method.\n */\n#define RLC_EPX_TABLE_LWNAF\t\t(1 << (EP_DEPTH - 2))\n\n/**\n * Size of a precomputation table using the chosen algorithm.\n */\n#if EP_FIX == BASIC\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_BASIC\n#elif EP_FIX == COMBS\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_COMBS\n#elif EP_FIX == COMBD\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_COMBD\n#elif EP_FIX == LWNAF\n#define RLC_EPX_TABLE\t\t\tRLC_EPX_TABLE_LWNAF\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_EPX_TABLE_MAX \tRLC_EPX_TABLE\n#else\n#define RLC_EPX_TABLE_MAX \tRLC_MAX(RLC_EPX_TABLE_BASIC, RLC_EPX_TABLE_COMBD)\n#endif\n\n/**\n * Maximum number of coefficients of an isogeny map polynomial.\n * 4 is sufficient for a degree-3 isogeny polynomial.\n */\n#define RLC_EPX_CTMAP_MAX\t4\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents an elliptic curve point over a quadratic extension over a prime\n * field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp2_t x;\n\t/** The second coordinate. */\n\tfp2_t y;\n\t/** The third coordinate (projective representation). */\n\tfp2_t z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep2_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep2_st ep2_t[1];\n#else\ntypedef ep2_st *ep2_t;\n#endif\n\n/**\n * Represents an elliptic curve point over a cubic extension over a prime\n * field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp3_t x;\n\t/** The second coordinate. */\n\tfp3_t y;\n\t/** The third coordinate (projective representation). */\n\tfp3_t z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep3_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep3_st ep3_t[1];\n#else\ntypedef ep3_st *ep3_t;\n#endif\n\n/**\n * Represents an elliptic curve point over a quartic extension over a prime\n * field.\n */\ntypedef struct {\n\t/** The first coordinate. */\n\tfp4_t x;\n\t/** The second coordinate. */\n\tfp4_t y;\n\t/** The third coordinate (projective representation). */\n\tfp4_t z;\n\t/** Flag to indicate the coordinate system of this point. */\n\tint coord;\n} ep4_st;\n\n/**\n * Pointer to an elliptic curve point.\n */\n#if ALLOC == AUTO\ntypedef ep4_st ep4_t[1];\n#else\ntypedef ep4_st *ep4_t;\n#endif\n\n/**\n * Coefficients of an isogeny map for a curve over a quadratic extension.\n */\ntypedef struct {\n\t/** The a-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp2_t a;\n\t/** The b-coefficient of the isogenous curve used for SSWU mapping. */\n\tfp2_t b;\n\t/** Degree of x numerator */\n\tint deg_xn;\n\t/** Degree of x denominator */\n\tint deg_xd;\n\t/** Degree of y numerator */\n\tint deg_yn;\n\t/** Degree of y denominator */\n\tint deg_yd;\n\t/** x numerator coefficients */\n\tfp2_t xn[RLC_EPX_CTMAP_MAX];\n\t/** x denominator coefficients */\n\tfp2_t xd[RLC_EPX_CTMAP_MAX];\n\t/** y numerator coefficients */\n\tfp2_t yn[RLC_EPX_CTMAP_MAX];\n\t/** y denominator coefficients */\n\tfp2_t yd[RLC_EPX_CTMAP_MAX];\n} iso2_st;\n\n/**\n * Pointer to isogeny map coefficients.\n */\ntypedef iso2_st *iso2_t;\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a point on an elliptic curve with a null value.\n *\n * @param[out] A\t\t\t\t- the point to initialize.\n */\n#define ep2_null(A)\t\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ep2_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ep2_t)calloc(1, sizeof(ep2_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_null((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_null((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_null((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_new((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp2_new((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep2_new(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ep2_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep2_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Initializes a point on an elliptic curve with a null value.\n *\n * @param[out] A\t\t\t\t- the point to initialize.\n */\n#define ep4_null(A)\t\t\t\tRLC_NULL(A)\n\n/**\n * Calls a function to allocate a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the new point.\n * @throw ERR_NO_MEMORY\t\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define ep4_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tA = (ep4_t)calloc(1, sizeof(ep4_st));\t\t\t\t\t\t\t\t\t\\\n\tif (A == NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tRLC_THROW(ERR_NO_MEMORY);\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_null((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_null((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_null((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_new((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_new((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tfp4_new((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep4_new(A)\t\t\t\t/* empty */\n\n#endif\n\n/**\n * Calls a function to clean and free a point on an elliptic curve.\n *\n * @param[out] A\t\t\t\t- the point to free.\n */\n#if ALLOC == DYNAMIC\n#define ep4_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (A != NULL) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free((A)->x);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free((A)->y);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free((A)->z);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfree(A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tA = NULL;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n#elif ALLOC == AUTO\n#define ep4_free(A)\t\t\t\t/* empty */\n#endif\n\n/**\n * Adds two points in an elliptic curve over a quadratic extension field.\n * Computes R = P + Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t\t- the second point to add.\n */\n#if EP_ADD == BASIC\n#define ep2_add(R, P, Q)\t\tep2_add_basic(R, P, Q);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep2_add(R, P, Q)\t\tep2_add_projc(R, P, Q);\n#endif\n\n/**\n * Doubles a point in an elliptic curve over a quadratic extension field.\n * Computes R = 2P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to double.\n */\n#if EP_ADD == BASIC\n#define ep2_dbl(R, P)\t\t\tep2_dbl_basic(R, P);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep2_dbl(R, P)\t\t\tep2_dbl_projc(R, P);\n#endif\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field by\n * an unrestricted integer scalar. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#define ep2_mul_big(R, P, K)\tep2_mul_basic(R, P, K)\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_MUL == BASIC\n#define ep2_mul(R, P, K)\t\tep2_mul_basic(R, P, K)\n#elif EP_MUL == SLIDE\n#define ep2_mul(R, P, K)\t\tep2_mul_slide(R, P, K)\n#elif EP_MUL == MONTY\n#define ep2_mul(R, P, K)\t\tep2_mul_monty(R, P, K)\n#elif EP_MUL == LWNAF || EP_MUL == LWREG\n#define ep2_mul(R, P, K)\t\tep2_mul_lwnaf(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * over a quadratic extension.\n *\n * @param[out] T\t\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\n#if EP_FIX == BASIC\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_basic(T, P)\n#elif EP_FIX == COMBS\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_combs(T, P)\n#elif EP_FIX == COMBD\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_combd(T, P)\n#elif EP_FIX == LWNAF\n//TODO: implement ep2_mul_pre_glv\n#define ep2_mul_pre(T, P)\t\tep2_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed prime elliptic point over a quadratic extension using a\n * precomputation table. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] T\t\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_FIX == BASIC\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_basic(R, T, K)\n#elif EP_FIX == COMBS\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_combs(R, T, K)\n#elif EP_FIX == COMBD\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_combd(R, T, K)\n#elif EP_FIX == LWNAF\n//TODO: implement ep2_mul_fix_glv\n#define ep2_mul_fix(R, T, K)\tep2_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously. Computes\n * R = [k]P + [l]Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t\t- the second integer,\n */\n#if EP_SIM == BASIC\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_basic(R, P, K, Q, M)\n#elif EP_SIM == TRICK\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_trick(R, P, K, Q, M)\n#elif EP_SIM == INTER\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_inter(R, P, K, Q, M)\n#elif EP_SIM == JOINT\n#define ep2_mul_sim(R, P, K, Q, M)\tep2_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/**\n * Adds two points in an elliptic curve over a quadratic extension field.\n * Computes R = P + Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to add.\n * @param[in] Q\t\t\t\t\t- the second point to add.\n */\n#if EP_ADD == BASIC\n#define ep4_add(R, P, Q)\t\tep4_add_basic(R, P, Q);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep4_add(R, P, Q)\t\tep4_add_projc(R, P, Q);\n#endif\n\n/**\n * Doubles a point in an elliptic curve over a quadratic extension field.\n * Computes R = 2P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to double.\n */\n#if EP_ADD == BASIC\n#define ep4_dbl(R, P)\t\t\tep4_dbl_basic(R, P);\n#elif EP_ADD == PROJC || EP_ADD == JACOB\n#define ep4_dbl(R, P)\t\t\tep4_dbl_projc(R, P);\n#endif\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field by\n * an unrestricted integer scalar. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#define ep4_mul_big(R, P, K)\tep4_mul_basic(R, P, K)\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field.\n * Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_MUL == BASIC\n#define ep4_mul(R, P, K)\t\tep4_mul_basic(R, P, K)\n#elif EP_MUL == SLIDE\n#define ep4_mul(R, P, K)\t\tep4_mul_slide(R, P, K)\n#elif EP_MUL == MONTY\n#define ep4_mul(R, P, K)\t\tep4_mul_monty(R, P, K)\n#elif EP_MUL == LWNAF || EP_MUL == LWREG\n#define ep4_mul(R, P, K)\t\tep4_mul_lwnaf(R, P, K)\n#endif\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * over a quadratic extension.\n *\n * @param[out] T\t\t\t\t- the precomputation table.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\n#if EP_FIX == BASIC\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_basic(T, P)\n#elif EP_FIX == COMBS\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_combs(T, P)\n#elif EP_FIX == COMBD\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_combd(T, P)\n#elif EP_FIX == LWNAF\n//TODO: implement ep4_mul_pre_glv\n#define ep4_mul_pre(T, P)\t\tep4_mul_pre_lwnaf(T, P)\n#endif\n\n/**\n * Multiplies a fixed prime elliptic point over a quadratic extension using a\n * precomputation table. Computes R = [k]P.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] T\t\t\t\t\t- the precomputation table.\n * @param[in] K\t\t\t\t\t- the integer.\n */\n#if EP_FIX == BASIC\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_basic(R, T, K)\n#elif EP_FIX == COMBS\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_combs(R, T, K)\n#elif EP_FIX == COMBD\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_combd(R, T, K)\n#elif EP_FIX == LWNAF\n//TODO: implement ep4_mul_fix_glv\n#define ep4_mul_fix(R, T, K)\tep4_mul_fix_lwnaf(R, T, K)\n#endif\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously. Computes\n * R = [k]P + [l]Q.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the first point to multiply.\n * @param[in] K\t\t\t\t\t- the first integer.\n * @param[in] Q\t\t\t\t\t- the second point to multiply.\n * @param[in] M\t\t\t\t\t- the second integer,\n */\n#if EP_SIM == BASIC\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_basic(R, P, K, Q, M)\n#elif EP_SIM == TRICK\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_trick(R, P, K, Q, M)\n#elif EP_SIM == INTER\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_inter(R, P, K, Q, M)\n#elif EP_SIM == JOINT\n#define ep4_mul_sim(R, P, K, Q, M)\tep4_mul_sim_joint(R, P, K, Q, M)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the elliptic curve over quadratic extension.\n */\nvoid ep2_curve_init(void);\n\n/**\n * Finalizes the elliptic curve over quadratic extension.\n */\nvoid ep2_curve_clean(void);\n\n/**\n * Returns the 'a' coefficient of the currently configured elliptic curve.\n *\n * @return the 'a' coefficient of the elliptic curve.\n */\nfp_t *ep2_curve_get_a(void);\n\n/**\n * Returns the 'b' coefficient of the currently configured elliptic curve.\n *\n * @param[out] b\t\t\t- the 'b' coefficient of the elliptic curve.\n */\nfp_t *ep2_curve_get_b(void);\n\n/**\n * Returns the vector of coefficients required to perform GLV method.\n *\n * @param[out] b\t\t\t- the vector of coefficients.\n */\nvoid ep2_curve_get_vs(bn_t *v);\n\n/**\n * Returns a optimization identifier based on the 'a' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep2_curve_opt_a(void);\n\n/**\n * Returns b optimization identifier based on the 'b' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep2_curve_opt_b(void);\n\n/**\n * Tests if the configured elliptic curve is a twist.\n *\n * @return the type of the elliptic curve twist, 0 if non-twisted curve.\n */\nint ep2_curve_is_twist(void);\n\n/**\n * Tests if the current curve should use an isogeny map for the SSWU map.\n *\n * @return 1 if the curve uses an isogeny, and 0 otherwise.\n */\nint ep2_curve_is_ctmap(void);\n\n/**\n * Returns the generator of the group of points in the elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ep2_curve_get_gen(ep2_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nep2_t *ep2_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the elliptic curve.\n *\n * @param[out] n\t\t\t- the returned order.\n */\nvoid ep2_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the group order in the elliptic curve.\n *\n * @param[out] h\t\t\t- the returned cofactor.\n */\nvoid ep2_curve_get_cof(bn_t h);\n\n/**\n * Returns the isogeny map coefficients for use with the SSWU map.\n */\niso2_t ep2_curve_get_iso(void);\n\n/**\n * Configures an elliptic curve over a quadratic extension by its coefficients.\n *\n * @param[in] a\t\t\t- the 'a' coefficient of the curve.\n * @param[in] b\t\t\t- the 'b' coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n */\nvoid ep2_curve_set(const fp2_t a, const fp2_t b, const ep2_t g, const bn_t r, const bn_t h);\n\n/**\n * Configures an elliptic curve by twisting the curve over the base prime field.\n *\n *  @param\t\t\t\t- the type of twist (multiplicative or divisive)\n */\nvoid ep2_curve_set_twist(int type);\n\n/**\n * Tests if a point on an elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ep2_is_infty(const ep2_t p);\n\n/**\n * Assigns an elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid ep2_set_infty(ep2_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t\t- the result.\n * @param[in] p\t\t\t\t- the elliptic curve point to copy.\n */\nvoid ep2_copy(ep2_t r, const ep2_t p);\n\n/**\n * Compares two elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first elliptic curve point.\n * @param[in] q\t\t\t\t- the second elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ep2_cmp(const ep2_t p, const ep2_t q);\n\n/**\n * Assigns a random value to an elliptic curve point.\n *\n * @param[out] p\t\t\t- the elliptic curve point to assign.\n */\nvoid ep2_rand(ep2_t p);\n\n/**\n * Randomizes coordinates of an elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded prime elliptic curve point.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to blind.\n */\nvoid ep2_blind(ep2_t r, const ep2_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep2_rhs(fp2_t rhs, const ep2_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint ep2_on_curve(const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a random prime elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ep2_tab(ep2_t *t, const ep2_t p, int w);\n\n/**\n * Prints an elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the elliptic curve point to print.\n */\nvoid ep2_print(const ep2_t p);\n\n/**\n * Returns the number of bytes necessary to store a prime elliptic curve point\n * over a quadratic extension with optional point compression.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ep2_size_bin(const ep2_t a, int pack);\n\n/**\n * Reads a prime elliptic curve point over a quadratic extension from a byte\n * vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a prime elliptic curve pointer over a quadratic extension to a byte\n * vector in big-endian format with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate point compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack);\n\n/**\n * Negates a point represented in affine coordinates in an elliptic curve over\n * a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the point to negate.\n */\nvoid ep2_neg(ep2_t r, const ep2_t p);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep2_add_basic(ep2_t r, const ep2_t p, const ep2_t q);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quadratic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep2_add_slp_basic(ep2_t r, fp2_t s, const ep2_t p, const ep2_t q);\n\n/**\n * Adds two points represented in projective coordinates in an elliptic curve\n * over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep2_add_projc(ep2_t r, const ep2_t p, const ep2_t q);\n\n /**\n  * Subtracts a point i an elliptic curve over a quadratic extension from\n  * another.\n  *\n  * @param[out] r\t\t\t- the result.\n  * @param[in] p\t\t\t- the first point.\n  * @param[in] q\t\t\t- the point to subtract.\n  */\nvoid ep2_sub(ep2_t r, const ep2_t p, const ep2_t q);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[int] p\t\t\t- the point to double.\n */\nvoid ep2_dbl_basic(ep2_t r, const ep2_t p);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quadratic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep2_dbl_slp_basic(ep2_t r, fp2_t s, const ep2_t p);\n\n/**\n * Doubles a points represented in projective coordinates in an elliptic curve\n * over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep2_dbl_projc(ep2_t r, const ep2_t p);\n\n/**\n * Multiplies a prime elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_monty(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_lwnaf(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_lwreg(ep2_t r, const ep2_t p, const bn_t k);\n\n/**\n * Multiplies the generator of an elliptic curve over a qaudratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_gen(ep2_t r, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by a small integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_dig(ep2_t r, const ep2_t p, const dig_t k);\n\n\n/**\n * Multiplies a point in an elliptic curve over a quadratic extension field by\n * the curve cofactor or a small multiple for which a short vector exists.\n * In short, it takes a point in the curve to the large prime-order subgroup.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_cof(ep2_t r, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_basic(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_yaowi(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_nafwi(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_combs(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_combd(ep2_t *t, const ep2_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep2_mul_pre_lwnaf(ep2_t *t, const ep2_t p);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_basic(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_yaowi(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_nafwi(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_combs(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_combd(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep2_mul_fix_lwnaf(ep2_t r, const ep2_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_basic(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\t\tconst bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\t\tconst bn_t m);\n\n/**\n * Multiplies simultaneously elements from a prime elliptic curve.\n * Computes R = \\Sum_i=0..n k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the points to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n);\n\n/**\n * Multiplies and adds the generator and a prime elliptic curve point\n * simultaneously. Computes R = [k]G + [l]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m);\n\n/**\n * Multiplies prime elliptic curve points by small scalars.\n * Computes R = \\sum k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the points to multiply.\n * @param[in] k\t\t\t\t- the small scalars.\n * @param[in] len\t\t\t- the number of points to multiply.\n */\nvoid ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ep2_norm(ep2_t r, const ep2_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ep2_norm_sim(ep2_t *r, const ep2_t *t, int n);\n\n/**\n * Maps an array of uniformly random bytes to a point in a prime elliptic\n * curve.\n * That array is expected to have a length suitable for four field elements plus\n * extra bytes for uniformity.\n  *\n * @param[out] p\t\t\t- the result.\n * @param[in] uniform_bytes\t\t- the array of uniform bytes to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quadratic extension.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep2_map(ep2_t p, const uint8_t *msg, size_t len);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quadratic extension\n * using an explicit domain separation tag.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separatoin tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len);\n\n/**\n * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point\n * represented in affine coordinates on a twisted elliptic curve over a\n * quadratic exension. That is, Psi^i(P) = Twist(P)(Frob^i(unTwist(P)).\n * On the trace-zero group of a quadratic twist, consists of a power of the\n * Frobenius map of a point represented in affine coordinates in an elliptic\n * curve over a quadratic exension. Computes Frob^i(P) = (p^i)P.\n *\n * @param[out] r\t\t\t- the result in affine coordinates.\n * @param[in] p\t\t\t\t- a point in affine coordinates.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid ep2_frb(ep2_t r, const ep2_t p, int i);\n\n/**\n * Compresses a point in an elliptic curve over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ep2_pck(ep2_t r, const ep2_t p);\n\n/**\n * Decompresses a point in an elliptic curve over a quadratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint ep2_upk(ep2_t r, const ep2_t p);\n\n/**\n * Initializes the elliptic curve over quartic extension.\n */\nvoid ep4_curve_init(void);\n\n/**\n * Finalizes the elliptic curve over quartic extension.\n */\nvoid ep4_curve_clean(void);\n\n/**\n * Returns the 'a' coefficient of the currently configured elliptic curve.\n *\n * @return the 'a' coefficient of the elliptic curve.\n */\nvoid ep4_curve_get_a(fp4_t a);\n\n/**\n * Returns the 'b' coefficient of the currently configured elliptic curve.\n *\n * @param[out] b\t\t\t- the 'b' coefficient of the elliptic curve.\n */\nvoid ep4_curve_get_b(fp4_t b);\n\n/**\n * Returns the vector of coefficients required to perform GLV method.\n *\n * @param[out] b\t\t\t- the vector of coefficients.\n */\nvoid ep4_curve_get_vs(bn_t *v);\n\n/**\n * Returns a optimization identifier based on the 'a' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep4_curve_opt_a(void);\n\n/**\n * Returns b optimization identifier based on the 'b' coefficient of the curve.\n *\n * @return the optimization identifier.\n */\nint ep4_curve_opt_b(void);\n\n/**\n * Tests if the configured elliptic curve is a twist.\n *\n * @return the type of the elliptic curve twist, 0 if non-twisted curve.\n */\nint ep4_curve_is_twist(void);\n\n/**\n * Returns the generator of the group of points in the elliptic curve.\n *\n * @param[out] g\t\t\t- the returned generator.\n */\nvoid ep4_curve_get_gen(ep4_t g);\n\n/**\n * Returns the precomputation table for the generator.\n *\n * @return the table.\n */\nep4_t *ep4_curve_get_tab(void);\n\n/**\n * Returns the order of the group of points in the elliptic curve.\n *\n * @param[out] n\t\t\t- the returned order.\n */\nvoid ep4_curve_get_ord(bn_t n);\n\n/**\n * Returns the cofactor of the group order in the elliptic curve.\n *\n * @param[out] h\t\t\t- the returned cofactor.\n */\nvoid ep4_curve_get_cof(bn_t h);\n\n/**\n * Configures an elliptic curve over a quartic extension by its coefficients.\n *\n * @param[in] a\t\t\t- the 'a' coefficient of the curve.\n * @param[in] b\t\t\t- the 'b' coefficient of the curve.\n * @param[in] g\t\t\t- the generator.\n * @param[in] r\t\t\t- the order of the group of points.\n * @param[in] h\t\t\t- the cofactor of the group order.\n */\nvoid ep4_curve_set(const fp4_t a, const fp4_t b, const ep4_t g, const bn_t r, const bn_t h);\n\n/**\n * Configures an elliptic curve by twisting the curve over the base prime field.\n *\n *  @param\t\t\t\t- the type of twist (multiplicative or divisive)\n */\nvoid ep4_curve_set_twist(int type);\n\n/**\n * Tests if a point on an elliptic curve is at the infinity.\n *\n * @param[in] p\t\t\t\t- the point to test.\n * @return 1 if the point is at infinity, 0 otherise.\n */\nint ep4_is_infty(const ep4_t p);\n\n/**\n * Assigns an elliptic curve point to the point at infinity.\n *\n * @param[out] p\t\t\t- the point to assign.\n */\nvoid ep4_set_infty(ep4_t p);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] q\t\t\t- the result.\n * @param[in] p\t\t\t\t- the elliptic curve point to copy.\n */\nvoid ep4_copy(ep4_t r, const ep4_t p);\n\n/**\n * Compares two elliptic curve points.\n *\n * @param[in] p\t\t\t\t- the first elliptic curve point.\n * @param[in] q\t\t\t\t- the second elliptic curve point.\n * @return RLC_EQ if p == q and RLC_NE if p != q.\n */\nint ep4_cmp(const ep4_t p, const ep4_t q);\n\n/**\n * Assigns a random value to an elliptic curve point.\n *\n * @param[out] p\t\t\t- the elliptic curve point to assign.\n */\nvoid ep4_rand(ep4_t p);\n\n/**\n * Randomizes coordinates of an elliptic curve point.\n *\n * @param[out] r\t\t\t- the blinded prime elliptic curve point.\n * @param[in] p\t\t\t\t- the prime elliptic curve point to blind.\n */\nvoid ep4_blind(ep4_t r, const ep4_t p);\n\n/**\n * Computes the right-hand side of the elliptic curve equation at a certain\n * elliptic curve point.\n *\n * @param[out] rhs\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point.\n */\nvoid ep4_rhs(fp4_t rhs, const ep4_t p);\n\n/**\n * Tests if a point is in the curve.\n *\n * @param[in] p\t\t\t\t- the point to test.\n */\nint ep4_on_curve(const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a random prime elliptic point.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] w\t\t\t\t- the window width.\n */\nvoid ep4_tab(ep4_t *t, const ep4_t p, int w);\n\n/**\n * Prints an elliptic curve point.\n *\n * @param[in] p\t\t\t\t- the elliptic curve point to print.\n */\nvoid ep4_print(const ep4_t p);\n\n/**\n * Returns the number of bytes necessary to store a prime elliptic curve point\n * over a quartic extension with optional point compression.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint ep4_size_bin(const ep4_t a, int pack);\n\n/**\n * Reads a prime elliptic curve point over a quartic extension from a byte\n * vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_VALID\t\t- if the encoded point is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a prime elliptic curve pointer over a quartic extension to a byte\n * vector in big-endian format with optional point compression.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime elliptic curve point to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is invalid.\n */\nvoid ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack);\n\n/**\n * Negates a point represented in affine coordinates in an elliptic curve over\n * a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the point to negate.\n */\nvoid ep4_neg(ep4_t r, const ep4_t p);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep4_add_basic(ep4_t r, const ep4_t p, const ep4_t q);\n\n/**\n * Adds to points represented in affine coordinates in an elliptic curve over a\n * quartic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep4_add_slp_basic(ep4_t r, fp4_t s, const ep4_t p, const ep4_t q);\n\n/**\n * Adds two points represented in projective coordinates in an elliptic curve\n * over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to add.\n * @param[in] q\t\t\t\t- the second point to add.\n */\nvoid ep4_add_projc(ep4_t r, const ep4_t p, const ep4_t q);\n\n /**\n  * Subtracts a point i an elliptic curve over a quartic extension from\n  * another.\n  *\n  * @param[out] r\t\t\t- the result.\n  * @param[in] p\t\t\t- the first point.\n  * @param[in] q\t\t\t- the point to subtract.\n  */\nvoid ep4_sub(ep4_t r, const ep4_t p, const ep4_t q);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[int] p\t\t\t- the point to double.\n */\nvoid ep4_dbl_basic(ep4_t r, const ep4_t p);\n\n/**\n * Doubles a points represented in affine coordinates in an elliptic curve over\n * a quartic extension and returns the computed slope.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] s\t\t\t- the slope.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep4_dbl_slp_basic(ep4_t r, fp4_t s, const ep4_t p);\n\n/**\n * Doubles a points represented in projective coordinates in an elliptic curve\n * over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to double.\n */\nvoid ep4_dbl_projc(ep4_t r, const ep4_t p);\n\n/**\n * Multiplies a prime elliptic point by an integer using the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_basic(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the sliding window\n * method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the constant-time\n * Montgomery ladder point multiplication method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_monty(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using the w-NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_lwnaf(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by an integer using a regular method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_lwreg(ep4_t r, const ep4_t p, const bn_t k);\n\n/**\n * Multiplies the generator of an elliptic curve over a qaudratic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_gen(ep4_t r, const bn_t k);\n\n/**\n * Multiplies a prime elliptic point by a small integer.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_dig(ep4_t r, const ep4_t p, const dig_t k);\n\n\n/**\n * Multiplies a point in an elliptic curve over a quartic extension field by\n * the curve cofactor or a small multiple for which a short vector exists.\n * In short, it takes a point in the curve to the large prime-order subgroup.\n *\n * @param[out] R\t\t\t\t- the result.\n * @param[in] P\t\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_cof(ep4_t r, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the binary method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_basic(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using Yao's windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_yaowi(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the NAF windowing method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_nafwi(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the single-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_combs(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the double-table comb method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_combd(ep4_t *t, const ep4_t p);\n\n/**\n * Builds a precomputation table for multiplying a fixed prime elliptic point\n * using the w-(T)NAF method.\n *\n * @param[out] t\t\t\t- the precomputation table.\n * @param[in] p\t\t\t\t- the point to multiply.\n */\nvoid ep4_mul_pre_lwnaf(ep4_t *t, const ep4_t p);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the binary method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_basic(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * Yao's windowing method\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_yaowi(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_nafwi(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the single-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_combs(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the double-table comb method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_combd(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies a fixed prime elliptic point using a precomputation table and\n * the w-(T)NAF method.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the precomputation table.\n * @param[in] k\t\t\t\t- the integer.\n */\nvoid ep4_mul_fix_lwnaf(ep4_t r, const ep4_t *t, const bn_t k);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * scalar multiplication and point addition.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_basic(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * shamir's trick.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_trick(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * interleaving of NAFs.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_inter(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously using\n * Solinas' Joint Sparse Form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies simultaneously elements from a prime elliptic curve.\n * Computes R = \\Sum_i=0..n k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t- the points to multiply.\n * @param[in] k\t\t\t- the integer scalars.\n * @param[in] n\t\t\t- the number of elements to multiply.\n */\nvoid ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n);\n\n/**\n * Multiplies and adds the generator and a prime elliptic curve point\n * simultaneously. Computes R = [k]G + [l]Q.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] k\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t- the second integer,\n */\nvoid ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m);\n\n/**\n * Multiplies prime elliptic curve points by small scalars.\n * Computes R = \\sum k_iP_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the points to multiply.\n * @param[in] k\t\t\t\t- the small scalars.\n * @param[in] len\t\t\t- the number of points to multiply.\n */\nvoid ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len);\n\n/**\n * Converts a point to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to convert.\n */\nvoid ep4_norm(ep4_t r, const ep4_t p);\n\n/**\n * Converts multiple points to affine coordinates.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] t\t\t\t\t- the points to convert.\n * @param[in] n\t\t\t\t- the number of points.\n */\nvoid ep4_norm_sim(ep4_t *r, const ep4_t *t, int n);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quartic extension.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n */\nvoid ep4_map(ep4_t p, const uint8_t *msg, size_t len);\n\n/**\n * Maps a byte array to a point in an elliptic curve over a quartic extension\n * using an explicit domain separation tag.\n *\n * @param[out] p\t\t\t- the result.\n * @param[in] msg\t\t\t- the byte array to map.\n * @param[in] len\t\t\t- the array length in bytes.\n * @param[in] dst\t\t\t- the domain separatoin tag.\n * @param[in] dst_len\t\t- the domain separation tag length in bytes.\n */\nvoid ep4_map_dst(ep4_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len);\n\n/**\n * Computes a power of the Gailbraith-Lin-Scott homomorphism of a point\n * represented in affine coordinates on a twisted elliptic curve over a\n * quartic exension. That is, Psi^i(P) = Twist(P)(Frob^i(unTwist(P)).\n * On the trace-zero group of a quartic twist, consists of a power of the\n * Frobenius map of a point represented in affine coordinates in an elliptic\n * curve over a quartic exension. Computes Frob^i(P) = (p^i)P.\n *\n * @param[out] r\t\t\t- the result in affine coordinates.\n * @param[in] p\t\t\t\t- a point in affine coordinates.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid ep4_frb(ep4_t r, const ep4_t p, int i);\n\n/**\n * Compresses a point in an elliptic curve over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to compress.\n */\nvoid ep4_pck(ep4_t r, const ep4_t p);\n\n/**\n * Decompresses a point in an elliptic curve over a quartic extension.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the point to decompress.\n * @return if the decompression was successful\n */\nint ep4_upk(ep4_t r, const ep4_t p);\n\n#endif /* !RLC_EPX_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup fb Binary field arithmetic\n */\n\n/**\n * @file\n *\n * Interface of module for binary field arithmetic.\n *\n * @ingroup fb\n */\n\n#ifndef RLC_FB_H\n#define RLC_FB_H\n\n#include \"relic_bn.h\"\n#include \"relic_dv.h\"\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a binary field element.\n */\n#define RLC_FB_BITS \t((size_t)FB_POLYN)\n\n/**\n * Size in digits of a block sufficient to store a binary field element.\n */\n#define RLC_FB_DIGS\t\t((size_t)RLC_CEIL(RLC_FB_BITS, RLC_DIG))\n\n/**\n * Size in bytes of a block sufficient to store a binary field element.\n */\n#define RLC_FB_BYTES \t((size_t)RLC_CEIL(RLC_FB_BITS, 8))\n\n/**\n * Finite field identifiers.\n */\nenum {\n\t/** AES pentaonimal. */\n\tPENTA_8 = 1,\n\t/** Toy pentanomial. */\n\tPENTA_64,\n\t/** Hankerson's trinomial for GLS curves. */\n\tTRINO_113,\n\t/** Hankerson's trinomial for GLS curves. */\n\tTRINO_127,\n\t/** GCM pentanomial */\n\tPENTA_128,\n\t/** Pentanomial for ECC2K-130 challenge. */\n\tPENTA_131,\n\t/** NIST 163-bit fast reduction polynomial. */\n\tNIST_163,\n\t/** Square-root friendly 163-bit polynomial. */\n\tSQRT_163,\n\t/** Example with 193 bits for Itoh-Tsuji. */\n\tTRINO_193,\n\t/** NIST 233-bit fast reduction polynomial. */\n\tNIST_233,\n\t/** Square-root friendly 233-bit polynomial. */\n\tSQRT_233,\n\t/** SECG 239-bit fast reduction polynomial. */\n\tSECG_239,\n\t/** Square-root friendly 239-bit polynomial. */\n\tSQRT_239,\n\t/** Square-root friendly 251-bit polynomial. */\n\tSQRT_251,\n\t/** eBATS curve_2_251 pentanomial. */\n\tPENTA_251,\n\t/** Hankerson's trinomial for halving curve. */\n\tTRINO_257,\n\t/** Scott's 271-bit pairing-friendly trinomial. */\n\tTRINO_271,\n\t/** Scott's 271-bit pairing-friendly pentanomial. */\n\tPENTA_271,\n\t/** NIST 283-bit fast reduction polynomial. */\n\tNIST_283,\n\t/** Square-root friendly 283-bit polynomial. */\n\tSQRT_283,\n\t/** Scott's 271-bit pairing-friendly trinomial. */\n\tTRINO_353,\n\t/** Detrey's trinomial for genus 2 curves. */\n\tTRINO_367,\n\t/** NIST 409-bit fast reduction polynomial. */\n\tNIST_409,\n\t/** Hankerson's trinomial for genus 2 curves. */\n\tTRINO_439,\n\t/** NIST 571-bit fast reduction polynomial. */\n\tNIST_571,\n\t/** Square-root friendly 571-bit polynomial. */\n\tSQRT_571,\n\t/** Scott's 1223-bit pairing-friendly trinomial. */\n\tTRINO_1223\n};\n\n/**\n * Size of a precomputation table for repeated squaring/square-root using the\n * trivial approach.\n */\n#define RLC_FB_TABLE_BASIC\t\t(1)\n\n/**\n * Size of a precomputation table for repeated squaring/square-root using the\n * faster approach.\n */\n#define RLC_FB_TABLE_QUICK      ((RLC_DIG / 4) * RLC_FB_DIGS * 16)\n\n/**\n * Size of a precomputation table for repeated squaring/square-root using the\n * chosen algorithm.\n */\n#if FB_ITR == BASIC\n#define RLC_FB_TABLE \t\t\tRLC_FB_TABLE_BASIC\n#else\n#define RLC_FB_TABLE\t\t\tRLC_FB_TABLE_QUICK\n#endif\n\n/**\n * Maximum size of a precomputation table.\n */\n#ifdef STRIP\n#define RLC_FB_TABLE_MAX \t\tRLC_FB_TABLE\n#else\n#define RLC_FB_TABLE_MAX \t\tRLC_FB_TABLE_QUICK\n#endif\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a binary field element.\n */\n#if ALLOC == AUTO\ntypedef rlc_align dig_t fb_t[RLC_FB_DIGS + RLC_PAD(RLC_FB_BYTES) / (RLC_DIG / 8)];\n#else\ntypedef dig_t *fb_t;\n#endif\n\n/**\n * Represents a binary field element with automatic memory allocation.\n */\ntypedef rlc_align dig_t fb_st[RLC_FB_DIGS + RLC_PAD(RLC_FB_BYTES) / (RLC_DIG / 8)];\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a binary field element with a null value.\n *\n * @param[out] A\t\t\t- the binary field element to initialize.\n */\n#if ALLOC == AUTO\n#define fb_null(A)\t\t\t/* empty */\n#else\n#define fb_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate a binary field element.\n *\n * @param[out] A\t\t\t- the new binary field element.\n * @throw ERR_NO_MEMORY\t\t- if there is no available memory.\n */\n#if ALLOC == DYNAMIC\n#define fb_new(A)\t\t\tdv_new_dynam((dv_t *)&(A), RLC_FB_DIGS)\n#elif ALLOC == AUTO\n#define fb_new(A)\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to free a binary field element.\n *\n * @param[out] A\t\t\t- the binary field element to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define fb_free(A)\t\t\tdv_free_dynam((dv_t *)&(A))\n#elif ALLOC == AUTO\n#define fb_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Multiples two binary field elements. Computes c = a * b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first binary field element to multiply.\n * @param[in] B\t\t\t\t- the second binary field element to multiply.\n */\n#if FB_KARAT > 0\n#define fb_mul(C, A, B)\t\tfb_mul_karat(C, A, B)\n#elif FB_MUL == BASIC\n#define fb_mul(C, A, B)\t\tfb_mul_basic(C, A, B)\n#elif FB_MUL == INTEG\n#define fb_mul(C, A, B)\t\tfb_mul_integ(C, A, B)\n#elif FB_MUL == LODAH\n#define fb_mul(C, A, B)\t\tfb_mul_lodah(C, A, B)\n#endif\n\n/**\n * Squares a binary field element. Computes c = a * a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element to square.\n */\n#if FB_SQR == BASIC\n#define fb_sqr(C, A)\t\tfb_sqr_basic(C, A)\n#elif FB_SQR == QUICK\n#define fb_sqr(C, A)\t\tfb_sqr_quick(C, A)\n#elif FB_SQR == INTEG\n#define fb_sqr(C, A)\t\tfb_sqr_integ(C, A)\n#endif\n\n/**\n * Extracts the square root of a binary field element. Computes c = a^(1/2).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element.\n */\n#if FB_SRT == BASIC\n#define fb_srt(C, A)\t\tfb_srt_basic(C, A)\n#elif FB_SRT == QUICK\n#define fb_srt(C, A)\t\tfb_srt_quick(C, A)\n#endif\n\n/**\n * Reduces a multiplication result modulo a binary irreducible polynomial.\n * Computes c = a mod f(z).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiplication result to reduce.\n */\n#if FB_RDC == BASIC\n#define fb_rdc(C, A)\t\tfb_rdc_basic(C, A)\n#elif FB_RDC == QUICK\n#define fb_rdc(C, A)\t\tfb_rdc_quick(C, A)\n#endif\n\n/**\n * Compute the trace of a binary field element. Computes c = Tr(a).\n *\n * @param[in] A\t\t\t\t- the binary field element.\n * @return the trace of the binary field element.\n */\n#if FB_TRC == BASIC\n#define fb_trc(A)\t\t\tfb_trc_basic(A)\n#elif FB_TRC == QUICK\n#define fb_trc(A)\t\t\tfb_trc_quick(A)\n#endif\n\n/**\n * Solves a quadratic equation for c, Tr(a) = 0. Computes c such that\n * c^2 + c = a.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element.\n */\n#if FB_SLV == BASIC\n#define fb_slv(C, A)\t\tfb_slv_basic(C, A)\n#elif FB_SLV == QUICK\n#define fb_slv(C, A)\t\tfb_slv_quick(C, A)\n#endif\n\n/**\n * Inverts a binary field element. Computes c = a^{-1}.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element to invert.\n */\n#if FB_INV == BASIC\n#define fb_inv(C, A)\t\tfb_inv_basic(C, A)\n#elif FB_INV == BINAR\n#define fb_inv(C, A)\t\tfb_inv_binar(C, A)\n#elif FB_INV == EXGCD\n#define fb_inv(C, A)\t\tfb_inv_exgcd(C, A)\n#elif FB_INV == ALMOS\n#define fb_inv(C, A)\t\tfb_inv_almos(C, A)\n#elif FB_INV == ITOHT\n#define fb_inv(C, A)\t\tfb_inv_itoht(C, A)\n#elif FB_INV == BRUCH\n#define fb_inv(C, A)\t\tfb_inv_bruch(C, A)\n#elif FB_INV == CTAIA\n#define fb_inv(C, A)\t\tfb_inv_ctaia(C, A)\n#elif FB_INV == LOWER\n#define fb_inv(C, A)\t\tfb_inv_lower(C, A)\n#endif\n\n/**\n * Exponentiates a binary field element. Computes c = a^b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n */\n#if FB_EXP == BASIC\n#define fb_exp(C, A, B)\t\tfb_exp_basic(C, A, B)\n#elif FB_EXP == SLIDE\n#define fb_exp(C, A, B)\t\tfb_exp_slide(C, A, B)\n#elif FB_EXP == MONTY\n#define fb_exp(C, A, B)\t\tfb_exp_monty(C, A, B)\n#endif\n\n/**\n * Precomputed the table for repeated squaring/square-root.\n *\n * @param[out] T\t\t\t- the table.\n * @param[in] B\t\t\t\t- the exponent.\n */\n#if FB_ITR == BASIC\n#define fb_itr_pre(T, B)\t(void)(T), (void)(B)\n#elif FB_ITR == QUICK\n#define fb_itr_pre(T, B)\tfb_itr_pre_quick(T, B)\n#endif\n\n/**\n * Computes the repeated Frobenius (squaring) or inverse Frobenius (square-root)\n * of a binary field element. If the number of arguments is 3, then simple\n * consecutive squaring/square-root is used. If the number of arguments if 4,\n * then a table-based method is used and the fourth argument is\n * a pointer fo the precomputed table. The variant with 4 arguments\n * should be used when several 2^k/2^-k powers are computed with the same\n * k. Computes c = a^(2^b), where b can be positive or negative.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the binary field element to exponentiate.\n * @param[in] B\t\t\t\t- the exponent.\n * @param[in] ...\t\t\t- the modulus and an optional argument.\n */\n#define fb_itr(C, A, ...)\tRLC_CAT(fb_itr, RLC_OPT(__VA_ARGS__)) (C, A, __VA_ARGS__)\n\n/**\n * Reduces a multiple precision integer modulo another integer. This macro\n * should not be called directly. Use bn_mod() with 4 arguments instead.\n *\n * @param[out] C\t\t\t\t- the result.\n * @param[in] A\t\t\t\t\t- the binary field element to exponentiate.\n * @param[in] B\t\t\t\t\t- the exponent.\n * @param[in] T\t\t\t\t\t- the precomputed table for the exponent.\n */\n#if FB_ITR == BASIC\n#define fb_itr_imp(C, A, B, T)\t\tfb_itr_basic(C, A, B)\n#elif FB_ITR == QUICK\n#define fb_itr_imp(C, A, B, T)\t\tfb_itr_quick(C, A, T)\n#endif\n/*============================================================================*/\n\t\t/* Function prototypes                                                        */\n/*============================================================================*/\n/**\n * Initializes the binary field arithmetic layer.\n */\nvoid fb_poly_init(void);\n\n/**\n * Finalizes the binary field arithmetic layer.\n */\nvoid fb_poly_clean(void);\n\n/**\n * Returns the irreducible polynomial f(z) configured for the binary field.\n *\n * @return the irreducible polynomial.\n */\ndig_t *fb_poly_get(void);\n\n/**\n * Configures the irreducible polynomial of the binary field as a dense\n * polynomial.\n *\n * @param[in] f\t\t\t\t- the new irreducible polynomial.\n */\nvoid fb_poly_set_dense(const fb_t f);\n\n/**\n * Configures a trinomial as the irreducible polynomial by its non-zero\n * coefficients. The other coefficients are RLC_FB_BITS and 0.\n *\n * @param[in] a\t\t\t\t- the second coefficient.\n */\nvoid fb_poly_set_trino(int a);\n\n/**\n * Configures a pentanomial as the binary field modulo by its non-zero\n * coefficients. The other coefficients are RLC_FB_BITS and 0.\n *\n * @param[in] a\t\t\t\t- the second coefficient.\n * @param[in] b\t\t\t\t- the third coefficient.\n * @param[in] c\t\t\t\t- the fourth coefficient.\n */\nvoid fb_poly_set_penta(int a, int b, int c);\n\n/**\n * Returns the square root of z.\n *\n * @return the square root of z.\n */\ndig_t *fb_poly_get_srz(void);\n\n/**\n * Returns sqrt(z) * (i represented as a polynomial).\n *\n * @return the precomputed result.\n */\nconst dig_t *fb_poly_tab_srz(int i);\n\n/**\n * Returns a table for accelerating repeated squarings.\n *\n * @param the number of the table.\n * @return the precomputed result.\n */\nconst fb_st *fb_poly_tab_sqr(int i);\n\n/**\n * Returns an addition chain for (RLC_FB_BITS - 1).\n *\n * @param[out] len\t\t\t- the number of elements in the addition chain.\n *\n * @return a pointer to the addition chain.\n */\nconst int *fb_poly_get_chain(int *len);\n\n/**\n * Returns the non-zero coefficients of the configured trinomial or pentanomial.\n * If b is -1, the irreducible polynomial configured is a trinomial.\n * The other coefficients are RLC_FB_BITS and 0.\n *\n * @param[out] a\t\t\t- the second coefficient.\n * @param[out] b\t\t\t- the third coefficient.\n * @param[out] c\t\t\t- the fourth coefficient.\n */\nvoid fb_poly_get_rdc(int *a, int *b, int *c);\n\n/**\n * Returns the non-zero bits used to compute the trace function. The -1\n * coefficient is the last coefficient.\n *\n * @param[out] a\t\t\t- the first coefficient.\n * @param[out] b\t\t\t- the second coefficient.\n * @param[out] c\t\t\t- the third coefficient.\n */\nvoid fb_poly_get_trc(int *a, int *b, int *c);\n\n/**\n * Returns the table of precomputed half-traces.\n *\n * @return the table of half-traces.\n */\nconst dig_t *fb_poly_get_slv(void);\n\n/**\n * Assigns a standard irreducible polynomial as modulo of the binary field.\n *\n * @param[in] param\t\t\t- the standardized polynomial identifier.\n */\nvoid fb_param_set(int param);\n\n/**\n * Configures some finite field parameters for the current security level.\n */\nvoid fb_param_set_any(void);\n\n/**\n * Prints the currently configured irreducible polynomial.\n */\nvoid fb_param_print(void);\n\n/**\n * Adds a binary field element and the irreducible polynomial. Computes\n * c = a + f(z).\n *\n * @param[out] c\t\t\t- the destination.\n * @param[in] a\t\t\t\t- the binary field element.\n */\nvoid fb_poly_add(fb_t c, const fb_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to copy.\n */\nvoid fb_copy(fb_t c, const fb_t a);\n\n/**\n * Negates a binary field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the binary field element to negate.\n */\nvoid fb_neg(fb_t c, const fb_t a);\n\n/**\n * Assigns zero to a binary field element.\n *\n * @param[out] a\t\t\t- the binary field element to assign.\n */\nvoid fb_zero(fb_t a);\n\n/**\n * Tests if a binary field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the binary field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fb_is_zero(const fb_t a);\n\n/**\n * Reads the bit stored in the given position on a binary field element.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] bit\t\t\t- the bit position.\n * @return the bit value.\n */\nint fb_get_bit(const fb_t a, size_t bit);\n\n/**\n * Stores a bit in a given position on a binary field element.\n *\n * @param[out] a\t\t\t- the binary field element.\n * @param[in] bit\t\t\t- the bit position.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid fb_set_bit(fb_t a, size_t bit, int value);\n\n/**\n * Assigns a small positive polynomial to a binary field element.\n *\n * The degree of the polynomial must be smaller than RLC_DIG.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the small polynomial to assign.\n */\nvoid fb_set_dig(fb_t c, dig_t a);\n\n/**\n * Returns the number of bits of a binary field element.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @return the number of bits.\n */\nsize_t fb_bits(const fb_t a);\n\n/**\n * Assigns a random value to a binary field element.\n *\n * @param[out] a\t\t\t- the binary field element to assign.\n */\nvoid fb_rand(fb_t a);\n\n/**\n * Prints a binary field element to standard output.\n *\n * @param[in] a\t\t\t\t- the binary field element to print.\n */\nvoid fb_print(const fb_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a binary field\n * element. The radix must be a power of 2 included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nsize_t fb_size_str(const fb_t a, unsigned int radix);\n\n/**\n * Reads a binary field element from a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the string is too long.\n */\nvoid fb_read_str(fb_t a, const char *str, size_t len, unsigned int radix);\n\n/**\n * Writes a binary field element to a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the binary field element to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n */\nvoid fb_write_str(char *str, size_t len, const fb_t a, unsigned int radix);\n\n/**\n * Reads a binary field element from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.,\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fb_read_bin(fb_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a binary field element to a byte vector in big-endian format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the binary field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fb_write_bin(uint8_t *bin, size_t len, const fb_t a);\n\n/**\n * Returns the result of a comparison between two binary field elements.\n *\n * @param[in] a\t\t\t\t- the first binary field element.\n * @param[in] b\t\t\t\t- the second binary field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fb_cmp(const fb_t a, const fb_t b);\n\n/**\n * Returns the result of a comparison between a binary field element\n * and a small binary field element.\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] b\t\t\t\t- the small binary field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fb_cmp_dig(const fb_t a, dig_t b);\n\n/**\n * Adds two binary field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to add.\n * @param[in] b\t\t\t\t- the second binary field element to add.\n */\nvoid fb_add(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Adds a binary field element and a small binary field element.\n * Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to add.\n * @param[in] b\t\t\t\t- the small binary field element to add.\n */\nvoid fb_add_dig(fb_t c, const fb_t a, dig_t b);\n\n/**\n * Multiples two binary field elements using Shift-and-add multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to multiply.\n * @param[in] b\t\t\t\t- the second binary field element to multiply.\n */\nvoid fb_mul_basic(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Multiples two binary field elements using multiplication integrated with\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to multiply.\n * @param[in] b\t\t\t\t- the second binary field element to multiply.\n */\nvoid fb_mul_integ(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Multiples two binary field elements using Lopez-Dahab multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element to multiply.\n * @param[in] b\t\t\t\t- the second binary field element to multiply.\n */\nvoid fb_mul_lodah(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Multiplies a binary field element by a small binary field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element.\n * @param[in] b\t\t\t\t- the small binary field element to multiply.\n */\nvoid fb_mul_dig(fb_t c, const fb_t a, dig_t b);\n\n/**\n * Multiples two binary field elements using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first binary field element.\n * @param[in] b\t\t\t\t- the second binary field element.\n */\nvoid fb_mul_karat(fb_t c, const fb_t a, const fb_t b);\n\n/**\n * Squares a binary field element using bit-manipulation squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fb_sqr_basic(fb_t c, const fb_t a);\n\n/**\n * Squares a binary field element with integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fb_sqr_integ(fb_t c, const fb_t a);\n\n/**\n * Squares a binary field element using table-based squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fb_sqr_quick(fb_t c, const fb_t a);\n\n/**\n * Shifts a binary field element to the left. Computes c = a * z^bits mod f(z).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fb_lsh(fb_t c, const fb_t a, int bits);\n\n/**\n* Shifts a binary field element to the right. Computes c = a / (z^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fb_rsh(fb_t c, const fb_t a, int bits);\n\n/**\n * Reduces a multiplication result modulo an irreducible polynomial using\n * shift-and-add modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fb_rdc_basic(fb_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo a trinomial or pentanomial.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fb_rdc_quick(fb_t c, dv_t a);\n\n/**\n * Extracts the square root of a binary field element using repeated squaring.\n * Computes c = a^{1/2}.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to take a square root.\n */\nvoid fb_srt_basic(fb_t c, const fb_t a);\n\n/**\n * Extracts the square root of a binary field element using a fast square root\n * extraction algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to take a square root.\n */\nvoid fb_srt_quick(fb_t c, const fb_t a);\n\n/**\n * Computes the trace of a binary field element using repeated squaring.\n * Returns Tr(a).\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @return the trace of the binary field element.\n */\ndig_t fb_trc_basic(const fb_t a);\n\n/**\n * Computes the trace of a binary field element using a fast trace computation\n * algorithm. Returns Tr(a).\n *\n * @param[in] a\t\t\t\t- the binary field element.\n * @return the trace of the binary field element.\n */\ndig_t fb_trc_quick(const fb_t a);\n\n/**\n * Inverts a binary field element using Fermat's Little Theorem.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_basic(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_binar(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the Extended Euclidean algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_exgcd(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the Almost Inverse algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_almos(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using Itoh-Tsuji inversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_itoht(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using the hardware-friendly\n * Brunner-Curiger-Hofstetter algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_bruch(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element in constant-time using\n * the Wu-Wu-Shieh-Hwang algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_ctaia(fb_t c, const fb_t a);\n\n/**\n * Inverts a binary field element using a direct call to the lower layer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fb_inv_lower(fb_t c, const fb_t a);\n\n/**\n * Inverts multiple binary field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fb_inv_sim(fb_t *c, const fb_t *a, int n);\n\n/**\n * Exponentiates a binary field element through consecutive squaring. Computes\n * c = a^(2^b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_2b(fb_t c, const fb_t a, int b);\n\n/**\n * Exponentiates a binary field element using the binary\n * method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_basic(fb_t c, const fb_t a, const bn_t b);\n\n/**\n * Exponentiates a binary field element using the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_slide(fb_t c, const fb_t a, const bn_t b);\n\n/**\n * Exponentiates a binary field element using the constant-time Montgomery\n * powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_exp_monty(fb_t c, const fb_t a, const bn_t b);\n\n/**\n * Solves a quadratic equation for a, Tr(a) = 0 by repeated squarings and\n * additions.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to solve.\n */\nvoid fb_slv_basic(fb_t c, const fb_t a);\n\n/**\n * Solves a quadratic equation for a, Tr(a) = 0 with precomputed half-traces.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to solve.\n */\nvoid fb_slv_quick(fb_t c, const fb_t a);\n\n/**\n * Computes the iterated squaring/square-root of a binary field element by\n * consecutive squaring/square-root. Computes c = a^(2^b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_itr_basic(fb_t c, const fb_t a, int b);\n\n/**\n * Precomputes a table for iterated squaring/square-root of a binary field\n * element.\n *\n * @param[out] t\t\t\t- the precomputed table.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fb_itr_pre_quick(fb_st *t, int b);\n\n/**\n * Computes the iterated squaring/square-root of a binary field element by\n * a table based method. Computes c = a^(2^b).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] t\t\t\t\t- the precomputed table.\n */\nvoid fb_itr_quick(fb_t c, const fb_t a, const fb_st *t);\n\n#endif /* !RLC_FB_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup fp Prime field arithmetic\n */\n\n/**\n * @file\n *\n * Interface of the module for prime field arithmetic.\n *\n * @ingroup fp\n */\n\n#ifndef RLC_FP_H\n#define RLC_FP_H\n\n#include \"relic_dv.h\"\n#include \"relic_bn.h\"\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Precision in bits of a prime field element.\n */\n#define RLC_FP_BITS \t((size_t)FP_PRIME)\n\n/**\n * Size in digits of a block sufficient to store a prime field element.\n */\n#define RLC_FP_DIGS \t((size_t)RLC_CEIL(RLC_FP_BITS, RLC_DIG))\n\n/**\n * Size in bytes of a block sufficient to store a binary field element.\n */\n#define RLC_FP_BYTES \t((size_t)RLC_CEIL(RLC_FP_BITS, 8))\n\n/*\n * Finite field identifiers.\n */\nenum {\n\t/** SECG 160-bit fast reduction prime. */\n\tSECG_160 = 1,\n\t/** SECG 160-bit denser reduction prime. */\n\tSECG_160D,\n\t/** NIST 192-bit fast reduction prime. */\n\tNIST_192,\n\t/** SECG 192-bit denser reduction prime. */\n\tSECG_192,\n\t/** Curve22103 221-bit prime modulus. */\n\tPRIME_22103,\n\t/** NIST 224-bit fast reduction polynomial. */\n\tNIST_224,\n\t/** SECG 224-bit denser reduction prime. */\n\tSECG_224,\n\t/** Curve4417 226-bit prime modulus. */\n\tPRIME_22605,\n\t/* Curve1174 251-bit prime modulus. */\n\tPRIME_25109,\n\t/** Prime with high 2-adicity for curve Tweedledum. */\n\tPRIME_H2ADC,\n\t/** Curve25519 255-bit prime modulus. */\n\tPRIME_25519,\n\t/** NIST 256-bit fast reduction polynomial. */\n\tNIST_256,\n\t/** Brainpool random 256-bit prime. */\n\tBSI_256,\n\t/** SECG 256-bit denser reduction prime. */\n\tSECG_256,\n\t/** SM2 256-bit prime modulus standardized in China. */\n\tSM2_256,\n\t/** Curve67254 382-bit prime modulus. */\n\tPRIME_382105,\n\t/** Curve383187 383-bit prime modulus. */\n\tPRIME_383187,\n\t/** NIST 384-bit fast reduction polynomial. */\n\tNIST_384,\n\t/** Curve448 prime. */\n\tPRIME_448,\n\t/** Curve511187 511-bit prime modulus. */\n\tPRIME_511187,\n\t/** NIST 521-bit fast reduction polynomial. */\n\tNIST_521,\n\t/** 158-bit prime for BN curve. */\n\tBN_158,\n\t/** 254-bit prime provided in Nogami et al. for BN curves. */\n\tBN_254,\n\t/** 256-bit prime provided in Barreto et al. for BN curves. */\n\tBN_256,\n\t/** 256-bit prime provided for BN curve standardized in China. */\n\tSM9_256,\n\t/** 315-bit prime for BLS curve of embedding degree 24 (SNARKs). */\n\tB24_315,\n\t/** 317-bit prime for BLS curve of embedding degree 24 (SNARKs). */\n\tB24_317,\n\t/** 381-bit prime for BLS curve of embedding degree 12 (SNARKs). */\n\tB12_377,\n\t/** 381-bit prime for BLS curve of embedding degree 12 (Zcash). */\n\tB12_381,\n\t/** 382-bit prime provided by Barreto for BN curve. */\n\tBN_382,\n\t/** 383-bit prime for GT-strong BLS curve of embedding degree 12. */\n\tB12_383,\n\t/** 446-bit prime provided by Barreto for BN curve. */\n\tBN_446,\n\t/** 446-bit prime for BLS curve of embedding degree 12. */\n\tB12_446,\n\t/** 455-bit prime for BLS curve of embedding degree 12. */\n\tB12_455,\n\t/** 477-bit prime for BLS curve of embedding degree 24. */\n\tB24_509,\n\t/** 508-bit prime for KSS16 curve. */\n\tKSS_508,\n\t/** 511-bit prime for Optimal TNFS-secure curve. */\n\tOT_511,\n\t/** Random 544-bit prime for Cocks-Pinch curve with embedding degree 8. */\n\tGMT8_544,\n\t/** 569-bit prime for KSS curve with embedding degree 54. */\n\tK54_569,\n\t/** 575-bit prime for BLS curve with embedding degree 48. */\n\tB48_575,\n\t/** 638-bit prime provided in Barreto et al. for BN curve. */\n\tBN_638,\n\t/** 638-bit prime for BLS curve with embedding degree 12. */\n\tB12_638,\n\t/** 1536-bit prime for supersingular curve with embedding degree k = 2. */\n\tSS_1536,\n\t/** 3072-bit prime for supersingular curve with embedding degree k = 1. */\n\tSS_3072,\n};\n\n/**\n * Constant used to indicate that there's some room left in the storage of\n * prime field elements. This can be used to avoid carries.\n */\n#if ((FP_PRIME % WSIZE) != 0) && ((FP_PRIME % WSIZE) <= (WSIZE - 2))\n#if ((2 * FP_PRIME % WSIZE) != 0) && ((2 * FP_PRIME % WSIZE) <= (WSIZE - 2))\n#define RLC_FP_ROOM\n#else\n#undef RLC_FP_ROOM\n#endif\n#else\n#undef RLC_FP_ROOM\n#endif\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a prime field element.\n *\n * A field element is represented as a digit vector. These digits are organized\n * in little-endian format, that is, the least significant digits are\n * stored in the first positions of the vector.\n */\n#if ALLOC == AUTO\ntypedef rlc_align dig_t fp_t[RLC_FP_DIGS + RLC_PAD(RLC_FP_BYTES)/(RLC_DIG / 8)];\n#else\ntypedef dig_t *fp_t;\n#endif\n\n/**\n * Represents a prime field element with automatic memory allocation.\n */\ntypedef rlc_align dig_t fp_st[RLC_FP_DIGS + RLC_PAD(RLC_FP_BYTES)/(RLC_DIG / 8)];\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a binary field element with a null value.\n *\n * @param[out] A\t\t\t- the binary field element to initialize.\n */\n#if ALLOC == AUTO\n#define fp_null(A)\t\t\t/* empty */\n#else\n#define fp_null(A)\t\t\tA = NULL;\n#endif\n\n/**\n * Calls a function to allocate and initialize a prime field element.\n *\n * @param[out] A\t\t\t- the new prime field element.\n */\n#if ALLOC == DYNAMIC\n#define fp_new(A)\t\t\tdv_new_dynam((dv_t *)&(A), RLC_FP_DIGS)\n#elif ALLOC == AUTO\n#define fp_new(A)\t\t\t/* empty */\n#endif\n\n/**\n * Calls a function to clean and free a prime field element.\n *\n * @param[out] A\t\t\t- the prime field element to clean and free.\n */\n#if ALLOC == DYNAMIC\n#define fp_free(A)\t\t\tdv_free_dynam((dv_t *)&(A))\n#elif ALLOC == AUTO\n#define fp_free(A)\t\t\t/* empty */\n#endif\n\n/**\n * Adds two prime field elements. Computes c = a + b.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n * @param[in] B\t\t\t\t- the second prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_add(C, A, B)\t\tfp_add_basic(C, A, B)\n#elif FP_ADD == INTEG\n#define fp_add(C, A, B)\t\tfp_add_integ(C, A, B)\n#endif\n\n/**\n * Subtracts a prime field element from another. Computes C = A - B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n * @param[in] B\t\t\t\t- the second prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_sub(C, A, B)\t\tfp_sub_basic(C, A, B)\n#elif FP_ADD == INTEG\n#define fp_sub(C, A, B)\t\tfp_sub_integ(C, A, B)\n#endif\n\n/**\n * Negates a prime field element from another. Computes C = -A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to negate.\n */\n#if FP_ADD == BASIC\n#define fp_neg(C, A)\t\tfp_neg_basic(C, A)\n#elif FP_ADD == INTEG\n#define fp_neg(C, A)\t\tfp_neg_integ(C, A)\n#endif\n\n/**\n * Doubles a prime field element. Computes C = A + A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_dbl(C, A)\t\tfp_dbl_basic(C, A)\n#elif FP_ADD == INTEG\n#define fp_dbl(C, A)\t\tfp_dbl_integ(C, A)\n#endif\n\n/**\n * Halves a prime field element. Computes C = A/2.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n */\n#if FP_ADD == BASIC\n#define fp_hlv(C, A)\t\tfp_hlv_basic(C, A)\n#elif FP_ADD == INTEG\n#define fp_hlv(C, A)\t\tfp_hlv_integ(C, A)\n#endif\n\n/**\n * Multiples two prime field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first prime field element.\n * @param[in] B\t\t\t\t- the second prime field element.\n */\n#if FP_KARAT > 0\n#define fp_mul(C, A, B)\t\tfp_mul_karat(C, A, B)\n#elif FP_MUL == BASIC\n#define fp_mul(C, A, B)\t\tfp_mul_basic(C, A, B)\n#elif FP_MUL == COMBA\n#define fp_mul(C, A, B)\t\tfp_mul_comba(C, A, B)\n#elif FP_MUL == INTEG\n#define fp_mul(C, A, B)\t\tfp_mul_integ(C, A, B)\n#endif\n\n/**\n * Squares a prime field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to square.\n */\n#if FP_KARAT > 0\n#define fp_sqr(C, A)\t\tfp_sqr_karat(C, A)\n#elif FP_SQR == BASIC\n#define fp_sqr(C, A)\t\tfp_sqr_basic(C, A)\n#elif FP_SQR == COMBA\n#define fp_sqr(C, A)\t\tfp_sqr_comba(C, A)\n#elif FP_SQR == MULTP\n#define fp_sqr(C, A)\t\tfp_mul(C, A, A)\n#elif FP_SQR == INTEG\n#define fp_sqr(C, A)\t\tfp_sqr_integ(C, A)\n#endif\n\n/**\n * Reduces a multiplication result modulo a prime field order. Computes\n * C = A mod p.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiplication result to reduce.\n */\n#if FP_RDC == BASIC\n#define fp_rdc(C, A)\t\tfp_rdc_basic(C, A)\n#elif FP_RDC == MONTY\n#define fp_rdc(C, A)\t\tfp_rdc_monty(C, A)\n#elif FP_RDC == QUICK\n#define fp_rdc(C, A)\t\tfp_rdc_quick(C, A)\n#endif\n\n/**\n * Reduces a multiplication result modulo a prime field order using Montgomery\n * modular reduction.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the multiplication result to reduce.\n */\n#if FP_MUL == BASIC\n#define fp_rdc_monty(C, A)\tfp_rdc_monty_basic(C, A)\n#else\n#define fp_rdc_monty(C, A)\tfp_rdc_monty_comba(C, A)\n#endif\n\n/**\n * Inverts a prime field element. Computes C = A^{-1}.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to invert.\n */\n#if FP_INV == BASIC\n#define fp_inv(C, A)\tfp_inv_basic(C, A)\n#elif FP_INV == BINAR\n#define fp_inv(C, A)\tfp_inv_binar(C, A)\n#elif FP_INV == MONTY\n#define fp_inv(C, A)\tfp_inv_monty(C, A)\n#elif FP_INV == EXGCD\n#define fp_inv(C, A)\tfp_inv_exgcd(C, A)\n#elif FP_INV == DIVST\n#define fp_inv(C, A)\tfp_inv_divst(C, A)\n#elif FP_INV == JMPDS\n#define fp_inv(C, A)\tfp_inv_jmpds(C, A)\n#elif FP_INV == LOWER\n#define fp_inv(C, A)\tfp_inv_lower(C, A)\n#endif\n\n/**\n * Computes the Legendre symbol of a prime field element. Computes C = (A|P).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the prime field element to compute.\n */\n#if FP_SMB == BASIC\n#define fp_smb(A)\t\tfp_smb_basic(A)\n#elif FP_SMB == BINAR\n#define fp_smb(A)\t\tfp_smb_binar(A)\n#elif FP_SMB == DIVST\n#define fp_smb(A)\t\tfp_smb_divst(A)\n#elif FP_SMB == JMPDS\n#define fp_smb(A)\t\tfp_smb_jmpds(A)\n#elif FP_SMB == LOWER\n#define fp_smb(A)\t\tfp_smb_lower(A)\n#endif\n\n/**\n * Exponentiates a prime field element. Computes C = A^B (mod p).\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the basis.\n * @param[in] B\t\t\t\t- the exponent.\n */\n#if FP_EXP == BASIC\n#define fp_exp(C, A, B)\t\tfp_exp_basic(C, A, B)\n#elif FP_EXP == SLIDE\n#define fp_exp(C, A, B)\t\tfp_exp_slide(C, A, B)\n#elif FP_EXP == MONTY\n#define fp_exp(C, A, B)\t\tfp_exp_monty(C, A, B)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the prime field arithmetic layer.\n */\nvoid fp_prime_init(void);\n\n/**\n * Finalizes the prime field arithmetic layer.\n */\nvoid fp_prime_clean(void);\n\n/**\n * Returns the order of the prime field.\n *\n * @return the order of the prime field.\n */\nconst dig_t *fp_prime_get(void);\n\n/**\n * Returns the additional value used for modular reduction.\n *\n * @return the additional value used for modular reduction.\n */\nconst dig_t *fp_prime_get_rdc(void);\n\n/**\n * Returns the additional value used for conversion from multiple precision\n * integer to prime field element.\n *\n * @return the additional value used for importing integers.\n */\nconst dig_t *fp_prime_get_conv(void);\n\n/**\n * Returns the result of prime order mod 8.\n *\n * @return the result of prime order mod 8.\n */\ndig_t fp_prime_get_mod8(void);\n\n/**\n * Returns the prime stored in special form. The most significant bit is\n * RLC_FP_BITS.\n *\n * @param[out] len\t\t- the number of returned bits, can be NULL.\n *\n * @return the prime represented by it non-zero bits.\n */\nconst int *fp_prime_get_sps(int *len);\n\n/**\n * Returns a non-quadratic residue in the prime field.\n *\n * @return the non-quadratic residue.\n */\nint fp_prime_get_qnr(void);\n\n/**\n * Returns a non-cubic residue in the prime field.\n *\n * @return the non-cubic residue.\n */\nint fp_prime_get_cnr(void);\n\n/**\n * Returns the 2-adicity of the prime modulus.\n *\n * @return the 2-adicity of the modulus.\n */\nint fp_prime_get_2ad(void);\n\n/**\n * Returns the prime field parameter identifier.\n *\n * @return the parameter identifier.\n */\nint fp_param_get(void);\n\n/**\n * Assigns the prime field modulus to a non-sparse prime.\n *\n * @param[in] p\t\t\t- the new prime field modulus.\n */\nvoid fp_prime_set_dense(const bn_t p);\n\n/**\n * Assigns the prime field modulus to a special form sparse prime.\n *\n * @param[in] spars\t\t- the list of powers of 2 describing the prime.\n * @param[in] len\t\t- the number of powers.\n */\nvoid fp_prime_set_pmers(const int *spars, size_t len);\n\n/**\n * Assigns the prime field modulus to a parametrization from a family of\n * pairing-friendly curves.\n */\nvoid fp_prime_set_pairf(const bn_t x, int pairf);\n\n/**\n * Computes the constants needed for evaluating Frobenius maps in higher\n * extension fields.\n */\nvoid fp_prime_calc(void);\n\n/**\n * Imports a multiple precision integer as a prime field element, doing the\n * necessary conversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiple precision integer to import.\n */\nvoid fp_prime_conv(fp_t c, const bn_t a);\n\n/**\n * Imports a single digit as a prime field element, doing the necessary\n * conversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the digit to import.\n */\nvoid fp_prime_conv_dig(fp_t c, dig_t a);\n\n/**\n * Exports a prime field element as a multiple precision integer, doing the\n * necessary conversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to export.\n */\nvoid fp_prime_back(bn_t c, const fp_t a);\n\n/**\n * Assigns a prime modulus based on its identifier.\n */\nvoid fp_param_set(int param);\n\n/**\n * Assigns any pre-defined parameter as the prime modulus.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any(void);\n\n/**\n * Assigns the order of the prime field to any non-sparse prime.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_dense(void);\n\n/**\n * Assigns the order of the prime field to any sparse prime.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_pmers(void);\n\n/**\n * Assigns the order of the prime field to any towering-friendly prime.\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_tower(void);\n\n/**\n * Assigns the order of the prime field to a prime with high 2-adicity..\n *\n * @return RLC_OK if no errors occurred; RLC_ERR otherwise.\n */\nint fp_param_set_any_h2adc(void);\n\n/**\n * Prints the currently configured prime modulus.\n */\nvoid fp_param_print(void);\n\n/**\n * Returns the variable used to parametrize the given prime modulus.\n *\n * @param[out] x\t\t\t- the integer parameter.\n */\nvoid fp_prime_get_par(bn_t x);\n\n/**\n * Returns the absolute value of the variable used to parameterize the given\n * prime modulus in sparse form.\n *\n * @param[out] len\t\t\t- the length of the representation.\n */\nconst int *fp_prime_get_par_sps(int *len);\n\n/**\n * Returns the absolute value of the variable used to parameterize the currently\n * configured prime modulus in sparse form. The first argument must be an array\n * of size (RLC_TERMS + 1).\n *\n * @param[out] s\t\t\t- the parameter in sparse form.\n * @param[out] len\t\t\t- the length of the parameter in sparse form.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the current configuration is invalid.\n * @return the integer parameter in sparse form.\n */\nvoid fp_param_get_sps(int *s, int *len);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to copy.\n */\nvoid fp_copy(fp_t c, const fp_t a);\n\n/**\n * Assigns zero to a prime field element.\n *\n * @param[out] a\t\t\t- the prime field element to asign.\n */\nvoid fp_zero(fp_t a);\n\n/**\n * Tests if a prime field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the prime field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp_is_zero(const fp_t a);\n\n/**\n * Tests if a prime field element is even or odd.\n *\n * @param[in] a\t\t\t\t- the prime field element to test.\n * @return 1 if the argument is even, 0 otherwise.\n */\nint fp_is_even(const fp_t a);\n\n/**\n * Reads the bit stored in the given position on a prime field element.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] bit\t\t\t- the bit position.\n * @return the bit value.\n */\nint fp_get_bit(const fp_t a, size_t bit);\n\n/**\n * Stores a bit in a given position on a prime field element.\n *\n * @param[out] a\t\t\t- the prime field element.\n * @param[in] bit\t\t\t- the bit position.\n * @param[in] value\t\t\t- the bit value.\n */\nvoid fp_set_bit(fp_t a, size_t bit, int value);\n\n/**\n * Assigns a small positive constant to a prime field element.\n *\n * The constant must fit on a multiple precision digit, or dig_t type using\n * only the number of bits specified on RLC_DIG.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the constant to assign.\n */\nvoid fp_set_dig(fp_t c, dig_t a);\n\n/**\n * Returns the number of bits of a prime field element.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @return the number of bits.\n */\nsize_t fp_bits(const fp_t a);\n\n/**\n * Assigns a random value to a prime field element.\n *\n * @param[out] a\t\t\t- the prime field element to assign.\n */\nvoid fp_rand(fp_t a);\n\n/**\n * Prints a prime field element to standard output.\n *\n * @param[in] a\t\t\t\t- the prime field element to print.\n */\nvoid fp_print(const fp_t a);\n\n/**\n * Returns the number of digits in radix necessary to store a multiple precision\n * integer. The radix must be a power of 2 included in the interval [2, 64].\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n * @return the number of digits in the given radix.\n */\nsize_t fp_size_str(const fp_t a, unsigned int radix);\n\n/**\n * Reads a prime field element from a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] str\t\t\t- the string.\n * @param[in] len\t\t\t- the size of the string.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid fp_read_str(fp_t a, const char *str, size_t len, unsigned int radix);\n\n/**\n * Writes a prime field element to a string in a given radix. The radix must\n * be a power of 2 included in the interval [2, 64].\n *\n * @param[out] str\t\t\t- the string.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime field element to write.\n * @param[in] radix\t\t\t- the radix.\n * @throw ERR_BUFFER\t\t- if the buffer capacity is insufficient.\n * @throw ERR_NO_VALID\t\t- if the radix is invalid.\n */\nvoid fp_write_str(char *str, size_t len, const fp_t a, unsigned int radix);\n\n/**\n * Reads a prime field element from a byte vector in big-endian format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fp_read_bin(fp_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a prime field element to a byte vector in big-endian format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the prime field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not RLC_FP_BYTES.\n */\nvoid fp_write_bin(uint8_t *bin, size_t len, const fp_t a);\n\n/**\n * Returns the result of a comparison between two prime field elements.\n *\n * @param[in] a\t\t\t\t- the first prime field element.\n * @param[in] b\t\t\t\t- the second prime field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp_cmp(const fp_t a, const fp_t b);\n\n/**\n * Returns the result of a signed comparison between a prime field element\n * and a digit.\n *\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp_cmp_dig(const fp_t a, dig_t b);\n\n/**\n * Adds two prime field elements using basic addition. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n * @param[in] b\t\t\t\t- the second prime field element to add.\n */\nvoid fp_add_basic(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Adds two prime field elements with integrated modular reduction. Computes\n * c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n * @param[in] b\t\t\t\t- the second prime field element to add.\n */\nvoid fp_add_integ(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Adds a prime field element and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid fp_add_dig(fp_t c, const fp_t a, dig_t b);\n\n/**\n * Subtracts a prime field element from another using basic subtraction.\n * Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the prime field element to subtract.\n */\nvoid fp_sub_basic(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Subtracts a prime field element from another with integrated modular\n * reduction. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the prime field element to subtract.\n */\nvoid fp_sub_integ(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Subtracts a digit from a prime field element. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid fp_sub_dig(fp_t c, const fp_t a, dig_t b);\n\n/**\n * Negates a prime field element using basic negation.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the prime field element to negate.\n */\nvoid fp_neg_basic(fp_t c, const fp_t a);\n\n/**\n * Negates a prime field element using integrated negation.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the prime field element to negate.\n */\nvoid fp_neg_integ(fp_t c, const fp_t a);\n\n/**\n * Doubles a prime field element using basic addition.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n */\nvoid fp_dbl_basic(fp_t c, const fp_t a);\n\n/**\n * Doubles a prime field element with integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to add.\n */\nvoid fp_dbl_integ(fp_t c, const fp_t a);\n\n/**\n * Halves a prime field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to halve.\n */\nvoid fp_hlv_basic(fp_t c, const fp_t a);\n\n/**\n * Halves a prime field element with integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to halve.\n */\nvoid fp_hlv_integ(fp_t c, const fp_t a);\n\n/**\n * Multiples two prime field elements using Schoolbook multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_basic(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiples two prime field elements using Comba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_comba(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiples two prime field elements using multiplication integrated with\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_integ(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiples two prime field elements using Karatsuba multiplication.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first prime field element to multiply.\n * @param[in] b\t\t\t\t- the second prime field element to multiply.\n */\nvoid fp_mul_karat(fp_t c, const fp_t a, const fp_t b);\n\n/**\n * Multiplies a prime field element by a digit. Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid fp_mul_dig(fp_t c, const fp_t a, dig_t b);\n\n/**\n * Squares a prime field element using Schoolbook squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to square.\n */\nvoid fp_sqr_basic(fp_t c, const fp_t a);\n\n/**\n * Squares a prime field element using Comba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to square.\n */\nvoid fp_sqr_comba(fp_t c, const fp_t a);\n\n/**\n * Squares two prime field elements using squaring integrated with\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the binary field element to square.\n */\nvoid fp_sqr_integ(fp_t c, const fp_t a);\n\n/**\n * Squares a prime field element using Karatsuba squaring.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to square.\n */\nvoid fp_sqr_karat(fp_t c, const fp_t a);\n\n/**\n * Shifts a prime field element number to the left. Computes\n * c = a * 2^bits.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fp_lsh(fp_t c, const fp_t a, int bits);\n\n/**\n * Shifts a prime field element to the right. Computes c = floor(a / 2^bits).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to shift.\n * @param[in] bits\t\t\t- the number of bits to shift.\n */\nvoid fp_rsh(fp_t c, const fp_t a, int bits);\n\n/**\n * Reduces a multiplication result modulo the prime field modulo using\n * division-based reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_basic(fp_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo the prime field order using Shoolbook\n * Montgomery reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_monty_basic(fp_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo the prime field order using Comba\n * Montgomery reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_monty_comba(fp_t c, dv_t a);\n\n/**\n * Reduces a multiplication result modulo the prime field modulo using\n * fast reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the multiplication result to reduce.\n */\nvoid fp_rdc_quick(fp_t c, dv_t a);\n\n/**\n * Inverts a prime field element using Fermat's Little Theorem.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_basic(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the binary method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_binar(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using Montgomery inversion.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_monty(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the Euclidean Extended Algorithm.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_exgcd(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the constant-time division step approach\n * by Bernstein and Bo-Yin Yang.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_divst(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using the constant-time jump division step\n * by Bernstein and Bo-Yin Yang.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_jmpds(fp_t c, const fp_t a);\n\n/**\n * Inverts a prime field element using a direct call to the lower layer.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @throw ERR_NO_VALID\t\t- if the field element is not invertible.\n */\nvoid fp_inv_lower(fp_t c, const fp_t a);\n\n/**\n * Inverts multiple prime field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp_inv_sim(fp_t *c, const fp_t *a, int n);\n\n/**\n * Computes Legendre symbol of a prime field element using exponentiation.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_basic(const fp_t a);\n\n/**\n * Computes Legendre symbol of a prime field element using the binary method.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_binar(const fp_t a);\n\n/**\n * Computes Legendre symbol of a prime field element using the constant-time\n * division step approach by Bernstein and Bo-Yin Yang.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_divst(const fp_t a);\n\n/**\n * Computes Legendre symbol of a prime field element using the constant-time\n * jump division step approach by Bernstein and Bo-Yin Yang.\n *\n * @param[in] a\t\t\t\t- the prime field element to compute.\n * @return the result.\n */\nint fp_smb_jmpds(const fp_t a);\n\n/**\n * Computes Legendre symbol a prime field element using a direct call to the\n * lower layer.\n *\n * @param[in] a\t\t\t\t- the prime field element to invert.\n * @return the result.\n */\nint fp_smb_lower(const fp_t a);\n\n/**\n * Exponentiates a prime field element using the binary\n * method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp_exp_basic(fp_t c, const fp_t a, const bn_t b);\n\n/**\n * Exponentiates a prime field element using the sliding window method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp_exp_slide(fp_t c, const fp_t a, const bn_t b);\n\n/**\n * Exponentiates a prime field element using the constant-time Montgomery\n * powering ladder method.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp_exp_monty(fp_t c, const fp_t a, const bn_t b);\n\n/**\n * Extracts the square root of a prime field element. Computes c = sqrt(a). The\n * other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the prime field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp_srt(fp_t c, const fp_t a);\n\n#endif /* !RLC_FP_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup fpx Prime field extensions.\n */\n\n/**\n * @file\n *\n * Interface of the module for prime extension field arithmetic.\n *\n * @ingroup fpx\n */\n\n#ifndef RLC_FPX_H\n#define RLC_FPX_H\n\n#include \"relic_fp.h\"\n#include \"relic_types.h\"\n\n/*============================================================================*/\n/* Type definitions                                                           */\n/*============================================================================*/\n\n/**\n * Represents a quadratic extension prime field element.\n *\n * This extension is constructed with the basis {1, i}, where i is an adjoined\n * square root in the prime field.\n */\ntypedef fp_t fp2_t[2];\n\n/**\n * Represents a double-precision quadratic extension field element.\n */\ntypedef dv_t dv2_t[2];\n\n/**\n * Represents a quadratic extension field element with automatic memory\n * allocation.\n */\ntypedef fp_st fp2_st[2];\n\n/**\n * Represents a cubic extension prime field element.\n *\n * This extension is constructed with the basis {1, j, j^2}, where j is an\n * adjoined cube root in the prime field.\n */\ntypedef fp_t fp3_t[3];\n\n/**\n * Represents a double-precision cubic extension field element.\n */\ntypedef dv_t dv3_t[3];\n\n/**\n * Represents a cubic extension field element with automatic memory\n * allocation.\n */\ntypedef fp_st fp3_st[3];\n\n/**\n * Represents a quartic extension prime field element.\n *\n * This extension is constructed with the basis {1, s}, where s^2 = E is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp2_t fp4_t[2];\n\n/**\n * Represents a double-precision quartic extension field element.\n */\ntypedef dv2_t dv4_t[2];\n\n/**\n * Represents a quartic extension field element with automatic memory\n * allocation.\n */\ntypedef fp2_st fp4_st[2];\n\n/**\n * Represents a sextic extension field element.\n *\n * This extension is constructed with the basis {1, v, v^2}, where v^3 = E is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp2_t fp6_t[3];\n\n/**\n * Represents a double-precision sextic extension field element.\n */\ntypedef dv2_t dv6_t[3];\n\n/**\n * Represents a sextic extension field element with automatic memory allocation.\n */\ntypedef fp2_st fp6_st[3];\n\n/**\n * Represents an octic extension prime field element.\n *\n * This extension is constructed with the basis {1, v}, where v^2 = s is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp4_t fp8_t[2];\n\n/**\n * Represents a double-precision octic extension field element.\n */\ntypedef dv4_t dv8_t[2];\n\n/**\n * Represents an octic extension field element with automatic memory\n * allocation.\n */\ntypedef fp4_st fp8_st[2];\n\n/**\n * Represents an octic extension prime field element.\n *\n * This extension is constructed with the basis {1, v, v^2}, where v^3 = j is an\n * adjoined root in the underlying quadratic extension.\n */\ntypedef fp3_t fp9_t[3];\n\n/**\n * Represents a double-precision octic extension field element.\n */\ntypedef dv3_t dv9_t[3];\n\n/**\n * Represents an octic extension field element with automatic memory\n * allocation.\n */\ntypedef fp3_st fp9_st[3];\n\n/**\n * Represents a dodecic extension field element.\n *\n * This extension is constructed with the basis {1, w}, where w^2 = v is an\n * adjoined root in the underlying sextic extension.\n */\ntypedef fp6_t fp12_t[2];\n\n/**\n * Represents a double-precision dodecic extension field element.\n */\ntypedef dv6_t dv12_t[2];\n\n/**\n * Represents an octdecic extension field element.\n *\n * This extension is constructed with the basis {1, w}, where w^2 = v is an\n * adjoined root in the underlying sextic extension.\n */\ntypedef fp9_t fp18_t[2];\n\n/**\n * Represents a double-precision octdecic extension field element.\n */\ntypedef dv9_t dv18_t[2];\n\n/**\n * Represents a 24-degree extension field element.\n *\n * This extension is constructed with the basis {1, t, t^2}, where t^3 = w is an\n * adjoined root in the underlying dodecic extension.\n */\ntypedef fp8_t fp24_t[3];\n\n/**\n * Represents a double-precision 24-degree extension field element.\n */\ntypedef dv8_t dv24_t[3];\n\n/**\n * Represents a 48-degree extension field element.\n *\n * This extension is constructed with the basis {1, u}, where u^2 = t is an\n * adjoined root in the underlying dodecic extension.\n */\ntypedef fp24_t fp48_t[2];\n\n/**\n * Represents a 54-degree extension field element.\n *\n * This extension is constructed with the basis {1, u, u^2}, where u^3 = t is an\n * adjoined root in the underlying dodecic extension.\n */\ntypedef fp18_t fp54_t[3];\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Initializes a double-precision quadratic extension field element with null.\n *\n* @param[out] A\t\t\t- the quadratic extension element to initialize.\n */\n#define dv2_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_null(A[0]); dv_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n\n/**\n * Allocates a double-precision quadratic extension field element.\n *\n * @param[out] A\t\t\t- the new quadratic extension field element.\n */\n#define dv2_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_new(A[0]); dv_new(A[1]);\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision quadratic extension field element.\n *\n * @param[out] A\t\t\t- the quadratic extension field element to free.\n */\n#define dv2_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_free(A[0]); dv_free(A[1]); \t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a quadratic extension field element with null.\n *\n* @param[out] A\t\t\t- the quadratic extension element to initialize.\n */\n#define fp2_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_null(A[0]); fp_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a quadratic extension field element.\n *\n * @param[out] A\t\t\t- the new quadratic extension field element.\n */\n#define fp2_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_new(A[0]); fp_new(A[1]);\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a quadratic extension field element.\n *\n * @param[out] A\t\t\t- the quadratic extension field element to free.\n */\n#define fp2_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_free(A[0]); fp_free(A[1]); \t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Adds two quadratic extension field elements. Computes C = A + B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quadratic extension field element.\n * @param[in] B\t\t\t\t- the second quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_add(C, A, B)\tfp2_add_basic(C, A, B)\n#elif FPX_QDR == INTEG\n#define fp2_add(C, A, B)\tfp2_add_integ(C, A, B)\n#endif\n\n/**\n * Subtracts a quadratic extension field element from another.\n * Computes C = A - B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quadratic extension field element.\n * @param[in] B\t\t\t\t- the second quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_sub(C, A, B)\tfp2_sub_basic(C, A, B)\n#elif FPX_QDR == INTEG\n#define fp2_sub(C, A, B)\tfp2_sub_integ(C, A, B)\n#endif\n\n/**\n * Doubles a quadratic extension field element. Computes C = A + A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_dbl(C, A)\t\tfp2_dbl_basic(C, A)\n#elif FPX_QDR == INTEG\n#define fp2_dbl(C, A)\t\tfp2_dbl_integ(C, A)\n#endif\n\n/**\n * Adds a quadratic extension field element and a digit. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit to add.\n */\nvoid fp2_add_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Subtracts a quadratic extension field element and a digit. Computes c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit to subtract.\n */\nvoid fp2_sub_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Multiplies two quadratic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quadratic extension field element.\n * @param[in] B\t\t\t\t- the second quadratic extension field element.\n */\n#if FPX_QDR == BASIC\n#define fp2_mul(C, A, B)\tfp2_mul_basic(C, A, B)\n#elif FPX_QDR == INTEG\n#define fp2_mul(C, A, B)\tfp2_mul_integ(C, A, B)\n#endif\n\n/**\n * Multiplies a quadratic extension field by the quadratic/cubic non-residue.\n * Computes C = A * E, where E is a non-square/non-cube in the quadratic\n * extension.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quadratic extension field element to multiply.\n */\n#if FPX_QDR == BASIC\n#define fp2_mul_nor(C, A)\tfp2_mul_nor_basic(C, A)\n#elif FPX_QDR == INTEG\n#define fp2_mul_nor(C, A)\tfp2_mul_nor_integ(C, A)\n#endif\n\n/**\n * Squares a quadratic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quadratic extension field element to square.\n */\n#if FPX_QDR == BASIC\n#define fp2_sqr(C, A)\t\tfp2_sqr_basic(C, A)\n#elif FPX_QDR == INTEG\n#define fp2_sqr(C, A)\t\tfp2_sqr_integ(C, A)\n#endif\n\n/**\n * Initializes a double-precision cubic extension field element with a null\n * value.\n *\n* @param[out] A\t\t\t- the cubic extension element to initialize.\n */\n#define dv3_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_null(A[0]); dv_null(A[1]); dv_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision cubic extension field element.\n *\n * @param[out] A\t\t\t- the new cubic extension field element.\n */\n#define dv3_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_new(A[0]); dv_new(A[1]);\tdv_new(A[2]);\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision cubic extension field element.\n *\n * @param[out] A\t\t\t- the cubic extension field element to free.\n */\n#define dv3_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_free(A[0]); dv_free(A[1]); dv_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Initializes a cubic extension field element with null.\n *\n* @param[out] A\t\t\t- the cubic extension element to initialize.\n */\n#define fp3_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_null(A[0]); fp_null(A[1]); fp_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a cubic extension field element.\n *\n * @param[out] A\t\t\t- the new cubic extension field element.\n */\n#define fp3_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_new(A[0]); fp_new(A[1]);\tfp_new(A[2]);\t\t\t\t\t\t\t\\\n\n/**\n * Frees a cubic extension field element.\n *\n * @param[out] A\t\t\t- the cubic extension field element to free.\n */\n#define fp3_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp_free(A[0]); fp_free(A[1]); fp_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Adds two cubic extension field elements. Computes C = A + B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first cubic extension field element.\n * @param[in] B\t\t\t\t- the second cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_add(C, A, B)\tfp3_add_basic(C, A, B)\n#elif FPX_CBC == INTEG\n#define fp3_add(C, A, B)\tfp3_add_integ(C, A, B)\n#endif\n\n/**\n * Subtracts a cubic extension field element from another.\n * Computes C = A - B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first cubic extension field element.\n * @param[in] B\t\t\t\t- the second cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_sub(C, A, B)\tfp3_sub_basic(C, A, B)\n#elif FPX_CBC == INTEG\n#define fp3_sub(C, A, B)\tfp3_sub_integ(C, A, B)\n#endif\n\n/**\n * Doubles a cubic extension field element. Computes C = A + A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_dbl(C, A)\t\tfp3_dbl_basic(C, A)\n#elif FPX_CBC == INTEG\n#define fp3_dbl(C, A)\t\tfp3_dbl_integ(C, A)\n#endif\n\n/**\n * Multiplies two cubic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first cubic extension field element.\n * @param[in] B\t\t\t\t- the second cubic extension field element.\n */\n#if FPX_CBC == BASIC\n#define fp3_mul(C, A, B)\tfp3_mul_basic(C, A, B)\n#elif FPX_CBC == INTEG\n#define fp3_mul(C, A, B)\tfp3_mul_integ(C, A, B)\n#endif\n\n/**\n * Squares a cubic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the cubic extension field element to square.\n */\n#if FPX_CBC == BASIC\n#define fp3_sqr(C, A)\t\tfp3_sqr_basic(C, A)\n#elif FPX_CBC == INTEG\n#define fp3_sqr(C, A)\t\tfp3_sqr_integ(C, A)\n#endif\n\n/**\n * Initializes a double-precision quartic extension field with null.\n *\n * @param[out] A\t\t\t- the quartic extension element to initialize.\n */\n#define dv4_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_null(A[0]); dv2_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision quartic extension field element.\n *\n * @param[out] A\t\t\t- the new quartic extension field element.\n */\n#define dv4_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_new(A[0]); dv2_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision quartic extension field element.\n *\n * @param[out] A\t\t\t- the quartic extension field element to free.\n */\n#define dv4_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_free(A[0]); dv2_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a quartic extension field with null.\n *\n * @param[out] A\t\t\t- the quartic extension element to initialize.\n */\n#define fp4_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_null(A[0]); fp2_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a quartic extension field element.\n *\n * @param[out] A\t\t\t- the new quartic extension field element.\n */\n#define fp4_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_new(A[0]); fp2_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a quartic extension field element.\n *\n * @param[out] A\t\t\t- the quartic extension field element to free.\n */\n#define fp4_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free(A[0]); fp2_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two quartic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first quartic extension field element.\n * @param[in] B\t\t\t\t- the second quartic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp4_mul(C, A, B)\tfp4_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp4_mul(C, A, B)\tfp4_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a quartic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the quartic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp4_sqr(C, A)\t\tfp4_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp4_sqr(C, A)\t\tfp4_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision sextic extension field with null.\n *\n * @param[out] A\t\t\t- the sextic extension element to initialize.\n */\n#define dv6_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_null(A[0]); dv2_null(A[1]); dv2_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the new sextic extension field element.\n */\n#define dv6_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_new(A[0]); dv2_new(A[1]); dv2_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the sextic extension field element to free.\n */\n#define dv6_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv2_free(A[0]); dv2_free(A[1]); dv2_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Initializes a sextic extension field with null.\n *\n * @param[out] A\t\t\t- the sextic extension element to initialize.\n */\n#define fp6_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_null(A[0]); fp2_null(A[1]); fp2_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a sextic extension field element.\n *\n * @param[out] A\t\t\t- the new sextic extension field element.\n */\n#define fp6_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_new(A[0]); fp2_new(A[1]); fp2_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a sextic extension field element.\n *\n * @param[out] A\t\t\t- the sextic extension field element to free.\n */\n#define fp6_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp2_free(A[0]); fp2_free(A[1]); fp2_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Multiplies two sextic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first sextic extension field element.\n * @param[in] B\t\t\t\t- the second sextic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp6_mul(C, A, B)\tfp6_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp6_mul(C, A, B)\tfp6_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a sextic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the sextic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp6_sqr(C, A)\t\tfp6_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp6_sqr(C, A)\t\tfp6_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision octic extension field with null.\n *\n * @param[out] A\t\t\t- the octic extension element to initialize.\n */\n#define dv8_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv4_null(A[0]); dv4_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision octic extension field element.\n *\n * @param[out] A\t\t\t- the new octic extension field element.\n */\n#define dv8_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv4_new(A[0]); dv4_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision octic extension field element.\n *\n * @param[out] A\t\t\t- the octic extension field element to free.\n */\n#define dv8_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv4_free(A[0]); dv4_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes an octic extension field with null.\n *\n * @param[out] A\t\t\t- the octic extension element to initialize.\n */\n#define fp8_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_null(A[0]); fp4_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates an octic extension field element.\n *\n * @param[out] A\t\t\t- the new octic extension field element.\n */\n#define fp8_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_new(A[0]); fp4_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees an octic extension field element.\n *\n * @param[out] A\t\t\t- the octic extension field element to free.\n */\n#define fp8_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp4_free(A[0]); fp4_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two octic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first octic extension field element.\n * @param[in] B\t\t\t\t- the second octic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp8_mul(C, A, B)\tfp8_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp8_mul(C, A, B)\tfp8_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares an octic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the octic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp8_sqr(C, A)\t\tfp8_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp8_sqr(C, A)\t\tfp8_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision nonic extension field with null.\n *\n * @param[out] A\t\t\t- the octic extension element to initialize.\n */\n#define dv9_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv3_null(A[0]); dv3_null(A[1]);\tdv3_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision nonic extension field element.\n *\n * @param[out] A\t\t\t- the new nonic extension field element.\n */\n#define dv9_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv3_new(A[0]); dv3_new(A[1]); dv3_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision nonic extension field element.\n *\n * @param[out] A\t\t\t- the nonic extension field element to free.\n */\n#define dv9_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv3_free(A[0]); dv3_free(A[1]); dv3_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Initializes a nonic extension field with null.\n *\n * @param[out] A\t\t\t- the nonic extension element to initialize.\n */\n#define fp9_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp3_null(A[0]); fp3_null(A[1]); fp3_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a nonic extension field element.\n *\n * @param[out] A\t\t\t- the new nonic extension field element.\n */\n#define fp9_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp3_new(A[0]); fp3_new(A[1]); fp3_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a nonic extension field element.\n *\n * @param[out] A\t\t\t- the nonic extension field element to free.\n */\n#define fp9_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp3_free(A[0]); fp3_free(A[1]); fp3_free(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Multiplies two nonic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first nonic extension field element.\n * @param[in] B\t\t\t\t- the second nonic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp9_mul(C, A, B)\tfp9_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp9_mul(C, A, B)\tfp9_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a nonic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the nonic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp9_sqr(C, A)\t\tfp9_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp9_sqr(C, A)\t\tfp9_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision dodecic extension field with null.\n *\n * @param[out] A\t\t\t- the dodecic extension element to initialize.\n */\n#define dv12_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv6_null(A[0]); dv6_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision dodecic extension field element.\n *\n * @param[out] A\t\t\t- the new dodecic extension field element.\n */\n#define dv12_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv6_new(A[0]); dv6_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision dodecic extension field element.\n *\n * @param[out] A\t\t\t- the dodecic extension field element to free.\n */\n#define dv12_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv6_free(A[0]); dv6_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a dodecic extension field with null.\n *\n * @param[out] A\t\t\t- the dodecic extension element to initialize.\n */\n#define fp12_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp6_null(A[0]); fp6_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a dodecic extension field element.\n *\n * @param[out] A\t\t\t- the new dodecic extension field element.\n */\n#define fp12_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp6_new(A[0]); fp6_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a dodecic extension field element.\n *\n * @param[out] A\t\t\t- the dodecic extension field element to free.\n */\n#define fp12_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp6_free(A[0]); fp6_free(A[1]); \t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two dodecic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first dodecic extension field element.\n * @param[in] B\t\t\t\t- the second dodecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp12_mul(C, A, B)\t\tfp12_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp12_mul(C, A, B)\t\tfp12_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Multiplies a dense and a sparse dodecic extension field elements. Computes\n * C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dense dodecic extension field element.\n * @param[in] B\t\t\t\t- the sparse dodecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp12_mul_dxs(C, A, B)\tfp12_mul_dxs_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp12_mul_dxs(C, A, B)\tfp12_mul_dxs_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a dodecic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dodecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp12_sqr(C, A)\t\t\tfp12_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp12_sqr(C, A)\t\t\tfp12_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a dodecic extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dodecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp12_sqr_cyc(C, A)\t\tfp12_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp12_sqr_cyc(C, A)\t\tfp12_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a dodecic extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dodecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp12_sqr_pck(C, A)\t\tfp12_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp12_sqr_pck(C, A)\t\tfp12_sqr_pck_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision sextic extension field with null.\n *\n * @param[out] A\t\t\t- the sextic extension element to initialize.\n */\n#define dv18_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv9_null(A[0]); dv9_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the new sextic extension field element.\n */\n#define dv18_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv9_new(A[0]); dv9_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision sextic extension field element.\n *\n * @param[out] A\t\t\t- the sextic extension field element to free.\n */\n#define dv18_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv9_free(A[0]); dv9_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes an octdecic extension field with null.\n *\n * @param[out] A\t\t\t- the octdecic extension element to initialize.\n */\n#define fp18_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp9_null(A[0]); fp9_null(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates an octdecic extension field element.\n *\n * @param[out] A\t\t\t- the new octdecic extension field element.\n */\n#define fp18_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp9_new(A[0]); fp9_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees an octdecic extension field element.\n *\n * @param[out] A\t\t\t- the octdecic extension field element to free.\n */\n#define fp18_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp9_free(A[0]); fp9_free(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two octdecic extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first octdecic extension field element.\n * @param[in] B\t\t\t\t- the second octdecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp18_mul(C, A, B)\t\tfp18_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp18_mul(C, A, B)\t\tfp18_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Multiplies a dense and a sparse octdecic extension field elements. Computes\n * C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the dense octdecic extension field element.\n * @param[in] B\t\t\t\t- the sparse octdecic extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp18_mul_dxs(C, A, B)\tfp18_mul_dxs_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp18_mul_dxs(C, A, B)\tfp18_mul_dxs_lazyr(C, A, B)\n#endif\n\n/**\n * Squares an octdecic extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the octdecic extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp18_sqr(C, A)\t\t\tfp18_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp18_sqr(C, A)\t\t\tfp18_sqr_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision 24-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 24-degree extension element to initialize.\n */\n#define dv24_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv8_null(A[0]); dv8_null(A[1]); dv8_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 24-degree extension field element.\n */\n#define dv24_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv8_new(A[0]); dv8_new(A[1]); dv8_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the 24-degree extension field element to free.\n */\n#define dv24_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv8_free(A[0]); dv8_free(A[1]); dv8_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Initializes a 24-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 24-degree extension element to initialize.\n */\n#define fp24_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp8_null(A[0]); fp8_null(A[1]); fp8_null(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Allocates a 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 24-degree extension field element.\n */\n#define fp24_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp8_new(A[0]); fp8_new(A[1]); fp8_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the 24-degree extension field element to free.\n */\n#define fp24_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp8_free(A[0]); fp8_free(A[1]); fp8_free(A[2]); \t\t\t\t\t\\\n\n/**\n * Multiplies two 24-degree extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first 24-degree extension field element.\n * @param[in] B\t\t\t\t- the second 24-degree extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp24_mul(C, A, B)\t\tfp24_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp24_mul(C, A, B)\t\tfp24_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a 24-degree extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 24-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp24_sqr(C, A)\t\t\tfp24_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp24_sqr(C, A)\t\t\tfp24_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a 24-degree extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 24-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp24_sqr_cyc(C, A)\t\tfp24_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp24_sqr_cyc(C, A)\t\tfp24_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a 24-degree extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 24-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp24_sqr_pck(C, A)\t\tfp24_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp24_sqr_pck(C, A)\t\tfp24_sqr_pck_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision 48-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 48-degree extension element to initialize.\n */\n#define dv48_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv24_null(A[0]); dv24_null(A[1]);\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 48-degree extension field element.\n */\n#define dv48_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv24_new(A[0]); dv24_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the 48-degree extension field element to free.\n */\n#define dv48_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv24_free(A[0]); dv24_free(A[1]);\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Initializes a 48-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 48-degree extension element to initialize.\n */\n#define fp48_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp24_null(A[0]); fp24_null(A[1]);\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Allocates a 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 48-degree extension field element.\n */\n#define fp48_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp24_new(A[0]); fp24_new(A[1]);\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Frees a 48-degree extension field element.\n *\n * @param[out] A\t\t\t- the 48-degree extension field element to free.\n */\n#define fp48_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp24_free(A[0]); fp24_free(A[1]); \t\t\t\t\t\t\t\t\t\\\n\n/**\n * Multiplies two 48-degree extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first 48-degree extension field element.\n * @param[in] B\t\t\t\t- the second 48-degree extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp48_mul(C, A, B)\t\tfp48_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp48_mul(C, A, B)\t\tfp48_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a 48-degree extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 48-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp48_sqr(C, A)\t\t\tfp48_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp48_sqr(C, A)\t\t\tfp48_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a 48-degree extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 48-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp48_sqr_cyc(C, A)\t\tfp48_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp48_sqr_cyc(C, A)\t\tfp48_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a 48-degree extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 48-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp48_sqr_pck(C, A)\t\tfp48_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp48_sqr_pck(C, A)\t\tfp48_sqr_pck_lazyr(C, A)\n#endif\n\n/**\n * Initializes a double-precision 54-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 54-degree extension element to initialize.\n */\n#define dv54_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv18_null(A[0]); dv18_null(A[1]); dv18_null(A[2]);\t\t\t\t\t\\\n\n/**\n * Allocates a double-precision 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 54-degree extension field element.\n */\n#define dv54_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv18_new(A[0]); dv18_new(A[1]);\tdv18_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a double-precision 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the 54-degree extension field element to free.\n */\n#define dv54_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv18_free(A[0]); dv18_free(A[1]); dv18_free(A[2]);\t\t\t\t\t\\\n\n/**\n * Initializes a 54-degree extension field with null.\n *\n * @param[out] A\t\t\t- the 54-degree extension element to initialize.\n */\n#define fp54_null(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp18_null(A[0]); fp18_null(A[1]); fp18_null(A[2]);\t\t\t\t\t\\\n\n/**\n * Allocates a 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the new 54-degree extension field element.\n */\n#define fp54_new(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp18_new(A[0]); fp18_new(A[1]);\tfp18_new(A[2]);\t\t\t\t\t\t\\\n\n/**\n * Frees a 54-degree extension field element.\n *\n * @param[out] A\t\t\t- the 54-degree extension field element to free.\n */\n#define fp54_free(A)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tfp18_free(A[0]); fp18_free(A[1]); fp18_free(A[2]);\t\t\t\t\t\\\n\n/**\n * Multiplies two 54-degree extension field elements. Computes C = A * B.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the first 54-degree extension field element.\n * @param[in] B\t\t\t\t- the second 54-degree extension field element.\n */\n#if FPX_RDC == BASIC\n#define fp54_mul(C, A, B)\t\tfp54_mul_basic(C, A, B)\n#elif FPX_RDC == LAZYR\n#define fp54_mul(C, A, B)\t\tfp54_mul_lazyr(C, A, B)\n#endif\n\n/**\n * Squares a 54-degree extension field element. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 54-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp54_sqr(C, A)\t\t\tfp54_sqr_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp54_sqr(C, A)\t\t\tfp54_sqr_lazyr(C, A)\n#endif\n\n/**\n * Squares a 54-degree extension field element in the cyclotomic subgroup.\n * Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 54-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp54_sqr_cyc(C, A)\t\tfp54_sqr_cyc_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp54_sqr_cyc(C, A)\t\tfp54_sqr_cyc_lazyr(C, A)\n#endif\n\n/**\n * Squares a 54-degree extension field element in the cyclotomic subgroup in\n * compressed form. Computes C = A * A.\n *\n * @param[out] C\t\t\t- the result.\n * @param[in] A\t\t\t\t- the 54-degree extension field element to square.\n */\n#if FPX_RDC == BASIC\n#define fp54_sqr_pck(C, A)\t\tfp54_sqr_pck_basic(C, A)\n#elif FPX_RDC == LAZYR\n#define fp54_sqr_pck(C, A)\t\tfp54_sqr_pck_lazyr(C, A)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the quadratic extension field arithmetic module.\n */\nvoid fp2_field_init(void);\n\n/**\n * Return the integer part (u) of the quadratic non-residue (i + u).\n */\nint fp2_field_get_qnr(void);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to copy.\n */\nvoid fp2_copy(fp2_t c, const fp2_t a);\n\n/**\n * Assigns zero to a quadratic extension field element.\n *\n * @param[out] a\t\t\t- the quadratic extension field element to zero.\n */\nvoid fp2_zero(fp2_t a);\n\n/**\n * Tests if a quadratic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp2_is_zero(const fp2_t a);\n\n/**\n * Assigns a random value to a quadratic extension field element.\n *\n * @param[out] a\t\t\t- the quadratic extension field element to assign.\n */\nvoid fp2_rand(fp2_t a);\n\n/**\n * Prints a quadratic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element to print.\n */\nvoid fp2_print(const fp2_t a);\n\n/**\n * Returns the number of bytes necessary to store a quadratic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp2_size_bin(fp2_t a, int pack);\n\n/**\n * Reads a quadratic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp2_read_bin(fp2_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a quadratic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack);\n\n/**\n * Returns the result of a comparison between two quadratic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp2_cmp(const fp2_t a, const fp2_t b);\n\n/**\n * Returns the result of a signed comparison between a quadratic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp2_cmp_dig(const fp2_t a, const dig_t b);\n\n/**\n * Assigns a quadratic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp2_set_dig(fp2_t a, const dig_t b);\n\n/**\n * Adds two quadratic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_add_basic(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Adds two quadratic extension field elements using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_add_integ(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Subtracts a quadratic extension field element from another using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_sub_basic(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Subtracts a quadratic extension field element from another using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_sub_integ(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Negates a quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the quadratic extension field element to negate.\n */\nvoid fp2_neg(fp2_t c, const fp2_t a);\n\n/**\n * Doubles a quadratic extension field element using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to double.\n */\nvoid fp2_dbl_basic(fp2_t c, const fp2_t a);\n\n/**\n * Doubles a quadratic extension field element using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to double.\n */\nvoid fp2_dbl_integ(fp2_t c, const fp2_t a);\n\n/**\n * Multiples two quadratic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_mul_basic(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Multiples two quadratic extension field elements using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quadratic extension field element.\n * @param[in] b\t\t\t\t- the second quadratic extension field element.\n */\nvoid fp2_mul_integ(fp2_t c, const fp2_t a, const fp2_t b);\n\n/**\n * Multiplies a quadratic extension field element by the adjoined root.\n * Computes c = a * i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to multiply.\n */\nvoid fp2_mul_art(fp2_t c, const fp2_t a);\n\n/**\n * Multiplies a quadratic extension field element by a quadratic/cubic\n * non-residue.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to multiply.\n */\nvoid fp2_mul_nor_basic(fp2_t c, const fp2_t a);\n\n/**\n * Multiplies a quadratic extension field element by a quadratic/cubic\n * non-residue using integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to multiply.\n */\nvoid fp2_mul_nor_integ(fp2_t c, const fp2_t a);\n\n/**\n * Multiplies a quadratic extension field element by a power of the constant\n * needed to compute a power of the Frobenius map.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n * @param[in] j\t\t\t\t- the power of the constant.\n */\nvoid fp2_mul_frb(fp2_t c, const fp2_t a, int i, int j);\n\n/**\n * Multiplies a quadratic extension field element by a digit.\n * Computes c = a * b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @param[in] b\t\t\t\t- the digit to multiply.\n */\nvoid fp2_mul_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Computes the square of a quadratic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to square.\n */\nvoid fp2_sqr_basic(fp2_t c, const fp2_t a);\n\n/**\n * Computes the square of a quadratic extension field element using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to square.\n */\nvoid fp2_sqr_integ(fp2_t c, const fp2_t a);\n\n/**\n * Inverts a quadratic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to invert.\n */\nvoid fp2_inv(fp2_t c, const fp2_t a);\n\n/**\n * Computes the inverse of a cyclotomic quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element to invert.\n */\nvoid fp2_inv_cyc(fp2_t c, const fp2_t a);\n\n/**\n * Inverts multiple quadratic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp2_inv_sim(fp2_t *c, const fp2_t *a, int n);\n\n/**\n * Tests if a quadratic extension field element is cyclotomic.\n *\n * @param[in] a\t\t\t\t- the quadratic extension field element to test.\n * @return 1 if the extension field element is cyclotomic, 0 otherwise.\n */\nint fp2_test_cyc(const fp2_t a);\n\n/**\n * Converts a quadratic extension field element to a cyclotomic element.\n * Computes c = a^(p - 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n */\nvoid fp2_conv_cyc(fp2_t c, const fp2_t a);\n\n/**\n * Computes a power of a quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp2_exp(fp2_t c, const fp2_t a, const bn_t b);\n\n/**\n * Computes a power of a quadratic extension field element by a small exponent.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp2_exp_dig(fp2_t c, const fp2_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius map of a quadratic extension field element.\n * When i is odd, this is the same as computing the conjugate of the extension\n * field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension element to conjugate.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp2_frb(fp2_t c, const fp2_t a, int i);\n\n/**\n * Extracts the square root of a quadratic extension field element. Computes\n * c = sqrt(a). The other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp2_srt(fp2_t c, const fp2_t a);\n\n/**\n * Compresses an extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element to compress.\n */\nvoid fp2_pck(fp2_t c, const fp2_t a);\n\n/**\n * Decompresses a quadratic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quadratic extension field element.\n * @return if the decompression was successful\n */\nint fp2_upk(fp2_t c, const fp2_t a);\n\n/**\n * Initializes the cubic extension field arithmetic module.\n */\nvoid fp3_field_init(void);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to copy.\n */\nvoid fp3_copy(fp3_t c, const fp3_t a);\n\n/**\n * Assigns zero to a cubic extension field element.\n *\n * @param[out] a\t\t\t- the cubic extension field element to zero.\n */\nvoid fp3_zero(fp3_t a);\n\n/**\n * Tests if a cubic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp3_is_zero(const fp3_t a);\n\n/**\n * Assigns a random value to a cubic extension field element.\n *\n * @param[out] a\t\t\t- the cubic extension field element to assign.\n */\nvoid fp3_rand(fp3_t a);\n\n/**\n * Prints a cubic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element to print.\n */\nvoid fp3_print(const fp3_t a);\n\n/**\n * Returns the number of bytes necessary to store a cubic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp3_size_bin(fp3_t a);\n\n/**\n * Reads a cubic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp3_read_bin(fp3_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a cubic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a);\n\n/**\n * Returns the result of a comparison between two cubic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp3_cmp(const fp3_t a, const fp3_t b);\n\n/**\n * Returns the result of a signed comparison between a cubic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp3_cmp_dig(const fp3_t a, const dig_t b);\n\n/**\n * Assigns a cubic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the cubic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp3_set_dig(fp3_t a, const dig_t b);\n\n/**\n * Adds two cubic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_add_basic(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Adds two cubic extension field elements using integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_add_integ(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Subtracts a cubic extension field element from another using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_sub_basic(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Subtracts a cubic extension field element from another using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_sub_integ(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Negates a cubic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the cubic extension field element to negate.\n */\nvoid fp3_neg(fp3_t c, const fp3_t a);\n\n/**\n * Doubles a cubic extension field element using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to double.\n */\nvoid fp3_dbl_basic(fp3_t c, const fp3_t a);\n\n/**\n * Doubles a cubic extension field element using integrated modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to double.\n */\nvoid fp3_dbl_integ(fp3_t c, const fp3_t a);\n\n/**\n * Multiples two cubic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_mul_basic(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Multiples two cubic extension field elements using integrated modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first cubic extension field element.\n * @param[in] b\t\t\t\t- the second cubic extension field element.\n */\nvoid fp3_mul_integ(fp3_t c, const fp3_t a, const fp3_t b);\n\n/**\n * Multiplies a cubic extension field element by a cubic non-residue.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to multiply.\n */\nvoid fp3_mul_nor(fp3_t c, const fp3_t a);\n\n/**\n * Multiplies a cubic extension field element by a power of the constant\n * needed to compute a power of the Frobenius map. If the flag is zero, the map\n * is computed on the cubic extension directly; otherwise the map is computed on\n * a higher extension.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n * @param[in] j\t\t\t\t- the power of the constant.\n */\nvoid fp3_mul_frb(fp3_t c, const fp3_t a, int i, int j);\n\n/**\n * Computes the square of a cubic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to square.\n */\nvoid fp3_sqr_basic(fp3_t c, const fp3_t a);\n\n/**\n * Computes the square of a cubic extension field element using integrated\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to square.\n */\nvoid fp3_sqr_integ(fp3_t c, const fp3_t a);\n\n/**\n * Inverts a cubic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field element to invert.\n */\nvoid fp3_inv(fp3_t c, const fp3_t a);\n\n/**\n * Inverts multiple cubic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp3_inv_sim(fp3_t *c, const fp3_t *a, int n);\n\n/**\n * Computes a power of a cubic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp3_exp(fp3_t c, const fp3_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius map of a cubic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cubic extension element to exponentiate.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp3_frb(fp3_t c, const fp3_t a, int i);\n\n/**\n * Extracts the square root of a cubic extension field element. Computes\n * c = sqrt(a). The other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp3_srt(fp3_t c, const fp3_t a);\n\n/**\n * Initializes the quartic extension field arithmetic module.\n */\nvoid fp4_field_init(void);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to copy.\n */\nvoid fp4_copy(fp4_t c, const fp4_t a);\n\n/**\n * Assigns zero to a quartic extension field element.\n *\n * @param[out] a\t\t\t- the quartic extension field element to zero.\n */\nvoid fp4_zero(fp4_t a);\n\n/**\n * Tests if a quartic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp4_is_zero(const fp4_t a);\n\n/**\n * Assigns a random value to a quartic extension field element.\n *\n * @param[out] a\t\t\t- the quartic extension field element to assign.\n */\nvoid fp4_rand(fp4_t a);\n\n/**\n * Prints a quartic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element to print.\n */\nvoid fp4_print(const fp4_t a);\n\n/**\n * Returns the number of bytes necessary to store a quartic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp4_size_bin(fp4_t a);\n\n/**\n * Reads a quartic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a quartic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a);\n\n/**\n * Returns the result of a comparison between two quartic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first quartic extension field element.\n * @param[in] b\t\t\t\t- the second quartic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp4_cmp(const fp4_t a, const fp4_t b);\n\n/**\n * Returns the result of a signed comparison between a quartic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp4_cmp_dig(const fp4_t a, const dig_t b);\n\n/**\n * Assigns a quartic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp4_set_dig(fp4_t a, const dig_t b);\n\n/**\n * Adds two quartic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first quartic extension field element.\n * @param[in] b\t\t\t\t- the second quartic extension field element.\n */\nvoid fp4_add(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Subtracts a quartic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_sub(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Negates a quartic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the quartic extension field element to negate.\n */\nvoid fp4_neg(fp4_t c, const fp4_t a);\n\n/**\n * Doubles a quartic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to double.\n */\nvoid fp4_dbl(fp4_t c, const fp4_t a);\n\n/**\n * Multiples two quartic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_mul_unr(dv4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Multiples two quartic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_mul_basic(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Multiples two quartic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element.\n * @param[in] b\t\t\t\t- the quartic extension field element.\n */\nvoid fp4_mul_lazyr(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Multiplies a quartic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to multiply.\n */\nvoid fp4_mul_art(fp4_t c, const fp4_t a);\n\n/**\n * Multiplies a quartic extension field element by a power of the constant\n * needed to compute a power of the Frobenius map.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the field element to multiply.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n * @param[in] j\t\t\t\t- the power of the constant.\n */\nvoid fp4_mul_frb(fp4_t c, const fp4_t a, int i, int j);\n\n/**\n * Multiples a dense quartic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a quartic extension field element.\n * @param[in] b\t\t\t\t- a sparse quartic extension field element.\n */\nvoid fp4_mul_dxs(fp4_t c, const fp4_t a, const fp4_t b);\n\n/**\n * Computes the square of a quartic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to square.\n */\nvoid fp4_sqr_unr(dv4_t c, const fp4_t a);\n\n/**\n * Computes the squares of a quartic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to square.\n */\nvoid fp4_sqr_basic(fp4_t c, const fp4_t a);\n\n/**\n * Computes the square of a quartic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to square.\n */\nvoid fp4_sqr_lazyr(fp4_t c, const fp4_t a);\n\n/**\n * Inverts a quartic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field element to invert.\n */\nvoid fp4_inv(fp4_t c, const fp4_t a);\n\n/**\n * Inverts multiple quartic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp4_inv_sim(fp4_t *c, const fp4_t *a, int n);\n\n/**\n * Computes the inverse of a cyclotomic quartic extension field element.\n *\n * For cyclotomic elements, this is equivalent to computing the conjugate.\n * A cyclotomic element is one previously raised to the (p^2 - 1)-th power.\n *\n * @param[out] c                        - the result.\n * @param[in] a                         - the quartic extension field element to invert.\n */\nvoid fp4_inv_cyc(fp4_t c, const fp4_t a);\n\n/**\n * Computes a power of a quartic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the quartic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp4_exp(fp4_t c, const fp4_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of a quartic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a quartic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp4_frb(fp4_t c, const fp4_t a, int i);\n\n/**\n * Extracts the square root of a quartic extension field element. Computes\n * c = sqrt(a). The other square root is the negation of c.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n * @return\t\t\t\t\t- 1 if there is a square root, 0 otherwise.\n */\nint fp4_srt(fp4_t c, const fp4_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to copy.\n */\nvoid fp6_copy(fp6_t c, const fp6_t a);\n\n/**\n * Assigns zero to a sextic extension field element.\n *\n * @param[out] a\t\t\t- the sextic extension field element to zero.\n */\nvoid fp6_zero(fp6_t a);\n\n/**\n * Tests if a sextic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp6_is_zero(const fp6_t a);\n\n/**\n * Assigns a random value to a sextic extension field element.\n *\n * @param[out] a\t\t\t- the sextic extension field element to assign.\n */\nvoid fp6_rand(fp6_t a);\n\n/**\n * Prints a sextic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element to print.\n */\nvoid fp6_print(const fp6_t a);\n\n/**\n * Returns the number of bytes necessary to store a quadratic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp6_size_bin(fp6_t a);\n\n/**\n * Reads a quadratic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp6_read_bin(fp6_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a sextic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp6_write_bin(uint8_t *bin, size_t len, const fp6_t a);\n\n/**\n * Returns the result of a comparison between two sextic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first sextic extension field element.\n * @param[in] b\t\t\t\t- the second sextic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp6_cmp(const fp6_t a, const fp6_t b);\n\n/**\n * Returns the result of a signed comparison between a sextic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp6_cmp_dig(const fp6_t a, const dig_t b);\n\n/**\n * Assigns a sextic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp6_set_dig(fp6_t a, const dig_t b);\n\n/**\n * Adds two sextic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first sextic extension field element.\n * @param[in] b\t\t\t\t- the second sextic extension field element.\n */\nvoid fp6_add(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Subtracts a sextic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_sub(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Negates a sextic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the sextic extension field element to negate.\n */\nvoid fp6_neg(fp6_t c, const fp6_t a);\n\n/**\n * Doubles a sextic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to double.\n */\nvoid fp6_dbl(fp6_t c, const fp6_t a);\n\n/**\n * Multiples two sextic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_mul_unr(dv6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Multiples two sextic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_mul_basic(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Multiples two sextic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element.\n * @param[in] b\t\t\t\t- the sextic extension field element.\n */\nvoid fp6_mul_lazyr(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Multiplies a sextic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to multiply.\n */\nvoid fp6_mul_art(fp6_t c, const fp6_t a);\n\n/**\n * Multiples a dense sextic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a sextic extension field element.\n * @param[in] b\t\t\t\t- a sparse sextic extension field element.\n */\nvoid fp6_mul_dxs(fp6_t c, const fp6_t a, const fp6_t b);\n\n/**\n * Computes the square of a sextic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to square.\n */\nvoid fp6_sqr_unr(dv6_t c, const fp6_t a);\n\n/**\n * Computes the squares of a sextic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to square.\n */\nvoid fp6_sqr_basic(fp6_t c, const fp6_t a);\n\n/**\n * Computes the square of a sextic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to square.\n */\nvoid fp6_sqr_lazyr(fp6_t c, const fp6_t a);\n\n/**\n * Inverts a sextic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension field element to invert.\n */\nvoid fp6_inv(fp6_t c, const fp6_t a);\n\n/**\n * Computes a power of a sextic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the sextic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp6_exp(fp6_t c, const fp6_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of a sextic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a sextic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp6_frb(fp6_t c, const fp6_t a, int i);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to copy.\n */\nvoid fp8_copy(fp8_t c, const fp8_t a);\n\n/**\n * Assigns zero to an octic extension field element.\n *\n * @param[out] a\t\t\t- the octic extension field element to zero.\n */\nvoid fp8_zero(fp8_t a);\n\n/**\n * Tests if an octic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the octic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp8_is_zero(const fp8_t a);\n\n/**\n * Assigns a random value to an octic extension field element.\n *\n * @param[out] a\t\t\t- the octic extension field element to assign.\n */\nvoid fp8_rand(fp8_t a);\n\n/**\n * Prints an octic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the octic extension field element to print.\n */\nvoid fp8_print(const fp8_t a);\n\n/**\n * Returns the number of bytes necessary to store an octic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp8_size_bin(fp8_t a, int pack);\n\n/**\n * Reads an octic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp8_read_bin(fp8_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes an octic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a);\n\n/**\n * Returns the result of a comparison between two octic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first octic extension field element.\n * @param[in] b\t\t\t\t- the second octic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp8_cmp(const fp8_t a, const fp8_t b);\n\n/**\n * Returns the result of a signed comparison between an octic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp8_cmp_dig(const fp8_t a, const dig_t b);\n\n/**\n * Assigns an octic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp8_set_dig(fp8_t a, const dig_t b);\n\n/**\n * Adds two octic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first octic extension field element.\n * @param[in] b\t\t\t\t- the second octic extension field element.\n */\nvoid fp8_add(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Subtracts an octic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_sub(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Negates an octic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the octic extension field element to negate.\n */\nvoid fp8_neg(fp8_t c, const fp8_t a);\n\n/**\n * Doubles an octic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to double.\n */\nvoid fp8_dbl(fp8_t c, const fp8_t a);\n\n/**\n * Multiples two octic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_mul_unr(dv8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Multiples two octic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_mul_basic(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Multiples two octic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n * @param[in] b\t\t\t\t- the octic extension field element.\n */\nvoid fp8_mul_lazyr(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Multiplies an octic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to multiply.\n */\nvoid fp8_mul_art(fp8_t c, const fp8_t a);\n\n/**\n * Multiples a dense octic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octic extension field element.\n * @param[in] b\t\t\t\t- a sparse octic extension field element.\n */\nvoid fp8_mul_dxs(fp8_t c, const fp8_t a, const fp8_t b);\n\n/**\n * Computes the square of an octic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to square.\n */\nvoid fp8_sqr_unr(dv8_t c, const fp8_t a);\n\n/**\n * Computes the squares of an octic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to square.\n */\nvoid fp8_sqr_basic(fp8_t c, const fp8_t a);\n\n/**\n * Computes the square of an octic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to square.\n */\nvoid fp8_sqr_lazyr(fp8_t c, const fp8_t a);\n\n/**\n * Computes the square of a cyclotomic octic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp8_sqr_cyc(fp8_t c, const fp8_t a);\n\n/**\n * Inverts an octic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to invert.\n */\nvoid fp8_inv(fp8_t c, const fp8_t a);\n\n/**\n * Computes the inverse of a cyclotomic octic extension field element.\n *\n * For cyclotomic elements, this is equivalent to computing the conjugate.\n * A cyclotomic element is one previously raised to the (p^4 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to invert.\n */\nvoid fp8_inv_cyc(fp8_t c, const fp8_t a);\n\n/**\n * Inverts multiple octic extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp8_inv_sim(fp8_t *c, const fp8_t *a, int n);\n\n/**\n * Tests if an octic extension field element is cyclotomic.\n *\n * @param[in] a\t\t\t\t- the octic extension field element to test.\n * @return 1 if the extension field element is cyclotomic, 0 otherwise.\n */\nint fp8_test_cyc(const fp8_t a);\n\n/**\n * Converts an octic extension field element to a cyclotomic element. Computes\n * c = a^(p^4 - 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element.\n */\nvoid fp8_conv_cyc(fp8_t c, const fp8_t a);\n\n/**\n * Computes a power of an octic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp8_exp(fp8_t c, const fp8_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic octic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of an octic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp8_frb(fp8_t c, const fp8_t a, int i);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to copy.\n */\nvoid fp9_copy(fp9_t c, const fp9_t a);\n\n/**\n * Assigns zero to a nonic extension field element.\n *\n * @param[out] a\t\t\t- the nonic extension field element to zero.\n */\nvoid fp9_zero(fp9_t a);\n\n/**\n * Tests if a nonic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp9_is_zero(const fp9_t a);\n\n/**\n * Assigns a random value to a nonic extension field element.\n *\n * @param[out] a\t\t\t- the nonic extension field element to assign.\n */\nvoid fp9_rand(fp9_t a);\n\n/**\n * Prints a nonic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element to print.\n */\nvoid fp9_print(const fp9_t a);\n\n/**\n * Returns the number of bytes necessary to store a quadratic extension field\n * element.\n *\n * @param[out] size\t\t\t- the result.\n * @param[in] a\t\t\t\t- the extension field element.\n */\nint fp9_size_bin(fp9_t a);\n\n/**\n * Reads a quadratic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp9_read_bin(fp9_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a nonic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp9_write_bin(uint8_t *bin, size_t len, const fp9_t a);\n\n/**\n * Returns the result of a comparison between two nonic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first nonic extension field element.\n * @param[in] b\t\t\t\t- the second nonic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp9_cmp(const fp9_t a, const fp9_t b);\n\n/**\n * Returns the result of a signed comparison between a nonic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp9_cmp_dig(const fp9_t a, const dig_t b);\n\n/**\n * Assigns a nonic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp9_set_dig(fp9_t a, const dig_t b);\n\n/**\n * Adds two nonic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first nonic extension field element.\n * @param[in] b\t\t\t\t- the second nonic extension field element.\n */\nvoid fp9_add(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Subtracts a nonic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_sub(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Negates a nonic extension field element. Computes c = -a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the nonic extension field element to negate.\n */\nvoid fp9_neg(fp9_t c, const fp9_t a);\n\n/**\n * Doubles a nonic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to double.\n */\nvoid fp9_dbl(fp9_t c, const fp9_t a);\n\n/**\n * Multiples two nonic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_mul_unr(dv9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Multiples two nonic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_mul_basic(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Multiples two nonic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element.\n * @param[in] b\t\t\t\t- the nonic extension field element.\n */\nvoid fp9_mul_lazyr(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Multiplies a nonic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to multiply.\n */\nvoid fp9_mul_art(fp9_t c, const fp9_t a);\n\n/**\n * Multiples a dense nonic extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a nonic extension field element.\n * @param[in] b\t\t\t\t- a sparse nonic extension field element.\n */\nvoid fp9_mul_dxs(fp9_t c, const fp9_t a, const fp9_t b);\n\n/**\n * Computes the square of a nonic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to square.\n */\nvoid fp9_sqr_unr(dv9_t c, const fp9_t a);\n\n/**\n * Computes the squares of a nonic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to square.\n */\nvoid fp9_sqr_basic(fp9_t c, const fp9_t a);\n\n/**\n * Computes the square of a nonic extension field element using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to square.\n */\nvoid fp9_sqr_lazyr(fp9_t c, const fp9_t a);\n\n/**\n * Inverts a nonic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field element to invert.\n */\nvoid fp9_inv(fp9_t c, const fp9_t a);\n\n/**\n * Inverts multiple noinc extension field elements simultaneously.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension field elements to invert.\n * @param[in] n\t\t\t\t- the number of elements.\n */\nvoid fp9_inv_sim(fp9_t *c, const fp9_t *a, int n);\n\n/**\n * Computes a power of a nonic extension field element. Computes c = a^b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the nonic extension element to exponentiate.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp9_exp(fp9_t c, const fp9_t a, const bn_t b);\n\n/**\n * Computes a power of the Frobenius endomorphism of a nonic extension field\n * element. Computes c = a^p^i.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a nonic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp9_frb(fp9_t c, const fp9_t a, int i);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to copy.\n */\nvoid fp12_copy(fp12_t c, const fp12_t a);\n\n/**\n * Assigns zero to a dodecic extension field element.\n *\n * @param[out] a\t\t\t- the dodecic extension field element to zero.\n */\nvoid fp12_zero(fp12_t a);\n\n/**\n * Tests if a dodecic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp12_is_zero(const fp12_t a);\n\n/**\n * Assigns a random value to a dodecic extension field element.\n *\n * @param[out] a\t\t\t- the dodecic extension field element to assign.\n */\nvoid fp12_rand(fp12_t a);\n\n/**\n * Prints a dodecic extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element to print.\n */\nvoid fp12_print(const fp12_t a);\n\n/**\n * Returns the number of bytes necessary to store a dodecic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp12_size_bin(fp12_t a, int pack);\n\n/**\n * Reads a dodecic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp12_read_bin(fp12_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a dodecic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp12_write_bin(uint8_t *bin, size_t len, const fp12_t a, int pack);\n\n/**\n * Returns the result of a comparison between two dodecic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first dodecic extension field element.\n * @param[in] b\t\t\t\t- the second dodecic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp12_cmp(const fp12_t a, const fp12_t b);\n\n/**\n * Returns the result of a signed comparison between a dodecic extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp12_cmp_dig(const fp12_t a, const dig_t b);\n\n/**\n * Assigns a dodecic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp12_set_dig(fp12_t a, const dig_t b);\n\n/**\n * Adds two dodecic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first dodecic extension field element.\n * @param[in] b\t\t\t\t- the second dodecic extension field element.\n */\nvoid fp12_add(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Subtracts a dodecic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first dodecic extension field element.\n * @param[in] b\t\t\t\t- the second dodecic extension field element.\n */\nvoid fp12_sub(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Negates a dodecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the dodecic extension field element to negate.\n */\nvoid fp12_neg(fp12_t c, const fp12_t a);\n\n/**\n * Doubles a dodecic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to double.\n */\nvoid fp12_dbl(fp12_t c, const fp12_t a);\n\n/**\n * Multiples two dodecic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the dodecic extension field element.\n */\nvoid fp12_mul_unr(dv12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiples two dodecic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the dodecic extension field element.\n */\nvoid fp12_mul_basic(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiples two dodecic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element.\n * @param[in] b\t\t\t\t- the dodecic extension field element.\n */\nvoid fp12_mul_lazyr(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiplies a dodecic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to multiply.\n */\nvoid fp12_mul_art(fp12_t c, const fp12_t a);\n\n/**\n * Multiples a dense dodecic extension field element by a sparse element using\n * basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense dodecic extension field element.\n * @param[in] b\t\t\t\t- the sparse dodecic extension field element.\n */\nvoid fp12_mul_dxs_basic(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Multiples a dense dodecic extension field element by a sparse element using\n * lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense dodecic extension field element.\n * @param[in] b\t\t\t\t- the sparse dodecic extension field element.\n */\nvoid fp12_mul_dxs_lazyr(fp12_t c, const fp12_t a, const fp12_t b);\n\n/**\n * Computes the square of a dodecic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to square.\n */\nvoid fp12_sqr_unr(dv12_t c, const fp12_t a);\n\n/**\n * Computes the square of a dodecic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to square.\n */\nvoid fp12_sqr_basic(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a dodecic extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to square.\n */\nvoid fp12_sqr_lazyr(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a cyclotomic dodecic extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_cyc_basic(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a cyclotomic dodecic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_cyc_lazyr(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_pck_basic(fp12_t c, const fp12_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp12_sqr_pck_lazyr(fp12_t c, const fp12_t a);\n\n/**\n * Tests if a dodecic extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the dodecic extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp12_test_cyc(const fp12_t a);\n\n/**\n * Converts a dodecic extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a dodecic extension field element.\n */\nvoid fp12_conv_cyc(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to decompress.\n */\nvoid fp12_back_cyc(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp12_back_cyc_sim(fp12_t *c, const fp12_t *a, int n);\n\n/**\n * Inverts a dodecic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to invert.\n */\nvoid fp12_inv(fp12_t c, const fp12_t a);\n\n/**\n * Computes the inverse of a cyclotomic dodecic extension field element.\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^6 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to invert.\n */\nvoid fp12_inv_cyc(fp12_t c, const fp12_t a);\n\n/**\n * Computes the Frobenius endomorphism of a dodecic extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a dodecic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp12_frb(fp12_t c, const fp12_t a, int i);\n\n/**\n * Computes a power of a dodecic extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp12_exp(fp12_t c, const fp12_t a, const bn_t b);\n\n/**\n * Computes a power of a dodecic extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic quadratic extension field element.\n *\n * @param[out] e\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first element to exponentiate.\n * @param[in] b\t\t\t\t- the first exponent.\n * @param[in] c\t\t\t\t- the second element to exponentiate.\n * @param[in] d\t\t\t\t- the second exponent.\n */\nvoid fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c,\n\t\tconst bn_t d);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] e\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first element to exponentiate.\n * @param[in] b\t\t\t\t- the first exponent.\n * @param[in] c\t\t\t\t- the second element to exponentiate.\n * @param[in] d\t\t\t\t- the second exponent.\n */\nvoid fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c,\n\t\tconst bn_t d);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, size_t l, int s);\n\n/**\n * Compresses a dodecic extension field element.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to compress.\n */\nvoid fp12_pck(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses a dodecic extension field element.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp12_upk(fp12_t c, const fp12_t a);\n\n/**\n * Compresses a dodecic extension field element at the maximum rate.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to compress.\n */\nvoid fp12_pck_max(fp12_t c, const fp12_t a);\n\n/**\n * Decompresses a dodecic extension field element at the maximum rate.\n *\n * @param[out] r\t\t\t- the result.\n * @param[in] p\t\t\t\t- the dodecic extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp12_upk_max(fp12_t c, const fp12_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to copy.\n */\nvoid fp18_copy(fp18_t c, const fp18_t a);\n\n/**\n * Assigns zero to an octdecic extension field element.\n *\n * @param[out] a\t\t\t- the octdecic extension field element to zero.\n */\nvoid fp18_zero(fp18_t a);\n\n/**\n * Tests if an octdecic extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the octdecic extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp18_is_zero(const fp18_t a);\n\n/**\n * Assigns a random value to an octdecic extension field element.\n *\n * @param[out] a\t\t\t- the octdecic extension field element to assign.\n */\nvoid fp18_rand(fp18_t a);\n\n/**\n * Prints an octdecic extension field element to standard output.\n *\n * @param[in] A\t\t\t\t- the octdecic extension field element to print.\n */\nvoid fp18_print(const fp18_t a);\n\n/**\n * Returns the number of bytes necessary to store an octdecic extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @return the number of bytes.\n */\nint fp18_size_bin(fp18_t a);\n\n/**\n * Reads an octdecic extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp18_read_bin(fp18_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes an octdecic extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp18_write_bin(uint8_t *bin, size_t len, const fp18_t a);\n\n/**\n * Returns the result of a comparison between two octdecic extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first octdecic extension field element.\n * @param[in] b\t\t\t\t- the second octdecic extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp18_cmp(const fp18_t a, const fp18_t b);\n\n/**\n * Returns the result of a signed comparison between an octdecic extension\n * field element and a digit.\n *\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp18_cmp_dig(const fp18_t a, const dig_t b);\n\n/**\n * Assigns an octdecic extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp18_set_dig(fp18_t a, const dig_t b);\n\n/**\n * Adds two octdecic extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first octdecic extension field element.\n * @param[in] b\t\t\t\t- the second octdecic extension field element.\n */\nvoid fp18_add(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Subtracts an octdecic extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first octdecic extension field element.\n * @param[in] b\t\t\t\t- the second octdecic extension field element.\n */\nvoid fp18_sub(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Negates an octdecic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the octdecic extension field element to negate.\n */\nvoid fp18_neg(fp18_t c, const fp18_t a);\n\n/**\n * Doubles an octdecic extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to double.\n */\nvoid fp18_dbl(fp18_t c, const fp18_t a);\n\n/**\n * Multiples two octdecic extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the octdecic extension field element.\n */\nvoid fp18_mul_unr(dv18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiples two octdecic extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the octdecic extension field element.\n */\nvoid fp18_mul_basic(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiples two octdecic extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element.\n * @param[in] b\t\t\t\t- the octdecic extension field element.\n */\nvoid fp18_mul_lazyr(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiplies an octdecic extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to multiply.\n */\nvoid fp18_mul_art(fp18_t c, const fp18_t a);\n\n/**\n * Multiples a dense octdecic extension field element by a sparse element using\n * basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense octdecic extension field element.\n * @param[in] b\t\t\t\t- the sparse octdecic extension field element.\n */\nvoid fp18_mul_dxs_basic(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Multiples a dense octdecic extension field element by a sparse element using\n * lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense octdecic extension field element.\n * @param[in] b\t\t\t\t- the sparse octdecic extension field element.\n */\nvoid fp18_mul_dxs_lazyr(fp18_t c, const fp18_t a, const fp18_t b);\n\n/**\n * Computes the square of an octdecic extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to square.\n */\nvoid fp18_sqr_unr(dv18_t c, const fp18_t a);\n\n/**\n * Computes the square of an octdecic extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to square.\n */\nvoid fp18_sqr_basic(fp18_t c, const fp18_t a);\n\n/**\n * Computes the square of an octdecic extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to square.\n */\nvoid fp18_sqr_lazyr(fp18_t c, const fp18_t a);\n\n/**\n * Inverts an octdecic extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to invert.\n */\nvoid fp18_inv(fp18_t c, const fp18_t a);\n\n/**\n * Computes the inverse of a cyclotomic octdecic extension field element.\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^9 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octdecic extension field element to invert.\n */\nvoid fp18_inv_cyc(fp18_t c, const fp18_t a);\n\n/**\n * Converts an octdecic extension field element to a cyclotomic element.\n * Computes c = a^(p^9 - 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octdecic extension field element.\n */\nvoid fp18_conv_cyc(fp18_t c, const fp18_t a);\n\n/**\n * Computes the Frobenius endomorphism of an octdecic extension element.\n * Computes c = a^(p^i).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- an octdecic extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp18_frb(fp18_t c, const fp18_t a, int i);\n\n/**\n * Computes a power of an octdecic extension field element.\n * Faster formulas are used if the field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp18_exp(fp18_t c, const fp18_t a, const bn_t b);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to copy.\n */\nvoid fp24_copy(fp24_t c, const fp24_t a);\n\n/**\n * Assigns zero to a 24-degree extension field element.\n *\n * @param[out] a\t\t\t- the 24-degree extension field element to zero.\n */\nvoid fp24_zero(fp24_t a);\n\n/**\n * Tests if a 24-degree extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the 24-degree extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp24_is_zero(const fp24_t a);\n\n/**\n * Assigns a random value to a 24-degree extension field element.\n *\n * @param[out] A\t\t\t- the 24-degree extension field element to assign.\n */\nvoid fp24_rand(fp24_t a);\n\n/**\n * Prints a 24-degree extension field element to standard output.\n *\n * @param[in] A\t\t\t\t- the 24-degree extension field element to print.\n */\nvoid fp24_print(const fp24_t a);\n\n/**\n * Returns the number of bytes necessary to store a 24-degree extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp24_size_bin(fp24_t a, int pack);\n\n/**\n * Reads a 24-degree extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp24_read_bin(fp24_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a 24-degree extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp24_write_bin(uint8_t *bin, size_t len, const fp24_t a, int pack);\n\n/**\n * Returns the result of a comparison between two 24-degree extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first 24-degree extension field element.\n * @param[in] b\t\t\t\t- the second 24-degree extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp24_cmp(const fp24_t a, const fp24_t b);\n\n/**\n * Returns the result of a signed comparison between a 24-degree extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp24_cmp_dig(const fp24_t a, const dig_t b);\n\n/**\n * Assigns a 24-degree extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp24_set_dig(fp24_t a, const dig_t b);\n\n/**\n * Adds two 24-degree extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 24-degree extension field element.\n * @param[in] b\t\t\t\t- the second 24-degree extension field element.\n */\nvoid fp24_add(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Subtracts a 24-degree extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 24-degree extension field element.\n * @param[in] b\t\t\t\t- the second 24-degree extension field element.\n */\nvoid fp24_sub(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Negates a 24-degree extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the 24-degree extension field element to negate.\n */\nvoid fp24_neg(fp24_t c, const fp24_t a);\n\n/**\n * Doubles a 24-degree extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the octic extension field element to double.\n */\nvoid fp24_dbl(fp24_t c, const fp24_t a);\n\n/**\n * Multiples two 24-degree extension field elements without performing modular\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the 24-degree extension field element.\n */\nvoid fp24_mul_unr(dv24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Multiples two 24-degree extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the 24-degree extension field element.\n */\nvoid fp24_mul_basic(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Multiples two 24-degree extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element.\n * @param[in] b\t\t\t\t- the 24-degree extension field element.\n */\nvoid fp24_mul_lazyr(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Multiplies a 24-degree extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dodecic extension field element to multiply.\n */\nvoid fp24_mul_art(fp24_t c, const fp24_t a);\n\n/**\n * Multiples a dense 24-degree extension field element by a sparse element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 24-degree extension field element.\n * @param[in] b\t\t\t\t- a 24-degree quartic extension field element.\n */\nvoid fp24_mul_dxs(fp24_t c, const fp24_t a, const fp24_t b);\n\n/**\n * Computes the square of a 24-degree extension field element without performing\n * modular reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to square.\n */\nvoid fp24_sqr_unr(dv24_t c, const fp24_t a);\n\n/**\n * Computes the square of a 24-degree extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to square.\n */\nvoid fp24_sqr_basic(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a 24-degree extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to square.\n */\nvoid fp24_sqr_lazyr(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a cyclotomic 24-extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_cyc_basic(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a cyclotomic 24-extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_cyc_lazyr(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_pck_basic(fp24_t c, const fp24_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp24_sqr_pck_lazyr(fp24_t c, const fp24_t a);\n\n/**\n * Tests if a 24-extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the 24-extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp24_test_cyc(const fp24_t a);\n\n/**\n * Converts a 24-extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 24-extension field element.\n */\nvoid fp24_conv_cyc(fp24_t c, const fp24_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-extension field element to decompress.\n */\nvoid fp24_back_cyc(fp24_t c, const fp24_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24 field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp24_back_cyc_sim(fp24_t *c, const fp24_t *a, int n);\n\n/**\n * Inverts a 24-degree extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to invert.\n */\nvoid fp24_inv(fp24_t c, const fp24_t a);\n\n/**\n * Computes the inverse of a cyclotomic octdecic extension field element.\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^12 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-degree extension field element to invert.\n */\nvoid fp24_inv_cyc(fp24_t c, const fp24_t a);\n\n/**\n * Computes the Frobenius endomorphism of a 24-degree extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 24-degree extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp24_frb(fp24_t c, const fp24_t a, int i);\n\n/**\n * Computes a power of a 24-degree extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp24_exp(fp24_t c, const fp24_t a, const bn_t b);\n\n/**\n * Computes a power of a 24-extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic dodecic extension field element.\n *\n * @param[out] e\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first element to exponentiate.\n * @param[in] b\t\t\t\t- the first exponent.\n * @param[in] c\t\t\t\t- the second element to exponentiate.\n * @param[in] d\t\t\t\t- the second exponent.\n */\nvoid fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d);\n\n/**\n * Computes a power of a cyclotomic 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t l, int s);\n\n/**\n * Compresses a 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-extension field element to compress.\n */\nvoid fp24_pck(fp24_t c, const fp24_t a);\n\n/**\n * Decompresses a 24-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 24-extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp24_upk(fp24_t c, const fp24_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to copy.\n */\nvoid fp48_copy(fp48_t c, const fp48_t a);\n\n/**\n * Assigns zero to a 48-extension field element.\n *\n * @param[out] a\t\t\t- the 48-extension field element to zero.\n */\nvoid fp48_zero(fp48_t a);\n\n/**\n * Tests if a 48-extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp48_is_zero(const fp48_t a);\n\n/**\n * Assigns a random value to a 48-extension field element.\n *\n * @param[out] a\t\t\t- the 48-extension field element to assign.\n */\nvoid fp48_rand(fp48_t a);\n\n/**\n * Prints a 48-extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element to print.\n */\nvoid fp48_print(const fp48_t a);\n\n/**\n * Returns the number of bytes necessary to store a 48-extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp48_size_bin(fp48_t a, int pack);\n\n/**\n * Reads a 48-extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp48_read_bin(fp48_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a 48-extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp48_write_bin(uint8_t *bin, size_t len, const fp48_t a, int pack);\n\n/**\n * Returns the result of a comparison between two 48-extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first 48-extension field element.\n * @param[in] b\t\t\t\t- the second 48-extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp48_cmp(const fp48_t a, const fp48_t b);\n\n/**\n * Returns the result of a signed comparison between a 48-extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp48_cmp_dig(const fp48_t a, const dig_t b);\n\n/**\n * Assigns a 48-extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp48_set_dig(fp48_t a, const dig_t b);\n\n/**\n * Adds two 48-extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 48-extension field element.\n * @param[in] b\t\t\t\t- the second 48-extension field element.\n */\nvoid fp48_add(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Subtracts a 48-extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 48-extension field element.\n * @param[in] b\t\t\t\t- the second 48-extension field element.\n */\nvoid fp48_sub(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Negates a 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the 48-extension field element to negate.\n */\nvoid fp48_neg(fp48_t c, const fp48_t a);\n\n/**\n * Doubles a 48-extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to double.\n */\nvoid fp48_dbl(fp48_t c, const fp48_t a);\n\n/**\n * Multiples two 48-extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the 48-extension field element.\n */\nvoid fp48_mul_basic(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Multiples two 48-extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element.\n * @param[in] b\t\t\t\t- the 48-extension field element.\n */\nvoid fp48_mul_lazyr(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Multiplies a 48-extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to multiply.\n */\nvoid fp48_mul_art(fp48_t c, const fp48_t a);\n\n/**\n * Multiples a dense 48-extension field element by a sparse element using\n * basic arithmetic. Computes C = A * B.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense 48-extension field element.\n * @param[in] b\t\t\t\t- the sparse 48-extension field element.\n */\nvoid fp48_mul_dxs(fp48_t c, const fp48_t a, const fp48_t b);\n\n/**\n * Computes the square of a 48-extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to square.\n */\nvoid fp48_sqr_basic(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a 48-extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to square.\n */\nvoid fp48_sqr_lazyr(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a cyclotomic 48-extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_cyc_basic(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a cyclotomic 48-extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_cyc_lazyr(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_pck_basic(fp48_t c, const fp48_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp48_sqr_pck_lazyr(fp48_t c, const fp48_t a);\n\n/**\n * Tests if a 48-extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the 48-extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp48_test_cyc(const fp48_t a);\n\n/**\n * Converts a 48-extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 48-extension field element.\n */\nvoid fp48_conv_cyc(fp48_t c, const fp48_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to decompress.\n */\nvoid fp48_back_cyc(fp48_t c, const fp48_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48 field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp48_back_cyc_sim(fp48_t *c, const fp48_t *a, int n);\n\n/**\n * Inverts a 48-extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to invert.\n */\nvoid fp48_inv(fp48_t c, const fp48_t a);\n\n/**\n * Computes the inverse of a cyclotomic 48-extension field element.\n *\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^24 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to invert.\n */\nvoid fp48_inv_cyc(fp48_t c, const fp48_t a);\n\n/**\n * Computes the Frobenius endomorphism of a 48-extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 48-extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp48_frb(fp48_t c, const fp48_t a, int i);\n\n/**\n * Computes a power of a 48-extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp48_exp(fp48_t c, const fp48_t a, const bn_t b);\n\n/**\n * Computes a power of a 48-extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp48_exp_dig(fp48_t c, const fp48_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t l, int s);\n\n/**\n * Compresses a 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to compress.\n */\nvoid fp48_pck(fp48_t c, const fp48_t a);\n\n/**\n * Decompresses a 48-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 48-extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp48_upk(fp48_t c, const fp48_t a);\n\n/**\n * Copies the second argument to the first argument.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to copy.\n */\nvoid fp54_copy(fp54_t c, const fp54_t a);\n\n/**\n * Assigns zero to a 54-extension field element.\n *\n * @param[out] a\t\t\t- the 54-extension field element to zero.\n */\nvoid fp54_zero(fp54_t a);\n\n/**\n * Tests if a 54-extension field element is zero or not.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element to test.\n * @return 1 if the argument is zero, 0 otherwise.\n */\nint fp54_is_zero(const fp54_t a);\n\n/**\n * Assigns a random value to a 54-extension field element.\n *\n * @param[out] a\t\t\t- the 54-extension field element to assign.\n */\nvoid fp54_rand(fp54_t a);\n\n/**\n * Prints a 54-extension field element to standard output.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element to print.\n */\nvoid fp54_print(const fp54_t a);\n\n/**\n * Returns the number of bytes necessary to store a 54-extension field\n * element.\n *\n * @param[in] a\t\t\t\t- the extension field element.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @return the number of bytes.\n */\nint fp54_size_bin(fp54_t a, int pack);\n\n/**\n * Reads a 54-extension field element from a byte vector in big-endian\n * format.\n *\n * @param[out] a\t\t\t- the result.\n * @param[in] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp54_read_bin(fp54_t a, const uint8_t *bin, size_t len);\n\n/**\n * Writes a 54-extension field element to a byte vector in big-endian\n * format.\n *\n * @param[out] bin\t\t\t- the byte vector.\n * @param[in] len\t\t\t- the buffer capacity.\n * @param[in] a\t\t\t\t- the extension field element to write.\n * @param[in] pack\t\t\t- the flag to indicate compression.\n * @throw ERR_NO_BUFFER\t\t- if the buffer capacity is not correct.\n */\nvoid fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack);\n\n/**\n * Returns the result of a comparison between two 54-extension field\n * elements.\n *\n * @param[in] a\t\t\t\t- the first 54-extension field element.\n * @param[in] b\t\t\t\t- the second 54-extension field element.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp54_cmp(const fp54_t a, const fp54_t b);\n\n/**\n * Returns the result of a signed comparison between a 54-extension field\n * element and a digit.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n * @return RLC_EQ if a == b, and RLC_NE otherwise.\n */\nint fp54_cmp_dig(const fp54_t a, const dig_t b);\n\n/**\n * Assigns a 54-extension field element to a digit.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the digit.\n */\nvoid fp54_set_dig(fp54_t a, const dig_t b);\n\n/**\n * Adds two 54-extension field elements. Computes c = a + b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 54-extension field element.\n * @param[in] b\t\t\t\t- the second 54-extension field element.\n */\nvoid fp54_add(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Subtracts a 54-extension field element from another. Computes\n * c = a - b.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the first 54-extension field element.\n * @param[in] b\t\t\t\t- the second 54-extension field element.\n */\nvoid fp54_sub(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Negates a 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[out] a\t\t\t- the 54-extension field element to negate.\n */\nvoid fp54_neg(fp54_t c, const fp54_t a);\n\n/**\n * Doubles a 54-extension field element. Computes c = 2 * a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to double.\n */\nvoid fp54_dbl(fp54_t c, const fp54_t a);\n\n/**\n * Multiples two 54-extension field elements using basic arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the 54-extension field element.\n */\nvoid fp54_mul_basic(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Multiples two 54-extension field elements using lazy reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element.\n * @param[in] b\t\t\t\t- the 54-extension field element.\n */\nvoid fp54_mul_lazyr(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Multiplies a 54-extension field element by the adjoined root.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to multiply.\n */\nvoid fp54_mul_art(fp54_t c, const fp54_t a);\n\n/**\n * Multiples a dense 54-extension field element by a sparse element using\n * basic arithmetic. Computes C = A * B.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the dense 54-extension field element.\n * @param[in] b\t\t\t\t- the sparse 54-extension field element.\n */\nvoid fp54_mul_dxs(fp54_t c, const fp54_t a, const fp54_t b);\n\n/**\n * Computes the square of a 54-extension field element using basic\n * arithmetic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to square.\n */\nvoid fp54_sqr_basic(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a 54-extension field element using lazy\n * reduction.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to square.\n */\nvoid fp54_sqr_lazyr(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a cyclotomic 54-extension field element using\n * basic arithmetic.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_cyc_basic(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a cyclotomic 54-extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_cyc_lazyr(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_pck_basic(fp54_t c, const fp54_t a);\n\n/**\n * Computes the square of a compressed cyclotomic extension field element using\n * lazy reduction.\n *\n * A cyclotomic element is one raised to the (p^6 - 1)(p^2 + 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the cyclotomic extension element to square.\n */\nvoid fp54_sqr_pck_lazyr(fp54_t c, const fp54_t a);\n\n/**\n * Tests if a 54-extension field element belongs to the cyclotomic\n * subgroup.\n *\n * @param[in] a\t\t\t\t- the 54-extension field element to test.\n * @return 1 if the extension field element is in the subgroup, 0 otherwise.\n */\nint fp54_test_cyc(const fp54_t a);\n\n/**\n * Converts a 54-extension field element to a cyclotomic element.\n * Computes c = a^(p^6 - 1)*(p^2 + 1).\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 54-extension field element.\n */\nvoid fp54_conv_cyc(fp54_t c, const fp54_t a);\n\n/**\n * Decompresses a compressed cyclotomic extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to decompress.\n */\nvoid fp54_back_cyc(fp54_t c, const fp54_t a);\n\n/**\n * Decompresses multiple compressed cyclotomic extension field elements.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54 field elements to decompress.\n * @param[in] n\t\t\t\t- the number of field elements to decompress.\n */\nvoid fp54_back_cyc_sim(fp54_t *c, const fp54_t *a, int n);\n\n/**\n * Inverts a 54-extension field element. Computes c = 1/a.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to invert.\n */\nvoid fp54_inv(fp54_t c, const fp54_t a);\n\n/**\n * Computes the inverse of a cyclotomic 54-extension field element.\n *\n * For unitary elements, this is equivalent to computing the conjugate.\n * A unitary element is one previously raised to the (p^24 - 1)-th power.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to invert.\n */\nvoid fp54_inv_cyc(fp54_t c, const fp54_t a);\n\n/**\n * Computes the Frobenius endomorphism of a 54-extension element.\n * Computes c = a^p.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- a 54-extension field element.\n * @param[in] i\t\t\t\t- the power of the Frobenius map.\n */\nvoid fp54_frb(fp54_t c, const fp54_t a, int i);\n\n/**\n * Computes a power of a 54-extension field element.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp54_exp(fp54_t c, const fp54_t a, const bn_t b);\n\n/**\n * Computes a power of a 54-extension field element by a small exponent.\n * Faster formulas are used if the extension field element is cyclotomic.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b);\n\n/**\n * Computes a power of a cyclotomic 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent.\n */\nvoid fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b);\n\n/**\n * Computes a power of a cyclotomic 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the basis.\n * @param[in] b\t\t\t\t- the exponent in sparse form.\n * @param[in] l\t\t\t\t- the length of the exponent in sparse form.\n * @param[in] s\t\t\t\t- the sign of the exponent.\n */\nvoid fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t l, int s);\n\n/**\n * Compresses a 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to compress.\n */\nvoid fp54_pck(fp54_t c, const fp54_t a);\n\n/**\n * Decompresses a 54-extension field element.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the 54-extension field element to decompress.\n * @return if the decompression was successful\n */\nint fp54_upk(fp54_t c, const fp54_t a);\n\n#endif /* !RLC_FPX_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup md Hash functions\n */\n\n/**\n * @file\n *\n * Interface of the module for computing hash functions.\n *\n * @ingroup md\n */\n\n#ifndef RLC_MD_H\n#define RLC_MD_H\n\n#include \"relic_conf.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\nenum {\n\t/** Hash length for SHA-224 function. */\n\tRLC_MD_LEN_SH224 = 28,\n\t/** Hash length for SHA-256 function. */\n\tRLC_MD_LEN_SH256 = 32,\n\t/** Hash length for SHA-384 function. */\n\tRLC_MD_LEN_SH384 = 48,\n\t/** Hash length for SHA-512 function. */\n\tRLC_MD_LEN_SH512 = 64,\n\t/** Hash length for BLAKE2s-160 function. */\n\tRLC_MD_LEN_B2S160 = 20,\n\t/** Hash length for BLAKE2s-256 function. */\n\tRLC_MD_LEN_B2S256 = 32\n};\n\n/**\n * Length in bytes of default hash function output.\n */\n#if MD_MAP == SH224\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH224\n#elif MD_MAP == SH256\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH256\n#elif MD_MAP == SH384\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH384\n#elif MD_MAP == SH512\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_SH512\n#elif MD_MAP == B2S160\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_B2S160\n#elif MD_MAP == B2S256\n#define RLC_MD_LEN\t\t\t\t\tRLC_MD_LEN_B2S256\n#endif\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Maps a byte vector to a fixed-length byte vector using the chosen hash\n * function.\n *\n * @param[out] H\t\t\t\t- the digest.\n * @param[in] M\t\t\t\t\t- the message to hash.\n * @param[in] L\t\t\t\t\t- the message length in bytes.\n */\n#if MD_MAP == SH224\n#define md_map(H, M, L)\t\t\tmd_map_sh224(H, M, L)\n#elif MD_MAP == SH256\n#define md_map(H, M, L)\t\t\tmd_map_sh256(H, M, L)\n#elif MD_MAP == SH384\n#define md_map(H, M, L)\t\t\tmd_map_sh384(H, M, L)\n#elif MD_MAP == SH512\n#define md_map(H, M, L)\t\t\tmd_map_sh512(H, M, L)\n#elif MD_MAP == B2S160\n#define md_map(H, M, L)\t\t\tmd_map_b2s160(H, M, L)\n#elif MD_MAP == B2S256\n#define md_map(H, M, L)\t\t\tmd_map_b2s256(H, M, L)\n#endif\n\n/**\n * Maps a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the chosen hash function.\n *\n * @param[out] B\t\t\t\t\t- the output buffer.\n * @param[in] BL\t\t\t\t\t- the requested size of the output.\n * @param[in] I\t\t\t\t\t\t- the message to hash.\n * @param[in] IL\t\t\t\t\t- the message length in bytes.\n * @param[in] D\t\t\t\t\t\t- the domain separation tag.\n * @param[in] DL\t\t\t\t\t- the domain separation tag length in bytes.\n */\n#if MD_MAP == SH224\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh224(B, BL, I, IL, D, DL)\n#elif MD_MAP == SH256\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh256(B, BL, I, IL, D, DL)\n#elif MD_MAP == SH384\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh384(B, BL, I, IL, D, DL)\n#elif MD_MAP == SH512\n#define md_xmd(B, BL, I, IL, D, DL) \tmd_xmd_sh512(B, BL, I, IL, D, DL)\n#endif\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Computes the SHA-224 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh224(uint8_t *hash, const uint8_t *msg, size_t len);\n\n/**\n * Computes the SHA-256 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len);\n\n/**\n * Computes the SHA-384 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh384(uint8_t *hash, const uint8_t *msg, size_t len);\n\n/**\n * Computes the SHA-512 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len);\n\n/**\n * Computes the BLAKE2s-160 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_b2s160(uint8_t *hash, const uint8_t *msg, size_t len);\n\n/**\n * Computes the BLAKE2s-256 hash function.\n *\n * @param[out] hash\t\t\t\t- the digest.\n * @param[in] msg\t\t\t\t- the message to hash.\n * @param[in] len\t\t\t\t- the message length in bytes.\n */\nvoid md_map_b2s256(uint8_t *hash, const uint8_t *msg, size_t len);\n\n/**\n * Derives a key from shared secret material through the standardized KDF2\n * function.\n *\n * @param[out] key\t\t\t\t- the resulting key.\n * @param[in] key_len\t\t\t- the intended key length in bytes.\n * @param[in] in\t\t\t\t- the shared secret.\n * @param[in] in_len\t\t\t- the length of the shared secret in bytes.\n */\nvoid md_kdf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len);\n\n/**\n * Derives a mask from shared secret material through the PKCS#1 2.1 MGF1\n * function. This is the same as the standardized KDF1 key derivation function.\n *\n * @param[out] key\t\t\t\t- the resulting mask.\n * @param[in] key_len\t\t\t- the intended mask length in bytes.\n * @param[in] in\t\t\t\t- the shared secret.\n * @param[in] in_len\t\t\t- the length of the shared secret in bytes.\n */\nvoid md_mgf(uint8_t *mask, size_t mask_len, const uint8_t *in, size_t in_len);\n\n/**\n * Computes a Message Authentication Code through HMAC.\n *\n * @param[out] mac\t\t\t\t- the authentication.\n * @param[in] in\t\t\t\t- the date to authenticate.\n * @param[in] in_len\t\t\t- the number of bytes to authenticate.\n * @param[in] key\t\t\t\t- the cryptographic key.\n * @param[in] key_len\t\t\t- the size of the key in bytes.\n */\nvoid md_hmac(uint8_t *mac, const uint8_t *in, size_t in_len, const uint8_t *key,\n\t\tsize_t key_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-224 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh224(uint8_t *buf, size_t buf_len, const uint8_t *in,\n\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-256 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh256(uint8_t *buf, size_t buf_len, const uint8_t *in,\n\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-384 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh384(uint8_t *buf, size_t buf_len, const uint8_t *in,\n\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n\n/**\n * Map a byte vector and optional domain separation tag to an arbitrary-length\n * pseudorandom output using the SHA-512 hash function.\n *\n * @param[out] buf\t\t\t\t\t- the output buffer.\n * @param[in] buf_len\t\t\t\t- the requested size of the output.\n * @param[in] in\t\t\t\t\t- the message to hash.\n * @param[in] in_len\t\t\t\t- the message length in bytes.\n * @param[in] dst\t\t\t\t\t- the domain separation tag.\n * @param[in] dst_len\t\t\t\t- the domain separation tag length in bytes.\n */\nvoid md_xmd_sh512(uint8_t *buf, size_t buf_len, const uint8_t *in,\n\t\tsize_t in_len, const uint8_t *dst, size_t dst_len);\n\n#endif /* !RLC_MD_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup rand Pseudo-random number generators.\n */\n\n/**\n * @file\n *\n * Interface of the module for pseudo-random number generation.\n *\n * @ingroup rand\n */\n\n#ifndef RLC_RAND_H\n#define RLC_RAND_H\n\n#include \"relic_rand.h\"\n\n/*============================================================================*/\n/* Constant definitions                                                       */\n/*============================================================================*/\n\n/**\n * Size of the PRNG internal state in bytes.\n */\n#if RAND == HASHD\n\n#if MD_MAP == SH224 || MD_MAP == SH256 || MD_MAP == B2S160 || MD_MAP == B2S256\n#define RLC_RAND_SIZE\t\t(1 + 2*440/8)\n#elif MD_MAP == SH384 || MD_MAP == SH512\n#define RLC_RAND_SIZE\t\t(1 + 2*888/8)\n#endif\n\n#elif RAND == UDEV\n#define RLC_RAND_SIZE\t\t(sizeof(int))\n#elif RAND == CALL\n#define RLC_RAND_SIZE\t\t(sizeof(void (*)(uint8_t *, int)))\n#elif RAND == RDRND\n#define RLC_RAND_SIZE      0\n#endif\n\n/**\n * Minimum size of the PRNG seed.\n */\n#define RLC_RAND_SEED\t    64\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Initializes the pseudo-random number generator.\n */\nvoid rand_init(void);\n\n/**\n * Finishes the pseudo-random number generator.\n */\nvoid rand_clean(void);\n\n#if RAND != CALL\n\n/**\n * Sets the initial state of the pseudo-random number generator.\n *\n * @param[in] buf\t\t\t- the buffer that represents the initial state.\n * @param[in] size\t\t\t- the number of bytes.\n * @throw ERR_NO_VALID\t\t- if the entropy length is too small or too large.\n */\nvoid rand_seed(uint8_t *buf, size_t size);\n\n#else\n\n/**\n * Sets the initial state of the pseudo-random number generator as a function\n * pointer.\n *\n * @param[in] callback\t\t- the callback to call.\n * @param[in] arg\t\t\t- the argument for the callback.\n */\nvoid rand_seed(void (*callback)(uint8_t *, size_t, void *), void *arg);\n\n#endif\n\n/**\n * Performs a basic self-test in the pseudo-random number generator output, and\n * raises an exception in case a string of identifical bytes is found.\n *\n * @param[out] buf\t\t\t- the buffer to check.\n * @param[in] size\t\t\t- the number of bytes to check.\n * @throw ERR_NO_RAND       - if the pseudo-random number generator is stuck.\n */\nint rand_check(uint8_t *buf, size_t size);\n\n/**\n * Gathers pseudo-random bytes from the pseudo-random number generator.\n *\n * @param[out] buf\t\t\t- the buffer to write.\n * @param[in] size\t\t\t- the number of bytes to gather.\n * @throw ERR_NO_VALID\t\t- if the required length is too large.\n * @throw ERR_NO_READ\t\t- it the pseudo-random number generator cannot\n * \t\t\t\t\t\t\tgenerate the specified number of bytes.\n */\nvoid rand_bytes(uint8_t *buf, size_t size);\n\n#endif /* !RLC_RAND_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @defgroup util Misc utilities\n */\n\n/**\n * @file\n *\n * Interface of misc utilitles.\n *\n * @ingroup util\n */\n\n#ifndef RLC_UTIL_H\n#define RLC_UTIL_H\n\n#include \"relic_arch.h\"\n#include \"relic_types.h\"\n#include \"relic_label.h\"\n\n/*============================================================================*/\n/* Macro definitions                                                          */\n/*============================================================================*/\n\n/**\n * Returns the minimum between two numbers.\n *\n * @param[in] A\t\t- the first number.\n * @param[in] B\t\t- the second number.\n */\n#define RLC_MIN(A, B)\t\t\t((A) < (B) ? (A) : (B))\n\n/**\n * Returns the maximum between two numbers.\n *\n * @param[in] A\t\t- the first number.\n * @param[in] B\t\t- the second number.\n */\n#define RLC_MAX(A, B)\t\t\t((A) > (B) ? (A) : (B))\n\n/**\n * Splits a bit count in a digit count and an updated bit count.\n *\n * @param[out] B\t\t- the resulting bit count.\n * @param[out] D\t\t- the resulting digit count.\n * @param[out] V\t\t- the bit count.\n */\n#define RLC_RIP(B, D, V)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tD = (V) >> (RLC_DIG_LOG); B = (V) - ((D) * (1 << RLC_DIG_LOG));\n\n/**\n * Computes the ceiling function of an integer division.\n *\n * @param[in] A\t\t\t- the dividend.\n * @param[in] B\t\t\t- the divisor.\n */\n#define RLC_CEIL(A, B)\t\t\t(((A) - 1) / (B) + 1)\n\n/**\n * Returns a bit mask to isolate the lowest part of a digit.\n *\n * @param[in] B\t\t\t- the number of bits to isolate.\n */\n#define RLC_MASK(B)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t((-(dig_t)((B) >= WSIZE)) | (((dig_t)1 << ((B) % WSIZE)) - 1))\n\n/**\n * Returns a bit mask to isolate the lowest half of a digit.\n */\n#define RLC_LMASK\t\t\t\t(RLC_MASK(RLC_DIG >> 1))\n\n/**\n * Returns a bit mask to isolate the highest half of a digit.\n */\n#define RLC_HMASK\t\t\t\t(RLC_LMASK << (RLC_DIG >> 1))\n\n/**\n * Bit mask used to return an entire digit.\n */\n#define RLC_DMASK\t\t\t\t(RLC_HMASK | RLC_LMASK)\n\n/**\n * Returns the lowest half of a digit.\n *\n * @param[in] D\t\t\t- the digit.\n */\n#define RLC_LOW(D)\t\t\t\t(D & RLC_LMASK)\n\n/**\n * Returns the highest half of a digit.\n *\n * @param[in] D\t\t\t- the digit.\n */\n#define RLC_HIGH(D)\t\t\t\t(D >> (RLC_DIG >> 1))\n\n/**\n * Returns the sign bit of a digit.\n *\n * @param[in] D\t\t\t- the digit.\n */\n#define RLC_SIGN(D)\t\t\t\t(((dig_t)D) >> (RLC_DIG - 1))\n\n/**\n * Selects between two values based on the value of a given flag.\n *\n * @param[in] A\t\t\t- the first argument.\n * @param[in] B\t\t\t- the second argument.\n * @param[in] C\t\t\t- the selection flag.\n */\n#define RLC_SEL(A, B, C) \t\t((-(C) & ((A) ^ (B))) ^ (A))\n\n/**\n * Swaps two values.\n *\n * @param[in] A\t\t\t- the first argument.\n * @param[in] B\t\t\t- the second argument.\n */\n#define RLC_SWAP(A, B) \t\t\t((A) ^= (B), (B) ^= (A), (A) ^= (B))\n\n/**\n * Returns the given character in upper case.\n *\n * @param[in] C\t\t\t- the character.\n */\n#define RLC_UPP(C)\t\t\t\t((C) - 0x20 * (((C) >= 'a') && ((C) <= 'z')))\n\n/**\n  *  Indirection to help some compilers expand symbols.\n  */\n#define RLC_ECHO(A) \t\t\tA\n\n/**\n * Concatenates two tokens.\n */\n/** @{ */\n#define RLC_CAT(A, B)\t\t\t_RLC_CAT(A, B)\n#define _RLC_CAT(A, B)\t\t\tA ## B\n/** @} */\n\n/**\n * Selects a basic or advanced version of a function by checking if an\n * additional argument was passed.\n */\n/** @{ */\n#define RLC_OPT(...)\t\t\t_OPT(__VA_ARGS__, _imp, _basic, _error)\n#define _OPT(...)\t\t\t\tRLC_ECHO(__OPT(__VA_ARGS__))\n#define __OPT(_1, _2, N, ...)\tN\n/** @} */\n\n/**\n * Generic macro to initialize an object to NULL.\n *\n * @param[out] A\t\t\t- the object to initialize.\n */\n#if ALLOC == AUTO\n#define RLC_NULL(A)\t\t\t/* empty */\n#else\n#define RLC_NULL(A)\t\t\tA = NULL;\n#endif\n\n\n/**\n * Accumulates a double precision digit in a triple register variable.\n *\n * @param[in,out] R2\t\t- most significant word of the triple register.\n * @param[in,out] R1\t\t- middle word of the triple register.\n * @param[in,out] R0\t\t- lowest significant word of the triple register.\n * @param[in] A\t\t\t\t- the first digit to multiply.\n * @param[in] B\t\t\t\t- the second digit to multiply.\n */\n#define RLC_COMBA_STEP_MUL(R2, R1, R0, A, B)\t\t\t\t\t\t\t\t\\\n\tdig_t _r, _r0, _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_MUL_DIG(_r1, _r0, A, B);\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_COMBA_ADD(_r, R2, R1, R0, _r0);\t\t\t\t\t\t\t\t\t\t\\\n\t(R1) += _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (R1) < _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Computes the step of a Comba squaring.\n *\n * @param[in,out] R2\t\t- most significant word of the triple register.\n * @param[in,out] R1\t\t- middle word of the triple register.\n * @param[in,out] R0\t\t- lowest significant word of the triple register.\n * @param[in] A\t\t\t\t- the first digit to multiply.\n * @param[in] B\t\t\t\t- the second digit to multiply.\n */\n#define RLC_COMBA_STEP_SQR(R2, R1, R0, A, B)\t\t\t\t\t\t\t\t\\\n\tdig_t _r, _r0, _r1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tRLC_MUL_DIG(_r1, _r0, A, B);\t\t\t\t\t\t\t\t\t\t\t\\\n\tdig_t _s0 = _r0 + _r0;\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tdig_t _s1 = _r1 + _r1 + (_s0 < _r0);\t\t\t\t\t\t\t\t\t\\\n\tRLC_COMBA_ADD(_r, R2, R1, R0, _s0);\t\t\t\t\t\t\t\t\t\t\\\n\t(R1) += _s1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (R1) < _s1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (_s1 < _r1);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Accumulates a single precision digit in a triple register variable.\n *\n * @param[in,out] T\t\t\t- the temporary variable.\n * @param[in,out] R2\t\t- most significant word of the triple register.\n * @param[in,out] R1\t\t- middle word of the triple register.\n * @param[in,out] R0\t\t- lowest significant word of the triple register.\n * @param[in] A\t\t\t\t- the first digit to accumulate.\n */\n#define RLC_COMBA_ADD(T, R2, R1, R0, A)\t\t\t\t\t\t\t\t\t\t\\\n\t(T) = (R1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R0) += (A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R1) += (R0) < (A);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t(R2) += (R1) < (T);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/**\n * Selects a real or dummy printing function depending on library flags.\n *\n * @param[in] F\t\t\t- the format string.\n */\n#ifndef QUIET\n#define util_print(F, ...)\t\tutil_printf(RLC_STR(F), ##__VA_ARGS__)\n#else\n#define util_print(F, ...)\t\t/* empty */\n#endif\n\n/**\n * Prints a standard label.\n *\n * @param[in] L\t\t\t- the label of the banner.\n * @param[in] I\t\t\t- if the banner is inside an hierarchy.\n */\n#define util_banner(L, I)\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (!I) {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tutil_print(\"\\n-- \" L \"\\n\");\t\t\t\t\t\t\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tutil_print(\"\\n** \" L \"\\n\\n\");\t\t\t\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\n/*============================================================================*/\n/* Function prototypes                                                        */\n/*============================================================================*/\n\n/**\n * Toggle endianess of a digit.\n */\nuint32_t util_conv_endian(uint32_t i);\n\n/**\n * Convert a digit to big-endian.\n */\nuint32_t util_conv_big(uint32_t i);\n\n/**\n * Convert a digit to little-endian.\n */\nuint32_t util_conv_little(uint32_t i);\n\n/**\n * Converts a small digit to a character.\n */\nchar util_conv_char(dig_t i);\n\n/**\n * Returns the highest bit set on a digit.\n *\n * @param[in] a\t\t\t\t- the digit.\n * @return the position of the highest bit set.\n */\nsize_t util_bits_dig(dig_t a);\n\n/**\n * Compares two buffers in constant time.\n *\n * @param[in] a\t\t\t\t- the first buffer.\n * @param[in] b\t\t\t\t- the second buffer.\n * @param[in] n\t\t\t\t- the length in bytes of the buffers.\n * @return RLC_EQ if they are equal and RLC_NE otherwise.\n */\nint util_cmp_const(const void *a, const void *b, int n);\n\n/**\n * Computes a random permutation in [0, n-1].\n *\n * @param[out] p \t\t\t- the resulting permutation.\n * @param[in] n \t\t\t- the size of the permutation.\n */\nvoid util_perm(unsigned int p[], int n);\n\n/**\n * Formats and prints data following a printf-like syntax.\n *\n * @param[in] format\t\t- the format.\n * @param[in] ...\t\t\t- the list of arguments matching the format.\n */\nvoid util_printf(const char *format, ...);\n\n/**\n * Prints a digit.\n *\n * @param[in] a \t\t\t- the digit to print.\n * @param[in] pad \t\t\t- the flag to indicate if the digit must be padded\n * \t\t\t\t\t\t\twith zeroes.\n */\nvoid util_print_dig(dig_t a, int pad);\n\n#endif /* !RLC_UTIL_H */\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision addition and subtraction functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\nvoid bn_gcd_basic(bn_t c, const bn_t a, const bn_t b) {\n\tbn_t u, v;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\n\t\tbn_abs(u, a);\n\t\tbn_abs(v, b);\n\t\twhile (!bn_is_zero(v)) {\n\t\t\tbn_copy(c, v);\n\t\t\tbn_mod(v, u, v);\n\t\t\tbn_copy(u, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t}\n}\n\nvoid bn_gcd_ext_basic(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n\tbn_t u, v, x_1, y_1, q, r;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(x_1);\n\tbn_null(y_1);\n\tbn_null(q);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(x_1);\n\t\tbn_new(y_1);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\n\t\tbn_abs(u, a);\n\t\tbn_abs(v, b);\n\n\t\tbn_zero(x_1);\n\t\tbn_set_dig(y_1, 1);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\n\t\twhile (!bn_is_zero(v)) {\n\t\t\tbn_div_rem(q, r, u, v);\n\n\t\t\tbn_copy(u, v);\n\t\t\tbn_copy(v, r);\n\n\t\t\tbn_mul(c, q, x_1);\n\t\t\tbn_sub(r, d, c);\n\t\t\tbn_copy(d, x_1);\n\t\t\tbn_copy(x_1, r);\n\n\t\t\tif (e != NULL) {\n\t\t\t\tbn_mul(c, q, y_1);\n\t\t\t\tbn_sub(r, e, c);\n\t\t\t\tbn_copy(e, y_1);\n\t\t\t\tbn_copy(y_1, r);\n\t\t\t}\n\t\t}\n\t\tbn_copy(c, u);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(x_1);\n\t\tbn_free(y_1);\n\t\tbn_free(q);\n\t\tbn_free(r);\n\t}\n}\n\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\nvoid bn_gcd_lehme(bn_t c, const bn_t a, const bn_t b) {\n\tbn_t x, y, u, v, t0, t1, t2, t3;\n\tdig_t _x, _y, q, _q, t, _t;\n\tdis_t _a, _b, _c, _d;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_null(x);\n\tbn_null(y);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\tbn_null(t3);\n\n\t/*\n\t * Taken from Handbook of Hyperelliptic and Elliptic Cryptography.\n\t */\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tbn_new(y);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\t\tbn_new(t3);\n\n\t\tif (bn_cmp_abs(a, b) == RLC_GT) {\n\t\t\tbn_abs(x, a);\n\t\t\tbn_abs(y, b);\n\t\t} else {\n\t\t\tbn_abs(x, b);\n\t\t\tbn_abs(y, a);\n\t\t}\n\t\twhile (y->used > 1) {\n\t\t\tif (bn_bits(x) > RLC_DIG) {\n\t\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n\t\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n\t\t\t} else {\n\t\t\t\tbn_copy(u, x);\n\t\t\t\tbn_copy(v, y);\n\t\t\t}\n\t\t\t_x = u->dp[0];\n\t\t\t_y = v->dp[0];\n\t\t\t_a = _d = 1;\n\t\t\t_b = _c = 0;\n\t\t\tt = 0;\n\t\t\tif (_y != 0) {\n\t\t\t\tq = _x / _y;\n\t\t\t\tt = _x % _y;\n\t\t\t}\n\t\t\tif (t >= ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\twhile (1) {\n\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t_t = _y % t;\n\t\t\t\t\tif (_t < ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_x = _y;\n\t\t\t\t\t_y = t;\n\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t_a = _c;\n\t\t\t\t\t_c = t;\n\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t_b = _d;\n\t\t\t\t\t_d = t;\n\t\t\t\t\tt = _t;\n\t\t\t\t\tq = _q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_b == 0) {\n\t\t\t\tbn_mod(t0, x, y);\n\t\t\t\tbn_copy(x, y);\n\t\t\t\tbn_copy(y, t0);\n\t\t\t} else {\n\t\t\t\tif (bn_bits(x) > 2 * RLC_DIG) {\n\t\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\t} else {\n\t\t\t\t\tbn_copy(u, x);\n\t\t\t\t\tbn_copy(v, y);\n\t\t\t\t}\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, u, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, u, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, v, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, v, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, u, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, u, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, v, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, v, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(u, t0, t1);\n\t\t\t\tbn_add(v, t2, t3);\n\t\t\t\tif (bn_bits(u) > RLC_DIG) {\n\t\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n\t\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n\t\t\t\t} else {\n\t\t\t\t\tbn_copy(t0, u);\n\t\t\t\t\tbn_copy(t1, v);\n\t\t\t\t}\n\t\t\t\t_x = t0->dp[0];\n\t\t\t\t_y = t1->dp[0];\n\t\t\t\tt = 0;\n\t\t\t\tif (_y != 0) {\n\t\t\t\t\tq = _x / _y;\n\t\t\t\t\tt = _x % _y;\n\t\t\t\t}\n\t\t\t\tif (t >= ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t\t_t = _y % t;\n\t\t\t\t\t\tif (_t < ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_x = _y;\n\t\t\t\t\t\t_y = t;\n\t\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t\t_a = _c;\n\t\t\t\t\t\t_c = t;\n\t\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t\t_b = _d;\n\t\t\t\t\t\t_d = t;\n\t\t\t\t\t\tt = _t;\n\t\t\t\t\t\tq = _q;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, x, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, x, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, y, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, y, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, x, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, x, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, y, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, y, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(x, t0, t1);\n\t\t\t\tbn_add(y, t2, t3);\n\t\t\t}\n\t\t}\n\t\tbn_gcd_ext_dig(c, u, v, x, y->dp[0]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tbn_free(y);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t\tbn_free(t3);\n\t}\n}\n\nvoid bn_gcd_ext_lehme(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n\tbn_t x, y, u, v, t0, t1, t2, t3, t4;\n\tdig_t _x, _y, q, _q, t, _t;\n\tdis_t _a, _b, _c, _d;\n\tint swap;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(x);\n\tbn_null(y);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\tbn_null(t3);\n\tbn_null(t4);\n\n\t/*\n\t * Taken from Handbook of Hyperelliptic and Elliptic Cryptography.\n\t */\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tbn_new(y);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\t\tbn_new(t3);\n\t\tbn_new(t4);\n\n\t\tif (bn_cmp_abs(a, b) != RLC_LT) {\n\t\t\tbn_abs(x, a);\n\t\t\tbn_abs(y, b);\n\t\t\tswap = 0;\n\t\t} else {\n\t\t\tbn_abs(x, b);\n\t\t\tbn_abs(y, a);\n\t\t\tswap = 1;\n\t\t}\n\n\t\tbn_zero(t4);\n\t\tbn_set_dig(d, 1);\n\n\t\twhile (y->used > 1) {\n\t\t\tif (bn_bits(x) > RLC_DIG) {\n\t\t\t\tbn_rsh(u, x, bn_bits(x) - RLC_DIG);\n\t\t\t\tbn_rsh(v, y, bn_bits(x) - RLC_DIG);\n\t\t\t} else {\n\t\t\t\tbn_copy(u, x);\n\t\t\t\tbn_copy(v, y);\n\t\t\t}\n\t\t\t_x = u->dp[0];\n\t\t\t_y = v->dp[0];\n\t\t\t_a = _d = 1;\n\t\t\t_b = _c = 0;\n\t\t\tt = 0;\n\t\t\tif (_y != 0) {\n\t\t\t\tq = _x / _y;\n\t\t\t\tt = _x % _y;\n\t\t\t}\n\t\t\tif (t >= ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\twhile (1) {\n\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t_t = _y % t;\n\t\t\t\t\tif (_t < ((dig_t)1 << (RLC_DIG / 2))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t_x = _y;\n\t\t\t\t\t_y = t;\n\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t_a = _c;\n\t\t\t\t\t_c = t;\n\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t_b = _d;\n\t\t\t\t\t_d = t;\n\t\t\t\t\tt = _t;\n\t\t\t\t\tq = _q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (_b == 0) {\n\t\t\t\tbn_div_rem(t1, t0, x, y);\n\t\t\t\tbn_copy(x, y);\n\t\t\t\tbn_copy(y, t0);\n\t\t\t\tbn_mul(t1, t1, d);\n\t\t\t\tbn_sub(t1, t4, t1);\n\t\t\t\tbn_copy(t4, d);\n\t\t\t\tbn_copy(d, t1);\n\t\t\t} else {\n\t\t\t\tif (bn_bits(x) > 2 * RLC_DIG) {\n\t\t\t\t\tbn_rsh(u, x, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\t\tbn_rsh(v, y, bn_bits(x) - 2 * RLC_DIG);\n\t\t\t\t} else {\n\t\t\t\t\tbn_copy(u, x);\n\t\t\t\t\tbn_copy(v, y);\n\t\t\t\t}\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, u, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, u, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, v, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, v, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, u, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, u, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, v, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, v, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(u, t0, t1);\n\t\t\t\tbn_add(v, t2, t3);\n\t\t\t\tif (bn_bits(u) > RLC_DIG) {\n\t\t\t\t\tbn_rsh(t0, u, bn_bits(u) - RLC_DIG);\n\t\t\t\t\tbn_rsh(t1, v, bn_bits(u) - RLC_DIG);\n\t\t\t\t} else {\n\t\t\t\t\tbn_copy(t0, u);\n\t\t\t\t\tbn_copy(t1, v);\n\t\t\t\t}\n\t\t\t\t_x = t0->dp[0];\n\t\t\t\t_y = t1->dp[0];\n\t\t\t\tt = 0;\n\t\t\t\tif (_y != 0) {\n\t\t\t\t\tq = _x / _y;\n\t\t\t\t\tt = _x % _y;\n\t\t\t\t}\n\t\t\t\tif (t >= ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\t_q = _y / t;\n\t\t\t\t\t\t_t = _y % t;\n\t\t\t\t\t\tif (_t < ((dig_t)1 << RLC_DIG / 2)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_x = _y;\n\t\t\t\t\t\t_y = t;\n\t\t\t\t\t\tt = _a - q * _c;\n\t\t\t\t\t\t_a = _c;\n\t\t\t\t\t\t_c = t;\n\t\t\t\t\t\tt = _b - q * _d;\n\t\t\t\t\t\t_b = _d;\n\t\t\t\t\t\t_d = t;\n\t\t\t\t\t\tt = _t;\n\t\t\t\t\t\tq = _q;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, x, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, x, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, y, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, y, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, x, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, x, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, y, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, y, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(x, t0, t1);\n\t\t\t\tbn_add(y, t2, t3);\n\n\t\t\t\tif (_a < 0) {\n\t\t\t\t\tbn_mul_dig(t0, t4, -_a);\n\t\t\t\t\tbn_neg(t0, t0);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t0, t4, _a);\n\t\t\t\t}\n\t\t\t\tif (_b < 0) {\n\t\t\t\t\tbn_mul_dig(t1, d, -_b);\n\t\t\t\t\tbn_neg(t1, t1);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t1, d, _b);\n\t\t\t\t}\n\t\t\t\tif (_c < 0) {\n\t\t\t\t\tbn_mul_dig(t2, t4, -_c);\n\t\t\t\t\tbn_neg(t2, t2);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t2, t4, _c);\n\t\t\t\t}\n\t\t\t\tif (_d < 0) {\n\t\t\t\t\tbn_mul_dig(t3, d, -_d);\n\t\t\t\t\tbn_neg(t3, t3);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul_dig(t3, d, _d);\n\t\t\t\t}\n\t\t\t\tbn_add(t4, t0, t1);\n\t\t\t\tbn_add(d, t2, t3);\n\t\t\t}\n\t\t}\n\t\tbn_gcd_ext_dig(c, u, v, x, y->dp[0]);\n\t\tif (!swap) {\n\t\t\tbn_mul(t0, t4, u);\n\t\t\tbn_mul(t1, d, v);\n\t\t\tbn_add(t4, t0, t1);\n\t\t\tbn_mul(x, b, t4);\n\t\t\tbn_sub(x, c, x);\n\t\t\tbn_div(d, x, a);\n\t\t} else {\n\t\t\tbn_mul(t0, t4, u);\n\t\t\tbn_mul(t1, d, v);\n\t\t\tbn_add(d, t0, t1);\n\t\t\tbn_mul(x, a, d);\n\t\t\tbn_sub(x, c, x);\n\t\t\tbn_div(t4, x, b);\n\t\t}\n\t\tif (e != NULL) {\n\t\t\tbn_copy(e, t4);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tbn_free(y);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t\tbn_free(t3);\n\t\tbn_free(t4);\n\t}\n}\n\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\nvoid bn_gcd_binar(bn_t c, const bn_t a, const bn_t b) {\n\tbn_t u, v, t;\n\tint shift;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(t);\n\n\t\tbn_abs(u, a);\n\t\tbn_abs(v, b);\n\n\t\tshift = 0;\n\t\twhile (bn_is_even(u) && bn_is_even(v)) {\n\t\t\tbn_hlv(u, u);\n\t\t\tbn_hlv(v, v);\n\t\t\tshift++;\n\t\t}\n\t\twhile (!bn_is_zero(u)) {\n\t\t\twhile (bn_is_even(u)) {\n\t\t\t\tbn_hlv(u, u);\n\t\t\t}\n\t\t\twhile (bn_is_even(v)) {\n\t\t\t\tbn_hlv(v, v);\n\t\t\t}\n\t\t\tbn_sub(t, u, v);\n\t\t\tbn_abs(t, t);\n\t\t\tbn_hlv(t, t);\n\t\t\tif (bn_cmp(u, v) != RLC_LT) {\n\t\t\t\tbn_copy(u, t);\n\t\t\t} else {\n\t\t\t\tbn_copy(v, t);\n\t\t\t}\n\t\t}\n\t\tbn_lsh(c, v, shift);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_gcd_ext_binar(bn_t c, bn_t d, bn_t e, const bn_t a, const bn_t b) {\n\tbn_t x, y, t, u, v, _a, _b, _e;\n\tint shift;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(x);\n\tbn_null(y);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(_a);\n\tbn_null(_b);\n\tbn_null(_e);\n\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tbn_new(y);\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(_a);\n\t\tbn_new(_b);\n\t\tbn_new(_e);\n\n\t\tbn_abs(x, a);\n\t\tbn_abs(y, b);\n\n\t\t/* g = 1. */\n\t\tshift = 0;\n\t\t/* While x and y are both even, x = x/2 and y = y/2, g = 2g. */\n\t\twhile (bn_is_even(x) && bn_is_even(y)) {\n\t\t\tbn_hlv(x, x);\n\t\t\tbn_hlv(y, y);\n\t\t\tshift++;\n\t\t}\n\n\t\tbn_copy(u, x);\n\t\tbn_copy(v, y);\n\n\t\t/* u = x, y = v, A = 1, B = 0, C = 0, D = 1. */\n\t\tbn_set_dig(_a, 1);\n\t\tbn_zero(_b);\n\t\tbn_zero(d);\n\t\tbn_set_dig(_e, 1);\n\n\t\t/* While u is even, u = u/2. */\n\t\twhile (bn_is_even(u)) {\n\t\t\tbn_hlv(u, u);\n\t\t\t/* If A = B = 0 (mod 2) then A = A/2, B = B/2. */\n\t\t\tif ((_a->dp[0] & 0x01) == 0 && (_b->dp[0] & 0x01) == 0) {\n\t\t\t\tbn_hlv(_a, _a);\n\t\t\t\tbn_hlv(_b, _b);\n\t\t\t} else {\n\t\t\t\t/* Otherwise A = (A + y)/2, B = (B - x)/2. */\n\t\t\t\tbn_add(_a, _a, y);\n\t\t\t\tbn_hlv(_a, _a);\n\t\t\t\tbn_sub(_b, _b, x);\n\t\t\t\tbn_hlv(_b, _b);\n\t\t\t}\n\t\t}\n\t\twhile (bn_cmp(u, v) != RLC_EQ) {\n\t\t\t/* If v is even, v = v/2. */\n\t\t\tif (bn_is_even(v)) {\n\t\t\t\tbn_hlv(v, v);\n\t\t\t\t/* If C = D = 0 (mod 2) then C = C/2, D = D/2. */\n\t\t\t\tif ((d->dp[0] & 0x01) == 0 && (_e->dp[0] & 0x01) == 0) {\n\t\t\t\t\tbn_hlv(d, d);\n\t\t\t\t\tbn_hlv(_e, _e);\n\t\t\t\t} else {\n\t\t\t\t\t/* Otherwise C = (C + y)/2, D = (D - x)/2. */\n\t\t\t\t\tbn_add(d, d, y);\n\t\t\t\t\tbn_hlv(d, d);\n\t\t\t\t\tbn_sub(_e, _e, x);\n\t\t\t\t\tbn_hlv(_e, _e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (bn_cmp(v, u) == RLC_LT) {\n\t\t\t\t\tbn_copy(c, u);\n\t\t\t\t\tbn_copy(u, v);\n\t\t\t\t\tbn_copy(v, c);\n\t\t\t\t\tbn_copy(c, d);\n\t\t\t\t\tbn_copy(d, _a);\n\t\t\t\t\tbn_copy(_a, c);\n\t\t\t\t\tbn_copy(c, _e);\n\t\t\t\t\tbn_copy(_e, _b);\n\t\t\t\t\tbn_copy(_b, c);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub(v, v, u);\n\t\t\t\t\tbn_sub(d, d, _a);\n\t\t\t\t\tbn_sub(_e, _e, _b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* If u = 0 then d = C, e = D and return (d, e, g * v). */\n\t\tbn_lsh(c, u, shift);\n\t\t/* Now fix reciprocals. */\n\t\tbn_div(x, x, u);\n\t\tbn_div(y, y, u);\n\t\tbn_hlv(_a, x);\n\t\tbn_hlv(_b, y);\n\t\twhile (bn_cmp_abs(d, _b) == RLC_GT) {\n\t\t\tbn_div(t, d, _b);\n\t\t\tif (bn_bits(t) > 1) {\n\t\t\t\tbn_hlv(t, t);\n\t\t\t}\n\t\t\tbn_mul(v, x, t);\n\t\t\tbn_mul(u, y, t);\n\t\t\tif (bn_sign(d) != bn_sign(u)) {\n\t\t\t\tbn_add(d, d, u);\n\t\t\t\tbn_sub(_e, _e, v);\n\t\t\t} else {\n\t\t\t\tbn_sub(d, d, u);\n\t\t\t\tbn_add(_e, _e, v);\n\t\t\t}\n\t\t}\n\t\tif (e != NULL) {\n\t\t\tbn_copy(e, _e);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tbn_free(y);\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(_a);\n\t\tbn_free(_b);\n\t\tbn_free(_e);\n\t}\n}\n\n#endif\n\nvoid bn_gcd_ext_mid(bn_t c, bn_t d, bn_t e, bn_t f, const bn_t a, const bn_t b) {\n\tbn_t p, q, r, s, t, u, v, x, w, y, z;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_abs(c, b);\n\t\tbn_zero(d);\n\t\tbn_zero(e);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tbn_set_dig(e, 1);\n\t\treturn;\n\t}\n\n\tbn_null(q);\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(x);\n\tbn_null(w);\n\tbn_null(y);\n\tbn_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(x);\n\t\tbn_new(w);\n\t\tbn_new(y);\n\t\tbn_new(z);\n\n\t\tif (bn_cmp_abs(a, b) == RLC_GT) {\n\t\t\tbn_abs(u, a);\n\t\t\tbn_abs(v, b);\n\t\t} else {\n\t\t\tbn_abs(u, b);\n\t\t\tbn_abs(v, a);\n\t\t}\n\n\t\tbn_srt(p, u);\n\n\t\tbn_set_dig(x, 1);\n\t\tbn_zero(t);\n\n\t\tint wait = 0;\n\t\twhile (!bn_is_zero(v)) {\n\t\t\tbn_div_rem(q, r, u, v);\n\n\t\t\tbn_copy(u, v);\n\t\t\tbn_copy(v, r);\n\n\t\t\tbn_mul(s, q, x);\n\t\t\tbn_sub(s, t, s);\n\t\t\tbn_copy(t, x);\n\t\t\tbn_copy(x, s);\n\n\t\t\tif (wait) {\n\t\t\t\tbn_copy(e, r);\n\t\t\t\tbn_neg(f, x);\n\t\t\t\twait = 0;\n\t\t\t}\n\t\t\tif (bn_cmp(u, p) != RLC_LT) {\n\t\t\t\tbn_copy(c, r);\n\t\t\t\tbn_neg(d, x);\n\t\t\t\tbn_copy(w, u);\n\t\t\t\tbn_neg(y, t);\n\t\t\t\twait = 1;\n\t\t\t}\n\t\t}\n\t\t/* Compute r as the norm of vector (w, y). */\n\t\tbn_sqr(s, w);\n\t\tbn_sqr(t, y);\n\t\tbn_add(t, t, s);\n\n\t\t/* Compute q as the norm of vector (e, f). */\n\t\tbn_sqr(r, e);\n\t\tbn_sqr(q, f);\n\t\tbn_add(q, q, r);\n\n\t\t/* Output (e, f) as the vector of smaller norm. */\n\t\tif (bn_cmp(t, q) == RLC_LT) {\n\t\t\tbn_copy(e, w);\n\t\t\tbn_copy(f, y);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(p);\n\t\tbn_free(q);\n\t\tbn_free(r);\n\t\tbn_free(s);\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(x);\n\t\tbn_free(w);\n\t\tbn_free(y);\n\t\tbn_free(z);\n\t}\n}\n\nvoid bn_gcd_dig(bn_t c, const bn_t a, dig_t b) {\n\tdig_t _u, _v, _t = 0;\n\n\tif (bn_is_zero(a)) {\n\t\tbn_set_dig(c, b);\n\t\treturn;\n\t}\n\n\tif (b == 0) {\n\t\tbn_abs(c, a);\n\t\treturn;\n\t}\n\n\tbn_mod_dig(&(c->dp[0]), a, b);\n\t_v = c->dp[0];\n\t_u = b;\n\twhile (_v != 0) {\n\t\t_t = _v;\n\t\t_v = _u % _v;\n\t\t_u = _t;\n\t}\n\tbn_set_dig(c, _u);\n}\n\nvoid bn_gcd_ext_dig(bn_t c, bn_t d, bn_t e, const bn_t a, const dig_t b) {\n\tbn_t u, v, x1, y1, q, r;\n\tdig_t _v, _q, _t, _u;\n\n\tif (d == NULL && e == NULL) {\n\t\tbn_gcd_dig(c, a, b);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(a)) {\n\t\tbn_set_dig(c, b);\n\t\tbn_zero(d);\n\t\tif (e != NULL) {\n\t\t\tbn_set_dig(e, 1);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (b == 0) {\n\t\tbn_abs(c, a);\n\t\tbn_set_dig(d, 1);\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\t\treturn;\n\t}\n\n\tbn_null(u);\n\tbn_null(v);\n\tbn_null(x1);\n\tbn_null(y1);\n\tbn_null(q);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tbn_new(x1);\n\t\tbn_new(y1);\n\t\tbn_new(q);\n\t\tbn_new(r);\n\n\t\tbn_abs(u, a);\n\t\tbn_set_dig(v, b);\n\n\t\tbn_zero(x1);\n\t\tbn_set_dig(y1, 1);\n\t\tbn_set_dig(d, 1);\n\n\t\tif (e != NULL) {\n\t\t\tbn_zero(e);\n\t\t}\n\n\t\tbn_div_rem(q, r, u, v);\n\n\t\tbn_copy(u, v);\n\t\tbn_copy(v, r);\n\n\t\tbn_mul(c, q, x1);\n\t\tbn_sub(r, d, c);\n\t\tbn_copy(d, x1);\n\t\tbn_copy(x1, r);\n\n\t\tif (e != NULL) {\n\t\t\tbn_mul(c, q, y1);\n\t\t\tbn_sub(r, e, c);\n\t\t\tbn_copy(e, y1);\n\t\t\tbn_copy(y1, r);\n\t\t}\n\n\t\t_v = v->dp[0];\n\t\t_u = u->dp[0];\n\t\twhile (_v != 0) {\n\t\t\t_q = _u / _v;\n\t\t\t_t = _u % _v;\n\n\t\t\t_u = _v;\n\t\t\t_v = _t;\n\n\t\t\tbn_mul_dig(c, x1, _q);\n\t\t\tbn_sub(r, d, c);\n\t\t\tbn_copy(d, x1);\n\t\t\tbn_copy(x1, r);\n\n\t\t\tif (e != NULL) {\n\t\t\t\tbn_mul_dig(c, y1, _q);\n\t\t\t\tbn_sub(r, e, c);\n\t\t\t\tbn_copy(e, y1);\n\t\t\t\tbn_copy(y1, r);\n\t\t\t}\n\t\t}\n\t\tbn_set_dig(c, _u);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(u);\n\t\tbn_free(v);\n\t\tbn_free(x1);\n\t\tbn_free(y1);\n\t\tbn_free(q);\n\t\tbn_free(r);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision integer memory management routines.\n *\n * @ingroup bn\n */\n\n#include <errno.h>\n\n#if ALLOC != AUTO\n#include <malloc.h>\n#endif\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_make(bn_t a, size_t digits) {\n\tif (digits < 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\t/* Allocate at least one digit. */\n\tdigits = RLC_MAX(digits, 1);\n\n#if ALLOC == DYNAMIC\n\tif (digits % RLC_BN_SIZE != 0) {\n\t\t/* Pad the number of digits to a multiple of the block. */\n\t\tdigits += (RLC_BN_SIZE - digits % RLC_BN_SIZE);\n\t}\n\n\tif (a != NULL) {\n\t\ta->dp = NULL;\n#if ALIGN == 1\n\t\ta->dp = (dig_t *)malloc(digits * sizeof(dig_t));\n#elif OPSYS == WINDOWS\n\t\ta->dp = _aligned_malloc(digits * sizeof(dig_t), ALIGN);\n#else\n\t\tint r = posix_memalign((void **)&a->dp, ALIGN, digits * sizeof(dig_t));\n\t\tif (r == ENOMEM) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tif (r == EINVAL) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n#endif /* ALIGN */\n\t}\n\n\tif (a->dp == NULL) {\n\t\tfree((void *)a);\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t}\n#else\n\t/* Verify if the number of digits is sane. */\n\tif (digits > RLC_BN_SIZE) {\n\t\tRLC_THROW(ERR_NO_PRECI);\n\t\treturn;\n\t} else {\n\t\tdigits = RLC_BN_SIZE;\n\t}\n#endif\n\tif (a != NULL) {\n\t\ta->used = 1;\n\t\ta->dp[0] = 0;\n\t\ta->alloc = digits;\n\t\ta->sign = RLC_POS;\n\t}\n}\n\nvoid bn_clean(bn_t a) {\n#if ALLOC == DYNAMIC\n\tif (a != NULL) {\n\t\tif (a->dp != NULL) {\n#if OPSYS == WINDOWS && ALIGN > 1\n\t\t\t_aligned_free(a->dp);\n#else\n\t\t\tfree(a->dp);\n#endif\n\t\t\ta->dp = NULL;\n\t\t}\n\t\ta->alloc = 0;\n\t}\n#endif\n\tif (a != NULL) {\n\t\ta->used = 0;\n\t\ta->sign = RLC_POS;\n\t}\n}\n\nvoid bn_grow(bn_t a, size_t digits) {\n#if ALLOC == DYNAMIC\n\tdig_t *t;\n\n\tif (a->alloc < digits) {\n\t\t/* At least add RLC_BN_SIZE more digits. */\n\t\tdigits += (RLC_BN_SIZE * 2) - (digits % RLC_BN_SIZE);\n\t\tt = (dig_t *)realloc(a->dp, (RLC_DIG / 8) * digits);\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\treturn;\n\t\t}\n\t\ta->dp = t;\n\t\t/* Set the newly allocated digits to zero. */\n\t\ta->alloc = digits;\n\t}\n#elif ALLOC == AUTO\n\tif (digits > RLC_BN_SIZE) {\n\t\tRLC_THROW(ERR_NO_PRECI);\n\t\treturn;\n\t}\n\t(void)a;\n#endif\n}\n\nvoid bn_trim(bn_t a) {\n\tif (a->used <= a->alloc) {\n\t\twhile (a->used > 0 && a->dp[a->used - 1] == 0) {\n\t\t\t--(a->used);\n\t\t}\n\t\t/* Zero can't be negative. */\n\t\tif (a->used == 0) {\n\t\t\ta->used = 1;\n\t\t\ta->dp[0] = 0;\n\t\t\ta->sign = RLC_POS;\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision exponentiation functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Size of precomputation table.\n */\n#define RLC_TABLE_SIZE\t\t\t64\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if BN_MXP == BASIC || !defined(STRIP)\n\nvoid bn_mxp_basic(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t, u, r;\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\n\t\tbn_mod_pre(u, m);\n\n\t\tl = bn_bits(b);\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_conv(t, a, m);\n#else\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(r, t);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(r, r);\n\t\t\tbn_mod(r, r, m, u);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tbn_mul(r, r, t);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(r, r, m);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, r, m);\n\t\t} else {\n\t\t\tbn_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(r);\n\t}\n}\n\n#endif\n\n#if BN_MXP == SLIDE || !defined(STRIP)\n\nvoid bn_mxp_slide(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tbn_t tab[RLC_TABLE_SIZE], t, u, r;\n\tsize_t l, w = 1;\n\tuint8_t *win = RLC_ALLOCA(uint8_t, bn_bits(b));\n\n\tif (win == NULL) {\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tRLC_FREE(win);\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tRLC_FREE(win);\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\t/* Initialize table. */\n\tfor (size_t i = 0; i < RLC_TABLE_SIZE; i++) {\n\t\tbn_null(tab[i]);\n\t}\n\n\t/* Find window size. */\n\tl = bn_bits(b);\n\tif (l <= 21) {\n\t\tw = 2;\n\t} else if (l <= 32) {\n\t\tw = 3;\n\t} else if (l <= 128) {\n\t\tw = 4;\n\t} else if (l <= 256) {\n\t\tw = 5;\n\t} else if (l <= 512) {\n\t\tw = 6;\n\t} else {\n\t\tw = 7;\n\t}\n\n\tRLC_TRY {\n\t\tfor (size_t i = 0; i < (1 << (w - 1)); i++) {\n\t\t\tbn_new(tab[i]);\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\t\tbn_mod_pre(u, m);\n\n#if BN_MOD == MONTY\n\t\tbn_set_dig(r, 1);\n\t\tbn_mod_monty_conv(r, r, m);\n\t\tbn_mod_monty_conv(t, a, m);\n#else /* BN_MOD == BARRT || BN_MOD == RADIX */\n\t\tbn_set_dig(r, 1);\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(tab[0], t);\n\t\tbn_sqr(t, tab[0]);\n\t\tbn_mod(t, t, m, u);\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < 1 << (w - 1); i++) {\n\t\t\tbn_mul(tab[i], tab[i - 1], t);\n\t\t\tbn_mod(tab[i], tab[i], m, u);\n\t\t}\n\n\t\tbn_rec_slw(win, &l, b, w);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tbn_sqr(r, r);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tbn_sqr(r, r);\n\t\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t\t}\n\t\t\t\tbn_mul(r, r, tab[win[i] >> 1]);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\t\tbn_trim(r);\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(r, r, m);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, r, m);\n\t\t} else {\n\t\t\tbn_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (w - 1)); i++) {\n\t\t\tbn_free(tab[i]);\n\t\t}\n\t\tbn_free(u);\n\t\tbn_free(t);\n\t\tbn_free(r);\n\t\tRLC_FREE(win);\n\t}\n}\n\n#endif\n\n#if BN_MXP == MONTY || !defined(STRIP)\n\nvoid bn_mxp_monty(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tbn_t tab[2], u;\n\tdig_t mask;\n\tint i, j, t;\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(b)) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(tab[0]);\n\tbn_null(tab[1]);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(u);\n\t\tbn_mod_pre(u, m);\n\n\t\tbn_new(tab[0]);\n\t\tbn_new(tab[1]);\n\n#if BN_MOD == MONTY\n\t\tbn_set_dig(tab[0], 1);\n\t\tbn_mod_monty_conv(tab[0], tab[0], m);\n\t\tbn_mod_monty_conv(tab[1], a, m);\n#else\n\t\tbn_set_dig(tab[0], 1);\n\t\tbn_mod(tab[1], a, m);\n#endif\n\n\t\tbn_grow(tab[0], m->alloc);\n\t\tbn_grow(tab[1], m->alloc);\n\t\tfor (i = bn_bits(b) - 1; i >= 0; i--) {\n\t\t\tj = bn_get_bit(b, i);\n\t\t\tdv_swap_cond(tab[0]->dp, tab[1]->dp, m->alloc, j ^ 1);\n\t\t\tmask = -(j ^ 1);\n\t\t\tt = (tab[0]->used ^ tab[1]->used) & mask;\n\t\t\ttab[0]->used ^= t;\n\t\t\ttab[1]->used ^= t;\n\t\t\tt = (tab[0]->sign ^ tab[1]->sign) & mask;\n\t\t\ttab[0]->sign ^= t;\n\t\t\ttab[1]->sign ^= t;\n\t\t\tbn_mul(tab[0], tab[0], tab[1]);\n\t\t\tbn_mod(tab[0], tab[0], m, u);\n\t\t\tbn_sqr(tab[1], tab[1]);\n\t\t\tbn_mod(tab[1], tab[1], m, u);\n\t\t\tdv_swap_cond(tab[0]->dp, tab[1]->dp, m->alloc, j ^ 1);\n\t\t\tmask = -(j ^ 1);\n\t\t\tt = (tab[0]->used ^ tab[1]->used) & mask;\n\t\t\ttab[0]->used ^= t;\n\t\t\ttab[1]->used ^= t;\n\t\t\tt = (tab[0]->sign ^ tab[1]->sign) & mask;\n\t\t\ttab[0]->sign ^= t;\n\t\t\ttab[1]->sign ^= t;\n\t\t}\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(u, tab[0], m);\n#else\n\t\tbn_copy(u, tab[0]);\n#endif\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tbn_mod_inv(c, u, m);\n\t\t} else {\n\t\t\tbn_copy(c, u);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(tab[1]);\n\t\tbn_free(tab[0]);\n\t\tbn_free(u);\n\t}\n}\n\n#endif\n\nvoid bn_mxp_crt(bn_t d, const bn_t a, const bn_t b, const bn_t c,\n\t\tconst crt_t crt, int sqr) {\n\tbn_t t, u;\n\n\tbn_null(t);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(u);\n\n\t\tif (!sqr) {\n#if MULTI == OPENMP\n\t\t\tomp_set_num_threads(CORES);\n\t\t\t#pragma omp parallel copyin(core_ctx) firstprivate(crt)\n\t\t\t{\n\t\t\t\t#pragma omp sections\n\t\t\t\t{\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m1 = a^dP mod p. */\n\t\t\t\t\t\tbn_mxp(t, a, b, crt->p);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* m2 = a^dQ mod q. */\n\t\t\t\t\t\tbn_mxp(u, a, c, crt->q);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t} else {\n#if MULTI == OPENMP\n\t\t\tomp_set_num_threads(CORES);\n\t\t\t#pragma omp parallel copyin(core_ctx) firstprivate(crt)\n\t\t\t{\n\t\t\t\t#pragma omp sections\n\t\t\t\t{\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* Compute m_p = L(c^(p-1) mod p^2) * dp mod p. */\n\t\t\t\t\t\tbn_sqr(t, crt->p);\n\t\t\t\t\t\tbn_mxp(t, a, b, t);\n\t\t\t\t\t\tbn_sub_dig(t, t, 1);\n\t\t\t\t\t\tbn_div(t, t, crt->p);\n\t\t\t\t\t\tbn_mul(t, t, crt->dp);\n\t\t\t\t\t\tbn_mod(t, t, crt->p);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t\t#pragma omp section\n\t\t\t\t\t{\n#endif\n\t\t\t\t\t\t/* Compute m_q = L(c^(q-1) mod q^2) * dq mod q. */\n\t\t\t\t\t\tbn_sqr(u, crt->q);\n\t\t\t\t\t\tbn_mxp(u, a, c, u);\n\t\t\t\t\t\tbn_sub_dig(u, u, 1);\n\t\t\t\t\t\tbn_div(u, u, crt->q);\n\t\t\t\t\t\tbn_mul(u, u, crt->dq);\n\t\t\t\t\t\tbn_mod(u, u, crt->q);\n#if MULTI == OPENMP\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t}\n\t\t/* m1 = m1 - m2 mod p. */\n\t\tbn_sub(d, t, u);\n\t\twhile (bn_sign(d) == RLC_NEG) {\n\t\t\tbn_add(d, d, crt->p);\n\t\t}\n\t\t/* m1 = qInv(m1 - m2) mod p. */\n\t\tbn_mul(d, d, crt->qi);\n\t\tbn_mod(d, d, crt->p);\n\t\t/* m = m2 + m1 * q. */\n\t\tbn_mul(d, d, crt->q);\n\t\tbn_add(d, d, u);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t}\n}\n\nvoid bn_mxp_dig(bn_t c, const bn_t a, dig_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t, u, r;\n\n\tif (bn_cmp_dig(m, 1) == RLC_EQ) {\n\t\tbn_zero(c);\n\t\treturn;\n\t}\n\n\tif (b == 0) {\n\t\tbn_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tbn_null(u);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(u);\n\t\tbn_new(r);\n\n\t\tbn_mod_pre(u, m);\n\n\t\tl = util_bits_dig(b);\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_conv(t, a, m);\n#else\n\t\tbn_copy(t, a);\n#endif\n\n\t\tbn_copy(r, t);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(r, r);\n\t\t\tbn_mod(r, r, m, u);\n\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\tbn_mul(r, r, t);\n\t\t\t\tbn_mod(r, r, m, u);\n\t\t\t}\n\t\t}\n\n#if BN_MOD == MONTY\n\t\tbn_mod_monty_back(c, r, m);\n#else\n\t\tbn_copy(c, r);\n#endif\n\t\t/* Exponent is unsigned, so no need to invert if negative. */\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(u);\n\t\tbn_free(r);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime number generation and testing functions.\n *\n * Strong prime generation is based on Gordon's Algorithm, taken from Handbook\n * of Applied Cryptography.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Number of trial division tests.\n */\n#define BASIC_TESTS\t((int)(sizeof(primes)/sizeof(dig_t)))\n\n/**\n * Small prime numbers table.\n */\nstatic const dig_t primes[] = {\n\t0x0002, 0x0003, 0x0005, 0x0007, 0x000B, 0x000D, 0x0011, 0x0013,\n\t0x0017, 0x001D, 0x001F, 0x0025, 0x0029, 0x002B, 0x002F, 0x0035,\n\t0x003B, 0x003D, 0x0043, 0x0047, 0x0049, 0x004F, 0x0053, 0x0059,\n\t0x0061, 0x0065, 0x0067, 0x006B, 0x006D, 0x0071, 0x007F, 0x0083,\n\t0x0089, 0x008B, 0x0095, 0x0097, 0x009D, 0x00A3, 0x00A7, 0x00AD,\n\t0x00B3, 0x00B5, 0x00BF, 0x00C1, 0x00C5, 0x00C7, 0x00D3, 0x00DF,\n#if WSIZE > 8\n\t0x00E3, 0x00E5, 0x00E9, 0x00EF, 0x00F1, 0x00FB, 0x0101, 0x0107,\n\t0x010D, 0x010F, 0x0115, 0x0119, 0x011B, 0x0125, 0x0133, 0x0137,\n\n\t0x0139, 0x013D, 0x014B, 0x0151, 0x015B, 0x015D, 0x0161, 0x0167,\n\t0x016F, 0x0175, 0x017B, 0x017F, 0x0185, 0x018D, 0x0191, 0x0199,\n\t0x01A3, 0x01A5, 0x01AF, 0x01B1, 0x01B7, 0x01BB, 0x01C1, 0x01C9,\n\t0x01CD, 0x01CF, 0x01D3, 0x01DF, 0x01E7, 0x01EB, 0x01F3, 0x01F7,\n\t0x01FD, 0x0209, 0x020B, 0x021D, 0x0223, 0x022D, 0x0233, 0x0239,\n\t0x023B, 0x0241, 0x024B, 0x0251, 0x0257, 0x0259, 0x025F, 0x0265,\n\t0x0269, 0x026B, 0x0277, 0x0281, 0x0283, 0x0287, 0x028D, 0x0293,\n\t0x0295, 0x02A1, 0x02A5, 0x02AB, 0x02B3, 0x02BD, 0x02C5, 0x02CF,\n\n\t0x02D7, 0x02DD, 0x02E3, 0x02E7, 0x02EF, 0x02F5, 0x02F9, 0x0301,\n\t0x0305, 0x0313, 0x031D, 0x0329, 0x032B, 0x0335, 0x0337, 0x033B,\n\t0x033D, 0x0347, 0x0355, 0x0359, 0x035B, 0x035F, 0x036D, 0x0371,\n\t0x0373, 0x0377, 0x038B, 0x038F, 0x0397, 0x03A1, 0x03A9, 0x03AD,\n\t0x03B3, 0x03B9, 0x03C7, 0x03CB, 0x03D1, 0x03D7, 0x03DF, 0x03E5,\n\t0x03F1, 0x03F5, 0x03FB, 0x03FD, 0x0407, 0x0409, 0x040F, 0x0419,\n\t0x041B, 0x0425, 0x0427, 0x042D, 0x043F, 0x0443, 0x0445, 0x0449,\n\t0x044F, 0x0455, 0x045D, 0x0463, 0x0469, 0x047F, 0x0481, 0x048B,\n\n\t0x0493, 0x049D, 0x04A3, 0x04A9, 0x04B1, 0x04BD, 0x04C1, 0x04C7,\n\t0x04CD, 0x04CF, 0x04D5, 0x04E1, 0x04EB, 0x04FD, 0x04FF, 0x0503,\n\t0x0509, 0x050B, 0x0511, 0x0515, 0x0517, 0x051B, 0x0527, 0x0529,\n\t0x052F, 0x0551, 0x0557, 0x055D, 0x0565, 0x0577, 0x0581, 0x058F,\n\t0x0593, 0x0595, 0x0599, 0x059F, 0x05A7, 0x05AB, 0x05AD, 0x05B3,\n\t0x05BF, 0x05C9, 0x05CB, 0x05CF, 0x05D1, 0x05D5, 0x05DB, 0x05E7,\n\t0x05F3, 0x05FB, 0x0607, 0x060D, 0x0611, 0x0617, 0x061F, 0x0623,\n\t0x062B, 0x062F, 0x063D, 0x0641, 0x0647, 0x0649, 0x064D, 0x0653,\n\n\t0x0655, 0x065B, 0x0665, 0x0679, 0x067F, 0x0683, 0x0685, 0x069D,\n\t0x06A1, 0x06A3, 0x06AD, 0x06B9, 0x06BB, 0x06C5, 0x06CD, 0x06D3,\n\t0x06D9, 0x06DF, 0x06F1, 0x06F7, 0x06FB, 0x06FD, 0x0709, 0x0713,\n\t0x071F, 0x0727, 0x0737, 0x0745, 0x074B, 0x074F, 0x0751, 0x0755,\n\t0x0757, 0x0761, 0x076D, 0x0773, 0x0779, 0x078B, 0x078D, 0x079D,\n\t0x079F, 0x07B5, 0x07BB, 0x07C3, 0x07C9, 0x07CD, 0x07CF, 0x07D3,\n\t0x07DB, 0x07E1, 0x07EB, 0x07ED, 0x07F7, 0x0805, 0x080F, 0x0815,\n\t0x0821, 0x0823, 0x0827, 0x0829, 0x0833, 0x083F, 0x0841, 0x0851,\n\n\t0x0853, 0x0859, 0x085D, 0x085F, 0x0869, 0x0871, 0x0883, 0x089B,\n\t0x089F, 0x08A5, 0x08AD, 0x08BD, 0x08BF, 0x08C3, 0x08CB, 0x08DB,\n\t0x08DD, 0x08E1, 0x08E9, 0x08EF, 0x08F5, 0x08F9, 0x0905, 0x0907,\n\t0x091D, 0x0923, 0x0925, 0x092B, 0x092F, 0x0935, 0x0943, 0x0949,\n\t0x094D, 0x094F, 0x0955, 0x0959, 0x095F, 0x096B, 0x0971, 0x0977,\n\t0x0985, 0x0989, 0x098F, 0x099B, 0x09A3, 0x09A9, 0x09AD, 0x09C7,\n\t0x09D9, 0x09E3, 0x09EB, 0x09EF, 0x09F5, 0x09F7, 0x09FD, 0x0A13,\n\t0x0A1F, 0x0A21, 0x0A31, 0x0A39, 0x0A3D, 0x0A49, 0x0A57, 0x0A61,\n\n\t0x0A63, 0x0A67, 0x0A6F, 0x0A75, 0x0A7B, 0x0A7F, 0x0A81, 0x0A85,\n\t0x0A8B, 0x0A93, 0x0A97, 0x0A99, 0x0A9F, 0x0AA9, 0x0AAB, 0x0AB5,\n\t0x0ABD, 0x0AC1, 0x0ACF, 0x0AD9, 0x0AE5, 0x0AE7, 0x0AED, 0x0AF1,\n\t0x0AF3, 0x0B03, 0x0B11, 0x0B15, 0x0B1B, 0x0B23, 0x0B29, 0x0B2D,\n\t0x0B3F, 0x0B47, 0x0B51, 0x0B57, 0x0B5D, 0x0B65, 0x0B6F, 0x0B7B,\n\t0x0B89, 0x0B8D, 0x0B93, 0x0B99, 0x0B9B, 0x0BB7, 0x0BB9, 0x0BC3,\n\t0x0BCB, 0x0BCF, 0x0BDD, 0x0BE1, 0x0BE9, 0x0BF5, 0x0BFB, 0x0C07,\n\t0x0C0B, 0x0C11, 0x0C25, 0x0C2F, 0x0C31, 0x0C41, 0x0C5B, 0x0C5F,\n\n\t0x0C61, 0x0C6D, 0x0C73, 0x0C77, 0x0C83, 0x0C89, 0x0C91, 0x0C95,\n\t0x0C9D, 0x0CB3, 0x0CB5, 0x0CB9, 0x0CBB, 0x0CC7, 0x0CE3, 0x0CE5,\n\t0x0CEB, 0x0CF1, 0x0CF7, 0x0CFB, 0x0D01, 0x0D03, 0x0D0F, 0x0D13,\n\t0x0D1F, 0x0D21, 0x0D2B, 0x0D2D, 0x0D3D, 0x0D3F, 0x0D4F, 0x0D55,\n\t0x0D69, 0x0D79, 0x0D81, 0x0D85, 0x0D87, 0x0D8B, 0x0D8D, 0x0DA3,\n\t0x0DAB, 0x0DB7, 0x0DBD, 0x0DC7, 0x0DC9, 0x0DCD, 0x0DD3, 0x0DD5,\n\t0x0DDB, 0x0DE5, 0x0DE7, 0x0DF3, 0x0DFD, 0x0DFF, 0x0E09, 0x0E17,\n\t0x0E1D, 0x0E21, 0x0E27, 0x0E2F, 0x0E35, 0x0E3B, 0x0E4B, 0x0E57,\n#endif\n};\n\n#if BN_MOD == PMERS\n\n/**\n * Computes c = a ^ b mod m.\n *\n * @param c\t\t\t\t- the result.\n * @param a\t\t\t\t- the basis.\n * @param b\t\t\t\t- the exponent.\n * @param m\t\t\t\t- the modulus.\n */\nstatic void bn_exp(bn_t c, const bn_t a, const bn_t b, const bn_t m) {\n\tint i, l;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tl = bn_bits(b);\n\n\t\tbn_copy(t, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tbn_sqr(t, t);\n\t\t\tbn_mod(t, t, m);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tbn_mul(t, t, a);\n\t\t\t\tbn_mod(t, t, m);\n\t\t\t}\n\t\t}\n\n\t\tbn_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint bn_is_prime(const bn_t a) {\n\tint result;\n\n\tresult = 0;\n\tif (!bn_is_prime_basic(a)) {\n\t\tgoto end;\n\t}\n\n\tif (!bn_is_prime_rabin(a)) {\n\t\tgoto end;\n\t}\n\n\tresult = 1;\n  end:\n\treturn result;\n}\n\nint bn_is_prime_basic(const bn_t a) {\n\tdig_t t;\n\tint i, result;\n\n\tresult = 1;\n\n\tif (bn_cmp_dig(a, 1) == RLC_EQ) {\n\t\treturn 0;\n\t}\n\n\t/* Trial division. */\n\tfor (i = 0; i < BASIC_TESTS; i++) {\n\t\tbn_mod_dig(&t, a, primes[i]);\n\t\tif (t == 0 && bn_cmp_dig(a, primes[i]) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nint bn_is_prime_rabin(const bn_t a) {\n\tbn_t t, n1, y, r;\n\tint i, s, j, result, b, tests = 0, cmp2;\n\n\ttests = 0;\n\tresult = 1;\n\n\tbn_null(t);\n\tbn_null(n1);\n\tbn_null(y);\n\tbn_null(r);\n\n\tcmp2 = bn_cmp_dig(a, 2);\n\tif (cmp2 == RLC_LT) {\n\t\t/* Numbers 1 or smaller are not prime */\n\t\treturn 0;\n\t}\n\tif (cmp2 == RLC_EQ) {\n\t\t/* The number 2 is prime */\n\t\treturn 1;\n\t}\n\n\tif (bn_is_even(a) == 1) {\n\t\t/* Even numbers > 2 are not prime */\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\t/*\n\t\t * These values are taken from Table 4.4 inside Handbook of Applied\n\t\t * Cryptography.\n\t\t */\n\t\tb = bn_bits(a);\n\t\tif (b >= 1300) {\n\t\t\ttests = 2;\n\t\t} else if (b >= 850) {\n\t\t\ttests = 3;\n\t\t} else if (b >= 650) {\n\t\t\ttests = 4;\n\t\t} else if (b >= 550) {\n\t\t\ttests = 5;\n\t\t} else if (b >= 450) {\n\t\t\ttests = 6;\n\t\t} else if (b >= 400) {\n\t\t\ttests = 7;\n\t\t} else if (b >= 350) {\n\t\t\ttests = 8;\n\t\t} else if (b >= 300) {\n\t\t\ttests = 9;\n\t\t} else if (b >= 250) {\n\t\t\ttests = 12;\n\t\t} else if (b >= 200) {\n\t\t\ttests = 15;\n\t\t} else if (b >= 150) {\n\t\t\ttests = 18;\n\t\t} else {\n\t\t\ttests = 27;\n\t\t}\n\n\t\tbn_new(t);\n\t\tbn_new(n1);\n\t\tbn_new(y);\n\t\tbn_new(r);\n\n\t\t/* r = (n - 1)/2^s. */\n\t\tbn_sub_dig(n1, a, 1);\n\t\tbn_copy(r, n1);\n\t\ts = 0;\n\t\twhile (!bn_is_zero(r) && bn_is_even(r)) {\n\t\t\ts++;\n\t\t\tbn_rsh(r, r, 1);\n\t\t}\n\n\t\tfor (i = 0; i < tests; i++) {\n\t\t\t/* Fix the basis as the first few primes. */\n\t\t\tbn_set_dig(t, primes[i]);\n\n\t\t\t/* Ensure t <= n - 2 as per HAC */\n\t\t\tif( bn_cmp(t, n1) != RLC_LT ) {\n\t\t\t\tresult = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* y = b^r mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(y, t, r, a);\n#else\n\t\t\tbn_exp(y, t, r, a);\n#endif\n\n\t\t\tif (bn_cmp_dig(y, 1) != RLC_EQ && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\tj = 1;\n\t\t\t\twhile ((j <= (s - 1)) && bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tbn_sqr(y, y);\n\t\t\t\t\tbn_mod(y, y, a);\n\n\t\t\t\t\t/* If y == 1 then composite. */\n\t\t\t\t\tif (bn_cmp_dig(y, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++j;\n\t\t\t\t}\n\n\t\t\t\t/* If y != n1 then composite. */\n\t\t\t\tif (bn_cmp(y, n1) != RLC_EQ) {\n\t\t\t\t\tresult = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(y);\n\t\tbn_free(n1);\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\nint bn_is_prime_solov(const bn_t a) {\n\tbn_t t0, t1, t2;\n\tint i, result;\n\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\n\tresult = 1;\n\n\tRLC_TRY {\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\n\t\tfor (i = 0; i < 100; i++) {\n\t\t\t/* Generate t0, 2 <= t0, <= a - 2. */\n\t\t\tdo {\n\t\t\t\tbn_rand(t0, RLC_POS, bn_bits(a));\n\t\t\t\tbn_mod(t0, t0, a);\n\t\t\t} while (bn_cmp_dig(t0, 2) == RLC_LT);\n\t\t\t/* t2 = a - 1. */\n\t\t\tbn_copy(t2, a);\n\t\t\tbn_sub_dig(t2, t2, 1);\n\t\t\t/* t1 = (a - 1)/2. */\n\t\t\tbn_rsh(t1, t2, 1);\n\t\t\t/* t1 = t0^(a - 1)/2 mod a. */\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t1, t0, t1, a);\n#else\n\t\t\tbn_exp(t1, t0, t1, a);\n#endif\n\t\t\t/* If t1 != 1 and t1 != n - 1 return 0 */\n\t\t\tif (bn_cmp_dig(t1, 1) != RLC_EQ && bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Lend result here, but restore afterwards, for t2 = (t0|a). */\n\t\t\tresult = bn_smb_jac(t0, a);\n\t\t\tbn_set_dig(t2, (result < 0 ? -result : result));\n\t\t\tif (result < 0) {\n\t\t\t\tbn_neg(t2, t2);\n\t\t\t}\n\t\t\tresult = 1;\n\t\t\t/* If t1 != t2 (mod a) return 0. */\n\t\t\tbn_mod(t1, t1, a);\n\t\t\tbn_mod(t2, t2, a);\n\t\t\tif (bn_cmp(t1, t2) != RLC_EQ) {\n\t\t\t\tresult = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t}\n\treturn result;\n}\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\nvoid bn_gen_prime_basic(bn_t a, size_t bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\tif (bn_is_prime(a)) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\nvoid bn_gen_prime_safep(bn_t a, size_t bits) {\n\twhile (1) {\n\t\tdo {\n\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t} while (bn_bits(a) != bits);\n\t\t/* Check if (a - 1)/2 is prime. */\n\t\tbn_sub_dig(a, a, 1);\n\t\tbn_rsh(a, a, 1);\n\t\tif (bn_is_prime(a)) {\n\t\t\t/* Restore a. */\n\t\t\tbn_lsh(a, a, 1);\n\t\t\tbn_add_dig(a, a, 1);\n\t\t\tif (bn_is_prime(a)) {\n\t\t\t\t/* Should be prime now. */\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\nvoid bn_gen_prime_stron(bn_t a, size_t bits) {\n\tdig_t i, j;\n\tint found, k;\n\tbn_t r, s, t;\n\n\tbn_null(r);\n\tbn_null(s);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(r);\n\t\tbn_new(s);\n\t\tbn_new(t);\n\n\t\tdo {\n\t\t\tdo {\n\t\t\t\t/* Generate two large primes r and s. */\n\t\t\t\tbn_rand(s, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t\tbn_rand(t, RLC_POS, bits / 2 - RLC_DIG / 2);\n\t\t\t} while (!bn_is_prime(s) || !bn_is_prime(t));\n\t\t\tfound = 1;\n\t\t\tbn_rand(a, RLC_POS, bits / 2 - bn_bits(t) - 1);\n\t\t\ti = a->dp[0];\n\t\t\tbn_dbl(t, t);\n\t\t\tdo {\n\t\t\t\t/* Find first prime r = 2 * i * t + 1. */\n\t\t\t\tbn_mul_dig(r, t, i);\n\t\t\t\tbn_add_dig(r, r, 1);\n\t\t\t\ti++;\n\t\t\t\tif (bn_bits(r) > bits / 2 - 1) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(r));\n\t\t\tif (found == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Compute t = 2 * (s^(r-2) mod r) * s - 1. */\n\t\t\tbn_sub_dig(t, r, 2);\n#if BN_MOD != PMERS\n\t\t\tbn_mxp(t, s, t, r);\n#else\n\t\t\tbn_exp(t, s, t, r);\n#endif\n\n\t\t\tbn_mul(t, t, s);\n\t\t\tbn_dbl(t, t);\n\t\t\tbn_sub_dig(t, t, 1);\n\n\t\t\tk = bits - bn_bits(r);\n\t\t\tk -= bn_bits(s);\n\t\t\tbn_rand(a, RLC_POS, k);\n\t\t\tj = a->dp[0];\n\t\t\tdo {\n\t\t\t\t/* Find first prime a = t + 2 * j * r * s. */\n\t\t\t\tbn_mul(a, r, s);\n\t\t\t\tbn_mul_dig(a, a, j);\n\t\t\t\tbn_dbl(a, a);\n\t\t\t\tbn_add(a, a, t);\n\t\t\t\tj++;\n\t\t\t\tif (bn_bits(a) > bits) {\n\t\t\t\t\tfound = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!bn_is_prime(a));\n\t\t} while (found == 0 && bn_bits(a) != bits);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r);\n\t\tbn_free(s);\n\t\tbn_free(t);\n\t}\n}\n\n#endif\n\nint bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;\n    }\n\n    bn_null(t);\n\n    RLC_TRY {\n        bn_new(t);\n\t\tbn_gen_prime(a, abits);\n        do {\n            bn_rand(t, RLC_POS, bbits - bn_bits(a));\n            do {\n                bn_mul(b, a, t);\n                bn_add_dig(b, b, 1);\n                bn_add_dig(t, t, 1);\n            } while(! bn_is_prime(b));\n        } while (bn_bits(b) != bbits);\n    }\n    RLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n    }\n    RLC_FINALLY {\n        bn_free(t);\n    }\n\n    return result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision integer recoding functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Returns a maximum of eight contiguous bits from a multiple precision integer.\n *\n * @param[in] a\t\t\t\t- the multiple precision integer.\n * @param[in] from\t\t\t- the first bit position.\n * @param[in] to\t\t\t- the last bit position, inclusive.\n * @return the bits in the chosen positions.\n */\nstatic char get_bits(const bn_t a, size_t from, size_t to) {\n\tint f, t;\n\tdig_t mf, mt;\n\n\tRLC_RIP(from, f, from);\n\tRLC_RIP(to, t, to);\n\n\tif (f == t) {\n\t\t/* Same digit. */\n\n\t\tmf = RLC_MASK(from);\n\t\tif (to + 1 >= RLC_DIG) {\n\t\t\tmt = RLC_DMASK;\n\t\t} else {\n\t\t\tmt = RLC_MASK(to + 1);\n\t\t}\n\n\t\tmf = mf ^ mt;\n\n\t\treturn ((a->dp[f] & (mf)) >> from);\n\t} else {\n\t\tmf = RLC_MASK(RLC_DIG - from) << from;\n\t\tmt = RLC_MASK(to + 1);\n\n\t\treturn ((a->dp[f] & mf) >> from) |\n\t\t\t\t((a->dp[t] & mt) << (RLC_DIG - from));\n\t}\n}\n\n/**\n * Constant C for the partial reduction modulo (t^m - 1)/(t - 1).\n */\n#define MOD_C\t\t8\n\n/**\n * Constant 2^C.\n */\n#define MOD_2TC\t\t(1 << MOD_C)\n\n/**\n * Mask to calculate reduction modulo 2^C.\n */\n#define MOD_CMASK\t(MOD_2TC - 1)\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_rec_win(uint8_t *win, size_t *len, const bn_t k, size_t w) {\n\tint i, j, l;\n\n\tl = bn_bits(k);\n\n\tif (*len < RLC_CEIL(l, w)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tmemset(win, 0, *len);\n\n\tj = 0;\n\tfor (i = 0; i < l - w; i += w) {\n\t\twin[j++] = get_bits(k, i, i + w - 1);\n\t}\n\twin[j++] = get_bits(k, i, bn_bits(k) - 1);\n\t*len = j;\n}\n\nvoid bn_rec_slw(uint8_t *win, size_t *len, const bn_t k, size_t w) {\n\tint i, j, l, s;\n\n\tl = bn_bits(k);\n\n\tif (*len < l) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tmemset(win, 0, *len);\n\n\ti = l - 1;\n\tj = 0;\n\twhile (i >= 0) {\n\t\tif (!bn_get_bit(k, i)) {\n\t\t\ti--;\n\t\t\twin[j++] = 0;\n\t\t} else {\n\t\t\ts = RLC_MAX(i - w + 1, 0);\n\t\t\twhile (!bn_get_bit(k, s)) {\n\t\t\t\ts++;\n\t\t\t}\n\t\t\twin[j++] = get_bits(k, s, i);\n\t\t\ti = s - 1;\n\t\t}\n\t}\n\t*len = j;\n}\n\nvoid bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_abs(t, k);\n\n\t\tmask = RLC_MASK(w);\n\t\tl = (1 << w);\n\n\t\tmemset(naf, 0, *len);\n\n\t\ti = 0;\n\t\tif (w == 2) {\n\t\t\twhile (!bn_is_zero(t)) {\n\t\t\t\tif (!bn_is_even(t)) {\n\t\t\t\t\tbn_get_dig(&t0, t);\n\t\t\t\t\tu_i = 2 - (t0 & mask);\n\t\t\t\t\tif (u_i < 0) {\n\t\t\t\t\t\tbn_add_dig(t, t, -u_i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(t, t, u_i);\n\t\t\t\t\t}\n\t\t\t\t\t*naf = u_i;\n\t\t\t\t} else {\n\t\t\t\t\t*naf = 0;\n\t\t\t\t}\n\t\t\t\tbn_hlv(t, t);\n\t\t\t\ti++;\n\t\t\t\tnaf++;\n\t\t\t}\n\t\t} else {\n\t\t\twhile (!bn_is_zero(t)) {\n\t\t\t\tif (!bn_is_even(t)) {\n\t\t\t\t\tbn_get_dig(&t0, t);\n\t\t\t\t\tu_i = t0 & mask;\n\t\t\t\t\tif (u_i > l / 2) {\n\t\t\t\t\t\tu_i = (int8_t)(u_i - l);\n\t\t\t\t\t}\n\t\t\t\t\tif (u_i < 0) {\n\t\t\t\t\t\tbn_add_dig(t, t, -u_i);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(t, t, u_i);\n\t\t\t\t\t}\n\t\t\t\t\t*naf = u_i;\n\t\t\t\t} else {\n\t\t\t\t\t*naf = 0;\n\t\t\t\t}\n\t\t\t\tbn_hlv(t, t);\n\t\t\t\ti++;\n\t\t\t\tnaf++;\n\t\t\t}\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_rec_tnaf_get(uint8_t *t, int8_t *beta, int8_t *gama, int8_t u,\n\t\tsize_t w) {\n\tif (u == -1) {\n\t\tswitch (w) {\n\t\t\tcase 2:\n\t\t\tcase 3:\n\t\t\t\t*t = 2;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t*t = 10;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\tcase 6:\n\t\t\t\t*t = 26;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\tcase 8:\n\t\t\t\t*t = 90;\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (w) {\n\t\t\tcase 2:\n\t\t\t\t*t = 2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tcase 4:\n\t\t\tcase 5:\n\t\t\t\t*t = 6;\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\tcase 7:\n\t\t\t\t*t = 38;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\t*t = 166;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tbeta[0] = 1;\n\tgama[0] = 0;\n\n\tif (w >= 3) {\n\t\tbeta[1] = 1;\n\t\tgama[1] = (int8_t)-u;\n\t}\n\n\tif (w >= 4) {\n\t\tbeta[1] = -3;\n\t\tbeta[2] = -1;\n\t\tbeta[3] = 1;\n\t\tgama[1] = gama[2] = gama[3] = (int8_t)u;\n\t}\n\n\tif (w >= 5) {\n\t\tbeta[4] = -3;\n\t\tbeta[5] = -1;\n\t\tbeta[6] = beta[7] = 1;\n\t\tgama[4] = gama[5] = gama[6] = (int8_t)(2 * u);\n\t\tgama[7] = (int8_t)(-3 * u);\n\t}\n\n\tif (w >= 6) {\n\t\tbeta[1] = beta[8] = beta[14] = 3;\n\t\tbeta[2] = beta[9] = beta[15] = 5;\n\t\tbeta[3] = -5;\n\t\tbeta[4] = beta[10] = beta[11] = -3;\n\t\tbeta[5] = beta[12] = -1;\n\t\tbeta[6] = beta[7] = beta[13] = 1;\n\t\tgama[1] = gama[2] = 0;\n\t\tgama[3] = gama[4] = gama[5] = gama[6] = (int8_t)(2 * u);\n\t\tgama[7] = gama[8] = gama[9] = (int8_t)(-3 * u);\n\t\tgama[10] = (int8_t)(4 * u);\n\t\tgama[11] = gama[12] = gama[13] = (int8_t)(-u);\n\t\tgama[14] = gama[15] = (int8_t)(-u);\n\t}\n\n\tif (w >= 7) {\n\t\tbeta[3] = beta[22] = beta[29] = 7;\n\t\tbeta[4] = beta[16] = beta[23] = -5;\n\t\tbeta[5] = beta[10] = beta[17] = beta[24] = -3;\n\t\tbeta[6] = beta[11] = beta[18] = beta[25] = beta[30] = -1;\n\t\tbeta[7] = beta[12] = beta[14] = beta[19] = beta[26] = beta[31] = 1;\n\t\tbeta[8] = beta[13] = beta[20] = beta[27] = 3;\n\t\tbeta[9] = beta[21] = beta[28] = 5;\n\t\tbeta[15] = -7;\n\t\tgama[3] = 0;\n\t\tgama[4] = gama[5] = gama[6] = (int8_t)(-3 * u);\n\t\tgama[11] = gama[12] = gama[13] = (int8_t)(4 * u);\n\t\tgama[14] = (int8_t)(-6 * u);\n\t\tgama[15] = gama[16] = gama[17] = gama[18] = (int8_t)u;\n\t\tgama[19] = gama[20] = gama[21] = gama[22] = (int8_t)u;\n\t\tgama[23] = gama[24] = gama[25] = gama[26] = (int8_t)(-2 * u);\n\t\tgama[27] = gama[28] = gama[29] = (int8_t)(-2 * u);\n\t\tgama[30] = gama[31] = (int8_t)(5 * u);\n\t}\n\n\tif (w == 8) {\n\t\tbeta[10] = beta[17] = beta[48] = beta[55] = beta[62] = 7;\n\t\tbeta[11] = beta[18] = beta[49] = beta[56] = beta[63] = 9;\n\t\tbeta[12] = beta[22] = beta[29] = -3;\n\t\tbeta[36] = beta[43] = beta[50] = -3;\n\t\tbeta[13] = beta[23] = beta[30] = beta[37] = -1;\n\t\tbeta[44] = beta[51] = beta[58] = -1;\n\t\tbeta[14] = beta[24] = beta[31] = beta[38] = 1;\n\t\tbeta[45] = beta[52] = beta[59] = 1;\n\t\tbeta[15] = beta[32] = beta[39] = beta[46] = beta[53] = beta[60] = 3;\n\t\tbeta[16] = beta[40] = beta[47] = beta[54] = beta[61] = 5;\n\t\tbeta[19] = beta[57] = 11;\n\t\tbeta[20] = beta[27] = beta[34] = beta[41] = -7;\n\t\tbeta[21] = beta[28] = beta[35] = beta[42] = -5;\n\t\tbeta[25] = -11;\n\t\tbeta[26] = beta[33] = -9;\n\t\tgama[10] = gama[11] = (int8_t)(-3 * u);\n\t\tgama[12] = gama[13] = gama[14] = gama[15] = (int8_t)(-6 * u);\n\t\tgama[16] = gama[17] = gama[18] = gama[19] = (int8_t)(-6 * u);\n\t\tgama[20] = gama[21] = gama[22] = (int8_t)(8 * u);\n\t\tgama[23] = gama[24] = (int8_t)(8 * u);\n\t\tgama[25] = gama[26] = gama[27] = gama[28] = (int8_t)(5 * u);\n\t\tgama[29] = gama[30] = gama[31] = gama[32] = (int8_t)(5 * u);\n\t\tgama[33] = gama[34] = gama[35] = gama[36] = (int8_t)(2 * u);\n\t\tgama[37] = gama[38] = gama[39] = gama[40] = (int8_t)(2 * u);\n\t\tgama[41] = gama[42] = gama[43] = gama[44] = (int8_t)(-1 * u);\n\t\tgama[45] = gama[46] = gama[47] = gama[48] = (int8_t)(-1 * u);\n\t\tgama[49] = (int8_t)(-1 * u);\n\t\tgama[50] = gama[51] = gama[52] = gama[53] = (int8_t)(-4 * u);\n\t\tgama[54] = gama[55] = gama[56] = gama[57] = (int8_t)(-4 * u);\n\t\tgama[58] = gama[59] = gama[60] = (int8_t)(-7 * u);\n\t\tgama[61] = gama[62] = gama[63] = (int8_t)(-7 * u);\n\t}\n}\n\nvoid bn_rec_tnaf_mod(bn_t r0, bn_t r1, const bn_t k, int u, size_t m) {\n\tbn_t t, t0, t1, t2, t3;\n\n\tbn_null(t);\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(t2);\n\tbn_null(t3);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(t2);\n\t\tbn_new(t3);\n\n\t\t/* (a0, a1) = (1, 0). */\n\t\tbn_set_dig(t0, 1);\n\t\tbn_zero(t1);\n\t\t/* (b0, b1) = (0, 0). */\n\t\tbn_zero(t2);\n\t\tbn_zero(t3);\n\t\t/* (r0, r1) = (k, 0). */\n\t\tbn_abs(r0, k);\n\t\tbn_zero(r1);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!bn_is_even(r0)) {\n\t\t\t\t/* r0 = r0 - 1. */\n\t\t\t\tbn_sub_dig(r0, r0, 1);\n\t\t\t\t/* (b0, b1) = (b0 + a0, b1 + a1). */\n\t\t\t\tbn_add(t2, t2, t0);\n\t\t\t\tbn_add(t3, t3, t1);\n\t\t\t}\n\n\t\t\tbn_hlv(t, r0);\n\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\tif (u == -1) {\n\t\t\t\tbn_sub(r0, r1, t);\n\t\t\t} else {\n\t\t\t\tbn_add(r0, r1, t);\n\t\t\t}\n\t\t\t/* r1 = - r0 / 2. */\n\t\t\tbn_neg(r1, t);\n\n\t\t\tbn_dbl(t, t1);\n\t\t\t/* a1 = a0 + mu * a1. */\n\t\t\tif (u == -1) {\n\t\t\t\tbn_sub(t1, t0, t1);\n\t\t\t} else {\n\t\t\t\tbn_add(t1, t0, t1);\n\t\t\t}\n\t\t\t/* a0 = - 2 * a1. */\n\t\t\tbn_neg(t0, t);\n\t\t}\n\n\t\t/*r 0 = r0 + b0, r1 = r1 + b1. */\n\t\tbn_add(r0, r0, t2);\n\t\tbn_add(r1, r1, t3);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(t2);\n\t\tbn_free(t3);\n\t}\n}\n\nvoid bn_rec_tnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n\t\tsize_t w) {\n\tint i, l;\n\tbn_t tmp, r0, r1;\n\tint8_t beta[64], gama[64];\n\tuint8_t t_w;\n\tdig_t t0, t1, mask;\n\tint s, t, u_i;\n\n\tbn_null(r0);\n\tbn_null(r1);\n\tbn_null(tmp);\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r0);\n\t\tbn_new(r1);\n\t\tbn_new(tmp);\n\n\t\tmemset(tnaf, 0, *len);\n\n\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\tbn_abs(tmp, k);\n\t\tbn_rec_tnaf_mod(r0, r1, tmp, u, m);\n\n\t\tmask = RLC_MASK(w);\n\t\tl = 1 << w;\n\n\t\ti = 0;\n\t\twhile (!bn_is_zero(r0) || !bn_is_zero(r1)) {\n\t\t\twhile ((r0->dp[0] & 1) == 0) {\n\t\t\t\ttnaf[i++] = 0;\n\t\t\t\t/* tmp = r0. */\n\t\t\t\tbn_hlv(tmp, r0);\n\t\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\t\tif (u == -1) {\n\t\t\t\t\tbn_sub(r0, r1, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add(r0, r1, tmp);\n\t\t\t\t}\n\t\t\t\t/* r1 = - r0 / 2. */\n\t\t\t\tbn_copy(r1, tmp);\n\t\t\t\tr1->sign = tmp->sign ^ 1;\n\t\t\t}\n\t\t\t/* If r0 is odd. */\n\t\t\tif (w == 2) {\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = l - t0;\n\t\t\t\t}\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = l - t1;\n\t\t\t\t}\n\t\t\t\tu_i = 2 - ((t0 - 2 * t1) & mask);\n\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tbn_add_dig(r0, r0, -u_i);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(r0, r0, u_i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* t0 = r0 mod_s 2^w. */\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = l - t0;\n\t\t\t\t}\n\t\t\t\t/* t1 = r1 mod_s 2^w. */\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = l - t1;\n\t\t\t\t}\n\t\t\t\t/* u = r0 + r1 * (t_w) mod_s 2^w. */\n\t\t\t\tu_i = (t0 + t_w * t1) & mask;\n\n\t\t\t\tif (u_i >= (l / 2)) {\n\t\t\t\t\t/* If u < 0, s = -1 and u = -u. */\n\t\t\t\t\tu_i = (int8_t)(u_i - l);\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(-u_i >> 1);\n\t\t\t\t\tt = -beta[u_i];\n\t\t\t\t\ts = -gama[u_i];\n\t\t\t\t} else {\n\t\t\t\t\t/* If u > 0, s = 1. */\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(u_i >> 1);\n\t\t\t\t\tt = beta[u_i];\n\t\t\t\t\ts = gama[u_i];\n\t\t\t\t}\n\t\t\t\t/* r0 = r0 - s * beta_u. */\n\t\t\t\tif (t > 0) {\n\t\t\t\t\tbn_sub_dig(r0, r0, t);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r0, r0, -t);\n\t\t\t\t}\n\t\t\t\t/* r1 = r1 - s * gama_u. */\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tbn_sub_dig(r1, r1, s);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r1, r1, -s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* tmp = r0. */\n\t\t\tbn_hlv(tmp, r0);\n\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\tif (u == -1) {\n\t\t\t\tbn_sub(r0, r1, tmp);\n\t\t\t} else {\n\t\t\t\tbn_add(r0, r1, tmp);\n\t\t\t}\n\t\t\t/* r1 = - r0 / 2. */\n\t\t\tbn_copy(r1, tmp);\n\t\t\tr1->sign = tmp->sign ^ 1;\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r0);\n\t\tbn_free(r1);\n\t\tbn_free(tmp);\n\t}\n}\n\nvoid bn_rec_rtnaf(int8_t *tnaf, size_t *len, const bn_t k, int8_t u, size_t m,\n\t\tsize_t w) {\n\tint i, l;\n\tbn_t tmp, r0, r1;\n\tint8_t beta[64], gama[64];\n\tuint8_t t_w;\n\tdig_t t0, t1, mask;\n\tint s, t, u_i;\n\n\tbn_null(r0);\n\tbn_null(r1);\n\tbn_null(tmp);\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(r0);\n\t\tbn_new(r1);\n\t\tbn_new(tmp);\n\n\t\tmemset(tnaf, 0, *len);\n\n\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\tbn_abs(tmp, k);\n\t\tbn_rec_tnaf_mod(r0, r1, tmp, u, m);\n\t\tmask = RLC_MASK(w);\n\t\tl = RLC_CEIL(m + 2, (w - 1));\n\n\t\ti = 0;\n\t\twhile (i < l) {\n\t\t\t/* If r0 is odd. */\n\t\t\tif (w == 2) {\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = (1 << w) - t0;\n\t\t\t\t}\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = (1 << w) - t1;\n\t\t\t\t}\n\t\t\t\tu_i = ((t0 - 2 * t1) & mask) - 2;\n\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tbn_add_dig(r0, r0, -u_i);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(r0, r0, u_i);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/* t0 = r0 mod_s 2^w. */\n\t\t\t\tt0 = r0->dp[0];\n\t\t\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\t\t\tt0 = (1 << w) - t0;\n\t\t\t\t}\n\t\t\t\t/* t1 = r1 mod_s 2^w. */\n\t\t\t\tt1 = r1->dp[0];\n\t\t\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\t\t\tt1 = (1 << w) - t1;\n\t\t\t\t}\n\t\t\t\t/* u = r0 + r1 * (t_w) mod_s 2^w. */\n\t\t\t\tu_i = ((t0 + t_w * t1) & mask) - (1 << (w - 1));\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\t/* If u < 0, s = -1 and u = -u. */\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(-u_i >> 1);\n\t\t\t\t\tt = -beta[u_i];\n\t\t\t\t\ts = -gama[u_i];\n\t\t\t\t} else {\n\t\t\t\t\t/* If u > 0, s = 1. */\n\t\t\t\t\ttnaf[i++] = u_i;\n\t\t\t\t\tu_i = (int8_t)(u_i >> 1);\n\t\t\t\t\tt = beta[u_i];\n\t\t\t\t\ts = gama[u_i];\n\t\t\t\t}\n\t\t\t\t/* r0 = r0 - s * beta_u. */\n\t\t\t\tif (t > 0) {\n\t\t\t\t\tbn_sub_dig(r0, r0, t);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r0, r0, -t);\n\t\t\t\t}\n\t\t\t\t/* r1 = r1 - s * gama_u. */\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tbn_sub_dig(r1, r1, s);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add_dig(r1, r1, -s);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < (w - 1); j++) {\n\t\t\t\t/* tmp = r0. */\n\t\t\t\tbn_hlv(tmp, r0);\n\t\t\t\t/* r0 = r1 + mu * r0 / 2. */\n\t\t\t\tif (u == -1) {\n\t\t\t\t\tbn_sub(r0, r1, tmp);\n\t\t\t\t} else {\n\t\t\t\t\tbn_add(r0, r1, tmp);\n\t\t\t\t}\n\t\t\t\t/* r1 = - r0 / 2. */\n\t\t\t\tbn_copy(r1, tmp);\n\t\t\t\tr1->sign = tmp->sign ^ 1;\n\t\t\t}\n\t\t}\n\t\ts = r0->dp[0];\n\t\tt = r1->dp[0];\n\t\tif (bn_sign(r0) == RLC_NEG) {\n\t\t\ts = -s;\n\t\t}\n\t\tif (bn_sign(r1) == RLC_NEG) {\n\t\t\tt = -t;\n\t\t}\n\t\tif (s != 0 && t != 0) {\n\t\t\tfor (int j = 0; j < (1 << (w - 2)); j++) {\n\t\t\t\tif (beta[j] == s && gama[j] == t) {\n\t\t\t\t\ttnaf[i++] = 2 * j + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < (1 << (w - 2)); j++) {\n\t\t\t\tif (beta[j] == -s && gama[j] == -t) {\n\t\t\t\t\ttnaf[i++] = -(2 * j + 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (t != 0) {\n\t\t\t\ttnaf[i++] = t;\n\t\t\t} else {\n\t\t\t\ttnaf[i++] = s;\n\t\t\t}\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(r0);\n\t\tbn_free(r1);\n\t\tbn_free(tmp);\n\t}\n}\n\nvoid bn_rec_reg(int8_t *naf, size_t *len, const bn_t k, size_t n, size_t w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n\n\tbn_null(t);\n\n\tmask = RLC_MASK(w);\n\tl = RLC_CEIL(n, w - 1);\n\n\tif (*len <= l) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_abs(t, k);\n\n\t\tmemset(naf, 0, *len);\n\n\t\ti = 0;\n\t\tif (w == 2) {\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tu_i = (t->dp[0] & mask) - 2;\n\t\t\t\tt->dp[0] -= u_i;\n\t\t\t\tnaf[i] = u_i;\n\t\t\t\tbn_hlv(t, t);\n\t\t\t}\n\t\t\tbn_get_dig(&t0, t);\n\t\t\tnaf[i] = t0;\n\t\t} else {\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tu_i = (t->dp[0] & mask) - (1 << (w - 1));\n\t\t\t\tt->dp[0] -= u_i;\n\t\t\t\tnaf[i] = u_i;\n\t\t\t\tbn_rsh(t, t, w - 1);\n\t\t\t}\n\t\t\tbn_get_dig(&t0, t);\n\t\t\tnaf[i] = t0;\n\t\t}\n\t\t*len = l + 1;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_rec_jsf(int8_t *jsf, size_t *len, const bn_t k, const bn_t l) {\n\tbn_t n0, n1;\n\tdig_t l0, l1;\n\tint8_t u0, u1, d0, d1;\n\tint i, j, offset;\n\n\tif (*len < (2 * bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tbn_null(n0);\n\tbn_null(n1);\n\n\tRLC_TRY {\n\t\tbn_new(n0);\n\t\tbn_new(n1);\n\n\t\tbn_abs(n0, k);\n\t\tbn_abs(n1, l);\n\n\t\ti = bn_bits(k);\n\t\tj = bn_bits(l);\n\t\toffset = RLC_MAX(i, j) + 1;\n\n\t\tmemset(jsf, 0, *len);\n\n\t\ti = 0;\n\t\td0 = d1 = 0;\n\t\twhile (!(bn_is_zero(n0) && d0 == 0) || !(bn_is_zero(n1) && d1 == 0)) {\n\t\t\tbn_get_dig(&l0, n0);\n\t\t\tbn_get_dig(&l1, n1);\n\t\t\t/* For reduction modulo 8. */\n\t\t\tl0 = (l0 + d0) & RLC_MASK(3);\n\t\t\tl1 = (l1 + d1) & RLC_MASK(3);\n\n\t\t\tif (l0 % 2 == 0) {\n\t\t\t\tu0 = 0;\n\t\t\t} else {\n\t\t\t\tu0 = 2 - (l0 & RLC_MASK(2));\n\t\t\t\tif ((l0 == 3 || l0 == 5) && ((l1 & RLC_MASK(2)) == 2)) {\n\t\t\t\t\tu0 = (int8_t)-u0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tjsf[i] = u0;\n\t\t\tif (l1 % 2 == 0) {\n\t\t\t\tu1 = 0;\n\t\t\t} else {\n\t\t\t\tu1 = 2 - (l1 & RLC_MASK(2));\n\t\t\t\tif ((l1 == 3 || l1 == 5) && ((l0 & RLC_MASK(2)) == 2)) {\n\t\t\t\t\tu1 = (int8_t)-u1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tjsf[i + offset] = u1;\n\n\t\t\tif (d0 + d0 == 1 + u0) {\n\t\t\t\td0 = (int8_t)(1 - d0);\n\t\t\t}\n\t\t\tif (d1 + d1 == 1 + u1) {\n\t\t\t\td1 = (int8_t)(1 - d1);\n\t\t\t}\n\n\t\t\ti++;\n\t\t\tbn_hlv(n0, n0);\n\t\t\tbn_hlv(n1, n1);\n\t\t}\n\t\t*len = i;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n0);\n\t\tbn_free(n1);\n\t}\n\n}\n\nvoid bn_rec_glv(bn_t k0, bn_t k1, const bn_t k, const bn_t n, const bn_t *v1,\n\t\tconst bn_t *v2) {\n\tbn_t t, b1, b2;\n\tint r1, r2;\n\tsize_t bits;\n\n\tbn_null(b1);\n\tbn_null(b2);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(b1);\n\t\tbn_new(b2);\n\t\tbn_new(t);\n\n\t\tbn_abs(t, k);\n\t\tbits = bn_bits(n);\n\n\t\tbn_mul(b1, t, v1[0]);\n\t\tr1 = bn_get_bit(b1, bits);\n\t\tbn_rsh(b1, b1, bits + 1);\n\t\tbn_add_dig(b1, b1, r1);\n\n\t\tbn_mul(b2, t, v2[0]);\n\t\tr2 = bn_get_bit(b2, bits);\n\t\tbn_rsh(b2, b2, bits + 1);\n\t\tbn_add_dig(b2, b2, r2);\n\n\t\tbn_mul(k0, b1, v1[1]);\n\t\tbn_mul(k1, b2, v2[1]);\n\t\tbn_add(k0, k0, k1);\n\t\tbn_sub(k0, t, k0);\n\n\t\tbn_mul(k1, b1, v1[2]);\n\t\tbn_mul(t, b2, v2[2]);\n\t\tbn_add(k1, k1, t);\n\t\tbn_neg(k1, k1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(b1);\n\t\tbn_free(b2);\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_rec_frb(bn_t *ki, int sub, const bn_t k, const bn_t x, const bn_t n,\n\t\tint cof) {\n\tint i, l, sk, sx;\n\tbn_t u[4], v[4];\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(u[i]);\n\t\t\tbn_null(v[i]);\n\t\t\tbn_new(u[i]);\n\t\t\tbn_new(v[i]);\n\t\t}\n\n\t\tif (cof == 0) {\n\t\t\tbn_abs(v[0], k);\n\t\t\tbn_abs(u[0], x);\n\n\t\t\tsk = bn_sign(k);\n\t\t\tsx = bn_sign(x);\n\n\t\t\tfor (i = 0; i < sub; i++) {\n\t\t\t\tbn_mod(ki[i], v[0], u[0]);\n\t\t\t\tbn_div(v[0], v[0], u[0]);\n\t\t\t\tif ((sx == RLC_NEG) && (i % 2 != 0)) {\n\t\t\t\t\tbn_neg(ki[i], ki[i]);\n\t\t\t\t}\n\t\t\t\tif (sk == RLC_NEG) {\n\t\t\t\t\tbn_neg(ki[i], ki[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbn_copy(v[1], x);\n\t\t\tbn_copy(v[2], x);\n\t\t\tbn_copy(v[3], x);\n\n\t\t\t/* t = 2x^2. */\n\t\t\tbn_sqr(u[3], x);\n\t\t\tbn_dbl(u[3], u[3]);\n\n\t\t\t/* v0 = 2x^2 + 3x + 1. */\n\t\t\tbn_mul_dig(v[0], x, 3);\n\t\t\tbn_add_dig(v[0], v[0], 1);\n\t\t\tbn_add(v[0], v[0], u[3]);\n\n\t\t\t/* v3 = -(2x^2 + x). */\n\t\t\tbn_add(v[3], v[3], u[3]);\n\t\t\tbn_neg(v[3], v[3]);\n\n\t\t\t/* v1 = 12x^3 + 8x^2 + x, v2 = 6x^3 + 4x^2 + x. */\n\t\t\tbn_dbl(u[3], u[3]);\n\t\t\tbn_add(v[2], v[2], u[3]);\n\t\t\tbn_dbl(u[3], u[3]);\n\t\t\tbn_add(v[1], v[1], u[3]);\n\t\t\tbn_rsh(u[3], u[3], 2);\n\t\t\tbn_mul(u[3], u[3], x);\n\t\t\tbn_mul_dig(u[3], u[3], 3);\n\t\t\tbn_add(v[2], v[2], u[3]);\n\t\t\tbn_dbl(u[3], u[3]);\n\t\t\tbn_add(v[1], v[1], u[3]);\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(v[i], v[i], k);\n\t\t\t\tbn_div(v[i], v[i], n);\n\t\t\t\tif (bn_sign(v[i]) == RLC_NEG) {\n\t\t\t\t\tbn_add_dig(v[i], v[i], 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* u0 = x + 1, u1 = 2x + 1, u2 = 2x, u3 = x - 1. */\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[1], u[2], 1);\n\t\t\tbn_sub_dig(u[3], x, 1);\n\t\t\tbn_add_dig(u[0], x, 1);\n\t\t\tbn_copy(ki[0], k);\n\t\t\tbn_zero(ki[1]);\n\t\t\tbn_zero(ki[2]);\n\t\t\tbn_zero(ki[3]);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[0], ki[0], n);\n\t\t\t\tbn_sub(ki[0], ki[0], u[i]);\n\t\t\t\tbn_mod(ki[0], ki[0], n);\n\t\t\t}\n\n\t\t\t/* u0 = x, u1 = -x, u2 = 2x + 1, u3 = 4x + 2. */\n\t\t\tbn_copy(u[0], x);\n\t\t\tbn_neg(u[1], x);\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[2], u[2], 1);\n\t\t\tbn_dbl(u[3], u[2]);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[1], ki[1], n);\n\t\t\t\tbn_sub(ki[1], ki[1], u[i]);\n\t\t\t\tbn_mod(ki[1], ki[1], n);\n\t\t\t}\n\n\t\t\t/* u0 = x, u1 = -(x + 1), u2 = 2x + 1, u3 = -(2x - 1). */\n\t\t\tbn_copy(u[0], x);\n\t\t\tbn_add_dig(u[1], x, 1);\n\t\t\tbn_neg(u[1], u[1]);\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[2], u[2], 1);\n\t\t\tbn_sub_dig(u[3], u[2], 2);\n\t\t\tbn_neg(u[3], u[3]);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[2], ki[2], n);\n\t\t\t\tbn_sub(ki[2], ki[2], u[i]);\n\t\t\t\tbn_mod(ki[2], ki[2], n);\n\t\t\t}\n\n\t\t\t/* u0 = -2x, u1 = -x, u2 = 2x + 1, u3 = x - 1. */\n\t\t\tbn_dbl(u[0], x);\n\t\t\tbn_neg(u[0], u[0]);\n\t\t\tbn_dbl(u[2], x);\n\t\t\tbn_add_dig(u[2], u[2], 1);\n\t\t\tbn_sub_dig(u[3], x, 1);\n\t\t\tbn_neg(u[1], x);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_mul(u[i], u[i], v[i]);\n\t\t\t\tbn_mod(u[i], u[i], n);\n\t\t\t\tbn_add(ki[3], ki[3], n);\n\t\t\t\tbn_sub(ki[3], ki[3], u[i]);\n\t\t\t\tbn_mod(ki[3], ki[3], n);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tl = bn_bits(ki[i]);\n\t\t\t\tbn_sub(ki[i], n, ki[i]);\n\t\t\t\tif (bn_bits(ki[i]) > l) {\n\t\t\t\t\tbn_sub(ki[i], ki[i], n);\n\t\t\t\t\tki[i]->sign = RLC_POS;\n\t\t\t\t} else {\n\t\t\t\t\tki[i]->sign = RLC_NEG;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(u[i]);\n\t\t\tbn_free(v[i]);\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision arithmetic shift functions.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n#include \"relic_bn_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_dbl(bn_t c, const bn_t a) {\n\tdig_t carry;\n\n\tRLC_TRY {\n\t\tbn_grow(c, a->used + 1);\n\n\t\tc->used = a->used;\n\t\tcarry = bn_lsh1_low(c->dp, a->dp, c->used);\n\n\t\t/* If there is an additional carry. */\n\t\tif (carry != 0) {\n\t\t\tc->dp[c->used] = carry;\n\t\t\t(c->used)++;\n\t\t}\n\n\t\tc->sign = a->sign;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_hlv(bn_t c, const bn_t a) {\n\tbn_copy(c, a);\n\tbn_rsh1_low(c->dp, c->dp, c->used);\n\tbn_trim(c);\n}\n\nvoid bn_lsh(bn_t c, const bn_t a, unsigned int bits) {\n\tint digits;\n\tdig_t carry;\n\n\tbn_copy(c, a);\n\n\tRLC_RIP(bits, digits, bits);\n\n\tRLC_TRY {\n\t\tbn_grow(c, c->used + digits + (bits > 0));\n\n\t\tc->used = a->used + digits;\n\t\tc->sign = a->sign;\n\t\tif (digits > 0) {\n\t\t\tdv_lshd(c->dp, a->dp, c->used, digits);\n\t\t}\n\n\t\tif (bits > 0) {\n\t\t\tif (c != a) {\n\t\t\t\tcarry = bn_lshb_low(c->dp + digits, a->dp, a->used, bits);\n\t\t\t} else {\n\t\t\t\tcarry = bn_lshb_low(c->dp + digits, c->dp + digits, c->used - digits, bits);\n\t\t\t}\n\t\t\tif (carry != 0) {\n\t\t\t\tc->dp[c->used] = carry;\n\t\t\t\t(c->used)++;\n\t\t\t}\n\t\t}\n\t\tbn_trim(c);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_rsh(bn_t c, const bn_t a, unsigned int bits) {\n\tint digits = 0;\n\n\tbn_copy(c, a);\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tdv_rshd(c->dp, a->dp, a->used, digits);\n\t}\n\n\tif (a->used > digits) {\n\t\tc->used = a->used - digits;\n\t} else {\n\t\tc->used = 0;\n\t}\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);\n\t\t} else {\n\t\t\tbn_rshb_low(c->dp, c->dp, c->used, bits);\n\t\t}\n\t}\n\tbn_trim(c);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of Legendre and Jacobi symbols.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint bn_smb_leg(const bn_t a, const bn_t b) {\n\tbn_t t;\n\tint res;\n\n\tbn_null(t);\n\n\tif (bn_sign(b) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tif (bn_cmp(a, b) == RLC_EQ) {\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\t/* t = (b - 1)/2. */\n\t\tbn_sub_dig(t, b, 1);\n\t\tbn_rsh(t, t, 1);\n\t\tbn_mxp(t, a, t, b);\n\t\tres = 0;\n\t\tif (bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\tres = 1;\n\t\t}\n\t\tbn_sub(t, b, t);\n\t\tif (bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\tres = -1;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn res;\n}\n\nint bn_smb_jac(const bn_t a, const bn_t b) {\n\tbn_t t0, t1, r;\n\tint t, h, res;\n\n\tbn_null(t0);\n\tbn_null(t1);\n\tbn_null(r);\n\n\t/* Argument b must be odd. */\n\tif (bn_is_even(b) || bn_sign(b) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\t\tbn_new(r);\n\t\tt = 1;\n\n\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\tbn_add(t0, a, b);\n\t\t} else {\n\t\t\tbn_copy(t0, a);\n\t\t}\n\t\tbn_copy(t1, b);\n\n\t\twhile (1) {\n\t\t\t/* t0 = a mod b. */\n\t\t\tbn_mod(t0, t0, t1);\n\t\t\t/* If a = 0 then if n = 1 return t else return 0. */\n\t\t\tif (bn_is_zero(t0)) {\n\t\t\t\tif (bn_cmp_dig(t1, 1) == RLC_EQ) {\n\t\t\t\t\tres = 1;\n\t\t\t\t\tif (t == -1) {\n\t\t\t\t\t\tres = -1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tres = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Write t0 as 2^h * t0. */\n\t\t\th = 0;\n\t\t\twhile (bn_is_even(t0) && !bn_is_zero(t0)) {\n\t\t\t\th++;\n\t\t\t\tbn_rsh(t0, t0, 1);\n\t\t\t}\n\t\t\t/* If h != 0 (mod 2) and n != +-1 (mod 8) then t = -t. */\n\t\t\tbn_mod_2b(r, t1, 3);\n\t\t\tif ((h % 2 != 0) && (bn_cmp_dig(r, 1) != RLC_EQ) &&\n\t\t\t\t\t(bn_cmp_dig(r, 7) != RLC_EQ)) {\n\t\t\t\tt = -t;\n\t\t\t}\n\t\t\t/* If t0 != 1 (mod 4) and n != 1 (mod 4) then t = -t. */\n\t\t\tbn_mod_2b(r, t0, 2);\n\t\t\tif (bn_cmp_dig(r, 1) != RLC_EQ) {\n\t\t\t\tbn_mod_2b(r, t1, 2);\n\t\t\t\tif (bn_cmp_dig(r, 1) != RLC_EQ) {\n\t\t\t\t\tt = -t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbn_copy(r, t0);\n\t\t\tbn_copy(t0, t1);\n\t\t\tbn_copy(t1, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t\tbn_free(r);\n\t}\n\n\treturn res;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2015 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision integer square root extraction.\n *\n * @ingroup bn\n */\n\n#include \"relic_core.h\"\n#include \"relic_bn_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tsize_t bits;\n\tint cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tbits = bn_bits(a);\n\tbits += (bits % 2);\n\n\tbn_null(h);\n\tbn_null(l);\n\tbn_null(m);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_zero(l);\n\t\tbn_set_2b(h, bits >> 1);\n\t\tif (bits >= 2) {\n\t\t\tbn_set_2b(l, (bits >> 1) - 1);\n\t\t}\n\n\t\t/* Trivial binary search approach. */\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);\n\t\t\tbn_sqr(t, m);\n\t\t\tcmp = bn_cmp(t, a);\n\t\t\tbn_sub(t, h, l);\n\n\t\t\tif (cmp == RLC_GT) {\n\t\t\t\tbn_copy(h, m);\n\t\t\t} else if (cmp == RLC_LT) {\n\t\t\t\tbn_copy(l, m);\n\t\t\t}\n\t\t} while (bn_cmp_dig(t, 1) == RLC_GT && cmp != RLC_EQ);\n\n\t\tbn_copy(c, m);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(h);\n\t\tbn_free(l);\n\t\tbn_free(m);\n\t\tbn_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the multiple precision utilities.\n *\n * @ingroup bn\n */\n\n#include <inttypes.h>\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Statistical distance 1/2^\\lambda between sampling and uniform distribution.\n */\n#define RAND_DIST\t\t40\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid bn_copy(bn_t c, const bn_t a) {\n\tif (c->dp == a->dp) {\n\t\treturn;\n\t}\n\n\tbn_grow(c, a->used);\n\tdv_copy(c->dp, a->dp, a->used);\n\n\tc->used = a->used;\n\tc->sign = a->sign;\n\tbn_trim(c);\n}\n\nvoid bn_abs(bn_t c, const bn_t a) {\n\tif (c->dp != a->dp) {\n\t\tbn_copy(c, a);\n\t}\n\tc->sign = RLC_POS;\n}\n\nvoid bn_neg(bn_t c, const bn_t a) {\n\tif (c->dp != a->dp) {\n\t\tbn_copy(c, a);\n\t}\n\tif (!bn_is_zero(c)) {\n\t\tc->sign = a->sign ^ 1;\n\t}\n}\n\nint bn_sign(const bn_t a) {\n\treturn a->sign;\n}\n\nvoid bn_zero(bn_t a) {\n\ta->sign = RLC_POS;\n\ta->used = 1;\n\tdv_zero(a->dp, a->alloc);\n}\n\nint bn_is_zero(const bn_t a) {\n\tif (a->used == 0) {\n\t\treturn 1;\n\t}\n\tif ((a->used == 1) && (a->dp[0] == 0)) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint bn_is_even(const bn_t a) {\n\tif (bn_is_zero(a)) {\n\t\treturn 1;\n\t}\n\tif ((a->dp[0] & 0x01) == 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nsize_t bn_bits(const bn_t a) {\n\tint bits;\n\n\tif (bn_is_zero(a)) {\n\t\treturn 0;\n\t}\n\n\t/* Bits in lower digits. */\n\tbits = (a->used - 1) * RLC_DIG;\n\n\treturn bits + util_bits_dig(a->dp[a->used - 1]);\n}\n\nint bn_get_bit(const bn_t a, size_t bit) {\n\tint d;\n\n\tif (bit < 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tif (bit > bn_bits(a)) {\n\t\treturn 0;\n\t}\n\n\tRLC_RIP(bit, d, bit);\n\n\tif (d >= a->used) {\n\t\treturn 0;\n\t} else {\n\t\treturn (a->dp[d] >> bit) & (dig_t)1;\n\t}\n}\n\nvoid bn_set_bit(bn_t a, size_t bit, int value) {\n\tint d;\n\n\tif (bit < 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tRLC_RIP(bit, d, bit);\n\n\tbn_grow(a, d);\n\n\tif (value == 1) {\n\t\ta->dp[d] |= ((dig_t)1 << bit);\n\t\tif ((d + 1) > a->used) {\n\t\t\ta->used = d + 1;\n\t\t}\n\t} else {\n\t\ta->dp[d] &= ~((dig_t)1 << bit);\n\t\tbn_trim(a);\n\t}\n}\n\nsize_t bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}\n\nvoid bn_get_dig(dig_t *c, const bn_t a) {\n\t*c = a->dp[0];\n}\n\nvoid bn_set_dig(bn_t a, dig_t digit) {\n\tbn_zero(a);\n\ta->dp[0] = digit;\n\ta->used = 1;\n\ta->sign = RLC_POS;\n}\n\nvoid bn_set_2b(bn_t a, size_t b) {\n\tint i, d;\n\n\tif (b >= RLC_BN_SIZE * RLC_DIG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t} else {\n\t\tRLC_RIP(b, d, b);\n\n\t\tbn_grow(a, d + 1);\n\t\tfor (i = 0; i < d; i++) {\n\t\t\ta->dp[i] = 0;\n\t\t}\n\t\ta->used = d + 1;\n\t\ta->dp[d] = ((dig_t)1 << b);\n\t\ta->sign = RLC_POS;\n\t}\n}\n\nvoid bn_rand(bn_t a, int sign, size_t bits) {\n\tint digits;\n\n\tRLC_RIP(bits, digits, bits);\n\tdigits += (bits > 0 ? 1 : 0);\n\n\tbn_grow(a, digits);\n\n\trand_bytes((uint8_t *)a->dp, digits * sizeof(dig_t));\n\n\ta->used = digits;\n\ta->sign = sign;\n\tif (bits > 0) {\n\t\tdig_t mask = ((dig_t)1 << (dig_t)bits) - 1;\n\t\ta->dp[a->used - 1] &= mask;\n\t}\n\tbn_trim(a);\n}\n\nvoid bn_rand_mod(bn_t a, const bn_t b) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_copy(t, b);\n\t\tdo {\n\t\t\tbn_rand(a, bn_sign(t), bn_bits(t) + RAND_DIST);\n\t\t\tbn_mod(a, a, t);\n\t\t} while (bn_is_zero(a) || bn_cmp_abs(a, t) != RLC_LT);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid bn_print(const bn_t a) {\n\tint i;\n\n\tif (a->sign == RLC_NEG) {\n\t\tutil_print(\"-\");\n\t}\n\tif (a->used == 0) {\n\t\tutil_print(\"0\\n\");\n\t} else {\n#if WSIZE == 64\n\t\tutil_print_dig(a->dp[a->used - 1], 0);\n\t\tfor (i = a->used - 2; i >= 0; i--) {\n\t\t\tutil_print_dig(a->dp[i], 1);\n\t\t}\n#else\n\t\tutil_print_dig(a->dp[a->used - 1], 0);\n\t\tfor (i = a->used - 2; i >= 0; i--) {\n\t\t\tutil_print_dig(a->dp[i], 1);\n\t\t}\n#endif\n\t\tutil_print(\"\\n\");\n\t}\n}\n\nsize_t bn_size_str(const bn_t a, unsigned int radix) {\n\tint digits = 0;\n\tbn_t t;\n\n\tbn_null(t);\n\n\t/* Check the radix. */\n\tif (radix < 2 || radix > 64) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tif (bn_is_zero(a)) {\n\t\treturn 2;\n\t}\n\n\t/* Binary case requires the bits, a sign and the null terminator. */\n\tif (radix == 2) {\n\t\treturn bn_bits(a) + (a->sign == RLC_NEG ? 1 : 0) + 1;\n\t}\n\n\tif (a->sign == RLC_NEG) {\n\t\tdigits++;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_copy(t, a);\n\n\t\tt->sign = RLC_POS;\n\n\t\twhile (!bn_is_zero(t)) {\n\t\t\tbn_div_dig(t, t, (dig_t)radix);\n\t\t\tdigits++;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn digits + 1;\n}\n\nvoid bn_read_str(bn_t a, const char *str, size_t len, unsigned int radix) {\n\tint sign, i, j;\n\tchar c;\n\n\tbn_zero(a);\n\n\tif (radix < 2 || radix > 64) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tj = 0;\n\tif (str[0] == '-') {\n\t\tj++;\n\t\tsign = RLC_NEG;\n\t} else {\n\t\tsign = RLC_POS;\n\t}\n\n\tRLC_TRY {\n\t\tbn_grow(a, RLC_CEIL(len * util_bits_dig(radix), RLC_DIG));\n\n\t\twhile (j < len) {\n\t\t\tif (str[j] == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc = (char)((radix < 36) ? RLC_UPP(str[j]) : str[j]);\n\t\t\tfor (i = 0; i < 64; i++) {\n\t\t\t\tif (c == util_conv_char(i)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < radix) {\n\t\t\t\tbn_mul_dig(a, a, (dig_t)radix);\n\t\t\t\tbn_add_dig(a, a, (dig_t)i);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\n\t\ta->sign = sign;\n\t\tbn_trim(a);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_write_str(char *str, size_t len, const bn_t a, unsigned int radix) {\n\tbn_t t;\n\tdig_t d;\n\tint digits, l, i, j;\n\tchar c;\n\n\tbn_null(t);\n\n\tl = bn_size_str(a, radix);\n\tif (len < l) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tif (radix < 2 || radix > 64) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tif (bn_is_zero(a) == 1) {\n\t\t*str++ = '0';\n\t\t*str = '\\0';\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_copy(t, a);\n\n\t\tj = 0;\n\t\tif (t->sign == RLC_NEG) {\n\t\t\tstr[j] = '-';\n\t\t\tj++;\n\t\t\tt->sign = RLC_POS;\n\t\t}\n\n\t\tdigits = 0;\n\t\twhile (!bn_is_zero(t) && j < len) {\n\t\t\tbn_div_rem_dig(t, &d, t, (dig_t)radix);\n\t\t\tstr[j] = util_conv_char(d);\n\t\t\tdigits++;\n\t\t\tj++;\n\t\t}\n\n\t\t/* Reverse the digits of the string. */\n\t\ti = 0;\n\t\tif (str[0] == '-') {\n\t\t\ti = 1;\n\t\t}\n\n\t\tj = l - 2;\n\t\twhile (i < j) {\n\t\t\tc = str[i];\n\t\t\tstr[i] = str[j];\n\t\t\tstr[j] = c;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\n\t\tstr[l - 1] = '\\0';\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nsize_t bn_size_bin(const bn_t a) {\n\tdig_t d;\n\tint digits;\n\n\tdigits = (a->used - 1) * (RLC_DIG / 8);\n\td = a->dp[a->used - 1];\n\n\twhile (d != 0) {\n\t\td = d >> 8;\n\t\tdigits++;\n\t}\n\treturn digits;\n}\n\nvoid bn_read_bin(bn_t a, const uint8_t *bin, size_t len) {\n\tint i, j;\n\tdig_t d = (RLC_DIG / 8);\n\tint digs = (len % d == 0 ? len / d : len / d + 1);\n\n\tbn_grow(a, digs);\n\tbn_zero(a);\n\ta->used = digs;\n\n\tfor (i = 0; i < digs - 1; i++) {\n\t\td = 0;\n\t\tfor (j = (RLC_DIG / 8) - 1; j >= 0; j--) {\n\t\t\td = d << 8;\n\t\t\td |= bin[len - 1 - (i * (RLC_DIG / 8) + j)];\n\t\t}\n\t\ta->dp[i] = d;\n\t}\n\td = 0;\n\tfor (j = (RLC_DIG / 8) - 1; j >= 0; j--) {\n\t\tif ((int)(i * (RLC_DIG / 8) + j) < len) {\n\t\t\td = d << 8;\n\t\t\td |= bin[len - 1 - (i * (RLC_DIG / 8) + j)];\n\t\t}\n\t}\n\ta->dp[i] = d;\n\n\ta->sign = RLC_POS;\n\tbn_trim(a);\n}\n\nvoid bn_write_bin(uint8_t *bin, size_t len, const bn_t a) {\n\tint size, k;\n\tdig_t d;\n\n\tsize = bn_size_bin(a);\n\n\tif (len < size) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tk = 0;\n\tfor (int i = 0; i < a->used - 1; i++) {\n\t\td = a->dp[i];\n\t\tfor (int j = 0; j < (int)(RLC_DIG / 8); j++) {\n\t\t\tbin[len - 1 - k++] = d & 0xFF;\n\t\t\td = d >> 8;\n\t\t}\n\t}\n\n\td = a->dp[a->used - 1];\n\twhile (d != 0) {\n\t\tbin[len - 1 - k++] = d & 0xFF;\n\t\td = d >> 8;\n\t}\n\n\twhile (k < len) {\n\t\tbin[len - 1 - k++] = 0;\n\t}\n}\n\nsize_t bn_size_raw(const bn_t a) {\n\treturn a->used;\n}\n\nvoid bn_read_raw(bn_t a, const dig_t *raw, size_t len) {\n\tRLC_TRY {\n\t\tbn_grow(a, len);\n\t\ta->used = len;\n\t\ta->sign = RLC_POS;\n\t\tdv_copy(a->dp, raw, len);\n\t\tbn_trim(a);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n}\n\nvoid bn_write_raw(dig_t *raw, size_t len, const bn_t a) {\n\tint i, size;\n\n\tsize = a->used;\n\n\tif (len < size) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < size; i++) {\n\t\traw[i] = a->dp[i];\n\t}\n\tfor (; i < len; i++) {\n\t\traw[i] = 0;\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Boneh-Lynn-Schacham short signature protocol.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_bls_gen(bn_t d, g2_t q) {\n\tbn_t n;\n\tint result = RLC_OK;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\t\tbn_rand_mod(d, n);\n\t\tg2_mul_gen(q, d);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_bls_sig(g1_t s, const uint8_t *msg, size_t len, const bn_t d) {\n\tg1_t p;\n\tint result = RLC_OK;\n\n\tg1_null(p);\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg1_map(p, msg, len);\n\t\tg1_mul_key(s, p, d);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(p);\n\t}\n\treturn result;\n}\n\nint cp_bls_ver(const g1_t s, const uint8_t *msg, size_t len, const g2_t q) {\n\tg1_t p[2];\n\tg2_t r[2];\n\tgt_t e;\n\tint result = 0;\n\n\tg1_null(p[0]);\n\tg1_null(p[1]);\n\tg2_null(r[0]);\n\tg2_null(r[1]);\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tg1_new(p[0]);\n\t\tg1_new(p[1]);\n\t\tg2_new(r[0]);\n\t\tg2_new(r[1]);\n\t\tgt_new(e);\n\n\t\tg1_map(p[0], msg, len);\n\t\tg1_copy(p[1], s);\n\t\tg2_copy(r[0], q);\n\t\tg2_get_gen(r[1]);\n\t\tg2_neg(r[1], r[1]);\n\n\t\tpc_map_sim(e, p, r, 2);\n\t\tif (gt_is_unity(e) && g2_is_valid(q)) {\n\t\t\tresult = 1;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(p[0]);\n\t\tg1_free(p[1]);\n\t\tg2_free(r[0]);\n\t\tg2_free(r[1]);\n\t\tgt_free(e);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of context-hiding linearly homomophic signature protocol.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_cmlhs_init(g1_t h) {\n\tg1_rand(h);\n\treturn RLC_OK;\n}\n\nint cp_cmlhs_gen(bn_t x[], gt_t hs[], size_t len, uint8_t prf[], size_t plen,\n\t\tbn_t sk, g2_t pk, bn_t d, g2_t y, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t gt;\n\tbn_t n;\n\tint result = RLC_OK;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(gt);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tgt_new(gt);\n\n\t\tpc_get_ord(n);\n\t\tg1_get_gen(g1);\n\t\tg2_get_gen(g2);\n\t\tpc_map(gt, g1, g2);\n\n\t\trand_bytes(prf, plen);\n\n\t\tbn_rand_mod(d, n);\n\t\tg2_mul_gen(y, d);\n\n\t\t/* Generate elements for n tags. */\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tbn_rand_mod(x[i], n);\n\t\t\tgt_exp(hs[i], gt, x[i]);\n\t\t}\n\n\t\tif (bls) {\n\t\t\tresult = cp_bls_gen(sk, pk);\n\t\t} else {\n\t\t\tif (cp_ecdsa_gen(sk, g1) == RLC_OK) {\n\t\t\t\tfp_copy(pk->x[0], g1->x);\n\t\t\t\tfp_copy(pk->y[0], g1->y);\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tgt_free(gt);\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_cmlhs_sig(g1_t sig, g2_t z, g1_t a, g1_t c, g1_t r, g2_t s,\n\t\tconst bn_t msg, const char *data, int label, const bn_t x, const g1_t h,\n\t\tconst uint8_t prf[], size_t plen, const bn_t d, const bn_t sk,\n\t\tint bls) {\n\tbn_t k, m, n;\n\tg1_t t;\n\tuint8_t mac[RLC_MD_LEN];\n\tsize_t len, dlen = strlen(data);\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);\n\tint result = RLC_OK;\n\n\tbn_null(k);\n\tbn_null(m);\n\tbn_null(n);\n\tg1_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(m);\n\t\tbn_new(n);\n\t\tg1_new(t);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tpc_get_ord(n);\n\t\t/* Generate r and s. */\n\t\tbn_rand_mod(k, n);\n\t\tbn_rand_mod(m, n);\n\n\t\t/* Compute S = -g2^s, C = g1^s. */\n\t\tg2_mul_gen(s, m);\n\t\tg2_neg(s, s);\n\t\tg1_mul_gen(c, m);\n\t\t/* Compute R = g1^(r - ys). */\n\t\tbn_mul(m, d, m);\n\t\tbn_mod(m, m, n);\n\t\tbn_sub(m, k, m);\n\t\tbn_mod(m, m, n);\n\t\tg1_mul_gen(r, m);\n\n\t\t/* Compute A = g1^(x + r) * \\prod H_j^(y * m_j). */\n\t\tbn_add(k, x, k);\n\t\tbn_mod(k, k, n);\n\t\tg1_mul_gen(a, k);\n\t\tbn_mul(k, d, msg);\n\t\tbn_mod(k, k, n);\n\t\tg1_mul(t, h, k);\n\t\tg1_add(a, a, t);\n\t\tg1_norm(a, a);\n\t\t/* Compute z = F_K(delta), Z = g2^z, A = A^(1/z). */\n\t\tmd_hmac(mac, (const uint8_t *)data, dlen, prf, plen);\n\t\tbn_read_bin(k, mac, RLC_MD_LEN);\n\t\tbn_mod(k, k, n);\n\t\tg2_mul_gen(z, k);\n\t\tbn_mod_inv(k, k, n);\n\t\tg1_mul(a, a, k);\n\n\t\t/* Compute C = C * sum H_j^m_j. */\n\t\tbn_mod(k, msg, n);\n\t\tg1_mul(t, h, k);\n\t\tg1_add(c, c, t);\n\t\tg1_norm(c, c);\n\n\t\tlen = g2_size_bin(z, 0);\n\t\tg2_write_bin(buf, len, z, 0);\n\t\tmemcpy(buf + len, data, dlen);\n\t\tif (bls) {\n\t\t\tcp_bls_sig(sig, buf, len + dlen, sk);\n\t\t} else {\n\t\t\tcp_ecdsa_sig(m, n, buf, len + dlen, 0, sk);\n\t\t\tfp_prime_conv(sig->x, m);\n\t\t\tfp_prime_conv(sig->y, n);\n\t\t\tfp_set_dig(sig->z, 1);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(m);\n\t\tbn_free(n);\n\t\tg1_free(t);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nint cp_cmlhs_fun(g1_t a, g1_t c, const g1_t as[], const g1_t cs[],\n\t\tconst dig_t f[], size_t len) {\n\tint result = RLC_OK;\n\n\tg1_mul_sim_dig(a, as, f, len);\n\tg1_mul_sim_dig(c, cs, f, len);\n\n\treturn result;\n}\n\nint cp_cmlhs_evl(g1_t r, g2_t s, const g1_t rs[], const g2_t ss[],\n\t\tconst dig_t f[], size_t len) {\n\tint result = RLC_OK;\n\n\tg1_mul_sim_dig(r, rs, f, len);\n\tg2_mul_sim_dig(s, ss, f, len);\n\n\treturn result;\n}\n\nint cp_cmlhs_ver(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const int label[], const gt_t *hs[], const dig_t *f[],\n\t\tconst size_t flen[], const g2_t y[], const g2_t pk[], size_t slen,\n\t\tint bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tsize_t len, dlen = strlen(data);\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_PC_BYTES + dlen);\n\tint result = 1;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tgt_new(e);\n\t\tgt_new(u);\n\t\tgt_new(v);\n\t\tbn_new(k);\n\t\tbn_new(n);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tlen = g2_size_bin(z[i], 0);\n\t\t\tg2_write_bin(buf, len, z[i], 0);\n\t\t\tmemcpy(buf + len, data, dlen);\n\t\t\tif (bls) {\n\t\t\t\tresult &= cp_bls_ver(sig[i], buf, len + dlen, pk[i]);\n\t\t\t} else {\n\t\t\t\tfp_prime_back(k, sig[i]->x);\n\t\t\t\tfp_prime_back(n, sig[i]->y);\n\t\t\t\tfp_copy(g1->x, pk[i]->x[0]);\n\t\t\t\tfp_copy(g1->y, pk[i]->y[0]);\n\t\t\t\tfp_set_dig(g1->z, 1);\n\t\t\t\tresult &= cp_ecdsa_ver(k, n, buf, len + dlen, 0, g1);\n\t\t\t}\n\t\t}\n\n\t\tpc_get_ord(n);\n\t\tg1_get_gen(g1);\n\t\tg2_get_gen(g2);\n\n\t\tpc_map_sim(e, a, z, slen);\n\t\tpc_map_sim(u, c, y, slen);\n\t\tpc_map(v, r, g2);\n\t\tgt_mul(u, u, v);\n\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tfor (int j = 0; j < flen[i]; j++) {\n\t\t\t\tgt_exp_dig(v, hs[i][label[j]], f[i][j]);\n\t\t\t\tgt_mul(u, u, v);\n\t\t\t}\n\t\t}\n\t\tif (gt_cmp(e, u) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\n\t\tpc_map(e, g1, s);\n\t\tg1_set_infty(g1);\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tg1_add(g1, g1, c[i]);\n\t\t}\n\t\tg1_norm(g1, g1);\n\t\tpc_map(u, g1, g2);\n\t\tgt_mul(e, e, u);\n\n\t\tg1_mul(g1, h, msg);\n\t\tpc_map(v, g1, g2);\n\t\tif (gt_cmp(e, v) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tgt_free(e);\n\t\tgt_free(u);\n\t\tgt_free(v);\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nvoid cp_cmlhs_off(gt_t vk, const g1_t h, const int label[], const gt_t *hs[],\n\t\tconst dig_t *f[], const size_t flen[], size_t slen) {\n\tgt_t v;\n\n\tgt_null(v);\n\n\tRLC_TRY {\n\t\tgt_new(v);\n\n\t\tgt_set_unity(vk);\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tfor (int j = 0; j < flen[i]; j++) {\n\t\t\t\tgt_exp_dig(v, hs[i][label[j]], f[i][j]);\n\t\t\t\tgt_mul(vk, vk, v);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tgt_free(v);\n\t}\n}\n\nint cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tsize_t len, dlen = strlen(data);\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\tint result = 1;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tgt_new(e);\n\t\tgt_new(u);\n\t\tgt_new(v);\n\t\tbn_new(k);\n\t\tbn_new(n);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tlen = g2_size_bin(z[i], 0);\n\t\t\tg2_write_bin(buf, len, z[i], 0);\n\t\t\tmemcpy(buf + len, data, dlen);\n\t\t\tif (bls) {\n\t\t\t\tresult &= cp_bls_ver(sig[i], buf, len + dlen, pk[i]);\n\t\t\t} else {\n\t\t\t\tfp_prime_back(k, sig[i]->x);\n\t\t\t\tfp_prime_back(n, sig[i]->y);\n\t\t\t\tfp_copy(g1->x, pk[i]->x[0]);\n\t\t\t\tfp_copy(g1->y, pk[i]->y[0]);\n\t\t\t\tfp_set_dig(g1->z, 1);\n\t\t\t\tresult &= cp_ecdsa_ver(k, n, buf, len + dlen, 0, g1);\n\t\t\t}\n\t\t}\n\n\t\tpc_get_ord(n);\n\t\tg1_get_gen(g1);\n\t\tg2_get_gen(g2);\n\n\t\tpc_map_sim(e, a, z, slen);\n\t\tpc_map_sim(u, c, y, slen);\n\t\tpc_map(v, r, g2);\n\t\tgt_mul(u, u, v);\n\t\tgt_mul(u, u, vk);\n\n\t\tif (gt_cmp(e, u) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\n\t\tpc_map(e, g1, s);\n\t\tg1_set_infty(g1);\n\t\tfor (int i = 0; i < slen; i++) {\n\t\t\tg1_add(g1, g1, c[i]);\n\t\t}\n\t\tg1_norm(g1, g1);\n\t\tpc_map(u, g1, g2);\n\t\tgt_mul(e, e, u);\n\n\t\tg1_mul(g1, h, msg);\n\t\tpc_map(v, g1, g2);\n\t\tif (gt_cmp(e, v) != RLC_EQ) {\n\t\t\tresult = 0;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tgt_free(e);\n\t\tgt_free(u);\n\t\tgt_free(v);\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing-based laconic private set intersection protocols.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_pbpsi_gen(bn_t sk, g1_t ss, g2_t s[], size_t m) {\n\tint i, result = RLC_OK;\n\tbn_t q;\n\n\tbn_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(q);\n\n\t\tpc_get_ord(q);\n\t\tbn_rand_mod(sk, q);\n\t\tg1_mul_gen(ss, sk);\n\n\t\tg2_get_gen(s[0]);\n\t\tfor (i = 1; i <= m; i++) {\n\t\t\tg2_mul(s[i], s[i - 1], sk);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(q);\n\t}\n\treturn result;\n}\n\nint cp_pbpsi_ask(g2_t d[], bn_t r, const bn_t x[], const g2_t s[], size_t m) {\n\tint i, result = RLC_OK;\n\tbn_t t, q, *p = RLC_ALLOCA(bn_t, m + 1), *_x = RLC_ALLOCA(bn_t, m + 1);\n\n\tbn_null(q);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(q);\n\t\tbn_new(t);\n\t\tif (p == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\tbn_null(p[i]);\n\t\t\tbn_new(p[i]);\n\t\t\tbn_null(_x[i]);\n\t\t\tbn_new(_x[i]);\n\t\t}\n\n\t\tpc_get_ord(q);\n\t\tbn_rand_mod(r, q);\n\t\tif (m == 0) {\n\t\t\tg2_mul_gen(d[0], r);\n\t\t} else {\n\t\t\tbn_lag(p, x, q, m);\n\t\t\tg2_mul_sim_lot(d[0], s, p, m + 1);\n\t\t\tg2_mul(d[0], d[0], r);\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tbn_copy(_x[i], x[i]);\n\t\t\t}\n\t\t\tfor (i = 0; i < m; i++) {\n\t\t\t\tbn_copy(t, _x[i]);\n\t\t\t\tbn_copy(_x[i], _x[m - 1]);\n\t\t\t\tbn_lag(p, _x, q, m - 1);\n\t\t\t\tg2_mul_sim_lot(d[i + 1], s, p, m);\n\t\t\t\tg2_mul(d[i + 1], d[i + 1], r);\n\t\t\t\tbn_copy(_x[i], t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(q);\n\t\tbn_free(t);\n\t\tfor (i = 0; i <= m; i++) {\n\t\t\tbn_free(p[i]);\n\t\t\tbn_free(_x[i]);\n\t\t}\n\t\tRLC_FREE(p);\n\t\tRLC_FREE(_x);\n\t}\n\treturn result;\n}\n\nint cp_pbpsi_ans(gt_t t[], g1_t u[], const g1_t ss, const g2_t d,\n\t\tconst bn_t y[], size_t n) {\n\tint j, result = RLC_OK;\n\tbn_t q, tj;\n\tg1_t g1;\n\tg2_t g2;\n\tunsigned int *shuffle = RLC_ALLOCA(unsigned int, n);\n\n\tbn_null(q);\n\tbn_null(tj);\n\tg1_null(g1);\n\tg2_null(g2);\n\n\tRLC_TRY {\n\t\tbn_new(q);\n\t\tbn_new(tj);\n\t\tg1_new(g1);\n\t\tg2_new(g2);\n\t\tif (shuffle == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tutil_perm(shuffle, n);\n\n\t\tpc_get_ord(q);\n\t\tg2_get_gen(g2);\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tbn_rand_mod(tj, q);\n\t\t\tg1_mul_gen(g1, tj);\n\t\t\tpc_map(t[j], g1, d);\n\t\t\tg1_mul_gen(u[j], y[shuffle[j]]);\n\t\t\tg1_sub(u[j], ss, u[j]);\n\t\t\tg1_mul(u[j], u[j], tj);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(q);\n\t\tbn_free(tj);\n\t\tg1_free(g1);\n\t\tg2_free(g2);\n\t\tRLC_FREE(shuffle);\n\t}\n\treturn result;\n}\n\nint cp_pbpsi_int(bn_t z[], size_t *len, const g2_t d[], const bn_t x[],\n\t\tsize_t m, const gt_t t[], const g1_t u[], size_t n) {\n\tint j, k, result = RLC_OK;\n\tgt_t e;\n\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tgt_new(e);\n\n\t\t*len = 0;\n\t\tif (m > 0) {\n\t\t\tfor (k = 0; k < m; k++) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tpc_map(e, u[j], d[k + 1]);\n\t\t\t\t\tif (gt_cmp(e, t[j]) == RLC_EQ && !gt_is_unity(e)) {\n\t\t\t\t\t\tbn_copy(z[*len], x[k]);\n\t\t\t\t\t\t(*len)++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tgt_free(e);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the RSA cryptosystem.\n *\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Length of chosen padding scheme.\n */\n#if CP_RSAPD == PKCS1\n#define RSA_PAD_LEN\t\t(11)\n#elif CP_RSAPD == PKCS2\n#define RSA_PAD_LEN\t\t(2 * RLC_MD_LEN + 2)\n#else\n#define RSA_PAD_LEN\t\t(2)\n#endif\n\n/**\n * Identifier for encrypted messages.\n */\n#define RSA_PUB\t\t\t\t(02)\n\n/**\n * Identifier for signed messages.\n */\n#define RSA_PRV\t\t\t\t(01)\n\n/**\n * Byte used as padding unit.\n */\n#define RSA_PAD\t\t\t\t(0xFF)\n\n/**\n * Byte used as padding unit in PSS signatures.\n */\n#define RSA_PSS\t\t\t\t(0xBC)\n\n/**\n * Identifier for encryption.\n */\n#define RSA_ENC\t\t\t\t1\n\n/**\n * Identifier for decryption.\n */\n#define RSA_DEC\t\t\t\t2\n\n/**\n * Identifier for signature.\n */\n#define RSA_SIG\t\t\t\t3\n\n/**\n * Identifier for verification.\n */\n#define RSA_VER\t\t\t\t4\n\n/**\n * Identifier for second encryption step.\n */\n#define RSA_ENC_FIN\t\t\t5\n\n/**\n * Identifier for second sining step.\n */\n#define RSA_SIG_FIN\t\t\t6\n\n/**\n * Identifier for signature of a precomputed hash.\n */\n#define RSA_SIG_HASH\t\t7\n\n/**\n * Identifier for verification of a precomputed hash.\n */\n#define RSA_VER_HASH\t\t8\n\n#if CP_RSAPD == BASIC\n\n/**\n * Applies or removes simple encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_basic(bn_t m, int *p_len, int m_len, int k_len, int operation) {\n\tuint8_t pad = 0;\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tRLC_TRY {\n\t\tbn_null(t);\n\t\tbn_new(t);\n\n\t\tswitch (operation) {\n\t\t\tcase RSA_ENC:\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\t/* EB = 00 | FF | D. */\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t*p_len = 1;\n\t\t\t\t\tdo {\n\t\t\t\t\t\t(*p_len)++;\n\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t} while (pad == 0 && m_len > 0);\n\t\t\t\t\tif (pad == RSA_PAD) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS1\n\n/**\n * ASN.1 identifier of the hash function SHA-224.\n */\nstatic const uint8_t sh224_id[] = {\n\t0x30, 0x2d, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x04, 0x05, 0x00, 0x04, 0x1c\n};\n\n/**\n * ASN.1 identifier of the hash function SHA-256.\n */\nstatic const uint8_t sh256_id[] = {\n\t0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20\n};\n\n/**\n * ASN.1 identifier of the hash function SHA-384.\n */\nstatic const uint8_t sh384_id[] = {\n\t0x30, 0x41, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x02, 0x05, 0x00, 0x04, 0x30\n};\n\n/**\n * ASN.1 identifier of the hash function SHA-512.\n */\nstatic const uint8_t sh512_id[] = {\n\t0x30, 0x51, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03,\n\t0x04, 0x02, 0x03, 0x05, 0x00, 0x04, 0x40\n};\n\n/**\n * Returns a pointer to the ASN.1 identifier of a hash function according to the\n * PKCS#1 v1.5 padding standard.\n *\n * @param[in] md\t\t\t- the hash function.\n * @param[in, out] len\t\t- the length of the identifier.\n * @return The pointer to the hash function identifier.\n */\nstatic uint8_t *hash_id(int md, int *len) {\n\tswitch (md) {\n\t\tcase SH224:\n\t\t\t*len = sizeof(sh224_id);\n\t\t\treturn (uint8_t *)sh224_id;\n\t\tcase SH256:\n\t\t\t*len = sizeof(sh256_id);\n\t\t\treturn (uint8_t *)sh256_id;\n\t\tcase SH384:\n\t\t\t*len = sizeof(sh384_id);\n\t\t\treturn (uint8_t *)sh384_id;\n\t\tcase SH512:\n\t\t\t*len = sizeof(sh512_id);\n\t\t\treturn (uint8_t *)sh512_id;\n\t\tdefault:\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn NULL;\n\t}\n}\n\n/**\n * Applies or removes a PKCS#1 v1.5 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs1(bn_t m, int *p_len, size_t m_len, size_t k_len, int op) {\n\tuint8_t *id, pad = 0;\n\tsize_t len;\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (op) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* EB = 00 | 02 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PUB);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tdo {\n\t\t\t\t\t\trand_bytes(&pad, 1);\n\t\t\t\t\t} while (pad == 0);\n\t\t\t\t\tbn_add_dig(m, m, pad);\n\t\t\t\t}\n\t\t\t\t/* Make room for the zero and real message. */\n\t\t\t\tbn_lsh(m, m, (m_len + 1) * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t*p_len = m_len;\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PUB) {\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad != 0 && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\t*p_len -= (m_len - 1);\n\t\t\t\t\t\tbn_mod_2b(m, m, (k_len - *p_len) * 8);\n\t\t\t\t\t\tresult = (m_len > 0 ? RLC_OK : RLC_ERR);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len - len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\t/* Make room for the zero and hash id. */\n\t\t\t\tbn_lsh(m, m, 8 * (len + 1));\n\t\t\t\tbn_read_bin(t, id, len);\n\t\t\t\tbn_add(m, m, t);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* EB = 00 | 01 | PS | 00 | D. */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PRV);\n\n\t\t\t\t*p_len = k_len - 3 - m_len;\n\t\t\t\tfor (int i = 0; i < *p_len; i++) {\n\t\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\t\tbn_add_dig(m, m, RSA_PAD);\n\t\t\t\t}\n\t\t\t\t/* Make room for the zero and hash. */\n\t\t\t\tbn_lsh(m, m, 8 * (m_len + 1));\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PRV) {\n\t\t\t\t\t\tint counter = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\tid = hash_id(MD_MAP, &len);\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tbn_mod_2b(t, t, 8);\n\t\t\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t\t\tm_len -= len;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tint r = 0;\n\t\t\t\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t\t\tr |= pad ^ id[len - i - 1];\n\t\t\t\t\t\t\t\tbn_rsh(t, t, 8);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\t\t\t\tif (r == 0 && m_len == RLC_MD_LEN && counter >= 8) {\n\t\t\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len--;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\tif (pad == RSA_PRV) {\n\t\t\t\t\t\tint counter = 0;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\tm_len--;\n\t\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\t\t\t} while (pad == RSA_PAD && m_len > 0);\n\t\t\t\t\t\t/* Remove padding and trailing zero. */\n\t\t\t\t\t\t*p_len = k_len - m_len;\n\t\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\t\tbn_mod_2b(t, t, 8);\n\t\t\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\t\t\tbn_mod_2b(m, m, m_len * 8);\n\t\t\t\t\t\t\tif (m_len == RLC_MD_LEN && counter >= 8) {\n\t\t\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\treturn result;\n}\n\n#endif\n\n#if CP_RSAPD == PKCS2\n\n/**\n * Applies or removes a PKCS#1 v2.1 encryption padding.\n *\n * @param[out] m\t\t- the buffer to pad.\n * @param[out] p_len\t- the number of added pad bytes.\n * @param[in] m_len\t\t- the message length in bytes.\n * @param[in] k_len\t\t- the key length in bytes.\n * @param[in] operation\t- flag to indicate the operation type.\n * @return RLC_ERR if errors occurred, RLC_OK otherwise.\n */\nstatic int pad_pkcs2(bn_t m, int *p_len, size_t m_len, size_t k_len, int op) {\n\tuint8_t pad, h1[RLC_MD_LEN], h2[RLC_MD_LEN];\n\tuint8_t *mask = RLC_ALLOCA(uint8_t, k_len);\n\tint result = RLC_ERR;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tswitch (op) {\n\t\t\tcase RSA_ENC:\n\t\t\t\t/* DB = lHash | PS | 01 | D. */\n\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\t*p_len = k_len - 2 * RLC_MD_LEN - 2 - m_len;\n\t\t\t\tbn_lsh(m, m, *p_len * 8);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, 0x01);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, m_len * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_ENC_FIN:\n\t\t\t\t/* EB = 00 | maskedSeed | maskedDB. */\n\t\t\t\trand_bytes(h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t}\n\t\t\t\tbn_write_bin(mask, k_len - RLC_MD_LEN - 1, m);\n\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t}\n\t\t\t\tbn_read_bin(t, h1, RLC_MD_LEN);\n\t\t\t\tbn_lsh(t, t, 8 * (k_len - RLC_MD_LEN - 1));\n\t\t\t\tbn_add(t, t, m);\n\t\t\t\tbn_copy(m, t);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_DEC:\n\t\t\t\tm_len = k_len - 1;\n\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\tif (bn_is_zero(t)) {\n\t\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(mask, m_len, m);\n\t\t\t\t\tmd_mgf(h2, RLC_MD_LEN, mask, m_len);\n\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\t\th1[i] ^= h2[i];\n\t\t\t\t\t}\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm_len -= RLC_MD_LEN;\n\t\t\t\t\tbn_rsh(t, m, 8 * m_len);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tmd_map(h1, NULL, 0);\n\t\t\t\t\tpad = 0;\n\t\t\t\t\tfor (int i = 0; i < RLC_MD_LEN; i++) {\n\t\t\t\t\t\tpad |= h1[i] ^ h2[i];\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, 8 * m_len);\n\t\t\t\t\t*p_len = bn_size_bin(m);\n\t\t\t\t\t(*p_len)--;\n\t\t\t\t\tbn_rsh(t, m, *p_len * 8);\n\t\t\t\t\tif (pad == 0 && bn_cmp_dig(t, 1) == RLC_EQ) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_mod_2b(m, m, *p_len * 8);\n\t\t\t\t\t*p_len = k_len - *p_len;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG:\n\t\t\tcase RSA_SIG_HASH:\n\t\t\t\t/* M' = 00 00 00 00 00 00 00 00 | H(M). */\n\t\t\t\tbn_zero(m);\n\t\t\t\tbn_lsh(m, m, 64);\n\t\t\t\t/* Make room for the real message. */\n\t\t\t\tbn_lsh(m, m, RLC_MD_LEN * 8);\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_SIG_FIN:\n\t\t\t\tmemset(mask, 0, 8);\n\t\t\t\tbn_write_bin(mask + 8, RLC_MD_LEN, m);\n\t\t\t\tmd_map(h1, mask, RLC_MD_LEN + 8);\n\t\t\t\tbn_read_bin(m, h1, RLC_MD_LEN);\n\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\tt->dp[0] ^= 0x01;\n\t\t\t\t/* m_len is now the size in bits of the modulus. */\n\t\t\t\tbn_lsh(t, t, 8 * RLC_MD_LEN);\n\t\t\t\tbn_add(m, t, m);\n\t\t\t\tbn_lsh(m, m, 8);\n\t\t\t\tbn_add_dig(m, m, RSA_PSS);\n\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\tbn_set_bit(m, i, 0);\n\t\t\t\t}\n\t\t\t\tresult = RLC_OK;\n\t\t\t\tbreak;\n\t\t\tcase RSA_VER:\n\t\t\tcase RSA_VER_HASH:\n\t\t\t\tbn_mod_2b(t, m, 8);\n\t\t\t\tpad = (uint8_t)t->dp[0];\n\t\t\t\tif (pad == RSA_PSS) {\n\t\t\t\t\tint r = 1;\n\t\t\t\t\tfor (int i = m_len; i < 8 * k_len; i++) {\n\t\t\t\t\t\tif (bn_get_bit(m, i) != 0) {\n\t\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbn_rsh(m, m, 8);\n\t\t\t\t\tbn_mod_2b(t, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h2, RLC_MD_LEN, t);\n\t\t\t\t\tbn_rsh(m, m, 8 * RLC_MD_LEN);\n\t\t\t\t\tbn_write_bin(h1, RLC_MD_LEN, t);\n\t\t\t\t\tmd_mgf(mask, k_len - RLC_MD_LEN - 1, h1, RLC_MD_LEN);\n\t\t\t\t\tbn_read_bin(t, mask, k_len - RLC_MD_LEN - 1);\n\t\t\t\t\tfor (int i = 0; i < t->used; i++) {\n\t\t\t\t\t\tm->dp[i] ^= t->dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tm->dp[0] ^= 0x01;\n\t\t\t\t\tfor (int i = m_len - 1; i < 8 * k_len; i++) {\n\t\t\t\t\t\tbn_set_bit(m, i - ((RLC_MD_LEN + 1) * 8), 0);\n\t\t\t\t\t}\n\t\t\t\t\tif (r == 1 && bn_is_zero(m)) {\n\t\t\t\t\t\tresult = RLC_OK;\n\t\t\t\t\t}\n\t\t\t\t\tbn_read_bin(m, h2, RLC_MD_LEN);\n\t\t\t\t\t*p_len = k_len - RLC_MD_LEN;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\tRLC_FREE(mask);\n\n\treturn result;\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_rsa_gen(rsa_t pub, rsa_t prv, size_t bits) {\n\tbn_t t, r;\n\tint result = RLC_OK;\n\n\tif (pub == NULL || prv == NULL || bits == 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tbn_null(t);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_new(r);\n\n\t\t/* Generate different primes p and q. */\n\t\tdo {\n\t\t\tbn_gen_prime(prv->crt->p, bits / 2);\n\t\t\tbn_gen_prime(prv->crt->q, bits / 2);\n\t\t} while (bn_cmp(prv->crt->p, prv->crt->q) == RLC_EQ);\n\n\t\t/* Swap p and q so that p is smaller. */\n\t\tif (bn_cmp(prv->crt->p, prv->crt->q) != RLC_LT) {\n\t\t\tbn_copy(t, prv->crt->p);\n\t\t\tbn_copy(prv->crt->p, prv->crt->q);\n\t\t\tbn_copy(prv->crt->q, t);\n\t\t}\n\n\t\t/* n = pq. */\n\t\tbn_mul(pub->crt->n, prv->crt->p, prv->crt->q);\n\t\tbn_copy(prv->crt->n, pub->crt->n);\n\t\tbn_sub_dig(prv->crt->p, prv->crt->p, 1);\n\t\tbn_sub_dig(prv->crt->q, prv->crt->q, 1);\n\n\t\t/* phi(n) = (p - 1)(q - 1). */\n\t\tbn_mul(t, prv->crt->p, prv->crt->q);\n\n\t\tbn_set_2b(pub->e, 16);\n\t\tbn_add_dig(pub->e, pub->e, 1);\n\n#if !defined(CP_CRT)\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\tresult = RLC_OK;\n\t\t}\n#else\n\t\t/* d = e^(-1) mod phi(n). */\n\t\tbn_gcd_ext(r, prv->d, NULL, pub->e, t);\n\t\tif (bn_sign(prv->d) == RLC_NEG) {\n\t\t\tbn_add(prv->d, prv->d, t);\n\t\t}\n\n\t\tif (bn_cmp_dig(r, 1) == RLC_EQ) {\n\t\t\t/* dP = d mod (p - 1). */\n\t\t\tbn_mod(prv->crt->dp, prv->d, prv->crt->p);\n\t\t\t/* dQ = d mod (q - 1). */\n\t\t\tbn_mod(prv->crt->dq, prv->d, prv->crt->q);\n\t\t\t/* Restore p and q. */\n\t\t\tbn_add_dig(prv->crt->p, prv->crt->p, 1);\n\t\t\tbn_add_dig(prv->crt->q, prv->crt->q, 1);\n\t\t\t/* qInv = q^(-1) mod p. */\n\t\t\tbn_mod_inv(prv->crt->qi, prv->crt->q, prv->crt->p);\n\n\t\t\tresult = RLC_OK;\n\t\t}\n#endif /* CP_CRT */\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tbn_free(r);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_enc(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(pub->crt->n);\n\n\tif (pub == NULL || in_len <= 0 || in_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC) == RLC_OK) {\n#endif\n\t\t\tbn_read_bin(m, in, in_len);\n\t\t\tbn_add(eb, eb, m);\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, in_len, size, RSA_ENC_FIN);\n#endif\n\t\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\t*out_len = size;\n\t\t\t\tmemset(out, 0, *out_len);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_dec(uint8_t *out, size_t *out_len, const uint8_t *in, size_t in_len,\n\t\tconst rsa_t prv) {\n\tbn_t m, eb;\n\tint size, pad_len, result = RLC_OK;\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tsize = bn_size_bin(prv->crt->n);\n\n\tif (prv == NULL || in_len != size || in_len < RSA_PAD_LEN) {\n\t\treturn RLC_ERR;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, in, in_len);\n#if !defined(CP_CRT)\n\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else\n\t\tbn_mxp_crt(eb, eb, prv->crt->dp, prv->crt->dq, prv->crt, 0);\n#endif /* CP_CRT */\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {\n#endif\n\t\t\tsize = size - pad_len;\n\n\t\t\tif (size <= *out_len) {\n\t\t\t\tmemset(out, 0, size);\n\t\t\t\tbn_write_bin(out, size, eb);\n\t\t\t\t*out_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_sig(uint8_t *sig, size_t *sig_len, const uint8_t *msg,\n\t\tsize_t msg_len, int hash, const rsa_t prv) {\n\tbn_t m, eb;\n\tint pad_len, size, result = RLC_OK;\n\tuint8_t h[RLC_MD_LEN];\n\n\tif (prv == NULL || msg_len < 0) {\n\t\treturn RLC_ERR;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(prv->crt->n) - 1;\n\tsize = (size / 8) + (size % 8 > 0);\n\tif (pad_len > (size - 2)) {\n\t\treturn RLC_ERR;\n\t}\n#else\n\tsize = bn_size_bin(prv->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn RLC_ERR;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_zero(m);\n\t\tbn_zero(eb);\n\n\t\tint operation = (!hash ? RSA_SIG : RSA_SIG_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, pad_len, size, operation) == RLC_OK) {\n#endif\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h, msg, msg_len);\n\t\t\t\tbn_read_bin(m, h, RLC_MD_LEN);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t} else {\n\t\t\t\tbn_read_bin(m, msg, msg_len);\n\t\t\t\tbn_add(eb, eb, m);\n\t\t\t}\n\n#if CP_RSAPD == PKCS2\n\t\t\tpad_pkcs2(eb, &pad_len, bn_bits(prv->crt->n), size, RSA_SIG_FIN);\n#endif\n\n\t\t\tbn_copy(m, eb);\n\n#if !defined(CP_CRT)\n\t\t\tbn_mxp(eb, eb, prv->d, prv->crt->n);\n#else /* CP_CRT */\n\t\t\tbn_mxp_crt(eb, eb, prv->crt->dp, prv->crt->dq, prv->crt, 0);\n#endif /* CP_CRT */\n\n\t\t\tsize = bn_size_bin(prv->crt->n);\n\n\t\t\tif (size <= *sig_len) {\n\t\t\t\tmemset(sig, 0, size);\n\t\t\t\tbn_write_bin(sig, size, eb);\n\t\t\t\t*sig_len = size;\n\t\t\t} else {\n\t\t\t\tresult = RLC_ERR;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = RLC_ERR;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t}\n\n\treturn result;\n}\n\nint cp_rsa_ver(uint8_t *sig, size_t sig_len, const uint8_t *msg, size_t msg_len,\n\t\tint hash, const rsa_t pub) {\n\tbn_t m, eb;\n\tint size, pad_len, result;\n\tuint8_t *h1 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN) + 8);\n\tuint8_t *h2 = RLC_ALLOCA(uint8_t, RLC_MAX(msg_len, RLC_MD_LEN));\n\n\t/* We suppose that the signature is invalid. */\n\tresult = 0;\n\n\tif (h1 == NULL || h2 == NULL) {\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t\treturn 0;\n\t}\n\n\tif (pub == NULL || msg_len < 0) {\n\t\treturn 0;\n\t}\n\n\tpad_len = (!hash ? RLC_MD_LEN : msg_len);\n\n#if CP_RSAPD == PKCS2\n\tsize = bn_bits(pub->crt->n) - 1;\n\tif (size % 8 == 0) {\n\t\tsize = size / 8 - 1;\n\t} else {\n\t\tsize = bn_size_bin(pub->crt->n);\n\t}\n\tif (pad_len > (size - 2)) {\n\t\treturn 0;\n\t}\n#else\n\tsize = bn_size_bin(pub->crt->n);\n\tif (pad_len > (size - RSA_PAD_LEN)) {\n\t\treturn 0;\n\t}\n#endif\n\n\tbn_null(m);\n\tbn_null(eb);\n\n\tRLC_TRY {\n\t\tbn_new(m);\n\t\tbn_new(eb);\n\n\t\tbn_read_bin(eb, sig, sig_len);\n\n\t\tbn_mxp(eb, eb, pub->e, pub->crt->n);\n\n\t\tint operation = (!hash ? RSA_VER : RSA_VER_HASH);\n\n#if CP_RSAPD == BASIC\n\t\tif (pad_basic(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS1\n\t\tif (pad_pkcs1(eb, &pad_len, RLC_MD_LEN, size, operation) == RLC_OK) {\n#elif CP_RSAPD == PKCS2\n\t\tif (pad_pkcs2(eb, &pad_len, bn_bits(pub->crt->n), size,\n\t\t\t\t\t\toperation) == RLC_OK) {\n#endif\n\n#if CP_RSAPD == PKCS2\n\t\t\tmemset(h1, 0, 8);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, RLC_MD_LEN);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\tmemcpy(h1 + 8, msg, msg_len);\n\t\t\t\tmd_map(h2, h1, RLC_MD_LEN + 8);\n\n\t\t\t\tmemset(h1, 0, msg_len);\n\t\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, msg_len);\n\t\t\t}\n#else\n\t\t\tmemset(h1, 0, RLC_MAX(msg_len, RLC_MD_LEN));\n\t\t\tbn_write_bin(h1, size - pad_len, eb);\n\n\t\t\tif (!hash) {\n\t\t\t\tmd_map(h2, msg, msg_len);\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, h2, RLC_MD_LEN);\n\t\t\t} else {\n\t\t\t\t/* Everything went ok, so signature status is changed. */\n\t\t\t\tresult = util_cmp_const(h1, msg, msg_len);\n\t\t\t}\n#endif\n\t\t\tresult = (result == RLC_EQ ? 1 : 0);\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = 0;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(m);\n\t\tbn_free(eb);\n\t\tRLC_FREE(h1);\n\t\tRLC_FREE(h2);\n\t}\n\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Sakai-Ohgishi-Kasahara Identity-Based Non-Interactive\n * Authenticated Key Agreement scheme.\n *\n * @ingroup test\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_sokaka_gen(bn_t master) {\n\tbn_t n;\n\tint result = RLC_OK;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\t\tbn_rand_mod(master, n);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_sokaka_gen_prv(sokaka_t k, const char *id, bn_t master) {\n\tif (pc_map_is_type1()) {\n\t\tg1_map(k->s1, (uint8_t *)id, strlen(id));\n\t\tg1_mul(k->s1, k->s1, master);\n\t} else {\n\t\tg1_map(k->s1, (uint8_t *)id, strlen(id));\n\t\tg1_mul(k->s1, k->s1, master);\n\t\tg2_map(k->s2, (uint8_t *)id, strlen(id));\n\t\tg2_mul(k->s2, k->s2, master);\n\t}\n\treturn RLC_OK;\n}\n\nint cp_sokaka_key(uint8_t *key, size_t key_len, const char *id1,\n\t\tconst sokaka_t k, const char *id2) {\n\tsize_t size, len1 = strlen(id1), len2 = strlen(id2);\n\tint first = 0, result = RLC_OK;\n\tuint8_t *buf;\n\tg1_t p;\n\tg2_t q;\n\tgt_t e;\n\n\tg1_null(p);\n\tg2_null(q);\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg2_new(q);\n\t\tgt_new(e);\n\t\tsize = gt_size_bin(e, 0);\n\t\tbuf = RLC_ALLOCA(uint8_t, size);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tif (len1 == len2) {\n\t\t\tif (strncmp(id1, id2, len1) == 0) {\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t}\n\t\t\tfirst = (strncmp(id1, id2, len1) < 0 ? 1 : 2);\n\t\t} else {\n\t\t\tif (len1 < len2) {\n\t\t\t\tif (strncmp(id1, id2, len1) == 0) {\n\t\t\t\t\tfirst = 1;\n\t\t\t\t} else {\n\t\t\t\t\tfirst = (strncmp(id1, id2, len1) < 0 ? 1 : 2);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (strncmp(id1, id2, len2) == 0) {\n\t\t\t\t\tfirst = 2;\n\t\t\t\t} else {\n\t\t\t\t\tfirst = (strncmp(id1, id2, len2) < 0 ? 1 : 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (pc_map_is_type1()) {\n\t\t\tg2_map(q, (uint8_t *)id2, len2);\n\t\t\tpc_map(e, k->s1, q);\n\t\t} else {\n\t\t\tif (first == 1) {\n\t\t\t\tg2_map(q, (uint8_t *)id2, len2);\n\t\t\t\tpc_map(e, k->s1, q);\n\t\t\t} else {\n\t\t\t\tg1_map(p, (uint8_t *)id2, len2);\n\t\t\t\tpc_map(e, p, k->s2);\n\t\t\t}\n\t\t}\n\n\t\t/* Allocate size for storing the output. */\n\t\tgt_write_bin(buf, size, e, 0);\n\t\tmd_kdf(key, key_len, buf, size);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\tg1_free(p);\n\t\tg2_free(q);\n\t\tgt_free(e);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2018 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the vBNN-IBS idenenty-based signature algorithm.\n *\n * Paper: \"IMBAS: id-based multi-user broadcast authentication in wireless sensor networks\"\n *\n * @version $Id$\n * @ingroup cp\n */\n\n#include \"relic.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint cp_vbnn_gen(bn_t msk, ec_t mpk) {\n\tint result = RLC_OK;\n\n\t/* order of the ECC group */\n\tbn_t n;\n\n\t/* zero variables */\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\t/* initialize variables */\n\t\tbn_new(n);\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\t/* calculate master secret key */\n\t\tbn_rand_mod(msk, n);\n\n\t\t/* calculate master public key */\n\t\tec_mul_gen(mpk, msk);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t}\n\treturn result;\n}\n\nint cp_vbnn_gen_prv(bn_t sk, ec_t pk, const bn_t msk, const uint8_t *id,\n\t\tsize_t id_len) {\n\tuint8_t hash[RLC_MD_LEN];\n\tsize_t len;\n\tuint8_t *buf = NULL;\n\tbn_t n, r;\n\tint result = RLC_OK;\n\n\t/* zero variables */\n\tbn_null(n);\n\tbn_null(r);\n\n\tRLC_TRY {\n\t\t/* initialize variables */\n\t\tbn_new(n);\n\t\tbn_new(r);\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\t/* extract user key from id */\n\t\tbn_rand_mod(r, n);\n\n\t\t/* calculate R part of the user key */\n\t\tec_mul_gen(pk, r);\n\n\t\t/* calculate s part of the user key */\n\t\tlen = id_len + ec_size_bin(pk, 1);\n\t\tbuf = RLC_ALLOCA(uint8_t, len);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tmemcpy(buf, id, id_len);\n\t\tec_write_bin(buf + id_len, ec_size_bin(pk, 1), pk, 1);\n\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(sk, hash, RLC_MD_LEN);\n\t\tbn_mod(sk, sk, n);\n\t\tbn_mul(sk, sk, msk);\n\t\tbn_add(sk, sk, r);\n\t\tbn_mod(sk, sk, n);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t\tbn_free(r);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nint cp_vbnn_sig(ec_t r, bn_t z, bn_t h, const uint8_t *id, size_t id_len,\n\t\tconst uint8_t *msg, int msg_len, const bn_t sk, const ec_t pk) {\n\tsize_t len;\n\tuint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];\n\tbn_t n, y;\n\tec_t t;\n\tint result = RLC_OK;\n\n\t/* zero variables */\n\tbn_null(n);\n\tbn_null(y);\n\tec_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(y);\n\t\tec_new(t);\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\tbn_rand_mod(y, n);\n\t\tec_mul_gen(t, y);\n\n\t\t/* calculate h part of the signature */\n\t\tlen = id_len + msg_len + ec_size_bin(t, 1) + ec_size_bin(pk, 1);\n\t\tbuf = RLC_ALLOCA(uint8_t, len);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tbuf_i = buf;\n\t\tmemcpy(buf_i, id, id_len);\n\t\tbuf_i += id_len;\n\t\tmemcpy(buf_i, msg, msg_len);\n\t\tbuf_i += msg_len;\n\t\tec_write_bin(buf_i, ec_size_bin(pk, 1), pk, 1);\n\t\tbuf_i += ec_size_bin(pk, 1);\n\t\tec_write_bin(buf_i, ec_size_bin(t, 1), t, 1);\n\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(h, hash, RLC_MD_LEN);\n\t\tbn_mod(h, h, n);\n\n\t\t/* calculate z part of the signature */\n\t\tbn_mul(z, h, sk);\n\t\tbn_add(z, z, y);\n\t\tbn_mod(z, z, n);\n\n\t\t/* calculate R part of the signature */\n\t\tec_copy(r, pk);\n\t}\n\tRLC_CATCH_ANY {\n\t\tresult = RLC_ERR;\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t\tbn_free(y);\n\t\tec_free(t);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n\nint cp_vbnn_ver(const ec_t r, const bn_t z, const bn_t h, const uint8_t *id,\n\t\tsize_t id_len, const uint8_t *msg, int msg_len, const ec_t mpk) {\n\tsize_t len;\n\tuint8_t *buf = NULL, *buf_i, hash[RLC_MD_LEN];\n\tbn_t n, c, _h;\n\tec_t Z, t;\n\tint result = 0;\n\n\t/* zero variables */\n\tbn_null(n);\n\tbn_null(c);\n\tbn_null(_h);\n\tec_null(Z);\n\tec_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(c);\n\t\tbn_new(_h);\n\t\tec_new(Z);\n\t\tec_new(t);\n\n\t\t/* calculate c */\n\t\tlen = id_len + msg_len + 2 * ec_size_bin(r, 1);\n\t\tbuf = RLC_ALLOCA(uint8_t, len);\n\t\tif (buf == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\t/* get order of ECC group */\n\t\tec_curve_get_ord(n);\n\n\t\tbuf_i = buf;\n\t\tmemcpy(buf_i, id, id_len);\n\t\tbuf_i += id_len;\n\t\tec_write_bin(buf_i, ec_size_bin(r, 1), r, 1);\n\n\t\tlen = id_len + ec_size_bin(r, 1);\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(c, hash, RLC_MD_LEN);\n\t\tbn_mod(c, c, n);\n\n\t\t/* calculate Z */\n\t\tec_mul_gen(Z, z);\n\t\tec_mul(t, mpk, c);\n\t\tec_add(t, t, r);\n\t\tec_norm(t, t);\n\t\tec_mul(t, t, h);\n\t\tec_sub(Z, Z, t);\n\t\tec_norm(Z, Z);\n\n\t\t/* calculate h_verify */\n\t\tbuf_i = buf;\n\t\tmemcpy(buf_i, id, id_len);\n\t\tbuf_i += id_len;\n\t\tmemcpy(buf_i, msg, msg_len);\n\t\tbuf_i += msg_len;\n\t\tec_write_bin(buf_i, ec_size_bin(r, 1), r, 1);\n\t\tbuf_i += ec_size_bin(r, 1);\n\t\tec_write_bin(buf_i, ec_size_bin(Z, 1), Z, 1);\n\n\t\tlen = id_len + msg_len + ec_size_bin(r, 1) + ec_size_bin(Z, 1);\n\t\tmd_map(hash, buf, len);\n\t\tbn_read_bin(_h, hash, RLC_MD_LEN);\n\t\tbn_mod(_h, _h, n);\n\t\tRLC_FREE(buf);\n\n\t\tif (bn_cmp(h, _h) == RLC_EQ) {\n\t\t\tresult = 1;\n\t\t} else {\n\t\t\tresult = 0;\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* free variables */\n\t\tbn_free(n);\n\t\tbn_free(c);\n\t\tbn_free(_h);\n\t\tec_free(Z);\n\t\tec_free(t);\n\t\tRLC_FREE(buf);\n\t}\n\treturn result;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a binary elliptic curve.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"relic_eb.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid eb_map(eb_t p, const uint8_t *msg, size_t len) {\n\tbn_t k;\n\tfb_t t0, t1;\n\tint i;\n\tuint8_t digest[RLC_MD_LEN];\n\n\tbn_null(k);\n\tfb_null(t0);\n\tfb_null(t1);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tfb_new(t0);\n\t\tfb_new(t1);\n\n\t\tmd_map(digest, msg, len);\n\t\tbn_read_bin(k, digest, RLC_MIN(RLC_FB_BYTES, RLC_MD_LEN));\n\t\tfb_set_dig(p->z, 1);\n\n\t\ti = 0;\n\t\twhile (1) {\n\t\t\tbn_add_dig(k, k, 1);\n\t\t\tbn_mod_2b(k, k, RLC_FB_BITS);\n\t\t\tdv_copy(p->x, k->dp, RLC_FB_DIGS);\n\n\t\t\teb_rhs(t1, p);\n\n\t\t\t/* t0 = 1/x1^2. */\n\t\t\tfb_sqr(t0, p->x);\n\t\t\tfb_inv(t0, t0);\n\t\t\t/* t0 = t1/x1^2. */\n\t\t\tfb_mul(t0, t0, t1);\n\t\t\t/* Solve t1^2 + t1 = t0. */\n\t\t\tif (fb_trc(t0) != 0) {\n\t\t\t\ti++;\n\t\t\t} else {\n\t\t\t\tfb_slv(t1, t0);\n\t\t\t\t/* x3 = x1, y3 = t1 * x1, z3 = 1. */\n\t\t\t\tfb_mul(p->y, t1, p->x);\n\t\t\t\tfb_set_dig(p->z, 1);\n\n\t\t\t\tp->coord = BASIC;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Now, multiply by cofactor to get the correct group. */\n\t\teb_curve_get_cof(k);\n\t\tif (bn_bits(k) < RLC_DIG) {\n\t\t\teb_mul_dig(p, p, k->dp[0]);\n\t\t} else {\n\t\t\teb_mul(p, p, k);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfb_free(t0);\n\t\tfb_free(t1);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of point multiplication on binary elliptic curves.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n#include \"relic_fb_low.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EB_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EB_KBLTZ)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-TNAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_ltnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, n;\n\tint8_t tnaf[RLC_FB_BITS + 8], u;\n\teb_t t[1 << (EB_WIDTH - 2)];\n\tsize_t l;\n\n\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\tu = -1;\n\t} else {\n\t\tu = 1;\n\t}\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t, p, EB_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tl = sizeof(tnaf);\n\t\tbn_rec_tnaf(tnaf, &l, k, u, RLC_FB_BITS, EB_WIDTH);\n\n\t\tn = tnaf[l - 1];\n\t\tif (n > 0) {\n\t\t\teb_copy(r, t[n / 2]);\n\t\t} else {\n\t\t\teb_neg(r, t[-n / 2]);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\teb_frb(r, r);\n\n\t\t\tn = tnaf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\n#if defined(EB_PLAIN)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the\n * left-to-right w-NAF method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_lnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, n;\n\tint8_t naf[RLC_FB_BITS + 1];\n\teb_t t[1 << (EB_WIDTH - 2)];\n\tsize_t l;\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t\tfb_set_dig(t[i]->z, 1);\n\t\t\tt[i]->coord = BASIC;\n\t\t}\n\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t, p, EB_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EB_WIDTH);\n\n\t\tn = naf[l - 1];\n\t\tif (n > 0) {\n\t\t\teb_copy(r, t[n / 2]);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\teb_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_PLAIN */\n#endif /* EB_MUL == LWNAF */\n\n#if EB_MUL == RWNAF || !defined(STRIP)\n\n#if defined(EB_KBLTZ)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-TNAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_rtnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, n;\n\tint8_t tnaf[RLC_FB_BITS + 8], u;\n\teb_t t[1 << (EB_WIDTH - 2)];\n\tsize_t l;\n\n\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\tu = -1;\n\t} else {\n\t\tu = 1;\n\t}\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t}\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tl = sizeof(tnaf);\n\t\tbn_rec_tnaf(tnaf, &l, k, u, RLC_FB_BITS, EB_WIDTH);\n\n\t\teb_copy(r, p);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tn = tnaf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(t[n / 2], t[n / 2], r);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(t[-n / 2], t[-n / 2], r);\n\t\t\t}\n\n\t\t\t/* We can avoid a function call here. */\n\t\t\tfb_sqr(r->x, r->x);\n\t\t\tfb_sqr(r->y, r->y);\n\t\t}\n\n\t\teb_copy(r, t[0]);\n\n#if defined(EB_MIXED) && defined(STRIP) && (EB_WIDTH > 2)\n\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (EB_WIDTH - 2)) - 1);\n#endif\n\n#if EB_WIDTH == 3\n\t\teb_frb(t[0], t[1]);\n\t\tif (u == 1) {\n\t\t\teb_sub(t[1], t[1], t[0]);\n\t\t} else {\n\t\t\teb_add(t[1], t[1], t[0]);\n\t\t}\n#endif\n\n#if EB_WIDTH == 4\n\t\teb_frb(t[0], t[3]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\n\t\tif (u == 1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[3], t[0], t[3]);\n\n\t\teb_frb(t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[1], t[0], t[1]);\n\n\t\teb_frb(t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n#endif\n\n#if EB_WIDTH == 5\n\t\teb_frb(t[0], t[3]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == 1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[3], t[0], t[3]);\n\n\t\teb_frb(t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[1], t[0], t[1]);\n\n\t\teb_frb(t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n\n\t\teb_frb(t[0], t[4]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[4]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == 1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[4], t[0], t[4]);\n\n\t\teb_frb(t[0], t[5]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[5]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_sub(t[5], t[0], t[5]);\n\n\t\teb_frb(t[0], t[6]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[6]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_add(t[6], t[0], t[6]);\n\n\t\teb_frb(t[0], t[7]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[7], t[0], t[7]);\n#endif\n\n#if EB_WIDTH == 6\n\t\teb_frb(t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[0], t[0], t[1]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[1], t[0], t[1]);\n\n\t\teb_frb(t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[0], t[0], t[2]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n\n\t\teb_frb(t[0], t[3]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[3]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[3], t[0], t[3]);\n\n\t\teb_frb(t[0], t[4]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[4]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[4], t[0], t[4]);\n\n\t\teb_frb(t[0], t[5]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[5]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[5], t[0], t[5]);\n\n\t\teb_frb(t[0], t[6]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[6]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[6], t[0], t[6]);\n\n\t\teb_frb(t[0], t[7]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[7], t[0], t[7]);\n\n\t\teb_frb(t[0], t[8]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[8], t[0], t[8]);\n\n\t\teb_frb(t[0], t[9]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[0], t[0], t[9]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_sub(t[0], t[0], t[9]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[9]);\n\t\teb_neg(t[9], t[0]);\n\n\t\teb_frb(t[0], t[10]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[10]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[10], t[0], t[10]);\n\n\t\teb_frb(t[0], t[11]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[11], t[0], t[11]);\n\n\t\teb_frb(t[0], t[12]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_add(t[12], t[0], t[12]);\n\n\t\teb_frb(t[0], t[13]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[13]);\n\t\teb_neg(t[13], t[0]);\n\n\t\teb_frb(t[0], t[14]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_neg(t[0], t[0]);\n\t\teb_add(t[14], t[0], t[14]);\n\n\t\teb_frb(t[0], t[15]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\teb_frb(t[0], t[0]);\n\t\tif (u == -1) {\n\t\t\teb_neg(t[0], t[0]);\n\t\t}\n\t\teb_sub(t[15], t[0], t[15]);\n#endif\n\n#if defined(EB_MIXED) && defined(STRIP) && (EB_WIDTH > 2)\n\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (EB_WIDTH - 2)) - 1);\n#endif\n\n\t\t/* Add accumulators */\n\t\tfor (i = 1; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\tif (r->coord == BASIC) {\n\t\t\t\teb_add(r, t[i], r);\n\t\t\t} else {\n\t\t\t\teb_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_KBLTZ */\n\n#if defined(EB_PLAIN)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the\n * right-to-left w-NAF method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void eb_mul_rnaf_imp(eb_t r, const eb_t p, const bn_t k) {\n\tint i, n;\n\tint8_t naf[RLC_FB_BITS + 1];\n\teb_t t[1 << (EB_WIDTH - 2)];\n\tsize_t l;\n\n\tRLC_TRY {\n\t\t/* Prepare the accumulator table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t}\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EB_WIDTH);\n\n\t\teb_copy(r, p);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\teb_add(t[n / 2], t[n / 2], r);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\teb_sub(t[-n / 2], t[-n / 2], r);\n\t\t\t}\n\n\t\t\teb_dbl(r, r);\n\t\t}\n\n\t\teb_copy(r, t[0]);\n\n#if EB_WIDTH >= 3\n\t\t/* Compute 3 * T[1]. */\n\t\teb_dbl(t[0], t[1]);\n\t\teb_add(t[1], t[0], t[1]);\n#endif\n#if EB_WIDTH >= 4\n\t\t/* Compute 5 * T[2]. */\n\t\teb_dbl(t[0], t[2]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[2], t[0], t[2]);\n\n\t\t/* Compute 7 * T[3]. */\n\t\teb_dbl(t[0], t[3]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_sub(t[3], t[0], t[3]);\n#endif\n#if EB_WIDTH >= 5\n\t\t/* Compute 9 * T[4]. */\n\t\teb_dbl(t[0], t[4]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[4], t[0], t[4]);\n\n\t\t/* Compute 11 * T[5]. */\n\t\teb_dbl(t[0], t[5]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[0], t[0], t[5]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[5], t[0], t[5]);\n\n\t\t/* Compute 13 * T[6]. */\n\t\teb_dbl(t[0], t[6]);\n\t\teb_add(t[0], t[0], t[6]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_add(t[6], t[0], t[6]);\n\n\t\t/* Compute 15 * T[7]. */\n\t\teb_dbl(t[0], t[7]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_sub(t[7], t[0], t[7]);\n#endif\n#if EB_WIDTH == 6\n\t\tfor (i = 8; i < 15; i++) {\n\t\t\teb_mul_dig(t[i], t[i], 2 * i + 1);\n\t\t}\n\t\teb_dbl(t[0], t[15]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_dbl(t[0], t[0]);\n\t\teb_sub(t[15], t[0], t[15]);\n#endif\n\n\t\t/* Add accumulators */\n\t\tfor (i = 1; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\tif (r->coord == BASIC) {\n\t\t\t\teb_add(r, t[i], r);\n\t\t\t} else {\n\t\t\t\teb_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the accumulator table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_PLAIN */\n#endif /* EB_MUL == RWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EB_MUL == BASIC || !defined(STRIP)\n\nvoid eb_mul_basic(eb_t r, const eb_t p, const bn_t k) {\n\teb_t t;\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\teb_null(t);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\n\t\teb_copy(t, p);\n\t\tfor (int i = bn_bits(k) - 2; i >= 0; i--) {\n\t\t\teb_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\teb_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\teb_norm(r, t);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n\n#endif\n\n#if EB_MUL == LODAH || !defined(STRIP)\n\nvoid eb_mul_lodah(eb_t r, const eb_t p, const bn_t k) {\n\tdv_t x1, z1, x2, z2, r1, r2, r3, r4, r5;\n\tconst dig_t *b;\n\tbn_t t, n;\n\tsize_t bits;\n\n\tif (bn_is_zero(k)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(t);\n\tdv_null(x1);\n\tdv_null(z1);\n\tdv_null(x2);\n\tdv_null(z2);\n\tdv_null(r1);\n\tdv_null(r2);\n\tdv_null(r3);\n\tdv_null(r4);\n\tdv_null(r5);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(t);\n\t\tdv_new(x1);\n\t\tdv_new(z1);\n\t\tdv_new(x2);\n\t\tdv_new(z2);\n\t\tdv_new(r1);\n\t\tdv_new(r2);\n\t\tdv_new(r3);\n\t\tdv_new(r4);\n\t\tdv_new(r5);\n\n\t\tfb_sqr(z2, p->x);\n\t\tfb_sqr(x2, z2);\n\t\tdv_zero(r5, 2 * RLC_FB_DIGS);\n\n\t\tb = eb_curve_get_b();\n\t\teb_curve_get_ord(n);\n\t\tbits = bn_bits(n);\n\n\t\tbn_abs(t, k);\n\t\tbn_add(t, t, n);\n\t\tbn_add(n, t, n);\n\t\tdv_swap_cond(t->dp, n->dp, RLC_MAX(t->used, n->used),\n\t\t\tbn_get_bit(t, bits) == 0);\n\t\tt->used = RLC_SEL(t->used, n->used, bn_get_bit(t, bits) == 0);\n\n\t\tswitch (eb_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfb_add_dig(x2, x2, (dig_t)1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfb_add_dig(x2, x2, b[0]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfb_addn_low(x2, x2, b);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Blind both points independently. */\n\t\tfb_rand(z1);\n\t\tfb_mul(x1, z1, p->x);\n\t\tfb_rand(r1);\n\t\tfb_mul(z2, z2, r1);\n\t\tfb_mul(x2, x2, r1);\n\n\t\tfor (int i = bits - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(t, i);\n\t\t\tfb_mul(r1, x1, z2);\n\t\t\tfb_mul(r2, x2, z1);\n\t\t\tfb_add(r3, r1, r2);\n\t\t\tfb_muln_low(r4, r1, r2);\n\t\t\tdv_swap_cond(x1, x2, RLC_FB_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(z1, z2, RLC_FB_DIGS, j ^ 1);\n\t\t\tfb_sqr(z1, r3);\n\t\t\tfb_muln_low(r1, z1, p->x);\n\t\t\tfb_addd_low(x1, r1, r4, 2 * RLC_FB_DIGS);\n\t\t\tfb_rdcn_low(x1, x1);\n\t\t\tfb_sqr(r1, z2);\n\t\t\tfb_sqr(r2, x2);\n\t\t\tfb_mul(z2, r1, r2);\n\t\t\tswitch (eb_curve_opt_b()) {\n\t\t\t\tcase RLC_ZERO:\n\t\t\t\t\tfb_sqr(x2, r2);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RLC_ONE:\n\t\t\t\t\tfb_add(r1, r1, r2);\n\t\t\t\t\tfb_sqr(x2, r1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RLC_TINY:\n\t\t\t\t\tfb_sqr(r1, r1);\n\t\t\t\t\tfb_sqrl_low(x2, r2);\n\t\t\t\t\tfb_mul1_low(r5, r1, b[0]);\n\t\t\t\t\tfb_addd_low(x2, x2, r5, RLC_FB_DIGS + 1);\n\t\t\t\t\tfb_rdcn_low(x2, x2);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfb_sqr(r1, r1);\n\t\t\t\t\tfb_sqrl_low(x2, r2);\n\t\t\t\t\tfb_muln_low(r5, r1, b);\n\t\t\t\t\tfb_addd_low(x2, x2, r5, 2 * RLC_FB_DIGS);\n\t\t\t\t\tfb_rdcn_low(x2, x2);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdv_swap_cond(x1, x2, RLC_FB_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(z1, z2, RLC_FB_DIGS, j ^ 1);\n\t\t}\n\n\t\tif (fb_is_zero(z1)) {\n\t\t\t/* The point q is at infinity. */\n\t\t\teb_set_infty(r);\n\t\t} else {\n\t\t\tif (fb_is_zero(z2)) {\n\t\t\t\tfb_copy(r->x, p->x);\n\t\t\t\tfb_add(r->y, p->x, p->y);\n\t\t\t\tfb_set_dig(r->z, 1);\n\t\t\t} else {\n\t\t\t\t/* r3 = z1 * z2. */\n\t\t\t\tfb_mul(r3, z1, z2);\n\t\t\t\t/* z1 = (x1 + x * z1). */\n\t\t\t\tfb_mul(z1, z1, p->x);\n\t\t\t\tfb_add(z1, z1, x1);\n\t\t\t\t/* z2 = x * z2. */\n\t\t\t\tfb_mul(z2, z2, p->x);\n\t\t\t\t/* x1 = x1 * z2. */\n\t\t\t\tfb_mul(x1, x1, z2);\n\t\t\t\t/* z2 = (x2 + x * z2)(x1 + x * z1). */\n\t\t\t\tfb_add(z2, z2, x2);\n\t\t\t\tfb_mul(z2, z2, z1);\n\n\t\t\t\t/* r4 = (x^2 + y) * z1 * z2 + (x2 + x * z2)(x1 + x * z1). */\n\t\t\t\tfb_sqr(r4, p->x);\n\t\t\t\tfb_add(r4, r4, p->y);\n\t\t\t\tfb_mul(r4, r4, r3);\n\t\t\t\tfb_add(r4, r4, z2);\n\n\t\t\t\t/* r3 = (z1 * z2 * x)^{-1}. */\n\t\t\t\tfb_mul(r3, r3, p->x);\n\t\t\t\tfb_inv(r3, r3);\n\t\t\t\t/* r4 = (x^2 + y) * z1 * z2 + (x2 + x * z2)(x1 + x * z1) * r3. */\n\t\t\t\tfb_mul(r4, r4, r3);\n\t\t\t\t/* x2 = x1 * x * z2 * (z1 * z2 * x)^{-1} = x1/z1. */\n\t\t\t\tfb_mul(x2, x1, r3);\n\t\t\t\t/* z2 = x + x1/z1. */\n\t\t\t\tfb_add(z2, x2, p->x);\n\n\t\t\t\t/* z2 = z2 * r4 + y. */\n\t\t\t\tfb_mul(z2, z2, r4);\n\t\t\t\tfb_add(z2, z2, p->y);\n\n\t\t\t\tfb_copy(r->x, x2);\n\t\t\t\tfb_copy(r->y, z2);\n\t\t\t\tfb_set_dig(r->z, 1);\n\t\t\t}\n\t\t}\n\n\t\tr->coord = BASIC;\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(t);\n\t\tdv_free(x1);\n\t\tdv_free(z1);\n\t\tdv_free(x2);\n\t\tdv_free(z2);\n\t\tdv_free(r1);\n\t\tdv_free(r2);\n\t\tdv_free(r3);\n\t\tdv_free(r4);\n\t\tdv_free(r5);\n\t}\n}\n\n#endif /* EB_MUL == LODAH */\n\n#if EB_MUL == LWNAF || !defined(STRIP)\n\nvoid eb_mul_lwnaf(eb_t r, const eb_t p, const bn_t k) {\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\teb_mul_ltnaf_imp(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EB_PLAIN)\n\teb_mul_lnaf_imp(r, p, k);\n#endif\n}\n\n#endif\n\n#if EB_MUL == RWNAF || !defined(STRIP)\n\nvoid eb_mul_rwnaf(eb_t r, const eb_t p, const bn_t k) {\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\teb_mul_rtnaf_imp(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EB_PLAIN)\n#if defined(EB_MIXED) && defined(STRIP)\n\t/* It is impossible to run a right-to-left algorithm using ordinary curves\n\t * and only mixed additions. */\n\tRLC_THROW(ERR_NO_CONFIG);\n#else\n\teb_mul_rnaf_imp(r, p, k);\n#endif\n#endif\n}\n\n#endif\n\n#if EB_MUL == HALVE || !defined(STRIP)\n\nvoid eb_mul_halve(eb_t r, const eb_t p, const bn_t k) {\n\tint i, j, trc, cof;\n\tint8_t naf[RLC_FB_BITS + 1], *_k;\n\teb_t q, s, t[1 << (EB_WIDTH - 2)];\n\tbn_t n, m;\n\tfb_t u, v, w, z;\n\tsize_t l;\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(m);\n\tbn_null(n);\n\teb_null(q);\n\teb_null(s);\n\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t[i]);\n\t}\n\tfb_null(u);\n\tfb_null(v);\n\tfb_null(w);\n\tfb_null(z);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(m);\n\t\teb_new(q);\n\t\teb_new(s);\n\t\tfb_new(u);\n\t\tfb_new(v);\n\t\tfb_new(w);\n\t\tfb_new(z);\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_new(t[i]);\n\t\t\teb_set_infty(t[i]);\n\t\t}\n\n\t\t/* Convert k to alternate representation k' = (2^{t-1}k mod n). */\n\t\teb_curve_get_ord(n);\n\t\tbn_lsh(m, k, bn_bits(n) - 1);\n\t\tbn_mod(m, m, n);\n\n\t\t/* Compute the w-NAF representation of k'. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, m, EB_WIDTH);\n\n\t\tif (naf[bn_bits(n)] == 1) {\n\t\t\teb_dbl(t[0], p);\n\t\t}\n\t\tl = bn_bits(n);\n\t\t_k = naf + l - 1;\n\n\t\teb_copy(q, p);\n\t\teb_curve_get_cof(n);\n\n\t\t/* Test if curve has a cofactor bigger than 2. */\n\t\tif (bn_cmp_dig(n, 2) == RLC_GT) {\n\t\t\tcof = 1;\n\t\t} else {\n\t\t\tcof = 0;\n\t\t}\n\n\t\ttrc = fb_trc(eb_curve_get_a());\n\n\t\tif (cof) {\n\t\t\t/* Curves with cofactor > 2, u = sqrt(a), v = Solve(u). */\n\t\t\tfb_srt(u, eb_curve_get_a());\n\t\t\tfb_slv(v, u);\n\n\t\t\tbn_rand(n, RLC_POS, l);\n\n\t\t\tfor (i = l - 1; i >= 0; i--, _k--) {\n\t\t\t\tj = *_k;\n\t\t\t\tif (j > 0) {\n\t\t\t\t\teb_norm(s, q);\n\t\t\t\t\teb_add(t[j / 2], t[j / 2], s);\n\t\t\t\t}\n\t\t\t\tif (j < 0) {\n\t\t\t\t\teb_norm(s, q);\n\t\t\t\t\teb_sub(t[-j / 2], t[-j / 2], s);\n\t\t\t\t}\n\n\t\t\t\t/* T = 1/2(Q). */\n\t\t\t\teb_hlv(s, q);\n\n\t\t\t\t/* If Tr(x_T) != Tr(a). */\n\t\t\t\tif (fb_trc(s->x) != 0) {\n\t\t\t\t\t/* z = l_t, w = sqrt(l_Q), l_T = l_T + sqrt(l_Q) + v. */\n\t\t\t\t\tfb_copy(z, s->y);\n\t\t\t\t\tfb_srt(w, q->y);\n\t\t\t\t\tfb_add(s->y, s->y, w);\n\t\t\t\t\tfb_add(s->y, s->y, v);\n\t\t\t\t\t/* z = (z + x_Q + v + sqrt(a)). */\n\t\t\t\t\tfb_add(z, z, q->x);\n\t\t\t\t\tfb_add(z, z, v);\n\t\t\t\t\tfb_add(z, z, u);\n\t\t\t\t\t/* w = sqrt(w + x_Q + l_Q + sqrt(a)). */\n\t\t\t\t\tfb_add(w, w, q->x);\n\t\t\t\t\tfb_add(w, w, q->y);\n\t\t\t\t\tfb_add(w, w, u);\n\t\t\t\t\t/* x_T = sqrt(w * z), . */\n\t\t\t\t\tfb_mul(w, w, z);\n\t\t\t\t\tfb_srt(s->x, w);\n\t\t\t\t\tfb_set_dig(s->z, 1);\n\t\t\t\t\ts->coord = HALVE;\n\t\t\t\t}\n\t\t\t\teb_copy(q, s);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = l - 1; i >= 0; i--, _k--) {\n\t\t\t\tj = *_k;\n\t\t\t\tif (j > 0) {\n\t\t\t\t\teb_norm(q, q);\n\t\t\t\t\teb_add(t[j / 2], t[j / 2], q);\n\t\t\t\t}\n\t\t\t\tif (j < 0) {\n\t\t\t\t\teb_norm(q, q);\n\t\t\t\t\teb_sub(t[-j / 2], t[-j / 2], q);\n\t\t\t\t}\n\t\t\t\teb_hlv(q, q);\n\t\t\t}\n\t\t}\n\n#if EB_WIDTH == 2\n\t\teb_norm(r, t[0]);\n#else\n\t\t/* Compute Q_i = Q_i + Q_{i+2} for i from 2^{w-1}-3 to 1. */\n\t\tfor (i = (1 << (EB_WIDTH - 1)) - 3; i >= 1; i -= 2) {\n\t\t\teb_add(t[i / 2], t[i / 2], t[(i + 2) / 2]);\n\t\t}\n\t\t/* Compute R = Q_1 + 2 * sum_{i != 1}Q_i. */\n\t\teb_copy(r, t[1]);\n\t\tfor (i = 2; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_add(r, r, t[i]);\n\t\t}\n\t\teb_dbl(r, r);\n\t\teb_add(r, r, t[0]);\n\t\teb_norm(r, r);\n#endif\n\n\t\t/* We may need to fix an error of a 2-torsion point if the curve has a\n\t\t * 4-cofactor. */\n\t\tif (cof) {\n\t\t\teb_hlv(s, r);\n\t\t\tif (fb_trc(s->x) != trc) {\n\t\t\t\tfb_zero(s->x);\n\t\t\t\tfb_srt(s->y, eb_curve_get_b());\n\t\t\t\tfb_set_dig(s->z, 1);\n\t\t\t\teb_add(r, r, s);\n\t\t\t\teb_norm(r, r);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t\tbn_free(n);\n\t\tbn_free(m);\n\t\teb_free(q);\n\t\teb_free(s);\n\t\tfb_free(u);\n\t\tfb_free(v);\n\t\tfb_free(w);\n\t\tfb_free(z);\n\t}\n}\n\n#endif\n\nvoid eb_mul_gen(eb_t r, const bn_t k) {\n#ifdef EB_PRECO\n\teb_mul_fix(r, eb_curve_get_tab(), k);\n#else\n\teb_t g;\n\n\teb_null(g);\n\n\tRLC_TRY {\n\t\teb_new(g);\n\t\teb_curve_get_gen(g);\n\t\teb_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(g);\n\t}\n#endif\n}\n\nvoid eb_mul_dig(eb_t r, const eb_t p, dig_t k) {\n\teb_t t;\n\n\tif (k == 0 || eb_is_infty(p)) {\n\t\teb_set_infty(r);\n\t\treturn;\n\t}\n\n\teb_null(t);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\n\t\teb_copy(t, p);\n\t\tfor (int i = util_bits_dig(k) - 2; i >= 0; i--) {\n\t\t\teb_dbl(t, t);\n\t\t\tif (k & ((dig_t)1 << i)) {\n\t\t\t\teb_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\teb_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on binary elliptic\n * curves.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EB_SIM == INTER || !defined(STRIP)\n\n#if defined(EB_KBLTZ)\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to a precomputed table.\n */\nstatic void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, n0, n1, w, g;\n\tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}\n\n\tRLC_TRY {\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\tu = -1;\n\t\t} else {\n\t\t\tu = 1;\n\t\t}\n\n\t\tg = (t == NULL ? 0 : 1);\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\t\teb_new(t0[i]);\n\t\t\t\teb_set_infty(t0[i]);\n\t\t\t\tfb_set_bit(t0[i]->z, 0, 1);\n\t\t\t\tt0[i]->coord = BASIC;\n\t\t\t}\n\t\t\teb_tab(t0, p, EB_WIDTH);\n\t\t\tt = (const eb_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_new(t1[i]);\n\t\t\teb_set_infty(t1[i]);\n\t\t\tfb_set_bit(t1[i]->z, 0, 1);\n\t\t\tt1[i]->coord = BASIC;\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t1, q, EB_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (g) {\n\t\t\tw = EB_DEPTH;\n\t\t} else {\n\t\t\tw = EB_WIDTH;\n\t\t}\n\n\t\tl0 = l1 = RLC_FB_BITS + 8;\n\t\tbn_rec_tnaf(tnaf0, &l0, k, u, RLC_FB_BITS, w);\n\t\tbn_rec_tnaf(tnaf1, &l1, m, u, RLC_FB_BITS, EB_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\t_k = tnaf0 + l - 1;\n\t\t_m = tnaf1 + l - 1;\n\t\tfor (i =  l0; i < l; i++) {\n\t\t\ttnaf0[i] = 0;\n\t\t}\n\t\tfor (i =  l1; i < l; i++) {\n\t\t\ttnaf1[i] = 0;\n\t\t}\n\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\ttnaf0[i] = -tnaf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\ttnaf1[i] = -tnaf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = tnaf0 + l - 1;\n\t\t_m = tnaf1 + l - 1;\n\t\teb_set_infty(r);\n\t\tfor (i =  l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\teb_frb(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\teb_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\teb_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\teb_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\teb_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\t\teb_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_KBLTZ */\n\n#if defined(EB_PLAIN)\n\n/**\n * Multiplies and adds two binary elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to a precomputed table.\n */\nstatic void eb_mul_sim_plain(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, n0, n1, w, g;\n\tint8_t naf0[RLC_FB_BITS + 1], naf1[RLC_FB_BITS + 1], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}\n\n\tRLC_TRY {\n\t\tg = (t == NULL ? 0 : 1);\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\t\teb_new(t0[i]);\n\t\t\t}\n\t\t\teb_tab(t0, p, EB_WIDTH);\n\t\t\tt = (const eb_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\t\teb_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\teb_tab(t1, q, EB_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tif (g) {\n\t\t\tw = EB_DEPTH;\n\t\t} else {\n\t\t\tw = EB_WIDTH;\n\t\t}\n\n\t\tl0 = l1 = RLC_FB_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EB_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\teb_set_infty(r);\n\t\tfor (i =  l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\teb_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\teb_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\teb_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\teb_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\teb_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\teb_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!g) {\n\t\t\tfor (i =  0; i < 1 << (EB_WIDTH - 2); i++) {\n\t\t\t\teb_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i =  0; i < 1 << (EB_WIDTH - 2); i++) {\n\t\t\teb_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EB_PLAIN */\n\n#endif /* EB_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EB_SIM == BASIC || !defined(STRIP)\n\nvoid eb_mul_sim_basic(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\teb_t t;\n\n\teb_null(t);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\t\teb_mul(t, q, m);\n\t\teb_mul(r, p, k);\n\t\teb_add(t, t, r);\n\t\teb_norm(r, t);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n\n#endif\n\n#if EB_SIM == TRICK || !defined(STRIP)\n\nvoid eb_mul_sim_trick(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\teb_t t0[1 << (EB_WIDTH / 2)], t1[1 << (EB_WIDTH / 2)], t[1 << EB_WIDTH];\n\tsize_t l0, l1, w = EB_WIDTH / 2;\n\tuint8_t w0[RLC_FB_BITS], w1[RLC_FB_BITS];\n\tbn_t n;\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\teb_curve_get_ord(n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\teb_null(t0[i]);\n\t\t\teb_null(t1[i]);\n\t\t\teb_new(t0[i]);\n\t\t\teb_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EB_WIDTH); i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t}\n\n\t\teb_set_infty(t0[0]);\n\t\teb_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\teb_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\teb_set_infty(t1[0]);\n\t\teb_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\teb_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\teb_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\teb_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if EB_WIDTH > 2 && defined(EB_MIXED)\n\t\teb_norm_sim(t + 1, (const eb_t *)(t + 1), (1 << EB_WIDTH) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(RLC_FB_BITS + 1, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\teb_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\teb_dbl(r, r);\n\t\t\t}\n\t\t\teb_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\teb_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\teb_free(t0[i]);\n\t\t\teb_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EB_WIDTH); i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EB_SIM == INTER || !defined(STRIP)\n\nvoid eb_mul_sim_inter(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul(r, p, k);\n\t\treturn;\n\t}\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\teb_mul_sim_kbltz(r, p, k, q, m, NULL);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EB_PLAIN)\n\teb_mul_sim_plain(r, p, k, q, m, NULL);\n#endif\n}\n\n#endif\n\n#if EB_SIM == JOINT || !defined(STRIP)\n\nvoid eb_mul_sim_joint(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m) {\n\teb_t t[5];\n\tint i, u_i, offset;\n\tint8_t jsf[2 * (RLC_FB_BITS + 1)];\n\tsize_t len;\n\n\tif (bn_is_zero(k) || eb_is_infty(p)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i =  0; i < 5; i++) {\n\t\t\teb_null(t[i]);\n\t\t\teb_new(t[i]);\n\t\t}\n\n\t\teb_set_infty(t[0]);\n\t\teb_copy(t[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\teb_neg(t[1], t[1]);\n\t\t}\n\t\teb_copy(t[2], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\teb_neg(t[2], t[2]);\n\t\t}\n\t\teb_add(t[3], t[2], t[1]);\n\t\teb_sub(t[4], t[2], t[1]);\n#if defined(EB_MIXED)\n\t\teb_norm_sim(t + 3, (const eb_t*)(t + 3), 2);\n#endif\n\n\t\tlen = 2 * (RLC_FB_BITS + 1);\n\t\tbn_rec_jsf(jsf, &len, k, m);\n\n\t\teb_set_infty(r);\n\t\toffset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;\n\t\tfor (i = len - 1; i >= 0; i--) {\n\t\t\teb_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\teb_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\teb_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\teb_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\teb_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\teb_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i =  0; i < 5; i++) {\n\t\t\teb_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid eb_mul_sim_gen(eb_t r, const bn_t k, const eb_t q, const bn_t m) {\n\teb_t g;\n\n\teb_null(g);\n\n\tif (bn_is_zero(k)) {\n\t\teb_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || eb_is_infty(q)) {\n\t\teb_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\teb_new(g);\n\n\t\teb_curve_get_gen(g);\n\n#if defined(EB_KBLTZ)\n#if EB_SIM == INTER && EB_FIX == LWNAF && defined(EB_PRECO)\n\t\tif (eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim_kbltz(r, g, k, q, m, eb_curve_get_tab());\n\t\t}\n#else\n\t\tif (eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim(r, g, k, q, m);\n\t\t}\n#endif\n#endif\n\n#if defined(EB_PLAIN)\n#if EB_SIM == INTER && EB_FIX == LWNAF && defined(EB_PRECO)\n\t\tif (!eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim_plain(r, g, k, q, m, eb_curve_get_tab());\n\t\t}\n#else\n\t\tif (!eb_curve_is_kbltz()) {\n\t\t\teb_mul_sim(r, g, k, q, m);\n\t\t}\n#endif\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(g);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the binary elliptic curve utilities.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n#include \"relic_eb.h\"\n#include \"relic_conf.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint eb_is_infty(const eb_t p) {\n\treturn (fb_is_zero(p->z) == 1);\n}\n\nvoid eb_set_infty(eb_t p) {\n\tfb_zero(p->x);\n\tfb_zero(p->y);\n\tfb_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid eb_copy(eb_t r, const eb_t p) {\n\tfb_copy(r->x, p->x);\n\tfb_copy(r->y, p->y);\n\tfb_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid eb_rand(eb_t p) {\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\teb_curve_get_ord(n);\n\n\t\tbn_rand_mod(k, n);\n\n\t\teb_mul_gen(p, k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid eb_rhs(fb_t rhs, const eb_t p) {\n\tfb_t t0, t1;\n\n\tfb_null(t0);\n\tfb_null(t1);\n\n\tRLC_TRY {\n\t\tfb_new(t0);\n\t\tfb_new(t1);\n\n\t\t/* t0 = x1^2. */\n\t\tfb_sqr(t0, p->x);\n\t\t/* t1 = x1^3. */\n\t\tfb_mul(t1, t0, p->x);\n\n\t\t/* t1 = x1^3 + a * x1^2 + b. */\n\t\tswitch (eb_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfb_add(t1, t1, t0);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfb_mul_dig(t0, t0, eb_curve_get_a()[0]);\n\t\t\t\tfb_add(t1, t1, t0);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfb_mul(t0, t0, eb_curve_get_a());\n\t\t\t\tfb_add(t1, t1, t0);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (eb_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfb_add_dig(t1, t1, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfb_add_dig(t1, t1, eb_curve_get_b()[0]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfb_add(t1, t1, eb_curve_get_b());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfb_copy(rhs, t1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(t0);\n\t\tfb_free(t1);\n\t}\n}\n\nvoid eb_blind(eb_t r, const eb_t p) {\n\tfb_t rand;\n\n\tfb_null(rand);\n\n\tRLC_TRY {\n\t\tfb_new(rand);\n\n\t\tfb_rand(rand);\n\t\tfb_mul(r->z, p->z, rand);\n\t\tfb_mul(r->x, p->x, rand);\n\t\tfb_sqr(rand, rand);\n\t\tfb_mul(r->y, p->y, rand);\n\t\tr->coord = PROJC;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfb_free(rand);\n\t}\n}\n\nint eb_on_curve(const eb_t p) {\n\teb_t t;\n\tfb_t lhs;\n\tint r = 0;\n\n\teb_null(t);\n\tfb_null(lhs);\n\n\tRLC_TRY {\n\t\teb_new(t);\n\t\tfb_new(lhs);\n\n\t\teb_norm(t, p);\n\n\t\tfb_mul(lhs, t->x, t->y);\n\t\teb_rhs(t->x, t);\n\t\tfb_sqr(t->y, t->y);\n\t\tfb_add(lhs, lhs, t->y);\n\t\tr = (fb_cmp(lhs, t->x) == RLC_EQ) || eb_is_infty(p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t\tfb_free(lhs);\n\t}\n\treturn r;\n}\n\nvoid eb_tab(eb_t *t, const eb_t p, int w) {\n\tint u;\n\n#if defined(EB_PLAIN)\n\tif (!eb_curve_is_kbltz()) {\n\t\tif (w > 2) {\n\t\t\teb_dbl(t[0], p);\n#if defined(EB_MIXED)\n\t\t\teb_norm(t[0], t[0]);\n#endif\n\t\t\teb_add(t[1], t[0], p);\n\t\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\t\teb_add(t[i], t[i - 1], t[0]);\n\t\t\t}\n#if defined(EB_MIXED)\n\t\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (w - 2)) - 1);\n#endif\n\t\t}\n\t\teb_copy(t[0], p);\n\t}\n#endif /* EB_PLAIN */\n\n#if defined(EB_KBLTZ)\n\tif (eb_curve_is_kbltz()) {\n\t\tu = (eb_curve_opt_a() == RLC_ZERO ? -1 : 1);\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (int i = 0; i < 1 << (w - 2); i++) {\n\t\t\teb_set_infty(t[i]);\n\t\t\tfb_set_dig(t[i]->z, 1);\n\t\t\tt[i]->coord = BASIC;\n\t\t}\n\n\t\tswitch (w) {\n\t\t\t/* Formulas from https://eprint.iacr.org/2014/664. */\n#if EB_DEPTH == 3 || EB_WIDTH ==  3\n\t\t\tcase 3:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\tif (u == 1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_add(t[1], t[0], p);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 4 || EB_WIDTH ==  4\n\t\t\tcase 4:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[1], t[0]);\n\t\t\t\tif (u == -1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[2], t[0], p);\n\t\t\t\teb_add(t[3], t[0], p);\n\t\t\t\teb_sub(t[1], t[1], p);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 5 || EB_WIDTH ==  5\n\t\t\tcase 5:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[1], t[0]);\n\t\t\t\tif (u == -1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[2], t[0], p);\n\t\t\t\teb_add(t[3], t[0], p);\n\t\t\t\teb_sub(t[1], t[1], p);\n\t\t\t\teb_add(t[4], t[1], t[0]);\n\t\t\t\teb_add(t[5], t[2], t[0]);\n\t\t\t\teb_add(t[6], t[3], t[0]);\n\t\t\t\teb_neg(t[7], t[5]);\n\t\t\t\teb_sub(t[7], t[7], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 6 || EB_WIDTH ==  6\n\t\t\tcase 6:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[15], t[0]);\n\t\t\t\teb_neg(t[15], t[15]);\n\t\t\t\tif (u == 1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[12], t[0], p);\n\t\t\t\teb_add(t[13], t[0], p);\n\t\t\t\teb_neg(t[6], t[12]);\n\t\t\t\teb_sub(t[6], t[6], t[0]);\n\t\t\t\teb_neg(t[5], t[13]);\n\t\t\t\teb_sub(t[5], t[5], t[0]);\n\t\t\t\teb_neg(t[7], t[5]);\n\t\t\t\teb_add(t[7], t[7], t[0]);\n\t\t\t\teb_add(t[14], t[15], p);\n\t\t\t\teb_sub(t[1], t[14], t[0]);\n\t\t\t\teb_neg(t[4], t[14]);\n\t\t\t\teb_sub(t[4], t[4], t[0]);\n\t\t\t\teb_neg(t[11], t[1]);\n\t\t\t\teb_add(t[11], t[11], t[0]);\n\t\t\t\teb_neg(t[8], t[4]);\n\t\t\t\teb_add(t[8], t[8], t[0]);\n\t\t\t\teb_neg(t[10], t[8]);\n\t\t\t\teb_sub(t[10], t[10],t[0]);\n\t\t\t\teb_add(t[15], t[1], t[15]);\n\t\t\t\teb_sub(t[2], t[15], t[0]);\n\t\t\t\teb_neg(t[3], t[15]);\n\t\t\t\teb_sub(t[3], t[3], t[0]);\n\t\t\t\teb_neg(t[9], t[3]);\n\t\t\t\teb_add(t[9], t[9], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 7 || EB_WIDTH ==  7\n\t\t\tcase 7:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[15], t[0]);\n\t\t\t\tif (u == -1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[18], t[0], p);\n\t\t\t\teb_add(t[19], t[0], p);\n\t\t\t\teb_neg(t[26], t[18]);\n\t\t\t\teb_sub(t[26], t[26], t[0]);\n\t\t\t\teb_neg(t[25], t[19]);\n\t\t\t\teb_sub(t[25], t[25], t[0]);\n\t\t\t\teb_sub(t[7], t[26], t[0]);\n\t\t\t\teb_sub(t[6], t[25], t[0]);\n\t\t\t\teb_neg(t[11], t[7]);\n\t\t\t\teb_add(t[11], t[11], t[0]);\n\t\t\t\teb_neg(t[12], t[6]);\n\t\t\t\teb_add(t[12], t[12], t[0]);\n\t\t\t\teb_add(t[30], t[11], t[0]);\n\t\t\t\teb_add(t[31], t[12], t[0]);\n\t\t\t\teb_neg(t[14], t[30]);\n\t\t\t\teb_sub(t[14], t[14], t[0]);\n\n\t\t\t\teb_sub(t[17], t[15], p);\n\t\t\t\teb_neg(t[1], t[17]);\n\t\t\t\teb_sub(t[27], t[1], t[0]);\n\t\t\t\teb_add(t[1], t[1], t[0]);\n\t\t\t\teb_add(t[20], t[1], t[0]);\n\t\t\t\teb_sub(t[8], t[27], t[0]);\n\t\t\t\teb_neg(t[24], t[20]);\n\t\t\t\teb_sub(t[24], t[24], t[0]);\n\t\t\t\teb_neg(t[10], t[8]);\n\t\t\t\teb_add(t[10], t[10], t[0]);\n\t\t\t\teb_sub(t[5], t[24], t[0]);\n\t\t\t\teb_neg(t[13], t[5]);\n\t\t\t\teb_add(t[13], t[13], t[0]);\n\t\t\t\teb_neg(t[16], t[1]);\n\t\t\t\teb_add(t[16], t[16], t[15]);\n\t\t\t\teb_neg(t[2], t[16]);\n\t\t\t\teb_sub(t[28], t[2], t[0]);\n\t\t\t\teb_add(t[2], t[2], t[0]);\n\t\t\t\teb_add(t[21], t[2], t[0]);\n\t\t\t\teb_sub(t[9], t[28], t[0]);\n\t\t\t\teb_neg(t[23], t[21]);\n\t\t\t\teb_sub(t[23], t[23], t[0]);\n\t\t\t\teb_sub(t[4], t[23], t[0]);\n\t\t\t\teb_neg(t[3], t[2]);\n\t\t\t\teb_add(t[15], t[3], t[15]);\n\t\t\t\teb_neg(t[3], t[15]);\n\t\t\t\teb_add(t[3], t[3], t[0]);\n\t\t\t\teb_neg(t[29], t[15]);\n\t\t\t\teb_sub(t[29], t[29], t[0]);\n\t\t\t\teb_add(t[22], t[3], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n#if EB_DEPTH == 8 || EB_WIDTH ==  8\n\t\t\tcase 8:\n\t\t\t\teb_frb(t[0], p);\n\t\t\t\teb_frb(t[57], t[0]);\n\t\t\t\teb_neg(t[57], t[57]);\n\t\t\t\tif (u == 1) {\n\t\t\t\t\teb_neg(t[0], t[0]);\n\t\t\t\t}\n\t\t\t\teb_sub(t[44], t[0], p);\n\t\t\t\teb_add(t[45], t[0], p);\n\t\t\t\teb_neg(t[38], t[44]);\n\t\t\t\teb_sub(t[38], t[38], t[0]);\n\t\t\t\teb_neg(t[37], t[45]);\n\t\t\t\teb_sub(t[37], t[37], t[0]);\n\t\t\t\teb_neg(t[6], t[38]);\n\t\t\t\teb_add(t[6], t[6], t[0]);\n\n\t\t\t\teb_neg(t[7], t[37]);\n\t\t\t\teb_add(t[7], t[7], t[0]);\n\t\t\t\teb_add(t[51], t[6], t[0]);\n\t\t\t\teb_add(t[52], t[7], t[0]);\n\t\t\t\teb_neg(t[31], t[51]);\n\t\t\t\teb_sub(t[31], t[31], t[0]);\n\t\t\t\teb_neg(t[30], t[52]);\n\t\t\t\teb_sub(t[30], t[30], t[0]);\n\t\t\t\teb_neg(t[13], t[31]);\n\t\t\t\teb_add(t[13], t[13], t[0]);\n\t\t\t\teb_neg(t[14], t[30]);\n\t\t\t\teb_add(t[14], t[14], t[0]);\n\t\t\t\teb_add(t[58], t[13], t[0]);\n\t\t\t\teb_add(t[59], t[14], t[0]);\n\t\t\t\teb_neg(t[24], t[58]);\n\t\t\t\teb_sub(t[24], t[24], t[0]);\n\t\t\t\teb_neg(t[23], t[59]);\n\t\t\t\teb_sub(t[23], t[23], t[0]);\n\t\t\t\teb_add(t[46], t[57], p);\n\t\t\t\teb_sub(t[1], t[46], t[0]);\n\t\t\t\teb_neg(t[36], t[46]);\n\t\t\t\teb_sub(t[36], t[36], t[0]);\n\t\t\t\teb_neg(t[43], t[1]);\n\t\t\t\teb_add(t[43], t[43], t[0]);\n\t\t\t\teb_neg(t[8], t[36]);\n\t\t\t\teb_add(t[8], t[8], t[0]);\n\t\t\t\teb_neg(t[39], t[43]);\n\t\t\t\teb_sub(t[39], t[39], t[0]);\n\t\t\t\teb_add(t[53], t[8], t[0]);\n\t\t\t\teb_neg(t[5], t[39]);\n\t\t\t\teb_add(t[5], t[5], t[0]);\n\t\t\t\teb_neg(t[29], t[53]);\n\t\t\t\teb_sub(t[29], t[29], t[0]);\n\t\t\t\teb_add(t[50], t[5], t[0]);\n\t\t\t\teb_neg(t[15], t[29]);\n\t\t\t\teb_add(t[15], t[15], t[0]);\n\t\t\t\teb_neg(t[32], t[50]);\n\t\t\t\teb_sub(t[32], t[32], t[0]);\n\t\t\t\teb_add(t[60], t[15], t[0]);\n\t\t\t\teb_neg(t[12], t[32]);\n\t\t\t\teb_add(t[12], t[12], t[0]);\n\t\t\t\teb_neg(t[22], t[60]);\n\t\t\t\teb_sub(t[22], t[22], t[0]);\n\t\t\t\teb_add(t[47], t[1], t[57]);\n\t\t\t\teb_sub(t[2], t[47], t[0]);\n\t\t\t\teb_neg(t[35], t[47]);\n\t\t\t\teb_sub(t[35], t[35], t[0]);\n\t\t\t\teb_neg(t[42], t[2]);\n\t\t\t\teb_add(t[42], t[42], t[0]);\n\t\t\t\teb_neg(t[9], t[35]);\n\t\t\t\teb_add(t[9], t[9], t[0]);\n\t\t\t\teb_neg(t[40], t[42]);\n\t\t\t\teb_sub(t[40], t[40], t[0]);\n\t\t\t\teb_add(t[54], t[9], t[0]);\n\t\t\t\teb_neg(t[4], t[40]);\n\t\t\t\teb_add(t[4], t[4], t[0]);\n\t\t\t\teb_neg(t[28], t[54]);\n\t\t\t\teb_sub(t[28], t[28], t[0]);\n\t\t\t\teb_neg(t[16], t[28]);\n\t\t\t\teb_add(t[16], t[16], t[0]);\n\t\t\t\teb_add(t[61], t[16], t[0]);\n\t\t\t\teb_neg(t[21], t[61]);\n\t\t\t\teb_sub(t[21], t[21], t[0]);\n\t\t\t\teb_add(t[48], t[2], t[57]);\n\t\t\t\teb_sub(t[3], t[48], t[0]);\n\t\t\t\teb_neg(t[34], t[48]);\n\t\t\t\teb_sub(t[34], t[34], t[0]);\n\t\t\t\teb_neg(t[41], t[3]);\n\t\t\t\teb_add(t[41], t[41], t[0]);\n\t\t\t\teb_neg(t[10], t[34]);\n\t\t\t\teb_add(t[10], t[10], t[0]);\n\t\t\t\teb_add(t[55], t[10], t[0]);\n\t\t\t\teb_neg(t[27], t[55]);\n\t\t\t\teb_sub(t[27], t[27], t[0]);\n\t\t\t\teb_neg(t[17], t[27]);\n\t\t\t\teb_add(t[17], t[17], t[0]);\n\t\t\t\teb_add(t[62], t[17], t[0]);\n\t\t\t\teb_neg(t[20], t[62]);\n\t\t\t\teb_sub(t[20], t[20], t[0]);\n\t\t\t\teb_add(t[49], t[3], t[57]);\n\t\t\t\teb_neg(t[33], t[49]);\n\t\t\t\teb_sub(t[33], t[33], t[0]);\n\t\t\t\teb_neg(t[11], t[33]);\n\t\t\t\teb_add(t[11], t[11], t[0]);\n\t\t\t\teb_add(t[56], t[11], t[0]);\n\t\t\t\teb_neg(t[26], t[56]);\n\t\t\t\teb_sub(t[26], t[26], t[0]);\n\t\t\t\teb_neg(t[18], t[26]);\n\t\t\t\teb_add(t[18], t[18], t[0]);\n\t\t\t\teb_add(t[63], t[18], t[0]);\n\t\t\t\teb_add(t[57], t[11], t[57]);\n\t\t\t\teb_neg(t[25], t[57]);\n\t\t\t\teb_sub(t[25], t[25], t[0]);\n\t\t\t\teb_neg(t[19], t[25]);\n\t\t\t\teb_add(t[19], t[19], t[0]);\n\t\t\t\teb_copy(t[0], p);\n\t\t\t\tbreak;\n#endif\n\t\t}\n#if defined(EB_MIXED)\n\t\tif (w > 2) {\n\t\t\teb_norm_sim(t + 1, (const eb_t *)t + 1, (1 << (w - 2)) - 1);\n\t\t}\n#endif\n\t}\n#endif /* EB_KBLTZ */\n}\n\nvoid eb_print(const eb_t p) {\n\tfb_print(p->x);\n\tfb_print(p->y);\n\tfb_print(p->z);\n}\n\nint eb_size_bin(const eb_t a, int pack) {\n\tint size = 0;\n\n\tif (eb_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tsize = 1 + RLC_FB_BYTES;\n\tif (!pack) {\n\t\tsize += RLC_FB_BYTES;\n\t}\n\n\treturn size;\n}\n\nvoid eb_read_bin(eb_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\teb_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (RLC_FB_BYTES + 1) && len != (2 * RLC_FB_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfb_set_dig(a->z, 1);\n\tfb_read_bin(a->x, bin + 1, RLC_FB_BYTES);\n\tif (len == RLC_FB_BYTES + 1) {\n\t\tswitch(bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfb_zero(a->y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfb_zero(a->y);\n\t\t\t\tfb_set_bit(a->y, 0, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\teb_upk(a, a);\n\t}\n\n\tif (len == 2 * RLC_FB_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfb_read_bin(a->y, bin + RLC_FB_BYTES + 1, RLC_FB_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!eb_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\nvoid eb_write_bin(uint8_t *bin, size_t len, const eb_t a, int pack) {\n\teb_t t;\n\n\teb_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (eb_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\teb_new(t);\n\n\t\teb_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < RLC_FB_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\teb_pck(t, t);\n\t\t\t\tbin[0] = 2 | fb_get_bit(t->y, 0);\n\t\t\t\tfb_write_bin(bin + 1, RLC_FB_BYTES, t->x);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FB_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfb_write_bin(bin + 1, RLC_FB_BYTES, t->x);\n\t\t\t\tfb_write_bin(bin + RLC_FB_BYTES + 1, RLC_FB_BYTES, t->y);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\teb_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\nvoid ed_map_ell2_5mod8(ed_t p, fp_t t) {\n\tbn_t h;\n\tfp_t tv1, tv2, tv3, tv4, tv5;\n\tbn_null(h);\n\tfp_null(tv1);\n\tfp_null(tv2);\n\tfp_null(tv3);\n\tfp_null(tv4);\n\tfp_null(tv5);\n\n\t/* aliases to make code easier to read */\n\tctx_t *ctx = core_get();\n\tdig_t *c_2exp = ctx->ed_map_c[0];\n\tdig_t *sqrt_M1 = ctx->ed_map_c[1];\n\tdig_t *sqrt_M486664 = ctx->ed_map_c[2];\n\tdig_t *c_486662 = ctx->ed_map_c[3];\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tfp_new(tv1);\n\t\tfp_new(tv2);\n\t\tfp_new(tv3);\n\t\tfp_new(tv4);\n\t\tfp_new(tv5);\n\n\t\t/* set h = (p - 5) / 8 */\n\t\th->used = RLC_FP_DIGS;\n\t\th->sign = RLC_POS;\n\t\tdv_copy(h->dp, fp_prime_get(), RLC_FP_DIGS); /* p */\n\t\tbn_sub_dig(h, h, 5);                         /* p - 5 */\n\t\tbn_rsh(h, h, 3);                             /* (p - 5) / 8 */\n\n\t\t/* start evaluating map */\n\t\tfp_sqr(tv1, t);\n\t\tfp_dbl(tv1, tv1);\n\t\tfp_add_dig(tv3, tv1, 1);\n\t\tfp_sqr(tv2, tv3);\n\t\tfp_mul(p->z, tv2, tv3);\n\n\t\t/* compute numerator of g(x1) */\n\t\tfp_sqr(tv4, c_486662);\n\t\tfp_mul(tv4, tv4, tv1);\n\t\tfp_sub(tv4, tv4, tv2);\n\t\tfp_mul(tv4, tv4, c_486662);\n\n\t\t/* compute divsrqt */\n\t\tfp_sqr(tv3, p->z);\n\t\tfp_sqr(tv2, tv3);\n\t\tfp_mul(tv3, tv3, p->z);\n\t\tfp_mul(tv3, tv3, tv4);\n\t\tfp_mul(tv2, tv2, tv3);\n\t\tfp_exp(tv2, tv2, h);\n\t\tfp_mul(tv2, tv2, tv3);\n\n\t\t/* figure out which sqrt we should keep */\n\t\tfp_mul(p->y, tv2, sqrt_M1);\n\t\tfp_sqr(p->x, tv2);\n\t\tfp_mul(p->x, p->x, p->z);\n\t\t{\n\t\t\tconst int e1 = fp_cmp(p->x, tv4);\n\t\t\tdv_copy_cond(p->y, tv2, RLC_FP_DIGS, e1 == RLC_EQ);\n\t\t} /* e1 goes out of scope */\n\n\t\t/* compute numerator of g(x2) */\n\t\tfp_mul(tv3, tv2, t);\n\t\tfp_mul(tv3, tv3, c_2exp);\n\t\tfp_mul(tv5, tv3, sqrt_M1);\n\n\t\t/* figure out which sqrt we should keep */\n\t\tfp_mul(p->x, tv4, tv1);\n\t\tfp_sqr(tv2, tv3);\n\t\tfp_mul(tv2, tv2, p->z);\n\t\t{\n\t\t\tconst int e2 = fp_cmp(p->x, tv2);\n\t\t\tdv_copy_cond(tv5, tv3, RLC_FP_DIGS, e2 == RLC_EQ);\n\t\t} /* e2 goes out of scope */\n\n\t\t/* figure out whether we wanted y1 or y2 and x1 or x2 */\n\t\tfp_sqr(tv2, p->y);\n\t\tfp_mul(tv2, tv2, p->z);\n\t\t{\n\t\t\tconst int e3 = fp_cmp(tv2, tv4);\n\t\t\tfp_set_dig(p->x, 1);\n\t\t\tdv_copy_cond(p->x, tv1, RLC_FP_DIGS, e3 != RLC_EQ);\n\t\t\tfp_mul(p->x, p->x, c_486662);\n\t\t\tfp_neg(p->x, p->x);\n\t\t\tdv_copy_cond(p->y, tv5, RLC_FP_DIGS, e3 != RLC_EQ);\n\n\t\t\t/* fix sign of y */\n\t\t\tfp_prime_back(h, p->y);\n\t\t\tconst int e4 = bn_get_bit(h, 0);\n\t\t\tfp_neg(tv2, p->y);\n\t\t\tdv_copy_cond(p->y, tv2, RLC_FP_DIGS, (e3 == RLC_EQ) ^ (e4 == 1));\n\t\t} /* e3 and e4 go out of scope */\n\t\tfp_add_dig(p->z, tv1, 1);\n\n\t\t/* convert to an Edwards point */\n\t\t/* tmp1 = xnumerator = sqrt_M486664 * x */\n\t\tfp_mul(tv1, p->x, sqrt_M486664); /* xn = sqrt(-486664) * x */\n\t\tfp_mul(tv2, p->y, p->z);         /* xd = y * z */\n\t\tfp_sub(tv3, p->x, p->z);         /* yn = x - z */\n\t\tfp_add(tv4, p->x, p->z);         /* yd = x + z */\n\n\t\tfp_mul(p->z, tv2, tv4);\n\t\tfp_mul(p->x, tv1, tv4);\n\t\tfp_mul(p->y, tv2, tv3);\n\t\t{\n\t\t\t/* exceptional case: either denominator == 0 */\n\t\t\tconst int e4 = fp_is_zero(p->z);\n\t\t\tfp_set_dig(tv5, 1);\n\t\t\tdv_copy_cond(p->x, p->z, RLC_FP_DIGS, e4); /* set x to 0 */\n\t\t\tdv_copy_cond(p->y, tv5, RLC_FP_DIGS, e4);\n\t\t\tdv_copy_cond(p->z, tv5, RLC_FP_DIGS, e4);\n\t\t} /* e4 goes out of scope */\n\n\t\t/* clear denominator / compute extended coordinates if necessary */\n#if ED_ADD == EXTND || ED_ADD == PROJC\n\t\tp->coord = PROJC;\n#if ED_ADD == EXTND\n\t\t/* extended coordinates: T * Z == X * Y */\n\t\tfp_mul(p->t, p->x, p->y);\n\t\tfp_mul(p->x, p->x, p->z);\n\t\tfp_mul(p->y, p->y, p->z);\n\t\tfp_sqr(p->z, p->z);\n#endif /* ED_ADD == EXTND */\n#else  /* ED_ADD == BASIC */\n\t\tfp_inv(tv1, p->z);\n\t\tfp_mul(p->x, p->x, tv1);\n\t\tfp_mul(p->y, p->y, tv1);\n\t\tfp_set_dig(p->z, 1);\n\t\tp->coord = BASIC;\n#endif /* ED_ADD */\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT)\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(h);\n\t\tfp_free(tv1);\n\t\tfp_free(tv2);\n\t\tfp_free(tv3);\n\t\tfp_free(tv4);\n\t\tfp_free(tv5);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ed_map_dst(ed_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len) {\n\tbn_t k;\n\tfp_t t;\n\ted_t q;\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ed_param_level() + 7) / 8;\n\tuint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 2 * len_per_elm);\n\n\tbn_null(k);\n\tfp_null(t);\n\ted_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tfp_new(t);\n\t\ted_new(q);\n\n\t\t/* pseudorandom string */\n\t\tmd_xmd(pseudo_random_bytes, 2 * len_per_elm, msg, len, dst, dst_len);\n\n#define ED_MAP_CONVERT_BYTES(IDX)                                                        \\\n\tdo {                                                                                 \\\n\t\tbn_read_bin(k, pseudo_random_bytes + IDX * len_per_elm, len_per_elm);            \\\n\t\tfp_prime_conv(t, k);                                                             \\\n\t} while (0)\n\n\t\t/* first map invocation */\n\t\tED_MAP_CONVERT_BYTES(0);\n\t\ted_map_ell2_5mod8(p, t);\n\n\t\t/* second map invocation */\n\t\tED_MAP_CONVERT_BYTES(1);\n\t\ted_map_ell2_5mod8(q, t);\n\n#undef ED_MAP_CONVERT_BYTES\n\n\t\ted_add(p, p, q);\n\n\t\t/* clear cofactor */\n\t\tswitch (ed_param_get()) {\n\t\t\tcase CURVE_ED25519:\n\t\t\t\ted_dbl(p, p);\n\t\t\t\ted_dbl(p, p);\n\t\t\t\ted_dbl(p, p);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\n\t\ted_norm(p, p);\n#if ED_ADD == EXTND\n\t\tfp_mul(p->t, p->x, p->y);\n#endif\n\t\tp->coord = BASIC;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfp_free(t);\n\t\ted_free(q);\n\t\tRLC_FREE(pseudo_random_bytes);\n\t}\n}\n\nvoid ed_map(ed_t p, const uint8_t *msg, size_t len) {\n\ted_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the point multiplication on Twisted Edwards elliptic curves.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if ED_MUL == LWNAF || !defined(STRIP)\n\nstatic void ed_mul_naf_imp(ed_t r, const ed_t p, const bn_t k) {\n\tint i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\ted_t t[1 << (ED_WIDTH - 2)];\n\tsize_t l;\n\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\ted_tab(t, p, ED_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i > 0; i--) {\n\t\t\tn = naf[i];\n\t\t\tif (n == 0) {\n\t\t\t\t/* This point will be doubled in the next iteration. */\n#if ED_ADD == EXTND\n\t\t\t\tr->coord = EXTND;\n#endif\n\t\t\t}\n\t\t\ted_dbl(r, r);\n\t\t\tif (n > 0) {\n\t\t\t\ted_add(r, r, t[n / 2]);\n\t\t\t} else if (n < 0) {\n\t\t\t\ted_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\n\t\t/* Last iteration. */\n\t\tn = naf[0];\n\t\ted_dbl(r, r);\n\t\tif (n > 0) {\n\t\t\ted_add(r, r, t[n / 2]);\n\t\t} else if (n < 0) {\n\t\t\ted_sub(r, r, t[-n / 2]);\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* ED_MUL == LWNAF */\n\n#if ED_MUL == LWREG || !defined(STRIP)\n\nstatic void ed_mul_reg_imp(ed_t r, const ed_t p, const bn_t k) {\n\tbn_t _k;\n\tint i, j, n;\n\tint8_t s, reg[RLC_CEIL(RLC_FP_BITS + 1, ED_WIDTH - 1)];\n\ted_t t[1 << (ED_WIDTH - 2)], u, v;\n\tsize_t l;\n\n\tbn_null(_k);\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(_k);\n\t\ted_new(u);\n\t\ted_new(v);\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\ted_tab(t, p, ED_WIDTH);\n\n\t\t/* Make a copy of the scalar for processing. */\n\t\tbn_abs(_k, k);\n\t\t_k->dp[0] |= bn_is_even(_k);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = RLC_CEIL(RLC_FP_BITS + 1, ED_WIDTH - 1);\n\t\tbn_rec_reg(reg, &l, _k, RLC_FP_BITS, ED_WIDTH);\n\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tfor (j = 0; j < ED_WIDTH - 1; j++) {\n#if ED_ADD == EXTND\n\t\t\t\tr->coord = EXTND;\n#endif\n\t\t\t\ted_dbl(r, r);\n\t\t\t}\n\n\t\t\tn = reg[i];\n\t\t\ts = (n >> 7);\n\t\t\tn = ((n ^ s) - s) >> 1;\n\n\t\t\tfor (j = 0; j < (1 << (EP_WIDTH - 2)); j++) {\n\t\t\t\tdv_copy_cond(u->x, t[j]->x, RLC_FP_DIGS, j == n);\n\t\t\t\tdv_copy_cond(u->y, t[j]->y, RLC_FP_DIGS, j == n);\n\t\t\t\tdv_copy_cond(u->z, t[j]->z, RLC_FP_DIGS, j == n);\n\t\t\t}\n\t\t\ted_neg(v, u);\n\t\t\tdv_copy_cond(u->x, v->x, RLC_FP_DIGS, s != 0);\n\t\t\ted_add(r, r, u);\n\t\t}\n\n\t\t/* t[0] has an unmodified copy of p. */\n\t\ted_sub(u, r, t[0]);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, bn_is_even(k));\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t\ted_neg(u, r);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, bn_sign(k) == RLC_NEG);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t\tbn_free(_k);\n\t}\n}\n\n#endif /* ED_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if ED_MUL == BASIC || !defined(STRIP)\n\nvoid ed_mul_basic(ed_t r, const ed_t p, const bn_t k) {\n\ted_t t;\n\n\ted_null(t);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t);\n\n\t\ted_copy(t, p);\n\t\tfor (int i = bn_bits(k) - 2; i >= 0; i--) {\n\t\t\ted_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\ted_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\ted_norm(r, t);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t}\n}\n\n#endif\n\n#if ED_MUL == SLIDE || !defined(STRIP)\n\nvoid ed_mul_slide(ed_t r, const ed_t p, const bn_t k) {\n\ted_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\ted_null(q);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\n\t\ted_new(q);\n\n\t\ted_copy(t[0], p);\n\t\ted_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\ted_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\ted_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\ted_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\ted_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\ted_dbl(q, q);\n\t\t\t\t}\n\t\t\t\ted_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\ted_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t\ted_free(q);\n\t}\n}\n\n#endif\n\n#if ED_MUL == MONTY || !defined(STRIP)\n\nvoid ed_mul_monty(ed_t r, const ed_t p, const bn_t k) {\n\ted_t t[2];\n\n\ted_null(t[0]);\n\ted_null(t[1]);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t[0]);\n\t\ted_new(t[1]);\n\n\t\ted_set_infty(t[0]);\n\t\ted_copy(t[1], p);\n\n\t\tfor (int i = bn_bits(k) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(k, i);\n\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n#if ED_ADD == EXTND\n\t\t\tdv_swap_cond(t[0]->t, t[1]->t, RLC_FP_DIGS, j ^ 1);\n#endif\n\t\t\ted_add(t[0], t[0], t[1]);\n\t\t\ted_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n#if ED_ADD == EXTND\n\t\t\tdv_swap_cond(t[0]->t, t[1]->t, RLC_FP_DIGS, j ^ 1);\n#endif\n\t\t}\n\n\t\ted_norm(r, t[0]);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t[1]);\n\t\ted_free(t[0]);\n\t}\n}\n\n#endif\n\n#if ED_MUL == LWNAF || !defined(STRIP)\n\nvoid ed_mul_lwnaf(ed_t r, const ed_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\ted_mul_naf_imp(r, p, k);\n}\n\n#endif\n\n#if ED_MUL == LWREG || !defined(STRIP)\n\nvoid ed_mul_lwreg(ed_t r, const ed_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\ted_mul_reg_imp(r, p, k);\n}\n\n#endif\n\nvoid ed_mul_gen(ed_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n#ifdef ED_PRECO\n\ted_mul_fix(r, ed_curve_get_tab(), k);\n#else\n\ted_t g;\n\n\ted_null(g);\n\n\tRLC_TRY {\n\t\ted_new(g);\n\t\ted_curve_get_gen(g);\n\t\ted_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(g);\n\t}\n#endif\n}\n\nvoid ed_mul_dig(ed_t r, const ed_t p, dig_t k) {\n\ted_t t;\n\tbn_t _k;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\ted_null(t);\n\tbn_null(_k);\n\n\tif (k == 0 || ed_is_infty(p)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t);\n\t\tbn_new(_k);\n\n\t\tbn_set_dig(_k, k);\n\n\t\tl = RLC_DIG + 1;\n\t\tbn_rec_naf(naf, &l, _k, 2);\n\n\t\ted_set_infty(t);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\ted_dbl(t, t);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\ted_add(t, t, p);\n\t\t\t} else if (u < 0) {\n\t\t\t\ted_sub(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\ted_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t\tbn_free(_k);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on prime elliptic Edwards curves.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if ED_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF mixed coordinate\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ed_mul_fix_plain(ed_t r, const ed_t * t, const bn_t k) {\n\tint i, n;\n\tint8_t naf[RLC_FP_BITS + 1], *_k;\n\tsize_t l;\n\n\t/* Compute the w-TNAF representation of k. */\n\tl = RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &l, k, ED_DEPTH);\n\n\t_k = naf + l - 1;\n\ted_set_infty(r);\n\tfor (i = l - 1; i >= 0; i--, _k--) {\n\t\tn = *_k;\n\t\tif (n == 0) {\n\t\t\t/* doubling is followed by another doubling */\n\t\t\tif (i > 0) {\n\t\t\t\tr->coord = EXTND;\n\t\t\t\ted_dbl(r, r);\n\t\t\t} else {\n\t\t\t\t/* use full extended coordinate doubling for last step */\n\t\t\t\ted_dbl(r, r);\n\t\t\t}\n\t\t} else {\n\t\t\ted_dbl(r, r);\n\t\t\tif (n > 0) {\n\t\t\t\ted_add(r, r, t[n / 2]);\n\t\t\t} else if (n < 0) {\n\t\t\t\ted_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\ted_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\ted_neg(r, r);\n\t}\n}\n\n#endif /* ED_FIX == LWNAF */\n\n#if ED_FIX == COMBS || !defined(STRIP)\n\n/**\n * Multiplies a prime elliptic curve point by an integer using the COMBS\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ed_mul_combs_plain(ed_t r, const ed_t * t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % ED_DEPTH) == 0 ? (l / ED_DEPTH) : (l / ED_DEPTH) + 1);\n\n\t\tn0 = bn_bits(k);\n\n\t\tp0 = (ED_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\t\ted_copy(r, t[w]);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\ted_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\ted_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif /* ED_FIX == COMBS */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if ED_FIX == BASIC || !defined(STRIP)\n\nvoid ed_mul_pre_basic(ed_t * t, const ed_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\n\t\ted_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\ted_dbl(t[i], t[i - 1]);\n\t\t}\n\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, bn_bits(n) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_mul_fix_basic(ed_t r, const ed_t *t, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\ted_set_infty(r);\n\t\treturn;\n\t}\n\n\ted_set_infty(r);\n\n\tfor (int i = 0; i < bn_bits(k); i++) {\n\t\tif (bn_get_bit(k, i)) {\n\t\t\ted_add(r, r, t[i]);\n\t\t}\n\t}\n\ted_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\ted_neg(r, r);\n\t}\n}\n\n#endif\n\n#if ED_FIX == COMBS || !defined(STRIP)\n\nvoid ed_mul_pre_combs(ed_t * t, const ed_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % ED_DEPTH) == 0 ? (l / ED_DEPTH) : (l / ED_DEPTH) + 1);\n\n\t\ted_set_infty(t[0]);\n\n\t\ted_copy(t[1], p);\n\t\tfor (j = 1; j < ED_DEPTH; j++) {\n\t\t\ted_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\ted_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(ED_MIXED)\n\t\t\ted_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\ted_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\n\t\ted_norm_sim(t + 2, (const ed_t *)t + 2, RLC_ED_TABLE_COMBS - 2);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_mul_fix_combs(ed_t r, const ed_t * t, const bn_t k) {\n\ted_mul_combs_plain(r, t, k);\n}\n#endif\n\n#if ED_FIX == COMBD || !defined(STRIP)\n\nvoid ed_mul_pre_combd(ed_t * t, const ed_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % ED_DEPTH) == 0 ? (d / ED_DEPTH) : (d / ED_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\ted_set_infty(t[0]);\n\t\ted_copy(t[1], p);\n\t\tfor (j = 1; j < ED_DEPTH; j++) {\n\t\t\ted_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\ted_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(ED_MIXED)\n\t\t\ted_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\ted_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\ted_set_infty(t[1 << ED_DEPTH]);\n\t\tfor (j = 1; j < (1 << ED_DEPTH); j++) {\n\t\t\ted_dbl(t[(1 << ED_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\ted_dbl(t[(1 << ED_DEPTH) + j], t[(1 << ED_DEPTH) + j]);\n\t\t\t}\n\t\t}\n\n\t\ted_norm_sim(t + 2, (const ed_t *)t + 2, (1 << ED_DEPTH) - 2);\n\t\ted_norm_sim(t + (1 << ED_DEPTH) + 1,\n\t\t\t\t(const ed_t *)t + (1 << ED_DEPTH) + 1, (1 << ED_DEPTH) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_mul_fix_combd(ed_t r, const ed_t * t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % ED_DEPTH) == 0 ? (d / ED_DEPTH) : (d / ED_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\ted_set_infty(r);\n\t\tn0 = bn_bits(k);\n\n\t\tp1 = (e - 1) + (ED_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = ED_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ted_add(r, r, t[w0]);\n\t\t\ted_add(r, r, t[(1 << ED_DEPTH) + w1]);\n\t\t}\n\t\ted_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif\n\n#if ED_FIX == LWNAF || !defined(STRIP)\n\nvoid ed_mul_pre_lwnaf(ed_t * t, const ed_t p) {\n\ted_tab(t, p, ED_DEPTH);\n}\n\nvoid ed_mul_fix_lwnaf(ed_t r, const ed_t * t, const bn_t k) {\n\ted_mul_fix_plain(r, t, k);\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on binary elliptic\n * curves.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if ED_SIM == INTER || !defined(STRIP)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m, const ed_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\ted_t t0[1 << (ED_WIDTH - 2)];\n\ted_t t1[1 << (ED_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\t\ted_null(t0[i]);\n\t\t\t\ted_new(t0[i]);\n\t\t\t}\n\t\t\ted_tab(t0, p, ED_WIDTH);\n\t\t\tt = (const ed_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\ted_null(t1[i]);\n\t\t\ted_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\ted_tab(t1, q, ED_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = ED_DEPTH;\n\t\t} else {\n\t\t\tw = ED_WIDTH;\n\t\t}\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, ED_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\ted_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\ted_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\ted_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\ted_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\ted_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < 1 << (ED_WIDTH - 2); i++) {\n\t\t\t\ted_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 1 << (ED_WIDTH - 2); i++) {\n\t\t\ted_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* ED_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if ED_SIM == BASIC || !defined(STRIP)\n\nvoid ed_mul_sim_basic(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t;\n\n\ted_null(t);\n\n\tRLC_TRY {\n\t\ted_new(t);\n\t\ted_mul(t, q, m);\n\t\ted_mul(r, p, k);\n\t\ted_add(t, t, r);\n\t\ted_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t}\n}\n\n#endif\n\n#if ED_SIM == TRICK || !defined(STRIP)\n\nvoid ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tsize_t l0, l1, w = ED_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\ted_null(t0[i]);\n\t\t\ted_null(t1[i]);\n\t\t\ted_new(t0[i]);\n\t\t\ted_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << ED_WIDTH); i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\n\t\ted_set_infty(t0[0]);\n\t\ted_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\ted_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\ted_set_infty(t1[0]);\n\t\ted_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\ted_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 1; i < (1 << w); i++) {\n\t\t\ted_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\ted_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if defined(ED_MIXED)\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (ED_WIDTH)) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(RLC_FP_BITS, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\ted_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ted_dbl(r, r);\n\t\t\t}\n\t\t\ted_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\ted_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\ted_free(t0[i]);\n\t\t\ted_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << ED_WIDTH); i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if ED_SIM == INTER || !defined(STRIP)\n\nvoid ed_mul_sim_inter(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);\n\t\treturn;\n\t}\n\n\ted_mul_sim_plain(r, p, k, q, m, NULL);\n}\n\n#endif\n\n#if ED_SIM == JOINT || !defined(STRIP)\n\nvoid ed_mul_sim_joint(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t[5];\n\tint i, u_i, offset;\n\tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n\tsize_t l;\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\ted_null(t[i]);\n\t\t\ted_new(t[i]);\n\t\t}\n\n\t\ted_set_infty(t[0]);\n\t\ted_copy(t[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\ted_neg(t[1], t[1]);\n\t\t}\n\t\ted_copy(t[2], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\ted_neg(t[2], t[2]);\n\t\t}\n\t\ted_add(t[3], t[2], t[1]);\n\t\ted_sub(t[4], t[2], t[1]);\n#if defined(ED_MIXED)\n\t\ted_norm_sim(t + 3, (const ed_t *)t + 3, 2);\n#endif\n\n\t\tl = 2 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, k, m);\n\n\t\ted_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\ted_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\ted_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\ted_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\ted_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ted_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\ted_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ed_mul_sim_gen(ed_t r, const bn_t k, const ed_t q, const bn_t m) {\n\ted_t g;\n\n\ted_null(g);\n\n\tif (bn_is_zero(k)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\ted_new(g);\n\n\t\ted_curve_get_gen(g);\n\n#if ED_SIM == INTER && ED_FIX == LWNAF && defined(ED_PRECO)\n\t\ted_mul_sim_plain(r, g, k, q, m, ed_curve_get_tab());\n#else\n\t\ted_mul_sim(r, g, k, q, m);\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(g);\n\t}\n}\n\nvoid ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j;\n\tint8_t *naf = NULL;\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ted_null(_p[i]);\n\t\t\ted_new(_p[i]);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t_l[i] = l;\n\t\t\ted_norm(_p[i], p[i]);\n\t\t\tbn_rec_naf(&naf[i*l], &_l[i], k[i], 2);\n\t\t\tif (bn_sign(k[i]) == RLC_NEG) {\n\t\t\t\ted_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t}\n\n\t\ted_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\ted_dbl(r, r);\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (naf[j*l + i] > 0) {\n\t\t\t\t\ted_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf[j*l + i] < 0) {\n\t\t\t\t\ted_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\ted_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\ted_free(_p[i]);\n\t\t}\n\t\tRLC_FREE(_l);\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(naf);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2014 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Edwards elliptic curve utilities.\n *\n * @version $Id$\n * @ingroup ed\n */\n\n#include <assert.h>\n\n#include \"relic_core.h\"\n#include \"relic_label.h\"\n#include \"relic_md.h\"\n\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ed_is_infty(const ed_t p) {\n\tfp_t t;\n\tint r = 0;\n\n\tfp_null(t);\n\n\tif (p->coord == BASIC) {\n\t\treturn (fp_is_zero(p->x) && (fp_cmp_dig(p->y, 1) == RLC_EQ));\n\t}\n\n\tif (fp_is_zero(p->z)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tfp_new(t);\n\t\tfp_inv(t, p->z);\n\t\tfp_mul(t, p->y, t);\n\t\tif (fp_is_zero(p->x) && (fp_cmp_dig(t, 1) == RLC_EQ)) {\n\t\t\tr = 1;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(t);\n\t}\n\n\treturn r;\n}\n\nvoid ed_set_infty(ed_t p) {\n\tfp_zero(p->x);\n\tfp_set_dig(p->y, 1);\n\tfp_set_dig(p->z, 1);\n#if ED_ADD == EXTND\n\tfp_zero(p->t);\n#endif\n\tp->coord = PROJC;\n}\n\nvoid ed_copy(ed_t r, const ed_t p) {\n\tfp_copy(r->x, p->x);\n\tfp_copy(r->y, p->y);\n\tfp_copy(r->z, p->z);\n#if ED_ADD == EXTND\n\tfp_copy(r->t, p->t);\n#endif\n\n\tr->coord = p->coord;\n}\n\nvoid ed_rand(ed_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\ted_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\ted_mul_gen(p, k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ed_blind(ed_t r, const ed_t p) {\n\tfp_t rand;\n\n\tfp_null(rand);\n\n\tRLC_TRY {\n\t\tfp_new(rand);\n\t\tfp_rand(rand);\n#if ED_ADD == BASIC\n\t\t(void)rand;\n\t\ted_copy(r, p);\n#elif ED_ADD == PROJC || ED_ADD == EXTND\n\t\tfp_mul(r->x, p->x, rand);\n\t\tfp_mul(r->y, p->y, rand);\n\t\tfp_mul(r->z, p->z, rand);\n\t\tr->coord = PROJC;\n#endif\n#if ED_ADD == EXTND\n\t\tfp_mul(r->t, p->t, rand);\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(rand);\n\t}\n}\n\nvoid ed_rhs(fp_t rhs, const ed_t p) {\n\tfp_t t0, t1;\n\n\tfp_null(t0);\n\tfp_null(t1);\n\n\tRLC_TRY {\n\t\tfp_new(t0);\n\t\tfp_new(t1);\n\n\t\t// 1 = a * X^2 + Y^2 - d * X^2 * Y^2\n\t\tfp_sqr(t0, p->x);\n\t\tfp_mul(t0, t0, core_get()->ed_a);\n\t\tfp_sqr(t1, p->y);\n\t\tfp_add(t1, t1, t0);\n\t\tfp_mul(t0, p->x, p->y);\n\t\tfp_sqr(t0, t0);\n\t\tfp_mul(t0, t0, core_get()->ed_d);\n\t\tfp_sub(rhs, t1, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(t0);\n\t\tfp_free(t1);\n\t}\n}\n\nint ed_on_curve(const ed_t p) {\n\ted_t t;\n\tint r = 0;\n\n\ted_null(t);\n\n\tif (fp_is_zero(p->z)) {\n\t\tr = 0;\n\t} else {\n\t\tRLC_TRY {\n\t\t\ted_new(t);\n\t\t\ted_norm(t, p);\n\n\t\t\ted_rhs(t->z, t);\n#if ED_ADD == EXTND\n\t\t\tfp_mul(t->y, t->x, t->y);\n\t\t\tr = ((fp_cmp_dig(t->z, 1) == RLC_EQ) &&\n\t\t\t\t\t(fp_cmp(t->y, t->t) == RLC_EQ)) || ed_is_infty(p);\n#else\n\t\t\tr = (fp_cmp_dig(t->z, 1) == RLC_EQ) || ed_is_infty(p);\n#endif\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\ted_free(t);\n\t\t}\n\t}\n\treturn r;\n}\n\nvoid ed_tab(ed_t * t, const ed_t p, int w) {\n\tif (w > 2) {\n\t\ted_dbl(t[0], p);\n#if defined(ED_MIXED)\n\t\ted_norm(t[0], t[0]);\n#endif\n\t\ted_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\ted_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(ED_MIXED)\n\t\ted_norm_sim(t + 1, (const ed_t *)t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\ted_copy(t[0], p);\n}\n\nvoid ed_print(const ed_t p) {\n\tfp_print(p->x);\n\tfp_print(p->y);\n#if ED_ADD == EXTND\n\tfp_print(p->t);\n#endif\n\tfp_print(p->z);\n}\n\nint ed_size_bin(const ed_t a, int pack) {\n\tint size = 0;\n\n\tif (ed_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tsize = 1 + RLC_FP_BYTES;\n\tif (!pack) {\n\t\tsize += RLC_FP_BYTES;\n\t}\n\n\treturn size;\n}\n\nvoid ed_read_bin(ed_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\ted_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (RLC_FP_BYTES + 1) && len != (2 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp_set_dig(a->z, 1);\n\tfp_read_bin(a->y, bin + 1, RLC_FP_BYTES);\n\tif (len == RLC_FP_BYTES + 1) {\n\t\tswitch (bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfp_zero(a->x);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfp_zero(a->x);\n\t\t\t\tfp_set_bit(a->x, 0, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\ted_upk(a, a);\n\t}\n\n\tif (len == 2 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp_read_bin(a->x, bin + RLC_FP_BYTES + 1, RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n#if ED_ADD == EXTND\n\tfp_mul(a->t, a->x, a->y);\n\tfp_mul(a->x, a->x, a->z);\n\tfp_mul(a->y, a->y, a->z);\n\tfp_sqr(a->z, a->z);\n#endif\n\n\tif (!ed_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n}\n\nvoid ed_write_bin(uint8_t *bin, size_t len, const ed_t a, int pack) {\n\ted_t t;\n\n\ted_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ed_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\ted_new(t);\n\n\t\ted_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\ted_pck(t, t);\n\t\t\t\tbin[0] = 2 | fp_get_bit(t->x, 0);\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->y);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->y);\n\t\t\t\tfp_write_bin(bin + RLC_FP_BYTES + 1, RLC_FP_BYTES, t->x);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\ted_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve.\n *\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"relic_tmpl_map.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#ifdef EP_CTMAP\n\n/**\n * Evaluate a polynomial represented by its coefficients over a using Horner's\n * rule. Might promove to an API if needed elsewhere in the future.\n *\n * @param[out] c\t\t- the result.\n * @param[in] a\t\t\t- the input value.\n * @param[in] coeffs\t- the vector of coefficients in the polynomial.\n * @param[in] deg \t\t- the degree of the polynomial.\n */\nTMPL_MAP_HORNER(fp, fp_st);\n\n/**\n * Generic isogeny map evaluation for use with SSWU map.\n */\nTMPL_MAP_ISOGENY_MAP(ep, fp, iso);\n\n#endif /* EP_CTMAP */\n\n#define EP_MAP_COPY_COND(O, I, C) dv_copy_cond(O, I, RLC_FP_DIGS, C)\n/**\n * Simplified SWU mapping from Section 4 of\n * \"Fast and simple constant-time hashing to the BLS12-381 Elliptic Curve\"\n */\nTMPL_MAP_SSWU(ep, fp, dig_t, EP_MAP_COPY_COND);\n\n/**\n * Shallue--van de Woestijne map, based on the definition from\n * draft-irtf-cfrg-hash-to-curve-06, Section 6.6.1\n */\nTMPL_MAP_SVDW(ep, fp, dig_t, EP_MAP_COPY_COND);\n\n#undef EP_MAP_COPY_COND\n\n/* caution: this function overwrites k, which used as an auxiliary variable */\nstatic inline int fp_sgn0(const fp_t t, bn_t k) {\n\tfp_prime_back(k, t);\n\treturn bn_get_bit(k, 0);\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len) {\n\tbn_t k;\n\tfp_t t;\n\tep_t q;\n\tint neg;\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\n\tbn_null(k);\n\tfp_null(t);\n\tep_null(q);\n\n\tRLC_TRY {\n\t\tif (len != 2 * len_per_elm) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\n\t\tbn_new(k);\n\t\tfp_new(t);\n\t\tep_new(q);\n\n\t\t/* figure out which hash function to use */\n\t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep_t, fp_t) = (ep_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n\n#define EP_MAP_CONVERT_BYTES(IDX)\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tbn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);\t\\\n\t\t\tfp_prime_conv(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while (0)\n\n#define EP_MAP_APPLY_MAP(PT)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t/* check sign of t */\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tneg = fp_sgn0(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t/* convert */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmap_fn(PT, t);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t/* compare sign of y and sign of t; fix if necessary */\t\t\t\\\n\t\t\tneg = neg != fp_sgn0(PT->y, k);\t\t\t\t\t\t\t\t\t\\\n\t\t\tfp_neg(t, PT->y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tdv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);\t\t\t\t\t\t\\\n\t\t} while (0)\n\n\t\t/* first map invocation */\n\t\tEP_MAP_CONVERT_BYTES(0);\n\t\tEP_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, p);\n\n\t\t/* second map invocation */\n\t\tEP_MAP_CONVERT_BYTES(1);\n\t\tEP_MAP_APPLY_MAP(q);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, q);\n\n\t\t/* XXX(rsw) could add p and q and then apply isomap,\n\t\t * but need ep_add to support addition on isogeny curves */\n\n#undef EP_MAP_CONVERT_BYTES\n#undef EP_MAP_APPLY_MAP\n\n\t\t/* sum the result */\n\t\tep_add(p, p, q);\n\t\tep_norm(p, p);\n\n\t\t/* clear cofactor */\n\t\tswitch (ep_curve_is_pairf()) {\n\t\t\tcase EP_BN:\n\t\t\t\t/* h = 1 */\n\t\t\t\tbreak;\n\t\t\tcase EP_B12:\n\t\t\tcase EP_B24:\n\t\t\t\t/* Multiply by (1-x) to get the correct group, as proven in\n\t\t\t\t * Piellard. https://eprint.iacr.org/2022/352.pdf */\n\t\t\t\tfp_prime_get_par(k);\n\t\t\t\tbn_neg(k, k);\n\t\t\t\tbn_add_dig(k, k, 1);\n\t\t\t\tif (bn_bits(k) < RLC_DIG) {\n\t\t\t\t\tep_mul_dig(p, p, k->dp[0]);\n\t\t\t\t} else {\n\t\t\t\t\tep_mul(p, p, k);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* multiply by cofactor to get the correct group. */\n\t\t\t\tep_curve_get_cof(k);\n\t\t\t\tif (bn_bits(k) < RLC_DIG) {\n\t\t\t\t\tep_mul_dig(p, p, k->dp[0]);\n\t\t\t\t} else {\n\t\t\t\t\tep_mul_basic(p, p, k);\n\t\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfp_free(t);\n\t\tep_free(q);\n\t}\n}\n\nvoid ep_map_dst(ep_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len) {\n\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\tuint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 2 * len_per_elm);\n\n\tRLC_TRY {\n\t\t/* for hash_to_field, need to hash to a pseudorandom string */\n\t\t/* XXX(rsw) the below assumes that we want to use MD_MAP for hashing.\n\t\t *          Consider making the hash function a per-curve option!\n\t\t */\n\t\tmd_xmd(pseudo_random_bytes, 2 * len_per_elm, msg, len, dst, dst_len);\n\t\tep_map_from_field(p, pseudo_random_bytes, 2 * len_per_elm);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tRLC_FREE(pseudo_random_bytes);\n\t}\n}\n\nvoid ep_map(ep_t p, const uint8_t *msg, size_t len) {\n\tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the point multiplication on prime elliptic curves.\n *\n * @ingroup eb\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep_mul_glv_imp(ep_t r, const ep_t p, const bn_t k) {\n\tint i, n0, n1, s0, s1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1;\n\tbn_t n, _k, k0, k1, v1[3], v2[3];\n\tep_t q, t[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(k0);\n\tbn_null(k1);\n\tep_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tep_new(q);\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_rec_glv(k0, k1, _k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\ts0 = bn_sign(k0);\n\t\ts1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\n\t\tif (s0 == RLC_POS) {\n\t\t\tep_tab(t, p, EP_WIDTH);\n\t\t} else {\n\t\t\tep_neg(q, p);\n\t\t\tep_tab(t, q, EP_WIDTH);\n\t\t}\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k0, EP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, k1, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tt0 = naf0 + l - 1;\n\t\tt1 = naf1 + l - 1;\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, t0--, t1--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tn0 = *t0;\n\t\t\tn1 = *t1;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep_psi(q, t[n1 / 2]);\n\t\t\t\tif (s0 != s1) {\n\t\t\t\t\tep_neg(q, q);\n\t\t\t\t}\n\t\t\t\tep_add(r, r, q);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep_psi(q, t[-n1 / 2]);\n\t\t\t\tif (s0 != s1) {\n\t\t\t\t\tep_neg(q, q);\n\t\t\t\t}\n\t\t\t\tep_sub(r, r, q);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tbn_free(n)\n\t\tep_free(q);\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\nstatic void ep_mul_naf_imp(ep_t r, const ep_t p, const bn_t k) {\n\t/* Some of the supported prime curves have order > field. */\n\tint8_t u, naf[RLC_FP_BITS + 2];\n\tep_t t[1 << (EP_WIDTH - 2)];\n\tbn_t _k, n;\n\tsize_t l;\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\t/* Prepare the precomputation table. */\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = RLC_FP_BITS + 2;\n\t\tbn_rec_naf(naf, &l, _k, EP_WIDTH);\n\n\t\tep_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\tep_add(r, r, t[u / 2]);\n\t\t\t} else if (u < 0) {\n\t\t\t\tep_sub(r, r, t[-u / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\t/* Free the precomputation table. */\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n#endif /* EP_MUL == LWNAF */\n\n#if EP_MUL == LWREG || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep_mul_reg_glv(ep_t r, const ep_t p, const bn_t k) {\n\tint i, j, n0, n1, s0, s1, b0, b1;\n\tint8_t _s0, _s1, reg0[RLC_FP_BITS + 1], reg1[RLC_FP_BITS + 1];\n\tbn_t n, _k, k0, k1, v1[3], v2[3];\n\tep_t q, t[1 << (EP_WIDTH - 2)], u, v, w;\n\tsize_t l;\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(k0);\n\tbn_null(k1);\n\tep_null(q);\n\tep_null(u);\n\tep_null(v);\n\tep_null(w);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tep_new(q);\n\t\tep_new(u);\n\t\tep_new(v);\n\t\tep_new(w);\n\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\n\t\tbn_abs(_k, k);\n\t\tbn_mod(_k, _k, n);\n\n\t\tbn_rec_glv(k0, k1, _k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\ts0 = bn_sign(k0);\n\t\ts1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\t\tb0 = bn_is_even(k0);\n\t\tb1 = bn_is_even(k1);\n\t\tk0->dp[0] |= b0;\n\t\tk1->dp[0] |= b1;\n\n\t\tep_copy(q, p);\n\t\tep_neg(t[0], p);\n\t\tdv_copy_cond(q->y, t[0]->y, RLC_FP_DIGS, s0 != RLC_POS);\n\t\tep_tab(t, q, EP_WIDTH);\n\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_reg(reg0, &l, k0, bn_bits(n)/2, EP_WIDTH);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_reg(reg1, &l, k1, bn_bits(n)/2, EP_WIDTH);\n\n#if defined(EP_MIXED)\n\t\tfp_set_dig(u->z, 1);\n\t\tfp_set_dig(w->z, 1);\n\t\tu->coord = w->coord = BASIC;\n#else\n\t\tu->coord = w->coord = EP_ADD;\n#endif\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tfor (j = 0; j < EP_WIDTH - 1; j++) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t}\n\n\t\t\tn0 = reg0[i];\n\t\t\t_s0 = (n0 >> 7);\n\t\t\tn0 = ((n0 ^ _s0) - _s0) >> 1;\n\t\t\tn1 = reg1[i];\n\t\t\t_s1 = (n1 >> 7);\n\t\t\tn1 = ((n1 ^ _s1) - _s1) >> 1;\n\n\t\t\tfor (j = 0; j < (1 << (EP_WIDTH - 2)); j++) {\n\t\t\t\tdv_copy_cond(u->x, t[j]->x, RLC_FP_DIGS, j == n0);\n\t\t\t\tdv_copy_cond(w->x, t[j]->x, RLC_FP_DIGS, j == n1);\n\t\t\t\tdv_copy_cond(u->y, t[j]->y, RLC_FP_DIGS, j == n0);\n\t\t\t\tdv_copy_cond(w->y, t[j]->y, RLC_FP_DIGS, j == n1);\n#if !defined(EP_MIXED)\n\t\t\t\tdv_copy_cond(u->z, t[j]->z, RLC_FP_DIGS, j == n0);\n\t\t\t\tdv_copy_cond(w->z, t[j]->z, RLC_FP_DIGS, j == n1);\n#endif\n\t\t\t}\n\t\t\tep_neg(v, u);\n\t\t\tdv_copy_cond(u->y, v->y, RLC_FP_DIGS, _s0 != 0);\n\t\t\tep_add(r, r, u);\n\n\t\t\tep_psi(w, w);\n\t\t\tep_neg(q, w);\n\t\t\tdv_copy_cond(w->y, q->y, RLC_FP_DIGS, s0 != s1);\n\t\t\tep_neg(q, w);\n\t\t\tdv_copy_cond(w->y, q->y, RLC_FP_DIGS, _s1 != 0);\n\t\t\tep_add(r, r, w);\n\t\t}\n\n\t\t/* t[0] has an unmodified copy of p. */\n\t\tep_sub(u, r, t[0]);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, b0);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, b0);\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, b0);\n\n\t\tep_psi(w, t[0]);\n\t\tep_neg(q, w);\n\t\tdv_copy_cond(w->y, q->y, RLC_FP_DIGS, s0 != s1);\n\t\tep_sub(u, r, w);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, b1);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, b1);\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, b1);\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tep_neg(u, r);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_sign(k) == RLC_NEG);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tbn_free(n);\n\t\tep_free(q);\n\t\tep_free(u);\n\t\tep_free(v);\n\t\tep_free(w);\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\nstatic void ep_mul_reg_imp(ep_t r, const ep_t p, const bn_t k) {\n\tbn_t _k;\n\tint i, j, n;\n\tint8_t s, reg[1 + RLC_CEIL(RLC_FP_BITS + 1, EP_WIDTH - 1)];\n\tep_t t[1 << (EP_WIDTH - 2)], u, v;\n\tsize_t l;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(_k);\n\t\tep_new(u);\n\t\tep_new(v);\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(t, p, EP_WIDTH);\n\n\t\tep_curve_get_ord(_k);\n\t\tn = bn_bits(_k);\n\n\t\t/* Make a copy of the scalar for processing. */\n\t\tbn_abs(_k, k);\n\t\t_k->dp[0] |= 1;\n\n\t\t/* Compute the regular w-NAF representation of k. */\n\t\tl = RLC_CEIL(n, EP_WIDTH - 1) + 1;\n\t\tbn_rec_reg(reg, &l, _k, n, EP_WIDTH);\n\n#if defined(EP_MIXED)\n\t\tfp_set_dig(u->z, 1);\n\t\tu->coord = BASIC;\n#else\n\t\tu->coord = EP_ADD;\n#endif\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tfor (j = 0; j < EP_WIDTH - 1; j++) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t}\n\n\t\t\tn = reg[i];\n\t\t\ts = (n >> 7);\n\t\t\tn = ((n ^ s) - s) >> 1;\n\n\t\t\tfor (j = 0; j < (1 << (EP_WIDTH - 2)); j++) {\n\t\t\t\tdv_copy_cond(u->x, t[j]->x, RLC_FP_DIGS, j == n);\n\t\t\t\tdv_copy_cond(u->y, t[j]->y, RLC_FP_DIGS, j == n);\n#if !defined(EP_MIXED)\n\t\t\t\tdv_copy_cond(u->z, t[j]->z, RLC_FP_DIGS, j == n);\n#endif\n\t\t\t}\n\t\t\tep_neg(v, u);\n\t\t\tdv_copy_cond(u->y, v->y, RLC_FP_DIGS, s != 0);\n\t\t\tep_add(r, r, u);\n\t\t}\n\t\t/* t[0] has an unmodified copy of p. */\n\t\tep_sub(u, r, t[0]);\n\t\tdv_copy_cond(r->x, u->x, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_is_even(k));\n\t\tdv_copy_cond(r->z, u->z, RLC_FP_DIGS, bn_is_even(k));\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t\tep_neg(u, r);\n\t\tdv_copy_cond(r->y, u->y, RLC_FP_DIGS, bn_sign(k) == RLC_NEG);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tbn_free(_k);\n\t\tep_free(u);\n\t\tep_free(v);\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n#endif /* EP_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep_mul_basic(ep_t r, const ep_t p, const bn_t k) {\n\tep_t t;\n\n\tep_null(t);\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_copy(t, p);\n\t\tfor (int i = bn_bits(k) - 2; i >= 0; i--) {\n\t\t\tep_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, t);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\nvoid ep_mul_slide(ep_t r, const ep_t p, const bn_t k) {\n\tbn_t _k, n;\n\tep_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tep_null(q);\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\t\tep_new(q);\n\n\t\tep_copy(t[0], p);\n\t\tep_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep_norm(q, q);\n#endif\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep_norm_sim(t + 1, (const ep_t *)t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, _k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, q);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t\tep_free(q);\n\t}\n}\n\n#endif\n#include \"assert.h\"\n#if EP_MUL == MONTY || !defined(STRIP)\n\nvoid ep_mul_monty(ep_t r, const ep_t p, const bn_t k) {\n\tep_t t[2];\n\tbn_t n, l, _k;\n\tsize_t bits;\n\n\tbn_null(n);\n\tbn_null(l);\n\tbn_null(_k);\n\tep_null(t[0]);\n\tep_null(t[1]);\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(l);\n\t\tbn_new(_k);\n\t\tep_new(t[0]);\n\t\tep_new(t[1]);\n\n\t\tep_curve_get_ord(n);\n\t\tbits = bn_bits(n);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_abs(l, _k);\n\t\tbn_add(l, l, n);\n\t\tbn_add(n, l, n);\n\t\tdv_swap_cond(l->dp, n->dp, RLC_MAX(l->used, n->used),\n\t\t\tbn_get_bit(l, bits) == 0);\n\t\tl->used = RLC_SEL(l->used, n->used, bn_get_bit(l, bits) == 0);\n\n\t\tep_norm(t[0], p);\n\t\tep_dbl(t[1], t[0]);\n\n\t\t/* Blind both points independently. */\n\t\tep_blind(t[0], t[0]);\n\t\tep_blind(t[1], t[1]);\n\n\t\tfor (int i = bits - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(l, i);\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n\t\t\tep_add(t[0], t[0], t[1]);\n\t\t\tep_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x, t[1]->x, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y, t[1]->y, RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z, t[1]->z, RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tep_norm(r, t[0]);\n\t\tep_neg(t[0], r);\n\t\tdv_copy_cond(r->y, t[0]->y, RLC_FP_DIGS, bn_sign(_k) == RLC_NEG);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(l);\n\t\tbn_free(_k);\n\t\tep_free(t[1]);\n\t\tep_free(t[0]);\n\t}\n}\n\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\nvoid ep_mul_lwnaf(ep_t r, const ep_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_glv_imp(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep_mul_naf_imp(r, p, k);\n#endif\n}\n\n#endif\n\n#if EP_MUL == LWREG || !defined(STRIP)\n\nvoid ep_mul_lwreg(ep_t r, const ep_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_reg_glv(r, p, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep_mul_reg_imp(r, p, k);\n#endif\n}\n\n#endif\n\nvoid ep_mul_gen(ep_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#ifdef EP_PRECO\n\tep_mul_fix(r, ep_curve_get_tab(), k);\n#else\n\tep_t g;\n\n\tep_null(g);\n\n\tRLC_TRY {\n\t\tep_new(g);\n\t\tep_curve_get_gen(g);\n\t\tep_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(g);\n\t}\n#endif\n}\n\nvoid ep_mul_dig(ep_t r, const ep_t p, dig_t k) {\n\tep_t t;\n\tbn_t _k;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tep_null(t);\n\tbn_null(_k);\n\n\tif (k == 0 || ep_is_infty(p)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\t\tbn_new(_k);\n\n\t\tbn_set_dig(_k, k);\n\n\t\tl = RLC_DIG + 1;\n\t\tbn_rec_naf(naf, &l, _k, 2);\n\n\t\tep_set_infty(t);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(t, t);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\tep_add(t, t, p);\n\t\t\t} else if (u < 0) {\n\t\t\t\tep_sub(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t\tbn_free(_k);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on binary elliptic curves.\n *\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep_mul_fix_plain(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\t/* Compute the w-TNAF representation of k. */\n\tl = RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &l, k, EP_DEPTH);\n\n\tn = naf[l - 1];\n\tif (n > 0) {\n\t\tep_copy(r, t[n / 2]);\n\t} else {\n\t\tep_neg(r, t[-n / 2]);\n\t}\n\n\tfor (i = l - 2; i >= 0; i--) {\n\t\tep_dbl(r, r);\n\n\t\tn = naf[i];\n\t\tif (n > 0) {\n\t\t\tep_add(r, r, t[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep_sub(r, r, t[-n / 2]);\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\tep_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep_neg(r, r);\n\t}\n}\n\n#endif /* EP_FIX == LWNAF */\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\n/**\n * Multiplies a prime elliptic curve point by an integer using the COMBS\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep_mul_combs_endom(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, j, l, w0, w1, n0, n1, p0, p1, s0, s1;\n\tbn_t n, _k, k0, k1, v1[3], v2[3];\n\tep_t u;\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(k0);\n\tbn_null(k1);\n\tep_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tep_new(u);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\t\tl = RLC_CEIL(bn_bits(n), (2 * EP_DEPTH));\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_rec_glv(k0, k1, _k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\ts0 = bn_sign(k0);\n\t\ts1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\n\t\tn0 = bn_bits(k0);\n\t\tn1 = bn_bits(k1);\n\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tep_set_infty(r);\n\t\tif (n0 > p0 + 1) {\n\t\t\tep_copy(r, t[1 << (EP_DEPTH-1)]);\n\t\t}\n\t\tif (n1 > p0 + 1) {\n\t\t\tep_psi(u, t[1 << (EP_DEPTH-1)]);\n\t\t\tep_add(r, r, u);\n\t\t}\n\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tw0 = w1 = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(k0, p1)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t\tif (p1 < n1 && bn_get_bit(k1, p1)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w0 > 0) {\n\t\t\t\tif (s0 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, t[w0]);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, t[w0]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w1 > 0) {\n\t\t\t\tep_psi(u, t[w1]);\n\t\t\t\tif (s1 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, u);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tep_free(u);\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n/**\n * Multiplies a prime elliptic curve point by an integer using the COMBS\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] t\t\t\t\t\t- the precomputed table.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep_mul_combs_plain(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n, _k;\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\tl = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\n\t\tbn_mod(_k, k, n);\n\t\tn0 = bn_bits(_k);\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\n\t\tep_copy(r, t[w]);\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\tep_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n\n#endif /* EP_FIX == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\nvoid ep_mul_pre_basic(ep_t *t, const ep_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\n\t\tep_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\tep_dbl(t[i], t[i - 1]);\n\t\t}\n\n\t\tep_norm_sim(t + 1, (const ep_t *)t + 1, bn_bits(n) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_mul_fix_basic(ep_t r, const ep_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\tep_set_infty(r);\n\t\tfor (int i = 0; i < bn_bits(_k); i++) {\n\t\t\tif (bn_get_bit(_k, i)) {\n\t\t\t\tep_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\nvoid ep_mul_pre_combs(ep_t *t, const ep_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\t\tl = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\n#if defined(EP_ENDOM)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tl = RLC_CEIL(bn_bits(n), 2 * EP_DEPTH);\n\t\t}\n#endif\n\n\t\tep_set_infty(t[0]);\n\n\t\tep_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\tep_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\n\t\tep_norm_sim(t + 2, (const ep_t *)t + 2, RLC_EP_TABLE_COMBS - 2);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_mul_fix_combs(ep_t r, const ep_t *t, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_combs_endom(r, t, k);\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep_mul_combs_plain(r, t, k);\n#endif\n}\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\nvoid ep_mul_pre_combd(ep_t *t, const ep_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\t\td = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep_set_infty(t[0]);\n\t\tep_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\tep_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\tep_set_infty(t[1 << EP_DEPTH]);\n\t\tfor (j = 1; j < (1 << EP_DEPTH); j++) {\n\t\t\tep_dbl(t[(1 << EP_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\tep_dbl(t[(1 << EP_DEPTH) + j], t[(1 << EP_DEPTH) + j]);\n\t\t\t}\n\t\t}\n\n\t\tep_norm_sim(t + 2, (const ep_t *)t + 2, (1 << EP_DEPTH) - 2);\n\t\tep_norm_sim(t + (1 << EP_DEPTH) + 1,\n\t\t\t\t(const ep_t *)t + (1 << EP_DEPTH) + 1, (1 << EP_DEPTH) - 1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_mul_fix_combd(ep_t r, const ep_t *t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\td = RLC_CEIL(bn_bits(n), EP_DEPTH);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tbn_mod(_k, k, n);\n\t\tep_set_infty(r);\n\t\tn0 = bn_bits(_k);\n\n\t\tp1 = (e - 1) + (EP_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_add(r, r, t[w0]);\n\t\t\tep_add(r, r, t[(1 << EP_DEPTH) + w1]);\n\t\t}\n\t\tep_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\nvoid ep_mul_pre_lwnaf(ep_t *t, const ep_t p) {\n\tep_tab(t, p, EP_DEPTH);\n}\n\nvoid ep_mul_fix_lwnaf(ep_t r, const ep_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tep_mul_fix_plain(r, t, _k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on binary elliptic\n * curves.\n *\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_SIM == INTER || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep_mul_sim_endom(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m, const ep_t *t) {\n\tint i, sk0, sk1, sl0, sl1, w, g = 0;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *t0, *t1, u;\n\tint8_t naf2[RLC_FP_BITS + 1], naf3[RLC_FP_BITS + 1], *t2, *t3;\n\tbn_t n, k0, k1, m0, m1;\n\tbn_t v1[3], v2[3];\n\tep_t v;\n\tep_t tab0[1 << (EP_WIDTH - 2)];\n\tep_t tab1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1, l2, l3;\n\n\tbn_null(n);\n\tbn_null(k0);\n\tbn_null(k1);\n\tbn_null(m0);\n\tbn_null(m1);\n\tep_null(v);\n\n\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\tep_null(tab0[i]);\n\t\tep_null(tab1[i]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(k0);\n\t\tbn_new(k1);\n\t\tbn_new(m0);\n\t\tbn_new(m1);\n\t\tep_new(v);\n\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_null(v1[i]);\n\t\t\tbn_null(v2[i]);\n\t\t\tbn_new(v1[i]);\n\t\t\tbn_new(v2[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tep_curve_get_v1(v1);\n\t\tep_curve_get_v2(v2);\n\n\t\tbn_rec_glv(k0, k1, k, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\tsk0 = bn_sign(k0);\n\t\tsk1 = bn_sign(k1);\n\t\tbn_abs(k0, k0);\n\t\tbn_abs(k1, k1);\n\n\t\tbn_rec_glv(m0, m1, m, n, (const bn_t *)v1, (const bn_t *)v2);\n\t\tsl0 = bn_sign(m0);\n\t\tsl1 = bn_sign(m1);\n\t\tbn_abs(m0, m0);\n\t\tbn_abs(m1, m1);\n\n\t\tg = (t == NULL ? 0 : 1);\n\t\tif (!g) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep_new(tab0[i]);\n\t\t\t}\n\t\t\tep_tab(tab0, p, EP_WIDTH);\n\t\t\tt = (const ep_t *)tab0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_new(tab1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(tab1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k and l */\n\t\tif (g) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = l2 = l3 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k0, w);\n\t\tbn_rec_naf(naf1, &l1, k1, w);\n\t\tbn_rec_naf(naf2, &l2, m0, EP_WIDTH);\n\t\tbn_rec_naf(naf3, &l3, m1, EP_WIDTH);\n\n\t\tl = RLC_MAX(RLC_MAX(l0, l1), RLC_MAX(l2, l3));\n\t\tt0 = naf0 + l - 1;\n\t\tt1 = naf1 + l - 1;\n\t\tt2 = naf2 + l - 1;\n\t\tt3 = naf3 + l - 1;\n\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l2; i++) {\n\t\t\t\tnaf2[i] = -naf2[i];\n\t\t\t}\n\t\t\tfor (i =  0; i < l3; i++) {\n\t\t\t\tnaf3[i] = -naf3[i];\n\t\t\t}\n\t\t}\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, t0--, t1--, t2--, t3--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tu = *t0;\n\t\t\tif (u > 0) {\n\t\t\t\tif (sk0 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, t[u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, t[u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tif (sk0 == RLC_POS) {\n\t\t\t\t\tep_sub(r, r, t[-u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, t[-u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu = *t1;\n\t\t\tif (u > 0) {\n\t\t\t\tep_psi(v, t[u / 2]);\n\t\t\t\tif (sk1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_add(r, r, v);\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tep_psi(v, t[-u / 2]);\n\t\t\t\tif (sk1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_sub(r, r, v);\n\t\t\t}\n\n\t\t\tu = *t2;\n\t\t\tif (u > 0) {\n\t\t\t\tif (sl0 == RLC_POS) {\n\t\t\t\t\tep_add(r, r, tab1[u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_sub(r, r, tab1[u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tif (sl0 == RLC_POS) {\n\t\t\t\t\tep_sub(r, r, tab1[-u / 2]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, tab1[-u / 2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tu = *t3;\n\t\t\tif (u > 0) {\n\t\t\t\tep_psi(v, tab1[u / 2]);\n\t\t\t\tif (sl1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_add(r, r, v);\n\t\t\t}\n\t\t\tif (u < 0) {\n\t\t\t\tep_psi(v, tab1[-u / 2]);\n\t\t\t\tif (sl1 == RLC_NEG) {\n\t\t\t\t\tep_neg(v, v);\n\t\t\t\t}\n\t\t\t\tep_sub(r, r, v);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(k0);\n\t\tbn_free(k1);\n\t\tbn_free(m0);\n\t\tbn_free(m1);\n\t\tep_free(v);\n\n\t\tif (!g) {\n\t\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\t\tep_free(tab0[i]);\n\t\t\t}\n\t\t}\n\t\t/* Free the precomputation tables. */\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(tab1[i]);\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbn_free(v1[i]);\n\t\t\tbn_free(v2[i]);\n\t\t}\n\t}\n}\n\n/**\n * Multiplies and adds multiple elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep_mul_sim_lot_endom(ep_t r, const ep_t p[], const bn_t k[], int n) {\n\tconst int len = RLC_FP_BITS + 1;\n\tint i, j, m, sk;\n\tbn_t _k[2], q, v1[3], v2[3];\n\tint8_t ptr, *naf = RLC_ALLOCA(int8_t, 2 * n * len);\n\tsize_t l, _l[2];\n\n\tbn_null(q);\n\n\tif (n <= 10) {\n\t\tep_t *_p = RLC_ALLOCA(ep_t, 2 * n);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tbn_null(_k[j]);\n\t\t\t\tbn_new(_k[j]);\n\t\t\t}\n\t\t\tfor (i = 0; i < 2 * n; i++) {\n\t\t\t\tep_null(_p[i]);\n\t\t\t\tep_new(_p[i]);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_null(v1[i]);\n\t\t\t\tbn_null(v2[i]);\n\t\t\t\tbn_new(v1[i]);\n\t\t\t\tbn_new(v2[i]);\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep_curve_get_ord(q);\n\t\t\tep_curve_get_v1(v1);\n\t\t\tep_curve_get_v2(v2);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tep_norm(_p[2*i], p[i]);\n\t\t\t\tep_psi(_p[2*i + 1], _p[2*i]);\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tsk = bn_sign(_k[0]);\n\t\t\t\tbn_rec_glv(_k[0], _k[1], _k[0], q, (const bn_t *)v1, (const bn_t *)v2);\n\t\t\t\tif (sk == RLC_NEG) {\n\t\t\t\t\tbn_neg(_k[0], _k[0]);\n\t\t\t\t\tbn_neg(_k[1], _k[1]);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(2*i + j)*len], &_l[j], _k[j], 2);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tep_neg(_p[2*i + j], _p[2*i + j]);\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_set_infty(r);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 2; m++) {\n\t\t\t\t\t\tif (naf[(2*j + m)*len + i] > 0) {\n\t\t\t\t\t\t\tep_add(r, r, _p[2*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[(2*j + m)*len + i] < 0) {\n\t\t\t\t\t\t\tep_sub(r, r, _p[2*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tep_norm(r, r);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(_k[0]);\n\t\t\tbn_free(_k[1]);\n\t\t\tfor (i = 0; i < 2 * n; i++) {\n\t\t\t\tep_free(_p[i]);\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_free(v1[i]);\n\t\t\t\tbn_free(v2[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconst int w = RLC_MAX(2, util_bits_dig(n) - 2), c = (1 << (w - 2));\n\t\tep_t s, t, u, v, *_p = RLC_ALLOCA(ep_t, 2 * c);\n\n\t\tep_null(s);\n\t\tep_null(t);\n\t\tep_null(u);\n\t\tep_null(v);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tep_new(s);\n\t\t\tep_new(t);\n\t\t\tep_new(u);\n\t\t\tep_new(v);\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tbn_null(_k[i]);\n\t\t\t\tbn_new(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep_null(_p[i*c + j]);\n\t\t\t\t\tep_new(_p[i*c + j]);\n\t\t\t\t\tep_set_infty(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_null(v1[i]);\n\t\t\t\tbn_null(v2[i]);\n\t\t\t\tbn_new(v1[i]);\n\t\t\t\tbn_new(v2[i]);\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep_curve_get_ord(q);\n\t\t\tep_curve_get_v1(v1);\n\t\t\tep_curve_get_v2(v2);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tsk = bn_sign(_k[0]);\n\t\t\t\tbn_rec_glv(_k[0], _k[1], _k[0], q, (const bn_t *)v1, (const bn_t *)v2);\n\t\t\t\tif (sk == RLC_NEG) {\n\t\t\t\t\tbn_neg(_k[0], _k[0]);\n\t\t\t\t\tbn_neg(_k[1], _k[1]);\n\t\t\t\t}\n\t\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(2*i + j)*len], &_l[j], _k[j], w);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tfor (m = 0; m < _l[j]; m++) {\n\t\t\t\t\t\t\tnaf[(2*i + j)*len + m] = -naf[(2*i + j)*len + m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_set_infty(s);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 2; m++) {\n\t\t\t\t\t\tptr = naf[(2*j + m)*len + i];\n\t\t\t\t\t\tif (ptr != 0) {\n\t\t\t\t\t\t\tep_copy(t, p[j]);\n\t\t\t\t\t\t\tif (ptr < 0) {\n\t\t\t\t\t\t\t\tptr = -ptr;\n\t\t\t\t\t\t\t\tep_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tep_add(_p[m*c + (ptr >> 1)], _p[m*c + (ptr >> 1)], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tep_set_infty(t);\n\t\t\t\tfor (m = 1; m >= 0; m--) {\n\t\t\t\t\tep_psi(t, t);\n\t\t\t\t\tep_set_infty(u);\n\t\t\t\t\tep_set_infty(v);\n\t\t\t\t\tfor (j = c - 1; j >= 0; j--) {\n\t\t\t\t\t\tep_add(u, u, _p[m*c + j]);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tep_dbl(v, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tep_add(v, v, u);\n\t\t\t\t\t\tep_set_infty(_p[m*c + j]);\n\t\t\t\t\t}\n\t\t\t\t\tep_add(t, t, v);\n\t\t\t\t}\n\t\t\t\tep_dbl(s, s);\n\t\t\t\tep_add(s, s, t);\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep_norm(r, s);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tep_free(s);\n\t\t\tep_free(t);\n\t\t\tep_free(u);\n\t\t\tep_free(v);\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\tbn_free(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep_free(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tbn_free(v1[i]);\n\t\t\t\tbn_free(v2[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep_mul_sim_plain(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m, const ep_t *t) {\n\tint i, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], n0, n1, *u, *v;\n\tep_t t0[1 << (EP_WIDTH - 2)];\n\tep_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep_null(t0[i]);\n\t\t\t\tep_new(t0[i]);\n\t\t\t}\n\t\t\tep_tab(t0, p, EP_WIDTH);\n\t\t\tt = (const ep_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep_null(t1[i]);\n\t\t\tep_new(t1[i]);\n\t\t}\n\n\t\t/* Compute the precomputation table. */\n\t\tep_tab(t1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\tu = naf0 + l - 1;\n\t\tv = naf1 + l - 1;\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, u--, v--) {\n\t\t\tep_dbl(r, r);\n\n\t\t\tn0 = *u;\n\t\t\tn1 = *v;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\t\tep_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 1 << (EP_WIDTH - 2); i++) {\n\t\t\tep_free(t1[i]);\n\t\t}\n\t}\n}\n\n/**\n * Multiplies and adds multiple elliptic curve points simultaneously.\n * Computes R = \\Sum_i=0..n [k_i]P_i.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] p\t\t\t- the elements to multiply.\n * @param[out] k\t\t\t- the integer scalars.\n * @param[out] n\t\t\t- the number of elements to multiply.\n */\nvoid ep_mul_sim_lot_plain(ep_t r, const ep_t p[], const bn_t k[], int n) {\n\tint i, j;\n\tint8_t *naf = NULL;\n\tep_t *_p = RLC_ALLOCA(ep_t, n);\n\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep_new(_p[i]);\n\t\t}\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\t_l[i] = l;\n\t\t\tep_norm(_p[i], p[i]);\n\t\t\tbn_rec_naf(&naf[i*l], &_l[i], k[i], 2);\n\t\t\tif (bn_sign(k[i]) == RLC_NEG) {\n\t\t\t\tep_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t}\n\n\t\tep_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (naf[j*l + i] > 0) {\n\t\t\t\t\tep_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf[j*l + i] < 0) {\n\t\t\t\t\tep_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tep_free(_p[i]);\n\t\t}\n\t\tRLC_FREE(_l);\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(naf);\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n\n#endif /* EP_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\nvoid ep_mul_sim_basic(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tep_t t;\n\n\tep_null(t);\n\n\tRLC_TRY {\n\t\tep_new(t);\n\t\tep_mul(t, q, m);\n\t\tep_mul(r, p, k);\n\t\tep_add(t, t, r);\n\t\tep_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\nvoid ep_mul_sim_trick(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tep_t t0[1 << (EP_WIDTH / 2)], t1[1 << (EP_WIDTH / 2)], t[1 << EP_WIDTH];\n\tbn_t n, _k, _m;\n\tsize_t l0, l1, w = EP_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep_null(t0[i]);\n\t\t\tep_null(t1[i]);\n\t\t\tep_new(t0[i]);\n\t\t\tep_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tep_set_infty(t0[0]);\n\t\tep_copy(t0[1], p);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\tep_set_infty(t1[0]);\n\t\tep_copy(t1[1], q);\n\t\tif (bn_sign(_m) == RLC_NEG) {\n\t\t\tep_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\tep_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if EP_WIDTH > 2 && defined(EP_MIXED)\n\t\tep_norm_sim(t + 1, (const ep_t *)(t + 1), (1 << EP_WIDTH) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(RLC_FP_BITS + 1, w);\n\t\tbn_rec_win(w0, &l0, _k, w);\n\t\tbn_rec_win(w1, &l1, _m, w);\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\tep_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tep_dbl(r, r);\n\t\t\t}\n\t\t\tep_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\tep_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep_free(t0[i]);\n\t\t\tep_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\nvoid ep_mul_sim_inter(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tint flag = 0;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\t/* Handle this here to reduce complexity of static functions. */\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep_mul_sim_endom(r, p, _k, q, _m, NULL);\n\t\t\tflag = 1;\n\t\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\t\tif (!flag) {\n\t\t\tep_mul_sim_plain(r, p, _k, q, _m, NULL);\n\t\t}\n#endif\n\t\t(void)flag;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\nvoid ep_mul_sim_joint(ep_t r, const ep_t p, const bn_t k, const ep_t q,\n\t\tconst bn_t m) {\n\tbn_t n, _k, _m;\n\tep_t t[5];\n\tint i, u_i, offset;\n\tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n\tsize_t l;\n\n\tif (bn_is_zero(k) || ep_is_infty(p)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep_null(t[i]);\n\t\t\tep_new(t[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tep_set_infty(t[0]);\n\t\tep_copy(t[1], q);\n\t\tif (bn_sign(_m) == RLC_NEG) {\n\t\t\tep_neg(t[1], t[1]);\n\t\t}\n\t\tep_copy(t[2], p);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep_neg(t[2], t[2]);\n\t\t}\n\t\tep_add(t[3], t[2], t[1]);\n\t\tep_sub(t[4], t[2], t[1]);\n#if defined(EP_MIXED)\n\t\tep_norm_sim(t + 3, (const ep_t *)t + 3, 2);\n#endif\n\n\t\tl = 2 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, _k, _m);\n\n\t\tep_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(_k), bn_bits(_m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\tep_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ep_mul_sim_gen(ep_t r, const bn_t k, const ep_t q, const bn_t m) {\n\tep_t g;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k)) {\n\t\tep_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep_is_infty(q)) {\n\t\tep_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tep_null(g);\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tep_new(g);\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tep_curve_get_gen(g);\n\t\tep_curve_get_ord(n);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep_mul_sim_endom(r, g, _k, q, _m, ep_curve_get_tab());\n\t\t}\n#else\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep_mul_sim_plain(r, g, _k, q, _m, ep_curve_get_tab());\n\t\t}\n#else\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(g);\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\nvoid ep_mul_sim_dig(ep_t r, const ep_t p[], const dig_t k[], int n) {\n\tep_t t;\n\tint max;\n\n\tep_null(t);\n\n\tmax = util_bits_dig(k[0]);\n\tfor (int i = 1; i < n; i++) {\n\t\tmax = RLC_MAX(max, util_bits_dig(k[i]));\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_set_infty(t);\n\t\tfor (int i = max - 1; i >= 0; i--) {\n\t\t\tep_dbl(t, t);\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (k[j] & ((dig_t)1 << i)) {\n\t\t\t\t\tep_add(t, t, p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tep_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n\nvoid ep_mul_sim_lot(ep_t r, const ep_t p[], const bn_t k[], int n) {\n\tint flag = 0;\n\n\tif (n == 0) {\n\t\tep_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tep_mul_sim_lot_endom(r, p, k, n);\n\t\tflag = 1;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tif (!flag) {\n\t\tep_mul_sim_lot_plain(r, p, k, n);\n\t}\n#endif\n\t(void)flag;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime elliptic curve utilities.\n *\n * @version $Id$\n * @ingroup ep\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ep_is_infty(const ep_t p) {\n\treturn (fp_is_zero(p->z) == 1);\n}\n\nvoid ep_set_infty(ep_t p) {\n\tfp_zero(p->x);\n\tfp_zero(p->y);\n\tfp_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid ep_copy(ep_t r, const ep_t p) {\n\tfp_copy(r->x, p->x);\n\tfp_copy(r->y, p->y);\n\tfp_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid ep_rand(ep_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tep_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\tep_mul_gen(p, k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep_blind(ep_t r, const ep_t p) {\n\tfp_t rand;\n\n\tfp_null(rand);\n\n\tRLC_TRY {\n\t\tfp_new(rand);\n\t\tfp_rand(rand);\n#if EP_ADD == BASIC\n\t\t(void)rand;\n\t\tep_copy(r, p);\n#elif EP_ADD == PROJC\n\t\tfp_mul(r->x, p->x, rand);\n\t\tfp_mul(r->y, p->y, rand);\n\t\tfp_mul(r->z, p->z, rand);\n\t\tr->coord = PROJC;\n#elif EP_ADD == JACOB\n\t\tfp_mul(r->z, p->z, rand);\n\t\tfp_mul(r->y, p->y, rand);\n\t\tfp_sqr(rand, rand);\n\t\tfp_mul(r->x, r->x, rand);\n\t\tfp_mul(r->y, r->y, rand);\n\t\tr->coord = JACOB;\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(rand);\n\t}\n}\n\nvoid ep_rhs(fp_t rhs, const ep_t p) {\n\tfp_t t0;\n\n\tfp_null(t0);\n\n\tRLC_TRY {\n\t\tfp_new(t0);\n\n\t\t/* t0 = x1^2. */\n\t\tfp_sqr(t0, p->x);\n\n\t\t/* t0 = x1^2 + a */\n\t\tswitch (ep_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp_add_dig(t0, t0, ep_curve_get_a()[0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp_add(t0, t0, ep_curve_get_a());\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* t0 = x1^3 + a * x */\n\t\tfp_mul(t0, t0, p->x);\n\n\t\t/* t0 = x1^3 + a * x + b */\n\t\tswitch (ep_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp_add_dig(t0, t0, ep_curve_get_b()[0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp_add(t0, t0, ep_curve_get_b());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp_copy(rhs, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp_free(t0);\n\t}\n}\n\nint ep_on_curve(const ep_t p) {\n\tep_t t;\n\tint r = 0;\n\n\tep_null(t);\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_norm(t, p);\n\t\tep_rhs(t->x, t);\n\t\tfp_sqr(t->y, t->y);\n\t\tr = (fp_cmp(t->x, t->y) == RLC_EQ) || ep_is_infty(p);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep_free(t);\n\t}\n\treturn r;\n}\n\nvoid ep_tab(ep_t *t, const ep_t p, int w) {\n\tif (w > 2) {\n\t\tep_dbl(t[0], p);\n#if defined(EP_MIXED)\n\t\tep_norm(t[0], t[0]);\n#endif\n\t\tep_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\tep_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(EP_MIXED)\n\t\tep_norm_sim(t + 1, (const ep_t *)t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\tep_copy(t[0], p);\n}\n\nvoid ep_print(const ep_t p) {\n\tfp_print(p->x);\n\tfp_print(p->y);\n\tfp_print(p->z);\n}\n\nint ep_size_bin(const ep_t a, int pack) {\n\tint size = 0;\n\n\tif (ep_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tsize = 1 + RLC_FP_BYTES;\n\tif (!pack) {\n\t\tsize += RLC_FP_BYTES;\n\t}\n\n\treturn size;\n}\n\nvoid ep_read_bin(ep_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (RLC_FP_BYTES + 1) && len != (2 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp_set_dig(a->z, 1);\n\tfp_read_bin(a->x, bin + 1, RLC_FP_BYTES);\n\tif (len == RLC_FP_BYTES + 1) {\n\t\tswitch(bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfp_zero(a->y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfp_zero(a->y);\n\t\t\t\tfp_set_bit(a->y, 0, 1);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\tep_upk(a, a);\n\t}\n\n\tif (len == 2 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp_read_bin(a->y, bin + RLC_FP_BYTES + 1, RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ep_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\nvoid ep_write_bin(uint8_t *bin, size_t len, const ep_t a, int pack) {\n\tep_t t;\n\n\tep_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ep_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\tep_new(t);\n\n\t\tep_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tep_pck(t, t);\n\t\t\t\tbin[0] = 2 | fp_get_bit(t->y, 0);\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->x);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfp_write_bin(bin + 1, RLC_FP_BYTES, t->x);\n\t\t\t\tfp_write_bin(bin + RLC_FP_BYTES + 1, RLC_FP_BYTES, t->y);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve over a quadratic\n * extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"relic_tmpl_map.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#ifdef EP_CTMAP\n/**\n * Evaluate a polynomial represented by its coefficients using Horner's rule.\n *\n * @param[out] c\t\t\t- the result.\n * @param[in] a\t\t\t\t- the input value.\n * @param[in] coeffs\t\t- the vector of coefficients in the polynomial.\n * @param[in] len\t\t\t- the degree of the polynomial.\n */\nTMPL_MAP_HORNER(fp2, fp2_t)\n/**\n * Generic isogeny map evaluation for use with SSWU map.\n */\nTMPL_MAP_ISOGENY_MAP(ep2, fp2, iso2)\n#endif /* EP_CTMAP */\n/**\n * Simplified SWU mapping.\n */\n#define EP2_MAP_COPY_COND(O, I, C)\t\t\t\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdv_copy_cond(O[0], I[0], RLC_FP_DIGS, C);\t\t\t\t\t\t\t\\\n\t\tdv_copy_cond(O[1], I[1], RLC_FP_DIGS, C);\t\t\t\t\t\t\t\\\n\t} while (0)\nTMPL_MAP_SSWU(ep2, fp2, fp_t, EP2_MAP_COPY_COND)\n/**\n * Shallue--van de Woestijne map.\n */\nTMPL_MAP_SVDW(ep2, fp2, fp_t, EP2_MAP_COPY_COND)\n#undef EP2_MAP_COPY_COND\n/* caution: this function overwrites k, which it uses as an auxiliary variable */\nstatic inline int fp2_sgn0(const fp2_t t, bn_t k) {\n\tconst int t_0_zero = fp_is_zero(t[0]);\n\n\tfp_prime_back(k, t[0]);\n\tconst int t_0_neg = bn_get_bit(k, 0);\n\n\tfp_prime_back(k, t[1]);\n\tconst int t_1_neg = bn_get_bit(k, 0);\n\n\t/* t[0] == 0 ? sgn0(t[1]) : sgn0(t[0]) */\n\treturn t_0_neg | (t_0_zero & t_1_neg);\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep2_map_from_field(ep2_t p, const uint8_t *uniform_bytes, size_t len) {\n\tbn_t k;\n\tfp2_t t;\n\tep2_t q;\n\tint neg;\n\t/* enough space for two extension field elements plus extra bytes for uniformity */\n\tconst int lpe = (FP_PRIME + ep_param_level() + 7) / 8;\n\n\tbn_null(k);\n\tfp2_null(t);\n\tep2_null(q);\n\n\tRLC_TRY {\n\t\tif (len != 2 * lpe) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\n\t\tbn_new(k);\n\t\tfp2_new(t);\n\t\tep2_new(q);\n\n\t\t/* which hash function should we use? */\n\t\tconst int abNeq0 = (ep2_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep2_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep2_t, fp2_t) = (ep2_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep2_map_sswu : ep2_map_svdw;\n\n#define EP2_MAP_CONVERT_BYTES(IDX)\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tbn_read_bin(k, uniform_bytes + 2 * IDX * lpe, lpe);\t\t\t\t\\\n\t\t\tfp_prime_conv(t[0], k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tbn_read_bin(k, uniform_bytes + (2 * IDX + 1) * lpe, lpe);\t\t\\\n\t\t\tfp_prime_conv(t[1], k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t    } while (0)\n\n#define EP2_MAP_APPLY_MAP(PT)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            /* sign of t */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            neg = fp2_sgn0(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n            /* convert */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            map_fn(PT, t);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n            /* compare sign of y to sign of t; fix if necessary */\t\t\t\\\n            neg = neg != fp2_sgn0(PT->y, k);\t\t\t\t\t\t\t\t\\\n            fp2_neg(t, PT->y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n            dv_copy_cond(PT->y[0], t[0], RLC_FP_DIGS, neg);\t\t\t\t\t\\\n            dv_copy_cond(PT->y[1], t[1], RLC_FP_DIGS, neg);\t\t\t\t\t\\\n\t\t} while (0)\n\n\t\t/* first map invocation */\n\t\tEP2_MAP_CONVERT_BYTES(0);\n\t\tEP2_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep2, p);\n\n\t\t/* second map invocation */\n\t\tEP2_MAP_CONVERT_BYTES(1);\n\t\tEP2_MAP_APPLY_MAP(q);\n\t\tTMPL_MAP_CALL_ISOMAP(ep2, q);\n\n\t\t/* XXX(rsw) could add p and q and then apply isomap,\n\t\t * but need ep_add to support addition on isogeny curves */\n\n#undef EP2_MAP_CONVERT_BYTES\n#undef EP2_MAP_APPLY_MAP\n\n\t\t/* sum the result */\n\t\tep2_add(p, p, q);\n\t\tep2_norm(p, p);\n\t\tep2_mul_cof(p, p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tfp2_free(t);\n\t\tep2_free(q);\n\t}\n}\n\n\nvoid ep2_map_dst(ep2_t p, const uint8_t *msg, size_t len, const uint8_t *dst,\n\t\tsize_t dst_len) {\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int lpe = (FP_PRIME + ep_param_level() + 7) / 8;\n\tuint8_t *pseudo_random_bytes = RLC_ALLOCA(uint8_t, 4 * lpe);\n\n\tRLC_TRY {\n\t\t/* XXX(rsw) See note in ep/relic_ep_map.c about using MD_MAP. */\n\t\t/* hash to a pseudorandom string using md_xmd */\n\t\tmd_xmd(pseudo_random_bytes, 4 * lpe, msg, len, dst, dst_len);\n\t\tep2_map_from_field(p, pseudo_random_bytes, 2 * lpe);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tRLC_FREE(pseudo_random_bytes);\n\t}\n}\n\nvoid ep2_map(ep2_t p, const uint8_t *msg, size_t len) {\n\tep2_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of point multiplication on prime elliptic curves over\n * quadratic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep2_mul_glv_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l, _l[4];\n\tbn_t n, _k[4], u;\n\tint8_t naf[4][RLC_FP_BITS + 1];\n\tep2_t q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tep2_null(q[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tep2_new(q[i]);\n\t\t}\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tep2_norm(q[0], p);\n\t\tep2_frb(q[1], q[0], 1);\n\t\tep2_frb(q[2], q[1], 1);\n\t\tep2_frb(q[3], q[2], 1);\n\n\t\tl = 0;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(q[i], q[i]);\n\t\t\t}\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf[i], &_l[i], _k[i], 2);\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int j = l - 1; j >= 0; j--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (naf[i][j] > 0) {\n\t\t\t\t\tep2_add(r, r, q[i]);\n\t\t\t\t}\n\t\t\t\tif (naf[i][j] < 0) {\n\t\t\t\t\tep2_sub(r, r, q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tep2_free(q[i]);\n\t\t}\n\n\t}\n}\n\n#endif /* EP_ENDOM */\n\nstatic void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep2_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep2_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep2_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tep2_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l;\n\tep2_t t;\n\n\tep2_null(t);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tl = bn_bits(k);\n\n\t\tif (bn_get_bit(k, l - 1)) {\n\t\t\tep2_copy(t, p);\n\t\t} else {\n\t\t\tep2_set_infty(t);\n\t\t}\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep2_copy(r, t);\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\nvoid ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n\n\t\tep2_copy(t[0], p);\n\t\tep2_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}\n\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\nvoid ep2_mul_monty(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[2];\n\n\tep2_null(t[0]);\n\tep2_null(t[1]);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t[0]);\n\t\tep2_new(t[1]);\n\n\t\tep2_set_infty(t[0]);\n\t\tep2_copy(t[1], p);\n\n\t\tfor (int i = bn_bits(k) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(k, i);\n\t\t\tdv_swap_cond(t[0]->x[0], t[1]->x[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1], t[1]->x[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0], t[1]->y[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1], t[1]->y[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0], t[1]->z[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1], t[1]->z[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tep2_add(t[0], t[0], t[1]);\n\t\t\tep2_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x[0], t[1]->x[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1], t[1]->x[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0], t[1]->y[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1], t[1]->y[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0], t[1]->z[0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1], t[1]->z[1], RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tep2_norm(r, t[0]);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t[1]);\n\t\tep2_free(t[0]);\n\t}\n}\n\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\nvoid ep2_mul_lwnaf(ep2_t r, const ep2_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tif (ep2_curve_opt_a() == RLC_ZERO) {\n\t\t\tep2_mul_glv_imp(r, p, k);\n\t\t} else {\n\t\t\tep2_mul_naf_imp(r, p, k);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep2_mul_naf_imp(r, p, k);\n#endif\n}\n\n#endif\n\nvoid ep2_mul_gen(ep2_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n#ifdef EP_PRECO\n\tep2_mul_fix(r, ep2_curve_get_tab(), k);\n#else\n\tep2_t g;\n\n\tep2_null(g);\n\n\tRLC_TRY {\n\t\tep2_new(g);\n\t\tep2_curve_get_gen(g);\n\t\tep2_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(g);\n\t}\n#endif\n}\n\nvoid ep2_mul_dig(ep2_t r, const ep2_t p, const dig_t k) {\n\tep2_t t;\n\tbn_t _k;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tep2_null(t);\n\tbn_null(_k);\n\n\tif (k == 0 || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tbn_new(_k);\n\n\t\tbn_set_dig(_k, k);\n\n\t\tl = RLC_DIG + 1;\n\t\tbn_rec_naf(naf, &l, _k, 2);\n\n\t\tep2_set_infty(t);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\n\t\t\tu = naf[i];\n\t\t\tif (u > 0) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t} else if (u < 0) {\n\t\t\t\tep2_sub(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t\tbn_free(_k);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on a prime elliptic curve over\n * a quadratic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep2_mul_fix_plain(ep2_t r, const ep2_t *table, const bn_t k) {\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\tsize_t len;\n\tint n;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\t/* Compute the w-TNAF representation of k. */\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep2_set_infty(r);\n\tfor (int i = len - 1; i >= 0; i--, t--) {\n\t\tep2_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep2_add(r, r, table[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep2_sub(r, r, table[-n / 2]);\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\tep2_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep2_neg(r, r);\n\t}\n}\n\n#endif /* EP_FIX == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\nvoid ep2_mul_pre_basic(ep2_t *t, const ep2_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\n\t\tep2_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\tep2_dbl(t[i], t[i - 1]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_mul_fix_basic(ep2_t r, const ep2_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = 0; i < bn_bits(_k); i++) {\n\t\t\tif (bn_get_bit(_k, i)) {\n\t\t\t\tep2_add(r, r, t[i]);\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\nvoid ep2_mul_pre_combs(ep2_t *t, const ep2_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tep2_set_infty(t[0]);\n\n\t\tep2_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep2_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\tep2_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep2_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep2_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBS; i++) {\n\t\t\tep2_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_mul_fix_combs(ep2_t r, const ep2_t *t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tbn_mod(_k, k, n);\n\t\tn0 = bn_bits(_k);\n\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\t\tep2_copy(r, t[w]);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(_k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\tep2_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\nvoid ep2_mul_pre_combd(ep2_t *t, const ep2_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep2_set_infty(t[0]);\n\t\tep2_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep2_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\tep2_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep2_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep2_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\tep2_set_infty(t[1 << EP_DEPTH]);\n\t\tfor (j = 1; j < (1 << EP_DEPTH); j++) {\n\t\t\tep2_dbl(t[(1 << EP_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\tep2_dbl(t[(1 << EP_DEPTH) + j], t[(1 << EP_DEPTH) + j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBD; i++) {\n\t\t\tep2_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_mul_fix_combd(ep2_t r, const ep2_t *t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep2_set_infty(r);\n\t\tbn_mod(_k, k, n);\n\t\tn0 = bn_bits(_k);\n\n\t\tp1 = (e - 1) + (EP_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(_k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep2_add(r, r, t[w0]);\n\t\t\tep2_add(r, r, t[(1 << EP_DEPTH) + w1]);\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\nvoid ep2_mul_pre_lwnaf(ep2_t *t, const ep2_t p) {\n\tep2_tab(t, p, EP_DEPTH);\n}\n\nvoid ep2_mul_fix_lwnaf(ep2_t r, const ep2_t *t, const bn_t k) {\n\tbn_t n, _k;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tep2_mul_fix_plain(r, t, _k);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on a prime elliptic\n * curve over a quadratic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_SIM == INTER || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tsize_t l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tep2_norm(_p[0], p);\n\t\tep2_frb(_p[1], _p[0], 1);\n\t\tep2_frb(_p[2], _p[1], 1);\n\t\tep2_frb(_p[3], _p[2], 1);\n\t\tep2_norm(_q[0], q);\n\t\tep2_frb(_q[1], _q[0], 1);\n\t\tep2_frb(_q[2], _q[1], 1);\n\t\tep2_frb(_q[3], _q[2], 1);\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf1[i], &_l[i], _m[i], 2);\n\t\t\tif (bn_sign(_m[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_q[i], _q[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_ENDOM */\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n\t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep2_t t0[1 << (EP_WIDTH - 2)];\n\tep2_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep2_null(t0[i]);\n\t\t\t\tep2_new(t0[i]);\n\t\t\t}\n\t\t\tep2_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep2_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t1[i]);\n\t\t\tep2_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep2_tab(t1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = 2 * RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep2_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep2_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep2_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep2_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep2_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_PLAIN || EP_SUPER */\n\n#endif /* EP_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\nvoid ep2_mul_sim_basic(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t l) {\n\tep2_t t;\n\n\tep2_null(t);\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tep2_mul(t, q, l);\n\t\tep2_mul(r, p, k);\n\t\tep2_add(t, t, r);\n\t\tep2_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\nvoid ep2_mul_sim_trick(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t m) {\n\tep2_t t0[1 << (EP_WIDTH / 2)];\n\tep2_t t1[1 << (EP_WIDTH / 2)];\n\tep2_t t[1 << EP_WIDTH];\n\tbn_t n, _k, _m;\n\tsize_t l0, l1, w = EP_WIDTH / 2;\n\tuint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep2_null(t0[i]);\n\t\t\tep2_null(t1[i]);\n\t\t\tep2_new(t0[i]);\n\t\t\tep2_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_set_infty(t0[0]);\n\t\tep2_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep2_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\tep2_set_infty(t1[0]);\n\t\tep2_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tep2_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 1; i < (1 << w); i++) {\n\t\t\tep2_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\tep2_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH)) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(2 * RLC_FP_BITS, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tep2_dbl(r, r);\n\t\t\t}\n\t\t\tep2_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep2_free(t0[i]);\n\t\t\tep2_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\nvoid ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t m) {\n\tint flag = 0;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\t/* Handle this here to reduce complexity of static functions. */\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep2_mul_sim_endom(r, p, _k, q, _m);\n\t\t\tflag = 1;\n\t\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\t\tif (!flag) {\n\t\t\tep2_mul_sim_plain(r, p, _k, q, _m, NULL);\n\t\t}\n#endif\n\t\t(void)flag;\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\nvoid ep2_mul_sim_joint(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,\n\t\tconst bn_t m) {\n\tbn_t n, _k, _m;\n\tep2_t t[5];\n\tint i, u_i, offset;\n\tint8_t jsf[2 * (RLC_FP_BITS + 1)];\n\tsize_t l;\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n\t\tep2_set_infty(t[0]);\n\t\tep2_copy(t[1], q);\n\t\tif (bn_sign(_m) == RLC_NEG) {\n\t\t\tep2_neg(t[1], t[1]);\n\t\t}\n\t\tep2_copy(t[2], p);\n\t\tif (bn_sign(_k) == RLC_NEG) {\n\t\t\tep2_neg(t[2], t[2]);\n\t\t}\n\t\tep2_add(t[3], t[2], t[1]);\n\t\tep2_sub(t[4], t[2], t[1]);\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 3, t + 3, 2);\n#endif\n\n\t\tl = 2 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, _k, _m);\n\n\t\tep2_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(_k), bn_bits(_m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep2_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\tep2_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep2_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\tep2_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ep2_mul_sim_gen(ep2_t r, const bn_t k, const ep2_t q, const bn_t m) {\n\tep2_t g;\n\tbn_t n, _k, _m;\n\n\tif (bn_is_zero(k)) {\n\t\tep2_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep2_is_infty(q)) {\n\t\tep2_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tep2_null(g);\n\tbn_null(n);\n\tbn_null(_k);\n\tbn_null(_m);\n\n\tRLC_TRY {\n\t\tep2_new(g);\n\t\tbn_new(n);\n\t\tbn_new(_k);\n\t\tbn_new(_m);\n\n\t\tep2_curve_get_gen(g);\n\t\tep2_curve_get_ord(n);\n\n\t\tbn_mod(_k, k, n);\n\t\tbn_mod(_m, m, n);\n\n#if defined(EP_ENDOM)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep2_mul_sim_endom(r, g, _k, q, _m, ep2_curve_get_tab());\n\t\t}\n#else\n\t\tif (ep_curve_is_endom()) {\n\t\t\tep2_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n#if EP_SIM == INTER && EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep2_mul_sim_plain(r, g, _k, q, _m, ep2_curve_get_tab());\n\t\t}\n#else\n\t\tif (!ep_curve_is_endom()) {\n\t\t\tep2_mul_sim(r, g, _k, q, _m);\n\t\t}\n#endif\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(g);\n\t\tbn_free(n);\n\t\tbn_free(_k);\n\t\tbn_free(_m);\n\t}\n}\n\nvoid ep2_mul_sim_dig(ep2_t r, const ep2_t p[], const dig_t k[], size_t len) {\n\tep2_t t;\n\tint max;\n\n\tep2_null(t);\n\n\tmax = util_bits_dig(k[0]);\n\tfor (int i = 1; i < len; i++) {\n\t\tmax = RLC_MAX(max, util_bits_dig(k[i]));\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_set_infty(t);\n\t\tfor (int i = max - 1; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tif (k[j] & ((dig_t)1 << i)) {\n\t\t\t\t\tep2_add(t, t, p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n\nvoid ep2_mul_sim_lot(ep2_t r, const ep2_t p[], const bn_t k[], size_t n) {\n\tconst size_t len = RLC_FP_BITS + 1;\n\tint i, j, m;\n\tbn_t _k[4], q, x;\n\tint8_t ptr, *naf = RLC_ALLOCA(int8_t, 4 * n * len);\n\tsize_t l, _l[4];\n\n\tif (n == 0) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(q);\n\tbn_null(x);\n\n\tif (n <= 10) {\n\t\tep2_t *_p = RLC_ALLOCA(ep2_t, 4 * n);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tbn_null(_k[j]);\n\t\t\t\tbn_new(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep2_null(_p[4*i + j]);\n\t\t\t\t\tep2_new(_p[4*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep2_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tep2_norm(_p[4*i], p[i]);\n\t\t\t\tep2_frb(_p[4*i + 1], _p[4*i], 1);\n\t\t\t\tep2_frb(_p[4*i + 2], _p[4*i + 1], 1);\n\t\t\t\tep2_frb(_p[4*i + 3], _p[4*i + 2], 1);\n\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tbn_rec_frb(_k, 4, _k[0], x, q, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(4*i + j)*len], &_l[j], _k[j], 2);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tep2_neg(_p[4*i + j], _p[4*i + j]);\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep2_set_infty(r);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tep2_dbl(r, r);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 4; m++) {\n\t\t\t\t\t\tif (naf[(4*j + m)*len + i] > 0) {\n\t\t\t\t\t\t\tep2_add(r, r, _p[4*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[(4*j + m)*len + i] < 0) {\n\t\t\t\t\t\t\tep2_sub(r, r, _p[4*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep2_norm(r, r);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tbn_free(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep2_free(_p[4*i + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t} else {\n\t\tconst int w = RLC_MAX(2, util_bits_dig(n) - 2), c = (1 << (w - 2));\n\t\tep2_t s, t, u, v, *_p = RLC_ALLOCA(ep2_t, 4 * c);\n\n\t\tep2_null(s);\n\t\tep2_null(t);\n\t\tep2_null(u);\n\t\tep2_null(v);\n\n\t\tRLC_TRY {\n\t\t\tif (naf == NULL || _p == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tep2_new(s);\n\t\t\tep2_new(t);\n\t\t\tep2_new(u);\n\t\t\tep2_new(v);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_null(_k[i]);\n\t\t\t\tbn_new(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep2_null(_p[i*c + j]);\n\t\t\t\t\tep2_new(_p[i*c + j]);\n\t\t\t\t\tep2_set_infty(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = 0;\n\t\t\tep2_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_mod(_k[0], k[i], q);\n\t\t\t\tbn_rec_frb(_k, 4, _k[0], x, q, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\t_l[j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(4*i + j)*len], &_l[j], _k[j], w);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tfor (m = 0; m < _l[j]; m++) {\n\t\t\t\t\t\t\tnaf[(4*i + j)*len + m] = -naf[(4*i + j)*len + m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep2_set_infty(s);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 4; m++) {\n\t\t\t\t\t\tptr = naf[(4*j + m)*len + i];\n\t\t\t\t\t\tif (ptr != 0) {\n\t\t\t\t\t\t\tep2_copy(t, p[j]);\n\t\t\t\t\t\t\tif (ptr < 0) {\n\t\t\t\t\t\t\t\tptr = -ptr;\n\t\t\t\t\t\t\t\tep2_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tep2_add(_p[m*c + (ptr/2)], _p[m*c + (ptr/2)], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tep2_set_infty(t);\n\t\t\t\tfor (m = 3; m >= 0; m--) {\n\t\t\t\t\tep2_frb(t, t, 1);\n\t\t\t\t\tep2_set_infty(u);\n\t\t\t\t\tep2_set_infty(v);\n\t\t\t\t\tfor (j = c - 1; j >= 0; j--) {\n\t\t\t\t\t\tep2_add(u, u, _p[m*c + j]);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tep2_dbl(v, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tep2_add(v, v, u);\n\t\t\t\t\t\tep2_set_infty(_p[m*c + j]);\n\t\t\t\t\t}\n\t\t\t\t\tep2_add(t, t, v);\n\t\t\t\t}\n\t\t\t\tep2_dbl(s, s);\n\t\t\t\tep2_add(s, s, t);\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep2_norm(r, s);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tep2_free(s);\n\t\t\tep2_free(t);\n\t\t\tep2_free(u);\n\t\t\tep2_free(v);\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tbn_free(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep2_free(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of comparison for points on prime elliptic curves over\n * quadratic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ep2_is_infty(const ep2_t p) {\n\treturn (fp2_is_zero(p->z) == 1);\n}\n\nvoid ep2_set_infty(ep2_t p) {\n\tfp2_zero(p->x);\n\tfp2_zero(p->y);\n\tfp2_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid ep2_copy(ep2_t r, const ep2_t p) {\n\tfp2_copy(r->x, p->x);\n\tfp2_copy(r->y, p->y);\n\tfp2_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid ep2_rand(ep2_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tep2_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\tep2_mul_gen(p, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep2_blind(ep2_t r, const ep2_t p) {\n\tfp2_t rand;\n\n\tfp2_null(rand);\n\n\tRLC_TRY {\n\t\tfp2_new(rand);\n\t\tfp2_rand(rand);\n#if EP_ADD == BASIC\n\t\t(void)rand;\n\t\tep2_copy(r, p);\n#else\n\t\tfp2_mul(r->z, p->z, rand);\n\t\tfp2_mul(r->y, p->y, rand);\n\t\tfp2_sqr(rand, rand);\n\t\tfp2_mul(r->x, r->x, rand);\n\t\tfp2_mul(r->y, r->y, rand);\n\t\tr->coord = EP_ADD;\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp2_free(rand);\n\t}\n}\n\nvoid ep2_rhs(fp2_t rhs, const ep2_t p) {\n\tfp2_t t0;\n\n\tfp2_null(t0);\n\n\tRLC_TRY {\n\t\tfp2_new(t0);\n\n\t\tfp2_sqr(t0, p->x);                  /* x1^2 */\n\n\t\tswitch (ep2_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp2_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp2_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp2_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp2_mul_dig(t0, t0, ep2_curve_get_a()[0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp2_add(t0, t0, ep2_curve_get_a());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp2_mul(t0, t0, p->x);\t\t\t\t/* x1^3 + a * x */\n\n\t\tswitch (ep2_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp2_sub_dig(t0, t0, 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp2_add_dig(t0, t0, 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp2_add_dig(t0, t0, 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tfp2_mul_dig(t0, t0, ep2_curve_get_b()[0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tfp2_add(t0, t0, ep2_curve_get_b());\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp2_copy(rhs, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp2_free(t0);\n\t}\n}\n\n\nint ep2_on_curve(const ep2_t p) {\n\tep2_t t;\n\tint r = 0;\n\n\tep2_null(t);\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_norm(t, p);\n\n\t\tep2_rhs(t->x, t);\n\t\tfp2_sqr(t->y, t->y);\n\n\t\tr = (fp2_cmp(t->x, t->y) == RLC_EQ) || ep2_is_infty(p);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep2_free(t);\n\t}\n\treturn r;\n}\n\nvoid ep2_tab(ep2_t *t, const ep2_t p, int w) {\n\tif (w > 2) {\n\t\tep2_dbl(t[0], p);\n#if defined(EP_MIXED)\n\t\tep2_norm(t[0], t[0]);\n#endif\n\t\tep2_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\tep2_copy(t[0], p);\n}\n\nvoid ep2_print(const ep2_t p) {\n\tfp2_print(p->x);\n\tfp2_print(p->y);\n\tfp2_print(p->z);\n}\n\nint ep2_size_bin(const ep2_t a, int pack) {\n\tep2_t t;\n\tint size = 0;\n\n\tep2_null(t);\n\n\tif (ep2_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_norm(t, a);\n\n\t\tsize = 1 + 2 * RLC_FP_BYTES;\n\t\tif (!pack) {\n\t\t\tsize += 2 * RLC_FP_BYTES;\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep2_free(t);\n\t}\n\n\treturn size;\n}\n\nvoid ep2_read_bin(ep2_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep2_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (2 * RLC_FP_BYTES + 1) && len != (4 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp2_set_dig(a->z, 1);\n\tfp2_read_bin(a->x, bin + 1, 2 * RLC_FP_BYTES);\n\tif (len == 2 * RLC_FP_BYTES + 1) {\n\t\tswitch(bin[0]) {\n\t\t\tcase 2:\n\t\t\t\tfp2_zero(a->y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tfp2_zero(a->y);\n\t\t\t\tfp_set_bit(a->y[0], 0, 1);\n\t\t\t\tfp_zero(a->y[1]);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\t\tbreak;\n\t\t}\n\t\tep2_upk(a, a);\n\t}\n\n\tif (len == 4 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp2_read_bin(a->y, bin + 2 * RLC_FP_BYTES + 1, 2 * RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ep2_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n}\n\nvoid ep2_write_bin(uint8_t *bin, size_t len, const ep2_t a, int pack) {\n\tep2_t t;\n\n\tep2_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ep2_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\n\t\tep2_norm(t, a);\n\n\t\tif (pack) {\n\t\t\tif (len < 2 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tep2_pck(t, t);\n\t\t\t\tbin[0] = 2 | fp_get_bit(t->y[0], 0);\n\t\t\t\tfp2_write_bin(bin + 1, 2 * RLC_FP_BYTES, t->x, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 4 * RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t} else {\n\t\t\t\tbin[0] = 4;\n\t\t\t\tfp2_write_bin(bin + 1, 2 * RLC_FP_BYTES, t->x, 0);\n\t\t\t\tfp2_write_bin(bin + 2 * RLC_FP_BYTES + 1, 2 * RLC_FP_BYTES, t->y, 0);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep2_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of hashing to a prime elliptic curve over a quadratic\n * extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep4_map(ep4_t p, const uint8_t *msg, size_t len) {\n\tbn_t x;\n\tfp4_t t0;\n\tuint8_t digest[RLC_MD_LEN];\n\n\tbn_null(x);\n\tfp4_null(t0);\n\n\tRLC_TRY {\n\t\tbn_new(x);\n\t\tfp4_new(t0);\n\n\t\tmd_map(digest, msg, len);\n\t\tbn_read_bin(x, digest, RLC_MIN(RLC_FP_BYTES, RLC_MD_LEN));\n\n\t\tfp4_zero(p->x);\n\t\tfp_prime_conv(p->x[0][0], x);\n\t\tfp4_set_dig(p->z, 1);\n\n\t\twhile (1) {\n\t\t\tep4_rhs(t0, p);\n\n\t\t\tif (fp4_srt(p->y, t0)) {\n\t\t\t\tp->coord = BASIC;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfp_add_dig(p->x[0][0], p->x[0][0], 1);\n\t\t}\n\n\t\tep4_mul_cof(p, p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(x);\n\t\tfp4_free(t0);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of point multiplication on prime elliptic curves over\n * quadratic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\n#if defined(EP_ENDOM)\n\nstatic void ep4_mul_glv_imp(ep4_t r, const ep4_t p, const bn_t k) {\n\tint sign, i, j;\n\tbn_t n, _k[8], u, v;\n\tint8_t naf[8][RLC_FP_BITS + 1];\n\tep4_t q[8];\n\tsize_t l, _l[8];\n\n\tbn_null(n);\n\tbn_null(u);\n\tbn_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tbn_new(v);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tep4_null(q[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tep4_new(q[i]);\n\t\t}\n\n        bn_abs(v, k);\n\t\tep4_curve_get_ord(n);\n        if (bn_cmp_abs(v, n) == RLC_GT) {\n            bn_mod(v, v, n);\n        }\n\n\t\tfp_prime_get_par(u);\n\t\tsign = bn_sign(u);\n        bn_abs(u, u);\n\n\t\tep4_norm(q[0], p);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tbn_mod(_k[i], v, u);\n\t\t\tbn_div(v, v, u);\n\t\t\tif ((sign == RLC_NEG) && (i % 2 != 0)) {\n\t\t\t\tbn_neg(_k[i], _k[i]);\n\t\t\t}\n            if (bn_sign(k) == RLC_NEG) {\n                bn_neg(_k[i], _k[i]);\n            }\n            if (i > 0) {\n                ep4_frb(q[i], q[i - 1], 1);\n            }\n\t\t}\n\n        l = 0;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep4_neg(q[i], q[i]);\n\t\t\t}\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf[i], &_l[i], _k[i], 2);\n            l = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep4_set_infty(r);\n\t\tfor (j = l - 1; j >= 0; j--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif (naf[i][j] > 0) {\n\t\t\t\t\tep4_add(r, r, q[i]);\n\t\t\t\t}\n\t\t\t\tif (naf[i][j] < 0) {\n\t\t\t\t\tep4_sub(r, r, q[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep4_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n        bn_free(u);\n        bn_free(v);\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tep4_free(q[i]);\n\t\t}\n\n\t}\n}\n\n#endif /* EP_ENDOM */\n\nstatic void ep4_mul_naf_imp(ep4_t r, const ep4_t p, const bn_t k) {\n\tint i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep4_t t[1 << (EP_WIDTH - 2)];\n\tsize_t l;\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep4_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep4_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep4_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tep4_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_MUL == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid ep4_mul_basic(ep4_t r, const ep4_t p, const bn_t k) {\n\tint i, l;\n\tep4_t t;\n\n\tep4_null(t);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\t\tl = bn_bits(k);\n\n\t\tif (bn_get_bit(k, l - 1)) {\n\t\t\tep4_copy(t, p);\n\t\t} else {\n\t\t\tep4_set_infty(t);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep4_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep4_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep4_copy(r, t);\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n\n#if EP_MUL == SLIDE || !defined(STRIP)\n\nvoid ep4_mul_slide(ep4_t r, const ep4_t p, const bn_t k) {\n\tep4_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tep4_null(q);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tep4_new(q);\n\n\t\tep4_copy(t[0], p);\n\t\tep4_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep4_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep4_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep4_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep4_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep4_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep4_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep4_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t\tep4_free(q);\n\t}\n}\n\n#endif\n\n#if EP_MUL == MONTY || !defined(STRIP)\n\nvoid ep4_mul_monty(ep4_t r, const ep4_t p, const bn_t k) {\n\tep4_t t[2];\n\n\tep4_null(t[0]);\n\tep4_null(t[1]);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t[0]);\n\t\tep4_new(t[1]);\n\n\t\tep4_set_infty(t[0]);\n\t\tep4_copy(t[1], p);\n\n\t\tfor (int i = bn_bits(k) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(k, i);\n\t\t\tdv_swap_cond(t[0]->x[0][0], t[1]->x[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[0][1], t[1]->x[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][0], t[1]->x[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][1], t[1]->x[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][0], t[1]->y[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][1], t[1]->y[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][0], t[1]->y[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][1], t[1]->y[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][0], t[1]->z[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][1], t[1]->z[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][0], t[1]->z[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][1], t[1]->z[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tep4_add(t[0], t[0], t[1]);\n\t\t\tep4_dbl(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0]->x[0][0], t[1]->x[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[0][1], t[1]->x[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][0], t[1]->x[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->x[1][1], t[1]->x[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][0], t[1]->y[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[0][1], t[1]->y[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][0], t[1]->y[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->y[1][1], t[1]->y[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][0], t[1]->z[0][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[0][1], t[1]->z[0][1], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][0], t[1]->z[1][0], RLC_FP_DIGS, j ^ 1);\n\t\t\tdv_swap_cond(t[0]->z[1][1], t[1]->z[1][1], RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tep4_norm(r, t[0]);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t[1]);\n\t\tep4_free(t[0]);\n\t}\n}\n\n#endif\n\n#if EP_MUL == LWNAF || !defined(STRIP)\n\nvoid ep4_mul_lwnaf(ep4_t r, const ep4_t p, const bn_t k) {\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n#if defined(EP_ENDOM)\n\tif (ep_curve_is_endom()) {\n\t\tif (ep_curve_opt_a() == RLC_ZERO) {\n\t\t\tep4_mul_glv_imp(r, p, k);\n\t\t} else {\n\t\t\tep4_mul_naf_imp(r, p, k);\n\t\t}\n\t\treturn;\n\t}\n#endif\n\n#if defined(EP_PLAIN) || defined(EP_SUPER)\n\tep4_mul_naf_imp(r, p, k);\n#endif\n}\n\n#endif\n\nvoid ep4_mul_gen(ep4_t r, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n#ifdef EP_PRECO\n\tep4_mul_fix(r, ep4_curve_get_tab(), k);\n#else\n\tep4_t g;\n\n\tep4_null(g);\n\n\tRLC_TRY {\n\t\tep4_new(g);\n\t\tep4_curve_get_gen(g);\n\t\tep4_mul(r, g, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(g);\n\t}\n#endif\n}\n\nvoid ep4_mul_dig(ep4_t r, const ep4_t p, const dig_t k) {\n\tint i, l;\n\tep4_t t;\n\n\tep4_null(t);\n\n\tif (k == 0 || ep4_is_infty(p)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tl = util_bits_dig(k);\n\n\t\tep4_copy(t, p);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep4_dbl(t, t);\n\t\t\tif (k & ((dig_t)1 << i)) {\n\t\t\t\tep4_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep4_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of fixed point multiplication on a prime elliptic curve over\n * a quartic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\n/**\n * Precomputes a table for a point multiplication on an ordinary curve.\n *\n * @param[out] t\t\t\t\t- the destination table.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n */\nstatic void ep4_mul_pre_ordin(ep4_t *t, const ep4_t p) {\n\tep4_dbl(t[0], p);\n#if defined(EP_MIXED)\n\tep4_norm(t[0], t[0]);\n#endif\n\n#if EP_DEPTH > 2\n\tep4_add(t[1], t[0], p);\n\tfor (int i = 2; i < (1 << (EP_DEPTH - 2)); i++) {\n\t\tep4_add(t[i], t[i - 1], t[0]);\n\t}\n\n#if defined(EP_MIXED)\n\tfor (int i = 1; i < (1 << (EP_DEPTH - 2)); i++) {\n\t\tep4_norm(t[i], t[i]);\n\t}\n#endif\n\n#endif\n\tep4_copy(t[0], p);\n}\n\n/**\n * Multiplies a binary elliptic curve point by an integer using the w-NAF\n * method.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the point to multiply.\n * @param[in] k\t\t\t\t\t- the integer.\n */\nstatic void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\tsize_t len;\n\tint n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\t/* Compute the w-TNAF representation of k. */\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep4_set_infty(r);\n\tfor (int i = len - 1; i >= 0; i--, t--) {\n\t\tep4_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep4_add(r, r, table[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep4_sub(r, r, table[-n / 2]);\n\t\t}\n\t}\n\t/* Convert r to affine coordinates. */\n\tep4_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep4_neg(r, r);\n\t}\n}\n\n#endif /* EP_FIX == LWNAF */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_FIX == BASIC || !defined(STRIP)\n\nvoid ep4_mul_pre_basic(ep4_t *t, const ep4_t p) {\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\n\t\tep4_copy(t[0], p);\n\t\tfor (int i = 1; i < bn_bits(n); i++) {\n\t\t\tep4_dbl(t[i], t[i - 1]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_mul_fix_basic(ep4_t r, const ep4_t *t, const bn_t k) {\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tep4_set_infty(r);\n\n\tfor (int i = 0; i < bn_bits(k); i++) {\n\t\tif (bn_get_bit(k, i)) {\n\t\t\tep4_add(r, r, t[i]);\n\t\t}\n\t}\n\tep4_norm(r, r);\n\tif (bn_sign(k) == RLC_NEG) {\n\t\tep4_neg(r, r);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBS || !defined(STRIP)\n\nvoid ep4_mul_pre_combs(ep4_t *t, const ep4_t p) {\n\tint i, j, l;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tep4_set_infty(t[0]);\n\n\t\tep4_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep4_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < l; i++) {\n\t\t\t\tep4_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep4_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep4_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBS; i++) {\n\t\t\tep4_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_mul_fix_combs(ep4_t r, const ep4_t *t, const bn_t k) {\n\tint i, j, l, w, n0, p0, p1;\n\tbn_t n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\tl = bn_bits(n);\n\t\tl = ((l % EP_DEPTH) == 0 ? (l / EP_DEPTH) : (l / EP_DEPTH) + 1);\n\n\t\tn0 = bn_bits(k);\n\n\t\tp0 = (EP_DEPTH) * l - 1;\n\n\t\tw = 0;\n\t\tp1 = p0--;\n\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\tw = w << 1;\n\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\tw = w | 1;\n\t\t\t}\n\t\t}\n\t\tep4_copy(r, t[w]);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tw = 0;\n\t\t\tp1 = p0--;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p1 -= l) {\n\t\t\t\tw = w << 1;\n\t\t\t\tif (p1 < n0 && bn_get_bit(k, p1)) {\n\t\t\t\t\tw = w | 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w > 0) {\n\t\t\t\tep4_add(r, r, t[w]);\n\t\t\t}\n\t\t}\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif\n\n#if EP_FIX == COMBD || !defined(STRIP)\n\nvoid ep4_mul_pre_combd(ep4_t *t, const ep4_t p) {\n\tint i, j, d, e;\n\tbn_t n;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep4_set_infty(t[0]);\n\t\tep4_copy(t[1], p);\n\t\tfor (j = 1; j < EP_DEPTH; j++) {\n\t\t\tep4_dbl(t[1 << j], t[1 << (j - 1)]);\n\t\t\tfor (i = 1; i < d; i++) {\n\t\t\t\tep4_dbl(t[1 << j], t[1 << j]);\n\t\t\t}\n#if defined(EP_MIXED)\n\t\t\tep4_norm(t[1 << j], t[1 << j]);\n#endif\n\t\t\tfor (i = 1; i < (1 << j); i++) {\n\t\t\t\tep4_add(t[(1 << j) + i], t[i], t[1 << j]);\n\t\t\t}\n\t\t}\n\t\tep4_set_infty(t[1 << EP_DEPTH]);\n\t\tfor (j = 1; j < (1 << EP_DEPTH); j++) {\n\t\t\tep4_dbl(t[(1 << EP_DEPTH) + j], t[j]);\n\t\t\tfor (i = 1; i < e; i++) {\n\t\t\t\tep4_dbl(t[(1 << EP_DEPTH) + j], t[(1 << EP_DEPTH) + j]);\n\t\t\t}\n\t\t}\n#if defined(EP_MIXED)\n\t\tfor (i = 1; i < RLC_EP_TABLE_COMBD; i++) {\n\t\t\tep4_norm(t[i], t[i]);\n\t\t}\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_mul_fix_combd(ep4_t r, const ep4_t *t, const bn_t k) {\n\tint i, j, d, e, w0, w1, n0, p0, p1;\n\tbn_t n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\td = bn_bits(n);\n\t\td = ((d % EP_DEPTH) == 0 ? (d / EP_DEPTH) : (d / EP_DEPTH) + 1);\n\t\te = (d % 2 == 0 ? (d / 2) : (d / 2) + 1);\n\n\t\tep4_set_infty(r);\n\t\tn0 = bn_bits(k);\n\n\t\tp1 = (e - 1) + (EP_DEPTH - 1) * d;\n\t\tfor (i = e - 1; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tw0 = 0;\n\t\t\tp0 = p1;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw0 = w0 << 1;\n\t\t\t\tif (p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw0 = w0 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tw1 = 0;\n\t\t\tp0 = p1-- + e;\n\t\t\tfor (j = EP_DEPTH - 1; j >= 0; j--, p0 -= d) {\n\t\t\t\tw1 = w1 << 1;\n\t\t\t\tif (i + e < d && p0 < n0 && bn_get_bit(k, p0)) {\n\t\t\t\t\tw1 = w1 | 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep4_add(r, r, t[w0]);\n\t\t\tep4_add(r, r, t[(1 << EP_DEPTH) + w1]);\n\t\t}\n\t\tep4_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t}\n}\n\n#endif\n\n#if EP_FIX == LWNAF || !defined(STRIP)\n\nvoid ep4_mul_pre_lwnaf(ep4_t *t, const ep4_t p) {\n\tep4_mul_pre_ordin(t, p);\n}\n\nvoid ep4_mul_fix_lwnaf(ep4_t r, const ep4_t *t, const bn_t k) {\n\tep4_mul_fix_ordin(r, t, k);\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of simultaneous point multiplication on a prime elliptic\n * curve over a quartic extension.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if EP_SIM == INTER || !defined(STRIP)\n\n/**\n * Multiplies and adds two prime elliptic curve points simultaneously,\n * optionally choosing the first point as the generator depending on an optional\n * table of precomputed points.\n *\n * @param[out] r \t\t\t\t- the result.\n * @param[in] p\t\t\t\t\t- the first point to multiply.\n * @param[in] k\t\t\t\t\t- the first integer.\n * @param[in] q\t\t\t\t\t- the second point to multiply.\n * @param[in] m\t\t\t\t\t- the second integer.\n * @param[in] t\t\t\t\t\t- the pointer to the precomputed table.\n */\nstatic void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_null(t0[i]);\n\t\t\t\tep4_new(t0[i]);\n\t\t\t}\n\t\t\tep4_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep4_t *)t0;\n\t\t}\n\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_null(t1[i]);\n\t\t\tep4_new(t1[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep4_tab(t1, q, EP_WIDTH);\n\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (gen) {\n\t\t\tw = EP_DEPTH;\n\t\t} else {\n\t\t\tw = EP_WIDTH;\n\t\t}\n\t\tl0 = l1 = 2 * RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, k, w);\n\t\tbn_rec_naf(naf1, &l1, m, EP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tfor (i =  0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\tep4_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tep4_dbl(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\t\t\tif (n0 > 0) {\n\t\t\t\tep4_add(r, r, t[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tep4_sub(r, r, t[-n0 / 2]);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tep4_add(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tep4_sub(r, r, t1[-n1 / 2]);\n\t\t\t}\n\t\t}\n\t\t/* Convert r to affine coordinates. */\n\t\tep4_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation tables. */\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_free(t0[i]);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep4_free(t1[i]);\n\t\t}\n\t}\n}\n\n#endif /* EP_SIM == INTER */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if EP_SIM == BASIC || !defined(STRIP)\n\nvoid ep4_mul_sim_basic(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t l) {\n\tep4_t t;\n\n\tep4_null(t);\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\t\tep4_mul(t, q, l);\n\t\tep4_mul(r, p, k);\n\t\tep4_add(t, t, r);\n\t\tep4_norm(r, t);\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n\n#endif\n\n#if EP_SIM == TRICK || !defined(STRIP)\n\nvoid ep4_mul_sim_trick(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t m) {\n\tep4_t t0[1 << (EP_WIDTH / 2)];\n\tep4_t t1[1 << (EP_WIDTH / 2)];\n\tep4_t t[1 << EP_WIDTH];\n\tbn_t n;\n\tsize_t l0, l1, w = EP_WIDTH / 2;\n\tuint8_t w0[2 * RLC_FP_BITS], w1[2 * RLC_FP_BITS];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep4_null(t0[i]);\n\t\t\tep4_null(t1[i]);\n\t\t\tep4_new(t0[i]);\n\t\t\tep4_new(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tep4_set_infty(t0[0]);\n\t\tep4_copy(t0[1], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(t0[1], t0[1]);\n\t\t}\n\t\tfor (int i = 2; i < (1 << w); i++) {\n\t\t\tep4_add(t0[i], t0[i - 1], t0[1]);\n\t\t}\n\n\t\tep4_set_infty(t1[0]);\n\t\tep4_copy(t1[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tep4_neg(t1[1], t1[1]);\n\t\t}\n\t\tfor (int i = 1; i < (1 << w); i++) {\n\t\t\tep4_add(t1[i], t1[i - 1], t1[1]);\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tfor (int j = 0; j < (1 << w); j++) {\n\t\t\t\tep4_add(t[(i << w) + j], t0[i], t1[j]);\n\t\t\t}\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH)) - 1);\n#endif\n\n\t\tl0 = l1 = RLC_CEIL(2 * RLC_FP_BITS, w);\n\t\tbn_rec_win(w0, &l0, k, w);\n\t\tbn_rec_win(w1, &l1, m, w);\n\n\t\tfor (int i = l0; i < l1; i++) {\n\t\t\tw0[i] = 0;\n\t\t}\n\t\tfor (int i = l1; i < l0; i++) {\n\t\t\tw1[i] = 0;\n\t\t}\n\n\t\tep4_set_infty(r);\n\t\tfor (int i = RLC_MAX(l0, l1) - 1; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tep4_dbl(r, r);\n\t\t\t}\n\t\t\tep4_add(r, r, t[(w0[i] << w) + w1[i]]);\n\t\t}\n\t\tep4_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (int i = 0; i < (1 << w); i++) {\n\t\t\tep4_free(t0[i]);\n\t\t\tep4_free(t1[i]);\n\t\t}\n\t\tfor (int i = 0; i < (1 << EP_WIDTH); i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t}\n}\n#endif\n\n#if EP_SIM == INTER || !defined(STRIP)\n\nvoid ep4_mul_sim_inter(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t m) {\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tep4_mul_sim_plain(r, p, k, q, m, NULL);\n}\n\n#endif\n\n#if EP_SIM == JOINT || !defined(STRIP)\n\nvoid ep4_mul_sim_joint(ep4_t r, const ep4_t p, const bn_t k, const ep4_t q,\n\t\tconst bn_t m) {\n\tep4_t t[5];\n\tint i, u_i, offset;\n\tint8_t jsf[4 * (RLC_FP_BITS + 1)];\n\tsize_t l;\n\n\tif (bn_is_zero(k) || ep4_is_infty(p)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul(r, p, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep4_null(t[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tep4_set_infty(t[0]);\n\t\tep4_copy(t[1], q);\n\t\tif (bn_sign(m) == RLC_NEG) {\n\t\t\tep4_neg(t[1], t[1]);\n\t\t}\n\t\tep4_copy(t[2], p);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep4_neg(t[2], t[2]);\n\t\t}\n\t\tep4_add(t[3], t[2], t[1]);\n\t\tep4_sub(t[4], t[2], t[1]);\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 3, t + 3, 2);\n#endif\n\n\t\tl = 4 * (RLC_FP_BITS + 1);\n\t\tbn_rec_jsf(jsf, &l, k, m);\n\n\t\tep4_set_infty(r);\n\n\t\toffset = RLC_MAX(bn_bits(k), bn_bits(m)) + 1;\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep4_dbl(r, r);\n\t\t\tif (jsf[i] != 0 && jsf[i] == -jsf[i + offset]) {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep4_sub(r, r, t[4]);\n\t\t\t\t} else {\n\t\t\t\t\tep4_add(r, r, t[4]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu_i = jsf[i] * 2 + jsf[i + offset];\n\t\t\t\tif (u_i < 0) {\n\t\t\t\t\tep4_sub(r, r, t[-u_i]);\n\t\t\t\t} else {\n\t\t\t\t\tep4_add(r, r, t[u_i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep4_norm(r, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tep4_free(t[i]);\n\t\t}\n\t}\n}\n\n#endif\n\nvoid ep4_mul_sim_gen(ep4_t r, const bn_t k, const ep4_t q, const bn_t m) {\n\tep4_t gen;\n\n\tep4_null(gen);\n\n\tif (bn_is_zero(k)) {\n\t\tep4_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ep4_is_infty(q)) {\n\t\tep4_mul_gen(r, k);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(gen);\n\n\t\tep4_curve_get_gen(gen);\n#if EP_FIX == LWNAF && defined(EP_PRECO)\n\t\tep4_mul_sim_plain(r, gen, k, q, m, ep4_curve_get_tab());\n#else\n\t\tep4_mul_sim(r, gen, k, q, m);\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(gen);\n\t}\n}\n\nvoid ep4_mul_sim_dig(ep4_t r, const ep4_t p[], const dig_t k[], size_t len) {\n\tep4_t t;\n\tint max;\n\n\tep4_null(t);\n\n\tmax = util_bits_dig(k[0]);\n\tfor (int i = 1; i < len; i++) {\n\t\tmax = RLC_MAX(max, util_bits_dig(k[i]));\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_set_infty(t);\n\t\tfor (int i = max - 1; i >= 0; i--) {\n\t\t\tep4_dbl(t, t);\n\t\t\tfor (int j = 0; j < len; j++) {\n\t\t\t\tif (k[j] & ((dig_t)1 << i)) {\n\t\t\t\t\tep4_add(t, t, p[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tep4_norm(r, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n\nvoid ep4_mul_sim_lot(ep4_t r, const ep4_t p[], const bn_t k[], size_t n) {\n\tconst size_t len = RLC_FP_BITS + 1;\n\tint i, j, m;\n\tbn_t _k[8], q, x;\n\tint8_t *naf = RLC_ALLOCA(int8_t, 8 * n * len);\n\tsize_t l, *_l = RLC_ALLOCA(size_t, 8 * n);\n\n\tbn_null(q);\n\tbn_null(x);\n\n\tif (n <= 10) {\n\t\tep4_t *_p = RLC_ALLOCA(ep4_t, 8 * n);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tbn_null(_k[j]);\n\t\t\t\tbn_new(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep4_null(_p[8*i + j]);\n\t\t\t\t\tep4_new(_p[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tep4_norm(_p[8*i], p[i]);\n\t\t\t\tep4_frb(_p[8*i + 1], _p[8*i], 1);\n\t\t\t\tep4_frb(_p[8*i + 2], _p[8*i + 1], 1);\n\t\t\t\tep4_frb(_p[8*i + 3], _p[8*i + 2], 1);\n\t\t\t\tep4_frb(_p[8*i + 4], _p[8*i + 3], 1);\n\t\t\t\tep4_frb(_p[8*i + 5], _p[8*i + 4], 1);\n\t\t\t\tep4_frb(_p[8*i + 6], _p[8*i + 5], 1);\n\t\t\t\tep4_frb(_p[8*i + 7], _p[8*i + 6], 1);\n\t\t\t}\n\n\t\t\tep_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\n\t\t\tl = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_rec_frb(_k, 8, k[i], q, x, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\t_l[8*i + j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(8*i + j)*len], &_l[8*i + j], _k[j], 2);\n\t\t\t\t\tif (bn_sign(_k[j]) == RLC_NEG) {\n\t\t\t\t\t\tep4_neg(_p[8*i + j], _p[8*i + j]);\n\t\t\t\t\t}\n\t\t\t\t\tl = RLC_MAX(l, _l[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\tfor (m = _l[8*i + j]; m < l; m++) {\n\t\t\t\t\t\tnaf[(8*i + j)*len + m] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep4_set_infty(r);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tep4_dbl(r, r);\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 8; m++) {\n\t\t\t\t\t\tif (naf[(8*j + m)*len + i] > 0) {\n\t\t\t\t\t\t\tep4_add(r, r, _p[8*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[(8*j + m)*len + i] < 0) {\n\t\t\t\t\t\t\tep4_sub(r, r, _p[8*j + m]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep4_norm(r, r);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tbn_free(_k[j]);\n\t\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\t\tep4_free(_p[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_l);\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t} else {\n\t\tconst int w = RLC_MAX(2, util_bits_dig(n) - 2), c = (1 << (w - 2));\n\t\tep4_t s, t, u, v, *_p = RLC_ALLOCA(ep4_t, 8 * c);\n\t\tint8_t ptr;\n\n\t\tep4_null(s);\n\t\tep4_null(t);\n\t\tep4_null(u);\n\t\tep4_null(v);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(q);\n\t\t\tbn_new(x);\n\t\t\tep4_new(s);\n\t\t\tep4_new(t);\n\t\t\tep4_new(u);\n\t\t\tep4_new(v);\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tbn_null(_k[i]);\n\t\t\t\tbn_new(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep4_null(_p[i*c + j]);\n\t\t\t\t\tep4_new(_p[i*c + j]);\n\t\t\t\t\tep4_set_infty(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep_curve_get_ord(q);\n\t\t\tfp_prime_get_par(x);\n\n\t\t\tl = 0;\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tbn_rec_frb(_k, 8, k[i], q, x, ep_curve_is_pairf() == EP_BN);\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\t_l[8*i + j] = len;\n\t\t\t\t\tbn_rec_naf(&naf[(8*i + j)*len], &_l[8*i + j], _k[j], w);\n\t\t\t\t\tl = RLC_MAX(l, _l[8*i + j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\t\tfor (m = _l[8*i + j]; m < l; m++) {\n\t\t\t\t\t\tnaf[(8*i + j)*len + m] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tep4_set_infty(s);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tfor (m = 0; m < 8; m++) {\n\t\t\t\t\t\tptr = naf[(8*j + m)*len + i];\n\t\t\t\t\t\tif (ptr != 0) {\n\t\t\t\t\t\t\tep4_copy(t, p[j]);\n\t\t\t\t\t\t\tif (ptr < 0) {\n\t\t\t\t\t\t\t\tptr = -ptr;\n\t\t\t\t\t\t\t\tep4_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (bn_sign(_k[m]) == RLC_NEG) {\n\t\t\t\t\t\t\t\tep4_neg(t, t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tep4_add(_p[m*c + (ptr/2)], _p[m*c + (ptr/2)], t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tep4_set_infty(t);\n\t\t\t\tfor (m = 3; m >= 0; m--) {\n\t\t\t\t\tep4_frb(t, t, 1);\n\t\t\t\t\tep4_set_infty(u);\n\t\t\t\t\tep4_set_infty(v);\n\t\t\t\t\tfor (j = c - 1; j >= 0; j--) {\n\t\t\t\t\t\tep4_add(u, u, _p[m*c + j]);\n\t\t\t\t\t\tif (j == 0) {\n\t\t\t\t\t\t\tep4_dbl(v, v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tep4_add(v, v, u);\n\t\t\t\t\t\tep4_set_infty(_p[m*c + j]);\n\t\t\t\t\t}\n\t\t\t\t\tep4_add(t, t, v);\n\t\t\t\t}\n\t\t\t\tep4_dbl(s, s);\n\t\t\t\tep4_add(s, s, t);\n\t\t\t}\n\n\t\t\t/* Convert r to affine coordinates. */\n\t\t\tep4_norm(r, s);\n\t\t} RLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t} RLC_FINALLY {\n\t\t\tbn_free(q);\n\t\t\tbn_free(x);\n\t\t\tep4_free(s);\n\t\t\tep4_free(t);\n\t\t\tep4_free(u);\n\t\t\tep4_free(v);\n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tbn_free(_k[i]);\n\t\t\t\tfor (j = 0; j < c; j++) {\n\t\t\t\t\tep4_free(_p[i*c + j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tRLC_FREE(_l);\n\t\t\tRLC_FREE(_p);\n\t\t\tRLC_FREE(naf);\n\t\t}\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2021 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of comparison for points on prime elliptic curves over\n * quartic extensions.\n *\n * @ingroup epx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nint ep4_is_infty(const ep4_t p) {\n\treturn (fp4_is_zero(p->z) == 1);\n}\n\nvoid ep4_set_infty(ep4_t p) {\n\tfp4_zero(p->x);\n\tfp4_zero(p->y);\n\tfp4_zero(p->z);\n\tp->coord = BASIC;\n}\n\nvoid ep4_copy(ep4_t r, const ep4_t p) {\n\tfp4_copy(r->x, p->x);\n\tfp4_copy(r->y, p->y);\n\tfp4_copy(r->z, p->z);\n\tr->coord = p->coord;\n}\n\nvoid ep4_rand(ep4_t p) {\n\tbn_t n, k;\n\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tep4_curve_get_ord(n);\n\t\tbn_rand_mod(k, n);\n\n\t\tep4_mul_gen(p, k);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(k);\n\t\tbn_free(n);\n\t}\n}\n\nvoid ep4_blind(ep4_t r, const ep4_t p) {\n\tfp4_t rand;\n\n\tfp4_null(rand);\n\n\tRLC_TRY {\n\t\tfp4_new(rand);\n\t\tfp4_rand(rand);\n#if EP_ADD == BASIC\n\t\t(void)rand;\n\t\tep4_copy(r, p);\n#else\n\t\tfp4_mul(r->z, p->z, rand);\n\t\tfp4_mul(r->y, p->y, rand);\n\t\tfp4_sqr(rand, rand);\n\t\tfp4_mul(r->x, r->x, rand);\n\t\tfp4_mul(r->y, r->y, rand);\n\t\tr->coord = EP_ADD;\n#endif\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp4_free(rand);\n\t}\n}\n\nvoid ep4_rhs(fp4_t rhs, const ep4_t p) {\n\tfp4_t t0, t1;\n\n\tfp4_null(t0);\n\tfp4_null(t1);\n\n\tRLC_TRY {\n\t\tfp4_new(t0);\n\t\tfp4_new(t1);\n\n\t\tfp4_sqr(t0, p->x);                  /* x1^2 */\n\n\t\tswitch (ep4_curve_opt_a()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0[0][0], t0[0][0], 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tep4_curve_get_a(t1);\n\t\t\t\tfp_mul_dig(t0[0][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[0][1], t0[0][1], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][1], t0[1][1], t1[0][0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tep4_curve_get_a(t1);\n\t\t\t\tfp4_add(t0, t0, t1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp4_mul(t0, t0, p->x);\t\t\t\t/* x1^3 + a * x */\n\n\t\tswitch (ep4_curve_opt_b()) {\n\t\t\tcase RLC_ZERO:\n\t\t\t\tbreak;\n#if FP_RDC != MONTY\n\t\t\tcase RLC_MIN3:\n\t\t\t\tfp_sub_dig(t0[0][0], t0[0][0], 3);\n\t\t\t\tbreak;\n\t\t\tcase RLC_ONE:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 1);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TWO:\n\t\t\t\tfp_add_dig(t0[0][0], t0[0][0], 2);\n\t\t\t\tbreak;\n\t\t\tcase RLC_TINY:\n\t\t\t\tep4_curve_get_b(t1);\n\t\t\t\tfp_mul_dig(t0[0][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[0][1], t0[0][1], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][0], t0[0][0], t1[0][0][0]);\n\t\t\t\tfp_mul_dig(t0[1][1], t0[1][1], t1[0][0][0]);\n\t\t\t\tbreak;\n#endif\n\t\t\tdefault:\n\t\t\t\tep4_curve_get_b(t1);\n\t\t\t\tfp4_add(t0, t0, t1);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfp4_copy(rhs, t0);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp4_free(t0);\n\t\tfp4_free(t1);\n\t}\n}\n\n\nint ep4_on_curve(const ep4_t p) {\n\tep4_t t;\n\tint r = 0;\n\n\tep4_null(t);\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_norm(t, p);\n\n\t\tep4_rhs(t->x, t);\n\t\tfp4_sqr(t->y, t->y);\n\n\t\tr = (fp4_cmp(t->x, t->y) == RLC_EQ) || ep4_is_infty(p);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep4_free(t);\n\t}\n\treturn r;\n}\n\nvoid ep4_tab(ep4_t *t, const ep4_t p, int w) {\n\tif (w > 2) {\n\t\tep4_dbl(t[0], p);\n#if defined(EP_MIXED)\n\t\tep4_norm(t[0], t[0]);\n#endif\n\t\tep4_add(t[1], t[0], p);\n\t\tfor (int i = 2; i < (1 << (w - 2)); i++) {\n\t\t\tep4_add(t[i], t[i - 1], t[0]);\n\t\t}\n#if defined(EP_MIXED)\n\t\tep4_norm_sim(t + 1, t + 1, (1 << (w - 2)) - 1);\n#endif\n\t}\n\tep4_copy(t[0], p);\n}\n\nvoid ep4_print(const ep4_t p) {\n\tfp4_print(p->x);\n\tfp4_print(p->y);\n\tfp4_print(p->z);\n}\n\nint ep4_size_bin(const ep4_t a, int pack) {\n\tep4_t t;\n\tint size = 0;\n\n\tep4_null(t);\n\n\tif (ep4_is_infty(a)) {\n\t\treturn 1;\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_norm(t, a);\n\n\t\tsize = 1 + 8 * RLC_FP_BYTES;\n\t\t//TODO: Implement compression.\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep4_free(t);\n\t}\n\n\treturn size;\n}\n\nvoid ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep4_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (len != (8 * RLC_FP_BYTES + 1)) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\ta->coord = BASIC;\n\tfp4_set_dig(a->z, 1);\n\tfp4_read_bin(a->x, bin + 1, 4 * RLC_FP_BYTES);\n\n\tif (len == 8 * RLC_FP_BYTES + 1) {\n\t\tif (bin[0] == 4) {\n\t\t\tfp4_read_bin(a->y, bin + 4 * RLC_FP_BYTES + 1, 4 * RLC_FP_BYTES);\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!ep4_on_curve(a)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n}\n\nvoid ep4_write_bin(uint8_t *bin, size_t len, const ep4_t a, int pack) {\n\tep4_t t;\n\n\tep4_null(t);\n\n\tmemset(bin, 0, len);\n\n\tif (ep4_is_infty(a)) {\n\t\tif (len < 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tRLC_TRY {\n\t\tep4_new(t);\n\n\t\tep4_norm(t, a);\n\n\t\tif (len < 8 * RLC_FP_BYTES + 1) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t} else {\n\t\t\tbin[0] = 4;\n\t\t\tfp4_write_bin(bin + 1, 4 * RLC_FP_BYTES, t->x);\n\t\t\tfp4_write_bin(bin + 4 * RLC_FP_BYTES + 1, 4 * RLC_FP_BYTES, t->y);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tep4_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2011 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of prime field exponentiation functions.\n *\n * @ingroup bn\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_fb.h\"\n#include \"relic_bn.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if FB_EXP == BASIC || !defined(STRIP)\n\nvoid fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n\tsize_t l;\n\tfb_t r;\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfb_null(r);\n\n\tRLC_TRY {\n\t\tfb_new(r);\n\n\t\tl = bn_bits(b);\n\n\t\tfb_copy(r, a);\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tfb_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfb_mul(r, r, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, r);\n\t\t} else {\n\t\t\tfb_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(r);\n\t}\n}\n\n#endif\n\n#if FB_EXP == SLIDE || !defined(STRIP)\n\nvoid fb_exp_slide(fb_t c, const fb_t a, const bn_t b) {\n\tfb_t t[1 << (FB_WIDTH - 1)], r;\n\tuint8_t win[RLC_FB_BITS + 1];\n\tsize_t l;\n\n\tfb_null(r);\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\n\t/* Initialize table. */\n\tfor (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n\t\tfb_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tfor (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i ++) {\n\t\t\tfb_new(t[i]);\n\t\t}\n\t\tfb_new(r);\n\n\t\tfb_copy(t[0], a);\n\t\tfb_sqr(r, a);\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < 1 << (FB_WIDTH - 1); i++) {\n\t\t\tfb_mul(t[i], t[i - 1], r);\n\t\t}\n\n\t\tfb_set_dig(r, 1);\n\t\tl = RLC_FB_BITS + 1;\n\t\tbn_rec_slw(win, &l, b, FB_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tfb_sqr(r, r);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tfb_sqr(r, r);\n\t\t\t\t}\n\t\t\t\tfb_mul(r, r, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, r);\n\t\t} else {\n\t\t\tfb_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (FB_WIDTH - 1)); i++) {\n\t\t\tfb_free(t[i]);\n\t\t}\n\t\tfb_free(r);\n\t}\n}\n\n#endif\n\n#if FB_EXP == MONTY || !defined(STRIP)\n\nvoid fb_exp_monty(fb_t c, const fb_t a, const bn_t b) {\n\tfb_t t[2];\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfb_null(t[0]);\n\tfb_null(t[1]);\n\n\tRLC_TRY {\n\t\tfb_new(t[0]);\n\t\tfb_new(t[1]);\n\n\t\tfb_set_dig(t[0], 1);\n\t\tfb_copy(t[1], a);\n\n\t\tfor (int i = bn_bits(b) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(b, i);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FB_DIGS, j ^ 1);\n\t\t\tfb_mul(t[0], t[0], t[1]);\n\t\t\tfb_sqr(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FB_DIGS, j ^ 1);\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, t[0]);\n\t\t} else {\n\t\t\tfb_copy(c, t[0]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(t[1]);\n\t\tfb_free(t[0]);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the basic functions to manipulate binary field elements.\n *\n * @ingroup fb\n */\n\n#include \"relic_core.h\"\n#include \"relic_fb.h\"\n#include \"relic_fb_low.h\"\n#include \"relic_rand.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Checks if a radix is a power of two.\n *\n * @param[in] radix\t\t\t\t- the radix to check.\n * @return if radix is a valid radix.\n */\nstatic int valid_radix(unsigned int radix) {\n\twhile (radix > 0) {\n\t\tif (radix != 1 && radix % 2 == 1)\n\t\t\treturn 0;\n\t\tradix = radix / 2;\n\t}\n\treturn 1;\n}\n\n/**\n * Computes the logarithm of a valid radix in basis two.\n *\n * @param[in] radix\t\t\t\t- the valid radix.\n * @return the logarithm of the radix in basis two.\n */\nstatic int log_radix(unsigned int radix) {\n\tint l = 0;\n\n\twhile (radix > 0) {\n\t\tradix = radix / 2;\n\t\tl++;\n\t}\n\treturn --l;\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fb_copy(fb_t c, const fb_t a) {\n\tdv_copy(c, a, RLC_FB_DIGS);\n}\n\nvoid fb_zero(fb_t a) {\n\tdv_zero(a, RLC_FB_DIGS);\n}\n\nint fb_is_zero(const fb_t a) {\n\tint i;\n\tdig_t t = 0;\n\n\tfor (i = 0; i < RLC_FB_DIGS; i++) {\n\t\tt |= a[i];\n\t}\n\n\treturn !t;\n}\n\nint fb_get_bit(const fb_t a, size_t bit) {\n\tint d;\n\n\tRLC_RIP(bit, d, bit);\n\n\treturn (a[d] >> bit) & 1;\n}\n\nvoid fb_set_bit(fb_t a, size_t bit, int value) {\n\tint d;\n\tdig_t mask;\n\n\tRLC_RIP(bit, d, bit);\n\n\tmask = (dig_t)1 << bit;\n\n\tif (value == 1) {\n\t\ta[d] |= mask;\n\t} else {\n\t\ta[d] &= ~mask;\n\t}\n}\n\nsize_t fb_bits(const fb_t a) {\n\tint i = RLC_FB_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}\n\nvoid fb_set_dig(fb_t c, dig_t a) {\n\tfb_zero(c);\n\tc[0] = a;\n}\n\nvoid fb_rand(fb_t a) {\n\tsize_t bits, digits;\n\n\trand_bytes((uint8_t *)a, RLC_FB_DIGS * sizeof(dig_t));\n\n\tRLC_RIP(bits, digits, RLC_FB_BITS);\n\tif (bits > 0) {\n\t\tdig_t mask = RLC_MASK(bits);\n\t\ta[RLC_FB_DIGS - 1] &= mask;\n\t}\n}\n\nvoid fb_print(const fb_t a) {\n\t/* Suppress possible unused parameter warning. */\n\t(void)a;\n\tfor (int i = RLC_FB_DIGS - 1; i > 0; i--) {\n\t\tutil_print_dig(a[i], 1);\n\t\tutil_print(\" \");\n\t}\n\tutil_print_dig(a[0], 1);\n\tutil_print(\"\\n\");\n}\n\nsize_t fb_size_str(const fb_t a, unsigned int radix) {\n\tbn_t t;\n\tsize_t digits = 0;\n\n\tbn_null(t);\n\n\tif (!valid_radix(radix)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn 0;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_raw(t, a, RLC_FB_DIGS);\n\n\t\tdigits = bn_size_str(t, radix);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn digits;\n}\n\nvoid fb_read_str(fb_t a, const char *str, size_t len, unsigned int radix) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (!valid_radix(radix)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_str(t, str, len, radix);\n\n\t\tif (bn_bits(t) > RLC_FB_BITS) {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t}\n\n\t\tfb_zero(a);\n\t\tdv_copy(a, t->dp, t->used);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fb_write_str(char *str, size_t len, const fb_t a, unsigned int radix) {\n\tfb_t t;\n\tint d, l, i, j;\n\tchar c;\n\n\tfb_null(t);\n\n\tl = fb_size_str(a, radix);\n\tif (len < l) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tlen = l;\n\n\tl = log_radix(radix);\n\tif (!valid_radix(radix)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tif (fb_is_zero(a) == 1) {\n\t\t*str++ = '0';\n\t\t*str = '\\0';\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfb_new(t);\n\t\tfb_copy(t, a);\n\n\t\tj = 0;\n\t\twhile (!fb_is_zero(t)) {\n\t\t\td = t[0] % radix;\n\t\t\tfb_rshb_low(t, t, l);\n\t\t\tstr[j] = util_conv_char(d);\n\t\t\tj++;\n\t\t}\n\n\t\t/* Reverse the digits of the string. */\n\t\ti = 0;\n\t\tj = len - 2;\n\t\twhile (i < j) {\n\t\t\tc = str[i];\n\t\t\tstr[i] = str[j];\n\t\t\tstr[j] = c;\n\t\t\t++i;\n\t\t\t--j;\n\t\t}\n\n\t\tstr[len - 1] = '\\0';\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfb_free(t);\n\t}\n}\n\nvoid fb_read_bin(fb_t a, const uint8_t *bin, size_t len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_bin(t, bin, len);\n\n\t\tfb_copy(a, t->dp);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fb_write_bin(uint8_t *bin, size_t len, const fb_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tbn_read_raw(t, a, RLC_FB_DIGS);\n\n\t\tbn_write_bin(bin, len, t);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of prime field exponentiation functions.\n *\n * @ingroup fp\n */\n\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if FP_EXP == BASIC || !defined(STRIP)\n\nvoid fp_exp_basic(fp_t c, const fp_t a, const bn_t b) {\n\tsize_t l;\n\tfp_t r;\n\n\tfp_null(r);\n\n\tif (bn_is_zero(b)) {\n\t\tfp_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfp_new(r);\n\n\t\tl = bn_bits(b);\n\n\t\tfp_copy(r, a);\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tfp_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp_mul(r, r, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp_inv(c, r);\n\t\t} else {\n\t\t\tfp_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp_free(r);\n\t}\n}\n\n#endif\n\n#if FP_EXP == SLIDE || !defined(STRIP)\n\nvoid fp_exp_slide(fp_t c, const fp_t a, const bn_t b) {\n\tfp_t t[1 << (FP_WIDTH - 1)], r;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tfp_null(r);\n\n\tif (bn_is_zero(b)) {\n\t\tfp_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\n\t/* Initialize table. */\n\tfor (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n\t\tfp_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tfor (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i ++) {\n\t\t\tfp_new(t[i]);\n\t\t}\n\t\tfp_new(r);\n\n\t\tfp_copy(t[0], a);\n\t\tfp_sqr(r, a);\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < 1 << (FP_WIDTH - 1); i++) {\n\t\t\tfp_mul(t[i], t[i - 1], r);\n\t\t}\n\n\t\tfp_set_dig(r, 1);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, b, FP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tfp_sqr(r, r);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tfp_sqr(r, r);\n\t\t\t\t}\n\t\t\t\tfp_mul(r, r, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp_inv(c, r);\n\t\t} else {\n\t\t\tfp_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (FP_WIDTH - 1)); i++) {\n\t\t\tfp_free(t[i]);\n\t\t}\n\t\tfp_free(r);\n\t}\n}\n\n#endif\n\n#if FP_EXP == MONTY || !defined(STRIP)\n\nvoid fp_exp_monty(fp_t c, const fp_t a, const bn_t b) {\n\tfp_t t[2];\n\n\tfp_null(t[0]);\n\tfp_null(t[1]);\n\n\tif (bn_is_zero(b)) {\n\t\tfp_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfp_new(t[0]);\n\t\tfp_new(t[1]);\n\n\t\tfp_set_dig(t[0], 1);\n\t\tfp_copy(t[1], a);\n\n\t\tfor (int i = bn_bits(b) - 1; i >= 0; i--) {\n\t\t\tint j = bn_get_bit(b, i);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FP_DIGS, j ^ 1);\n\t\t\tfp_mul(t[0], t[0], t[1]);\n\t\t\tfp_sqr(t[1], t[1]);\n\t\t\tdv_swap_cond(t[0], t[1], RLC_FP_DIGS, j ^ 1);\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp_inv(c, t[0]);\n\t\t} else {\n\t\t\tfp_copy(c, t[0]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp_free(t[1]);\n\t\tfp_free(t[0]);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime field prime manipulation functions.\n *\n * @ingroup fp\n */\n\n#include \"relic_core.h\"\n#include \"relic_ep.h\"\n#include \"relic_fpx.h\"\n#include \"relic_bn_low.h\"\n#include \"relic_fp_low.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Assigns the prime field modulus.\n *\n * @param[in] p\t\t\t- the new prime field modulus.\n */\nstatic void fp_prime_set(const bn_t p) {\n\tbn_t t;\n\tfp_t r;\n\tctx_t *ctx = core_get();\n\n\tif (p->used != RLC_FP_DIGS) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tbn_null(t);\n\tfp_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tfp_new(r);\n\n\t\tbn_copy(&(ctx->prime), p);\n\n#if FP_RDC == MONTY || !defined(STRIP)\n\n\t\tbn_mod_pre_monty(t, &(ctx->prime));\n\t\tctx->u = t->dp[0];\n\n\t\t/* compute R mod p */\n\t\tbn_set_dig(&(ctx->one), 1);\n\t\tbn_lsh(&(ctx->one), &(ctx->one), RLC_FP_DIGS * RLC_DIG);\n\t\tbn_mod(&(ctx->one), &(ctx->one), &(ctx->prime));\n\n\t\t/* compute the R^2 mod p */\n\t\tfp_add(r, ctx->one.dp, ctx->one.dp);\n\t\tbn_set_dig(t, RLC_FP_DIGS);\n\t\tbn_lsh(t, t, RLC_DIG_LOG);\n\t\tfp_exp(ctx->conv.dp, r, t);\n\t\tctx->conv.used = RLC_FP_DIGS;\n\t\tbn_trim(&(ctx->conv));\n\n#endif /* FP_RDC == MONTY */\n\n#if FP_INV == JUMPDS || !defined(STRIP)\n\n\t\tint d = (45907 * FP_PRIME + 26313) / 19929;\n\n#if WSIZE == 8\n\t\tbn_set_dig(t, d >> 8);\n\t\tbn_lsh(t, t, 8);\n\t\tbn_add_dig(t, t, d & 0xFF);\n#else\n\t\tbn_set_dig(t, d);\n#endif\n\t\tctx->inv.used = RLC_FP_DIGS;\n\t\tdv_copy(ctx->inv.dp, fp_prime_get(), RLC_FP_DIGS);\n\t\tfp_add_dig(ctx->inv.dp, ctx->inv.dp, 1);\n\t\tfp_hlv(ctx->inv.dp, ctx->inv.dp);\n\t\tfp_exp(ctx->inv.dp, ctx->inv.dp, t);\n\n#if FP_RDC == MONTY\n\n#if (FP_PRIME % WSIZE) != 0\n\t\tfp_mul(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);\n\t\tfp_mul(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);\n\n\t\tfor (int i = 1, j = 0; i < d / (RLC_DIG - 2); i++) {\n\t\t\tj = i % RLC_FP_DIGS;\n\t\t\tif (j == 0) {\n\t\t\t\tfp_mulm_low(ctx->inv.dp, ctx->inv.dp, ctx->conv.dp);\n\t\t\t}\n\t\t}\n#endif\n\n#endif /* FP_RDC == MONTY */\n\n#endif /* FP_INV */\n\n\t\t/* Now look for proper quadratic/cubic non-residues. */\n\t\tctx->qnr = ctx->cnr = 0;\n\t\tbn_mod_dig(&(ctx->mod8), &(ctx->prime), 8);\n\n\t\tswitch (ctx->mod8) {\n\t\t\tcase 3:\n\t\t\t\tctx->qnr = -1;\n\t\t\t\tctx->cnr = 2;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tctx->qnr = -1;\n\t\t\t\tctx->cnr = -2;\n\t\t\t\t/* TODO: implement cube root to handle this better. */\n#if FP_PRIME == 638\n\t\t\t\tctx->cnr = -3;\n#endif\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\tcase 5:\n\t\t\t\tctx->qnr = -2;\n\t\t\t\tctx->cnr = 2;\n\t\t\t\t/* Check if it is a quadratic non-residue or find another. */\n\t\t\t\tfp_set_dig(r, -ctx->qnr);\n\t\t\t\tfp_neg(r, r);\n\t\t\t\twhile (fp_srt(r, r) == 1) {\n\t\t\t\t\tctx->qnr--;\n\t\t\t\t\tfp_set_dig(r, -ctx->qnr);\n\t\t\t\t\tfp_neg(r, r);\n\t\t\t\t\t/* We cannot guarantee a cubic extension anymore. */\n\t\t\t\t\tctx->cnr = 0;\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t}\n#ifdef FP_QNRES\n\t\tif (ctx->mod8 != 3) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n#endif\n\n\t\tctx->ad2 = 0;\n\t\tbn_sub_dig(t, p, 1);\n\t\twhile (bn_is_even(t)) {\n\t\t\tctx->ad2++;\n\t\t\tbn_hlv(t, t);\n\t\t}\n\n\t\tfp_prime_calc();\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t\tfp_free(r);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp_prime_init(void) {\n\tctx_t *ctx = core_get();\n\tctx->fp_id = 0;\n\tbn_make(&(ctx->prime), RLC_FP_DIGS);\n\tbn_make(&(ctx->par), RLC_FP_DIGS);\n#if FP_RDC == QUICK || !defined(STRIP)\n\tctx->sps_len = 0;\n\tmemset(ctx->sps, 0, sizeof(ctx->sps));\n#endif\n#if FP_RDC == MONTY || !defined(STRIP)\n\tbn_make(&(ctx->conv), RLC_FP_DIGS);\n\tbn_make(&(ctx->one), RLC_FP_DIGS);\n#endif\n#if FP_INV == JUMPDS || !defined(STRIP)\n\tbn_make(&(ctx->inv), RLC_FP_DIGS);\n#endif /* FP_INV */\n}\n\nvoid fp_prime_clean(void) {\n\tctx_t *ctx = core_get();\n\tif (ctx != NULL) {\n\t\tctx->fp_id = 0;\n#if FP_RDC == QUICK || !defined(STRIP)\n\t\tctx->sps_len = 0;\n\t\tmemset(ctx->sps, 0, sizeof(ctx->sps));\n#endif\n#if FP_RDC == MONTY || !defined(STRIP)\n\t\tbn_clean(&(ctx->one));\n\t\tbn_clean(&(ctx->conv));\n#endif\n#if FP_INV == JUMPDS || !defined(STRIP)\n\t\tbn_clean(&(ctx->inv));\n#endif /* FP_INV */\n\t\tbn_clean(&(ctx->prime));\n\t\tbn_clean(&(ctx->par));\n\t}\n}\n\nconst dig_t *fp_prime_get(void) {\n\treturn core_get()->prime.dp;\n}\n\nconst dig_t *fp_prime_get_rdc(void) {\n\treturn &(core_get()->u);\n}\n\nvoid fp_prime_get_par(bn_t x) {\n\tbn_copy(x, &(core_get()->par));\n}\n\nconst int *fp_prime_get_par_sps(int *len) {\n\tctx_t *ctx = core_get();\n\tif (ctx->par_len > 0) {\n\t\tif (len != NULL) {\n\t\t\t*len = ctx->par_len;\n\t\t}\n\t\treturn ctx->par_sps;\n\t}\n\tif (len != NULL) {\n\t\t*len = 0;\n\t}\n\treturn NULL;\n}\n\nconst int *fp_prime_get_sps(int *len) {\n#if FP_RDC == QUICK || !defined(STRIP)\n\tctx_t *ctx = core_get();\n\tif (ctx->sps_len > 0 && ctx->sps_len < RLC_TERMS) {\n\t\tif (len != NULL) {\n\t\t\t*len = ctx->sps_len;\n\t\t}\n\t\treturn ctx->sps;\n\t} else {\n\t\tif (len != NULL) {\n\t\t\t*len = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n#else\n\treturn NULL;\n#endif\n}\n\nconst dig_t *fp_prime_get_conv(void) {\n#if FP_RDC == MONTY || !defined(STRIP)\n\treturn core_get()->conv.dp;\n#else\n\treturn NULL;\n#endif\n}\n\ndig_t fp_prime_get_mod8(void) {\n\treturn core_get()->mod8;\n}\n\nint fp_prime_get_qnr(void) {\n\treturn core_get()->qnr;\n}\n\nint fp_prime_get_cnr(void) {\n\treturn core_get()->cnr;\n}\n\nint fp_prime_get_2ad(void) {\n\treturn core_get()->ad2;\n}\n\nvoid fp_prime_set_dense(const bn_t p) {\n\tfp_prime_set(p);\n#if FP_RDC == QUICK\n\tRLC_THROW(ERR_NO_CONFIG);\n#endif\n}\n\nvoid fp_prime_set_pairf(const bn_t x, int pairf) {\n\tbn_t p, t0, t1;\n\tctx_t *ctx = core_get();\n\tsize_t len = bn_bits(x) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tbn_null(p);\n\tbn_null(t0);\n\tbn_null(t1);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(t0);\n\t\tbn_new(t1);\n\n\t\tbn_copy(&(ctx->par), x);\n\t\tbn_copy(t0, x);\n\n\t\tswitch (pairf) {\n\t\t\tcase EP_BN:\n\t\t\t\t/* p = 36 * x^4 + 36 * x^3 + 24 * x^2 + 6 * x + 1. */\n\t\t\t\tbn_set_dig(p, 1);\n\t\t\t\tbn_mul_dig(t1, t0, 6);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t0, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 24);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t0, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 36);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t0, t0, t0);\n\t\t\t\tbn_mul(t1, t0, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 36);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_B12:\n\t\t\t\t/* p = (x^2 - 2x + 1) * (x^4 - x^2 + 1)/3 + x. */\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_sqr(p, t1);\n\t\t\t\tbn_sub(p, p, t1);\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t\tbn_sub(t1, t1, t0);\n\t\t\t\tbn_sub(t1, t1, t0);\n\t\t\t\tbn_add_dig(t1, t1, 1);\n\t\t\t\tbn_mul(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 3);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_OT8:\n\t\t\t\t/* p = (x^8 + x^6 + 5*x^4 + x^2 + 4*x + 4) / 4. */\n\t\t\t\tbn_set_dig(p, 4);\n\t\t\t\tbn_mul_dig(t1, t0, 4);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_sqr(t0, t0);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 4);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_B24:\n\t\t\t\t/* p = (x - 1)^2 * (x^8 - x^4 + 1)/3 + x. */\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_sqr(p, t1);\n\t\t\t\tbn_sub(p, p, t1);\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t\tbn_sub_dig(t1, t0, 1);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_mul(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 3);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_B48:\n\t\t\t\t/* p = (x - 1)^2*(x^16 - x^8 + 1) / 3 + x. */\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_sqr(p, t1);\n\t\t\t\tbn_sqr(t1, p);\n\t\t\t\tbn_sub(t1, t1, p);\n\t\t\t\tbn_add_dig(t1, t1, 1);\n\t\t\t\tbn_sub_dig(p, t0, 1);\n\t\t\t\tbn_sqr(p, p);\n\t\t\t\tbn_mul(p, p, t1);\n\t\t\t\tbn_div_dig(p, p, 3);\n\t\t\t\tbn_add(p, p, t0);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t\tcase EP_K54:\n\t\t\t\t/* p = (1+3*x+3*x^2+(3^5)*x^9+(3^5)*x^10+(3^6)*x^10+(3^6)*x^11+(3^9)*x^18+(3^10)*x^19+(3^10)*x^20) */\n\t\t\t\tbn_set_dig(p, 1);\n\t\t\t\tbn_mul_dig(t1, t0, 3);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_sqr(t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_sqr(t1, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul_dig(t1, t1, 243);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul_dig(t1, t1, 3);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul_dig(t1, t1, 27);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul_dig(t1, t1, 3);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tbn_mul(t1, t1, t0);\n\t\t\t\tbn_add(p, p, t1);\n\t\t\t\tfp_prime_set_dense(p);\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Store parameter in NAF form. */\n\t\tctx->par_len = 0;\n\t\tbn_rec_naf(s, &len, &(ctx->par), 2);\n\t\t/* Fix corner case to avoid problems with sparse representation. */\n\t\tif (s[0] == -1) {\n\t\t\ts[0] = 1;\n\t\t\ts[1] = -1;\n\t\t}\n\t\tfor (int i = 0; i < len && ctx->par_len < RLC_TERMS; i++) {\n\t\t\tif (s[i] > 0) {\n\t\t\t\tctx->par_sps[ctx->par_len++] = i;\n\t\t\t}\n\t\t\tif (s[i] < 0) {\n\t\t\t\tctx->par_sps[ctx->par_len++] = -i;\n\t\t\t}\n\t\t}\n\t\tif (ctx->par_len == RLC_TERMS) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(p);\n\t\tbn_free(t0);\n\t\tbn_free(t1);\n\t}\n}\n\nvoid fp_prime_set_pmers(const int *f, size_t len) {\n\tbn_t p, t;\n\n\tbn_null(p);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(t);\n\n\t\tif (len >= RLC_TERMS) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t\treturn;\n\t\t}\n\n\t\tbn_set_2b(p, f[len - 1]);\n\t\tfor (int i = len - 2; i > 0; i--) {\n\t\t\tif (f[i] > 0) {\n\t\t\t\tbn_set_2b(t, f[i]);\n\t\t\t\tbn_add(p, p, t);\n\t\t\t} else {\n\t\t\t\tbn_set_2b(t, -f[i]);\n\t\t\t\tbn_sub(p, p, t);\n\t\t\t}\n\t\t}\n\t\tif (f[0] > 0) {\n\t\t\tbn_add_dig(p, p, f[0]);\n\t\t} else {\n\t\t\tbn_sub_dig(p, p, -f[0]);\n\t\t}\n\n#if FP_RDC == QUICK || !defined(STRIP)\n\t\tctx_t *ctx = core_get();\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tctx->sps[i] = f[i];\n\t\t}\n\t\tctx->sps[len] = 0;\n\t\tctx->sps_len = len;\n#endif /* FP_RDC == QUICK */\n\n\t\tfp_prime_set(p);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(p);\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_prime_calc(void) {\n#ifdef WITH_FPX\n\tif (fp_prime_get_qnr() != 0) {\n\t\tfp2_field_init();\n\t\tfp4_field_init();\n\t}\n\tif (fp_prime_get_cnr() != 0) {\n\t\tfp3_field_init();\n\t}\n#endif\n}\n\nvoid fp_prime_conv(fp_t c, const bn_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\t/* Reduce a modulo the prime to ensure bounds. */\n\t\tbn_mod(t, a, &(core_get()->prime));\n\n\t\tif (bn_is_zero(t)) {\n\t\t\tfp_zero(c);\n\t\t} else {\n\t\t\t/* Copy used digits, fill the rest with zero. */\n\t\t\tdv_copy(c, t->dp, t->used);\n\t\t\tdv_zero(c + t->used, RLC_FP_DIGS - t->used);\n#if FP_RDC == MONTY\n\t\t\tfp_mul(c, c, core_get()->conv.dp);\n#endif\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_prime_conv_dig(fp_t c, dig_t a) {\n\tdv_t t;\n\tctx_t *ctx = core_get();\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tdv_new(t);\n\n#if FP_RDC == MONTY\n\t\tif (a != 1) {\n\t\t\tdv_zero(t, 2 * RLC_FP_DIGS + 1);\n\t\t\tt[RLC_FP_DIGS] = fp_mul1_low(t, ctx->conv.dp, a);\n\t\t\tfp_rdc(c, t);\n\t\t} else {\n\t\t\tdv_copy(c, ctx->one.dp, RLC_FP_DIGS);\n\t\t}\n#else\n\t\t(void)ctx;\n\t\tfp_zero(c);\n\t\tc[0] = a;\n#endif\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tdv_free(t);\n\t}\n}\n\nvoid fp_prime_back(bn_t c, const fp_t a) {\n\tdv_t t;\n\tint i;\n\n\tdv_null(t);\n\n\tRLC_TRY {\n\t\tdv_new(t);\n\n\t\tbn_grow(c, RLC_FP_DIGS);\n\t\tfor (i = 0; i < RLC_FP_DIGS; i++) {\n\t\t\tc->dp[i] = a[i];\n\t\t}\n#if FP_RDC == MONTY\n\t\tdv_zero(t, 2 * RLC_FP_DIGS + 1);\n\t\tdv_copy(t, a, RLC_FP_DIGS);\n\t\tfp_rdc(c->dp, t);\n#endif\n\t\tc->used = RLC_FP_DIGS;\n\t\tc->sign = RLC_POS;\n\t\tbn_trim(c);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tdv_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the prime field utilities.\n *\n * @ingroup fp\n */\n\n#include \"relic_core.h\"\n#include \"relic_fp_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp_copy(fp_t c, const fp_t a) {\n\tdv_copy(c, a, RLC_FP_DIGS);\n}\n\nvoid fp_zero(fp_t a) {\n\tdv_zero(a, RLC_FP_DIGS);\n}\n\nint fp_is_zero(const fp_t a) {\n\tint i;\n\tdig_t t = 0;\n\n\tfor (i = 0; i < RLC_FP_DIGS; i++) {\n\t\tt |= a[i];\n\t}\n\n\treturn !t;\n}\n\nint fp_is_even(const fp_t a) {\n\tif ((a[0] & 0x01) == 0) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint fp_get_bit(const fp_t a, size_t bit) {\n\tint d;\n\n\tRLC_RIP(bit, d, bit);\n\n\treturn (a[d] >> bit) & 1;\n}\n\nvoid fp_set_bit(fp_t a, size_t bit, int value) {\n\tint d;\n\tdig_t mask;\n\n\tRLC_RIP(bit, d, bit);\n\n\tmask = (dig_t)1 << bit;\n\n\tif (value == 1) {\n\t\ta[d] |= mask;\n\t} else {\n\t\ta[d] &= ~mask;\n\t}\n}\n\nsize_t fp_bits(const fp_t a) {\n\tint i = RLC_FP_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}\n\nvoid fp_set_dig(fp_t c, dig_t a) {\n\tfp_prime_conv_dig(c, a);\n}\n\nvoid fp_rand(fp_t a) {\n\tint bits, digits;\n\n\trand_bytes((uint8_t *)a, RLC_FP_DIGS * sizeof(dig_t));\n\n\tRLC_RIP(bits, digits, RLC_FP_BITS);\n\tif (bits > 0) {\n\t\tdig_t mask = ((dig_t)1 << (dig_t)bits) - 1;\n\t\ta[RLC_FP_DIGS - 1] &= mask;\n\t}\n\n\twhile (dv_cmp(a, fp_prime_get(), RLC_FP_DIGS) != RLC_LT) {\n\t\tfp_subm_low(a, a, fp_prime_get());\n\t}\n}\n\nvoid fp_print(const fp_t a) {\n\tint i;\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n#if FP_RDC == MONTY\n\t\tif (a != fp_prime_get()) {\n\t\t\tfp_prime_back(t, a);\n\t\t} else {\n\t\t\tbn_read_raw(t, a, RLC_FP_DIGS);\n\t\t}\n#else\n\t\tbn_read_raw(t, a, RLC_FP_DIGS);\n#endif\n\n\t\tfor (i = RLC_FP_DIGS - 1; i > 0; i--) {\n\t\t\tif (i >= t->used) {\n\t\t\t\tutil_print_dig(0, 1);\n\t\t\t} else {\n\t\t\t\tutil_print_dig(t->dp[i], 1);\n\t\t\t}\n\t\t\tutil_print(\" \");\n\t\t}\n\t\tutil_print_dig(t->dp[0], 1);\n\t\tutil_print(\"\\n\");\n\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nsize_t fp_size_str(const fp_t a, unsigned int radix) {\n\tbn_t t;\n\tsize_t digits = 0;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tfp_prime_back(t, a);\n\n\t\tdigits = bn_size_str(t, radix);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n\n\treturn digits;\n}\n\nvoid fp_read_str(fp_t a, const char *str, size_t len, unsigned int radix) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_read_str(t, str, len, radix);\n\t\tif (bn_is_zero(t)) {\n\t\t\tfp_zero(a);\n\t\t} else {\n\t\t\tif (t->used == 1) {\n\t\t\t\tfp_prime_conv_dig(a, t->dp[0]);\n\t\t\t\tif (bn_sign(t) == RLC_NEG) {\n\t\t\t\t\tfp_neg(a, a);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfp_prime_conv(a, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_write_str(char *str, size_t len, const fp_t a, unsigned int radix) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tfp_prime_back(t, a);\n\n\t\tbn_write_str(str, len, t, radix);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_read_bin(fp_t a, const uint8_t *bin, size_t len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\t\tbn_read_bin(t, bin, len);\n\n\t\t/* Reject values out of bounds. */\n\t\tif (bn_sign(t) == RLC_NEG || bn_cmp(t, &core_get()->prime) != RLC_LT) {\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t} else {\n\t\t\tif (bn_is_zero(t)) {\n\t\t\t\tfp_zero(a);\n\t\t\t} else {\n\t\t\t\tif (t->used == 1) {\n\t\t\t\t\tfp_prime_conv_dig(a, t->dp[0]);\n\t\t\t\t} else {\n\t\t\t\t\tfp_prime_conv(a, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n\nvoid fp_write_bin(uint8_t *bin, size_t len, const fp_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(t);\n\n\t\tfp_prime_back(t, a);\n\n\t\tbn_write_bin(bin, len, t);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(t);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of exponentiation in cyclotomic subgroups of extensions\n * defined over prime fields.\n *\n * @ingroup fpx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp2_conv_cyc(fp2_t c, const fp2_t a) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\t/* t = a^{-1}. */\n\t\tfp2_inv(t, a);\n\t\t/* c = a^p. */\n\t\tfp2_inv_cyc(c, a);\n\t\t/* c = a^(p - 1). */\n\t\tfp2_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nint fp2_test_cyc(const fp2_t a) {\n\tfp2_t t;\n\tint result = 0;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\t\tfp2_frb(t, a, 1);\n\t\tfp2_mul(t, t, a);\n\t\tresult = ((fp2_cmp_dig(t, 1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n\n\treturn result;\n}\n\nvoid fp2_exp_cyc(fp2_t c, const fp2_t a, const bn_t b) {\n\tfp2_t r, s, t[1 << (FP_WIDTH - 2)];\n\tint8_t naf[RLC_FP_BITS + 1], *k;\n\tsize_t l;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp2_set_dig(c, 1);\n\t}\n\n\tfp2_null(r);\n\tfp2_null(s);\n\n\tRLC_TRY {\n\t\tfp2_new(r);\n\t\tfp2_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp2_null(t[i]);\n\t\t\tfp2_new(t[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp2_sqr(t[0], a);\n\t\tfp2_mul(t[1], t[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_mul(t[i], t[i - 1], t[0]);\n\t\t}\n#endif\n\t\tfp2_copy(t[0], a);\n\n\t\tl = RLC_FP_BITS + 1;\n\t\tfp2_set_dig(r, 1);\n\t\tbn_rec_naf(naf, &l, b, FP_WIDTH);\n\n\t\tk = naf + l - 1;\n\n\t\tfor (int i = l - 1; i >= 0; i--, k--) {\n\t\t\tfp2_sqr(r, r);\n\n\t\t\tif (*k > 0) {\n\t\t\t\tfp2_mul(r, r, t[*k / 2]);\n\t\t\t}\n\t\t\tif (*k < 0) {\n\t\t\t\tfp2_inv_cyc(s, t[-*k / 2]);\n\t\t\t\tfp2_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp2_inv_cyc(c, r);\n\t\t} else {\n\t\t\tfp2_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(r);\n\t\tfp2_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_free(t[i]);\n\t\t}\n\t}\n}\n\nvoid fp8_conv_cyc(fp8_t c, const fp8_t a) {\n\tfp8_t t;\n\n\tfp8_null(t);\n\n\tRLC_TRY {\n\t\tfp8_new(t);\n\n\t\t/* t = a^{-1}. */\n\t\tfp8_inv(t, a);\n\t\t/* c = a^(p^4). */\n\t\tfp8_inv_cyc(c, a);\n\t\t/* c = a^(p^4 - 1). */\n\t\tfp8_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t);\n\t}\n}\n\nint fp8_test_cyc(const fp8_t a) {\n\tfp8_t t;\n\tint result = 0;\n\n\tfp8_null(t);\n\n\tRLC_TRY {\n\t\tfp8_new(t);\n\t\tfp8_inv_cyc(t, a);\n\t\tfp8_mul(t, t, a);\n\t\tresult = ((fp8_cmp_dig(t, 1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t);\n\t}\n\n\treturn result;\n}\n\nvoid fp8_exp_cyc(fp8_t c, const fp8_t a, const bn_t b) {\n\tfp8_t r, s, t[1 << (FP_WIDTH - 2)];\n\tint8_t naf[RLC_FP_BITS + 1], *k;\n\tsize_t l;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp8_set_dig(c, 1);\n\t}\n\n\tfp8_null(r);\n\tfp8_null(s);\n\n\tRLC_TRY {\n\t\tfp8_new(r);\n\t\tfp8_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp8_null(t[i]);\n\t\t\tfp8_new(t[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp8_sqr_cyc(t[0], a);\n\t\tfp8_mul(t[1], t[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp8_mul(t[i], t[i - 1], t[0]);\n\t\t}\n#endif\n\t\tfp8_copy(t[0], a);\n\n\t\tl = RLC_FP_BITS + 1;\n\t\tfp8_set_dig(r, 1);\n\t\tbn_rec_naf(naf, &l, b, FP_WIDTH);\n\n\t\tk = naf + l - 1;\n\n\t\tfor (int i = l - 1; i >= 0; i--, k--) {\n\t\t\tfp8_sqr_cyc(r, r);\n\n\t\t\tif (*k > 0) {\n\t\t\t\tfp8_mul(r, r, t[*k / 2]);\n\t\t\t}\n\t\t\tif (*k < 0) {\n\t\t\t\tfp8_inv_cyc(s, t[-*k / 2]);\n\t\t\t\tfp8_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp8_inv_cyc(c, r);\n\t\t} else {\n\t\t\tfp8_copy(c, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(r);\n\t\tfp8_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp8_free(t[i]);\n\t\t}\n\t}\n}\n\nvoid fp12_conv_cyc(fp12_t c, const fp12_t a) {\n\tfp12_t t;\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tfp12_new(t);\n\n\t\t/* First, compute c = a^(p^6 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp12_inv(t, a);\n\t\t/* c = a^(p^6). */\n\t\tfp12_inv_cyc(c, a);\n\t\t/* c = a^(p^6 - 1). */\n\t\tfp12_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^2 + 1). */\n\t\t/* t = c^(p^2). */\n\t\tfp12_frb(t, c, 2);\n\n\t\t/* c = c^(p^2 + 1). */\n\t\tfp12_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(t);\n\t}\n}\n\nint fp12_test_cyc(const fp12_t a) {\n\tfp12_t t0, t1;\n\tint result = 0;\n\n\tfp12_null(t0);\n\tfp12_null(t1);\n\n\tRLC_TRY {\n\t\tfp12_new(t0);\n\t\tfp12_new(t1);\n\n\t\t/* Check if a^(p^4 - p^2 + 1) == 1. */\n\t\tfp12_frb(t0, a, 4);\n\t\tfp12_mul(t0, t0, a);\n\t\tfp12_frb(t1, a, 2);\n\n\t\tresult = ((fp12_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(t0);\n\t\tfp12_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp12_back_cyc(fp12_t c, const fp12_t a) {\n\tfp2_t t0, t1, t2;\n\n\tfp2_null(t0);\n\tfp2_null(t1);\n\tfp2_null(t2);\n\n\tRLC_TRY {\n\t\tfp2_new(t0);\n\t\tfp2_new(t1);\n\t\tfp2_new(t2);\n\n\t\tif (fp2_is_zero(a[1][0])) {\n\t\t\t/* t0 = 2 * g4 * g5 */\n\t\t\tfp2_mul(t0, a[0][1], a[1][2]);\n\t\t\tfp2_dbl(t0, t0);\n\t\t\tfp2_copy(t1, a[0][2]);\n\t\t} else {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp2_sqr(t0, a[0][1]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp2_sub(t1, t0, a[0][2]);\n\t\t\tfp2_dbl(t1, t1);\n\t\t\tfp2_add(t1, t1, t0);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp2_sqr(t2, a[1][2]);\n\t\t\tfp2_mul_nor(t0, t2);\n\t\t\tfp2_add(t0, t0, t1);\n\t\t\t/* t1 = 1/(4 * g2). */\n\t\t\tfp2_dbl(t1, a[1][0]);\n\t\t\tfp2_dbl(t1, t1);\n\t\t}\n\n\t\tfp2_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp2_mul(c[1][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp2_mul(t1, a[0][2], a[0][1]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp2_sqr(t2, c[1][1]);\n\t\tfp2_sub(t2, t2, t1);\n\t\tfp2_dbl(t2, t2);\n\t\tfp2_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp2_mul(t1, a[1][0], a[1][2]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp2_add(t2, t2, t1);\n\t\tfp2_mul_nor(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0], c[0][0][0], 1);\n\n\t\tfp2_copy(c[0][1], a[0][1]);\n\t\tfp2_copy(c[0][2], a[0][2]);\n\t\tfp2_copy(c[1][0], a[1][0]);\n\t\tfp2_copy(c[1][2], a[1][2]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t0);\n\t\tfp2_free(t1);\n\t\tfp2_free(t2);\n\t}\n}\n\nvoid fp12_back_cyc_sim(fp12_t c[], const fp12_t a[], int n) {\n    fp2_t *t = RLC_ALLOCA(fp2_t, n * 3);\n    fp2_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp2_null(t0[i]);\n\t\t\tfp2_null(t1[i]);\n\t\t\tfp2_null(t2[i]);\n\t\t\tfp2_new(t0[i]);\n\t\t\tfp2_new(t1[i]);\n\t\t\tfp2_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* TODO: make this constant time. */\n\t\t\tif (fp2_is_zero(a[i][1][0])) {\n\t\t\t\t/* t0 = 2 * g4 * g5 */\n\t\t\t\tfp2_mul(t0[i], a[i][0][1], a[i][1][2]);\n\t\t\t\tfp2_dbl(t0[i], t0[i]);\n\t\t\t\tfp2_copy(t1[i], a[i][0][2]);\n\t\t\t} else {\n\t\t\t\t/* t0 = g4^2. */\n\t\t\t\tfp2_sqr(t0[i], a[i][0][1]);\n\t\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\t\tfp2_sub(t1[i], t0[i], a[i][0][2]);\n\t\t\t\tfp2_dbl(t1[i], t1[i]);\n\t\t\t\tfp2_add(t1[i], t1[i], t0[i]);\n\t\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\t\tfp2_sqr(t2[i], a[i][1][2]);\n\t\t\t\tfp2_mul_nor(t0[i], t2[i]);\n\t\t\t\tfp2_add(t0[i], t0[i], t1[i]);\n\t\t\t\t/* t1 = (4 * g2). */\n\t\t\t\tfp2_dbl(t1[i], a[i][1][0]);\n\t\t\t\tfp2_dbl(t1[i], t1[i]);\n\t\t\t}\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp2_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp2_mul(c[i][1][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp2_mul(t1[i], a[i][0][2], a[i][0][1]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp2_sqr(t2[i], c[i][1][1]);\n\t\t\tfp2_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp2_dbl(t2[i], t2[i]);\n\t\t\tfp2_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp2_mul(t1[i], a[i][1][0], a[i][1][2]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp2_add(t2[i], t2[i], t1[i]);\n\t\t\tfp2_mul_nor(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0], c[i][0][0][0], 1);\n\n\t\t\tfp2_copy(c[i][0][1], a[i][0][1]);\n\t\t\tfp2_copy(c[i][0][2], a[i][0][2]);\n\t\t\tfp2_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp2_copy(c[i][1][2], a[i][1][2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp2_free(t0[i]);\n\t\t\tfp2_free(t1[i]);\n\t\t\tfp2_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp12_exp_cyc(fp12_t c, const fp12_t a, const bn_t b) {\n\tsize_t j, k, l, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp12_set_dig(c, 1);\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tsize_t _l[4];\n\t\tint8_t naf[4][RLC_FP_BITS + 1];\n\t\tfp12_t t[4];\n\t\tbn_t _b[4], n, u;\n\n\t\tbn_null(n);\n\t\tbn_null(u);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(n);\n\t\t\tbn_new(u);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tbn_null(_b[i]);\n\t\t\t\tbn_new(_b[i]);\n\t\t\t\tfp12_null(t[i]);\n\t\t\t\tfp12_new(t[i]);\n\t\t\t}\n\n\t\t\tep_curve_get_ord(n);\n\t\t\tfp_prime_get_par(u);\n\t\t\tbn_rec_frb(_b, 4, b, u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\t\tif (ep_curve_is_pairf()) {\n\t\t\t\tfp12_copy(t[0], a);\n\t\t\t\tfp12_frb(t[1], t[0], 1);\n\t\t\t\tfp12_frb(t[2], t[1], 1);\n\t\t\t\tfp12_frb(t[3], t[2], 1);\n\n\t\t\t\tl = 0;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n\t\t\t\t\t\tfp12_inv_cyc(t[i], t[i]);\n\t\t\t\t\t}\n\t\t\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\t\t\tbn_rec_naf(naf[i], &_l[i], _b[i], 2);\n\t\t\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t\t}\n\n\t\t\t\tfp12_set_dig(c, 1);\n\t\t\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\t\t\tfp12_sqr_cyc(c, c);\n\t\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\t\tif (naf[j][i] > 0) {\n\t\t\t\t\t\t\tfp12_mul(c, c, t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[j][i] < 0) {\n\t\t\t\t\t\t\tfp12_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t\tfp12_mul(c, c, t[j]);\n\t\t\t\t\t\t\tfp12_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfp12_copy(t[0], a);\n\n\t\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\t\tfp12_sqr_cyc(t[0], t[0]);\n\t\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\t\tfp12_mul(t[0], t[0], a);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfp12_copy(c, t[0]);\n\t\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\t\tfp12_inv_cyc(c, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tbn_free(n);\n\t\t\tbn_free(u);\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tbn_free(_b[i]);\n\t\t\t\tfp12_free(t[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfp12_t t, *u = RLC_ALLOCA(fp12_t, w);\n\n\t\tfp12_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tfp12_null(u[i]);\n\t\t\t\tfp12_new(u[i]);\n\t\t\t}\n\t\t\tfp12_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp12_copy(t, a);\n\t\t\tfor (size_t i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp12_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp12_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp12_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp12_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp12_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (size_t i = j; i < k; i++) {\n\t\t\t\tfp12_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp12_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (size_t i = 0; i < w; i++) {\n\t\t\t\tfp12_free(u[i]);\n\t\t\t}\n\t\t\tfp12_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp2_exp_cyc_sim(fp2_t e, const fp2_t a, const bn_t b, const fp2_t c, const bn_t d) {\n\tint n0, n1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp2_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp2_t s, t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp2_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp2_exp_cyc(e, a, b);\n\t}\n\n\tfp2_null(r);\n\tfp2_null(s);\n\n\tRLC_TRY {\n\t\tfp2_new(r);\n\t\tfp2_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp2_null(t0[i]);\n\t\t\tfp2_null(t1[i]);\n\t\t\tfp2_new(t0[i]);\n\t\t\tfp2_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp2_sqr(t0[0], a);\n\t\tfp2_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_mul(t0[i], t0[i - 1], t0[0]);\n\t\t}\n\n\t\tfp2_sqr(t1[0], c);\n\t\tfp2_mul(t1[1], t1[0], c);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_mul(t1[i], t1[i - 1], t1[0]);\n\t\t}\n#endif\n\t\tfp2_copy(t0[0], a);\n\t\tfp2_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp2_set_dig(r, 1);\n\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp2_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp2_mul(r, r, t0[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp2_inv_cyc(s, t0[-n0 / 2]);\n\t\t\t\tfp2_mul(r, r, s);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tfp2_mul(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tfp2_inv_cyc(s, t1[-n1 / 2]);\n\t\t\t\tfp2_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tfp2_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(r);\n\t\tfp2_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp2_free(t0[i]);\n\t\t\tfp2_free(t1[i]);\n\t\t}\n\t}\n}\n\n\nvoid fp12_exp_cyc_sim(fp12_t e, const fp12_t a, const bn_t b, const fp12_t c, const bn_t d) {\n\tint i, j, l;\n\tbn_t _b[4], _d[4], n, x;\n\tfp12_t t[4], u[4];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp12_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp12_exp_cyc(e, a, b);\n\t}\n\n\tbn_null(n);\n\tbn_null(x);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(x);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_b[i]);\n\t\t\tbn_null(_d[i]);\n\t\t\tfp12_null(t[i]);\n\t\t\tfp12_null(u[i]);\n\t\t\tbn_new(_b[i]);\n\t\t\tbn_new(_d[i]);\n\t\t\tfp12_new(t[i]);\n\t\t\tfp12_new(u[i]);\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tfp_prime_get_par(x);\n\t\tbn_rec_frb(_b, 4, b, x, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_rec_frb(_d, 4, d, x, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tif (ep_curve_is_pairf()) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tfp12_frb(t[i], a, i);\n\t\t\t\tfp12_frb(u[i], c, i);\n\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n\t\t\t\t\tfp12_inv_cyc(t[i], t[i]);\n\t\t\t\t}\n\t\t\t\tif (bn_sign(_d[i]) == RLC_NEG) {\n\t\t\t\t\tfp12_inv_cyc(u[i], u[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tl = RLC_MAX(bn_bits(_b[0]), bn_bits(_b[1]));\n\t\t\tl = RLC_MAX(l, RLC_MAX(bn_bits(_b[2]), bn_bits(_b[3])));\n\t\t\tl = RLC_MAX(l, RLC_MAX(bn_bits(_d[0]), bn_bits(_d[1])));\n\t\t\tl = RLC_MAX(l, RLC_MAX(bn_bits(_d[2]), bn_bits(_d[3])));\n\n\t\t\tfp12_set_dig(e, 1);\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfp12_sqr_cyc(e, e);\n\t\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\t\tif (bn_get_bit(_b[j], i)) {\n\t\t\t\t\t\tfp12_mul(e, e, t[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (bn_get_bit(_d[j], i)) {\n\t\t\t\t\t\tfp12_mul(e, e, u[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp12_inv_cyc(t[0], a);\n\t\t\t} else {\n\t\t\t\tfp12_copy(t[0], a);\n\t\t\t}\n\t\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\t\tfp12_inv_cyc(u[0], c);\n\t\t\t} else {\n\t\t\t\tfp12_copy(u[0], c);\n\t\t\t}\n\n\t\t\tfp12_set_dig(e, 1);\n\t\t\tl = RLC_MAX(bn_bits(b), bn_bits(d));\n\t\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\t\tfp12_sqr_cyc(e, e);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp12_mul(e, e, t[0]);\n\t\t\t\t}\n\t\t\t\tif (bn_get_bit(d, i)) {\n\t\t\t\t\tfp12_mul(e, e, u[0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(x);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_b[i]);\n\t\t\tbn_free(_d[i]);\n\t\t\tfp12_free(t[i]);\n\t\t\tfp12_free(u[i]);\n\t\t}\n\t}\n}\n\nvoid fp12_exp_cyc_sps(fp12_t c, const fp12_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp12_t t, *u = RLC_ALLOCA(fp12_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp12_null(u[i]);\n\t\t\tfp12_new(u[i]);\n\t\t}\n\t\tfp12_new(t);\n\n\t\tfp12_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp12_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp12_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp12_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp12_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp12_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp12_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp12_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp12_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp12_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp12_back_cyc_sim(u, u, w);\n\n\t\t\tfp12_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp12_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp12_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp12_free(u[i]);\n\t\t}\n\t\tfp12_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n\nvoid fp24_conv_cyc(fp24_t c, const fp24_t a) {\n\tfp24_t t;\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tfp24_new(t);\n\n\t\t/* First, compute c = a^(p^12 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp24_inv(t, a);\n\t\t/* c = a^(p^12). */\n\t\tfp24_inv_cyc(c, a);\n\t\t/* c = a^(p^12 - 1). */\n\t\tfp24_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^4 + 1). */\n\t\t/* t = c^(p^4). */\n\t\tfp24_frb(t, c, 4);\n\n\t\t/* c = c^(p^4 + 1). */\n\t\tfp24_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(t);\n\t}\n}\n\nint fp24_test_cyc(const fp24_t a) {\n\tfp24_t t0, t1;\n\tint result = 0;\n\n\tfp24_null(t0);\n\tfp24_null(t1);\n\n\tRLC_TRY {\n\t\tfp24_new(t0);\n\t\tfp24_new(t1);\n\n\t\t/* Check if a^(p^8 - p^4 + 1) == 1. */\n\t\tfp24_frb(t0, a, 8);\n\t\tfp24_mul(t0, t0, a);\n\t\tfp24_frb(t1, a, 4);\n\n\t\tresult = ((fp24_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(t0);\n\t\tfp24_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp24_back_cyc(fp24_t c, const fp24_t a) {\n\tfp4_t t0, t1, t2;\n\n\tfp4_null(t0);\n\tfp4_null(t1);\n\tfp4_null(t2);\n\n\tRLC_TRY {\n\t\tfp4_new(t0);\n\t\tfp4_new(t1);\n\t\tfp4_new(t2);\n\n\t\t/* t0 = g4^2. */\n\t\tfp4_sqr(t0, a[2][0]);\n\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\tfp4_sub(t1, t0, a[1][1]);\n\t\tfp4_dbl(t1, t1);\n\t\tfp4_add(t1, t1, t0);\n\t\t/* t0 = E * g5^2 + t1. */\n\t\tfp4_sqr(t2, a[2][1]);\n\t\tfp4_mul_art(t0, t2);\n\t\tfp4_add(t0, t0, t1);\n\t\t/* t1 = 1/(4 * g2). */\n\t\tfp4_dbl(t1, a[1][0]);\n\t\tfp4_dbl(t1, t1);\n\t\tfp4_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp4_mul(c[0][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp4_mul(t1, a[1][1], a[2][0]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp4_sqr(t2, c[0][1]);\n\t\tfp4_sub(t2, t2, t1);\n\t\tfp4_dbl(t2, t2);\n\t\tfp4_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp4_mul(t1, a[1][0], a[2][1]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp4_add(t2, t2, t1);\n\t\tfp4_mul_art(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0][0], c[0][0][0][0], 1);\n\n\t\tfp4_copy(c[1][0], a[1][0]);\n\t\tfp4_copy(c[1][1], a[1][1]);\n\t\tfp4_copy(c[2][0], a[2][0]);\n\t\tfp4_copy(c[2][1], a[2][1]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp4_free(t0);\n\t\tfp4_free(t1);\n\t\tfp4_free(t2);\n\t}\n}\n\nvoid fp24_back_cyc_sim(fp24_t c[], const fp24_t a[], int n) {\n    fp4_t *t = RLC_ALLOCA(fp4_t, n * 3);\n    fp4_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp4_null(t0[i]);\n\t\t\tfp4_null(t1[i]);\n\t\t\tfp4_null(t2[i]);\n\t\t\tfp4_new(t0[i]);\n\t\t\tfp4_new(t1[i]);\n\t\t\tfp4_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp4_sqr(t0[i], a[i][2][0]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp4_sub(t1[i], t0[i], a[i][1][1]);\n\t\t\tfp4_dbl(t1[i], t1[i]);\n\t\t\tfp4_add(t1[i], t1[i], t0[i]);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp4_sqr(t2[i], a[i][2][1]);\n\t\t\tfp4_mul_art(t0[i], t2[i]);\n\t\t\tfp4_add(t0[i], t0[i], t1[i]);\n\t\t\t/* t1 = (4 * g2). */\n\t\t\tfp4_dbl(t1[i], a[i][1][0]);\n\t\t\tfp4_dbl(t1[i], t1[i]);\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp4_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp4_mul(c[i][0][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp4_mul(t1[i], a[i][1][1], a[i][2][0]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp4_sqr(t2[i], c[i][0][1]);\n\t\t\tfp4_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp4_dbl(t2[i], t2[i]);\n\t\t\tfp4_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp4_mul(t1[i], a[i][1][0], a[i][2][1]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp4_add(t2[i], t2[i], t1[i]);\n\t\t\tfp4_mul_art(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0][0], c[i][0][0][0][0], 1);\n\n\t\t\tfp4_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp4_copy(c[i][1][1], a[i][1][1]);\n\t\t\tfp4_copy(c[i][2][0], a[i][2][0]);\n\t\t\tfp4_copy(c[i][2][1], a[i][2][1]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp4_free(t0[i]);\n\t\t\tfp4_free(t1[i]);\n\t\t\tfp4_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp24_exp_cyc(fp24_t c, const fp24_t a, const bn_t b) {\n\tsize_t j, k, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tsize_t l, _l[8];\n\t\tint8_t naf[8][RLC_FP_BITS + 1];\n\t\tfp24_t t[8];\n\t\tbn_t _b[8], n, x;\n\n\t\tbn_null(n);\n\t\tbn_null(x);\n\n\t\tRLC_TRY {\n\t\t\tbn_new(n);\n\t\t\tbn_new(x);\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tbn_null(_b[i]);\n\t\t\t\tbn_new(_b[i]);\n\t\t\t\tfp24_null(t[i]);\n\t\t\t\tfp24_new(t[i]);\n\t\t\t}\n\n\t\t\tep_curve_get_ord(n);\n\t\t\tfp_prime_get_par(x);\n\t\t\tbn_rec_frb(_b, 8, b, x, n, ep_curve_is_pairf() == EP_BN);\n\n\t\t\tif (ep_curve_is_pairf()) {\n\t\t\t\tl = 0;\n\n\t\t\t\tfp24_copy(t[0], a);\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\t\t\tbn_rec_naf(naf[i], &_l[i], _b[i], 2);\n\t\t\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tfp24_frb(t[i], t[i - 1], 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\t\tif (bn_sign(_b[i]) == RLC_NEG) {\n\t\t\t\t\t\tfp24_inv_cyc(t[i], t[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfp24_set_dig(c, 1);\n\t\t\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\t\t\tfp24_sqr_cyc(c, c);\n\t\t\t\t\tfor (int j = 0; j < 8; j++) {\n\t\t\t\t\t\tif (naf[j][i] > 0) {\n\t\t\t\t\t\t\tfp24_mul(c, c, t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (naf[j][i] < 0) {\n\t\t\t\t\t\t\tfp24_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t\tfp24_mul(c, c, t[j]);\n\t\t\t\t\t\t\tfp24_inv_cyc(t[j], t[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfp24_copy(t[0], a);\n\n\t\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\t\tfp24_sqr_cyc(t[0], t[0]);\n\t\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\t\tfp24_mul(t[0], t[0], a);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfp24_copy(c, t[0]);\n\t\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\t\tfp24_inv_cyc(c, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tbn_free(n);\n\t\t\tbn_free(x);\n\t\t\tfor (int i = 0; i < 8; i++) {\n\t\t\t\tbn_free(_b[i]);\n\t\t\t\tfp24_free(t[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfp24_t t, *u = RLC_ALLOCA(fp24_t, w);\n\n\t\tfp24_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tfor (size_t i = 0; i < w; i++) {\n\t\t\t\tfp24_null(u[i]);\n\t\t\t\tfp24_new(u[i]);\n\t\t\t}\n\t\t\tfp24_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp24_copy(t, a);\n\t\t\tfor (size_t i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp24_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp24_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp24_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp24_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp24_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (size_t i = j; i < k; i++) {\n\t\t\t\tfp24_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp24_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (size_t i = 0; i < w; i++) {\n\t\t\t\tfp24_free(u[i]);\n\t\t\t}\n\t\t\tfp24_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint n0, n1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp24_exp_cyc(e, a, b);\n\t}\n\n\tfp24_null(r);\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp24_sqr(t0[0], a);\n\t\tfp24_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_mul(t0[i], t0[i - 1], t0[0]);\n\t\t}\n\n\t\tfp24_sqr(t1[0], c);\n\t\tfp24_mul(t1[1], t1[0], c);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_mul(t1[i], t1[i - 1], t1[0]);\n\t\t}\n#endif\n\t\tfp24_copy(t0[0], a);\n\t\tfp24_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp24_mul(r, r, t0[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t0[-n0 / 2]);\n\t\t\t\tfp24_mul(r, r, s);\n\t\t\t}\n\t\t\tif (n1 > 0) {\n\t\t\t\tfp24_mul(r, r, t1[n1 / 2]);\n\t\t\t}\n\t\t\tif (n1 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t1[-n1 / 2]);\n\t\t\t\tfp24_mul(r, r, s);\n\t\t\t}\n\t\t}\n\n\t\tfp24_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}\n\nvoid fp24_exp_cyc_sps(fp24_t c, const fp24_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp24_t t, *u = RLC_ALLOCA(fp24_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp24_null(u[i]);\n\t\t\tfp24_new(u[i]);\n\t\t}\n\t\tfp24_new(t);\n\n\t\tfp24_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp24_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp24_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp24_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp24_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp24_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp24_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp24_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp24_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp24_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp24_back_cyc_sim(u, u, w);\n\n\t\t\tfp24_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp24_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp24_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp24_free(u[i]);\n\t\t}\n\t\tfp24_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n\nvoid fp48_conv_cyc(fp48_t c, const fp48_t a) {\n\tfp48_t t;\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tfp48_new(t);\n\n\t\t/* First, compute c = a^(p^24 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp48_inv(t, a);\n\t\t/* c = a^(p^24). */\n\t\tfp48_inv_cyc(c, a);\n\t\t/* c = a^(p^24 - 1). */\n\t\tfp48_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^8 + 1). */\n\t\t/* t = c^(p^8). */\n\t\tfp48_frb(t, c, 8);\n\n\t\t/* c = c^(p^8 + 1). */\n\t\tfp48_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(t);\n\t}\n}\n\nint fp48_test_cyc(const fp48_t a) {\n\tfp48_t t0, t1;\n\tint result = 0;\n\n\tfp48_null(t0);\n\tfp48_null(t1);\n\n\tRLC_TRY {\n\t\tfp48_new(t0);\n\t\tfp48_new(t1);\n\n\t\t/* Check if a^(p^16 - p^8 + 1) == 1. */\n\t\tfp48_frb(t0, a, 16);\n\t\tfp48_mul(t0, t0, a);\n\t\tfp48_frb(t1, a, 8);\n\n\t\tresult = ((fp48_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(t0);\n\t\tfp48_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp48_back_cyc(fp48_t c, const fp48_t a) {\n\tfp8_t t0, t1, t2;\n\n\tfp8_null(t0);\n\tfp8_null(t1);\n\tfp8_null(t2);\n\n\tRLC_TRY {\n\t\tfp8_new(t0);\n\t\tfp8_new(t1);\n\t\tfp8_new(t2);\n\n\t\t/* t0 = g4^2. */\n\t\tfp8_sqr(t0, a[0][1]);\n\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\tfp8_sub(t1, t0, a[0][2]);\n\t\tfp8_dbl(t1, t1);\n\t\tfp8_add(t1, t1, t0);\n\t\t/* t0 = E * g5^2 + t1. */\n\t\tfp8_sqr(t2, a[1][2]);\n\t\tfp8_mul_art(t0, t2);\n\t\tfp8_add(t0, t0, t1);\n\t\t/* t1 = 1/(4 * g2). */\n\t\tfp8_dbl(t1, a[1][0]);\n\t\tfp8_dbl(t1, t1);\n\t\tfp8_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp8_mul(c[1][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp8_mul(t1, a[0][2], a[0][1]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp8_sqr(t2, c[1][1]);\n\t\tfp8_sub(t2, t2, t1);\n\t\tfp8_dbl(t2, t2);\n\t\tfp8_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp8_mul(t1, a[1][0], a[1][2]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp8_add(t2, t2, t1);\n\t\tfp8_mul_art(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0][0][0], c[0][0][0][0][0], 1);\n\n\t\tfp8_copy(c[0][1], a[0][1]);\n\t\tfp8_copy(c[0][2], a[0][2]);\n\t\tfp8_copy(c[1][0], a[1][0]);\n\t\tfp8_copy(c[1][2], a[1][2]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t0);\n\t\tfp8_free(t1);\n\t\tfp8_free(t2);\n\t}\n}\n\nvoid fp48_back_cyc_sim(fp48_t c[], const fp48_t a[], int n) {\n    fp8_t *t = RLC_ALLOCA(fp8_t, n * 3);\n    fp8_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp8_null(t0[i]);\n\t\t\tfp8_null(t1[i]);\n\t\t\tfp8_null(t2[i]);\n\t\t\tfp8_new(t0[i]);\n\t\t\tfp8_new(t1[i]);\n\t\t\tfp8_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp8_sqr(t0[i], a[i][0][1]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp8_sub(t1[i], t0[i], a[i][0][2]);\n\t\t\tfp8_dbl(t1[i], t1[i]);\n\t\t\tfp8_add(t1[i], t1[i], t0[i]);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp8_sqr(t2[i], a[i][1][2]);\n\t\t\tfp8_mul_art(t0[i], t2[i]);\n\t\t\tfp8_add(t0[i], t0[i], t1[i]);\n\t\t\t/* t1 = (4 * g2). */\n\t\t\tfp8_dbl(t1[i], a[i][1][0]);\n\t\t\tfp8_dbl(t1[i], t1[i]);\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp8_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp8_mul(c[i][1][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp8_mul(t1[i], a[i][0][2], a[i][0][1]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp8_sqr(t2[i], c[i][1][1]);\n\t\t\tfp8_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp8_dbl(t2[i], t2[i]);\n\t\t\tfp8_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp8_mul(t1[i], a[i][1][0], a[i][1][2]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp8_add(t2[i], t2[i], t1[i]);\n\t\t\tfp8_mul_art(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0][0][0], c[i][0][0][0][0][0], 1);\n\n\t\t\tfp8_copy(c[i][0][1], a[i][0][1]);\n\t\t\tfp8_copy(c[i][0][2], a[i][0][2]);\n\t\t\tfp8_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp8_copy(c[i][1][2], a[i][1][2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp8_free(t0[i]);\n\t\t\tfp8_free(t1[i]);\n\t\t\tfp8_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp48_exp_cyc(fp48_t c, const fp48_t a, const bn_t b) {\n\tint i, j, k, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp48_set_dig(c, 1);\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tfp48_t t;\n\n\t\tfp48_null(t)\n\n\t\tRLC_TRY {\n\t\t\tfp48_new(t);\n\n\t\t\tfp48_copy(t, a);\n\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr_cyc(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp48_copy(c, t);\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp48_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfp48_free(t);\n\t\t}\n\t} else {\n\t\tfp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\t\tfp48_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t}\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp48_null(u[i]);\n\t\t\t\tfp48_new(u[i]);\n\t\t\t}\n\t\t\tfp48_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp48_copy(t, a);\n\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp48_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp48_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp48_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp48_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp48_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (i = j; i < k; i++) {\n\t\t\t\tfp48_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp48_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp48_free(u[i]);\n\t\t\t}\n\t\t\tfp48_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp48_null(u[i]);\n\t\t\tfp48_new(u[i]);\n\t\t}\n\t\tfp48_new(t);\n\n\t\tfp48_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp48_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp48_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp48_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp48_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp48_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp48_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp48_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp48_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp48_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp48_back_cyc_sim(u, u, w);\n\n\t\t\tfp48_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp48_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp48_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp48_free(u[i]);\n\t\t}\n\t\tfp48_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n\nvoid fp54_conv_cyc(fp54_t c, const fp54_t a) {\n\tfp54_t t;\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tfp54_new(t);\n\n\t\t/* First, compute c = a^(p^27 - 1). */\n\t\t/* t = a^{-1}. */\n\t\tfp54_inv(t, a);\n\t\t/* c = a^(p^27). */\n\t\tfp54_inv_cyc(c, a);\n\t\t/* c = a^(p^27 - 1). */\n\t\tfp54_mul(c, c, t);\n\n\t\t/* Second, compute c^(p^9 + 1). */\n\t\t/* t = c^(p^9). */\n\t\tfp54_frb(t, c, 9);\n\n\t\t/* c = c^(p^9 + 1). */\n\t\tfp54_mul(c, c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(t);\n\t}\n}\n\nint fp54_test_cyc(const fp54_t a) {\n\tfp54_t t0, t1;\n\tint result = 0;\n\n\tfp54_null(t0);\n\tfp54_null(t1);\n\n\tRLC_TRY {\n\t\tfp54_new(t0);\n\t\tfp54_new(t1);\n\n\t\t/* Check if a^(p^18 - p^9 + 1) == 1. */\n\t\tfp54_frb(t0, a, 18);\n\t\tfp54_mul(t0, t0, a);\n\t\tfp54_frb(t1, a, 9);\n\t\tresult = ((fp54_cmp(t0, t1) == RLC_EQ) ? 1 : 0);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(t0);\n\t\tfp54_free(t1);\n\t}\n\n\treturn result;\n}\n\nvoid fp54_back_cyc(fp54_t c, const fp54_t a) {\n\tfp9_t t0, t1, t2;\n\n\tfp9_null(t0);\n\tfp9_null(t1);\n\tfp9_null(t2);\n\n\tRLC_TRY {\n\t\tfp9_new(t0);\n\t\tfp9_new(t1);\n\t\tfp9_new(t2);\n\n\t\t/* t0 = g4^2. */\n\t\tfp9_sqr(t0, a[2][0]);\n\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\tfp9_sub(t1, t0, a[1][1]);\n\t\tfp9_dbl(t1, t1);\n\t\tfp9_add(t1, t1, t0);\n\t\t/* t0 = E * g5^2 + t1. */\n\t\tfp9_sqr(t2, a[2][1]);\n\t\tfp9_mul_art(t0, t2);\n\t\tfp9_add(t0, t0, t1);\n\t\t/* t1 = 1/(4 * g2). */\n\t\tfp9_dbl(t1, a[1][0]);\n\t\tfp9_dbl(t1, t1);\n\t\tfp9_inv(t1, t1);\n\t\t/* c_1 = g1. */\n\t\tfp9_mul(c[0][1], t0, t1);\n\n\t\t/* t1 = g3 * g4. */\n\t\tfp9_mul(t1, a[1][1], a[2][0]);\n\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\tfp9_sqr(t2, c[0][1]);\n\t\tfp9_sub(t2, t2, t1);\n\t\tfp9_dbl(t2, t2);\n\t\tfp9_sub(t2, t2, t1);\n\t\t/* t1 = g2 * g5. */\n\t\tfp9_mul(t1, a[1][0], a[2][1]);\n\t\t/* c_0 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\tfp9_add(t2, t2, t1);\n\t\tfp9_mul_art(c[0][0], t2);\n\t\tfp_add_dig(c[0][0][0][0], c[0][0][0][0], 1);\n\n\t\tfp9_copy(c[1][0], a[1][0]);\n\t\tfp9_copy(c[1][1], a[1][1]);\n\t\tfp9_copy(c[2][0], a[2][0]);\n\t\tfp9_copy(c[2][1], a[2][1]);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp9_free(t0);\n\t\tfp9_free(t1);\n\t\tfp9_free(t2);\n\t}\n}\n\nvoid fp54_back_cyc_sim(fp54_t c[], const fp54_t a[], int n) {\n    fp9_t *t = RLC_ALLOCA(fp9_t, n * 3);\n    fp9_t\n        *t0 = t + 0 * n,\n        *t1 = t + 1 * n,\n        *t2 = t + 2 * n;\n\n\tif (n == 0) {\n\t\tRLC_FREE(t);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tif (t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp9_null(t0[i]);\n\t\t\tfp9_null(t1[i]);\n\t\t\tfp9_null(t2[i]);\n\t\t\tfp9_new(t0[i]);\n\t\t\tfp9_new(t1[i]);\n\t\t\tfp9_new(t2[i]);\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g4^2. */\n\t\t\tfp9_sqr(t0[i], a[i][2][0]);\n\t\t\t/* t1 = 3 * g4^2 - 2 * g3. */\n\t\t\tfp9_sub(t1[i], t0[i], a[i][1][1]);\n\t\t\tfp9_dbl(t1[i], t1[i]);\n\t\t\tfp9_add(t1[i], t1[i], t0[i]);\n\t\t\t/* t0 = E * g5^2 + t1. */\n\t\t\tfp9_sqr(t2[i], a[i][2][1]);\n\t\t\tfp9_mul_art(t0[i], t2[i]);\n\t\t\tfp9_add(t0[i], t0[i], t1[i]);\n\t\t\t/* t1 = (4 * g2). */\n\t\t\tfp9_dbl(t1[i], a[i][1][0]);\n\t\t\tfp9_dbl(t1[i], t1[i]);\n\t\t}\n\n\t\t/* t1 = 1 / t1. */\n\t\tfp9_inv_sim(t1, t1, n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\t/* t0 = g1. */\n\t\t\tfp9_mul(c[i][0][1], t0[i], t1[i]);\n\n\t\t\t/* t1 = g3 * g4. */\n\t\t\tfp9_mul(t1[i], a[i][1][1], a[i][2][0]);\n\t\t\t/* t2 = 2 * g1^2 - 3 * g3 * g4. */\n\t\t\tfp9_sqr(t2[i], c[i][0][1]);\n\t\t\tfp9_sub(t2[i], t2[i], t1[i]);\n\t\t\tfp9_dbl(t2[i], t2[i]);\n\t\t\tfp9_sub(t2[i], t2[i], t1[i]);\n\t\t\t/* t1 = g2 * g5. */\n\t\t\tfp9_mul(t1[i], a[i][1][0], a[i][2][1]);\n\t\t\t/* t2 = E * (2 * g1^2 + g2 * g5 - 3 * g3 * g4) + 1. */\n\t\t\tfp9_add(t2[i], t2[i], t1[i]);\n\t\t\tfp9_mul_art(c[i][0][0], t2[i]);\n\t\t\tfp_add_dig(c[i][0][0][0][0], c[i][0][0][0][0], 1);\n\n\t\t\tfp9_copy(c[i][1][0], a[i][1][0]);\n\t\t\tfp9_copy(c[i][1][1], a[i][1][1]);\n\t\t\tfp9_copy(c[i][2][0], a[i][2][0]);\n\t\t\tfp9_copy(c[i][2][1], a[i][2][1]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfp9_free(t0[i]);\n\t\t\tfp9_free(t1[i]);\n\t\t\tfp9_free(t2[i]);\n\t\t}\n\t\tRLC_FREE(t);\n\t}\n}\n\nvoid fp54_exp_cyc(fp54_t c, const fp54_t a, const bn_t b) {\n\tint i, j, k, w = bn_ham(b);\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp54_set_dig(c, 1);\n\t}\n\n\tif ((bn_bits(b) > RLC_DIG) && ((w << 3) > bn_bits(b))) {\n\t\tfp54_t t;\n\n\t\tfp54_null(t)\n\n\t\tRLC_TRY {\n\t\t\tfp54_new(t);\n\n\t\t\tfp54_copy(t, a);\n\n\t\t\tfor (i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp54_sqr_cyc(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp54_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp54_copy(c, t);\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp54_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfp54_free(t);\n\t\t}\n\t} else {\n\t\tfp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\t\tfp54_null(t);\n\n\t\tRLC_TRY {\n\t\t\tif (u == NULL) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY)\n\t\t\t}\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp54_null(u[i]);\n\t\t\t\tfp54_new(u[i]);\n\t\t\t}\n\t\t\tfp54_new(t);\n\n\t\t\tj = 0;\n\t\t\tfp54_copy(t, a);\n\t\t\tfor (i = 1; i < bn_bits(b); i++) {\n\t\t\t\tfp54_sqr_pck(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp54_copy(u[j++], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tj = 0;\n\t\t\t\tk = w - 1;\n\t\t\t} else {\n\t\t\t\tj = 1;\n\t\t\t\tk = w;\n\t\t\t}\n\n\t\t\tfp54_back_cyc_sim(u, u, k);\n\n\t\t\tif (!bn_is_even(b)) {\n\t\t\t\tfp54_copy(c, a);\n\t\t\t} else {\n\t\t\t\tfp54_copy(c, u[0]);\n\t\t\t}\n\n\t\t\tfor (i = j; i < k; i++) {\n\t\t\t\tfp54_mul(c, c, u[i]);\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp54_inv_cyc(c, c);\n\t\t\t}\n\t\t}\n\t\tRLC_CATCH_ANY {\n\t\t\tRLC_THROW(ERR_CAUGHT);\n\t\t}\n\t\tRLC_FINALLY {\n\t\t\tfor (i = 0; i < w; i++) {\n\t\t\t\tfp54_free(u[i]);\n\t\t\t}\n\t\t\tfp54_free(t);\n\t\t\tRLC_FREE(u);\n\t\t}\n\t}\n}\n\nvoid fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tif (u == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp54_null(u[i]);\n\t\t\tfp54_new(u[i]);\n\t\t}\n\t\tfp54_new(t);\n\n\t\tfp54_copy(t, a);\n\t\tif (b[0] == 0) {\n\t\t\tfor (j = 0, i = 1; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp54_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp54_inv_cyc(u[i - 1], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp54_copy(u[i - 1], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp54_back_cyc_sim(u, u, w - 1);\n\n\t\t\tfp54_copy(c, a);\n\t\t\tfor (i = 0; i < w - 1; i++) {\n\t\t\t\tfp54_mul(c, c, u[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (j = 0, i = 0; i < len; i++) {\n\t\t\t\tk = (b[i] < 0 ? -b[i] : b[i]);\n\t\t\t\tfor (; j < k; j++) {\n\t\t\t\t\tfp54_sqr_pck(t, t);\n\t\t\t\t}\n\t\t\t\tif (b[i] < 0) {\n\t\t\t\t\tfp54_inv_cyc(u[i], t);\n\t\t\t\t} else {\n\t\t\t\t\tfp54_copy(u[i], t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfp54_back_cyc_sim(u, u, w);\n\n\t\t\tfp54_copy(c, u[0]);\n\t\t\tfor (i = 1; i < w; i++) {\n\t\t\t\tfp54_mul(c, c, u[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (sign == RLC_NEG) {\n\t\t\tfp54_inv_cyc(c, c);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < w; i++) {\n\t\t\tfp54_free(u[i]);\n\t\t}\n\t\tfp54_free(t);\n\t\tRLC_FREE(u);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of exponentiation in extensions defined over prime fields.\n *\n * @ingroup fpx\n */\n\n#include \"relic_core.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp2_exp(fp2_t c, const fp2_t a, const bn_t b) {\n\tfp2_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp2_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tfp2_copy(t, a);\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp2_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp2_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp2_inv(c, t);\n\t\t} else {\n\t\t\tfp2_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nvoid fp2_exp_dig(fp2_t c, const fp2_t a, dig_t b) {\n\tfp2_t t;\n\n\tif (b == 0) {\n\t\tfp2_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tfp2_copy(t, a);\n\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\tfp2_sqr(t, t);\n\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\tfp2_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tfp2_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nvoid fp3_exp(fp3_t c, const fp3_t a, const bn_t b) {\n\tfp3_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp3_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp3_null(t);\n\n\tRLC_TRY {\n\t\tfp3_new(t);\n\n\t\tfp3_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp3_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp3_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp3_inv(c, t);\n\t\t} else {\n\t\t\tfp3_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp3_free(t);\n\t}\n}\n\nvoid fp4_exp(fp4_t c, const fp4_t a, const bn_t b) {\n\tfp4_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp4_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp4_null(t);\n\n\tRLC_TRY {\n\t\tfp4_new(t);\n\n\t\tfp4_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp4_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp4_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp4_inv(c, t);\n\t\t} else {\n\t\t\tfp4_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp4_free(t);\n\t}\n}\n\nvoid fp6_exp(fp6_t c, const fp6_t a, const bn_t b) {\n\tfp6_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp6_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp6_null(t);\n\n\tRLC_TRY {\n\t\tfp6_new(t);\n\n\t\tfp6_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp6_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp6_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp6_inv(c, t);\n\t\t} else {\n\t\t\tfp6_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp6_free(t);\n\t}\n}\n\nvoid fp8_exp(fp8_t c, const fp8_t a, const bn_t b) {\n\tfp8_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp8_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp8_null(t);\n\n\tRLC_TRY {\n\t\tfp8_new(t);\n\n\t\tif (fp8_test_cyc(a)) {\n\t\t\tfp8_exp_cyc(c, a, b);\n\t\t} else {\n\t\t\tfp8_copy(t, a);\n\n\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp8_sqr(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp8_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp8_inv(c, t);\n\t\t\t} else {\n\t\t\t\tfp8_copy(c, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(t);\n\t}\n}\n\nvoid fp9_exp(fp9_t c, const fp9_t a, const bn_t b) {\n\tfp9_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp9_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp9_null(t);\n\n\tRLC_TRY {\n\t\tfp9_new(t);\n\n\t\tfp9_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp9_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp9_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp9_inv(c, t);\n\t\t} else {\n\t\t\tfp9_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp9_free(t);\n\t}\n}\n\nvoid fp12_exp(fp12_t c, const fp12_t a, const bn_t b) {\n\tfp12_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tfp12_new(t);\n\n\t\tif (fp12_test_cyc(a)) {\n\t\t\tfp12_exp_cyc(c, a, b);\n\t\t} else {\n\t\t\tfp12_copy(t, a);\n\n\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp12_sqr(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp12_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp12_inv(c, t);\n\t\t\t} else {\n\t\t\t\tfp12_copy(c, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(t);\n\t}\n}\n\nvoid fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp12_null(t);\n\tfp12_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp12_new(t);\n\t\tfp12_new(v);\n\n\t\tfp12_copy(t, a);\n\n\t\tif (fp12_test_cyc(a)) {\n\t\t\tfp12_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp12_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp12_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp12_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp12_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp12_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp12_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp12_free(t);\n\t\tfp12_free(v);\n\t}\n}\n\nvoid fp18_exp(fp18_t c, const fp18_t a, const bn_t b) {\n\tfp18_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp18_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp18_null(t);\n\n\tRLC_TRY {\n\t\tfp18_new(t);\n\n\t\tfp18_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp18_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp18_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp18_inv(c, t);\n\t\t} else {\n\t\t\tfp18_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp18_free(t);\n\t}\n}\n\nvoid fp24_exp(fp24_t c, const fp24_t a, const bn_t b) {\n\tfp24_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tfp24_new(t);\n\n\t\tfp24_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp24_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp24_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp24_inv(c, t);\n\t\t} else {\n\t\t\tfp24_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(t);\n\t}\n}\n\nvoid fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp24_null(t);\n\tfp24_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp24_new(t);\n\t\tfp24_new(v);\n\n\t\tfp24_copy(t, a);\n\n\t\tif (fp24_test_cyc(a)) {\n\t\t\tfp24_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp24_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp24_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp24_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp24_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp24_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp24_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp24_free(t);\n\t\tfp24_free(v);\n\t}\n}\n\nvoid fp48_exp(fp48_t c, const fp48_t a, const bn_t b) {\n\tfp48_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tfp48_new(t);\n\n\t\tif (fp48_test_cyc(a)) {\n\t\t\tfp48_exp_cyc(c, a, b);\n\t\t} else {\n\t\t\tfp48_copy(t, a);\n\n\t\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr(t, t);\n\t\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\tfp48_inv(c, t);\n\t\t\t} else {\n\t\t\t\tfp48_copy(c, t);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(t);\n\t}\n}\n\nvoid fp48_exp_dig(fp48_t c, const fp48_t a, dig_t b) {\n\tbn_t _b;\n\tfp48_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp48_null(t);\n\tfp48_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp48_new(t);\n\t\tfp48_new(v);\n\n\t\tfp48_copy(t, a);\n\n\t\tif (fp48_test_cyc(a)) {\n\t\t\tfp48_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp48_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp48_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp48_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp48_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp48_free(t);\n\t\tfp48_free(v);\n\t}\n}\n\nvoid fp54_exp(fp54_t c, const fp54_t a, const bn_t b) {\n\tfp54_t t;\n\n\tif (bn_is_zero(b)) {\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tfp54_new(t);\n\n\t\tfp54_copy(t, a);\n\n\t\tfor (int i = bn_bits(b) - 2; i >= 0; i--) {\n\t\t\tfp54_sqr(t, t);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfp54_mul(t, t, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfp54_inv(c, t);\n\t\t} else {\n\t\t\tfp54_copy(c, t);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(t);\n\t}\n}\n\nvoid fp54_exp_dig(fp54_t c, const fp54_t a, dig_t b) {\n\tbn_t _b;\n\tfp54_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp54_null(t);\n\tfp54_null(v);\n\n\tRLC_TRY {\n\t\tbn_new(_b);\n\t\tfp54_new(t);\n\t\tfp54_new(v);\n\n\t\tfp54_copy(t, a);\n\n\t\tif (fp54_test_cyc(a)) {\n\t\t\tfp54_inv_cyc(v, a);\n\t\t\tbn_set_dig(_b, b);\n\n\t\t\tl = RLC_DIG + 1;\n\t\t\tbn_rec_naf(naf, &l, _b, 2);\n\n\t\t\tfor (int i = bn_bits(_b) - 2; i >= 0; i--) {\n\t\t\t\tfp54_sqr_cyc(t, t);\n\n\t\t\t\tu = naf[i];\n\t\t\t\tif (u > 0) {\n\t\t\t\t\tfp54_mul(t, t, a);\n\t\t\t\t} else if (u < 0) {\n\t\t\t\t\tfp54_mul(t, t, v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = util_bits_dig(b) - 2; i >= 0; i--) {\n\t\t\t\tfp54_sqr(t, t);\n\t\t\t\tif (b & ((dig_t)1 << i)) {\n\t\t\t\t\tfp54_mul(t, t, a);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfp54_copy(c, t);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(_b);\n\t\tfp54_free(t);\n\t\tfp54_free(v);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of utilities in extensions defined over prime fields.\n *\n * @ingroup fpx\n */\n\n#include \"relic_core.h\"\n#include \"relic_fpx_low.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid fp2_copy(fp2_t c, const fp2_t a) {\n\tfp_copy(c[0], a[0]);\n\tfp_copy(c[1], a[1]);\n}\n\nvoid fp2_zero(fp2_t a) {\n\tfp_zero(a[0]);\n\tfp_zero(a[1]);\n}\n\nint fp2_is_zero(const fp2_t a) {\n\treturn fp_is_zero(a[0]) && fp_is_zero(a[1]);\n}\n\nvoid fp2_rand(fp2_t a) {\n\tfp_rand(a[0]);\n\tfp_rand(a[1]);\n}\n\nvoid fp2_print(const fp2_t a) {\n\tfp_print(a[0]);\n\tfp_print(a[1]);\n}\n\nint fp2_size_bin(fp2_t a, int pack) {\n\tif (pack) {\n\t\tif (fp2_test_cyc(a)) {\n\t\t\treturn RLC_FP_BYTES + 1;\n\t\t} else {\n\t\t\treturn 2 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 2 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp2_read_bin(fp2_t a, const uint8_t *bin, size_t len) {\n\tif (len != RLC_FP_BYTES + 1 && len != 2 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == RLC_FP_BYTES + 1) {\n\t\tfp_read_bin(a[0], bin, RLC_FP_BYTES);\n\t\tfp_zero(a[1]);\n\t\tfp_set_bit(a[1], 0, bin[RLC_FP_BYTES]);\n\t\tfp2_upk(a, a);\n\t}\n\tif (len == 2 * RLC_FP_BYTES) {\n\t\tfp_read_bin(a[0], bin, RLC_FP_BYTES);\n\t\tfp_read_bin(a[1], bin + RLC_FP_BYTES, RLC_FP_BYTES);\n\t}\n}\n\nvoid fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tif (pack && fp2_test_cyc(a)) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfp2_pck(t, a);\n\t\t\t\tfp_write_bin(bin, RLC_FP_BYTES, t[0]);\n\t\t\t\tbin[RLC_FP_BYTES] = fp_get_bit(t[1], 0);\n\t\t\t}\n\t\t} else {\n\t\t\tif (len < 2 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\t\t\t\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\t\t\t}\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp2_free(t);\n\t}\n}\n\nvoid fp2_set_dig(fp2_t a, const dig_t b) {\n\tfp_set_dig(a[0], b);\n\tfp_zero(a[1]);\n}\n\nvoid fp3_copy(fp3_t c, const fp3_t a) {\n\tfp_copy(c[0], a[0]);\n\tfp_copy(c[1], a[1]);\n\tfp_copy(c[2], a[2]);\n}\n\nvoid fp3_zero(fp3_t a) {\n\tfp_zero(a[0]);\n\tfp_zero(a[1]);\n\tfp_zero(a[2]);\n}\n\nint fp3_is_zero(const fp3_t a) {\n\treturn fp_is_zero(a[0]) && fp_is_zero(a[1]) && fp_is_zero(a[2]);\n}\n\nvoid fp3_rand(fp3_t a) {\n\tfp_rand(a[0]);\n\tfp_rand(a[1]);\n\tfp_rand(a[2]);\n}\n\nvoid fp3_print(const fp3_t a) {\n\tfp_print(a[0]);\n\tfp_print(a[1]);\n\tfp_print(a[2]);\n}\n\nint fp3_size_bin(fp3_t a) {\n\treturn 3 * RLC_FP_BYTES;\n}\n\nvoid fp3_read_bin(fp3_t a, const uint8_t *bin, size_t len) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_read_bin(a[0], bin, RLC_FP_BYTES);\n\tfp_read_bin(a[1], bin + RLC_FP_BYTES, RLC_FP_BYTES);\n\tfp_read_bin(a[2], bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES);\n}\n\nvoid fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\tfp_write_bin(bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES, a[2]);\n}\n\nvoid fp3_set_dig(fp3_t a, const dig_t b) {\n\tfp_set_dig(a[0], b);\n\tfp_zero(a[1]);\n\tfp_zero(a[2]);\n}\n\nvoid fp4_copy(fp4_t c, const fp4_t a) {\n\tfp2_copy(c[0], a[0]);\n\tfp2_copy(c[1], a[1]);\n}\n\nvoid fp4_zero(fp4_t a) {\n\tfp2_zero(a[0]);\n\tfp2_zero(a[1]);\n}\n\nint fp4_is_zero(const fp4_t a) {\n\treturn fp2_is_zero(a[0]) && fp2_is_zero(a[1]);\n}\n\nvoid fp4_rand(fp4_t a) {\n\tfp2_rand(a[0]);\n\tfp2_rand(a[1]);\n}\n\nvoid fp4_print(const fp4_t a) {\n\tfp2_print(a[0]);\n\tfp2_print(a[1]);\n}\n\nint fp4_size_bin(fp4_t a) {\n\treturn 4 * RLC_FP_BYTES;\n}\n\nvoid fp4_read_bin(fp4_t a, const uint8_t *bin, size_t len) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_read_bin(a[0], bin, 2 * RLC_FP_BYTES);\n\tfp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n}\n\nvoid fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);\n\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1], 0);\n}\n\nvoid fp4_set_dig(fp4_t a, const dig_t b) {\n\tfp2_set_dig(a[0], b);\n\tfp2_zero(a[1]);\n}\n\nvoid fp6_copy(fp6_t c, const fp6_t a) {\n\tfp2_copy(c[0], a[0]);\n\tfp2_copy(c[1], a[1]);\n\tfp2_copy(c[2], a[2]);\n}\n\nvoid fp6_zero(fp6_t a) {\n\tfp2_zero(a[0]);\n\tfp2_zero(a[1]);\n\tfp2_zero(a[2]);\n}\n\nint fp6_is_zero(const fp6_t a) {\n\treturn fp2_is_zero(a[0]) && fp2_is_zero(a[1]) && fp2_is_zero(a[2]);\n}\n\nvoid fp6_rand(fp6_t a) {\n\tfp2_rand(a[0]);\n\tfp2_rand(a[1]);\n\tfp2_rand(a[2]);\n}\n\nvoid fp6_print(const fp6_t a) {\n\tfp2_print(a[0]);\n\tfp2_print(a[1]);\n\tfp2_print(a[2]);\n}\n\nint fp6_size_bin(fp6_t a) {\n\treturn 6 * RLC_FP_BYTES;\n}\n\nvoid fp6_read_bin(fp6_t a, const uint8_t *bin, size_t len) {\n\tif (len != 6 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_read_bin(a[0], bin, 2 * RLC_FP_BYTES);\n\tfp2_read_bin(a[1], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\tfp2_read_bin(a[2], bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n}\n\nvoid fp6_write_bin(uint8_t *bin, size_t len, const fp6_t a) {\n\tif (len != 6 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);\n\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1], 0);\n\tfp2_write_bin(bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[2], 0);\n}\n\nvoid fp6_set_dig(fp6_t a, const dig_t b) {\n\tfp2_set_dig(a[0], b);\n\tfp2_zero(a[1]);\n\tfp2_zero(a[2]);\n}\n\nvoid fp8_copy(fp8_t c, const fp8_t a) {\n\tfp4_copy(c[0], a[0]);\n\tfp4_copy(c[1], a[1]);\n}\n\nvoid fp8_zero(fp8_t a) {\n\tfp4_zero(a[0]);\n\tfp4_zero(a[1]);\n}\n\nint fp8_is_zero(const fp8_t a) {\n\treturn fp4_is_zero(a[0]) && fp4_is_zero(a[1]);\n}\n\nvoid fp8_rand(fp8_t a) {\n\tfp4_rand(a[0]);\n\tfp4_rand(a[1]);\n}\n\nvoid fp8_print(const fp8_t a) {\n\tfp4_print(a[0]);\n\tfp4_print(a[1]);\n}\n\nint fp8_size_bin(fp8_t a, int pack) {\n\tif (pack) {\n\t\tif (fp8_test_cyc(a)) {\n\t\t\treturn 4 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 8 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 8 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp8_read_bin(fp8_t a, const uint8_t *bin, size_t len) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_read_bin(a[0], bin, 4 * RLC_FP_BYTES);\n\tfp4_read_bin(a[1], bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n}\n\nvoid fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[0]);\n\tfp4_write_bin(bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[1]);\n}\n\nvoid fp8_set_dig(fp8_t a, const dig_t b) {\n\tfp4_set_dig(a[0], b);\n\tfp4_zero(a[1]);\n}\n\nvoid fp9_copy(fp9_t c, const fp9_t a) {\n\tfp3_copy(c[0], a[0]);\n\tfp3_copy(c[1], a[1]);\n\tfp3_copy(c[2], a[2]);\n}\n\nvoid fp9_zero(fp9_t a) {\n\tfp3_zero(a[0]);\n\tfp3_zero(a[1]);\n\tfp3_zero(a[2]);\n}\n\nint fp9_is_zero(const fp9_t a) {\n\treturn fp3_is_zero(a[0]) && fp3_is_zero(a[1]) && fp3_is_zero(a[2]);\n}\n\nvoid fp9_rand(fp9_t a) {\n\tfp3_rand(a[0]);\n\tfp3_rand(a[1]);\n\tfp3_rand(a[2]);\n}\n\nvoid fp9_print(const fp9_t a) {\n\tfp3_print(a[0]);\n\tfp3_print(a[1]);\n\tfp3_print(a[2]);\n}\n\nint fp9_size_bin(fp9_t a) {\n\treturn 9 * RLC_FP_BYTES;\n}\n\nvoid fp9_read_bin(fp9_t a, const uint8_t *bin, size_t len) {\n\tif (len != 9 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp3_read_bin(a[0], bin, 3 * RLC_FP_BYTES);\n\tfp3_read_bin(a[1], bin + 3 * RLC_FP_BYTES, 3 * RLC_FP_BYTES);\n\tfp3_read_bin(a[2], bin + 6 * RLC_FP_BYTES, 3 * RLC_FP_BYTES);\n}\n\nvoid fp9_write_bin(uint8_t *bin, size_t len, const fp9_t a) {\n\tif (len != 9 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp3_write_bin(bin, 3 * RLC_FP_BYTES, a[0]);\n\tfp3_write_bin(bin + 3 * RLC_FP_BYTES, 3 * RLC_FP_BYTES, a[1]);\n\tfp3_write_bin(bin + 6 * RLC_FP_BYTES, 3 * RLC_FP_BYTES, a[2]);\n}\n\nvoid fp9_set_dig(fp9_t a, const dig_t b) {\n\tfp3_set_dig(a[0], b);\n\tfp3_zero(a[1]);\n\tfp3_zero(a[2]);\n}\n\nvoid fp12_copy(fp12_t c, const fp12_t a) {\n\tfp6_copy(c[0], a[0]);\n\tfp6_copy(c[1], a[1]);\n}\n\nvoid fp12_zero(fp12_t a) {\n\tfp6_zero(a[0]);\n\tfp6_zero(a[1]);\n}\n\nint fp12_is_zero(const fp12_t a) {\n\treturn (fp6_is_zero(a[0]) && fp6_is_zero(a[1]));\n}\n\nvoid fp12_rand(fp12_t a) {\n\tfp6_rand(a[0]);\n\tfp6_rand(a[1]);\n}\n\nvoid fp12_print(const fp12_t a) {\n\tfp6_print(a[0]);\n\tfp6_print(a[1]);\n}\n\nint fp12_size_bin(fp12_t a, int pack) {\n\tif (pack) {\n\t\tif (fp12_test_cyc(a)) {\n\t\t\treturn 8 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 12 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 12 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp12_read_bin(fp12_t a, const uint8_t *bin, size_t len) {\n\tif (len != 8 * RLC_FP_BYTES && len != 12 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 8 * RLC_FP_BYTES) {\n\t\tfp2_zero(a[0][0]);\n\t\tfp2_read_bin(a[0][1], bin, 2 * RLC_FP_BYTES);\n\t\tfp2_read_bin(a[0][2], bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\t\tfp2_read_bin(a[1][0], bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\t\tfp2_zero(a[1][1]);\n\t\tfp2_read_bin(a[1][2], bin + 6 * RLC_FP_BYTES, 2 * RLC_FP_BYTES);\n\t\tfp12_back_cyc(a, a);\n\t}\n\tif (len == 12 * RLC_FP_BYTES) {\n\t\tfp6_read_bin(a[0], bin, 6 * RLC_FP_BYTES);\n\t\tfp6_read_bin(a[1], bin + 6 * RLC_FP_BYTES, 6 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp12_write_bin(uint8_t *bin, size_t len, const fp12_t a, int pack) {\n\tfp12_t t;\n\n\tfp12_null(t);\n\n\tRLC_TRY {\n\t\tfp12_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 8 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp12_pck(t, a);\n\t\t\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0][1], 0);\n\t\t\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[0][2], 0);\n\t\t\tfp2_write_bin(bin + 4 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1][0], 0);\n\t\t\tfp2_write_bin(bin + 6 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1][2], 0);\n\t\t} else {\n\t\t\tif (len != 12 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp6_write_bin(bin, 6 * RLC_FP_BYTES, a[0]);\n\t\t\tfp6_write_bin(bin + 6 * RLC_FP_BYTES, 6 * RLC_FP_BYTES, a[1]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp12_free(t);\n\t}\n}\n\nvoid fp12_set_dig(fp12_t a, const dig_t b) {\n\tfp6_set_dig(a[0], b);\n\tfp6_zero(a[1]);\n}\n\nvoid fp18_copy(fp18_t c, const fp18_t a) {\n\tfp9_copy(c[0], a[0]);\n\tfp9_copy(c[1], a[1]);\n}\n\nvoid fp18_zero(fp18_t a) {\n\tfp9_zero(a[0]);\n\tfp9_zero(a[1]);\n}\n\nint fp18_is_zero(const fp18_t a) {\n\treturn (fp9_is_zero(a[0]) && fp9_is_zero(a[1]));\n}\n\nvoid fp18_rand(fp18_t a) {\n\tfp9_rand(a[0]);\n\tfp9_rand(a[1]);\n}\n\nvoid fp18_print(const fp18_t a) {\n\tfp9_print(a[0]);\n\tfp9_print(a[1]);\n}\n\nint fp18_size_bin(fp18_t a) {\n\treturn 18 * RLC_FP_BYTES;\n}\n\nvoid fp18_read_bin(fp18_t a, const uint8_t *bin, size_t len) {\n\tif (len != 18 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp9_read_bin(a[0], bin, 9 * RLC_FP_BYTES);\n\tfp9_read_bin(a[1], bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n}\n\nvoid fp18_write_bin(uint8_t *bin, size_t len, const fp18_t a) {\n\tif (len != 18 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp9_write_bin(bin, 9 * RLC_FP_BYTES, a[0]);\n\tfp9_write_bin(bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[1]);\n}\n\nvoid fp18_set_dig(fp18_t a, const dig_t b) {\n\tfp9_set_dig(a[0], b);\n\tfp9_zero(a[1]);\n}\n\nvoid fp24_copy(fp24_t c, const fp24_t a) {\n\tfp8_copy(c[0], a[0]);\n\tfp8_copy(c[1], a[1]);\n\tfp8_copy(c[2], a[2]);\n}\n\nvoid fp24_zero(fp24_t a) {\n\tfp8_zero(a[0]);\n\tfp8_zero(a[1]);\n\tfp8_zero(a[2]);\n}\n\nint fp24_is_zero(const fp24_t a) {\n\treturn fp8_is_zero(a[0]) && fp8_is_zero(a[1]) && fp8_is_zero(a[2]);\n}\n\nvoid fp24_rand(fp24_t a) {\n\tfp8_rand(a[0]);\n\tfp8_rand(a[1]);\n\tfp8_rand(a[2]);\n}\n\nvoid fp24_print(const fp24_t a) {\n\tfp8_print(a[0]);\n\tfp8_print(a[1]);\n\tfp8_print(a[2]);\n}\n\nint fp24_size_bin(fp24_t a, int pack) {\n\tif (pack) {\n\t\tif (fp24_test_cyc(a)) {\n\t\t\treturn 16 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 24 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 24 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp24_read_bin(fp24_t a, const uint8_t *bin, size_t len) {\n\tif (len != 16 * RLC_FP_BYTES && len != 24 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 16 * RLC_FP_BYTES) {\n\t\tfp4_zero(a[0][0]);\n\t\tfp4_zero(a[0][1]);\n\t\tfp4_read_bin(a[1][0], bin, 4 * RLC_FP_BYTES);\n\t\tfp4_read_bin(a[1][1], bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n\t\tfp4_read_bin(a[2][0], bin + 8 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n\t\tfp4_read_bin(a[2][1], bin + 12 * RLC_FP_BYTES, 4 * RLC_FP_BYTES);\n\t\tfp24_back_cyc(a, a);\n\t}\n\tif (len == 24 * RLC_FP_BYTES) {\n\t\tfp8_read_bin(a[0], bin, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[1], bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[2], bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp24_write_bin(uint8_t *bin, size_t len, const fp24_t a, int pack) {\n\tfp24_t t;\n\n\tfp24_null(t);\n\n\tRLC_TRY {\n\t\tfp24_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 16 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp24_pck(t, a);\n\t\t\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[1][0]);\n\t\t\tfp4_write_bin(bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[1][1]);\n\t\t\tfp4_write_bin(bin + 8 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[2][0]);\n\t\t\tfp4_write_bin(bin + 12 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[2][1]);\n\t\t} else {\n\t\t\tif (len != 24 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp8_write_bin(bin, 8 * RLC_FP_BYTES, a[0]);\n\t\t\tfp8_write_bin(bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[1]);\n\t\t\tfp8_write_bin(bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp24_free(t);\n\t}\n}\n\nvoid fp24_set_dig(fp24_t a, const dig_t b) {\n\tfp8_set_dig(a[0], b);\n\tfp8_zero(a[1]);\n\tfp8_zero(a[2]);\n}\n\nvoid fp48_copy(fp48_t c, const fp48_t a) {\n\tfp24_copy(c[0], a[0]);\n\tfp24_copy(c[1], a[1]);\n}\n\nvoid fp48_zero(fp48_t a) {\n\tfp24_zero(a[0]);\n\tfp24_zero(a[1]);\n}\n\nint fp48_is_zero(const fp48_t a) {\n\treturn (fp24_is_zero(a[0]) && fp24_is_zero(a[1]));\n}\n\nvoid fp48_rand(fp48_t a) {\n\tfp24_rand(a[0]);\n\tfp24_rand(a[1]);\n}\n\nvoid fp48_print(const fp48_t a) {\n\tfp24_print(a[0]);\n\tfp24_print(a[1]);\n}\n\nint fp48_size_bin(fp48_t a, int pack) {\n\tif (pack) {\n\t\tif (fp48_test_cyc(a)) {\n\t\t\treturn 32 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 48 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 48 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp48_read_bin(fp48_t a, const uint8_t *bin, size_t len) {\n\tif (len != 32 * RLC_FP_BYTES && len != 48 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 32 * RLC_FP_BYTES) {\n\t\tfp8_zero(a[0][0]);\n\t\tfp8_read_bin(a[0][1], bin, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[0][2], bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp8_read_bin(a[1][0], bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp8_zero(a[1][1]);\n\t\tfp8_read_bin(a[1][2], bin + 24 * RLC_FP_BYTES, 8 * RLC_FP_BYTES);\n\t\tfp48_back_cyc(a, a);\n\t}\n\tif (len == 48 * RLC_FP_BYTES) {\n\t\tfp24_read_bin(a[0], bin, 24 * RLC_FP_BYTES);\n\t\tfp24_read_bin(a[1], bin + 24 * RLC_FP_BYTES, 24 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp48_write_bin(uint8_t *bin, size_t len, const fp48_t a, int pack) {\n\tfp48_t t;\n\n\tfp48_null(t);\n\n\tRLC_TRY {\n\t\tfp48_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 32 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp48_pck(t, a);\n\t\t\tfp8_write_bin(bin, 8 * RLC_FP_BYTES, a[0][1]);\n\t\t\tfp8_write_bin(bin + 8 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[0][2]);\n\t\t\tfp8_write_bin(bin + 16 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[1][0]);\n\t\t\tfp8_write_bin(bin + 24 * RLC_FP_BYTES, 8 * RLC_FP_BYTES, a[1][2]);\n\t\t} else {\n\t\t\tif (len != 48 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp24_write_bin(bin, 24 * RLC_FP_BYTES, a[0], 0);\n\t\t\tfp24_write_bin(bin + 24 * RLC_FP_BYTES, 24 * RLC_FP_BYTES, a[1], 0);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp48_free(t);\n\t}\n}\n\nvoid fp48_set_dig(fp48_t a, const dig_t b) {\n\tfp24_set_dig(a[0], b);\n\tfp24_zero(a[1]);\n}\n\nvoid fp54_copy(fp54_t c, const fp54_t a) {\n\tfp18_copy(c[0], a[0]);\n\tfp18_copy(c[1], a[1]);\n\tfp18_copy(c[2], a[2]);\n}\n\nvoid fp54_zero(fp54_t a) {\n\tfp18_zero(a[0]);\n\tfp18_zero(a[1]);\n\tfp18_zero(a[2]);\n}\n\nint fp54_is_zero(const fp54_t a) {\n\treturn (fp18_is_zero(a[0]) && fp18_is_zero(a[1]) && fp18_is_zero(a[2]));\n}\n\nvoid fp54_rand(fp54_t a) {\n\tfp18_rand(a[0]);\n\tfp18_rand(a[1]);\n\tfp18_rand(a[2]);\n}\n\nvoid fp54_print(const fp54_t a) {\n\tfp18_print(a[0]);\n\tfp18_print(a[1]);\n\tfp18_print(a[2]);\n}\n\nint fp54_size_bin(fp54_t a, int pack) {\n\tif (pack) {\n\t\tif (fp54_test_cyc(a)) {\n\t\t\treturn 36 * RLC_FP_BYTES;\n\t\t} else {\n\t\t\treturn 54 * RLC_FP_BYTES;\n\t\t}\n\t} else {\n\t\treturn 54 * RLC_FP_BYTES;\n\t}\n}\n\nvoid fp54_read_bin(fp54_t a, const uint8_t *bin, size_t len) {\n\tif (len != 36 * RLC_FP_BYTES && len != 54 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tif (len == 36 * RLC_FP_BYTES) {\n\t\tfp9_zero(a[0][0]);\n\t\tfp9_zero(a[0][1]);\n\t\tfp9_read_bin(a[1][0], bin, 9 * RLC_FP_BYTES);\n\t\tfp9_read_bin(a[1][1], bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n\t\tfp9_read_bin(a[2][0], bin + 18 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n\t\tfp9_read_bin(a[2][1], bin + 27 * RLC_FP_BYTES, 9 * RLC_FP_BYTES);\n\t\tfp54_back_cyc(a, a);\n\t}\n\tif (len == 54 * RLC_FP_BYTES) {\n\t\tfp18_read_bin(a[0], bin, 18 * RLC_FP_BYTES);\n\t\tfp18_read_bin(a[1], bin + 18 * RLC_FP_BYTES, 18 * RLC_FP_BYTES);\n\t\tfp18_read_bin(a[2], bin + 36 * RLC_FP_BYTES, 18 * RLC_FP_BYTES);\n\t}\n}\n\nvoid fp54_write_bin(uint8_t *bin, size_t len, const fp54_t a, int pack) {\n\tfp54_t t;\n\n\tfp54_null(t);\n\n\tRLC_TRY {\n\t\tfp54_new(t);\n\n\t\tif (pack) {\n\t\t\tif (len != 36 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp54_pck(t, a);\n\t\t\tfp9_write_bin(bin, 9 * RLC_FP_BYTES, a[1][0]);\n\t\t\tfp9_write_bin(bin + 9 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[1][1]);\n\t\t\tfp9_write_bin(bin + 18 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][0]);\n\t\t\tfp9_write_bin(bin + 27 * RLC_FP_BYTES, 9 * RLC_FP_BYTES, a[2][1]);\n\t\t} else {\n\t\t\tif (len != 54 * RLC_FP_BYTES) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\t}\n\t\t\tfp18_write_bin(bin, 18 * RLC_FP_BYTES, a[0]);\n\t\t\tfp18_write_bin(bin + 18 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[1]);\n\t\t\tfp18_write_bin(bin + 36 * RLC_FP_BYTES, 18 * RLC_FP_BYTES, a[2]);\n\t\t}\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp54_free(t);\n\t}\n}\n\nvoid fp54_set_dig(fp54_t a, dig_t b) {\n\tfp18_set_dig(a[0], b);\n\tfp18_zero(a[1]);\n\tfp18_zero(a[2]);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2015 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the BLAKE2s hash function.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n#include \"blake2.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == B2S160 || !defined(STRIP)\n\nvoid md_map_b2s160(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tmemset(hash, 0, RLC_MD_LEN_B2S160);\n\tblake2s(hash, RLC_MD_LEN_B2S160, msg, len, NULL, 0);\n}\n\n#endif\n\n#if MD_MAP == B2S256 || !defined(STRIP)\n\nvoid md_map_b2s256(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tmemset(hash, 0, RLC_MD_LEN_B2S256);\n\tblake2s(hash, RLC_MD_LEN_B2S256, msg, len, NULL, 0);\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2013 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of Hash-based Message Authentication Code.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid md_hmac(uint8_t *mac, const uint8_t *in, size_t in_len, const uint8_t *key,\n    size_t key_len) {\n#if MD_MAP == SH224 || MD_MAP == SH256 || MD_MAP == B2S160 || MD_MAP == B2S256\n  #define block_size 64\n#elif MD_MAP == SH384 || MD_MAP == SH512\n  #define block_size  128\n#endif\n    uint8_t opad[block_size + RLC_MD_LEN];\n    uint8_t *ipad = RLC_ALLOCA(uint8_t, block_size + in_len);\n\tuint8_t _key[RLC_MAX(RLC_MD_LEN, block_size)];\n\n    if (ipad == NULL) {\n        RLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n    }\n\n\tif (key_len > block_size) {\n\t\tmd_map(_key, key, key_len);\n\t\tkey = _key;\n\t\tkey_len = RLC_MD_LEN;\n\t}\n\tif (key_len <= block_size) {\n\t\tmemcpy(_key, key, key_len);\n\t\tmemset(_key + key_len, 0, block_size - key_len);\n\t\tkey = _key;\n\t}\n\tfor (int i = 0; i < block_size; i++) {\n\t\topad[i] = 0x5C ^ key[i];\n\t\tipad[i] = 0x36 ^ key[i];\n\t}\n\tmemcpy(ipad + block_size, in, in_len);\n\tmd_map(opad + block_size, ipad, block_size + in_len);\n\tmd_map(mac, opad, block_size + RLC_MD_LEN);\n\n    RLC_FREE(ipad);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of a Key Derivation function.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid md_kdf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len) {\n\tuint32_t i, j, d;\n\tuint8_t* buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));\n\tuint8_t* t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);\n\tif (buffer == NULL || t == NULL) {\n\t\tRLC_FREE(buffer);\n\t\tRLC_FREE(t);\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\t/* d = ceil(kLen/hLen). */\n\td = RLC_CEIL(key_len, RLC_MD_LEN);\n\tmemcpy(buffer, in, in_len);\n\tfor (i = 1; i <= d; i++) {\n\t\tj = util_conv_big(i);\n\t\t/* c = integer_to_string(c, 4). */\n\t\tmemcpy(buffer + in_len, &j, sizeof(uint32_t));\n\t\t/* t = t || hash(z || c). */\n\t\tmd_map(t + (i - 1) * RLC_MD_LEN, buffer, in_len + sizeof(uint32_t));\n\t}\n\tmemcpy(key, t, key_len);\n\n\tRLC_FREE(buffer);\n\tRLC_FREE(t);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2011 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of a Mask Generation Function.\n *\n * @ingroup md\n */\n\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_util.h\"\n#include \"relic_md.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid md_mgf(uint8_t *key, size_t key_len, const uint8_t *in, size_t in_len) {\n\tuint32_t i, j, d;\n\tuint8_t *buffer = RLC_ALLOCA(uint8_t, in_len + sizeof(uint32_t));\n\tuint8_t *t = RLC_ALLOCA(uint8_t, key_len + RLC_MD_LEN);\n\n\tif (buffer == NULL || t == NULL) {\n\t\tRLC_FREE(buffer);\n\t\tRLC_FREE(t);\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\t/* d = ceil(kLen/hLen). */\n\td = RLC_CEIL(key_len, RLC_MD_LEN);\n\tmemcpy(buffer, in, in_len);\n\tfor (i = 0; i < d; i++) {\n\t\tj = util_conv_big(i);\n\t\t/* c = integer_to_string(c, 4). */\n\t\tmemcpy(buffer + in_len, &j, sizeof(uint32_t));\n\t\t/* t = t || hash(z || c). */\n\t\tmd_map(t + i * RLC_MD_LEN, buffer, in_len + sizeof(uint32_t));\n\t}\n\tmemcpy(key, t, key_len);\n\n\tRLC_FREE(buffer);\n\tRLC_FREE(t);\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-224 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH224 || !defined(STRIP)\n\nvoid md_map_sh224(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA224Context ctx;\n\n\tif (SHA224Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA224Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA224Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-256 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH256 || !defined(STRIP)\n\nvoid md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA256Context ctx;\n\n\tif (SHA256Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA256Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA256Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-384 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH384 || !defined(STRIP)\n\nvoid md_map_sh384(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA384Context ctx;\n\n\tif (SHA384Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA384Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA384Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the SHA-512 hash function.\n *\n * @ingroup md\n */\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_md.h\"\n#include \"sha.h\"\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if MD_MAP == SH512 || !defined(STRIP)\n\nvoid md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA512Context ctx;\n\n\tif (SHA512Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA512Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA512Result(&ctx, hash) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 12.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Compute the Miller loop for pairings of type G_2 x G_1 over the bits of a\n * given parameter represented in sparse form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the vector of first arguments in affine coordinates.\n * @param[in] p\t\t\t\t- the vector of second arguments in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp12_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp12_null(l);\n\n\tRLC_TRY {\n\t\tfp12_new(l);\n\t\tif (_p == NULL || _q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_null(_p[j]);\n\t\t\tep2_null(_q[j]);\n\t\t\tep_new(_p[j]);\n\t\t\tep2_new(_q[j]);\n\t\t\tep2_copy(t[j], q[j]);\n\t\t\tep2_neg(_q[j], q[j]);\n#if EP_ADD == BASIC\n\t\t\tep_neg(_p[j], p[j]);\n#else\n\t\t\tfp_add(_p[j]->x, p[j]->x, p[j]->x);\n\t\t\tfp_add(_p[j]->x, _p[j]->x, p[j]->x);\n\t\t\tfp_neg(_p[j]->y, p[j]->y);\n#endif\n\t\t}\n\n\t\tfp12_zero(l);\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tpp_dbl_k12(r, t[0], t[0], _p[0]);\n\t\tfor (j = 1; j < m; j++) {\n\t\t\tpp_dbl_k12(l, t[j], t[j], _p[j]);\n\t\t\tfp12_mul_dxs(r, r, l);\n\t\t}\n\t\tif (s[len - 2] > 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k12(l, t[j], q[j], p[j]);\n\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t\tif (s[len - 2] < 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k12(l, t[j], _q[j], p[j]);\n\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = len - 3; i >= 0; i--) {\n\t\t\tfp12_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_k12(l, t[j], t[j], _p[j]);\n\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t\tif (s[i] > 0) {\n\t\t\t\t\tpp_add_k12(l, t[j], q[j], p[j]);\n\t\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tpp_add_k12(l, t[j], _q[j], p[j]);\n\t\t\t\t\tfp12_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_free(_p[j]);\n\t\t\tep2_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/**\n * Compute the Miller loop for pairings of type G_1 x G_2 over the bits of a\n * given parameter.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] p\t\t\t\t- the first pairing argument in affine coordinates.\n * @param[in] q\t\t\t\t- the second pairing argument in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_mil_lit_k12(fp12_t r, ep_t *t, ep_t *p, ep2_t *q, int m, bn_t a) {\n\tfp12_t l;\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint j;\n\n\tfp12_null(l);\n\n\tRLC_TRY {\n\t\tif (_q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfp12_new(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep2_null(_q[j]);\n\t\t\tep2_new(_q[j]);\n\t\t\tep_copy(t[j], p[j]);\n\t\t\tep2_neg(_q[j], q[j]);\n\t\t}\n\n\t\tfp12_zero(l);\n\t\tfor (int i = bn_bits(a) - 2; i >= 0; i--) {\n\t\t\tfp12_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_lit_k12(l, t[j], t[j], _q[j]);\n\t\t\t\tfp12_mul(r, r, l);\n\t\t\t\tif (bn_get_bit(a, i)) {\n\t\t\t\t\tpp_add_lit_k12(l, t[j], p[j], q[j]);\n\t\t\t\t\tfp12_mul(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep2_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/**\n * Compute the final lines for optimal ate pairings.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the first point of the pairing, in G_2.\n * @param[in] p\t\t\t\t- the second point of the pairing, in G_1.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_fin_k12_oatep(fp12_t r, ep2_t t, ep2_t q, ep_t p) {\n\tep2_t q1, q2;\n\tfp12_t tmp;\n\n\tfp12_null(tmp);\n\tep2_null(q1);\n\tep2_null(q2);\n\n\tRLC_TRY {\n\t\tep2_new(q1);\n\t\tep2_new(q2);\n\t\tfp12_new(tmp);\n\t\tfp12_zero(tmp);\n\n\t\tfp2_set_dig(q1->z, 1);\n\t\tfp2_set_dig(q2->z, 1);\n\n\t\tep2_frb(q1, q, 1);\n\t\tep2_frb(q2, q, 2);\n\t\tep2_neg(q2, q2);\n\n\t\tpp_add_k12(tmp, t, q1, p);\n\t\tfp12_mul_dxs(r, r, tmp);\n\t\tpp_add_k12(tmp, t, q2, p);\n\t\tfp12_mul_dxs(r, r, tmp);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tfp12_free(tmp);\n\t\tep2_free(q1);\n\t\tep2_free(q2);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if PP_MAP == TATEP || !defined(STRIP)\n\nvoid pp_map_tatep_k12(fp12_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1], t[1];\n\tep2_t _q[1];\n\tbn_t n;\n\n\tep_null(_p[0]);\n\tep_null(t[0]);\n\tep2_null(_q[0]);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep_new(t[0]);\n\t\tep2_new(_q[0]);\n\t\tbn_new(n);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\t\tep_curve_get_ord(n);\n\t\tfp12_set_dig(r, 1);\n\n\t\tif (!ep_is_infty(p) && !ep2_is_infty(q)) {\n\t\t\tpp_mil_lit_k12(r, t, _p, _q, 1, n);\n\t\t\tpp_exp_k12(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep_free(t[0]);\n\t\tep2_free(_q[0]);\n\t\tbn_free(n);\n\t}\n}\n\nvoid pp_map_sim_tatep_k12(fp12_t r, const ep_t *p, const ep2_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m), *t = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tbn_t n;\n\tint i, j;\n\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tif (_p == NULL || _q == NULL || t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep_null(t[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep_new(t[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep2_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep2_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tfp12_set_dig(r, 1);\n\t\tif (j > 0) {\n\t\t\tpp_mil_lit_k12(r, t, _p, _q, j, n);\n\t\t\tpp_exp_k12(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(n);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep_free(t[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(t);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n#endif\n\n#if PP_MAP == WEILP || !defined(STRIP)\n\nvoid pp_map_weilp_k12(fp12_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1], t0[1];\n\tep2_t _q[1], t1[1];\n\tfp12_t r0, r1;\n\tbn_t n;\n\n\tep_null(_p[0]);\n\tep_null(t0[0]);\n\tep2_null(_q[0]);\n\tep2_null(t1[0]);\n\tfp12_null(r0);\n\tfp12_null(r1);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep_new(t0[0]);\n\t\tep2_new(_q[0]);\n\t\tep2_new(t1[0]);\n\t\tfp12_new(r0);\n\t\tfp12_new(r1);\n\t\tbn_new(n);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\t\tep_curve_get_ord(n);\n\t\tbn_sub_dig(n, n, 1);\n\t\tfp12_set_dig(r0, 1);\n\t\tfp12_set_dig(r1, 1);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep2_is_infty(_q[0])) {\n\t\t\tpp_mil_lit_k12(r0, t0, _p, _q, 1, n);\n\t\t\tpp_mil_k12(r1, t1, _q, _p, 1, n);\n\t\t\tfp12_inv(r1, r1);\n\t\t\tfp12_mul(r0, r0, r1);\n\t\t\tfp12_inv(r1, r0);\n\t\t\tfp12_inv_cyc(r0, r0);\n\t\t}\n\t\tfp12_mul(r, r0, r1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep_free(t0[0]);\n\t\tep2_free(_q[0]);\n\t\tep2_free(t1[0]);\n\t\tfp12_free(r0);\n\t\tfp12_free(r1);\n\t\tbn_free(n);\n\t}\n}\n\nvoid pp_map_sim_weilp_k12(fp12_t r, const ep_t *p, const ep2_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m), *t0 = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m), *t1 = RLC_ALLOCA(ep2_t, m);\n\tfp12_t r0, r1;\n\tbn_t n;\n\tint i, j;\n\n\tfp12_null(r0);\n\tfp12_null(r1);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tfp12_new(r0);\n\t\tfp12_new(r1);\n\t\tbn_new(n);\n\t\tif (_p == NULL || _q == NULL || t0 == NULL || t1 == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep_null(t0[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_null(t1[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep_new(t0[i]);\n\t\t\tep2_new(_q[i]);\n\t\t\tep2_new(t1[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep2_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep2_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tep_curve_get_ord(n);\n\t\tbn_sub_dig(n, n, 1);\n\t\tfp12_set_dig(r0, 1);\n\t\tfp12_set_dig(r1, 1);\n\n\t\tif (j > 0) {\n\t\t\tpp_mil_lit_k12(r0, t0, _p, _q, j, n);\n\t\t\tpp_mil_k12(r1, t1, _q, _p, j, n);\n\t\t\tfp12_inv(r1, r1);\n\t\t\tfp12_mul(r0, r0, r1);\n\t\t\tfp12_inv(r1, r0);\n\t\t\tfp12_inv_cyc(r0, r0);\n\t\t}\n\t\tfp12_mul(r, r0, r1);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp12_free(r0);\n\t\tfp12_free(r1);\n\t\tbn_free(n);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep_free(t0[i]);\n\t\t\tep2_free(_q[i]);\n\t\t\tep2_free(t1[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t\tRLC_FREE(t0);\n\t\tRLC_FREE(t1);\n\t}\n}\n\n#endif\n\n#if PP_MAP == OATEP || !defined(STRIP)\n\nvoid pp_map_oatep_k12(fp12_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1];\n\tep2_t t[1], _q[1];\n\tbn_t a;\n\n\tep_null(_p[0]);\n\tep2_null(_q[0]);\n\tep2_null(t[0]);\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep2_new(_q[0]);\n\t\tep2_new(t[0]);\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp12_set_dig(r, 1);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep2_is_infty(_q[0])) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_BN:\n\t\t\t\t\tbn_mul_dig(a, a, 6);\n\t\t\t\t\tbn_add_dig(a, a, 2);\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, 1, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\t/* f_{-a,Q}(P) = 1/f_{a,Q}(P). */\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t\tep2_neg(t[0], t[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_fin_k12_oatep(r, t[0], _q[0], _p[0]);\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EP_B12:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, 1, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t\tep2_neg(t[0], t[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep2_free(_q[0]);\n\t\tep2_free(t[0]);\n\t\tbn_free(a);\n\t}\n}\n\nvoid pp_map_sim_oatep_k12(fp12_t r, const ep_t *p, const ep2_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *t = RLC_ALLOCA(ep2_t, m), *_q = RLC_ALLOCA(ep2_t, m);\n\tbn_t a;\n\tint i, j;\n\n\tRLC_TRY {\n\t\tbn_null(a);\n\t\tbn_new(a);\n\t\tif (_p == NULL || _q == NULL || t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_null(t[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep2_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep2_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tfp_prime_get_par(a);\n\t\tfp12_set_dig(r, 1);\n\n\t\tif (j > 0) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_BN:\n\t\t\t\t\tbn_mul_dig(a, a, 6);\n\t\t\t\t\tbn_add_dig(a, a, 2);\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, j, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\t/* f_{-a,Q}(P) = 1/f_{a,Q}(P). */\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tfor (i = 0; i < j; i++) {\n\t\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\t\tep2_neg(t[i], t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpp_fin_k12_oatep(r, t[i], _q[i], _p[i]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EP_B12:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k12(r, t, _q, _p, j, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp12_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k12(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t\tRLC_FREE(t);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 12.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Compute the Miller loop for pairings of type G_2 x G_1 over the bits of a\n * given parameter represented in sparse form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the vector of first arguments in affine coordinates.\n * @param[in] p\t\t\t\t- the vector of second arguments in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] a\t\t\t\t- the loop parameter.\n */\nstatic void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n\tfp24_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp24_null(l);\n\n\tRLC_TRY {\n\t\tfp24_new(l);\n\t\tif (_p == NULL || _q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_null(_p[j]);\n\t\t\tep4_null(_q[j]);\n\t\t\tep_new(_p[j]);\n\t\t\tep4_new(_q[j]);\n\t\t\tep4_copy(t[j], q[j]);\n\t\t\tep4_neg(_q[j], q[j]);\n#if EP_ADD == BASIC\n\t\t\tep_neg(_p[j], p[j]);\n#else\n\t\t\tfp_add(_p[j]->x, p[j]->x, p[j]->x);\n\t\t\tfp_add(_p[j]->x, _p[j]->x, p[j]->x);\n\t\t\tfp_neg(_p[j]->y, p[j]->y);\n#endif\n\t\t}\n\n\t\tfp24_zero(l);\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tpp_dbl_k24(r, t[0], t[0], _p[0]);\n\t\tfor (j = 1; j < m; j++) {\n\t\t\tpp_dbl_k24(l, t[j], t[j], _p[j]);\n\t\t\tfp24_mul_dxs(r, r, l);\n\t\t}\n\t\tif (s[len - 2] > 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k24(l, t[j], q[j], p[j]);\n\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t\tif (s[len - 2] < 0) {\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_add_k24(l, t[j], _q[j], p[j]);\n\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\n\t\tfor (i = len - 3; i >= 0; i--) {\n\t\t\tfp24_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_k24(l, t[j], t[j], _p[j]);\n\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t\tif (s[i] > 0) {\n\t\t\t\t\tpp_add_k24(l, t[j], q[j], p[j]);\n\t\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tpp_add_k24(l, t[j], _q[j], p[j]);\n\t\t\t\t\tfp24_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_free(_p[j]);\n\t\t\tep4_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if PP_MAP == OATEP || !defined(STRIP)\n\nvoid pp_map_k24(fp24_t r, const ep_t p, const ep4_t q) {\n\tep_t _p[1];\n\tep4_t t[1], _q[1];\n\tbn_t a;\n\n\tep_null(_p[0]);\n\tep4_null(_q[0]);\n\tep4_null(t[0]);\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep4_new(_q[0]);\n\t\tep4_new(t[0]);\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp24_set_dig(r, 1);\n\n\t\tep_norm(_p[0], p);\n\t\tep4_norm(_q[0], q);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep4_is_infty(_q[0])) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_B24:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k24(r, t, _q, _p, 1, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp24_inv_cyc(r, r);\n\t\t\t\t\t\tep4_neg(t[0], t[0]);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k24(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep4_free(_q[0]);\n\t\tep4_free(t[0]);\n\t\tbn_free(a);\n\t}\n}\n\nvoid pp_map_sim_k24(fp24_t r, const ep_t *p, const ep4_t *q, int m) {\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *t = RLC_ALLOCA(ep4_t, m), *_q = RLC_ALLOCA(ep4_t, m);\n\tbn_t a;\n\tint i, j;\n\n\tRLC_TRY {\n\t\tbn_null(a);\n\t\tbn_new(a);\n\t\tif (_p == NULL || _q == NULL || t == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_null(_p[i]);\n\t\t\tep4_null(_q[i]);\n\t\t\tep4_null(t[i]);\n\t\t\tep_new(_p[i]);\n\t\t\tep4_new(_q[i]);\n\t\t\tep4_new(t[i]);\n\t\t}\n\n\t\tj = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (!ep_is_infty(p[i]) && !ep4_is_infty(q[i])) {\n\t\t\t\tep_norm(_p[j], p[i]);\n\t\t\t\tep4_norm(_q[j++], q[i]);\n\t\t\t}\n\t\t}\n\n\t\tfp_prime_get_par(a);\n\t\tfp24_set_dig(r, 1);\n\n\t\tif (j > 0) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_B24:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k24(r, t, _q, _p, j, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp24_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k24(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tep_free(_p[i]);\n\t\t\tep4_free(_q[i]);\n\t\t\tep4_free(t[i]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t\tRLC_FREE(t);\n\t}\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 48.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                         */\n/*============================================================================*/\n\nstatic void pp_mil_k48(fp48_t r, const fp8_t qx, const fp8_t qy, const ep_t p,\n\t\tconst bn_t a) {\n\tfp48_t l;\n\tep_t _p;\n\tfp8_t rx, ry, rz, qn;\n\tsize_t len = bn_bits(a) + 1;\n\tint i;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tfp48_null(l);\n\tep_null(_p);\n\tfp8_null(rx);\n\tfp8_null(ry);\n\tfp8_null(rz);\n\tfp8_null(qn);\n\n\tRLC_TRY {\n\t\tfp48_new(l);\n\t\tep_new(_p);\n\t\tfp8_new(rx);\n\t\tfp8_new(ry);\n\t\tfp8_new(rz);\n\t\tfp8_new(qn);\n\n\t\tfp48_zero(l);\n\t\tfp8_copy(rx, qx);\n\t\tfp8_copy(ry, qy);\n\t\tfp8_set_dig(rz, 1);\n#if EP_ADD == BASIC\n\t\tep_neg(_p, p);\n#else\n\t\tfp_add(_p->x, p->x, p->x);\n\t\tfp_add(_p->x, _p->x, p->x);\n\t\tfp_neg(_p->y, p->y);\n#endif\n\t\tfp8_neg(qn, qy);\n\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tfp48_sqr(r, r);\n\t\t\tpp_dbl_k48(l, rx, ry, rz, _p);\n\t\t\tfp48_mul_dxs(r, r, l);\n\t\t\tif (s[i] > 0) {\n\t\t\t\tpp_add_k48(l, rx, ry, rz, qx, qy, p);\n\t\t\t\tfp48_mul_dxs(r, r, l);\n\t\t\t}\n\t\t\tif (s[i] < 0) {\n\t\t\t\tpp_add_k48(l, rx, ry, rz, qx, qn, p);\n\t\t\t\tfp48_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp48_free(l);\n\t\tep_free(_p);\n\t\tfp8_free(rx);\n\t\tfp8_free(ry);\n\t\tfp8_free(rz);\n\t\tfp8_free(qn);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid pp_map_k48(fp48_t r, const ep_t p, const fp8_t qx, const fp8_t qy) {\n\tbn_t a;\n\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp48_set_dig(r, 1);\n\n\t\tif (!ep_is_infty(p) && !(fp8_is_zero(qx) && fp8_is_zero(qy))) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_B48:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k48(r, qx, qy, p, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp48_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k48(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 54.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\nstatic void pp_mil_k54(fp54_t r, const fp9_t qx, const fp9_t qy, const ep_t p,\n\t\tconst bn_t a) {\n\tfp54_t l;\n\tep_t _p;\n\tfp9_t rx, ry, rz, sx, sy, sz, qn;\n\tsize_t len = bn_bits(a) + 1;\n\tint i;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tfp54_null(l);\n\tep_null(_p);\n\tfp9_null(rx);\n\tfp9_null(ry);\n\tfp9_null(rz);\n\tfp9_null(sx);\n\tfp9_null(sy);\n\tfp9_null(sz);\n\n\tRLC_TRY {\n\t\tfp54_new(l);\n\t\tep_new(_p);\n\t\tfp9_new(rx);\n\t\tfp9_new(ry);\n\t\tfp9_new(rz);\n\t\tfp9_new(sx);\n\t\tfp9_new(sy);\n\t\tfp9_new(sz);\n\t\tfp9_new(qn);\n\n\t\tfp54_zero(l);\n\t\tfp9_copy(rx, qx);\n\t\tfp9_copy(ry, qy);\n\t\tfp9_set_dig(rz, 1);\n#if EP_ADD == BASIC\n\t\tep_neg(_p, p);\n#else\n\t\tfp_add(_p->x, p->x, p->x);\n\t\tfp_add(_p->x, _p->x, p->x);\n\t\tfp_neg(_p->y, p->y);\n#endif\n\t\tfp9_neg(qn, qy);\n\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tfp54_sqr(r, r);\n\t\t\tpp_dbl_k54(l, rx, ry, rz, _p);\n\t\t\tfp54_mul_dxs(r, r, l);\n\t\t\tif (s[i] > 0) {\n\t\t\t\tpp_add_k54(l, rx, ry, rz, qx, qy, p);\n\t\t\t\tfp54_mul_dxs(r, r, l);\n\t\t\t}\n\t\t\tif (s[i] < 0) {\n\t\t\t\tpp_add_k54(l, rx, ry, rz, qx, qn, p);\n\t\t\t\tfp54_mul_dxs(r, r, l);\n\t\t\t}\n\t\t}\n\t\t/* Compute f^3. */\n\t\tfp54_sqr(l, r);\n\t\tfp54_mul(r, r, l);\n\n\t\tfp54_zero(l);\n\t\tfp9_copy(sx, rx);\n\t\tfp9_copy(sy, ry);\n\t\tfp9_copy(sz, rz);\n\t\tpp_dbl_k54(l, sx, sy, sz, _p);\n\t\tfp54_mul_dxs(r, r, l);\n#if EP_ADD == PROJC\n\t\tfp9_inv(sz, sz);\n\t\tfp9_mul(sx, sx, sz);\n\t\tfp9_mul(sy, sy, sz);\n#endif\n\t\tpp_add_k54(l, rx, ry, rz, sx, sy, p);\n\t\tfp54_mul_dxs(r, r, l);\n\t\tfp9_frb(rx, qx, 1);\n\t\tfp9_frb(ry, qy, 1);\n\t\tfp9_zero(sz);\n\t\tfp3_set_dig(sz[1], 1);\n\t\tfp9_inv(sz, sz);\n\t\tfp_copy(sz[0][0], sz[2][2]);\n\t\tfp_mul(sz[0][0], sz[0][0], core_get()->fp3_p0[1]);\n\t\tfp_mul(sz[0][0], sz[0][0], core_get()->fp3_p1[3]);\n\t\tfp_mul(sz[0][0], sz[0][0], core_get()->fp3_p1[0]);\n\t\tfp3_mul_nor(sz[0], sz[0]);\n\t\tfp3_mul_nor(sz[0], sz[0]);\n\t\tfp3_mul_nor(sz[0], sz[0]);\n\t\tfp_mul(sz[1][0], sz[0][0], core_get()->fp3_p2[1]);\n\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tfp3_mul(ry[i], ry[i], sz[0]);\n\t\t\tfp3_mul(rx[i], rx[i], sz[1]);\n\t\t}\n\n\t\tfp9_frb(sx, qx, 10);\n\t\tfp9_frb(sy, qy, 10);\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tfor (int i = 0; i < 3; i++) {\n\t\t\t\tfp3_mul(sy[i], sy[i], sz[0]);\n\t\t\t\tfp3_mul(sx[i], sx[i], sz[1]);\n\t\t\t}\n\t\t}\n\t\tfp9_set_dig(sz, 1);\n\n\t\tpp_add_k54(l, sx, sy, sz, rx, ry, p);\n\t\tfp54_mul_dxs(r, r, l);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp54_free(l);\n\t\tep_free(_p);\n\t\tfp9_free(rx);\n\t\tfp9_free(ry);\n\t\tfp9_free(rz);\n\t\tfp9_free(sx);\n\t\tfp9_free(sy);\n\t\tfp9_free(sz);\n\t\tfp9_free(qn);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid pp_map_k54(fp54_t r, const ep_t p, const fp9_t qx, const fp9_t qy) {\n\tbn_t a;\n\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp54_set_dig(r, 1);\n\n\t\tif (!ep_is_infty(p) && !(fp9_is_zero(qx) && fp9_is_zero(qy))) {\n\t\t\tswitch (ep_curve_is_pairf()) {\n\t\t\t\tcase EP_K54:\n\t\t\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\t\t\tpp_mil_k54(r, qx, qy, p, a);\n\t\t\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\t\t\tfp54_inv_cyc(r, r);\n\t\t\t\t\t}\n\t\t\t\t\tpp_exp_k54(r, r);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tbn_free(a);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2019 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of pairing computation for curves with embedding degree 8.\n *\n * @ingroup pp\n */\n\n#include \"relic_core.h\"\n#include \"relic_pp.h\"\n#include \"relic_util.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Compute the Miller loop for pairings of type G_2 x G_1 over the bits of a\n * given parameter represented in sparse form.\n *\n * @param[out] r\t\t\t- the result.\n * @param[out] t\t\t\t- the resulting point.\n * @param[in] q\t\t\t\t- the vector of first arguments in affine coordinates.\n * @param[in] p\t\t\t\t- the vector of second arguments in affine coordinates.\n * @param[in] n \t\t\t- the number of pairings to evaluate.\n * @param[in] s\t\t\t\t- the loop parameter in sparse form.\n * @paramin] len\t\t\t- the length of the loop parameter.\n */\nstatic void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp8_null(l);\n\n\tRLC_TRY {\n\t\tfp8_new(l);\n\t\tif (_p == NULL || _q == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}\n\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_null(_p[j]);\n\t\t\tep2_null(_q[j]);\n\t\t\tep_new(_p[j]);\n\t\t\tep2_new(_q[j]);\n\t\t\tep2_copy(t[j], q[j]);\n\t\t\tep2_neg(_q[j], q[j]);\n\n#if EP_ADD == BASIC\n\t\t\tep_neg(_p[j], p[j]);\n#else\n\t\t\tfp_neg(_p[j]->x, p[j]->x);\n\t\t\tfp_copy(_p[j]->y, p[j]->y);\n#endif\n\t\t}\n\n\t\tfp8_zero(l);\n\t\tbn_rec_naf(s, &len, a, 2);\n\t\tfor (i = len - 2; i >= 0; i--) {\n\t\t\tfp8_sqr(r, r);\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tpp_dbl_k8(l, t[j], t[j], _p[j]);\n\t\t\t\tfp8_mul(r, r, l);\n\t\t\t\tif (s[i] > 0) {\n\t\t\t\t\tpp_add_k8(l, t[j], q[j], _p[j]);\n\t\t\t\t\tfp8_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tpp_add_k8(l, t[j], _q[j], _p[j]);\n\t\t\t\t\tfp8_mul_dxs(r, r, l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp8_free(l);\n\t\tfor (j = 0; j < m; j++) {\n\t\t\tep_free(_p[j]);\n\t\t\tep2_free(_q[j]);\n\t\t}\n\t\tRLC_FREE(_p);\n\t\tRLC_FREE(_q);\n\t}\n}\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid pp_map_oatep_k8(fp8_t r, const ep_t p, const ep2_t q) {\n\tep_t _p[1];\n\tep2_t t[1], _q[1];\n\tbn_t a;\n\n\tep_null(_p[0]);\n\tep2_null(_q[0]);\n\tep2_null(t[0]);\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tep_new(_p[0]);\n\t\tep2_new(_q[0]);\n\t\tep2_new(t[0]);\n\t\tbn_new(a);\n\n\t\tfp_prime_get_par(a);\n\t\tfp8_set_dig(r, 1);\n\n\t\tep_norm(_p[0], p);\n\t\tep2_norm(_q[0], q);\n\n\t\tif (!ep_is_infty(_p[0]) && !ep2_is_infty(_q[0])) {\n\t\t\t/* r = f_{|a|,Q}(P). */\n\t\t\tpp_mil_k8(r, t, _q, _p, 1, a);\n\t\t\tif (bn_sign(a) == RLC_NEG) {\n\t\t\t\tfp8_inv_cyc(r, r);\n\t\t\t\tep2_neg(t[0], t[0]);\n\t\t\t}\n\t\t\tpp_exp_k8(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tep_free(_p[0]);\n\t\tep2_free(_q[0]);\n\t\tep2_free(t[0]);\n\t\tbn_free(a);\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2013 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of utilities for pseudo-random number generation.\n *\n * @ingroup rand\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_label.h\"\n#include \"relic_rand.h\"\n#include \"relic_md.h\"\n#include \"relic_err.h\"\n\n#if RAND == UDEV || SEED == UDEV\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n#elif SEED == WCGR\n\n/* Avoid redefinition warning. */\n#undef ERROR\n#undef WSIZE\n#undef DOUBLE\n\n#include <windows.h>\n#include <wincrypt.h>\n\n#elif SEED == RDRND\n\n#include <immintrin.h>\n\n#endif\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * The path to the char device that supplies entropy.\n */\n#if SEED == DEV\n#define RLC_RAND_PATH\t\t\"/dev/random\"\n#else\n#define RLC_RAND_PATH\t\t\"/dev/urandom\"\n#endif\n\n/** The maximum number of bytes that can be repeated in the output. */\n#define RAND_REP\t\t\t6\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nvoid rand_init(void) {\n\tuint8_t buf[RLC_RAND_SEED];\n\n#if RAND == UDEV\n\tint *fd = (int *)&(core_get()->rand);\n\n\t*fd = open(RLC_RAND_PATH, O_RDONLY);\n\tif (*fd == -1) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t\treturn;\n\t}\n#else\n\n#if !defined(SEED)\n\n\tmemset(buf, 0, RLC_RAND_SEED);\n\n#elif SEED == DEV || SEED == UDEV\n\tint fd, c, l;\n\n\tfd = open(RLC_RAND_PATH, O_RDONLY);\n\tif (fd == -1) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t\treturn;\n\t}\n\n\tl = 0;\n\tdo {\n\t\tc = read(fd, buf + l, RLC_RAND_SEED - l);\n\t\tl += c;\n\t\tif (c == -1) {\n\t\t\tRLC_THROW(ERR_NO_READ);\n\t\t\treturn;\n\t\t}\n\t} while (l < RLC_RAND_SEED);\n\n\tif (fd != -1) {\n\t\tclose(fd);\n\t}\n#elif SEED == LIBC\n\n#if OPSYS == FREEBSD || OPSYS == NETBSD\n\t/* This is better than using a fixed value. */\n\tsrandomdev();\n\tfor (int i = 0; i < RLC_RAND_SEED; i++) {\n\t\tbuf[i] = (uint8_t)random();\n\t}\n#else\n\t/* This is horribly insecure, serves only for benchmarking. */\n\tsrand(1);\n\tfor (int i = 0; i < RLC_RAND_SEED; i++) {\n\t\tbuf[i] = (uint8_t)rand();\n\t}\n#endif\n\n#elif SEED == WCGR\n\n\tHCRYPTPROV hCryptProv;\n\n\tif (!CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_RSA_FULL,\n\t\t\t\t\tCRYPT_VERIFYCONTEXT | CRYPT_SILENT)) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t\treturn;\n\t}\n\tif (hCryptProv && !CryptGenRandom(hCryptProv, RLC_RAND_SEED, buf)) {\n\t\tRLC_THROW(ERR_NO_READ);\n\t\treturn;\n\t}\n\tif (hCryptProv && !CryptReleaseContext(hCryptProv, 0)) {\n\t\tRLC_THROW(ERR_NO_READ);\n\t\treturn;\n\t}\n\n#elif SEED == RDRND\n\n\tint i, j;\n\tull_t r;\n\n\twhile (i < RLC_RAND_SEED) {\n#ifdef __RDRND__\n\t\twhile (_rdrand64_step(&r) == 0);\n#else\n#error \"RdRand not available, check your compiler settings.\"\n#endif\n\t\tfor (j = 0; i < RLC_RAND_SEED && j < sizeof(ull_t); i++, j++) {\n\t\t\tbuf[i] = r & 0xFF;\n\t\t}\n\t}\n\n#endif\n\n#endif /* RAND == UDEV */\n\n#if RAND != CALL\n\tcore_get()->seeded = 0;\n\trand_seed(buf, RLC_RAND_SEED);\n#else\n\trand_seed(NULL, NULL);\n#endif\n}\n\nint rand_check(uint8_t *buf, size_t size) {\n\tint count = 0;\n\n\tfor (int i = 1; i < size; i++) {\n\t\tif (buf[i] == buf[i - 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tcount = 0;\n\t\t}\n\t}\n\n\tif (count > RAND_REP) {\n\t\treturn RLC_ERR;\n\t}\n\treturn RLC_OK;\n}\n\nvoid rand_clean(void) {\n\tctx_t *ctx = core_get();\n\tif (ctx != NULL) {\n#if RAND == UDEV\n\t\tint *fd = (int *)&(ctx->rand);\n\t\tclose(*fd);\n#endif\n#if RAND != CALL\n\t\tmemset(ctx->rand, 0, sizeof(ctx->rand));\n#else\n\t\tctx->rand_call = NULL;\n\t\tctx->rand_args = NULL;\n#endif\n\t\tctx->seeded = 0;\n\t}\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2018 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of the Hash_DRBG pseudo-random number generator.\n *\n * @ingroup rand\n */\n\n#include <stdlib.h>\n#include <stdint.h>\n\n#include \"relic_conf.h\"\n#include \"relic_core.h\"\n#include \"relic_label.h\"\n#include \"relic_rand.h\"\n#include \"relic_md.h\"\n#include \"relic_err.h\"\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n#if RAND == HASHD\n\n/*\n * Computes the hash derivation function.\n *\n * param[out] out       - the result.\n * param[in] out_len    - the number of bytes to return.\n * param[in] in         - the input string.\n * param[in] in_len     - the number of bytes in the input.\n */\nstatic void rand_hash(uint8_t *out, size_t out_len, uint8_t *in,\n\t\tsize_t in_len) {\n\tuint32_t j = util_conv_big(8 * out_len);\n\tsize_t len = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t* buf = RLC_ALLOCA(uint8_t, 1 + sizeof(uint32_t) + in_len);\n\tuint8_t hash[RLC_MD_LEN];\n\n\tif (buf == NULL) {\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\treturn;\n\t}\n\n\tbuf[0] = 1;\n\tmemcpy(buf + 1, &j, sizeof(uint32_t));\n\tmemcpy(buf + 1 + sizeof(uint32_t), in, in_len);\n\n\tfor (int i = 0; i < len; i++) {\n\t\t/* h = Hash(counter || bits_to_return || input_string) */\n\t\tmd_map(hash, buf, 1 + sizeof(uint32_t) + in_len);\n\t\t/* temp = temp || h */\n\t\tmemcpy(out, hash, RLC_MIN(RLC_MD_LEN, out_len));\n\t\tout += RLC_MD_LEN;\n\t\tout_len -= RLC_MD_LEN;\n\t\t/* counter = counter + 1 */\n\t\tbuf[0]++;\n\t}\n\n\tRLC_FREE(buf);\n}\n\n/**\n * Accumulates a small integer in the internal state.\n *\n * @param[in,out] state\t\t- the internal state.\n * @param[in] digit\t\t\t- the small integer.\n */\nstatic int rand_inc(uint8_t *data, size_t size, int digit) {\n\tint carry = digit;\n\tfor (int i = size - 1; i >= 0; i--) {\n\t\tint16_t s;\n\t\ts = (data[i] + carry);\n\t\tdata[i] = s & 0xFF;\n\t\tcarry = s >> 8;\n\t}\n\treturn carry;\n}\n\n/**\n * Accumulates the hash value in the internal state.\n *\n * @param[in,out] state\t\t- the internal state.\n * @param[in] hash\t\t\t- the hash value.\n */\nstatic int rand_add(uint8_t *state, uint8_t *hash, size_t size) {\n\tint carry = 0;\n\tfor (int i = size - 1; i >= 0; i--) {\n\t\t/* Make sure carries are detected. */\n\t\tint16_t s;\n\t\ts = (state[i] + hash[i] + carry);\n\t\tstate[i] = s & 0xFF;\n\t\tcarry = s >> 8;\n\t}\n\treturn carry;\n}\n\n/**\n * Generates pseudo-random bytes by iterating the hash function.\n *\n * @param[out] out \t\t\t- the buffer to write.\n * @param[in] out_len\t\t- the number of bytes to write.\n */\nstatic void rand_gen(uint8_t *out, size_t out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n\tctx_t *ctx = core_get();\n\n\t/* data = V */\n\tmemcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)/2);\n\tfor (int i = 0; i < m; i++) {\n\t\t/* w_i = Hash(data) */\n\t\tmd_map(hash, data, sizeof(data));\n\t\t/* W = W || w_i */\n\t\tmemcpy(out, hash, RLC_MIN(RLC_MD_LEN, out_len));\n\t\tout += RLC_MD_LEN;\n\t\tout_len -= RLC_MD_LEN;\n\t\t/* data = data + 1 mod 2^b. */\n\t\trand_inc(data, (RLC_RAND_SIZE - 1)/2, 1);\n\t}\n}\n\n#endif\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\n#if RAND == HASHD\n\nvoid rand_bytes(uint8_t *buf, size_t size) {\n\tuint8_t hash[RLC_MD_LEN];\n\tint carry, len  = (RLC_RAND_SIZE - 1)/2;\n\tctx_t *ctx = core_get();\n\n\tif (sizeof(int) > 2 && size > (1 << 16)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\t/* buf = hash_gen(size) */\n\trand_gen(buf, size);\n\t/* H = hash(03 || V) */\n\tctx->rand[0] = 0x3;\n\tmd_map(hash, ctx->rand, 1 + len);\n\t/* V = V + H + C  + reseed_counter. */\n\trand_add(ctx->rand + 1, ctx->rand + 1 + len, len);\n\tcarry = rand_add(ctx->rand + 1 + (len - RLC_MD_LEN), hash, RLC_MD_LEN);\n\trand_inc(ctx->rand, len - RLC_MD_LEN + 1, carry);\n\trand_inc(ctx->rand, len + 1, ctx->counter);\n\tctx->counter = ctx->counter + 1;\n}\n\nvoid rand_seed(uint8_t *buf, size_t size) {\n\tctx_t *ctx = core_get();\n\tsize_t len = (RLC_RAND_SIZE - 1) / 2;\n\n\tif (size <= 0) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tif (sizeof(int) > 4 && size > (1 << 32)) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\n\tctx->rand[0] = 0x0;\n\tif (ctx->seeded == 0) {\n\t\t/* V = hash_df(seed). */\n\t\trand_hash(ctx->rand + 1, len, buf, size);\n\t\t/* C = hash_df(00 || V). */\n\t\trand_hash(ctx->rand + 1 + len, len, ctx->rand, len + 1);\n\t} else {\n\t\t/* V = hash_df(01 || V || seed). */\n        int tmp_size = 1 + len + size;\n\t\tuint8_t* tmp = RLC_ALLOCA(uint8_t, tmp_size);\n\t\tif (tmp == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\treturn;\n\t\t}\n\t\ttmp[0] = 1;\n\t\tmemcpy(tmp + 1, ctx->rand + 1, len);\n\t\tmemcpy(tmp + 1 + len, buf, size);\n\t\trand_hash(ctx->rand + 1, len, tmp, tmp_size);\n\t\t/* C = hash_df(00 || V). */\n\t\trand_hash(ctx->rand + 1 + len, len, ctx->rand, len + 1);\n\t\tRLC_FREE(tmp);\n\t}\n\tctx->counter = ctx->seeded = 1;\n}\n\n#endif\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Implementation of useful configuration routines.\n *\n * @ingroup relic\n */\n\n#include <stdio.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <inttypes.h>\n\n#include \"relic_core.h\"\n#include \"relic_conf.h\"\n#include \"relic_util.h\"\n#include \"relic_types.h\"\n\n#if ARCH == ARM && OPSYS == DROID\n#include <android/log.h>\n#endif\n\n/*============================================================================*/\n/* Private definitions                                                        */\n/*============================================================================*/\n\n/**\n * Buffer to hold printed messages.\n */\n#if ARCH == AVR\n\n#ifndef QUIET\nvolatile char print_buf[128 + 1];\nvolatile char *util_print_ptr;\n\n#if OPSYS == DUINO\n/**\n * Send byte to serial port.\n */\nvoid uart_putchar(char c, FILE *stream) {\n\tif (c == '\\n') {\n\t\tuart_putchar('\\r', stream);\n\t}\n\tloop_until_bit_is_set(UCSR0A, UDRE0);\n\tUDR0 = c;\n}\n\n/**\n * Stream for serial port.\n */\nFILE uart_output = FDEV_SETUP_STREAM(uart_putchar, NULL, _FDEV_SETUP_WRITE);\n\n#endif\n#endif\n\n#endif /* QUIET */\n\n/*============================================================================*/\n/* Public definitions                                                         */\n/*============================================================================*/\n\nuint32_t util_conv_endian(uint32_t i) {\n\tuint32_t i1, i2, i3, i4;\n\ti1 = i & 0xFF;\n\ti2 = (i >> 8) & 0xFF;\n\ti3 = (i >> 16) & 0xFF;\n\ti4 = (i >> 24) & 0xFF;\n\n\treturn ((uint32_t) i1 << 24) | ((uint32_t) i2 << 16) | ((uint32_t) i3 << 8)\n\t\t\t| i4;\n}\n\nuint32_t util_conv_big(uint32_t i) {\n#ifdef BIGED\n\treturn i;\n#else\n\treturn util_conv_endian(i);\n#endif\n}\n\nuint32_t util_conv_little(uint32_t i) {\n#ifndef BIGED\n\treturn util_conv_endian(i);\n#else\n\treturn i;\n#endif\n}\n\nchar util_conv_char(dig_t i) {\n#if WSIZE == 8 || WSIZE == 16\n\t/* Avoid tables to save up some memory. This is not performance-critical. */\n\tif (i < 10) {\n\t\treturn i + '0';\n\t}\n\tif (i < 36) {\n\t\treturn (i - 10) + 'A';\n\t}\n\tif (i < 62) {\n\t\treturn (i - 36) + 'a';\n\t}\n\tif (i == 62) {\n\t\treturn '+';\n\t} else {\n\t\treturn '/';\n\t}\n#else\n\t/* Use a table. */\n\tstatic const char conv_table[] =\n\t\t\t\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/\";\n\treturn conv_table[i];\n#endif\n}\n\nsize_t util_bits_dig(dig_t a) {\n    return RLC_DIG - arch_lzcnt(a);\n}\n\nint util_cmp_const(const void *a, const void *b, int size) {\n\tconst uint8_t *_a = (const uint8_t *)a;\n\tconst uint8_t *_b = (const uint8_t *)b;\n\tuint8_t result = 0;\n\tint i;\n\n\tfor (i = 0; i < size; i++) {\n\t\tresult |= _a[i] ^ _b[i];\n\t}\n\n\treturn (result == 0 ? RLC_EQ : RLC_NE);\n}\n\nvoid util_perm(unsigned int p[], int n) {\n\tsize_t i, j, k;\n\n\tfor (i = 0; i < n; i++) {\n\t\trand_bytes((uint8_t *)&k, sizeof(size_t));\n\t\tj = k % (i+1);\n\t\tp[i] = p[j];\n\t\tp[j] = i;\n\t}\n}\n\n#ifndef QUIET\nvoid util_print(const char *format, ...) {\n#if ARCH == AVR && !defined(OPSYS)\n\tutil_print_ptr = print_buf + 1;\n\tva_list list;\n\tva_start(list, format);\n\tvsnprintf_P((char *)util_print_ptr, sizeof(print_buf) - 1, format, list);\n\tva_end(list);\n\tprint_buf[0] = (uint8_t)2;\n#elif ARCH == AVR && OPSYS == DUINO\n\tstdout = &uart_output;\n\tva_list list;\n\tva_start(list, format);\n\tvsnprintf_P((char *)print_buf, sizeof(print_buf), format, list);\n\tprintf(\"%s\", (char *)print_buf);\n\tva_end(list);\n#elif ARCH == MSP && !defined(OPSYS)\n\tva_list list;\n\tva_start(list, format);\n\tvprintf(format, list);\n\tva_end(list);\n#elif ARCH == ARM && OPSYS == DROID\n\tva_list list;\n\tva_start(list, format);\n\t__android_log_vprint(ANDROID_LOG_INFO, \"relic-toolkit\", format, list);\n\tva_end(list);\n#else\n\tva_list list;\n\tva_start(list, format);\n\tvprintf(format, list);\n\tfflush(stdout);\n\tva_end(list);\n#endif\n}\n#endif\n\nvoid util_print_dig(dig_t a, int pad) {\n#if RLC_DIG == 64\n\tif (pad) {\n\t\tutil_print(\"%.16\" PRIX64, (uint64_t) a);\n\t} else {\n\t\tutil_print(\"%\" PRIX64, (uint64_t) a);\n\t}\n#elif RLC_DIG == 32\n\tif (pad) {\n\t\tutil_print(\"%.8\" PRIX32, (uint32_t) a);\n\t} else {\n\t\tutil_print(\"%\" PRIX32, (uint32_t) a);\n\t}\n#elif RLC_DIG == 16\n\tif (pad) {\n\t\tutil_print(\"%.4\" PRIX16, (uint16_t) a);\n\t} else {\n\t\tutil_print(\"%\" PRIX16, (uint16_t) a);\n\t}\n#else\n\tif (pad) {\n\t\tutil_print(\"%.2\" PRIX8, (uint8_t)a);\n\t} else {\n\t\tutil_print(\"%\" PRIX8, (uint8_t)a);\n\t}\n#endif\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for multiple precision integer arithmetic.\n *\n * @ingroup test\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\nstatic int memory(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tbn_t a;\n\n\tbn_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tbn_new(a);\n\t\t\tbn_free(a);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nstatic int util(void) {\n\tint bits, code = RLC_ERR;\n\tchar str[RLC_BN_BITS + 2];\n\tdig_t digit, raw[RLC_BN_DIGS];\n\tuint8_t bin[RLC_CEIL(RLC_BN_BITS, 8)];\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tif (bn_cmp(a, b) != RLC_EQ) {\n\t\t\t\tif (bn_cmp(a, b) == RLC_GT) {\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_LT, end);\n\t\t\t\t} else {\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_GT, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS);\n\t\t\tif (bn_cmp(a, c) != RLC_EQ) {\n\t\t\t\tbn_copy(c, a);\n\t\t\t\tTEST_ASSERT(bn_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (bn_cmp(b, c) != RLC_EQ) {\n\t\t\t\tbn_copy(c, b);\n\t\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"absolute, negation and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_neg(b, a);\n\t\t\tbn_abs(a, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_abs(a, b) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_LT, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"signal test is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_sign(a) == RLC_POS, end);\n\t\t\tTEST_ASSERT(bn_sign(b) == RLC_NEG, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to zero and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_zero(c);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(c, a) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp(c, b) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, (dig_t)0) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to zero and zero test are consistent\") {\n\t\t\tbn_zero(c);\n\t\t\tTEST_ASSERT(bn_is_zero(c), end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, (dig_t)0) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"oddness test is correct\") {\n\t\t\tbn_set_dig(a, 2);\n\t\t\tbn_set_dig(b, 1);\n\t\t\tTEST_ASSERT(bn_is_even(a) == 1, end);\n\t\t\tTEST_ASSERT(bn_is_even(b) == 0, end);\n\t\t} TEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"assignment and bit counting are consistent\") {\n\t\t\tbn_set_2b(a, bits);\n\t\t\tTEST_ASSERT(bits + 1 == bn_bits(a), end);\n\t\t\tbits = (bits + 1) % RLC_BN_BITS;\n\t\t} TEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"bit setting and getting are consistent\") {\n\t\t\tbn_zero(a);\n\t\t\tbn_set_bit(a, bits, 1);\n\t\t\tTEST_ASSERT(bn_get_bit(a, bits) == 1, end);\n\t\t\tbn_set_bit(a, bits, 0);\n\t\t\tTEST_ASSERT(bn_get_bit(a, bits) == 0, end);\n\t\t\tbits = (bits + 1) % RLC_BN_BITS;\n\t\t}\n\t\tTEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"hamming weight is correct\") {\n\t\t\tbn_zero(a);\n\t\t\tfor (int j = 0; j < bits; j++) {\n\t\t\t\tbn_set_bit(a, j, 1);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_ham(a) == bits, end);\n\t\t\tbits = (bits + 1) % RLC_BN_BITS;\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"generating a random integer is consistent\") {\n\t\t\tdo {\n\t\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\t} while (bn_is_zero(b));\n\t\t\tbn_rand_mod(a, b);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(b), end);\n\t\t\tTEST_ASSERT(bn_is_zero(a) == 0, end);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_LT, end);\n\t\t\tdo {\n\t\t\t\tbn_rand(b, RLC_NEG, RLC_DIG);\n\t\t\t} while (bn_bits(b) <= 1);\n\t\t\tbn_rand_mod(a, b);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(b), end);\n\t\t\tTEST_ASSERT(bn_is_zero(a) == 0, end);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_GT, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing the first digit are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_DIG);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&digit, a);\n\t\t\tbn_set_dig(b, digit);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to a constant and comparison are consistent\") {\n\t\t\tbn_set_dig(a, 2);\n\t\t\tbn_set_dig(b, 1);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, a) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_GT, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"assignment to random and comparison are consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_zero(c);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_LT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, (dig_t)0) == RLC_GT, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, (dig_t)0) == RLC_LT, end);\n\t\t} TEST_END;\n\n\t\tbits = 0;\n\t\tTEST_CASE(\"different forms of assignment are consistent\") {\n\t\t\tbn_set_dig(a, (dig_t)(1) << (dig_t)bits);\n\t\t\tbn_set_2b(b, bits);\n\t\t\tbits++;\n\t\t\tbits %= (RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\tlen = RLC_BN_DIGS;\n\t\t\tbn_write_raw(raw, len, a);\n\t\t\tbn_read_raw(b, raw, len);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"getting the size of a positive number is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tTEST_ASSERT((bn_size_str(a, 2) - 1) == bn_bits(a), end);\n\t\t\tbits = (bn_bits(a) % 8 == 0 ? bn_bits(a) / 8 : bn_bits(a) / 8 + 1);\n\t\t\tTEST_ASSERT(bn_size_bin(a) == bits, end);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tbn_neg(b, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\tlen = RLC_BN_DIGS;\n\t\t\tbn_write_raw(raw, len, a);\n\t\t\tbn_read_raw(b, raw, len);\n\t\t\tbn_neg(b, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"getting the size of a negative number is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tTEST_ASSERT((bn_size_str(a, 2) - 2) == bn_bits(a), end);\n\t\t\tbits = (bn_bits(a) % 8 == 0 ? bn_bits(a) / 8 : bn_bits(a) / 8 + 1);\n\t\t\tTEST_ASSERT(bn_size_bin(a) == bits, end);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int addition(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\n\t\tTEST_CASE(\"addition is commutative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_add(d, a, b);\n\t\t\tbn_add(e, b, a);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"addition is associative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_add(d, a, b);\n\t\t\tbn_add(d, d, c);\n\t\t\tbn_add(e, b, c);\n\t\t\tbn_add(e, a, e);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"addition has identity\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(d);\n\t\t\tbn_add(e, a, d);\n\t\t\tTEST_ASSERT(bn_cmp(e, a) == RLC_EQ, end);\n\t\t\tbn_add(e, d, a);\n\t\t\tTEST_ASSERT(bn_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"addition has inverse\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_neg(d, a);\n\t\t\tbn_add(e, a, d);\n\t\t\tTEST_ASSERT(bn_is_zero(e), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\treturn code;\n}\n\nstatic int subtraction(void) {\n\tint code = RLC_ERR;\n\tint s;\n\tbn_t a, b, c, d;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\n\t\tTEST_CASE(\"subtraction is anti-commutative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_sub(c, a, b);\n\t\t\tbn_sub(d, b, a);\n\t\t\tTEST_ASSERT(bn_cmp_abs(c, d) == RLC_EQ, end);\n\t\t\tif (!bn_is_zero(c)) {\n\t\t\t\ts = bn_sign(d);\n\t\t\t\tTEST_ASSERT(bn_sign(c) != s, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"subtraction has identity\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(c);\n\t\t\tbn_sub(d, a, c);\n\t\t\tTEST_ASSERT(bn_cmp(d, a) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"subtraction has inverse\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_sub(c, a, a);\n\t\t\tTEST_ASSERT(bn_is_zero(c), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\treturn code;\n}\n\nstatic int multiplication(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e, f;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(f);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(f);\n\n\t\tTEST_CASE(\"multiplication is commutative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(d, a, b);\n\t\t\tbn_mul(e, b, a);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication is associative\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 3);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 3);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 3);\n\t\t\tbn_mul(d, a, b);\n\t\t\tbn_mul(d, d, c);\n\t\t\tbn_mul(e, b, c);\n\t\t\tbn_mul(e, a, e);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication is distributive\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_add(d, a, b);\n\t\t\tbn_mul(d, c, d);\n\t\t\tbn_mul(e, c, a);\n\t\t\tbn_mul(f, c, b);\n\t\t\tbn_add(e, e, f);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has identity\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_set_dig(d, (dig_t)1);\n\t\t\tbn_mul(e, a, d);\n\t\t\tTEST_ASSERT(bn_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has zero property\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(d);\n\t\t\tbn_mul(e, a, d);\n\t\t\tTEST_ASSERT(bn_is_zero(e), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has negation property\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_set_dig(d, 1);\n\t\t\tbn_neg(d, d);\n\t\t\tbn_mul(e, a, d);\n\t\t\tTEST_ASSERT(bn_cmp_abs(e, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(e) == RLC_NEG, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication by a positive number preserves order\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tint t = bn_cmp(a, b);\n\t\t\tbn_mul(d, c, a);\n\t\t\tbn_mul(e, c, b);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == t, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication by a negative number reverses order\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tint t = bn_cmp(a, b);\n\t\t\tbn_neg(d, c);\n\t\t\tbn_mul(e, d, a);\n\t\t\tbn_mul(d, d, b);\n\t\t\tif (t != RLC_EQ) {\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) != t, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n#if BN_MUL == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic multiplication is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_basic(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MUL == COMBA || !defined(STRIP)\n\t\tTEST_CASE(\"comba multiplication is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_comba(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\t\tTEST_CASE(\"karatsuba multiplication is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_karat(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(f);\n\treturn code;\n}\n\nstatic int squaring(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(b, a, a);\n\t\t\tbn_sqr(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n#if BN_SQR == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_sqr(b, a);\n\t\t\tbn_sqr_basic(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_SQR == COMBA || !defined(STRIP)\n\t\tTEST_CASE(\"comba squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_sqr(b, a);\n\t\t\tbn_sqr_comba(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_KARAT > 0 || !defined(STRIP)\n\t\tTEST_CASE(\"karatsuba squaring is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_sqr(b, a);\n\t\t\tbn_sqr_karat(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int doubling_halving(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"doubling is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 1);\n\t\t\tbn_add(b, a, a);\n\t\t\tbn_dbl(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"halving is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 1);\n\t\t\tbn_dbl(b, a);\n\t\t\tbn_hlv(c, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int shifting(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"shifting by 1 bit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 1);\n\t\t\tbn_lsh(b, a, 1);\n\t\t\tbn_dbl(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\tbn_rsh(b, a, 1);\n\t\t\tbn_hlv(c, a);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\tbn_lsh(b, a, 1);\n\t\t\tbn_rsh(c, b, 1);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by 2 bits is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 2);\n\t\t\tbn_lsh(b, a, 2);\n\t\t\tbn_rsh(c, b, 2);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by half digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_lsh(b, a, RLC_DIG / 2);\n\t\t\tbn_rsh(c, b, RLC_DIG / 2);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by 1 digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_DIG);\n\t\t\tbn_lsh(b, a, RLC_DIG);\n\t\t\tbn_rsh(c, b, RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"shifting by 2 digits is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - 2 * RLC_DIG);\n\t\t\tbn_lsh(b, a, 2 * RLC_DIG);\n\t\t\tbn_rsh(c, b, 2 * RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, c) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"shifting by 1 digit and half is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG - RLC_DIG / 2);\n\t\t\tbn_lsh(b, a, RLC_DIG + RLC_DIG / 2);\n\t\t\tbn_copy(c, a);\n\t\t\tfor (int j = 0; j < (int)(RLC_DIG + RLC_DIG / 2); j++)\n\t\t\t\tbn_dbl(c, c);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t\tbn_rsh(b, a, (RLC_DIG + RLC_DIG / 2));\n\t\t\tbn_copy(c, a);\n\t\t\tfor (int j = 0; j < (int)(RLC_DIG + RLC_DIG / 2); j++)\n\t\t\t\tbn_hlv(c, c);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int division(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\n\t\tTEST_CASE(\"trivial division is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == RLC_POS, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"trivial negative division is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"trivial division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"negative trivial division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"division is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(d), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"negative division is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) == bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == RLC_POS, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"negative division by negative is correct\") {\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_NEG, RLC_BN_BITS / 2);\n\t\t\tbn_div(e, a, b);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);\n\t\t\tbn_mul(e, c, b);\n\t\t\tbn_add(e, e, d);\n\t\t\tTEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_sign(a) != bn_sign(c), end);\n\t\t\tTEST_ASSERT(bn_sign(d) == bn_sign(b), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\treturn code;\n}\n\nstatic int reduction(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\n#if BN_MOD == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tbn_sqr(c, b);\n\t\t\tif (bn_cmp(a, c) == RLC_LT) {\n\t\t\t\tbn_mod_basic(e, a, b);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t\tbn_neg(a, a);\n\t\t\t\tbn_mod_basic(e, a, b);\n\t\t\t\tbn_sub(e, b, e);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MOD == BARRT || !defined(STRIP)\n\t\tTEST_CASE(\"barrett reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_div_rem(c, d, a, b);\n\t\t\tbn_sqr(c, b);\n\t\t\tif (bn_cmp(a, c) == RLC_LT) {\n\t\t\t\tbn_mod_pre_barrt(c, b);\n\t\t\t\tbn_mod_barrt(e, a, b, c);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t\tbn_neg(a, a);\n\t\t\t\tbn_mod_barrt(e, a, b, c);\n\t\t\t\tbn_sub(e, b, e);\n\t\t\t\tTEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if (BN_MOD == MONTY && BN_MUL == BASIC) || !defined(STRIP)\n\t\tTEST_CASE(\"basic montgomery reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(b)) {\n\t\t\t\tbn_add_dig(b, b, 1);\n\t\t\t}\n\t\t\tbn_mod(a, a, b);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_pre_monty(e, b);\n\t\t\tbn_mod_monty_basic(d, c, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t\tbn_neg(a, a);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_monty_basic(d, c, b, e);\n\t\t\tbn_add(a, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if (BN_MOD == MONTY && BN_MUL == COMBA) || !defined(STRIP)\n\t\tTEST_CASE(\"comba montgomery reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(b)) {\n\t\t\t\tbn_add_dig(b, b, 1);\n\t\t\t}\n\t\t\tbn_mod(a, a, b);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_pre_monty(e, b);\n\t\t\tbn_mod_monty_comba(d, c, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t\tbn_neg(a, a);\n\t\t\tbn_mod_monty_conv(c, a, b);\n\t\t\tbn_mod_monty_comba(d, c, b, e);\n\t\t\tbn_add(a, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MOD == PMERS || !defined(STRIP)\n\t\tTEST_CASE(\"pseudo-mersenne reduction is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(c, RLC_POS, RLC_BN_BITS / 4);\n\t\t\tif (bn_is_zero(c)) {\n\t\t\t\tbn_set_dig(c, 1);\n\t\t\t}\n\t\t\tbn_set_2b(b, RLC_BN_BITS / 2);\n\t\t\tbn_sub(b, b, c);\n\t\t\tbn_mod(c, a, b);\n\t\t\tbn_mod_pre_pmers(e, b);\n\t\t\tbn_mod_pmers(d, a, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t\tbn_neg(a, a);\n\t\t\tbn_mod(c, a, b);\n\t\t\tbn_mod_pmers(d, a, b, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\treturn code;\n}\n\nstatic int exponentiation(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, p;\n\tcrt_t crt;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(p);\n\tcrt_null(crt);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(p);\n\t\tcrt_new(crt);\n\n#if BN_MOD != PMERS\n\t\tbn_gen_prime(p, RLC_BN_BITS);\n#elif BN_PRECI >= 128\n\t\t/* Let's try a Mersenne prime. */\n\t\tbn_zero(p);\n\t\tbn_set_bit(p, 127, 1);\n\t\tbn_sub_dig(p, p, 1);\n#endif\n\n\t\tTEST_CASE(\"modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"modular exponentiation with zero power is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(b);\n\t\t\tbn_mxp(a, a, b, p);\n\t\t\tTEST_ASSERT(bn_cmp_dig(a, 1) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"modular exponentiation with negative power is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\t/* Compute c = a^b mod p. */\n\t\t\tbn_mxp(c, a, b, p);\n\t\t\t/* Compute b = a^-b mod p. */\n\t\t\tbn_neg(b, b);\n\t\t\tbn_mxp(b, a, b, p);\n\t\t\t/* Check that c * b = 1 mod p. */\n\t\t\tbn_mul(c, c, b);\n\t\t\tbn_mod(c, c, p);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n#if BN_MXP == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp_basic(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MXP == SLIDE || !defined(STRIP)\n\t\tTEST_CASE(\"sliding window modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp_slide(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n#if BN_MXP == CONST || !defined(STRIP)\n\t\tTEST_CASE(\"powering ladder modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, p);\n\t\t\tbn_mxp_monty(b, a, p, p);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n#endif\n\n\t\tdo {\n\t\t\tbn_gen_prime(crt->p, RLC_BN_BITS / 2);\n\t\t\tbn_gen_prime(crt->q, RLC_BN_BITS / 2);\n\t\t} while (bn_is_even(crt->p) || bn_is_even(crt->q));\n\n\t\t/* n = pq. */\n\t\tbn_mul(crt->n, crt->p, crt->q);\n\t\t/* qInv = q^(-1) mod p. */\n\t\tbn_mod_inv(crt->qi, crt->q, crt->p);\n\t\tbn_sub_dig(crt->dp, crt->p, 1);\n\t\tbn_sub_dig(crt->dq, crt->q, 1);\n\n\t\tTEST_CASE(\"chinese remainder theorem modular exponentiation is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_mod(a, a, crt->n);\n\t\t\tbn_mul(c, crt->dp, crt->dq);\n\t\t\tbn_mod(b, b, c);\n\t\t\tbn_mxp(p, a, b, crt->n);\n\t\t\tbn_mod(c, b, crt->dp);\n\t\t\tbn_mod(b, b, crt->dq);\n\t\t\tbn_mxp_crt(c, a, c, b, crt, 0);\n\t\t\tTEST_ASSERT(bn_cmp(c, p) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(p);\n\tcrt_free(crt);\n\treturn code;\n}\n\nstatic int square_root(void) {\n\tsize_t bits;\n\tbn_t a, b, c;\n\tint code = RLC_ERR;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_ONCE(\"square root extraction is correct\") {\n\t\t\tfor (bits = 0; bits < RLC_BN_BITS / 2; bits++) {\n\t\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t\t\tbn_sqr(c, a);\n\t\t\t\tbn_srt(b, c);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tfor (bits = 0; bits < RLC_BN_BITS; bits++) {\n\t\t\t\tbn_rand(a, RLC_POS, bits);\n\t\t\t\tbn_srt(b, a);\n\t\t\t\tbn_sqr(c, b);\n\t\t\t\tTEST_ASSERT(bn_cmp(c, a) != RLC_GT, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_ONCE(\"square root of powers of 2 is correct\") {\n\t\t\tfor (bits = 0; bits < RLC_BN_BITS / 2; bits++) {\n\t\t\t\tbn_set_2b(a, bits);\n\t\t\t\tbn_sqr(c, a);\n\t\t\t\tbn_srt(b, c);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int gcd(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e, f, g, h;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(f);\n\tbn_null(g);\n\tbn_null(h);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(f);\n\t\tbn_new(g);\n\t\tbn_new(h);\n\n\t\tTEST_CASE(\"greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_mod(d, a, c);\n\t\t\tbn_mod(e, b, c);\n\t\t\tTEST_ASSERT(bn_is_zero(d) && bn_is_zero(e), end);\n\t\t\tbn_div(a, a, c);\n\t\t\tbn_div(b, b, c);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_zero(b);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tTEST_ASSERT(bn_cmp_abs(c, a) == RLC_EQ, end);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tbn_zero(b);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tTEST_ASSERT(bn_cmp_abs(c, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tbn_gcd(f, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t} TEST_END;\n\n#if BN_GCD == BASIC || !defined(STRIP)\n\t\tTEST_CASE(\"basic greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_basic(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"basic extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_basic(f, a, b);\n\t\t\tbn_gcd_ext_basic(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_gcd_ext_basic(f, g, h, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, f) == RLC_EQ && bn_cmp(d, g) == RLC_EQ\n\t\t\t\t&& bn_cmp(e, h) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GCD == BINAR || !defined(STRIP)\n\t\tTEST_CASE(\"binary greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_binar(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"binary extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_binar(f, a, b);\n\t\t\tbn_gcd_ext_binar(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_gcd_ext_binar(f, g, h, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, f) == RLC_EQ && bn_cmp(d, g) == RLC_EQ\n\t\t\t\t&& bn_cmp(e, h) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GCD == LEHME || !defined(STRIP)\n\t\tTEST_CASE(\"lehmer greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_lehme(d, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"lehmer extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_lehme(f, a, b);\n\t\t\tbn_gcd_ext_lehme(c, d, e, a, b);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ && bn_cmp(c, f) == RLC_EQ, end);\n\t\t\tbn_gcd_ext(c, d, e, a, b);\n\t\t\tbn_gcd_ext_lehme(f, g, h, a, b);\n\t\t\tTEST_ASSERT(bn_cmp(c, f) == RLC_EQ && bn_cmp(d, g) == RLC_EQ\n\t\t\t\t&& bn_cmp(e, h) == RLC_EQ, end);\n\t\t} TEST_END;\n#endif\n\n\t\tTEST_CASE(\"midway extended greatest common divisor is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_gcd_ext_mid(c, d, e, f, a, b);\n\t\t\tbn_abs(d, d);\n\t\t\tbn_abs(f, f);\n\t\t\tbn_mul(c, c, f);\n\t\t\tbn_mul(e, e, d);\n\t\t\tbn_add(c, c, e);\n\t\t\tTEST_ASSERT(bn_cmp(b, c) == RLC_EQ || bn_cmp(a, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(f);\n\tbn_free(g);\n\tbn_free(h);\n\treturn code;\n}\n\nstatic int lcm(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\n\t\tTEST_CASE(\"least common multiple is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_lcm(c, a, b);\n\t\t\tbn_mod(a, c, a);\n\t\t\tbn_mod(b, c, b);\n\t\t\tTEST_ASSERT(bn_is_zero(a) && bn_is_zero(b), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\treturn code;\n}\n\nstatic int symbol(void) {\n\tint r, code = RLC_ERR;\n\tbn_t a, b, c, p, q;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(p);\n\tbn_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(p);\n\t\tbn_new(q);\n\n\t\tdo {\n\t\t\tbn_gen_prime(p, RLC_BN_BITS);\n\t\t\tbn_gen_prime(q, RLC_BN_BITS);\n\t\t} while (bn_is_even(p) || bn_is_even(q));\n\n\t\tTEST_CASE(\"legendre symbol is correct\") {\n\t\t\tTEST_ASSERT(bn_smb_leg(p, p) == 0, end);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_sqr(a, a);\n\t\t\tbn_mod(a, a, p);\n\t\t\tTEST_ASSERT(bn_smb_leg(a, p) == 1, end);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tr = bn_smb_leg(a, p);\n\t\t\tTEST_ASSERT(r == 1 || r == -1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"legendre symbol is a homomorphism\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_mul(c, a, b);\n\t\t\tr = bn_smb_leg(a, p) * bn_smb_leg(b, p);\n\t\t\tTEST_ASSERT(r == bn_smb_leg(c, p), end);\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"legendre symbol satisfies quadratic reciprocity\") {\n\t\t\t/* Check the first supplement: (-1|p) = (-1)^(p-1)/2. */\n\t\t\tbn_set_dig(a, 1);\n\t\t\tbn_neg(a, a);\n\t\t\tr = bn_smb_leg(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check second supplement: (2|p) = (-1)^(p^2-1)/8. */\n\t\t\tbn_set_dig(a, 2);\n\t\t\tr = bn_smb_leg(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sqr(c, p);\n\t\t\tbn_sub_dig(c, c, 1);\n\t\t\tbn_rsh(c, c, 3);\n\t\t\tbn_set_dig(a, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check quadratic reciprocity law. */\n\t\t\tr = bn_smb_leg(q, p);\n\t\t\tbn_set_dig(a, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tr = bn_smb_leg(p, q);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_sub_dig(c, q, 1);\n\t\t\t\tbn_rsh(c, c, 1);\n\t\t\t\tif (!bn_is_even(c)) {\n\t\t\t\t\tbn_neg(b, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_smb_leg(a, p) == bn_smb_jac(a, p), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol is a homomorphism\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(p, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(p)) {\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t}\n\t\t\tbn_mul(c, a, b);\n\t\t\tr = bn_smb_jac(a, p) * bn_smb_jac(b, p);\n\t\t\tTEST_ASSERT(r == bn_smb_jac(c, p), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol is consistent with gcd\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tbn_rand(p, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(p)) {\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t}\n\t\t\tr = bn_smb_jac(a, p);\n\t\t\tbn_set_dig(c, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(c, c);\n\t\t\t}\n\t\t\tbn_gcd(b, a, p);\n\t\t\tif (bn_cmp_dig(b, 1) != RLC_EQ) {\n\t\t\t\tTEST_ASSERT(r == 0, end);\n\t\t\t} else {\n\t\t\t\tTEST_ASSERT(r == 1 || r == -1, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jacobi symbol satisfies quadratic reciprocity\") {\n\t\t\tbn_rand(p, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(p)) {\n\t\t\t\tbn_add_dig(p, p, 1);\n\t\t\t}\n\t\t\tbn_rand(q, RLC_POS, RLC_BN_BITS / 2);\n\t\t\tif (bn_is_even(q)) {\n\t\t\t\tbn_add_dig(q, q, 1);\n\t\t\t}\n\t\t\t/* Check the first supplement: (-1|n) = (-1)^(n-1)/2. */\n\t\t\tbn_set_dig(a, 1);\n\t\t\tbn_neg(a, a);\n\t\t\tr = bn_smb_jac(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check second supplement: (2|p) = (-1)^(p^2-1)/8. */\n\t\t\tbn_set_dig(a, 2);\n\t\t\tr = bn_smb_jac(a, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sqr(c, p);\n\t\t\tbn_sub_dig(c, c, 1);\n\t\t\tbn_rsh(c, c, 3);\n\t\t\tbn_set_dig(a, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t/* Check quadratic reciprocity law. */\n\t\t\tr = bn_smb_jac(p, q);\n\t\t\tbn_set_dig(a, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(a, a);\n\t\t\t}\n\t\t\tr = bn_smb_jac(q, p);\n\t\t\tbn_set_dig(b, (r < 0 ? -r : r));\n\t\t\tif (r < 0) {\n\t\t\t\tbn_neg(b, b);\n\t\t\t}\n\t\t\tbn_sub_dig(c, p, 1);\n\t\t\tbn_rsh(c, c, 1);\n\t\t\tif (!bn_is_even(c)) {\n\t\t\t\tbn_sub_dig(c, q, 1);\n\t\t\t\tbn_rsh(c, c, 1);\n\t\t\t\tif (!bn_is_even(c)) {\n\t\t\t\t\tbn_neg(b, b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(p);\n\tbn_free(q);\n\treturn code;\n}\n\nstatic int digit(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d, e, f;\n\tdig_t g;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(f);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(f);\n\n\t\tTEST_CASE(\"addition of a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_add(c, a, b);\n\t\t\tbn_add_dig(d, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"subtraction of a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_sub(c, a, b);\n\t\t\tbn_sub_dig(d, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication by a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_mul(c, a, b);\n\t\t\tbn_mul_dig(d, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"division by a single digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tif (bn_is_zero(b)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbn_div(d, a, b);\n\t\t\tbn_div_dig(e, a, b->dp[0]);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t\tbn_div_rem(d, c, a, b);\n\t\t\tbn_div_rem_dig(e, &g, a, b->dp[0]);\n\t\t\tTEST_ASSERT(bn_cmp(d, e) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, g) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"modular reduction modulo a digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tif (b->dp[0] == 0)\n\t\t\t\tcontinue;\n\t\t\tbn_div_rem(d, c, a, b);\n\t\t\tbn_mod_dig(&g, a, b->dp[0]);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, g) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"greatest common divisor with a digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_gcd(c, a, b);\n\t\t\tbn_gcd_dig(e, a, g);\n\t\t\tTEST_ASSERT(bn_cmp(c, e) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"extended greatest common divisor with a digit is consistent\")\n\t\t{\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_gcd_ext_dig(c, d, e, a, g);\n\t\t\tbn_mul(d, d, a);\n\t\t\tbn_mul(e, e, b);\n\t\t\tbn_add(d, d, e);\n\t\t\tTEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n#if BN_MOD != PMERS\n\t\tbn_gen_prime(d, RLC_BN_BITS);\n#elif BN_PRECI >= 128\n\t\t/* Let's try a Mersenne prime. */\n\t\tbn_zero(d);\n\t\tbn_set_bit(d, 127, 1);\n\t\tbn_sub_dig(d, d, 1);\n#endif\n\n\t\tTEST_CASE(\"modular exponentiation with a digit is consistent\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_DIG);\n\t\t\tbn_get_dig(&g, b);\n\t\t\tbn_mxp(c, a, b, d);\n\t\t\tbn_mxp_dig(e, a, g, d);\n\t\t\tTEST_ASSERT(bn_cmp(c, e) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(f);\n\treturn code;\n}\n\nstatic int prime(void) {\n\tint code = RLC_ERR;\n\tbn_t p, q;\n\n\tbn_null(p);\n\tbn_null(q);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(q);\n\n\t\tTEST_ONCE(\"prime generation is consistent\") {\n\t\t\tbn_gen_prime(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n\n#if BN_GEN == BASIC || !defined(STRIP)\n\t\tTEST_ONCE(\"basic prime generation is consistent\") {\n\t\t\tbn_gen_prime_basic(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GEN == SAFEP || !defined(STRIP)\n\t\tTEST_ONCE(\"safe prime generation is consistent\") {\n\t\t\tbn_gen_prime_safep(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t\tbn_sub_dig(p, p, 1);\n\t\t\tbn_hlv(p, p);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n#endif\n\n#if BN_GEN == STRON || !defined(STRIP)\n\t\tTEST_ONCE(\"strong prime generation is consistent\") {\n\t\t\tbn_gen_prime_stron(p, RLC_BN_BITS);\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n#endif\n\t\tbn_gen_prime(p, RLC_BN_BITS);\n\n\t\tTEST_ONCE(\"basic prime testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime_basic(p) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"miller-rabin prime testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime_rabin(p) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"solovay-strassen prime testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime_solov(p) == 1, end);\n\t\t} TEST_END;\n\n\t\tbn_gen_prime_factor(q, p, RLC_BN_BITS>>1, RLC_BN_BITS);\n\t\tTEST_ONCE(\"prime with large (p-1) prime factor testing is correct\") {\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t\tTEST_ASSERT(bn_is_prime(q) == 1, end);\n\t\t\tbn_sub_dig(p, p, 1); \t// (p-1)\n\t\t\tbn_div(p, p, q);\t\t// (p-1)/q\n\t\t\tbn_mul(p, p, q);\t\t// ((p-1)/q)*q\n\t\t\tbn_add_dig(p, p, 1);\t// ((p-1)/q)*q+1\n\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(p);\n\tbn_free(q);\n\treturn code;\n}\n\nstatic int small_primes(void) {\n\tint code = RLC_ERR;\n\n\tint i;\n\tconst int nr_tests = 50;\n\n\tdig_t primes[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\n\t\t\t47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,\n\t\t\t107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163,\n\t\t\t167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\n\t\t\t229};\n\n\tdig_t non_primes[] = {1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22,\n\t\t\t24, 25, 26, 27, 28, 30, 32, 33, 34, 35, 36, 38, 39, 40,\n\t\t\t42, 44, 45, 46, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58,\n\t\t\t60, 62, 63, 64, 65, 66, 68, 69};\n\n\tbn_t p;\n\tbn_null(p);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\n\t\tTEST_ONCE(\"prime testing of small primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime(p) == 1, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"miller-rabin testing of small primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime_rabin(p) == 1, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"prime testing of small non-primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, non_primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime(p) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_ONCE(\"miller-rabin testing of small non-primes is correct\") {\n\t\t\tfor(i = 0; i < nr_tests; i++) {\n\t\t\t\tbn_set_dig(p, non_primes[i]);\n\t\t\t\tTEST_ASSERT(bn_is_prime_rabin(p) == 0, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(p);\n\treturn code;\n}\n\nstatic int inversion(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, d[2];\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tbn_null(d[0]);\n\tbn_null(d[1]);\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tbn_new(d[0]);\n\t\tbn_new(d[1]);\n\n\t\tbn_gen_prime(a, RLC_BN_BITS);\n\n\t\tTEST_CASE(\"modular inversion is correct\") {\n\t\t\tbn_rand_mod(b, a);\n\t\t\tbn_mod_inv(c, b, a);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) != RLC_EQ, end);\n\t\t\tbn_mul(c, b, c);\n\t\t\tbn_mod(c, c, a);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t\tbn_rand_mod(b, a);\n\t\t\tbn_rand_mod(c, a);\n\t\t\tbn_copy(d[0], b);\n\t\t\tbn_copy(d[1], c);\n\t\t\tbn_mod_inv_sim(d, d, a, 2);\n\t\t\tbn_mul(b, b, d[0]);\n\t\t\tbn_mod(b, b, a);\n\t\t\tbn_mul(c, c, d[1]);\n\t\t\tbn_mod(c, c, a);\n\t\t\tTEST_ASSERT(bn_cmp_dig(b, 1) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(bn_cmp_dig(c, 1) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tbn_free(d[0]);\n\tbn_free(d[1]);\n\treturn code;\n}\n\nstatic int factor(void) {\n\tint code = RLC_ERR;\n\tbn_t p, q, n;\n\n\tbn_null(p);\n\tbn_null(q);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tbn_new(p);\n\t\tbn_new(q);\n\t\tbn_new(n);\n\n\t\tTEST_ONCE(\"integer factorization is consistent\") {\n\t\t\tbn_gen_prime(p, 16);\n\t\t\tbn_rand(n, RLC_POS, RLC_BN_BITS - 16);\n\t\t\tbn_mul(n, n, p);\n\t\t\tif (bn_factor(q, n) == 1) {\n\t\t\t\tTEST_ASSERT(bn_is_factor(q, n) == 1, end);\n\t\t\t} else {\n\t\t\t\tTEST_ASSERT(bn_is_factor(p, n) == 1, end);\n\t\t\t}\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(p);\n\tbn_free(q);\n\tbn_free(n);\n\treturn code;\n}\n\nstatic int recoding(void) {\n\tint code = RLC_ERR;\n\tbn_t a, b, c, v1[3], v2[3];\n\tint w, k;\n\tuint8_t d[RLC_BN_BITS + 1];\n\tint8_t e[2 * (RLC_BN_BITS + 1)];\n\tsize_t l;\n\n\tbn_null(a);\n\tbn_null(b);\n\tbn_null(c);\n\tfor (k = 0; k < 3; k++) {\n\t\tbn_null(v1[k]);\n\t\tbn_null(v2[k]);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(a);\n\t\tbn_new(b);\n\t\tbn_new(c);\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tbn_new(v1[k]);\n\t\t\tbn_new(v2[k]);\n\t\t}\n\n\t\tTEST_CASE(\"window recoding is correct\") {\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_win(d, &l, a, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\tbn_lsh(b, b, w);\n\t\t\t\t\tbn_add_dig(b, b, d[k]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"sliding window recoding is correct\") {\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_slw(d, &l, a, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = 0; k < l; k++) {\n\t\t\t\t\tif (d[k] == 0) {\n\t\t\t\t\t\tbn_dbl(b, b);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_lsh(b, b, util_bits_dig(d[k]));\n\t\t\t\t\t\tbn_add_dig(b, b, d[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"naf recoding is correct\") {\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_naf(e, &l, a, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\tbn_dbl(b, b);\n\t\t\t\t\tif (e[k] >= 0) {\n\t\t\t\t\t\tbn_add_dig(b, b, e[k]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(b, b, -e[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n#if defined(WITH_EB) && defined(EB_KBLTZ) && (EB_MUL == LWNAF || EB_MUL == RWNAF || EB_FIX == LWNAF || EB_SIM == INTER || !defined(STRIP))\n\t\tif (eb_param_set_any_kbltz() == RLC_OK) {\n\t\t\teb_curve_get_ord(v1[2]);\n\t\t\tTEST_CASE(\"tnaf recoding is correct\") {\n\t\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\t\tuint8_t t_w;\n\t\t\t\t\tint8_t beta[64], gama[64];\n\t\t\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\t\t\tint8_t u = (eb_curve_opt_a() == RLC_ZERO ? -1 : 1);\n\t\t\t\t\tbn_rand_mod(a, v1[2]);\n\t\t\t\t\tl = RLC_FB_BITS + 1;\n\t\t\t\t\tbn_rec_tnaf_mod(v1[0], v1[1], a, u, RLC_FB_BITS);\n\t\t\t\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\t\t\t\tbn_rec_tnaf(tnaf, &l, a, u, RLC_FB_BITS, w);\n\t\t\t\t\tbn_zero(a);\n\t\t\t\t\tbn_zero(b);\n\t\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\t\tbn_copy(c, b);\n\t\t\t\t\t\tif (u == -1) {\n\t\t\t\t\t\t\tbn_neg(c, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbn_add(c, c, a);\n\t\t\t\t\t\tbn_dbl(a, b);\n\t\t\t\t\t\tbn_neg(a, a);\n\t\t\t\t\t\tbn_copy(b, c);\n\t\t\t\t\t\tif (w == 2) {\n\t\t\t\t\t\t\tif (tnaf[k] >= 0) {\n\t\t\t\t\t\t\t\tbn_add_dig(a, a, tnaf[k]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -tnaf[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tnaf[k] > 0) {\n\t\t\t\t\t\t\t\tif (beta[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, -gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tnaf[k] < 0) {\n\t\t\t\t\t\t\t\tif (beta[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, -beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, -gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTEST_ASSERT(bn_cmp(a, v1[0]) == RLC_EQ, end);\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, v1[1]) == RLC_EQ, end);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_END;\n\n\t\t\tTEST_CASE(\"regular tnaf recoding is correct\") {\n\t\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\t\tuint8_t t_w;\n\t\t\t\t\tint8_t beta[64], gama[64];\n\t\t\t\t\tint8_t tnaf[RLC_FB_BITS + 8];\n\t\t\t\t\tint8_t u = (eb_curve_opt_a() == RLC_ZERO ? -1 : 1);\n\t\t\t\t\tint n;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tbn_rand_mod(a, v1[2]);\n\t\t\t\t\t\tl = RLC_FB_BITS + 1;\n\t\t\t\t\t\tbn_rec_tnaf_mod(v1[0], v1[1], a, u, RLC_FB_BITS);\n\t\t\t\t\t} while (bn_is_even(v1[0]) || bn_is_even(v1[1]));\n\t\t\t\t\tbn_rec_tnaf_get(&t_w, beta, gama, u, w);\n\t\t\t\t\tbn_rec_rtnaf(tnaf, &l, a, u, RLC_FB_BITS, w);\n\t\t\t\t\tbn_zero(a);\n\t\t\t\t\tbn_zero(b);\n\t\t\t\t\tn = 0;\n\t\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\t\tfor (int m = 0; m < w - 1; m++) {\n\t\t\t\t\t\t\tbn_copy(c, b);\n\t\t\t\t\t\t\tif (u == -1) {\n\t\t\t\t\t\t\t\tbn_neg(c, c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbn_add(c, c, a);\n\t\t\t\t\t\t\tbn_dbl(a, b);\n\t\t\t\t\t\t\tbn_neg(a, a);\n\t\t\t\t\t\t\tbn_copy(b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (tnaf[k] != 0) {\n\t\t\t\t\t\t\tn++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (w == 2) {\n\t\t\t\t\t\t\tif (tnaf[k] >= 0) {\n\t\t\t\t\t\t\t\tbn_add_dig(a, a, tnaf[k]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -tnaf[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (tnaf[k] > 0) {\n\t\t\t\t\t\t\t\tif (beta[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, -beta[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, -gama[tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (tnaf[k] < 0) {\n\t\t\t\t\t\t\t\tif (beta[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(a, a, beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(a, a, -beta[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (gama[-tnaf[k] / 2] >= 0) {\n\t\t\t\t\t\t\t\t\tbn_sub_dig(b, b, gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tbn_add_dig(b, b, -gama[-tnaf[k] / 2]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tTEST_ASSERT(bn_cmp(a, v1[0]) == RLC_EQ, end);\n\t\t\t\t\tTEST_ASSERT(bn_cmp(b, v1[1]) == RLC_EQ, end);\n\t\t\t\t}\n\t\t\t} TEST_END;\n\t\t}\n#endif\n\n\t\tTEST_CASE(\"regular recoding is correct\") {\n\t\t\t/* Recode same scalar with different widths. */\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tif (bn_is_even(a)) {\n\t\t\t\tbn_add_dig(a, a, 1);\n\t\t\t}\n\t\t\tfor (w = 2; w <= 8; w++) {\n\t\t\t\tl = RLC_BN_BITS + 1;\n\t\t\t\tbn_rec_reg(e, &l, a, RLC_BN_BITS, w);\n\t\t\t\tbn_zero(b);\n\t\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\t\tbn_lsh(b, b, w - 1);\n\t\t\t\t\tif (e[k] > 0) {\n\t\t\t\t\t\tbn_add_dig(b, b, e[k]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbn_sub_dig(b, b, -e[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"jsf recoding is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tbn_rand(b, RLC_POS, RLC_BN_BITS);\n\t\t\tl = 2 * (RLC_BN_BITS + 1);\n\t\t\tbn_rec_jsf(e, &l, a, b);\n\t\t\tw = RLC_MAX(bn_bits(a), bn_bits(b)) + 1;\n\t\t\tbn_add(a, a, b);\n\t\t\tbn_zero(b);\n\t\t\tfor (k = l - 1; k >= 0; k--) {\n\t\t\t\tbn_dbl(b, b);\n\t\t\t\tif (e[k] >= 0) {\n\t\t\t\t\tbn_add_dig(b, b, e[k]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(b, b, -e[k]);\n\t\t\t\t}\n\t\t\t\tif (e[k + w] >= 0) {\n\t\t\t\t\tbn_add_dig(b, b, e[k + w]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_sub_dig(b, b, -e[k + w]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n#if defined(WITH_EP) && defined(EP_ENDOM) && (EP_MUL == LWNAF || EP_FIX == COMBS || EP_FIX == LWNAF || EP_SIM == INTER || !defined(STRIP))\n\t\tTEST_CASE(\"glv recoding is correct\") {\n\t\t\tif (ep_param_set_any_endom() == RLC_OK) {\n\t\t\t\tep_curve_get_v1(v1);\n\t\t\t\tep_curve_get_v2(v2);\n\t\t\t\tep_curve_get_ord(b);\n\t\t\t\tbn_rand_mod(a, b);\n\t\t\t\tbn_rec_glv(b, c, a, b, (const bn_t *)v1, (const bn_t *)v2);\n\t\t\t\tep_curve_get_ord(v2[0]);\n\t\t\t\t/* Check that subscalars have the right length. */\n\t\t\t\tTEST_ASSERT(bn_bits(b) <= 1 + (bn_bits(v2[0]) >> 1), end);\n\t\t\t\tTEST_ASSERT(bn_bits(c) <= 1 + (bn_bits(v2[0]) >> 1), end);\n\t\t\t\t/* Recover lambda parameter. */\n\t\t\t\tif (bn_cmp_dig(v1[2], 1) == RLC_EQ) {\n\t\t\t\t\tbn_gcd_ext(v1[0], v2[1], NULL, v1[1], v2[0]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_gcd_ext(v1[0], v2[1], NULL, v1[2], v2[0]);\n\t\t\t\t}\n\t\t\t\tif (bn_sign(v2[1]) == RLC_NEG) {\n\t\t\t\t\t/* Negate modulo r. */\n\t\t\t\t\tbn_add(v2[1], v2[0], v2[1]);\n\t\t\t\t}\n\t\t\t\tif (bn_cmp_dig(v1[2], 1) == RLC_EQ) {\n\t\t\t\t\tbn_sub(v1[0], v2[1], v1[2]);\n\t\t\t\t} else {\n\t\t\t\t\tbn_mul(v1[0], v2[1], v1[1]);\n\t\t\t\t}\n\t\t\t\tbn_mod(v1[0], v1[0], v2[0]);\n\t\t\t\tbn_sub(v1[1], v2[0], v1[0]);\n\t\t\t\tif (bn_cmp(v1[1], v1[0]) == RLC_LT) {\n\t\t\t\t\tbn_copy(v1[0], v1[1]);\n\t\t\t\t}\n\t\t\t\t/* Check if b + c * lambda = k (mod n). */\n\t\t\t\tbn_mul(c, c, v1[0]);\n\t\t\t\tbn_add(b, b, c);\n\t\t\t\tbn_mod(b, b, v2[0]);\n\t\t\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\t\t\tbn_add(b, b, v2[0]);\n\t\t\t\t}\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t} TEST_END;\n#endif /* WITH_EP && EP_ENDOM */\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(a);\n\tbn_free(b);\n\tbn_free(c);\n\tfor (k = 0; k < 3; k++) {\n\t\tbn_free(v1[k]);\n\t\tbn_free(v2[k]);\n\t}\n\treturn code;\n}\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the BN module\", 0);\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (addition() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (subtraction() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (multiplication() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (squaring() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (doubling_halving() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (shifting() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (division() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (reduction() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (square_root() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (gcd() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (lcm() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (symbol() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (digit() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (recoding() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (exponentiation() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (prime() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (small_primes() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (inversion() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (factor() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2012 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for configuration management.\n *\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\n#if defined(MULTI)\n#if MULTI == PTHREAD\n\nvoid *master(void *ptr) {\n\tint *code = (int *)ptr;\n\tcore_init();\n\tRLC_THROW(ERR_NO_MEMORY);\n\tif (err_get_code() != RLC_ERR) {\n\t\t*code = RLC_ERR;\n\t} else {\n\t\t*code = RLC_OK;\n\t}\n\tcore_clean();\n\treturn NULL;\n}\n\nvoid *tester(void *ptr) {\n\tint *code = (int *)ptr;\n\tcore_init();\n\tif (err_get_code() != RLC_OK) {\n\t\t*code = RLC_ERR;\n\t} else {\n\t\t*code = RLC_OK;\n\t}\n\tcore_clean();\n\treturn NULL;\n}\n\n#endif\n#endif\n\nint main(void) {\n\tint code = RLC_ERR;\n\n\t/* Initialize library with default configuration. */\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the CORE module:\\n\", 0);\n\n\tTEST_ONCE(\"the library context is consistent\") {\n\t\tTEST_ASSERT(core_get() != NULL, end);\n\t} TEST_END;\n\n\tTEST_ONCE(\"switching the library context is correct\") {\n\t\tctx_t new_ctx, *old_ctx;\n\t\t/* Backup the old context. */\n\t\told_ctx = core_get();\n\t\t/* Switch the library context. */\n\t\tcore_set(&new_ctx);\n\t\t/* Reinitialize library with new context. */\n\t\tcore_init();\n\t\t/* Run function to manipulate the library context. */\n\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\tcore_set(old_ctx);\n\t\tTEST_ASSERT(err_get_code() == RLC_OK, end);\n\t\tcore_set(&new_ctx);\n\t\tTEST_ASSERT(err_get_code() == RLC_ERR, end);\n\t\t/* Now we need to finalize the new context. */\n\t\tcore_clean();\n\t\t/* And restore the original context. */\n\t\tcore_set(old_ctx);\n\t} TEST_END;\n\n\tcode = RLC_OK;\n\n#if defined(MULTI)\n#if MULTI == OPENMP\n\tTEST_ONCE(\"library context is thread-safe\") {\n\t\tomp_set_num_threads(CORES);\n#pragma omp parallel shared(code)\n\t\t{\n\t\t\tif (omp_get_thread_num() == 0) {\n\t\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t\t\tif (err_get_code() != RLC_ERR) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcore_init();\n\t\t\t\tif (err_get_code() != RLC_OK) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t\tcore_clean();\n\t\t\t}\n\t\t}\n\t\tTEST_ASSERT(code == RLC_OK, end);\n\n\t\tcore_clean();\n\t\tcore_init();\n#pragma omp parallel copyin(core_ctx) shared(code)\n\t\t{\n\t\t\tif (core_get() == NULL) {\n\t\t\t\tcode = RLC_ERR;\n\t\t\t}\n\t\t}\n\t\tTEST_ASSERT(code == RLC_OK, end);\n\t\tcore_clean();\n\t} TEST_END;\n#endif\n\n#if MULTI == PTHREAD\n\tTEST_ONCE(\"library context is thread-safe\") {\n\t\tpthread_t thread[CORES];\n\t\tint result[CORES] = { RLC_OK };\n\t\tfor (int i = 0; i < CORES; i++) {\n\t\t\tif (i == 0) {\n\t\t\t\tif (pthread_create(&(thread[0]), NULL, master, &(result[0]))) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pthread_create(&(thread[i]), NULL, tester, &(result[i]))) {\n\t\t\t\t\tcode = RLC_ERR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (result[i] != RLC_OK) {\n\t\t\t\tcode = RLC_ERR;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < CORES; i++) {\n\t\t\tif (pthread_join(thread[i], NULL)) {\n\t\t\t\tcode = RLC_ERR;\n\t\t\t}\n\t\t}\n\t\tTEST_ASSERT(code == RLC_OK, end);\n\t} TEST_END;\n#endif\n#endif\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n  end:\n\tcore_clean();\n\treturn code;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2010 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for the Pairing-Based Cryptography module.\n *\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\nstatic int memory1(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tg1_t a;\n\n\tg1_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tg1_new(a);\n\t\t\tg1_free(a);\n\t\t} TEST_END;\n\t} RLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t(void)a;\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nint util1(void) {\n\tint l, code = RLC_ERR;\n\tg1_t a, b, c;\n\tuint8_t bin[2 * RLC_PC_BYTES + 1];\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tTEST_ASSERT(g1_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_rand(c);\n\t\t\t/* Compare points in affine coordinates. */\n\t\t\tif (g1_cmp(a, c) != RLC_EQ) {\n\t\t\t\tg1_copy(c, a);\n\t\t\t\tTEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (g1_cmp(b, c) != RLC_EQ) {\n\t\t\t\tg1_copy(c, b);\n\t\t\t\tTEST_ASSERT(g1_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t\t/* Compare with one point in projective. */\n\t\t\tg1_dbl(c, a);\n\t\t\tg1_norm(c, c);\n\t\t\tg1_dbl(a, a);\n\t\t\tTEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g1_cmp(a, c) == RLC_EQ, end);\n\t\t\t/* Compare with two points in projective. */\n\t\t\tg1_dbl(c, c);\n\t\t\tg1_dbl(a, a);\n\t\t\tTEST_ASSERT(g1_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g1_cmp(a, c) == RLC_EQ, end);\n\t\t\tg1_neg(b, a);\n\t\t\tg1_add(a, a, b);\n\t\t\tg1_set_infty(b);\n\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"inversion and comparison are consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_neg(b, a);\n\t\t\tTEST_ASSERT(g1_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"assignment to random/infinity and comparison are consistent\")\n\t\t{\n\t\t\tg1_rand(a);\n\t\t\tg1_set_infty(c);\n\t\t\tTEST_ASSERT(g1_cmp(a, c) != RLC_EQ, end);\n\t\t\tTEST_ASSERT(g1_cmp(c, a) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"assignment to infinity and infinity test are consistent\") {\n\t\t\tg1_set_infty(a);\n\t\t\tTEST_ASSERT(g1_is_infty(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a point are consistent\") {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tg1_set_infty(a);\n\t\t\t\tl = g1_size_bin(a, j);\n\t\t\t\tg1_write_bin(bin, l, a, j);\n\t\t\t\tg1_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg1_rand(a);\n\t\t\t\tl = g1_size_bin(a, j);\n\t\t\t\tg1_write_bin(bin, l, a, j);\n\t\t\t\tg1_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg1_rand(a);\n\t\t\t\tg1_dbl(a, a);\n\t\t\t\tl = g1_size_bin(a, j);\n\t\t\t\tg1_norm(a, a);\n\t\t\t\tg1_write_bin(bin, l, a, j);\n\t\t\t\tg1_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g1_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\treturn code;\n}\n\nint addition1(void) {\n\tint code = RLC_ERR;\n\n\tg1_t a, b, c, d, e;\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\tg1_null(d);\n\tg1_null(e);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\t\tg1_new(d);\n\t\tg1_new(e);\n\n\t\tTEST_CASE(\"point addition is commutative\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_add(d, a, b);\n\t\t\tg1_add(e, b, a);\n\t\t\tTEST_ASSERT(g1_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition is associative\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_rand(c);\n\t\t\tg1_add(d, a, b);\n\t\t\tg1_add(d, d, c);\n\t\t\tg1_add(e, b, c);\n\t\t\tg1_add(e, e, a);\n\t\t\tTEST_ASSERT(g1_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has identity\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_set_infty(d);\n\t\t\tg1_add(e, a, d);\n\t\t\tTEST_ASSERT(g1_cmp(e, a) == RLC_EQ, end);\n\t\t\tg1_add(e, d, a);\n\t\t\tTEST_ASSERT(g1_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has inverse\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_neg(d, a);\n\t\t\tg1_add(e, a, d);\n\t\t\tTEST_ASSERT(g1_is_infty(e), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\tg1_free(d);\n\tg1_free(e);\n\treturn code;\n}\n\nint subtraction1(void) {\n\tint code = RLC_ERR;\n\tg1_t a, b, c, d;\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\tg1_null(d);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\t\tg1_new(d);\n\n\t\tTEST_CASE(\"point subtraction is anti-commutative\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_rand(b);\n\t\t\tg1_sub(c, a, b);\n\t\t\tg1_sub(d, b, a);\n\t\t\tg1_neg(d, d);\n\t\t\tTEST_ASSERT(g1_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has identity\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_set_infty(c);\n\t\t\tg1_sub(d, a, c);\n\t\t\tTEST_ASSERT(g1_cmp(d, a) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has inverse\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_sub(c, a, a);\n\t\t\tTEST_ASSERT(g1_is_infty(c), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\tg1_free(d);\n\treturn code;\n}\n\nint doubling1(void) {\n\tint code = RLC_ERR;\n\tg1_t a, b, c;\n\n\tg1_null(a);\n\tg1_null(b);\n\tg1_null(c);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tg1_new(b);\n\t\tg1_new(c);\n\n\t\tTEST_CASE(\"point doubling is correct\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_add(b, a, a);\n\t\t\tg1_dbl(c, a);\n\t\t\tTEST_ASSERT(g1_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tg1_free(b);\n\tg1_free(c);\n\treturn code;\n}\n\nstatic int multiplication1(void) {\n\tint code = RLC_ERR;\n\tg1_t p, q, r;\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg1_null(p);\n\tg1_null(q);\n\tg1_null(r);\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg1_new(q);\n\t\tg1_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg1_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"generator has the right order\") {\n\t\t\tg1_mul(r, p, n);\n\t\t\tTEST_ASSERT(g1_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"generator multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g1_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g1_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_gen(r, k);\n\t\t\tg1_neg(r, r);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"random element has the right order\") {\n\t\t\tg1_rand(p);\n\t\t\tg1_mul(r, p, n);\n\t\t\tTEST_ASSERT(g1_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point multiplication by digit is correct\") {\n\t\t\tg1_mul_dig(r, p, 0);\n\t\t\tTEST_ASSERT(g1_is_infty(r), end);\n\t\t\tg1_mul_dig(r, p, 1);\n\t\t\tTEST_ASSERT(g1_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_dig(r, p, k->dp[0]);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(p);\n\tg1_free(q);\n\tg1_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int fixed1(void) {\n\tint code = RLC_ERR;\n\tg1_t p, q, r;\n\tg1_t t[RLC_G1_TABLE];\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg1_null(p);\n\tg1_null(q);\n\tg1_null(r);\n\n\tfor (int i = 0; i < RLC_G1_TABLE; i++) {\n\t\tg1_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tg1_new(p);\n\t\tg1_new(q);\n\t\tg1_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg1_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tfor (int i = 0; i < RLC_G1_TABLE; i++) {\n\t\t\tg1_new(t[i]);\n\t\t}\n\t\tTEST_CASE(\"fixed point multiplication is correct\") {\n\t\t\tg1_rand(p);\n\t\t\tg1_mul_pre(t, p);\n\t\t\tbn_zero(k);\n\t\t\tg1_mul_fix(r, (const g1_t *)t, k);\n\t\t\tTEST_ASSERT(g1_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg1_mul_fix(r, (const g1_t *)t, k);\n\t\t\tTEST_ASSERT(g1_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_fix(q, (const g1_t *)t, k);\n\t\t\tg1_mul(r, p, k);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_fix(r, (const g1_t *)t, k);\n\t\t\tg1_neg(r, r);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t\tfor (int i = 0; i < RLC_G1_TABLE; i++) {\n\t\t\tg1_free(t[i]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(p);\n\tg1_free(q);\n\tg1_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int simultaneous1(void) {\n\tint code = RLC_ERR;\n\tg1_t p, q, r;\n\tbn_t n, k, l;\n\n\tbn_null(n);\n\tbn_null(k);\n\tbn_null(l);\n\tg1_null(p);\n\tg1_null(q);\n\tg1_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(k);\n\t\tbn_new(l);\n\t\tg1_new(p);\n\t\tg1_new(q);\n\t\tg1_new(r);\n\n\t\tg1_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"simultaneous point multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul(q, p, l);\n\t\t\tg1_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg1_mul(q, p, k);\n\t\t\tg1_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul_sim(r, p, k, q, l);\n\t\t\tg1_mul(p, p, k);\n\t\t\tg1_mul(q, q, l);\n\t\t\tg1_add(q, q, p);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_sim(r, p, k, q, l);\n\t\t\tg1_mul(p, p, k);\n\t\t\tg1_mul(q, q, l);\n\t\t\tg1_add(q, q, p);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg1_mul_sim(r, p, k, q, l);\n\t\t\tg1_mul(p, p, k);\n\t\t\tg1_mul(q, q, l);\n\t\t\tg1_add(q, q, p);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"simultaneous multiplication with generator is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul(q, p, l);\n\t\t\tg1_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg1_mul_gen(q, k);\n\t\t\tg1_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg1_mul_sim_gen(r, k, q, l);\n\t\t\tg1_get_gen(p);\n\t\t\tg1_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg1_mul_sim_gen(r, k, q, l);\n\t\t\tg1_get_gen(p);\n\t\t\tg1_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg1_mul_sim_gen(r, k, q, l);\n\t\t\tg1_get_gen(p);\n\t\t\tg1_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g1_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(n);\n\tbn_free(k);\n\tbn_free(l);\n\tg1_free(p);\n\tg1_free(q);\n\tg1_free(r);\n\treturn code;\n}\n\nstatic int validity1(void) {\n\tint code = RLC_ERR;\n\tg1_t a;\n\n\tg1_null(a);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\n\t\tTEST_CASE(\"validity test is correct\") {\n\t\t\tg1_set_infty(a);\n\t\t\tTEST_ASSERT(!g1_is_valid(a), end);\n\t\t\tg1_rand(a);\n\t\t\tTEST_ASSERT(g1_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"blinding is consistent\") {\n\t\t\tg1_rand(a);\n\t\t\tg1_blind(a, a);\n\t\t\tTEST_ASSERT(g1_is_valid(a), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\treturn code;\n}\n\nstatic int hashing1(void) {\n\tint code = RLC_ERR;\n\tg1_t a;\n\tbn_t n;\n\tuint8_t msg[5];\n\n\tg1_null(a);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg1_new(a);\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"point hashing is correct\") {\n\t\t\trand_bytes(msg, sizeof(msg));\n\t\t\tg1_map(a, msg, sizeof(msg));\n\t\t\tTEST_ASSERT(g1_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg1_free(a);\n\tbn_free(n);\n\treturn code;\n}\n\nstatic int memory2(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tg2_t a;\n\n\tg2_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tg2_new(a);\n\t\t\tg2_free(a);\n\t\t} TEST_END;\n\t} RLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t(void)a;\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nint util2(void) {\n\tint l, code = RLC_ERR;\n\tg2_t a, b, c;\n\tuint8_t bin[8 * RLC_PC_BYTES + 1];\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tTEST_ASSERT(g2_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_rand(c);\n\t\t\t/* Compare points in affine coordinates. */\n\t\t\tif (g2_cmp(a, c) != RLC_EQ) {\n\t\t\t\tg2_copy(c, a);\n\t\t\t\tTEST_ASSERT(g2_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (g2_cmp(b, c) != RLC_EQ) {\n\t\t\t\tg2_copy(c, b);\n\t\t\t\tTEST_ASSERT(g2_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t\t/* Compare with one point in projective. */\n\t\t\tg2_dbl(c, a);\n\t\t\tg2_norm(c, c);\n\t\t\tg2_dbl(a, a);\n\t\t\tTEST_ASSERT(g2_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g2_cmp(a, c) == RLC_EQ, end);\n\t\t\t/* Compare with two points in projective. */\n\t\t\tg2_dbl(c, c);\n\t\t\tg2_dbl(a, a);\n\t\t\tTEST_ASSERT(g2_cmp(c, a) == RLC_EQ, end);\n\t\t\tTEST_ASSERT(g2_cmp(a, c) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"negation and comparison are consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_neg(b, a);\n\t\t\tTEST_ASSERT(g2_cmp(a, b) != RLC_EQ, end);\n\t\t\tg2_neg(b, a);\n\t\t\tg2_add(a, a, b);\n\t\t\tg2_set_infty(b);\n\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"assignment to random/infinity and comparison are consistent\")\n\t\t{\n\t\t\tg2_rand(a);\n\t\t\tg2_set_infty(c);\n\t\t\tTEST_ASSERT(g2_cmp(a, c) != RLC_EQ, end);\n\t\t\tTEST_ASSERT(g2_cmp(c, a) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"assignment to infinity and infinity test are consistent\") {\n\t\t\tg2_set_infty(a);\n\t\t\tTEST_ASSERT(g2_is_infty(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a point are consistent\") {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tg2_set_infty(a);\n\t\t\t\tl = g2_size_bin(a, j);\n\t\t\t\tg2_write_bin(bin, l, a, j);\n\t\t\t\tg2_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg2_rand(a);\n\t\t\t\tl = g2_size_bin(a, j);\n\t\t\t\tg2_write_bin(bin, l, a, j);\n\t\t\t\tg2_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t\t\tg2_rand(a);\n\t\t\t\tg2_dbl(a, a);\n\t\t\t\tl = g2_size_bin(a, j);\n\t\t\t\tg2_norm(a, a);\n\t\t\t\tg2_write_bin(bin, l, a, j);\n\t\t\t\tg2_read_bin(b, bin, l);\n\t\t\t\tTEST_ASSERT(g2_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\treturn code;\n}\n\nint addition2(void) {\n\tint code = RLC_ERR;\n\n\tg2_t a, b, c, d, e;\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\tg2_null(d);\n\tg2_null(e);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\t\tg2_new(d);\n\t\tg2_new(e);\n\n\t\tTEST_CASE(\"point addition is commutative\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_add(d, a, b);\n\t\t\tg2_add(e, b, a);\n\t\t\tTEST_ASSERT(g2_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition is associative\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_rand(c);\n\t\t\tg2_add(d, a, b);\n\t\t\tg2_add(d, d, c);\n\t\t\tg2_add(e, b, c);\n\t\t\tg2_add(e, e, a);\n\t\t\tTEST_ASSERT(g2_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has identity\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_set_infty(d);\n\t\t\tg2_add(e, a, d);\n\t\t\tTEST_ASSERT(g2_cmp(e, a) == RLC_EQ, end);\n\t\t\tg2_add(e, d, a);\n\t\t\tTEST_ASSERT(g2_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point addition has inverse\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_neg(d, a);\n\t\t\tg2_add(e, a, d);\n\t\t\tTEST_ASSERT(g2_is_infty(e), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\tg2_free(d);\n\tg2_free(e);\n\treturn code;\n}\n\nint subtraction2(void) {\n\tint code = RLC_ERR;\n\tg2_t a, b, c, d;\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\tg2_null(d);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\t\tg2_new(d);\n\n\t\tTEST_CASE(\"point subtraction is anti-commutative\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_rand(b);\n\t\t\tg2_sub(c, a, b);\n\t\t\tg2_sub(d, b, a);\n\t\t\tg2_neg(d, d);\n\t\t\tTEST_ASSERT(g2_cmp(c, d) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has identity\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_set_infty(c);\n\t\t\tg2_sub(d, a, c);\n\t\t\tTEST_ASSERT(g2_cmp(d, a) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"point subtraction has inverse\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_sub(c, a, a);\n\t\t\tTEST_ASSERT(g2_is_infty(c), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\tg2_free(d);\n\treturn code;\n}\n\nint doubling2(void) {\n\tint code = RLC_ERR;\n\tg2_t a, b, c;\n\n\tg2_null(a);\n\tg2_null(b);\n\tg2_null(c);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tg2_new(b);\n\t\tg2_new(c);\n\n\t\tTEST_CASE(\"point doubling is correct\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_add(b, a, a);\n\t\t\tg2_dbl(c, a);\n\t\t\tTEST_ASSERT(g2_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tg2_free(b);\n\tg2_free(c);\n\treturn code;\n}\n\nstatic int multiplication2(void) {\n\tint code = RLC_ERR;\n\tg2_t p, q, r;\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg2_null(p);\n\tg2_null(q);\n\tg2_null(r);\n\n\tRLC_TRY {\n\t\tg2_new(p);\n\t\tg2_new(q);\n\t\tg2_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg2_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"generator has the right order\") {\n\t\t\tg2_mul(r, p, n);\n\t\t\tTEST_ASSERT(g2_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"generator multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g2_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g2_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_gen(r, k);\n\t\t\tg2_neg(r, r);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"random element has the right order\") {\n\t\t\tg2_rand(p);\n\t\t\tg2_mul(r, p, n);\n\t\t\tTEST_ASSERT(g2_is_infty(r) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"point multiplication by digit is correct\") {\n\t\t\tg2_mul_dig(r, p, 0);\n\t\t\tTEST_ASSERT(g2_is_infty(r), end);\n\t\t\tg2_mul_dig(r, p, 1);\n\t\t\tTEST_ASSERT(g2_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand(k, RLC_POS, RLC_DIG);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_dig(r, p, k->dp[0]);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(p);\n\tg2_free(q);\n\tg2_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int fixed2(void) {\n\tint code = RLC_ERR;\n\tg2_t p, q, r;\n\tg2_t t[RLC_G2_TABLE];\n\tbn_t n, k;\n\n\tbn_null(n);\n\tbn_null(k);\n\tg2_null(p);\n\tg2_null(q);\n\tg2_null(r);\n\n\tfor (int i = 0; i < RLC_G2_TABLE; i++) {\n\t\tg2_null(t[i]);\n\t}\n\n\tRLC_TRY {\n\t\tg2_new(p);\n\t\tg2_new(q);\n\t\tg2_new(r);\n\t\tbn_new(n);\n\t\tbn_new(k);\n\n\t\tg2_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tfor (int i = 0; i < RLC_G2_TABLE; i++) {\n\t\t\tg2_new(t[i]);\n\t\t}\n\t\tTEST_CASE(\"fixed point multiplication is correct\") {\n\t\t\tg2_rand(p);\n\t\t\tg2_mul_pre(t, p);\n\t\t\tbn_zero(k);\n\t\t\tg2_mul_fix(r, t, k);\n\t\t\tTEST_ASSERT(g2_is_infty(r), end);\n\t\t\tbn_set_dig(k, 1);\n\t\t\tg2_mul_fix(r, t, k);\n\t\t\tTEST_ASSERT(g2_cmp(p, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_fix(q, t, k);\n\t\t\tg2_mul(r, p, k);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_fix(r, t, k);\n\t\t\tg2_neg(r, r);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t\tfor (int i = 0; i < RLC_G2_TABLE; i++) {\n\t\t\tg2_free(t[i]);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(p);\n\tg2_free(q);\n\tg2_free(r);\n\tbn_free(n);\n\tbn_free(k);\n\treturn code;\n}\n\nstatic int simultaneous2(void) {\n\tint code = RLC_ERR;\n\tg2_t p, q, r;\n\tbn_t n, k, l;\n\n\tbn_null(n);\n\tbn_null(k);\n\tbn_null(l);\n\tg2_null(p);\n\tg2_null(q);\n\tg2_null(r);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(k);\n\t\tbn_new(l);\n\t\tg2_new(p);\n\t\tg2_new(q);\n\t\tg2_new(r);\n\n\t\tg2_get_gen(p);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"simultaneous point multiplication is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul(q, p, l);\n\t\t\tg2_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg2_mul(q, p, k);\n\t\t\tg2_mul_sim(r, p, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul_sim(r, p, k, q, l);\n\t\t\tg2_mul(p, p, k);\n\t\t\tg2_mul(q, q, l);\n\t\t\tg2_add(q, q, p);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_sim(r, p, k, q, l);\n\t\t\tg2_mul(p, p, k);\n\t\t\tg2_mul(q, q, l);\n\t\t\tg2_add(q, q, p);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg2_mul_sim(r, p, k, q, l);\n\t\t\tg2_mul(p, p, k);\n\t\t\tg2_mul(q, q, l);\n\t\t\tg2_add(q, q, p);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"simultaneous multiplication with generator is correct\") {\n\t\t\tbn_zero(k);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul(q, p, l);\n\t\t\tg2_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_zero(l);\n\t\t\tg2_mul_gen(q, k);\n\t\t\tg2_mul_sim_gen(r, k, p, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tbn_rand_mod(l, n);\n\t\t\tg2_mul_sim_gen(r, k, q, l);\n\t\t\tg2_get_gen(p);\n\t\t\tg2_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(k, k);\n\t\t\tg2_mul_sim_gen(r, k, q, l);\n\t\t\tg2_get_gen(p);\n\t\t\tg2_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t\tbn_neg(l, l);\n\t\t\tg2_mul_sim_gen(r, k, q, l);\n\t\t\tg2_get_gen(p);\n\t\t\tg2_mul_sim(q, p, k, q, l);\n\t\t\tTEST_ASSERT(g2_cmp(q, r) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tbn_free(n);\n\tbn_free(k);\n\tbn_free(l);\n\tg2_free(p);\n\tg2_free(q);\n\tg2_free(r);\n\treturn code;\n}\n\nstatic int validity2(void) {\n\tint code = RLC_ERR;\n\tg2_t a;\n\n\tg2_null(a);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\n\t\tTEST_CASE(\"validity test is correct\") {\n\t\t\tg2_set_infty(a);\n\t\t\tTEST_ASSERT(!g2_is_valid(a), end);\n\t\t\tg2_rand(a);\n\t\t\tTEST_ASSERT(g2_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"blinding is consistent\") {\n\t\t\tg2_rand(a);\n\t\t\tg2_blind(a, a);\n\t\t\tTEST_ASSERT(g2_is_valid(a), end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\treturn code;\n}\n\n#if FP_PRIME != 509\n\nstatic int hashing2(void) {\n\tint code = RLC_ERR;\n\tg2_t a;\n\tbn_t n;\n\tuint8_t msg[5];\n\n\tg2_null(a);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tg2_new(a);\n\t\tbn_new(n);\n\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"point hashing is correct\") {\n\t\t\trand_bytes(msg, sizeof(msg));\n\t\t\tg2_map(a, msg, sizeof(msg));\n\t\t\tTEST_ASSERT(g2_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tg2_free(a);\n\tbn_free(n);\n\treturn code;\n}\n\n#endif\n\nstatic int memory(void) {\n\terr_t e;\n\tint code = RLC_ERR;\n\tgt_t a;\n\n\tgt_null(a);\n\n\tRLC_TRY {\n\t\tTEST_CASE(\"memory can be allocated\") {\n\t\t\tgt_new(a);\n\t\t\tgt_free(a);\n\t\t} TEST_END;\n\t} RLC_CATCH(e) {\n\t\tswitch (e) {\n\t\t\tcase ERR_NO_MEMORY:\n\t\t\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\t\t\tRLC_ERROR(end);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t(void)a;\n\tcode = RLC_OK;\n  end:\n\treturn code;\n}\n\nint util(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\tuint8_t bin[24 * RLC_PC_BYTES];\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\n\t\tTEST_CASE(\"comparison is consistent\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tTEST_ASSERT(gt_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"copy and comparison are consistent\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tgt_rand(c);\n\t\t\tif (gt_cmp(a, c) != RLC_EQ) {\n\t\t\t\tgt_copy(c, a);\n\t\t\t\tTEST_ASSERT(gt_cmp(c, a) == RLC_EQ, end);\n\t\t\t}\n\t\t\tif (gt_cmp(b, c) != RLC_EQ) {\n\t\t\t\tgt_copy(c, b);\n\t\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t\t}\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"inversion and comparison are consistent\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_inv(b, a);\n\t\t\tTEST_ASSERT(gt_cmp(a, b) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE\n\t\t\t\t(\"assignment to random/infinity and comparison are consistent\")\n\t\t{\n\t\t\tgt_rand(a);\n\t\t\tgt_set_unity(c);\n\t\t\tTEST_ASSERT(gt_cmp(a, c) != RLC_EQ, end);\n\t\t\tTEST_ASSERT(gt_cmp(c, a) != RLC_EQ, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"assignment to unity and unity test are consistent\") {\n\t\t\tgt_set_unity(a);\n\t\t\tTEST_ASSERT(gt_is_unity(a), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\treturn code;\n}\n\nint multiplication(void) {\n\tint code = RLC_ERR;\n\n\tgt_t a, b, c, d, e;\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\tgt_null(d);\n\tgt_null(e);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\t\tgt_new(d);\n\t\tgt_new(e);\n\n\t\tTEST_CASE(\"multiplication is commutative\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tgt_mul(d, a, b);\n\t\t\tgt_mul(e, b, a);\n\t\t\tTEST_ASSERT(gt_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication is associative\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tgt_rand(c);\n\t\t\tgt_mul(d, a, b);\n\t\t\tgt_mul(d, d, c);\n\t\t\tgt_mul(e, b, c);\n\t\t\tgt_mul(e, e, a);\n\t\t\tTEST_ASSERT(gt_cmp(d, e) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multiplication has identity\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_set_unity(d);\n\t\t\tgt_mul(e, a, d);\n\t\t\tTEST_ASSERT(gt_cmp(e, a) == RLC_EQ, end);\n\t\t\tgt_mul(e, d, a);\n\t\t\tTEST_ASSERT(gt_cmp(e, a) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\tgt_free(d);\n\tgt_free(e);\n\treturn code;\n}\n\nint squaring(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\n\t\tTEST_CASE(\"squaring is correct\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_mul(b, a, a);\n\t\t\tgt_sqr(c, a);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\treturn code;\n}\n\nstatic int inversion(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\n\t\tTEST_CASE(\"inversion is correct\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_inv(b, a);\n\t\t\tgt_mul(c, a, b);\n\t\t\tgt_set_unity(b);\n\t\t\tTEST_ASSERT(gt_cmp(c, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\treturn code;\n}\n\nint exponentiation(void) {\n\tint code = RLC_ERR;\n\tgt_t a, b, c;\n\tbn_t n, d, e;\n\n\tgt_null(a);\n\tgt_null(b);\n\tgt_null(c);\n\tbn_null(d);\n\tbn_null(e);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\t\tgt_new(b);\n\t\tgt_new(c);\n\t\tbn_new(d);\n\t\tbn_new(e);\n\t\tbn_new(n);\n\n\t\tgt_get_gen(a);\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"generator has the right order\") {\n\t\t\tgt_exp(c, a, n);\n\t\t\tTEST_ASSERT(gt_is_unity(c), end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"generator exponentiation is correct\") {\n\t\t\tbn_zero(d);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tTEST_ASSERT(gt_is_unity(c), end);\n\t\t\tbn_set_dig(d, 1);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tTEST_ASSERT(gt_cmp(c, a) == RLC_EQ, end);\n\t\t\tbn_add_dig(d, n, 1);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tTEST_ASSERT(gt_cmp(c, a) == RLC_EQ, end);\n\t\t\tgt_exp_gen(c, n);\n\t\t\tTEST_ASSERT(gt_is_unity(c), end);\n\t\t\tbn_rand_mod(d, n);\n\t\t\tgt_exp_gen(b, d);\n\t\t\tbn_neg(d, d);\n\t\t\tgt_exp_gen(c, d);\n\t\t\tgt_inv(c, c);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"random element has the right order\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_exp(c, a, n);\n\t\t\tTEST_ASSERT(gt_is_unity(c) == 1, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"exponentiation is correct\") {\n\t\t\tgt_rand(a);\n\t\t\tgt_rand(b);\n\t\t\tbn_rand_mod(d, n);\n\t\t\tbn_rand_mod(e, n);\n\t\t\tgt_exp_sim(c, a, d, b, e);\n\t\t\tgt_exp(a, a, d);\n\t\t\tgt_exp(b, b, e);\n\t\t\tgt_mul(b, a, b);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t\tgt_exp_dig(b, a, 0);\n\t\t\tTEST_ASSERT(gt_is_unity(b), end);\n\t\t\tgt_exp_dig(b, a, 1);\n\t\t\tTEST_ASSERT(gt_cmp(a, b) == RLC_EQ, end);\n\t\t\tbn_rand(d, RLC_POS, RLC_DIG);\n\t\t\tgt_exp(b, a, d);\n\t\t\tgt_exp_dig(c, a, d->dp[0]);\n\t\t\tTEST_ASSERT(gt_cmp(b, c) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\tgt_free(b);\n\tgt_free(c);\n\tbn_free(d);\n\tbn_free(e);\n\tbn_free(n);\n\treturn code;\n}\n\nstatic int validity(void) {\n\tint code = RLC_ERR;\n\tgt_t a;\n\n\tgt_null(a);\n\n\tRLC_TRY {\n\t\tgt_new(a);\n\n\t\tTEST_CASE(\"validity check is correct\") {\n\t\t\tgt_set_unity(a);\n\t\t\tTEST_ASSERT(!gt_is_valid(a), end);\n\t\t\tgt_rand(a);\n\t\t\tTEST_ASSERT(gt_is_valid(a), end);\n\t\t}\n\t\tTEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(a);\n\treturn code;\n}\n\nstatic int pairing(void) {\n\tint j, code = RLC_ERR;\n\tg1_t p[2];\n\tg2_t q[2];\n\tgt_t e1, e2;\n\tbn_t k, n;\n\n\tgt_null(e1);\n\tgt_null(e2);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {\n\t\tgt_new(e1);\n\t\tgt_new(e2);\n\t\tbn_new(k);\n\t\tbn_new(n);\n\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tg1_null(p[j]);\n\t\t\tg2_null(q[j]);\n\t\t\tg1_new(p[j]);\n\t\t\tg2_new(q[j]);\n\t\t}\n\n\t\tpc_get_ord(n);\n\n\t\tTEST_CASE(\"pairing non-degeneracy is correct\") {\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_rand(q[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e1, 1) != RLC_EQ, end);\n\t\t\tg1_set_infty(p[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e1, 1) == RLC_EQ, end);\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_set_infty(q[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e1, 1) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"pairing is bilinear\") {\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_rand(q[0]);\n\t\t\tbn_rand_mod(k, n);\n\t\t\tg2_mul(q[1], q[0], k);\n\t\t\tpc_map(e1, p[0], q[1]);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tgt_exp(e2, e2, k);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg1_mul(p[0], p[0], k);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg1_dbl(p[0], p[0]);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tgt_sqr(e1, e1);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg2_dbl(q[0], q[0]);\n\t\t\tpc_map(e2, p[0], q[0]);\n\t\t\tgt_sqr(e1, e1);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"multi-pairing is correct\") {\n\t\t\tg1_rand(p[i % 2]);\n\t\t\tg2_rand(q[i % 2]);\n\t\t\tpc_map(e1, p[i % 2], q[i % 2]);\n\t\t\tg1_rand(p[1 - (i % 2)]);\n\t\t\tg2_set_infty(q[1 - (i % 2)]);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg1_set_infty(p[1 - (i % 2)]);\n\t\t\tg2_rand(q[1 - (i % 2)]);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t\tg2_set_infty(q[i % 2]);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp_dig(e2, 1) == RLC_EQ, end);\n\t\t\tg1_rand(p[0]);\n\t\t\tg2_rand(q[0]);\n\t\t\tpc_map(e1, p[0], q[0]);\n\t\t\tg1_rand(p[1]);\n\t\t\tg2_rand(q[1]);\n\t\t\tpc_map(e2, p[1], q[1]);\n\t\t\tgt_mul(e1, e1, e2);\n\t\t\tpc_map_sim(e2, p, q, 2);\n\t\t\tTEST_ASSERT(gt_cmp(e1, e2) == RLC_EQ, end);\n\t\t} TEST_END;\n\t}\n\tRLC_CATCH_ANY {\n\t\tutil_print(\"FATAL ERROR!\\n\");\n\t\tRLC_ERROR(end);\n\t}\n\tcode = RLC_OK;\n  end:\n\tgt_free(e1);\n\tgt_free(e2);\n\tbn_free(k);\n\tbn_free(n);\n\tfor (j = 0; j < 2; j++) {\n\t\tg1_free(p[j]);\n\t\tg2_free(q[j]);\n\t}\n\treturn code;\n}\n\nint test1(void) {\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory1() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (addition1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (subtraction1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (doubling1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (multiplication1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (fixed1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (simultaneous1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (validity1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (hashing1() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\treturn RLC_OK;\n}\n\nint test2(void) {\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory2() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (addition2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (subtraction2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (doubling2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (multiplication2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (fixed2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (simultaneous2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (validity2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n#if FP_PRIME != 509\n\tif (hashing2() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n#endif\n\n\treturn RLC_OK;\n}\n\nint test(void) {\n\tutil_banner(\"Utilities:\", 1);\n\n\tif (memory() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tif (util() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tutil_banner(\"Arithmetic:\", 1);\n\n\tif (multiplication() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (squaring() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (inversion() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (exponentiation() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (validity() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\tif (pairing() != RLC_OK) {\n\t\treturn RLC_ERR;\n\t}\n\n\treturn RLC_OK;\n}\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the PC module:\", 0);\n\n\tif (pc_param_set_any() != RLC_OK) {\n\t\tRLC_THROW(ERR_NO_CURVE);\n\t\tcore_clean();\n\t\treturn 0;\n\t}\n\n\tpc_param_print();\n\n\tutil_banner(\"Group G_1:\", 0);\n\tif (test1() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Group G_2:\", 0);\n\tif (test2() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Group G_T:\", 0);\n\tif (test() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n", "/*\n * RELIC is an Efficient LIbrary for Cryptography\n * Copyright (c) 2009 RELIC Authors\n *\n * This file is part of RELIC. RELIC is legal property of its developers,\n * whose names are not listed here. Please refer to the COPYRIGHT file\n * for contact information.\n *\n * RELIC is free software; you can redistribute it and/or modify it under the\n * terms of the version 2.1 (or later) of the GNU Lesser General Public License\n * as published by the Free Software Foundation; or version 2.0 of the Apache\n * License as published by the Apache Software Foundation. See the LICENSE files\n * for more details.\n *\n * RELIC is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the LICENSE files for more details.\n *\n * You should have received a copy of the GNU Lesser General Public or the\n * Apache License along with RELIC. If not, see <https://www.gnu.org/licenses/>\n * or <https://www.apache.org/licenses/>.\n */\n\n/**\n * @file\n *\n * Tests for random number generation.\n *\n * @ingroup test\n */\n\n#include <stdio.h>\n\n#include \"relic.h\"\n#include \"relic_test.h\"\n\n#if RAND == HASHD\n\n/*\n * Test vectors taken from:\n * - http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/Hash_DRBG.pdf\n */\n\n#if MD_MAP == SH224\n\n#define FUNCTION \"sha-224\"\n\nuint8_t seed1[62];\n\nuint8_t result1[] = {\n\t0x5E, 0x68, 0xBD, 0xE0, 0x9A, 0xAA, 0x08, 0xBC, 0x11, 0xB3,\n\t0x27, 0x90, 0x2C, 0x82, 0xF0, 0x11, 0x4C, 0xBA, 0x0F, 0x9C,\n\t0xCC, 0xA6, 0x20, 0x3B, 0xA3, 0x94, 0x00, 0x91, 0x3E, 0xCD,\n\t0x36, 0x71, 0xA5, 0xB6, 0x0E, 0xF9, 0x22, 0x99, 0x9D, 0x90,\n\t0xFC, 0xEE, 0xEC, 0x5C, 0x22, 0x7E, 0x5D, 0x25, 0xC5, 0x69,\n\t0x21, 0xEE, 0x57, 0x2E, 0xD4, 0x72, 0xDC, 0x05, 0x6F, 0xCB,\n\t0x35, 0xFF, 0x51, 0xD7, 0xD9, 0xFB, 0x72, 0xFD, 0x4F, 0xD1,\n\t0xB1, 0xD2, 0x46, 0x45, 0x1D, 0xB5, 0x6C, 0xD4, 0xF8, 0x89,\n\t0xE4, 0x32, 0xE3, 0x27, 0x3F, 0x9E, 0xD8, 0x2D, 0xE3, 0xEF,\n\t0x7C, 0xD2, 0x8B, 0x6A, 0x9C, 0x0F, 0x4D, 0x78, 0xE5, 0xC8,\n\t0x45, 0x1D, 0x36, 0x34, 0x0A, 0x2B, 0xD7, 0xE6, 0x9F, 0xAB,\n\t0x32, 0xEB\n};\n\nuint8_t result2[] = {\n\t0x3F, 0xE2, 0xAD, 0x85, 0x24, 0xCE, 0x60, 0xE7, 0xC2, 0x1C,\n\t0x38, 0xA1, 0xDA, 0xB0, 0x2F, 0x3C, 0x20, 0x50, 0x11, 0x82,\n\t0xF3, 0x89, 0xEE, 0x69, 0x9F, 0x03, 0xFD, 0x87, 0x79, 0xED,\n\t0x17, 0xC6, 0x5B, 0x87, 0xAC, 0xEE, 0xEB, 0xF1, 0xD1, 0x46,\n\t0xE7, 0xEE, 0x10, 0x6C, 0xEC, 0x89, 0x55, 0xEE, 0xAF, 0xC1,\n\t0x8A, 0xBB, 0xC5, 0x62, 0xA5, 0x66, 0x8B, 0xB4, 0x9B, 0x0B,\n\t0x9C, 0x2F, 0xC7, 0x01, 0x89, 0xB2, 0x4E, 0x02, 0x73, 0x59,\n\t0x54, 0x58, 0xCD, 0x78, 0x0F, 0xBF, 0xA5, 0xF2, 0x16, 0x12,\n\t0x24, 0x21, 0xB8, 0x0B, 0xF7, 0x73, 0xD7, 0x36, 0xE6, 0xE1,\n\t0x1D, 0xEB, 0xB4, 0x24, 0x77, 0xD6, 0x96, 0x68, 0xD2, 0xF9,\n\t0x40, 0xC6, 0x60, 0xF6, 0xA2, 0xC1, 0xC9, 0xB4, 0x17, 0x95,\n\t0x92, 0xE0\n};\n\n#elif MD_MAP == SH256\n\nuint8_t seed1[63];\n\n#define FUNCTION \"sha-256\"\n\nuint8_t result1[] = {\n\t0x77, 0xE0, 0x5A, 0x0E, 0x7D, 0xC7, 0x8A, 0xB5, 0xD8, 0x93,\n\t0x4D, 0x5E, 0x93, 0xE8, 0x2C, 0x06, 0xA0, 0x7C, 0x04, 0xCE,\n\t0xE6, 0xC9, 0xC5, 0x30, 0x45, 0xEE, 0xB4, 0x85, 0x87, 0x27,\n\t0x77, 0xCF, 0x3B, 0x3E, 0x35, 0xC4, 0x74, 0xF9, 0x76, 0xB8,\n\t0x94, 0xBF, 0x30, 0x1A, 0x86, 0xFA, 0x65, 0x1F, 0x46, 0x39,\n\t0x70, 0xE8, 0x9D, 0x4A, 0x05, 0x34, 0xB2, 0xEC, 0xAD, 0x29,\n\t0xEC, 0x04, 0x4E, 0x7E, 0x5F, 0xF4, 0xBA, 0x49, 0x3C, 0x40,\n\t0xCF, 0xFF, 0x3B, 0x01, 0xE4, 0x72, 0xC5, 0x75, 0x66, 0x8C,\n\t0xCE, 0x38, 0x80, 0xB9, 0x29, 0x0B, 0x05, 0xBF, 0xED, 0xE5,\n\t0xEC, 0x96, 0xED, 0x5E, 0x9B, 0x28, 0x98, 0x50, 0x8B, 0x09,\n\t0xBC, 0x80, 0x0E, 0xEE, 0x09, 0x9A, 0x3C, 0x90, 0x60, 0x2A,\n\t0xBD, 0x4B, 0x1D, 0x4F, 0x34, 0x3D, 0x49, 0x7C, 0x60, 0x55,\n\t0xC8, 0x7B, 0xB9, 0x56, 0xD5, 0x3B, 0xF3, 0x51\n};\n\nuint8_t result2[] = {\n\t0x92, 0x27, 0x55, 0x23, 0xC7, 0x0E, 0x56, 0x7B, 0xCF, 0x9B,\n\t0x35, 0xEC, 0x50, 0xB9, 0x33, 0xF8, 0x12, 0x61, 0x6D, 0xF5,\n\t0x86, 0xB7, 0xF7, 0x2E, 0xE1, 0xBC, 0x77, 0x35, 0xA5, 0xC2,\n\t0x65, 0x43, 0x73, 0xCB, 0xBC, 0x72, 0x31, 0x6D, 0xFF, 0x84,\n\t0x20, 0xA3, 0x3B, 0xF0, 0x2B, 0x97, 0xAC, 0x8D, 0x19, 0x52,\n\t0x58, 0x3F, 0x27, 0x0A, 0xCD, 0x70, 0x05, 0xCC, 0x02, 0x7F,\n\t0x4C, 0xF1, 0x18, 0x7E, 0x68, 0x1A, 0x46, 0xB2, 0xAA, 0x86,\n\t0x94, 0xA0, 0xFE, 0x4D, 0xEE, 0xA7, 0x20, 0x92, 0x7A, 0x84,\n\t0xEA, 0xAA, 0x98, 0x5E, 0x59, 0xC1, 0x9F, 0x8B, 0xE0, 0x98,\n\t0x4D, 0x8C, 0xBE, 0xF8, 0xC6, 0x9B, 0x75, 0x41, 0x67, 0x64,\n\t0x19, 0x46, 0xE0, 0x40, 0xEE, 0x20, 0x43, 0xE1, 0xCC, 0xB2,\n\t0x9D, 0xCF, 0x06, 0x3C, 0x0A, 0x50, 0x83, 0x0E, 0x42, 0x8E,\n\t0x6D, 0xCA, 0x26, 0x2E, 0xCD, 0x77, 0xC5, 0x42\n};\n\n#elif MD_MAP == SH384\n\n#define FUNCTION \"sha-384\"\n\nuint8_t seed1[123];\n\nuint8_t result1[] = {\n\t0x04, 0xFF, 0x23, 0xAD, 0x15, 0xE7, 0x87, 0x90, 0xAD, 0xD3,\n\t0x6B, 0x43, 0x8B, 0xBC, 0x09, 0x7C, 0x7A, 0x11, 0x74, 0x7C,\n\t0xC2, 0xCC, 0xEE, 0xDE, 0x2C, 0x97, 0x8B, 0x23, 0xB3, 0xDC,\n\t0x63, 0xB7, 0x32, 0xC9, 0x53, 0x06, 0x1D, 0x77, 0x64, 0x99,\n\t0x0A, 0xBF, 0xEF, 0xC4, 0x7A, 0x58, 0x1B, 0x92, 0x1B, 0xC0,\n\t0x42, 0x8C, 0x4F, 0x12, 0x21, 0x24, 0x60, 0xE4, 0x06, 0xA0,\n\t0xF0, 0x65, 0x1E, 0x7F, 0x0C, 0xB9, 0xA9, 0x0A, 0xBF, 0xDB,\n\t0x07, 0xB5, 0x25, 0x56, 0x5C, 0x74, 0xF0, 0xAA, 0x08, 0x50,\n\t0x82, 0xF6, 0xCF, 0x21, 0x3A, 0xAF, 0xAD, 0x0C, 0x06, 0x46,\n\t0x89, 0x50, 0x78, 0xF1, 0xE1, 0xFE, 0x4F, 0x35, 0xB8, 0x5F,\n\t0x95, 0xDE, 0xE3, 0xE8, 0x73, 0x05, 0x49, 0x05, 0xCF, 0xD0,\n\t0x23, 0x41, 0x65, 0x3E, 0x18, 0xF5, 0x29, 0x93, 0x0C, 0xBE,\n\t0x14, 0xD9, 0x09, 0xF3, 0x7F, 0xEA, 0xF2, 0xC7, 0x90, 0xD2,\n\t0x2F, 0xAE, 0x75, 0x16, 0xB4, 0x59, 0x0B, 0xE3, 0x5D, 0x53,\n\t0xE2, 0xFE, 0x1A, 0x35, 0xAF, 0xE4, 0xB6, 0x60, 0x7C, 0xB3,\n\t0x58, 0x58, 0x9C, 0x3B, 0x4D, 0x09, 0x4A, 0x1D, 0x81, 0xFE,\n\t0x07, 0x17, 0xF1, 0xDF, 0x5B, 0xDD, 0xEB, 0x3E, 0x11, 0x4F,\n\t0x13, 0x0B, 0xB7, 0x81, 0xE6, 0x6C, 0x22, 0xB5, 0xB7, 0x70,\n\t0xE8, 0xAE, 0x11, 0x5F, 0xF3, 0x9F, 0x8A, 0xDA, 0xF6, 0x6D,\n\t0xEE, 0xDF\n};\n\nuint8_t result2[] = {\n\t0x97, 0x99, 0x3B, 0x78, 0xF7, 0xC3, 0x1C, 0x0E, 0x87, 0x6D,\n\t0xC9, 0x2E, 0xB7, 0xD6, 0xC4, 0x08, 0xE0, 0x9D, 0x60, 0x8A,\n\t0xD6, 0xB9, 0x9D, 0x0E, 0xA2, 0x22, 0x9B, 0x05, 0xA5, 0x78,\n\t0xC4, 0x26, 0x33, 0x4F, 0xCC, 0x8A, 0x1C, 0x7E, 0x67, 0x6E,\n\t0xD2, 0xD8, 0x9A, 0x5B, 0x4C, 0xDF, 0x5B, 0x3F, 0x4A, 0xDF,\n\t0x11, 0x93, 0x6B, 0xF1, 0x4F, 0x4E, 0x10, 0x90, 0x9D, 0xBA,\n\t0x9C, 0x24, 0xF4, 0xFD, 0xFF, 0xDE, 0x72, 0x35, 0x1D, 0xA8,\n\t0xE2, 0xCC, 0x3B, 0x13, 0x5A, 0x39, 0x53, 0x73, 0x89, 0x9E,\n\t0x5F, 0x1A, 0x59, 0x55, 0xB8, 0x80, 0xCA, 0x9B, 0x9E, 0x9D,\n\t0xD4, 0xC9, 0xCA, 0x7F, 0xA4, 0xD4, 0xF5, 0x98, 0x39, 0x46,\n\t0x32, 0x0E, 0x36, 0xC6, 0x4E, 0xF2, 0x83, 0xCA, 0x1F, 0x65,\n\t0xD1, 0x97, 0xCF, 0x81, 0x62, 0x4E, 0xC6, 0x77, 0x8E, 0x77,\n\t0x0E, 0x78, 0x94, 0x9D, 0x84, 0xEF, 0x21, 0xA4, 0x5C, 0xDD,\n\t0x62, 0xD1, 0xDB, 0x76, 0x92, 0x0D, 0x4C, 0x28, 0x36, 0xFC,\n\t0x6A, 0xE5, 0x29, 0x9F, 0xAF, 0x13, 0x57, 0xD9, 0x70, 0x1F,\n\t0xAD, 0x10, 0xFB, 0xD8, 0x8D, 0x1E, 0x28, 0x32, 0x23, 0x94,\n\t0x36, 0xD7, 0x6E, 0xB2, 0x71, 0xBD, 0xC3, 0xCA, 0x04, 0x42,\n\t0x5E, 0xC8, 0x8B, 0xC0, 0xE8, 0x9A, 0x4D, 0x5C, 0x37, 0xFF,\n\t0xCE, 0x7C, 0x6C, 0x3A, 0xBD, 0xE9, 0xC4, 0x13, 0xAE, 0x6D,\n\t0x3F, 0xEA\n};\n\n#elif MD_MAP == SH512\n\n#define FUNCTION \"sha-512\"\n\nuint8_t seed1[127];\n\nuint8_t result1[] = {\n\t0x17, 0x0C, 0xC7, 0x07, 0xC7, 0x1C, 0x69, 0xCE, 0x45, 0xC4,\n\t0x3C, 0xBA, 0xFF, 0x52, 0x10, 0x14, 0x05, 0x72, 0xD4, 0x78,\n\t0x59, 0x52, 0x1B, 0xA1, 0x31, 0x41, 0xBA, 0xDD, 0x2E, 0x5B,\n\t0x9A, 0x7B, 0x3E, 0x80, 0x20, 0x62, 0x5C, 0xD8, 0x89, 0x3F,\n\t0xD6, 0xA4, 0x73, 0x9C, 0x58, 0x1E, 0xD5, 0xBE, 0x7F, 0xA3,\n\t0x14, 0x8A, 0x05, 0xD7, 0xF5, 0x4A, 0xE9, 0xEA, 0xDA, 0xE8,\n\t0xF1, 0xA7, 0x19, 0x4D, 0xF9, 0x4B, 0x6B, 0x75, 0x5B, 0x94,\n\t0x8E, 0x0C, 0x27, 0xE1, 0x74, 0x7F, 0x02, 0xF6, 0x63, 0xD6,\n\t0xB5, 0x14, 0xA0, 0xF5, 0x86, 0xF9, 0x4E, 0x53, 0xD3, 0x21,\n\t0x69, 0xE1, 0xCC, 0xC6, 0x21, 0x1A, 0xD0, 0x34, 0x81, 0x24,\n\t0x19, 0xB6, 0xBA, 0x8F, 0x3C, 0x82, 0x93, 0x04, 0x89, 0x83,\n\t0x93, 0xBF, 0x39, 0xE5, 0x7E, 0x2F, 0xED, 0xF7, 0x75, 0xFC,\n\t0x6E, 0x5E, 0xB0, 0xE3, 0x07, 0xED, 0xCA, 0x0B, 0xD5, 0x15,\n\t0xB9, 0x2B, 0x18, 0x11, 0xF5, 0xAA, 0xD0, 0x2A, 0xAC, 0x9B,\n\t0x39, 0xDF, 0xA5, 0xB8, 0xB1, 0xA9, 0x50, 0x48, 0x7D, 0x34,\n\t0x29, 0xB1, 0x08, 0x1D, 0x0F, 0xEC, 0x28, 0xD5, 0x76, 0x86,\n\t0xD8, 0x5B, 0xC6, 0xB4, 0x5A, 0xB8, 0xB8, 0x4C, 0x54, 0xDD,\n\t0x80, 0xB2, 0x82, 0x59, 0x1F, 0x55, 0x07, 0xED, 0x9B, 0x3F,\n\t0xB1, 0xCD, 0xEE, 0xFD, 0x58, 0xAD, 0x5A, 0x98, 0x12, 0xED,\n\t0x92, 0x9C, 0x77, 0x9B, 0x0F, 0x54, 0xBA, 0xDF, 0x2C, 0xAF,\n\t0xBA, 0xCF, 0xAC, 0xB3, 0xEC, 0xAC, 0xC1, 0x27, 0xC7, 0x64,\n\t0x0C, 0xBB, 0x67, 0x15, 0x4F, 0x54, 0x5A, 0x62, 0x2B, 0xE0,\n\t0xA9, 0xB5, 0x52, 0xA2, 0x42, 0x08, 0x31, 0x3B, 0xFA, 0x49,\n\t0x1F, 0x53, 0xAA, 0xA3, 0x07, 0x4B, 0xDC, 0x48, 0xBC, 0x5B,\n\t0xDB, 0x3F, 0xF0, 0xE2, 0xD0, 0x5B, 0xB4, 0x77, 0xB5, 0x9F,\n\t0x87, 0xE3, 0xA1, 0xEA, 0xB3, 0xE6\n};\n\nuint8_t result2[] = {\n\t0xF9, 0x3C, 0xA6, 0x85, 0x55, 0x90, 0xA7, 0x7F, 0x07, 0x35,\n\t0x40, 0x97, 0xE9, 0x0E, 0x02, 0x66, 0x48, 0xB6, 0x11, 0x5D,\n\t0xF0, 0x08, 0xFF, 0xED, 0xBD, 0x9D, 0x98, 0x11, 0xF5, 0x4E,\n\t0x82, 0x86, 0xEF, 0x00, 0xFD, 0xD6, 0xBA, 0x1E, 0x58, 0xDF,\n\t0x25, 0x35, 0xE3, 0xFB, 0xDD, 0x9A, 0x9B, 0xA3, 0x75, 0x4A,\n\t0x97, 0xF3, 0x6E, 0xE8, 0x33, 0x22, 0x15, 0x82, 0x06, 0x0A,\n\t0x1F, 0x37, 0xFC, 0xE4, 0xEE, 0x88, 0x26, 0x63, 0x6B, 0x28,\n\t0xEA, 0xD5, 0x89, 0x59, 0x3F, 0x4C, 0xA8, 0xB6, 0x47, 0x38,\n\t0x8F, 0x24, 0xEB, 0x3F, 0x0A, 0x34, 0x79, 0x69, 0x68, 0xD2,\n\t0x1B, 0xDE, 0xE6, 0xF8, 0x1F, 0xD5, 0xDF, 0x93, 0x53, 0x6F,\n\t0x93, 0x59, 0x37, 0xB8, 0x02, 0x5E, 0xC8, 0xCB, 0xF5, 0x7D,\n\t0xDB, 0x0C, 0x61, 0xF2, 0xE4, 0x14, 0x63, 0xCC, 0x15, 0x16,\n\t0xD6, 0x57, 0xDA, 0x28, 0x29, 0xC6, 0xBF, 0x90, 0x48, 0x17,\n\t0x61, 0x8F, 0x48, 0xC6, 0x0F, 0xB1, 0xCE, 0x5B, 0xFB, 0xDA,\n\t0x0C, 0xAF, 0x45, 0x91, 0x88, 0x2A, 0x31, 0xF6, 0xEE, 0x3F,\n\t0xE0, 0xF7, 0x87, 0x79, 0x99, 0x2A, 0x06, 0xEC, 0x60, 0xF3,\n\t0x7F, 0xB9, 0xA8, 0xD6, 0x10, 0x8C, 0x23, 0x1F, 0x0A, 0x92,\n\t0x77, 0x54, 0xB0, 0x59, 0x9F, 0xA4, 0xFA, 0x27, 0xA4, 0xE2,\n\t0x5E, 0x06, 0x5E, 0xF0, 0x30, 0x85, 0xB8, 0x92, 0x97, 0x9D,\n\t0xC0, 0xE7, 0xA1, 0x08, 0x08, 0x83, 0xCA, 0xEB, 0xFD, 0xFD,\n\t0x36, 0x65, 0xA8, 0xF2, 0xD0, 0x61, 0xC5, 0x21, 0xF7, 0xD6,\n\t0xE3, 0xDA, 0x2A, 0xF8, 0xB9, 0x7B, 0x6B, 0x43, 0xB6, 0xEC,\n\t0x83, 0x1A, 0xF5, 0x15, 0x07, 0x0A, 0x83, 0xBB, 0xB9, 0xAC,\n\t0x95, 0xED, 0x4E, 0xF4, 0x9B, 0x75, 0x6A, 0x23, 0x77, 0xA5,\n\t0xF0, 0x83, 0x3D, 0x84, 0x7E, 0x27, 0xA8, 0x8D, 0xDB, 0x0C,\n\t0x2C, 0xE4, 0xAD, 0x78, 0x2E, 0x7B\n};\n\n#elif MD_MAP == B2S160\n\n#define FUNCTION \"blake2s-160\"\n\nuint8_t seed1[60];\n\nuint8_t result1[] = {\n\t0x3B, 0xFB, 0x98, 0xB1, 0x75, 0x4A, 0x85, 0x1D, 0x82, 0x51,\n\t0x09, 0xE7, 0xA9, 0x7B, 0x45, 0x25, 0x3F, 0x82, 0xEC, 0xBB,\n\t0x8A, 0xF6, 0x7A, 0x15, 0x6B, 0x8D, 0x8A, 0xE7, 0x1E, 0xD9,\n\t0x17, 0xED, 0x24, 0x35, 0x00, 0x87, 0x7B, 0xE6, 0xBD, 0xEF,\n\t0xF5, 0xD7, 0xD0, 0x6C, 0x57, 0x08, 0xF6, 0x62, 0x43, 0x51,\n\t0xD6, 0x9C, 0x6A, 0x7A, 0xF1, 0xC9, 0xB3, 0xF6, 0xD9, 0x5B,\n\t0x94, 0x3C, 0xBB, 0x1A, 0xF4, 0x3C, 0xD8, 0xB4, 0x2A, 0xA3,\n\t0xE8, 0x7C, 0x62, 0x40, 0xD1, 0xBD, 0x5D, 0x6B, 0x8C, 0xF0\n};\n\nuint8_t result2[] = {\n\t0xAD, 0xF3, 0x6B, 0x2A, 0x4A, 0xAA, 0x78, 0xEC, 0x4B, 0xE7,\n\t0x50, 0xEA, 0x91, 0x08, 0xD7, 0xBC, 0x9A, 0x7B, 0x52, 0x0A,\n\t0x46, 0x0D, 0xA5, 0xD9, 0x12, 0xCC, 0xF8, 0x3C, 0x51, 0x48,\n\t0xFD, 0xD3, 0x45, 0x9E, 0xC5, 0x84, 0xF1, 0x29, 0xFD, 0x0C,\n\t0x03, 0x28, 0xD1, 0xEF, 0x0B, 0xBE, 0x73, 0x8B, 0xD4, 0x77,\n\t0xA2, 0x48, 0x05, 0xDE, 0xA3, 0xFD, 0xB2, 0x75, 0xF2, 0x9F,\n\t0xE8, 0xCA, 0xEF, 0xDB, 0x5D, 0x4F, 0xBF, 0xB6, 0x27, 0x93,\n\t0x98, 0x7B, 0x11, 0x8D, 0x9F, 0x97, 0xA1, 0x4E, 0x67, 0x82\n};\n\n#elif MD_MAP == B2S256\n\nuint8_t seed1[63];\n\n#define FUNCTION \"blake2s-256\"\n\nuint8_t result1[] = {\n\t0xD5, 0x26, 0xBD, 0x3B, 0x1A, 0x08, 0x91, 0x25, 0xB1, 0x2D,\n\t0xFF, 0x63, 0x57, 0x33, 0x85, 0x11, 0x7A, 0x1E, 0xF3, 0x7E,\n\t0xE0, 0xAE, 0xCE, 0x77, 0xAC, 0x19, 0x8B, 0x92, 0x7A, 0xDE,\n\t0x79, 0x23, 0x0E, 0xA9, 0x25, 0xF3, 0x33, 0xB4, 0x17, 0xC7,\n\t0xF7, 0x0A, 0xEB, 0x25, 0x0C, 0x9B, 0xAF, 0x38, 0xD0, 0x5C,\n\t0xCE, 0xC6, 0xB5, 0x63, 0x70, 0x15, 0xD7, 0x36, 0x4A, 0x99,\n\t0x25, 0xE9, 0xE1, 0x76, 0x75, 0xE0, 0x1C, 0x8E, 0x1E, 0x0B,\n\t0xC1, 0xE2, 0x8F, 0xB7, 0xCA, 0x56, 0x69, 0xB7, 0xAB, 0x5B,\n\t0x45, 0x6F, 0x5B, 0xA4, 0xF3, 0xAA, 0x54, 0x30, 0x3B, 0x44,\n\t0xFF, 0x35, 0xBF, 0xBB, 0xD8, 0xA3, 0xEA, 0xFA, 0x32, 0x8F,\n\t0xD0, 0x68, 0x76, 0x5B, 0x47, 0x9E, 0x61, 0x73, 0xEB, 0xF8,\n\t0x84, 0x1D, 0xF5, 0xA7, 0xEF, 0x91, 0x47, 0x19, 0x30, 0x12,\n\t0xF6, 0x7C, 0x04, 0x7A, 0x4F, 0x4F, 0x07, 0xA0\n};\n\nuint8_t result2[] = {\n\t0xAB, 0x61, 0x58, 0xF2, 0x82, 0x88, 0xAA, 0x0A, 0xD1, 0xA3,\n\t0x98, 0xAD, 0x73, 0xD5, 0xD5, 0x1D, 0x6E, 0xDE, 0xA4, 0x24,\n\t0xA7, 0x76, 0x3D, 0x77, 0xD5, 0x33, 0xB8, 0x1B, 0xE7, 0x43,\n\t0x32, 0x0A, 0xB6, 0x44, 0x4D, 0x47, 0x54, 0x68, 0x69, 0x1B,\n\t0xA7, 0x5E, 0xA4, 0x90, 0x1D, 0x21, 0xBA, 0x3B, 0xC3, 0x7B,\n\t0x60, 0x3A, 0xDB, 0xD5, 0xDC, 0xCB, 0x8B, 0x6E, 0xB6, 0x6A,\n\t0xA0, 0xA7, 0x5B, 0xBB, 0x40, 0xC4, 0x7E, 0xB9, 0xD0, 0xC9,\n\t0xDB, 0xFF, 0xAC, 0x19, 0xFA, 0xB2, 0x71, 0x41, 0xAB, 0x0A,\n\t0x41, 0xEB, 0x9C, 0xD1, 0x42, 0x08, 0x97, 0xAF, 0x17, 0x87,\n\t0x45, 0x7A, 0x2C, 0x7D, 0x8F, 0x43, 0xB3, 0x85, 0x49, 0xFF,\n\t0x28, 0x81, 0xE9, 0x5C, 0x85, 0x58, 0x06, 0x74, 0x11, 0x3A,\n\t0xDC, 0x00, 0x29, 0xA0, 0x78, 0xC8, 0xA7, 0xE4, 0xEB, 0x2D,\n\t0x9D, 0x07, 0xE1, 0x64, 0xCC, 0x0B, 0x94, 0x37\n};\n\n#endif\n\nstatic int test(void) {\n\tint i, len = 2 * RLC_MD_LEN, code = RLC_ERR;\n\tuint8_t out[2 * RLC_MD_LEN], seed2[(RLC_RAND_SIZE - 1) / 2], seed3[(RLC_RAND_SIZE - 1) / 2];\n\n\tfor (i = 0; i < (RLC_RAND_SIZE - 1) / 2; i++) {\n\t\tseed1[i] = i;\n\t\tseed2[i] = 0x80 + i;\n\t\tseed3[i] = 0xC0 + i;\n\t}\n\tfor (; i < sizeof(seed1); i++) {\n\t\tseed1[i] = 0x20 + (i - (RLC_RAND_SIZE - 1) / 2);\n\t}\n\n\tTEST_ONCE(\"hash-dbrg (\" FUNCTION \") random generator is correct\") {\n\t\trand_clean();\n\t\trand_seed(seed1, sizeof(seed1));\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result1, len) == 0, end);\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result1 + len, len) == 0, end);\n\t}\n\tTEST_END;\n\n\tTEST_ONCE(\"hash-dbrg (\" FUNCTION \") reseeding is correct\") {\n\t\trand_clean();\n\t\trand_seed(seed1, sizeof(seed1));\n\t\trand_seed(seed2, sizeof(seed2));\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result2, len) == 0, end);\n\t\trand_seed(seed3, sizeof(seed3));\n\t\trand_bytes(out, len);\n\t\tTEST_ASSERT(memcmp(out, result2 + len, len) == 0, end);\n\t}\n\tTEST_END;\n\n\tcode = RLC_OK;\n\n  end:\n\treturn code;\n}\n\n#elif RAND == UDEV\n\nstatic int test(void) {\n\tuint8_t out[20], digit;\n\n\tTEST_ONCE(\"reading from /dev/urandom is correct\") {\n\t\tdigit = 0;\n\t\tmemset(out, 0, sizeof(out));\n\t\trand_bytes(out, sizeof(out));\n\t\tfor (int j = 0; j < sizeof(20); j++) {\n\t\t\tdigit ^= out[j];\n\t\t}\n\t\tTEST_ASSERT(digit != 0, end);\n\t}\n\tTEST_END;\n  end:\n\treturn RLC_OK;\n}\n\n#elif RAND == RDRND\n\nstatic int test(void) {\n\tuint8_t out[64];\n\tsize_t len = sizeof(out) / 2, code = RLC_ERR;\n\n\tTEST_ONCE(\"rdrand hardware generator is non-trivial\") {\n\t\tmemset(out, 0, 2 * len);\n\t\trand_bytes(out, len);\n\t\t/* This fails with negligible probability. */\n\t\tTEST_ASSERT(memcmp(out, out + len, len) != 0, end);\n\t}\n\tTEST_END;\n\n\tcode = RLC_OK;\n\n  end:\n\treturn code;\n}\n\n#elif RAND == CALL\n\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nstatic void test_bytes(uint8_t *buf, int size, void *args) {\n\tint c, l, fd = *(int *)args;\n\n\tif (fd == -1) {\n\t\tRLC_THROW(ERR_NO_FILE);\n\t}\n\n\tl = 0;\n\tdo {\n\t\tc = read(fd, buf + l, size - l);\n\t\tl += c;\n\t\tif (c == -1) {\n\t\t\tRLC_THROW(ERR_NO_READ);\n\t\t}\n\t} while (l < size);\n}\n\nstatic int test(void) {\n\tuint8_t out[20], digit;\n\tint fd = open(\"/dev/urandom\", O_RDONLY);\n\n\tTEST_ONCE(\"callback to reading /dev/urandom is correct\") {\n\t\tdigit = 0;\n\t\tmemset(out, 0, sizeof(out));\n\t\trand_bytes(out, sizeof(out));\n\t\tfor (int j = 0; j < sizeof(20); j++) {\n\t\t\tdigit ^= out[j];\n\t\t}\n\t\tTEST_ASSERT(digit != 0, end);\n\t\trand_seed(&test_bytes, (void *)&fd);\n\t\trand_bytes(out, sizeof(out));\n\t\tfor (int j = 0; j < sizeof(20); j++) {\n\t\t\tdigit ^= out[j];\n\t\t}\n\t\tTEST_ASSERT(digit != 0, end);\n\t}\n\tTEST_END;\n  end:\n  \tclose(fd);\n\treturn RLC_OK;\n}\n\n#endif\n\nint main(void) {\n\tif (core_init() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"Tests for the RAND module:\\n\", 0);\n\n\tif (test() != RLC_OK) {\n\t\tcore_clean();\n\t\treturn 1;\n\t}\n\n\tutil_banner(\"All tests have passed.\\n\", 0);\n\n\tcore_clean();\n\treturn 0;\n}\n"], "filenames": ["bench/bench_bn.c", "bench/bench_cp.c", "bench/bench_epx.c", "include/relic_bn.h", "include/relic_cp.h", "include/relic_eb.h", "include/relic_ed.h", "include/relic_ep.h", "include/relic_epx.h", "include/relic_fb.h", "include/relic_fp.h", "include/relic_fpx.h", "include/relic_md.h", "include/relic_rand.h", "include/relic_util.h", "src/bn/relic_bn_gcd.c", "src/bn/relic_bn_mem.c", "src/bn/relic_bn_mxp.c", "src/bn/relic_bn_prime.c", "src/bn/relic_bn_rec.c", "src/bn/relic_bn_shift.c", "src/bn/relic_bn_smb.c", "src/bn/relic_bn_srt.c", "src/bn/relic_bn_util.c", "src/cp/relic_cp_bls.c", "src/cp/relic_cp_cmlhs.c", "src/cp/relic_cp_pbpsi.c", "src/cp/relic_cp_rsa.c", "src/cp/relic_cp_sokaka.c", "src/cp/relic_cp_vbnn.c", "src/eb/relic_eb_map.c", "src/eb/relic_eb_mul.c", "src/eb/relic_eb_mul_sim.c", "src/eb/relic_eb_util.c", "src/ed/relic_ed_map.c", "src/ed/relic_ed_mul.c", "src/ed/relic_ed_mul_fix.c", "src/ed/relic_ed_mul_sim.c", "src/ed/relic_ed_util.c", "src/ep/relic_ep_map.c", "src/ep/relic_ep_mul.c", "src/ep/relic_ep_mul_fix.c", "src/ep/relic_ep_mul_sim.c", "src/ep/relic_ep_util.c", "src/epx/relic_ep2_map.c", "src/epx/relic_ep2_mul.c", "src/epx/relic_ep2_mul_fix.c", "src/epx/relic_ep2_mul_sim.c", "src/epx/relic_ep2_util.c", "src/epx/relic_ep4_map.c", "src/epx/relic_ep4_mul.c", "src/epx/relic_ep4_mul_fix.c", "src/epx/relic_ep4_mul_sim.c", "src/epx/relic_ep4_util.c", "src/fb/relic_fb_exp.c", "src/fb/relic_fb_util.c", "src/fp/relic_fp_exp.c", "src/fp/relic_fp_prime.c", "src/fp/relic_fp_util.c", "src/fpx/relic_fpx_cyc.c", "src/fpx/relic_fpx_exp.c", "src/fpx/relic_fpx_util.c", "src/md/relic_md_blake2s.c", "src/md/relic_md_hmac.c", "src/md/relic_md_kdf.c", "src/md/relic_md_mgf.c", "src/md/relic_md_sha224.c", "src/md/relic_md_sha256.c", "src/md/relic_md_sha384.c", "src/md/relic_md_sha512.c", "src/pp/relic_pp_map_k12.c", "src/pp/relic_pp_map_k24.c", "src/pp/relic_pp_map_k48.c", "src/pp/relic_pp_map_k54.c", "src/pp/relic_pp_map_k8.c", "src/rand/relic_rand_core.c", "src/rand/relic_rand_hashd.c", "src/relic_util.c", "test/test_bn.c", "test/test_core.c", "test/test_pc.c", "test/test_rand.c"], "buggy_code_start_loc": [287, 143, 40, 56, 743, 563, 485, 814, 748, 51, 51, 1335, 137, 92, 288, 205, 44, 119, 279, 46, 66, 124, 41, 108, 60, 68, 116, 247, 75, 76, 40, 52, 57, 503, 190, 42, 50, 56, 245, 51, 43, 49, 57, 237, 51, 44, 50, 57, 246, 40, 44, 48, 55, 257, 47, 48, 42, 299, 65, 86, 332, 75, 46, 43, 43, 43, 43, 43, 43, 43, 55, 55, 45, 45, 56, 186, 56, 137, 237, 125, 1248, 366], "buggy_code_end_loc": [932, 166, 51, 1475, 1544, 932, 856, 1241, 1787, 640, 755, 4667, 273, 127, 289, 473, 147, 222, 523, 832, 119, 125, 63, 521, 61, 335, 116, 582, 77, 197, 41, 896, 440, 554, 258, 413, 51, 404, 301, 206, 727, 50, 842, 288, 192, 391, 65, 642, 297, 41, 290, 95, 437, 292, 146, 305, 141, 463, 268, 2095, 661, 811, 56, 45, 45, 45, 44, 44, 44, 44, 56, 56, 46, 46, 57, 187, 179, 138, 1943, 125, 1249, 367], "fixing_code_start_loc": [287, 144, 40, 56, 743, 563, 485, 814, 748, 51, 51, 1335, 137, 92, 288, 205, 44, 119, 279, 46, 66, 124, 41, 108, 60, 68, 117, 247, 75, 76, 40, 52, 57, 503, 190, 42, 50, 56, 245, 51, 43, 49, 57, 237, 50, 44, 49, 57, 246, 40, 44, 47, 55, 257, 47, 48, 42, 299, 65, 85, 332, 75, 46, 43, 43, 43, 43, 43, 43, 43, 55, 55, 45, 45, 56, 186, 56, 137, 237, 126, 1248, 366], "fixing_code_end_loc": [932, 166, 51, 1478, 1544, 932, 857, 1241, 1791, 640, 755, 4669, 273, 127, 289, 502, 147, 221, 523, 836, 116, 125, 67, 521, 61, 343, 118, 583, 77, 199, 41, 902, 444, 554, 259, 415, 53, 407, 301, 212, 730, 52, 848, 288, 189, 391, 66, 646, 297, 41, 292, 94, 441, 292, 146, 303, 141, 463, 268, 2101, 661, 811, 56, 45, 44, 44, 44, 44, 44, 44, 57, 57, 47, 47, 58, 187, 180, 138, 1946, 127, 1249, 367], "type": "CWE-190", "message": "Integer Overflow vulnerability in RELIC before commit 34580d840469361ba9b5f001361cad659687b9ab, allows attackers to execute arbitrary code, cause a denial of service, and escalate privileges when calling realloc function in bn_grow function.", "other": {"cve": {"id": "CVE-2023-36326", "sourceIdentifier": "cve@mitre.org", "published": "2023-09-01T16:15:08.077", "lastModified": "2023-09-06T00:04:24.377", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Integer Overflow vulnerability in RELIC before commit 34580d840469361ba9b5f001361cad659687b9ab, allows attackers to execute arbitrary code, cause a denial of service, and escalate privileges when calling realloc function in bn_grow function."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de enteros en RELIC antes del commit 34580d840469361ba9b5f001361cad659687b9ab, permite a los atacantes ejecutar c\u00f3digo arbitrario, causar una denegaci\u00f3n de servicio y escalar privilegios al llamar la funci\u00f3n realloc en la funci\u00f3n bn_grow"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:relic_project:relic:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-11-14", "matchCriteriaId": "D636CA1B-2334-4D2F-92E0-FADDA9CDF77B"}]}]}], "references": [{"url": "https://github.com/relic-toolkit/relic/commit/34580d840469361ba9b5f001361cad659687b9ab", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://groups.google.com/g/relic-discuss/c/A_J2-ArVIAo/m/qgFiXsUJBQAJ?utm_medium=email&utm_source=footer", "source": "cve@mitre.org", "tags": ["Mailing List"]}]}, "github_commit_url": "https://github.com/relic-toolkit/relic/commit/34580d840469361ba9b5f001361cad659687b9ab"}}