{"buggy_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\n#include <ctype.h>\n\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\n\treturn 0;\n}\n\n/* the rest of the line will be useful for multi_ack and multi_ack_detailed */\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\n\t/* Remove \"ERR \" from the line */\n\tline += 4;\n\tlen -= 4;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\n\treturn 0;\n}\n\n/*\n * Parse an other-ref line.\n */\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\n\t/* Check for a bit of consistency */\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"Error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\n\t/* Jump from the name */\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\n\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_OK;\n\n\tline += 3; /* skip \"ok \" */\n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\n\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\n\tGIT_UNUSED(len);\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\t/* Make sure there are no special characters before passing to error message */\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\n\treturn len;\n}\n\n/*\n * As per the documentation, the syntax is:\n *\n * pkt-line\t= data-pkt / flush-pkt\n * data-pkt\t= pkt-len pkt-payload\n * pkt-len\t\t= 4*(HEXDIG)\n * pkt-payload = (pkt-len -4)*(OCTET)\n * flush-pkt\t= \"0000\"\n *\n * Which means that the first four bytes are the length of the line,\n * in ASCII hexadecimal (including itself)\n */\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}\n\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\n\t/* Prefer multi_ack_detailed */\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\n\t/* Prefer side-band-64k if the server supports both */\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1 /* NUL */ +\n\t\t git_buf_len(&str) + 1 /* LF */;\n\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\n\treturn 0;\n}\n\n/*\n * All \"want\" packets have the same length and format, so what we do\n * is overwrite the OID each time.\n */\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}\n"], "fixing_code": ["/*\n * Copyright (C) the libgit2 contributors. All rights reserved.\n *\n * This file is part of libgit2, distributed under the GNU GPL v2 with\n * a Linking Exception. For full terms see the included COPYING file.\n */\n\n#include \"common.h\"\n\n#include \"git2/types.h\"\n#include \"git2/errors.h\"\n#include \"git2/refs.h\"\n#include \"git2/revwalk.h\"\n\n#include \"smart.h\"\n#include \"util.h\"\n#include \"netops.h\"\n#include \"posix.h\"\n#include \"buffer.h\"\n\n#include <ctype.h>\n\n#define PKT_LEN_SIZE 4\nstatic const char pkt_done_str[] = \"0009done\\n\";\nstatic const char pkt_flush_str[] = \"0000\";\nstatic const char pkt_have_prefix[] = \"0032have \";\nstatic const char pkt_want_prefix[] = \"0032want \";\n\nstatic int flush_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_FLUSH;\n\t*out = pkt;\n\n\treturn 0;\n}\n\n/* the rest of the line will be useful for multi_ack and multi_ack_detailed */\nstatic int ack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ack *pkt;\n\tGIT_UNUSED(line);\n\tGIT_UNUSED(len);\n\n\tpkt = git__calloc(1, sizeof(git_pkt_ack));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ACK;\n\tline += 3;\n\tlen -= 3;\n\n\tif (len >= GIT_OID_HEXSZ) {\n\t\tgit_oid_fromstr(&pkt->oid, line + 1);\n\t\tline += GIT_OID_HEXSZ + 1;\n\t\tlen -= GIT_OID_HEXSZ + 1;\n\t}\n\n\tif (len >= 7) {\n\t\tif (!git__prefixcmp(line + 1, \"continue\"))\n\t\t\tpkt->status = GIT_ACK_CONTINUE;\n\t\tif (!git__prefixcmp(line + 1, \"common\"))\n\t\t\tpkt->status = GIT_ACK_COMMON;\n\t\tif (!git__prefixcmp(line + 1, \"ready\"))\n\t\t\tpkt->status = GIT_ACK_READY;\n\t}\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int nak_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_NAK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int pack_pkt(git_pkt **out)\n{\n\tgit_pkt *pkt;\n\n\tpkt = git__malloc(sizeof(git_pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PACK;\n\t*out = pkt;\n\n\treturn 0;\n}\n\nstatic int comment_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_comment *pkt;\n\tsize_t alloclen;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_comment), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_COMMENT;\n\tmemcpy(pkt->comment, line, len);\n\tpkt->comment[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int err_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloclen;\n\n\t/* Remove \"ERR \" from the line */\n\tline += 4;\n\tlen -= 4;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, alloclen, 1);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int data_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_data *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_DATA;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_progress_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_progress *pkt;\n\tsize_t alloclen;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, sizeof(git_pkt_progress), len);\n\tpkt = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_PROGRESS;\n\tpkt->len = (int) len;\n\tmemcpy(pkt->data, line, len);\n\n\t*out = (git_pkt *) pkt;\n\n\treturn 0;\n}\n\nstatic int sideband_error_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_err *pkt;\n\tsize_t alloc_len;\n\n\tline++;\n\tlen--;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, sizeof(git_pkt_err), len);\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, alloc_len, 1);\n\tpkt = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_ERR;\n\tpkt->len = (int)len;\n\tmemcpy(pkt->error, line, len);\n\tpkt->error[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\n\treturn 0;\n}\n\n/*\n * Parse an other-ref line.\n */\nstatic int ref_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tint error;\n\tgit_pkt_ref *pkt;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(git_pkt_ref));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tmemset(pkt, 0x0, sizeof(git_pkt_ref));\n\tpkt->type = GIT_PKT_REF;\n\tif ((error = git_oid_fromstr(&pkt->head.oid, line)) < 0)\n\t\tgoto error_out;\n\n\t/* Check for a bit of consistency */\n\tif (line[GIT_OID_HEXSZ] != ' ') {\n\t\tgiterr_set(GITERR_NET, \"Error parsing pkt-line\");\n\t\terror = -1;\n\t\tgoto error_out;\n\t}\n\n\t/* Jump from the name */\n\tline += GIT_OID_HEXSZ + 1;\n\tlen -= (GIT_OID_HEXSZ + 1);\n\n\tif (line[len - 1] == '\\n')\n\t\t--len;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->head.name = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->head.name);\n\n\tmemcpy(pkt->head.name, line, len);\n\tpkt->head.name[len] = '\\0';\n\n\tif (strlen(pkt->head.name) < len) {\n\t\tpkt->capabilities = strchr(pkt->head.name, '\\0') + 1;\n\t}\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nerror_out:\n\tgit__free(pkt);\n\treturn error;\n}\n\nstatic int ok_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ok *pkt;\n\tconst char *ptr;\n\tsize_t alloc_len;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_OK;\n\n\tline += 3; /* skip \"ok \" */\n\tif (!(ptr = strchr(line, '\\n'))) {\n\t\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\t\tgit__free(pkt);\n\t\treturn -1;\n\t}\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloc_len, len, 1);\n\tpkt->ref = git__malloc(alloc_len);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int ng_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_ng *pkt;\n\tconst char *ptr;\n\tsize_t alloclen;\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->ref = NULL;\n\tpkt->type = GIT_PKT_NG;\n\n\tline += 3; /* skip \"ng \" */\n\tif (!(ptr = strchr(line, ' ')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->ref = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->ref);\n\n\tmemcpy(pkt->ref, line, len);\n\tpkt->ref[len] = '\\0';\n\n\tline = ptr + 1;\n\tif (!(ptr = strchr(line, '\\n')))\n\t\tgoto out_err;\n\tlen = ptr - line;\n\n\tGITERR_CHECK_ALLOC_ADD(&alloclen, len, 1);\n\tpkt->msg = git__malloc(alloclen);\n\tGITERR_CHECK_ALLOC(pkt->msg);\n\n\tmemcpy(pkt->msg, line, len);\n\tpkt->msg[len] = '\\0';\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n\nout_err:\n\tgiterr_set(GITERR_NET, \"Invalid packet line\");\n\tgit__free(pkt->ref);\n\tgit__free(pkt);\n\treturn -1;\n}\n\nstatic int unpack_pkt(git_pkt **out, const char *line, size_t len)\n{\n\tgit_pkt_unpack *pkt;\n\n\tGIT_UNUSED(len);\n\n\tpkt = git__malloc(sizeof(*pkt));\n\tGITERR_CHECK_ALLOC(pkt);\n\n\tpkt->type = GIT_PKT_UNPACK;\n\tif (!git__prefixcmp(line, \"unpack ok\"))\n\t\tpkt->unpack_ok = 1;\n\telse\n\t\tpkt->unpack_ok = 0;\n\n\t*out = (git_pkt *)pkt;\n\treturn 0;\n}\n\nstatic int32_t parse_len(const char *line)\n{\n\tchar num[PKT_LEN_SIZE + 1];\n\tint i, k, error;\n\tint32_t len;\n\tconst char *num_end;\n\n\tmemcpy(num, line, PKT_LEN_SIZE);\n\tnum[PKT_LEN_SIZE] = '\\0';\n\n\tfor (i = 0; i < PKT_LEN_SIZE; ++i) {\n\t\tif (!isxdigit(num[i])) {\n\t\t\t/* Make sure there are no special characters before passing to error message */\n\t\t\tfor (k = 0; k < PKT_LEN_SIZE; ++k) {\n\t\t\t\tif(!isprint(num[k])) {\n\t\t\t\t\tnum[k] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tgiterr_set(GITERR_NET, \"invalid hex digit in length: '%s'\", num);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((error = git__strtol32(&len, num, &num_end, 16)) < 0)\n\t\treturn error;\n\n\treturn len;\n}\n\n/*\n * As per the documentation, the syntax is:\n *\n * pkt-line\t= data-pkt / flush-pkt\n * data-pkt\t= pkt-len pkt-payload\n * pkt-len\t\t= 4*(HEXDIG)\n * pkt-payload = (pkt-len -4)*(OCTET)\n * flush-pkt\t= \"0000\"\n *\n * Which means that the first four bytes are the length of the line,\n * in ASCII hexadecimal (including itself)\n */\n\nint git_pkt_parse_line(\n\tgit_pkt **head, const char *line, const char **out, size_t bufflen)\n{\n\tint ret;\n\tint32_t len;\n\n\t/* Not even enough for the length */\n\tif (bufflen > 0 && bufflen < PKT_LEN_SIZE)\n\t\treturn GIT_EBUFS;\n\n\tlen = parse_len(line);\n\tif (len < 0) {\n\t\t/*\n\t\t * If we fail to parse the length, it might be because the\n\t\t * server is trying to send us the packfile already.\n\t\t */\n\t\tif (bufflen >= 4 && !git__prefixcmp(line, \"PACK\")) {\n\t\t\tgiterr_clear();\n\t\t\t*out = line;\n\t\t\treturn pack_pkt(head);\n\t\t}\n\n\t\treturn (int)len;\n\t}\n\n\t/*\n\t * If we were given a buffer length, then make sure there is\n\t * enough in the buffer to satisfy this line\n\t */\n\tif (bufflen > 0 && bufflen < (size_t)len)\n\t\treturn GIT_EBUFS;\n\n\t/*\n\t * The length has to be exactly 0 in case of a flush\n\t * packet or greater than PKT_LEN_SIZE, as the decoded\n\t * length includes its own encoded length of four bytes.\n\t */\n\tif (len != 0 && len < PKT_LEN_SIZE)\n\t\treturn GIT_ERROR;\n\n\tline += PKT_LEN_SIZE;\n\t/*\n\t * TODO: How do we deal with empty lines? Try again? with the next\n\t * line?\n\t */\n\tif (len == PKT_LEN_SIZE) {\n\t\t*head = NULL;\n\t\t*out = line;\n\t\treturn 0;\n\t}\n\n\tif (len == 0) { /* Flush pkt */\n\t\t*out = line;\n\t\treturn flush_pkt(head);\n\t}\n\n\tlen -= PKT_LEN_SIZE; /* the encoded length includes its own size */\n\n\tif (*line == GIT_SIDE_BAND_DATA)\n\t\tret = data_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_PROGRESS)\n\t\tret = sideband_progress_pkt(head, line, len);\n\telse if (*line == GIT_SIDE_BAND_ERROR)\n\t\tret = sideband_error_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ACK\"))\n\t\tret = ack_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"NAK\"))\n\t\tret = nak_pkt(head);\n\telse if (!git__prefixcmp(line, \"ERR \"))\n\t\tret = err_pkt(head, line, len);\n\telse if (*line == '#')\n\t\tret = comment_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ok\"))\n\t\tret = ok_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"ng\"))\n\t\tret = ng_pkt(head, line, len);\n\telse if (!git__prefixcmp(line, \"unpack\"))\n\t\tret = unpack_pkt(head, line, len);\n\telse\n\t\tret = ref_pkt(head, line, len);\n\n\t*out = line + len;\n\n\treturn ret;\n}\n\nvoid git_pkt_free(git_pkt *pkt)\n{\n\tif (pkt->type == GIT_PKT_REF) {\n\t\tgit_pkt_ref *p = (git_pkt_ref *) pkt;\n\t\tgit__free(p->head.name);\n\t\tgit__free(p->head.symref_target);\n\t}\n\n\tif (pkt->type == GIT_PKT_OK) {\n\t\tgit_pkt_ok *p = (git_pkt_ok *) pkt;\n\t\tgit__free(p->ref);\n\t}\n\n\tif (pkt->type == GIT_PKT_NG) {\n\t\tgit_pkt_ng *p = (git_pkt_ng *) pkt;\n\t\tgit__free(p->ref);\n\t\tgit__free(p->msg);\n\t}\n\n\tgit__free(pkt);\n}\n\nint git_pkt_buffer_flush(git_buf *buf)\n{\n\treturn git_buf_put(buf, pkt_flush_str, strlen(pkt_flush_str));\n}\n\nstatic int buffer_want_with_caps(const git_remote_head *head, transport_smart_caps *caps, git_buf *buf)\n{\n\tgit_buf str = GIT_BUF_INIT;\n\tchar oid[GIT_OID_HEXSZ +1] = {0};\n\tsize_t len;\n\n\t/* Prefer multi_ack_detailed */\n\tif (caps->multi_ack_detailed)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK_DETAILED \" \");\n\telse if (caps->multi_ack)\n\t\tgit_buf_puts(&str, GIT_CAP_MULTI_ACK \" \");\n\n\t/* Prefer side-band-64k if the server supports both */\n\tif (caps->side_band_64k)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND_64K);\n\telse if (caps->side_band)\n\t\tgit_buf_printf(&str, \"%s \", GIT_CAP_SIDE_BAND);\n\n\tif (caps->include_tag)\n\t\tgit_buf_puts(&str, GIT_CAP_INCLUDE_TAG \" \");\n\n\tif (caps->thin_pack)\n\t\tgit_buf_puts(&str, GIT_CAP_THIN_PACK \" \");\n\n\tif (caps->ofs_delta)\n\t\tgit_buf_puts(&str, GIT_CAP_OFS_DELTA \" \");\n\n\tif (git_buf_oom(&str))\n\t\treturn -1;\n\n\tlen = strlen(\"XXXXwant \") + GIT_OID_HEXSZ + 1 /* NUL */ +\n\t\t git_buf_len(&str) + 1 /* LF */;\n\n\tif (len > 0xffff) {\n\t\tgiterr_set(GITERR_NET,\n\t\t\t\"Tried to produce packet with invalid length %\" PRIuZ, len);\n\t\treturn -1;\n\t}\n\n\tgit_buf_grow_by(buf, len);\n\tgit_oid_fmt(oid, &head->oid);\n\tgit_buf_printf(buf,\n\t\t\"%04xwant %s %s\\n\", (unsigned int)len, oid, git_buf_cstr(&str));\n\tgit_buf_free(&str);\n\n\tGITERR_CHECK_ALLOC_BUF(buf);\n\n\treturn 0;\n}\n\n/*\n * All \"want\" packets have the same length and format, so what we do\n * is overwrite the OID each time.\n */\n\nint git_pkt_buffer_wants(\n\tconst git_remote_head * const *refs,\n\tsize_t count,\n\ttransport_smart_caps *caps,\n\tgit_buf *buf)\n{\n\tsize_t i = 0;\n\tconst git_remote_head *head;\n\n\tif (caps->common) {\n\t\tfor (; i < count; ++i) {\n\t\t\thead = refs[i];\n\t\t\tif (!head->local)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (buffer_want_with_caps(refs[i], caps, buf) < 0)\n\t\t\treturn -1;\n\n\t\ti++;\n\t}\n\n\tfor (; i < count; ++i) {\n\t\tchar oid[GIT_OID_HEXSZ];\n\n\t\thead = refs[i];\n\t\tif (head->local)\n\t\t\tcontinue;\n\n\t\tgit_oid_fmt(oid, &head->oid);\n\t\tgit_buf_put(buf, pkt_want_prefix, strlen(pkt_want_prefix));\n\t\tgit_buf_put(buf, oid, GIT_OID_HEXSZ);\n\t\tgit_buf_putc(buf, '\\n');\n\t\tif (git_buf_oom(buf))\n\t\t\treturn -1;\n\t}\n\n\treturn git_pkt_buffer_flush(buf);\n}\n\nint git_pkt_buffer_have(git_oid *oid, git_buf *buf)\n{\n\tchar oidhex[GIT_OID_HEXSZ + 1];\n\n\tmemset(oidhex, 0x0, sizeof(oidhex));\n\tgit_oid_fmt(oidhex, oid);\n\treturn git_buf_printf(buf, \"%s%s\\n\", pkt_have_prefix, oidhex);\n}\n\nint git_pkt_buffer_done(git_buf *buf)\n{\n\treturn git_buf_puts(buf, pkt_done_str);\n}\n"], "filenames": ["src/transports/smart_pkt.c"], "buggy_code_start_loc": [428], "buggy_code_end_loc": [428], "fixing_code_start_loc": [429], "fixing_code_end_loc": [437], "type": "CWE-119", "message": "Buffer overflow in the git_pkt_parse_line function in transports/smart_pkt.c in the Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to have unspecified impact via a crafted non-flush packet.", "other": {"cve": {"id": "CVE-2016-10128", "sourceIdentifier": "security@debian.org", "published": "2017-03-24T15:59:00.153", "lastModified": "2017-03-28T01:59:00.443", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the git_pkt_parse_line function in transports/smart_pkt.c in the Git Smart Protocol support in libgit2 before 0.24.6 and 0.25.x before 0.25.1 allows remote attackers to have unspecified impact via a crafted non-flush packet."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n git_pkt_parse_line en transports/smart_pkt.c en el soporte Git Smart Protocol en libgit2 en versiones anteriores a 0.24.6 y 0.25.x en versiones anteriores a 0.25.1 permite a atacantes remotos tener impacto no especificado a trav\u00e9s de un paquete non-flush manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.24.5", "matchCriteriaId": "6747DEC6-17F3-45F9-B98B-5161469D89F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:*:*:*:*:*:*:*", "matchCriteriaId": "157A6552-8A3B-42B7-8BA3-24B03BD7812E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "EB081C3A-79B4-48A9-B6C2-46641293244B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libgit2_project:libgit2:0.25.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "D0A1B2E8-B0EC-41B9-A8B2-DD6A0A8DF14C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00030.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00036.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2017-02/msg00072.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/10/5", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/01/11/6", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/95338", "source": "security@debian.org"}, {"url": "https://github.com/libgit2/libgit2/commit/4ac39c76c0153d1ee6889a0984c39e97731684b2", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libgit2/libgit2/commit/66e3774d279672ee51c3b54545a79d20d1ada834", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://libgit2.github.com/security/", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libgit2/libgit2/commit/4ac39c76c0153d1ee6889a0984c39e97731684b2"}}