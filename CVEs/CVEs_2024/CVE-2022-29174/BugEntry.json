{"buggy_code": ["/**\n * Module contaning functions for basic user operations: login, logout, setup, settings\n * @module frontend/express/libs/members\n * @example\n * var plugins = require('../../plugins/pluginManager.js'); //need for db\n * var countlyDb = plugins.dbConnection(countlyConfig); //get db connection\n * var membersUtility = require(\"./libs/members.js\");\n * membersUtility.db = countlyDB; //setting db before using any function\n *\n */\n\nvar authorize = require('./../../../api/utils/authorizer.js'); //for token validations\nvar common = require('./../../../api/utils/common.js');\nvar plugins = require('./../../../plugins/pluginManager.js');\nvar { getUserApps } = require('./../../../api/utils/rights.js');\nvar configs = require('./../config', 'dont-enclose');\nvar countlyMail = require('./../../../api/parts/mgmt/mail.js');\nvar countlyStats = require('./../../../api/parts/data/stats.js');\nvar request = require('request');\nvar url = require('url');\nvar crypto = require('crypto');\nvar argon2 = require('argon2');\n\nvar versionInfo = require('./../version.info'),\n    COUNTLY_TYPE = versionInfo.type;\n\n/** @lends module:frontend/express/libs/members */\nvar membersUtility = { };\n//Helper functions\n/**\n * @property {object} db - Data base connection. Needs to be set befoe callng any other function.\n */\nmembersUtility.db = null;\n/**\n * @property {object} countlyConfig - countly configuration object\n */\nmembersUtility.countlyConfig = configs;\nif (membersUtility.countlyConfig.web && membersUtility.countlyConfig.web.track === \"all\") {\n    membersUtility.countlyConfig.web.track = null;\n}\n\n/**\n * @property {object} emptyPermission - empty crud permission\n */\nmembersUtility.emptyPermission = {\n    \"permission\": {\n        \"c\": {},\n        \"r\": {},\n        \"u\": {},\n        \"d\": {},\n        \"_\": {\n            \"a\": [],\n            \"u\": [\n                []\n            ]\n        }\n    }\n};\n\n/** Checks remote configuration and sets variables to configuration object\n * @param {object} countlyConfigOrig - configuration settings object. Original(ar read from file)\n * @param {object} countlyConfig - contiguration. Changes if are done on this object.\n*/\nmembersUtility.recheckConfigs = function(countlyConfigOrig, countlyConfig) {\n    var checkUrl = \"https://count.ly/configurations/ce/tracking\";\n    if (COUNTLY_TYPE !== \"777a2bf527a18e0fffe22fb5b3e322e68d9c07a6\") {\n        checkUrl = \"https://count.ly/configurations/ee/tracking\";\n    }\n    if (!plugins.getConfig(\"api\").offline_mode) {\n        request(checkUrl, function(error, response, body) {\n            if (typeof body === \"string\") {\n                try {\n                    body = JSON.parse(body);\n                }\n                catch (ex) {\n                    body = null;\n                }\n            }\n            if (body) {\n                if (countlyConfigOrig.web.use_intercom && typeof body.intercom !== \"undefined\") {\n                    countlyConfig.web.use_intercom = body.intercom;\n                }\n                if (typeof countlyConfigOrig.web.track === \"undefined\" && typeof body.stats !== \"undefined\") {\n                    if (body.stats) {\n                        countlyConfig.web.track = null;\n                    }\n                    else {\n                        countlyConfig.web.track = \"none\";\n                    }\n                }\n            }\n        });\n    }\n};\nvar origConf = JSON.parse(JSON.stringify(membersUtility.countlyConfig));\nmembersUtility.recheckConfigs(origConf, membersUtility.countlyConfig);\n\n/**\n * Is hashed string argon2?\n * @param {string} hashedStr | argon2 hashed string\n * @returns {boolean} return true if string hashed by argon2\n */\nfunction isArgon2Hash(hashedStr) {\n    return hashedStr && hashedStr.includes(\"$argon2\");\n}\n\n/**\n* Verify argon2 hash string\n* @param {string} hashedStr - argon2 hashed string\n* @param {string} str - string for verify\n* @returns {promise} verify promise\n**/\nfunction verifyArgon2Hash(hashedStr, str) {\n    return argon2.verify(hashedStr, str);\n}\n\n/**\n* Create argon2 hash string\n* @param {string} str - string to hash\n* @returns {promise} hash promise\n**/\nfunction argon2Hash(str) {\n    return argon2.hash(str);\n}\n\n/**\n* Update user password to new sha512 hash\n* @param {string} id - id of the user document\n* @param {string} password - password to hash\n* @param {object} countlyDb  - data base object\n**/\nfunction updateUserPasswordToArgon2(id, password, countlyDb) {\n    countlyDb.collection('members').update({ _id: id}, { $set: { password: password}});\n}\n\n/**\n* Create sha1 hash string\n* @param {string} str - string to hash\n* @param {boolean} addSalt - should salt be added\n* @returns {string} hashed string\n**/\nfunction sha1Hash(str, addSalt) {\n    var salt = (addSalt) ? new Date().getTime() : \"\";\n    return crypto.createHmac('sha1', salt + \"\").update(str + \"\").digest('hex');\n}\n\n/**\n* Create sha512 hash string\n* @param {string} str - string to hash\n* @param {boolean} addSalt - should salt be added\n* @returns {string} hashed string\n**/\nfunction sha512Hash(str, addSalt) {\n    var salt = (addSalt) ? new Date().getTime() : \"\";\n    return crypto.createHmac('sha512', salt + \"\").update(str + \"\").digest('hex');\n}\n\n/**\n * Verify member for Argon2 Hash\n * @param {string} username | User name\n * @param {password} password | Password string\n * @param {object} countlyDb  - data base object\n * @param {Function} callback | Callback function\n */\nfunction verifyMemberArgon2Hash(username, password, countlyDb, callback) {\n    countlyDb.collection('members').findOne({$and: [{ $or: [ {\"username\": username}, {\"email\": username}]}]}, (err, member) => {\n        if (member) {\n            if (isArgon2Hash(member.password)) {\n                verifyArgon2Hash(member.password, password).then(match => {\n                    if (match) {\n                        callback(undefined, member);\n                    }\n                    else {\n                        callback(\"Password is wrong!\");\n                    }\n                }).catch(function() {\n                    callback(\"Password is wrong!\");\n                });\n            }\n            else {\n                var password_SHA1 = sha1Hash(password);\n                var password_SHA5 = sha512Hash(password);\n\n                if (member.password === password_SHA1 || member.password === password_SHA5) {\n                    argon2Hash(password).then(password_ARGON2 => {\n                        updateUserPasswordToArgon2(member._id, password_ARGON2, countlyDb);\n                        callback(undefined, member);\n                    }).catch(function() {\n                        callback(\"Password is wrong!\");\n                    });\n                }\n                else {\n                    callback(\"Password is wrong!\");\n                }\n            }\n        }\n        else {\n            callback(\"Username is wrong!\");\n        }\n    });\n}\n\n/**\n* Validate password based on configured settings\n* @param {string} password - password to validatePassword\n* @returns {vary} returns string if there is error, or false if everything is ok\n**/\nfunction validatePassword(password) {\n    if (password.length < plugins.getConfig(\"security\").password_min) {\n        return \"management-users.password.length\";\n    }\n    if (plugins.getConfig(\"security\").password_char && !/[A-Z]/.test(password)) {\n        return \"management-users.password.has-char\";\n    }\n    if (plugins.getConfig(\"security\").password_number && !/\\d/.test(password)) {\n        return \"management-users.password.has-number\";\n    }\n    if (plugins.getConfig(\"security\").password_symbol && !/[^A-Za-z\\d]/.test(password)) {\n        return \"management-users.password.has-special\";\n    }\n    return false;\n}\n/**\n * Function gets session timeout in ms.\n * @param {object} req - requets object\n * @returns {integer} Session timeout in ms.\n */\nvar getSessionTimeoutInMs = function(req) {\n    var myTimeoutValue = parseInt(plugins.getConfig(\"frontend\", req.session && req.session.settings).session_timeout, 10) * 1000 * 60;\n    //max value used by set timeout function\n    if (myTimeoutValue > 2147483647) {\n        myTimeoutValue = 1800000;\n    }//30 minutes\n    return myTimeoutValue;\n};\n\n/**\n* Sets variables for logged in session\n* @param {object} req - request object\n* @param {object} member - member object\n* @param {object} countlyDb  -data base reference\n* @param {function} callback - callback function, called after token and variables are set. Returns nothing.\n**/\nfunction setLoggedInVariables(req, member, countlyDb, callback) {\n    req.session.uid = member._id;\n    req.session.gadm = (member.global_admin === true);\n    req.session.email = member.email;\n    req.session.settings = member.settings;\n    var reuse = true;\n    if (req.session.temporary_token) {\n        reuse = false;\n    }\n\n    authorize.save({\n        db: countlyDb,\n        multi: true,\n        owner: req.session.uid,\n        tryReuse: reuse,\n        ttl: getSessionTimeoutInMs(req) / 1000,\n        purpose: \"LoggedInAuth\",\n        callback: function(err2, token) {\n            if (err2) {\n                console.log(err2);\n            }\n            if (token) {\n                req.session.auth_token = token;\n            }\n            callback();\n        }\n    });\n}\n\n/** Clears all inforamtion about user from session parameters. Used when logging ut user.\n* @param {object} req - request object\n* @param {object} res - response object\n*/\nmembersUtility.clearReqAndRes = function(req, res) {\n    if (req.session) {\n        req.session.uid = null;\n        req.session.gadm = null;\n        req.session.email = null;\n        req.session.settings = null;\n        res.clearCookie('uid');\n        res.clearCookie('gadm');\n        req.session.destroy(function() {});\n    }\n};\n\n/**\n* Verifies a user's credentials without logging in.\n*\n* @param {string} username - username or the email address of the user\n* @param {string} password - password\n* @param {function} callback - callback function.  First parameter in callback function is member object if logging in is successful.\n* @example\n*   membersUtility.verifyCredentials(username, password, function(member) {\n        if (member) {\n            // logged in\n        }\n        else {\n            // failed\n        }\n    });\n**/\nmembersUtility.verifyCredentials = function(username, password, callback) {\n    if (username && password) {\n        username = (username + \"\").trim();\n\n        var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n        password = password + secret;\n\n        verifyMemberArgon2Hash(username, password, membersUtility.db, (err, member) => {\n            if (member) {\n                callback(member);\n            }\n            else {\n                callback(undefined);\n            }\n        });\n    }\n    else {\n        callback(undefined);\n    }\n};\n\n/**\n* Update Stats for member.\n*\n* @param {object} member - member properties\n* @example\n*   membersUtility.updateStats(member );\n**/\nmembersUtility.updateStats = function(member) {\n    var countlyConfig = membersUtility.countlyConfig;\n\n    if ((!countlyConfig.web.track || countlyConfig.web.track === \"GA\" && member.global_admin || countlyConfig.web.track === \"noneGA\" && !member.global_admin) && !plugins.getConfig(\"api\").offline_mode) {\n        countlyStats.getUser(membersUtility.db, member, function(statsObj) {\n            const userApps = getUserApps(member);\n            var custom = {\n                apps: (userApps) ? userApps.length : 0,\n                platforms: {\"$addToSet\": statsObj[\"total-platforms\"]},\n                events: statsObj[\"total-events\"],\n                pushes: statsObj[\"total-msg-sent\"],\n                crashes: statsObj[\"total-crash-groups\"],\n                users: statsObj[\"total-users\"]\n            };\n            var date = new Date();\n            request({\n                uri: \"https://stats.count.ly/i\",\n                method: \"GET\",\n                timeout: 4E3,\n                qs: {\n                    device_id: member.email,\n                    app_key: \"386012020c7bf7fcb2f1edf215f1801d6146913f\",\n                    timestamp: Math.round(date.getTime() / 1000),\n                    hour: date.getHours(),\n                    dow: date.getDay(),\n                    user_details: JSON.stringify(\n                        {\n                            custom: custom\n                        }\n                    )\n                }\n            }, function() {});\n        });\n    }\n};\n\n/**\n* Tries to log in user based passed userame and password. Calls \"plugins\"\n* methods to notify successful and unsucessful logging in attempts. If\n* successful, sets all session variables and auth token. Passes the member\n* object to the callback if retrieved succesfully, but not necessarily logged\n* in succesfully i.e. a member object will still be returned even if the member\n* was locked. Also passes a boolean parameter to the callback indicating if the\n* login was succesful.\n*\n* @param {object} req - request object\n* @param {string} req.body.username - username\n* @param {string} req.body.password - password\n* @param {object} res - response object\n* @param {function} callback - callback function. First parameter in callback\n* function is member object, if it could be retrieved succesfully. Second\n* parameter is a boolean that is true when logged in succesfully.\n* @example\n*   membersUtility.login(req, res, function(member) {\n        if(member) {\n            // logged in\n        }\n        else {\n            // failed\n        }\n    });\n**/\n\nmembersUtility.login = function(req, res, callback) {\n    membersUtility.verifyCredentials(req.body.username, req.body.password, (member) => {\n        if (member === undefined || member.locked) {\n            plugins.callMethod(\"loginFailed\", {req: req, data: req.body});\n            callback(member, false);\n        }\n        else {\n            plugins.callMethod(\"loginSuccessful\", {req: req, data: member});\n\n            // update stats\n            membersUtility.updateStats(member);\n\n            req.session.regenerate(function() {\n                // will have a new session here\n                var update = {last_login: Math.round(new Date().getTime() / 1000)};\n                if (typeof member.password_changed === \"undefined\") {\n                    update.password_changed = Math.round(new Date().getTime() / 1000);\n                }\n                if (req.body.lang && req.body.lang !== member.lang) {\n                    update.lang = req.body.lang;\n                }\n\n                membersUtility.db.collection('members').update({_id: member._id}, {$set: update}, function() {});\n\n                if (parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10)) {\n                    req.session.expires = Date.now() + parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10) * 1000 * 60;\n                }\n                if (member.upgrade) {\n                    res.set({\n                        'Cache-Control': 'no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0',\n                        'Expires': '0',\n                        'Pragma': 'no-cache'\n                    });\n                }\n\n                setLoggedInVariables(req, member, membersUtility.db, function() {\n                    callback(member, true);\n                });\n            });\n        }\n    });\n};\n\n/**\n* Tries to log in user without verification for external authentication.\n* Similar behavior as the membersUtility.login just bypass the verification\n* as the user is already authenticated by external authentication mechanism\n* such as Active Directory, Azure AD or Ldap\n*\n* @param {object} req - request object\n* @param {string} req.body.username - username\n* @param {object} res - response object\n* @param {function} callback - callback function. First parameter in callback\n* function is member object, if it could be retrieved succesfully. Second\n* parameter is a boolean that is true when logged in succesfully.\n* @example\n*   membersUtility.loginWithExternalAuthentication(req, res, function(member) {\n        if(member) {\n            // logged in\n        }\n        else {\n            // failed\n        }\n    });\n**/\n\nmembersUtility.loginWithExternalAuthentication = function(req, res, callback) {\n    if (!req.body || !req.body.username) {\n        callback(undefined);\n    }\n\n    var username = (req.body.username + \"\").trim();\n\n    membersUtility.db.collection('members').findOne({username}, (err, member) => {\n        if (member === undefined || member.locked) {\n            plugins.callMethod(\"loginFailed\", {req: req, data: req.body});\n            callback(member, false);\n        }\n        else {\n            plugins.callMethod(\"loginSuccessful\", {req: req, data: member});\n\n            // update stats\n            membersUtility.updateStats(member);\n\n            req.session.regenerate(function() {\n                // will have a new session here\n                var update = {last_login: Math.round(new Date().getTime() / 1000)};\n\n                if (req.body.lang && req.body.lang !== member.lang) {\n                    update.lang = req.body.lang;\n                }\n\n                membersUtility.db.collection('members').update({_id: member._id}, {$set: update}, function() {});\n\n                if (parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10)) {\n                    req.session.expires = Date.now() + parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10) * 1000 * 60;\n                }\n                if (member.upgrade) {\n                    res.set({\n                        'Cache-Control': 'no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0',\n                        'Expires': '0',\n                        'Pragma': 'no-cache'\n                    });\n                }\n\n                setLoggedInVariables(req, member, membersUtility.db, function() {\n                    req.session.settings = member.settings;\n                    callback(member, true);\n                });\n            });\n        }\n    });\n};\n\n/**\n* Removes all other active sessions for user\n* @param {string} userId - id of the user for which to remove sessions\n* @param {string} my_token - current auth token\n* @param {string} my_session - current session id\n* @param {object} countlyDb  -data base reference\n**/\nfunction killOtherSessionsForUser(userId, my_token, my_session, countlyDb) {\n    countlyDb.collection('sessions_').find({\"session\": { $regex: userId }}).toArray(function(err, sessions) {\n        var delete_us = [];\n        if (sessions) {\n            for (var i = 0; i < sessions.length; i++) {\n                var parsed_data = \"\";\n                try {\n                    parsed_data = JSON.parse(sessions[i].session);\n                }\n                catch (error) {\n                    console.log(error);\n                }\n\n                if ((!my_session || sessions[i]._id !== my_session) && parsed_data && parsed_data.uid === userId) {\n                    delete_us.push(sessions[i]._id);\n                }\n            }\n            if (delete_us.length > 0) {\n                countlyDb.collection('sessions_').remove({'_id': {$in: delete_us}});\n            }\n        }\n    });\n    //delete other auth tokens with purpose:\"LoggedInAuth\"\n    if (my_token) {\n        countlyDb.collection('auth_tokens').remove({'owner': countlyDb.ObjectID(userId), 'purpose': \"LoggedInAuth\", '_id': {$ne: my_token}});\n    }\n    else {\n        countlyDb.collection('auth_tokens').remove({'owner': countlyDb.ObjectID(userId), 'purpose': \"LoggedInAuth\"});\n    }\n}\n\n/**\n* Logins user with token\n* @param {object} req - request object\n* @param {function} callback - callback function\n**/\nmembersUtility.loginWithToken = function(req, callback) {\n    var token = req.params.token;\n    var pathUrl = req.url.replace(membersUtility.countlyConfig.path, \"\");\n    var urlParts = url.parse(pathUrl, true);\n    var fullPath = urlParts.pathname;\n\n    authorize.verify_return({\n        db: membersUtility.db,\n        token: token,\n        req_path: fullPath,\n        return_data: true,\n        callback: function(valid) {\n            if (!valid) {\n                plugins.callMethod(\"tokenLoginFailed\", {req: req, data: {token: token}});\n                return callback(undefined);\n            }\n\n            membersUtility.db.collection('members').findOne({\"_id\": membersUtility.db.ObjectID(valid.owner)}, function(err, member) {\n                if (err || !member) {\n                    plugins.callMethod(\"tokenLoginFailed\", {req: req, data: {token: token, token_owner: valid.owner}});\n                    callback(undefined);\n                }\n                else {\n                    plugins.callMethod(\"tokenLoginSuccessful\", {req: req, data: {username: member.username}});\n                    if (valid.temporary) {\n                        req.session.temporary_token = true;\n                    }\n                    setLoggedInVariables(req, member, membersUtility.db, function() {\n                        req.session.settings = member.settings;\n                        callback(member);\n                    });\n                }\n            });\n        }\n    });\n};\n\n\n\n/**\n* Logs out user  -  clears session info for request and response object\n* @param {object} req - request object\n* @param {object} res - response object\n**/\nmembersUtility.logout = function(req, res) {\n    if (req.session) {\n        if (req.session.uid && req.session.email) {\n            plugins.callMethod(\"userLogout\", {req: req, data: {uid: req.session.uid, email: req.session.email, query: req.query}});\n        }\n        if (req.session.auth_token) {\n            membersUtility.db.collection(\"auth_tokens\").remove({_id: req.session.auth_token});\n\n            //louout also other users logged in with same credentials\n            if (!req.session.temporary_token) {\n                killOtherSessionsForUser(req.session.uid, null, null, membersUtility.db);\n            }\n            req.session.auth_token = null;\n        }\n        membersUtility.clearReqAndRes(req, res);\n    }\n};\n\n/**\n * Function to extend user session. Changes time when session expires and also extends token(if passed).\n * @param {object} req - request object\n * @param {string} req.session.auth_token - auth token\n*/\nmembersUtility.extendSession = function(req) {\n    req.session.expires = Date.now() + getSessionTimeoutInMs(req);\n    if (req.session.auth_token) {\n        var ChangeTime = getSessionTimeoutInMs(req);\n        if (ChangeTime > 0) {\n            authorize.extend_token({token: req.session.auth_token, db: membersUtility.db, extendTill: Date.now() + ChangeTime}, function(err) {\n                if (err) {\n                    console.log(err);\n                }\n            });\n        }\n        else { //changed to not expire\n            authorize.extend_token({token: req.session.auth_token, db: membersUtility.db, extendBy: 0}, function(err) {\n                if (err) {\n                    console.log(err);\n                }\n            });\n        }\n    }\n};\n\n/**\n * Sets up first user in Countly(if there is none). Req object is used to get mandatory variables from req.body and also there are variables set to have logged in session for new user.\n * @param {object} req - request object\n * @param {string} req.body.full_name - Full name. Mandatory.\n * @param {string} req.body.username - Username. Mandatory.\n * @param {string} req.body.password  - Password. Mandatory.\n * @param {string} req.body.email  - E-mail. Mandatory.\n * @param {function} callback  - Function with one return value - error (if there is one)\n * @example\n *   membersUtility.setup(req, res, countlyConfig, function(error) {\n *      if(error) {\n *          //there is error while setting up user\n *          // error === \"Wrong request parameters\" - not all mandatory parameters passed or there was error during creating user\n *         // error === \"User exists\" - There is already at least one user.\n *           // error === \".....\" - mongo error while getting user count.\n *      }\n *      else {\n *          //Success\n *      }\n *  });\n**/\n\nmembersUtility.setup = function(req, callback) {\n    membersUtility.db.collection('members').count(function(err, memberCount) {\n        if (!err && memberCount === 0) {\n            //check password\n            const argProps = {\n                'full_name': {\n                    'required': true,\n                    'type': 'String'\n                },\n                'username': {\n                    'required': true,\n                    'type': 'String'\n                },\n                'password': {\n                    'required': true,\n                    'type': 'String',\n                    'min-length': plugins.getConfig(\"security\").password_min,\n                    'has-number': plugins.getConfig(\"security\").password_number,\n                    'has-upchar': plugins.getConfig(\"security\").password_char,\n                    'has-special': plugins.getConfig(\"security\").password_symbol\n                },\n                'email': {\n                    'required': true,\n                    'type': 'String'\n                },\n            };\n            var memberCreateValidation = common.validateArgs(req.body, argProps, true);\n            if (!(req.body = memberCreateValidation.obj)) {\n                callback({\n                    message: memberCreateValidation.errors,\n                    passMinLen: plugins.getConfig(\"security\").password_min,\n                });\n                return;\n            }\n            var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n            argon2Hash(req.body.password + secret).then(password => {\n                req.body.email = (req.body.email + \"\").trim();\n                req.body.username = (req.body.username + \"\").trim();\n                var doc = {\n                    \"full_name\": req.body.full_name,\n                    \"username\": req.body.username,\n                    \"password\": password,\n                    \"email\": req.body.email,\n                    \"global_admin\": true,\n                    created_at: Math.floor(((new Date()).getTime()) / 1000),\n                    password_changed: Math.floor(((new Date()).getTime()) / 1000),\n                    permission: membersUtility.emptyPermission\n                };\n                if (req.body.lang) {\n                    doc.lang = req.body.lang;\n                }\n                crypto.randomBytes(48, function(errorBuff, buffer) {\n                    doc.api_key = common.md5Hash(buffer.toString('hex') + Math.random());\n                    membersUtility.db.collection('members').insert(doc, {safe: true}, function(err2, member) {\n                        member = member.ops;\n                        setLoggedInVariables(req, member[0], membersUtility.db, function() {\n                            req.session.install = true;\n                            callback();\n                        });\n                    });\n                });\n            }).catch(function() {\n                callback(\"Wrong request parameters\");\n            });\n        }\n        else if (err) {\n            callback(err);\n        }\n        else {\n            callback(\"User exists\");\n        }\n    });\n};\n\n/**\n * Function validates if email is not used by any other member.\n * @param {string} email - mandatory. E-mail to check\n * @param {function} callback -  function with one return value. Returns true if email is not used, false if taken.\n * @example\n * membersUtility.checkEmail(email, function(isFree) {\n *      if(isFree ===true) {\n *          //email is not taken\n *      }\n * });\n *\n *\n*/\nmembersUtility.checkEmail = function(email, callback) {\n    email = (email + \"\").trim();\n    membersUtility.db.collection('members').findOne({email: email}, function(err, member) {\n        if (member || err) {\n            callback(false);\n        }\n        else {\n            callback(true);\n        }\n    });\n};\n\n/**\n * Function validates if username is not used by any other member.\n * @param {string} username - mandatory. Username to check.\n * @param {function} callback -  function with one return value. Returns true if username is free, false if taken.\n * @example\n * membersUtility.checkUsername(username, function(isFree) {\n *      if(isFree ===true) {\n *          //username is not taken\n *      }\n * });\n *\n *\n*/\nmembersUtility.checkUsername = function(username, callback) {\n    username = (username + \"\").trim();\n    membersUtility.db.collection('members').findOne({username: username}, function(err, member) {\n        if (member || err) {\n            callback(false);\n        }\n        else {\n            callback(true);\n        }\n    });\n};\n\n/**\n * Sends user password reseting information to given e-mail.\n * @param {object} req - request object.\n * @param {string} req.body.email - mandatory. User email.\n * @param {string} req.body.lang - optional. Language.(default \"en\"  - english)\n * @param {function} callback  - function with one return value. Returns member object if successful.\n * @example\n * membersUtility.forgot(req, function(member) {\n *      if(member) {\n *         //member found\n *      }\n *      else {\n *         //e-mail not passed or user with this e-mail not found\n *      }\n * });\n*/\nmembersUtility.forgot = function(req, callback) {\n    if (!req || !req.body || !req.body.email) {\n        callback(undefined); //to be sure email is passed\n    }\n    else {\n        var email = (req.body.email + \"\").trim();\n        membersUtility.db.collection('members').findOne({\"email\": email}, function(err, member) {\n            if (member) {\n                var timestamp = Math.round(new Date().getTime() / 1000),\n                    prid = sha512Hash(member.username + member.full_name, timestamp);\n                member.lang = member.lang || req.body.lang || \"en\";\n                membersUtility.db.collection('password_reset').insert({\"prid\": prid, \"user_id\": member._id, \"timestamp\": timestamp}, {safe: true}, function() {\n                    countlyMail.sendPasswordResetInfo(member, prid);\n                    plugins.callMethod(\"passwordRequest\", {req: req, data: req.body}); //used in systemlogs\n                    callback(member);\n                });\n            }\n            else {\n                callback(undefined);\n            }\n        });\n    }\n};\n/**\n * Resets user password\n * @param {object} req - request object\n * @param {string} req.body.password - mandatory. new password.\n * @param {string} req.body.again - mandatory.\n * @param {string} req.body.prid - mandatory. Password reset id.\n * @param {function} callback - function with one two return values. First one is password validation error(false if no error) and second one is member object if reset is sucessful.\n*/\nmembersUtility.reset = function(req, callback) {\n    var result = validatePassword(req.body.password);\n    if (result === false) {\n        if (req.body.password && req.body.again && req.body.prid) {\n            req.body.prid += \"\";\n            var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n            argon2Hash(req.body.password + secret).then(password => {\n                membersUtility.db.collection('password_reset').findOne({ prid: req.body.prid }, function(err, passwordReset) {\n                    membersUtility.db.collection('members').findAndModify({ _id: passwordReset.user_id }, {}, { '$set': { \"password\": password } }, function(err2, member) {\n                        member = member && member.ok ? member.value : null;\n                        killOtherSessionsForUser(passwordReset.user_id + \"\", null, null, membersUtility.db);\n                        plugins.callMethod(\"passwordReset\", { req: req, data: member }); //only req, used for systemolgs\n                        callback(false, member);\n                    });\n                    membersUtility.db.collection('password_reset').remove({ prid: req.body.prid }, function() { });\n                });\n            }).catch(function() {\n                callback(false, undefined);\n            });\n        }\n        else {\n            callback(false, undefined);\n        }\n    }\n    else {\n        callback(result, undefined);\n    }\n};\n\n/**\n * Saves changed user settings\n * @param {object} req - request object\n * @param {string} req.body.username - mandatory - username (current or new one to chacge to)\n * @param {string} req.body.api_key - mandatory. User API KEY (current or the one to change to)\n * @param {string} req.body.old_pwd  - Old password. Optional. Passed if changing password.\n * @param {string} req.body.new_pwd  - New password. Optional. Passed if changing password.\n * @param {function} callback  - function with two return values. First one is true - if successful (false if not sucessful) and the second one - error message(in some cases).\n*/\nmembersUtility.settings = function(req, callback) {\n    var updatedUser = {};\n    if (req.body.username && req.body.api_key) {\n        if (req.body.api_key.length !== 32) {\n            callback(false, \"user-settings.api-key-length\");\n            return;\n        }\n        if (!req.body.api_key.match(/^[0-9a-zA-Z]+([0-9]+)([a-z]+)[0-9a-zA-Z]+$/)) {\n            callback(false, \"user-settings.api-key-restrict\");\n            return;\n        }\n\n        req.body.username = (req.body.username + \"\").trim();\n        if (req.body.member_image && req.body.member_image !== \"delete\") {\n            updatedUser.member_image = req.body.member_image;\n        }\n        if (req.body.member_image === \"delete\") {\n            updatedUser.member_image = \"\";\n        }\n        updatedUser.username = req.body.username;\n        updatedUser.api_key = req.body.api_key;\n        if (req.body.lang) {\n            updatedUser.lang = req.body.lang;\n        }\n        var change = JSON.parse(JSON.stringify(updatedUser));\n        membersUtility.db.collection('members').findOne({\"_id\": membersUtility.db.ObjectID(req.session.uid + \"\")}, function(err, member) {\n            if (err || !member) {\n                callback(false);\n                return;\n            }\n            membersUtility.db.collection('members').findOne({username: req.body.username}, async function(err2, user) {\n                if (err) {\n                    callback(false);\n                    return;\n                }\n                member.change = change;\n                if ((user && user._id + \"\" !== req.session.uid + \"\") || err2) {\n                    callback(false, \"username-exists\");\n                }\n                else {\n                    var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n                    req.body.new_pwd = req.body.new_pwd + secret;\n                    if (req.body.old_pwd && req.body.old_pwd.length) {\n                        if (isArgon2Hash(member.password)) {\n                            var match;\n                            try {\n                                match = await verifyArgon2Hash(member.password, req.body.old_pwd);\n                            }\n                            catch (ex) {\n                                match = null;\n                            }\n                            if (!match) {\n                                return callback(false, \"user-settings.old-password-not-match\");\n                            }\n                        }\n                        else {\n                            var password_SHA1 = sha1Hash(req.body.old_pwd);\n                            var password_SHA5 = sha512Hash(req.body.old_pwd);\n\n                            if (member.password === password_SHA1 || member.password === password_SHA5) {\n                                argon2Hash(req.body.old_pwd).then(password_ARGON2 => {\n                                    updateUserPasswordToArgon2(member._id, password_ARGON2, membersUtility.db);\n                                }).catch(function() {\n                                    console.log(\"Problem updating password\");\n                                });\n                            }\n                            else {\n                                return callback(false, \"user-settings.old-password-not-match\");\n                            }\n                        }\n                        // eslint-disable-next-line require-atomic-updates\n                        member.change.password = true;\n                        try {\n                            var newPassword_SHA5 = sha512Hash(req.body.new_pwd),\n                                newPassword_ARGON2 = await argon2Hash(req.body.new_pwd);\n                        }\n                        catch (ex) {\n                            callback(false);\n                            return;\n                        }\n\n                        let isUsedBefore = false;\n                        if (plugins.getConfig('security').password_rotation > 0) {\n                            // Check if used before\n                            const promises = [];\n                            const passwordHistory = member.password_history || [];\n\n                            for (let i = 0; i < passwordHistory.length; i++) {\n                                const oldPassword = passwordHistory[i];\n                                if (isArgon2Hash(oldPassword)) {\n                                    promises.push(verifyArgon2Hash(oldPassword, req.body.new_pwd));\n                                }\n                                else if (oldPassword === newPassword_SHA5) {\n                                    isUsedBefore = true;\n                                    break;\n                                }\n                            }\n\n                            if (!isUsedBefore && promises.length > 0) {\n                                try {\n                                    const promiseResults = await Promise.all(promises);\n                                    isUsedBefore = promiseResults.some(x => x === true);\n                                }\n                                catch (ex) {\n                                    callback(false);\n                                    return;\n                                }\n                            }\n                        }\n\n                        if (req.body.new_pwd !== req.body.old_pwd && !isUsedBefore) {\n                            var passRes = validatePassword(req.body.new_pwd);\n                            if (passRes === false) {\n                                updatedUser.password = newPassword_ARGON2;\n                                updatedUser.password_changed = Math.round(new Date().getTime() / 1000);\n                                membersUtility.db.collection('members').update({\"_id\": membersUtility.db.ObjectID(req.session.uid + \"\")}, {'$set': updatedUser, $push: {password_history: {$each: [newPassword_ARGON2], $slice: -parseInt(plugins.getConfig('security').password_rotation)}}}, {safe: true}, function(err3, result) {\n                                    if (result && result.result && result.result.ok && result.result.nModified > 0 && !err3) {\n                                        killOtherSessionsForUser(req.session.uid, req.session.auth_token, req.sessionID, membersUtility.db);\n                                        plugins.callMethod(\"userSettings\", {req: req, data: member});\n                                        callback(true, updatedUser.password_changed + \"\");\n                                    }\n                                    else {\n                                        callback(false, \"user-settings.old-password-not-match\");\n                                        return;\n                                    }\n                                });\n                            }\n                            else {\n                                callback(false, passRes);\n                            }\n                        }\n                        else {\n                            callback(false, \"user-settings.password-not-old\");\n                        }\n                    }\n                    else {\n                        membersUtility.db.collection('members').update({\"_id\": membersUtility.db.ObjectID(req.session.uid + \"\")}, {'$set': updatedUser}, {safe: true}, function(err3, result) {\n                            if (result && !err3) {\n                                plugins.callMethod(\"userSettings\", {req: req, data: member});\n                                callback(true);\n                            }\n                            else {\n                                callback(false);\n                            }\n                        });\n                    }\n                }\n            });\n        });\n    }\n    else {\n        callback(false);\n        return;\n    }\n};\n\n/**\n * Searches for a user with the given username/email. Useful for the input from the login prompt.\n * @param {string} input - username or the email address of the user we are looking for\n * @param {function} callback - function with one parameter, the member object if a user is found, undefined otherwise\n*/\nmembersUtility.findByUsernameOrEmail = function(input, callback) {\n    input = (input + \"\").trim();\n    membersUtility.db.collection('members').findOne({$or: [{username: input}, {email: input}]}, function(err, member) {\n        if (err) {\n            console.log(`Database error searching for user: ${err}`);\n        }\n        callback(member);\n    });\n};\n\n/**\n * Find Members\n * @param {Object} query query\n * @returns {Object[]} list of members\n*/\nmembersUtility.findMembers = async function(query = {}) {\n    return new Promise((resolve, reject) => {\n        this.db.collection('members').find(query).toArray((err, members) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(members);\n            }\n        });\n    });\n};\n\n/**\n * Update Member\n * @param {Object} query query\n * @param {Object} data data to update\n * @param {boolean} upsert upsert\n * @returns {Object} list of members\n*/\nmembersUtility.updateMember = async function(query = {}, data = {}, upsert = true) {\n    return new Promise((resolve, reject) => {\n        this.db.collection('members').update(query, { $set: data }, { upsert }, (err) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(data);\n            }\n        });\n    });\n};\n\n/**\n * Remove Members\n * @param {Object} query query\n * @returns {Object[]} list of members\n*/\nmembersUtility.removeMembers = async function(query = {}) {\n    return new Promise((resolve, reject) => {\n        if (!Object.keys(query).length) {\n            return reject('Invalid query to remove members');\n        }\n\n        this.db.collection('members').remove(query, (err, response) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    });\n};\n\n/**\n * Create User for external authentication provider\n * @method createMember\n * @param {Object} data user data\n * @param {string} provider auth provider\n * @param {boolean} deleteDuplicate delete duplicate\n * @returns {Promise<any>} created or updated user data\n*/\nmembersUtility.createMember = async function(data, provider = '', deleteDuplicate = false) {\n    let user = {};\n    if (!data || !Object.keys(data).length) {\n        throw new Error('Invalid user data provided');\n    }\n    user._id = data._id || data.id || data.sub || data.username;\n    user.email = data.email || '';\n    user.username = data.username || data.email;\n    user.full_name = data.full_name || data.name || `${data.firstName} ${data.lastName}` || \"\";\n    user.global_admin = data.global_admin || false;\n    user.locked = (typeof data.locked !== \"undefined\") ? data.locked : false;\n    user.provider = provider;\n\n    // can be deprecated after all data migrated to provider property\n    user.isAD = (provider === 'ad' || provider === 'azure');\n    user.isCognito = provider === 'cognito';\n\n    user.created_at = data.created_at || Math.floor(((new Date()).getTime()) / 1000);\n\n    user.admin_of = data.admin_of || [];\n    user.user_of = data.user_of || [];\n    user.restrict = data.restrict || [];\n    user.app_restrict = data.app_restrict || {};\n    user.permission = data.permission || membersUtility.emptyPermission;\n\n    if (data.admin_of && data.admin_of.length) {\n        user.user_of = [...new Set([...data.admin_of, ...data.user_of])];\n    }\n\n    if (data.group_id && data.group_id.length) {\n        user.group_id = data.group_id;\n    }\n\n    // legacy rbac\n    if (data.marketing_of && data.marketing_of.length) {\n        user.admin_of.push(...data.marketing_of);\n    }\n\n    const buffer = crypto.randomBytes(48);\n    user.api_key = data.api_key || common.md5Hash(buffer.toString('hex') + Math.random());\n    user.password = data.password || common.md5Hash(data.api_key);\n\n    // push approver permission\n    user.approver = !!data.approver;\n    user.approver_bypass = !!data.approver_bypass;\n\n    const query = user.email\n        ? {\n            $or: [\n                { _id: user._id },\n                { email: user.email }\n            ]\n        }\n        : { _id: user._id };\n\n    try {\n        const existingMembers = await membersUtility.findMembers(query);\n        if (deleteDuplicate && (existingMembers.length >= 2 || (existingMembers.length === 1 && existingMembers[0]._id !== user._id))) {\n            await membersUtility.removeMembers(query);\n        }\n\n        const memberData = await membersUtility.updateMember(query, user, true);\n\n        return memberData;\n    }\n    catch (error) {\n        console.error(`create member error ${provider} ${error.message}`, error);\n        throw new Error(error);\n    }\n};\n\n/**\n * Merge permission objects\n * @method mergePermissions\n * @param {object} current - current permission object\n * @param {object} addition - permission object to merge\n */\nmembersUtility.mergePermissions = (current, addition) => {\n    var crud = {\"c\": true, \"r\": true, \"u\": true, \"d\": true};\n    for (var p in addition) {\n        //permission does not exist yet, just copy it\n        if (!current[p]) {\n            current[p] = addition[p];\n        }\n        else if (crud[p]) {\n            //iterating through the apps\n            if (addition[p]) {\n                if (!current[p]) {\n                    current[p] = {};\n                }\n                for (var app in addition[p]) {\n                    if (addition[p][app]) {\n                        if (!current[p][app]) {\n                            current[p][app] = {};\n                        }\n                        if (addition[p][app].all) {\n                            current[p][app].all = true;\n                        }\n                        if (addition[p][app].allowed) {\n                            current[p][app].allowed = current[p][app].allowed || {};\n                            for (var feat in addition[p][app].allowed) {\n                                if (addition[p][app].allowed[feat]) {\n                                    current[p][app].allowed[feat] = true;\n                                }\n                                else if (typeof current[p][app].allowed[feat] === \"undefined\") {\n                                    current[p][app].allowed[feat] = addition[p][app].allowed[feat];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (p === \"_\") {\n            //merge admin by merging arrays\n            if (addition[p].a) {\n                if (!current[p].a) {\n                    current[p].a = [];\n                }\n                current[p].a = [...(new Set([...current[p].a, ...addition[p].a]))];\n            }\n            if (addition[p].u) {\n                if (!current[p].u) {\n                    current[p].u = [];\n                }\n                current[p].u = [...(new Set([...current[p].u, ...addition[p].u]))];\n            }\n        }\n    }\n};\n\nmodule.exports = membersUtility;"], "fixing_code": ["/**\n * Module contaning functions for basic user operations: login, logout, setup, settings\n * @module frontend/express/libs/members\n * @example\n * var plugins = require('../../plugins/pluginManager.js'); //need for db\n * var countlyDb = plugins.dbConnection(countlyConfig); //get db connection\n * var membersUtility = require(\"./libs/members.js\");\n * membersUtility.db = countlyDB; //setting db before using any function\n *\n */\n\nvar authorize = require('./../../../api/utils/authorizer.js'); //for token validations\nvar common = require('./../../../api/utils/common.js');\nvar plugins = require('./../../../plugins/pluginManager.js');\nvar { getUserApps } = require('./../../../api/utils/rights.js');\nvar configs = require('./../config', 'dont-enclose');\nvar countlyMail = require('./../../../api/parts/mgmt/mail.js');\nvar countlyStats = require('./../../../api/parts/data/stats.js');\nvar request = require('request');\nvar url = require('url');\nvar crypto = require('crypto');\nvar argon2 = require('argon2');\n\nvar versionInfo = require('./../version.info'),\n    COUNTLY_TYPE = versionInfo.type;\n\n/** @lends module:frontend/express/libs/members */\nvar membersUtility = { };\n//Helper functions\n/**\n * @property {object} db - Data base connection. Needs to be set befoe callng any other function.\n */\nmembersUtility.db = null;\n/**\n * @property {object} countlyConfig - countly configuration object\n */\nmembersUtility.countlyConfig = configs;\nif (membersUtility.countlyConfig.web && membersUtility.countlyConfig.web.track === \"all\") {\n    membersUtility.countlyConfig.web.track = null;\n}\n\n/**\n * @property {object} emptyPermission - empty crud permission\n */\nmembersUtility.emptyPermission = {\n    \"permission\": {\n        \"c\": {},\n        \"r\": {},\n        \"u\": {},\n        \"d\": {},\n        \"_\": {\n            \"a\": [],\n            \"u\": [\n                []\n            ]\n        }\n    }\n};\n\n/** Checks remote configuration and sets variables to configuration object\n * @param {object} countlyConfigOrig - configuration settings object. Original(ar read from file)\n * @param {object} countlyConfig - contiguration. Changes if are done on this object.\n*/\nmembersUtility.recheckConfigs = function(countlyConfigOrig, countlyConfig) {\n    var checkUrl = \"https://count.ly/configurations/ce/tracking\";\n    if (COUNTLY_TYPE !== \"777a2bf527a18e0fffe22fb5b3e322e68d9c07a6\") {\n        checkUrl = \"https://count.ly/configurations/ee/tracking\";\n    }\n    if (!plugins.getConfig(\"api\").offline_mode) {\n        request(checkUrl, function(error, response, body) {\n            if (typeof body === \"string\") {\n                try {\n                    body = JSON.parse(body);\n                }\n                catch (ex) {\n                    body = null;\n                }\n            }\n            if (body) {\n                if (countlyConfigOrig.web.use_intercom && typeof body.intercom !== \"undefined\") {\n                    countlyConfig.web.use_intercom = body.intercom;\n                }\n                if (typeof countlyConfigOrig.web.track === \"undefined\" && typeof body.stats !== \"undefined\") {\n                    if (body.stats) {\n                        countlyConfig.web.track = null;\n                    }\n                    else {\n                        countlyConfig.web.track = \"none\";\n                    }\n                }\n            }\n        });\n    }\n};\nvar origConf = JSON.parse(JSON.stringify(membersUtility.countlyConfig));\nmembersUtility.recheckConfigs(origConf, membersUtility.countlyConfig);\n\n/**\n * Is hashed string argon2?\n * @param {string} hashedStr | argon2 hashed string\n * @returns {boolean} return true if string hashed by argon2\n */\nfunction isArgon2Hash(hashedStr) {\n    return hashedStr && hashedStr.includes(\"$argon2\");\n}\n\n/**\n* Verify argon2 hash string\n* @param {string} hashedStr - argon2 hashed string\n* @param {string} str - string for verify\n* @returns {promise} verify promise\n**/\nfunction verifyArgon2Hash(hashedStr, str) {\n    return argon2.verify(hashedStr, str);\n}\n\n/**\n* Create argon2 hash string\n* @param {string} str - string to hash\n* @returns {promise} hash promise\n**/\nfunction argon2Hash(str) {\n    return argon2.hash(str);\n}\n\n/**\n* Update user password to new sha512 hash\n* @param {string} id - id of the user document\n* @param {string} password - password to hash\n* @param {object} countlyDb  - data base object\n**/\nfunction updateUserPasswordToArgon2(id, password, countlyDb) {\n    countlyDb.collection('members').update({ _id: id}, { $set: { password: password}});\n}\n\n/**\n* Create sha1 hash string\n* @param {string} str - string to hash\n* @param {boolean} addSalt - should salt be added\n* @returns {string} hashed string\n**/\nfunction sha1Hash(str, addSalt) {\n    var salt = (addSalt) ? new Date().getTime() : \"\";\n    return crypto.createHmac('sha1', salt + \"\").update(str + \"\").digest('hex');\n}\n\n/**\n* Create sha512 hash string\n* @param {string} str - string to hash\n* @param {boolean} addSalt - should salt be added\n* @returns {string} hashed string\n**/\nfunction sha512Hash(str, addSalt) {\n    var salt = (addSalt) ? new Date().getTime() : \"\";\n    return crypto.createHmac('sha512', salt + \"\").update(str + \"\").digest('hex');\n}\n\n/**\n * Verify member for Argon2 Hash\n * @param {string} username | User name\n * @param {password} password | Password string\n * @param {object} countlyDb  - data base object\n * @param {Function} callback | Callback function\n */\nfunction verifyMemberArgon2Hash(username, password, countlyDb, callback) {\n    countlyDb.collection('members').findOne({$and: [{ $or: [ {\"username\": username}, {\"email\": username}]}]}, (err, member) => {\n        if (member) {\n            if (isArgon2Hash(member.password)) {\n                verifyArgon2Hash(member.password, password).then(match => {\n                    if (match) {\n                        callback(undefined, member);\n                    }\n                    else {\n                        callback(\"Password is wrong!\");\n                    }\n                }).catch(function() {\n                    callback(\"Password is wrong!\");\n                });\n            }\n            else {\n                var password_SHA1 = sha1Hash(password);\n                var password_SHA5 = sha512Hash(password);\n\n                if (member.password === password_SHA1 || member.password === password_SHA5) {\n                    argon2Hash(password).then(password_ARGON2 => {\n                        updateUserPasswordToArgon2(member._id, password_ARGON2, countlyDb);\n                        callback(undefined, member);\n                    }).catch(function() {\n                        callback(\"Password is wrong!\");\n                    });\n                }\n                else {\n                    callback(\"Password is wrong!\");\n                }\n            }\n        }\n        else {\n            callback(\"Username is wrong!\");\n        }\n    });\n}\n\n/**\n* Validate password based on configured settings\n* @param {string} password - password to validatePassword\n* @returns {vary} returns string if there is error, or false if everything is ok\n**/\nfunction validatePassword(password) {\n    if (password.length < plugins.getConfig(\"security\").password_min) {\n        return \"management-users.password.length\";\n    }\n    if (plugins.getConfig(\"security\").password_char && !/[A-Z]/.test(password)) {\n        return \"management-users.password.has-char\";\n    }\n    if (plugins.getConfig(\"security\").password_number && !/\\d/.test(password)) {\n        return \"management-users.password.has-number\";\n    }\n    if (plugins.getConfig(\"security\").password_symbol && !/[^A-Za-z\\d]/.test(password)) {\n        return \"management-users.password.has-special\";\n    }\n    return false;\n}\n/**\n * Function gets session timeout in ms.\n * @param {object} req - requets object\n * @returns {integer} Session timeout in ms.\n */\nvar getSessionTimeoutInMs = function(req) {\n    var myTimeoutValue = parseInt(plugins.getConfig(\"frontend\", req.session && req.session.settings).session_timeout, 10) * 1000 * 60;\n    //max value used by set timeout function\n    if (myTimeoutValue > 2147483647) {\n        myTimeoutValue = 1800000;\n    }//30 minutes\n    return myTimeoutValue;\n};\n\n/**\n* Sets variables for logged in session\n* @param {object} req - request object\n* @param {object} member - member object\n* @param {object} countlyDb  -data base reference\n* @param {function} callback - callback function, called after token and variables are set. Returns nothing.\n**/\nfunction setLoggedInVariables(req, member, countlyDb, callback) {\n    req.session.uid = member._id;\n    req.session.gadm = (member.global_admin === true);\n    req.session.email = member.email;\n    req.session.settings = member.settings;\n    var reuse = true;\n    if (req.session.temporary_token) {\n        reuse = false;\n    }\n\n    authorize.save({\n        db: countlyDb,\n        multi: true,\n        owner: req.session.uid,\n        tryReuse: reuse,\n        ttl: getSessionTimeoutInMs(req) / 1000,\n        purpose: \"LoggedInAuth\",\n        callback: function(err2, token) {\n            if (err2) {\n                console.log(err2);\n            }\n            if (token) {\n                req.session.auth_token = token;\n            }\n            callback();\n        }\n    });\n}\n\n/** Clears all inforamtion about user from session parameters. Used when logging ut user.\n* @param {object} req - request object\n* @param {object} res - response object\n*/\nmembersUtility.clearReqAndRes = function(req, res) {\n    if (req.session) {\n        req.session.uid = null;\n        req.session.gadm = null;\n        req.session.email = null;\n        req.session.settings = null;\n        res.clearCookie('uid');\n        res.clearCookie('gadm');\n        req.session.destroy(function() {});\n    }\n};\n\n/**\n* Verifies a user's credentials without logging in.\n*\n* @param {string} username - username or the email address of the user\n* @param {string} password - password\n* @param {function} callback - callback function.  First parameter in callback function is member object if logging in is successful.\n* @example\n*   membersUtility.verifyCredentials(username, password, function(member) {\n        if (member) {\n            // logged in\n        }\n        else {\n            // failed\n        }\n    });\n**/\nmembersUtility.verifyCredentials = function(username, password, callback) {\n    if (username && password) {\n        username = (username + \"\").trim();\n\n        var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n        password = password + secret;\n\n        verifyMemberArgon2Hash(username, password, membersUtility.db, (err, member) => {\n            if (member) {\n                callback(member);\n            }\n            else {\n                callback(undefined);\n            }\n        });\n    }\n    else {\n        callback(undefined);\n    }\n};\n\n/**\n* Update Stats for member.\n*\n* @param {object} member - member properties\n* @example\n*   membersUtility.updateStats(member );\n**/\nmembersUtility.updateStats = function(member) {\n    var countlyConfig = membersUtility.countlyConfig;\n\n    if ((!countlyConfig.web.track || countlyConfig.web.track === \"GA\" && member.global_admin || countlyConfig.web.track === \"noneGA\" && !member.global_admin) && !plugins.getConfig(\"api\").offline_mode) {\n        countlyStats.getUser(membersUtility.db, member, function(statsObj) {\n            const userApps = getUserApps(member);\n            var custom = {\n                apps: (userApps) ? userApps.length : 0,\n                platforms: {\"$addToSet\": statsObj[\"total-platforms\"]},\n                events: statsObj[\"total-events\"],\n                pushes: statsObj[\"total-msg-sent\"],\n                crashes: statsObj[\"total-crash-groups\"],\n                users: statsObj[\"total-users\"]\n            };\n            var date = new Date();\n            request({\n                uri: \"https://stats.count.ly/i\",\n                method: \"GET\",\n                timeout: 4E3,\n                qs: {\n                    device_id: member.email,\n                    app_key: \"386012020c7bf7fcb2f1edf215f1801d6146913f\",\n                    timestamp: Math.round(date.getTime() / 1000),\n                    hour: date.getHours(),\n                    dow: date.getDay(),\n                    user_details: JSON.stringify(\n                        {\n                            custom: custom\n                        }\n                    )\n                }\n            }, function() {});\n        });\n    }\n};\n\n/**\n* Tries to log in user based passed userame and password. Calls \"plugins\"\n* methods to notify successful and unsucessful logging in attempts. If\n* successful, sets all session variables and auth token. Passes the member\n* object to the callback if retrieved succesfully, but not necessarily logged\n* in succesfully i.e. a member object will still be returned even if the member\n* was locked. Also passes a boolean parameter to the callback indicating if the\n* login was succesful.\n*\n* @param {object} req - request object\n* @param {string} req.body.username - username\n* @param {string} req.body.password - password\n* @param {object} res - response object\n* @param {function} callback - callback function. First parameter in callback\n* function is member object, if it could be retrieved succesfully. Second\n* parameter is a boolean that is true when logged in succesfully.\n* @example\n*   membersUtility.login(req, res, function(member) {\n        if(member) {\n            // logged in\n        }\n        else {\n            // failed\n        }\n    });\n**/\n\nmembersUtility.login = function(req, res, callback) {\n    membersUtility.verifyCredentials(req.body.username, req.body.password, (member) => {\n        if (member === undefined || member.locked) {\n            plugins.callMethod(\"loginFailed\", {req: req, data: req.body});\n            callback(member, false);\n        }\n        else {\n            plugins.callMethod(\"loginSuccessful\", {req: req, data: member});\n\n            // update stats\n            membersUtility.updateStats(member);\n\n            req.session.regenerate(function() {\n                // will have a new session here\n                var update = {last_login: Math.round(new Date().getTime() / 1000)};\n                if (typeof member.password_changed === \"undefined\") {\n                    update.password_changed = Math.round(new Date().getTime() / 1000);\n                }\n                if (req.body.lang && req.body.lang !== member.lang) {\n                    update.lang = req.body.lang;\n                }\n\n                membersUtility.db.collection('members').update({_id: member._id}, {$set: update}, function() {});\n\n                if (parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10)) {\n                    req.session.expires = Date.now() + parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10) * 1000 * 60;\n                }\n                if (member.upgrade) {\n                    res.set({\n                        'Cache-Control': 'no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0',\n                        'Expires': '0',\n                        'Pragma': 'no-cache'\n                    });\n                }\n\n                setLoggedInVariables(req, member, membersUtility.db, function() {\n                    callback(member, true);\n                });\n            });\n        }\n    });\n};\n\n/**\n* Tries to log in user without verification for external authentication.\n* Similar behavior as the membersUtility.login just bypass the verification\n* as the user is already authenticated by external authentication mechanism\n* such as Active Directory, Azure AD or Ldap\n*\n* @param {object} req - request object\n* @param {string} req.body.username - username\n* @param {object} res - response object\n* @param {function} callback - callback function. First parameter in callback\n* function is member object, if it could be retrieved succesfully. Second\n* parameter is a boolean that is true when logged in succesfully.\n* @example\n*   membersUtility.loginWithExternalAuthentication(req, res, function(member) {\n        if(member) {\n            // logged in\n        }\n        else {\n            // failed\n        }\n    });\n**/\n\nmembersUtility.loginWithExternalAuthentication = function(req, res, callback) {\n    if (!req.body || !req.body.username) {\n        callback(undefined);\n    }\n\n    var username = (req.body.username + \"\").trim();\n\n    membersUtility.db.collection('members').findOne({username}, (err, member) => {\n        if (member === undefined || member.locked) {\n            plugins.callMethod(\"loginFailed\", {req: req, data: req.body});\n            callback(member, false);\n        }\n        else {\n            plugins.callMethod(\"loginSuccessful\", {req: req, data: member});\n\n            // update stats\n            membersUtility.updateStats(member);\n\n            req.session.regenerate(function() {\n                // will have a new session here\n                var update = {last_login: Math.round(new Date().getTime() / 1000)};\n\n                if (req.body.lang && req.body.lang !== member.lang) {\n                    update.lang = req.body.lang;\n                }\n\n                membersUtility.db.collection('members').update({_id: member._id}, {$set: update}, function() {});\n\n                if (parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10)) {\n                    req.session.expires = Date.now() + parseInt(plugins.getConfig(\"frontend\", member.settings).session_timeout, 10) * 1000 * 60;\n                }\n                if (member.upgrade) {\n                    res.set({\n                        'Cache-Control': 'no-cache, private, no-store, must-revalidate, max-stale=0, post-check=0, pre-check=0',\n                        'Expires': '0',\n                        'Pragma': 'no-cache'\n                    });\n                }\n\n                setLoggedInVariables(req, member, membersUtility.db, function() {\n                    req.session.settings = member.settings;\n                    callback(member, true);\n                });\n            });\n        }\n    });\n};\n\n/**\n* Removes all other active sessions for user\n* @param {string} userId - id of the user for which to remove sessions\n* @param {string} my_token - current auth token\n* @param {string} my_session - current session id\n* @param {object} countlyDb  -data base reference\n**/\nfunction killOtherSessionsForUser(userId, my_token, my_session, countlyDb) {\n    countlyDb.collection('sessions_').find({\"session\": { $regex: userId }}).toArray(function(err, sessions) {\n        var delete_us = [];\n        if (sessions) {\n            for (var i = 0; i < sessions.length; i++) {\n                var parsed_data = \"\";\n                try {\n                    parsed_data = JSON.parse(sessions[i].session);\n                }\n                catch (error) {\n                    console.log(error);\n                }\n\n                if ((!my_session || sessions[i]._id !== my_session) && parsed_data && parsed_data.uid === userId) {\n                    delete_us.push(sessions[i]._id);\n                }\n            }\n            if (delete_us.length > 0) {\n                countlyDb.collection('sessions_').remove({'_id': {$in: delete_us}});\n            }\n        }\n    });\n    //delete other auth tokens with purpose:\"LoggedInAuth\"\n    if (my_token) {\n        countlyDb.collection('auth_tokens').remove({'owner': countlyDb.ObjectID(userId), 'purpose': \"LoggedInAuth\", '_id': {$ne: my_token}});\n    }\n    else {\n        countlyDb.collection('auth_tokens').remove({'owner': countlyDb.ObjectID(userId), 'purpose': \"LoggedInAuth\"});\n    }\n}\n\n/**\n* Logins user with token\n* @param {object} req - request object\n* @param {function} callback - callback function\n**/\nmembersUtility.loginWithToken = function(req, callback) {\n    var token = req.params.token;\n    var pathUrl = req.url.replace(membersUtility.countlyConfig.path, \"\");\n    var urlParts = url.parse(pathUrl, true);\n    var fullPath = urlParts.pathname;\n\n    authorize.verify_return({\n        db: membersUtility.db,\n        token: token,\n        req_path: fullPath,\n        return_data: true,\n        callback: function(valid) {\n            if (!valid) {\n                plugins.callMethod(\"tokenLoginFailed\", {req: req, data: {token: token}});\n                return callback(undefined);\n            }\n\n            membersUtility.db.collection('members').findOne({\"_id\": membersUtility.db.ObjectID(valid.owner)}, function(err, member) {\n                if (err || !member) {\n                    plugins.callMethod(\"tokenLoginFailed\", {req: req, data: {token: token, token_owner: valid.owner}});\n                    callback(undefined);\n                }\n                else {\n                    plugins.callMethod(\"tokenLoginSuccessful\", {req: req, data: {username: member.username}});\n                    if (valid.temporary) {\n                        req.session.temporary_token = true;\n                    }\n                    setLoggedInVariables(req, member, membersUtility.db, function() {\n                        req.session.settings = member.settings;\n                        callback(member);\n                    });\n                }\n            });\n        }\n    });\n};\n\n\n\n/**\n* Logs out user  -  clears session info for request and response object\n* @param {object} req - request object\n* @param {object} res - response object\n**/\nmembersUtility.logout = function(req, res) {\n    if (req.session) {\n        if (req.session.uid && req.session.email) {\n            plugins.callMethod(\"userLogout\", {req: req, data: {uid: req.session.uid, email: req.session.email, query: req.query}});\n        }\n        if (req.session.auth_token) {\n            membersUtility.db.collection(\"auth_tokens\").remove({_id: req.session.auth_token});\n\n            //louout also other users logged in with same credentials\n            if (!req.session.temporary_token) {\n                killOtherSessionsForUser(req.session.uid, null, null, membersUtility.db);\n            }\n            req.session.auth_token = null;\n        }\n        membersUtility.clearReqAndRes(req, res);\n    }\n};\n\n/**\n * Function to extend user session. Changes time when session expires and also extends token(if passed).\n * @param {object} req - request object\n * @param {string} req.session.auth_token - auth token\n*/\nmembersUtility.extendSession = function(req) {\n    req.session.expires = Date.now() + getSessionTimeoutInMs(req);\n    if (req.session.auth_token) {\n        var ChangeTime = getSessionTimeoutInMs(req);\n        if (ChangeTime > 0) {\n            authorize.extend_token({token: req.session.auth_token, db: membersUtility.db, extendTill: Date.now() + ChangeTime}, function(err) {\n                if (err) {\n                    console.log(err);\n                }\n            });\n        }\n        else { //changed to not expire\n            authorize.extend_token({token: req.session.auth_token, db: membersUtility.db, extendBy: 0}, function(err) {\n                if (err) {\n                    console.log(err);\n                }\n            });\n        }\n    }\n};\n\n/**\n * Sets up first user in Countly(if there is none). Req object is used to get mandatory variables from req.body and also there are variables set to have logged in session for new user.\n * @param {object} req - request object\n * @param {string} req.body.full_name - Full name. Mandatory.\n * @param {string} req.body.username - Username. Mandatory.\n * @param {string} req.body.password  - Password. Mandatory.\n * @param {string} req.body.email  - E-mail. Mandatory.\n * @param {function} callback  - Function with one return value - error (if there is one)\n * @example\n *   membersUtility.setup(req, res, countlyConfig, function(error) {\n *      if(error) {\n *          //there is error while setting up user\n *          // error === \"Wrong request parameters\" - not all mandatory parameters passed or there was error during creating user\n *         // error === \"User exists\" - There is already at least one user.\n *           // error === \".....\" - mongo error while getting user count.\n *      }\n *      else {\n *          //Success\n *      }\n *  });\n**/\n\nmembersUtility.setup = function(req, callback) {\n    membersUtility.db.collection('members').count(function(err, memberCount) {\n        if (!err && memberCount === 0) {\n            //check password\n            const argProps = {\n                'full_name': {\n                    'required': true,\n                    'type': 'String'\n                },\n                'username': {\n                    'required': true,\n                    'type': 'String'\n                },\n                'password': {\n                    'required': true,\n                    'type': 'String',\n                    'min-length': plugins.getConfig(\"security\").password_min,\n                    'has-number': plugins.getConfig(\"security\").password_number,\n                    'has-upchar': plugins.getConfig(\"security\").password_char,\n                    'has-special': plugins.getConfig(\"security\").password_symbol\n                },\n                'email': {\n                    'required': true,\n                    'type': 'String'\n                },\n            };\n            var memberCreateValidation = common.validateArgs(req.body, argProps, true);\n            if (!(req.body = memberCreateValidation.obj)) {\n                callback({\n                    message: memberCreateValidation.errors,\n                    passMinLen: plugins.getConfig(\"security\").password_min,\n                });\n                return;\n            }\n            var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n            argon2Hash(req.body.password + secret).then(password => {\n                req.body.email = (req.body.email + \"\").trim();\n                req.body.username = (req.body.username + \"\").trim();\n                var doc = {\n                    \"full_name\": req.body.full_name,\n                    \"username\": req.body.username,\n                    \"password\": password,\n                    \"email\": req.body.email,\n                    \"global_admin\": true,\n                    created_at: Math.floor(((new Date()).getTime()) / 1000),\n                    password_changed: Math.floor(((new Date()).getTime()) / 1000),\n                    permission: membersUtility.emptyPermission\n                };\n                if (req.body.lang) {\n                    doc.lang = req.body.lang;\n                }\n                crypto.randomBytes(48, function(errorBuff, buffer) {\n                    doc.api_key = common.md5Hash(buffer.toString('hex') + Math.random());\n                    membersUtility.db.collection('members').insert(doc, {safe: true}, function(err2, member) {\n                        member = member.ops;\n                        setLoggedInVariables(req, member[0], membersUtility.db, function() {\n                            req.session.install = true;\n                            callback();\n                        });\n                    });\n                });\n            }).catch(function() {\n                callback(\"Wrong request parameters\");\n            });\n        }\n        else if (err) {\n            callback(err);\n        }\n        else {\n            callback(\"User exists\");\n        }\n    });\n};\n\n/**\n * Function validates if email is not used by any other member.\n * @param {string} email - mandatory. E-mail to check\n * @param {function} callback -  function with one return value. Returns true if email is not used, false if taken.\n * @example\n * membersUtility.checkEmail(email, function(isFree) {\n *      if(isFree ===true) {\n *          //email is not taken\n *      }\n * });\n *\n *\n*/\nmembersUtility.checkEmail = function(email, callback) {\n    email = (email + \"\").trim();\n    membersUtility.db.collection('members').findOne({email: email}, function(err, member) {\n        if (member || err) {\n            callback(false);\n        }\n        else {\n            callback(true);\n        }\n    });\n};\n\n/**\n * Function validates if username is not used by any other member.\n * @param {string} username - mandatory. Username to check.\n * @param {function} callback -  function with one return value. Returns true if username is free, false if taken.\n * @example\n * membersUtility.checkUsername(username, function(isFree) {\n *      if(isFree ===true) {\n *          //username is not taken\n *      }\n * });\n *\n *\n*/\nmembersUtility.checkUsername = function(username, callback) {\n    username = (username + \"\").trim();\n    membersUtility.db.collection('members').findOne({username: username}, function(err, member) {\n        if (member || err) {\n            callback(false);\n        }\n        else {\n            callback(true);\n        }\n    });\n};\n\n/**\n * Sends user password reseting information to given e-mail.\n * @param {object} req - request object.\n * @param {string} req.body.email - mandatory. User email.\n * @param {string} req.body.lang - optional. Language.(default \"en\"  - english)\n * @param {function} callback  - function with one return value. Returns member object if successful.\n * @example\n * membersUtility.forgot(req, function(member) {\n *      if(member) {\n *         //member found\n *      }\n *      else {\n *         //e-mail not passed or user with this e-mail not found\n *      }\n * });\n*/\nmembersUtility.forgot = function(req, callback) {\n    if (!req || !req.body || !req.body.email) {\n        callback(undefined); //to be sure email is passed\n    }\n    else {\n        var email = (req.body.email + \"\").trim();\n        membersUtility.db.collection('members').findOne({\"email\": email}, function(err, member) {\n            if (member) {\n                var timestamp = Math.round(new Date().getTime() / 1000),\n                    prid = crypto.randomBytes(32).toString('hex');\n                member.lang = member.lang || req.body.lang || \"en\";\n                membersUtility.db.collection('password_reset').insert({\"prid\": prid, \"user_id\": member._id, \"timestamp\": timestamp}, {safe: true}, function() {\n                    countlyMail.sendPasswordResetInfo(member, prid);\n                    plugins.callMethod(\"passwordRequest\", {req: req, data: req.body}); //used in systemlogs\n                    callback(member);\n                });\n            }\n            else {\n                callback(undefined);\n            }\n        });\n    }\n};\n/**\n * Resets user password\n * @param {object} req - request object\n * @param {string} req.body.password - mandatory. new password.\n * @param {string} req.body.again - mandatory.\n * @param {string} req.body.prid - mandatory. Password reset id.\n * @param {function} callback - function with one two return values. First one is password validation error(false if no error) and second one is member object if reset is sucessful.\n*/\nmembersUtility.reset = function(req, callback) {\n    var result = validatePassword(req.body.password);\n    if (result === false) {\n        if (req.body.password && req.body.again && req.body.prid) {\n            req.body.prid += \"\";\n            var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n            argon2Hash(req.body.password + secret).then(password => {\n                membersUtility.db.collection('password_reset').findOne({ prid: req.body.prid }, function(err, passwordReset) {\n                    membersUtility.db.collection('members').findAndModify({ _id: passwordReset.user_id }, {}, { '$set': { \"password\": password } }, function(err2, member) {\n                        member = member && member.ok ? member.value : null;\n                        killOtherSessionsForUser(passwordReset.user_id + \"\", null, null, membersUtility.db);\n                        plugins.callMethod(\"passwordReset\", { req: req, data: member }); //only req, used for systemolgs\n                        callback(false, member);\n                    });\n                    membersUtility.db.collection('password_reset').remove({ prid: req.body.prid }, function() { });\n                });\n            }).catch(function() {\n                callback(false, undefined);\n            });\n        }\n        else {\n            callback(false, undefined);\n        }\n    }\n    else {\n        callback(result, undefined);\n    }\n};\n\n/**\n * Saves changed user settings\n * @param {object} req - request object\n * @param {string} req.body.username - mandatory - username (current or new one to chacge to)\n * @param {string} req.body.api_key - mandatory. User API KEY (current or the one to change to)\n * @param {string} req.body.old_pwd  - Old password. Optional. Passed if changing password.\n * @param {string} req.body.new_pwd  - New password. Optional. Passed if changing password.\n * @param {function} callback  - function with two return values. First one is true - if successful (false if not sucessful) and the second one - error message(in some cases).\n*/\nmembersUtility.settings = function(req, callback) {\n    var updatedUser = {};\n    if (req.body.username && req.body.api_key) {\n        if (req.body.api_key.length !== 32) {\n            callback(false, \"user-settings.api-key-length\");\n            return;\n        }\n        if (!req.body.api_key.match(/^[0-9a-zA-Z]+([0-9]+)([a-z]+)[0-9a-zA-Z]+$/)) {\n            callback(false, \"user-settings.api-key-restrict\");\n            return;\n        }\n\n        req.body.username = (req.body.username + \"\").trim();\n        if (req.body.member_image && req.body.member_image !== \"delete\") {\n            updatedUser.member_image = req.body.member_image;\n        }\n        if (req.body.member_image === \"delete\") {\n            updatedUser.member_image = \"\";\n        }\n        updatedUser.username = req.body.username;\n        updatedUser.api_key = req.body.api_key;\n        if (req.body.lang) {\n            updatedUser.lang = req.body.lang;\n        }\n        var change = JSON.parse(JSON.stringify(updatedUser));\n        membersUtility.db.collection('members').findOne({\"_id\": membersUtility.db.ObjectID(req.session.uid + \"\")}, function(err, member) {\n            if (err || !member) {\n                callback(false);\n                return;\n            }\n            membersUtility.db.collection('members').findOne({username: req.body.username}, async function(err2, user) {\n                if (err) {\n                    callback(false);\n                    return;\n                }\n                member.change = change;\n                if ((user && user._id + \"\" !== req.session.uid + \"\") || err2) {\n                    callback(false, \"username-exists\");\n                }\n                else {\n                    var secret = membersUtility.countlyConfig.passwordSecret || \"\";\n                    req.body.new_pwd = req.body.new_pwd + secret;\n                    if (req.body.old_pwd && req.body.old_pwd.length) {\n                        if (isArgon2Hash(member.password)) {\n                            var match;\n                            try {\n                                match = await verifyArgon2Hash(member.password, req.body.old_pwd);\n                            }\n                            catch (ex) {\n                                match = null;\n                            }\n                            if (!match) {\n                                return callback(false, \"user-settings.old-password-not-match\");\n                            }\n                        }\n                        else {\n                            var password_SHA1 = sha1Hash(req.body.old_pwd);\n                            var password_SHA5 = sha512Hash(req.body.old_pwd);\n\n                            if (member.password === password_SHA1 || member.password === password_SHA5) {\n                                argon2Hash(req.body.old_pwd).then(password_ARGON2 => {\n                                    updateUserPasswordToArgon2(member._id, password_ARGON2, membersUtility.db);\n                                }).catch(function() {\n                                    console.log(\"Problem updating password\");\n                                });\n                            }\n                            else {\n                                return callback(false, \"user-settings.old-password-not-match\");\n                            }\n                        }\n                        // eslint-disable-next-line require-atomic-updates\n                        member.change.password = true;\n                        try {\n                            var newPassword_SHA5 = sha512Hash(req.body.new_pwd),\n                                newPassword_ARGON2 = await argon2Hash(req.body.new_pwd);\n                        }\n                        catch (ex) {\n                            callback(false);\n                            return;\n                        }\n\n                        let isUsedBefore = false;\n                        if (plugins.getConfig('security').password_rotation > 0) {\n                            // Check if used before\n                            const promises = [];\n                            const passwordHistory = member.password_history || [];\n\n                            for (let i = 0; i < passwordHistory.length; i++) {\n                                const oldPassword = passwordHistory[i];\n                                if (isArgon2Hash(oldPassword)) {\n                                    promises.push(verifyArgon2Hash(oldPassword, req.body.new_pwd));\n                                }\n                                else if (oldPassword === newPassword_SHA5) {\n                                    isUsedBefore = true;\n                                    break;\n                                }\n                            }\n\n                            if (!isUsedBefore && promises.length > 0) {\n                                try {\n                                    const promiseResults = await Promise.all(promises);\n                                    isUsedBefore = promiseResults.some(x => x === true);\n                                }\n                                catch (ex) {\n                                    callback(false);\n                                    return;\n                                }\n                            }\n                        }\n\n                        if (req.body.new_pwd !== req.body.old_pwd && !isUsedBefore) {\n                            var passRes = validatePassword(req.body.new_pwd);\n                            if (passRes === false) {\n                                updatedUser.password = newPassword_ARGON2;\n                                updatedUser.password_changed = Math.round(new Date().getTime() / 1000);\n                                membersUtility.db.collection('members').update({\"_id\": membersUtility.db.ObjectID(req.session.uid + \"\")}, {'$set': updatedUser, $push: {password_history: {$each: [newPassword_ARGON2], $slice: -parseInt(plugins.getConfig('security').password_rotation)}}}, {safe: true}, function(err3, result) {\n                                    if (result && result.result && result.result.ok && result.result.nModified > 0 && !err3) {\n                                        killOtherSessionsForUser(req.session.uid, req.session.auth_token, req.sessionID, membersUtility.db);\n                                        plugins.callMethod(\"userSettings\", {req: req, data: member});\n                                        callback(true, updatedUser.password_changed + \"\");\n                                    }\n                                    else {\n                                        callback(false, \"user-settings.old-password-not-match\");\n                                        return;\n                                    }\n                                });\n                            }\n                            else {\n                                callback(false, passRes);\n                            }\n                        }\n                        else {\n                            callback(false, \"user-settings.password-not-old\");\n                        }\n                    }\n                    else {\n                        membersUtility.db.collection('members').update({\"_id\": membersUtility.db.ObjectID(req.session.uid + \"\")}, {'$set': updatedUser}, {safe: true}, function(err3, result) {\n                            if (result && !err3) {\n                                plugins.callMethod(\"userSettings\", {req: req, data: member});\n                                callback(true);\n                            }\n                            else {\n                                callback(false);\n                            }\n                        });\n                    }\n                }\n            });\n        });\n    }\n    else {\n        callback(false);\n        return;\n    }\n};\n\n/**\n * Searches for a user with the given username/email. Useful for the input from the login prompt.\n * @param {string} input - username or the email address of the user we are looking for\n * @param {function} callback - function with one parameter, the member object if a user is found, undefined otherwise\n*/\nmembersUtility.findByUsernameOrEmail = function(input, callback) {\n    input = (input + \"\").trim();\n    membersUtility.db.collection('members').findOne({$or: [{username: input}, {email: input}]}, function(err, member) {\n        if (err) {\n            console.log(`Database error searching for user: ${err}`);\n        }\n        callback(member);\n    });\n};\n\n/**\n * Find Members\n * @param {Object} query query\n * @returns {Object[]} list of members\n*/\nmembersUtility.findMembers = async function(query = {}) {\n    return new Promise((resolve, reject) => {\n        this.db.collection('members').find(query).toArray((err, members) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(members);\n            }\n        });\n    });\n};\n\n/**\n * Update Member\n * @param {Object} query query\n * @param {Object} data data to update\n * @param {boolean} upsert upsert\n * @returns {Object} list of members\n*/\nmembersUtility.updateMember = async function(query = {}, data = {}, upsert = true) {\n    return new Promise((resolve, reject) => {\n        this.db.collection('members').update(query, { $set: data }, { upsert }, (err) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(data);\n            }\n        });\n    });\n};\n\n/**\n * Remove Members\n * @param {Object} query query\n * @returns {Object[]} list of members\n*/\nmembersUtility.removeMembers = async function(query = {}) {\n    return new Promise((resolve, reject) => {\n        if (!Object.keys(query).length) {\n            return reject('Invalid query to remove members');\n        }\n\n        this.db.collection('members').remove(query, (err, response) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    });\n};\n\n/**\n * Create User for external authentication provider\n * @method createMember\n * @param {Object} data user data\n * @param {string} provider auth provider\n * @param {boolean} deleteDuplicate delete duplicate\n * @returns {Promise<any>} created or updated user data\n*/\nmembersUtility.createMember = async function(data, provider = '', deleteDuplicate = false) {\n    let user = {};\n    if (!data || !Object.keys(data).length) {\n        throw new Error('Invalid user data provided');\n    }\n    user._id = data._id || data.id || data.sub || data.username;\n    user.email = data.email || '';\n    user.username = data.username || data.email;\n    user.full_name = data.full_name || data.name || `${data.firstName} ${data.lastName}` || \"\";\n    user.global_admin = data.global_admin || false;\n    user.locked = (typeof data.locked !== \"undefined\") ? data.locked : false;\n    user.provider = provider;\n\n    // can be deprecated after all data migrated to provider property\n    user.isAD = (provider === 'ad' || provider === 'azure');\n    user.isCognito = provider === 'cognito';\n\n    user.created_at = data.created_at || Math.floor(((new Date()).getTime()) / 1000);\n\n    user.admin_of = data.admin_of || [];\n    user.user_of = data.user_of || [];\n    user.restrict = data.restrict || [];\n    user.app_restrict = data.app_restrict || {};\n    user.permission = data.permission || membersUtility.emptyPermission;\n\n    if (data.admin_of && data.admin_of.length) {\n        user.user_of = [...new Set([...data.admin_of, ...data.user_of])];\n    }\n\n    if (data.group_id && data.group_id.length) {\n        user.group_id = data.group_id;\n    }\n\n    // legacy rbac\n    if (data.marketing_of && data.marketing_of.length) {\n        user.admin_of.push(...data.marketing_of);\n    }\n\n    const buffer = crypto.randomBytes(48);\n    user.api_key = data.api_key || common.md5Hash(buffer.toString('hex') + Math.random());\n    user.password = data.password || common.md5Hash(data.api_key);\n\n    // push approver permission\n    user.approver = !!data.approver;\n    user.approver_bypass = !!data.approver_bypass;\n\n    const query = user.email\n        ? {\n            $or: [\n                { _id: user._id },\n                { email: user.email }\n            ]\n        }\n        : { _id: user._id };\n\n    try {\n        const existingMembers = await membersUtility.findMembers(query);\n        if (deleteDuplicate && (existingMembers.length >= 2 || (existingMembers.length === 1 && existingMembers[0]._id !== user._id))) {\n            await membersUtility.removeMembers(query);\n        }\n\n        const memberData = await membersUtility.updateMember(query, user, true);\n\n        return memberData;\n    }\n    catch (error) {\n        console.error(`create member error ${provider} ${error.message}`, error);\n        throw new Error(error);\n    }\n};\n\n/**\n * Merge permission objects\n * @method mergePermissions\n * @param {object} current - current permission object\n * @param {object} addition - permission object to merge\n */\nmembersUtility.mergePermissions = (current, addition) => {\n    var crud = {\"c\": true, \"r\": true, \"u\": true, \"d\": true};\n    for (var p in addition) {\n        //permission does not exist yet, just copy it\n        if (!current[p]) {\n            current[p] = addition[p];\n        }\n        else if (crud[p]) {\n            //iterating through the apps\n            if (addition[p]) {\n                if (!current[p]) {\n                    current[p] = {};\n                }\n                for (var app in addition[p]) {\n                    if (addition[p][app]) {\n                        if (!current[p][app]) {\n                            current[p][app] = {};\n                        }\n                        if (addition[p][app].all) {\n                            current[p][app].all = true;\n                        }\n                        if (addition[p][app].allowed) {\n                            current[p][app].allowed = current[p][app].allowed || {};\n                            for (var feat in addition[p][app].allowed) {\n                                if (addition[p][app].allowed[feat]) {\n                                    current[p][app].allowed[feat] = true;\n                                }\n                                else if (typeof current[p][app].allowed[feat] === \"undefined\") {\n                                    current[p][app].allowed[feat] = addition[p][app].allowed[feat];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        else if (p === \"_\") {\n            //merge admin by merging arrays\n            if (addition[p].a) {\n                if (!current[p].a) {\n                    current[p].a = [];\n                }\n                current[p].a = [...(new Set([...current[p].a, ...addition[p].a]))];\n            }\n            if (addition[p].u) {\n                if (!current[p].u) {\n                    current[p].u = [];\n                }\n                current[p].u = [...(new Set([...current[p].u, ...addition[p].u]))];\n            }\n        }\n    }\n};\n\nmodule.exports = membersUtility;"], "filenames": ["frontend/express/libs/members.js"], "buggy_code_start_loc": [812], "buggy_code_end_loc": [813], "fixing_code_start_loc": [812], "fixing_code_end_loc": [813], "type": "CWE-640", "message": "countly-server is the server-side part of Countly, a product analytics solution. Prior to versions 22.03.7 and 21.11.4, a malicious actor who knows an account email address/username and full name specified in the database is capable of guessing the password reset token. The actor may use this information to reset the password and take over the account. The problem has been patched in Countly Server version 22.03.7 for servers using the new user interface and in 21.11.4 for servers using the old user interface.", "other": {"cve": {"id": "CVE-2022-29174", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-17T21:15:08.380", "lastModified": "2022-05-30T00:24:06.337", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "countly-server is the server-side part of Countly, a product analytics solution. Prior to versions 22.03.7 and 21.11.4, a malicious actor who knows an account email address/username and full name specified in the database is capable of guessing the password reset token. The actor may use this information to reset the password and take over the account. The problem has been patched in Countly Server version 22.03.7 for servers using the new user interface and in 21.11.4 for servers using the old user interface."}, {"lang": "es", "value": "countly-server es la parte del lado del servidor de Countly, una soluci\u00f3n de an\u00e1lisis de productos. En versiones anteriores a 22.03.7 y 21.11.4, un actor malicioso que conoce la direcci\u00f3n de correo electr\u00f3nico/nombre de usuario de una cuenta y el nombre completo especificado en la base de datos es capaz de adivinar el token de restablecimiento de la contrase\u00f1a. El actor puede usar esta informaci\u00f3n para restablecer la contrase\u00f1a y hacerse con la cuenta. El problema ha sido parcheado en Countly Server versi\u00f3n 22.03.7, para los servidores usando la nueva interfaz de usuario y en versi\u00f3n 21.11.4, para servidores usando la antigua interfaz de usuario"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-640"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:count:countly_server:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.11.4", "matchCriteriaId": "2827D174-3849-42BE-8BCB-3B99A4B067EB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:count:countly_server:*:*:*:*:*:*:*:*", "versionStartIncluding": "22.03", "versionEndExcluding": "22.03.7", "matchCriteriaId": "1694F16A-7DBE-40D5-8C91-BA16A482B04D"}]}]}], "references": [{"url": "https://github.com/Countly/countly-server/commit/2bfa1ee1fa46e9bb007cf8687ad197ab9c604999", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Countly/countly-server/security/advisories/GHSA-98vh-wqw5-p23v", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Countly/countly-server/commit/2bfa1ee1fa46e9bb007cf8687ad197ab9c604999"}}