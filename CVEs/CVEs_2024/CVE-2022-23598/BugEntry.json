{"buggy_code": ["{\n    \"name\": \"laminas/laminas-form\",\n    \"description\": \"Validate and display simple and complex forms, casting forms to business objects and vice versa\",\n    \"keywords\": [\n        \"laminas\",\n        \"form\"\n    ],\n    \"homepage\": \"https://laminas.dev\",\n    \"license\": \"BSD-3-Clause\",\n    \"require\": {\n        \"php\": \"^7.4 || ~8.0.0 || ~8.1.0\",\n        \"laminas/laminas-hydrator\": \"^4.3.0\",\n        \"laminas/laminas-inputfilter\": \"^2.13.0\",\n        \"laminas/laminas-stdlib\": \"^3.6.1\"\n    },\n    \"conflict\": {\n        \"doctrine/annotations\": \"<1.12.0\",\n        \"laminas/laminas-captcha\": \"<2.11.0\",\n        \"laminas/laminas-eventmanager\": \"<3.4.0\",\n        \"laminas/laminas-i18n\": \"<2.12.0\",\n        \"laminas/laminas-recaptcha\": \"<3.4.0\",\n        \"laminas/laminas-servicemanager\": \"<3.10.0\",\n        \"laminas/laminas-view\": \"<2.14.0\"\n    },\n    \"require-dev\": {\n        \"ext-intl\": \"*\",\n        \"doctrine/annotations\": \"^1.12.0\",\n        \"laminas/laminas-captcha\": \"^2.11.0\",\n        \"laminas/laminas-coding-standard\": \"^2.3.0\",\n        \"laminas/laminas-db\": \"^2.13.4\",\n        \"laminas/laminas-escaper\": \"^2.9.0\",\n        \"laminas/laminas-eventmanager\": \"^3.4.0\",\n        \"laminas/laminas-filter\": \"^2.13.0\",\n        \"laminas/laminas-i18n\": \"^2.12.0\",\n        \"laminas/laminas-modulemanager\": \"^2.11.0\",\n        \"laminas/laminas-recaptcha\": \"^3.4.0\",\n        \"laminas/laminas-servicemanager\": \"^3.10.0\",\n        \"laminas/laminas-session\": \"^2.12.0\",\n        \"laminas/laminas-text\": \"^2.9.0\",\n        \"laminas/laminas-validator\": \"^2.15.1\",\n        \"laminas/laminas-view\": \"^2.14.0\",\n        \"phpspec/prophecy-phpunit\": \"^2.0.1\",\n        \"phpunit/phpunit\": \"^9.5.10\",\n        \"psalm/plugin-phpunit\": \"^0.16.1\",\n        \"vimeo/psalm\": \"^4.13.1\"\n    },\n    \"suggest\": {\n        \"doctrine/annotations\": \"^1.12, required to use laminas-form annotations support\",\n        \"laminas/laminas-captcha\": \"^2.11, required for using CAPTCHA form elements\",\n        \"laminas/laminas-eventmanager\": \"^3.4, reuired for laminas-form annotations support\",\n        \"laminas/laminas-i18n\": \"^2.12, required when using laminas-form view helpers\",\n        \"laminas/laminas-recaptcha\": \"^3.4, in order to use the ReCaptcha form element\",\n        \"laminas/laminas-servicemanager\": \"^3.10, required to use the form factories or provide services\",\n        \"laminas/laminas-view\": \"^2.14, required for using the laminas-form view helpers\"\n    },\n    \"config\": {\n        \"sort-packages\": true\n    },\n    \"extra\": {\n        \"laminas\": {\n            \"component\": \"Laminas\\\\Form\",\n            \"config-provider\": \"Laminas\\\\Form\\\\ConfigProvider\"\n        }\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Laminas\\\\Form\\\\\": \"src/\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"LaminasTest\\\\Form\\\\\": \"test/\"\n        }\n    },\n    \"scripts\": {\n        \"check\": [\n            \"@cs-check\",\n            \"@static-analysis\",\n            \"@test\"\n        ],\n        \"cs-check\": \"phpcs\",\n        \"cs-fix\": \"phpcbf\",\n        \"static-analysis\": \"psalm --shepherd --stats\",\n        \"test\": \"phpunit --colors=always\",\n        \"test-coverage\": \"phpunit --colors=always --coverage-clover clover.xml\"\n    },\n    \"support\": {\n        \"issues\": \"https://github.com/laminas/laminas-form/issues\",\n        \"forum\": \"https://discourse.laminas.dev\",\n        \"chat\": \"https://laminas.dev/chat\",\n        \"source\": \"https://github.com/laminas/laminas-form\",\n        \"docs\": \"https://docs.laminas.dev/laminas-form/\",\n        \"rss\": \"https://github.com/laminas/laminas-form/releases.atom\"\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\nnamespace Laminas\\Form\\View\\Helper;\n\nuse Laminas\\Form\\ElementInterface;\nuse Laminas\\Form\\Exception;\n\nuse function array_merge;\nuse function array_walk_recursive;\nuse function implode;\nuse function sprintf;\n\nclass FormElementErrors extends AbstractHelper\n{\n    /** @var string Templates for the open/close/separators for message tags */\n    protected $messageOpenFormat = '<ul%s><li>';\n    /** @var string Templates for the open/close/separators for message tags */\n    protected $messageCloseString = '</li></ul>';\n    /** @var string Templates for the open/close/separators for message tags */\n    protected $messageSeparatorString = '</li><li>';\n\n    /** @var array Default attributes for the open format tag */\n    protected $attributes = [];\n\n    /** @var bool Whether or not to translate error messages during render. */\n    protected $translateErrorMessages = true;\n\n    /**\n     * Invoke helper as functor\n     *\n     * Proxies to {@link render()} if an element is passed.\n     *\n     * @template T as null|ElementInterface\n     * @psalm-param T $element\n     * @psalm-return (T is null ? self : string)\n     * @param  array $attributes\n     * @return string|FormElementErrors\n     */\n    public function __invoke(?ElementInterface $element = null, array $attributes = [])\n    {\n        if (! $element) {\n            return $this;\n        }\n\n        return $this->render($element, $attributes);\n    }\n\n    /**\n     * Render validation errors for the provided $element\n     *\n     * If {@link $translateErrorMessages} is true, and a translator is\n     * composed, messages retrieved from the element will be translated; if\n     * either is not the case, they will not.\n     *\n     * @param  array $attributes\n     * @throws Exception\\DomainException\n     */\n    public function render(ElementInterface $element, array $attributes = []): string\n    {\n        $messages = $element->getMessages();\n        if (! $messages) {\n            return '';\n        }\n\n        // Flatten message array\n        $messages = $this->flattenMessages($messages);\n        if (! $messages) {\n            return '';\n        }\n\n        // Prepare attributes for opening tag\n        $attributes = array_merge($this->attributes, $attributes);\n        $attributes = $this->createAttributesString($attributes);\n        if (! empty($attributes)) {\n            $attributes = ' ' . $attributes;\n        }\n\n        // Generate markup\n        $markup  = sprintf($this->getMessageOpenFormat(), $attributes);\n        $markup .= implode($this->getMessageSeparatorString(), $messages);\n        $markup .= $this->getMessageCloseString();\n\n        return $markup;\n    }\n\n    /**\n     * Set the attributes that will go on the message open format\n     *\n     * @param  array $attributes key value pairs of attributes\n     * @return $this\n     */\n    public function setAttributes(array $attributes)\n    {\n        $this->attributes = $attributes;\n        return $this;\n    }\n\n    /**\n     * Get the attributes that will go on the message open format\n     *\n     * @return array\n     */\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n\n    /**\n     * Set the string used to close message representation\n     *\n     * @return $this\n     */\n    public function setMessageCloseString(string $messageCloseString)\n    {\n        $this->messageCloseString = $messageCloseString;\n        return $this;\n    }\n\n    /**\n     * Get the string used to close message representation\n     */\n    public function getMessageCloseString(): string\n    {\n        return $this->messageCloseString;\n    }\n\n    /**\n     * Set the formatted string used to open message representation\n     *\n     * @return $this\n     */\n    public function setMessageOpenFormat(string $messageOpenFormat)\n    {\n        $this->messageOpenFormat = $messageOpenFormat;\n        return $this;\n    }\n\n    /**\n     * Get the formatted string used to open message representation\n     */\n    public function getMessageOpenFormat(): string\n    {\n        return $this->messageOpenFormat;\n    }\n\n    /**\n     * Set the string used to separate messages\n     *\n     * @return $this\n     */\n    public function setMessageSeparatorString(string $messageSeparatorString)\n    {\n        $this->messageSeparatorString = $messageSeparatorString;\n        return $this;\n    }\n\n    /**\n     * Get the string used to separate messages\n     */\n    public function getMessageSeparatorString(): string\n    {\n        return $this->messageSeparatorString;\n    }\n\n    /**\n     * Set the flag detailing whether or not to translate error messages.\n     *\n     * @return $this\n     */\n    public function setTranslateMessages(bool $flag)\n    {\n        $this->translateErrorMessages = $flag;\n        return $this;\n    }\n\n    /**\n     * @param array $messages\n     * @return array\n     */\n    private function flattenMessages(array $messages): array\n    {\n        return $this->translateErrorMessages && $this->getTranslator()\n            ? $this->flattenMessagesWithTranslator($messages)\n            : $this->flattenMessagesWithoutTranslator($messages);\n    }\n\n    /**\n     * @param array $messages\n     * @return array\n     */\n    private function flattenMessagesWithoutTranslator(array $messages): array\n    {\n        $messagesToPrint = [];\n        array_walk_recursive($messages, static function (string $item) use (&$messagesToPrint): void {\n            $messagesToPrint[] = $item;\n        });\n        return $messagesToPrint;\n    }\n\n    /**\n     * @param array $messages\n     * @return array\n     */\n    private function flattenMessagesWithTranslator(array $messages): array\n    {\n        $translator      = $this->getTranslator();\n        $textDomain      = $this->getTranslatorTextDomain();\n        $messagesToPrint = [];\n        $messageCallback = static function ($item) use (&$messagesToPrint, $translator, $textDomain): void {\n            $messagesToPrint[] = $translator->translate($item, $textDomain);\n        };\n        array_walk_recursive($messages, $messageCallback);\n        return $messagesToPrint;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\nnamespace LaminasTest\\Form\\View\\Helper;\n\nuse Laminas\\Form\\Element;\nuse Laminas\\Form\\Form;\nuse Laminas\\Form\\View\\Helper\\FormElementErrors as FormElementErrorsHelper;\nuse Laminas\\I18n\\Translator\\Translator;\nuse Laminas\\Validator\\AbstractValidator;\nuse Laminas\\Validator\\Translator\\TranslatorInterface;\nuse Prophecy\\PhpUnit\\ProphecyTrait;\n\n/**\n * @property FormElementErrorsHelper $helper\n */\nfinal class FormElementErrorsTest extends AbstractCommonTestCase\n{\n    use ProphecyTrait;\n\n    /** @var null|TranslatorInterface */\n    protected $defaultTranslator;\n\n    protected function setUp(): void\n    {\n        $this->defaultTranslator = AbstractValidator::getDefaultTranslator();\n        $this->helper            = new FormElementErrorsHelper();\n        parent::setUp();\n    }\n\n    protected function tearDown(): void\n    {\n        AbstractValidator::setDefaultTranslator($this->defaultTranslator);\n    }\n\n    public function getMessageList(): array\n    {\n        return [\n            'First error message',\n            'Second error message',\n            'Third error message',\n        ];\n    }\n\n    public function testLackOfMessagesResultsInEmptyMarkup(): void\n    {\n        $element = new Element('foo');\n        $markup  = $this->helper->render($element);\n        $this->assertEquals('', $markup);\n    }\n\n    public function testRendersErrorMessagesUsingUnorderedListByDefault(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<ul>\\s*<li>First error message</li>\\s*<li>Second error message</li>\\s*<li>Third error message</li>\\s*</ul>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testRendersErrorMessagesUsingUnorderedListTranslated(): void\n    {\n        $mockTranslator = $this->createMock(Translator::class);\n        $mockTranslator->expects($this->exactly(3))\n            ->method('translate')\n            ->willReturnOnConsecutiveCalls(\n                'Translated first error message',\n                'Translated second error message',\n                'Translated third error message'\n            );\n\n        $this->helper->setTranslator($mockTranslator);\n        $this->assertTrue($this->helper->hasTranslator());\n\n        $this->helper->setTranslatorTextDomain('default');\n\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<ul>\\s*<li>Translated first error message</li>\\s*<li>Translated second error message</li>\\s*<li>Translated third error message</li>\\s*</ul>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testRendersErrorMessagesWithoutDoubleTranslation(): void\n    {\n        $form = new Form('test_form');\n        $form->add([\n            'name' => 'test_element',\n            'type' => Element\\Color::class,\n        ]);\n        $form->setData(['test_element' => 'This is invalid!']);\n\n        $mockValidatorTranslator = $this->createMock(TranslatorInterface::class);\n        $mockValidatorTranslator\n            ->expects(self::once())\n            ->method('translate')\n            ->willReturnCallback(\n                static function (string $message): string {\n                    self::assertEquals(\n                        'The input does not match against pattern \\'%pattern%\\'',\n                        $message,\n                        'Unexpected translation key.'\n                    );\n\n                    return 'TRANSLATED: The input does not match against pattern \\'%pattern%\\'';\n                }\n            );\n\n        AbstractValidator::setDefaultTranslator($mockValidatorTranslator, 'default');\n\n        self::assertFalse($form->isValid());\n\n        $mockFormTranslator = $this->createMock(Translator::class);\n        $mockFormTranslator\n            ->expects(self::never())\n            ->method('translate');\n\n        $this->helper->setTranslator($mockFormTranslator);\n        $this->assertTrue($this->helper->hasTranslator());\n\n        $this->helper->setTranslatorTextDomain('default');\n\n        // Disable translation...\n        $this->helper->setTranslateMessages(false);\n\n        $markup = $this->helper->render($form->get('test_element'));\n\n        $this->assertMatchesRegularExpression('#^<ul>\\s*<li>TRANSLATED#s', $markup);\n    }\n\n    public function testCanSpecifyAttributesForOpeningTag(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element, ['class' => 'error']);\n        $this->assertStringContainsString('ul class=\"error\"', $markup);\n    }\n\n    public function testCanSpecifyAttributesForOpeningTagUsingInvoke(): void\n    {\n        $helper   = $this->helper;\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $helper($element, ['class' => 'error']);\n        $this->assertStringContainsString('ul class=\"error\"', $markup);\n    }\n\n    public function testCanSpecifyAlternateMarkupStringsViaSetters(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $this->helper->setMessageOpenFormat('<div%s><span>')\n                     ->setMessageCloseString('</span></div>')\n                     ->setMessageSeparatorString('</span><span>')\n                     ->setAttributes(['class' => 'error']);\n\n        $markup = $this->helper->render($element);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<div class=\"error\">\\s*<span>First error message</span>\\s*<span>Second error message</span>\\s*<span>Third error message</span>\\s*</div>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testSpecifiedAttributesOverrideDefaults(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n        $element->setAttributes(['class' => 'foo']);\n\n        $markup = $this->helper->render($element, ['class' => 'error']);\n        $this->assertStringContainsString('ul class=\"error\"', $markup);\n    }\n\n    public function testGetAttributes(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $this->helper->setAttributes(['class' => 'error']);\n\n        $this->helper->render($element);\n\n        $this->assertEquals(['class' => 'error'], $this->helper->getAttributes());\n    }\n\n    public function testRendersNestedMessageSetsAsAFlatList(): void\n    {\n        $messages = [\n            [\n                'First validator message',\n            ],\n            [\n                'Second validator first message',\n                'Second validator second message',\n            ],\n        ];\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element, ['class' => 'error']);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<ul class=\"error\">\\s*<li>First validator message</li>\\s*<li>Second validator first message</li>\\s*<li>Second validator second message</li>\\s*</ul>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testCallingTheHelperToRenderInvokeCanReturnObject(): void\n    {\n        $helper = $this->helper;\n        $this->assertEquals($helper(), $helper);\n    }\n}\n"], "fixing_code": ["{\n    \"name\": \"laminas/laminas-form\",\n    \"description\": \"Validate and display simple and complex forms, casting forms to business objects and vice versa\",\n    \"keywords\": [\n        \"laminas\",\n        \"form\"\n    ],\n    \"homepage\": \"https://laminas.dev\",\n    \"license\": \"BSD-3-Clause\",\n    \"require\": {\n        \"php\": \"^7.4 || ~8.0.0 || ~8.1.0\",\n        \"laminas/laminas-hydrator\": \"^4.3.0\",\n        \"laminas/laminas-inputfilter\": \"^2.13.0\",\n        \"laminas/laminas-stdlib\": \"^3.6.1\"\n    },\n    \"conflict\": {\n        \"doctrine/annotations\": \"<1.12.0\",\n        \"laminas/laminas-captcha\": \"<2.11.0\",\n        \"laminas/laminas-eventmanager\": \"<3.4.0\",\n        \"laminas/laminas-i18n\": \"<2.12.0\",\n        \"laminas/laminas-recaptcha\": \"<3.4.0\",\n        \"laminas/laminas-servicemanager\": \"<3.10.0\",\n        \"laminas/laminas-view\": \"<2.14.0\"\n    },\n    \"require-dev\": {\n        \"ext-intl\": \"*\",\n        \"doctrine/annotations\": \"^1.12.0\",\n        \"laminas/laminas-captcha\": \"^2.11.0\",\n        \"laminas/laminas-coding-standard\": \"^2.3.0\",\n        \"laminas/laminas-db\": \"^2.13.4\",\n        \"laminas/laminas-escaper\": \"^2.9.0\",\n        \"laminas/laminas-eventmanager\": \"^3.4.0\",\n        \"laminas/laminas-filter\": \"^2.13.0\",\n        \"laminas/laminas-i18n\": \"^2.12.0\",\n        \"laminas/laminas-modulemanager\": \"^2.11.0\",\n        \"laminas/laminas-recaptcha\": \"^3.4.0\",\n        \"laminas/laminas-servicemanager\": \"^3.10.0\",\n        \"laminas/laminas-session\": \"^2.12.0\",\n        \"laminas/laminas-text\": \"^2.9.0\",\n        \"laminas/laminas-validator\": \"^2.15.1\",\n        \"laminas/laminas-view\": \"^2.14.0\",\n        \"phpspec/prophecy-phpunit\": \"^2.0.1\",\n        \"phpunit/phpunit\": \"^9.5.10\",\n        \"psalm/plugin-phpunit\": \"^0.16.1\",\n        \"vimeo/psalm\": \"^4.13.1\"\n    },\n    \"suggest\": {\n        \"doctrine/annotations\": \"^1.12, required to use laminas-form annotations support\",\n        \"laminas/laminas-captcha\": \"^2.11, required for using CAPTCHA form elements\",\n        \"laminas/laminas-eventmanager\": \"^3.4, reuired for laminas-form annotations support\",\n        \"laminas/laminas-i18n\": \"^2.12, required when using laminas-form view helpers\",\n        \"laminas/laminas-recaptcha\": \"^3.4, in order to use the ReCaptcha form element\",\n        \"laminas/laminas-servicemanager\": \"^3.10, required to use the form factories or provide services\",\n        \"laminas/laminas-view\": \"^2.14, required for using the laminas-form view helpers\"\n    },\n    \"config\": {\n        \"sort-packages\": true,\n        \"allow-plugins\": {\n            \"composer/package-versions-deprecated\": true,\n            \"dealerdirect/phpcodesniffer-composer-installer\": true\n        }\n    },\n    \"extra\": {\n        \"laminas\": {\n            \"component\": \"Laminas\\\\Form\",\n            \"config-provider\": \"Laminas\\\\Form\\\\ConfigProvider\"\n        }\n    },\n    \"autoload\": {\n        \"psr-4\": {\n            \"Laminas\\\\Form\\\\\": \"src/\"\n        }\n    },\n    \"autoload-dev\": {\n        \"psr-4\": {\n            \"LaminasTest\\\\Form\\\\\": \"test/\"\n        }\n    },\n    \"scripts\": {\n        \"check\": [\n            \"@cs-check\",\n            \"@static-analysis\",\n            \"@test\"\n        ],\n        \"cs-check\": \"phpcs\",\n        \"cs-fix\": \"phpcbf\",\n        \"static-analysis\": \"psalm --shepherd --stats\",\n        \"test\": \"phpunit --colors=always\",\n        \"test-coverage\": \"phpunit --colors=always --coverage-clover clover.xml\"\n    },\n    \"support\": {\n        \"issues\": \"https://github.com/laminas/laminas-form/issues\",\n        \"forum\": \"https://discourse.laminas.dev\",\n        \"chat\": \"https://laminas.dev/chat\",\n        \"source\": \"https://github.com/laminas/laminas-form\",\n        \"docs\": \"https://docs.laminas.dev/laminas-form/\",\n        \"rss\": \"https://github.com/laminas/laminas-form/releases.atom\"\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\nnamespace Laminas\\Form\\View\\Helper;\n\nuse Laminas\\Form\\ElementInterface;\nuse Laminas\\Form\\Exception;\n\nuse function array_merge;\nuse function array_walk_recursive;\nuse function count;\nuse function implode;\nuse function sprintf;\n\nclass FormElementErrors extends AbstractHelper\n{\n    /** @var string Templates for the open/close/separators for message tags */\n    protected $messageOpenFormat = '<ul%s><li>';\n    /** @var string Templates for the open/close/separators for message tags */\n    protected $messageCloseString = '</li></ul>';\n    /** @var string Templates for the open/close/separators for message tags */\n    protected $messageSeparatorString = '</li><li>';\n\n    /** @var array Default attributes for the open format tag */\n    protected $attributes = [];\n\n    /** @var bool Whether or not to translate error messages during render. */\n    protected $translateErrorMessages = true;\n\n    /**\n     * Invoke helper as functor\n     *\n     * Proxies to {@link render()} if an element is passed.\n     *\n     * @template T as null|ElementInterface\n     * @psalm-param T $element\n     * @psalm-return (T is null ? self : string)\n     * @param  array $attributes\n     * @return string|FormElementErrors\n     */\n    public function __invoke(?ElementInterface $element = null, array $attributes = [])\n    {\n        if (! $element) {\n            return $this;\n        }\n\n        return $this->render($element, $attributes);\n    }\n\n    /**\n     * Render validation errors for the provided $element\n     *\n     * If {@link $translateErrorMessages} is true, and a translator is\n     * composed, messages retrieved from the element will be translated; if\n     * either is not the case, they will not.\n     *\n     * @param  array $attributes\n     * @throws Exception\\DomainException\n     */\n    public function render(ElementInterface $element, array $attributes = []): string\n    {\n        $messages = $element->getMessages();\n        if (! $messages) {\n            return '';\n        }\n\n        // Flatten message array\n        $messages = $this->flattenMessages($messages);\n        if (! $messages) {\n            return '';\n        }\n\n        // Prepare attributes for opening tag\n        $attributes = array_merge($this->attributes, $attributes);\n        $attributes = $this->createAttributesString($attributes);\n        if (! empty($attributes)) {\n            $attributes = ' ' . $attributes;\n        }\n\n        $count   = count($messages);\n        $escaper = $this->getEscapeHtmlHelper();\n        for ($i = 0; $i < $count; $i += 1) {\n            $messages[$i] = $escaper($messages[$i]);\n        }\n\n        // Generate markup\n        $markup  = sprintf($this->getMessageOpenFormat(), $attributes);\n        $markup .= implode($this->getMessageSeparatorString(), $messages);\n        $markup .= $this->getMessageCloseString();\n\n        return $markup;\n    }\n\n    /**\n     * Set the attributes that will go on the message open format\n     *\n     * @param  array $attributes key value pairs of attributes\n     * @return $this\n     */\n    public function setAttributes(array $attributes)\n    {\n        $this->attributes = $attributes;\n        return $this;\n    }\n\n    /**\n     * Get the attributes that will go on the message open format\n     *\n     * @return array\n     */\n    public function getAttributes(): array\n    {\n        return $this->attributes;\n    }\n\n    /**\n     * Set the string used to close message representation\n     *\n     * @return $this\n     */\n    public function setMessageCloseString(string $messageCloseString)\n    {\n        $this->messageCloseString = $messageCloseString;\n        return $this;\n    }\n\n    /**\n     * Get the string used to close message representation\n     */\n    public function getMessageCloseString(): string\n    {\n        return $this->messageCloseString;\n    }\n\n    /**\n     * Set the formatted string used to open message representation\n     *\n     * @return $this\n     */\n    public function setMessageOpenFormat(string $messageOpenFormat)\n    {\n        $this->messageOpenFormat = $messageOpenFormat;\n        return $this;\n    }\n\n    /**\n     * Get the formatted string used to open message representation\n     */\n    public function getMessageOpenFormat(): string\n    {\n        return $this->messageOpenFormat;\n    }\n\n    /**\n     * Set the string used to separate messages\n     *\n     * @return $this\n     */\n    public function setMessageSeparatorString(string $messageSeparatorString)\n    {\n        $this->messageSeparatorString = $messageSeparatorString;\n        return $this;\n    }\n\n    /**\n     * Get the string used to separate messages\n     */\n    public function getMessageSeparatorString(): string\n    {\n        return $this->messageSeparatorString;\n    }\n\n    /**\n     * Set the flag detailing whether or not to translate error messages.\n     *\n     * @return $this\n     */\n    public function setTranslateMessages(bool $flag)\n    {\n        $this->translateErrorMessages = $flag;\n        return $this;\n    }\n\n    /**\n     * @param array $messages\n     * @return array\n     */\n    private function flattenMessages(array $messages): array\n    {\n        return $this->translateErrorMessages && $this->getTranslator()\n            ? $this->flattenMessagesWithTranslator($messages)\n            : $this->flattenMessagesWithoutTranslator($messages);\n    }\n\n    /**\n     * @param array $messages\n     * @return array\n     */\n    private function flattenMessagesWithoutTranslator(array $messages): array\n    {\n        $messagesToPrint = [];\n        array_walk_recursive($messages, static function (string $item) use (&$messagesToPrint): void {\n            $messagesToPrint[] = $item;\n        });\n        return $messagesToPrint;\n    }\n\n    /**\n     * @param array $messages\n     * @return array\n     */\n    private function flattenMessagesWithTranslator(array $messages): array\n    {\n        $translator      = $this->getTranslator();\n        $textDomain      = $this->getTranslatorTextDomain();\n        $messagesToPrint = [];\n        $messageCallback = static function ($item) use (&$messagesToPrint, $translator, $textDomain): void {\n            $messagesToPrint[] = $translator->translate($item, $textDomain);\n        };\n        array_walk_recursive($messages, $messageCallback);\n        return $messagesToPrint;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\nnamespace LaminasTest\\Form\\View\\Helper;\n\nuse Laminas\\Form\\Element;\nuse Laminas\\Form\\Form;\nuse Laminas\\Form\\View\\Helper\\FormElementErrors as FormElementErrorsHelper;\nuse Laminas\\I18n\\Translator\\Translator;\nuse Laminas\\Validator\\AbstractValidator;\nuse Laminas\\Validator\\Translator\\TranslatorInterface;\nuse Prophecy\\PhpUnit\\ProphecyTrait;\n\n/**\n * @property FormElementErrorsHelper $helper\n */\nfinal class FormElementErrorsTest extends AbstractCommonTestCase\n{\n    use ProphecyTrait;\n\n    /** @var null|TranslatorInterface */\n    protected $defaultTranslator;\n\n    protected function setUp(): void\n    {\n        $this->defaultTranslator = AbstractValidator::getDefaultTranslator();\n        $this->helper            = new FormElementErrorsHelper();\n        parent::setUp();\n    }\n\n    protected function tearDown(): void\n    {\n        AbstractValidator::setDefaultTranslator($this->defaultTranslator);\n    }\n\n    public function getMessageList(): array\n    {\n        return [\n            'First error message',\n            'Second error message',\n            'Third error message',\n        ];\n    }\n\n    public function testLackOfMessagesResultsInEmptyMarkup(): void\n    {\n        $element = new Element('foo');\n        $markup  = $this->helper->render($element);\n        $this->assertEquals('', $markup);\n    }\n\n    public function testRendersErrorMessagesUsingUnorderedListByDefault(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<ul>\\s*<li>First error message</li>\\s*<li>Second error message</li>\\s*<li>Third error message</li>\\s*</ul>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testRendersErrorMessagesUsingUnorderedListTranslated(): void\n    {\n        $mockTranslator = $this->createMock(Translator::class);\n        $mockTranslator->expects($this->exactly(3))\n            ->method('translate')\n            ->willReturnOnConsecutiveCalls(\n                'Translated first error message',\n                'Translated second error message',\n                'Translated third error message'\n            );\n\n        $this->helper->setTranslator($mockTranslator);\n        $this->assertTrue($this->helper->hasTranslator());\n\n        $this->helper->setTranslatorTextDomain('default');\n\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<ul>\\s*<li>Translated first error message</li>\\s*<li>Translated second error message</li>\\s*<li>Translated third error message</li>\\s*</ul>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testRendersErrorMessagesWithoutDoubleTranslation(): void\n    {\n        $form = new Form('test_form');\n        $form->add([\n            'name' => 'test_element',\n            'type' => Element\\Color::class,\n        ]);\n        $form->setData(['test_element' => 'This is invalid!']);\n\n        $mockValidatorTranslator = $this->createMock(TranslatorInterface::class);\n        $mockValidatorTranslator\n            ->expects(self::once())\n            ->method('translate')\n            ->willReturnCallback(\n                static function (string $message): string {\n                    self::assertEquals(\n                        'The input does not match against pattern \\'%pattern%\\'',\n                        $message,\n                        'Unexpected translation key.'\n                    );\n\n                    return 'TRANSLATED: The input does not match against pattern \\'%pattern%\\'';\n                }\n            );\n\n        AbstractValidator::setDefaultTranslator($mockValidatorTranslator, 'default');\n\n        self::assertFalse($form->isValid());\n\n        $mockFormTranslator = $this->createMock(Translator::class);\n        $mockFormTranslator\n            ->expects(self::never())\n            ->method('translate');\n\n        $this->helper->setTranslator($mockFormTranslator);\n        $this->assertTrue($this->helper->hasTranslator());\n\n        $this->helper->setTranslatorTextDomain('default');\n\n        // Disable translation...\n        $this->helper->setTranslateMessages(false);\n\n        $markup = $this->helper->render($form->get('test_element'));\n\n        $this->assertMatchesRegularExpression('#^<ul>\\s*<li>TRANSLATED#s', $markup);\n    }\n\n    public function testCanSpecifyAttributesForOpeningTag(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element, ['class' => 'error']);\n        $this->assertStringContainsString('ul class=\"error\"', $markup);\n    }\n\n    public function testCanSpecifyAttributesForOpeningTagUsingInvoke(): void\n    {\n        $helper   = $this->helper;\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $helper($element, ['class' => 'error']);\n        $this->assertStringContainsString('ul class=\"error\"', $markup);\n    }\n\n    public function testCanSpecifyAlternateMarkupStringsViaSetters(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $this->helper->setMessageOpenFormat('<div%s><span>')\n                     ->setMessageCloseString('</span></div>')\n                     ->setMessageSeparatorString('</span><span>')\n                     ->setAttributes(['class' => 'error']);\n\n        $markup = $this->helper->render($element);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<div class=\"error\">\\s*<span>First error message</span>\\s*<span>Second error message</span>\\s*<span>Third error message</span>\\s*</div>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testSpecifiedAttributesOverrideDefaults(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n        $element->setAttributes(['class' => 'foo']);\n\n        $markup = $this->helper->render($element, ['class' => 'error']);\n        $this->assertStringContainsString('ul class=\"error\"', $markup);\n    }\n\n    public function testGetAttributes(): void\n    {\n        $messages = $this->getMessageList();\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $this->helper->setAttributes(['class' => 'error']);\n\n        $this->helper->render($element);\n\n        $this->assertEquals(['class' => 'error'], $this->helper->getAttributes());\n    }\n\n    public function testRendersNestedMessageSetsAsAFlatList(): void\n    {\n        $messages = [\n            [\n                'First validator message',\n            ],\n            [\n                'Second validator first message',\n                'Second validator second message',\n            ],\n        ];\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element, ['class' => 'error']);\n        // @codingStandardsIgnoreStart\n        $this->assertMatchesRegularExpression('#<ul class=\"error\">\\s*<li>First validator message</li>\\s*<li>Second validator first message</li>\\s*<li>Second validator second message</li>\\s*</ul>#s', $markup);\n        // @codingStandardsIgnoreEnd\n    }\n\n    public function testCallingTheHelperToRenderInvokeCanReturnObject(): void\n    {\n        $helper = $this->helper;\n        $this->assertEquals($helper(), $helper);\n    }\n\n    public function testHtmlEscapingOfMessages(): void\n    {\n        $messages = [\n            [\n                '<span>First validator message</span>',\n                '<span>Second validator first message</span>',\n                '<span>Second validator second message</span>',\n            ],\n        ];\n        $element  = new Element('foo');\n        $element->setMessages($messages);\n\n        $markup = $this->helper->render($element);\n\n        $this->assertStringNotContainsString('<span>', $markup);\n        $this->assertStringNotContainsString('</span>', $markup);\n    }\n}\n"], "filenames": ["composer.json", "src/View/Helper/FormElementErrors.php", "test/View/Helper/FormElementErrorsTest.php"], "buggy_code_start_loc": [57, 11, 224], "buggy_code_end_loc": [58, 79, 224], "fixing_code_start_loc": [57, 12, 225], "fixing_code_end_loc": [62, 87, 243], "type": "CWE-79", "message": "laminas-form is a package for validating and displaying simple and complex forms. When rendering validation error messages via the `formElementErrors()` view helper shipped with laminas-form, many messages will contain the submitted value. However, in laminas-form prior to version 3.1.1, the value was not being escaped for HTML contexts, which could potentially lead to a reflected cross-site scripting attack. Versions 3.1.1 and above contain a patch to mitigate the vulnerability. A workaround is available. One may manually place code at the top of a view script where one calls the `formElementErrors()` view helper. More information about this workaround is available on the GitHub Security Advisory.", "other": {"cve": {"id": "CVE-2022-23598", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-28T22:15:16.770", "lastModified": "2022-03-25T14:20:58.420", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "laminas-form is a package for validating and displaying simple and complex forms. When rendering validation error messages via the `formElementErrors()` view helper shipped with laminas-form, many messages will contain the submitted value. However, in laminas-form prior to version 3.1.1, the value was not being escaped for HTML contexts, which could potentially lead to a reflected cross-site scripting attack. Versions 3.1.1 and above contain a patch to mitigate the vulnerability. A workaround is available. One may manually place code at the top of a view script where one calls the `formElementErrors()` view helper. More information about this workaround is available on the GitHub Security Advisory."}, {"lang": "es", "value": "laminas-form es un paquete para la comprobaci\u00f3n y visualizaci\u00f3n de formularios simples y complejos. Cuando son mostrados los mensajes de error de comprobaci\u00f3n por medio del ayudante de vista \"formElementErrors()\" incluido en laminas-form, muchos mensajes contienen el valor enviado. Sin embargo, en laminas-form versiones anteriores a 3.1.1, el valor no es escapado para los contextos HTML, lo que potencialmente pod\u00eda conllevar a un ataque de tipo Cross-site scripting reflejado. Las versiones 3.1.1 y superiores contienen un parche para mitigar la vulnerabilidad. Se presenta una soluci\u00f3n disponible. Puede colocarse manualmente un c\u00f3digo en la parte superior de un script de visualizaci\u00f3n donde es llamado al ayudante de visualizaci\u00f3n \"formElementErrors()\". Se presenta m\u00e1s informaci\u00f3n sobre esta medida de mitigaci\u00f3n en el aviso de seguridad de GitHub"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:getlaminas:laminas-form:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.17.1", "matchCriteriaId": "87A945AD-C8D8-4BF9-AEFE-AB8F1018484D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getlaminas:laminas-form:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.0.2", "matchCriteriaId": "44B054C5-A156-47EC-AAD5-7AC4A6E9460E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:getlaminas:laminas-form:3.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "98097242-DBA4-4D6A-8BD5-7263E1E06D3B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}], "references": [{"url": "https://getlaminas.org/security/advisory/LP-2022-01", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/laminas/laminas-form/commit/43005a3ec4c2292d4f825273768d9b884acbca37", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/laminas/laminas-form/security/advisories/GHSA-jq4p-mq33-w375", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/CFF6WJ5I7PSEBRF6I753WKE2BXFBGQXE/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/SLNABVK26CE4PFL57VLY242FW3QY4CPC/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/laminas/laminas-form/commit/43005a3ec4c2292d4f825273768d9b884acbca37"}}