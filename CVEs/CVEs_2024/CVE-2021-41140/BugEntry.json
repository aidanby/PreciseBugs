{"buggy_code": ["# frozen_string_literal: true\n\nmodule DiscourseReactions\n  class CustomReactionsController < DiscourseReactionsController\n    MAX_USERS_COUNT = 26\n\n    before_action :ensure_logged_in, except: [:post_reactions_users]\n\n    def toggle\n      post = fetch_post_from_params\n\n      unless DiscourseReactions::Reaction.valid_reactions.include?(params[:reaction])\n        return render_json_error(post)\n      end\n\n      begin\n        DiscourseReactions::ReactionManager.new(reaction_value: params[:reaction], user: current_user, guardian: guardian, post: post).toggle!\n      rescue ActiveRecord::RecordNotUnique\n        # If the user already performed this action, it's probably due to a different browser tab\n        # or non-debounced clicking. We can ignore.\n      end\n\n      post.publish_change_to_clients!(:acted)\n      publish_change_to_clients!(post)\n\n      render_json_dump(post_serializer(post).as_json)\n    end\n\n    def reactions_given\n      params.require(:username)\n      user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts))\n      raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n      reaction_users = DiscourseReactions::ReactionUser\n        .joins(:reaction, :post)\n        .includes(:user, :post, :reaction)\n        .where(user_id: user.id)\n        .where('discourse_reactions_reactions.reaction_users_count IS NOT NULL')\n\n      if params[:before_reaction_user_id]\n        reaction_users = reaction_users\n          .where('discourse_reactions_reaction_users.id < ?', params[:before_reaction_user_id].to_i)\n      end\n\n      reaction_users = reaction_users\n        .order(created_at: :desc)\n        .limit(20)\n\n      render_serialized(reaction_users.to_a, UserReactionSerializer)\n    end\n\n    def reactions_received\n      params.require(:username)\n      user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts))\n      raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n      posts = Post.joins(:topic).where(user_id: user.id)\n      posts = guardian.filter_allowed_categories(posts)\n      post_ids = posts.pluck(:id)\n\n      reaction_users = DiscourseReactions::ReactionUser\n        .joins(:reaction)\n        .where(post_id: post_ids)\n        .where('discourse_reactions_reactions.reaction_users_count IS NOT NULL')\n\n      if params[:before_post_id]\n        reaction_users = reaction_users\n          .where('discourse_reactions_reaction_users.id < ?', params[:before_post_id].to_i)\n      end\n\n      reaction_users = reaction_users\n        .order(created_at: :desc)\n        .limit(20)\n\n      render_serialized reaction_users.to_a, UserReactionSerializer\n    end\n\n    def post_reactions_users\n      id = params.require(:id).to_i\n      reaction_value = params[:reaction_value]\n      post = Post.find_by(id: id)\n\n      raise Discourse::InvalidParameters if !post\n\n      reaction_users = []\n\n      likes = post.post_actions.where('deleted_at IS NULL AND post_action_type_id = ?', PostActionType.types[:like]) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id\n\n      if likes.present?\n        main_reaction = DiscourseReactions::Reaction.find_by(reaction_value: DiscourseReactions::Reaction.main_reaction_id, post_id: post.id)\n        count = likes.length\n        users = format_likes_users(likes)\n\n        if main_reaction && main_reaction[:reaction_users_count]\n          (users << get_users(main_reaction)).flatten!\n          users.sort_by! { |user| user[:created_at] }\n          count += main_reaction.reaction_users_count.to_i\n        end\n\n        reaction_users << {\n          id: DiscourseReactions::Reaction.main_reaction_id,\n          count: count,\n          users: users.reverse.slice(0, MAX_USERS_COUNT + 1)\n        }\n      end\n\n      if !reaction_value\n        post.reactions.select { |reaction| reaction[:reaction_users_count] && reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id }.each do |reaction|\n          reaction_users << format_reaction_user(reaction)\n        end\n      elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id\n        post.reactions.where(reaction_value: reaction_value).select { |reaction| reaction[:reaction_users_count] }.each do |reaction|\n          reaction_users << format_reaction_user(reaction)\n        end\n      end\n\n      render_json_dump(reaction_users: reaction_users)\n    end\n\n    private\n\n    def get_users(reaction)\n      reaction.reaction_users.includes(:user).order(\"discourse_reactions_reaction_users.created_at desc\").limit(MAX_USERS_COUNT + 1).map { |reaction_user|\n        {\n          username: reaction_user.user.username,\n          name: reaction_user.user.name,\n          avatar_template: reaction_user.user.avatar_template,\n          can_undo: reaction_user.can_undo?,\n          created_at: reaction_user.created_at.to_s\n        }\n      }\n    end\n\n    def post_serializer(post)\n      PostSerializer.new(post, scope: guardian, root: false)\n    end\n\n    def format_reaction_user(reaction)\n      {\n        id: reaction.reaction_value,\n        count: reaction.reaction_users_count.to_i,\n        users: get_users(reaction)\n      }\n    end\n\n    def format_like_user(like)\n      {\n        username: like.user.username,\n        name: like.user.name,\n        avatar_template: like.user.avatar_template,\n        can_undo: guardian.can_delete_post_action?(like),\n        created_at: like.created_at.to_s\n      }\n    end\n\n    def format_likes_users(likes)\n      likes\n        .includes([:user])\n        .limit(MAX_USERS_COUNT + 1)\n        .map { |like| format_like_user(like) }\n    end\n\n    def fetch_post_from_params\n      post = Post.find(params[:post_id])\n      guardian.ensure_can_see!(post)\n      post\n    end\n\n    def publish_change_to_clients!(post)\n      reactions = [params[:reaction]]\n      reaction_id = DiscourseReactions::ReactionUser\n        .where(user_id: current_user.id, post_id: post.id)\n        .pluck_first(:reaction_id)\n\n      if reaction_id\n        reaction_value = DiscourseReactions::Reaction\n          .where(id: reaction_id)\n          .pluck_first(:reaction_value)\n\n        reactions.push(reaction_value) if reaction_value\n      end\n\n      message = {\n        post_id: post.id,\n        reactions: reactions\n      }\n\n      MessageBus.publish(\"/topic/#{post.topic.id}/reactions\", message)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\n\ndescribe DiscourseReactions::CustomReactionsController do\n  fab!(:post_1) { Fabricate(:post) }\n  fab!(:user_1) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:user_3) { Fabricate(:user) }\n  fab!(:user_4) { Fabricate(:user) }\n  fab!(:user_5) { Fabricate(:user) }\n  fab!(:post_2) { Fabricate(:post, user: user_1) }\n  fab!(:reaction_1) { Fabricate(:reaction, post: post_2, reaction_value: \"laughing\") }\n  fab!(:reaction_2) { Fabricate(:reaction, post: post_2, reaction_value: \"open_mouth\") }\n  fab!(:reaction_3) { Fabricate(:reaction, post: post_2, reaction_value: \"hugs\") }\n  fab!(:like) { Fabricate(:post_action, post: post_2, user: user_5, post_action_type_id: PostActionType.types[:like]) }\n  fab!(:reaction_user_1) { Fabricate(:reaction_user, reaction: reaction_1, user: user_2, post: post_2) }\n  fab!(:reaction_user_2) { Fabricate(:reaction_user, reaction: reaction_1, user: user_1, post: post_2) }\n  fab!(:reaction_user_3) { Fabricate(:reaction_user, reaction: reaction_3, user: user_4, post: post_2) }\n  fab!(:reaction_user_4) { Fabricate(:reaction_user, reaction: reaction_2, user: user_3, post: post_2) }\n\n  before do\n    SiteSetting.discourse_reactions_like_icon = 'heart'\n    SiteSetting.discourse_reactions_enabled_reactions = \"laughing|open_mouth|cry|angry|thumbsup|hugs\"\n  end\n\n  context '#toggle' do\n    let(:payload_with_user) {\n      [\n        {\n          'id' => 'hugs',\n          'type' => 'emoji',\n          'count' => 1\n        }\n      ]\n    }\n\n    it 'toggles reaction' do\n      sign_in(user_1)\n      expected_payload = [\n        {\n          'id' => 'hugs',\n          'type' => 'emoji',\n          'count' => 1\n        }\n      ]\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(1)\n        .and change { DiscourseReactions::ReactionUser.count }.by(1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['reactions']).to eq(expected_payload)\n\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq('hugs')\n      expect(reaction.reaction_users_count).to eq(1)\n\n      sign_in(user_2)\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq('hugs')\n      expect(reaction.reaction_users_count).to eq(2)\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(0)\n        .and change { DiscourseReactions::ReactionUser.count }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['reactions']).to eq(expected_payload)\n\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(-1)\n        .and change { DiscourseReactions::ReactionUser.count }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['reactions']).to eq([])\n    end\n\n    it 'publishes MessageBus messages' do\n      sign_in(user_1)\n\n      messages = MessageBus.track_publish(\"/topic/#{post_1.topic.id}\") do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:data).map { |m| m[:type] }.uniq).to eq(%i(acted))\n\n      messages = MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n    end\n\n    it 'errors when reaction is invalid' do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/invalid-reaction/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(0)\n\n      expect(response.status).to eq(422)\n    end\n  end\n\n  context '#reactions_given' do\n    it 'returns reactions given by a user' do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0]['user']['id']).to eq(user_2.id)\n      expect(parsed[0]['post_id']).to eq(post_2.id)\n      expect(parsed[0]['post']['user']['id']).to eq(user_1.id)\n      expect(parsed[0]['reaction']['id']).to eq(reaction_1.id)\n    end\n\n    context 'a post with one of your reactions has been deleted' do\n      fab!(:deleted_post) { Fabricate(:post) }\n      fab!(:kept_post) { Fabricate(:post) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:reaction_on_deleted_post) { Fabricate(:reaction, post: deleted_post, reaction_value: \"laughing\") }\n      fab!(:reaction_on_kept_post) { Fabricate(:reaction, post: kept_post, reaction_value: \"laughing\") }\n      fab!(:reaction_user_on_deleted_post) { Fabricate(:reaction_user, reaction: reaction_on_deleted_post, user: user, post: deleted_post) }\n      fab!(:reaction_user_on_kept_post) { Fabricate(:reaction_user, reaction: reaction_on_kept_post, user: user, post: kept_post) }\n\n      it 'doesn\u2019t return the deleted post/reaction' do\n        sign_in(user)\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, deleted_post).destroy\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n\n        expect(parsed.length).to eq(1)\n        expect(parsed[0]['post_id']).to eq(kept_post.id)\n      end\n    end\n  end\n\n  context '#reactions_received' do\n    it 'returns reactions received by a user' do\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions-received.json\", params: { username: user_1.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0]['user']['id']).to eq(user_3.id)\n      expect(parsed[0]['post_id']).to eq(post_2.id)\n      expect(parsed[0]['post']['user']['id']).to eq(user_1.id)\n      expect(parsed[0]['reaction']['id']).to eq(reaction_2.id)\n    end\n  end\n\n  context '#post_reactions_users' do\n    it 'return reaction_users of post when theres no parameters' do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_5.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_5.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(user_5.avatar_template)\n    end\n\n    it 'return reaction_users of reaction when there are parameters' do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{reaction_1.reaction_value}\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_1.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_1.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(user_1.avatar_template)\n    end\n\n    it \"gives 400 ERROR when the post_id OR reaction_value is invalid\" do\n      get \"/discourse-reactions/posts/1000000/reactions-users.json\"\n      expect(response.status).to eq(400)\n\n      get \"/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test\"\n      expect(response.status).to eq(400)\n    end\n\n    it 'merges identic custom reaction into likes' do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      like_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(post_2.like_count)\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=laughing\"\n      parsed = response.parsed_body\n      reaction_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(reaction_1.reaction_users_count)\n\n      SiteSetting.discourse_reactions_reaction_for_like = 'laughing'\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(like_count + reaction_count)\n    end\n  end\n\n  context 'positive notifications' do\n    before do\n      PostActionNotifier.enable\n    end\n\n    it 'creates notification when first like' do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(1)\n        .and change { PostAction.count }.by(1)\n\n      expect(PostAction.last.post_action_type_id).to eq(PostActionType.types[:like])\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(-1)\n        .and change { PostAction.count }.by(-1)\n    end\n  end\n\n  context 'reaction notifications' do\n    it 'calls ReactinNotification service' do\n      sign_in(user_1)\n      DiscourseReactions::ReactionNotification.any_instance.expects(:create).once\n      DiscourseReactions::ReactionNotification.any_instance.expects(:delete).once\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n    end\n  end\n\n  it 'allows to delete reaction only in undo action window frame' do\n    SiteSetting.post_undo_action_window_mins = 10\n    sign_in(user_1)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1)\n      .and change { DiscourseReactions::ReactionUser.count }.by(1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(-1)\n      .and change { DiscourseReactions::ReactionUser.count }.by(-1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1)\n      .and change { DiscourseReactions::ReactionUser.count }.by(1)\n\n    freeze_time(Time.zone.now + 11.minutes)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(0)\n      .and change { DiscourseReactions::ReactionUser.count }.by(0)\n\n    expect(response.status).to eq(403)\n  end\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule DiscourseReactions\n  class CustomReactionsController < DiscourseReactionsController\n    MAX_USERS_COUNT = 26\n\n    before_action :ensure_logged_in, except: [:post_reactions_users]\n\n    def toggle\n      post = fetch_post_from_params\n\n      unless DiscourseReactions::Reaction.valid_reactions.include?(params[:reaction])\n        return render_json_error(post)\n      end\n\n      begin\n        DiscourseReactions::ReactionManager.new(reaction_value: params[:reaction], user: current_user, guardian: guardian, post: post).toggle!\n      rescue ActiveRecord::RecordNotUnique\n        # If the user already performed this action, it's probably due to a different browser tab\n        # or non-debounced clicking. We can ignore.\n      end\n\n      post.publish_change_to_clients!(:acted)\n      publish_change_to_clients!(post)\n\n      render_json_dump(post_serializer(post).as_json)\n    end\n\n    def reactions_given\n      params.require(:username)\n      user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts))\n      raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n      reaction_users = DiscourseReactions::ReactionUser\n        .joins(:reaction, post: :topic)\n        .joins(\"LEFT JOIN categories ON categories.id = topics.category_id\")\n        .includes(:user, :post, :reaction)\n        .where(user_id: user.id)\n        .where('discourse_reactions_reactions.reaction_users_count IS NOT NULL')\n\n      reaction_users = secure_reaction_users!(reaction_users)\n\n      if params[:before_reaction_user_id]\n        reaction_users = reaction_users\n          .where('discourse_reactions_reaction_users.id < ?', params[:before_reaction_user_id].to_i)\n      end\n\n      reaction_users = reaction_users\n        .order(created_at: :desc)\n        .limit(20)\n\n      render_serialized(reaction_users.to_a, UserReactionSerializer)\n    end\n\n    def reactions_received\n      params.require(:username)\n      user = fetch_user_from_params(include_inactive: current_user.try(:staff?) || (current_user && SiteSetting.show_inactive_accounts))\n      raise Discourse::NotFound unless guardian.can_see_profile?(user)\n\n      posts = Post.joins(:topic).where(user_id: user.id)\n      posts = guardian.filter_allowed_categories(posts)\n      post_ids = posts.pluck(:id)\n\n      reaction_users = DiscourseReactions::ReactionUser\n        .joins(:reaction)\n        .where(post_id: post_ids)\n        .where('discourse_reactions_reactions.reaction_users_count IS NOT NULL')\n\n      if params[:before_post_id]\n        reaction_users = reaction_users\n          .where('discourse_reactions_reaction_users.id < ?', params[:before_post_id].to_i)\n      end\n\n      reaction_users = reaction_users\n        .order(created_at: :desc)\n        .limit(20)\n\n      render_serialized reaction_users.to_a, UserReactionSerializer\n    end\n\n    def post_reactions_users\n      id = params.require(:id).to_i\n      reaction_value = params[:reaction_value]\n      post = Post.find_by(id: id)\n\n      raise Discourse::InvalidParameters if !post\n\n      reaction_users = []\n\n      likes = post.post_actions.where('deleted_at IS NULL AND post_action_type_id = ?', PostActionType.types[:like]) if !reaction_value || reaction_value == DiscourseReactions::Reaction.main_reaction_id\n\n      if likes.present?\n        main_reaction = DiscourseReactions::Reaction.find_by(reaction_value: DiscourseReactions::Reaction.main_reaction_id, post_id: post.id)\n        count = likes.length\n        users = format_likes_users(likes)\n\n        if main_reaction && main_reaction[:reaction_users_count]\n          (users << get_users(main_reaction)).flatten!\n          users.sort_by! { |user| user[:created_at] }\n          count += main_reaction.reaction_users_count.to_i\n        end\n\n        reaction_users << {\n          id: DiscourseReactions::Reaction.main_reaction_id,\n          count: count,\n          users: users.reverse.slice(0, MAX_USERS_COUNT + 1)\n        }\n      end\n\n      if !reaction_value\n        post.reactions.select { |reaction| reaction[:reaction_users_count] && reaction[:reaction_value] != DiscourseReactions::Reaction.main_reaction_id }.each do |reaction|\n          reaction_users << format_reaction_user(reaction)\n        end\n      elsif reaction_value != DiscourseReactions::Reaction.main_reaction_id\n        post.reactions.where(reaction_value: reaction_value).select { |reaction| reaction[:reaction_users_count] }.each do |reaction|\n          reaction_users << format_reaction_user(reaction)\n        end\n      end\n\n      render_json_dump(reaction_users: reaction_users)\n    end\n\n    private\n\n    def get_users(reaction)\n      reaction.reaction_users.includes(:user).order(\"discourse_reactions_reaction_users.created_at desc\").limit(MAX_USERS_COUNT + 1).map { |reaction_user|\n        {\n          username: reaction_user.user.username,\n          name: reaction_user.user.name,\n          avatar_template: reaction_user.user.avatar_template,\n          can_undo: reaction_user.can_undo?,\n          created_at: reaction_user.created_at.to_s\n        }\n      }\n    end\n\n    def post_serializer(post)\n      PostSerializer.new(post, scope: guardian, root: false)\n    end\n\n    def format_reaction_user(reaction)\n      {\n        id: reaction.reaction_value,\n        count: reaction.reaction_users_count.to_i,\n        users: get_users(reaction)\n      }\n    end\n\n    def format_like_user(like)\n      {\n        username: like.user.username,\n        name: like.user.name,\n        avatar_template: like.user.avatar_template,\n        can_undo: guardian.can_delete_post_action?(like),\n        created_at: like.created_at.to_s\n      }\n    end\n\n    def format_likes_users(likes)\n      likes\n        .includes([:user])\n        .limit(MAX_USERS_COUNT + 1)\n        .map { |like| format_like_user(like) }\n    end\n\n    def fetch_post_from_params\n      post = Post.find(params[:post_id])\n      guardian.ensure_can_see!(post)\n      post\n    end\n\n    def publish_change_to_clients!(post)\n      reactions = [params[:reaction]]\n      reaction_id = DiscourseReactions::ReactionUser\n        .where(user_id: current_user.id, post_id: post.id)\n        .pluck_first(:reaction_id)\n\n      if reaction_id\n        reaction_value = DiscourseReactions::Reaction\n          .where(id: reaction_id)\n          .pluck_first(:reaction_value)\n\n        reactions.push(reaction_value) if reaction_value\n      end\n\n      message = {\n        post_id: post.id,\n        reactions: reactions\n      }\n\n      MessageBus.publish(\"/topic/#{post.topic.id}/reactions\", message)\n    end\n\n    def secure_reaction_users!(reaction_users)\n      if !guardian.can_see_private_messages?(current_user.id) || !guardian.user\n        reaction_users = reaction_users.where(\"topics.archetype <> :private_message\", private_message: archetype::private_message)\n      else\n        unless guardian.is_admin?\n          sql = <<~SQL\n            topics.archetype <> :private_message OR\n            EXISTS (\n              SELECT 1 FROM topic_allowed_users tu WHERE tu.topic_id = topics.id AND tu.user_id = :current_user_id\n            ) OR\n            EXISTS (\n              SELECT 1 FROM topic_allowed_groups tg WHERE tg.topic_id = topics.id AND tg.group_id IN (\n                SELECT group_id FROM group_users gu WHERE gu.user_id = :current_user_id\n              )\n            )\n          SQL\n\n          reaction_users = reaction_users.where(sql, private_message: Archetype::private_message, current_user_id: guardian.user.id)\n        end\n      end\n\n      unless guardian.is_admin?\n        allowed = guardian.secure_category_ids\n        if allowed.present?\n          reaction_users = reaction_users.where(\"(categories.read_restricted IS NULL OR\n                         NOT categories.read_restricted OR\n                        (categories.read_restricted and categories.id in (:categories)) )\", categories: guardian.secure_category_ids)\n        else\n          reaction_users = reaction_users.where(\"(categories.read_restricted IS NULL OR NOT categories.read_restricted)\")\n        end\n      end\n\n      reaction_users\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rails_helper'\nrequire_relative '../fabricators/reaction_fabricator.rb'\nrequire_relative '../fabricators/reaction_user_fabricator.rb'\n\ndescribe DiscourseReactions::CustomReactionsController do\n  fab!(:post_1) { Fabricate(:post) }\n  fab!(:user_1) { Fabricate(:user) }\n  fab!(:user_2) { Fabricate(:user) }\n  fab!(:user_3) { Fabricate(:user) }\n  fab!(:user_4) { Fabricate(:user) }\n  fab!(:user_5) { Fabricate(:user) }\n  fab!(:post_2) { Fabricate(:post, user: user_1) }\n  fab!(:reaction_1) { Fabricate(:reaction, post: post_2, reaction_value: \"laughing\") }\n  fab!(:reaction_2) { Fabricate(:reaction, post: post_2, reaction_value: \"open_mouth\") }\n  fab!(:reaction_3) { Fabricate(:reaction, post: post_2, reaction_value: \"hugs\") }\n  fab!(:like) { Fabricate(:post_action, post: post_2, user: user_5, post_action_type_id: PostActionType.types[:like]) }\n  fab!(:reaction_user_1) { Fabricate(:reaction_user, reaction: reaction_1, user: user_2, post: post_2) }\n  fab!(:reaction_user_2) { Fabricate(:reaction_user, reaction: reaction_1, user: user_1, post: post_2) }\n  fab!(:reaction_user_3) { Fabricate(:reaction_user, reaction: reaction_3, user: user_4, post: post_2) }\n  fab!(:reaction_user_4) { Fabricate(:reaction_user, reaction: reaction_2, user: user_3, post: post_2) }\n\n  before do\n    SiteSetting.discourse_reactions_like_icon = 'heart'\n    SiteSetting.discourse_reactions_enabled_reactions = \"laughing|open_mouth|cry|angry|thumbsup|hugs\"\n  end\n\n  context '#toggle' do\n    let(:payload_with_user) {\n      [\n        {\n          'id' => 'hugs',\n          'type' => 'emoji',\n          'count' => 1\n        }\n      ]\n    }\n\n    it 'toggles reaction' do\n      sign_in(user_1)\n      expected_payload = [\n        {\n          'id' => 'hugs',\n          'type' => 'emoji',\n          'count' => 1\n        }\n      ]\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(1)\n        .and change { DiscourseReactions::ReactionUser.count }.by(1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['reactions']).to eq(expected_payload)\n\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq('hugs')\n      expect(reaction.reaction_users_count).to eq(1)\n\n      sign_in(user_2)\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      reaction = DiscourseReactions::Reaction.last\n      expect(reaction.reaction_value).to eq('hugs')\n      expect(reaction.reaction_users_count).to eq(2)\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(0)\n        .and change { DiscourseReactions::ReactionUser.count }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['reactions']).to eq(expected_payload)\n\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(-1)\n        .and change { DiscourseReactions::ReactionUser.count }.by(-1)\n\n      expect(response.status).to eq(200)\n      expect(response.parsed_body['reactions']).to eq([])\n    end\n\n    it 'publishes MessageBus messages' do\n      sign_in(user_1)\n\n      messages = MessageBus.track_publish(\"/topic/#{post_1.topic.id}\") do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:data).map { |m| m[:type] }.uniq).to eq(%i(acted))\n\n      messages = MessageBus.track_publish(\"/topic/#{post_1.topic.id}/reactions\") do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      end\n      expect(messages.count).to eq(2)\n      expect(messages.map(&:channel).uniq.first).to eq(\"/topic/#{post_1.topic.id}/reactions\")\n    end\n\n    it 'errors when reaction is invalid' do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/invalid-reaction/toggle.json\"\n      end.to change { DiscourseReactions::Reaction.count }.by(0)\n\n      expect(response.status).to eq(422)\n    end\n  end\n\n  context '#reactions_given' do\n    fab!(:private_topic) { Fabricate(:private_message_topic, user: user_2) }\n    fab!(:private_post) { Fabricate(:post, topic: private_topic) }\n    fab!(:secure_group) { Fabricate(:group) }\n    fab!(:secure_category) { Fabricate(:private_category, group: secure_group) }\n    fab!(:secure_topic) { Fabricate(:topic, category: secure_category) }\n    fab!(:secure_post) { Fabricate(:post, topic: secure_topic) }\n    fab!(:private_reaction) { Fabricate(:reaction, post: private_post, reaction_value: \"hugs\") }\n    fab!(:secure_reaction) { Fabricate(:reaction, post: secure_post, reaction_value: \"hugs\") }\n    fab!(:private_topic_reaction_user) { Fabricate(:reaction_user, reaction: private_reaction, user: user_2, post: private_post) }\n    fab!(:secure_topic_reaction_user) { Fabricate(:reaction_user, reaction: secure_reaction, user: user_2, post: secure_post) }\n\n    it 'returns reactions given by a user' do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0]['user']['id']).to eq(user_2.id)\n      expect(parsed[0]['post_id']).to eq(post_2.id)\n      expect(parsed[0]['post']['user']['id']).to eq(user_1.id)\n      expect(parsed[0]['reaction']['id']).to eq(reaction_1.id)\n    end\n\n    it 'does not return reactions for private messages' do\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(private_post.id)\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(private_post.id)\n    end\n\n    it 'does not return reactions for secure categories' do\n      secure_group.add(user_2)\n      sign_in(user_1)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).not_to include(secure_post.id)\n\n      secure_group.add(user_1)\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions.json\", params: { username: user_2.username }\n      parsed = response.parsed_body\n      expect(response.parsed_body.map { |reaction| reaction[\"post_id\"] }).to include(secure_post.id)\n    end\n\n    context 'a post with one of your reactions has been deleted' do\n      fab!(:deleted_post) { Fabricate(:post) }\n      fab!(:kept_post) { Fabricate(:post) }\n      fab!(:user) { Fabricate(:user) }\n      fab!(:reaction_on_deleted_post) { Fabricate(:reaction, post: deleted_post, reaction_value: \"laughing\") }\n      fab!(:reaction_on_kept_post) { Fabricate(:reaction, post: kept_post, reaction_value: \"laughing\") }\n      fab!(:reaction_user_on_deleted_post) { Fabricate(:reaction_user, reaction: reaction_on_deleted_post, user: user, post: deleted_post) }\n      fab!(:reaction_user_on_kept_post) { Fabricate(:reaction_user, reaction: reaction_on_kept_post, user: user, post: kept_post) }\n\n      it 'doesn\u2019t return the deleted post/reaction' do\n        sign_in(user)\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n        expect(parsed.length).to eq(2)\n\n        PostDestroyer.new(Discourse.system_user, deleted_post).destroy\n\n        get \"/discourse-reactions/posts/reactions.json\", params: { username: user.username }\n        parsed = response.parsed_body\n\n        expect(parsed.length).to eq(1)\n        expect(parsed[0]['post_id']).to eq(kept_post.id)\n      end\n    end\n  end\n\n  context '#reactions_received' do\n    it 'returns reactions received by a user' do\n      sign_in(user_2)\n\n      get \"/discourse-reactions/posts/reactions-received.json\", params: { username: user_1.username }\n      parsed = response.parsed_body\n\n      expect(parsed[0]['user']['id']).to eq(user_3.id)\n      expect(parsed[0]['post_id']).to eq(post_2.id)\n      expect(parsed[0]['post']['user']['id']).to eq(user_1.id)\n      expect(parsed[0]['reaction']['id']).to eq(reaction_2.id)\n    end\n  end\n\n  context '#post_reactions_users' do\n    it 'return reaction_users of post when theres no parameters' do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_5.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_5.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(user_5.avatar_template)\n    end\n\n    it 'return reaction_users of reaction when there are parameters' do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{reaction_1.reaction_value}\"\n      parsed = response.parsed_body\n\n      expect(response.status).to eq(200)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"username\"]).to eq(user_1.username)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"name\"]).to eq(user_1.name)\n      expect(parsed[\"reaction_users\"][0][\"users\"][0][\"avatar_template\"]).to eq(user_1.avatar_template)\n    end\n\n    it \"gives 400 ERROR when the post_id OR reaction_value is invalid\" do\n      get \"/discourse-reactions/posts/1000000/reactions-users.json\"\n      expect(response.status).to eq(400)\n\n      get \"/discourse-reactions/posts/1000000/reactions-users.json?reaction_value=test\"\n      expect(response.status).to eq(400)\n    end\n\n    it 'merges identic custom reaction into likes' do\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      like_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(post_2.like_count)\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=laughing\"\n      parsed = response.parsed_body\n      reaction_count = parsed[\"reaction_users\"][0][\"count\"].to_i\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(reaction_1.reaction_users_count)\n\n      SiteSetting.discourse_reactions_reaction_for_like = 'laughing'\n\n      get \"/discourse-reactions/posts/#{post_2.id}/reactions-users.json?reaction_value=#{DiscourseReactions::Reaction.main_reaction_id}\"\n      parsed = response.parsed_body\n      expect(parsed[\"reaction_users\"][0][\"count\"]).to eq(like_count + reaction_count)\n    end\n  end\n\n  context 'positive notifications' do\n    before do\n      PostActionNotifier.enable\n    end\n\n    it 'creates notification when first like' do\n      sign_in(user_1)\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(1)\n        .and change { PostAction.count }.by(1)\n\n      expect(PostAction.last.post_action_type_id).to eq(PostActionType.types[:like])\n\n      expect do\n        put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/heart/toggle.json\"\n      end.to change { Notification.count }.by(-1)\n        .and change { PostAction.count }.by(-1)\n    end\n  end\n\n  context 'reaction notifications' do\n    it 'calls ReactinNotification service' do\n      sign_in(user_1)\n      DiscourseReactions::ReactionNotification.any_instance.expects(:create).once\n      DiscourseReactions::ReactionNotification.any_instance.expects(:delete).once\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/cry/toggle.json\"\n    end\n  end\n\n  it 'allows to delete reaction only in undo action window frame' do\n    SiteSetting.post_undo_action_window_mins = 10\n    sign_in(user_1)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1)\n      .and change { DiscourseReactions::ReactionUser.count }.by(1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(-1)\n      .and change { DiscourseReactions::ReactionUser.count }.by(-1)\n\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(1)\n      .and change { DiscourseReactions::ReactionUser.count }.by(1)\n\n    freeze_time(Time.zone.now + 11.minutes)\n    expect do\n      put \"/discourse-reactions/posts/#{post_1.id}/custom-reactions/hugs/toggle.json\"\n    end.to change { DiscourseReactions::Reaction.count }.by(0)\n      .and change { DiscourseReactions::ReactionUser.count }.by(0)\n\n    expect(response.status).to eq(403)\n  end\nend\n"], "filenames": ["app/controllers/discourse_reactions/custom_reactions_controller.rb", "spec/requests/custom_reactions_controller_spec.rb"], "buggy_code_start_loc": [35, 3], "buggy_code_end_loc": [189, 121], "fixing_code_start_loc": [35, 4], "fixing_code_end_loc": [228, 169], "type": "CWE-200", "message": "Discourse-reactions is a plugin for the Discourse platform that allows user to add their reactions to the post. In affected versions reactions given by user to secure topics and private messages are visible. This issue is patched in version 0.2 of discourse-reaction. Users who are unable to update are advised to disable the Discourse-reactions plugin in admin panel.", "other": {"cve": {"id": "CVE-2021-41140", "sourceIdentifier": "security-advisories@github.com", "published": "2021-10-19T18:15:08.030", "lastModified": "2022-08-12T16:16:03.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse-reactions is a plugin for the Discourse platform that allows user to add their reactions to the post. In affected versions reactions given by user to secure topics and private messages are visible. This issue is patched in version 0.2 of discourse-reaction. Users who are unable to update are advised to disable the Discourse-reactions plugin in admin panel."}, {"lang": "es", "value": "Discourse-reactions es un plugin para la plataforma Discourse que permite al usuario a\u00f1adir sus reacciones al post. En las versiones afectadas, las reacciones dadas por el usuario a temas seguros y mensajes privados son visibles. Este problema est\u00e1 parcheado en la versi\u00f3n 0.2 de discourse-reactions. Se aconseja a los usuarios que no puedan actualizar, deshabilitar el plugin Discourse-reactions en el panel de administraci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse_reactions:*:*:*:*:*:discourse:*:*", "versionEndExcluding": "0.2", "matchCriteriaId": "47F9288B-DA60-403C-B7D0-C101EFC0FCBB"}]}]}], "references": [{"url": "https://github.com/discourse/discourse-reactions/commit/213d90b82fd15c4186ebc290fee18817d9727d0d", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse-reactions/security/advisories/GHSA-9358-hwg5-jrmh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse-reactions/commit/213d90b82fd15c4186ebc290fee18817d9727d0d"}}