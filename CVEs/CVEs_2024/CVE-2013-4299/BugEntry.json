{"buggy_code": ["/*\n * Copyright (C) 2001-2002 Sistina Software (UK) Limited.\n * Copyright (C) 2006-2008 Red Hat GmbH\n *\n * This file is released under the GPL.\n */\n\n#include \"dm-exception-store.h\"\n\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/dm-io.h>\n\n#define DM_MSG_PREFIX \"persistent snapshot\"\n#define DM_CHUNK_SIZE_DEFAULT_SECTORS 32\t/* 16KB */\n\n/*-----------------------------------------------------------------\n * Persistent snapshots, by persistent we mean that the snapshot\n * will survive a reboot.\n *---------------------------------------------------------------*/\n\n/*\n * We need to store a record of which parts of the origin have\n * been copied to the snapshot device.  The snapshot code\n * requires that we copy exception chunks to chunk aligned areas\n * of the COW store.  It makes sense therefore, to store the\n * metadata in chunk size blocks.\n *\n * There is no backward or forward compatibility implemented,\n * snapshots with different disk versions than the kernel will\n * not be usable.  It is expected that \"lvcreate\" will blank out\n * the start of a fresh COW device before calling the snapshot\n * constructor.\n *\n * The first chunk of the COW device just contains the header.\n * After this there is a chunk filled with exception metadata,\n * followed by as many exception chunks as can fit in the\n * metadata areas.\n *\n * All on disk structures are in little-endian format.  The end\n * of the exceptions info is indicated by an exception with a\n * new_chunk of 0, which is invalid since it would point to the\n * header chunk.\n */\n\n/*\n * Magic for persistent snapshots: \"SnAp\" - Feeble isn't it.\n */\n#define SNAP_MAGIC 0x70416e53\n\n/*\n * The on-disk version of the metadata.\n */\n#define SNAPSHOT_DISK_VERSION 1\n\n#define NUM_SNAPSHOT_HDR_CHUNKS 1\n\nstruct disk_header {\n\t__le32 magic;\n\n\t/*\n\t * Is this snapshot valid.  There is no way of recovering\n\t * an invalid snapshot.\n\t */\n\t__le32 valid;\n\n\t/*\n\t * Simple, incrementing version. no backward\n\t * compatibility.\n\t */\n\t__le32 version;\n\n\t/* In sectors */\n\t__le32 chunk_size;\n} __packed;\n\nstruct disk_exception {\n\t__le64 old_chunk;\n\t__le64 new_chunk;\n} __packed;\n\nstruct core_exception {\n\tuint64_t old_chunk;\n\tuint64_t new_chunk;\n};\n\nstruct commit_callback {\n\tvoid (*callback)(void *, int success);\n\tvoid *context;\n};\n\n/*\n * The top level structure for a persistent exception store.\n */\nstruct pstore {\n\tstruct dm_exception_store *store;\n\tint version;\n\tint valid;\n\tuint32_t exceptions_per_area;\n\n\t/*\n\t * Now that we have an asynchronous kcopyd there is no\n\t * need for large chunk sizes, so it wont hurt to have a\n\t * whole chunks worth of metadata in memory at once.\n\t */\n\tvoid *area;\n\n\t/*\n\t * An area of zeros used to clear the next area.\n\t */\n\tvoid *zero_area;\n\n\t/*\n\t * An area used for header. The header can be written\n\t * concurrently with metadata (when invalidating the snapshot),\n\t * so it needs a separate buffer.\n\t */\n\tvoid *header_area;\n\n\t/*\n\t * Used to keep track of which metadata area the data in\n\t * 'chunk' refers to.\n\t */\n\tchunk_t current_area;\n\n\t/*\n\t * The next free chunk for an exception.\n\t *\n\t * When creating exceptions, all the chunks here and above are\n\t * free.  It holds the next chunk to be allocated.  On rare\n\t * occasions (e.g. after a system crash) holes can be left in\n\t * the exception store because chunks can be committed out of\n\t * order.\n\t *\n\t * When merging exceptions, it does not necessarily mean all the\n\t * chunks here and above are free.  It holds the value it would\n\t * have held if all chunks had been committed in order of\n\t * allocation.  Consequently the value may occasionally be\n\t * slightly too low, but since it's only used for 'status' and\n\t * it can never reach its minimum value too early this doesn't\n\t * matter.\n\t */\n\n\tchunk_t next_free;\n\n\t/*\n\t * The index of next free exception in the current\n\t * metadata area.\n\t */\n\tuint32_t current_committed;\n\n\tatomic_t pending_count;\n\tuint32_t callback_count;\n\tstruct commit_callback *callbacks;\n\tstruct dm_io_client *io_client;\n\n\tstruct workqueue_struct *metadata_wq;\n};\n\nstatic int alloc_area(struct pstore *ps)\n{\n\tint r = -ENOMEM;\n\tsize_t len;\n\n\tlen = ps->store->chunk_size << SECTOR_SHIFT;\n\n\t/*\n\t * Allocate the chunk_size block of memory that will hold\n\t * a single metadata area.\n\t */\n\tps->area = vmalloc(len);\n\tif (!ps->area)\n\t\tgoto err_area;\n\n\tps->zero_area = vzalloc(len);\n\tif (!ps->zero_area)\n\t\tgoto err_zero_area;\n\n\tps->header_area = vmalloc(len);\n\tif (!ps->header_area)\n\t\tgoto err_header_area;\n\n\treturn 0;\n\nerr_header_area:\n\tvfree(ps->zero_area);\n\nerr_zero_area:\n\tvfree(ps->area);\n\nerr_area:\n\treturn r;\n}\n\nstatic void free_area(struct pstore *ps)\n{\n\tif (ps->area)\n\t\tvfree(ps->area);\n\tps->area = NULL;\n\n\tif (ps->zero_area)\n\t\tvfree(ps->zero_area);\n\tps->zero_area = NULL;\n\n\tif (ps->header_area)\n\t\tvfree(ps->header_area);\n\tps->header_area = NULL;\n}\n\nstruct mdata_req {\n\tstruct dm_io_region *where;\n\tstruct dm_io_request *io_req;\n\tstruct work_struct work;\n\tint result;\n};\n\nstatic void do_metadata(struct work_struct *work)\n{\n\tstruct mdata_req *req = container_of(work, struct mdata_req, work);\n\n\treq->result = dm_io(req->io_req, 1, req->where, NULL);\n}\n\n/*\n * Read or write a chunk aligned and sized block of data from a device.\n */\nstatic int chunk_io(struct pstore *ps, void *area, chunk_t chunk, int rw,\n\t\t    int metadata)\n{\n\tstruct dm_io_region where = {\n\t\t.bdev = dm_snap_cow(ps->store->snap)->bdev,\n\t\t.sector = ps->store->chunk_size * chunk,\n\t\t.count = ps->store->chunk_size,\n\t};\n\tstruct dm_io_request io_req = {\n\t\t.bi_rw = rw,\n\t\t.mem.type = DM_IO_VMA,\n\t\t.mem.ptr.vma = area,\n\t\t.client = ps->io_client,\n\t\t.notify.fn = NULL,\n\t};\n\tstruct mdata_req req;\n\n\tif (!metadata)\n\t\treturn dm_io(&io_req, 1, &where, NULL);\n\n\treq.where = &where;\n\treq.io_req = &io_req;\n\n\t/*\n\t * Issue the synchronous I/O from a different thread\n\t * to avoid generic_make_request recursion.\n\t */\n\tINIT_WORK_ONSTACK(&req.work, do_metadata);\n\tqueue_work(ps->metadata_wq, &req.work);\n\tflush_workqueue(ps->metadata_wq);\n\n\treturn req.result;\n}\n\n/*\n * Convert a metadata area index to a chunk index.\n */\nstatic chunk_t area_location(struct pstore *ps, chunk_t area)\n{\n\treturn NUM_SNAPSHOT_HDR_CHUNKS + ((ps->exceptions_per_area + 1) * area);\n}\n\n/*\n * Read or write a metadata area.  Remembering to skip the first\n * chunk which holds the header.\n */\nstatic int area_io(struct pstore *ps, int rw)\n{\n\tint r;\n\tchunk_t chunk;\n\n\tchunk = area_location(ps, ps->current_area);\n\n\tr = chunk_io(ps, ps->area, chunk, rw, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void zero_memory_area(struct pstore *ps)\n{\n\tmemset(ps->area, 0, ps->store->chunk_size << SECTOR_SHIFT);\n}\n\nstatic int zero_disk_area(struct pstore *ps, chunk_t area)\n{\n\treturn chunk_io(ps, ps->zero_area, area_location(ps, area), WRITE, 0);\n}\n\nstatic int read_header(struct pstore *ps, int *new_snapshot)\n{\n\tint r;\n\tstruct disk_header *dh;\n\tunsigned chunk_size;\n\tint chunk_size_supplied = 1;\n\tchar *chunk_err;\n\n\t/*\n\t * Use default chunk size (or logical_block_size, if larger)\n\t * if none supplied\n\t */\n\tif (!ps->store->chunk_size) {\n\t\tps->store->chunk_size = max(DM_CHUNK_SIZE_DEFAULT_SECTORS,\n\t\t    bdev_logical_block_size(dm_snap_cow(ps->store->snap)->\n\t\t\t\t\t    bdev) >> 9);\n\t\tps->store->chunk_mask = ps->store->chunk_size - 1;\n\t\tps->store->chunk_shift = ffs(ps->store->chunk_size) - 1;\n\t\tchunk_size_supplied = 0;\n\t}\n\n\tps->io_client = dm_io_client_create();\n\tif (IS_ERR(ps->io_client))\n\t\treturn PTR_ERR(ps->io_client);\n\n\tr = alloc_area(ps);\n\tif (r)\n\t\treturn r;\n\n\tr = chunk_io(ps, ps->header_area, 0, READ, 1);\n\tif (r)\n\t\tgoto bad;\n\n\tdh = ps->header_area;\n\n\tif (le32_to_cpu(dh->magic) == 0) {\n\t\t*new_snapshot = 1;\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(dh->magic) != SNAP_MAGIC) {\n\t\tDMWARN(\"Invalid or corrupt snapshot\");\n\t\tr = -ENXIO;\n\t\tgoto bad;\n\t}\n\n\t*new_snapshot = 0;\n\tps->valid = le32_to_cpu(dh->valid);\n\tps->version = le32_to_cpu(dh->version);\n\tchunk_size = le32_to_cpu(dh->chunk_size);\n\n\tif (ps->store->chunk_size == chunk_size)\n\t\treturn 0;\n\n\tif (chunk_size_supplied)\n\t\tDMWARN(\"chunk size %u in device metadata overrides \"\n\t\t       \"table chunk size of %u.\",\n\t\t       chunk_size, ps->store->chunk_size);\n\n\t/* We had a bogus chunk_size. Fix stuff up. */\n\tfree_area(ps);\n\n\tr = dm_exception_store_set_chunk_size(ps->store, chunk_size,\n\t\t\t\t\t      &chunk_err);\n\tif (r) {\n\t\tDMERR(\"invalid on-disk chunk size %u: %s.\",\n\t\t      chunk_size, chunk_err);\n\t\treturn r;\n\t}\n\n\tr = alloc_area(ps);\n\treturn r;\n\nbad:\n\tfree_area(ps);\n\treturn r;\n}\n\nstatic int write_header(struct pstore *ps)\n{\n\tstruct disk_header *dh;\n\n\tmemset(ps->header_area, 0, ps->store->chunk_size << SECTOR_SHIFT);\n\n\tdh = ps->header_area;\n\tdh->magic = cpu_to_le32(SNAP_MAGIC);\n\tdh->valid = cpu_to_le32(ps->valid);\n\tdh->version = cpu_to_le32(ps->version);\n\tdh->chunk_size = cpu_to_le32(ps->store->chunk_size);\n\n\treturn chunk_io(ps, ps->header_area, 0, WRITE, 1);\n}\n\n/*\n * Access functions for the disk exceptions, these do the endian conversions.\n */\nstatic struct disk_exception *get_exception(struct pstore *ps, uint32_t index)\n{\n\tBUG_ON(index >= ps->exceptions_per_area);\n\n\treturn ((struct disk_exception *) ps->area) + index;\n}\n\nstatic void read_exception(struct pstore *ps,\n\t\t\t   uint32_t index, struct core_exception *result)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tresult->old_chunk = le64_to_cpu(de->old_chunk);\n\tresult->new_chunk = le64_to_cpu(de->new_chunk);\n}\n\nstatic void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n\nstatic void clear_exception(struct pstore *ps, uint32_t index)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* clear it */\n\tde->old_chunk = 0;\n\tde->new_chunk = 0;\n}\n\n/*\n * Registers the exceptions that are present in the current area.\n * 'full' is filled in to indicate if the area has been\n * filled.\n */\nstatic int insert_exceptions(struct pstore *ps,\n\t\t\t     int (*callback)(void *callback_context,\n\t\t\t\t\t     chunk_t old, chunk_t new),\n\t\t\t     void *callback_context,\n\t\t\t     int *full)\n{\n\tint r;\n\tunsigned int i;\n\tstruct core_exception e;\n\n\t/* presume the area is full */\n\t*full = 1;\n\n\tfor (i = 0; i < ps->exceptions_per_area; i++) {\n\t\tread_exception(ps, i, &e);\n\n\t\t/*\n\t\t * If the new_chunk is pointing at the start of\n\t\t * the COW device, where the first metadata area\n\t\t * is we know that we've hit the end of the\n\t\t * exceptions.  Therefore the area is not full.\n\t\t */\n\t\tif (e.new_chunk == 0LL) {\n\t\t\tps->current_committed = i;\n\t\t\t*full = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Keep track of the start of the free chunks.\n\t\t */\n\t\tif (ps->next_free <= e.new_chunk)\n\t\t\tps->next_free = e.new_chunk + 1;\n\n\t\t/*\n\t\t * Otherwise we add the exception to the snapshot.\n\t\t */\n\t\tr = callback(callback_context, e.old_chunk, e.new_chunk);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\n\t/*\n\t * Keeping reading chunks and inserting exceptions until\n\t * we find a partially full area.\n\t */\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tps->current_area--;\n\n\treturn 0;\n}\n\nstatic struct pstore *get_info(struct dm_exception_store *store)\n{\n\treturn (struct pstore *) store->context;\n}\n\nstatic void persistent_usage(struct dm_exception_store *store,\n\t\t\t     sector_t *total_sectors,\n\t\t\t     sector_t *sectors_allocated,\n\t\t\t     sector_t *metadata_sectors)\n{\n\tstruct pstore *ps = get_info(store);\n\n\t*sectors_allocated = ps->next_free * store->chunk_size;\n\t*total_sectors = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t/*\n\t * First chunk is the fixed header.\n\t * Then there are (ps->current_area + 1) metadata chunks, each one\n\t * separated from the next by ps->exceptions_per_area data chunks.\n\t */\n\t*metadata_sectors = (ps->current_area + 1 + NUM_SNAPSHOT_HDR_CHUNKS) *\n\t\t\t    store->chunk_size;\n}\n\nstatic void persistent_dtr(struct dm_exception_store *store)\n{\n\tstruct pstore *ps = get_info(store);\n\n\tdestroy_workqueue(ps->metadata_wq);\n\n\t/* Created in read_header */\n\tif (ps->io_client)\n\t\tdm_io_client_destroy(ps->io_client);\n\tfree_area(ps);\n\n\t/* Allocated in persistent_read_metadata */\n\tif (ps->callbacks)\n\t\tvfree(ps->callbacks);\n\n\tkfree(ps);\n}\n\nstatic int persistent_read_metadata(struct dm_exception_store *store,\n\t\t\t\t    int (*callback)(void *callback_context,\n\t\t\t\t\t\t    chunk_t old, chunk_t new),\n\t\t\t\t    void *callback_context)\n{\n\tint r, uninitialized_var(new_snapshot);\n\tstruct pstore *ps = get_info(store);\n\n\t/*\n\t * Read the snapshot header.\n\t */\n\tr = read_header(ps, &new_snapshot);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Now we know correct chunk_size, complete the initialisation.\n\t */\n\tps->exceptions_per_area = (ps->store->chunk_size << SECTOR_SHIFT) /\n\t\t\t\t  sizeof(struct disk_exception);\n\tps->callbacks = dm_vcalloc(ps->exceptions_per_area,\n\t\t\t\t   sizeof(*ps->callbacks));\n\tif (!ps->callbacks)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Do we need to setup a new snapshot ?\n\t */\n\tif (new_snapshot) {\n\t\tr = write_header(ps);\n\t\tif (r) {\n\t\t\tDMWARN(\"write_header failed\");\n\t\t\treturn r;\n\t\t}\n\n\t\tps->current_area = 0;\n\t\tzero_memory_area(ps);\n\t\tr = zero_disk_area(ps, 0);\n\t\tif (r)\n\t\t\tDMWARN(\"zero_disk_area(0) failed\");\n\t\treturn r;\n\t}\n\t/*\n\t * Sanity checks.\n\t */\n\tif (ps->version != SNAPSHOT_DISK_VERSION) {\n\t\tDMWARN(\"unable to handle snapshot disk version %d\",\n\t\t       ps->version);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Metadata are valid, but snapshot is invalidated\n\t */\n\tif (!ps->valid)\n\t\treturn 1;\n\n\t/*\n\t * Read the metadata.\n\t */\n\tr = read_exceptions(ps, callback, callback_context);\n\n\treturn r;\n}\n\nstatic int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t/* Is there enough room ? */\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\te->new_chunk = ps->next_free;\n\n\t/*\n\t * Move onto the next free pending, making sure to take\n\t * into account the location of the metadata chunks.\n\t */\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}\n\nstatic void persistent_commit_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e,\n\t\t\t\t\tvoid (*callback) (void *, int success),\n\t\t\t\t\tvoid *callback_context)\n{\n\tunsigned int i;\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tstruct commit_callback *cb;\n\n\tce.old_chunk = e->old_chunk;\n\tce.new_chunk = e->new_chunk;\n\twrite_exception(ps, ps->current_committed++, &ce);\n\n\t/*\n\t * Add the callback to the back of the array.  This code\n\t * is the only place where the callback array is\n\t * manipulated, and we know that it will never be called\n\t * multiple times concurrently.\n\t */\n\tcb = ps->callbacks + ps->callback_count++;\n\tcb->callback = callback;\n\tcb->context = callback_context;\n\n\t/*\n\t * If there are exceptions in flight and we have not yet\n\t * filled this metadata area there's nothing more to do.\n\t */\n\tif (!atomic_dec_and_test(&ps->pending_count) &&\n\t    (ps->current_committed != ps->exceptions_per_area))\n\t\treturn;\n\n\t/*\n\t * If we completely filled the current area, then wipe the next one.\n\t */\n\tif ((ps->current_committed == ps->exceptions_per_area) &&\n\t    zero_disk_area(ps, ps->current_area + 1))\n\t\tps->valid = 0;\n\n\t/*\n\t * Commit exceptions to disk.\n\t */\n\tif (ps->valid && area_io(ps, WRITE_FLUSH_FUA))\n\t\tps->valid = 0;\n\n\t/*\n\t * Advance to the next area if this one is full.\n\t */\n\tif (ps->current_committed == ps->exceptions_per_area) {\n\t\tps->current_committed = 0;\n\t\tps->current_area++;\n\t\tzero_memory_area(ps);\n\t}\n\n\tfor (i = 0; i < ps->callback_count; i++) {\n\t\tcb = ps->callbacks + i;\n\t\tcb->callback(cb->context, ps->valid);\n\t}\n\n\tps->callback_count = 0;\n}\n\nstatic int persistent_prepare_merge(struct dm_exception_store *store,\n\t\t\t\t    chunk_t *last_old_chunk,\n\t\t\t\t    chunk_t *last_new_chunk)\n{\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tint nr_consecutive;\n\tint r;\n\n\t/*\n\t * When current area is empty, move back to preceding area.\n\t */\n\tif (!ps->current_committed) {\n\t\t/*\n\t\t * Have we finished?\n\t\t */\n\t\tif (!ps->current_area)\n\t\t\treturn 0;\n\n\t\tps->current_area--;\n\t\tr = area_io(ps, READ);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tps->current_committed = ps->exceptions_per_area;\n\t}\n\n\tread_exception(ps, ps->current_committed - 1, &ce);\n\t*last_old_chunk = ce.old_chunk;\n\t*last_new_chunk = ce.new_chunk;\n\n\t/*\n\t * Find number of consecutive chunks within the current area,\n\t * working backwards.\n\t */\n\tfor (nr_consecutive = 1; nr_consecutive < ps->current_committed;\n\t     nr_consecutive++) {\n\t\tread_exception(ps, ps->current_committed - 1 - nr_consecutive,\n\t\t\t       &ce);\n\t\tif (ce.old_chunk != *last_old_chunk - nr_consecutive ||\n\t\t    ce.new_chunk != *last_new_chunk - nr_consecutive)\n\t\t\tbreak;\n\t}\n\n\treturn nr_consecutive;\n}\n\nstatic int persistent_commit_merge(struct dm_exception_store *store,\n\t\t\t\t   int nr_merged)\n{\n\tint r, i;\n\tstruct pstore *ps = get_info(store);\n\n\tBUG_ON(nr_merged > ps->current_committed);\n\n\tfor (i = 0; i < nr_merged; i++)\n\t\tclear_exception(ps, ps->current_committed - 1 - i);\n\n\tr = area_io(ps, WRITE_FLUSH_FUA);\n\tif (r < 0)\n\t\treturn r;\n\n\tps->current_committed -= nr_merged;\n\n\t/*\n\t * At this stage, only persistent_usage() uses ps->next_free, so\n\t * we make no attempt to keep ps->next_free strictly accurate\n\t * as exceptions may have been committed out-of-order originally.\n\t * Once a snapshot has become merging, we set it to the value it\n\t * would have held had all the exceptions been committed in order.\n\t *\n\t * ps->current_area does not get reduced by prepare_merge() until\n\t * after commit_merge() has removed the nr_merged previous exceptions.\n\t */\n\tps->next_free = area_location(ps, ps->current_area) +\n\t\t\tps->current_committed + 1;\n\n\treturn 0;\n}\n\nstatic void persistent_drop_snapshot(struct dm_exception_store *store)\n{\n\tstruct pstore *ps = get_info(store);\n\n\tps->valid = 0;\n\tif (write_header(ps))\n\t\tDMWARN(\"write header failed\");\n}\n\nstatic int persistent_ctr(struct dm_exception_store *store,\n\t\t\t  unsigned argc, char **argv)\n{\n\tstruct pstore *ps;\n\n\t/* allocate the pstore */\n\tps = kzalloc(sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\treturn -ENOMEM;\n\n\tps->store = store;\n\tps->valid = 1;\n\tps->version = SNAPSHOT_DISK_VERSION;\n\tps->area = NULL;\n\tps->zero_area = NULL;\n\tps->header_area = NULL;\n\tps->next_free = NUM_SNAPSHOT_HDR_CHUNKS + 1; /* header and 1st area */\n\tps->current_committed = 0;\n\n\tps->callback_count = 0;\n\tatomic_set(&ps->pending_count, 0);\n\tps->callbacks = NULL;\n\n\tps->metadata_wq = alloc_workqueue(\"ksnaphd\", WQ_MEM_RECLAIM, 0);\n\tif (!ps->metadata_wq) {\n\t\tkfree(ps);\n\t\tDMERR(\"couldn't start header metadata update thread\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstore->context = ps;\n\n\treturn 0;\n}\n\nstatic unsigned persistent_status(struct dm_exception_store *store,\n\t\t\t\t  status_type_t status, char *result,\n\t\t\t\t  unsigned maxlen)\n{\n\tunsigned sz = 0;\n\n\tswitch (status) {\n\tcase STATUSTYPE_INFO:\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\" P %llu\", (unsigned long long)store->chunk_size);\n\t}\n\n\treturn sz;\n}\n\nstatic struct dm_exception_store_type _persistent_type = {\n\t.name = \"persistent\",\n\t.module = THIS_MODULE,\n\t.ctr = persistent_ctr,\n\t.dtr = persistent_dtr,\n\t.read_metadata = persistent_read_metadata,\n\t.prepare_exception = persistent_prepare_exception,\n\t.commit_exception = persistent_commit_exception,\n\t.prepare_merge = persistent_prepare_merge,\n\t.commit_merge = persistent_commit_merge,\n\t.drop_snapshot = persistent_drop_snapshot,\n\t.usage = persistent_usage,\n\t.status = persistent_status,\n};\n\nstatic struct dm_exception_store_type _persistent_compat_type = {\n\t.name = \"P\",\n\t.module = THIS_MODULE,\n\t.ctr = persistent_ctr,\n\t.dtr = persistent_dtr,\n\t.read_metadata = persistent_read_metadata,\n\t.prepare_exception = persistent_prepare_exception,\n\t.commit_exception = persistent_commit_exception,\n\t.prepare_merge = persistent_prepare_merge,\n\t.commit_merge = persistent_commit_merge,\n\t.drop_snapshot = persistent_drop_snapshot,\n\t.usage = persistent_usage,\n\t.status = persistent_status,\n};\n\nint dm_persistent_snapshot_init(void)\n{\n\tint r;\n\n\tr = dm_exception_store_type_register(&_persistent_type);\n\tif (r) {\n\t\tDMERR(\"Unable to register persistent exception store type\");\n\t\treturn r;\n\t}\n\n\tr = dm_exception_store_type_register(&_persistent_compat_type);\n\tif (r) {\n\t\tDMERR(\"Unable to register old-style persistent exception \"\n\t\t      \"store type\");\n\t\tdm_exception_store_type_unregister(&_persistent_type);\n\t\treturn r;\n\t}\n\n\treturn r;\n}\n\nvoid dm_persistent_snapshot_exit(void)\n{\n\tdm_exception_store_type_unregister(&_persistent_type);\n\tdm_exception_store_type_unregister(&_persistent_compat_type);\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2001-2002 Sistina Software (UK) Limited.\n * Copyright (C) 2006-2008 Red Hat GmbH\n *\n * This file is released under the GPL.\n */\n\n#include \"dm-exception-store.h\"\n\n#include <linux/mm.h>\n#include <linux/pagemap.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/dm-io.h>\n\n#define DM_MSG_PREFIX \"persistent snapshot\"\n#define DM_CHUNK_SIZE_DEFAULT_SECTORS 32\t/* 16KB */\n\n/*-----------------------------------------------------------------\n * Persistent snapshots, by persistent we mean that the snapshot\n * will survive a reboot.\n *---------------------------------------------------------------*/\n\n/*\n * We need to store a record of which parts of the origin have\n * been copied to the snapshot device.  The snapshot code\n * requires that we copy exception chunks to chunk aligned areas\n * of the COW store.  It makes sense therefore, to store the\n * metadata in chunk size blocks.\n *\n * There is no backward or forward compatibility implemented,\n * snapshots with different disk versions than the kernel will\n * not be usable.  It is expected that \"lvcreate\" will blank out\n * the start of a fresh COW device before calling the snapshot\n * constructor.\n *\n * The first chunk of the COW device just contains the header.\n * After this there is a chunk filled with exception metadata,\n * followed by as many exception chunks as can fit in the\n * metadata areas.\n *\n * All on disk structures are in little-endian format.  The end\n * of the exceptions info is indicated by an exception with a\n * new_chunk of 0, which is invalid since it would point to the\n * header chunk.\n */\n\n/*\n * Magic for persistent snapshots: \"SnAp\" - Feeble isn't it.\n */\n#define SNAP_MAGIC 0x70416e53\n\n/*\n * The on-disk version of the metadata.\n */\n#define SNAPSHOT_DISK_VERSION 1\n\n#define NUM_SNAPSHOT_HDR_CHUNKS 1\n\nstruct disk_header {\n\t__le32 magic;\n\n\t/*\n\t * Is this snapshot valid.  There is no way of recovering\n\t * an invalid snapshot.\n\t */\n\t__le32 valid;\n\n\t/*\n\t * Simple, incrementing version. no backward\n\t * compatibility.\n\t */\n\t__le32 version;\n\n\t/* In sectors */\n\t__le32 chunk_size;\n} __packed;\n\nstruct disk_exception {\n\t__le64 old_chunk;\n\t__le64 new_chunk;\n} __packed;\n\nstruct core_exception {\n\tuint64_t old_chunk;\n\tuint64_t new_chunk;\n};\n\nstruct commit_callback {\n\tvoid (*callback)(void *, int success);\n\tvoid *context;\n};\n\n/*\n * The top level structure for a persistent exception store.\n */\nstruct pstore {\n\tstruct dm_exception_store *store;\n\tint version;\n\tint valid;\n\tuint32_t exceptions_per_area;\n\n\t/*\n\t * Now that we have an asynchronous kcopyd there is no\n\t * need for large chunk sizes, so it wont hurt to have a\n\t * whole chunks worth of metadata in memory at once.\n\t */\n\tvoid *area;\n\n\t/*\n\t * An area of zeros used to clear the next area.\n\t */\n\tvoid *zero_area;\n\n\t/*\n\t * An area used for header. The header can be written\n\t * concurrently with metadata (when invalidating the snapshot),\n\t * so it needs a separate buffer.\n\t */\n\tvoid *header_area;\n\n\t/*\n\t * Used to keep track of which metadata area the data in\n\t * 'chunk' refers to.\n\t */\n\tchunk_t current_area;\n\n\t/*\n\t * The next free chunk for an exception.\n\t *\n\t * When creating exceptions, all the chunks here and above are\n\t * free.  It holds the next chunk to be allocated.  On rare\n\t * occasions (e.g. after a system crash) holes can be left in\n\t * the exception store because chunks can be committed out of\n\t * order.\n\t *\n\t * When merging exceptions, it does not necessarily mean all the\n\t * chunks here and above are free.  It holds the value it would\n\t * have held if all chunks had been committed in order of\n\t * allocation.  Consequently the value may occasionally be\n\t * slightly too low, but since it's only used for 'status' and\n\t * it can never reach its minimum value too early this doesn't\n\t * matter.\n\t */\n\n\tchunk_t next_free;\n\n\t/*\n\t * The index of next free exception in the current\n\t * metadata area.\n\t */\n\tuint32_t current_committed;\n\n\tatomic_t pending_count;\n\tuint32_t callback_count;\n\tstruct commit_callback *callbacks;\n\tstruct dm_io_client *io_client;\n\n\tstruct workqueue_struct *metadata_wq;\n};\n\nstatic int alloc_area(struct pstore *ps)\n{\n\tint r = -ENOMEM;\n\tsize_t len;\n\n\tlen = ps->store->chunk_size << SECTOR_SHIFT;\n\n\t/*\n\t * Allocate the chunk_size block of memory that will hold\n\t * a single metadata area.\n\t */\n\tps->area = vmalloc(len);\n\tif (!ps->area)\n\t\tgoto err_area;\n\n\tps->zero_area = vzalloc(len);\n\tif (!ps->zero_area)\n\t\tgoto err_zero_area;\n\n\tps->header_area = vmalloc(len);\n\tif (!ps->header_area)\n\t\tgoto err_header_area;\n\n\treturn 0;\n\nerr_header_area:\n\tvfree(ps->zero_area);\n\nerr_zero_area:\n\tvfree(ps->area);\n\nerr_area:\n\treturn r;\n}\n\nstatic void free_area(struct pstore *ps)\n{\n\tif (ps->area)\n\t\tvfree(ps->area);\n\tps->area = NULL;\n\n\tif (ps->zero_area)\n\t\tvfree(ps->zero_area);\n\tps->zero_area = NULL;\n\n\tif (ps->header_area)\n\t\tvfree(ps->header_area);\n\tps->header_area = NULL;\n}\n\nstruct mdata_req {\n\tstruct dm_io_region *where;\n\tstruct dm_io_request *io_req;\n\tstruct work_struct work;\n\tint result;\n};\n\nstatic void do_metadata(struct work_struct *work)\n{\n\tstruct mdata_req *req = container_of(work, struct mdata_req, work);\n\n\treq->result = dm_io(req->io_req, 1, req->where, NULL);\n}\n\n/*\n * Read or write a chunk aligned and sized block of data from a device.\n */\nstatic int chunk_io(struct pstore *ps, void *area, chunk_t chunk, int rw,\n\t\t    int metadata)\n{\n\tstruct dm_io_region where = {\n\t\t.bdev = dm_snap_cow(ps->store->snap)->bdev,\n\t\t.sector = ps->store->chunk_size * chunk,\n\t\t.count = ps->store->chunk_size,\n\t};\n\tstruct dm_io_request io_req = {\n\t\t.bi_rw = rw,\n\t\t.mem.type = DM_IO_VMA,\n\t\t.mem.ptr.vma = area,\n\t\t.client = ps->io_client,\n\t\t.notify.fn = NULL,\n\t};\n\tstruct mdata_req req;\n\n\tif (!metadata)\n\t\treturn dm_io(&io_req, 1, &where, NULL);\n\n\treq.where = &where;\n\treq.io_req = &io_req;\n\n\t/*\n\t * Issue the synchronous I/O from a different thread\n\t * to avoid generic_make_request recursion.\n\t */\n\tINIT_WORK_ONSTACK(&req.work, do_metadata);\n\tqueue_work(ps->metadata_wq, &req.work);\n\tflush_workqueue(ps->metadata_wq);\n\n\treturn req.result;\n}\n\n/*\n * Convert a metadata area index to a chunk index.\n */\nstatic chunk_t area_location(struct pstore *ps, chunk_t area)\n{\n\treturn NUM_SNAPSHOT_HDR_CHUNKS + ((ps->exceptions_per_area + 1) * area);\n}\n\nstatic void skip_metadata(struct pstore *ps)\n{\n\tuint32_t stride = ps->exceptions_per_area + 1;\n\tchunk_t next_free = ps->next_free;\n\tif (sector_div(next_free, stride) == NUM_SNAPSHOT_HDR_CHUNKS)\n\t\tps->next_free++;\n}\n\n/*\n * Read or write a metadata area.  Remembering to skip the first\n * chunk which holds the header.\n */\nstatic int area_io(struct pstore *ps, int rw)\n{\n\tint r;\n\tchunk_t chunk;\n\n\tchunk = area_location(ps, ps->current_area);\n\n\tr = chunk_io(ps, ps->area, chunk, rw, 0);\n\tif (r)\n\t\treturn r;\n\n\treturn 0;\n}\n\nstatic void zero_memory_area(struct pstore *ps)\n{\n\tmemset(ps->area, 0, ps->store->chunk_size << SECTOR_SHIFT);\n}\n\nstatic int zero_disk_area(struct pstore *ps, chunk_t area)\n{\n\treturn chunk_io(ps, ps->zero_area, area_location(ps, area), WRITE, 0);\n}\n\nstatic int read_header(struct pstore *ps, int *new_snapshot)\n{\n\tint r;\n\tstruct disk_header *dh;\n\tunsigned chunk_size;\n\tint chunk_size_supplied = 1;\n\tchar *chunk_err;\n\n\t/*\n\t * Use default chunk size (or logical_block_size, if larger)\n\t * if none supplied\n\t */\n\tif (!ps->store->chunk_size) {\n\t\tps->store->chunk_size = max(DM_CHUNK_SIZE_DEFAULT_SECTORS,\n\t\t    bdev_logical_block_size(dm_snap_cow(ps->store->snap)->\n\t\t\t\t\t    bdev) >> 9);\n\t\tps->store->chunk_mask = ps->store->chunk_size - 1;\n\t\tps->store->chunk_shift = ffs(ps->store->chunk_size) - 1;\n\t\tchunk_size_supplied = 0;\n\t}\n\n\tps->io_client = dm_io_client_create();\n\tif (IS_ERR(ps->io_client))\n\t\treturn PTR_ERR(ps->io_client);\n\n\tr = alloc_area(ps);\n\tif (r)\n\t\treturn r;\n\n\tr = chunk_io(ps, ps->header_area, 0, READ, 1);\n\tif (r)\n\t\tgoto bad;\n\n\tdh = ps->header_area;\n\n\tif (le32_to_cpu(dh->magic) == 0) {\n\t\t*new_snapshot = 1;\n\t\treturn 0;\n\t}\n\n\tif (le32_to_cpu(dh->magic) != SNAP_MAGIC) {\n\t\tDMWARN(\"Invalid or corrupt snapshot\");\n\t\tr = -ENXIO;\n\t\tgoto bad;\n\t}\n\n\t*new_snapshot = 0;\n\tps->valid = le32_to_cpu(dh->valid);\n\tps->version = le32_to_cpu(dh->version);\n\tchunk_size = le32_to_cpu(dh->chunk_size);\n\n\tif (ps->store->chunk_size == chunk_size)\n\t\treturn 0;\n\n\tif (chunk_size_supplied)\n\t\tDMWARN(\"chunk size %u in device metadata overrides \"\n\t\t       \"table chunk size of %u.\",\n\t\t       chunk_size, ps->store->chunk_size);\n\n\t/* We had a bogus chunk_size. Fix stuff up. */\n\tfree_area(ps);\n\n\tr = dm_exception_store_set_chunk_size(ps->store, chunk_size,\n\t\t\t\t\t      &chunk_err);\n\tif (r) {\n\t\tDMERR(\"invalid on-disk chunk size %u: %s.\",\n\t\t      chunk_size, chunk_err);\n\t\treturn r;\n\t}\n\n\tr = alloc_area(ps);\n\treturn r;\n\nbad:\n\tfree_area(ps);\n\treturn r;\n}\n\nstatic int write_header(struct pstore *ps)\n{\n\tstruct disk_header *dh;\n\n\tmemset(ps->header_area, 0, ps->store->chunk_size << SECTOR_SHIFT);\n\n\tdh = ps->header_area;\n\tdh->magic = cpu_to_le32(SNAP_MAGIC);\n\tdh->valid = cpu_to_le32(ps->valid);\n\tdh->version = cpu_to_le32(ps->version);\n\tdh->chunk_size = cpu_to_le32(ps->store->chunk_size);\n\n\treturn chunk_io(ps, ps->header_area, 0, WRITE, 1);\n}\n\n/*\n * Access functions for the disk exceptions, these do the endian conversions.\n */\nstatic struct disk_exception *get_exception(struct pstore *ps, uint32_t index)\n{\n\tBUG_ON(index >= ps->exceptions_per_area);\n\n\treturn ((struct disk_exception *) ps->area) + index;\n}\n\nstatic void read_exception(struct pstore *ps,\n\t\t\t   uint32_t index, struct core_exception *result)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tresult->old_chunk = le64_to_cpu(de->old_chunk);\n\tresult->new_chunk = le64_to_cpu(de->new_chunk);\n}\n\nstatic void write_exception(struct pstore *ps,\n\t\t\t    uint32_t index, struct core_exception *e)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* copy it */\n\tde->old_chunk = cpu_to_le64(e->old_chunk);\n\tde->new_chunk = cpu_to_le64(e->new_chunk);\n}\n\nstatic void clear_exception(struct pstore *ps, uint32_t index)\n{\n\tstruct disk_exception *de = get_exception(ps, index);\n\n\t/* clear it */\n\tde->old_chunk = 0;\n\tde->new_chunk = 0;\n}\n\n/*\n * Registers the exceptions that are present in the current area.\n * 'full' is filled in to indicate if the area has been\n * filled.\n */\nstatic int insert_exceptions(struct pstore *ps,\n\t\t\t     int (*callback)(void *callback_context,\n\t\t\t\t\t     chunk_t old, chunk_t new),\n\t\t\t     void *callback_context,\n\t\t\t     int *full)\n{\n\tint r;\n\tunsigned int i;\n\tstruct core_exception e;\n\n\t/* presume the area is full */\n\t*full = 1;\n\n\tfor (i = 0; i < ps->exceptions_per_area; i++) {\n\t\tread_exception(ps, i, &e);\n\n\t\t/*\n\t\t * If the new_chunk is pointing at the start of\n\t\t * the COW device, where the first metadata area\n\t\t * is we know that we've hit the end of the\n\t\t * exceptions.  Therefore the area is not full.\n\t\t */\n\t\tif (e.new_chunk == 0LL) {\n\t\t\tps->current_committed = i;\n\t\t\t*full = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Keep track of the start of the free chunks.\n\t\t */\n\t\tif (ps->next_free <= e.new_chunk)\n\t\t\tps->next_free = e.new_chunk + 1;\n\n\t\t/*\n\t\t * Otherwise we add the exception to the snapshot.\n\t\t */\n\t\tr = callback(callback_context, e.old_chunk, e.new_chunk);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_exceptions(struct pstore *ps,\n\t\t\t   int (*callback)(void *callback_context, chunk_t old,\n\t\t\t\t\t   chunk_t new),\n\t\t\t   void *callback_context)\n{\n\tint r, full = 1;\n\n\t/*\n\t * Keeping reading chunks and inserting exceptions until\n\t * we find a partially full area.\n\t */\n\tfor (ps->current_area = 0; full; ps->current_area++) {\n\t\tr = area_io(ps, READ);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tr = insert_exceptions(ps, callback, callback_context, &full);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tps->current_area--;\n\n\tskip_metadata(ps);\n\n\treturn 0;\n}\n\nstatic struct pstore *get_info(struct dm_exception_store *store)\n{\n\treturn (struct pstore *) store->context;\n}\n\nstatic void persistent_usage(struct dm_exception_store *store,\n\t\t\t     sector_t *total_sectors,\n\t\t\t     sector_t *sectors_allocated,\n\t\t\t     sector_t *metadata_sectors)\n{\n\tstruct pstore *ps = get_info(store);\n\n\t*sectors_allocated = ps->next_free * store->chunk_size;\n\t*total_sectors = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t/*\n\t * First chunk is the fixed header.\n\t * Then there are (ps->current_area + 1) metadata chunks, each one\n\t * separated from the next by ps->exceptions_per_area data chunks.\n\t */\n\t*metadata_sectors = (ps->current_area + 1 + NUM_SNAPSHOT_HDR_CHUNKS) *\n\t\t\t    store->chunk_size;\n}\n\nstatic void persistent_dtr(struct dm_exception_store *store)\n{\n\tstruct pstore *ps = get_info(store);\n\n\tdestroy_workqueue(ps->metadata_wq);\n\n\t/* Created in read_header */\n\tif (ps->io_client)\n\t\tdm_io_client_destroy(ps->io_client);\n\tfree_area(ps);\n\n\t/* Allocated in persistent_read_metadata */\n\tif (ps->callbacks)\n\t\tvfree(ps->callbacks);\n\n\tkfree(ps);\n}\n\nstatic int persistent_read_metadata(struct dm_exception_store *store,\n\t\t\t\t    int (*callback)(void *callback_context,\n\t\t\t\t\t\t    chunk_t old, chunk_t new),\n\t\t\t\t    void *callback_context)\n{\n\tint r, uninitialized_var(new_snapshot);\n\tstruct pstore *ps = get_info(store);\n\n\t/*\n\t * Read the snapshot header.\n\t */\n\tr = read_header(ps, &new_snapshot);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Now we know correct chunk_size, complete the initialisation.\n\t */\n\tps->exceptions_per_area = (ps->store->chunk_size << SECTOR_SHIFT) /\n\t\t\t\t  sizeof(struct disk_exception);\n\tps->callbacks = dm_vcalloc(ps->exceptions_per_area,\n\t\t\t\t   sizeof(*ps->callbacks));\n\tif (!ps->callbacks)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * Do we need to setup a new snapshot ?\n\t */\n\tif (new_snapshot) {\n\t\tr = write_header(ps);\n\t\tif (r) {\n\t\t\tDMWARN(\"write_header failed\");\n\t\t\treturn r;\n\t\t}\n\n\t\tps->current_area = 0;\n\t\tzero_memory_area(ps);\n\t\tr = zero_disk_area(ps, 0);\n\t\tif (r)\n\t\t\tDMWARN(\"zero_disk_area(0) failed\");\n\t\treturn r;\n\t}\n\t/*\n\t * Sanity checks.\n\t */\n\tif (ps->version != SNAPSHOT_DISK_VERSION) {\n\t\tDMWARN(\"unable to handle snapshot disk version %d\",\n\t\t       ps->version);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Metadata are valid, but snapshot is invalidated\n\t */\n\tif (!ps->valid)\n\t\treturn 1;\n\n\t/*\n\t * Read the metadata.\n\t */\n\tr = read_exceptions(ps, callback, callback_context);\n\n\treturn r;\n}\n\nstatic int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t/* Is there enough room ? */\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\te->new_chunk = ps->next_free;\n\n\t/*\n\t * Move onto the next free pending, making sure to take\n\t * into account the location of the metadata chunks.\n\t */\n\tps->next_free++;\n\tskip_metadata(ps);\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}\n\nstatic void persistent_commit_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e,\n\t\t\t\t\tvoid (*callback) (void *, int success),\n\t\t\t\t\tvoid *callback_context)\n{\n\tunsigned int i;\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tstruct commit_callback *cb;\n\n\tce.old_chunk = e->old_chunk;\n\tce.new_chunk = e->new_chunk;\n\twrite_exception(ps, ps->current_committed++, &ce);\n\n\t/*\n\t * Add the callback to the back of the array.  This code\n\t * is the only place where the callback array is\n\t * manipulated, and we know that it will never be called\n\t * multiple times concurrently.\n\t */\n\tcb = ps->callbacks + ps->callback_count++;\n\tcb->callback = callback;\n\tcb->context = callback_context;\n\n\t/*\n\t * If there are exceptions in flight and we have not yet\n\t * filled this metadata area there's nothing more to do.\n\t */\n\tif (!atomic_dec_and_test(&ps->pending_count) &&\n\t    (ps->current_committed != ps->exceptions_per_area))\n\t\treturn;\n\n\t/*\n\t * If we completely filled the current area, then wipe the next one.\n\t */\n\tif ((ps->current_committed == ps->exceptions_per_area) &&\n\t    zero_disk_area(ps, ps->current_area + 1))\n\t\tps->valid = 0;\n\n\t/*\n\t * Commit exceptions to disk.\n\t */\n\tif (ps->valid && area_io(ps, WRITE_FLUSH_FUA))\n\t\tps->valid = 0;\n\n\t/*\n\t * Advance to the next area if this one is full.\n\t */\n\tif (ps->current_committed == ps->exceptions_per_area) {\n\t\tps->current_committed = 0;\n\t\tps->current_area++;\n\t\tzero_memory_area(ps);\n\t}\n\n\tfor (i = 0; i < ps->callback_count; i++) {\n\t\tcb = ps->callbacks + i;\n\t\tcb->callback(cb->context, ps->valid);\n\t}\n\n\tps->callback_count = 0;\n}\n\nstatic int persistent_prepare_merge(struct dm_exception_store *store,\n\t\t\t\t    chunk_t *last_old_chunk,\n\t\t\t\t    chunk_t *last_new_chunk)\n{\n\tstruct pstore *ps = get_info(store);\n\tstruct core_exception ce;\n\tint nr_consecutive;\n\tint r;\n\n\t/*\n\t * When current area is empty, move back to preceding area.\n\t */\n\tif (!ps->current_committed) {\n\t\t/*\n\t\t * Have we finished?\n\t\t */\n\t\tif (!ps->current_area)\n\t\t\treturn 0;\n\n\t\tps->current_area--;\n\t\tr = area_io(ps, READ);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\tps->current_committed = ps->exceptions_per_area;\n\t}\n\n\tread_exception(ps, ps->current_committed - 1, &ce);\n\t*last_old_chunk = ce.old_chunk;\n\t*last_new_chunk = ce.new_chunk;\n\n\t/*\n\t * Find number of consecutive chunks within the current area,\n\t * working backwards.\n\t */\n\tfor (nr_consecutive = 1; nr_consecutive < ps->current_committed;\n\t     nr_consecutive++) {\n\t\tread_exception(ps, ps->current_committed - 1 - nr_consecutive,\n\t\t\t       &ce);\n\t\tif (ce.old_chunk != *last_old_chunk - nr_consecutive ||\n\t\t    ce.new_chunk != *last_new_chunk - nr_consecutive)\n\t\t\tbreak;\n\t}\n\n\treturn nr_consecutive;\n}\n\nstatic int persistent_commit_merge(struct dm_exception_store *store,\n\t\t\t\t   int nr_merged)\n{\n\tint r, i;\n\tstruct pstore *ps = get_info(store);\n\n\tBUG_ON(nr_merged > ps->current_committed);\n\n\tfor (i = 0; i < nr_merged; i++)\n\t\tclear_exception(ps, ps->current_committed - 1 - i);\n\n\tr = area_io(ps, WRITE_FLUSH_FUA);\n\tif (r < 0)\n\t\treturn r;\n\n\tps->current_committed -= nr_merged;\n\n\t/*\n\t * At this stage, only persistent_usage() uses ps->next_free, so\n\t * we make no attempt to keep ps->next_free strictly accurate\n\t * as exceptions may have been committed out-of-order originally.\n\t * Once a snapshot has become merging, we set it to the value it\n\t * would have held had all the exceptions been committed in order.\n\t *\n\t * ps->current_area does not get reduced by prepare_merge() until\n\t * after commit_merge() has removed the nr_merged previous exceptions.\n\t */\n\tps->next_free = area_location(ps, ps->current_area) +\n\t\t\tps->current_committed + 1;\n\n\treturn 0;\n}\n\nstatic void persistent_drop_snapshot(struct dm_exception_store *store)\n{\n\tstruct pstore *ps = get_info(store);\n\n\tps->valid = 0;\n\tif (write_header(ps))\n\t\tDMWARN(\"write header failed\");\n}\n\nstatic int persistent_ctr(struct dm_exception_store *store,\n\t\t\t  unsigned argc, char **argv)\n{\n\tstruct pstore *ps;\n\n\t/* allocate the pstore */\n\tps = kzalloc(sizeof(*ps), GFP_KERNEL);\n\tif (!ps)\n\t\treturn -ENOMEM;\n\n\tps->store = store;\n\tps->valid = 1;\n\tps->version = SNAPSHOT_DISK_VERSION;\n\tps->area = NULL;\n\tps->zero_area = NULL;\n\tps->header_area = NULL;\n\tps->next_free = NUM_SNAPSHOT_HDR_CHUNKS + 1; /* header and 1st area */\n\tps->current_committed = 0;\n\n\tps->callback_count = 0;\n\tatomic_set(&ps->pending_count, 0);\n\tps->callbacks = NULL;\n\n\tps->metadata_wq = alloc_workqueue(\"ksnaphd\", WQ_MEM_RECLAIM, 0);\n\tif (!ps->metadata_wq) {\n\t\tkfree(ps);\n\t\tDMERR(\"couldn't start header metadata update thread\");\n\t\treturn -ENOMEM;\n\t}\n\n\tstore->context = ps;\n\n\treturn 0;\n}\n\nstatic unsigned persistent_status(struct dm_exception_store *store,\n\t\t\t\t  status_type_t status, char *result,\n\t\t\t\t  unsigned maxlen)\n{\n\tunsigned sz = 0;\n\n\tswitch (status) {\n\tcase STATUSTYPE_INFO:\n\t\tbreak;\n\tcase STATUSTYPE_TABLE:\n\t\tDMEMIT(\" P %llu\", (unsigned long long)store->chunk_size);\n\t}\n\n\treturn sz;\n}\n\nstatic struct dm_exception_store_type _persistent_type = {\n\t.name = \"persistent\",\n\t.module = THIS_MODULE,\n\t.ctr = persistent_ctr,\n\t.dtr = persistent_dtr,\n\t.read_metadata = persistent_read_metadata,\n\t.prepare_exception = persistent_prepare_exception,\n\t.commit_exception = persistent_commit_exception,\n\t.prepare_merge = persistent_prepare_merge,\n\t.commit_merge = persistent_commit_merge,\n\t.drop_snapshot = persistent_drop_snapshot,\n\t.usage = persistent_usage,\n\t.status = persistent_status,\n};\n\nstatic struct dm_exception_store_type _persistent_compat_type = {\n\t.name = \"P\",\n\t.module = THIS_MODULE,\n\t.ctr = persistent_ctr,\n\t.dtr = persistent_dtr,\n\t.read_metadata = persistent_read_metadata,\n\t.prepare_exception = persistent_prepare_exception,\n\t.commit_exception = persistent_commit_exception,\n\t.prepare_merge = persistent_prepare_merge,\n\t.commit_merge = persistent_commit_merge,\n\t.drop_snapshot = persistent_drop_snapshot,\n\t.usage = persistent_usage,\n\t.status = persistent_status,\n};\n\nint dm_persistent_snapshot_init(void)\n{\n\tint r;\n\n\tr = dm_exception_store_type_register(&_persistent_type);\n\tif (r) {\n\t\tDMERR(\"Unable to register persistent exception store type\");\n\t\treturn r;\n\t}\n\n\tr = dm_exception_store_type_register(&_persistent_compat_type);\n\tif (r) {\n\t\tDMERR(\"Unable to register old-style persistent exception \"\n\t\t      \"store type\");\n\t\tdm_exception_store_type_unregister(&_persistent_type);\n\t\treturn r;\n\t}\n\n\treturn r;\n}\n\nvoid dm_persistent_snapshot_exit(void)\n{\n\tdm_exception_store_type_unregister(&_persistent_type);\n\tdm_exception_store_type_unregister(&_persistent_compat_type);\n}\n"], "filenames": ["drivers/md/dm-snap-persistent.c"], "buggy_code_start_loc": [271], "buggy_code_end_loc": [637], "fixing_code_start_loc": [272], "fixing_code_end_loc": [643], "type": "CWE-200", "message": "Interpretation conflict in drivers/md/dm-snap-persistent.c in the Linux kernel through 3.11.6 allows remote authenticated users to obtain sensitive information or modify data via a crafted mapping to a snapshot block device.", "other": {"cve": {"id": "CVE-2013-4299", "sourceIdentifier": "secalert@redhat.com", "published": "2013-10-24T10:53:09.613", "lastModified": "2019-04-22T17:48:00.643", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Interpretation conflict in drivers/md/dm-snap-persistent.c in the Linux kernel through 3.11.6 allows remote authenticated users to obtain sensitive information or modify data via a crafted mapping to a snapshot block device."}, {"lang": "es", "value": "Conflicto de interpretaci\u00f3n en drivers/md/dm-snap-persistent.c en el kernel de Linux hasta 3.11.6 permite a usuarios remotamente autenticados obtener informaci\u00f3n sensible o modificar datos a trav\u00e9s de un mapeado manipulado a un dispositivo de capturas de bloque."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.11.6", "matchCriteriaId": "C3D55C7B-D6AF-4DB4-8CCC-3BFC8C15F45D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "D30AEC07-3CBD-4F4F-9646-BEAA1D98750B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "C2AA8E68-691B-499C-AEDD-3C0BFFE70044"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "9440475B-5960-4066-A204-F30AAFC87846"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "53BCFBFB-6AF0-4525-8623-7633CC5E17DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "6ED4E86A-74F0-436A-BEB4-3F4EE93A5421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc6:*:*:*:*:*:*", "matchCriteriaId": "BF0365B0-8E16-4F30-BD92-5DD538CC8135"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0:rc7:*:*:*:*:*:*", "matchCriteriaId": "079505E8-2942-4C33-93D1-35ADA4C39E72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "38989541-2360-4E0A-AE5A-3D6144AA6114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "4E51646B-7A0E-40F3-B8C9-239C1DA81DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "42A8A507-F8E2-491C-A144-B2448A1DB26E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "901FC6F3-2C2A-4112-AE27-AB102BBE8DEE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "203AD334-DB9F-41B0-A4D1-A6C158EF8C40"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "B3611753-E440-410F-8250-600C996A4B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.7:*:*:*:*:*:*:*", "matchCriteriaId": "9739BB47-EEAF-42F1-A557-2AE2EA9526A3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.8:*:*:*:*:*:*:*", "matchCriteriaId": "5A95E3BB-0AFC-4C2E-B9BE-C975E902A266"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.9:*:*:*:*:*:*:*", "matchCriteriaId": "482A6C9A-9B8E-4D1C-917A-F16370745E7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.10:*:*:*:*:*:*:*", "matchCriteriaId": "C6D87357-63E0-41D0-9F02-1BCBF9A77E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.11:*:*:*:*:*:*:*", "matchCriteriaId": "3765A2D6-2D78-4FB1-989E-D5106BFA3F5E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "F54257DB-7023-43C4-AC4D-9590B815CD92"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.13:*:*:*:*:*:*:*", "matchCriteriaId": "61FF5FCD-A4A1-4803-AC53-320A4C838AF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.14:*:*:*:*:*:*:*", "matchCriteriaId": "9F096553-064F-46A2-877B-F32F163A0F49"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.15:*:*:*:*:*:*:*", "matchCriteriaId": "C0D762D1-E3AD-40EA-8D39-83EEB51B5E85"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.16:*:*:*:*:*:*:*", "matchCriteriaId": "A6187D19-7148-4B87-AD7E-244FF9EE0FA6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.17:*:*:*:*:*:*:*", "matchCriteriaId": "99AC64C2-E391-485C-9CD7-BA09C8FA5E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.18:*:*:*:*:*:*:*", "matchCriteriaId": "8CDA5E95-7805-441B-BEF7-4448EA45E964"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.19:*:*:*:*:*:*:*", "matchCriteriaId": "51561053-6C28-4F38-BC9B-3F7A7508EB72"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.20:*:*:*:*:*:*:*", "matchCriteriaId": "118F4A5B-C498-4FC3-BE28-50D18EBE4F22"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.21:*:*:*:*:*:*:*", "matchCriteriaId": "BD38EBE6-FE1A-4B55-9FB5-07952253B7A5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.22:*:*:*:*:*:*:*", "matchCriteriaId": "3A491E47-82AD-4055-9444-2EC0D6715326"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.23:*:*:*:*:*:*:*", "matchCriteriaId": "13C5FD16-23B6-467F-9438-5B554922F974"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.24:*:*:*:*:*:*:*", "matchCriteriaId": "9C67235F-5B51-4BF7-89EC-4810F720246F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.25:*:*:*:*:*:*:*", "matchCriteriaId": "08405DEF-05F4-45F0-AC95-DBF914A36D93"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.26:*:*:*:*:*:*:*", "matchCriteriaId": "1A7B9C4B-4A41-4175-9F07-191C1EE98C1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.27:*:*:*:*:*:*:*", "matchCriteriaId": "B306E0A8-4D4A-4895-8128-A500D30A7E0C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.28:*:*:*:*:*:*:*", "matchCriteriaId": "295C839A-F34E-4853-A926-55EABC639412"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.29:*:*:*:*:*:*:*", "matchCriteriaId": "2AFD5F49-7EF9-4CFE-95BD-8FD19B500B0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.30:*:*:*:*:*:*:*", "matchCriteriaId": "00B3DDDD-B2F6-4753-BA38-65A24017857D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.31:*:*:*:*:*:*:*", "matchCriteriaId": "33FCD39E-F4BF-432D-9CF9-F195CF5844F3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.32:*:*:*:*:*:*:*", "matchCriteriaId": "C7308690-CB0D-4758-B80F-D2ADCD2A9D66"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.33:*:*:*:*:*:*:*", "matchCriteriaId": "313A470B-8A2B-478A-82B5-B27D2718331C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.34:*:*:*:*:*:*:*", "matchCriteriaId": "83FF021E-07E3-41CC-AAE8-D99D7FF24B9D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.35:*:*:*:*:*:*:*", "matchCriteriaId": "F72412E3-8DA9-4CC9-A426-B534202ADBA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.36:*:*:*:*:*:*:*", "matchCriteriaId": "FCAA9D7A-3C3E-4C0B-9D38-EA80E68C2E46"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.37:*:*:*:*:*:*:*", "matchCriteriaId": "4A9E3AE5-3FCF-4CBB-A30B-082BCFBFB0CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.38:*:*:*:*:*:*:*", "matchCriteriaId": "CF715657-4C3A-4392-B85D-1BBF4DE45D89"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.39:*:*:*:*:*:*:*", "matchCriteriaId": "4B63C618-AC3D-4EF7-AFDF-27B9BF482B78"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.40:*:*:*:*:*:*:*", "matchCriteriaId": "C33DA5A9-5E40-4365-9602-82FB4DCD15B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.41:*:*:*:*:*:*:*", "matchCriteriaId": "EFAFDB74-40BD-46FA-89AC-617EB2C7160B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.42:*:*:*:*:*:*:*", "matchCriteriaId": "CF5F17DA-30A7-40CF-BD7C-CEDF06D64617"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.43:*:*:*:*:*:*:*", "matchCriteriaId": "71A276F5-BD9D-4C1B-90DF-9B0C15B6F7DF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.44:*:*:*:*:*:*:*", "matchCriteriaId": "F8F6EBEC-3C29-444B-BB85-6EF239B59EC1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.45:*:*:*:*:*:*:*", "matchCriteriaId": "FDB91302-FD18-44CF-A8A8-B31483328539"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.46:*:*:*:*:*:*:*", "matchCriteriaId": "9B81DC2B-46FA-4640-AD6C-2A404D94BA0B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.47:*:*:*:*:*:*:*", "matchCriteriaId": "BA6A1663-BC4C-4FC9-B5EB-A52EDED17B26"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.48:*:*:*:*:*:*:*", "matchCriteriaId": "69C33D6C-6B9F-49F4-B505-E7B589CDEC50"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.49:*:*:*:*:*:*:*", "matchCriteriaId": "C464796B-2F31-4159-A132-82A0C74137B7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.50:*:*:*:*:*:*:*", "matchCriteriaId": "1D6C6E46-FE29-4D2D-A0EC-43DA5112BCC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.51:*:*:*:*:*:*:*", "matchCriteriaId": "1A370E91-73A1-4D62-8E7B-696B920203F8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.52:*:*:*:*:*:*:*", "matchCriteriaId": "340197CD-9645-4B7E-B976-F3F5A7D4C5BE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.53:*:*:*:*:*:*:*", "matchCriteriaId": "96030636-0C4A-4A10-B768-525D6A0E18CB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.54:*:*:*:*:*:*:*", "matchCriteriaId": "A42D8419-914F-4AD6-B0E9-C1290D514FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.55:*:*:*:*:*:*:*", "matchCriteriaId": "F4E2C88B-42EA-4F4F-B1F6-A9332EC6888B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.56:*:*:*:*:*:*:*", "matchCriteriaId": "2449D13B-3314-4182-832F-03F6B11AA31F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.57:*:*:*:*:*:*:*", "matchCriteriaId": "9A35B66C-F050-4462-A58E-FEE061B5582E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.58:*:*:*:*:*:*:*", "matchCriteriaId": "1B551164-0167-49BB-A3AE-4034BDA3DCB4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.59:*:*:*:*:*:*:*", "matchCriteriaId": "7244278E-49B6-4405-A14C-F3540C8F5AF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.60:*:*:*:*:*:*:*", "matchCriteriaId": "B4C3E4B8-7274-4ABB-B7CE-6A39C183CE18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.61:*:*:*:*:*:*:*", "matchCriteriaId": "6501EDB9-4847-47F8-90EE-B295626E4CDC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.62:*:*:*:*:*:*:*", "matchCriteriaId": "2D676D48-7521-45E2-8563-6B966FF86A35"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.63:*:*:*:*:*:*:*", "matchCriteriaId": "3B69FA17-0AB9-4986-A5A7-2A4C1DD24222"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.64:*:*:*:*:*:*:*", "matchCriteriaId": "7BC35593-96C7-41F0-B738-1568F8129121"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.65:*:*:*:*:*:*:*", "matchCriteriaId": "38D23794-0E7C-4FA5-A7A8-CF940E3FA962"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.66:*:*:*:*:*:*:*", "matchCriteriaId": "008E1E7D-4C20-4560-9288-EF532ADB0029"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.67:*:*:*:*:*:*:*", "matchCriteriaId": "3B3A7044-A92E-47A9-A7BD-35E5B575F5FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.0.68:*:*:*:*:*:*:*", "matchCriteriaId": "783E2980-B6AB-489E-B157-B6A2E10A32CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "3DFFE5A6-6A67-4992-84A3-C0F05FACDEAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc1:*:*:*:*:*:*", "matchCriteriaId": "13BBD2A3-AE10-48B9-8776-4FB1CAC37D44"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc2:*:*:*:*:*:*", "matchCriteriaId": "B25680CC-8918-4F27-8D7E-A6579215450B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc3:*:*:*:*:*:*", "matchCriteriaId": "92C48B4C-410C-4BA8-A28A-B2E928320FCC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1:rc4:*:*:*:*:*:*", "matchCriteriaId": "CB447523-855B-461E-8197-95169BE86EB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "B155BBDF-6DF6-4FF5-9C41-D8A5266DCC67"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "28476DEC-9630-4B40-9D4D-9BC151DC4CA4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "5646880A-2355-4BDD-89E7-825863A0311F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.4:*:*:*:*:*:*:*", "matchCriteriaId": "7FF99148-267A-46F8-9927-A9082269BAF6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.5:*:*:*:*:*:*:*", "matchCriteriaId": "A783C083-5D9C-48F9-B5A6-A97A9604FB19"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.6:*:*:*:*:*:*:*", "matchCriteriaId": "2B817A24-03AC-46CD-BEFA-505457FD2A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.7:*:*:*:*:*:*:*", "matchCriteriaId": "51CF1BCE-090E-4B70-BA16-ACB74411293B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.8:*:*:*:*:*:*:*", "matchCriteriaId": "187AAD67-10D7-4B57-B4C6-00443E246AF3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.9:*:*:*:*:*:*:*", "matchCriteriaId": "F341CE88-C5BC-4CDD-9CB5-B6BAD7152E63"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.1.10:*:*:*:*:*:*:*", "matchCriteriaId": "37ACE2A6-C229-4236-8E9F-235F008F3AA0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "D3220B70-917F-4F9F-8A3B-2BF581281E8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc2:*:*:*:*:*:*", "matchCriteriaId": "99372D07-C06A-41FA-9843-6D57F99AB5AF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc3:*:*:*:*:*:*", "matchCriteriaId": "2B9DC110-D260-4DB4-B8B0-EF1D160ADA07"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc4:*:*:*:*:*:*", "matchCriteriaId": "6192FE84-4D53-40D4-AF61-78CE7136141A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc5:*:*:*:*:*:*", "matchCriteriaId": "42FEF3CF-1302-45EB-89CC-3786FE4BAC1F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc6:*:*:*:*:*:*", "matchCriteriaId": "AE6A6B58-2C89-4DE4-BA57-78100818095C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2:rc7:*:*:*:*:*:*", "matchCriteriaId": "1D467F87-2F13-4D26-9A93-E0BA526FEA24"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "FE348F7B-02DE-47D5-8011-F83DA9426021"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "E91594EA-F0A3-41B3-A9C6-F7864FC2F229"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.3:*:*:*:*:*:*:*", "matchCriteriaId": "9E1ECCDB-0208-48F6-B44F-16CC0ECE3503"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "FBA8B5DE-372E-47E0-A0F6-BE286D509CC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.5:*:*:*:*:*:*:*", "matchCriteriaId": "9A1CA083-2CF8-45AE-9E15-1AA3A8352E3B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.6:*:*:*:*:*:*:*", "matchCriteriaId": "19D69A49-5290-4C5F-8157-719AD58D253D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.7:*:*:*:*:*:*:*", "matchCriteriaId": "290BD969-42E7-47B0-B21B-06DE4865432C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.8:*:*:*:*:*:*:*", "matchCriteriaId": "23A9E29E-DE78-4C73-9FBD-C2410F5FC8B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.9:*:*:*:*:*:*:*", "matchCriteriaId": "018434C9-E75F-45CB-A169-DAB4B1D864D7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.10:*:*:*:*:*:*:*", "matchCriteriaId": "DC0AC68F-EC58-4C4F-8CBC-A59ECC00CCDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.11:*:*:*:*:*:*:*", "matchCriteriaId": "C123C844-F6D7-471E-A62E-F756042FB1CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.12:*:*:*:*:*:*:*", "matchCriteriaId": "A11C38BB-7FA2-49B0-AAC9-83DB387A06DB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.13:*:*:*:*:*:*:*", "matchCriteriaId": "61F3733C-E5F6-4855-B471-DF3FB823613B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.14:*:*:*:*:*:*:*", "matchCriteriaId": "1DDCA75F-9A06-4457-9A45-38A38E7F7086"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.15:*:*:*:*:*:*:*", "matchCriteriaId": "7AEA837E-7864-4003-8DB7-111ED710A7E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.16:*:*:*:*:*:*:*", "matchCriteriaId": "B6FE471F-2D1F-4A1D-A197-7E46B75787E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.17:*:*:*:*:*:*:*", "matchCriteriaId": "FDA9E6AB-58DC-4EC5-A25C-11F9D0B38BF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.18:*:*:*:*:*:*:*", "matchCriteriaId": "DC6B8DB3-B05B-41A2-B091-342D66AAE8F5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.19:*:*:*:*:*:*:*", "matchCriteriaId": "958F0FF8-33EF-4A71-A0BD-572C85211DBA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.20:*:*:*:*:*:*:*", "matchCriteriaId": "FBA39F48-B02F-4C48-B304-DA9CCA055244"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.21:*:*:*:*:*:*:*", "matchCriteriaId": "1FF841F3-48A7-41D7-9C45-A8170435A5EB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.22:*:*:*:*:*:*:*", "matchCriteriaId": "EF506916-A6DC-4B1E-90E5-959492AF55F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.23:*:*:*:*:*:*:*", "matchCriteriaId": "B3CDAD1F-2C6A-48C0-8FAB-C2659373FA25"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.24:*:*:*:*:*:*:*", "matchCriteriaId": "4FFE4B22-C96A-43D0-B993-F51EDD9C5E0E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.25:*:*:*:*:*:*:*", "matchCriteriaId": "F571CC8B-B212-4553-B463-1DB01D616E8A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.26:*:*:*:*:*:*:*", "matchCriteriaId": "84E3E151-D437-48ED-A529-731EEFF88567"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.27:*:*:*:*:*:*:*", "matchCriteriaId": "E9E3EA3C-CCA5-4433-86E0-3D02C4757A0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.28:*:*:*:*:*:*:*", "matchCriteriaId": "F7AC4F7D-9FA6-4CF1-B2E9-70BF7D4D177C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.29:*:*:*:*:*:*:*", "matchCriteriaId": "3CE3A80D-9648-43CC-8F99-D741ED6552BF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.2.30:*:*:*:*:*:*:*", "matchCriteriaId": "C8A98C03-A465-41B4-A551-A26FEC7FFD94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "AFB76697-1C2F-48C0-9B14-517EC053D4B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "BED88DFD-1DC5-4505-A441-44ECDEF0252D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc2:*:*:*:*:*:*", "matchCriteriaId": "DBFD2ACD-728A-4082-BB6A-A1EF6E58E47D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc3:*:*:*:*:*:*", "matchCriteriaId": "C31B0E51-F62D-4053-B04F-FC4D5BC373D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc4:*:*:*:*:*:*", "matchCriteriaId": "A914303E-1CB6-4AAD-9F5F-DE5433C4E814"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc5:*:*:*:*:*:*", "matchCriteriaId": "203BBA69-90B2-4C5E-8023-C14180742421"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc6:*:*:*:*:*:*", "matchCriteriaId": "0DBFAB53-B889-4028-AC0E-7E165B152A18"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3:rc7:*:*:*:*:*:*", "matchCriteriaId": "FE409AEC-F677-4DEF-8EB7-2C35809043CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "578EC12B-402F-4AD4-B8F8-C9B2CAB06891"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "877002ED-8097-4BB4-BB88-6FC6306C38B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "76294CE3-D72C-41D5-9E0F-B693D0042699"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "916E97D4-1FAB-42F5-826B-653B1C0909A8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "33FD2217-C5D0-48C1-AD74-3527127FEF9C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.6:*:*:*:*:*:*:*", "matchCriteriaId": "2E92971F-B629-4E0A-9A50-8B235F9704B8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.7:*:*:*:*:*:*:*", "matchCriteriaId": "EDD3A069-3829-4EE2-9D5A-29459F29D4C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.3.8:*:*:*:*:*:*:*", "matchCriteriaId": "A4A0964C-CEB2-41D7-A69C-1599B05B6171"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "0F960FA6-F904-4A4E-B483-44C70090E9A1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc1:*:*:*:*:*:*", "matchCriteriaId": "261C1B41-C9E0-414F-8368-51C0C0B8AD38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc2:*:*:*:*:*:*", "matchCriteriaId": "5CCA261D-2B97-492F-89A0-5F209A804350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc3:*:*:*:*:*:*", "matchCriteriaId": "1B1C0C68-9194-473F-BE5E-EC7F184899FA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc4:*:*:*:*:*:*", "matchCriteriaId": "D7A6AC9E-BEA6-44B0-B3B3-F0F94E32424A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc5:*:*:*:*:*:*", "matchCriteriaId": "16038328-9399-4B85-B777-BA4757D02C9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc6:*:*:*:*:*:*", "matchCriteriaId": "16CA2757-FA8D-43D9-96E8-D3C0EB6E1DEF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4:rc7:*:*:*:*:*:*", "matchCriteriaId": "E8CB5481-5EAE-401E-BD7E-D3095CCA9E94"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A0F36FAC-141D-476D-84C5-A558C199F904"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "51D64824-25F6-4761-BD6A-29038A143744"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "E284C8A1-740F-454D-A774-99CD3A21B594"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.4:*:*:*:*:*:*:*", "matchCriteriaId": "C70D72AE-0CBF-4324-9935-57E28EC6279C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.5:*:*:*:*:*:*:*", "matchCriteriaId": "F674B06B-7E86-4E41-9126-8152D0DDABAE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.6:*:*:*:*:*:*:*", "matchCriteriaId": "7039B3EC-8B22-413E-B582-B4BEC6181241"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.7:*:*:*:*:*:*:*", "matchCriteriaId": "35CF1DD2-80B9-4476-8963-5C3EF52B33F4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.8:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0B05B-A5CE-4B9C-AE7F-83062868D35B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.9:*:*:*:*:*:*:*", "matchCriteriaId": "D166A66E-7454-47EC-BB56-861A9AFEAFE1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.10:*:*:*:*:*:*:*", "matchCriteriaId": "7DA94F50-2A62-4300-BF4D-A342AAE35629"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.11:*:*:*:*:*:*:*", "matchCriteriaId": "252D937B-50DC-444F-AE73-5FCF6203DF27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.12:*:*:*:*:*:*:*", "matchCriteriaId": "F6D8EE51-02C1-47BC-A92C-0A8ABEFD28FF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.13:*:*:*:*:*:*:*", "matchCriteriaId": "7F20A5D7-3B38-4911-861A-04C8310D5916"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.14:*:*:*:*:*:*:*", "matchCriteriaId": "D472DE3A-71D8-4F40-9DDE-85929A2B047D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.15:*:*:*:*:*:*:*", "matchCriteriaId": "B2AED943-65A8-4FDB-BBD0-CCEF8682A48C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.16:*:*:*:*:*:*:*", "matchCriteriaId": "D4640185-F3D8-4575-A71D-4C889A93DE2C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.17:*:*:*:*:*:*:*", "matchCriteriaId": "144CCF7C-025E-4879-B2E7-ABB8E4390BE5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.18:*:*:*:*:*:*:*", "matchCriteriaId": "B6FAA052-0B2B-40CE-8C98-919B8D08A5ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.19:*:*:*:*:*:*:*", "matchCriteriaId": "4B5A53DE-9C83-4A6B-96F3-23C03BF445D9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.20:*:*:*:*:*:*:*", "matchCriteriaId": "063EB879-CB05-4E33-AA90-9E43516839B5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.21:*:*:*:*:*:*:*", "matchCriteriaId": "2D25764F-4B02-4C65-954E-8C7D6632DE00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.22:*:*:*:*:*:*:*", "matchCriteriaId": "F31F5BF3-CD0A-465C-857F-273841BCD28A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.23:*:*:*:*:*:*:*", "matchCriteriaId": "FF302C8A-079B-42B9-B455-CD9083BFA067"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.24:*:*:*:*:*:*:*", "matchCriteriaId": "744999C0-33D3-4363-B3DB-E0D02CDD3918"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.25:*:*:*:*:*:*:*", "matchCriteriaId": "C2E77A76-2A60-45D8-9337-867BC22C5110"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.26:*:*:*:*:*:*:*", "matchCriteriaId": "C9F4AAE7-C870-46B7-B559-2949737BE777"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.27:*:*:*:*:*:*:*", "matchCriteriaId": "20FA2824-20B0-48B8-BB0A-4904C1D3E8AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.28:*:*:*:*:*:*:*", "matchCriteriaId": "9F9B347E-61AC-419F-9701-B862BBFA46F2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.29:*:*:*:*:*:*:*", "matchCriteriaId": "989F351C-8B7C-4C1B-AFA2-AE9431576368"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.30:*:*:*:*:*:*:*", "matchCriteriaId": "8D22172A-9FA7-42E0-8451-165D8E47A573"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.31:*:*:*:*:*:*:*", "matchCriteriaId": "CE31624C-94F9-45D8-9B4A-D0028F10602F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.4.32:*:*:*:*:*:*:*", "matchCriteriaId": "70967A83-28F6-4568-9ADA-6EF232E5BBC2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "962B0C45-AB29-4383-AC16-C6E8245D0FF7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "A0EE126B-74B2-4F79-BFE1-3DC169F3F9B2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "392075E0-A9C7-4B4A-90F9-7F1ADFF5EFA7"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "ECC66968-06F0-4874-A95A-A292C36E45C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.5:*:*:*:*:*:*:*", "matchCriteriaId": "5FE986E6-1068-4E1B-8EAB-DF1EAF32B4E3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.6:*:*:*:*:*:*:*", "matchCriteriaId": "543E8536-1A8E-4E76-B89F-1B1F9F26FAB8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.5.7:*:*:*:*:*:*:*", "matchCriteriaId": "EC2B45E3-31E1-4B46-85FA-3A84E75B8F84"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6:*:*:*:*:*:*:*", "matchCriteriaId": "DDB8CC75-D3EE-417C-A83D-CB6D666FE595"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "09A072F1-7BEE-4236-ACBB-55DB8FEF4A03"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "E19D5A58-17D6-4502-A57A-70B2F84817A4"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "D58BA035-1204-4DFA-98A1-12111FB6222E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "A17F2E87-8EB8-476A-B5B5-9AE5CF53D9FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.5:*:*:*:*:*:*:*", "matchCriteriaId": "A8CCC101-5852-4299-9B67-EA1B149D58C0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.6:*:*:*:*:*:*:*", "matchCriteriaId": "B8074D32-C252-4AD3-A579-1C5EDDD7014B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.7:*:*:*:*:*:*:*", "matchCriteriaId": "962AA802-8179-4606-AAC0-9363BAEABC9F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.8:*:*:*:*:*:*:*", "matchCriteriaId": "1286C858-D5A2-45F3-86D1-E50FE53FB23C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.9:*:*:*:*:*:*:*", "matchCriteriaId": "5AC4A13E-F560-4D01-98A3-E2A2B82EB25B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.10:*:*:*:*:*:*:*", "matchCriteriaId": "942C462A-5398-4BB9-A792-598682E1FEF2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.6.11:*:*:*:*:*:*:*", "matchCriteriaId": "B852F7E0-0282-483D-BB4D-18CB7A4F1392"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7:*:*:*:*:*:*:*", "matchCriteriaId": "53ED9A31-99CC-41C8-8B72-5B2A9B49AA6C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "EFD646BC-62F7-47CF-B0BE-768F701F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "F43D418E-87C1-4C83-9FF1-4F45B4F452DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.3:*:*:*:*:*:*:*", "matchCriteriaId": "680D0E00-F29A-487C-8770-8E7EAC672B7C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.4:*:*:*:*:*:*:*", "matchCriteriaId": "2DCA96A4-A836-4E94-A39C-3AD3EA1D9611"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.5:*:*:*:*:*:*:*", "matchCriteriaId": "753C05E3-B603-4E36-B9BA-FAEDCBF62A7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.6:*:*:*:*:*:*:*", "matchCriteriaId": "E385C2E0-B9F1-4564-8E6D-56FD9E762405"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.7:*:*:*:*:*:*:*", "matchCriteriaId": "041335D4-05E1-4004-9381-28AAD5994B47"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.8:*:*:*:*:*:*:*", "matchCriteriaId": "370F2AE5-3DBC-46B9-AC70-F052C9229C00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.9:*:*:*:*:*:*:*", "matchCriteriaId": "7A971BE3-259D-4494-BBC5-12793D92DB57"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.7.10:*:*:*:*:*:*:*", "matchCriteriaId": "8E4719A6-FDEA-4714-A830-E23A52AE90BC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A6E41FB-38CE-49F2-B796-9A5AA648E73F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "93523FE1-5993-46CB-9299-7C8C1A04E873"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "27ADC356-6BE9-43A3-9E0B-393DC4B1559A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "4F543D23-1774-4D14-A7D1-AD49EDEA94DD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "FC323F58-CA00-4C3C-BA4D-CC2C0A6E5F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "FEA0B2E3-668D-40ED-9D3D-709EB6449F8D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.6:*:*:*:*:*:*:*", "matchCriteriaId": "3431B258-4EC8-4E7F-87BB-4D934880601E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.7:*:*:*:*:*:*:*", "matchCriteriaId": "1B09FA1E-8B28-4F2A-BA7E-8E1C40365970"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.8:*:*:*:*:*:*:*", "matchCriteriaId": "91917120-9D68-41C0-8B5D-85C256BC6200"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.9:*:*:*:*:*:*:*", "matchCriteriaId": "AAD268A0-096C-4C31-BEC5-D47F5149D462"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.10:*:*:*:*:*:*:*", "matchCriteriaId": "32BD2427-C47F-4660-A1D9-448E500EF5B9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.11:*:*:*:*:*:*:*", "matchCriteriaId": "02048CE5-81C7-4DFB-BC40-CE4C86B7E022"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.12:*:*:*:*:*:*:*", "matchCriteriaId": "934D2B37-0575-4A75-B00B-0028316D6DF0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.8.13:*:*:*:*:*:*:*", "matchCriteriaId": "06754C21-995C-4850-A4DC-F21826C0F8C5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc1:*:*:*:*:*:*", "matchCriteriaId": "42633FF9-FB0C-4095-B4A1-8D623A98683B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc2:*:*:*:*:*:*", "matchCriteriaId": "08C04619-89A2-4B15-82A2-48BCC662C1F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc3:*:*:*:*:*:*", "matchCriteriaId": "5B039196-7159-476C-876A-C61242CC41DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc4:*:*:*:*:*:*", "matchCriteriaId": "3A9E0457-53C9-44DD-ACFB-31EE1D1E060E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc5:*:*:*:*:*:*", "matchCriteriaId": "BEE406E7-87BA-44BA-BF61-673E6CC44A2F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc6:*:*:*:*:*:*", "matchCriteriaId": "29FBA173-658F-45DC-8205-934CACD67166"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9:rc7:*:*:*:*:*:*", "matchCriteriaId": "139700F0-BA32-40CF-B9DF-C9C450384FDE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "E578085C-3968-4543-BEBA-EE3C3CB4FA02"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "4DCFA441-68FB-4559-A245-FF0B79DE43CA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "8C2508D8-6571-4B81-A0D7-E494CCD039CE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "8B516926-5E86-4C0A-85F3-F64E1FCDA249"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "069D774D-79BE-479F-BF4E-F021AD808114"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "D15B27A9-46E0-4DDF-A00C-29F8F1F18D73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "A381BB4A-28B4-4672-87EE-91B3DDD6C71A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "922F80CF-937D-4FA2-AFF2-6E47FFE9E1E9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "A548ADF4-9E3B-407C-A5ED-05150EB3A185"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "9C623230-4497-41B9-9BD2-7A6CFDD77983"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "C72FA8A6-60A6-4486-A245-7BEF8B2A2711"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "0A498D90-BB99-405E-9FA6-1FBFE179787E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.1:*:*:*:*:*:*:*", "matchCriteriaId": "D0D32776-8ADB-4E79-846A-C0C99FED19E0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.2:*:*:*:*:*:*:*", "matchCriteriaId": "B7D01673-D13F-487F-81B6-1279C187277E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.3:*:*:*:*:*:*:*", "matchCriteriaId": "ADB27A3E-78E4-40F7-9716-A1099B0D85FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.4:*:*:*:*:*:*:*", "matchCriteriaId": "16E7136A-A8A6-4BF5-AF5D-AFB5C7A10712"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.5:*:*:*:*:*:*:*", "matchCriteriaId": "6FE127AC-E61D-427A-B998-D60DF5AABA21"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.6:*:*:*:*:*:*:*", "matchCriteriaId": "3819FF99-AEC5-4466-8542-D395419E4308"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.7:*:*:*:*:*:*:*", "matchCriteriaId": "E621FA1A-464B-4D2A-A0D6-EDA475A3709B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.8:*:*:*:*:*:*:*", "matchCriteriaId": "B760B422-EA11-43AB-B6D2-CA54E7229663"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.9:*:*:*:*:*:*:*", "matchCriteriaId": "D2CA7BBC-917C-4F31-A442-465C30444836"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.10:*:*:*:*:*:*:*", "matchCriteriaId": "AE778000-4FD5-4032-86CE-5930EF4CB7C1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.11:*:*:*:*:*:*:*", "matchCriteriaId": "B3344EEB-F037-48FE-81DC-67F6384F7D9A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.10.12:*:*:*:*:*:*:*", "matchCriteriaId": "0244B0CA-9C67-4F06-BFBA-1F257112AC08"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11:*:*:*:*:*:*:*", "matchCriteriaId": "639E3A57-A9E7-40E6-8929-81CCC0060EFB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.1:*:*:*:*:*:*:*", "matchCriteriaId": "07012ADD-F521-40A8-B067-E87C2238A3D2"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.2:*:*:*:*:*:*:*", "matchCriteriaId": "3F5FF393-3F89-4274-B82B-F671358072ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.3:*:*:*:*:*:*:*", "matchCriteriaId": "E348698F-54D1-4F5E-B701-CFAF50881E0A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.4:*:*:*:*:*:*:*", "matchCriteriaId": "932205D9-3514-4289-9B55-C7A169276930"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:3.11.5:*:*:*:*:*:*:*", "matchCriteriaId": "2ECB2D33-F517-480F-8A6F-99D9D6C49596"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "2F6AB192-9D7D-4A9A-8995-E53A9DE9EAFC"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e9c6a182649f4259db704ae15a91ac820e63b0ca", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00000.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2015-04/msg00020.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1436.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1449.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1450.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1460.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1490.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1519.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1520.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1783.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2013-1860.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2015-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2016-1", "source": "secalert@redhat.com"}, {"url": "http://www.ubuntu.com/usn/USN-2040-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2041-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2042-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2043-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2044-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2045-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2046-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2049-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2050-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2066-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.ubuntu.com/usn/USN-2067-1", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1004233", "source": "secalert@redhat.com", "tags": ["Patch", "Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/e9c6a182649f4259db704ae15a91ac820e63b0ca", "source": "secalert@redhat.com", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e9c6a182649f4259db704ae15a91ac820e63b0ca"}}