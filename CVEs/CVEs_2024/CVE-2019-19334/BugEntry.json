{"buggy_code": ["/**\n * @file parser.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief common libyang parsers routines implementations\n *\n * Copyright (c) 2015-2017 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pcre.h>\n#include <time.h>\n\n#include \"common.h\"\n#include \"context.h\"\n#include \"libyang.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"tree_internal.h\"\n#include \"parser_yang.h\"\n#include \"xpath.h\"\n\n#define LYP_URANGE_LEN 19\n\nstatic char *lyp_ublock2urange[][2] = {\n    {\"BasicLatin\", \"[\\\\x{0000}-\\\\x{007F}]\"},\n    {\"Latin-1Supplement\", \"[\\\\x{0080}-\\\\x{00FF}]\"},\n    {\"LatinExtended-A\", \"[\\\\x{0100}-\\\\x{017F}]\"},\n    {\"LatinExtended-B\", \"[\\\\x{0180}-\\\\x{024F}]\"},\n    {\"IPAExtensions\", \"[\\\\x{0250}-\\\\x{02AF}]\"},\n    {\"SpacingModifierLetters\", \"[\\\\x{02B0}-\\\\x{02FF}]\"},\n    {\"CombiningDiacriticalMarks\", \"[\\\\x{0300}-\\\\x{036F}]\"},\n    {\"Greek\", \"[\\\\x{0370}-\\\\x{03FF}]\"},\n    {\"Cyrillic\", \"[\\\\x{0400}-\\\\x{04FF}]\"},\n    {\"Armenian\", \"[\\\\x{0530}-\\\\x{058F}]\"},\n    {\"Hebrew\", \"[\\\\x{0590}-\\\\x{05FF}]\"},\n    {\"Arabic\", \"[\\\\x{0600}-\\\\x{06FF}]\"},\n    {\"Syriac\", \"[\\\\x{0700}-\\\\x{074F}]\"},\n    {\"Thaana\", \"[\\\\x{0780}-\\\\x{07BF}]\"},\n    {\"Devanagari\", \"[\\\\x{0900}-\\\\x{097F}]\"},\n    {\"Bengali\", \"[\\\\x{0980}-\\\\x{09FF}]\"},\n    {\"Gurmukhi\", \"[\\\\x{0A00}-\\\\x{0A7F}]\"},\n    {\"Gujarati\", \"[\\\\x{0A80}-\\\\x{0AFF}]\"},\n    {\"Oriya\", \"[\\\\x{0B00}-\\\\x{0B7F}]\"},\n    {\"Tamil\", \"[\\\\x{0B80}-\\\\x{0BFF}]\"},\n    {\"Telugu\", \"[\\\\x{0C00}-\\\\x{0C7F}]\"},\n    {\"Kannada\", \"[\\\\x{0C80}-\\\\x{0CFF}]\"},\n    {\"Malayalam\", \"[\\\\x{0D00}-\\\\x{0D7F}]\"},\n    {\"Sinhala\", \"[\\\\x{0D80}-\\\\x{0DFF}]\"},\n    {\"Thai\", \"[\\\\x{0E00}-\\\\x{0E7F}]\"},\n    {\"Lao\", \"[\\\\x{0E80}-\\\\x{0EFF}]\"},\n    {\"Tibetan\", \"[\\\\x{0F00}-\\\\x{0FFF}]\"},\n    {\"Myanmar\", \"[\\\\x{1000}-\\\\x{109F}]\"},\n    {\"Georgian\", \"[\\\\x{10A0}-\\\\x{10FF}]\"},\n    {\"HangulJamo\", \"[\\\\x{1100}-\\\\x{11FF}]\"},\n    {\"Ethiopic\", \"[\\\\x{1200}-\\\\x{137F}]\"},\n    {\"Cherokee\", \"[\\\\x{13A0}-\\\\x{13FF}]\"},\n    {\"UnifiedCanadianAboriginalSyllabics\", \"[\\\\x{1400}-\\\\x{167F}]\"},\n    {\"Ogham\", \"[\\\\x{1680}-\\\\x{169F}]\"},\n    {\"Runic\", \"[\\\\x{16A0}-\\\\x{16FF}]\"},\n    {\"Khmer\", \"[\\\\x{1780}-\\\\x{17FF}]\"},\n    {\"Mongolian\", \"[\\\\x{1800}-\\\\x{18AF}]\"},\n    {\"LatinExtendedAdditional\", \"[\\\\x{1E00}-\\\\x{1EFF}]\"},\n    {\"GreekExtended\", \"[\\\\x{1F00}-\\\\x{1FFF}]\"},\n    {\"GeneralPunctuation\", \"[\\\\x{2000}-\\\\x{206F}]\"},\n    {\"SuperscriptsandSubscripts\", \"[\\\\x{2070}-\\\\x{209F}]\"},\n    {\"CurrencySymbols\", \"[\\\\x{20A0}-\\\\x{20CF}]\"},\n    {\"CombiningMarksforSymbols\", \"[\\\\x{20D0}-\\\\x{20FF}]\"},\n    {\"LetterlikeSymbols\", \"[\\\\x{2100}-\\\\x{214F}]\"},\n    {\"NumberForms\", \"[\\\\x{2150}-\\\\x{218F}]\"},\n    {\"Arrows\", \"[\\\\x{2190}-\\\\x{21FF}]\"},\n    {\"MathematicalOperators\", \"[\\\\x{2200}-\\\\x{22FF}]\"},\n    {\"MiscellaneousTechnical\", \"[\\\\x{2300}-\\\\x{23FF}]\"},\n    {\"ControlPictures\", \"[\\\\x{2400}-\\\\x{243F}]\"},\n    {\"OpticalCharacterRecognition\", \"[\\\\x{2440}-\\\\x{245F}]\"},\n    {\"EnclosedAlphanumerics\", \"[\\\\x{2460}-\\\\x{24FF}]\"},\n    {\"BoxDrawing\", \"[\\\\x{2500}-\\\\x{257F}]\"},\n    {\"BlockElements\", \"[\\\\x{2580}-\\\\x{259F}]\"},\n    {\"GeometricShapes\", \"[\\\\x{25A0}-\\\\x{25FF}]\"},\n    {\"MiscellaneousSymbols\", \"[\\\\x{2600}-\\\\x{26FF}]\"},\n    {\"Dingbats\", \"[\\\\x{2700}-\\\\x{27BF}]\"},\n    {\"BraillePatterns\", \"[\\\\x{2800}-\\\\x{28FF}]\"},\n    {\"CJKRadicalsSupplement\", \"[\\\\x{2E80}-\\\\x{2EFF}]\"},\n    {\"KangxiRadicals\", \"[\\\\x{2F00}-\\\\x{2FDF}]\"},\n    {\"IdeographicDescriptionCharacters\", \"[\\\\x{2FF0}-\\\\x{2FFF}]\"},\n    {\"CJKSymbolsandPunctuation\", \"[\\\\x{3000}-\\\\x{303F}]\"},\n    {\"Hiragana\", \"[\\\\x{3040}-\\\\x{309F}]\"},\n    {\"Katakana\", \"[\\\\x{30A0}-\\\\x{30FF}]\"},\n    {\"Bopomofo\", \"[\\\\x{3100}-\\\\x{312F}]\"},\n    {\"HangulCompatibilityJamo\", \"[\\\\x{3130}-\\\\x{318F}]\"},\n    {\"Kanbun\", \"[\\\\x{3190}-\\\\x{319F}]\"},\n    {\"BopomofoExtended\", \"[\\\\x{31A0}-\\\\x{31BF}]\"},\n    {\"EnclosedCJKLettersandMonths\", \"[\\\\x{3200}-\\\\x{32FF}]\"},\n    {\"CJKCompatibility\", \"[\\\\x{3300}-\\\\x{33FF}]\"},\n    {\"CJKUnifiedIdeographsExtensionA\", \"[\\\\x{3400}-\\\\x{4DB5}]\"},\n    {\"CJKUnifiedIdeographs\", \"[\\\\x{4E00}-\\\\x{9FFF}]\"},\n    {\"YiSyllables\", \"[\\\\x{A000}-\\\\x{A48F}]\"},\n    {\"YiRadicals\", \"[\\\\x{A490}-\\\\x{A4CF}]\"},\n    {\"HangulSyllables\", \"[\\\\x{AC00}-\\\\x{D7A3}]\"},\n    {\"PrivateUse\", \"[\\\\x{E000}-\\\\x{F8FF}]\"},\n    {\"CJKCompatibilityIdeographs\", \"[\\\\x{F900}-\\\\x{FAFF}]\"},\n    {\"AlphabeticPresentationForms\", \"[\\\\x{FB00}-\\\\x{FB4F}]\"},\n    {\"ArabicPresentationForms-A\", \"[\\\\x{FB50}-\\\\x{FDFF}]\"},\n    {\"CombiningHalfMarks\", \"[\\\\x{FE20}-\\\\x{FE2F}]\"},\n    {\"CJKCompatibilityForms\", \"[\\\\x{FE30}-\\\\x{FE4F}]\"},\n    {\"SmallFormVariants\", \"[\\\\x{FE50}-\\\\x{FE6F}]\"},\n    {\"ArabicPresentationForms-B\", \"[\\\\x{FE70}-\\\\x{FEFE}]\"},\n    {\"HalfwidthandFullwidthForms\", \"[\\\\x{FF00}-\\\\x{FFEF}]\"},\n    {NULL, NULL}\n};\n\nconst char *ly_stmt_str[] = {\n    [LY_STMT_UNKNOWN] = \"\",\n    [LY_STMT_ARGUMENT] = \"argument\",\n    [LY_STMT_BASE] = \"base\",\n    [LY_STMT_BELONGSTO] = \"belongs-to\",\n    [LY_STMT_CONTACT] = \"contact\",\n    [LY_STMT_DEFAULT] = \"default\",\n    [LY_STMT_DESCRIPTION] = \"description\",\n    [LY_STMT_ERRTAG] = \"error-app-tag\",\n    [LY_STMT_ERRMSG] = \"error-message\",\n    [LY_STMT_KEY] = \"key\",\n    [LY_STMT_NAMESPACE] = \"namespace\",\n    [LY_STMT_ORGANIZATION] = \"organization\",\n    [LY_STMT_PATH] = \"path\",\n    [LY_STMT_PREFIX] = \"prefix\",\n    [LY_STMT_PRESENCE] = \"presence\",\n    [LY_STMT_REFERENCE] = \"reference\",\n    [LY_STMT_REVISIONDATE] = \"revision-date\",\n    [LY_STMT_UNITS] = \"units\",\n    [LY_STMT_VALUE] = \"value\",\n    [LY_STMT_VERSION] = \"yang-version\",\n    [LY_STMT_MODIFIER] = \"modifier\",\n    [LY_STMT_REQINSTANCE] = \"require-instance\",\n    [LY_STMT_YINELEM] = \"yin-element\",\n    [LY_STMT_CONFIG] = \"config\",\n    [LY_STMT_MANDATORY] = \"mandatory\",\n    [LY_STMT_ORDEREDBY] = \"ordered-by\",\n    [LY_STMT_STATUS] = \"status\",\n    [LY_STMT_DIGITS] = \"fraction-digits\",\n    [LY_STMT_MAX] = \"max-elements\",\n    [LY_STMT_MIN] = \"min-elements\",\n    [LY_STMT_POSITION] = \"position\",\n    [LY_STMT_UNIQUE] = \"unique\",\n    [LY_STMT_MODULE] = \"module\",\n    [LY_STMT_SUBMODULE] = \"submodule\",\n    [LY_STMT_ACTION] = \"action\",\n    [LY_STMT_ANYDATA] = \"anydata\",\n    [LY_STMT_ANYXML] = \"anyxml\",\n    [LY_STMT_CASE] = \"case\",\n    [LY_STMT_CHOICE] = \"choice\",\n    [LY_STMT_CONTAINER] = \"container\",\n    [LY_STMT_GROUPING] = \"grouping\",\n    [LY_STMT_INPUT] = \"input\",\n    [LY_STMT_LEAF] = \"leaf\",\n    [LY_STMT_LEAFLIST] = \"leaf-list\",\n    [LY_STMT_LIST] = \"list\",\n    [LY_STMT_NOTIFICATION] = \"notification\",\n    [LY_STMT_OUTPUT] = \"output\",\n    [LY_STMT_RPC] = \"rpc\",\n    [LY_STMT_USES] = \"uses\",\n    [LY_STMT_TYPEDEF] = \"typedef\",\n    [LY_STMT_TYPE] = \"type\",\n    [LY_STMT_BIT] = \"bit\",\n    [LY_STMT_ENUM] = \"enum\",\n    [LY_STMT_REFINE] = \"refine\",\n    [LY_STMT_AUGMENT] = \"augment\",\n    [LY_STMT_DEVIATE] = \"deviate\",\n    [LY_STMT_DEVIATION] = \"deviation\",\n    [LY_STMT_EXTENSION] = \"extension\",\n    [LY_STMT_FEATURE] = \"feature\",\n    [LY_STMT_IDENTITY] = \"identity\",\n    [LY_STMT_IFFEATURE] = \"if-feature\",\n    [LY_STMT_IMPORT] = \"import\",\n    [LY_STMT_INCLUDE] = \"include\",\n    [LY_STMT_LENGTH] = \"length\",\n    [LY_STMT_MUST] = \"must\",\n    [LY_STMT_PATTERN] = \"pattern\",\n    [LY_STMT_RANGE] = \"range\",\n    [LY_STMT_WHEN] = \"when\",\n    [LY_STMT_REVISION] = \"revision\"\n};\n\nint\nlyp_is_rpc_action(struct lys_node *node)\n{\n    assert(node);\n\n    while (lys_parent(node)) {\n        node = lys_parent(node);\n        if (node->nodetype == LYS_ACTION) {\n            break;\n        }\n    }\n\n    if (node->nodetype & (LYS_RPC | LYS_ACTION)) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint\nlyp_data_check_options(struct ly_ctx *ctx, int options, const char *func)\n{\n    int x = options & LYD_OPT_TYPEMASK;\n\n    /* LYD_OPT_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG */\n    if (options & LYD_OPT_WHENAUTODEL) {\n        if ((x == LYD_OPT_EDIT) || (x == LYD_OPT_NOTIF_FILTER)) {\n            LOGERR(ctx, LY_EINVAL, \"%s: Invalid options 0x%x (LYD_OPT_DATA_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG)\",\n                   func, options);\n            return 1;\n        }\n    }\n\n    if (options & (LYD_OPT_DATA_ADD_YANGLIB | LYD_OPT_DATA_NO_YANGLIB)) {\n        if (x != LYD_OPT_DATA) {\n            LOGERR(ctx, LY_EINVAL, \"%s: Invalid options 0x%x (LYD_OPT_DATA_*_YANGLIB can be used only with LYD_OPT_DATA)\",\n                   func, options);\n            return 1;\n        }\n    }\n\n    /* \"is power of 2\" algorithm, with 0 exception */\n    if (x && !(x && !(x & (x - 1)))) {\n        LOGERR(ctx, LY_EINVAL, \"%s: Invalid options 0x%x (multiple data type flags set).\", func, options);\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nlyp_mmap(struct ly_ctx *ctx, int fd, size_t addsize, size_t *length, void **addr)\n{\n    struct stat sb;\n    long pagesize;\n    size_t m;\n\n    assert(fd >= 0);\n    if (fstat(fd, &sb) == -1) {\n        LOGERR(ctx, LY_ESYS, \"Failed to stat the file descriptor (%s) for the mmap().\", strerror(errno));\n        return 1;\n    }\n    if (!S_ISREG(sb.st_mode)) {\n        LOGERR(ctx, LY_EINVAL, \"File to mmap() is not a regular file.\");\n        return 1;\n    }\n    if (!sb.st_size) {\n        *addr = NULL;\n        return 0;\n    }\n    pagesize = sysconf(_SC_PAGESIZE);\n    ++addsize;                       /* at least one additional byte for terminating NULL byte */\n\n    m = sb.st_size % pagesize;\n    if (m && pagesize - m >= addsize) {\n        /* there will be enough space after the file content mapping to provide zeroed additional bytes */\n        *length = sb.st_size + addsize;\n        *addr = mmap(NULL, *length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    } else {\n        /* there will not be enough bytes after the file content mapping for the additional bytes and some of them\n         * would overflow into another page that would not be zeroed and any access into it would generate SIGBUS.\n         * Therefore we have to do the following hack with double mapping. First, the required number of bytes\n         * (including the additional bytes) is required as anonymous and thus they will be really provided (actually more\n         * because of using whole pages) and also initialized by zeros. Then, the file is mapped to the same address\n         * where the anonymous mapping starts. */\n        *length = sb.st_size + pagesize;\n        *addr = mmap(NULL, *length, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n        *addr = mmap(*addr, sb.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fd, 0);\n    }\n    if (*addr == MAP_FAILED) {\n        LOGERR(ctx, LY_ESYS, \"mmap() failed (%s).\", strerror(errno));\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nlyp_munmap(void *addr, size_t length)\n{\n    return munmap(addr, length);\n}\n\nint\nlyp_add_ietf_netconf_annotations_config(struct lys_module *mod)\n{\n    void *reallocated;\n    struct lys_ext_instance_complex *op;\n    struct lys_type **type;\n    struct lys_node_anydata *anyxml;\n    int i;\n    struct ly_ctx *ctx = mod->ctx; /* shortcut */\n\n    reallocated = realloc(mod->ext, (mod->ext_size + 3) * sizeof *mod->ext);\n    LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext = reallocated;\n    /* 1) edit-config's operation */\n    op = calloc(1, (sizeof(struct lys_ext_instance_complex) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));\n    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext[mod->ext_size] = (struct lys_ext_instance *)op;\n    op->arg_value = lydict_insert(ctx, \"operation\", 9);\n    op->def = &ctx->models.list[0]->extensions[0];\n    op->ext_type = LYEXT_COMPLEX;\n    op->module = op->parent = mod;\n    op->parent_type = LYEXT_PAR_MODULE;\n    op->substmt = ((struct lyext_plugin_complex *)op->def->plugin)->substmt;\n    op->nodetype = LYS_EXT;\n    type = (struct lys_type**)&op->content; /* type is stored at offset 0 */\n    *type = calloc(1, sizeof(struct lys_type));\n    LY_CHECK_ERR_RETURN(!*type, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->base = LY_TYPE_ENUM;\n    (*type)->der = ly_types[LY_TYPE_ENUM];\n    (*type)->parent = (struct lys_tpdf *)op;\n    (*type)->info.enums.count = 5;\n    (*type)->info.enums.enm = calloc(5, sizeof *(*type)->info.enums.enm);\n    LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->info.enums.enm[0].value = 0;\n    (*type)->info.enums.enm[0].name = lydict_insert(ctx, \"merge\", 5);\n    (*type)->info.enums.enm[1].value = 1;\n    (*type)->info.enums.enm[1].name = lydict_insert(ctx, \"replace\", 7);\n    (*type)->info.enums.enm[2].value = 2;\n    (*type)->info.enums.enm[2].name = lydict_insert(ctx, \"create\", 6);\n    (*type)->info.enums.enm[3].value = 3;\n    (*type)->info.enums.enm[3].name = lydict_insert(ctx, \"delete\", 6);\n    (*type)->info.enums.enm[4].value = 4;\n    (*type)->info.enums.enm[4].name = lydict_insert(ctx, \"remove\", 6);\n    mod->ext_size++;\n\n    /* 2) filter's type */\n    op = calloc(1, (sizeof(struct lys_ext_instance_complex) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));\n    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext[mod->ext_size] = (struct lys_ext_instance *)op;\n    op->arg_value = lydict_insert(ctx, \"type\", 4);\n    op->def = &ctx->models.list[0]->extensions[0];\n    op->ext_type = LYEXT_COMPLEX;\n    op->module = op->parent = mod;\n    op->parent_type = LYEXT_PAR_MODULE;\n    op->substmt = ((struct lyext_plugin_complex *)op->def->plugin)->substmt;\n    op->nodetype = LYS_EXT;\n    type = (struct lys_type**)&op->content; /* type is stored at offset 0 */\n    *type = calloc(1, sizeof(struct lys_type));\n    LY_CHECK_ERR_RETURN(!*type, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->base = LY_TYPE_ENUM;\n    (*type)->der = ly_types[LY_TYPE_ENUM];\n    (*type)->parent = (struct lys_tpdf *)op;\n    (*type)->info.enums.count = 2;\n    (*type)->info.enums.enm = calloc(2, sizeof *(*type)->info.enums.enm);\n    LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->info.enums.enm[0].value = 0;\n    (*type)->info.enums.enm[0].name = lydict_insert(ctx, \"subtree\", 7);\n    (*type)->info.enums.enm[1].value = 1;\n    (*type)->info.enums.enm[1].name = lydict_insert(ctx, \"xpath\", 5);\n    for (i = mod->features_size; i > 0; i--) {\n        if (!strcmp(mod->features[i - 1].name, \"xpath\")) {\n            (*type)->info.enums.enm[1].iffeature_size = 1;\n            (*type)->info.enums.enm[1].iffeature = calloc(1, sizeof(struct lys_feature));\n            LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm[1].iffeature, LOGMEM(ctx), EXIT_FAILURE);\n            (*type)->info.enums.enm[1].iffeature[0].expr = malloc(sizeof(uint8_t));\n            LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm[1].iffeature[0].expr, LOGMEM(ctx), EXIT_FAILURE);\n            *(*type)->info.enums.enm[1].iffeature[0].expr = 3; /* LYS_IFF_F */\n            (*type)->info.enums.enm[1].iffeature[0].features = malloc(sizeof(struct lys_feature*));\n            LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm[1].iffeature[0].features, LOGMEM(ctx), EXIT_FAILURE);\n            (*type)->info.enums.enm[1].iffeature[0].features[0] = &mod->features[i - 1];\n            break;\n        }\n    }\n    mod->ext_size++;\n\n    /* 3) filter's select */\n    op = calloc(1, (sizeof(struct lys_ext_instance_complex) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));\n    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext[mod->ext_size] = (struct lys_ext_instance *)op;\n    op->arg_value = lydict_insert(ctx, \"select\", 6);\n    op->def = &ctx->models.list[0]->extensions[0];\n    op->ext_type = LYEXT_COMPLEX;\n    op->module = op->parent = mod;\n    op->parent_type = LYEXT_PAR_MODULE;\n    op->substmt = ((struct lyext_plugin_complex *)op->def->plugin)->substmt;\n    op->nodetype = LYS_EXT;\n    type = (struct lys_type**)&op->content; /* type is stored at offset 0 */\n    *type = calloc(1, sizeof(struct lys_type));\n    LY_CHECK_ERR_RETURN(!*type, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->base = LY_TYPE_STRING;\n    (*type)->der = ly_types[LY_TYPE_STRING];\n    (*type)->parent = (struct lys_tpdf *)op;\n    mod->ext_size++;\n\n    /* 4) URL config */\n    anyxml = calloc(1, sizeof *anyxml);\n    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), EXIT_FAILURE);\n    anyxml->nodetype = LYS_ANYXML;\n    anyxml->prev = (struct lys_node *)anyxml;\n    anyxml->name = lydict_insert(ctx, \"config\", 0);\n    anyxml->module = mod;\n    anyxml->flags = LYS_CONFIG_W;\n    if (lys_node_addchild(NULL, mod, (struct lys_node *)anyxml, 0)) {\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly\n * base: 0  - to accept decimal, octal, hexadecimal (in default value)\n *       10 - to accept only decimal (instance value)\n */\nstatic int\nparse_int(const char *val_str, int64_t min, int64_t max, int base, int64_t *ret, struct lyd_node *node)\n{\n    char *strptr;\n\n    assert(node);\n\n    if (!val_str || !val_str[0]) {\n        goto error;\n    }\n\n    /* convert to 64-bit integer, all the redundant characters are handled */\n    errno = 0;\n    strptr = NULL;\n\n    /* parse the value */\n    *ret = strtoll(val_str, &strptr, base);\n    if (errno || (*ret < min) || (*ret > max)) {\n        goto error;\n    } else if (strptr && *strptr) {\n        while (isspace(*strptr)) {\n            ++strptr;\n        }\n        if (*strptr) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    LOGVAL(node->schema->module->ctx, LYE_INVAL, LY_VLOG_LYD, node, val_str ? val_str : \"\", node->schema->name);\n    return EXIT_FAILURE;\n}\n\n/* logs directly\n * base: 0  - to accept decimal, octal, hexadecimal (in default value)\n *       10 - to accept only decimal (instance value)\n */\nstatic int\nparse_uint(const char *val_str, uint64_t max, int base, uint64_t *ret, struct lyd_node *node)\n{\n    char *strptr;\n    uint64_t u;\n\n    assert(node);\n\n    if (!val_str || !val_str[0]) {\n        goto error;\n    }\n\n    errno = 0;\n    strptr = NULL;\n    u = strtoull(val_str, &strptr, base);\n    if (errno || (u > max)) {\n        goto error;\n    } else if (strptr && *strptr) {\n        while (isspace(*strptr)) {\n            ++strptr;\n        }\n        if (*strptr) {\n            goto error;\n        }\n    } else if (u != 0 && val_str[0] == '-') {\n        goto error;\n    }\n\n    *ret = u;\n    return EXIT_SUCCESS;\n\nerror:\n    LOGVAL(node->schema->module->ctx, LYE_INVAL, LY_VLOG_LYD, node, val_str ? val_str : \"\", node->schema->name);\n    return EXIT_FAILURE;\n}\n\n/* logs directly\n *\n * kind == 0 - unsigned (unum used), 1 - signed (snum used), 2 - floating point (fnum used)\n */\nstatic int\nvalidate_length_range(uint8_t kind, uint64_t unum, int64_t snum, int64_t fnum, uint8_t fnum_dig, struct lys_type *type,\n                      const char *val_str, struct lyd_node *node)\n{\n    struct lys_restr *restr = NULL;\n    struct len_ran_intv *intv = NULL, *tmp_intv;\n    struct lys_type *cur_type;\n    struct ly_ctx *ctx = type->parent->module->ctx;\n    int match;\n\n    if (resolve_len_ran_interval(ctx, NULL, type, &intv)) {\n        /* already done during schema parsing */\n        LOGINT(ctx);\n        return EXIT_FAILURE;\n    }\n    if (!intv) {\n        return EXIT_SUCCESS;\n    }\n\n    /* I know that all intervals belonging to a single restriction share one type pointer */\n    tmp_intv = intv;\n    cur_type = intv->type;\n    do {\n        match = 0;\n        for (; tmp_intv && (tmp_intv->type == cur_type); tmp_intv = tmp_intv->next) {\n            if (match) {\n                /* just iterate through the rest of this restriction intervals */\n                continue;\n            }\n\n            if (((kind == 0) && (unum < tmp_intv->value.uval.min))\n                    || ((kind == 1) && (snum < tmp_intv->value.sval.min))\n                    || ((kind == 2) && (dec64cmp(fnum, fnum_dig, tmp_intv->value.fval.min, cur_type->info.dec64.dig) < 0))) {\n                break;\n            }\n\n            if (((kind == 0) && (unum >= tmp_intv->value.uval.min) && (unum <= tmp_intv->value.uval.max))\n                    || ((kind == 1) && (snum >= tmp_intv->value.sval.min) && (snum <= tmp_intv->value.sval.max))\n                    || ((kind == 2) && (dec64cmp(fnum, fnum_dig, tmp_intv->value.fval.min, cur_type->info.dec64.dig) > -1)\n                    && (dec64cmp(fnum, fnum_dig, tmp_intv->value.fval.max, cur_type->info.dec64.dig) < 1))) {\n                match = 1;\n            }\n        }\n\n        if (!match) {\n            break;\n        } else if (tmp_intv) {\n            cur_type = tmp_intv->type;\n        }\n    } while (tmp_intv);\n\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n\n    if (!match) {\n        switch (cur_type->base) {\n        case LY_TYPE_BINARY:\n            restr = cur_type->info.binary.length;\n            break;\n        case LY_TYPE_DEC64:\n            restr = cur_type->info.dec64.range;\n            break;\n        case LY_TYPE_INT8:\n        case LY_TYPE_INT16:\n        case LY_TYPE_INT32:\n        case LY_TYPE_INT64:\n        case LY_TYPE_UINT8:\n        case LY_TYPE_UINT16:\n        case LY_TYPE_UINT32:\n        case LY_TYPE_UINT64:\n            restr = cur_type->info.num.range;\n            break;\n        case LY_TYPE_STRING:\n            restr = cur_type->info.str.length;\n            break;\n        default:\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n\n        LOGVAL(ctx, LYE_NOCONSTR, LY_VLOG_LYD, node, (val_str ? val_str : \"\"), restr ? restr->expr : \"\");\n        if (restr && restr->emsg) {\n            ly_vlog_str(ctx, LY_VLOG_PREV, restr->emsg);\n        }\n        if (restr && restr->eapptag) {\n            ly_err_last_set_apptag(ctx, restr->eapptag);\n        }\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nstatic int\nvalidate_pattern(struct ly_ctx *ctx, const char *val_str, struct lys_type *type, struct lyd_node *node)\n{\n    int rc;\n    unsigned int i;\n#ifndef LY_ENABLED_CACHE\n    pcre *precomp;\n#endif\n\n    assert(ctx && (type->base == LY_TYPE_STRING));\n\n    if (!val_str) {\n        val_str = \"\";\n    }\n\n    if (type->der && validate_pattern(ctx, val_str, &type->der->type, node)) {\n        return EXIT_FAILURE;\n    }\n\n#ifdef LY_ENABLED_CACHE\n    /* there is no cache, build it */\n    if (!type->info.str.patterns_pcre && type->info.str.pat_count) {\n        type->info.str.patterns_pcre = malloc(2 * type->info.str.pat_count * sizeof *type->info.str.patterns_pcre);\n        LY_CHECK_ERR_RETURN(!type->info.str.patterns_pcre, LOGMEM(ctx), -1);\n\n        for (i = 0; i < type->info.str.pat_count; ++i) {\n            if (lyp_precompile_pattern(ctx, &type->info.str.patterns[i].expr[1],\n                                       (pcre**)&type->info.str.patterns_pcre[i * 2],\n                                       (pcre_extra**)&type->info.str.patterns_pcre[i * 2 + 1])) {\n                return EXIT_FAILURE;\n            }\n        }\n    }\n#endif\n\n    for (i = 0; i < type->info.str.pat_count; ++i) {\n#ifdef LY_ENABLED_CACHE\n        rc = pcre_exec((pcre *)type->info.str.patterns_pcre[2 * i], (pcre_extra *)type->info.str.patterns_pcre[2 * i + 1],\n                       val_str, strlen(val_str), 0, 0, NULL, 0);\n#else\n        if (lyp_check_pattern(ctx, &type->info.str.patterns[i].expr[1], &precomp)) {\n            return EXIT_FAILURE;\n        }\n        rc = pcre_exec(precomp, NULL, val_str, strlen(val_str), 0, 0, NULL, 0);\n        free(precomp);\n#endif\n        if ((rc && type->info.str.patterns[i].expr[0] == 0x06) || (!rc && type->info.str.patterns[i].expr[0] == 0x15)) {\n            LOGVAL(ctx, LYE_NOCONSTR, LY_VLOG_LYD, node, val_str, &type->info.str.patterns[i].expr[1]);\n            if (type->info.str.patterns[i].emsg) {\n                ly_vlog_str(ctx, LY_VLOG_PREV, type->info.str.patterns[i].emsg);\n            }\n            if (type->info.str.patterns[i].eapptag) {\n                ly_err_last_set_apptag(ctx, type->info.str.patterns[i].eapptag);\n            }\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic void\ncheck_number(const char *str_num, const char **num_end, LY_DATA_TYPE base)\n{\n    if (!isdigit(str_num[0]) && (str_num[0] != '-') && (str_num[0] != '+')) {\n        *num_end = str_num;\n        return;\n    }\n\n    if ((str_num[0] == '-') || (str_num[0] == '+')) {\n        ++str_num;\n    }\n\n    while (isdigit(str_num[0])) {\n        ++str_num;\n    }\n\n    if ((base != LY_TYPE_DEC64) || (str_num[0] != '.') || !isdigit(str_num[1])) {\n        *num_end = str_num;\n        return;\n    }\n\n    ++str_num;\n    while (isdigit(str_num[0])) {\n        ++str_num;\n    }\n\n    *num_end = str_num;\n}\n\n/**\n * @brief Checks the syntax of length or range statement,\n *        on success checks the semantics as well. Does not log.\n *\n * @param[in] expr Length or range expression.\n * @param[in] type Type with the restriction.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE otherwise.\n */\nint\nlyp_check_length_range(struct ly_ctx *ctx, const char *expr, struct lys_type *type)\n{\n    struct len_ran_intv *intv = NULL, *tmp_intv;\n    const char *c = expr, *tail;\n    int ret = EXIT_FAILURE, flg = 1; /* first run flag */\n\n    assert(expr);\n\nlengthpart:\n\n    while (isspace(*c)) {\n        c++;\n    }\n\n    /* lower boundary or explicit number */\n    if (!strncmp(c, \"max\", 3)) {\nmax:\n        c += 3;\n        while (isspace(*c)) {\n            c++;\n        }\n        if (*c != '\\0') {\n            goto error;\n        }\n\n        goto syntax_ok;\n\n    } else if (!strncmp(c, \"min\", 3)) {\n        if (!flg) {\n            /* min cannot be used elsewhere than in the first length-part */\n            goto error;\n        } else {\n            flg = 0;\n        }\n        c += 3;\n        while (isspace(*c)) {\n            c++;\n        }\n\n        if (*c == '|') {\n            c++;\n            /* process next length-part */\n            goto lengthpart;\n        } else if (*c == '\\0') {\n            goto syntax_ok;\n        } else if (!strncmp(c, \"..\", 2)) {\nupper:\n            c += 2;\n            while (isspace(*c)) {\n                c++;\n            }\n            if (*c == '\\0') {\n                goto error;\n            }\n\n            /* upper boundary */\n            if (!strncmp(c, \"max\", 3)) {\n                goto max;\n            }\n\n            check_number(c, &tail, type->base);\n            if (c == tail) {\n                goto error;\n            }\n            c = tail;\n            while (isspace(*c)) {\n                c++;\n            }\n            if (*c == '\\0') {\n                goto syntax_ok;\n            } else if (*c == '|') {\n                c++;\n                /* process next length-part */\n                goto lengthpart;\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n    } else if (isdigit(*c) || (*c == '-') || (*c == '+')) {\n        /* number */\n        check_number(c, &tail, type->base);\n        if (c == tail) {\n            goto error;\n        }\n        c = tail;\n\n        while (isspace(*c)) {\n            c++;\n        }\n\n        if (*c == '|') {\n            c++;\n            /* process next length-part */\n            goto lengthpart;\n        } else if (*c == '\\0') {\n            goto syntax_ok;\n        } else if (!strncmp(c, \"..\", 2)) {\n            goto upper;\n        }\n\n    } else {\n        goto error;\n    }\n\nsyntax_ok:\n    if (resolve_len_ran_interval(ctx, expr, type, &intv)) {\n        goto error;\n    }\n\n    ret = EXIT_SUCCESS;\n\nerror:\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n\n    return ret;\n}\n\n/**\n * @brief Checks pattern syntax. Logs directly.\n *\n * @param[in] pattern Pattern to check.\n * @param[out] pcre_precomp Precompiled PCRE pattern. Can be NULL.\n * @return EXIT_SUCCESS on success, EXIT_FAILURE otherwise.\n */\nint\nlyp_check_pattern(struct ly_ctx *ctx, const char *pattern, pcre **pcre_precomp)\n{\n    int idx, idx2, start, end, err_offset, count;\n    char *perl_regex, *ptr;\n    const char *err_msg, *orig_ptr;\n    pcre *precomp;\n\n    /*\n     * adjust the expression to a Perl equivalent\n     *\n     * http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#regexs\n     */\n\n    /* we need to replace all \"$\" with \"\\$\", count them now */\n    for (count = 0, ptr = strchr(pattern, '$'); ptr; ++count, ptr = strchr(ptr + 1, '$'));\n\n    perl_regex = malloc((strlen(pattern) + 4 + count) * sizeof(char));\n    LY_CHECK_ERR_RETURN(!perl_regex, LOGMEM(ctx), EXIT_FAILURE);\n    perl_regex[0] = '\\0';\n\n    ptr = perl_regex;\n\n    if (strncmp(pattern + strlen(pattern) - 2, \".*\", 2)) {\n        /* we wil add line-end anchoring */\n        ptr[0] = '(';\n        ++ptr;\n    }\n\n    for (orig_ptr = pattern; orig_ptr[0]; ++orig_ptr) {\n        if (orig_ptr[0] == '$') {\n            ptr += sprintf(ptr, \"\\\\$\");\n        } else {\n            ptr[0] = orig_ptr[0];\n            ++ptr;\n        }\n    }\n\n    if (strncmp(pattern + strlen(pattern) - 2, \".*\", 2)) {\n        ptr += sprintf(ptr, \")$\");\n    } else {\n        ptr[0] = '\\0';\n        ++ptr;\n    }\n\n    /* substitute Unicode Character Blocks with exact Character Ranges */\n    while ((ptr = strstr(perl_regex, \"\\\\p{Is\"))) {\n        start = ptr - perl_regex;\n\n        ptr = strchr(ptr, '}');\n        if (!ptr) {\n            LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + start + 2, \"unterminated character property\");\n            free(perl_regex);\n            return EXIT_FAILURE;\n        }\n\n        end = (ptr - perl_regex) + 1;\n\n        /* need more space */\n        if (end - start < LYP_URANGE_LEN) {\n            perl_regex = ly_realloc(perl_regex, strlen(perl_regex) + (LYP_URANGE_LEN - (end - start)) + 1);\n            LY_CHECK_ERR_RETURN(!perl_regex, LOGMEM(ctx); free(perl_regex), EXIT_FAILURE);\n        }\n\n        /* find our range */\n        for (idx = 0; lyp_ublock2urange[idx][0]; ++idx) {\n            if (!strncmp(perl_regex + start + 5, lyp_ublock2urange[idx][0], strlen(lyp_ublock2urange[idx][0]))) {\n                break;\n            }\n        }\n        if (!lyp_ublock2urange[idx][0]) {\n            LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + start + 5, \"unknown block name\");\n            free(perl_regex);\n            return EXIT_FAILURE;\n        }\n\n        /* make the space in the string and replace the block (but we cannot include brackets if it was already enclosed in them) */\n        for (idx2 = 0, count = 0; idx2 < start; ++idx2) {\n            if ((perl_regex[idx2] == '[') && (!idx2 || (perl_regex[idx2 - 1] != '\\\\'))) {\n                ++count;\n            }\n            if ((perl_regex[idx2] == ']') && (!idx2 || (perl_regex[idx2 - 1] != '\\\\'))) {\n                --count;\n            }\n        }\n        if (count) {\n            /* skip brackets */\n            memmove(perl_regex + start + (LYP_URANGE_LEN - 2), perl_regex + end, strlen(perl_regex + end) + 1);\n            memcpy(perl_regex + start, lyp_ublock2urange[idx][1] + 1, LYP_URANGE_LEN - 2);\n        } else {\n            memmove(perl_regex + start + LYP_URANGE_LEN, perl_regex + end, strlen(perl_regex + end) + 1);\n            memcpy(perl_regex + start, lyp_ublock2urange[idx][1], LYP_URANGE_LEN);\n        }\n    }\n\n    /* must return 0, already checked during parsing */\n    precomp = pcre_compile(perl_regex, PCRE_ANCHORED | PCRE_DOLLAR_ENDONLY | PCRE_NO_AUTO_CAPTURE,\n                           &err_msg, &err_offset, NULL);\n    if (!precomp) {\n        LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + err_offset, err_msg);\n        free(perl_regex);\n        return EXIT_FAILURE;\n    }\n    free(perl_regex);\n\n    if (pcre_precomp) {\n        *pcre_precomp = precomp;\n    } else {\n        free(precomp);\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nlyp_precompile_pattern(struct ly_ctx *ctx, const char *pattern, pcre** pcre_cmp, pcre_extra **pcre_std)\n{\n    const char *err_msg = NULL;\n\n    if (lyp_check_pattern(ctx, pattern, pcre_cmp)) {\n        return EXIT_FAILURE;\n    }\n\n    if (pcre_std && pcre_cmp) {\n        (*pcre_std) = pcre_study(*pcre_cmp, 0, &err_msg);\n        if (err_msg) {\n            LOGWRN(ctx, \"Studying pattern \\\"%s\\\" failed (%s).\", pattern, err_msg);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Change the value into its canonical form. In libyang, additionally to the RFC,\n * all identities have their module as a prefix in their canonical form.\n *\n * @param[in] ctx\n * @param[in] type Type of the value.\n * @param[in,out] value Original and then canonical value.\n * @param[in] data1 If \\p type is #LY_TYPE_BITS: (struct lys_type_bit **) type bit field,\n *                                #LY_TYPE_DEC64: (int64_t *) parsed digits of the number itself without floating point,\n *                                #LY_TYPE_IDENT: (const char *) local module name (identityref node module),\n *                                #LY_TYPE_INT*: (int64_t *) parsed int number itself,\n *                                #LY_TYPE_UINT*: (uint64_t *) parsed uint number itself,\n *                                otherwise ignored.\n * @param[in] data2 If \\p type is #LY_TYPE_BITS: (int *) type bit field length,\n *                                #LY_TYPE_DEC64: (uint8_t *) number of fraction digits (position of the floating point),\n *                                otherwise ignored.\n * @return 1 if a conversion took place, 0 if the value was kept the same, -1 on error.\n */\nstatic int\nmake_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)\n{\n    const uint16_t buf_len = 511;\n    char buf[buf_len + 1];\n    struct lys_type_bit **bits = NULL;\n    struct lyxp_expr *exp;\n    const char *module_name, *cur_expr, *end;\n    int i, j, count;\n    int64_t num;\n    uint64_t unum;\n    uint8_t c;\n\n#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, \"Value \\\"%s\\\" is too long.\", str)\n\n    switch (type) {\n    case LY_TYPE_BITS:\n        bits = (struct lys_type_bit **)data1;\n        count = *((int *)data2);\n        /* in canonical form, the bits are ordered by their position */\n        buf[0] = '\\0';\n        for (i = 0; i < count; i++) {\n            if (!bits[i]) {\n                /* bit not set */\n                continue;\n            }\n            if (buf[0]) {\n                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                sprintf(buf + strlen(buf), \" %s\", bits[i]->name);\n            } else {\n                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                strcpy(buf, bits[i]->name);\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        module_name = (const char *)data1;\n        /* identity must always have a prefix */\n        if (!strchr(*value, ':')) {\n            sprintf(buf, \"%s:%s\", module_name, *value);\n        } else {\n            strcpy(buf, *value);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        exp = lyxp_parse_expr(ctx, *value);\n        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);\n\n        module_name = NULL;\n        count = 0;\n        for (i = 0; (unsigned)i < exp->used; ++i) {\n            cur_expr = &exp->expr[exp->expr_pos[i]];\n\n            /* copy WS */\n            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {\n                if (count + (cur_expr - end) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, cur_expr - end);\n                count += cur_expr - end;\n            }\n\n            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {\n                /* get the module name with \":\" */\n                ++end;\n                j = end - cur_expr;\n\n                if (!module_name || strncmp(cur_expr, module_name, j)) {\n                    /* print module name with colon, it does not equal to the parent one */\n                    if (count + j > buf_len) {\n                        lyxp_expr_free(exp);\n                        LOGBUF(cur_expr);\n                        return -1;\n                    }\n                    strncpy(&buf[count], cur_expr, j);\n                    count += j;\n                }\n                module_name = cur_expr;\n\n                /* copy the rest */\n                if (count + (exp->tok_len[i] - j) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, exp->tok_len[i] - j);\n                count += exp->tok_len[i] - j;\n            } else {\n                if (count + exp->tok_len[i] > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(&exp->expr[exp->expr_pos[i]]);\n                    return -1;\n                }\n                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);\n                count += exp->tok_len[i];\n            }\n        }\n        if (count > buf_len) {\n            LOGINT(ctx);\n            lyxp_expr_free(exp);\n            return -1;\n        }\n        buf[count] = '\\0';\n\n        lyxp_expr_free(exp);\n        break;\n\n    case LY_TYPE_DEC64:\n        num = *((int64_t *)data1);\n        c = *((uint8_t *)data2);\n        if (num) {\n            count = sprintf(buf, \"%\"PRId64\" \", num);\n            if ( (num > 0 && (count - 1) <= c)\n                 || (count - 2) <= c ) {\n                /* we have 0. value, print the value with the leading zeros\n                 * (one for 0. and also keep the correct with of num according\n                 * to fraction-digits value)\n                 * for (num<0) - extra character for '-' sign */\n                count = sprintf(buf, \"%0*\"PRId64\" \", (num > 0) ? (c + 1) : (c + 2), num);\n            }\n            for (i = c, j = 1; i > 0 ; i--) {\n                if (j && i > 1 && buf[count - 2] == '0') {\n                    /* we have trailing zero to skip */\n                    buf[count - 1] = '\\0';\n                } else {\n                    j = 0;\n                    buf[count - 1] = buf[count - 2];\n                }\n                count--;\n            }\n            buf[count - 1] = '.';\n        } else {\n            /* zero */\n            sprintf(buf, \"0.0\");\n        }\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n        num = *((int64_t *)data1);\n        sprintf(buf, \"%\"PRId64, num);\n        break;\n\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        unum = *((uint64_t *)data1);\n        sprintf(buf, \"%\"PRIu64, unum);\n        break;\n\n    default:\n        /* should not be even called - just do nothing */\n        return 0;\n    }\n\n    if (strcmp(buf, *value)) {\n        lydict_remove(ctx, *value);\n        *value = lydict_insert(ctx, buf, 0);\n        return 1;\n    }\n\n    return 0;\n\n#undef LOGBUF\n}\n\nstatic const char *\nident_val_add_module_prefix(const char *value, const struct lyxml_elem *xml, struct ly_ctx *ctx)\n{\n    const struct lyxml_ns *ns;\n    const struct lys_module *mod;\n    char *str;\n\n    do {\n        LY_TREE_FOR((struct lyxml_ns *)xml->attr, ns) {\n            if ((ns->type == LYXML_ATTR_NS) && !ns->prefix) {\n                /* match */\n                break;\n            }\n        }\n        if (!ns) {\n            xml = xml->parent;\n        }\n    } while (!ns && xml);\n\n    if (!ns) {\n        /* no default namespace */\n        LOGINT(ctx);\n        return NULL;\n    }\n\n    /* find module */\n    mod = ly_ctx_get_module_by_ns(ctx, ns->value, NULL, 1);\n    if (!mod) {\n        LOGINT(ctx);\n        return NULL;\n    }\n\n    if (asprintf(&str, \"%s:%s\", mod->name, value) == -1) {\n        LOGMEM(ctx);\n        return NULL;\n    }\n    lydict_remove(ctx, value);\n\n    return lydict_insert_zc(ctx, str);\n}\n\n/*\n * xml  - optional for converting instance-identifier and identityref into JSON format\n * leaf - mandatory to know the context (necessary e.g. for prefixes in idenitytref values)\n * attr - alternative to leaf in case of parsing value in annotations (attributes)\n * local_mod - optional if the local module dos not match the module of leaf/attr\n * store - flag for union resolution - we do not want to store the result, we are just learning the type\n * dflt - whether the value is a default value from the schema\n * trusted - whether the value is trusted to be valid (but may not be canonical, so it is canonized)\n */\nstruct lys_type *\nlyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *xml,\n                struct lyd_node_leaf_list *leaf, struct lyd_attr *attr, struct lys_module *local_mod,\n                int store, int dflt, int trusted)\n{\n    struct lys_type *ret = NULL, *t;\n    struct lys_tpdf *tpdf;\n    enum int_log_opts prev_ilo;\n    int c, len, found = 0;\n    unsigned int i, j;\n    int64_t num;\n    uint64_t unum, uind, u = 0;\n    const char *ptr, *value = *value_, *itemname, *old_val_str = NULL;\n    struct lys_type_bit **bits = NULL;\n    struct lys_ident *ident;\n    lyd_val *val, old_val;\n    LY_DATA_TYPE *val_type, old_val_type;\n    uint8_t *val_flags, old_val_flags;\n    struct lyd_node *contextnode;\n    struct ly_ctx *ctx = type->parent->module->ctx;\n\n    assert(leaf || attr);\n\n    if (leaf) {\n        assert(!attr);\n        if (!local_mod) {\n            local_mod = leaf->schema->module;\n        }\n        val = &leaf->value;\n        val_type = &leaf->value_type;\n        val_flags = &leaf->value_flags;\n        contextnode = (struct lyd_node *)leaf;\n        itemname = leaf->schema->name;\n    } else {\n        assert(!leaf);\n        if (!local_mod) {\n            local_mod = attr->annotation->module;\n        }\n        val = &attr->value;\n        val_type = &attr->value_type;\n        val_flags = &attr->value_flags;\n        contextnode = attr->parent;\n        itemname = attr->name;\n    }\n\n    /* fully clear the value */\n    if (store) {\n        old_val_str = lydict_insert(ctx, *value_, 0);\n        lyd_free_value(*val, *val_type, *val_flags, type, old_val_str, &old_val, &old_val_type, &old_val_flags);\n        *val_flags &= ~LY_VALUE_UNRES;\n    }\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        /* get number of octets for length validation */\n        unum = 0;\n        ptr = NULL;\n        if (value) {\n            /* silently skip leading/trailing whitespaces */\n            for (uind = 0; isspace(value[uind]); ++uind);\n            ptr = &value[uind];\n            u = strlen(ptr);\n            while (u && isspace(ptr[u - 1])) {\n                --u;\n            }\n            unum = u;\n            for (uind = 0; uind < u; ++uind) {\n                if (ptr[uind] == '\\n') {\n                    unum--;\n                } else if ((ptr[uind] < '/' && ptr[uind] != '+') ||\n                    (ptr[uind] > '9' && ptr[uind] < 'A') ||\n                    (ptr[uind] > 'Z' && ptr[uind] < 'a') || ptr[uind] > 'z') {\n                    if (ptr[uind] == '=') {\n                        /* padding */\n                        if (uind == u - 2 && ptr[uind + 1] == '=') {\n                            found = 2;\n                            uind++;\n                        } else if (uind == u - 1) {\n                            found = 1;\n                        }\n                    }\n                    if (!found) {\n                        /* error */\n                        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, contextnode, ptr[uind], &ptr[uind]);\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Invalid Base64 character.\");\n                        goto error;\n                    }\n                }\n            }\n        }\n\n        if (unum & 3) {\n            /* base64 length must be multiple of 4 chars */\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n            }\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Base64 encoded value length must be divisible by 4.\");\n            goto error;\n        }\n\n        /* length of the encoded string */\n        len = ((unum / 4) * 3) - found;\n        if (!trusted && validate_length_range(0, len, 0, 0, 0, type, value, contextnode)) {\n            goto error;\n        }\n\n        if (value && (ptr != value || ptr[u] != '\\0')) {\n            /* update the changed value */\n            ptr = lydict_insert(ctx, ptr, u);\n            lydict_remove(ctx, *value_);\n            *value_ = ptr;\n        }\n\n        if (store) {\n            /* store the result */\n            val->binary = value;\n            *val_type = LY_TYPE_BINARY;\n        }\n        break;\n\n    case LY_TYPE_BITS:\n        /* locate bits structure with the bits definitions\n         * since YANG 1.1 allows restricted bits, it is the first\n         * bits type with some explicit bit specification */\n        for (; !type->info.bits.count; type = &type->der->type);\n\n        if (value || store) {\n            /* allocate the array of pointers to bits definition */\n            bits = calloc(type->info.bits.count, sizeof *bits);\n            LY_CHECK_ERR_GOTO(!bits, LOGMEM(ctx), error);\n        }\n\n        if (!value) {\n            /* no bits set */\n            if (store) {\n                /* store empty array */\n                val->bit = bits;\n                *val_type = LY_TYPE_BITS;\n            }\n            break;\n        }\n\n        c = 0;\n        i = 0;\n        while (value[c]) {\n            /* skip leading whitespaces */\n            while (isspace(value[c])) {\n                c++;\n            }\n            if (!value[c]) {\n                /* trailing white spaces */\n                break;\n            }\n\n            /* get the length of the bit identifier */\n            for (len = 0; value[c] && !isspace(value[c]); c++, len++);\n\n            /* go back to the beginning of the identifier */\n            c = c - len;\n\n            /* find bit definition, identifiers appear ordered by their position */\n            for (found = i = 0; i < type->info.bits.count; i++) {\n                if (!strncmp(type->info.bits.bit[i].name, &value[c], len) && !type->info.bits.bit[i].name[len]) {\n                    /* we have match, check if the value is enabled ... */\n                    for (j = 0; !trusted && (j < type->info.bits.bit[i].iffeature_size); j++) {\n                        if (!resolve_iffeature(&type->info.bits.bit[i].iffeature[j])) {\n                            if (leaf) {\n                                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                            } else {\n                                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                            }\n                            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                                   \"Bit \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                                   type->info.bits.bit[i].name, j + 1);\n                            free(bits);\n                            goto error;\n                        }\n                    }\n                    /* check that the value was not already set */\n                    if (bits[i]) {\n                        if (leaf) {\n                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                        } else {\n                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                        }\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Bit \\\"%s\\\" used multiple times.\",\n                               type->info.bits.bit[i].name);\n                        free(bits);\n                        goto error;\n                    }\n                    /* ... and then store the pointer */\n                    bits[i] = &type->info.bits.bit[i];\n\n                    /* stop searching */\n                    found = 1;\n                    break;\n                }\n            }\n\n            if (!found) {\n                /* referenced bit value does not exist */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                }\n                free(bits);\n                goto error;\n            }\n            c = c + len;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_BITS, value_, bits, &type->info.bits.count) == -1) {\n            free(bits);\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->bit = bits;\n            *val_type = LY_TYPE_BITS;\n        } else {\n            free(bits);\n        }\n        break;\n\n    case LY_TYPE_BOOL:\n        if (value && !strcmp(value, \"true\")) {\n            if (store) {\n                val->bln = 1;\n            }\n        } else if (!value || strcmp(value, \"false\")) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value ? value : \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value ? value : \"\");\n            }\n            goto error;\n        } else {\n            if (store) {\n                val->bln = 0;\n            }\n        }\n\n        if (store) {\n            *val_type = LY_TYPE_BOOL;\n        }\n        break;\n\n    case LY_TYPE_DEC64:\n        if (!value || !value[0]) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        ptr = value;\n        if (parse_range_dec64(&ptr, type->info.dec64.dig, &num) || ptr[0]) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n            }\n            goto error;\n        }\n\n        if (!trusted && validate_length_range(2, 0, 0, num, type->info.dec64.dig, type, value, contextnode)) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_DEC64, value_, &num, &type->info.dec64.dig) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->dec64 = num;\n            *val_type = LY_TYPE_DEC64;\n        }\n        break;\n\n    case LY_TYPE_EMPTY:\n        if (value && value[0]) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n            }\n            goto error;\n        }\n\n        if (store) {\n            *val_type = LY_TYPE_EMPTY;\n        }\n        break;\n\n    case LY_TYPE_ENUM:\n        /* locate enums structure with the enumeration definitions,\n         * since YANG 1.1 allows restricted enums, it is the first\n         * enum type with some explicit enum specification */\n        for (; !type->info.enums.count; type = &type->der->type);\n\n        /* find matching enumeration value */\n        for (i = found = 0; i < type->info.enums.count; i++) {\n            if (value && !strcmp(value, type->info.enums.enm[i].name)) {\n                /* we have match, check if the value is enabled ... */\n                for (j = 0; !trusted && (j < type->info.enums.enm[i].iffeature_size); j++) {\n                    if (!resolve_iffeature(&type->info.enums.enm[i].iffeature[j])) {\n                        if (leaf) {\n                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                        } else {\n                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                        }\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Enum \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                               value, j + 1);\n                        goto error;\n                    }\n                }\n                /* ... and store pointer to the definition */\n                if (store) {\n                    val->enm = &type->info.enums.enm[i];\n                    *val_type = LY_TYPE_ENUM;\n                }\n                found = 1;\n                break;\n            }\n        }\n\n        if (!found) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value ? value : \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value ? value : \"\");\n            }\n            goto error;\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        if (!value) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        if (xml) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            /* first, convert value into the json format, silently */\n            value = transform_xml2json(ctx, value, xml, 0, 0);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n            if (!value) {\n                /* invalid identityref format */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n                }\n                goto error;\n            }\n\n            /* the value has no prefix (default namespace), but the element's namespace has a prefix, find default namespace */\n            if (!strchr(value, ':') && xml->ns->prefix) {\n                value = ident_val_add_module_prefix(value, xml, ctx);\n                if (!value) {\n                    goto error;\n                }\n            }\n        } else if (dflt) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            /* the value actually uses module's prefixes instead of the module names as in JSON format,\n             * we have to convert it */\n            value = transform_schema2json(local_mod, value);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n            if (!value) {\n                /* invalid identityref format or it was already transformed, so ignore the error here */\n                value = lydict_insert(ctx, *value_, 0);\n            }\n        } else {\n            value = lydict_insert(ctx, *value_, 0);\n        }\n        /* value is now in the dictionary, whether it differs from *value_ or not */\n\n        ident = resolve_identref(type, value, contextnode, local_mod, dflt);\n        if (!ident) {\n            lydict_remove(ctx, value);\n            goto error;\n        } else if (store) {\n            /* store the result */\n            val->ident = ident;\n            *val_type = LY_TYPE_IDENT;\n        }\n\n        /* the value is always changed and includes prefix */\n        if (dflt) {\n            type->parent->flags |= LYS_DFLTJSON;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_IDENT, &value, (void*)lys_main_module(local_mod)->name, NULL) == -1) {\n            lydict_remove(ctx, value);\n            goto error;\n        }\n\n        /* replace the old value with the new one (even if they may be the same) */\n        lydict_remove(ctx, *value_);\n        *value_ = value;\n        break;\n\n    case LY_TYPE_INST:\n        if (!value) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        if (xml) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            /* first, convert value into the json format, silently */\n            value = transform_xml2json(ctx, value, xml, 1, 1);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n            if (!value) {\n                /* invalid instance-identifier format */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n                }\n                goto error;\n            } else if (ly_strequal(value, *value_, 1)) {\n                /* we have actually created the same expression (prefixes are the same as the module names)\n                 * so we have just increased dictionary's refcount - fix it */\n                lydict_remove(ctx, value);\n            }\n        } else if (dflt) {\n            /* turn logging off */\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n\n            /* the value actually uses module's prefixes instead of the module names as in JSON format,\n             * we have to convert it */\n            value = transform_schema2json(local_mod, value);\n            if (!value) {\n                /* invalid identityref format or it was already transformed, so ignore the error here */\n                value = *value_;\n            } else if (ly_strequal(value, *value_, 1)) {\n                /* we have actually created the same expression (prefixes are the same as the module names)\n                 * so we have just increased dictionary's refcount - fix it */\n                lydict_remove(ctx, value);\n            }\n            /* turn logging back on */\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n        } else {\n            if ((c = make_canonical(ctx, LY_TYPE_INST, &value, NULL, NULL))) {\n                if (c == -1) {\n                    goto error;\n                }\n\n                /* if a change occurred, value was removed from the dictionary so fix the pointers */\n                *value_ = value;\n            }\n        }\n\n        if (store) {\n            /* note that the data node is an unresolved instance-identifier */\n            val->instance = NULL;\n            *val_type = LY_TYPE_INST;\n            *val_flags |= LY_VALUE_UNRES;\n        }\n\n        if (!ly_strequal(value, *value_, 1)) {\n            /* update the changed value */\n            lydict_remove(ctx, *value_);\n            *value_ = value;\n\n            /* we have to remember the conversion into JSON format to be able to print it in correct form */\n            if (dflt) {\n                type->parent->flags |= LYS_DFLTJSON;\n            }\n        }\n        break;\n\n    case LY_TYPE_LEAFREF:\n        if (!value) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        /* it is called not only to get the final type, but mainly to update value to canonical or JSON form\n         * if needed */\n        t = lyp_parse_value(&type->info.lref.target->type, value_, xml, leaf, attr, NULL, store, dflt, trusted);\n        value = *value_; /* refresh possibly changed value */\n        if (!t) {\n            /* already logged */\n            goto error;\n        }\n\n        if (store) {\n            /* make the note that the data node is an unresolved leafref (value union was already filled) */\n            *val_flags |= LY_VALUE_UNRES;\n        }\n\n        type = t;\n        break;\n\n    case LY_TYPE_STRING:\n        if (!trusted && validate_length_range(0, (value ? ly_strlen_utf8(value) : 0), 0, 0, 0, type, value, contextnode)) {\n            goto error;\n        }\n\n        if (!trusted && validate_pattern(ctx, value, type, contextnode)) {\n            goto error;\n        }\n\n        /* special handling of ietf-yang-types xpath1.0 */\n        for (tpdf = type->der;\n             tpdf->module && (strcmp(tpdf->name, \"xpath1.0\") || strcmp(tpdf->module->name, \"ietf-yang-types\"));\n             tpdf = tpdf->type.der);\n        if (tpdf->module && xml) {\n            /* convert value into the json format */\n            value = transform_xml2json(ctx, value ? value : \"\", xml, 1, 1);\n            if (!value) {\n                /* invalid instance-identifier format */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n                }\n                goto error;\n            }\n\n            if (!ly_strequal(value, *value_, 1)) {\n                /* update the changed value */\n                lydict_remove(ctx, *value_);\n                *value_ = value;\n            }\n        }\n\n        if (store) {\n            /* store the result */\n            val->string = value;\n            *val_type = LY_TYPE_STRING;\n        }\n        break;\n\n    case LY_TYPE_INT8:\n        if (parse_int(value, __INT64_C(-128), __INT64_C(127), dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT8, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int8 = (int8_t)num;\n            *val_type = LY_TYPE_INT8;\n        }\n        break;\n\n    case LY_TYPE_INT16:\n        if (parse_int(value, __INT64_C(-32768), __INT64_C(32767), dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT16, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int16 = (int16_t)num;\n            *val_type = LY_TYPE_INT16;\n        }\n        break;\n\n    case LY_TYPE_INT32:\n        if (parse_int(value, __INT64_C(-2147483648), __INT64_C(2147483647), dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT32, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int32 = (int32_t)num;\n            *val_type = LY_TYPE_INT32;\n        }\n        break;\n\n    case LY_TYPE_INT64:\n        if (parse_int(value, __INT64_C(-9223372036854775807) - __INT64_C(1), __INT64_C(9223372036854775807),\n                      dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT64, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int64 = num;\n            *val_type = LY_TYPE_INT64;\n        }\n        break;\n\n    case LY_TYPE_UINT8:\n        if (parse_uint(value, __UINT64_C(255), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT8, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint8 = (uint8_t)unum;\n            *val_type = LY_TYPE_UINT8;\n        }\n        break;\n\n    case LY_TYPE_UINT16:\n        if (parse_uint(value, __UINT64_C(65535), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT16, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint16 = (uint16_t)unum;\n            *val_type = LY_TYPE_UINT16;\n        }\n        break;\n\n    case LY_TYPE_UINT32:\n        if (parse_uint(value, __UINT64_C(4294967295), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT32, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint32 = (uint32_t)unum;\n            *val_type = LY_TYPE_UINT32;\n        }\n        break;\n\n    case LY_TYPE_UINT64:\n        if (parse_uint(value, __UINT64_C(18446744073709551615), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT64, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint64 = unum;\n            *val_type = LY_TYPE_UINT64;\n        }\n        break;\n\n    case LY_TYPE_UNION:\n        if (store) {\n            /* unresolved union type */\n            memset(val, 0, sizeof(lyd_val));\n            *val_type = LY_TYPE_UNION;\n        }\n\n        if (type->info.uni.has_ptr_type) {\n            /* we are not resolving anything here, only parsing, and in this case we cannot decide\n             * the type without resolving it -> we return the union type (resolve it with resolve_union()) */\n            if (xml) {\n                /* in case it should resolve into a instance-identifier, we can only do the JSON conversion here */\n                ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n                val->string = transform_xml2json(ctx, value, xml, 1, 1);\n                ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n                if (!val->string) {\n                    /* invalid instance-identifier format, likely some other type */\n                    val->string = lydict_insert(ctx, value, 0);\n                }\n            }\n            break;\n        }\n\n        t = NULL;\n        found = 0;\n\n        /* turn logging off, we are going to try to validate the value with all the types in order */\n        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n\n        while ((t = lyp_get_next_union_type(type, t, &found))) {\n            found = 0;\n            ret = lyp_parse_value(t, value_, xml, leaf, attr, NULL, store, dflt, 0);\n            if (ret) {\n                /* we have the result */\n                type = ret;\n                break;\n            }\n\n            if (store) {\n                /* erase possible present and invalid value data */\n                lyd_free_value(*val, *val_type, *val_flags, t, *value_, NULL, NULL, NULL);\n                memset(val, 0, sizeof(lyd_val));\n            }\n        }\n\n        /* turn logging back on */\n        ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n        if (!t) {\n            /* not found */\n            if (store) {\n                *val_type = 0;\n            }\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_ ? *value_ : \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n            }\n            goto error;\n        }\n        break;\n\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n\n    /* search user types in case this value is supposed to be stored in a custom way */\n    if (store && type->der && type->der->module) {\n        c = lytype_store(type->der->module, type->der->name, value_, val);\n        if (c == -1) {\n            goto error;\n        } else if (!c) {\n            *val_flags |= LY_VALUE_USER;\n        }\n    }\n\n    /* free backup */\n    if (store) {\n        lyd_free_value(old_val, old_val_type, old_val_flags, type, old_val_str, NULL, NULL, NULL);\n        lydict_remove(ctx, old_val_str);\n    }\n    return type;\n\nerror:\n    /* restore the backup */\n    if (store) {\n        *val = old_val;\n        *val_type = old_val_type;\n        *val_flags = old_val_flags;\n        lydict_remove(ctx, old_val_str);\n    }\n    return NULL;\n}\n\n/* does not log, cannot fail */\nstruct lys_type *\nlyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)\n{\n    unsigned int i;\n    struct lys_type *ret = NULL;\n\n    while (!type->info.uni.count) {\n        assert(type->der); /* at least the direct union type has to have type specified */\n        type = &type->der->type;\n    }\n\n    for (i = 0; i < type->info.uni.count; ++i) {\n        if (type->info.uni.types[i].base == LY_TYPE_UNION) {\n            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);\n            if (ret) {\n                break;\n            }\n            continue;\n        }\n\n        if (!prev_type || *found) {\n            ret = &type->info.uni.types[i];\n            break;\n        }\n\n        if (&type->info.uni.types[i] == prev_type) {\n            *found = 1;\n        }\n    }\n\n    return ret;\n}\n\n/* ret 0 - ret set, ret 1 - ret not set, no log, ret -1 - ret not set, fatal error */\nint\nlyp_fill_attr(struct ly_ctx *ctx, struct lyd_node *parent, const char *module_ns, const char *module_name,\n              const char *attr_name, const char *attr_value, struct lyxml_elem *xml, int options, struct lyd_attr **ret)\n{\n    const struct lys_module *mod = NULL;\n    const struct lys_submodule *submod = NULL;\n    struct lys_type **type;\n    struct lyd_attr *dattr;\n    int pos, i, j, k;\n\n    /* first, get module where the annotation should be defined */\n    if (module_ns) {\n        mod = (struct lys_module *)ly_ctx_get_module_by_ns(ctx, module_ns, NULL, 0);\n    } else if (module_name) {\n        mod = (struct lys_module *)ly_ctx_get_module(ctx, module_name, NULL, 0);\n    } else {\n        LOGINT(ctx);\n        return -1;\n    }\n    if (!mod) {\n        return 1;\n    }\n\n    /* then, find the appropriate annotation definition */\n    pos = -1;\n    for (i = 0, j = 0; i < mod->ext_size; i = i + j + 1) {\n        j = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0], &mod->ext[i], mod->ext_size - i);\n        if (j == -1) {\n            break;\n        }\n        if (ly_strequal(mod->ext[i + j]->arg_value, attr_name, 0)) {\n            pos = i + j;\n            break;\n        }\n    }\n\n    /* try submodules */\n    if (pos == -1) {\n        for (k = 0; k < mod->inc_size; ++k) {\n            submod = mod->inc[k].submodule;\n            for (i = 0, j = 0; i < submod->ext_size; i = i + j + 1) {\n                j = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0], &submod->ext[i], submod->ext_size - i);\n                if (j == -1) {\n                    break;\n                }\n                if (ly_strequal(submod->ext[i + j]->arg_value, attr_name, 0)) {\n                    pos = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (pos == -1) {\n        return 1;\n    }\n\n    /* allocate and fill the data attribute structure */\n    dattr = calloc(1, sizeof *dattr);\n    LY_CHECK_ERR_RETURN(!dattr, LOGMEM(ctx), -1);\n\n    dattr->parent = parent;\n    dattr->next = NULL;\n    dattr->annotation = submod ? (struct lys_ext_instance_complex *)submod->ext[pos] :\n                                 (struct lys_ext_instance_complex *)mod->ext[pos];\n    dattr->name = lydict_insert(ctx, attr_name, 0);\n    dattr->value_str = lydict_insert(ctx, attr_value, 0);\n\n    /* the value is here converted to a JSON format if needed in case of LY_TYPE_IDENT and LY_TYPE_INST or to a\n     * canonical form of the value */\n    type = lys_ext_complex_get_substmt(LY_STMT_TYPE, dattr->annotation, NULL);\n    if (!type || !lyp_parse_value(*type, &dattr->value_str, xml, NULL, dattr, NULL, 1, 0, options & LYD_OPT_TRUSTED)) {\n        lydict_remove(ctx, dattr->name);\n        lydict_remove(ctx, dattr->value_str);\n        free(dattr);\n        return -1;\n    }\n\n    *ret = dattr;\n    return 0;\n}\n\nint\nlyp_check_edit_attr(struct ly_ctx *ctx, struct lyd_attr *attr, struct lyd_node *parent, int *editbits)\n{\n    struct lyd_attr *last = NULL;\n    int bits = 0;\n\n    /* 0x01 - insert attribute present\n     * 0x02 - insert is relative (before or after)\n     * 0x04 - value attribute present\n     * 0x08 - key attribute present\n     * 0x10 - operation attribute present\n     * 0x20 - operation not allowing insert attribute (delete or remove)\n     */\n    LY_TREE_FOR(attr, attr) {\n        last = NULL;\n        if (!strcmp(attr->annotation->arg_value, \"operation\") &&\n                !strcmp(attr->annotation->module->name, \"ietf-netconf\")) {\n            if (bits & 0x10) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"operation attributes\", parent->schema->name);\n                return -1;\n            }\n\n            bits |= 0x10;\n            if (attr->value.enm->value >= 3) {\n                /* delete or remove */\n                bits |= 0x20;\n            }\n        } else if (attr->annotation->module == ctx->models.list[1] && /* internal YANG schema */\n                !strcmp(attr->annotation->arg_value, \"insert\")) {\n            /* 'insert' attribute present */\n            if (!(parent->schema->flags & LYS_USERORDERED)) {\n                /* ... but it is not expected */\n                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, \"insert\");\n                return -1;\n            }\n            if (bits & 0x01) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"insert attributes\", parent->schema->name);\n                return -1;\n            }\n\n            bits |= 0x01;\n            if (attr->value.enm->value >= 2) {\n                /* before or after */\n                bits |= 0x02;\n            }\n            last = attr;\n        } else if (attr->annotation->module == ctx->models.list[1] && /* internal YANG schema */\n                !strcmp(attr->annotation->arg_value, \"value\")) {\n            if (bits & 0x04) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"value attributes\", parent->schema->name);\n                return -1;\n            } else if (parent->schema->nodetype & LYS_LIST) {\n                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, attr->name);\n                return -1;\n            }\n            bits |= 0x04;\n            last = attr;\n        } else if (attr->annotation->module == ctx->models.list[1] && /* internal YANG schema */\n                !strcmp(attr->annotation->arg_value, \"key\")) {\n            if (bits & 0x08) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"key attributes\", parent->schema->name);\n                return -1;\n            } else if (parent->schema->nodetype & LYS_LEAFLIST) {\n                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, attr->name);\n                return -1;\n            }\n            bits |= 0x08;\n            last = attr;\n        }\n    }\n\n    /* report errors */\n    if (last && (!(parent->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) || !(parent->schema->flags & LYS_USERORDERED))) {\n        /* moving attributes in wrong elements (not an user ordered list or not a list at all) */\n        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, last->name);\n        return -1;\n    } else if (bits == 3) {\n        /* 0x01 | 0x02 - relative position, but value/key is missing */\n        if (parent->schema->nodetype & LYS_LIST) {\n            LOGVAL(ctx, LYE_MISSATTR, LY_VLOG_LYD, parent, \"key\", parent->schema->name);\n        } else { /* LYS_LEAFLIST */\n            LOGVAL(ctx, LYE_MISSATTR, LY_VLOG_LYD, parent, \"value\", parent->schema->name);\n        }\n        return -1;\n    } else if ((bits & (0x04 | 0x08)) && !(bits & 0x02)) {\n        /* key/value without relative position */\n        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, (bits & 0x04) ? \"value\" : \"key\");\n        return -1;\n    } else if ((bits & 0x21) == 0x21) {\n        /* insert in delete/remove */\n        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, \"insert\");\n        return -1;\n    }\n\n    if (editbits) {\n        *editbits = bits;\n    }\n    return 0;\n}\n\n/* does not log */\nstatic int\ndup_identity_check(const char *id, struct lys_ident *ident, uint32_t size)\n{\n    uint32_t i;\n\n    for (i = 0; i < size; i++) {\n        if (ly_strequal(id, ident[i].name, 1)) {\n            /* name collision */\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\ndup_identities_check(const char *id, struct lys_module *module)\n{\n    struct lys_module *mainmod;\n    int i;\n\n    if (dup_identity_check(id, module->ident, module->ident_size)) {\n        LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"identity\", id);\n        return EXIT_FAILURE;\n    }\n\n    /* check identity in submodules */\n    mainmod = lys_main_module(module);\n    for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; ++i) {\n        if (dup_identity_check(id, mainmod->inc[i].submodule->ident, mainmod->inc[i].submodule->ident_size)) {\n            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"identity\", id);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nint\ndup_typedef_check(const char *type, struct lys_tpdf *tpdf, int size)\n{\n    int i;\n\n    for (i = 0; i < size; i++) {\n        if (!strcmp(type, tpdf[i].name)) {\n            /* name collision */\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nstatic int\ndup_feature_check(const char *id, struct lys_module *module)\n{\n    int i;\n\n    for (i = 0; i < module->features_size; i++) {\n        if (!strcmp(id, module->features[i].name)) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nstatic int\ndup_prefix_check(const char *prefix, struct lys_module *module)\n{\n    int i;\n\n    if (module->prefix && !strcmp(module->prefix, prefix)) {\n        return EXIT_FAILURE;\n    }\n    for (i = 0; i < module->imp_size; i++) {\n        if (!strcmp(module->imp[i].prefix, prefix)) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlyp_check_identifier(struct ly_ctx *ctx, const char *id, enum LY_IDENT type, struct lys_module *module,\n                     struct lys_node *parent)\n{\n    int i, j;\n    int size;\n    struct lys_tpdf *tpdf;\n    struct lys_node *node;\n    struct lys_module *mainmod;\n    struct lys_submodule *submod;\n\n    assert(ctx && id);\n\n    /* check id syntax */\n    if (!(id[0] >= 'A' && id[0] <= 'Z') && !(id[0] >= 'a' && id[0] <= 'z') && id[0] != '_') {\n        LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, \"invalid start character\");\n        return EXIT_FAILURE;\n    }\n    for (i = 1; id[i]; i++) {\n        if (!(id[i] >= 'A' && id[i] <= 'Z') && !(id[i] >= 'a' && id[i] <= 'z')\n                && !(id[i] >= '0' && id[i] <= '9') && id[i] != '_' && id[i] != '-' && id[i] != '.') {\n            LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, \"invalid character\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (i > 64) {\n        LOGWRN(ctx, \"Identifier \\\"%s\\\" is long, you should use something shorter.\", id);\n    }\n\n    switch (type) {\n    case LY_IDENT_NAME:\n        /* check uniqueness of the node within its siblings */\n        if (!parent) {\n            break;\n        }\n\n        LY_TREE_FOR(parent->child, node) {\n            if (ly_strequal(node->name, id, 1)) {\n                LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, \"name duplication\");\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    case LY_IDENT_TYPE:\n        assert(module);\n        mainmod = lys_main_module(module);\n\n        /* check collision with the built-in types */\n        if (!strcmp(id, \"binary\") || !strcmp(id, \"bits\") ||\n                !strcmp(id, \"boolean\") || !strcmp(id, \"decimal64\") ||\n                !strcmp(id, \"empty\") || !strcmp(id, \"enumeration\") ||\n                !strcmp(id, \"identityref\") || !strcmp(id, \"instance-identifier\") ||\n                !strcmp(id, \"int8\") || !strcmp(id, \"int16\") ||\n                !strcmp(id, \"int32\") || !strcmp(id, \"int64\") ||\n                !strcmp(id, \"leafref\") || !strcmp(id, \"string\") ||\n                !strcmp(id, \"uint8\") || !strcmp(id, \"uint16\") ||\n                !strcmp(id, \"uint32\") || !strcmp(id, \"uint64\") || !strcmp(id, \"union\")) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, id, \"typedef\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Typedef name duplicates a built-in type.\");\n            return EXIT_FAILURE;\n        }\n\n        /* check locally scoped typedefs (avoid name shadowing) */\n        for (; parent; parent = lys_parent(parent)) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n            case LYS_LIST:\n                size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n            case LYS_GROUPING:\n                size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n            default:\n                continue;\n            }\n\n            if (dup_typedef_check(id, tpdf, size)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"typedef\", id);\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* check top-level names */\n        if (dup_typedef_check(id, module->tpdf, module->tpdf_size)) {\n            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"typedef\", id);\n            return EXIT_FAILURE;\n        }\n\n        /* check submodule's top-level names */\n        for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; i++) {\n            if (dup_typedef_check(id, mainmod->inc[i].submodule->tpdf, mainmod->inc[i].submodule->tpdf_size)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"typedef\", id);\n                return EXIT_FAILURE;\n            }\n        }\n\n        break;\n    case LY_IDENT_PREFIX:\n        assert(module);\n\n        /* check the module itself */\n        if (dup_prefix_check(id, module)) {\n            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"prefix\", id);\n            return EXIT_FAILURE;\n        }\n        break;\n    case LY_IDENT_FEATURE:\n        assert(module);\n        mainmod = lys_main_module(module);\n\n        /* check feature name uniqueness*/\n        /* check features in the current module */\n        if (dup_feature_check(id, module)) {\n            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"feature\", id);\n            return EXIT_FAILURE;\n        }\n\n        /* and all its submodules */\n        for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; i++) {\n            if (dup_feature_check(id, (struct lys_module *)mainmod->inc[i].submodule)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"feature\", id);\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n\n    case LY_IDENT_EXTENSION:\n        assert(module);\n        mainmod = lys_main_module(module);\n\n        /* check extension name uniqueness in the main module ... */\n        for (i = 0; i < mainmod->extensions_size; i++) {\n            if (ly_strequal(id, mainmod->extensions[i].name, 1)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"extension\", id);\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* ... and all its submodules */\n        for (j = 0; j < mainmod->inc_size && mainmod->inc[j].submodule; j++) {\n            submod = mainmod->inc[j].submodule; /* shortcut */\n            for (i = 0; i < submod->extensions_size; i++) {\n                if (ly_strequal(id, submod->extensions[i].name, 1)) {\n                    LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"extension\", id);\n                    return EXIT_FAILURE;\n                }\n            }\n        }\n\n        break;\n\n    default:\n        /* no check required */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlyp_check_date(struct ly_ctx *ctx, const char *date)\n{\n    int i;\n    struct tm tm, tm_;\n    char *r;\n\n    assert(date);\n\n    /* check format */\n    for (i = 0; i < LY_REV_SIZE - 1; i++) {\n        if (i == 4 || i == 7) {\n            if (date[i] != '-') {\n                goto error;\n            }\n        } else if (!isdigit(date[i])) {\n            goto error;\n        }\n    }\n\n    /* check content, e.g. 2018-02-31 */\n    memset(&tm, 0, sizeof tm);\n    r = strptime(date, \"%Y-%m-%d\", &tm);\n    if (!r || r != &date[LY_REV_SIZE - 1]) {\n        goto error;\n    }\n    /* set some arbitrary non-0 value in case DST changes, it could move the day otherwise */\n    tm.tm_hour = 12;\n\n    memcpy(&tm_, &tm, sizeof tm);\n    mktime(&tm_); /* mktime modifies tm_ if it refers invalid date */\n    if (tm.tm_mday != tm_.tm_mday) { /* e.g 2018-02-29 -> 2018-03-01 */\n        /* checking days is enough, since other errors\n         * have been checked by strptime() */\n        goto error;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    LOGVAL(ctx, LYE_INDATE, LY_VLOG_NONE, NULL, date);\n    return EXIT_FAILURE;\n}\n\n/**\n * @return\n * NULL - success\n * root - not yet resolvable\n * other node - mandatory node under the root\n */\nstatic const struct lys_node *\nlyp_check_mandatory_(const struct lys_node *root)\n{\n    int mand_flag = 0;\n    const struct lys_node *iter = NULL;\n\n    while ((iter = lys_getnext(iter, root, NULL, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHUSES | LYS_GETNEXT_INTOUSES\n            | LYS_GETNEXT_INTONPCONT | LYS_GETNEXT_NOSTATECHECK))) {\n        if (iter->nodetype == LYS_USES) {\n            if (!((struct lys_node_uses *)iter)->grp) {\n                /* not yet resolved uses */\n                return root;\n            } else {\n                /* go into uses */\n                continue;\n            }\n        }\n        if (iter->nodetype == LYS_CHOICE) {\n            /* skip it, it was already checked for direct mandatory node in default */\n            continue;\n        }\n        if (iter->nodetype == LYS_LIST) {\n            if (((struct lys_node_list *)iter)->min) {\n                mand_flag = 1;\n            }\n        } else if (iter->nodetype == LYS_LEAFLIST) {\n            if (((struct lys_node_leaflist *)iter)->min) {\n                mand_flag = 1;\n            }\n        } else if (iter->flags & LYS_MAND_TRUE) {\n            mand_flag = 1;\n        }\n\n        if (mand_flag) {\n            return iter;\n        }\n    }\n\n    return NULL;\n}\n\n/* logs directly */\nint\nlyp_check_mandatory_augment(struct lys_node_augment *aug, const struct lys_node *target)\n{\n    const struct lys_node *node;\n\n    if (aug->when || target->nodetype == LYS_CHOICE) {\n        /* - mandatory nodes in new cases are ok;\n         * clarification from YANG 1.1 - augmentation can add mandatory nodes when it is\n         * conditional with a when statement */\n        return EXIT_SUCCESS;\n    }\n\n    if ((node = lyp_check_mandatory_((struct lys_node *)aug))) {\n        if (node != (struct lys_node *)aug) {\n            LOGVAL(target->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(target->module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                   \"Mandatory node \\\"%s\\\" appears in augment of \\\"%s\\\" without when condition.\",\n                   node->name, aug->target_name);\n            return -1;\n        }\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief check that a mandatory node is not directly under the default case.\n * @param[in] node choice with default node\n * @return EXIT_SUCCESS if the constraint is fulfilled, EXIT_FAILURE otherwise\n */\nint\nlyp_check_mandatory_choice(struct lys_node *node)\n{\n    const struct lys_node *mand, *dflt = ((struct lys_node_choice *)node)->dflt;\n\n    if ((mand = lyp_check_mandatory_(dflt))) {\n        if (mand != dflt) {\n            LOGVAL(node->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(node->module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                   \"Mandatory node \\\"%s\\\" is directly under the default case \\\"%s\\\" of the \\\"%s\\\" choice.\",\n                   mand->name, dflt->name, node->name);\n            return -1;\n        }\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check status for invalid combination.\n *\n * @param[in] flags1 Flags of the referencing node.\n * @param[in] mod1 Module of the referencing node,\n * @param[in] name1 Schema node name of the referencing node.\n * @param[in] flags2 Flags of the referenced node.\n * @param[in] mod2 Module of the referenced node,\n * @param[in] name2 Schema node name of the referenced node.\n * @return EXIT_SUCCES on success, EXIT_FAILURE on invalid reference.\n */\nint\nlyp_check_status(uint16_t flags1, struct lys_module *mod1, const char *name1,\n                 uint16_t flags2, struct lys_module *mod2, const char *name2,\n                 const struct lys_node *node)\n{\n    uint16_t flg1, flg2;\n\n    flg1 = (flags1 & LYS_STATUS_MASK) ? (flags1 & LYS_STATUS_MASK) : LYS_STATUS_CURR;\n    flg2 = (flags2 & LYS_STATUS_MASK) ? (flags2 & LYS_STATUS_MASK) : LYS_STATUS_CURR;\n\n    if ((flg1 < flg2) && (lys_main_module(mod1) == lys_main_module(mod2))) {\n        LOGVAL(mod1->ctx, LYE_INSTATUS, node ? LY_VLOG_LYS : LY_VLOG_NONE, node,\n               flg1 == LYS_STATUS_CURR ? \"current\" : \"deprecated\", name1, \"references\",\n               flg2 == LYS_STATUS_OBSLT ? \"obsolete\" : \"deprecated\", name2);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nvoid\nlyp_del_includedup(struct lys_module *mod, int free_subs)\n{\n    struct ly_modules_list *models = &mod->ctx->models;\n    uint8_t i;\n\n    assert(mod && !mod->type);\n\n    if (models->parsed_submodules_count) {\n        for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i);\n        if (models->parsed_submodules[i] == mod) {\n            if (free_subs) {\n                for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i) {\n                    lys_sub_module_remove_devs_augs((struct lys_module *)models->parsed_submodules[i]);\n                    lys_submodule_module_data_free((struct lys_submodule *)models->parsed_submodules[i]);\n                    lys_submodule_free((struct lys_submodule *)models->parsed_submodules[i], NULL);\n                }\n            }\n\n            models->parsed_submodules_count = i;\n            if (!models->parsed_submodules_count) {\n                free(models->parsed_submodules);\n                models->parsed_submodules = NULL;\n            }\n        }\n    }\n}\n\nstatic void\nlyp_add_includedup(struct lys_module *sub_mod, struct lys_submodule *parsed_submod)\n{\n    struct ly_modules_list *models = &sub_mod->ctx->models;\n    int16_t i;\n\n    /* store main module if first include */\n    if (models->parsed_submodules_count) {\n        for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i);\n    } else {\n        i = -1;\n    }\n    if ((i == -1) || (models->parsed_submodules[i] != lys_main_module(sub_mod))) {\n        ++models->parsed_submodules_count;\n        models->parsed_submodules = ly_realloc(models->parsed_submodules,\n                                               models->parsed_submodules_count * sizeof *models->parsed_submodules);\n        LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );\n        models->parsed_submodules[models->parsed_submodules_count - 1] = lys_main_module(sub_mod);\n    }\n\n    /* store parsed submodule */\n    ++models->parsed_submodules_count;\n    models->parsed_submodules = ly_realloc(models->parsed_submodules,\n                                           models->parsed_submodules_count * sizeof *models->parsed_submodules);\n    LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );\n    models->parsed_submodules[models->parsed_submodules_count - 1] = (struct lys_module *)parsed_submod;\n}\n\n/*\n * types: 0 - include, 1 - import\n */\nstatic int\nlyp_check_circmod(struct lys_module *module, const char *value, int type)\n{\n    LY_ECODE code = type ? LYE_CIRC_IMPORTS : LYE_CIRC_INCLUDES;\n    struct ly_modules_list *models = &module->ctx->models;\n    uint8_t i;\n\n    /* include/import itself */\n    if (ly_strequal(module->name, value, 1)) {\n        LOGVAL(module->ctx, code, LY_VLOG_NONE, NULL, value);\n        return -1;\n    }\n\n    /* currently parsed modules */\n    for (i = 0; i < models->parsing_sub_modules_count; i++) {\n        if (ly_strequal(models->parsing_sub_modules[i]->name, value, 1)) {\n            LOGVAL(module->ctx, code, LY_VLOG_NONE, NULL, value);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nint\nlyp_check_circmod_add(struct lys_module *module)\n{\n    struct ly_modules_list *models = &module->ctx->models;\n\n    /* storing - enlarge the list of modules being currently parsed */\n    ++models->parsing_sub_modules_count;\n    models->parsing_sub_modules = ly_realloc(models->parsing_sub_modules,\n                                             models->parsing_sub_modules_count * sizeof *models->parsing_sub_modules);\n    LY_CHECK_ERR_RETURN(!models->parsing_sub_modules, LOGMEM(module->ctx), -1);\n    models->parsing_sub_modules[models->parsing_sub_modules_count - 1] = module;\n\n    return 0;\n}\n\nvoid\nlyp_check_circmod_pop(struct ly_ctx *ctx)\n{\n    if (!ctx->models.parsing_sub_modules_count) {\n        LOGINT(ctx);\n        return;\n    }\n\n    /* update the list of currently being parsed modules */\n    ctx->models.parsing_sub_modules_count--;\n    if (!ctx->models.parsing_sub_modules_count) {\n        free(ctx->models.parsing_sub_modules);\n        ctx->models.parsing_sub_modules = NULL;\n    }\n}\n\n/*\n * -1 - error - invalid duplicities)\n *  0 - success, no duplicity\n *  1 - success, valid duplicity found and stored in *sub\n */\nstatic int\nlyp_check_includedup(struct lys_module *mod, const char *name, struct lys_include *inc, struct lys_submodule **sub)\n{\n    struct lys_module **parsed_sub = mod->ctx->models.parsed_submodules;\n    uint8_t i, parsed_sub_count = mod->ctx->models.parsed_submodules_count;\n\n    assert(sub);\n\n    for (i = 0; i < mod->inc_size; ++i) {\n        if (ly_strequal(mod->inc[i].submodule->name, name, 1)) {\n            /* the same module is already included in the same module - error */\n            LOGVAL(mod->ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, \"include\");\n            LOGVAL(mod->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Submodule \\\"%s\\\" included twice in the same module \\\"%s\\\".\",\n                   name, mod->name);\n            return -1;\n        }\n    }\n\n    if (parsed_sub_count) {\n        assert(!parsed_sub[0]->type);\n        for (i = parsed_sub_count - 1; parsed_sub[i]->type; --i) {\n            if (ly_strequal(parsed_sub[i]->name, name, 1)) {\n                /* check revisions, including multiple revisions of a single module is error */\n                if (inc->rev[0] && (!parsed_sub[i]->rev_size || strcmp(parsed_sub[i]->rev[0].date, inc->rev))) {\n                    /* the already included submodule has\n                     * - no revision, but here we require some\n                     * - different revision than the one required here */\n                    LOGVAL(mod->ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, \"include\");\n                    LOGVAL(mod->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Including multiple revisions of submodule \\\"%s\\\".\", name);\n                    return -1;\n                }\n\n                /* the same module is already included in some other submodule, return it */\n                (*sub) = (struct lys_submodule *)parsed_sub[i];\n                return 1;\n            }\n        }\n    }\n\n    /* no duplicity found */\n    return 0;\n}\n\n/* returns:\n *  0 - inc successfully filled\n * -1 - error\n */\nint\nlyp_check_include(struct lys_module *module, const char *value, struct lys_include *inc, struct unres_schema *unres)\n{\n    int i;\n\n    /* check that the submodule was not included yet */\n    i = lyp_check_includedup(module, value, inc, &inc->submodule);\n    if (i == -1) {\n        return -1;\n    } else if (i == 1) {\n        return 0;\n    }\n    /* submodule is not yet loaded */\n\n    /* circular include check */\n    if (lyp_check_circmod(module, value, 0)) {\n        return -1;\n    }\n\n    /* try to load the submodule */\n    inc->submodule = (struct lys_submodule *)ly_ctx_load_sub_module(module->ctx, module, value,\n                                                                    inc->rev[0] ? inc->rev : NULL, 1, unres);\n\n    /* check the result */\n    if (!inc->submodule) {\n        if (ly_errno != LY_EVALID) {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"include\");\n        }\n        LOGERR(module->ctx, LY_EVALID, \"Including \\\"%s\\\" module into \\\"%s\\\" failed.\", value, module->name);\n        return -1;\n    }\n\n    /* check the revision */\n    if (inc->rev[0] && inc->submodule->rev_size && strcmp(inc->rev, inc->submodule->rev[0].date)) {\n        LOGERR(module->ctx, LY_EVALID, \"\\\"%s\\\" include of submodule \\\"%s\\\" in revision \\\"%s\\\" not found.\",\n               module->name, value, inc->rev);\n        unres_schema_free((struct lys_module *)inc->submodule, &unres, 0);\n        lys_sub_module_remove_devs_augs((struct lys_module *)inc->submodule);\n        lys_submodule_module_data_free((struct lys_submodule *)inc->submodule);\n        lys_submodule_free(inc->submodule, NULL);\n        inc->submodule = NULL;\n        return -1;\n    }\n\n    /* store the submodule as successfully parsed */\n    lyp_add_includedup(module, inc->submodule);\n\n    return 0;\n}\n\nstatic int\nlyp_check_include_missing_recursive(struct lys_module *main_module, struct lys_submodule *sub)\n{\n    uint8_t i, j;\n    void *reallocated;\n    int ret = 0, tmp;\n    struct ly_ctx *ctx = main_module->ctx;\n\n    for (i = 0; i < sub->inc_size; i++) {\n        /* check that the include is also present in the main module */\n        for (j = 0; j < main_module->inc_size; j++) {\n            if (main_module->inc[j].submodule == sub->inc[i].submodule) {\n                break;\n            }\n        }\n\n        if (j == main_module->inc_size) {\n            /* match not found */\n            if (main_module->version >= LYS_VERSION_1_1) {\n                LOGVAL(ctx, LYE_MISSSTMT, LY_VLOG_NONE, NULL, \"include\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                       \"The main module \\\"%s\\\" misses include of the \\\"%s\\\" submodule used in another submodule \\\"%s\\\".\",\n                       main_module->name, sub->inc[i].submodule->name, sub->name);\n                /* now we should return error, but due to the issues with freeing the module, we actually have\n                 * to go through the all includes and, as in case of 1.0, add them into the main module and fail\n                 * at the end when all the includes are in the main module and we can free them */\n                ret = 1;\n            } else {\n                /* not strictly an error in YANG 1.0 */\n                LOGWRN(ctx, \"The main module \\\"%s\\\" misses include of the \\\"%s\\\" submodule used in another submodule \\\"%s\\\".\",\n                       main_module->name, sub->inc[i].submodule->name, sub->name);\n                LOGWRN(ctx, \"To avoid further issues, adding submodule \\\"%s\\\" into the main module \\\"%s\\\".\",\n                       sub->inc[i].submodule->name, main_module->name);\n                /* but since it is a good practise and because we expect all the includes in the main module\n                 * when searching it and also when freeing the module, put it into it */\n            }\n            main_module->inc_size++;\n            reallocated = realloc(main_module->inc, main_module->inc_size * sizeof *main_module->inc);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), 1);\n            main_module->inc = reallocated;\n            memset(&main_module->inc[main_module->inc_size - 1], 0, sizeof *main_module->inc);\n            /* to avoid unexpected consequences, copy just a link to the submodule and the revision,\n             * all other substatements of the include are ignored */\n            memcpy(&main_module->inc[main_module->inc_size - 1].rev, sub->inc[i].rev, LY_REV_SIZE - 1);\n            main_module->inc[main_module->inc_size - 1].submodule = sub->inc[i].submodule;\n        }\n\n        /* recursion */\n        tmp = lyp_check_include_missing_recursive(main_module, sub->inc[i].submodule);\n        if (!ret && tmp) {\n            ret = 1;\n        }\n    }\n\n    return ret;\n}\n\nint\nlyp_check_include_missing(struct lys_module *main_module)\n{\n    int ret = 0;\n    uint8_t i;\n\n    /* in YANG 1.1, all the submodules must be in the main module, check it even for\n     * 1.0 where it will be printed as warning and the include will be added into the main module */\n    for (i = 0; i < main_module->inc_size; i++) {\n        if (lyp_check_include_missing_recursive(main_module, main_module->inc[i].submodule)) {\n            ret = 1;\n        }\n    }\n\n    return ret;\n}\n\n/* returns:\n *  0 - imp successfully filled\n * -1 - error, imp not cleaned\n */\nint\nlyp_check_import(struct lys_module *module, const char *value, struct lys_import *imp)\n{\n    int i;\n    struct lys_module *dup = NULL;\n    struct ly_ctx *ctx = module->ctx;\n\n    /* check for importing a single module in multiple revisions */\n    for (i = 0; i < module->imp_size; i++) {\n        if (!module->imp[i].module) {\n            /* skip the not yet filled records */\n            continue;\n        }\n        if (ly_strequal(module->imp[i].module->name, value, 1)) {\n            /* check revisions, including multiple revisions of a single module is error */\n            if (imp->rev[0] && (!module->imp[i].module->rev_size || strcmp(module->imp[i].module->rev[0].date, imp->rev))) {\n                /* the already imported module has\n                 * - no revision, but here we require some\n                 * - different revision than the one required here */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"import\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Importing multiple revisions of module \\\"%s\\\".\", value);\n                return -1;\n            } else if (!imp->rev[0]) {\n                /* no revision, remember the duplication, but check revisions after loading the module\n                 * because the current revision can be the same (then it is ok) or it can differ (then it\n                 * is error */\n                dup = module->imp[i].module;\n                break;\n            }\n\n            /* there is duplication, but since prefixes differs (checked in caller of this function),\n             * it is ok */\n            imp->module = module->imp[i].module;\n            return 0;\n        }\n    }\n\n    /* circular import check */\n    if (lyp_check_circmod(module, value, 1)) {\n        return -1;\n    }\n\n    /* load module - in specific situations it tries to get the module from the context */\n    imp->module = (struct lys_module *)ly_ctx_load_sub_module(module->ctx, NULL, value, imp->rev[0] ? imp->rev : NULL,\n                                                              module->ctx->models.flags & LY_CTX_ALLIMPLEMENTED ? 1 : 0,\n                                                              NULL);\n\n    /* check the result */\n    if (!imp->module) {\n        LOGERR(ctx, LY_EVALID, \"Importing \\\"%s\\\" module into \\\"%s\\\" failed.\", value, module->name);\n        return -1;\n    }\n\n    if (imp->rev[0] && imp->module->rev_size && strcmp(imp->rev, imp->module->rev[0].date)) {\n        LOGERR(ctx, LY_EVALID, \"\\\"%s\\\" import of module \\\"%s\\\" in revision \\\"%s\\\" not found.\",\n               module->name, value, imp->rev);\n        return -1;\n    }\n\n    if (dup) {\n        /* check the revisions */\n        if ((dup != imp->module) ||\n                (dup->rev_size != imp->module->rev_size && (!dup->rev_size || imp->module->rev_size)) ||\n                (dup->rev_size && strcmp(dup->rev[0].date, imp->module->rev[0].date))) {\n            /* - modules are not the same\n             * - one of modules has no revision (except they both has no revision)\n             * - revisions of the modules are not the same */\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"import\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Importing multiple revisions of module \\\"%s\\\".\", value);\n            return -1;\n        } else {\n            LOGWRN(ctx, \"Module \\\"%s\\\" is imported by \\\"%s\\\" multiple times with different prefixes.\", dup->name, module->name);\n        }\n    }\n\n    return 0;\n}\n\n/*\n * put the newest revision to the first position\n */\nvoid\nlyp_sort_revisions(struct lys_module *module)\n{\n    uint8_t i, r;\n    struct lys_revision rev;\n\n    for (i = 1, r = 0; i < module->rev_size; i++) {\n        if (strcmp(module->rev[i].date, module->rev[r].date) > 0) {\n            r = i;\n        }\n    }\n\n    if (r) {\n        /* the newest revision is not on position 0, switch them */\n        memcpy(&rev, &module->rev[0], sizeof rev);\n        memcpy(&module->rev[0], &module->rev[r], sizeof rev);\n        memcpy(&module->rev[r], &rev, sizeof rev);\n    }\n}\n\nvoid\nlyp_ext_instance_rm(struct ly_ctx *ctx, struct lys_ext_instance ***ext, uint8_t *size, uint8_t index)\n{\n    uint8_t i;\n\n    lys_extension_instances_free(ctx, (*ext)[index]->ext, (*ext)[index]->ext_size, NULL);\n    lydict_remove(ctx, (*ext)[index]->arg_value);\n    free((*ext)[index]);\n\n    /* move the rest of the array */\n    for (i = index + 1; i < (*size); i++) {\n        (*ext)[i - 1] = (*ext)[i];\n    }\n    /* clean the last cell in the array structure */\n    (*ext)[(*size) - 1] = NULL;\n    /* the array is not reallocated here, just change its size */\n    (*size) = (*size) - 1;\n\n    if (!(*size)) {\n        /* ext array is empty */\n        free((*ext));\n        ext = NULL;\n    }\n}\n\nstatic int\nlyp_rfn_apply_ext_(struct lys_refine *rfn, struct lys_node *target, LYEXT_SUBSTMT substmt, struct lys_ext *extdef)\n{\n    struct ly_ctx *ctx;\n    int m, n;\n    struct lys_ext_instance *new;\n    void *reallocated;\n\n    ctx = target->module->ctx; /* shortcut */\n\n    m = n = -1;\n    while ((m = lys_ext_iter(rfn->ext, rfn->ext_size, m + 1, substmt)) != -1) {\n        /* refine's substatement includes extensions, copy them to the target, replacing the previous\n         * substatement's extensions if any. In case of refining the extension itself, we are going to\n         * replace only the same extension (pointing to the same definition) */\n        if (substmt == LYEXT_SUBSTMT_SELF && rfn->ext[m]->def != extdef) {\n            continue;\n        }\n\n        /* get the index of the extension to replace in the target node */\n        do {\n            n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt);\n        } while (n != -1 && substmt == LYEXT_SUBSTMT_SELF && target->ext[n]->def != extdef);\n\n        /* TODO cover complex extension instances */\n        if (n == -1) {\n            /* nothing to replace, we are going to add it - reallocate */\n            new = malloc(sizeof **target->ext);\n            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n            reallocated = realloc(target->ext, (target->ext_size + 1) * sizeof *target->ext);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx); free(new), EXIT_FAILURE);\n            target->ext = reallocated;\n            target->ext_size++;\n\n            /* init */\n            n = target->ext_size - 1;\n            target->ext[n] = new;\n            target->ext[n]->parent = target;\n            target->ext[n]->parent_type = LYEXT_PAR_NODE;\n            target->ext[n]->flags = 0;\n            target->ext[n]->insubstmt = substmt;\n            target->ext[n]->priv = NULL;\n            target->ext[n]->nodetype = LYS_EXT;\n            target->ext[n]->module = target->module;\n        } else {\n            /* replacing - first remove the allocated data from target */\n            lys_extension_instances_free(ctx, target->ext[n]->ext, target->ext[n]->ext_size, NULL);\n            lydict_remove(ctx, target->ext[n]->arg_value);\n        }\n        /* common part for adding and replacing */\n        target->ext[n]->def = rfn->ext[m]->def;\n        /* parent and parent_type do not change */\n        target->ext[n]->arg_value = lydict_insert(ctx, rfn->ext[m]->arg_value, 0);\n        /* flags do not change */\n        target->ext[n]->ext_size = rfn->ext[m]->ext_size;\n        lys_ext_dup(ctx, target->module, rfn->ext[m]->ext, rfn->ext[m]->ext_size, target, LYEXT_PAR_NODE,\n                    &target->ext[n]->ext, 0, NULL);\n        /* substmt does not change, but the index must be taken from the refine */\n        target->ext[n]->insubstmt_index = rfn->ext[m]->insubstmt_index;\n    }\n\n    /* remove the rest of extensions belonging to the original substatement in the target node */\n    while ((n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt)) != -1) {\n        if (substmt == LYEXT_SUBSTMT_SELF && target->ext[n]->def != extdef) {\n            /* keep this extension */\n            continue;\n        }\n\n        /* remove the item */\n        lyp_ext_instance_rm(ctx, &target->ext, &target->ext_size, n);\n        --n;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * apply extension instances defined under refine's substatements.\n * It cannot be done immediately when applying the refine because there can be\n * still unresolved data (e.g. type) and mainly the targeted extension instances.\n */\nint\nlyp_rfn_apply_ext(struct lys_module *module)\n{\n    int i, k, a = 0;\n    struct lys_node *root, *nextroot, *next, *node;\n    struct lys_node *target;\n    struct lys_node_uses *uses;\n    struct lys_refine *rfn;\n    struct ly_set *extset;\n\n    /* refines in uses */\n    LY_TREE_FOR_SAFE(module->data, nextroot, root) {\n        /* go through the data tree of the module and all the defined augments */\n\n        LY_TREE_DFS_BEGIN(root, next, node) {\n            if (node->nodetype == LYS_USES) {\n                uses = (struct lys_node_uses *)node;\n\n                for (i = 0; i < uses->refine_size; i++) {\n                    if (!uses->refine[i].ext_size) {\n                        /* no extensions in refine */\n                        continue;\n                    }\n                    rfn = &uses->refine[i]; /* shortcut */\n\n                    /* get the target node */\n                    target = NULL;\n                    resolve_descendant_schema_nodeid(rfn->target_name, uses->child,\n                                                     LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,\n                                                     0, (const struct lys_node **)&target);\n                    if (!target) {\n                        /* it should always succeed since the target_name was already resolved at least\n                         * once when the refine itself was being resolved */\n                        LOGINT(module->ctx);;\n                        return EXIT_FAILURE;\n                    }\n\n                    /* extensions */\n                    extset = ly_set_new();\n                    k = -1;\n                    while ((k = lys_ext_iter(rfn->ext, rfn->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {\n                        ly_set_add(extset, rfn->ext[k]->def, 0);\n                    }\n                    for (k = 0; (unsigned int)k < extset->number; k++) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_SELF, (struct lys_ext *)extset->set.g[k])) {\n                            ly_set_free(extset);\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    ly_set_free(extset);\n\n                    /* description */\n                    if (rfn->dsc && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_DESCRIPTION, NULL)) {\n                        return EXIT_FAILURE;\n                    }\n                    /* reference */\n                    if (rfn->ref && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_REFERENCE, NULL)) {\n                        return EXIT_FAILURE;\n                    }\n                    /* config, in case of notification or rpc/action{notif, the config is not applicable\n                     * (there is no config status) */\n                    if ((rfn->flags & LYS_CONFIG_MASK) && (target->flags & LYS_CONFIG_MASK)) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_CONFIG, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* default value */\n                    if (rfn->dflt_size && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_DEFAULT, NULL)) {\n                        return EXIT_FAILURE;\n                    }\n                    /* mandatory */\n                    if (rfn->flags & LYS_MAND_MASK) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MANDATORY, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* presence */\n                    if ((target->nodetype & LYS_CONTAINER) && rfn->mod.presence) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_PRESENCE, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* min/max */\n                    if (rfn->flags & LYS_RFN_MINSET) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MIN, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    if (rfn->flags & LYS_RFN_MAXSET) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MAX, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* must and if-feature contain extensions on their own, not needed to be solved here */\n\n                    if (target->ext_size) {\n                        /* the allocated target's extension array can be now longer than needed in case\n                         * there is less refine substatement's extensions than in original. Since we are\n                         * going to reduce or keep the same memory, it is not necessary to test realloc's result */\n                        target->ext = realloc(target->ext, target->ext_size * sizeof *target->ext);\n                    }\n                }\n            }\n            LY_TREE_DFS_END(root, next, node)\n        }\n\n        if (!nextroot && a < module->augment_size) {\n            nextroot = module->augment[a].child;\n            a++;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * check mandatory substatements defined under extension instances.\n */\nint\nlyp_mand_check_ext(struct lys_ext_instance_complex *ext, const char *ext_name)\n{\n    void *p;\n    int i;\n    struct ly_ctx *ctx = ext->module->ctx;\n\n    /* check for mandatory substatements */\n    for (i = 0; ext->substmt[i].stmt; i++) {\n        if (ext->substmt[i].cardinality == LY_STMT_CARD_OPT || ext->substmt[i].cardinality == LY_STMT_CARD_ANY) {\n            /* not a mandatory */\n            continue;\n        } else if (ext->substmt[i].cardinality == LY_STMT_CARD_SOME) {\n            goto array;\n        }\n\n        /*\n         * LY_STMT_ORDEREDBY - not checked, has a default value which is the same as explicit system order\n         * LY_STMT_MODIFIER, LY_STMT_STATUS, LY_STMT_MANDATORY, LY_STMT_CONFIG - checked, but mandatory requirement\n         * does not make sense since there is also a default value specified\n         */\n        switch(ext->substmt[i].stmt) {\n        case LY_STMT_ORDEREDBY:\n            /* always ok */\n            break;\n        case LY_STMT_REQINSTANCE:\n        case LY_STMT_DIGITS:\n        case LY_STMT_MODIFIER:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!*(uint8_t*)p) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        case LY_STMT_STATUS:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(uint16_t*)p & LYS_STATUS_MASK)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        case LY_STMT_MANDATORY:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(uint16_t*)p & LYS_MAND_MASK)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        case LY_STMT_CONFIG:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(uint16_t*)p & LYS_CONFIG_MASK)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        default:\narray:\n            /* stored as a pointer */\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(void**)p)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nlyp_deviate_del_ext(struct lys_node *target, struct lys_ext_instance *ext)\n{\n    int n = -1, found = 0;\n    char *path;\n\n    while ((n = lys_ext_iter(target->ext, target->ext_size, n + 1, ext->insubstmt)) != -1) {\n        if (target->ext[n]->def != ext->def) {\n            continue;\n        }\n\n        if (ext->def->argument) {\n            /* check matching arguments */\n            if (!ly_strequal(target->ext[n]->arg_value, ext->arg_value, 1)) {\n                continue;\n            }\n        }\n\n        /* we have the matching extension - remove it */\n        ++found;\n        lyp_ext_instance_rm(target->module->ctx, &target->ext, &target->ext_size, n);\n        --n;\n    }\n\n    if (!found) {\n        path = lys_path(target, LYS_PATH_FIRST_PREFIX);\n        LOGERR(target->module->ctx, LY_EVALID, \"Extension deviation: extension \\\"%s\\\" to delete not found in \\\"%s\\\".\",\n               ext->def->name, path)\n        free(path);\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\nlyp_deviate_apply_ext(struct lys_deviate *dev, struct lys_node *target, LYEXT_SUBSTMT substmt, struct lys_ext *extdef)\n{\n    struct ly_ctx *ctx;\n    int m, n;\n    struct lys_ext_instance *new;\n    void *reallocated;\n\n    /* LY_DEVIATE_ADD and LY_DEVIATE_RPL are very similar so they are implement the same way - in replacing,\n     * there can be some extension instances in the target, in case of adding, there should not be any so we\n     * will be just adding. */\n\n    ctx = target->module->ctx; /* shortcut */\n    m = n = -1;\n\n    while ((m = lys_ext_iter(dev->ext, dev->ext_size, m + 1, substmt)) != -1) {\n        /* deviate and its substatements include extensions, copy them to the target, replacing the previous\n         * extensions if any. In case of deviating extension itself, we have to deviate only the same type\n         * of the extension as specified in the deviation */\n        if (substmt == LYEXT_SUBSTMT_SELF && dev->ext[m]->def != extdef) {\n            continue;\n        }\n\n        if (substmt == LYEXT_SUBSTMT_SELF && dev->mod == LY_DEVIATE_ADD) {\n            /* in case of adding extension, we will be replacing only the inherited extensions */\n            do {\n                n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt);\n            } while (n != -1 && (target->ext[n]->def != extdef || !(target->ext[n]->flags & LYEXT_OPT_INHERIT)));\n        } else {\n            /* get the index of the extension to replace in the target node */\n            do {\n                n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt);\n                /* if we are applying extension deviation, we have to deviate only the same type of the extension */\n            } while (n != -1 && substmt == LYEXT_SUBSTMT_SELF && target->ext[n]->def != extdef);\n        }\n\n        if (n == -1) {\n            /* nothing to replace, we are going to add it - reallocate */\n            new = malloc(sizeof **target->ext);\n            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n            reallocated = realloc(target->ext, (target->ext_size + 1) * sizeof *target->ext);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx); free(new), EXIT_FAILURE);\n            target->ext = reallocated;\n            target->ext_size++;\n\n            n = target->ext_size - 1;\n        } else {\n            /* replacing - the original set of extensions is actually backuped together with the\n             * node itself, so we are supposed only to free the allocated data here ... */\n            lys_extension_instances_free(ctx, target->ext[n]->ext, target->ext[n]->ext_size, NULL);\n            lydict_remove(ctx, target->ext[n]->arg_value);\n            free(target->ext[n]);\n\n            /* and prepare the new structure */\n            new = malloc(sizeof **target->ext);\n            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        }\n        /* common part for adding and replacing - fill the newly created / replaced cell */\n        target->ext[n] = new;\n        target->ext[n]->def = dev->ext[m]->def;\n        target->ext[n]->arg_value = lydict_insert(ctx, dev->ext[m]->arg_value, 0);\n        target->ext[n]->flags = 0;\n        target->ext[n]->parent = target;\n        target->ext[n]->parent_type = LYEXT_PAR_NODE;\n        target->ext[n]->insubstmt = substmt;\n        target->ext[n]->insubstmt_index = dev->ext[m]->insubstmt_index;\n        target->ext[n]->ext_size = dev->ext[m]->ext_size;\n        lys_ext_dup(ctx, target->module, dev->ext[m]->ext, dev->ext[m]->ext_size, target, LYEXT_PAR_NODE,\n                    &target->ext[n]->ext, 1, NULL);\n        target->ext[n]->nodetype = LYS_EXT;\n        target->ext[n]->module = target->module;\n        target->ext[n]->priv = NULL;\n\n        /* TODO cover complex extension instances */\n    }\n\n    /* remove the rest of extensions belonging to the original substatement in the target node,\n     * due to possible reverting of the deviation effect, they are actually not removed, just moved\n     * to the backup of the original node when the original node is backuped, here we just have to\n     * free the replaced / deleted originals */\n    while ((n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt)) != -1) {\n        if (substmt == LYEXT_SUBSTMT_SELF) {\n            /* if we are applying extension deviation, we are going to remove only\n             * - the same type of the extension in case of replacing\n             * - the same type of the extension which was inherited in case of adding\n             * note - delete deviation is covered in lyp_deviate_del_ext */\n            if (target->ext[n]->def != extdef ||\n                    (dev->mod == LY_DEVIATE_ADD && !(target->ext[n]->flags & LYEXT_OPT_INHERIT))) {\n                /* keep this extension */\n                continue;\n            }\n\n        }\n\n        /* remove the item */\n        lyp_ext_instance_rm(ctx, &target->ext, &target->ext_size, n);\n        --n;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * not-supported deviations are not processed since they affect the complete node, not just their substatements\n */\nint\nlyp_deviation_apply_ext(struct lys_module *module)\n{\n    int i, j, k;\n    struct lys_deviate *dev;\n    struct lys_node *target;\n    struct ly_set *extset;\n\n    for (i = 0; i < module->deviation_size; i++) {\n        target = NULL;\n        extset = NULL;\n        j = resolve_schema_nodeid(module->deviation[i].target_name, NULL, module, &extset, 0, 0);\n        if (j == -1) {\n            return EXIT_FAILURE;\n        } else if (!extset) {\n            /* LY_DEVIATE_NO */\n            ly_set_free(extset);\n            continue;\n        }\n        target = extset->set.s[0];\n        ly_set_free(extset);\n\n        for (j = 0; j < module->deviation[i].deviate_size; j++) {\n            dev = &module->deviation[i].deviate[j];\n            if (!dev->ext_size) {\n                /* no extensions in deviate and its substatement, nothing to do here */\n                continue;\n            }\n\n            /* extensions */\n            if (dev->mod == LY_DEVIATE_DEL) {\n                k = -1;\n                while ((k = lys_ext_iter(dev->ext, dev->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {\n                    if (lyp_deviate_del_ext(target, dev->ext[k])) {\n                        return EXIT_FAILURE;\n                    }\n                }\n\n                /* In case of LY_DEVIATE_DEL, we are applying only extension deviation, removing\n                 * of the substatement's extensions was already done when the substatement was applied.\n                 * Extension deviation could not be applied by the parser since the extension could be unresolved,\n                 * which is not the issue of the other substatements. */\n                continue;\n            } else {\n                extset = ly_set_new();\n                k = -1;\n                while ((k = lys_ext_iter(dev->ext, dev->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {\n                    ly_set_add(extset, dev->ext[k]->def, 0);\n                }\n                for (k = 0; (unsigned int)k < extset->number; k++) {\n                    if (lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_SELF, (struct lys_ext *)extset->set.g[k])) {\n                        ly_set_free(extset);\n                        return EXIT_FAILURE;\n                    }\n                }\n                ly_set_free(extset);\n            }\n\n            /* unique */\n            if (dev->unique_size && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_UNIQUE, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* units */\n            if (dev->units && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_UNITS, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* default */\n            if (dev->dflt_size && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_DEFAULT, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* config */\n            if ((dev->flags & LYS_CONFIG_MASK) && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_CONFIG, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* mandatory */\n            if ((dev->flags & LYS_MAND_MASK) && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MANDATORY, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* min/max */\n            if (dev->min_set && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MIN, NULL)) {\n                return EXIT_FAILURE;\n            }\n            if (dev->min_set && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MAX, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* type and must contain extension instances in their structures */\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nlyp_ctx_check_module(struct lys_module *module)\n{\n    struct ly_ctx *ctx;\n    int i, match_i = -1, to_implement;\n    const char *last_rev = NULL;\n\n    assert(module);\n    to_implement = 0;\n    ctx = module->ctx;\n\n    /* find latest revision */\n    for (i = 0; i < module->rev_size; ++i) {\n        if (!last_rev || (strcmp(last_rev, module->rev[i].date) < 0)) {\n            last_rev = module->rev[i].date;\n        }\n    }\n\n    for (i = 0; i < ctx->models.used; i++) {\n        /* check name (name/revision) and namespace uniqueness */\n        if (!strcmp(ctx->models.list[i]->name, module->name)) {\n            if (to_implement) {\n                if (i == match_i) {\n                    continue;\n                }\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s@%s\\\" in another revision \\\"%s\\\" already implemented.\",\n                       module->name, last_rev ? last_rev : \"<latest>\", ctx->models.list[i]->rev[0].date);\n                return -1;\n            } else if (!ctx->models.list[i]->rev_size && module->rev_size) {\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" without revision already in context.\", module->name);\n                return -1;\n            } else if (ctx->models.list[i]->rev_size && !module->rev_size) {\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" with revision \\\"%s\\\" already in context.\",\n                       module->name, ctx->models.list[i]->rev[0].date);\n                return -1;\n            } else if ((!module->rev_size && !ctx->models.list[i]->rev_size)\n                    || !strcmp(ctx->models.list[i]->rev[0].date, last_rev)) {\n\n                LOGVRB(\"Module \\\"%s@%s\\\" already in context.\", module->name, last_rev ? last_rev : \"<latest>\");\n\n                /* if disabled, enable first */\n                if (ctx->models.list[i]->disabled) {\n                    lys_set_enabled(ctx->models.list[i]);\n                }\n\n                to_implement = module->implemented;\n                match_i = i;\n                if (to_implement && !ctx->models.list[i]->implemented) {\n                    /* check first that it is okay to change it to implemented */\n                    i = -1;\n                    continue;\n                }\n                return 1;\n\n            } else if (module->implemented && ctx->models.list[i]->implemented) {\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s@%s\\\" in another revision \\\"%s\\\" already implemented.\",\n                       module->name, last_rev ? last_rev : \"<latest>\", ctx->models.list[i]->rev[0].date);\n                return -1;\n            }\n            /* else keep searching, for now the caller is just adding\n             * another revision of an already present schema\n             */\n        } else if (!strcmp(ctx->models.list[i]->ns, module->ns)) {\n            LOGERR(ctx, LY_EINVAL, \"Two different modules (\\\"%s\\\" and \\\"%s\\\") have the same namespace \\\"%s\\\".\",\n                   ctx->models.list[i]->name, module->name, module->ns);\n            return -1;\n        }\n    }\n\n    if (to_implement) {\n        if (lys_set_implemented(ctx->models.list[match_i])) {\n            return -1;\n        }\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nlyp_ctx_add_module(struct lys_module *module)\n{\n    struct lys_module **newlist = NULL;\n    int i;\n\n    assert(!lyp_ctx_check_module(module));\n\n#ifndef NDEBUG\n    int j;\n    /* check that all augments are resolved */\n    for (i = 0; i < module->augment_size; ++i) {\n        assert(module->augment[i].target);\n    }\n    for (i = 0; i < module->inc_size; ++i) {\n        for (j = 0; j < module->inc[i].submodule->augment_size; ++j) {\n            assert(module->inc[i].submodule->augment[j].target);\n        }\n    }\n#endif\n\n    /* add to the context's list of modules */\n    if (module->ctx->models.used == module->ctx->models.size) {\n        newlist = realloc(module->ctx->models.list, (2 * module->ctx->models.size) * sizeof *newlist);\n        LY_CHECK_ERR_RETURN(!newlist, LOGMEM(module->ctx), -1);\n        for (i = module->ctx->models.size; i < module->ctx->models.size * 2; i++) {\n            newlist[i] = NULL;\n        }\n        module->ctx->models.size *= 2;\n        module->ctx->models.list = newlist;\n    }\n    module->ctx->models.list[module->ctx->models.used++] = module;\n    module->ctx->models.module_set_id++;\n\n    return 0;\n}\n\n/**\n * Store UTF-8 character specified as 4byte integer into the dst buffer.\n * Returns number of written bytes (4 max), expects that dst has enough space.\n *\n * UTF-8 mapping:\n * 00000000 -- 0000007F:    0xxxxxxx\n * 00000080 -- 000007FF:    110xxxxx 10xxxxxx\n * 00000800 -- 0000FFFF:    1110xxxx 10xxxxxx 10xxxxxx\n * 00010000 -- 001FFFFF:    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n *\n * Includes checking for valid characters (following RFC 7950, sec 9.4)\n */\nunsigned int\npututf8(struct ly_ctx *ctx, char *dst, int32_t value)\n{\n    if (value < 0x80) {\n        /* one byte character */\n        if (value < 0x20 &&\n                value != 0x09 &&\n                value != 0x0a &&\n                value != 0x0d) {\n            goto error;\n        }\n\n        dst[0] = value;\n        return 1;\n    } else if (value < 0x800) {\n        /* two bytes character */\n        dst[0] = 0xc0 | (value >> 6);\n        dst[1] = 0x80 | (value & 0x3f);\n        return 2;\n    } else if (value < 0xfffe) {\n        /* three bytes character */\n        if (((value & 0xf800) == 0xd800) ||\n                (value >= 0xfdd0 && value <= 0xfdef)) {\n            /* exclude surrogate blocks %xD800-DFFF */\n            /* exclude noncharacters %xFDD0-FDEF */\n            goto error;\n        }\n\n        dst[0] = 0xe0 | (value >> 12);\n        dst[1] = 0x80 | ((value >> 6) & 0x3f);\n        dst[2] = 0x80 | (value & 0x3f);\n\n        return 3;\n    } else if (value < 0x10fffe) {\n        if ((value & 0xffe) == 0xffe) {\n            /* exclude noncharacters %xFFFE-FFFF, %x1FFFE-1FFFF, %x2FFFE-2FFFF, %x3FFFE-3FFFF, %x4FFFE-4FFFF,\n             * %x5FFFE-5FFFF, %x6FFFE-6FFFF, %x7FFFE-7FFFF, %x8FFFE-8FFFF, %x9FFFE-9FFFF, %xAFFFE-AFFFF,\n             * %xBFFFE-BFFFF, %xCFFFE-CFFFF, %xDFFFE-DFFFF, %xEFFFE-EFFFF, %xFFFFE-FFFFF, %x10FFFE-10FFFF */\n            goto error;\n        }\n        /* four bytes character */\n        dst[0] = 0xf0 | (value >> 18);\n        dst[1] = 0x80 | ((value >> 12) & 0x3f);\n        dst[2] = 0x80 | ((value >> 6) & 0x3f);\n        dst[3] = 0x80 | (value & 0x3f);\n\n        return 4;\n    }\n\nerror:\n    /* out of range */\n    LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, NULL);\n    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%08x\", value);\n    return 0;\n}\n\nunsigned int\ncopyutf8(struct ly_ctx *ctx, char *dst, const char *src)\n{\n    uint32_t value;\n\n    /* unicode characters */\n    if (!(src[0] & 0x80)) {\n        /* one byte character */\n        if (src[0] < 0x20 &&\n                src[0] != 0x09 &&\n                src[0] != 0x0a &&\n                src[0] != 0x0d) {\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%02x\", src[0]);\n            return 0;\n        }\n\n        dst[0] = src[0];\n        return 1;\n    } else if (!(src[0] & 0x20)) {\n        /* two bytes character */\n        dst[0] = src[0];\n        dst[1] = src[1];\n        return 2;\n    } else if (!(src[0] & 0x10)) {\n        /* three bytes character */\n        value = ((uint32_t)(src[0] & 0xf) << 12) | ((uint32_t)(src[1] & 0x3f) << 6) | (src[2] & 0x3f);\n        if (((value & 0xf800) == 0xd800) ||\n                (value >= 0xfdd0 && value <= 0xfdef) ||\n                (value & 0xffe) == 0xffe) {\n            /* exclude surrogate blocks %xD800-DFFF */\n            /* exclude noncharacters %xFDD0-FDEF */\n            /* exclude noncharacters %xFFFE-FFFF */\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%08x\", value);\n            return 0;\n        }\n\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        return 3;\n    } else if (!(src[0] & 0x08)) {\n        /* four bytes character */\n        value = ((uint32_t)(src[0] & 0x7) << 18) | ((uint32_t)(src[1] & 0x3f) << 12) | ((uint32_t)(src[2] & 0x3f) << 6) | (src[3] & 0x3f);\n        if ((value & 0xffe) == 0xffe) {\n            /* exclude noncharacters %x1FFFE-1FFFF, %x2FFFE-2FFFF, %x3FFFE-3FFFF, %x4FFFE-4FFFF,\n             * %x5FFFE-5FFFF, %x6FFFE-6FFFF, %x7FFFE-7FFFF, %x8FFFE-8FFFF, %x9FFFE-9FFFF, %xAFFFE-AFFFF,\n             * %xBFFFE-BFFFF, %xCFFFE-CFFFF, %xDFFFE-DFFFF, %xEFFFE-EFFFF, %xFFFFE-FFFFF, %x10FFFE-10FFFF */\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%08x\", value);\n            return 0;\n        }\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[3];\n        return 4;\n    } else {\n        LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 leading byte 0x%02x\", src[0]);\n        return 0;\n    }\n}\n\nconst struct lys_module *\nlyp_get_module(const struct lys_module *module, const char *prefix, int pref_len, const char *name, int name_len, int in_data)\n{\n    const struct lys_module *main_module;\n    char *str;\n    int i;\n\n    assert(!prefix || !name);\n\n    if (prefix && !pref_len) {\n        pref_len = strlen(prefix);\n    }\n    if (name && !name_len) {\n        name_len = strlen(name);\n    }\n\n    main_module = lys_main_module(module);\n\n    /* module own prefix, submodule own prefix, (sub)module own name */\n    if ((!prefix || (!module->type && !strncmp(main_module->prefix, prefix, pref_len) && !main_module->prefix[pref_len])\n                 || (module->type && !strncmp(module->prefix, prefix, pref_len) && !module->prefix[pref_len]))\n            && (!name || (!strncmp(main_module->name, name, name_len) && !main_module->name[name_len]))) {\n        return main_module;\n    }\n\n    /* standard import */\n    for (i = 0; i < module->imp_size; ++i) {\n        if ((!prefix || (!strncmp(module->imp[i].prefix, prefix, pref_len) && !module->imp[i].prefix[pref_len]))\n                && (!name || (!strncmp(module->imp[i].module->name, name, name_len) && !module->imp[i].module->name[name_len]))) {\n            return module->imp[i].module;\n        }\n    }\n\n    /* module required by a foreign grouping, deviation, or submodule */\n    if (name) {\n        str = strndup(name, name_len);\n        if (!str) {\n            LOGMEM(module->ctx);\n            return NULL;\n        }\n        main_module = ly_ctx_get_module(module->ctx, str, NULL, 0);\n\n        /* try data callback */\n        if (!main_module && in_data && module->ctx->data_clb) {\n            main_module = module->ctx->data_clb(module->ctx, str, NULL, 0, module->ctx->data_clb_data);\n        }\n\n        free(str);\n        return main_module;\n    }\n\n    return NULL;\n}\n\nconst struct lys_module *\nlyp_get_import_module_ns(const struct lys_module *module, const char *ns)\n{\n    int i;\n    const struct lys_module *mod = NULL;\n\n    assert(module && ns);\n\n    if (module->type) {\n        /* the module is actually submodule and to get the namespace, we need the main module */\n        if (ly_strequal(((struct lys_submodule *)module)->belongsto->ns, ns, 0)) {\n            return ((struct lys_submodule *)module)->belongsto;\n        }\n    } else {\n        /* module's own namespace */\n        if (ly_strequal(module->ns, ns, 0)) {\n            return module;\n        }\n    }\n\n    /* imported modules */\n    for (i = 0; i < module->imp_size; ++i) {\n        if (ly_strequal(module->imp[i].module->ns, ns, 0)) {\n            return module->imp[i].module;\n        }\n    }\n\n    return mod;\n}\n\nconst char *\nlyp_get_yang_data_template_name(const struct lyd_node *node)\n{\n    struct lys_node *snode;\n\n    snode = lys_parent(node->schema);\n    while (snode && snode->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE)) {\n        snode = lys_parent(snode);\n    }\n\n    if (snode && snode->nodetype == LYS_EXT && strcmp(((struct lys_ext_instance_complex *)snode)->def->name, \"yang-data\") == 0) {\n        return ((struct lys_ext_instance_complex *)snode)->arg_value;\n    } else {\n        return NULL;\n    }\n}\n\nconst struct lys_node *\nlyp_get_yang_data_template(const struct lys_module *module, const char *yang_data_name, int yang_data_name_len)\n{\n    int i, j;\n    const struct lys_node *ret = NULL;\n    const struct lys_submodule *submodule;\n\n    for(i = 0; i < module->ext_size; ++i) {\n        if (!strcmp(module->ext[i]->def->name, \"yang-data\") && !strncmp(module->ext[i]->arg_value, yang_data_name, yang_data_name_len)\n            && !module->ext[i]->arg_value[yang_data_name_len]) {\n            ret = (struct lys_node *)module->ext[i];\n            break;\n        }\n    }\n\n    for(j = 0; !ret && j < module->inc_size; ++j) {\n        submodule = module->inc[j].submodule;\n        for(i = 0; i < submodule->ext_size; ++i) {\n            if (!strcmp(submodule->ext[i]->def->name, \"yang-data\") && !strncmp(submodule->ext[i]->arg_value, yang_data_name, yang_data_name_len)\n                && !submodule->ext[i]->arg_value[yang_data_name_len]) {\n                ret = (struct lys_node *)submodule->ext[i];\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\n"], "fixing_code": ["/**\n * @file parser.c\n * @author Radek Krejci <rkrejci@cesnet.cz>\n * @brief common libyang parsers routines implementations\n *\n * Copyright (c) 2015-2017 CESNET, z.s.p.o.\n *\n * This source code is licensed under BSD 3-Clause License (the \"License\").\n * You may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://opensource.org/licenses/BSD-3-Clause\n */\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <inttypes.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pcre.h>\n#include <time.h>\n\n#include \"common.h\"\n#include \"context.h\"\n#include \"libyang.h\"\n#include \"parser.h\"\n#include \"resolve.h\"\n#include \"tree_internal.h\"\n#include \"parser_yang.h\"\n#include \"xpath.h\"\n\n#define LYP_URANGE_LEN 19\n\nstatic char *lyp_ublock2urange[][2] = {\n    {\"BasicLatin\", \"[\\\\x{0000}-\\\\x{007F}]\"},\n    {\"Latin-1Supplement\", \"[\\\\x{0080}-\\\\x{00FF}]\"},\n    {\"LatinExtended-A\", \"[\\\\x{0100}-\\\\x{017F}]\"},\n    {\"LatinExtended-B\", \"[\\\\x{0180}-\\\\x{024F}]\"},\n    {\"IPAExtensions\", \"[\\\\x{0250}-\\\\x{02AF}]\"},\n    {\"SpacingModifierLetters\", \"[\\\\x{02B0}-\\\\x{02FF}]\"},\n    {\"CombiningDiacriticalMarks\", \"[\\\\x{0300}-\\\\x{036F}]\"},\n    {\"Greek\", \"[\\\\x{0370}-\\\\x{03FF}]\"},\n    {\"Cyrillic\", \"[\\\\x{0400}-\\\\x{04FF}]\"},\n    {\"Armenian\", \"[\\\\x{0530}-\\\\x{058F}]\"},\n    {\"Hebrew\", \"[\\\\x{0590}-\\\\x{05FF}]\"},\n    {\"Arabic\", \"[\\\\x{0600}-\\\\x{06FF}]\"},\n    {\"Syriac\", \"[\\\\x{0700}-\\\\x{074F}]\"},\n    {\"Thaana\", \"[\\\\x{0780}-\\\\x{07BF}]\"},\n    {\"Devanagari\", \"[\\\\x{0900}-\\\\x{097F}]\"},\n    {\"Bengali\", \"[\\\\x{0980}-\\\\x{09FF}]\"},\n    {\"Gurmukhi\", \"[\\\\x{0A00}-\\\\x{0A7F}]\"},\n    {\"Gujarati\", \"[\\\\x{0A80}-\\\\x{0AFF}]\"},\n    {\"Oriya\", \"[\\\\x{0B00}-\\\\x{0B7F}]\"},\n    {\"Tamil\", \"[\\\\x{0B80}-\\\\x{0BFF}]\"},\n    {\"Telugu\", \"[\\\\x{0C00}-\\\\x{0C7F}]\"},\n    {\"Kannada\", \"[\\\\x{0C80}-\\\\x{0CFF}]\"},\n    {\"Malayalam\", \"[\\\\x{0D00}-\\\\x{0D7F}]\"},\n    {\"Sinhala\", \"[\\\\x{0D80}-\\\\x{0DFF}]\"},\n    {\"Thai\", \"[\\\\x{0E00}-\\\\x{0E7F}]\"},\n    {\"Lao\", \"[\\\\x{0E80}-\\\\x{0EFF}]\"},\n    {\"Tibetan\", \"[\\\\x{0F00}-\\\\x{0FFF}]\"},\n    {\"Myanmar\", \"[\\\\x{1000}-\\\\x{109F}]\"},\n    {\"Georgian\", \"[\\\\x{10A0}-\\\\x{10FF}]\"},\n    {\"HangulJamo\", \"[\\\\x{1100}-\\\\x{11FF}]\"},\n    {\"Ethiopic\", \"[\\\\x{1200}-\\\\x{137F}]\"},\n    {\"Cherokee\", \"[\\\\x{13A0}-\\\\x{13FF}]\"},\n    {\"UnifiedCanadianAboriginalSyllabics\", \"[\\\\x{1400}-\\\\x{167F}]\"},\n    {\"Ogham\", \"[\\\\x{1680}-\\\\x{169F}]\"},\n    {\"Runic\", \"[\\\\x{16A0}-\\\\x{16FF}]\"},\n    {\"Khmer\", \"[\\\\x{1780}-\\\\x{17FF}]\"},\n    {\"Mongolian\", \"[\\\\x{1800}-\\\\x{18AF}]\"},\n    {\"LatinExtendedAdditional\", \"[\\\\x{1E00}-\\\\x{1EFF}]\"},\n    {\"GreekExtended\", \"[\\\\x{1F00}-\\\\x{1FFF}]\"},\n    {\"GeneralPunctuation\", \"[\\\\x{2000}-\\\\x{206F}]\"},\n    {\"SuperscriptsandSubscripts\", \"[\\\\x{2070}-\\\\x{209F}]\"},\n    {\"CurrencySymbols\", \"[\\\\x{20A0}-\\\\x{20CF}]\"},\n    {\"CombiningMarksforSymbols\", \"[\\\\x{20D0}-\\\\x{20FF}]\"},\n    {\"LetterlikeSymbols\", \"[\\\\x{2100}-\\\\x{214F}]\"},\n    {\"NumberForms\", \"[\\\\x{2150}-\\\\x{218F}]\"},\n    {\"Arrows\", \"[\\\\x{2190}-\\\\x{21FF}]\"},\n    {\"MathematicalOperators\", \"[\\\\x{2200}-\\\\x{22FF}]\"},\n    {\"MiscellaneousTechnical\", \"[\\\\x{2300}-\\\\x{23FF}]\"},\n    {\"ControlPictures\", \"[\\\\x{2400}-\\\\x{243F}]\"},\n    {\"OpticalCharacterRecognition\", \"[\\\\x{2440}-\\\\x{245F}]\"},\n    {\"EnclosedAlphanumerics\", \"[\\\\x{2460}-\\\\x{24FF}]\"},\n    {\"BoxDrawing\", \"[\\\\x{2500}-\\\\x{257F}]\"},\n    {\"BlockElements\", \"[\\\\x{2580}-\\\\x{259F}]\"},\n    {\"GeometricShapes\", \"[\\\\x{25A0}-\\\\x{25FF}]\"},\n    {\"MiscellaneousSymbols\", \"[\\\\x{2600}-\\\\x{26FF}]\"},\n    {\"Dingbats\", \"[\\\\x{2700}-\\\\x{27BF}]\"},\n    {\"BraillePatterns\", \"[\\\\x{2800}-\\\\x{28FF}]\"},\n    {\"CJKRadicalsSupplement\", \"[\\\\x{2E80}-\\\\x{2EFF}]\"},\n    {\"KangxiRadicals\", \"[\\\\x{2F00}-\\\\x{2FDF}]\"},\n    {\"IdeographicDescriptionCharacters\", \"[\\\\x{2FF0}-\\\\x{2FFF}]\"},\n    {\"CJKSymbolsandPunctuation\", \"[\\\\x{3000}-\\\\x{303F}]\"},\n    {\"Hiragana\", \"[\\\\x{3040}-\\\\x{309F}]\"},\n    {\"Katakana\", \"[\\\\x{30A0}-\\\\x{30FF}]\"},\n    {\"Bopomofo\", \"[\\\\x{3100}-\\\\x{312F}]\"},\n    {\"HangulCompatibilityJamo\", \"[\\\\x{3130}-\\\\x{318F}]\"},\n    {\"Kanbun\", \"[\\\\x{3190}-\\\\x{319F}]\"},\n    {\"BopomofoExtended\", \"[\\\\x{31A0}-\\\\x{31BF}]\"},\n    {\"EnclosedCJKLettersandMonths\", \"[\\\\x{3200}-\\\\x{32FF}]\"},\n    {\"CJKCompatibility\", \"[\\\\x{3300}-\\\\x{33FF}]\"},\n    {\"CJKUnifiedIdeographsExtensionA\", \"[\\\\x{3400}-\\\\x{4DB5}]\"},\n    {\"CJKUnifiedIdeographs\", \"[\\\\x{4E00}-\\\\x{9FFF}]\"},\n    {\"YiSyllables\", \"[\\\\x{A000}-\\\\x{A48F}]\"},\n    {\"YiRadicals\", \"[\\\\x{A490}-\\\\x{A4CF}]\"},\n    {\"HangulSyllables\", \"[\\\\x{AC00}-\\\\x{D7A3}]\"},\n    {\"PrivateUse\", \"[\\\\x{E000}-\\\\x{F8FF}]\"},\n    {\"CJKCompatibilityIdeographs\", \"[\\\\x{F900}-\\\\x{FAFF}]\"},\n    {\"AlphabeticPresentationForms\", \"[\\\\x{FB00}-\\\\x{FB4F}]\"},\n    {\"ArabicPresentationForms-A\", \"[\\\\x{FB50}-\\\\x{FDFF}]\"},\n    {\"CombiningHalfMarks\", \"[\\\\x{FE20}-\\\\x{FE2F}]\"},\n    {\"CJKCompatibilityForms\", \"[\\\\x{FE30}-\\\\x{FE4F}]\"},\n    {\"SmallFormVariants\", \"[\\\\x{FE50}-\\\\x{FE6F}]\"},\n    {\"ArabicPresentationForms-B\", \"[\\\\x{FE70}-\\\\x{FEFE}]\"},\n    {\"HalfwidthandFullwidthForms\", \"[\\\\x{FF00}-\\\\x{FFEF}]\"},\n    {NULL, NULL}\n};\n\nconst char *ly_stmt_str[] = {\n    [LY_STMT_UNKNOWN] = \"\",\n    [LY_STMT_ARGUMENT] = \"argument\",\n    [LY_STMT_BASE] = \"base\",\n    [LY_STMT_BELONGSTO] = \"belongs-to\",\n    [LY_STMT_CONTACT] = \"contact\",\n    [LY_STMT_DEFAULT] = \"default\",\n    [LY_STMT_DESCRIPTION] = \"description\",\n    [LY_STMT_ERRTAG] = \"error-app-tag\",\n    [LY_STMT_ERRMSG] = \"error-message\",\n    [LY_STMT_KEY] = \"key\",\n    [LY_STMT_NAMESPACE] = \"namespace\",\n    [LY_STMT_ORGANIZATION] = \"organization\",\n    [LY_STMT_PATH] = \"path\",\n    [LY_STMT_PREFIX] = \"prefix\",\n    [LY_STMT_PRESENCE] = \"presence\",\n    [LY_STMT_REFERENCE] = \"reference\",\n    [LY_STMT_REVISIONDATE] = \"revision-date\",\n    [LY_STMT_UNITS] = \"units\",\n    [LY_STMT_VALUE] = \"value\",\n    [LY_STMT_VERSION] = \"yang-version\",\n    [LY_STMT_MODIFIER] = \"modifier\",\n    [LY_STMT_REQINSTANCE] = \"require-instance\",\n    [LY_STMT_YINELEM] = \"yin-element\",\n    [LY_STMT_CONFIG] = \"config\",\n    [LY_STMT_MANDATORY] = \"mandatory\",\n    [LY_STMT_ORDEREDBY] = \"ordered-by\",\n    [LY_STMT_STATUS] = \"status\",\n    [LY_STMT_DIGITS] = \"fraction-digits\",\n    [LY_STMT_MAX] = \"max-elements\",\n    [LY_STMT_MIN] = \"min-elements\",\n    [LY_STMT_POSITION] = \"position\",\n    [LY_STMT_UNIQUE] = \"unique\",\n    [LY_STMT_MODULE] = \"module\",\n    [LY_STMT_SUBMODULE] = \"submodule\",\n    [LY_STMT_ACTION] = \"action\",\n    [LY_STMT_ANYDATA] = \"anydata\",\n    [LY_STMT_ANYXML] = \"anyxml\",\n    [LY_STMT_CASE] = \"case\",\n    [LY_STMT_CHOICE] = \"choice\",\n    [LY_STMT_CONTAINER] = \"container\",\n    [LY_STMT_GROUPING] = \"grouping\",\n    [LY_STMT_INPUT] = \"input\",\n    [LY_STMT_LEAF] = \"leaf\",\n    [LY_STMT_LEAFLIST] = \"leaf-list\",\n    [LY_STMT_LIST] = \"list\",\n    [LY_STMT_NOTIFICATION] = \"notification\",\n    [LY_STMT_OUTPUT] = \"output\",\n    [LY_STMT_RPC] = \"rpc\",\n    [LY_STMT_USES] = \"uses\",\n    [LY_STMT_TYPEDEF] = \"typedef\",\n    [LY_STMT_TYPE] = \"type\",\n    [LY_STMT_BIT] = \"bit\",\n    [LY_STMT_ENUM] = \"enum\",\n    [LY_STMT_REFINE] = \"refine\",\n    [LY_STMT_AUGMENT] = \"augment\",\n    [LY_STMT_DEVIATE] = \"deviate\",\n    [LY_STMT_DEVIATION] = \"deviation\",\n    [LY_STMT_EXTENSION] = \"extension\",\n    [LY_STMT_FEATURE] = \"feature\",\n    [LY_STMT_IDENTITY] = \"identity\",\n    [LY_STMT_IFFEATURE] = \"if-feature\",\n    [LY_STMT_IMPORT] = \"import\",\n    [LY_STMT_INCLUDE] = \"include\",\n    [LY_STMT_LENGTH] = \"length\",\n    [LY_STMT_MUST] = \"must\",\n    [LY_STMT_PATTERN] = \"pattern\",\n    [LY_STMT_RANGE] = \"range\",\n    [LY_STMT_WHEN] = \"when\",\n    [LY_STMT_REVISION] = \"revision\"\n};\n\nint\nlyp_is_rpc_action(struct lys_node *node)\n{\n    assert(node);\n\n    while (lys_parent(node)) {\n        node = lys_parent(node);\n        if (node->nodetype == LYS_ACTION) {\n            break;\n        }\n    }\n\n    if (node->nodetype & (LYS_RPC | LYS_ACTION)) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nint\nlyp_data_check_options(struct ly_ctx *ctx, int options, const char *func)\n{\n    int x = options & LYD_OPT_TYPEMASK;\n\n    /* LYD_OPT_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG */\n    if (options & LYD_OPT_WHENAUTODEL) {\n        if ((x == LYD_OPT_EDIT) || (x == LYD_OPT_NOTIF_FILTER)) {\n            LOGERR(ctx, LY_EINVAL, \"%s: Invalid options 0x%x (LYD_OPT_DATA_WHENAUTODEL can be used only with LYD_OPT_DATA or LYD_OPT_CONFIG)\",\n                   func, options);\n            return 1;\n        }\n    }\n\n    if (options & (LYD_OPT_DATA_ADD_YANGLIB | LYD_OPT_DATA_NO_YANGLIB)) {\n        if (x != LYD_OPT_DATA) {\n            LOGERR(ctx, LY_EINVAL, \"%s: Invalid options 0x%x (LYD_OPT_DATA_*_YANGLIB can be used only with LYD_OPT_DATA)\",\n                   func, options);\n            return 1;\n        }\n    }\n\n    /* \"is power of 2\" algorithm, with 0 exception */\n    if (x && !(x && !(x & (x - 1)))) {\n        LOGERR(ctx, LY_EINVAL, \"%s: Invalid options 0x%x (multiple data type flags set).\", func, options);\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nlyp_mmap(struct ly_ctx *ctx, int fd, size_t addsize, size_t *length, void **addr)\n{\n    struct stat sb;\n    long pagesize;\n    size_t m;\n\n    assert(fd >= 0);\n    if (fstat(fd, &sb) == -1) {\n        LOGERR(ctx, LY_ESYS, \"Failed to stat the file descriptor (%s) for the mmap().\", strerror(errno));\n        return 1;\n    }\n    if (!S_ISREG(sb.st_mode)) {\n        LOGERR(ctx, LY_EINVAL, \"File to mmap() is not a regular file.\");\n        return 1;\n    }\n    if (!sb.st_size) {\n        *addr = NULL;\n        return 0;\n    }\n    pagesize = sysconf(_SC_PAGESIZE);\n    ++addsize;                       /* at least one additional byte for terminating NULL byte */\n\n    m = sb.st_size % pagesize;\n    if (m && pagesize - m >= addsize) {\n        /* there will be enough space after the file content mapping to provide zeroed additional bytes */\n        *length = sb.st_size + addsize;\n        *addr = mmap(NULL, *length, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n    } else {\n        /* there will not be enough bytes after the file content mapping for the additional bytes and some of them\n         * would overflow into another page that would not be zeroed and any access into it would generate SIGBUS.\n         * Therefore we have to do the following hack with double mapping. First, the required number of bytes\n         * (including the additional bytes) is required as anonymous and thus they will be really provided (actually more\n         * because of using whole pages) and also initialized by zeros. Then, the file is mapped to the same address\n         * where the anonymous mapping starts. */\n        *length = sb.st_size + pagesize;\n        *addr = mmap(NULL, *length, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n        *addr = mmap(*addr, sb.st_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED, fd, 0);\n    }\n    if (*addr == MAP_FAILED) {\n        LOGERR(ctx, LY_ESYS, \"mmap() failed (%s).\", strerror(errno));\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nlyp_munmap(void *addr, size_t length)\n{\n    return munmap(addr, length);\n}\n\nint\nlyp_add_ietf_netconf_annotations_config(struct lys_module *mod)\n{\n    void *reallocated;\n    struct lys_ext_instance_complex *op;\n    struct lys_type **type;\n    struct lys_node_anydata *anyxml;\n    int i;\n    struct ly_ctx *ctx = mod->ctx; /* shortcut */\n\n    reallocated = realloc(mod->ext, (mod->ext_size + 3) * sizeof *mod->ext);\n    LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext = reallocated;\n    /* 1) edit-config's operation */\n    op = calloc(1, (sizeof(struct lys_ext_instance_complex) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));\n    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext[mod->ext_size] = (struct lys_ext_instance *)op;\n    op->arg_value = lydict_insert(ctx, \"operation\", 9);\n    op->def = &ctx->models.list[0]->extensions[0];\n    op->ext_type = LYEXT_COMPLEX;\n    op->module = op->parent = mod;\n    op->parent_type = LYEXT_PAR_MODULE;\n    op->substmt = ((struct lyext_plugin_complex *)op->def->plugin)->substmt;\n    op->nodetype = LYS_EXT;\n    type = (struct lys_type**)&op->content; /* type is stored at offset 0 */\n    *type = calloc(1, sizeof(struct lys_type));\n    LY_CHECK_ERR_RETURN(!*type, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->base = LY_TYPE_ENUM;\n    (*type)->der = ly_types[LY_TYPE_ENUM];\n    (*type)->parent = (struct lys_tpdf *)op;\n    (*type)->info.enums.count = 5;\n    (*type)->info.enums.enm = calloc(5, sizeof *(*type)->info.enums.enm);\n    LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->info.enums.enm[0].value = 0;\n    (*type)->info.enums.enm[0].name = lydict_insert(ctx, \"merge\", 5);\n    (*type)->info.enums.enm[1].value = 1;\n    (*type)->info.enums.enm[1].name = lydict_insert(ctx, \"replace\", 7);\n    (*type)->info.enums.enm[2].value = 2;\n    (*type)->info.enums.enm[2].name = lydict_insert(ctx, \"create\", 6);\n    (*type)->info.enums.enm[3].value = 3;\n    (*type)->info.enums.enm[3].name = lydict_insert(ctx, \"delete\", 6);\n    (*type)->info.enums.enm[4].value = 4;\n    (*type)->info.enums.enm[4].name = lydict_insert(ctx, \"remove\", 6);\n    mod->ext_size++;\n\n    /* 2) filter's type */\n    op = calloc(1, (sizeof(struct lys_ext_instance_complex) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));\n    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext[mod->ext_size] = (struct lys_ext_instance *)op;\n    op->arg_value = lydict_insert(ctx, \"type\", 4);\n    op->def = &ctx->models.list[0]->extensions[0];\n    op->ext_type = LYEXT_COMPLEX;\n    op->module = op->parent = mod;\n    op->parent_type = LYEXT_PAR_MODULE;\n    op->substmt = ((struct lyext_plugin_complex *)op->def->plugin)->substmt;\n    op->nodetype = LYS_EXT;\n    type = (struct lys_type**)&op->content; /* type is stored at offset 0 */\n    *type = calloc(1, sizeof(struct lys_type));\n    LY_CHECK_ERR_RETURN(!*type, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->base = LY_TYPE_ENUM;\n    (*type)->der = ly_types[LY_TYPE_ENUM];\n    (*type)->parent = (struct lys_tpdf *)op;\n    (*type)->info.enums.count = 2;\n    (*type)->info.enums.enm = calloc(2, sizeof *(*type)->info.enums.enm);\n    LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->info.enums.enm[0].value = 0;\n    (*type)->info.enums.enm[0].name = lydict_insert(ctx, \"subtree\", 7);\n    (*type)->info.enums.enm[1].value = 1;\n    (*type)->info.enums.enm[1].name = lydict_insert(ctx, \"xpath\", 5);\n    for (i = mod->features_size; i > 0; i--) {\n        if (!strcmp(mod->features[i - 1].name, \"xpath\")) {\n            (*type)->info.enums.enm[1].iffeature_size = 1;\n            (*type)->info.enums.enm[1].iffeature = calloc(1, sizeof(struct lys_feature));\n            LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm[1].iffeature, LOGMEM(ctx), EXIT_FAILURE);\n            (*type)->info.enums.enm[1].iffeature[0].expr = malloc(sizeof(uint8_t));\n            LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm[1].iffeature[0].expr, LOGMEM(ctx), EXIT_FAILURE);\n            *(*type)->info.enums.enm[1].iffeature[0].expr = 3; /* LYS_IFF_F */\n            (*type)->info.enums.enm[1].iffeature[0].features = malloc(sizeof(struct lys_feature*));\n            LY_CHECK_ERR_RETURN(!(*type)->info.enums.enm[1].iffeature[0].features, LOGMEM(ctx), EXIT_FAILURE);\n            (*type)->info.enums.enm[1].iffeature[0].features[0] = &mod->features[i - 1];\n            break;\n        }\n    }\n    mod->ext_size++;\n\n    /* 3) filter's select */\n    op = calloc(1, (sizeof(struct lys_ext_instance_complex) - 1) + 5 * sizeof(void*) + sizeof(uint16_t));\n    LY_CHECK_ERR_RETURN(!op, LOGMEM(ctx), EXIT_FAILURE);\n    mod->ext[mod->ext_size] = (struct lys_ext_instance *)op;\n    op->arg_value = lydict_insert(ctx, \"select\", 6);\n    op->def = &ctx->models.list[0]->extensions[0];\n    op->ext_type = LYEXT_COMPLEX;\n    op->module = op->parent = mod;\n    op->parent_type = LYEXT_PAR_MODULE;\n    op->substmt = ((struct lyext_plugin_complex *)op->def->plugin)->substmt;\n    op->nodetype = LYS_EXT;\n    type = (struct lys_type**)&op->content; /* type is stored at offset 0 */\n    *type = calloc(1, sizeof(struct lys_type));\n    LY_CHECK_ERR_RETURN(!*type, LOGMEM(ctx), EXIT_FAILURE);\n    (*type)->base = LY_TYPE_STRING;\n    (*type)->der = ly_types[LY_TYPE_STRING];\n    (*type)->parent = (struct lys_tpdf *)op;\n    mod->ext_size++;\n\n    /* 4) URL config */\n    anyxml = calloc(1, sizeof *anyxml);\n    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), EXIT_FAILURE);\n    anyxml->nodetype = LYS_ANYXML;\n    anyxml->prev = (struct lys_node *)anyxml;\n    anyxml->name = lydict_insert(ctx, \"config\", 0);\n    anyxml->module = mod;\n    anyxml->flags = LYS_CONFIG_W;\n    if (lys_node_addchild(NULL, mod, (struct lys_node *)anyxml, 0)) {\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly\n * base: 0  - to accept decimal, octal, hexadecimal (in default value)\n *       10 - to accept only decimal (instance value)\n */\nstatic int\nparse_int(const char *val_str, int64_t min, int64_t max, int base, int64_t *ret, struct lyd_node *node)\n{\n    char *strptr;\n\n    assert(node);\n\n    if (!val_str || !val_str[0]) {\n        goto error;\n    }\n\n    /* convert to 64-bit integer, all the redundant characters are handled */\n    errno = 0;\n    strptr = NULL;\n\n    /* parse the value */\n    *ret = strtoll(val_str, &strptr, base);\n    if (errno || (*ret < min) || (*ret > max)) {\n        goto error;\n    } else if (strptr && *strptr) {\n        while (isspace(*strptr)) {\n            ++strptr;\n        }\n        if (*strptr) {\n            goto error;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    LOGVAL(node->schema->module->ctx, LYE_INVAL, LY_VLOG_LYD, node, val_str ? val_str : \"\", node->schema->name);\n    return EXIT_FAILURE;\n}\n\n/* logs directly\n * base: 0  - to accept decimal, octal, hexadecimal (in default value)\n *       10 - to accept only decimal (instance value)\n */\nstatic int\nparse_uint(const char *val_str, uint64_t max, int base, uint64_t *ret, struct lyd_node *node)\n{\n    char *strptr;\n    uint64_t u;\n\n    assert(node);\n\n    if (!val_str || !val_str[0]) {\n        goto error;\n    }\n\n    errno = 0;\n    strptr = NULL;\n    u = strtoull(val_str, &strptr, base);\n    if (errno || (u > max)) {\n        goto error;\n    } else if (strptr && *strptr) {\n        while (isspace(*strptr)) {\n            ++strptr;\n        }\n        if (*strptr) {\n            goto error;\n        }\n    } else if (u != 0 && val_str[0] == '-') {\n        goto error;\n    }\n\n    *ret = u;\n    return EXIT_SUCCESS;\n\nerror:\n    LOGVAL(node->schema->module->ctx, LYE_INVAL, LY_VLOG_LYD, node, val_str ? val_str : \"\", node->schema->name);\n    return EXIT_FAILURE;\n}\n\n/* logs directly\n *\n * kind == 0 - unsigned (unum used), 1 - signed (snum used), 2 - floating point (fnum used)\n */\nstatic int\nvalidate_length_range(uint8_t kind, uint64_t unum, int64_t snum, int64_t fnum, uint8_t fnum_dig, struct lys_type *type,\n                      const char *val_str, struct lyd_node *node)\n{\n    struct lys_restr *restr = NULL;\n    struct len_ran_intv *intv = NULL, *tmp_intv;\n    struct lys_type *cur_type;\n    struct ly_ctx *ctx = type->parent->module->ctx;\n    int match;\n\n    if (resolve_len_ran_interval(ctx, NULL, type, &intv)) {\n        /* already done during schema parsing */\n        LOGINT(ctx);\n        return EXIT_FAILURE;\n    }\n    if (!intv) {\n        return EXIT_SUCCESS;\n    }\n\n    /* I know that all intervals belonging to a single restriction share one type pointer */\n    tmp_intv = intv;\n    cur_type = intv->type;\n    do {\n        match = 0;\n        for (; tmp_intv && (tmp_intv->type == cur_type); tmp_intv = tmp_intv->next) {\n            if (match) {\n                /* just iterate through the rest of this restriction intervals */\n                continue;\n            }\n\n            if (((kind == 0) && (unum < tmp_intv->value.uval.min))\n                    || ((kind == 1) && (snum < tmp_intv->value.sval.min))\n                    || ((kind == 2) && (dec64cmp(fnum, fnum_dig, tmp_intv->value.fval.min, cur_type->info.dec64.dig) < 0))) {\n                break;\n            }\n\n            if (((kind == 0) && (unum >= tmp_intv->value.uval.min) && (unum <= tmp_intv->value.uval.max))\n                    || ((kind == 1) && (snum >= tmp_intv->value.sval.min) && (snum <= tmp_intv->value.sval.max))\n                    || ((kind == 2) && (dec64cmp(fnum, fnum_dig, tmp_intv->value.fval.min, cur_type->info.dec64.dig) > -1)\n                    && (dec64cmp(fnum, fnum_dig, tmp_intv->value.fval.max, cur_type->info.dec64.dig) < 1))) {\n                match = 1;\n            }\n        }\n\n        if (!match) {\n            break;\n        } else if (tmp_intv) {\n            cur_type = tmp_intv->type;\n        }\n    } while (tmp_intv);\n\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n\n    if (!match) {\n        switch (cur_type->base) {\n        case LY_TYPE_BINARY:\n            restr = cur_type->info.binary.length;\n            break;\n        case LY_TYPE_DEC64:\n            restr = cur_type->info.dec64.range;\n            break;\n        case LY_TYPE_INT8:\n        case LY_TYPE_INT16:\n        case LY_TYPE_INT32:\n        case LY_TYPE_INT64:\n        case LY_TYPE_UINT8:\n        case LY_TYPE_UINT16:\n        case LY_TYPE_UINT32:\n        case LY_TYPE_UINT64:\n            restr = cur_type->info.num.range;\n            break;\n        case LY_TYPE_STRING:\n            restr = cur_type->info.str.length;\n            break;\n        default:\n            LOGINT(ctx);\n            return EXIT_FAILURE;\n        }\n\n        LOGVAL(ctx, LYE_NOCONSTR, LY_VLOG_LYD, node, (val_str ? val_str : \"\"), restr ? restr->expr : \"\");\n        if (restr && restr->emsg) {\n            ly_vlog_str(ctx, LY_VLOG_PREV, restr->emsg);\n        }\n        if (restr && restr->eapptag) {\n            ly_err_last_set_apptag(ctx, restr->eapptag);\n        }\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nstatic int\nvalidate_pattern(struct ly_ctx *ctx, const char *val_str, struct lys_type *type, struct lyd_node *node)\n{\n    int rc;\n    unsigned int i;\n#ifndef LY_ENABLED_CACHE\n    pcre *precomp;\n#endif\n\n    assert(ctx && (type->base == LY_TYPE_STRING));\n\n    if (!val_str) {\n        val_str = \"\";\n    }\n\n    if (type->der && validate_pattern(ctx, val_str, &type->der->type, node)) {\n        return EXIT_FAILURE;\n    }\n\n#ifdef LY_ENABLED_CACHE\n    /* there is no cache, build it */\n    if (!type->info.str.patterns_pcre && type->info.str.pat_count) {\n        type->info.str.patterns_pcre = malloc(2 * type->info.str.pat_count * sizeof *type->info.str.patterns_pcre);\n        LY_CHECK_ERR_RETURN(!type->info.str.patterns_pcre, LOGMEM(ctx), -1);\n\n        for (i = 0; i < type->info.str.pat_count; ++i) {\n            if (lyp_precompile_pattern(ctx, &type->info.str.patterns[i].expr[1],\n                                       (pcre**)&type->info.str.patterns_pcre[i * 2],\n                                       (pcre_extra**)&type->info.str.patterns_pcre[i * 2 + 1])) {\n                return EXIT_FAILURE;\n            }\n        }\n    }\n#endif\n\n    for (i = 0; i < type->info.str.pat_count; ++i) {\n#ifdef LY_ENABLED_CACHE\n        rc = pcre_exec((pcre *)type->info.str.patterns_pcre[2 * i], (pcre_extra *)type->info.str.patterns_pcre[2 * i + 1],\n                       val_str, strlen(val_str), 0, 0, NULL, 0);\n#else\n        if (lyp_check_pattern(ctx, &type->info.str.patterns[i].expr[1], &precomp)) {\n            return EXIT_FAILURE;\n        }\n        rc = pcre_exec(precomp, NULL, val_str, strlen(val_str), 0, 0, NULL, 0);\n        free(precomp);\n#endif\n        if ((rc && type->info.str.patterns[i].expr[0] == 0x06) || (!rc && type->info.str.patterns[i].expr[0] == 0x15)) {\n            LOGVAL(ctx, LYE_NOCONSTR, LY_VLOG_LYD, node, val_str, &type->info.str.patterns[i].expr[1]);\n            if (type->info.str.patterns[i].emsg) {\n                ly_vlog_str(ctx, LY_VLOG_PREV, type->info.str.patterns[i].emsg);\n            }\n            if (type->info.str.patterns[i].eapptag) {\n                ly_err_last_set_apptag(ctx, type->info.str.patterns[i].eapptag);\n            }\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nstatic void\ncheck_number(const char *str_num, const char **num_end, LY_DATA_TYPE base)\n{\n    if (!isdigit(str_num[0]) && (str_num[0] != '-') && (str_num[0] != '+')) {\n        *num_end = str_num;\n        return;\n    }\n\n    if ((str_num[0] == '-') || (str_num[0] == '+')) {\n        ++str_num;\n    }\n\n    while (isdigit(str_num[0])) {\n        ++str_num;\n    }\n\n    if ((base != LY_TYPE_DEC64) || (str_num[0] != '.') || !isdigit(str_num[1])) {\n        *num_end = str_num;\n        return;\n    }\n\n    ++str_num;\n    while (isdigit(str_num[0])) {\n        ++str_num;\n    }\n\n    *num_end = str_num;\n}\n\n/**\n * @brief Checks the syntax of length or range statement,\n *        on success checks the semantics as well. Does not log.\n *\n * @param[in] expr Length or range expression.\n * @param[in] type Type with the restriction.\n *\n * @return EXIT_SUCCESS on success, EXIT_FAILURE otherwise.\n */\nint\nlyp_check_length_range(struct ly_ctx *ctx, const char *expr, struct lys_type *type)\n{\n    struct len_ran_intv *intv = NULL, *tmp_intv;\n    const char *c = expr, *tail;\n    int ret = EXIT_FAILURE, flg = 1; /* first run flag */\n\n    assert(expr);\n\nlengthpart:\n\n    while (isspace(*c)) {\n        c++;\n    }\n\n    /* lower boundary or explicit number */\n    if (!strncmp(c, \"max\", 3)) {\nmax:\n        c += 3;\n        while (isspace(*c)) {\n            c++;\n        }\n        if (*c != '\\0') {\n            goto error;\n        }\n\n        goto syntax_ok;\n\n    } else if (!strncmp(c, \"min\", 3)) {\n        if (!flg) {\n            /* min cannot be used elsewhere than in the first length-part */\n            goto error;\n        } else {\n            flg = 0;\n        }\n        c += 3;\n        while (isspace(*c)) {\n            c++;\n        }\n\n        if (*c == '|') {\n            c++;\n            /* process next length-part */\n            goto lengthpart;\n        } else if (*c == '\\0') {\n            goto syntax_ok;\n        } else if (!strncmp(c, \"..\", 2)) {\nupper:\n            c += 2;\n            while (isspace(*c)) {\n                c++;\n            }\n            if (*c == '\\0') {\n                goto error;\n            }\n\n            /* upper boundary */\n            if (!strncmp(c, \"max\", 3)) {\n                goto max;\n            }\n\n            check_number(c, &tail, type->base);\n            if (c == tail) {\n                goto error;\n            }\n            c = tail;\n            while (isspace(*c)) {\n                c++;\n            }\n            if (*c == '\\0') {\n                goto syntax_ok;\n            } else if (*c == '|') {\n                c++;\n                /* process next length-part */\n                goto lengthpart;\n            } else {\n                goto error;\n            }\n        } else {\n            goto error;\n        }\n\n    } else if (isdigit(*c) || (*c == '-') || (*c == '+')) {\n        /* number */\n        check_number(c, &tail, type->base);\n        if (c == tail) {\n            goto error;\n        }\n        c = tail;\n\n        while (isspace(*c)) {\n            c++;\n        }\n\n        if (*c == '|') {\n            c++;\n            /* process next length-part */\n            goto lengthpart;\n        } else if (*c == '\\0') {\n            goto syntax_ok;\n        } else if (!strncmp(c, \"..\", 2)) {\n            goto upper;\n        }\n\n    } else {\n        goto error;\n    }\n\nsyntax_ok:\n    if (resolve_len_ran_interval(ctx, expr, type, &intv)) {\n        goto error;\n    }\n\n    ret = EXIT_SUCCESS;\n\nerror:\n    while (intv) {\n        tmp_intv = intv->next;\n        free(intv);\n        intv = tmp_intv;\n    }\n\n    return ret;\n}\n\n/**\n * @brief Checks pattern syntax. Logs directly.\n *\n * @param[in] pattern Pattern to check.\n * @param[out] pcre_precomp Precompiled PCRE pattern. Can be NULL.\n * @return EXIT_SUCCESS on success, EXIT_FAILURE otherwise.\n */\nint\nlyp_check_pattern(struct ly_ctx *ctx, const char *pattern, pcre **pcre_precomp)\n{\n    int idx, idx2, start, end, err_offset, count;\n    char *perl_regex, *ptr;\n    const char *err_msg, *orig_ptr;\n    pcre *precomp;\n\n    /*\n     * adjust the expression to a Perl equivalent\n     *\n     * http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#regexs\n     */\n\n    /* we need to replace all \"$\" with \"\\$\", count them now */\n    for (count = 0, ptr = strchr(pattern, '$'); ptr; ++count, ptr = strchr(ptr + 1, '$'));\n\n    perl_regex = malloc((strlen(pattern) + 4 + count) * sizeof(char));\n    LY_CHECK_ERR_RETURN(!perl_regex, LOGMEM(ctx), EXIT_FAILURE);\n    perl_regex[0] = '\\0';\n\n    ptr = perl_regex;\n\n    if (strncmp(pattern + strlen(pattern) - 2, \".*\", 2)) {\n        /* we wil add line-end anchoring */\n        ptr[0] = '(';\n        ++ptr;\n    }\n\n    for (orig_ptr = pattern; orig_ptr[0]; ++orig_ptr) {\n        if (orig_ptr[0] == '$') {\n            ptr += sprintf(ptr, \"\\\\$\");\n        } else {\n            ptr[0] = orig_ptr[0];\n            ++ptr;\n        }\n    }\n\n    if (strncmp(pattern + strlen(pattern) - 2, \".*\", 2)) {\n        ptr += sprintf(ptr, \")$\");\n    } else {\n        ptr[0] = '\\0';\n        ++ptr;\n    }\n\n    /* substitute Unicode Character Blocks with exact Character Ranges */\n    while ((ptr = strstr(perl_regex, \"\\\\p{Is\"))) {\n        start = ptr - perl_regex;\n\n        ptr = strchr(ptr, '}');\n        if (!ptr) {\n            LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + start + 2, \"unterminated character property\");\n            free(perl_regex);\n            return EXIT_FAILURE;\n        }\n\n        end = (ptr - perl_regex) + 1;\n\n        /* need more space */\n        if (end - start < LYP_URANGE_LEN) {\n            perl_regex = ly_realloc(perl_regex, strlen(perl_regex) + (LYP_URANGE_LEN - (end - start)) + 1);\n            LY_CHECK_ERR_RETURN(!perl_regex, LOGMEM(ctx); free(perl_regex), EXIT_FAILURE);\n        }\n\n        /* find our range */\n        for (idx = 0; lyp_ublock2urange[idx][0]; ++idx) {\n            if (!strncmp(perl_regex + start + 5, lyp_ublock2urange[idx][0], strlen(lyp_ublock2urange[idx][0]))) {\n                break;\n            }\n        }\n        if (!lyp_ublock2urange[idx][0]) {\n            LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + start + 5, \"unknown block name\");\n            free(perl_regex);\n            return EXIT_FAILURE;\n        }\n\n        /* make the space in the string and replace the block (but we cannot include brackets if it was already enclosed in them) */\n        for (idx2 = 0, count = 0; idx2 < start; ++idx2) {\n            if ((perl_regex[idx2] == '[') && (!idx2 || (perl_regex[idx2 - 1] != '\\\\'))) {\n                ++count;\n            }\n            if ((perl_regex[idx2] == ']') && (!idx2 || (perl_regex[idx2 - 1] != '\\\\'))) {\n                --count;\n            }\n        }\n        if (count) {\n            /* skip brackets */\n            memmove(perl_regex + start + (LYP_URANGE_LEN - 2), perl_regex + end, strlen(perl_regex + end) + 1);\n            memcpy(perl_regex + start, lyp_ublock2urange[idx][1] + 1, LYP_URANGE_LEN - 2);\n        } else {\n            memmove(perl_regex + start + LYP_URANGE_LEN, perl_regex + end, strlen(perl_regex + end) + 1);\n            memcpy(perl_regex + start, lyp_ublock2urange[idx][1], LYP_URANGE_LEN);\n        }\n    }\n\n    /* must return 0, already checked during parsing */\n    precomp = pcre_compile(perl_regex, PCRE_ANCHORED | PCRE_DOLLAR_ENDONLY | PCRE_NO_AUTO_CAPTURE,\n                           &err_msg, &err_offset, NULL);\n    if (!precomp) {\n        LOGVAL(ctx, LYE_INREGEX, LY_VLOG_NONE, NULL, pattern, perl_regex + err_offset, err_msg);\n        free(perl_regex);\n        return EXIT_FAILURE;\n    }\n    free(perl_regex);\n\n    if (pcre_precomp) {\n        *pcre_precomp = precomp;\n    } else {\n        free(precomp);\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nlyp_precompile_pattern(struct ly_ctx *ctx, const char *pattern, pcre** pcre_cmp, pcre_extra **pcre_std)\n{\n    const char *err_msg = NULL;\n\n    if (lyp_check_pattern(ctx, pattern, pcre_cmp)) {\n        return EXIT_FAILURE;\n    }\n\n    if (pcre_std && pcre_cmp) {\n        (*pcre_std) = pcre_study(*pcre_cmp, 0, &err_msg);\n        if (err_msg) {\n            LOGWRN(ctx, \"Studying pattern \\\"%s\\\" failed (%s).\", pattern, err_msg);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Change the value into its canonical form. In libyang, additionally to the RFC,\n * all identities have their module as a prefix in their canonical form.\n *\n * @param[in] ctx\n * @param[in] type Type of the value.\n * @param[in,out] value Original and then canonical value.\n * @param[in] data1 If \\p type is #LY_TYPE_BITS: (struct lys_type_bit **) type bit field,\n *                                #LY_TYPE_DEC64: (int64_t *) parsed digits of the number itself without floating point,\n *                                #LY_TYPE_IDENT: (const char *) local module name (identityref node module),\n *                                #LY_TYPE_INT*: (int64_t *) parsed int number itself,\n *                                #LY_TYPE_UINT*: (uint64_t *) parsed uint number itself,\n *                                otherwise ignored.\n * @param[in] data2 If \\p type is #LY_TYPE_BITS: (int *) type bit field length,\n *                                #LY_TYPE_DEC64: (uint8_t *) number of fraction digits (position of the floating point),\n *                                otherwise ignored.\n * @return 1 if a conversion took place, 0 if the value was kept the same, -1 on error.\n */\nstatic int\nmake_canonical(struct ly_ctx *ctx, int type, const char **value, void *data1, void *data2)\n{\n    const uint16_t buf_len = 511;\n    char buf[buf_len + 1];\n    struct lys_type_bit **bits = NULL;\n    struct lyxp_expr *exp;\n    const char *module_name, *cur_expr, *end;\n    int i, j, count;\n    int64_t num;\n    uint64_t unum;\n    uint8_t c;\n\n#define LOGBUF(str) LOGERR(ctx, LY_EINVAL, \"Value \\\"%s\\\" is too long.\", str)\n\n    switch (type) {\n    case LY_TYPE_BITS:\n        bits = (struct lys_type_bit **)data1;\n        count = *((int *)data2);\n        /* in canonical form, the bits are ordered by their position */\n        buf[0] = '\\0';\n        for (i = 0; i < count; i++) {\n            if (!bits[i]) {\n                /* bit not set */\n                continue;\n            }\n            if (buf[0]) {\n                LY_CHECK_ERR_RETURN(strlen(buf) + 1 + strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                sprintf(buf + strlen(buf), \" %s\", bits[i]->name);\n            } else {\n                LY_CHECK_ERR_RETURN(strlen(bits[i]->name) > buf_len, LOGBUF(bits[i]->name), -1);\n                strcpy(buf, bits[i]->name);\n            }\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        module_name = (const char *)data1;\n        /* identity must always have a prefix */\n        if (!strchr(*value, ':')) {\n            LY_CHECK_ERR_RETURN(strlen(module_name) + 1 + strlen(*value) > buf_len, LOGBUF(*value), -1);\n            sprintf(buf, \"%s:%s\", module_name, *value);\n        } else {\n            LY_CHECK_ERR_RETURN(strlen(*value) > buf_len, LOGBUF(*value), -1);\n            strcpy(buf, *value);\n        }\n        break;\n\n    case LY_TYPE_INST:\n        exp = lyxp_parse_expr(ctx, *value);\n        LY_CHECK_ERR_RETURN(!exp, LOGINT(ctx), -1);\n\n        module_name = NULL;\n        count = 0;\n        for (i = 0; (unsigned)i < exp->used; ++i) {\n            cur_expr = &exp->expr[exp->expr_pos[i]];\n\n            /* copy WS */\n            if (i && ((end = exp->expr + exp->expr_pos[i - 1] + exp->tok_len[i - 1]) != cur_expr)) {\n                if (count + (cur_expr - end) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, cur_expr - end);\n                count += cur_expr - end;\n            }\n\n            if ((exp->tokens[i] == LYXP_TOKEN_NAMETEST) && (end = strnchr(cur_expr, ':', exp->tok_len[i]))) {\n                /* get the module name with \":\" */\n                ++end;\n                j = end - cur_expr;\n\n                if (!module_name || strncmp(cur_expr, module_name, j)) {\n                    /* print module name with colon, it does not equal to the parent one */\n                    if (count + j > buf_len) {\n                        lyxp_expr_free(exp);\n                        LOGBUF(cur_expr);\n                        return -1;\n                    }\n                    strncpy(&buf[count], cur_expr, j);\n                    count += j;\n                }\n                module_name = cur_expr;\n\n                /* copy the rest */\n                if (count + (exp->tok_len[i] - j) > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(end);\n                    return -1;\n                }\n                strncpy(&buf[count], end, exp->tok_len[i] - j);\n                count += exp->tok_len[i] - j;\n            } else {\n                if (count + exp->tok_len[i] > buf_len) {\n                    lyxp_expr_free(exp);\n                    LOGBUF(&exp->expr[exp->expr_pos[i]]);\n                    return -1;\n                }\n                strncpy(&buf[count], &exp->expr[exp->expr_pos[i]], exp->tok_len[i]);\n                count += exp->tok_len[i];\n            }\n        }\n        if (count > buf_len) {\n            LOGINT(ctx);\n            lyxp_expr_free(exp);\n            return -1;\n        }\n        buf[count] = '\\0';\n\n        lyxp_expr_free(exp);\n        break;\n\n    case LY_TYPE_DEC64:\n        num = *((int64_t *)data1);\n        c = *((uint8_t *)data2);\n        if (num) {\n            count = sprintf(buf, \"%\"PRId64\" \", num);\n            if ( (num > 0 && (count - 1) <= c)\n                 || (count - 2) <= c ) {\n                /* we have 0. value, print the value with the leading zeros\n                 * (one for 0. and also keep the correct with of num according\n                 * to fraction-digits value)\n                 * for (num<0) - extra character for '-' sign */\n                count = sprintf(buf, \"%0*\"PRId64\" \", (num > 0) ? (c + 1) : (c + 2), num);\n            }\n            for (i = c, j = 1; i > 0 ; i--) {\n                if (j && i > 1 && buf[count - 2] == '0') {\n                    /* we have trailing zero to skip */\n                    buf[count - 1] = '\\0';\n                } else {\n                    j = 0;\n                    buf[count - 1] = buf[count - 2];\n                }\n                count--;\n            }\n            buf[count - 1] = '.';\n        } else {\n            /* zero */\n            sprintf(buf, \"0.0\");\n        }\n        break;\n\n    case LY_TYPE_INT8:\n    case LY_TYPE_INT16:\n    case LY_TYPE_INT32:\n    case LY_TYPE_INT64:\n        num = *((int64_t *)data1);\n        sprintf(buf, \"%\"PRId64, num);\n        break;\n\n    case LY_TYPE_UINT8:\n    case LY_TYPE_UINT16:\n    case LY_TYPE_UINT32:\n    case LY_TYPE_UINT64:\n        unum = *((uint64_t *)data1);\n        sprintf(buf, \"%\"PRIu64, unum);\n        break;\n\n    default:\n        /* should not be even called - just do nothing */\n        return 0;\n    }\n\n    if (strcmp(buf, *value)) {\n        lydict_remove(ctx, *value);\n        *value = lydict_insert(ctx, buf, 0);\n        return 1;\n    }\n\n    return 0;\n\n#undef LOGBUF\n}\n\nstatic const char *\nident_val_add_module_prefix(const char *value, const struct lyxml_elem *xml, struct ly_ctx *ctx)\n{\n    const struct lyxml_ns *ns;\n    const struct lys_module *mod;\n    char *str;\n\n    do {\n        LY_TREE_FOR((struct lyxml_ns *)xml->attr, ns) {\n            if ((ns->type == LYXML_ATTR_NS) && !ns->prefix) {\n                /* match */\n                break;\n            }\n        }\n        if (!ns) {\n            xml = xml->parent;\n        }\n    } while (!ns && xml);\n\n    if (!ns) {\n        /* no default namespace */\n        LOGINT(ctx);\n        return NULL;\n    }\n\n    /* find module */\n    mod = ly_ctx_get_module_by_ns(ctx, ns->value, NULL, 1);\n    if (!mod) {\n        LOGINT(ctx);\n        return NULL;\n    }\n\n    if (asprintf(&str, \"%s:%s\", mod->name, value) == -1) {\n        LOGMEM(ctx);\n        return NULL;\n    }\n    lydict_remove(ctx, value);\n\n    return lydict_insert_zc(ctx, str);\n}\n\n/*\n * xml  - optional for converting instance-identifier and identityref into JSON format\n * leaf - mandatory to know the context (necessary e.g. for prefixes in idenitytref values)\n * attr - alternative to leaf in case of parsing value in annotations (attributes)\n * local_mod - optional if the local module dos not match the module of leaf/attr\n * store - flag for union resolution - we do not want to store the result, we are just learning the type\n * dflt - whether the value is a default value from the schema\n * trusted - whether the value is trusted to be valid (but may not be canonical, so it is canonized)\n */\nstruct lys_type *\nlyp_parse_value(struct lys_type *type, const char **value_, struct lyxml_elem *xml,\n                struct lyd_node_leaf_list *leaf, struct lyd_attr *attr, struct lys_module *local_mod,\n                int store, int dflt, int trusted)\n{\n    struct lys_type *ret = NULL, *t;\n    struct lys_tpdf *tpdf;\n    enum int_log_opts prev_ilo;\n    int c, len, found = 0;\n    unsigned int i, j;\n    int64_t num;\n    uint64_t unum, uind, u = 0;\n    const char *ptr, *value = *value_, *itemname, *old_val_str = NULL;\n    struct lys_type_bit **bits = NULL;\n    struct lys_ident *ident;\n    lyd_val *val, old_val;\n    LY_DATA_TYPE *val_type, old_val_type;\n    uint8_t *val_flags, old_val_flags;\n    struct lyd_node *contextnode;\n    struct ly_ctx *ctx = type->parent->module->ctx;\n\n    assert(leaf || attr);\n\n    if (leaf) {\n        assert(!attr);\n        if (!local_mod) {\n            local_mod = leaf->schema->module;\n        }\n        val = &leaf->value;\n        val_type = &leaf->value_type;\n        val_flags = &leaf->value_flags;\n        contextnode = (struct lyd_node *)leaf;\n        itemname = leaf->schema->name;\n    } else {\n        assert(!leaf);\n        if (!local_mod) {\n            local_mod = attr->annotation->module;\n        }\n        val = &attr->value;\n        val_type = &attr->value_type;\n        val_flags = &attr->value_flags;\n        contextnode = attr->parent;\n        itemname = attr->name;\n    }\n\n    /* fully clear the value */\n    if (store) {\n        old_val_str = lydict_insert(ctx, *value_, 0);\n        lyd_free_value(*val, *val_type, *val_flags, type, old_val_str, &old_val, &old_val_type, &old_val_flags);\n        *val_flags &= ~LY_VALUE_UNRES;\n    }\n\n    switch (type->base) {\n    case LY_TYPE_BINARY:\n        /* get number of octets for length validation */\n        unum = 0;\n        ptr = NULL;\n        if (value) {\n            /* silently skip leading/trailing whitespaces */\n            for (uind = 0; isspace(value[uind]); ++uind);\n            ptr = &value[uind];\n            u = strlen(ptr);\n            while (u && isspace(ptr[u - 1])) {\n                --u;\n            }\n            unum = u;\n            for (uind = 0; uind < u; ++uind) {\n                if (ptr[uind] == '\\n') {\n                    unum--;\n                } else if ((ptr[uind] < '/' && ptr[uind] != '+') ||\n                    (ptr[uind] > '9' && ptr[uind] < 'A') ||\n                    (ptr[uind] > 'Z' && ptr[uind] < 'a') || ptr[uind] > 'z') {\n                    if (ptr[uind] == '=') {\n                        /* padding */\n                        if (uind == u - 2 && ptr[uind + 1] == '=') {\n                            found = 2;\n                            uind++;\n                        } else if (uind == u - 1) {\n                            found = 1;\n                        }\n                    }\n                    if (!found) {\n                        /* error */\n                        LOGVAL(ctx, LYE_INCHAR, LY_VLOG_LYD, contextnode, ptr[uind], &ptr[uind]);\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Invalid Base64 character.\");\n                        goto error;\n                    }\n                }\n            }\n        }\n\n        if (unum & 3) {\n            /* base64 length must be multiple of 4 chars */\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n            }\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Base64 encoded value length must be divisible by 4.\");\n            goto error;\n        }\n\n        /* length of the encoded string */\n        len = ((unum / 4) * 3) - found;\n        if (!trusted && validate_length_range(0, len, 0, 0, 0, type, value, contextnode)) {\n            goto error;\n        }\n\n        if (value && (ptr != value || ptr[u] != '\\0')) {\n            /* update the changed value */\n            ptr = lydict_insert(ctx, ptr, u);\n            lydict_remove(ctx, *value_);\n            *value_ = ptr;\n        }\n\n        if (store) {\n            /* store the result */\n            val->binary = value;\n            *val_type = LY_TYPE_BINARY;\n        }\n        break;\n\n    case LY_TYPE_BITS:\n        /* locate bits structure with the bits definitions\n         * since YANG 1.1 allows restricted bits, it is the first\n         * bits type with some explicit bit specification */\n        for (; !type->info.bits.count; type = &type->der->type);\n\n        if (value || store) {\n            /* allocate the array of pointers to bits definition */\n            bits = calloc(type->info.bits.count, sizeof *bits);\n            LY_CHECK_ERR_GOTO(!bits, LOGMEM(ctx), error);\n        }\n\n        if (!value) {\n            /* no bits set */\n            if (store) {\n                /* store empty array */\n                val->bit = bits;\n                *val_type = LY_TYPE_BITS;\n            }\n            break;\n        }\n\n        c = 0;\n        i = 0;\n        while (value[c]) {\n            /* skip leading whitespaces */\n            while (isspace(value[c])) {\n                c++;\n            }\n            if (!value[c]) {\n                /* trailing white spaces */\n                break;\n            }\n\n            /* get the length of the bit identifier */\n            for (len = 0; value[c] && !isspace(value[c]); c++, len++);\n\n            /* go back to the beginning of the identifier */\n            c = c - len;\n\n            /* find bit definition, identifiers appear ordered by their position */\n            for (found = i = 0; i < type->info.bits.count; i++) {\n                if (!strncmp(type->info.bits.bit[i].name, &value[c], len) && !type->info.bits.bit[i].name[len]) {\n                    /* we have match, check if the value is enabled ... */\n                    for (j = 0; !trusted && (j < type->info.bits.bit[i].iffeature_size); j++) {\n                        if (!resolve_iffeature(&type->info.bits.bit[i].iffeature[j])) {\n                            if (leaf) {\n                                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                            } else {\n                                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                            }\n                            LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n                                   \"Bit \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                                   type->info.bits.bit[i].name, j + 1);\n                            free(bits);\n                            goto error;\n                        }\n                    }\n                    /* check that the value was not already set */\n                    if (bits[i]) {\n                        if (leaf) {\n                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                        } else {\n                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                        }\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Bit \\\"%s\\\" used multiple times.\",\n                               type->info.bits.bit[i].name);\n                        free(bits);\n                        goto error;\n                    }\n                    /* ... and then store the pointer */\n                    bits[i] = &type->info.bits.bit[i];\n\n                    /* stop searching */\n                    found = 1;\n                    break;\n                }\n            }\n\n            if (!found) {\n                /* referenced bit value does not exist */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                }\n                free(bits);\n                goto error;\n            }\n            c = c + len;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_BITS, value_, bits, &type->info.bits.count) == -1) {\n            free(bits);\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->bit = bits;\n            *val_type = LY_TYPE_BITS;\n        } else {\n            free(bits);\n        }\n        break;\n\n    case LY_TYPE_BOOL:\n        if (value && !strcmp(value, \"true\")) {\n            if (store) {\n                val->bln = 1;\n            }\n        } else if (!value || strcmp(value, \"false\")) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value ? value : \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value ? value : \"\");\n            }\n            goto error;\n        } else {\n            if (store) {\n                val->bln = 0;\n            }\n        }\n\n        if (store) {\n            *val_type = LY_TYPE_BOOL;\n        }\n        break;\n\n    case LY_TYPE_DEC64:\n        if (!value || !value[0]) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        ptr = value;\n        if (parse_range_dec64(&ptr, type->info.dec64.dig, &num) || ptr[0]) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n            }\n            goto error;\n        }\n\n        if (!trusted && validate_length_range(2, 0, 0, num, type->info.dec64.dig, type, value, contextnode)) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_DEC64, value_, &num, &type->info.dec64.dig) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->dec64 = num;\n            *val_type = LY_TYPE_DEC64;\n        }\n        break;\n\n    case LY_TYPE_EMPTY:\n        if (value && value[0]) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n            }\n            goto error;\n        }\n\n        if (store) {\n            *val_type = LY_TYPE_EMPTY;\n        }\n        break;\n\n    case LY_TYPE_ENUM:\n        /* locate enums structure with the enumeration definitions,\n         * since YANG 1.1 allows restricted enums, it is the first\n         * enum type with some explicit enum specification */\n        for (; !type->info.enums.count; type = &type->der->type);\n\n        /* find matching enumeration value */\n        for (i = found = 0; i < type->info.enums.count; i++) {\n            if (value && !strcmp(value, type->info.enums.enm[i].name)) {\n                /* we have match, check if the value is enabled ... */\n                for (j = 0; !trusted && (j < type->info.enums.enm[i].iffeature_size); j++) {\n                    if (!resolve_iffeature(&type->info.enums.enm[i].iffeature[j])) {\n                        if (leaf) {\n                            LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value, itemname);\n                        } else {\n                            LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value);\n                        }\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Enum \\\"%s\\\" is disabled by its %d. if-feature condition.\",\n                               value, j + 1);\n                        goto error;\n                    }\n                }\n                /* ... and store pointer to the definition */\n                if (store) {\n                    val->enm = &type->info.enums.enm[i];\n                    *val_type = LY_TYPE_ENUM;\n                }\n                found = 1;\n                break;\n            }\n        }\n\n        if (!found) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, value ? value : \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, value ? value : \"\");\n            }\n            goto error;\n        }\n        break;\n\n    case LY_TYPE_IDENT:\n        if (!value) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        if (xml) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            /* first, convert value into the json format, silently */\n            value = transform_xml2json(ctx, value, xml, 0, 0);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n            if (!value) {\n                /* invalid identityref format */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n                }\n                goto error;\n            }\n\n            /* the value has no prefix (default namespace), but the element's namespace has a prefix, find default namespace */\n            if (!strchr(value, ':') && xml->ns->prefix) {\n                value = ident_val_add_module_prefix(value, xml, ctx);\n                if (!value) {\n                    goto error;\n                }\n            }\n        } else if (dflt) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            /* the value actually uses module's prefixes instead of the module names as in JSON format,\n             * we have to convert it */\n            value = transform_schema2json(local_mod, value);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n            if (!value) {\n                /* invalid identityref format or it was already transformed, so ignore the error here */\n                value = lydict_insert(ctx, *value_, 0);\n            }\n        } else {\n            value = lydict_insert(ctx, *value_, 0);\n        }\n        /* value is now in the dictionary, whether it differs from *value_ or not */\n\n        ident = resolve_identref(type, value, contextnode, local_mod, dflt);\n        if (!ident) {\n            lydict_remove(ctx, value);\n            goto error;\n        } else if (store) {\n            /* store the result */\n            val->ident = ident;\n            *val_type = LY_TYPE_IDENT;\n        }\n\n        /* the value is always changed and includes prefix */\n        if (dflt) {\n            type->parent->flags |= LYS_DFLTJSON;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_IDENT, &value, (void*)lys_main_module(local_mod)->name, NULL) == -1) {\n            lydict_remove(ctx, value);\n            goto error;\n        }\n\n        /* replace the old value with the new one (even if they may be the same) */\n        lydict_remove(ctx, *value_);\n        *value_ = value;\n        break;\n\n    case LY_TYPE_INST:\n        if (!value) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        if (xml) {\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n            /* first, convert value into the json format, silently */\n            value = transform_xml2json(ctx, value, xml, 1, 1);\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n            if (!value) {\n                /* invalid instance-identifier format */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n                }\n                goto error;\n            } else if (ly_strequal(value, *value_, 1)) {\n                /* we have actually created the same expression (prefixes are the same as the module names)\n                 * so we have just increased dictionary's refcount - fix it */\n                lydict_remove(ctx, value);\n            }\n        } else if (dflt) {\n            /* turn logging off */\n            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n\n            /* the value actually uses module's prefixes instead of the module names as in JSON format,\n             * we have to convert it */\n            value = transform_schema2json(local_mod, value);\n            if (!value) {\n                /* invalid identityref format or it was already transformed, so ignore the error here */\n                value = *value_;\n            } else if (ly_strequal(value, *value_, 1)) {\n                /* we have actually created the same expression (prefixes are the same as the module names)\n                 * so we have just increased dictionary's refcount - fix it */\n                lydict_remove(ctx, value);\n            }\n            /* turn logging back on */\n            ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n        } else {\n            if ((c = make_canonical(ctx, LY_TYPE_INST, &value, NULL, NULL))) {\n                if (c == -1) {\n                    goto error;\n                }\n\n                /* if a change occurred, value was removed from the dictionary so fix the pointers */\n                *value_ = value;\n            }\n        }\n\n        if (store) {\n            /* note that the data node is an unresolved instance-identifier */\n            val->instance = NULL;\n            *val_type = LY_TYPE_INST;\n            *val_flags |= LY_VALUE_UNRES;\n        }\n\n        if (!ly_strequal(value, *value_, 1)) {\n            /* update the changed value */\n            lydict_remove(ctx, *value_);\n            *value_ = value;\n\n            /* we have to remember the conversion into JSON format to be able to print it in correct form */\n            if (dflt) {\n                type->parent->flags |= LYS_DFLTJSON;\n            }\n        }\n        break;\n\n    case LY_TYPE_LEAFREF:\n        if (!value) {\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, \"\");\n            }\n            goto error;\n        }\n\n        /* it is called not only to get the final type, but mainly to update value to canonical or JSON form\n         * if needed */\n        t = lyp_parse_value(&type->info.lref.target->type, value_, xml, leaf, attr, NULL, store, dflt, trusted);\n        value = *value_; /* refresh possibly changed value */\n        if (!t) {\n            /* already logged */\n            goto error;\n        }\n\n        if (store) {\n            /* make the note that the data node is an unresolved leafref (value union was already filled) */\n            *val_flags |= LY_VALUE_UNRES;\n        }\n\n        type = t;\n        break;\n\n    case LY_TYPE_STRING:\n        if (!trusted && validate_length_range(0, (value ? ly_strlen_utf8(value) : 0), 0, 0, 0, type, value, contextnode)) {\n            goto error;\n        }\n\n        if (!trusted && validate_pattern(ctx, value, type, contextnode)) {\n            goto error;\n        }\n\n        /* special handling of ietf-yang-types xpath1.0 */\n        for (tpdf = type->der;\n             tpdf->module && (strcmp(tpdf->name, \"xpath1.0\") || strcmp(tpdf->module->name, \"ietf-yang-types\"));\n             tpdf = tpdf->type.der);\n        if (tpdf->module && xml) {\n            /* convert value into the json format */\n            value = transform_xml2json(ctx, value ? value : \"\", xml, 1, 1);\n            if (!value) {\n                /* invalid instance-identifier format */\n                if (leaf) {\n                    LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_, itemname);\n                } else {\n                    LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n                }\n                goto error;\n            }\n\n            if (!ly_strequal(value, *value_, 1)) {\n                /* update the changed value */\n                lydict_remove(ctx, *value_);\n                *value_ = value;\n            }\n        }\n\n        if (store) {\n            /* store the result */\n            val->string = value;\n            *val_type = LY_TYPE_STRING;\n        }\n        break;\n\n    case LY_TYPE_INT8:\n        if (parse_int(value, __INT64_C(-128), __INT64_C(127), dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT8, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int8 = (int8_t)num;\n            *val_type = LY_TYPE_INT8;\n        }\n        break;\n\n    case LY_TYPE_INT16:\n        if (parse_int(value, __INT64_C(-32768), __INT64_C(32767), dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT16, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int16 = (int16_t)num;\n            *val_type = LY_TYPE_INT16;\n        }\n        break;\n\n    case LY_TYPE_INT32:\n        if (parse_int(value, __INT64_C(-2147483648), __INT64_C(2147483647), dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT32, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int32 = (int32_t)num;\n            *val_type = LY_TYPE_INT32;\n        }\n        break;\n\n    case LY_TYPE_INT64:\n        if (parse_int(value, __INT64_C(-9223372036854775807) - __INT64_C(1), __INT64_C(9223372036854775807),\n                      dflt ? 0 : 10, &num, contextnode)\n                || (!trusted && validate_length_range(1, 0, num, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_INT64, value_, &num, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->int64 = num;\n            *val_type = LY_TYPE_INT64;\n        }\n        break;\n\n    case LY_TYPE_UINT8:\n        if (parse_uint(value, __UINT64_C(255), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT8, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint8 = (uint8_t)unum;\n            *val_type = LY_TYPE_UINT8;\n        }\n        break;\n\n    case LY_TYPE_UINT16:\n        if (parse_uint(value, __UINT64_C(65535), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT16, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint16 = (uint16_t)unum;\n            *val_type = LY_TYPE_UINT16;\n        }\n        break;\n\n    case LY_TYPE_UINT32:\n        if (parse_uint(value, __UINT64_C(4294967295), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT32, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint32 = (uint32_t)unum;\n            *val_type = LY_TYPE_UINT32;\n        }\n        break;\n\n    case LY_TYPE_UINT64:\n        if (parse_uint(value, __UINT64_C(18446744073709551615), dflt ? 0 : 10, &unum, contextnode)\n                || (!trusted && validate_length_range(0, unum, 0, 0, 0, type, value, contextnode))) {\n            goto error;\n        }\n\n        if (make_canonical(ctx, LY_TYPE_UINT64, value_, &unum, NULL) == -1) {\n            goto error;\n        }\n\n        if (store) {\n            /* store the result */\n            val->uint64 = unum;\n            *val_type = LY_TYPE_UINT64;\n        }\n        break;\n\n    case LY_TYPE_UNION:\n        if (store) {\n            /* unresolved union type */\n            memset(val, 0, sizeof(lyd_val));\n            *val_type = LY_TYPE_UNION;\n        }\n\n        if (type->info.uni.has_ptr_type) {\n            /* we are not resolving anything here, only parsing, and in this case we cannot decide\n             * the type without resolving it -> we return the union type (resolve it with resolve_union()) */\n            if (xml) {\n                /* in case it should resolve into a instance-identifier, we can only do the JSON conversion here */\n                ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n                val->string = transform_xml2json(ctx, value, xml, 1, 1);\n                ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n                if (!val->string) {\n                    /* invalid instance-identifier format, likely some other type */\n                    val->string = lydict_insert(ctx, value, 0);\n                }\n            }\n            break;\n        }\n\n        t = NULL;\n        found = 0;\n\n        /* turn logging off, we are going to try to validate the value with all the types in order */\n        ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);\n\n        while ((t = lyp_get_next_union_type(type, t, &found))) {\n            found = 0;\n            ret = lyp_parse_value(t, value_, xml, leaf, attr, NULL, store, dflt, 0);\n            if (ret) {\n                /* we have the result */\n                type = ret;\n                break;\n            }\n\n            if (store) {\n                /* erase possible present and invalid value data */\n                lyd_free_value(*val, *val_type, *val_flags, t, *value_, NULL, NULL, NULL);\n                memset(val, 0, sizeof(lyd_val));\n            }\n        }\n\n        /* turn logging back on */\n        ly_ilo_restore(NULL, prev_ilo, NULL, 0);\n\n        if (!t) {\n            /* not found */\n            if (store) {\n                *val_type = 0;\n            }\n            if (leaf) {\n                LOGVAL(ctx, LYE_INVAL, LY_VLOG_LYD, contextnode, *value_ ? *value_ : \"\", itemname);\n            } else {\n                LOGVAL(ctx, LYE_INMETA, LY_VLOG_LYD, contextnode, \"<none>\", itemname, *value_);\n            }\n            goto error;\n        }\n        break;\n\n    default:\n        LOGINT(ctx);\n        goto error;\n    }\n\n    /* search user types in case this value is supposed to be stored in a custom way */\n    if (store && type->der && type->der->module) {\n        c = lytype_store(type->der->module, type->der->name, value_, val);\n        if (c == -1) {\n            goto error;\n        } else if (!c) {\n            *val_flags |= LY_VALUE_USER;\n        }\n    }\n\n    /* free backup */\n    if (store) {\n        lyd_free_value(old_val, old_val_type, old_val_flags, type, old_val_str, NULL, NULL, NULL);\n        lydict_remove(ctx, old_val_str);\n    }\n    return type;\n\nerror:\n    /* restore the backup */\n    if (store) {\n        *val = old_val;\n        *val_type = old_val_type;\n        *val_flags = old_val_flags;\n        lydict_remove(ctx, old_val_str);\n    }\n    return NULL;\n}\n\n/* does not log, cannot fail */\nstruct lys_type *\nlyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)\n{\n    unsigned int i;\n    struct lys_type *ret = NULL;\n\n    while (!type->info.uni.count) {\n        assert(type->der); /* at least the direct union type has to have type specified */\n        type = &type->der->type;\n    }\n\n    for (i = 0; i < type->info.uni.count; ++i) {\n        if (type->info.uni.types[i].base == LY_TYPE_UNION) {\n            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);\n            if (ret) {\n                break;\n            }\n            continue;\n        }\n\n        if (!prev_type || *found) {\n            ret = &type->info.uni.types[i];\n            break;\n        }\n\n        if (&type->info.uni.types[i] == prev_type) {\n            *found = 1;\n        }\n    }\n\n    return ret;\n}\n\n/* ret 0 - ret set, ret 1 - ret not set, no log, ret -1 - ret not set, fatal error */\nint\nlyp_fill_attr(struct ly_ctx *ctx, struct lyd_node *parent, const char *module_ns, const char *module_name,\n              const char *attr_name, const char *attr_value, struct lyxml_elem *xml, int options, struct lyd_attr **ret)\n{\n    const struct lys_module *mod = NULL;\n    const struct lys_submodule *submod = NULL;\n    struct lys_type **type;\n    struct lyd_attr *dattr;\n    int pos, i, j, k;\n\n    /* first, get module where the annotation should be defined */\n    if (module_ns) {\n        mod = (struct lys_module *)ly_ctx_get_module_by_ns(ctx, module_ns, NULL, 0);\n    } else if (module_name) {\n        mod = (struct lys_module *)ly_ctx_get_module(ctx, module_name, NULL, 0);\n    } else {\n        LOGINT(ctx);\n        return -1;\n    }\n    if (!mod) {\n        return 1;\n    }\n\n    /* then, find the appropriate annotation definition */\n    pos = -1;\n    for (i = 0, j = 0; i < mod->ext_size; i = i + j + 1) {\n        j = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0], &mod->ext[i], mod->ext_size - i);\n        if (j == -1) {\n            break;\n        }\n        if (ly_strequal(mod->ext[i + j]->arg_value, attr_name, 0)) {\n            pos = i + j;\n            break;\n        }\n    }\n\n    /* try submodules */\n    if (pos == -1) {\n        for (k = 0; k < mod->inc_size; ++k) {\n            submod = mod->inc[k].submodule;\n            for (i = 0, j = 0; i < submod->ext_size; i = i + j + 1) {\n                j = lys_ext_instance_presence(&ctx->models.list[0]->extensions[0], &submod->ext[i], submod->ext_size - i);\n                if (j == -1) {\n                    break;\n                }\n                if (ly_strequal(submod->ext[i + j]->arg_value, attr_name, 0)) {\n                    pos = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (pos == -1) {\n        return 1;\n    }\n\n    /* allocate and fill the data attribute structure */\n    dattr = calloc(1, sizeof *dattr);\n    LY_CHECK_ERR_RETURN(!dattr, LOGMEM(ctx), -1);\n\n    dattr->parent = parent;\n    dattr->next = NULL;\n    dattr->annotation = submod ? (struct lys_ext_instance_complex *)submod->ext[pos] :\n                                 (struct lys_ext_instance_complex *)mod->ext[pos];\n    dattr->name = lydict_insert(ctx, attr_name, 0);\n    dattr->value_str = lydict_insert(ctx, attr_value, 0);\n\n    /* the value is here converted to a JSON format if needed in case of LY_TYPE_IDENT and LY_TYPE_INST or to a\n     * canonical form of the value */\n    type = lys_ext_complex_get_substmt(LY_STMT_TYPE, dattr->annotation, NULL);\n    if (!type || !lyp_parse_value(*type, &dattr->value_str, xml, NULL, dattr, NULL, 1, 0, options & LYD_OPT_TRUSTED)) {\n        lydict_remove(ctx, dattr->name);\n        lydict_remove(ctx, dattr->value_str);\n        free(dattr);\n        return -1;\n    }\n\n    *ret = dattr;\n    return 0;\n}\n\nint\nlyp_check_edit_attr(struct ly_ctx *ctx, struct lyd_attr *attr, struct lyd_node *parent, int *editbits)\n{\n    struct lyd_attr *last = NULL;\n    int bits = 0;\n\n    /* 0x01 - insert attribute present\n     * 0x02 - insert is relative (before or after)\n     * 0x04 - value attribute present\n     * 0x08 - key attribute present\n     * 0x10 - operation attribute present\n     * 0x20 - operation not allowing insert attribute (delete or remove)\n     */\n    LY_TREE_FOR(attr, attr) {\n        last = NULL;\n        if (!strcmp(attr->annotation->arg_value, \"operation\") &&\n                !strcmp(attr->annotation->module->name, \"ietf-netconf\")) {\n            if (bits & 0x10) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"operation attributes\", parent->schema->name);\n                return -1;\n            }\n\n            bits |= 0x10;\n            if (attr->value.enm->value >= 3) {\n                /* delete or remove */\n                bits |= 0x20;\n            }\n        } else if (attr->annotation->module == ctx->models.list[1] && /* internal YANG schema */\n                !strcmp(attr->annotation->arg_value, \"insert\")) {\n            /* 'insert' attribute present */\n            if (!(parent->schema->flags & LYS_USERORDERED)) {\n                /* ... but it is not expected */\n                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, \"insert\");\n                return -1;\n            }\n            if (bits & 0x01) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"insert attributes\", parent->schema->name);\n                return -1;\n            }\n\n            bits |= 0x01;\n            if (attr->value.enm->value >= 2) {\n                /* before or after */\n                bits |= 0x02;\n            }\n            last = attr;\n        } else if (attr->annotation->module == ctx->models.list[1] && /* internal YANG schema */\n                !strcmp(attr->annotation->arg_value, \"value\")) {\n            if (bits & 0x04) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"value attributes\", parent->schema->name);\n                return -1;\n            } else if (parent->schema->nodetype & LYS_LIST) {\n                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, attr->name);\n                return -1;\n            }\n            bits |= 0x04;\n            last = attr;\n        } else if (attr->annotation->module == ctx->models.list[1] && /* internal YANG schema */\n                !strcmp(attr->annotation->arg_value, \"key\")) {\n            if (bits & 0x08) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYD, parent, \"key attributes\", parent->schema->name);\n                return -1;\n            } else if (parent->schema->nodetype & LYS_LEAFLIST) {\n                LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, attr->name);\n                return -1;\n            }\n            bits |= 0x08;\n            last = attr;\n        }\n    }\n\n    /* report errors */\n    if (last && (!(parent->schema->nodetype & (LYS_LEAFLIST | LYS_LIST)) || !(parent->schema->flags & LYS_USERORDERED))) {\n        /* moving attributes in wrong elements (not an user ordered list or not a list at all) */\n        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, last->name);\n        return -1;\n    } else if (bits == 3) {\n        /* 0x01 | 0x02 - relative position, but value/key is missing */\n        if (parent->schema->nodetype & LYS_LIST) {\n            LOGVAL(ctx, LYE_MISSATTR, LY_VLOG_LYD, parent, \"key\", parent->schema->name);\n        } else { /* LYS_LEAFLIST */\n            LOGVAL(ctx, LYE_MISSATTR, LY_VLOG_LYD, parent, \"value\", parent->schema->name);\n        }\n        return -1;\n    } else if ((bits & (0x04 | 0x08)) && !(bits & 0x02)) {\n        /* key/value without relative position */\n        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, (bits & 0x04) ? \"value\" : \"key\");\n        return -1;\n    } else if ((bits & 0x21) == 0x21) {\n        /* insert in delete/remove */\n        LOGVAL(ctx, LYE_INATTR, LY_VLOG_LYD, parent, \"insert\");\n        return -1;\n    }\n\n    if (editbits) {\n        *editbits = bits;\n    }\n    return 0;\n}\n\n/* does not log */\nstatic int\ndup_identity_check(const char *id, struct lys_ident *ident, uint32_t size)\n{\n    uint32_t i;\n\n    for (i = 0; i < size; i++) {\n        if (ly_strequal(id, ident[i].name, 1)) {\n            /* name collision */\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\ndup_identities_check(const char *id, struct lys_module *module)\n{\n    struct lys_module *mainmod;\n    int i;\n\n    if (dup_identity_check(id, module->ident, module->ident_size)) {\n        LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"identity\", id);\n        return EXIT_FAILURE;\n    }\n\n    /* check identity in submodules */\n    mainmod = lys_main_module(module);\n    for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; ++i) {\n        if (dup_identity_check(id, mainmod->inc[i].submodule->ident, mainmod->inc[i].submodule->ident_size)) {\n            LOGVAL(module->ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"identity\", id);\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nint\ndup_typedef_check(const char *type, struct lys_tpdf *tpdf, int size)\n{\n    int i;\n\n    for (i = 0; i < size; i++) {\n        if (!strcmp(type, tpdf[i].name)) {\n            /* name collision */\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nstatic int\ndup_feature_check(const char *id, struct lys_module *module)\n{\n    int i;\n\n    for (i = 0; i < module->features_size; i++) {\n        if (!strcmp(id, module->features[i].name)) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* does not log */\nstatic int\ndup_prefix_check(const char *prefix, struct lys_module *module)\n{\n    int i;\n\n    if (module->prefix && !strcmp(module->prefix, prefix)) {\n        return EXIT_FAILURE;\n    }\n    for (i = 0; i < module->imp_size; i++) {\n        if (!strcmp(module->imp[i].prefix, prefix)) {\n            return EXIT_FAILURE;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlyp_check_identifier(struct ly_ctx *ctx, const char *id, enum LY_IDENT type, struct lys_module *module,\n                     struct lys_node *parent)\n{\n    int i, j;\n    int size;\n    struct lys_tpdf *tpdf;\n    struct lys_node *node;\n    struct lys_module *mainmod;\n    struct lys_submodule *submod;\n\n    assert(ctx && id);\n\n    /* check id syntax */\n    if (!(id[0] >= 'A' && id[0] <= 'Z') && !(id[0] >= 'a' && id[0] <= 'z') && id[0] != '_') {\n        LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, \"invalid start character\");\n        return EXIT_FAILURE;\n    }\n    for (i = 1; id[i]; i++) {\n        if (!(id[i] >= 'A' && id[i] <= 'Z') && !(id[i] >= 'a' && id[i] <= 'z')\n                && !(id[i] >= '0' && id[i] <= '9') && id[i] != '_' && id[i] != '-' && id[i] != '.') {\n            LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, \"invalid character\");\n            return EXIT_FAILURE;\n        }\n    }\n\n    if (i > 64) {\n        LOGWRN(ctx, \"Identifier \\\"%s\\\" is long, you should use something shorter.\", id);\n    }\n\n    switch (type) {\n    case LY_IDENT_NAME:\n        /* check uniqueness of the node within its siblings */\n        if (!parent) {\n            break;\n        }\n\n        LY_TREE_FOR(parent->child, node) {\n            if (ly_strequal(node->name, id, 1)) {\n                LOGVAL(ctx, LYE_INID, LY_VLOG_NONE, NULL, id, \"name duplication\");\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n    case LY_IDENT_TYPE:\n        assert(module);\n        mainmod = lys_main_module(module);\n\n        /* check collision with the built-in types */\n        if (!strcmp(id, \"binary\") || !strcmp(id, \"bits\") ||\n                !strcmp(id, \"boolean\") || !strcmp(id, \"decimal64\") ||\n                !strcmp(id, \"empty\") || !strcmp(id, \"enumeration\") ||\n                !strcmp(id, \"identityref\") || !strcmp(id, \"instance-identifier\") ||\n                !strcmp(id, \"int8\") || !strcmp(id, \"int16\") ||\n                !strcmp(id, \"int32\") || !strcmp(id, \"int64\") ||\n                !strcmp(id, \"leafref\") || !strcmp(id, \"string\") ||\n                !strcmp(id, \"uint8\") || !strcmp(id, \"uint16\") ||\n                !strcmp(id, \"uint32\") || !strcmp(id, \"uint64\") || !strcmp(id, \"union\")) {\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, id, \"typedef\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Typedef name duplicates a built-in type.\");\n            return EXIT_FAILURE;\n        }\n\n        /* check locally scoped typedefs (avoid name shadowing) */\n        for (; parent; parent = lys_parent(parent)) {\n            switch (parent->nodetype) {\n            case LYS_CONTAINER:\n                size = ((struct lys_node_container *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_container *)parent)->tpdf;\n                break;\n            case LYS_LIST:\n                size = ((struct lys_node_list *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_list *)parent)->tpdf;\n                break;\n            case LYS_GROUPING:\n                size = ((struct lys_node_grp *)parent)->tpdf_size;\n                tpdf = ((struct lys_node_grp *)parent)->tpdf;\n                break;\n            default:\n                continue;\n            }\n\n            if (dup_typedef_check(id, tpdf, size)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"typedef\", id);\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* check top-level names */\n        if (dup_typedef_check(id, module->tpdf, module->tpdf_size)) {\n            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"typedef\", id);\n            return EXIT_FAILURE;\n        }\n\n        /* check submodule's top-level names */\n        for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; i++) {\n            if (dup_typedef_check(id, mainmod->inc[i].submodule->tpdf, mainmod->inc[i].submodule->tpdf_size)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"typedef\", id);\n                return EXIT_FAILURE;\n            }\n        }\n\n        break;\n    case LY_IDENT_PREFIX:\n        assert(module);\n\n        /* check the module itself */\n        if (dup_prefix_check(id, module)) {\n            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"prefix\", id);\n            return EXIT_FAILURE;\n        }\n        break;\n    case LY_IDENT_FEATURE:\n        assert(module);\n        mainmod = lys_main_module(module);\n\n        /* check feature name uniqueness*/\n        /* check features in the current module */\n        if (dup_feature_check(id, module)) {\n            LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"feature\", id);\n            return EXIT_FAILURE;\n        }\n\n        /* and all its submodules */\n        for (i = 0; i < mainmod->inc_size && mainmod->inc[i].submodule; i++) {\n            if (dup_feature_check(id, (struct lys_module *)mainmod->inc[i].submodule)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"feature\", id);\n                return EXIT_FAILURE;\n            }\n        }\n        break;\n\n    case LY_IDENT_EXTENSION:\n        assert(module);\n        mainmod = lys_main_module(module);\n\n        /* check extension name uniqueness in the main module ... */\n        for (i = 0; i < mainmod->extensions_size; i++) {\n            if (ly_strequal(id, mainmod->extensions[i].name, 1)) {\n                LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"extension\", id);\n                return EXIT_FAILURE;\n            }\n        }\n\n        /* ... and all its submodules */\n        for (j = 0; j < mainmod->inc_size && mainmod->inc[j].submodule; j++) {\n            submod = mainmod->inc[j].submodule; /* shortcut */\n            for (i = 0; i < submod->extensions_size; i++) {\n                if (ly_strequal(id, submod->extensions[i].name, 1)) {\n                    LOGVAL(ctx, LYE_DUPID, LY_VLOG_NONE, NULL, \"extension\", id);\n                    return EXIT_FAILURE;\n                }\n            }\n        }\n\n        break;\n\n    default:\n        /* no check required */\n        break;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/* logs directly */\nint\nlyp_check_date(struct ly_ctx *ctx, const char *date)\n{\n    int i;\n    struct tm tm, tm_;\n    char *r;\n\n    assert(date);\n\n    /* check format */\n    for (i = 0; i < LY_REV_SIZE - 1; i++) {\n        if (i == 4 || i == 7) {\n            if (date[i] != '-') {\n                goto error;\n            }\n        } else if (!isdigit(date[i])) {\n            goto error;\n        }\n    }\n\n    /* check content, e.g. 2018-02-31 */\n    memset(&tm, 0, sizeof tm);\n    r = strptime(date, \"%Y-%m-%d\", &tm);\n    if (!r || r != &date[LY_REV_SIZE - 1]) {\n        goto error;\n    }\n    /* set some arbitrary non-0 value in case DST changes, it could move the day otherwise */\n    tm.tm_hour = 12;\n\n    memcpy(&tm_, &tm, sizeof tm);\n    mktime(&tm_); /* mktime modifies tm_ if it refers invalid date */\n    if (tm.tm_mday != tm_.tm_mday) { /* e.g 2018-02-29 -> 2018-03-01 */\n        /* checking days is enough, since other errors\n         * have been checked by strptime() */\n        goto error;\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    LOGVAL(ctx, LYE_INDATE, LY_VLOG_NONE, NULL, date);\n    return EXIT_FAILURE;\n}\n\n/**\n * @return\n * NULL - success\n * root - not yet resolvable\n * other node - mandatory node under the root\n */\nstatic const struct lys_node *\nlyp_check_mandatory_(const struct lys_node *root)\n{\n    int mand_flag = 0;\n    const struct lys_node *iter = NULL;\n\n    while ((iter = lys_getnext(iter, root, NULL, LYS_GETNEXT_WITHCHOICE | LYS_GETNEXT_WITHUSES | LYS_GETNEXT_INTOUSES\n            | LYS_GETNEXT_INTONPCONT | LYS_GETNEXT_NOSTATECHECK))) {\n        if (iter->nodetype == LYS_USES) {\n            if (!((struct lys_node_uses *)iter)->grp) {\n                /* not yet resolved uses */\n                return root;\n            } else {\n                /* go into uses */\n                continue;\n            }\n        }\n        if (iter->nodetype == LYS_CHOICE) {\n            /* skip it, it was already checked for direct mandatory node in default */\n            continue;\n        }\n        if (iter->nodetype == LYS_LIST) {\n            if (((struct lys_node_list *)iter)->min) {\n                mand_flag = 1;\n            }\n        } else if (iter->nodetype == LYS_LEAFLIST) {\n            if (((struct lys_node_leaflist *)iter)->min) {\n                mand_flag = 1;\n            }\n        } else if (iter->flags & LYS_MAND_TRUE) {\n            mand_flag = 1;\n        }\n\n        if (mand_flag) {\n            return iter;\n        }\n    }\n\n    return NULL;\n}\n\n/* logs directly */\nint\nlyp_check_mandatory_augment(struct lys_node_augment *aug, const struct lys_node *target)\n{\n    const struct lys_node *node;\n\n    if (aug->when || target->nodetype == LYS_CHOICE) {\n        /* - mandatory nodes in new cases are ok;\n         * clarification from YANG 1.1 - augmentation can add mandatory nodes when it is\n         * conditional with a when statement */\n        return EXIT_SUCCESS;\n    }\n\n    if ((node = lyp_check_mandatory_((struct lys_node *)aug))) {\n        if (node != (struct lys_node *)aug) {\n            LOGVAL(target->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(target->module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                   \"Mandatory node \\\"%s\\\" appears in augment of \\\"%s\\\" without when condition.\",\n                   node->name, aug->target_name);\n            return -1;\n        }\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief check that a mandatory node is not directly under the default case.\n * @param[in] node choice with default node\n * @return EXIT_SUCCESS if the constraint is fulfilled, EXIT_FAILURE otherwise\n */\nint\nlyp_check_mandatory_choice(struct lys_node *node)\n{\n    const struct lys_node *mand, *dflt = ((struct lys_node_choice *)node)->dflt;\n\n    if ((mand = lyp_check_mandatory_(dflt))) {\n        if (mand != dflt) {\n            LOGVAL(node->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, \"mandatory\");\n            LOGVAL(node->module->ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                   \"Mandatory node \\\"%s\\\" is directly under the default case \\\"%s\\\" of the \\\"%s\\\" choice.\",\n                   mand->name, dflt->name, node->name);\n            return -1;\n        }\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/**\n * @brief Check status for invalid combination.\n *\n * @param[in] flags1 Flags of the referencing node.\n * @param[in] mod1 Module of the referencing node,\n * @param[in] name1 Schema node name of the referencing node.\n * @param[in] flags2 Flags of the referenced node.\n * @param[in] mod2 Module of the referenced node,\n * @param[in] name2 Schema node name of the referenced node.\n * @return EXIT_SUCCES on success, EXIT_FAILURE on invalid reference.\n */\nint\nlyp_check_status(uint16_t flags1, struct lys_module *mod1, const char *name1,\n                 uint16_t flags2, struct lys_module *mod2, const char *name2,\n                 const struct lys_node *node)\n{\n    uint16_t flg1, flg2;\n\n    flg1 = (flags1 & LYS_STATUS_MASK) ? (flags1 & LYS_STATUS_MASK) : LYS_STATUS_CURR;\n    flg2 = (flags2 & LYS_STATUS_MASK) ? (flags2 & LYS_STATUS_MASK) : LYS_STATUS_CURR;\n\n    if ((flg1 < flg2) && (lys_main_module(mod1) == lys_main_module(mod2))) {\n        LOGVAL(mod1->ctx, LYE_INSTATUS, node ? LY_VLOG_LYS : LY_VLOG_NONE, node,\n               flg1 == LYS_STATUS_CURR ? \"current\" : \"deprecated\", name1, \"references\",\n               flg2 == LYS_STATUS_OBSLT ? \"obsolete\" : \"deprecated\", name2);\n        return EXIT_FAILURE;\n    }\n\n    return EXIT_SUCCESS;\n}\n\nvoid\nlyp_del_includedup(struct lys_module *mod, int free_subs)\n{\n    struct ly_modules_list *models = &mod->ctx->models;\n    uint8_t i;\n\n    assert(mod && !mod->type);\n\n    if (models->parsed_submodules_count) {\n        for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i);\n        if (models->parsed_submodules[i] == mod) {\n            if (free_subs) {\n                for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i) {\n                    lys_sub_module_remove_devs_augs((struct lys_module *)models->parsed_submodules[i]);\n                    lys_submodule_module_data_free((struct lys_submodule *)models->parsed_submodules[i]);\n                    lys_submodule_free((struct lys_submodule *)models->parsed_submodules[i], NULL);\n                }\n            }\n\n            models->parsed_submodules_count = i;\n            if (!models->parsed_submodules_count) {\n                free(models->parsed_submodules);\n                models->parsed_submodules = NULL;\n            }\n        }\n    }\n}\n\nstatic void\nlyp_add_includedup(struct lys_module *sub_mod, struct lys_submodule *parsed_submod)\n{\n    struct ly_modules_list *models = &sub_mod->ctx->models;\n    int16_t i;\n\n    /* store main module if first include */\n    if (models->parsed_submodules_count) {\n        for (i = models->parsed_submodules_count - 1; models->parsed_submodules[i]->type; --i);\n    } else {\n        i = -1;\n    }\n    if ((i == -1) || (models->parsed_submodules[i] != lys_main_module(sub_mod))) {\n        ++models->parsed_submodules_count;\n        models->parsed_submodules = ly_realloc(models->parsed_submodules,\n                                               models->parsed_submodules_count * sizeof *models->parsed_submodules);\n        LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );\n        models->parsed_submodules[models->parsed_submodules_count - 1] = lys_main_module(sub_mod);\n    }\n\n    /* store parsed submodule */\n    ++models->parsed_submodules_count;\n    models->parsed_submodules = ly_realloc(models->parsed_submodules,\n                                           models->parsed_submodules_count * sizeof *models->parsed_submodules);\n    LY_CHECK_ERR_RETURN(!models->parsed_submodules, LOGMEM(sub_mod->ctx), );\n    models->parsed_submodules[models->parsed_submodules_count - 1] = (struct lys_module *)parsed_submod;\n}\n\n/*\n * types: 0 - include, 1 - import\n */\nstatic int\nlyp_check_circmod(struct lys_module *module, const char *value, int type)\n{\n    LY_ECODE code = type ? LYE_CIRC_IMPORTS : LYE_CIRC_INCLUDES;\n    struct ly_modules_list *models = &module->ctx->models;\n    uint8_t i;\n\n    /* include/import itself */\n    if (ly_strequal(module->name, value, 1)) {\n        LOGVAL(module->ctx, code, LY_VLOG_NONE, NULL, value);\n        return -1;\n    }\n\n    /* currently parsed modules */\n    for (i = 0; i < models->parsing_sub_modules_count; i++) {\n        if (ly_strequal(models->parsing_sub_modules[i]->name, value, 1)) {\n            LOGVAL(module->ctx, code, LY_VLOG_NONE, NULL, value);\n            return -1;\n        }\n    }\n\n    return 0;\n}\n\nint\nlyp_check_circmod_add(struct lys_module *module)\n{\n    struct ly_modules_list *models = &module->ctx->models;\n\n    /* storing - enlarge the list of modules being currently parsed */\n    ++models->parsing_sub_modules_count;\n    models->parsing_sub_modules = ly_realloc(models->parsing_sub_modules,\n                                             models->parsing_sub_modules_count * sizeof *models->parsing_sub_modules);\n    LY_CHECK_ERR_RETURN(!models->parsing_sub_modules, LOGMEM(module->ctx), -1);\n    models->parsing_sub_modules[models->parsing_sub_modules_count - 1] = module;\n\n    return 0;\n}\n\nvoid\nlyp_check_circmod_pop(struct ly_ctx *ctx)\n{\n    if (!ctx->models.parsing_sub_modules_count) {\n        LOGINT(ctx);\n        return;\n    }\n\n    /* update the list of currently being parsed modules */\n    ctx->models.parsing_sub_modules_count--;\n    if (!ctx->models.parsing_sub_modules_count) {\n        free(ctx->models.parsing_sub_modules);\n        ctx->models.parsing_sub_modules = NULL;\n    }\n}\n\n/*\n * -1 - error - invalid duplicities)\n *  0 - success, no duplicity\n *  1 - success, valid duplicity found and stored in *sub\n */\nstatic int\nlyp_check_includedup(struct lys_module *mod, const char *name, struct lys_include *inc, struct lys_submodule **sub)\n{\n    struct lys_module **parsed_sub = mod->ctx->models.parsed_submodules;\n    uint8_t i, parsed_sub_count = mod->ctx->models.parsed_submodules_count;\n\n    assert(sub);\n\n    for (i = 0; i < mod->inc_size; ++i) {\n        if (ly_strequal(mod->inc[i].submodule->name, name, 1)) {\n            /* the same module is already included in the same module - error */\n            LOGVAL(mod->ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, \"include\");\n            LOGVAL(mod->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Submodule \\\"%s\\\" included twice in the same module \\\"%s\\\".\",\n                   name, mod->name);\n            return -1;\n        }\n    }\n\n    if (parsed_sub_count) {\n        assert(!parsed_sub[0]->type);\n        for (i = parsed_sub_count - 1; parsed_sub[i]->type; --i) {\n            if (ly_strequal(parsed_sub[i]->name, name, 1)) {\n                /* check revisions, including multiple revisions of a single module is error */\n                if (inc->rev[0] && (!parsed_sub[i]->rev_size || strcmp(parsed_sub[i]->rev[0].date, inc->rev))) {\n                    /* the already included submodule has\n                     * - no revision, but here we require some\n                     * - different revision than the one required here */\n                    LOGVAL(mod->ctx, LYE_INARG, LY_VLOG_NONE, NULL, name, \"include\");\n                    LOGVAL(mod->ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Including multiple revisions of submodule \\\"%s\\\".\", name);\n                    return -1;\n                }\n\n                /* the same module is already included in some other submodule, return it */\n                (*sub) = (struct lys_submodule *)parsed_sub[i];\n                return 1;\n            }\n        }\n    }\n\n    /* no duplicity found */\n    return 0;\n}\n\n/* returns:\n *  0 - inc successfully filled\n * -1 - error\n */\nint\nlyp_check_include(struct lys_module *module, const char *value, struct lys_include *inc, struct unres_schema *unres)\n{\n    int i;\n\n    /* check that the submodule was not included yet */\n    i = lyp_check_includedup(module, value, inc, &inc->submodule);\n    if (i == -1) {\n        return -1;\n    } else if (i == 1) {\n        return 0;\n    }\n    /* submodule is not yet loaded */\n\n    /* circular include check */\n    if (lyp_check_circmod(module, value, 0)) {\n        return -1;\n    }\n\n    /* try to load the submodule */\n    inc->submodule = (struct lys_submodule *)ly_ctx_load_sub_module(module->ctx, module, value,\n                                                                    inc->rev[0] ? inc->rev : NULL, 1, unres);\n\n    /* check the result */\n    if (!inc->submodule) {\n        if (ly_errno != LY_EVALID) {\n            LOGVAL(module->ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"include\");\n        }\n        LOGERR(module->ctx, LY_EVALID, \"Including \\\"%s\\\" module into \\\"%s\\\" failed.\", value, module->name);\n        return -1;\n    }\n\n    /* check the revision */\n    if (inc->rev[0] && inc->submodule->rev_size && strcmp(inc->rev, inc->submodule->rev[0].date)) {\n        LOGERR(module->ctx, LY_EVALID, \"\\\"%s\\\" include of submodule \\\"%s\\\" in revision \\\"%s\\\" not found.\",\n               module->name, value, inc->rev);\n        unres_schema_free((struct lys_module *)inc->submodule, &unres, 0);\n        lys_sub_module_remove_devs_augs((struct lys_module *)inc->submodule);\n        lys_submodule_module_data_free((struct lys_submodule *)inc->submodule);\n        lys_submodule_free(inc->submodule, NULL);\n        inc->submodule = NULL;\n        return -1;\n    }\n\n    /* store the submodule as successfully parsed */\n    lyp_add_includedup(module, inc->submodule);\n\n    return 0;\n}\n\nstatic int\nlyp_check_include_missing_recursive(struct lys_module *main_module, struct lys_submodule *sub)\n{\n    uint8_t i, j;\n    void *reallocated;\n    int ret = 0, tmp;\n    struct ly_ctx *ctx = main_module->ctx;\n\n    for (i = 0; i < sub->inc_size; i++) {\n        /* check that the include is also present in the main module */\n        for (j = 0; j < main_module->inc_size; j++) {\n            if (main_module->inc[j].submodule == sub->inc[i].submodule) {\n                break;\n            }\n        }\n\n        if (j == main_module->inc_size) {\n            /* match not found */\n            if (main_module->version >= LYS_VERSION_1_1) {\n                LOGVAL(ctx, LYE_MISSSTMT, LY_VLOG_NONE, NULL, \"include\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL,\n                       \"The main module \\\"%s\\\" misses include of the \\\"%s\\\" submodule used in another submodule \\\"%s\\\".\",\n                       main_module->name, sub->inc[i].submodule->name, sub->name);\n                /* now we should return error, but due to the issues with freeing the module, we actually have\n                 * to go through the all includes and, as in case of 1.0, add them into the main module and fail\n                 * at the end when all the includes are in the main module and we can free them */\n                ret = 1;\n            } else {\n                /* not strictly an error in YANG 1.0 */\n                LOGWRN(ctx, \"The main module \\\"%s\\\" misses include of the \\\"%s\\\" submodule used in another submodule \\\"%s\\\".\",\n                       main_module->name, sub->inc[i].submodule->name, sub->name);\n                LOGWRN(ctx, \"To avoid further issues, adding submodule \\\"%s\\\" into the main module \\\"%s\\\".\",\n                       sub->inc[i].submodule->name, main_module->name);\n                /* but since it is a good practise and because we expect all the includes in the main module\n                 * when searching it and also when freeing the module, put it into it */\n            }\n            main_module->inc_size++;\n            reallocated = realloc(main_module->inc, main_module->inc_size * sizeof *main_module->inc);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx), 1);\n            main_module->inc = reallocated;\n            memset(&main_module->inc[main_module->inc_size - 1], 0, sizeof *main_module->inc);\n            /* to avoid unexpected consequences, copy just a link to the submodule and the revision,\n             * all other substatements of the include are ignored */\n            memcpy(&main_module->inc[main_module->inc_size - 1].rev, sub->inc[i].rev, LY_REV_SIZE - 1);\n            main_module->inc[main_module->inc_size - 1].submodule = sub->inc[i].submodule;\n        }\n\n        /* recursion */\n        tmp = lyp_check_include_missing_recursive(main_module, sub->inc[i].submodule);\n        if (!ret && tmp) {\n            ret = 1;\n        }\n    }\n\n    return ret;\n}\n\nint\nlyp_check_include_missing(struct lys_module *main_module)\n{\n    int ret = 0;\n    uint8_t i;\n\n    /* in YANG 1.1, all the submodules must be in the main module, check it even for\n     * 1.0 where it will be printed as warning and the include will be added into the main module */\n    for (i = 0; i < main_module->inc_size; i++) {\n        if (lyp_check_include_missing_recursive(main_module, main_module->inc[i].submodule)) {\n            ret = 1;\n        }\n    }\n\n    return ret;\n}\n\n/* returns:\n *  0 - imp successfully filled\n * -1 - error, imp not cleaned\n */\nint\nlyp_check_import(struct lys_module *module, const char *value, struct lys_import *imp)\n{\n    int i;\n    struct lys_module *dup = NULL;\n    struct ly_ctx *ctx = module->ctx;\n\n    /* check for importing a single module in multiple revisions */\n    for (i = 0; i < module->imp_size; i++) {\n        if (!module->imp[i].module) {\n            /* skip the not yet filled records */\n            continue;\n        }\n        if (ly_strequal(module->imp[i].module->name, value, 1)) {\n            /* check revisions, including multiple revisions of a single module is error */\n            if (imp->rev[0] && (!module->imp[i].module->rev_size || strcmp(module->imp[i].module->rev[0].date, imp->rev))) {\n                /* the already imported module has\n                 * - no revision, but here we require some\n                 * - different revision than the one required here */\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"import\");\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Importing multiple revisions of module \\\"%s\\\".\", value);\n                return -1;\n            } else if (!imp->rev[0]) {\n                /* no revision, remember the duplication, but check revisions after loading the module\n                 * because the current revision can be the same (then it is ok) or it can differ (then it\n                 * is error */\n                dup = module->imp[i].module;\n                break;\n            }\n\n            /* there is duplication, but since prefixes differs (checked in caller of this function),\n             * it is ok */\n            imp->module = module->imp[i].module;\n            return 0;\n        }\n    }\n\n    /* circular import check */\n    if (lyp_check_circmod(module, value, 1)) {\n        return -1;\n    }\n\n    /* load module - in specific situations it tries to get the module from the context */\n    imp->module = (struct lys_module *)ly_ctx_load_sub_module(module->ctx, NULL, value, imp->rev[0] ? imp->rev : NULL,\n                                                              module->ctx->models.flags & LY_CTX_ALLIMPLEMENTED ? 1 : 0,\n                                                              NULL);\n\n    /* check the result */\n    if (!imp->module) {\n        LOGERR(ctx, LY_EVALID, \"Importing \\\"%s\\\" module into \\\"%s\\\" failed.\", value, module->name);\n        return -1;\n    }\n\n    if (imp->rev[0] && imp->module->rev_size && strcmp(imp->rev, imp->module->rev[0].date)) {\n        LOGERR(ctx, LY_EVALID, \"\\\"%s\\\" import of module \\\"%s\\\" in revision \\\"%s\\\" not found.\",\n               module->name, value, imp->rev);\n        return -1;\n    }\n\n    if (dup) {\n        /* check the revisions */\n        if ((dup != imp->module) ||\n                (dup->rev_size != imp->module->rev_size && (!dup->rev_size || imp->module->rev_size)) ||\n                (dup->rev_size && strcmp(dup->rev[0].date, imp->module->rev[0].date))) {\n            /* - modules are not the same\n             * - one of modules has no revision (except they both has no revision)\n             * - revisions of the modules are not the same */\n            LOGVAL(ctx, LYE_INARG, LY_VLOG_NONE, NULL, value, \"import\");\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Importing multiple revisions of module \\\"%s\\\".\", value);\n            return -1;\n        } else {\n            LOGWRN(ctx, \"Module \\\"%s\\\" is imported by \\\"%s\\\" multiple times with different prefixes.\", dup->name, module->name);\n        }\n    }\n\n    return 0;\n}\n\n/*\n * put the newest revision to the first position\n */\nvoid\nlyp_sort_revisions(struct lys_module *module)\n{\n    uint8_t i, r;\n    struct lys_revision rev;\n\n    for (i = 1, r = 0; i < module->rev_size; i++) {\n        if (strcmp(module->rev[i].date, module->rev[r].date) > 0) {\n            r = i;\n        }\n    }\n\n    if (r) {\n        /* the newest revision is not on position 0, switch them */\n        memcpy(&rev, &module->rev[0], sizeof rev);\n        memcpy(&module->rev[0], &module->rev[r], sizeof rev);\n        memcpy(&module->rev[r], &rev, sizeof rev);\n    }\n}\n\nvoid\nlyp_ext_instance_rm(struct ly_ctx *ctx, struct lys_ext_instance ***ext, uint8_t *size, uint8_t index)\n{\n    uint8_t i;\n\n    lys_extension_instances_free(ctx, (*ext)[index]->ext, (*ext)[index]->ext_size, NULL);\n    lydict_remove(ctx, (*ext)[index]->arg_value);\n    free((*ext)[index]);\n\n    /* move the rest of the array */\n    for (i = index + 1; i < (*size); i++) {\n        (*ext)[i - 1] = (*ext)[i];\n    }\n    /* clean the last cell in the array structure */\n    (*ext)[(*size) - 1] = NULL;\n    /* the array is not reallocated here, just change its size */\n    (*size) = (*size) - 1;\n\n    if (!(*size)) {\n        /* ext array is empty */\n        free((*ext));\n        ext = NULL;\n    }\n}\n\nstatic int\nlyp_rfn_apply_ext_(struct lys_refine *rfn, struct lys_node *target, LYEXT_SUBSTMT substmt, struct lys_ext *extdef)\n{\n    struct ly_ctx *ctx;\n    int m, n;\n    struct lys_ext_instance *new;\n    void *reallocated;\n\n    ctx = target->module->ctx; /* shortcut */\n\n    m = n = -1;\n    while ((m = lys_ext_iter(rfn->ext, rfn->ext_size, m + 1, substmt)) != -1) {\n        /* refine's substatement includes extensions, copy them to the target, replacing the previous\n         * substatement's extensions if any. In case of refining the extension itself, we are going to\n         * replace only the same extension (pointing to the same definition) */\n        if (substmt == LYEXT_SUBSTMT_SELF && rfn->ext[m]->def != extdef) {\n            continue;\n        }\n\n        /* get the index of the extension to replace in the target node */\n        do {\n            n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt);\n        } while (n != -1 && substmt == LYEXT_SUBSTMT_SELF && target->ext[n]->def != extdef);\n\n        /* TODO cover complex extension instances */\n        if (n == -1) {\n            /* nothing to replace, we are going to add it - reallocate */\n            new = malloc(sizeof **target->ext);\n            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n            reallocated = realloc(target->ext, (target->ext_size + 1) * sizeof *target->ext);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx); free(new), EXIT_FAILURE);\n            target->ext = reallocated;\n            target->ext_size++;\n\n            /* init */\n            n = target->ext_size - 1;\n            target->ext[n] = new;\n            target->ext[n]->parent = target;\n            target->ext[n]->parent_type = LYEXT_PAR_NODE;\n            target->ext[n]->flags = 0;\n            target->ext[n]->insubstmt = substmt;\n            target->ext[n]->priv = NULL;\n            target->ext[n]->nodetype = LYS_EXT;\n            target->ext[n]->module = target->module;\n        } else {\n            /* replacing - first remove the allocated data from target */\n            lys_extension_instances_free(ctx, target->ext[n]->ext, target->ext[n]->ext_size, NULL);\n            lydict_remove(ctx, target->ext[n]->arg_value);\n        }\n        /* common part for adding and replacing */\n        target->ext[n]->def = rfn->ext[m]->def;\n        /* parent and parent_type do not change */\n        target->ext[n]->arg_value = lydict_insert(ctx, rfn->ext[m]->arg_value, 0);\n        /* flags do not change */\n        target->ext[n]->ext_size = rfn->ext[m]->ext_size;\n        lys_ext_dup(ctx, target->module, rfn->ext[m]->ext, rfn->ext[m]->ext_size, target, LYEXT_PAR_NODE,\n                    &target->ext[n]->ext, 0, NULL);\n        /* substmt does not change, but the index must be taken from the refine */\n        target->ext[n]->insubstmt_index = rfn->ext[m]->insubstmt_index;\n    }\n\n    /* remove the rest of extensions belonging to the original substatement in the target node */\n    while ((n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt)) != -1) {\n        if (substmt == LYEXT_SUBSTMT_SELF && target->ext[n]->def != extdef) {\n            /* keep this extension */\n            continue;\n        }\n\n        /* remove the item */\n        lyp_ext_instance_rm(ctx, &target->ext, &target->ext_size, n);\n        --n;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * apply extension instances defined under refine's substatements.\n * It cannot be done immediately when applying the refine because there can be\n * still unresolved data (e.g. type) and mainly the targeted extension instances.\n */\nint\nlyp_rfn_apply_ext(struct lys_module *module)\n{\n    int i, k, a = 0;\n    struct lys_node *root, *nextroot, *next, *node;\n    struct lys_node *target;\n    struct lys_node_uses *uses;\n    struct lys_refine *rfn;\n    struct ly_set *extset;\n\n    /* refines in uses */\n    LY_TREE_FOR_SAFE(module->data, nextroot, root) {\n        /* go through the data tree of the module and all the defined augments */\n\n        LY_TREE_DFS_BEGIN(root, next, node) {\n            if (node->nodetype == LYS_USES) {\n                uses = (struct lys_node_uses *)node;\n\n                for (i = 0; i < uses->refine_size; i++) {\n                    if (!uses->refine[i].ext_size) {\n                        /* no extensions in refine */\n                        continue;\n                    }\n                    rfn = &uses->refine[i]; /* shortcut */\n\n                    /* get the target node */\n                    target = NULL;\n                    resolve_descendant_schema_nodeid(rfn->target_name, uses->child,\n                                                     LYS_NO_RPC_NOTIF_NODE | LYS_ACTION | LYS_NOTIF,\n                                                     0, (const struct lys_node **)&target);\n                    if (!target) {\n                        /* it should always succeed since the target_name was already resolved at least\n                         * once when the refine itself was being resolved */\n                        LOGINT(module->ctx);;\n                        return EXIT_FAILURE;\n                    }\n\n                    /* extensions */\n                    extset = ly_set_new();\n                    k = -1;\n                    while ((k = lys_ext_iter(rfn->ext, rfn->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {\n                        ly_set_add(extset, rfn->ext[k]->def, 0);\n                    }\n                    for (k = 0; (unsigned int)k < extset->number; k++) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_SELF, (struct lys_ext *)extset->set.g[k])) {\n                            ly_set_free(extset);\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    ly_set_free(extset);\n\n                    /* description */\n                    if (rfn->dsc && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_DESCRIPTION, NULL)) {\n                        return EXIT_FAILURE;\n                    }\n                    /* reference */\n                    if (rfn->ref && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_REFERENCE, NULL)) {\n                        return EXIT_FAILURE;\n                    }\n                    /* config, in case of notification or rpc/action{notif, the config is not applicable\n                     * (there is no config status) */\n                    if ((rfn->flags & LYS_CONFIG_MASK) && (target->flags & LYS_CONFIG_MASK)) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_CONFIG, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* default value */\n                    if (rfn->dflt_size && lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_DEFAULT, NULL)) {\n                        return EXIT_FAILURE;\n                    }\n                    /* mandatory */\n                    if (rfn->flags & LYS_MAND_MASK) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MANDATORY, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* presence */\n                    if ((target->nodetype & LYS_CONTAINER) && rfn->mod.presence) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_PRESENCE, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* min/max */\n                    if (rfn->flags & LYS_RFN_MINSET) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MIN, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    if (rfn->flags & LYS_RFN_MAXSET) {\n                        if (lyp_rfn_apply_ext_(rfn, target, LYEXT_SUBSTMT_MAX, NULL)) {\n                            return EXIT_FAILURE;\n                        }\n                    }\n                    /* must and if-feature contain extensions on their own, not needed to be solved here */\n\n                    if (target->ext_size) {\n                        /* the allocated target's extension array can be now longer than needed in case\n                         * there is less refine substatement's extensions than in original. Since we are\n                         * going to reduce or keep the same memory, it is not necessary to test realloc's result */\n                        target->ext = realloc(target->ext, target->ext_size * sizeof *target->ext);\n                    }\n                }\n            }\n            LY_TREE_DFS_END(root, next, node)\n        }\n\n        if (!nextroot && a < module->augment_size) {\n            nextroot = module->augment[a].child;\n            a++;\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * check mandatory substatements defined under extension instances.\n */\nint\nlyp_mand_check_ext(struct lys_ext_instance_complex *ext, const char *ext_name)\n{\n    void *p;\n    int i;\n    struct ly_ctx *ctx = ext->module->ctx;\n\n    /* check for mandatory substatements */\n    for (i = 0; ext->substmt[i].stmt; i++) {\n        if (ext->substmt[i].cardinality == LY_STMT_CARD_OPT || ext->substmt[i].cardinality == LY_STMT_CARD_ANY) {\n            /* not a mandatory */\n            continue;\n        } else if (ext->substmt[i].cardinality == LY_STMT_CARD_SOME) {\n            goto array;\n        }\n\n        /*\n         * LY_STMT_ORDEREDBY - not checked, has a default value which is the same as explicit system order\n         * LY_STMT_MODIFIER, LY_STMT_STATUS, LY_STMT_MANDATORY, LY_STMT_CONFIG - checked, but mandatory requirement\n         * does not make sense since there is also a default value specified\n         */\n        switch(ext->substmt[i].stmt) {\n        case LY_STMT_ORDEREDBY:\n            /* always ok */\n            break;\n        case LY_STMT_REQINSTANCE:\n        case LY_STMT_DIGITS:\n        case LY_STMT_MODIFIER:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!*(uint8_t*)p) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        case LY_STMT_STATUS:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(uint16_t*)p & LYS_STATUS_MASK)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        case LY_STMT_MANDATORY:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(uint16_t*)p & LYS_MAND_MASK)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        case LY_STMT_CONFIG:\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(uint16_t*)p & LYS_CONFIG_MASK)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        default:\narray:\n            /* stored as a pointer */\n            p = lys_ext_complex_get_substmt(ext->substmt[i].stmt, ext, NULL);\n            if (!(*(void**)p)) {\n                LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_NONE, NULL, ly_stmt_str[ext->substmt[i].stmt], ext_name);\n                goto error;\n            }\n            break;\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    return EXIT_FAILURE;\n}\n\nstatic int\nlyp_deviate_del_ext(struct lys_node *target, struct lys_ext_instance *ext)\n{\n    int n = -1, found = 0;\n    char *path;\n\n    while ((n = lys_ext_iter(target->ext, target->ext_size, n + 1, ext->insubstmt)) != -1) {\n        if (target->ext[n]->def != ext->def) {\n            continue;\n        }\n\n        if (ext->def->argument) {\n            /* check matching arguments */\n            if (!ly_strequal(target->ext[n]->arg_value, ext->arg_value, 1)) {\n                continue;\n            }\n        }\n\n        /* we have the matching extension - remove it */\n        ++found;\n        lyp_ext_instance_rm(target->module->ctx, &target->ext, &target->ext_size, n);\n        --n;\n    }\n\n    if (!found) {\n        path = lys_path(target, LYS_PATH_FIRST_PREFIX);\n        LOGERR(target->module->ctx, LY_EVALID, \"Extension deviation: extension \\\"%s\\\" to delete not found in \\\"%s\\\".\",\n               ext->def->name, path)\n        free(path);\n        return EXIT_FAILURE;\n    }\n    return EXIT_SUCCESS;\n}\n\nstatic int\nlyp_deviate_apply_ext(struct lys_deviate *dev, struct lys_node *target, LYEXT_SUBSTMT substmt, struct lys_ext *extdef)\n{\n    struct ly_ctx *ctx;\n    int m, n;\n    struct lys_ext_instance *new;\n    void *reallocated;\n\n    /* LY_DEVIATE_ADD and LY_DEVIATE_RPL are very similar so they are implement the same way - in replacing,\n     * there can be some extension instances in the target, in case of adding, there should not be any so we\n     * will be just adding. */\n\n    ctx = target->module->ctx; /* shortcut */\n    m = n = -1;\n\n    while ((m = lys_ext_iter(dev->ext, dev->ext_size, m + 1, substmt)) != -1) {\n        /* deviate and its substatements include extensions, copy them to the target, replacing the previous\n         * extensions if any. In case of deviating extension itself, we have to deviate only the same type\n         * of the extension as specified in the deviation */\n        if (substmt == LYEXT_SUBSTMT_SELF && dev->ext[m]->def != extdef) {\n            continue;\n        }\n\n        if (substmt == LYEXT_SUBSTMT_SELF && dev->mod == LY_DEVIATE_ADD) {\n            /* in case of adding extension, we will be replacing only the inherited extensions */\n            do {\n                n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt);\n            } while (n != -1 && (target->ext[n]->def != extdef || !(target->ext[n]->flags & LYEXT_OPT_INHERIT)));\n        } else {\n            /* get the index of the extension to replace in the target node */\n            do {\n                n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt);\n                /* if we are applying extension deviation, we have to deviate only the same type of the extension */\n            } while (n != -1 && substmt == LYEXT_SUBSTMT_SELF && target->ext[n]->def != extdef);\n        }\n\n        if (n == -1) {\n            /* nothing to replace, we are going to add it - reallocate */\n            new = malloc(sizeof **target->ext);\n            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n            reallocated = realloc(target->ext, (target->ext_size + 1) * sizeof *target->ext);\n            LY_CHECK_ERR_RETURN(!reallocated, LOGMEM(ctx); free(new), EXIT_FAILURE);\n            target->ext = reallocated;\n            target->ext_size++;\n\n            n = target->ext_size - 1;\n        } else {\n            /* replacing - the original set of extensions is actually backuped together with the\n             * node itself, so we are supposed only to free the allocated data here ... */\n            lys_extension_instances_free(ctx, target->ext[n]->ext, target->ext[n]->ext_size, NULL);\n            lydict_remove(ctx, target->ext[n]->arg_value);\n            free(target->ext[n]);\n\n            /* and prepare the new structure */\n            new = malloc(sizeof **target->ext);\n            LY_CHECK_ERR_RETURN(!new, LOGMEM(ctx), EXIT_FAILURE);\n        }\n        /* common part for adding and replacing - fill the newly created / replaced cell */\n        target->ext[n] = new;\n        target->ext[n]->def = dev->ext[m]->def;\n        target->ext[n]->arg_value = lydict_insert(ctx, dev->ext[m]->arg_value, 0);\n        target->ext[n]->flags = 0;\n        target->ext[n]->parent = target;\n        target->ext[n]->parent_type = LYEXT_PAR_NODE;\n        target->ext[n]->insubstmt = substmt;\n        target->ext[n]->insubstmt_index = dev->ext[m]->insubstmt_index;\n        target->ext[n]->ext_size = dev->ext[m]->ext_size;\n        lys_ext_dup(ctx, target->module, dev->ext[m]->ext, dev->ext[m]->ext_size, target, LYEXT_PAR_NODE,\n                    &target->ext[n]->ext, 1, NULL);\n        target->ext[n]->nodetype = LYS_EXT;\n        target->ext[n]->module = target->module;\n        target->ext[n]->priv = NULL;\n\n        /* TODO cover complex extension instances */\n    }\n\n    /* remove the rest of extensions belonging to the original substatement in the target node,\n     * due to possible reverting of the deviation effect, they are actually not removed, just moved\n     * to the backup of the original node when the original node is backuped, here we just have to\n     * free the replaced / deleted originals */\n    while ((n = lys_ext_iter(target->ext, target->ext_size, n + 1, substmt)) != -1) {\n        if (substmt == LYEXT_SUBSTMT_SELF) {\n            /* if we are applying extension deviation, we are going to remove only\n             * - the same type of the extension in case of replacing\n             * - the same type of the extension which was inherited in case of adding\n             * note - delete deviation is covered in lyp_deviate_del_ext */\n            if (target->ext[n]->def != extdef ||\n                    (dev->mod == LY_DEVIATE_ADD && !(target->ext[n]->flags & LYEXT_OPT_INHERIT))) {\n                /* keep this extension */\n                continue;\n            }\n\n        }\n\n        /* remove the item */\n        lyp_ext_instance_rm(ctx, &target->ext, &target->ext_size, n);\n        --n;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n/*\n * not-supported deviations are not processed since they affect the complete node, not just their substatements\n */\nint\nlyp_deviation_apply_ext(struct lys_module *module)\n{\n    int i, j, k;\n    struct lys_deviate *dev;\n    struct lys_node *target;\n    struct ly_set *extset;\n\n    for (i = 0; i < module->deviation_size; i++) {\n        target = NULL;\n        extset = NULL;\n        j = resolve_schema_nodeid(module->deviation[i].target_name, NULL, module, &extset, 0, 0);\n        if (j == -1) {\n            return EXIT_FAILURE;\n        } else if (!extset) {\n            /* LY_DEVIATE_NO */\n            ly_set_free(extset);\n            continue;\n        }\n        target = extset->set.s[0];\n        ly_set_free(extset);\n\n        for (j = 0; j < module->deviation[i].deviate_size; j++) {\n            dev = &module->deviation[i].deviate[j];\n            if (!dev->ext_size) {\n                /* no extensions in deviate and its substatement, nothing to do here */\n                continue;\n            }\n\n            /* extensions */\n            if (dev->mod == LY_DEVIATE_DEL) {\n                k = -1;\n                while ((k = lys_ext_iter(dev->ext, dev->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {\n                    if (lyp_deviate_del_ext(target, dev->ext[k])) {\n                        return EXIT_FAILURE;\n                    }\n                }\n\n                /* In case of LY_DEVIATE_DEL, we are applying only extension deviation, removing\n                 * of the substatement's extensions was already done when the substatement was applied.\n                 * Extension deviation could not be applied by the parser since the extension could be unresolved,\n                 * which is not the issue of the other substatements. */\n                continue;\n            } else {\n                extset = ly_set_new();\n                k = -1;\n                while ((k = lys_ext_iter(dev->ext, dev->ext_size, k + 1, LYEXT_SUBSTMT_SELF)) != -1) {\n                    ly_set_add(extset, dev->ext[k]->def, 0);\n                }\n                for (k = 0; (unsigned int)k < extset->number; k++) {\n                    if (lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_SELF, (struct lys_ext *)extset->set.g[k])) {\n                        ly_set_free(extset);\n                        return EXIT_FAILURE;\n                    }\n                }\n                ly_set_free(extset);\n            }\n\n            /* unique */\n            if (dev->unique_size && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_UNIQUE, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* units */\n            if (dev->units && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_UNITS, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* default */\n            if (dev->dflt_size && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_DEFAULT, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* config */\n            if ((dev->flags & LYS_CONFIG_MASK) && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_CONFIG, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* mandatory */\n            if ((dev->flags & LYS_MAND_MASK) && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MANDATORY, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* min/max */\n            if (dev->min_set && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MIN, NULL)) {\n                return EXIT_FAILURE;\n            }\n            if (dev->min_set && lyp_deviate_apply_ext(dev, target, LYEXT_SUBSTMT_MAX, NULL)) {\n                return EXIT_FAILURE;\n            }\n            /* type and must contain extension instances in their structures */\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n\nint\nlyp_ctx_check_module(struct lys_module *module)\n{\n    struct ly_ctx *ctx;\n    int i, match_i = -1, to_implement;\n    const char *last_rev = NULL;\n\n    assert(module);\n    to_implement = 0;\n    ctx = module->ctx;\n\n    /* find latest revision */\n    for (i = 0; i < module->rev_size; ++i) {\n        if (!last_rev || (strcmp(last_rev, module->rev[i].date) < 0)) {\n            last_rev = module->rev[i].date;\n        }\n    }\n\n    for (i = 0; i < ctx->models.used; i++) {\n        /* check name (name/revision) and namespace uniqueness */\n        if (!strcmp(ctx->models.list[i]->name, module->name)) {\n            if (to_implement) {\n                if (i == match_i) {\n                    continue;\n                }\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s@%s\\\" in another revision \\\"%s\\\" already implemented.\",\n                       module->name, last_rev ? last_rev : \"<latest>\", ctx->models.list[i]->rev[0].date);\n                return -1;\n            } else if (!ctx->models.list[i]->rev_size && module->rev_size) {\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" without revision already in context.\", module->name);\n                return -1;\n            } else if (ctx->models.list[i]->rev_size && !module->rev_size) {\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s\\\" with revision \\\"%s\\\" already in context.\",\n                       module->name, ctx->models.list[i]->rev[0].date);\n                return -1;\n            } else if ((!module->rev_size && !ctx->models.list[i]->rev_size)\n                    || !strcmp(ctx->models.list[i]->rev[0].date, last_rev)) {\n\n                LOGVRB(\"Module \\\"%s@%s\\\" already in context.\", module->name, last_rev ? last_rev : \"<latest>\");\n\n                /* if disabled, enable first */\n                if (ctx->models.list[i]->disabled) {\n                    lys_set_enabled(ctx->models.list[i]);\n                }\n\n                to_implement = module->implemented;\n                match_i = i;\n                if (to_implement && !ctx->models.list[i]->implemented) {\n                    /* check first that it is okay to change it to implemented */\n                    i = -1;\n                    continue;\n                }\n                return 1;\n\n            } else if (module->implemented && ctx->models.list[i]->implemented) {\n                LOGERR(ctx, LY_EINVAL, \"Module \\\"%s@%s\\\" in another revision \\\"%s\\\" already implemented.\",\n                       module->name, last_rev ? last_rev : \"<latest>\", ctx->models.list[i]->rev[0].date);\n                return -1;\n            }\n            /* else keep searching, for now the caller is just adding\n             * another revision of an already present schema\n             */\n        } else if (!strcmp(ctx->models.list[i]->ns, module->ns)) {\n            LOGERR(ctx, LY_EINVAL, \"Two different modules (\\\"%s\\\" and \\\"%s\\\") have the same namespace \\\"%s\\\".\",\n                   ctx->models.list[i]->name, module->name, module->ns);\n            return -1;\n        }\n    }\n\n    if (to_implement) {\n        if (lys_set_implemented(ctx->models.list[match_i])) {\n            return -1;\n        }\n        return 1;\n    }\n\n    return 0;\n}\n\nint\nlyp_ctx_add_module(struct lys_module *module)\n{\n    struct lys_module **newlist = NULL;\n    int i;\n\n    assert(!lyp_ctx_check_module(module));\n\n#ifndef NDEBUG\n    int j;\n    /* check that all augments are resolved */\n    for (i = 0; i < module->augment_size; ++i) {\n        assert(module->augment[i].target);\n    }\n    for (i = 0; i < module->inc_size; ++i) {\n        for (j = 0; j < module->inc[i].submodule->augment_size; ++j) {\n            assert(module->inc[i].submodule->augment[j].target);\n        }\n    }\n#endif\n\n    /* add to the context's list of modules */\n    if (module->ctx->models.used == module->ctx->models.size) {\n        newlist = realloc(module->ctx->models.list, (2 * module->ctx->models.size) * sizeof *newlist);\n        LY_CHECK_ERR_RETURN(!newlist, LOGMEM(module->ctx), -1);\n        for (i = module->ctx->models.size; i < module->ctx->models.size * 2; i++) {\n            newlist[i] = NULL;\n        }\n        module->ctx->models.size *= 2;\n        module->ctx->models.list = newlist;\n    }\n    module->ctx->models.list[module->ctx->models.used++] = module;\n    module->ctx->models.module_set_id++;\n\n    return 0;\n}\n\n/**\n * Store UTF-8 character specified as 4byte integer into the dst buffer.\n * Returns number of written bytes (4 max), expects that dst has enough space.\n *\n * UTF-8 mapping:\n * 00000000 -- 0000007F:    0xxxxxxx\n * 00000080 -- 000007FF:    110xxxxx 10xxxxxx\n * 00000800 -- 0000FFFF:    1110xxxx 10xxxxxx 10xxxxxx\n * 00010000 -- 001FFFFF:    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n *\n * Includes checking for valid characters (following RFC 7950, sec 9.4)\n */\nunsigned int\npututf8(struct ly_ctx *ctx, char *dst, int32_t value)\n{\n    if (value < 0x80) {\n        /* one byte character */\n        if (value < 0x20 &&\n                value != 0x09 &&\n                value != 0x0a &&\n                value != 0x0d) {\n            goto error;\n        }\n\n        dst[0] = value;\n        return 1;\n    } else if (value < 0x800) {\n        /* two bytes character */\n        dst[0] = 0xc0 | (value >> 6);\n        dst[1] = 0x80 | (value & 0x3f);\n        return 2;\n    } else if (value < 0xfffe) {\n        /* three bytes character */\n        if (((value & 0xf800) == 0xd800) ||\n                (value >= 0xfdd0 && value <= 0xfdef)) {\n            /* exclude surrogate blocks %xD800-DFFF */\n            /* exclude noncharacters %xFDD0-FDEF */\n            goto error;\n        }\n\n        dst[0] = 0xe0 | (value >> 12);\n        dst[1] = 0x80 | ((value >> 6) & 0x3f);\n        dst[2] = 0x80 | (value & 0x3f);\n\n        return 3;\n    } else if (value < 0x10fffe) {\n        if ((value & 0xffe) == 0xffe) {\n            /* exclude noncharacters %xFFFE-FFFF, %x1FFFE-1FFFF, %x2FFFE-2FFFF, %x3FFFE-3FFFF, %x4FFFE-4FFFF,\n             * %x5FFFE-5FFFF, %x6FFFE-6FFFF, %x7FFFE-7FFFF, %x8FFFE-8FFFF, %x9FFFE-9FFFF, %xAFFFE-AFFFF,\n             * %xBFFFE-BFFFF, %xCFFFE-CFFFF, %xDFFFE-DFFFF, %xEFFFE-EFFFF, %xFFFFE-FFFFF, %x10FFFE-10FFFF */\n            goto error;\n        }\n        /* four bytes character */\n        dst[0] = 0xf0 | (value >> 18);\n        dst[1] = 0x80 | ((value >> 12) & 0x3f);\n        dst[2] = 0x80 | ((value >> 6) & 0x3f);\n        dst[3] = 0x80 | (value & 0x3f);\n\n        return 4;\n    }\n\nerror:\n    /* out of range */\n    LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, NULL);\n    LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%08x\", value);\n    return 0;\n}\n\nunsigned int\ncopyutf8(struct ly_ctx *ctx, char *dst, const char *src)\n{\n    uint32_t value;\n\n    /* unicode characters */\n    if (!(src[0] & 0x80)) {\n        /* one byte character */\n        if (src[0] < 0x20 &&\n                src[0] != 0x09 &&\n                src[0] != 0x0a &&\n                src[0] != 0x0d) {\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%02x\", src[0]);\n            return 0;\n        }\n\n        dst[0] = src[0];\n        return 1;\n    } else if (!(src[0] & 0x20)) {\n        /* two bytes character */\n        dst[0] = src[0];\n        dst[1] = src[1];\n        return 2;\n    } else if (!(src[0] & 0x10)) {\n        /* three bytes character */\n        value = ((uint32_t)(src[0] & 0xf) << 12) | ((uint32_t)(src[1] & 0x3f) << 6) | (src[2] & 0x3f);\n        if (((value & 0xf800) == 0xd800) ||\n                (value >= 0xfdd0 && value <= 0xfdef) ||\n                (value & 0xffe) == 0xffe) {\n            /* exclude surrogate blocks %xD800-DFFF */\n            /* exclude noncharacters %xFDD0-FDEF */\n            /* exclude noncharacters %xFFFE-FFFF */\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%08x\", value);\n            return 0;\n        }\n\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        return 3;\n    } else if (!(src[0] & 0x08)) {\n        /* four bytes character */\n        value = ((uint32_t)(src[0] & 0x7) << 18) | ((uint32_t)(src[1] & 0x3f) << 12) | ((uint32_t)(src[2] & 0x3f) << 6) | (src[3] & 0x3f);\n        if ((value & 0xffe) == 0xffe) {\n            /* exclude noncharacters %x1FFFE-1FFFF, %x2FFFE-2FFFF, %x3FFFE-3FFFF, %x4FFFE-4FFFF,\n             * %x5FFFE-5FFFF, %x6FFFE-6FFFF, %x7FFFE-7FFFF, %x8FFFE-8FFFF, %x9FFFE-9FFFF, %xAFFFE-AFFFF,\n             * %xBFFFE-BFFFF, %xCFFFE-CFFFF, %xDFFFE-DFFFF, %xEFFFE-EFFFF, %xFFFFE-FFFFF, %x10FFFE-10FFFF */\n            LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n            LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 value 0x%08x\", value);\n            return 0;\n        }\n        dst[0] = src[0];\n        dst[1] = src[1];\n        dst[2] = src[2];\n        dst[3] = src[3];\n        return 4;\n    } else {\n        LOGVAL(ctx, LYE_XML_INCHAR, LY_VLOG_NONE, NULL, src);\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_NONE, NULL, \"Invalid UTF-8 leading byte 0x%02x\", src[0]);\n        return 0;\n    }\n}\n\nconst struct lys_module *\nlyp_get_module(const struct lys_module *module, const char *prefix, int pref_len, const char *name, int name_len, int in_data)\n{\n    const struct lys_module *main_module;\n    char *str;\n    int i;\n\n    assert(!prefix || !name);\n\n    if (prefix && !pref_len) {\n        pref_len = strlen(prefix);\n    }\n    if (name && !name_len) {\n        name_len = strlen(name);\n    }\n\n    main_module = lys_main_module(module);\n\n    /* module own prefix, submodule own prefix, (sub)module own name */\n    if ((!prefix || (!module->type && !strncmp(main_module->prefix, prefix, pref_len) && !main_module->prefix[pref_len])\n                 || (module->type && !strncmp(module->prefix, prefix, pref_len) && !module->prefix[pref_len]))\n            && (!name || (!strncmp(main_module->name, name, name_len) && !main_module->name[name_len]))) {\n        return main_module;\n    }\n\n    /* standard import */\n    for (i = 0; i < module->imp_size; ++i) {\n        if ((!prefix || (!strncmp(module->imp[i].prefix, prefix, pref_len) && !module->imp[i].prefix[pref_len]))\n                && (!name || (!strncmp(module->imp[i].module->name, name, name_len) && !module->imp[i].module->name[name_len]))) {\n            return module->imp[i].module;\n        }\n    }\n\n    /* module required by a foreign grouping, deviation, or submodule */\n    if (name) {\n        str = strndup(name, name_len);\n        if (!str) {\n            LOGMEM(module->ctx);\n            return NULL;\n        }\n        main_module = ly_ctx_get_module(module->ctx, str, NULL, 0);\n\n        /* try data callback */\n        if (!main_module && in_data && module->ctx->data_clb) {\n            main_module = module->ctx->data_clb(module->ctx, str, NULL, 0, module->ctx->data_clb_data);\n        }\n\n        free(str);\n        return main_module;\n    }\n\n    return NULL;\n}\n\nconst struct lys_module *\nlyp_get_import_module_ns(const struct lys_module *module, const char *ns)\n{\n    int i;\n    const struct lys_module *mod = NULL;\n\n    assert(module && ns);\n\n    if (module->type) {\n        /* the module is actually submodule and to get the namespace, we need the main module */\n        if (ly_strequal(((struct lys_submodule *)module)->belongsto->ns, ns, 0)) {\n            return ((struct lys_submodule *)module)->belongsto;\n        }\n    } else {\n        /* module's own namespace */\n        if (ly_strequal(module->ns, ns, 0)) {\n            return module;\n        }\n    }\n\n    /* imported modules */\n    for (i = 0; i < module->imp_size; ++i) {\n        if (ly_strequal(module->imp[i].module->ns, ns, 0)) {\n            return module->imp[i].module;\n        }\n    }\n\n    return mod;\n}\n\nconst char *\nlyp_get_yang_data_template_name(const struct lyd_node *node)\n{\n    struct lys_node *snode;\n\n    snode = lys_parent(node->schema);\n    while (snode && snode->nodetype & (LYS_USES | LYS_CASE | LYS_CHOICE)) {\n        snode = lys_parent(snode);\n    }\n\n    if (snode && snode->nodetype == LYS_EXT && strcmp(((struct lys_ext_instance_complex *)snode)->def->name, \"yang-data\") == 0) {\n        return ((struct lys_ext_instance_complex *)snode)->arg_value;\n    } else {\n        return NULL;\n    }\n}\n\nconst struct lys_node *\nlyp_get_yang_data_template(const struct lys_module *module, const char *yang_data_name, int yang_data_name_len)\n{\n    int i, j;\n    const struct lys_node *ret = NULL;\n    const struct lys_submodule *submodule;\n\n    for(i = 0; i < module->ext_size; ++i) {\n        if (!strcmp(module->ext[i]->def->name, \"yang-data\") && !strncmp(module->ext[i]->arg_value, yang_data_name, yang_data_name_len)\n            && !module->ext[i]->arg_value[yang_data_name_len]) {\n            ret = (struct lys_node *)module->ext[i];\n            break;\n        }\n    }\n\n    for(j = 0; !ret && j < module->inc_size; ++j) {\n        submodule = module->inc[j].submodule;\n        for(i = 0; i < submodule->ext_size; ++i) {\n            if (!strcmp(submodule->ext[i]->def->name, \"yang-data\") && !strncmp(submodule->ext[i]->arg_value, yang_data_name, yang_data_name_len)\n                && !submodule->ext[i]->arg_value[yang_data_name_len]) {\n                ret = (struct lys_node *)submodule->ext[i];\n                break;\n            }\n        }\n    }\n\n    return ret;\n}\n"], "filenames": ["src/parser.c"], "buggy_code_start_loc": [1023], "buggy_code_end_loc": [1025], "fixing_code_start_loc": [1024], "fixing_code_end_loc": [1028], "type": "CWE-787", "message": "In all versions of libyang before 1.0-r5, a stack-based buffer overflow was discovered in the way libyang parses YANG files with a leaf of type \"identityref\". An application that uses libyang to parse untrusted YANG files may be vulnerable to this flaw, which would allow an attacker to cause a denial of service or possibly gain code execution.", "other": {"cve": {"id": "CVE-2019-19334", "sourceIdentifier": "secalert@redhat.com", "published": "2019-12-06T16:15:10.920", "lastModified": "2019-12-18T18:15:19.740", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In all versions of libyang before 1.0-r5, a stack-based buffer overflow was discovered in the way libyang parses YANG files with a leaf of type \"identityref\". An application that uses libyang to parse untrusted YANG files may be vulnerable to this flaw, which would allow an attacker to cause a denial of service or possibly gain code execution."}, {"lang": "es", "value": "En todas las versiones de libyang anteriores a 1.0-r5, se detect\u00f3 un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria en la manera en que libyang analiza los archivos YANG con una hoja de tipo \"identityref\". Una aplicaci\u00f3n que usa libyang para analizar archivos YANG no confiables puede ser vulnerable a este fallo, lo que permitir\u00eda a un atacante causar una denegaci\u00f3n de servicio o posiblemente conseguir la ejecuci\u00f3n de c\u00f3digo."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r1:*:*:*:*:*:*", "matchCriteriaId": "65E91322-5F67-43C2-8112-5ECAEC2A3C12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.11:r2:*:*:*:*:*:*", "matchCriteriaId": "80A88DE4-93F8-40C3-AA52-A5F353F028AA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r1:*:*:*:*:*:*", "matchCriteriaId": "05C120CA-50EF-4B6D-92C9-ED736219DB07"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.12:r2:*:*:*:*:*:*", "matchCriteriaId": "99D1FA55-3F56-4E09-B41E-B05C199B96B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r1:*:*:*:*:*:*", "matchCriteriaId": "35D48EC4-58D2-49C6-8049-920787733587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.13:r2:*:*:*:*:*:*", "matchCriteriaId": "B57F3953-49D6-413C-A4AE-03125935FC77"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.14:r1:*:*:*:*:*:*", "matchCriteriaId": "DD62411F-A524-4E80-B540-780EA39CB6A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.15:r1:*:*:*:*:*:*", "matchCriteriaId": "FEF091B1-978A-4881-B1FC-6848CD1A7BBF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r1:*:*:*:*:*:*", "matchCriteriaId": "0C50D690-9A4D-4B78-BF4E-A4D9B4074216"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r2:*:*:*:*:*:*", "matchCriteriaId": "124A5D30-7451-4516-9AA2-963AE62DD679"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:0.16:r3:*:*:*:*:*:*", "matchCriteriaId": "C260D13B-82E9-4596-9116-61073B42D661"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r1:*:*:*:*:*:*", "matchCriteriaId": "5F8D5FC0-959E-4014-9CB7-91378CC8B2BA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r2:*:*:*:*:*:*", "matchCriteriaId": "DCBDA519-805B-4193-8092-75E2748A7BC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r3:*:*:*:*:*:*", "matchCriteriaId": "4653ED0D-1E48-4E56-ACA4-0475C9568A89"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cesnet:libyang:1.0:r4:*:*:*:*:*:*", "matchCriteriaId": "F0BEE023-C83B-4465-97BC-8E15627025D1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2019:4360", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2019-19334", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/CESNET/libyang/commit/6980afae2ff9fcd6d67508b0a3f694d75fd059d6", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PETB6TVMFV5KUD4IKVP2JPLBCYHUGSAJ/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/RL54JMS7XW7PI6JC4BFSNNLSX5AINQUL/", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/CESNET/libyang/commit/6980afae2ff9fcd6d67508b0a3f694d75fd059d6"}}