{"buggy_code": ["#!/usr/bin/env python2\n# vim:fileencoding=utf-8\nfrom __future__ import (unicode_literals, division, absolute_import,\n                        print_function)\n\n__license__ = 'GPL v3'\n__copyright__ = '2013, Kovid Goyal <kovid at kovidgoyal.net>'\n\nimport cPickle\n\nfrom PyQt5.Qt import (\n    Qt, QListWidget, QListWidgetItem, QItemSelectionModel, QAction,\n    QGridLayout, QPushButton, QIcon, QWidget, pyqtSignal, QLabel)\n\nfrom calibre.gui2 import choose_save_file, choose_files\nfrom calibre.utils.icu import sort_key\n\n\nclass BookmarksList(QListWidget):\n\n    changed = pyqtSignal()\n    bookmark_activated = pyqtSignal(object)\n\n    def __init__(self, parent=None):\n        QListWidget.__init__(self, parent)\n        self.setDragEnabled(True)\n        self.setDragDropMode(self.InternalMove)\n        self.setDefaultDropAction(Qt.MoveAction)\n        self.setAlternatingRowColors(True)\n        self.setStyleSheet('QListView::item { padding: 0.5ex }')\n        self.viewport().setAcceptDrops(True)\n        self.setDropIndicatorShown(True)\n        self.setContextMenuPolicy(Qt.ActionsContextMenu)\n        self.ac_edit = ac = QAction(QIcon(I('edit_input.png')), _('Edit this bookmark'), self)\n        self.addAction(ac)\n        self.ac_delete = ac = QAction(QIcon(I('trash.png')), _('Remove this bookmark'), self)\n        self.addAction(ac)\n        self.ac_sort = ac = QAction(_('Sort by name'), self)\n        self.addAction(ac)\n        self.ac_sort_pos = ac = QAction(_('Sort by position in book'), self)\n        self.addAction(ac)\n\n    def dropEvent(self, ev):\n        QListWidget.dropEvent(self, ev)\n        if ev.isAccepted():\n            self.changed.emit()\n\n    def keyPressEvent(self, ev):\n        if ev.key() in (Qt.Key_Enter, Qt.Key_Return):\n            i = self.currentItem()\n            if i is not None:\n                self.bookmark_activated.emit(i)\n                ev.accept()\n                return\n        if ev.key() in (Qt.Key_Delete, Qt.Key_Backspace):\n            i = self.currentItem()\n            if i is not None:\n                self.ac_delete.trigger()\n                ev.accept()\n                return\n        return QListWidget.keyPressEvent(self, ev)\n\n\nclass BookmarkManager(QWidget):\n\n    edited = pyqtSignal(object)\n    activated = pyqtSignal(object)\n    create_requested = pyqtSignal()\n\n    def __init__(self, parent):\n        QWidget.__init__(self, parent)\n        self.l = l = QGridLayout(self)\n        l.setContentsMargins(0, 0, 0, 0)\n        self.setLayout(l)\n\n        self.bookmarks_list = bl = BookmarksList(self)\n        bl.itemChanged.connect(self.item_changed)\n        l.addWidget(bl, 0, 0, 1, -1)\n        bl.itemClicked.connect(self.item_activated)\n        bl.bookmark_activated.connect(self.item_activated)\n        bl.changed.connect(lambda : self.edited.emit(self.get_bookmarks()))\n        bl.ac_edit.triggered.connect(self.edit_bookmark)\n        bl.ac_sort.triggered.connect(self.sort_by_name)\n        bl.ac_sort_pos.triggered.connect(self.sort_by_pos)\n        bl.ac_delete.triggered.connect(self.delete_bookmark)\n\n        self.la = la = QLabel(_(\n            'Double click to edit and drag-and-drop to re-order the bookmarks'))\n        la.setWordWrap(True)\n        l.addWidget(la, l.rowCount(), 0, 1, -1)\n\n        self.button_new = b = QPushButton(QIcon(I('bookmarks.png')), _('&New'), self)\n        b.clicked.connect(self.create_requested)\n        b.setToolTip(_('Create a new bookmark at the current location'))\n        l.addWidget(b)\n\n        self.button_delete = b = QPushButton(QIcon(I('trash.png')), _('&Remove'), self)\n        b.setToolTip(_('Remove the currently selected bookmark'))\n        b.clicked.connect(self.delete_bookmark)\n        l.addWidget(b, l.rowCount() - 1, 1)\n\n        self.button_delete = b = QPushButton(_('Sort by &name'), self)\n        b.setToolTip(_('Sort bookmarks by name'))\n        b.clicked.connect(self.sort_by_name)\n        l.addWidget(b)\n\n        self.button_delete = b = QPushButton(_('Sort by &position'), self)\n        b.setToolTip(_('Sort bookmarks by position in book'))\n        b.clicked.connect(self.sort_by_pos)\n        l.addWidget(b, l.rowCount() - 1, 1)\n\n        self.button_export = b = QPushButton(QIcon(I('back.png')), _('E&xport'), self)\n        b.clicked.connect(self.export_bookmarks)\n        l.addWidget(b)\n\n        self.button_import = b = QPushButton(QIcon(I('forward.png')), _('&Import'), self)\n        b.clicked.connect(self.import_bookmarks)\n        l.addWidget(b, l.rowCount() - 1, 1)\n\n    def item_activated(self, item):\n        bm = self.item_to_bm(item)\n        self.activated.emit(bm)\n\n    def set_bookmarks(self, bookmarks=()):\n        self.bookmarks_list.clear()\n        for bm in bookmarks:\n            if bm['title'] != 'calibre_current_page_bookmark':\n                i = QListWidgetItem(bm['title'])\n                i.setData(Qt.UserRole, self.bm_to_item(bm))\n                i.setFlags(i.flags() | Qt.ItemIsEditable)\n                self.bookmarks_list.addItem(i)\n        if self.bookmarks_list.count() > 0:\n            self.bookmarks_list.setCurrentItem(self.bookmarks_list.item(0), QItemSelectionModel.ClearAndSelect)\n\n    def set_current_bookmark(self, bm):\n        for i, q in enumerate(self):\n            if bm == q:\n                l = self.bookmarks_list\n                item = l.item(i)\n                l.setCurrentItem(item, QItemSelectionModel.ClearAndSelect)\n                l.scrollToItem(item)\n\n    def __iter__(self):\n        for i in xrange(self.bookmarks_list.count()):\n            yield self.item_to_bm(self.bookmarks_list.item(i))\n\n    def item_changed(self, item):\n        self.bookmarks_list.blockSignals(True)\n        title = unicode(item.data(Qt.DisplayRole))\n        if not title:\n            title = _('Unknown')\n            item.setData(Qt.DisplayRole, title)\n        bm = self.item_to_bm(item)\n        bm['title'] = title\n        item.setData(Qt.UserRole, self.bm_to_item(bm))\n        self.bookmarks_list.blockSignals(False)\n        self.edited.emit(self.get_bookmarks())\n\n    def delete_bookmark(self):\n        row = self.bookmarks_list.currentRow()\n        if row > -1:\n            self.bookmarks_list.takeItem(row)\n            self.edited.emit(self.get_bookmarks())\n\n    def edit_bookmark(self):\n        item = self.bookmarks_list.currentItem()\n        if item is not None:\n            self.bookmarks_list.editItem(item)\n\n    def sort_by_name(self):\n        bm = self.get_bookmarks()\n        bm.sort(key=lambda x:sort_key(x['title']))\n        self.set_bookmarks(bm)\n        self.edited.emit(bm)\n\n    def sort_by_pos(self):\n        from calibre.ebooks.epub.cfi.parse import cfi_sort_key\n\n        def pos_key(b):\n            if b.get('type', None) == 'cfi':\n                return b['spine'], cfi_sort_key(b['pos'])\n            return (None, None)\n        bm = self.get_bookmarks()\n        bm.sort(key=pos_key)\n        self.set_bookmarks(bm)\n        self.edited.emit(bm)\n\n    def bm_to_item(self, bm):\n        return bytearray(cPickle.dumps(bm, -1))\n\n    def item_to_bm(self, item):\n        return cPickle.loads(bytes(item.data(Qt.UserRole)))\n\n    def get_bookmarks(self):\n        return list(self)\n\n    def export_bookmarks(self):\n        filename = choose_save_file(\n            self, 'export-viewer-bookmarks', _('Export bookmarks'),\n            filters=[(_('Saved bookmarks'), ['pickle'])], all_files=False, initial_filename='bookmarks.pickle')\n        if filename:\n            with open(filename, 'wb') as fileobj:\n                cPickle.dump(self.get_bookmarks(), fileobj, -1)\n\n    def import_bookmarks(self):\n        files = choose_files(self, 'export-viewer-bookmarks', _('Import bookmarks'),\n            filters=[(_('Saved bookmarks'), ['pickle'])], all_files=False, select_only_single_file=True)\n        if not files:\n            return\n        filename = files[0]\n\n        imported = None\n        with open(filename, 'rb') as fileobj:\n            imported = cPickle.load(fileobj)\n\n        if imported is not None:\n            bad = False\n            try:\n                for bm in imported:\n                    if 'title' not in bm:\n                        bad = True\n                        break\n            except Exception:\n                pass\n\n            if not bad:\n                bookmarks = self.get_bookmarks()\n                for bm in imported:\n                    if bm not in bookmarks:\n                        bookmarks.append(bm)\n                self.set_bookmarks([bm for bm in bookmarks if bm['title'] != 'calibre_current_page_bookmark'])\n                self.edited.emit(self.get_bookmarks())\n", "#!/usr/bin/env python2\n# vim:fileencoding=utf-8\n# License: GPLv3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport cPickle\nimport hashlib\nimport random\nimport shutil\nimport sys\nimport zipfile\nfrom json import load as load_json_file\nfrom threading import Lock\n\nfrom calibre import as_unicode\nfrom calibre.customize.ui import available_input_formats\nfrom calibre.db.view import sanitize_sort_field_name\nfrom calibre.srv.ajax import search_result\nfrom calibre.srv.errors import (\n    BookNotFound, HTTPBadRequest, HTTPForbidden, HTTPNotFound\n)\nfrom calibre.srv.metadata import (\n    book_as_json, categories_as_json, categories_settings, icon_map\n)\nfrom calibre.srv.routes import endpoint, json\nfrom calibre.srv.utils import get_library_data, get_use_roman\nfrom calibre.utils.config import prefs, tweaks\nfrom calibre.utils.icu import sort_key\nfrom calibre.utils.localization import get_lang\nfrom calibre.utils.search_query_parser import ParseException\n\nPOSTABLE = frozenset({'GET', 'POST', 'HEAD'})\n\n\n@endpoint('', auth_required=False)\ndef index(ctx, rd):\n    return lopen(P('content-server/index-generated.html'), 'rb')\n\n\n@endpoint('/calibre.appcache', auth_required=False, cache_control='no-cache')\ndef appcache(ctx, rd):\n    return lopen(P('content-server/calibre.appcache'), 'rb')\n\n\n@endpoint('/robots.txt', auth_required=False)\ndef robots(ctx, rd):\n    return b'User-agent: *\\nDisallow: /'\n\n\n@endpoint('/ajax-setup', auth_required=False, cache_control='no-cache', postprocess=json)\ndef ajax_setup(ctx, rd):\n    auto_reload_port = getattr(rd.opts, 'auto_reload_port', 0)\n    return {\n        'auto_reload_port': max(0, auto_reload_port),\n        'allow_console_print': bool(getattr(rd.opts, 'allow_console_print', False)),\n        'ajax_timeout': rd.opts.ajax_timeout,\n    }\n\n\nprint_lock = Lock()\n\n\n@endpoint('/console-print', methods=('POST', ))\ndef console_print(ctx, rd):\n    if not getattr(rd.opts, 'allow_console_print', False):\n        raise HTTPForbidden('console printing is not allowed')\n    with print_lock:\n        print(rd.remote_addr, end=' ')\n        shutil.copyfileobj(rd.request_body_file, sys.stdout)\n    return ''\n\n\ndef get_basic_query_data(ctx, rd):\n    db, library_id, library_map, default_library = get_library_data(ctx, rd)\n    skeys = db.field_metadata.sortable_field_keys()\n    sorts, orders = [], []\n    for x in rd.query.get('sort', '').split(','):\n        if x:\n            s, o = x.rpartition('.')[::2]\n            if o and not s:\n                s, o = o, ''\n            if o not in ('asc', 'desc'):\n                o = 'asc'\n            if s.startswith('_'):\n                s = '#' + s[1:]\n            s = sanitize_sort_field_name(db.field_metadata, s)\n            if s in skeys:\n                sorts.append(s), orders.append(o)\n    if not sorts:\n        sorts, orders = ['timestamp'], ['desc']\n    return library_id, db, sorts, orders, rd.query.get('vl') or ''\n\n\n_cached_translations = None\n\n\ndef get_translations():\n    global _cached_translations\n    if _cached_translations is None:\n        _cached_translations = False\n        with zipfile.ZipFile(\n            P('content-server/locales.zip', allow_user_override=False), 'r'\n        ) as zf:\n            names = set(zf.namelist())\n            lang = get_lang()\n            if lang not in names:\n                xlang = lang.split('_')[0].lower()\n                if xlang in names:\n                    lang = xlang\n            if lang in names:\n                _cached_translations = load_json_file(zf.open(lang, 'r'))\n    return _cached_translations\n\n\ndef custom_list_template():\n    ans = getattr(custom_list_template, 'ans', None)\n    if ans is None:\n        ans = {\n            'thumbnail': True,\n            'thumbnail_height': 140,\n            'height': 'auto',\n            'comments_fields': ['comments'],\n            'lines': [\n                _('<b>{title}</b> by {authors}'),\n                _('{series_index} of <i>{series}</i>') + '|||{rating}',\n                '{tags}',\n                _('Date: {timestamp}') + '|||' + _('Published: {pubdate}') + '|||' + _('Publisher: {publisher}'),\n                '',\n            ]\n        }\n        custom_list_template.ans = ans\n    return ans\n\n\ndef basic_interface_data(ctx, rd):\n    ans = {\n        'username': rd.username,\n        'output_format': prefs['output_format'].upper(),\n        'input_formats': {x.upper(): True\n                          for x in available_input_formats()},\n        'gui_pubdate_display_format': tweaks['gui_pubdate_display_format'],\n        'gui_timestamp_display_format': tweaks['gui_timestamp_display_format'],\n        'gui_last_modified_display_format': tweaks['gui_last_modified_display_format'],\n        'use_roman_numerals_for_series_number': get_use_roman(),\n        'translations': get_translations(),\n        'icon_map': icon_map(),\n        'icon_path': ctx.url_for('/icon', which=''),\n        'custom_list_template': getattr(ctx, 'custom_list_template', None) or custom_list_template(),\n        'num_per_page': rd.opts.num_per_page,\n    }\n    ans['library_map'], ans['default_library_id'] = ctx.library_info(rd)\n    return ans\n\n\n@endpoint('/interface-data/update', postprocess=json)\ndef update_interface_data(ctx, rd):\n    '''\n    Return the interface data needed for the server UI\n    '''\n    return basic_interface_data(ctx, rd)\n\n\ndef get_field_list(db):\n    fieldlist = list(db.pref('book_display_fields', ()))\n    names = frozenset([x[0] for x in fieldlist])\n    available = frozenset(db.field_metadata.displayable_field_keys())\n    for field in available:\n        if field not in names:\n            fieldlist.append((field, True))\n    return [f for f, d in fieldlist if d and f in available]\n\n\ndef get_library_init_data(ctx, rd, db, num, sorts, orders, vl):\n    ans = {}\n    with db.safe_read_lock:\n        try:\n            ans['search_result'] = search_result(\n                ctx, rd, db,\n                rd.query.get('search', ''), num, 0, ','.join(sorts),\n                ','.join(orders), vl\n            )\n        except ParseException:\n            ans['search_result'] = search_result(\n                ctx, rd, db, '', num, 0, ','.join(sorts), ','.join(orders), vl\n            )\n        sf = db.field_metadata.ui_sortable_field_keys()\n        sf.pop('ondevice', None)\n        ans['sortable_fields'] = sorted(\n            ((sanitize_sort_field_name(db.field_metadata, k), v)\n             for k, v in sf.iteritems()),\n            key=lambda (field, name): sort_key(name)\n        )\n        ans['field_metadata'] = db.field_metadata.all_metadata()\n        ans['virtual_libraries'] = db._pref('virtual_libraries', {})\n        ans['book_display_fields'] = get_field_list(db)\n        mdata = ans['metadata'] = {}\n        try:\n            extra_books = set(\n                int(x) for x in rd.query.get('extra_books', '').split(',')\n            )\n        except Exception:\n            extra_books = ()\n        for coll in (ans['search_result']['book_ids'], extra_books):\n            for book_id in coll:\n                if book_id not in mdata:\n                    data = book_as_json(db, book_id)\n                    if data is not None:\n                        mdata[book_id] = data\n    return ans\n\n\n@endpoint('/interface-data/books-init', postprocess=json)\ndef books(ctx, rd):\n    '''\n    Get data to create list of books\n\n    Optional: ?num=50&sort=timestamp.desc&library_id=<default library>\n              &search=''&extra_books=''&vl=''\n    '''\n    ans = {}\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    library_id, db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n    ans = get_library_init_data(ctx, rd, db, num, sorts, orders, vl)\n    ans['library_id'] = library_id\n    return ans\n\n\n@endpoint('/interface-data/init', postprocess=json)\ndef interface_data(ctx, rd):\n    '''\n    Return the data needed to create the server UI as well as a list of books.\n\n    Optional: ?num=50&sort=timestamp.desc&library_id=<default library>\n              &search=''&extra_books=''&vl=''\n    '''\n    ans = basic_interface_data(ctx, rd)\n    ud = {}\n    if rd.username:\n        # Override session data with stored values for the authenticated user,\n        # if any\n        ud = ctx.user_manager.get_session_data(rd.username)\n        lid = ud.get('library_id')\n        if lid and lid in ans['library_map']:\n            rd.query.set('library_id', lid)\n        usort = ud.get('sort')\n        if usort:\n            rd.query.set('sort', usort)\n    ans['library_id'], db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n    ans['user_session_data'] = ud\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    ans.update(get_library_init_data(ctx, rd, db, num, sorts, orders, vl))\n    return ans\n\n\n@endpoint('/interface-data/more-books', postprocess=json, methods=POSTABLE)\ndef more_books(ctx, rd):\n    '''\n    Get more results from the specified search-query, which must\n    be specified as JSON in the request body.\n\n    Optional: ?num=50&library_id=<default library>\n    '''\n    db, library_id = get_library_data(ctx, rd)[:2]\n\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    try:\n        search_query = load_json_file(rd.request_body_file)\n        query, offset, sorts, orders, vl = search_query['query'], search_query[\n            'offset'\n        ], search_query['sort'], search_query['sort_order'], search_query['vl']\n    except KeyError as err:\n        raise HTTPBadRequest('Search query missing key: %s' % as_unicode(err))\n    except Exception as err:\n        raise HTTPBadRequest('Invalid query: %s' % as_unicode(err))\n    ans = {}\n    with db.safe_read_lock:\n        ans['search_result'] = search_result(\n            ctx, rd, db, query, num, offset, sorts, orders, vl\n        )\n        mdata = ans['metadata'] = {}\n        for book_id in ans['search_result']['book_ids']:\n            data = book_as_json(db, book_id)\n            if data is not None:\n                mdata[book_id] = data\n\n    return ans\n\n\n@endpoint('/interface-data/set-session-data', postprocess=json, methods=POSTABLE)\ndef set_session_data(ctx, rd):\n    '''\n    Store session data persistently so that it is propagated automatically to\n    new logged in clients\n    '''\n    if rd.username:\n        try:\n            new_data = load_json_file(rd.request_body_file)\n            if not isinstance(new_data, dict):\n                raise Exception('session data must be a dict')\n        except Exception as err:\n            raise HTTPBadRequest('Invalid data: %s' % as_unicode(err))\n        ud = ctx.user_manager.get_session_data(rd.username)\n        ud.update(new_data)\n        ctx.user_manager.set_session_data(rd.username, ud)\n\n\n@endpoint('/interface-data/get-books', postprocess=json)\ndef get_books(ctx, rd):\n    '''\n    Get books for the specified query\n\n    Optional: ?library_id=<default library>&num=50&sort=timestamp.desc&search=''&vl=''\n    '''\n    library_id, db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    searchq = rd.query.get('search', '')\n    db = get_library_data(ctx, rd)[0]\n    ans = {}\n    mdata = ans['metadata'] = {}\n    with db.safe_read_lock:\n        try:\n            ans['search_result'] = search_result(\n                ctx, rd, db, searchq, num, 0, ','.join(sorts), ','.join(orders), vl\n            )\n        except ParseException as err:\n            # This must not be translated as it is used by the front end to\n            # detect invalid search expressions\n            raise HTTPBadRequest('Invalid search expression: %s' % as_unicode(err))\n        for book_id in ans['search_result']['book_ids']:\n            data = book_as_json(db, book_id)\n            if data is not None:\n                mdata[book_id] = data\n    return ans\n\n\n@endpoint('/interface-data/book-metadata/{book_id=0}', postprocess=json)\ndef book_metadata(ctx, rd, book_id):\n    '''\n    Get metadata for the specified book. If no book_id is specified, return metadata for a random book.\n\n    Optional: ?library_id=<default library>&vl=<virtual library>\n    '''\n    library_id, db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n\n    if not book_id:\n        all_ids = ctx.allowed_book_ids(rd, db)\n        book_id = random.choice(tuple(all_ids))\n    elif not ctx.has_id(rd, db, book_id):\n        raise BookNotFound(book_id, db)\n    data = book_as_json(db, book_id)\n    if data is None:\n        raise BookNotFound(book_id, db)\n    data['id'] = book_id  # needed for random book view (when book_id=0)\n    return data\n\n\n@endpoint('/interface-data/tag-browser')\ndef tag_browser(ctx, rd):\n    '''\n    Get the Tag Browser serialized as JSON\n    Optional: ?library_id=<default library>&sort_tags_by=name&partition_method=first letter\n              &collapse_at=25&dont_collapse=&hide_empty_categories=&vl=''\n    '''\n    db, library_id = get_library_data(ctx, rd)[:2]\n    opts = categories_settings(rd.query, db)\n    vl = rd.query.get('vl') or ''\n    etag = cPickle.dumps([db.last_modified().isoformat(), rd.username, library_id, vl, list(opts)], -1)\n    etag = hashlib.sha1(etag).hexdigest()\n\n    def generate():\n        return json(ctx, rd, tag_browser, categories_as_json(ctx, rd, db, opts, vl))\n\n    return rd.etagged_dynamic_response(etag, generate)\n\n\n@endpoint('/interface-data/field-names/{field}', postprocess=json)\ndef field_names(ctx, rd, field):\n    '''\n    Get a list of all names for the specified field\n    Optional: ?library_id=<default library>\n    '''\n    db, library_id = get_library_data(ctx, rd)[:2]\n    return tuple(db.all_field_names(field))\n", "# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2018, Kovid Goyal <kovid at kovidgoyal.net>\nfrom __python__ import bound_methods, hash_literals\n\nimport traceback\nfrom elementmaker import E\nfrom gettext import gettext as _\n\nfrom ajax import ajax_send\nfrom book_list.book_details import (\n    basic_table_rules, fetch_metadata, field_sorter, no_book, report_load_failure\n)\nfrom book_list.library_data import (\n    book_metadata, current_library_id, field_names_for, library_data, load_status,\n    loaded_book_ids, set_book_metadata\n)\nfrom book_list.router import back\nfrom book_list.top_bar import create_top_bar, set_title\nfrom book_list.ui import set_panel_handler, show_panel\nfrom date import format_date\nfrom dom import add_extra_css, build_rule, clear, svgicon\nfrom modals import error_dialog\nfrom session import get_interface_data\nfrom utils import (\n    conditional_timeout, fmt_sidx, parse_url_params, safe_set_inner_html\n)\nfrom widgets import create_button\n\nCLASS_NAME = 'edit-metadata-panel'\nIGNORED_FIELDS = {'formats', 'sort', 'uuid', 'id', 'urls_from_identifiers', 'lang_names', 'last_modified', 'path', 'marked', 'size', 'ondevice', 'cover', 'au_map', 'isbn'}\nvalue_to_json = None\nchanges = {}\nhas_changes = False\n\nadd_extra_css(def():\n    sel = '.' + CLASS_NAME + ' '\n    style = basic_table_rules(sel)\n    style += build_rule(sel + 'table.metadata', margin_left='1rem')\n    style += build_rule(sel + 'table.metadata td', padding_bottom='0.5ex', padding_top='0.5ex', cursor='pointer')\n    style += build_rule(sel + 'table.metadata tr:hover', color='red')\n    style += build_rule(sel + 'table.metadata tr:active', transform='scale(1.5)')\n    return style\n)\n\n\ndef resolved_metadata(mi, field):\n    if Object.prototype.hasOwnProperty.call(changes, field):\n        return changes[field]\n    return mi[field]\n\n\ndef truncated_html(val):\n    ans = val.replace(/<[^>]+>/g, '')\n    if ans.length > 40:\n        ans = ans[:40] + '\u2026'\n    return ans\n\n\n\ndef onsubmit_field(get_value, container_id, book_id, field):\n    c = document.getElementById(container_id)\n    if not c:\n        return\n    d = c.querySelector('div[data-ctype=\"edit\"]')\n    if not d:\n        return\n    ok, value = get_value(d)\n    if not ok:\n        return\n    if value is book_metadata(book_id)[field]:\n        on_close(container_id)\n        return\n\n    def proceed():\n        nonlocal has_changes\n        clear(d)\n        d.appendChild(E.div(style='margin: 1ex 1rem', _('Contacting server, please wait') + '\u2026'))\n        jval = value_to_json(value)\n        changes[field] = jval\n        has_changes = True\n        show_book(container_id, book_id)\n        on_close(container_id)\n\n\n    window.setTimeout(proceed, 0)  # needed to avoid console error about form submission failing because form is removed from DOM in onsubmit handler\n\n\ndef create_form(widget, get_value, container_id, book_id, field, *edit_widgets):\n    submit_action = onsubmit_field.bind(None, get_value, container_id, book_id, field)\n    button = create_button(_('OK'), action=submit_action)\n    widget.classList.add('metadata-editor')\n    form = E.form(\n        action='javascript: void(0)', onsubmit=submit_action, style='margin: 1ex auto',\n        E.div(widget, style='margin-bottom: 1ex'),\n        E.div(button)\n    )\n    return form\n\n\ndef line_edit_get_value(container):\n    return True, container.querySelector('input[type=\"text\"]').value\n\n\ndef simple_line_edit(container_id, book_id, field, fm, div, mi):\n    nonlocal value_to_json\n    name = fm.name or field\n    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True)\n    le.value = resolved_metadata(mi, field) or ''\n    form = create_form(le, line_edit_get_value, container_id, book_id, field)\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', _('Edit the \"{}\" below').format(name)))\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', form))\n    le.focus(), le.select()\n    value_to_json = def(x):\n        return x\n\n\ndef multiple_line_edit(list_to_ui, ui_to_list, container_id, book_id, field, fm, div, mi):\n    nonlocal value_to_json\n    name = fm.name or field\n    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True)\n    le.value = (resolved_metadata(mi, field) or v'[]').join(list_to_ui)\n    form = create_form(le, line_edit_get_value, container_id, book_id, field)\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', _(\n        'Edit the \"{0}\" below. Multiple items can be separated by {1}.').format(name, list_to_ui.strip())))\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', form))\n    div.appendChild(E.div(style='margin: 0.5ex 1rem'))\n    le.focus(), le.select()\n    value_to_json = def(x):\n        return [a.strip() for a in x.split(ui_to_list) if a.strip()]\n    div.lastChild.appendChild(E.span(_('Loading all {}...').format(name)))\n    field_names_for(field, print)\n\n\ndef edit_field(container_id, book_id, field):\n    nonlocal value_to_json\n    fm = library_data.field_metadata[field]\n    c = document.getElementById(container_id)\n    mi = book_metadata(book_id)\n    if not c or not fm or not mi:\n        return\n    d = c.querySelector('div[data-ctype=\"edit\"]')\n    d.style.display = 'block'\n    d.previousSibling.style.display = 'none'\n    clear(d)\n    if field is 'authors':\n        multiple_line_edit(' & ', '&', container_id, book_id, field, fm, d, mi)\n    else:\n        simple_line_edit(container_id, book_id, field, fm, d, mi)\n    if field is 'title':\n        value_to_json = def(x):\n            return x or _('Untitled')\n    elif field is 'authors':\n        value_to_json = def(x):\n            return [a.strip() for a in x.split('&') if a.strip()] or [_('Unknown')]\n\n\ndef render_metadata(mi, table, container_id, book_id):  # {{{\n    field_metadata = library_data.field_metadata\n    interface_data = get_interface_data()\n    current_edit_action = None\n\n    def allowed_fields(field):\n        if field.endswith('_index'):\n            fm = field_metadata[field[:-len('_index')]]\n            if fm and fm.datatype is 'series':\n                return False\n        if field.startswith('#'):\n            return True\n        if field in IGNORED_FIELDS or field.endswith('_sort') or field[0] is '@':\n            return False\n        return True\n\n    fields = library_data.book_display_fields\n    if not fields or not fields.length:\n        fields = sorted(filter(allowed_fields, mi), key=field_sorter(field_metadata))\n    else:\n        fields = filter(allowed_fields, fields)\n    fields = list(fields)\n    added_fields = {f:True for f in fields}\n    if not added_fields.title:\n        added_fields.title = True\n        fields.insert(0, 'title')\n    for other_field in Object.keys(library_data.field_metadata):\n        if not added_fields[other_field] and allowed_fields(other_field) and other_field not in IGNORED_FIELDS:\n            fields.push(other_field)\n\n    def add_row(name, val, is_html=False, join=None):\n        if val is undefined or val is None:\n            val = v'[\" \"]' if join else '\\xa0'\n        def add_val(v):\n            if not v.appendChild:\n                v += ''\n            if v.appendChild:\n                table.lastChild.lastChild.appendChild(v)\n            else:\n                table.lastChild.lastChild.appendChild(document.createTextNode(v))\n\n        table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n        if is_html:\n            table.lastChild.lastChild.appendChild(document.createTextNode(truncated_html(val + '')))\n        else:\n            if not join:\n                add_val(val)\n            else:\n                for v in val:\n                    add_val(v)\n                    if v is not val[-1]:\n                        table.lastChild.lastChild.appendChild(document.createTextNode(join))\n        return table.lastChild.lastChild\n\n    def process_composite(field, fm, name, val):\n        if fm.display and fm.display.contains_html:\n            add_row(name, val, is_html=True)\n        elif fm.is_multiple and fm.is_multiple.list_to_ui:\n            all_vals = filter(None, map(str.strip, val.split(fm.is_multiple.list_to_ui)))\n            add_row(name, all_vals, join=fm.is_multiple.list_to_ui)\n        else:\n            add_row(name, val)\n\n    def process_authors(field, fm, name, val):\n        add_row(name, val, join=' & ')\n\n    def process_publisher(field, fm, name, val):\n        add_row(name, val)\n\n    def process_rating(field, fm, name, val):\n        stars = E.span()\n        val = int(val or 0)\n        if val > 0:\n            for i in range(val // 2):\n                stars.appendChild(svgicon('star'))\n            if fm.display.allow_half_stars and (val % 2):\n                stars.appendChild(svgicon('star-half'))\n            add_row(name, stars)\n        else:\n            add_row(name, None)\n\n    def process_identifiers(field, fm, name, val):\n        if val:\n            keys = Object.keys(val)\n            if keys.length:\n                table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n                td = table.lastChild.lastChild\n                for k in keys:\n                    if td.childNodes.length:\n                        td.appendChild(document.createTextNode(', '))\n                    td.appendChild(document.createTextNode(k))\n                return\n        add_row(name, None)\n\n    def process_languages(field, fm, name, val):\n        if val and val.length:\n            table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n            td = table.lastChild.lastChild\n            for k in val:\n                lang = mi.lang_names[k] or k\n                td.appendChild(document.createTextNode(lang))\n                if k is not val[-1]:\n                    td.appendChild(document.createTextNode(', '))\n            return\n        add_row(name, None)\n\n    def process_datetime(field, fm, name, val):\n        if val:\n            fmt = interface_data['gui_' + field + '_display_format'] or (fm['display'] or {}).date_format\n            add_row(name, format_date(val, fmt))\n        else:\n            add_row(name, None)\n\n    def process_series(field, fm, name, val):\n        if val:\n            ifield = field + '_index'\n            try:\n                ival = float(resolved_metadata(mi, ifield))\n            except Exception:\n                ival = 1.0\n            ival = fmt_sidx(ival, use_roman=interface_data.use_roman_numerals_for_series_number)\n            table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n            s = safe_set_inner_html(E.span(), _('{0} of <i>{1}</i>').format(ival, val))\n            table.lastChild.lastChild.appendChild(s)\n        else:\n            add_row(name, None)\n\n    def process_field(field, fm):\n        name = fm.name or field\n        datatype = fm.datatype\n        val = resolved_metadata(mi, field)\n        if field is 'comments' or datatype is 'comments':\n            add_row(name, truncated_html(val or ''))\n            return\n        func = None\n        if datatype is 'composite':\n            func = process_composite\n        elif datatype is 'rating':\n            func = process_rating\n        elif field is 'identifiers':\n            func = process_identifiers\n        elif field is 'authors':\n            func = process_authors\n        elif field is 'publisher':\n            func = process_publisher\n        elif field is 'languages':\n            func = process_languages\n        elif datatype is 'datetime':\n            func = process_datetime\n        elif datatype is 'series':\n            func = process_series\n        if func:\n            func(field, fm, name, val)\n        else:\n            if datatype is 'text' or datatype is 'enumeration':\n                if val is not undefined and val is not None:\n                    join = fm.is_multiple.list_to_ui if fm.is_multiple else None\n                    add_row(name, val, join=join)\n                else:\n                    add_row(name, None)\n            elif datatype is 'bool':\n                add_row(name, _('Yes') if val else _('No'))\n            elif datatype is 'int' or datatype is 'float':\n                if val is not undefined and val is not None:\n                    fmt = (fm.display or {}).number_format\n                    if fmt:\n                        val = fmt.format(val)\n                    else:\n                        val += ''\n                    add_row(name, val)\n                else:\n                    add_row(name, None)\n\n    for field in fields:\n        fm = field_metadata[field]\n        if not fm:\n            continue\n        current_edit_action = edit_field.bind(None, container_id, book_id, field)\n        try:\n            process_field(field, fm)\n        except Exception:\n            print('Failed to render metadata field: ' + field)\n            traceback.print_exc()\n\n# }}}\n\n\ndef changes_submitted(container_id, book_id, end_type, xhr, ev):\n    nonlocal changes, has_changes\n    changes = {}\n    has_changes = False\n    if end_type is 'abort':\n        on_close(container_id)\n        return\n    if end_type is not 'load':\n        error_dialog(_('Failed to update metadata on server'), _(\n            'Updating metadata for the book: {} failed.').format(book_id), xhr.error_html)\n        return\n    try:\n        dirtied = JSON.parse(xhr.responseText)\n    except Exception as err:\n        error_dialog(_('Could not update metadata for book'), _('Server returned an invalid response'), err.toString())\n        return\n\n    for bid in dirtied:\n        set_book_metadata(bid, dirtied[book_id])\n    on_close(container_id)\n\n\ndef submit_changes(container_id, book_id):\n    c = document.getElementById(container_id)\n    d = c.querySelector('div[data-ctype=\"show\"]')\n    clear(d)\n    d.appendChild(E.div(style='margin: 1ex 1rem', _('Uploading changes to server, please wait...')))\n    data = {'changes': changes, 'loaded_book_ids': loaded_book_ids()}\n    ajax_send(\n        f'cdb/set-fields/{book_id}/{current_library_id()}', data, changes_submitted.bind(None, container_id, book_id))\n\n\ndef show_book(container_id, book_id):\n    container = document.getElementById(container_id)\n    mi = book_metadata(book_id)\n    if not container or not mi:\n        return\n    div = container.querySelector('div[data-ctype=\"show\"]')\n    if not div:\n        return\n    clear(div)\n    if has_changes:\n        b = create_button(_('Apply changes'), action=submit_changes.bind(None, container_id, book_id))\n        div.appendChild(E.div(style='margin: 1ex 1rem', b))\n    else:\n        div.appendChild(E.div(style='margin: 1ex 1rem', _(\n            'Tap any field below to edit it')))\n    div.appendChild(E.table(class_='metadata'))\n    render_metadata(mi, div.lastChild, container_id, book_id)\n    if has_changes:\n        b = create_button(_('Apply changes'), action=submit_changes.bind(None, container_id, book_id))\n        div.appendChild(E.div(style='margin: 1ex 1rem', b))\n\n\ndef on_close(container_id):\n    c = document.getElementById(container_id)\n    if c:\n        d = c.querySelector('div[data-ctype=\"edit\"]')\n        if d:\n            if d.style.display is 'block':\n                d.style.display = 'none'\n                d.previousSibling.style.display = 'block'\n                clear(d), clear(d.previousSibling)\n                q = parse_url_params()\n                show_book(container_id, int(q.book_id))\n                return\n        back()\n\n\ndef proceed_after_succesful_fetch_metadata(container_id, book_id):\n    nonlocal changes, has_changes\n    changes = {}\n    has_changes = False\n    container = document.getElementById(container_id)\n    mi = book_metadata(book_id)\n    if not mi or not container:\n        show_panel('book_details', query=parse_url_params(), replace=True)\n        return\n    set_title(container, _('Edit metadata for {}').format(mi.title))\n    clear(container.lastChild)\n    container.lastChild.appendChild(E.div(data_ctype='show', style='display:block'))\n    container.lastChild.appendChild(E.div(data_ctype='edit', style='display:none'))\n    show_book(container_id, book_id)\n\n\ndef create_edit_metadata(container):\n    q = parse_url_params()\n    current_book_id = q.book_id\n    if not current_book_id:\n        no_book(container)\n        return\n    current_book_id = int(current_book_id)\n    container_id = container.parentNode.id\n    if not book_metadata(current_book_id):\n        fetch_metadata(container_id, current_book_id, proceed_after_succesful_fetch_metadata)\n    else:\n        proceed_after_succesful_fetch_metadata(container_id, current_book_id)\n\n\ndef check_for_books_loaded():\n    container = this\n    if load_status.loading:\n        conditional_timeout(container.id, 5, check_for_books_loaded)\n        return\n    container = container.lastChild\n    clear(container)\n    if not load_status.ok:\n        report_load_failure(container)\n        return\n    create_edit_metadata(container)\n\n\ndef init(container_id):\n    container = document.getElementById(container_id)\n    create_top_bar(container, title=_('Edit metadata'), action=on_close.bind(None, container_id), icon='close')\n    container.appendChild(E.div(class_=CLASS_NAME))\n    container.lastChild.appendChild(E.div(_('Loading books from the calibre library, please wait...'), style='margin: 1ex 1em'))\n    conditional_timeout(container_id, 5, check_for_books_loaded)\n\n\nset_panel_handler('edit_metadata', init)\n"], "fixing_code": ["#!/usr/bin/env python2\n# vim:fileencoding=utf-8\nfrom __future__ import (unicode_literals, division, absolute_import,\n                        print_function)\n\n__license__ = 'GPL v3'\n__copyright__ = '2013, Kovid Goyal <kovid at kovidgoyal.net>'\n\nimport json\n\nfrom PyQt5.Qt import (\n    Qt, QListWidget, QListWidgetItem, QItemSelectionModel, QAction,\n    QGridLayout, QPushButton, QIcon, QWidget, pyqtSignal, QLabel)\n\nfrom calibre.gui2 import choose_save_file, choose_files\nfrom calibre.utils.icu import sort_key\n\n\nclass BookmarksList(QListWidget):\n\n    changed = pyqtSignal()\n    bookmark_activated = pyqtSignal(object)\n\n    def __init__(self, parent=None):\n        QListWidget.__init__(self, parent)\n        self.setDragEnabled(True)\n        self.setDragDropMode(self.InternalMove)\n        self.setDefaultDropAction(Qt.MoveAction)\n        self.setAlternatingRowColors(True)\n        self.setStyleSheet('QListView::item { padding: 0.5ex }')\n        self.viewport().setAcceptDrops(True)\n        self.setDropIndicatorShown(True)\n        self.setContextMenuPolicy(Qt.ActionsContextMenu)\n        self.ac_edit = ac = QAction(QIcon(I('edit_input.png')), _('Edit this bookmark'), self)\n        self.addAction(ac)\n        self.ac_delete = ac = QAction(QIcon(I('trash.png')), _('Remove this bookmark'), self)\n        self.addAction(ac)\n        self.ac_sort = ac = QAction(_('Sort by name'), self)\n        self.addAction(ac)\n        self.ac_sort_pos = ac = QAction(_('Sort by position in book'), self)\n        self.addAction(ac)\n\n    def dropEvent(self, ev):\n        QListWidget.dropEvent(self, ev)\n        if ev.isAccepted():\n            self.changed.emit()\n\n    def keyPressEvent(self, ev):\n        if ev.key() in (Qt.Key_Enter, Qt.Key_Return):\n            i = self.currentItem()\n            if i is not None:\n                self.bookmark_activated.emit(i)\n                ev.accept()\n                return\n        if ev.key() in (Qt.Key_Delete, Qt.Key_Backspace):\n            i = self.currentItem()\n            if i is not None:\n                self.ac_delete.trigger()\n                ev.accept()\n                return\n        return QListWidget.keyPressEvent(self, ev)\n\n\nclass BookmarkManager(QWidget):\n\n    edited = pyqtSignal(object)\n    activated = pyqtSignal(object)\n    create_requested = pyqtSignal()\n\n    def __init__(self, parent):\n        QWidget.__init__(self, parent)\n        self.l = l = QGridLayout(self)\n        l.setContentsMargins(0, 0, 0, 0)\n        self.setLayout(l)\n\n        self.bookmarks_list = bl = BookmarksList(self)\n        bl.itemChanged.connect(self.item_changed)\n        l.addWidget(bl, 0, 0, 1, -1)\n        bl.itemClicked.connect(self.item_activated)\n        bl.bookmark_activated.connect(self.item_activated)\n        bl.changed.connect(lambda : self.edited.emit(self.get_bookmarks()))\n        bl.ac_edit.triggered.connect(self.edit_bookmark)\n        bl.ac_sort.triggered.connect(self.sort_by_name)\n        bl.ac_sort_pos.triggered.connect(self.sort_by_pos)\n        bl.ac_delete.triggered.connect(self.delete_bookmark)\n\n        self.la = la = QLabel(_(\n            'Double click to edit and drag-and-drop to re-order the bookmarks'))\n        la.setWordWrap(True)\n        l.addWidget(la, l.rowCount(), 0, 1, -1)\n\n        self.button_new = b = QPushButton(QIcon(I('bookmarks.png')), _('&New'), self)\n        b.clicked.connect(self.create_requested)\n        b.setToolTip(_('Create a new bookmark at the current location'))\n        l.addWidget(b)\n\n        self.button_delete = b = QPushButton(QIcon(I('trash.png')), _('&Remove'), self)\n        b.setToolTip(_('Remove the currently selected bookmark'))\n        b.clicked.connect(self.delete_bookmark)\n        l.addWidget(b, l.rowCount() - 1, 1)\n\n        self.button_delete = b = QPushButton(_('Sort by &name'), self)\n        b.setToolTip(_('Sort bookmarks by name'))\n        b.clicked.connect(self.sort_by_name)\n        l.addWidget(b)\n\n        self.button_delete = b = QPushButton(_('Sort by &position'), self)\n        b.setToolTip(_('Sort bookmarks by position in book'))\n        b.clicked.connect(self.sort_by_pos)\n        l.addWidget(b, l.rowCount() - 1, 1)\n\n        self.button_export = b = QPushButton(QIcon(I('back.png')), _('E&xport'), self)\n        b.clicked.connect(self.export_bookmarks)\n        l.addWidget(b)\n\n        self.button_import = b = QPushButton(QIcon(I('forward.png')), _('&Import'), self)\n        b.clicked.connect(self.import_bookmarks)\n        l.addWidget(b, l.rowCount() - 1, 1)\n\n    def item_activated(self, item):\n        bm = self.item_to_bm(item)\n        self.activated.emit(bm)\n\n    def set_bookmarks(self, bookmarks=()):\n        self.bookmarks_list.clear()\n        for bm in bookmarks:\n            if bm['title'] != 'calibre_current_page_bookmark':\n                i = QListWidgetItem(bm['title'])\n                i.setData(Qt.UserRole, self.bm_to_item(bm))\n                i.setFlags(i.flags() | Qt.ItemIsEditable)\n                self.bookmarks_list.addItem(i)\n        if self.bookmarks_list.count() > 0:\n            self.bookmarks_list.setCurrentItem(self.bookmarks_list.item(0), QItemSelectionModel.ClearAndSelect)\n\n    def set_current_bookmark(self, bm):\n        for i, q in enumerate(self):\n            if bm == q:\n                l = self.bookmarks_list\n                item = l.item(i)\n                l.setCurrentItem(item, QItemSelectionModel.ClearAndSelect)\n                l.scrollToItem(item)\n\n    def __iter__(self):\n        for i in xrange(self.bookmarks_list.count()):\n            yield self.item_to_bm(self.bookmarks_list.item(i))\n\n    def item_changed(self, item):\n        self.bookmarks_list.blockSignals(True)\n        title = unicode(item.data(Qt.DisplayRole))\n        if not title:\n            title = _('Unknown')\n            item.setData(Qt.DisplayRole, title)\n        bm = self.item_to_bm(item)\n        bm['title'] = title\n        item.setData(Qt.UserRole, self.bm_to_item(bm))\n        self.bookmarks_list.blockSignals(False)\n        self.edited.emit(self.get_bookmarks())\n\n    def delete_bookmark(self):\n        row = self.bookmarks_list.currentRow()\n        if row > -1:\n            self.bookmarks_list.takeItem(row)\n            self.edited.emit(self.get_bookmarks())\n\n    def edit_bookmark(self):\n        item = self.bookmarks_list.currentItem()\n        if item is not None:\n            self.bookmarks_list.editItem(item)\n\n    def sort_by_name(self):\n        bm = self.get_bookmarks()\n        bm.sort(key=lambda x:sort_key(x['title']))\n        self.set_bookmarks(bm)\n        self.edited.emit(bm)\n\n    def sort_by_pos(self):\n        from calibre.ebooks.epub.cfi.parse import cfi_sort_key\n\n        def pos_key(b):\n            if b.get('type', None) == 'cfi':\n                return b['spine'], cfi_sort_key(b['pos'])\n            return (None, None)\n        bm = self.get_bookmarks()\n        bm.sort(key=pos_key)\n        self.set_bookmarks(bm)\n        self.edited.emit(bm)\n\n    def bm_to_item(self, bm):\n        return bm.copy()\n\n    def item_to_bm(self, item):\n        return item.data(Qt.UserRole).copy()\n\n    def get_bookmarks(self):\n        return list(self)\n\n    def export_bookmarks(self):\n        filename = choose_save_file(\n            self, 'export-viewer-bookmarks', _('Export bookmarks'),\n            filters=[(_('Saved bookmarks'), ['calibre-bookmarks'])], all_files=False, initial_filename='bookmarks.calibre-bookmarks')\n        if filename:\n            with lopen(filename, 'wb') as fileobj:\n                fileobj.write(json.dumps(self.get_bookmarks(), indent=True))\n\n    def import_bookmarks(self):\n        files = choose_files(self, 'export-viewer-bookmarks', _('Import bookmarks'),\n            filters=[(_('Saved bookmarks'), ['calibre-bookmarks'])], all_files=False, select_only_single_file=True)\n        if not files:\n            return\n        filename = files[0]\n\n        imported = None\n        with lopen(filename, 'rb') as fileobj:\n            imported = json.load(fileobj)\n\n        if imported is not None:\n            bad = False\n            try:\n                for bm in imported:\n                    if 'title' not in bm:\n                        bad = True\n                        break\n            except Exception:\n                pass\n\n            if not bad:\n                bookmarks = self.get_bookmarks()\n                for bm in imported:\n                    if bm not in bookmarks:\n                        bookmarks.append(bm)\n                self.set_bookmarks([bm for bm in bookmarks if bm['title'] != 'calibre_current_page_bookmark'])\n                self.edited.emit(self.get_bookmarks())\n", "#!/usr/bin/env python2\n# vim:fileencoding=utf-8\n# License: GPLv3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport cPickle\nimport hashlib\nimport random\nimport shutil\nimport sys\nimport zipfile\nfrom json import load as load_json_file\nfrom threading import Lock\n\nfrom calibre import as_unicode\nfrom calibre.customize.ui import available_input_formats\nfrom calibre.db.view import sanitize_sort_field_name\nfrom calibre.srv.ajax import search_result\nfrom calibre.srv.errors import (\n    BookNotFound, HTTPBadRequest, HTTPForbidden, HTTPNotFound\n)\nfrom calibre.srv.metadata import (\n    book_as_json, categories_as_json, categories_settings, icon_map\n)\nfrom calibre.srv.routes import endpoint, json\nfrom calibre.srv.utils import get_library_data, get_use_roman\nfrom calibre.utils.config import prefs, tweaks\nfrom calibre.utils.icu import sort_key, numeric_sort_key\nfrom calibre.utils.localization import get_lang\nfrom calibre.utils.search_query_parser import ParseException\n\nPOSTABLE = frozenset({'GET', 'POST', 'HEAD'})\n\n\n@endpoint('', auth_required=False)\ndef index(ctx, rd):\n    return lopen(P('content-server/index-generated.html'), 'rb')\n\n\n@endpoint('/calibre.appcache', auth_required=False, cache_control='no-cache')\ndef appcache(ctx, rd):\n    return lopen(P('content-server/calibre.appcache'), 'rb')\n\n\n@endpoint('/robots.txt', auth_required=False)\ndef robots(ctx, rd):\n    return b'User-agent: *\\nDisallow: /'\n\n\n@endpoint('/ajax-setup', auth_required=False, cache_control='no-cache', postprocess=json)\ndef ajax_setup(ctx, rd):\n    auto_reload_port = getattr(rd.opts, 'auto_reload_port', 0)\n    return {\n        'auto_reload_port': max(0, auto_reload_port),\n        'allow_console_print': bool(getattr(rd.opts, 'allow_console_print', False)),\n        'ajax_timeout': rd.opts.ajax_timeout,\n    }\n\n\nprint_lock = Lock()\n\n\n@endpoint('/console-print', methods=('POST', ))\ndef console_print(ctx, rd):\n    if not getattr(rd.opts, 'allow_console_print', False):\n        raise HTTPForbidden('console printing is not allowed')\n    with print_lock:\n        print(rd.remote_addr, end=' ')\n        shutil.copyfileobj(rd.request_body_file, sys.stdout)\n    return ''\n\n\ndef get_basic_query_data(ctx, rd):\n    db, library_id, library_map, default_library = get_library_data(ctx, rd)\n    skeys = db.field_metadata.sortable_field_keys()\n    sorts, orders = [], []\n    for x in rd.query.get('sort', '').split(','):\n        if x:\n            s, o = x.rpartition('.')[::2]\n            if o and not s:\n                s, o = o, ''\n            if o not in ('asc', 'desc'):\n                o = 'asc'\n            if s.startswith('_'):\n                s = '#' + s[1:]\n            s = sanitize_sort_field_name(db.field_metadata, s)\n            if s in skeys:\n                sorts.append(s), orders.append(o)\n    if not sorts:\n        sorts, orders = ['timestamp'], ['desc']\n    return library_id, db, sorts, orders, rd.query.get('vl') or ''\n\n\n_cached_translations = None\n\n\ndef get_translations():\n    global _cached_translations\n    if _cached_translations is None:\n        _cached_translations = False\n        with zipfile.ZipFile(\n            P('content-server/locales.zip', allow_user_override=False), 'r'\n        ) as zf:\n            names = set(zf.namelist())\n            lang = get_lang()\n            if lang not in names:\n                xlang = lang.split('_')[0].lower()\n                if xlang in names:\n                    lang = xlang\n            if lang in names:\n                _cached_translations = load_json_file(zf.open(lang, 'r'))\n    return _cached_translations\n\n\ndef custom_list_template():\n    ans = getattr(custom_list_template, 'ans', None)\n    if ans is None:\n        ans = {\n            'thumbnail': True,\n            'thumbnail_height': 140,\n            'height': 'auto',\n            'comments_fields': ['comments'],\n            'lines': [\n                _('<b>{title}</b> by {authors}'),\n                _('{series_index} of <i>{series}</i>') + '|||{rating}',\n                '{tags}',\n                _('Date: {timestamp}') + '|||' + _('Published: {pubdate}') + '|||' + _('Publisher: {publisher}'),\n                '',\n            ]\n        }\n        custom_list_template.ans = ans\n    return ans\n\n\ndef basic_interface_data(ctx, rd):\n    ans = {\n        'username': rd.username,\n        'output_format': prefs['output_format'].upper(),\n        'input_formats': {x.upper(): True\n                          for x in available_input_formats()},\n        'gui_pubdate_display_format': tweaks['gui_pubdate_display_format'],\n        'gui_timestamp_display_format': tweaks['gui_timestamp_display_format'],\n        'gui_last_modified_display_format': tweaks['gui_last_modified_display_format'],\n        'use_roman_numerals_for_series_number': get_use_roman(),\n        'translations': get_translations(),\n        'icon_map': icon_map(),\n        'icon_path': ctx.url_for('/icon', which=''),\n        'custom_list_template': getattr(ctx, 'custom_list_template', None) or custom_list_template(),\n        'num_per_page': rd.opts.num_per_page,\n    }\n    ans['library_map'], ans['default_library_id'] = ctx.library_info(rd)\n    return ans\n\n\n@endpoint('/interface-data/update', postprocess=json)\ndef update_interface_data(ctx, rd):\n    '''\n    Return the interface data needed for the server UI\n    '''\n    return basic_interface_data(ctx, rd)\n\n\ndef get_field_list(db):\n    fieldlist = list(db.pref('book_display_fields', ()))\n    names = frozenset([x[0] for x in fieldlist])\n    available = frozenset(db.field_metadata.displayable_field_keys())\n    for field in available:\n        if field not in names:\n            fieldlist.append((field, True))\n    return [f for f, d in fieldlist if d and f in available]\n\n\ndef get_library_init_data(ctx, rd, db, num, sorts, orders, vl):\n    ans = {}\n    with db.safe_read_lock:\n        try:\n            ans['search_result'] = search_result(\n                ctx, rd, db,\n                rd.query.get('search', ''), num, 0, ','.join(sorts),\n                ','.join(orders), vl\n            )\n        except ParseException:\n            ans['search_result'] = search_result(\n                ctx, rd, db, '', num, 0, ','.join(sorts), ','.join(orders), vl\n            )\n        sf = db.field_metadata.ui_sortable_field_keys()\n        sf.pop('ondevice', None)\n        ans['sortable_fields'] = sorted(\n            ((sanitize_sort_field_name(db.field_metadata, k), v)\n             for k, v in sf.iteritems()),\n            key=lambda (field, name): sort_key(name)\n        )\n        ans['field_metadata'] = db.field_metadata.all_metadata()\n        ans['virtual_libraries'] = db._pref('virtual_libraries', {})\n        ans['book_display_fields'] = get_field_list(db)\n        mdata = ans['metadata'] = {}\n        try:\n            extra_books = set(\n                int(x) for x in rd.query.get('extra_books', '').split(',')\n            )\n        except Exception:\n            extra_books = ()\n        for coll in (ans['search_result']['book_ids'], extra_books):\n            for book_id in coll:\n                if book_id not in mdata:\n                    data = book_as_json(db, book_id)\n                    if data is not None:\n                        mdata[book_id] = data\n    return ans\n\n\n@endpoint('/interface-data/books-init', postprocess=json)\ndef books(ctx, rd):\n    '''\n    Get data to create list of books\n\n    Optional: ?num=50&sort=timestamp.desc&library_id=<default library>\n              &search=''&extra_books=''&vl=''\n    '''\n    ans = {}\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    library_id, db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n    ans = get_library_init_data(ctx, rd, db, num, sorts, orders, vl)\n    ans['library_id'] = library_id\n    return ans\n\n\n@endpoint('/interface-data/init', postprocess=json)\ndef interface_data(ctx, rd):\n    '''\n    Return the data needed to create the server UI as well as a list of books.\n\n    Optional: ?num=50&sort=timestamp.desc&library_id=<default library>\n              &search=''&extra_books=''&vl=''\n    '''\n    ans = basic_interface_data(ctx, rd)\n    ud = {}\n    if rd.username:\n        # Override session data with stored values for the authenticated user,\n        # if any\n        ud = ctx.user_manager.get_session_data(rd.username)\n        lid = ud.get('library_id')\n        if lid and lid in ans['library_map']:\n            rd.query.set('library_id', lid)\n        usort = ud.get('sort')\n        if usort:\n            rd.query.set('sort', usort)\n    ans['library_id'], db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n    ans['user_session_data'] = ud\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    ans.update(get_library_init_data(ctx, rd, db, num, sorts, orders, vl))\n    return ans\n\n\n@endpoint('/interface-data/more-books', postprocess=json, methods=POSTABLE)\ndef more_books(ctx, rd):\n    '''\n    Get more results from the specified search-query, which must\n    be specified as JSON in the request body.\n\n    Optional: ?num=50&library_id=<default library>\n    '''\n    db, library_id = get_library_data(ctx, rd)[:2]\n\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    try:\n        search_query = load_json_file(rd.request_body_file)\n        query, offset, sorts, orders, vl = search_query['query'], search_query[\n            'offset'\n        ], search_query['sort'], search_query['sort_order'], search_query['vl']\n    except KeyError as err:\n        raise HTTPBadRequest('Search query missing key: %s' % as_unicode(err))\n    except Exception as err:\n        raise HTTPBadRequest('Invalid query: %s' % as_unicode(err))\n    ans = {}\n    with db.safe_read_lock:\n        ans['search_result'] = search_result(\n            ctx, rd, db, query, num, offset, sorts, orders, vl\n        )\n        mdata = ans['metadata'] = {}\n        for book_id in ans['search_result']['book_ids']:\n            data = book_as_json(db, book_id)\n            if data is not None:\n                mdata[book_id] = data\n\n    return ans\n\n\n@endpoint('/interface-data/set-session-data', postprocess=json, methods=POSTABLE)\ndef set_session_data(ctx, rd):\n    '''\n    Store session data persistently so that it is propagated automatically to\n    new logged in clients\n    '''\n    if rd.username:\n        try:\n            new_data = load_json_file(rd.request_body_file)\n            if not isinstance(new_data, dict):\n                raise Exception('session data must be a dict')\n        except Exception as err:\n            raise HTTPBadRequest('Invalid data: %s' % as_unicode(err))\n        ud = ctx.user_manager.get_session_data(rd.username)\n        ud.update(new_data)\n        ctx.user_manager.set_session_data(rd.username, ud)\n\n\n@endpoint('/interface-data/get-books', postprocess=json)\ndef get_books(ctx, rd):\n    '''\n    Get books for the specified query\n\n    Optional: ?library_id=<default library>&num=50&sort=timestamp.desc&search=''&vl=''\n    '''\n    library_id, db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n    try:\n        num = int(rd.query.get('num', rd.opts.num_per_page))\n    except Exception:\n        raise HTTPNotFound('Invalid number of books: %r' % rd.query.get('num'))\n    searchq = rd.query.get('search', '')\n    db = get_library_data(ctx, rd)[0]\n    ans = {}\n    mdata = ans['metadata'] = {}\n    with db.safe_read_lock:\n        try:\n            ans['search_result'] = search_result(\n                ctx, rd, db, searchq, num, 0, ','.join(sorts), ','.join(orders), vl\n            )\n        except ParseException as err:\n            # This must not be translated as it is used by the front end to\n            # detect invalid search expressions\n            raise HTTPBadRequest('Invalid search expression: %s' % as_unicode(err))\n        for book_id in ans['search_result']['book_ids']:\n            data = book_as_json(db, book_id)\n            if data is not None:\n                mdata[book_id] = data\n    return ans\n\n\n@endpoint('/interface-data/book-metadata/{book_id=0}', postprocess=json)\ndef book_metadata(ctx, rd, book_id):\n    '''\n    Get metadata for the specified book. If no book_id is specified, return metadata for a random book.\n\n    Optional: ?library_id=<default library>&vl=<virtual library>\n    '''\n    library_id, db, sorts, orders, vl = get_basic_query_data(ctx, rd)\n\n    if not book_id:\n        all_ids = ctx.allowed_book_ids(rd, db)\n        book_id = random.choice(tuple(all_ids))\n    elif not ctx.has_id(rd, db, book_id):\n        raise BookNotFound(book_id, db)\n    data = book_as_json(db, book_id)\n    if data is None:\n        raise BookNotFound(book_id, db)\n    data['id'] = book_id  # needed for random book view (when book_id=0)\n    return data\n\n\n@endpoint('/interface-data/tag-browser')\ndef tag_browser(ctx, rd):\n    '''\n    Get the Tag Browser serialized as JSON\n    Optional: ?library_id=<default library>&sort_tags_by=name&partition_method=first letter\n              &collapse_at=25&dont_collapse=&hide_empty_categories=&vl=''\n    '''\n    db, library_id = get_library_data(ctx, rd)[:2]\n    opts = categories_settings(rd.query, db)\n    vl = rd.query.get('vl') or ''\n    etag = cPickle.dumps([db.last_modified().isoformat(), rd.username, library_id, vl, list(opts)], -1)\n    etag = hashlib.sha1(etag).hexdigest()\n\n    def generate():\n        return json(ctx, rd, tag_browser, categories_as_json(ctx, rd, db, opts, vl))\n\n    return rd.etagged_dynamic_response(etag, generate)\n\n\n@endpoint('/interface-data/field-names/{field}', postprocess=json)\ndef field_names(ctx, rd, field):\n    '''\n    Get a list of all names for the specified field\n    Optional: ?library_id=<default library>\n    '''\n    db, library_id = get_library_data(ctx, rd)[:2]\n    return tuple(sorted(db.all_field_names(field), key=numeric_sort_key))\n", "# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2018, Kovid Goyal <kovid at kovidgoyal.net>\nfrom __python__ import bound_methods, hash_literals\n\nimport traceback\nfrom elementmaker import E\nfrom gettext import gettext as _\n\nfrom ajax import ajax_send\nfrom book_list.book_details import (\n    basic_table_rules, fetch_metadata, field_sorter, no_book, report_load_failure\n)\nfrom book_list.library_data import (\n    book_metadata, current_library_id, field_names_for, library_data, load_status,\n    loaded_book_ids, set_book_metadata\n)\nfrom book_list.router import back\nfrom book_list.theme import get_color\nfrom book_list.top_bar import create_top_bar, set_title\nfrom book_list.ui import set_panel_handler, show_panel\nfrom date import format_date\nfrom dom import add_extra_css, build_rule, clear, svgicon\nfrom modals import error_dialog\nfrom session import get_interface_data\nfrom utils import (\n    conditional_timeout, fmt_sidx, parse_url_params, safe_set_inner_html\n)\nfrom widgets import create_button\n\nCLASS_NAME = 'edit-metadata-panel'\nIGNORED_FIELDS = {'formats', 'sort', 'uuid', 'id', 'urls_from_identifiers', 'lang_names', 'last_modified', 'path', 'marked', 'size', 'ondevice', 'cover', 'au_map', 'isbn'}\nvalue_to_json = None\nchanges = {}\nhas_changes = False\n\nadd_extra_css(def():\n    sel = '.' + CLASS_NAME + ' '\n    style = basic_table_rules(sel)\n    style += build_rule(sel + 'table.metadata', margin_left='1rem')\n    style += build_rule(sel + 'table.metadata td', padding_bottom='0.5ex', padding_top='0.5ex', cursor='pointer')\n    style += build_rule(sel + 'table.metadata tr:hover', color='red')\n    style += build_rule(sel + 'table.metadata tr:active', transform='scale(1.5)')\n\n    style += build_rule(sel + '.completions', display='flex', flex_wrap='wrap', align_items='center')\n    style += build_rule(sel + '.completions > div', margin='0.5ex 0.5rem', margin_left='0', padding='0.5ex 0.5rem', border='solid 1px currentColor', border_radius='1ex', cursor='pointer')\n    style += build_rule(sel + '.completions > div:active', transform='scale(1.5)')\n    style += build_rule(sel + '.completions > div:hover', background=get_color('window-foreground'), color=get_color('window-background'))\n    return style\n)\n\n\ndef resolved_metadata(mi, field):\n    if Object.prototype.hasOwnProperty.call(changes, field):\n        return changes[field]\n    return mi[field]\n\n\ndef truncated_html(val):\n    ans = val.replace(/<[^>]+>/g, '')\n    if ans.length > 40:\n        ans = ans[:40] + '\u2026'\n    return ans\n\n\n\ndef onsubmit_field(get_value, container_id, book_id, field):\n    c = document.getElementById(container_id)\n    if not c:\n        return\n    d = c.querySelector('div[data-ctype=\"edit\"]')\n    if not d:\n        return\n    ok, value = get_value(d)\n    if not ok:\n        return\n    if value is book_metadata(book_id)[field]:\n        on_close(container_id)\n        return\n\n    def proceed():\n        nonlocal has_changes\n        clear(d)\n        d.appendChild(E.div(style='margin: 1ex 1rem', _('Contacting server, please wait') + '\u2026'))\n        jval = value_to_json(value)\n        changes[field] = jval\n        has_changes = True\n        show_book(container_id, book_id)\n        on_close(container_id)\n\n\n    window.setTimeout(proceed, 0)  # needed to avoid console error about form submission failing because form is removed from DOM in onsubmit handler\n\n\ndef create_form(widget, get_value, container_id, book_id, field, *edit_widgets):\n    submit_action = onsubmit_field.bind(None, get_value, container_id, book_id, field)\n    button = create_button(_('OK'), action=submit_action)\n    widget.classList.add('metadata-editor')\n    form = E.form(\n        action='javascript: void(0)', onsubmit=submit_action, style='margin: 1ex auto',\n        E.div(widget, style='margin-bottom: 1ex'),\n        E.div(button)\n    )\n    return form\n\n\ndef line_edit_get_value(container):\n    return True, container.querySelector('input[type=\"text\"]').value\n\n\ndef simple_line_edit(container_id, book_id, field, fm, div, mi):\n    nonlocal value_to_json\n    name = fm.name or field\n    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True)\n    le.value = resolved_metadata(mi, field) or ''\n    form = create_form(le, line_edit_get_value, container_id, book_id, field)\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', _('Edit the \"{}\" below').format(name)))\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', form))\n    le.focus(), le.select()\n    value_to_json = def(x):\n        return x\n\n\ndef add_completion(container_id, name):\n    pass\n\n\ndef show_completions(container_id, div, field, prefix, names):\n    clear(div)\n    completions = E.div(class_='completions')\n    div.appendChild(completions)\n    for i, name in enumerate(names):\n        completions.appendChild(E.div(name, onclick=add_completion.bind(None, container_id, name)))\n        if i >= 50:\n            break\n\n\ndef update_completions(container_id, ok, field, names):\n    c = document.getElementById(container_id)\n    if not c:\n        return\n    d = c.querySelector('div[data-ctype=\"edit\"]')\n    if not d or d.style.display is not 'block':\n        return\n    div = d.lastChild\n    clear(div)\n    if not ok:\n        err = E.div()\n        safe_set_inner_html(err, names)\n        div.appendChild(E.div(\n            _('Failed to download items for completion, with error:'), err\n        ))\n        return\n    val = d.querySelector('input').value or ''\n    val = value_to_json(val)\n    if jstype(val) is 'string':\n        prefix = val\n    else:\n        prefix = val[-1] if val.length else ''\n    if prefix is update_completions.prefix:\n        return\n    pl = prefix.toLowerCase().strip()\n    if pl:\n        if pl.startswith(update_completions.prefix.toLowerCase()):\n            matching_names = [x for x in update_completions.names if x.toLowerCase().startswith(pl)]\n        else:\n            matching_names = [x for x in names if x.toLowerCase().startswith(pl)]\n    else:\n        matching_names = []\n    update_completions.prefix = prefix\n    update_completions.names = matching_names\n    show_completions(container_id, div, field, prefix, matching_names)\n\n\nupdate_completions.ui_to_list = None\nupdate_completions.list_to_ui = None\nupdate_completions.names = v'[]'\nupdate_completions.prefix = ''\n\n\ndef line_edit_updated(container_id, field):\n    field_names_for(field, update_completions.bind(None, container_id))\n\n\ndef multiple_line_edit(list_to_ui, ui_to_list, container_id, book_id, field, fm, div, mi):\n    nonlocal value_to_json\n    update_completions.ui_to_list = ui_to_list\n    update_completions.list_to_ui = list_to_ui\n    name = fm.name or field\n    le = E.input(type='text', name=name.replace('#', '_c_'), autocomplete=True, oninput=line_edit_updated.bind(None, container_id, field))\n    le.value = (resolved_metadata(mi, field) or v'[]').join(list_to_ui)\n    form = create_form(le, line_edit_get_value, container_id, book_id, field)\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', _(\n        'Edit the \"{0}\" below. Multiple items can be separated by {1}.').format(name, list_to_ui.strip())))\n    div.appendChild(E.div(style='margin: 0.5ex 1rem', form))\n    div.appendChild(E.div(E.span(_('Loading all {}...').format(name)), style='margin: 0.5ex 1rem'))\n    le.focus(), le.select()\n    value_to_json = def(x):\n        return [a.strip() for a in x.split(ui_to_list) if a.strip()]\n    field_names_for(field, update_completions.bind(None, container_id))\n\n\ndef edit_field(container_id, book_id, field):\n    nonlocal value_to_json\n    fm = library_data.field_metadata[field]\n    c = document.getElementById(container_id)\n    mi = book_metadata(book_id)\n    if not c or not fm or not mi:\n        return\n    d = c.querySelector('div[data-ctype=\"edit\"]')\n    d.style.display = 'block'\n    d.previousSibling.style.display = 'none'\n    clear(d)\n    update_completions.ui_to_list = None\n    update_completions.list_to_ui = None\n    update_completions.names = v'[]'\n    update_completions.prefix = ''\n    if field is 'authors':\n        multiple_line_edit(' & ', '&', container_id, book_id, field, fm, d, mi)\n    else:\n        simple_line_edit(container_id, book_id, field, fm, d, mi)\n    if field is 'title':\n        value_to_json = def(x):\n            return x or _('Untitled')\n    elif field is 'authors':\n        value_to_json = def(x):\n            return [a.strip() for a in x.split('&') if a.strip()] or [_('Unknown')]\n\n\ndef render_metadata(mi, table, container_id, book_id):  # {{{\n    field_metadata = library_data.field_metadata\n    interface_data = get_interface_data()\n    current_edit_action = None\n\n    def allowed_fields(field):\n        if field.endswith('_index'):\n            fm = field_metadata[field[:-len('_index')]]\n            if fm and fm.datatype is 'series':\n                return False\n        if field.startswith('#'):\n            return True\n        if field in IGNORED_FIELDS or field.endswith('_sort') or field[0] is '@':\n            return False\n        return True\n\n    fields = library_data.book_display_fields\n    if not fields or not fields.length:\n        fields = sorted(filter(allowed_fields, mi), key=field_sorter(field_metadata))\n    else:\n        fields = filter(allowed_fields, fields)\n    fields = list(fields)\n    added_fields = {f:True for f in fields}\n    if not added_fields.title:\n        added_fields.title = True\n        fields.insert(0, 'title')\n    for other_field in Object.keys(library_data.field_metadata):\n        if not added_fields[other_field] and allowed_fields(other_field) and other_field not in IGNORED_FIELDS:\n            fields.push(other_field)\n\n    def add_row(name, val, is_html=False, join=None):\n        if val is undefined or val is None:\n            val = v'[\" \"]' if join else '\\xa0'\n        def add_val(v):\n            if not v.appendChild:\n                v += ''\n            if v.appendChild:\n                table.lastChild.lastChild.appendChild(v)\n            else:\n                table.lastChild.lastChild.appendChild(document.createTextNode(v))\n\n        table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n        if is_html:\n            table.lastChild.lastChild.appendChild(document.createTextNode(truncated_html(val + '')))\n        else:\n            if not join:\n                add_val(val)\n            else:\n                for v in val:\n                    add_val(v)\n                    if v is not val[-1]:\n                        table.lastChild.lastChild.appendChild(document.createTextNode(join))\n        return table.lastChild.lastChild\n\n    def process_composite(field, fm, name, val):\n        if fm.display and fm.display.contains_html:\n            add_row(name, val, is_html=True)\n        elif fm.is_multiple and fm.is_multiple.list_to_ui:\n            all_vals = filter(None, map(str.strip, val.split(fm.is_multiple.list_to_ui)))\n            add_row(name, all_vals, join=fm.is_multiple.list_to_ui)\n        else:\n            add_row(name, val)\n\n    def process_authors(field, fm, name, val):\n        add_row(name, val, join=' & ')\n\n    def process_publisher(field, fm, name, val):\n        add_row(name, val)\n\n    def process_rating(field, fm, name, val):\n        stars = E.span()\n        val = int(val or 0)\n        if val > 0:\n            for i in range(val // 2):\n                stars.appendChild(svgicon('star'))\n            if fm.display.allow_half_stars and (val % 2):\n                stars.appendChild(svgicon('star-half'))\n            add_row(name, stars)\n        else:\n            add_row(name, None)\n\n    def process_identifiers(field, fm, name, val):\n        if val:\n            keys = Object.keys(val)\n            if keys.length:\n                table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n                td = table.lastChild.lastChild\n                for k in keys:\n                    if td.childNodes.length:\n                        td.appendChild(document.createTextNode(', '))\n                    td.appendChild(document.createTextNode(k))\n                return\n        add_row(name, None)\n\n    def process_languages(field, fm, name, val):\n        if val and val.length:\n            table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n            td = table.lastChild.lastChild\n            for k in val:\n                lang = mi.lang_names[k] or k\n                td.appendChild(document.createTextNode(lang))\n                if k is not val[-1]:\n                    td.appendChild(document.createTextNode(', '))\n            return\n        add_row(name, None)\n\n    def process_datetime(field, fm, name, val):\n        if val:\n            fmt = interface_data['gui_' + field + '_display_format'] or (fm['display'] or {}).date_format\n            add_row(name, format_date(val, fmt))\n        else:\n            add_row(name, None)\n\n    def process_series(field, fm, name, val):\n        if val:\n            ifield = field + '_index'\n            try:\n                ival = float(resolved_metadata(mi, ifield))\n            except Exception:\n                ival = 1.0\n            ival = fmt_sidx(ival, use_roman=interface_data.use_roman_numerals_for_series_number)\n            table.appendChild(E.tr(onclick=current_edit_action, E.td(name + ':'), E.td()))\n            s = safe_set_inner_html(E.span(), _('{0} of <i>{1}</i>').format(ival, val))\n            table.lastChild.lastChild.appendChild(s)\n        else:\n            add_row(name, None)\n\n    def process_field(field, fm):\n        name = fm.name or field\n        datatype = fm.datatype\n        val = resolved_metadata(mi, field)\n        if field is 'comments' or datatype is 'comments':\n            add_row(name, truncated_html(val or ''))\n            return\n        func = None\n        if datatype is 'composite':\n            func = process_composite\n        elif datatype is 'rating':\n            func = process_rating\n        elif field is 'identifiers':\n            func = process_identifiers\n        elif field is 'authors':\n            func = process_authors\n        elif field is 'publisher':\n            func = process_publisher\n        elif field is 'languages':\n            func = process_languages\n        elif datatype is 'datetime':\n            func = process_datetime\n        elif datatype is 'series':\n            func = process_series\n        if func:\n            func(field, fm, name, val)\n        else:\n            if datatype is 'text' or datatype is 'enumeration':\n                if val is not undefined and val is not None:\n                    join = fm.is_multiple.list_to_ui if fm.is_multiple else None\n                    add_row(name, val, join=join)\n                else:\n                    add_row(name, None)\n            elif datatype is 'bool':\n                add_row(name, _('Yes') if val else _('No'))\n            elif datatype is 'int' or datatype is 'float':\n                if val is not undefined and val is not None:\n                    fmt = (fm.display or {}).number_format\n                    if fmt:\n                        val = fmt.format(val)\n                    else:\n                        val += ''\n                    add_row(name, val)\n                else:\n                    add_row(name, None)\n\n    for field in fields:\n        fm = field_metadata[field]\n        if not fm:\n            continue\n        current_edit_action = edit_field.bind(None, container_id, book_id, field)\n        try:\n            process_field(field, fm)\n        except Exception:\n            print('Failed to render metadata field: ' + field)\n            traceback.print_exc()\n\n# }}}\n\n\ndef changes_submitted(container_id, book_id, end_type, xhr, ev):\n    nonlocal changes, has_changes\n    changes = {}\n    has_changes = False\n    if end_type is 'abort':\n        on_close(container_id)\n        return\n    if end_type is not 'load':\n        error_dialog(_('Failed to update metadata on server'), _(\n            'Updating metadata for the book: {} failed.').format(book_id), xhr.error_html)\n        return\n    try:\n        dirtied = JSON.parse(xhr.responseText)\n    except Exception as err:\n        error_dialog(_('Could not update metadata for book'), _('Server returned an invalid response'), err.toString())\n        return\n\n    for bid in dirtied:\n        set_book_metadata(bid, dirtied[book_id])\n    on_close(container_id)\n\n\ndef submit_changes(container_id, book_id):\n    c = document.getElementById(container_id)\n    d = c.querySelector('div[data-ctype=\"show\"]')\n    clear(d)\n    d.appendChild(E.div(style='margin: 1ex 1rem', _('Uploading changes to server, please wait...')))\n    data = {'changes': changes, 'loaded_book_ids': loaded_book_ids()}\n    ajax_send(\n        f'cdb/set-fields/{book_id}/{current_library_id()}', data, changes_submitted.bind(None, container_id, book_id))\n\n\ndef show_book(container_id, book_id):\n    container = document.getElementById(container_id)\n    mi = book_metadata(book_id)\n    if not container or not mi:\n        return\n    div = container.querySelector('div[data-ctype=\"show\"]')\n    if not div:\n        return\n    clear(div)\n    if has_changes:\n        b = create_button(_('Apply changes'), action=submit_changes.bind(None, container_id, book_id))\n        div.appendChild(E.div(style='margin: 1ex 1rem', b))\n    else:\n        div.appendChild(E.div(style='margin: 1ex 1rem', _(\n            'Tap any field below to edit it')))\n    div.appendChild(E.table(class_='metadata'))\n    render_metadata(mi, div.lastChild, container_id, book_id)\n    if has_changes:\n        b = create_button(_('Apply changes'), action=submit_changes.bind(None, container_id, book_id))\n        div.appendChild(E.div(style='margin: 1ex 1rem', b))\n\n\ndef on_close(container_id):\n    c = document.getElementById(container_id)\n    if c:\n        d = c.querySelector('div[data-ctype=\"edit\"]')\n        if d:\n            if d.style.display is 'block':\n                d.style.display = 'none'\n                d.previousSibling.style.display = 'block'\n                clear(d), clear(d.previousSibling)\n                q = parse_url_params()\n                show_book(container_id, int(q.book_id))\n                return\n        back()\n\n\ndef proceed_after_succesful_fetch_metadata(container_id, book_id):\n    nonlocal changes, has_changes\n    changes = {}\n    has_changes = False\n    container = document.getElementById(container_id)\n    mi = book_metadata(book_id)\n    if not mi or not container:\n        show_panel('book_details', query=parse_url_params(), replace=True)\n        return\n    set_title(container, _('Edit metadata for {}').format(mi.title))\n    clear(container.lastChild)\n    container.lastChild.appendChild(E.div(data_ctype='show', style='display:block'))\n    container.lastChild.appendChild(E.div(data_ctype='edit', style='display:none'))\n    show_book(container_id, book_id)\n\n\ndef create_edit_metadata(container):\n    q = parse_url_params()\n    current_book_id = q.book_id\n    if not current_book_id:\n        no_book(container)\n        return\n    current_book_id = int(current_book_id)\n    container_id = container.parentNode.id\n    if not book_metadata(current_book_id):\n        fetch_metadata(container_id, current_book_id, proceed_after_succesful_fetch_metadata)\n    else:\n        proceed_after_succesful_fetch_metadata(container_id, current_book_id)\n\n\ndef check_for_books_loaded():\n    container = this\n    if load_status.loading:\n        conditional_timeout(container.id, 5, check_for_books_loaded)\n        return\n    container = container.lastChild\n    clear(container)\n    if not load_status.ok:\n        report_load_failure(container)\n        return\n    create_edit_metadata(container)\n\n\ndef init(container_id):\n    container = document.getElementById(container_id)\n    create_top_bar(container, title=_('Edit metadata'), action=on_close.bind(None, container_id), icon='close')\n    container.appendChild(E.div(class_=CLASS_NAME))\n    container.lastChild.appendChild(E.div(_('Loading books from the calibre library, please wait...'), style='margin: 1ex 1em'))\n    conditional_timeout(container_id, 5, check_for_books_loaded)\n\n\nset_panel_handler('edit_metadata', init)\n"], "filenames": ["src/calibre/gui2/viewer/bookmarkmanager.py", "src/calibre/srv/code.py", "src/pyj/book_list/edit_metadata.pyj"], "buggy_code_start_loc": [9, 29, 17], "buggy_code_end_loc": [215, 397, 144], "fixing_code_start_loc": [9, 29, 18], "fixing_code_end_loc": [215, 397, 217], "type": "CWE-502", "message": "gui2/viewer/bookmarkmanager.py in Calibre 3.18 calls cPickle.load on imported bookmark data, which allows remote attackers to execute arbitrary code via a crafted .pickle file, as demonstrated by Python code that contains an os.system call.", "other": {"cve": {"id": "CVE-2018-7889", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-08T21:29:00.207", "lastModified": "2018-10-12T18:21:43.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "gui2/viewer/bookmarkmanager.py in Calibre 3.18 calls cPickle.load on imported bookmark data, which allows remote attackers to execute arbitrary code via a crafted .pickle file, as demonstrated by Python code that contains an os.system call."}, {"lang": "es", "value": "gui2/viewer/bookmarkmanager.py en Calibre 3.18 llama a cPickle.load en los datos importados de marcap\u00e1ginas, lo que permite que atacantes remotos ejecuten c\u00f3digo arbitrario mediante un archivo .pickle manipulado. Esto se demuestra por el c\u00f3digo Python que contiene una llamada os.system."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-502"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:calibre-ebook:calibre:3.18.0:*:*:*:*:*:*:*", "matchCriteriaId": "17A3979D-F8DF-4ADC-A75E-36471893EE95"}]}]}], "references": [{"url": "https://bugs.launchpad.net/calibre/+bug/1753870", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/kovidgoyal/calibre/commit/aeb5b036a0bf657951756688b3c72bd68b6e4a7d", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/kovidgoyal/calibre/commit/aeb5b036a0bf657951756688b3c72bd68b6e4a7d"}}