{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RemoteFX USB Redirection\n *\n * Copyright 2012 Atrust corp.\n * Copyright 2012 Alfred Liu <alfred.liu@atruscorp.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/sysinfo.h>\n\n#include <urbdrc_helpers.h>\n\n#include \"urbdrc_types.h\"\n#include \"data_transfer.h\"\n\nstatic void usb_process_get_port_status(IUDEVICE* pdev, wStream* out)\n{\n\tint bcdUSB = pdev->query_device_descriptor(pdev, BCD_USB);\n\n\tswitch (bcdUSB)\n\t{\n\t\tcase USB_v1_0:\n\t\t\tStream_Write_UINT32(out, 0x303);\n\t\t\tbreak;\n\n\t\tcase USB_v1_1:\n\t\t\tStream_Write_UINT32(out, 0x103);\n\t\t\tbreak;\n\n\t\tcase USB_v2_0:\n\t\t\tStream_Write_UINT32(out, 0x503);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tStream_Write_UINT32(out, 0x503);\n\t\t\tbreak;\n\t}\n}\n\nstatic UINT urb_write_completion(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, BOOL noAck,\n                                 wStream* out, UINT32 InterfaceId, UINT32 MessageId,\n                                 UINT32 RequestId, UINT32 usbd_status, UINT32 OutputBufferSize)\n{\n\tif (!out)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_Capacity(out) < OutputBufferSize + 36)\n\t{\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tStream_SetPosition(out, 0);\n\tStream_Write_UINT32(out, InterfaceId); /** interface */\n\tStream_Write_UINT32(out, MessageId);   /** message id */\n\n\tif (OutputBufferSize != 0)\n\t\tStream_Write_UINT32(out, URB_COMPLETION);\n\telse\n\t\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA);\n\n\tStream_Write_UINT32(out, RequestId); /** RequestId */\n\tStream_Write_UINT32(out, 8);         /** CbTsUrbResult */\n\t/** TsUrbResult TS_URB_RESULT_HEADER */\n\tStream_Write_UINT16(out, 8);                /** Size */\n\tStream_Write_UINT16(out, 0);                /* Padding */\n\tStream_Write_UINT32(out, usbd_status);      /** UsbdStatus */\n\tStream_Write_UINT32(out, 0);                /** HResult */\n\tStream_Write_UINT32(out, OutputBufferSize); /** OutputBufferSize */\n\tStream_Seek(out, OutputBufferSize);\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic wStream* urb_create_iocompletion(UINT32 InterfaceField, UINT32 MessageId, UINT32 RequestId,\n                                        UINT32 OutputBufferSize)\n{\n\tconst UINT32 InterfaceId = (STREAM_ID_PROXY << 30) | (InterfaceField & 0x3FFFFFFF);\n\n#if UINT32_MAX >= SIZE_MAX\n\tif (OutputBufferSize > UINT32_MAX - 28ull)\n\t\treturn NULL;\n#endif\n\n\twStream* out = Stream_New(NULL, OutputBufferSize + 28ull);\n\n\tif (!out)\n\t\treturn NULL;\n\n\tStream_Write_UINT32(out, InterfaceId);          /** interface */\n\tStream_Write_UINT32(out, MessageId);            /** message id */\n\tStream_Write_UINT32(out, IOCONTROL_COMPLETION); /** function id */\n\tStream_Write_UINT32(out, RequestId);            /** RequestId */\n\tStream_Write_UINT32(out, USBD_STATUS_SUCCESS);  /** HResult */\n\tStream_Write_UINT32(out, OutputBufferSize);     /** Information */\n\tStream_Write_UINT32(out, OutputBufferSize);     /** OutputBufferSize */\n\treturn out;\n}\n\nstatic UINT urbdrc_process_register_request_callback(IUDEVICE* pdev,\n                                                     URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                                     IUDEVMAN* udevman)\n{\n\tUINT32 NumRequestCompletion = 0;\n\tUINT32 RequestCompletion = 0;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urbdrc_process_register_request_callback\");\n\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT32(s, NumRequestCompletion); /** must be 1 */\n\t\t/** RequestCompletion:\n\t\t *   unique Request Completion interface for the client to use */\n\t\tStream_Read_UINT32(s, RequestCompletion);\n\t\tpdev->set_ReqCompletion(pdev, RequestCompletion);\n\t}\n\telse if (Stream_GetRemainingLength(s) >= 4) /** Unregister the device */\n\t{\n\t\tStream_Read_UINT32(s, RequestCompletion);\n\n\t\tif (pdev->get_ReqCompletion(pdev) == RequestCompletion)\n\t\t\tpdev->setChannelClosed(pdev);\n\t}\n\telse\n\t\treturn ERROR_INVALID_DATA;\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urbdrc_process_cancel_request(IUDEVICE* pdev, wStream* s, IUDEVMAN* udevman)\n{\n\tUINT32 CancelId;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)udevman->plugin;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, CancelId);\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"CANCEL_REQUEST: CancelId=%08\" PRIx32 \"\", CancelId);\n\n\tif (pdev->cancel_transfer_request(pdev, CancelId) < 0)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urbdrc_process_retract_device_request(IUDEVICE* pdev, wStream* s, IUDEVMAN* udevman)\n{\n\tUINT32 Reason;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)udevman->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, Reason); /** Reason */\n\n\tswitch (Reason)\n\t{\n\t\tcase UsbRetractReason_BlockedByPolicy:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"UsbRetractReason_BlockedByPolicy: now it is not support\");\n\t\t\treturn ERROR_ACCESS_DENIED;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"urbdrc_process_retract_device_request: Unknown Reason %\" PRIu32 \"\", Reason);\n\t\t\treturn ERROR_ACCESS_DENIED;\n\t}\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urbdrc_process_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                      UINT32 MessageId, IUDEVMAN* udevman)\n{\n\tUINT32 InterfaceId;\n\tUINT32 IoControlCode;\n\tUINT32 InputBufferSize;\n\tUINT32 OutputBufferSize;\n\tUINT32 RequestId;\n\tUINT32 usbd_status = USBD_STATUS_SUCCESS;\n\twStream* out;\n\tint success = 0;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, IoControlCode);\n\tStream_Read_UINT32(s, InputBufferSize);\n\n\tif (!Stream_SafeSeek(s, InputBufferSize))\n\t\treturn ERROR_INVALID_DATA;\n\tif (Stream_GetRemainingLength(s) < 8ULL)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tStream_Read_UINT32(s, RequestId);\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tout = urb_create_iocompletion(InterfaceId, MessageId, RequestId, OutputBufferSize + 4);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tswitch (IoControlCode)\n\t{\n\t\tcase IOCTL_INTERNAL_USB_SUBMIT_URB: /** 0x00220003 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_SUBMIT_URB\");\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \" Function IOCTL_INTERNAL_USB_SUBMIT_URB: Unchecked\");\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_RESET_PORT: /** 0x00220007 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_RESET_PORT\");\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_GET_PORT_STATUS: /** 0x00220013 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_GET_PORT_STATUS\");\n\t\t\tsuccess = pdev->query_device_port_status(pdev, &usbd_status, &OutputBufferSize,\n\t\t\t                                         Stream_Pointer(out));\n\n\t\t\tif (success)\n\t\t\t{\n\t\t\t\tif (!Stream_SafeSeek(out, OutputBufferSize))\n\t\t\t\t{\n\t\t\t\t\tStream_Free(out, TRUE);\n\t\t\t\t\treturn ERROR_INVALID_DATA;\n\t\t\t\t}\n\n\t\t\t\tif (pdev->isExist(pdev) == 0)\n\t\t\t\t\tStream_Write_UINT32(out, 0);\n\t\t\t\telse\n\t\t\t\t\tusb_process_get_port_status(pdev, out);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_CYCLE_PORT: /** 0x0022001F */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_CYCLE_PORT\");\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \" Function IOCTL_INTERNAL_USB_CYCLE_PORT: Unchecked\");\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION: /** 0x00220027 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"ioctl: IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION\");\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \" Function IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION: Unchecked\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"urbdrc_process_io_control: unknown IoControlCode 0x%\" PRIX32 \"\",\n\t\t\t           IoControlCode);\n\t\t\tStream_Free(out, TRUE);\n\t\t\treturn ERROR_INVALID_OPERATION;\n\t}\n\n\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n}\n\nstatic UINT urbdrc_process_internal_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                               wStream* s, UINT32 MessageId, IUDEVMAN* udevman)\n{\n\twStream* out;\n\tUINT32 IoControlCode, InterfaceId, InputBufferSize;\n\tUINT32 OutputBufferSize, RequestId, frames;\n\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, IoControlCode);\n\tStream_Read_UINT32(s, InputBufferSize);\n\n\tif (!Stream_SafeSeek(s, InputBufferSize))\n\t\treturn ERROR_INVALID_DATA;\n\tif (Stream_GetRemainingLength(s) < 8ULL)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tStream_Read_UINT32(s, RequestId);\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\t// TODO: Implement control code.\n\t/** Fixme: Currently this is a FALSE bustime... */\n\tframes = GetTickCount();\n\tout = urb_create_iocompletion(InterfaceId, MessageId, RequestId, 4);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, frames); /** OutputBuffer */\n\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n}\n\nstatic UINT urbdrc_process_query_device_text(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                             wStream* s, UINT32 MessageId, IUDEVMAN* udevman)\n{\n\tUINT32 out_size;\n\tUINT32 TextType;\n\tUINT32 LocaleId;\n\tUINT32 InterfaceId;\n\tUINT8 bufferSize = 0xFF;\n\tUINT32 hr;\n\twStream* out;\n\tBYTE DeviceDescription[0x100] = { 0 };\n\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, TextType);\n\tStream_Read_UINT32(s, LocaleId);\n\tif (LocaleId > UINT16_MAX)\n\t\treturn ERROR_INVALID_DATA;\n\n\thr = pdev->control_query_device_text(pdev, TextType, (UINT16)LocaleId, &bufferSize,\n\t                                     DeviceDescription);\n\tInterfaceId = ((STREAM_ID_STUB << 30) | pdev->get_UsbDevice(pdev));\n\tout_size = 16 + bufferSize;\n\n\tif (bufferSize != 0)\n\t\tout_size += 2;\n\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId);            /** interface */\n\tStream_Write_UINT32(out, MessageId);              /** message id */\n\tStream_Write_UINT32(out, bufferSize / 2);         /** cchDeviceDescription in WCHAR */\n\tStream_Write(out, DeviceDescription, bufferSize); /* '\\0' terminated unicode */\n\tStream_Write_UINT32(out, hr);                     /** HResult */\n\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n}\n\nstatic void func_select_all_interface_for_msconfig(IUDEVICE* pdev,\n                                                   MSUSB_CONFIG_DESCRIPTOR* MsConfig)\n{\n\tUINT32 inum;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces = MsConfig->MsInterfaces;\n\tBYTE InterfaceNumber, AlternateSetting;\n\tUINT32 NumInterfaces = MsConfig->NumInterfaces;\n\n\tfor (inum = 0; inum < NumInterfaces; inum++)\n\t{\n\t\tInterfaceNumber = MsInterfaces[inum]->InterfaceNumber;\n\t\tAlternateSetting = MsInterfaces[inum]->AlternateSetting;\n\t\tpdev->select_interface(pdev, InterfaceNumber, AlternateSetting);\n\t}\n}\n\nstatic UINT urb_select_configuration(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                     UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                                     int transferDir)\n{\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig = NULL;\n\tsize_t out_size;\n\tUINT32 InterfaceId, NumInterfaces, usbd_status = 0;\n\tBYTE ConfigurationDescriptorIsValid;\n\twStream* out;\n\tint MsOutSize = 0;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"urb_select_configuration: unsupported transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT8(s, ConfigurationDescriptorIsValid);\n\tStream_Seek(s, 3); /* Padding */\n\tStream_Read_UINT32(s, NumInterfaces);\n\n\t/** if ConfigurationDescriptorIsValid is zero, then just do nothing.*/\n\tif (ConfigurationDescriptorIsValid)\n\t{\n\t\t/* parser data for struct config */\n\t\tMsConfig = msusb_msconfig_read(s, NumInterfaces);\n\n\t\tif (!MsConfig)\n\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t/* select config */\n\t\tpdev->select_configuration(pdev, MsConfig->bConfigurationValue);\n\t\t/* select all interface */\n\t\tfunc_select_all_interface_for_msconfig(pdev, MsConfig);\n\t\t/* complete configuration setup */\n\t\tif (!pdev->complete_msconfig_setup(pdev, MsConfig))\n\t\t{\n\t\t\tmsusb_msconfig_free(MsConfig);\n\t\t\tMsConfig = NULL;\n\t\t}\n\t}\n\n\tif (MsConfig)\n\t\tMsOutSize = MsConfig->MsOutSize;\n\n\tif (MsOutSize > 0)\n\t{\n\t\tif ((size_t)MsOutSize > SIZE_MAX - 36)\n\t\t\treturn ERROR_INVALID_DATA;\n\n\t\tout_size = 36 + MsOutSize;\n\t}\n\telse\n\t\tout_size = 44;\n\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId);            /** interface */\n\tStream_Write_UINT32(out, MessageId);              /** message id */\n\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */\n\tStream_Write_UINT32(out, RequestId);              /** RequestId */\n\n\tif (MsOutSize > 0)\n\t{\n\t\t/** CbTsUrbResult */\n\t\tStream_Write_UINT32(out, 8 + MsOutSize);\n\t\t/** TS_URB_RESULT_HEADER Size*/\n\t\tStream_Write_UINT16(out, 8 + MsOutSize);\n\t}\n\telse\n\t{\n\t\tStream_Write_UINT32(out, 16);\n\t\tStream_Write_UINT16(out, 16);\n\t}\n\n\t/** Padding, MUST be ignored upon receipt */\n\tStream_Write_UINT16(out, TS_URB_SELECT_CONFIGURATION);\n\tStream_Write_UINT32(out, usbd_status); /** UsbdStatus */\n\n\t/** TS_URB_SELECT_CONFIGURATION_RESULT */\n\tif (MsOutSize > 0)\n\t\tmsusb_msconfig_write(MsConfig, out);\n\telse\n\t{\n\t\tStream_Write_UINT32(out, 0);             /** ConfigurationHandle */\n\t\tStream_Write_UINT32(out, NumInterfaces); /** NumInterfaces */\n\t}\n\n\tStream_Write_UINT32(out, 0); /** HResult */\n\tStream_Write_UINT32(out, 0); /** OutputBufferSize */\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urb_select_interface(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                 UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                                 int transferDir)\n{\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig;\n\tMSUSB_INTERFACE_DESCRIPTOR* MsInterface;\n\tUINT32 out_size, InterfaceId, ConfigurationHandle;\n\tUINT32 OutputBufferSize;\n\tBYTE InterfaceNumber;\n\twStream* out;\n\tUINT32 interface_size;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"urb_select_interface: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, ConfigurationHandle);\n\tMsInterface = msusb_msinterface_read(s);\n\n\tif ((Stream_GetRemainingLength(s) < 4) || !MsInterface)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tpdev->select_interface(pdev, MsInterface->InterfaceNumber, MsInterface->AlternateSetting);\n\t/* replace device's MsInterface */\n\tMsConfig = pdev->get_MsConfig(pdev);\n\tInterfaceNumber = MsInterface->InterfaceNumber;\n\tif (!msusb_msinterface_replace(MsConfig, InterfaceNumber, MsInterface))\n\t{\n\t\tmsusb_msconfig_free(MsConfig);\n\t\treturn ERROR_BAD_CONFIGURATION;\n\t}\n\t/* complete configuration setup */\n\tif (!pdev->complete_msconfig_setup(pdev, MsConfig))\n\t{\n\t\tmsusb_msconfig_free(MsConfig);\n\t\treturn ERROR_BAD_CONFIGURATION;\n\t}\n\tMsInterface = MsConfig->MsInterfaces[InterfaceNumber];\n\tinterface_size = 16 + (MsInterface->NumberOfPipes * 20);\n\tout_size = 36 + interface_size;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId);            /** interface */\n\tStream_Write_UINT32(out, MessageId);              /** message id */\n\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */\n\tStream_Write_UINT32(out, RequestId);              /** RequestId */\n\tStream_Write_UINT32(out, 8 + interface_size);     /** CbTsUrbResult */\n\t/** TS_URB_RESULT_HEADER */\n\tStream_Write_UINT16(out, 8 + interface_size); /** Size */\n\t/** Padding, MUST be ignored upon receipt */\n\tStream_Write_UINT16(out, TS_URB_SELECT_INTERFACE);\n\tStream_Write_UINT32(out, USBD_STATUS_SUCCESS); /** UsbdStatus */\n\t/** TS_URB_SELECT_INTERFACE_RESULT */\n\tmsusb_msinterface_write(MsInterface, out);\n\tStream_Write_UINT32(out, 0); /** HResult */\n\tStream_Write_UINT32(out, 0); /** OutputBufferSize */\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urb_control_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                 UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                                 int transferDir, int External)\n{\n\tUINT32 out_size, InterfaceId, EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize, usbd_status, Timeout;\n\tBYTE bmRequestType, Request;\n\tUINT16 Value, Index, length;\n\tBYTE* buffer;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); /** TransferFlags */\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tTimeout = 2000;\n\n\tswitch (External)\n\t{\n\t\tcase URB_CONTROL_TRANSFER_EXTERNAL:\n\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tStream_Read_UINT32(s, Timeout); /** TransferFlags */\n\t\t\tbreak;\n\n\t\tcase URB_CONTROL_TRANSFER_NONEXTERNAL:\n\t\t\tbreak;\n\t}\n\n\t/** SetupPacket 8 bytes */\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT8(s, bmRequestType);\n\tStream_Read_UINT8(s, Request);\n\tStream_Read_UINT16(s, Value);\n\tStream_Read_UINT16(s, Index);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\n\tif (length != OutputBufferSize)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"urb_control_transfer ERROR: buf != length\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tout_size = 36 + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\t/** Get Buffer Data */\n\tbuffer = Stream_Pointer(out);\n\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t\tStream_Copy(s, out, OutputBufferSize);\n\n\t/**  process TS_URB_CONTROL_TRANSFER */\n\tif (!pdev->control_transfer(pdev, RequestId, EndpointAddress, TransferFlags, bmRequestType,\n\t                            Request, Value, Index, &usbd_status, &OutputBufferSize, buffer,\n\t                            Timeout))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic void urb_bulk_transfer_cb(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* out,\n                                 UINT32 InterfaceId, BOOL noAck, UINT32 MessageId, UINT32 RequestId,\n                                 UINT32 NumberOfPackets, UINT32 status, UINT32 StartFrame,\n                                 UINT32 ErrorCount, UINT32 OutputBufferSize)\n{\n\tif (!pdev->isChannelClosed(pdev))\n\t\turb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId, status,\n\t\t                     OutputBufferSize);\n\telse\n\t\tStream_Free(out, TRUE);\n}\n\nstatic UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); /** TransferFlags */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\t/**  process TS_URB_BULK_OR_INTERRUPT_TRANSFER */\n\treturn pdev->bulk_or_interrupt_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck,\n\t    OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_bulk_transfer_cb, 10000);\n}\n\nstatic void urb_isoch_transfer_cb(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* out,\n                                  UINT32 InterfaceId, BOOL noAck, UINT32 MessageId,\n                                  UINT32 RequestId, UINT32 NumberOfPackets, UINT32 status,\n                                  UINT32 StartFrame, UINT32 ErrorCount, UINT32 OutputBufferSize)\n{\n\tif (!noAck)\n\t{\n\t\tUINT32 packetSize = (status == 0) ? NumberOfPackets * 12 : 0;\n\t\tStream_SetPosition(out, 0);\n\t\t/* fill the send data */\n\t\tStream_Write_UINT32(out, InterfaceId); /** interface */\n\t\tStream_Write_UINT32(out, MessageId);   /** message id */\n\n\t\tif (OutputBufferSize == 0)\n\t\t\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */\n\t\telse\n\t\t\tStream_Write_UINT32(out, URB_COMPLETION); /** function id */\n\n\t\tStream_Write_UINT32(out, RequestId);       /** RequestId */\n\t\tStream_Write_UINT32(out, 20 + packetSize); /** CbTsUrbResult */\n\t\t/** TsUrbResult TS_URB_RESULT_HEADER */\n\t\tStream_Write_UINT16(out, 20 + packetSize); /** Size */\n\t\tStream_Write_UINT16(out, 0);               /* Padding */\n\t\tStream_Write_UINT32(out, status);          /** UsbdStatus */\n\t\tStream_Write_UINT32(out, StartFrame);      /** StartFrame */\n\n\t\tif (status == 0)\n\t\t{\n\t\t\t/** NumberOfPackets */\n\t\t\tStream_Write_UINT32(out, NumberOfPackets);\n\t\t\tStream_Write_UINT32(out, ErrorCount); /** ErrorCount */\n\t\t\tStream_Seek(out, packetSize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(out, 0);          /** NumberOfPackets */\n\t\t\tStream_Write_UINT32(out, ErrorCount); /** ErrorCount */\n\t\t}\n\n\t\tStream_Write_UINT32(out, 0);                /** HResult */\n\t\tStream_Write_UINT32(out, OutputBufferSize); /** OutputBufferSize */\n\t\tStream_Seek(out, OutputBufferSize);\n\n\t\tstream_write_and_free(callback->plugin, callback->channel, out);\n\t}\n}\n\nstatic UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                               UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                               int transferDir)\n{\n\tUINT32 EndpointAddress;\n\tUINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets;\n\tUINT32 ErrorCount, OutputBufferSize;\n\tBYTE* packetDescriptorData;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!pdev || !callback || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, PipeHandle);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tStream_Read_UINT32(s, TransferFlags);   /** TransferFlags */\n\tStream_Read_UINT32(s, StartFrame);      /** StartFrame */\n\tStream_Read_UINT32(s, NumberOfPackets); /** NumberOfPackets */\n\tStream_Read_UINT32(s, ErrorCount);      /** ErrorCount */\n\n\tif (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpacketDescriptorData = Stream_Pointer(s);\n\tStream_Seek(s, NumberOfPackets * 12);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\treturn pdev->isoch_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame,\n\t    ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize,\n\t    (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_isoch_transfer_cb, 2000);\n}\n\nstatic UINT urb_control_descriptor_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, BYTE func_recipient, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tBYTE bmRequestType, desc_index, desc_type;\n\tUINT16 langId;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT8(s, desc_index);\n\tStream_Read_UINT8(s, desc_type);\n\tStream_Read_UINT16(s, langId);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tbmRequestType = func_recipient;\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_IN:\n\t\t\tbmRequestType |= 0x80;\n\t\t\tbreak;\n\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tbmRequestType |= 0x00;\n\t\t\tStream_Copy(s, out, OutputBufferSize);\n\t\t\tStream_Rewind(out, OutputBufferSize);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"get error transferDir\");\n\t\t\tOutputBufferSize = 0;\n\t\t\tusbd_status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\t}\n\n\t/** process get usb device descriptor */\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType,\n\t                            0x06, /* REQUEST_GET_DESCRIPTOR */\n\t                            (desc_type << 8) | desc_index, langId, &usbd_status,\n\t                            &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"get_descriptor failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_control_get_status_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, BYTE func_recipient, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tUINT16 Index;\n\tBYTE bmRequestType;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_control_get_status_request: transfer out not supported\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT16(s, Index); /** Index */\n\tStream_Seek(s, 2);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tbmRequestType = func_recipient | 0x80;\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType, 0x00, /* REQUEST_GET_STATUS */\n\t                            0, Index, &usbd_status, &OutputBufferSize, Stream_Pointer(out),\n\t                            1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_control_vendor_or_class_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                                wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                                IUDEVMAN* udevman, BYTE func_type,\n                                                BYTE func_recipient, int transferDir)\n{\n\tUINT32 out_size, InterfaceId, TransferFlags, usbd_status;\n\tUINT32 OutputBufferSize;\n\tBYTE ReqTypeReservedBits, Request, bmRequestType;\n\tUINT16 Value, Index, Padding;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, TransferFlags);      /** TransferFlags */\n\tStream_Read_UINT8(s, ReqTypeReservedBits); /** ReqTypeReservedBids */\n\tStream_Read_UINT8(s, Request);             /** Request */\n\tStream_Read_UINT16(s, Value);              /** value */\n\tStream_Read_UINT16(s, Index);              /** index */\n\tStream_Read_UINT16(s, Padding);            /** Padding */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\n\t/** Get Buffer */\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tStream_Copy(s, out, OutputBufferSize);\n\t\tStream_Rewind(out, OutputBufferSize);\n\t}\n\n\t/** vendor or class command */\n\tbmRequestType = func_type | func_recipient;\n\n\tif (TransferFlags & USBD_TRANSFER_DIRECTION)\n\t\tbmRequestType |= 0x80;\n\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"RequestId 0x%\" PRIx32 \" TransferFlags: 0x%\" PRIx32 \" ReqTypeReservedBits: 0x%\" PRIx8\n\t           \" \"\n\t           \"Request:0x%\" PRIx8 \" Value: 0x%\" PRIx16 \" Index: 0x%\" PRIx16\n\t           \" OutputBufferSize: 0x%\" PRIx32 \" bmRequestType: 0x%\" PRIx8,\n\t           RequestId, TransferFlags, ReqTypeReservedBits, Request, Value, Index,\n\t           OutputBufferSize, bmRequestType);\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType, Request, Value, Index,\n\t                            &usbd_status, &OutputBufferSize, Stream_Pointer(out), 2000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_os_feature_descriptor_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                              wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                              IUDEVMAN* udevman, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tBYTE Recipient, InterfaceNumber, Ms_PageIndex;\n\tUINT16 Ms_featureDescIndex;\n\twStream* out;\n\tint ret;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\t/* 2.2.9.15 TS_URB_OS_FEATURE_DESCRIPTOR_REQUEST */\n\tStream_Read_UINT8(s, Recipient);            /** Recipient */\n\tRecipient = (Recipient & 0x1f);             /* Mask out Padding1 */\n\tStream_Read_UINT8(s, InterfaceNumber);      /** InterfaceNumber */\n\tStream_Read_UINT8(s, Ms_PageIndex);         /** Ms_PageIndex */\n\tStream_Read_UINT16(s, Ms_featureDescIndex); /** Ms_featureDescIndex */\n\tStream_Seek(s, 3);                          /* Padding 2 */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tStream_Copy(s, out, OutputBufferSize);\n\t\t\tStream_Rewind(out, OutputBufferSize);\n\t\t\tbreak;\n\n\t\tcase USBD_TRANSFER_DIRECTION_IN:\n\t\t\tbreak;\n\t}\n\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"Ms descriptor arg: Recipient:0x%\" PRIx8 \", \"\n\t           \"InterfaceNumber:0x%\" PRIx8 \", Ms_PageIndex:0x%\" PRIx8 \", \"\n\t           \"Ms_featureDescIndex:0x%\" PRIx16 \", OutputBufferSize:0x%\" PRIx32 \"\",\n\t           Recipient, InterfaceNumber, Ms_PageIndex, Ms_featureDescIndex, OutputBufferSize);\n\t/** get ms string */\n\tret = pdev->os_feature_descriptor_request(pdev, RequestId, Recipient, InterfaceNumber,\n\t                                          Ms_PageIndex, Ms_featureDescIndex, &usbd_status,\n\t                                          &OutputBufferSize, Stream_Pointer(out), 1000);\n\n\tif (ret < 0)\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"os_feature_descriptor_request: error num %d\", ret);\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_pipe_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                             UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                             int transferDir, int action)\n{\n\tUINT32 out_size, InterfaceId, PipeHandle, EndpointAddress;\n\tUINT32 OutputBufferSize, usbd_status = 0;\n\twStream* out;\n\tUINT32 ret = USBD_STATUS_REQUEST_FAILED;\n\tint rc;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urb_pipe_request: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, PipeHandle); /** PipeHandle */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\n\tswitch (action)\n\t{\n\t\tcase PIPE_CANCEL:\n\t\t\trc = pdev->control_pipe_request(pdev, RequestId, EndpointAddress, &usbd_status,\n\t\t\t                                PIPE_CANCEL);\n\n\t\t\tif (rc < 0)\n\t\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"PIPE SET HALT: error %d\", ret);\n\t\t\telse\n\t\t\t\tret = USBD_STATUS_SUCCESS;\n\n\t\t\tbreak;\n\n\t\tcase PIPE_RESET:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urb_pipe_request: PIPE_RESET ep 0x%\" PRIx32 \"\",\n\t\t\t           EndpointAddress);\n\t\t\trc = pdev->control_pipe_request(pdev, RequestId, EndpointAddress, &usbd_status,\n\t\t\t                                PIPE_RESET);\n\n\t\t\tif (rc < 0)\n\t\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"PIPE RESET: error %d\", ret);\n\t\t\telse\n\t\t\t\tret = USBD_STATUS_SUCCESS;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urb_pipe_request action: %d not supported\",\n\t\t\t           action);\n\t\t\tret = USBD_STATUS_INVALID_URB_FUNCTION;\n\t\t\tbreak;\n\t}\n\n\t/** send data */\n\tout_size = 36;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId, ret,\n\t                            0);\n}\n\nstatic UINT urb_get_current_frame_number(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                         wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                         IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 out_size, InterfaceId, OutputBufferSize;\n\tUINT32 dummy_frames;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_get_current_frame_number: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, OutputBufferSize);\n\t/** Fixme: Need to fill actual frame number!!*/\n\tdummy_frames = GetTickCount();\n\tout_size = 40;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId); /** interface */\n\tStream_Write_UINT32(out, MessageId);   /** message id */\n\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA);\n\tStream_Write_UINT32(out, RequestId); /** RequestId */\n\tStream_Write_UINT32(out, 12);        /** CbTsUrbResult */\n\t/** TsUrbResult TS_URB_RESULT_HEADER */\n\tStream_Write_UINT16(out, 12); /** Size */\n\t/** Padding, MUST be ignored upon receipt */\n\tStream_Write_UINT16(out, TS_URB_GET_CURRENT_FRAME_NUMBER);\n\tStream_Write_UINT32(out, USBD_STATUS_SUCCESS); /** UsbdStatus */\n\tStream_Write_UINT32(out, dummy_frames);        /** FrameNumber */\n\tStream_Write_UINT32(out, 0);                   /** HResult */\n\tStream_Write_UINT32(out, 0);                   /** OutputBufferSize */\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\n/* Unused function for current server */\nstatic UINT urb_control_get_configuration_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                                  wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                                  IUDEVMAN* udevman, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_control_get_configuration_request:\"\n\t\t           \" not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, 0x80 | 0x00,\n\t                            0x08, /* REQUEST_GET_CONFIGURATION */\n\t                            0, 0, &usbd_status, &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\n/* Unused function for current server */\nstatic UINT urb_control_get_interface_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                              wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                              IUDEVMAN* udevman, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tUINT16 interface;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_control_get_interface_request: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT16(s, interface);\n\tStream_Seek(s, 2);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\n\tif (!pdev->control_transfer(\n\t        pdev, RequestId, 0, 0, 0x80 | 0x01, 0x0A, /* REQUEST_GET_INTERFACE */\n\t        0, interface, &usbd_status, &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_control_feature_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                        wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                        IUDEVMAN* udevman, BYTE func_recipient, BYTE command,\n                                        int transferDir)\n{\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tUINT16 FeatureSelector, Index;\n\tBYTE bmRequestType, bmRequest;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT16(s, FeatureSelector);\n\tStream_Read_UINT16(s, Index);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tout = Stream_New(NULL, 36ULL + OutputBufferSize);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tbmRequestType = func_recipient;\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \"Function urb_control_feature_request: OUT Unchecked\");\n\t\t\tStream_Copy(s, out, OutputBufferSize);\n\t\t\tStream_Rewind(out, OutputBufferSize);\n\t\t\tbmRequestType |= 0x00;\n\t\t\tbreak;\n\n\t\tcase USBD_TRANSFER_DIRECTION_IN:\n\t\t\tbmRequestType |= 0x80;\n\t\t\tbreak;\n\t}\n\n\tswitch (command)\n\t{\n\t\tcase URB_SET_FEATURE:\n\t\t\tbmRequest = 0x03; /* REQUEST_SET_FEATURE */\n\t\t\tbreak;\n\n\t\tcase URB_CLEAR_FEATURE:\n\t\t\tbmRequest = 0x01; /* REQUEST_CLEAR_FEATURE */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \"urb_control_feature_request: Error Command 0x%02\" PRIx8 \"\", command);\n\t\t\tStream_Free(out, TRUE);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType, bmRequest, FeatureSelector,\n\t                            Index, &usbd_status, &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"feature control transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urbdrc_process_transfer_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                            wStream* s, UINT32 MessageId, IUDEVMAN* udevman,\n                                            int transferDir)\n{\n\tUINT32 CbTsUrb;\n\tUINT16 Size;\n\tUINT16 URB_Function;\n\tUINT32 RequestId;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, CbTsUrb); /** CbTsUrb */\n\tStream_Read_UINT16(s, Size);    /** size */\n\tStream_Read_UINT16(s, URB_Function);\n\tStream_Read_UINT32(s, RequestId);\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"URB %s[\" PRIu16 \"]\", urb_function_string(URB_Function),\n\t           URB_Function);\n\n\tswitch (URB_Function)\n\t{\n\t\tcase TS_URB_SELECT_CONFIGURATION: /** 0x0000 */\n\t\t\terror = urb_select_configuration(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                 transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SELECT_INTERFACE: /** 0x0001 */\n\t\t\terror =\n\t\t\t    urb_select_interface(pdev, callback, s, RequestId, MessageId, udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_PIPE_REQUEST: /** 0x0002  */\n\t\t\terror = urb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                         PIPE_CANCEL);\n\t\t\tbreak;\n\n\t\tcase TS_URB_TAKE_FRAME_LENGTH_CONTROL: /** 0x0003  */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_RELEASE_FRAME_LENGTH_CONTROL: /** 0x0004 */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_FRAME_LENGTH: /** 0x0005 */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FRAME_LENGTH: /** 0x0006 */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_CURRENT_FRAME_NUMBER: /** 0x0007 */\n\t\t\terror = urb_get_current_frame_number(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                     transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_TRANSFER: /** 0x0008 */\n\t\t\terror = urb_control_transfer(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                             transferDir, URB_CONTROL_TRANSFER_NONEXTERNAL);\n\t\t\tbreak;\n\n\t\tcase TS_URB_BULK_OR_INTERRUPT_TRANSFER: /** 0x0009 */\n\t\t\terror = urb_bulk_or_interrupt_transfer(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_ISOCH_TRANSFER: /** 0x000A */\n\t\t\terror =\n\t\t\t    urb_isoch_transfer(pdev, callback, s, RequestId, MessageId, udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_DESCRIPTOR_FROM_DEVICE: /** 0x000B */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_DESCRIPTOR_TO_DEVICE: /** 0x000C */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_DEVICE: /** 0x000D */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x00, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_INTERFACE: /** 0x000E */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x01, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_ENDPOINT: /** 0x000F */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x02, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_DEVICE: /** 0x0010 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x00, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_INTERFACE: /** 0x0011 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x01, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_ENDPOINT: /** 0x0012 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x02, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_DEVICE: /** 0x0013 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_INTERFACE: /** 0x0014 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_ENDPOINT: /** 0x0015 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_RESERVED_0X0016: /** 0x0016 */\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_DEVICE: /** 0x0017 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_INTERFACE: /** 0x0018 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_ENDPOINT: /** 0x0019 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_DEVICE: /** 0x001A */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_INTERFACE: /** 0x001B */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_ENDPOINT: /** 0x001C */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_RESERVE_0X001D: /** 0x001D */\n\t\t\tbreak;\n\n\t\tcase TS_URB_SYNC_RESET_PIPE_AND_CLEAR_STALL: /** 0x001E */\n\t\t\terror = urb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                         PIPE_RESET);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_OTHER: /** 0x001F */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x03, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_OTHER: /** 0x0020 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x03, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_OTHER: /** 0x0021 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x03, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_OTHER: /** 0x0022 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x03, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_OTHER: /** 0x0023 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x03, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_DESCRIPTOR_FROM_ENDPOINT: /** 0x0024 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_DESCRIPTOR_TO_ENDPOINT: /** 0x0025 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_GET_CONFIGURATION_REQUEST: /** 0x0026 */\n\t\t\terror = urb_control_get_configuration_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                              udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_GET_INTERFACE_REQUEST: /** 0x0027 */\n\t\t\terror = urb_control_get_interface_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                          udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_DESCRIPTOR_FROM_INTERFACE: /** 0x0028 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_DESCRIPTOR_TO_INTERFACE: /** 0x0029 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_OS_FEATURE_DESCRIPTOR_REQUEST: /** 0x002A */\n\t\t\terror = urb_os_feature_descriptor_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                          udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_RESERVE_0X002B: /** 0x002B */\n\t\tcase TS_URB_RESERVE_0X002C: /** 0x002C */\n\t\tcase TS_URB_RESERVE_0X002D: /** 0x002D */\n\t\tcase TS_URB_RESERVE_0X002E: /** 0x002E */\n\t\tcase TS_URB_RESERVE_0X002F: /** 0x002F */\n\t\t\tbreak;\n\n\t\t/** USB 2.0 calls start at 0x0030 */\n\t\tcase TS_URB_SYNC_RESET_PIPE: /** 0x0030 */\n\t\t\terror = urb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                         PIPE_RESET);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SYNC_CLEAR_STALL: /** 0x0031 */\n\t\t\turb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                 PIPE_RESET);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_TRANSFER_EX: /** 0x0032 */\n\t\t\terror = urb_control_transfer(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                             transferDir, URB_CONTROL_TRANSFER_EXTERNAL);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"URB_Func: %\" PRIx16 \" is not found!\",\n\t\t\t           URB_Function);\n\t\t\tbreak;\n\t}\n\n\tif (error)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"USB transfer request URB Function %08\" PRIx32 \" failed with %08\" PRIx32,\n\t\t           URB_Function, error);\n\t}\n\n\treturn error;\n}\n\nUINT urbdrc_process_udev_data_transfer(URBDRC_CHANNEL_CALLBACK* callback, URBDRC_PLUGIN* urbdrc,\n                                       IUDEVMAN* udevman, wStream* data)\n{\n\tUINT32 InterfaceId;\n\tUINT32 MessageId;\n\tUINT32 FunctionId;\n\tIUDEVICE* pdev;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\tsize_t len;\n\n\tif (!urbdrc || !data || !callback || !udevman)\n\t\tgoto fail;\n\n\tlen = Stream_GetRemainingLength(data);\n\n\tif (len < 8)\n\t\tgoto fail;\n\n\tStream_Rewind_UINT32(data);\n\n\tStream_Read_UINT32(data, InterfaceId);\n\tStream_Read_UINT32(data, MessageId);\n\tStream_Read_UINT32(data, FunctionId);\n\n\tpdev = udevman->get_udevice_by_UsbDevice(udevman, InterfaceId);\n\n\t/* Device does not exist, ignore this request. */\n\tif (pdev == NULL)\n\t{\n\t\terror = ERROR_SUCCESS;\n\t\tgoto fail;\n\t}\n\n\t/* Device has been removed, ignore this request. */\n\tif (pdev->isChannelClosed(pdev))\n\t{\n\t\terror = ERROR_SUCCESS;\n\t\tgoto fail;\n\t}\n\n\t/* USB kernel driver detach!! */\n\tpdev->detach_kernel_driver(pdev);\n\n\tswitch (FunctionId)\n\t{\n\t\tcase CANCEL_REQUEST:\n\t\t\terror = urbdrc_process_cancel_request(pdev, data, udevman);\n\t\t\tbreak;\n\n\t\tcase REGISTER_REQUEST_CALLBACK:\n\t\t\terror = urbdrc_process_register_request_callback(pdev, callback, data, udevman);\n\t\t\tbreak;\n\n\t\tcase IO_CONTROL:\n\t\t\terror = urbdrc_process_io_control(pdev, callback, data, MessageId, udevman);\n\t\t\tbreak;\n\n\t\tcase INTERNAL_IO_CONTROL:\n\t\t\terror = urbdrc_process_internal_io_control(pdev, callback, data, MessageId, udevman);\n\t\t\tbreak;\n\n\t\tcase QUERY_DEVICE_TEXT:\n\t\t\terror = urbdrc_process_query_device_text(pdev, callback, data, MessageId, udevman);\n\t\t\tbreak;\n\n\t\tcase TRANSFER_IN_REQUEST:\n\t\t\terror = urbdrc_process_transfer_request(pdev, callback, data, MessageId, udevman,\n\t\t\t                                        USBD_TRANSFER_DIRECTION_IN);\n\t\t\tbreak;\n\n\t\tcase TRANSFER_OUT_REQUEST:\n\t\t\terror = urbdrc_process_transfer_request(pdev, callback, data, MessageId, udevman,\n\t\t\t                                        USBD_TRANSFER_DIRECTION_OUT);\n\t\t\tbreak;\n\n\t\tcase RETRACT_DEVICE:\n\t\t\terror = urbdrc_process_retract_device_request(pdev, data, udevman);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t\t           \"urbdrc_process_udev_data_transfer:\"\n\t\t\t           \" unknown FunctionId 0x%\" PRIX32 \"\",\n\t\t\t           FunctionId);\n\t\t\tbreak;\n\t}\n\nfail:\n\tif (error)\n\t{\n\t\tWLog_WARN(TAG, \"USB request failed with %08\" PRIx32, error);\n\t}\n\n\treturn error;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RemoteFX USB Redirection\n *\n * Copyright 2012 Atrust corp.\n * Copyright 2012 Alfred Liu <alfred.liu@atruscorp.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/sysinfo.h>\n\n#include <urbdrc_helpers.h>\n\n#include \"urbdrc_types.h\"\n#include \"data_transfer.h\"\n\nstatic void usb_process_get_port_status(IUDEVICE* pdev, wStream* out)\n{\n\tint bcdUSB = pdev->query_device_descriptor(pdev, BCD_USB);\n\n\tswitch (bcdUSB)\n\t{\n\t\tcase USB_v1_0:\n\t\t\tStream_Write_UINT32(out, 0x303);\n\t\t\tbreak;\n\n\t\tcase USB_v1_1:\n\t\t\tStream_Write_UINT32(out, 0x103);\n\t\t\tbreak;\n\n\t\tcase USB_v2_0:\n\t\t\tStream_Write_UINT32(out, 0x503);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tStream_Write_UINT32(out, 0x503);\n\t\t\tbreak;\n\t}\n}\n\nstatic UINT urb_write_completion(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, BOOL noAck,\n                                 wStream* out, UINT32 InterfaceId, UINT32 MessageId,\n                                 UINT32 RequestId, UINT32 usbd_status, UINT32 OutputBufferSize)\n{\n\tif (!out)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_Capacity(out) < OutputBufferSize + 36)\n\t{\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tStream_SetPosition(out, 0);\n\tStream_Write_UINT32(out, InterfaceId); /** interface */\n\tStream_Write_UINT32(out, MessageId);   /** message id */\n\n\tif (OutputBufferSize != 0)\n\t\tStream_Write_UINT32(out, URB_COMPLETION);\n\telse\n\t\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA);\n\n\tStream_Write_UINT32(out, RequestId); /** RequestId */\n\tStream_Write_UINT32(out, 8);         /** CbTsUrbResult */\n\t/** TsUrbResult TS_URB_RESULT_HEADER */\n\tStream_Write_UINT16(out, 8);                /** Size */\n\tStream_Write_UINT16(out, 0);                /* Padding */\n\tStream_Write_UINT32(out, usbd_status);      /** UsbdStatus */\n\tStream_Write_UINT32(out, 0);                /** HResult */\n\tStream_Write_UINT32(out, OutputBufferSize); /** OutputBufferSize */\n\tStream_Seek(out, OutputBufferSize);\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic wStream* urb_create_iocompletion(UINT32 InterfaceField, UINT32 MessageId, UINT32 RequestId,\n                                        UINT32 OutputBufferSize)\n{\n\tconst UINT32 InterfaceId = (STREAM_ID_PROXY << 30) | (InterfaceField & 0x3FFFFFFF);\n\n#if UINT32_MAX >= SIZE_MAX\n\tif (OutputBufferSize > UINT32_MAX - 28ull)\n\t\treturn NULL;\n#endif\n\n\twStream* out = Stream_New(NULL, OutputBufferSize + 28ull);\n\n\tif (!out)\n\t\treturn NULL;\n\n\tStream_Write_UINT32(out, InterfaceId);          /** interface */\n\tStream_Write_UINT32(out, MessageId);            /** message id */\n\tStream_Write_UINT32(out, IOCONTROL_COMPLETION); /** function id */\n\tStream_Write_UINT32(out, RequestId);            /** RequestId */\n\tStream_Write_UINT32(out, USBD_STATUS_SUCCESS);  /** HResult */\n\tStream_Write_UINT32(out, OutputBufferSize);     /** Information */\n\tStream_Write_UINT32(out, OutputBufferSize);     /** OutputBufferSize */\n\treturn out;\n}\n\nstatic UINT urbdrc_process_register_request_callback(IUDEVICE* pdev,\n                                                     URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                                     IUDEVMAN* udevman)\n{\n\tUINT32 NumRequestCompletion = 0;\n\tUINT32 RequestCompletion = 0;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urbdrc_process_register_request_callback\");\n\n\tif (Stream_GetRemainingLength(s) >= 8)\n\t{\n\t\tStream_Read_UINT32(s, NumRequestCompletion); /** must be 1 */\n\t\t/** RequestCompletion:\n\t\t *   unique Request Completion interface for the client to use */\n\t\tStream_Read_UINT32(s, RequestCompletion);\n\t\tpdev->set_ReqCompletion(pdev, RequestCompletion);\n\t}\n\telse if (Stream_GetRemainingLength(s) >= 4) /** Unregister the device */\n\t{\n\t\tStream_Read_UINT32(s, RequestCompletion);\n\n\t\tif (pdev->get_ReqCompletion(pdev) == RequestCompletion)\n\t\t\tpdev->setChannelClosed(pdev);\n\t}\n\telse\n\t\treturn ERROR_INVALID_DATA;\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urbdrc_process_cancel_request(IUDEVICE* pdev, wStream* s, IUDEVMAN* udevman)\n{\n\tUINT32 CancelId;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)udevman->plugin;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, CancelId);\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"CANCEL_REQUEST: CancelId=%08\" PRIx32 \"\", CancelId);\n\n\tif (pdev->cancel_transfer_request(pdev, CancelId) < 0)\n\t\treturn ERROR_INTERNAL_ERROR;\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urbdrc_process_retract_device_request(IUDEVICE* pdev, wStream* s, IUDEVMAN* udevman)\n{\n\tUINT32 Reason;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)udevman->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, Reason); /** Reason */\n\n\tswitch (Reason)\n\t{\n\t\tcase UsbRetractReason_BlockedByPolicy:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"UsbRetractReason_BlockedByPolicy: now it is not support\");\n\t\t\treturn ERROR_ACCESS_DENIED;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"urbdrc_process_retract_device_request: Unknown Reason %\" PRIu32 \"\", Reason);\n\t\t\treturn ERROR_ACCESS_DENIED;\n\t}\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urbdrc_process_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                      UINT32 MessageId, IUDEVMAN* udevman)\n{\n\tUINT32 InterfaceId;\n\tUINT32 IoControlCode;\n\tUINT32 InputBufferSize;\n\tUINT32 OutputBufferSize;\n\tUINT32 RequestId;\n\tUINT32 usbd_status = USBD_STATUS_SUCCESS;\n\twStream* out;\n\tint success = 0;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, IoControlCode);\n\tStream_Read_UINT32(s, InputBufferSize);\n\n\tif (!Stream_SafeSeek(s, InputBufferSize))\n\t\treturn ERROR_INVALID_DATA;\n\tif (Stream_GetRemainingLength(s) < 8ULL)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tStream_Read_UINT32(s, RequestId);\n\n\tif (OutputBufferSize > UINT32_MAX - 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tout = urb_create_iocompletion(InterfaceId, MessageId, RequestId, OutputBufferSize + 4);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tswitch (IoControlCode)\n\t{\n\t\tcase IOCTL_INTERNAL_USB_SUBMIT_URB: /** 0x00220003 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_SUBMIT_URB\");\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \" Function IOCTL_INTERNAL_USB_SUBMIT_URB: Unchecked\");\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_RESET_PORT: /** 0x00220007 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_RESET_PORT\");\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_GET_PORT_STATUS: /** 0x00220013 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_GET_PORT_STATUS\");\n\t\t\tsuccess = pdev->query_device_port_status(pdev, &usbd_status, &OutputBufferSize,\n\t\t\t                                         Stream_Pointer(out));\n\n\t\t\tif (success)\n\t\t\t{\n\t\t\t\tif (!Stream_SafeSeek(out, OutputBufferSize))\n\t\t\t\t{\n\t\t\t\t\tStream_Free(out, TRUE);\n\t\t\t\t\treturn ERROR_INVALID_DATA;\n\t\t\t\t}\n\n\t\t\t\tif (pdev->isExist(pdev) == 0)\n\t\t\t\t\tStream_Write_UINT32(out, 0);\n\t\t\t\telse\n\t\t\t\t\tusb_process_get_port_status(pdev, out);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_CYCLE_PORT: /** 0x0022001F */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"ioctl: IOCTL_INTERNAL_USB_CYCLE_PORT\");\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \" Function IOCTL_INTERNAL_USB_CYCLE_PORT: Unchecked\");\n\t\t\tbreak;\n\n\t\tcase IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION: /** 0x00220027 */\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"ioctl: IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION\");\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \" Function IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION: Unchecked\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t\t           \"urbdrc_process_io_control: unknown IoControlCode 0x%\" PRIX32 \"\",\n\t\t\t           IoControlCode);\n\t\t\tStream_Free(out, TRUE);\n\t\t\treturn ERROR_INVALID_OPERATION;\n\t}\n\n\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n}\n\nstatic UINT urbdrc_process_internal_io_control(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                               wStream* s, UINT32 MessageId, IUDEVMAN* udevman)\n{\n\twStream* out;\n\tUINT32 IoControlCode, InterfaceId, InputBufferSize;\n\tUINT32 OutputBufferSize, RequestId, frames;\n\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, IoControlCode);\n\tStream_Read_UINT32(s, InputBufferSize);\n\n\tif (!Stream_SafeSeek(s, InputBufferSize))\n\t\treturn ERROR_INVALID_DATA;\n\tif (Stream_GetRemainingLength(s) < 8ULL)\n\t\treturn ERROR_INVALID_DATA;\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tStream_Read_UINT32(s, RequestId);\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\t// TODO: Implement control code.\n\t/** Fixme: Currently this is a FALSE bustime... */\n\tframes = GetTickCount();\n\tout = urb_create_iocompletion(InterfaceId, MessageId, RequestId, 4);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, frames); /** OutputBuffer */\n\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n}\n\nstatic UINT urbdrc_process_query_device_text(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                             wStream* s, UINT32 MessageId, IUDEVMAN* udevman)\n{\n\tUINT32 out_size;\n\tUINT32 TextType;\n\tUINT32 LocaleId;\n\tUINT32 InterfaceId;\n\tUINT8 bufferSize = 0xFF;\n\tUINT32 hr;\n\twStream* out;\n\tBYTE DeviceDescription[0x100] = { 0 };\n\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, TextType);\n\tStream_Read_UINT32(s, LocaleId);\n\tif (LocaleId > UINT16_MAX)\n\t\treturn ERROR_INVALID_DATA;\n\n\thr = pdev->control_query_device_text(pdev, TextType, (UINT16)LocaleId, &bufferSize,\n\t                                     DeviceDescription);\n\tInterfaceId = ((STREAM_ID_STUB << 30) | pdev->get_UsbDevice(pdev));\n\tout_size = 16 + bufferSize;\n\n\tif (bufferSize != 0)\n\t\tout_size += 2;\n\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId);            /** interface */\n\tStream_Write_UINT32(out, MessageId);              /** message id */\n\tStream_Write_UINT32(out, bufferSize / 2);         /** cchDeviceDescription in WCHAR */\n\tStream_Write(out, DeviceDescription, bufferSize); /* '\\0' terminated unicode */\n\tStream_Write_UINT32(out, hr);                     /** HResult */\n\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n}\n\nstatic void func_select_all_interface_for_msconfig(IUDEVICE* pdev,\n                                                   MSUSB_CONFIG_DESCRIPTOR* MsConfig)\n{\n\tUINT32 inum;\n\tMSUSB_INTERFACE_DESCRIPTOR** MsInterfaces = MsConfig->MsInterfaces;\n\tBYTE InterfaceNumber, AlternateSetting;\n\tUINT32 NumInterfaces = MsConfig->NumInterfaces;\n\n\tfor (inum = 0; inum < NumInterfaces; inum++)\n\t{\n\t\tInterfaceNumber = MsInterfaces[inum]->InterfaceNumber;\n\t\tAlternateSetting = MsInterfaces[inum]->AlternateSetting;\n\t\tpdev->select_interface(pdev, InterfaceNumber, AlternateSetting);\n\t}\n}\n\nstatic UINT urb_select_configuration(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                     UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                                     int transferDir)\n{\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig = NULL;\n\tsize_t out_size;\n\tUINT32 InterfaceId, NumInterfaces, usbd_status = 0;\n\tBYTE ConfigurationDescriptorIsValid;\n\twStream* out;\n\tint MsOutSize = 0;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"urb_select_configuration: unsupported transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT8(s, ConfigurationDescriptorIsValid);\n\tStream_Seek(s, 3); /* Padding */\n\tStream_Read_UINT32(s, NumInterfaces);\n\n\t/** if ConfigurationDescriptorIsValid is zero, then just do nothing.*/\n\tif (ConfigurationDescriptorIsValid)\n\t{\n\t\t/* parser data for struct config */\n\t\tMsConfig = msusb_msconfig_read(s, NumInterfaces);\n\n\t\tif (!MsConfig)\n\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t/* select config */\n\t\tpdev->select_configuration(pdev, MsConfig->bConfigurationValue);\n\t\t/* select all interface */\n\t\tfunc_select_all_interface_for_msconfig(pdev, MsConfig);\n\t\t/* complete configuration setup */\n\t\tif (!pdev->complete_msconfig_setup(pdev, MsConfig))\n\t\t{\n\t\t\tmsusb_msconfig_free(MsConfig);\n\t\t\tMsConfig = NULL;\n\t\t}\n\t}\n\n\tif (MsConfig)\n\t\tMsOutSize = MsConfig->MsOutSize;\n\n\tif (MsOutSize > 0)\n\t{\n\t\tif ((size_t)MsOutSize > SIZE_MAX - 36)\n\t\t\treturn ERROR_INVALID_DATA;\n\n\t\tout_size = 36 + MsOutSize;\n\t}\n\telse\n\t\tout_size = 44;\n\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId);            /** interface */\n\tStream_Write_UINT32(out, MessageId);              /** message id */\n\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */\n\tStream_Write_UINT32(out, RequestId);              /** RequestId */\n\n\tif (MsOutSize > 0)\n\t{\n\t\t/** CbTsUrbResult */\n\t\tStream_Write_UINT32(out, 8 + MsOutSize);\n\t\t/** TS_URB_RESULT_HEADER Size*/\n\t\tStream_Write_UINT16(out, 8 + MsOutSize);\n\t}\n\telse\n\t{\n\t\tStream_Write_UINT32(out, 16);\n\t\tStream_Write_UINT16(out, 16);\n\t}\n\n\t/** Padding, MUST be ignored upon receipt */\n\tStream_Write_UINT16(out, TS_URB_SELECT_CONFIGURATION);\n\tStream_Write_UINT32(out, usbd_status); /** UsbdStatus */\n\n\t/** TS_URB_SELECT_CONFIGURATION_RESULT */\n\tif (MsOutSize > 0)\n\t\tmsusb_msconfig_write(MsConfig, out);\n\telse\n\t{\n\t\tStream_Write_UINT32(out, 0);             /** ConfigurationHandle */\n\t\tStream_Write_UINT32(out, NumInterfaces); /** NumInterfaces */\n\t}\n\n\tStream_Write_UINT32(out, 0); /** HResult */\n\tStream_Write_UINT32(out, 0); /** OutputBufferSize */\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urb_select_interface(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                 UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                                 int transferDir)\n{\n\tMSUSB_CONFIG_DESCRIPTOR* MsConfig;\n\tMSUSB_INTERFACE_DESCRIPTOR* MsInterface;\n\tUINT32 out_size, InterfaceId, ConfigurationHandle;\n\tUINT32 OutputBufferSize;\n\tBYTE InterfaceNumber;\n\twStream* out;\n\tUINT32 interface_size;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"urb_select_interface: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, ConfigurationHandle);\n\tMsInterface = msusb_msinterface_read(s);\n\n\tif ((Stream_GetRemainingLength(s) < 4) || !MsInterface)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tpdev->select_interface(pdev, MsInterface->InterfaceNumber, MsInterface->AlternateSetting);\n\t/* replace device's MsInterface */\n\tMsConfig = pdev->get_MsConfig(pdev);\n\tInterfaceNumber = MsInterface->InterfaceNumber;\n\tif (!msusb_msinterface_replace(MsConfig, InterfaceNumber, MsInterface))\n\t{\n\t\tmsusb_msconfig_free(MsConfig);\n\t\treturn ERROR_BAD_CONFIGURATION;\n\t}\n\t/* complete configuration setup */\n\tif (!pdev->complete_msconfig_setup(pdev, MsConfig))\n\t{\n\t\tmsusb_msconfig_free(MsConfig);\n\t\treturn ERROR_BAD_CONFIGURATION;\n\t}\n\tMsInterface = MsConfig->MsInterfaces[InterfaceNumber];\n\tinterface_size = 16 + (MsInterface->NumberOfPipes * 20);\n\tout_size = 36 + interface_size;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId);            /** interface */\n\tStream_Write_UINT32(out, MessageId);              /** message id */\n\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */\n\tStream_Write_UINT32(out, RequestId);              /** RequestId */\n\tStream_Write_UINT32(out, 8 + interface_size);     /** CbTsUrbResult */\n\t/** TS_URB_RESULT_HEADER */\n\tStream_Write_UINT16(out, 8 + interface_size); /** Size */\n\t/** Padding, MUST be ignored upon receipt */\n\tStream_Write_UINT16(out, TS_URB_SELECT_INTERFACE);\n\tStream_Write_UINT32(out, USBD_STATUS_SUCCESS); /** UsbdStatus */\n\t/** TS_URB_SELECT_INTERFACE_RESULT */\n\tmsusb_msinterface_write(MsInterface, out);\n\tStream_Write_UINT32(out, 0); /** HResult */\n\tStream_Write_UINT32(out, 0); /** OutputBufferSize */\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\nstatic UINT urb_control_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                                 UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                                 int transferDir, int External)\n{\n\tUINT32 out_size, InterfaceId, EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize, usbd_status, Timeout;\n\tBYTE bmRequestType, Request;\n\tUINT16 Value, Index, length;\n\tBYTE* buffer;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); /** TransferFlags */\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tTimeout = 2000;\n\n\tswitch (External)\n\t{\n\t\tcase URB_CONTROL_TRANSFER_EXTERNAL:\n\t\t\tif (Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tStream_Read_UINT32(s, Timeout); /** TransferFlags */\n\t\t\tbreak;\n\n\t\tcase URB_CONTROL_TRANSFER_NONEXTERNAL:\n\t\t\tbreak;\n\t}\n\n\t/** SetupPacket 8 bytes */\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT8(s, bmRequestType);\n\tStream_Read_UINT8(s, Request);\n\tStream_Read_UINT16(s, Value);\n\tStream_Read_UINT16(s, Index);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\n\tif (length != OutputBufferSize)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"urb_control_transfer ERROR: buf != length\");\n\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tout_size = 36 + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\t/** Get Buffer Data */\n\tbuffer = Stream_Pointer(out);\n\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t\tStream_Copy(s, out, OutputBufferSize);\n\n\t/**  process TS_URB_CONTROL_TRANSFER */\n\tif (!pdev->control_transfer(pdev, RequestId, EndpointAddress, TransferFlags, bmRequestType,\n\t                            Request, Value, Index, &usbd_status, &OutputBufferSize, buffer,\n\t                            Timeout))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic void urb_bulk_transfer_cb(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* out,\n                                 UINT32 InterfaceId, BOOL noAck, UINT32 MessageId, UINT32 RequestId,\n                                 UINT32 NumberOfPackets, UINT32 status, UINT32 StartFrame,\n                                 UINT32 ErrorCount, UINT32 OutputBufferSize)\n{\n\tif (!pdev->isChannelClosed(pdev))\n\t\turb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId, status,\n\t\t                     OutputBufferSize);\n\telse\n\t\tStream_Free(out, TRUE);\n}\n\nstatic UINT urb_bulk_or_interrupt_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 EndpointAddress, PipeHandle;\n\tUINT32 TransferFlags, OutputBufferSize;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!pdev || !callback || !s || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, PipeHandle);\n\tStream_Read_UINT32(s, TransferFlags); /** TransferFlags */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t{\n\t\t\treturn ERROR_INVALID_DATA;\n\t\t}\n\t}\n\n\t/**  process TS_URB_BULK_OR_INTERRUPT_TRANSFER */\n\treturn pdev->bulk_or_interrupt_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, noAck,\n\t    OutputBufferSize, (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_bulk_transfer_cb, 10000);\n}\n\nstatic void urb_isoch_transfer_cb(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* out,\n                                  UINT32 InterfaceId, BOOL noAck, UINT32 MessageId,\n                                  UINT32 RequestId, UINT32 NumberOfPackets, UINT32 status,\n                                  UINT32 StartFrame, UINT32 ErrorCount, UINT32 OutputBufferSize)\n{\n\tif (!noAck)\n\t{\n\t\tUINT32 packetSize = (status == 0) ? NumberOfPackets * 12 : 0;\n\t\tStream_SetPosition(out, 0);\n\t\t/* fill the send data */\n\t\tStream_Write_UINT32(out, InterfaceId); /** interface */\n\t\tStream_Write_UINT32(out, MessageId);   /** message id */\n\n\t\tif (OutputBufferSize == 0)\n\t\t\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA); /** function id */\n\t\telse\n\t\t\tStream_Write_UINT32(out, URB_COMPLETION); /** function id */\n\n\t\tStream_Write_UINT32(out, RequestId);       /** RequestId */\n\t\tStream_Write_UINT32(out, 20 + packetSize); /** CbTsUrbResult */\n\t\t/** TsUrbResult TS_URB_RESULT_HEADER */\n\t\tStream_Write_UINT16(out, 20 + packetSize); /** Size */\n\t\tStream_Write_UINT16(out, 0);               /* Padding */\n\t\tStream_Write_UINT32(out, status);          /** UsbdStatus */\n\t\tStream_Write_UINT32(out, StartFrame);      /** StartFrame */\n\n\t\tif (status == 0)\n\t\t{\n\t\t\t/** NumberOfPackets */\n\t\t\tStream_Write_UINT32(out, NumberOfPackets);\n\t\t\tStream_Write_UINT32(out, ErrorCount); /** ErrorCount */\n\t\t\tStream_Seek(out, packetSize);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tStream_Write_UINT32(out, 0);          /** NumberOfPackets */\n\t\t\tStream_Write_UINT32(out, ErrorCount); /** ErrorCount */\n\t\t}\n\n\t\tStream_Write_UINT32(out, 0);                /** HResult */\n\t\tStream_Write_UINT32(out, OutputBufferSize); /** OutputBufferSize */\n\t\tStream_Seek(out, OutputBufferSize);\n\n\t\tstream_write_and_free(callback->plugin, callback->channel, out);\n\t}\n}\n\nstatic UINT urb_isoch_transfer(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                               UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                               int transferDir)\n{\n\tUINT32 EndpointAddress;\n\tUINT32 PipeHandle, TransferFlags, StartFrame, NumberOfPackets;\n\tUINT32 ErrorCount, OutputBufferSize;\n\tBYTE* packetDescriptorData;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!pdev || !callback || !udevman)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, PipeHandle);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\tStream_Read_UINT32(s, TransferFlags);   /** TransferFlags */\n\tStream_Read_UINT32(s, StartFrame);      /** StartFrame */\n\tStream_Read_UINT32(s, NumberOfPackets); /** NumberOfPackets */\n\tStream_Read_UINT32(s, ErrorCount);      /** ErrorCount */\n\n\tif (Stream_GetRemainingLength(s) < NumberOfPackets * 12 + 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tpacketDescriptorData = Stream_Pointer(s);\n\tStream_Seek(s, NumberOfPackets * 12);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (!Stream_CheckAndLogRequiredLength(TAG, s, OutputBufferSize))\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\treturn pdev->isoch_transfer(\n\t    pdev, callback, MessageId, RequestId, EndpointAddress, TransferFlags, StartFrame,\n\t    ErrorCount, noAck, packetDescriptorData, NumberOfPackets, OutputBufferSize,\n\t    (transferDir == USBD_TRANSFER_DIRECTION_OUT) ? Stream_Pointer(s) : NULL,\n\t    urb_isoch_transfer_cb, 2000);\n}\n\nstatic UINT urb_control_descriptor_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, BYTE func_recipient, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tBYTE bmRequestType, desc_index, desc_type;\n\tUINT16 langId;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT8(s, desc_index);\n\tStream_Read_UINT8(s, desc_type);\n\tStream_Read_UINT16(s, langId);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tbmRequestType = func_recipient;\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_IN:\n\t\t\tbmRequestType |= 0x80;\n\t\t\tbreak;\n\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tbmRequestType |= 0x00;\n\t\t\tStream_Copy(s, out, OutputBufferSize);\n\t\t\tStream_Rewind(out, OutputBufferSize);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"get error transferDir\");\n\t\t\tOutputBufferSize = 0;\n\t\t\tusbd_status = USBD_STATUS_STALL_PID;\n\t\t\tbreak;\n\t}\n\n\t/** process get usb device descriptor */\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType,\n\t                            0x06, /* REQUEST_GET_DESCRIPTOR */\n\t                            (desc_type << 8) | desc_index, langId, &usbd_status,\n\t                            &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"get_descriptor failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_control_get_status_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                           wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                           IUDEVMAN* udevman, BYTE func_recipient, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tUINT16 Index;\n\tBYTE bmRequestType;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_control_get_status_request: transfer out not supported\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT16(s, Index); /** Index */\n\tStream_Seek(s, 2);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tbmRequestType = func_recipient | 0x80;\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType, 0x00, /* REQUEST_GET_STATUS */\n\t                            0, Index, &usbd_status, &OutputBufferSize, Stream_Pointer(out),\n\t                            1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_control_vendor_or_class_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                                wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                                IUDEVMAN* udevman, BYTE func_type,\n                                                BYTE func_recipient, int transferDir)\n{\n\tUINT32 out_size, InterfaceId, TransferFlags, usbd_status;\n\tUINT32 OutputBufferSize;\n\tBYTE ReqTypeReservedBits, Request, bmRequestType;\n\tUINT16 Value, Index, Padding;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 16)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, TransferFlags);      /** TransferFlags */\n\tStream_Read_UINT8(s, ReqTypeReservedBits); /** ReqTypeReservedBids */\n\tStream_Read_UINT8(s, Request);             /** Request */\n\tStream_Read_UINT16(s, Value);              /** value */\n\tStream_Read_UINT16(s, Index);              /** index */\n\tStream_Read_UINT16(s, Padding);            /** Padding */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\treturn ERROR_INVALID_DATA;\n\t}\n\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\n\t/** Get Buffer */\n\tif (transferDir == USBD_TRANSFER_DIRECTION_OUT)\n\t{\n\t\tStream_Copy(s, out, OutputBufferSize);\n\t\tStream_Rewind(out, OutputBufferSize);\n\t}\n\n\t/** vendor or class command */\n\tbmRequestType = func_type | func_recipient;\n\n\tif (TransferFlags & USBD_TRANSFER_DIRECTION)\n\t\tbmRequestType |= 0x80;\n\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"RequestId 0x%\" PRIx32 \" TransferFlags: 0x%\" PRIx32 \" ReqTypeReservedBits: 0x%\" PRIx8\n\t           \" \"\n\t           \"Request:0x%\" PRIx8 \" Value: 0x%\" PRIx16 \" Index: 0x%\" PRIx16\n\t           \" OutputBufferSize: 0x%\" PRIx32 \" bmRequestType: 0x%\" PRIx8,\n\t           RequestId, TransferFlags, ReqTypeReservedBits, Request, Value, Index,\n\t           OutputBufferSize, bmRequestType);\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType, Request, Value, Index,\n\t                            &usbd_status, &OutputBufferSize, Stream_Pointer(out), 2000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_ERROR, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_os_feature_descriptor_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                              wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                              IUDEVMAN* udevman, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tBYTE Recipient, InterfaceNumber, Ms_PageIndex;\n\tUINT16 Ms_featureDescIndex;\n\twStream* out;\n\tint ret;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\t/* 2.2.9.15 TS_URB_OS_FEATURE_DESCRIPTOR_REQUEST */\n\tStream_Read_UINT8(s, Recipient);            /** Recipient */\n\tRecipient = (Recipient & 0x1f);             /* Mask out Padding1 */\n\tStream_Read_UINT8(s, InterfaceNumber);      /** InterfaceNumber */\n\tStream_Read_UINT8(s, Ms_PageIndex);         /** Ms_PageIndex */\n\tStream_Read_UINT16(s, Ms_featureDescIndex); /** Ms_featureDescIndex */\n\tStream_Seek(s, 3);                          /* Padding 2 */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tStream_Copy(s, out, OutputBufferSize);\n\t\t\tStream_Rewind(out, OutputBufferSize);\n\t\t\tbreak;\n\n\t\tcase USBD_TRANSFER_DIRECTION_IN:\n\t\t\tbreak;\n\t}\n\n\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t           \"Ms descriptor arg: Recipient:0x%\" PRIx8 \", \"\n\t           \"InterfaceNumber:0x%\" PRIx8 \", Ms_PageIndex:0x%\" PRIx8 \", \"\n\t           \"Ms_featureDescIndex:0x%\" PRIx16 \", OutputBufferSize:0x%\" PRIx32 \"\",\n\t           Recipient, InterfaceNumber, Ms_PageIndex, Ms_featureDescIndex, OutputBufferSize);\n\t/** get ms string */\n\tret = pdev->os_feature_descriptor_request(pdev, RequestId, Recipient, InterfaceNumber,\n\t                                          Ms_PageIndex, Ms_featureDescIndex, &usbd_status,\n\t                                          &OutputBufferSize, Stream_Pointer(out), 1000);\n\n\tif (ret < 0)\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"os_feature_descriptor_request: error num %d\", ret);\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_pipe_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback, wStream* s,\n                             UINT32 RequestField, UINT32 MessageId, IUDEVMAN* udevman,\n                             int transferDir, int action)\n{\n\tUINT32 out_size, InterfaceId, PipeHandle, EndpointAddress;\n\tUINT32 OutputBufferSize, usbd_status = 0;\n\twStream* out;\n\tUINT32 ret = USBD_STATUS_REQUEST_FAILED;\n\tint rc;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urb_pipe_request: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, PipeHandle); /** PipeHandle */\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tEndpointAddress = (PipeHandle & 0x000000ff);\n\n\tswitch (action)\n\t{\n\t\tcase PIPE_CANCEL:\n\t\t\trc = pdev->control_pipe_request(pdev, RequestId, EndpointAddress, &usbd_status,\n\t\t\t                                PIPE_CANCEL);\n\n\t\t\tif (rc < 0)\n\t\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"PIPE SET HALT: error %d\", ret);\n\t\t\telse\n\t\t\t\tret = USBD_STATUS_SUCCESS;\n\n\t\t\tbreak;\n\n\t\tcase PIPE_RESET:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urb_pipe_request: PIPE_RESET ep 0x%\" PRIx32 \"\",\n\t\t\t           EndpointAddress);\n\t\t\trc = pdev->control_pipe_request(pdev, RequestId, EndpointAddress, &usbd_status,\n\t\t\t                                PIPE_RESET);\n\n\t\t\tif (rc < 0)\n\t\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"PIPE RESET: error %d\", ret);\n\t\t\telse\n\t\t\t\tret = USBD_STATUS_SUCCESS;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"urb_pipe_request action: %d not supported\",\n\t\t\t           action);\n\t\t\tret = USBD_STATUS_INVALID_URB_FUNCTION;\n\t\t\tbreak;\n\t}\n\n\t/** send data */\n\tout_size = 36;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId, ret,\n\t                            0);\n}\n\nstatic UINT urb_get_current_frame_number(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                         wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                         IUDEVMAN* udevman, int transferDir)\n{\n\tUINT32 out_size, InterfaceId, OutputBufferSize;\n\tUINT32 dummy_frames;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_get_current_frame_number: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT32(s, OutputBufferSize);\n\t/** Fixme: Need to fill actual frame number!!*/\n\tdummy_frames = GetTickCount();\n\tout_size = 40;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Write_UINT32(out, InterfaceId); /** interface */\n\tStream_Write_UINT32(out, MessageId);   /** message id */\n\tStream_Write_UINT32(out, URB_COMPLETION_NO_DATA);\n\tStream_Write_UINT32(out, RequestId); /** RequestId */\n\tStream_Write_UINT32(out, 12);        /** CbTsUrbResult */\n\t/** TsUrbResult TS_URB_RESULT_HEADER */\n\tStream_Write_UINT16(out, 12); /** Size */\n\t/** Padding, MUST be ignored upon receipt */\n\tStream_Write_UINT16(out, TS_URB_GET_CURRENT_FRAME_NUMBER);\n\tStream_Write_UINT32(out, USBD_STATUS_SUCCESS); /** UsbdStatus */\n\tStream_Write_UINT32(out, dummy_frames);        /** FrameNumber */\n\tStream_Write_UINT32(out, 0);                   /** HResult */\n\tStream_Write_UINT32(out, 0);                   /** OutputBufferSize */\n\n\tif (!noAck)\n\t\treturn stream_write_and_free(callback->plugin, callback->channel, out);\n\telse\n\t\tStream_Free(out, TRUE);\n\n\treturn ERROR_SUCCESS;\n}\n\n/* Unused function for current server */\nstatic UINT urb_control_get_configuration_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                                  wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                                  IUDEVMAN* udevman, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_control_get_configuration_request:\"\n\t\t           \" not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, 0x80 | 0x00,\n\t                            0x08, /* REQUEST_GET_CONFIGURATION */\n\t                            0, 0, &usbd_status, &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\n/* Unused function for current server */\nstatic UINT urb_control_get_interface_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                              wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                              IUDEVMAN* udevman, int transferDir)\n{\n\tsize_t out_size;\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tUINT16 interface;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tif (transferDir == 0)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG,\n\t\t           \"urb_control_get_interface_request: not support transfer out\");\n\t\treturn ERROR_INVALID_PARAMETER;\n\t}\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT16(s, interface);\n\tStream_Seek(s, 2);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tout_size = 36ULL + OutputBufferSize;\n\tout = Stream_New(NULL, out_size);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\n\tif (!pdev->control_transfer(\n\t        pdev, RequestId, 0, 0, 0x80 | 0x01, 0x0A, /* REQUEST_GET_INTERFACE */\n\t        0, interface, &usbd_status, &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"control_transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urb_control_feature_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                        wStream* s, UINT32 RequestField, UINT32 MessageId,\n                                        IUDEVMAN* udevman, BYTE func_recipient, BYTE command,\n                                        int transferDir)\n{\n\tUINT32 InterfaceId, OutputBufferSize, usbd_status;\n\tUINT16 FeatureSelector, Index;\n\tBYTE bmRequestType, bmRequest;\n\twStream* out;\n\tURBDRC_PLUGIN* urbdrc;\n\tconst BOOL noAck = (RequestField & 0x80000000U) != 0;\n\tconst UINT32 RequestId = RequestField & 0x7FFFFFFF;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn ERROR_INVALID_DATA;\n\n\tInterfaceId = ((STREAM_ID_PROXY << 30) | pdev->get_ReqCompletion(pdev));\n\tStream_Read_UINT16(s, FeatureSelector);\n\tStream_Read_UINT16(s, Index);\n\tStream_Read_UINT32(s, OutputBufferSize);\n\tif (OutputBufferSize > UINT32_MAX - 36)\n\t\treturn ERROR_INVALID_DATA;\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tif (Stream_GetRemainingLength(s) < OutputBufferSize)\n\t\t\t\treturn ERROR_INVALID_DATA;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\tout = Stream_New(NULL, 36ULL + OutputBufferSize);\n\n\tif (!out)\n\t\treturn ERROR_OUTOFMEMORY;\n\n\tStream_Seek(out, 36);\n\tbmRequestType = func_recipient;\n\n\tswitch (transferDir)\n\t{\n\t\tcase USBD_TRANSFER_DIRECTION_OUT:\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \"Function urb_control_feature_request: OUT Unchecked\");\n\t\t\tStream_Copy(s, out, OutputBufferSize);\n\t\t\tStream_Rewind(out, OutputBufferSize);\n\t\t\tbmRequestType |= 0x00;\n\t\t\tbreak;\n\n\t\tcase USBD_TRANSFER_DIRECTION_IN:\n\t\t\tbmRequestType |= 0x80;\n\t\t\tbreak;\n\t}\n\n\tswitch (command)\n\t{\n\t\tcase URB_SET_FEATURE:\n\t\t\tbmRequest = 0x03; /* REQUEST_SET_FEATURE */\n\t\t\tbreak;\n\n\t\tcase URB_CLEAR_FEATURE:\n\t\t\tbmRequest = 0x01; /* REQUEST_CLEAR_FEATURE */\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_ERROR,\n\t\t\t           \"urb_control_feature_request: Error Command 0x%02\" PRIx8 \"\", command);\n\t\t\tStream_Free(out, TRUE);\n\t\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\tif (!pdev->control_transfer(pdev, RequestId, 0, 0, bmRequestType, bmRequest, FeatureSelector,\n\t                            Index, &usbd_status, &OutputBufferSize, Stream_Pointer(out), 1000))\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"feature control transfer failed\");\n\t\tStream_Free(out, TRUE);\n\t\treturn ERROR_INTERNAL_ERROR;\n\t}\n\n\treturn urb_write_completion(pdev, callback, noAck, out, InterfaceId, MessageId, RequestId,\n\t                            usbd_status, OutputBufferSize);\n}\n\nstatic UINT urbdrc_process_transfer_request(IUDEVICE* pdev, URBDRC_CHANNEL_CALLBACK* callback,\n                                            wStream* s, UINT32 MessageId, IUDEVMAN* udevman,\n                                            int transferDir)\n{\n\tUINT32 CbTsUrb;\n\tUINT16 Size;\n\tUINT16 URB_Function;\n\tUINT32 RequestId;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\tURBDRC_PLUGIN* urbdrc;\n\n\tif (!callback || !s || !udevman || !pdev)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\turbdrc = (URBDRC_PLUGIN*)callback->plugin;\n\n\tif (!urbdrc)\n\t\treturn ERROR_INVALID_PARAMETER;\n\n\tif (Stream_GetRemainingLength(s) < 12)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(s, CbTsUrb); /** CbTsUrb */\n\tStream_Read_UINT16(s, Size);    /** size */\n\tStream_Read_UINT16(s, URB_Function);\n\tStream_Read_UINT32(s, RequestId);\n\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"URB %s[\" PRIu16 \"]\", urb_function_string(URB_Function),\n\t           URB_Function);\n\n\tswitch (URB_Function)\n\t{\n\t\tcase TS_URB_SELECT_CONFIGURATION: /** 0x0000 */\n\t\t\terror = urb_select_configuration(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                 transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SELECT_INTERFACE: /** 0x0001 */\n\t\t\terror =\n\t\t\t    urb_select_interface(pdev, callback, s, RequestId, MessageId, udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_PIPE_REQUEST: /** 0x0002  */\n\t\t\terror = urb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                         PIPE_CANCEL);\n\t\t\tbreak;\n\n\t\tcase TS_URB_TAKE_FRAME_LENGTH_CONTROL: /** 0x0003  */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_RELEASE_FRAME_LENGTH_CONTROL: /** 0x0004 */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_FRAME_LENGTH: /** 0x0005 */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FRAME_LENGTH: /** 0x0006 */\n\t\t\t/** This URB function is obsolete in Windows 2000\n\t\t\t * and later operating systems\n\t\t\t * and is not supported by Microsoft. */\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_CURRENT_FRAME_NUMBER: /** 0x0007 */\n\t\t\terror = urb_get_current_frame_number(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                     transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_TRANSFER: /** 0x0008 */\n\t\t\terror = urb_control_transfer(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                             transferDir, URB_CONTROL_TRANSFER_NONEXTERNAL);\n\t\t\tbreak;\n\n\t\tcase TS_URB_BULK_OR_INTERRUPT_TRANSFER: /** 0x0009 */\n\t\t\terror = urb_bulk_or_interrupt_transfer(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_ISOCH_TRANSFER: /** 0x000A */\n\t\t\terror =\n\t\t\t    urb_isoch_transfer(pdev, callback, s, RequestId, MessageId, udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_DESCRIPTOR_FROM_DEVICE: /** 0x000B */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_DESCRIPTOR_TO_DEVICE: /** 0x000C */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_DEVICE: /** 0x000D */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x00, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_INTERFACE: /** 0x000E */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x01, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_ENDPOINT: /** 0x000F */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x02, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_DEVICE: /** 0x0010 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x00, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_INTERFACE: /** 0x0011 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x01, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_ENDPOINT: /** 0x0012 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x02, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_DEVICE: /** 0x0013 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_INTERFACE: /** 0x0014 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_ENDPOINT: /** 0x0015 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_RESERVED_0X0016: /** 0x0016 */\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_DEVICE: /** 0x0017 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_INTERFACE: /** 0x0018 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_ENDPOINT: /** 0x0019 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_DEVICE: /** 0x001A */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x00, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_INTERFACE: /** 0x001B */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_ENDPOINT: /** 0x001C */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_RESERVE_0X001D: /** 0x001D */\n\t\t\tbreak;\n\n\t\tcase TS_URB_SYNC_RESET_PIPE_AND_CLEAR_STALL: /** 0x001E */\n\t\t\terror = urb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                         PIPE_RESET);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLASS_OTHER: /** 0x001F */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x01 << 5), /* class type */\n\t\t\t                                            0x03, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_VENDOR_OTHER: /** 0x0020 */\n\t\t\terror = urb_control_vendor_or_class_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                            udevman, (0x02 << 5), /* vendor type */\n\t\t\t                                            0x03, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_STATUS_FROM_OTHER: /** 0x0021 */\n\t\t\terror = urb_control_get_status_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x03, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CLEAR_FEATURE_TO_OTHER: /** 0x0022 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x03, URB_CLEAR_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_FEATURE_TO_OTHER: /** 0x0023 */\n\t\t\terror = urb_control_feature_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                    0x03, URB_SET_FEATURE, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_DESCRIPTOR_FROM_ENDPOINT: /** 0x0024 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_DESCRIPTOR_TO_ENDPOINT: /** 0x0025 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x02, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_GET_CONFIGURATION_REQUEST: /** 0x0026 */\n\t\t\terror = urb_control_get_configuration_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                              udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_GET_INTERFACE_REQUEST: /** 0x0027 */\n\t\t\terror = urb_control_get_interface_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                          udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_DESCRIPTOR_FROM_INTERFACE: /** 0x0028 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SET_DESCRIPTOR_TO_INTERFACE: /** 0x0029 */\n\t\t\terror = urb_control_descriptor_request(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                                       0x01, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_GET_OS_FEATURE_DESCRIPTOR_REQUEST: /** 0x002A */\n\t\t\terror = urb_os_feature_descriptor_request(pdev, callback, s, RequestId, MessageId,\n\t\t\t                                          udevman, transferDir);\n\t\t\tbreak;\n\n\t\tcase TS_URB_RESERVE_0X002B: /** 0x002B */\n\t\tcase TS_URB_RESERVE_0X002C: /** 0x002C */\n\t\tcase TS_URB_RESERVE_0X002D: /** 0x002D */\n\t\tcase TS_URB_RESERVE_0X002E: /** 0x002E */\n\t\tcase TS_URB_RESERVE_0X002F: /** 0x002F */\n\t\t\tbreak;\n\n\t\t/** USB 2.0 calls start at 0x0030 */\n\t\tcase TS_URB_SYNC_RESET_PIPE: /** 0x0030 */\n\t\t\terror = urb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                         PIPE_RESET);\n\t\t\tbreak;\n\n\t\tcase TS_URB_SYNC_CLEAR_STALL: /** 0x0031 */\n\t\t\turb_pipe_request(pdev, callback, s, RequestId, MessageId, udevman, transferDir,\n\t\t\t                 PIPE_RESET);\n\t\t\tbreak;\n\n\t\tcase TS_URB_CONTROL_TRANSFER_EX: /** 0x0032 */\n\t\t\terror = urb_control_transfer(pdev, callback, s, RequestId, MessageId, udevman,\n\t\t\t                             transferDir, URB_CONTROL_TRANSFER_EXTERNAL);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_DEBUG, \"URB_Func: %\" PRIx16 \" is not found!\",\n\t\t\t           URB_Function);\n\t\t\tbreak;\n\t}\n\n\tif (error)\n\t{\n\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t           \"USB transfer request URB Function %08\" PRIx32 \" failed with %08\" PRIx32,\n\t\t           URB_Function, error);\n\t}\n\n\treturn error;\n}\n\nUINT urbdrc_process_udev_data_transfer(URBDRC_CHANNEL_CALLBACK* callback, URBDRC_PLUGIN* urbdrc,\n                                       IUDEVMAN* udevman, wStream* data)\n{\n\tUINT32 InterfaceId;\n\tUINT32 MessageId;\n\tUINT32 FunctionId;\n\tIUDEVICE* pdev;\n\tUINT error = ERROR_INTERNAL_ERROR;\n\tsize_t len;\n\n\tif (!urbdrc || !data || !callback || !udevman)\n\t\tgoto fail;\n\n\tlen = Stream_GetRemainingLength(data);\n\n\tif (len < 8)\n\t\tgoto fail;\n\n\tStream_Rewind_UINT32(data);\n\n\tStream_Read_UINT32(data, InterfaceId);\n\tStream_Read_UINT32(data, MessageId);\n\tStream_Read_UINT32(data, FunctionId);\n\n\tpdev = udevman->get_udevice_by_UsbDevice(udevman, InterfaceId);\n\n\t/* Device does not exist, ignore this request. */\n\tif (pdev == NULL)\n\t{\n\t\terror = ERROR_SUCCESS;\n\t\tgoto fail;\n\t}\n\n\t/* Device has been removed, ignore this request. */\n\tif (pdev->isChannelClosed(pdev))\n\t{\n\t\terror = ERROR_SUCCESS;\n\t\tgoto fail;\n\t}\n\n\t/* USB kernel driver detach!! */\n\tpdev->detach_kernel_driver(pdev);\n\n\tswitch (FunctionId)\n\t{\n\t\tcase CANCEL_REQUEST:\n\t\t\terror = urbdrc_process_cancel_request(pdev, data, udevman);\n\t\t\tbreak;\n\n\t\tcase REGISTER_REQUEST_CALLBACK:\n\t\t\terror = urbdrc_process_register_request_callback(pdev, callback, data, udevman);\n\t\t\tbreak;\n\n\t\tcase IO_CONTROL:\n\t\t\terror = urbdrc_process_io_control(pdev, callback, data, MessageId, udevman);\n\t\t\tbreak;\n\n\t\tcase INTERNAL_IO_CONTROL:\n\t\t\terror = urbdrc_process_internal_io_control(pdev, callback, data, MessageId, udevman);\n\t\t\tbreak;\n\n\t\tcase QUERY_DEVICE_TEXT:\n\t\t\terror = urbdrc_process_query_device_text(pdev, callback, data, MessageId, udevman);\n\t\t\tbreak;\n\n\t\tcase TRANSFER_IN_REQUEST:\n\t\t\terror = urbdrc_process_transfer_request(pdev, callback, data, MessageId, udevman,\n\t\t\t                                        USBD_TRANSFER_DIRECTION_IN);\n\t\t\tbreak;\n\n\t\tcase TRANSFER_OUT_REQUEST:\n\t\t\terror = urbdrc_process_transfer_request(pdev, callback, data, MessageId, udevman,\n\t\t\t                                        USBD_TRANSFER_DIRECTION_OUT);\n\t\t\tbreak;\n\n\t\tcase RETRACT_DEVICE:\n\t\t\terror = urbdrc_process_retract_device_request(pdev, data, udevman);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_Print(urbdrc->log, WLOG_WARN,\n\t\t\t           \"urbdrc_process_udev_data_transfer:\"\n\t\t\t           \" unknown FunctionId 0x%\" PRIX32 \"\",\n\t\t\t           FunctionId);\n\t\t\tbreak;\n\t}\n\nfail:\n\tif (error)\n\t{\n\t\tWLog_WARN(TAG, \"USB request failed with %08\" PRIx32, error);\n\t}\n\n\treturn error;\n}\n"], "filenames": ["channels/urbdrc/client/data_transfer.c"], "buggy_code_start_loc": [249], "buggy_code_end_loc": [812], "fixing_code_start_loc": [250], "fixing_code_end_loc": [833], "type": "CWE-125", "message": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input length validation in the `urbdrc` channel. A malicious server can trick a FreeRDP based client to read out of bound data and send it back to the server. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection switch.", "other": {"cve": {"id": "CVE-2022-39319", "sourceIdentifier": "security-advisories@github.com", "published": "2022-11-16T21:15:10.493", "lastModified": "2023-01-25T19:56:57.153", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP is a free remote desktop protocol library and clients. Affected versions of FreeRDP are missing input length validation in the `urbdrc` channel. A malicious server can trick a FreeRDP based client to read out of bound data and send it back to the server. This issue has been addressed in version 2.9.0 and all users are advised to upgrade. Users unable to upgrade should not use the `/usb` redirection switch."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.9.0", "matchCriteriaId": "AF273D61-AA72-44FE-937E-D5749D565AEE"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://github.com/FreeRDP/FreeRDP/commit/11555828d2cf289b350baba5ad1f462f10b80b76", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-mvxm-wfj2-5fvh", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/UDOTAOJBCZKREZJPT6VZ25GESI5T6RBG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YGQN3OWQNHSMWKOF4D35PF5ASKNLC74B/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/11555828d2cf289b350baba5ad1f462f10b80b76"}}