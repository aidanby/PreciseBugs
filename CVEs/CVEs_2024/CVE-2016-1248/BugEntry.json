{"buggy_code": ["/*\n * Code to handle user-settable options. This is all pretty much table-\n * driven. Checklist for adding a new option:\n * - Put it in the options array below (copy an existing entry).\n * - For a global option: Add a variable for it in option_defs.h.\n * - For a buffer or window local option:\n *   - Add a PV_XX entry to the enum below.\n *   - Add a variable to the window or buffer struct in buffer_defs.h.\n *   - For a window option, add some code to copy_winopt().\n *   - For a buffer option, add some code to buf_copy_options().\n *   - For a buffer string option, add code to check_buf_options().\n * - If it's a numeric option, add any necessary bounds checks to do_set().\n * - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n * - When adding an option with expansion (P_EXPAND), but with a different\n *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.\n * - Add documentation!  One line in doc/help.txt, full description in\n *   options.txt, and any other related places.\n * - Add an entry in runtime/optwin.vim.\n * When making changes:\n * - Adjust the help for the option in doc/option.txt.\n */\n\n#define IN_OPTION_C\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/option.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hardcopy.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memfile.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/cursor_shape.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/input.h\"\n\n/*\n * The options that are local to a window or buffer have \"indir\" set to one of\n * these values.  Special values:\n * PV_NONE: global option.\n * PV_WIN is added: window-local option\n * PV_BUF is added: buffer-local option\n * PV_BOTH is added: global option which also has a local value.\n */\n#define PV_BOTH 0x1000\n#define PV_WIN  0x2000\n#define PV_BUF  0x4000\n#define PV_MASK 0x0fff\n#define OPT_WIN(x)  (idopt_T)(PV_WIN + (int)(x))\n#define OPT_BUF(x)  (idopt_T)(PV_BUF + (int)(x))\n#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))\n\n\n/* WV_ and BV_ values get typecasted to this for the \"indir\" field */\ntypedef enum {\n  PV_NONE = 0,\n  PV_MAXVAL = 0xffff      /* to avoid warnings for value out of range */\n} idopt_T;\n\n/*\n * Options local to a window have a value local to a buffer and global to all\n * buffers.  Indicate this by setting \"var\" to VAR_WIN.\n */\n#define VAR_WIN ((char_u *)-1)\n\n/*\n * These are the global values for options which are also local to a buffer.\n * Only to be used in option.c!\n */\nstatic int p_ai;\nstatic int p_bin;\nstatic int p_bomb;\nstatic char_u   *p_bh;\nstatic char_u   *p_bt;\nstatic int p_bl;\nstatic int p_ci;\nstatic int p_cin;\nstatic char_u   *p_cink;\nstatic char_u   *p_cino;\nstatic char_u   *p_cinw;\nstatic char_u   *p_com;\nstatic char_u   *p_cms;\nstatic char_u   *p_cpt;\nstatic char_u   *p_cfu;\nstatic char_u   *p_ofu;\nstatic int p_eol;\nstatic int p_fixeol;\nstatic int p_et;\nstatic char_u   *p_fenc;\nstatic char_u   *p_ff;\nstatic char_u   *p_fo;\nstatic char_u   *p_flp;\nstatic char_u   *p_ft;\nstatic long p_iminsert;\nstatic long p_imsearch;\nstatic char_u   *p_inex;\nstatic char_u   *p_inde;\nstatic char_u   *p_indk;\nstatic char_u   *p_fex;\nstatic int p_inf;\nstatic char_u   *p_isk;\nstatic int p_lisp;\nstatic int p_ml;\nstatic int p_ma;\nstatic int p_mod;\nstatic char_u   *p_mps;\nstatic char_u   *p_nf;\nstatic int p_pi;\nstatic char_u   *p_qe;\nstatic int p_ro;\nstatic int p_si;\nstatic long p_sts;\nstatic char_u   *p_sua;\nstatic long p_sw;\nstatic int p_swf;\nstatic long p_smc;\nstatic char_u   *p_syn;\nstatic char_u   *p_spc;\nstatic char_u   *p_spf;\nstatic char_u   *p_spl;\nstatic long p_ts;\nstatic long p_tw;\nstatic int p_udf;\nstatic long p_wm;\nstatic char_u   *p_keymap;\n\n/* Saved values for when 'bin' is set. */\nstatic int p_et_nobin;\nstatic int p_ml_nobin;\nstatic long p_tw_nobin;\nstatic long p_wm_nobin;\n\n// Saved values for when 'paste' is set.\nstatic int p_ai_nopaste;\nstatic int p_et_nopaste;\nstatic long p_sts_nopaste;\nstatic long p_tw_nopaste;\nstatic long p_wm_nopaste;\n\ntypedef struct vimoption {\n  char        *fullname;        /* full option name */\n  char        *shortname;       /* permissible abbreviation */\n  uint32_t flags;               /* see below */\n  char_u      *var;             /* global option: pointer to variable;\n                                * window-local option: VAR_WIN;\n                                * buffer-local option: global value */\n  idopt_T indir;                /* global option: PV_NONE;\n                                 * local option: indirect option index */\n  char_u      *def_val[2];      /* default values for variable (vi and vim) */\n  scid_T scriptID;              /* script in which the option was last set */\n# define SCRIPTID_INIT , 0\n} vimoption_T;\n\n#define VI_DEFAULT  0       /* def_val[VI_DEFAULT] is Vi default value */\n#define VIM_DEFAULT 1       /* def_val[VIM_DEFAULT] is Vim default value */\n\n/*\n * Flags\n */\n#define P_BOOL          0x01U    /* the option is boolean */\n#define P_NUM           0x02U    /* the option is numeric */\n#define P_STRING        0x04U    /* the option is a string */\n#define P_ALLOCED       0x08U    /* the string option is in allocated memory,\n                                    must use free_string_option() when\n                                    assigning new value. Not set if default is\n                                    the same. */\n#define P_EXPAND        0x10U    /* environment expansion.  NOTE: P_EXPAND can\n                                    never be used for local or hidden options */\n#define P_NODEFAULT     0x40U    /* don't set to default value */\n#define P_DEF_ALLOCED   0x80U    /* default value is in allocated memory, must\n                                    use free() when assigning new value */\n#define P_WAS_SET       0x100U   /* option has been set/reset */\n#define P_NO_MKRC       0x200U   /* don't include in :mkvimrc output */\n#define P_VI_DEF        0x400U   /* Use Vi default for Vim */\n#define P_VIM           0x800U   /* Vim option */\n\n/* when option changed, what to display: */\n#define P_RSTAT         0x1000U  /* redraw status lines */\n#define P_RWIN          0x2000U  /* redraw current window */\n#define P_RBUF          0x4000U  /* redraw current buffer */\n#define P_RALL          0x6000U  /* redraw all windows */\n#define P_RCLR          0x7000U  /* clear and redraw all */\n\n#define P_COMMA         0x8000U    ///< comma separated list\n#define P_ONECOMMA      0x18000U   ///< P_COMMA and cannot have two consecutive\n                                   ///< commas\n#define P_NODUP         0x20000U   ///< don't allow duplicate strings\n#define P_FLAGLIST      0x40000U   ///< list of single-char flags\n\n#define P_SECURE        0x80000U   ///< cannot change in modeline or secure mode\n#define P_GETTEXT       0x100000U  ///< expand default value with _()\n#define P_NOGLOB        0x200000U  ///< do not use local value for global vimrc\n#define P_NFNAME        0x400000U  ///< only normal file name chars allowed\n#define P_INSECURE      0x800000U  ///< option was set from a modeline\n#define P_PRI_MKRC     0x1000000U  ///< priority for :mkvimrc (setting option\n                                   ///< has side effects)\n#define P_NO_ML        0x2000000U  ///< not allowed in modeline\n#define P_CURSWANT     0x4000000U  ///< update curswant required; not needed\n                                   ///< when there is a redraw flag\n#define P_NO_DEF_EXP   0x8000000U  ///< Do not expand default value.\n\n#define HIGHLIGHT_INIT \\\n  \"8:SpecialKey,~:EndOfBuffer,z:TermCursor,Z:TermCursorNC,@:NonText,\" \\\n  \"d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,\" \\\n  \"N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,\" \\\n  \"v:Visual,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,\" \\\n  \"A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,-:Conceal,\" \\\n  \"B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,\" \\\n  \"x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,\" \\\n  \"!:CursorColumn,.:CursorLine,o:ColorColumn,q:QuickFixLine\"\n\n/*\n * options[] is initialized here.\n * The order of the options MUST be alphabetic for \":set all\" and findoption().\n * All option names MUST start with a lowercase letter (for findoption()).\n * Exception: \"t_\" options are at the end.\n * The options with a NULL variable are 'hidden': a set command for them is\n * ignored and they are not printed.\n */\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"options.generated.h\"\n#endif\n\n#define PARAM_COUNT ARRAY_SIZE(options)\n\nstatic char *(p_ambw_values[]) =      { \"single\", \"double\", NULL };\nstatic char *(p_bg_values[]) =        { \"light\", \"dark\", NULL };\nstatic char *(p_nf_values[]) =        { \"bin\", \"octal\", \"hex\", \"alpha\", NULL };\nstatic char *(p_ff_values[]) =        { FF_UNIX, FF_DOS, FF_MAC, NULL };\nstatic char *(p_wop_values[]) =       { \"tagfile\", NULL };\nstatic char *(p_wak_values[]) =       { \"yes\", \"menu\", \"no\", NULL };\nstatic char *(p_mousem_values[]) =    { \"extend\", \"popup\", \"popup_setpos\",\n                                        \"mac\", NULL };\nstatic char *(p_sel_values[]) =       { \"inclusive\", \"exclusive\", \"old\", NULL };\nstatic char *(p_slm_values[]) =       { \"mouse\", \"key\", \"cmd\", NULL };\nstatic char *(p_km_values[]) =        { \"startsel\", \"stopsel\", NULL };\nstatic char *(p_scbopt_values[]) =    { \"ver\", \"hor\", \"jump\", NULL };\nstatic char *(p_debug_values[]) =     { \"msg\", \"throw\", \"beep\", NULL };\nstatic char *(p_ead_values[]) =       { \"both\", \"ver\", \"hor\", NULL };\nstatic char *(p_buftype_values[]) =   { \"nofile\", \"nowrite\", \"quickfix\",\n                                        \"help\", \"acwrite\", \"terminal\", NULL };\n\nstatic char *(p_bufhidden_values[]) = { \"hide\", \"unload\", \"delete\",\n                                        \"wipe\", NULL };\nstatic char *(p_bs_values[]) =        { \"indent\", \"eol\", \"start\", NULL };\nstatic char *(p_fdm_values[]) =       { \"manual\", \"expr\", \"marker\", \"indent\",\n                                        \"syntax\",  \"diff\", NULL };\nstatic char *(p_fcl_values[]) =       { \"all\", NULL };\nstatic char *(p_cot_values[]) =       { \"menu\", \"menuone\", \"longest\", \"preview\",\n                                        \"noinsert\", \"noselect\", NULL };\nstatic char *(p_icm_values[]) =       { \"nosplit\", \"split\", NULL };\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"option.c.generated.h\"\n#endif\n\n/// Append string with escaped commas\nstatic char *strcpy_comma_escaped(char *dest, const char *src, const size_t len)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  size_t shift = 0;\n  for (size_t i = 0; i < len; i++) {\n    if (src[i] == ',') {\n      dest[i + shift++] = '\\\\';\n    }\n    dest[i + shift] = src[i];\n  }\n  return &dest[len + shift];\n}\n\n/// Compute length of a colon-separated value, doubled and with some suffixes\n///\n/// @param[in]  val  Colon-separated array value.\n/// @param[in]  common_suf_len  Length of the common suffix which is appended to\n///                             each item in the array, twice.\n/// @param[in]  single_suf_len  Length of the suffix which is appended to each\n///                             item in the array once.\n///\n/// @return Length of the comma-separated string array that contains each item\n///         in the original array twice with suffixes with given length\n///         (common_suf is present after each new item, single_suf is present\n///         after half of the new items) and with commas after each item, commas\n///         inside the values are escaped.\nstatic inline size_t compute_double_colon_len(const char *const val,\n                                              const size_t common_suf_len,\n                                              const size_t single_suf_len)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE\n{\n  if (val == NULL || *val == NUL) {\n    return 0;\n  }\n  size_t ret = 0;\n  const void *iter = NULL;\n  do {\n    size_t dir_len;\n    const char *dir;\n    iter = vim_colon_env_iter(val, iter, &dir, &dir_len);\n    if (dir != NULL && dir_len > 0) {\n      ret += ((dir_len + memcnt(dir, ',', dir_len) + common_suf_len\n               + !after_pathsep(dir, dir + dir_len)) * 2\n              + single_suf_len);\n    }\n  } while (iter != NULL);\n  return ret;\n}\n\n#define NVIM_SIZE (sizeof(\"nvim\") - 1)\n\n/// Add directories to a comma-separated array from a colon-separated one\n///\n/// Commas are escaped in process. To each item PATHSEP \"nvim\" is appended in\n/// addition to suf1 and suf2.\n///\n/// @param[in,out]  dest  Destination comma-separated array.\n/// @param[in]  val  Source colon-separated array.\n/// @param[in]  suf1  If not NULL, suffix appended to destination. Prior to it\n///                   directory separator is appended. Suffix must not contain\n///                   commas.\n/// @param[in]  len1  Length of the suf1.\n/// @param[in]  suf2  If not NULL, another suffix appended to destination. Again\n///                   with directory separator behind. Suffix must not contain\n///                   commas.\n/// @param[in]  len2  Length of the suf2.\n/// @param[in]  forward  If true, iterate over val in forward direction.\n///                      Otherwise in reverse.\n///\n/// @return (dest + appended_characters_length)\nstatic inline char *add_colon_dirs(char *dest, const char *const val,\n                                   const char *const suf1, const size_t len1,\n                                   const char *const suf2, const size_t len2,\n                                   const bool forward)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (val == NULL || *val == NUL) {\n    return dest;\n  }\n  const void *iter = NULL;\n  do {\n    size_t dir_len;\n    const char *dir;\n    iter = (forward ? vim_colon_env_iter : vim_colon_env_iter_rev)(\n        val, iter, &dir, &dir_len);\n    if (dir != NULL && dir_len > 0) {\n      dest = strcpy_comma_escaped(dest, dir, dir_len);\n      if (!after_pathsep(dest - 1, dest)) {\n        *dest++ = PATHSEP;\n      }\n      memmove(dest, \"nvim\", NVIM_SIZE);\n      dest += NVIM_SIZE;\n      if (suf1 != NULL) {\n        *dest++ = PATHSEP;\n        memmove(dest, suf1, len1);\n        dest += len1;\n        if (suf2 != NULL) {\n          *dest++ = PATHSEP;\n          memmove(dest, suf2, len2);\n          dest += len2;\n        }\n      }\n      *dest++ = ',';\n    }\n  } while (iter != NULL);\n  return dest;\n}\n\n/// Add directory to a comma-separated list of directories\n///\n/// In the added directory comma is escaped.\n///\n/// @param[in,out]  dest  Destination comma-separated array.\n/// @param[in]  dir  Directory to append.\n/// @param[in]  append_nvim  If true, append \"nvim\" as the very first suffix.\n/// @param[in]  suf1  If not NULL, suffix appended to destination. Prior to it\n///                   directory separator is appended. Suffix must not contain\n///                   commas.\n/// @param[in]  len1  Length of the suf1.\n/// @param[in]  suf2  If not NULL, another suffix appended to destination. Again\n///                   with directory separator behind. Suffix must not contain\n///                   commas.\n/// @param[in]  len2  Length of the suf2.\n/// @param[in]  forward  If true, iterate over val in forward direction.\n///                      Otherwise in reverse.\n///\n/// @return (dest + appended_characters_length)\nstatic inline char *add_dir(char *dest, const char *const dir,\n                            const size_t dir_len, const bool append_nvim,\n                            const char *const suf1, const size_t len1,\n                            const char *const suf2, const size_t len2)\n  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (dir == NULL || dir_len == 0) {\n    return dest;\n  }\n  dest = strcpy_comma_escaped(dest, dir, dir_len);\n  if (append_nvim) {\n    if (!after_pathsep(dest - 1, dest)) {\n      *dest++ = PATHSEP;\n    }\n    memmove(dest, \"nvim\", NVIM_SIZE);\n    dest += NVIM_SIZE;\n    if (suf1 != NULL) {\n      *dest++ = PATHSEP;\n      memmove(dest, suf1, len1);\n      dest += len1;\n      if (suf2 != NULL) {\n        *dest++ = PATHSEP;\n        memmove(dest, suf2, len2);\n        dest += len2;\n      }\n    }\n  }\n  *dest++ = ',';\n  return dest;\n}\n\n/// Set &runtimepath to default value\nstatic void set_runtimepath_default(void)\n{\n  size_t rtp_size = 0;\n  char *const data_home = stdpaths_get_xdg_var(kXDGDataHome);\n  char *const config_home = stdpaths_get_xdg_var(kXDGConfigHome);\n  char *const vimruntime = vim_getenv(\"VIMRUNTIME\");\n  char *const data_dirs = stdpaths_get_xdg_var(kXDGDataDirs);\n  char *const config_dirs = stdpaths_get_xdg_var(kXDGConfigDirs);\n#define SITE_SIZE (sizeof(\"site\") - 1)\n#define AFTER_SIZE (sizeof(\"after\") - 1)\n  size_t data_len = 0;\n  size_t config_len = 0;\n  size_t vimruntime_len = 0;\n  if (data_home != NULL) {\n    data_len = strlen(data_home);\n    if (data_len != 0) {\n      rtp_size += ((data_len + memcnt(data_home, ',', data_len)\n                    + NVIM_SIZE + 1 + SITE_SIZE + 1\n                    + !after_pathsep(data_home, data_home + data_len)) * 2\n                   + AFTER_SIZE + 1);\n    }\n  }\n  if (config_home != NULL) {\n    config_len = strlen(config_home);\n    if (config_len != 0) {\n      rtp_size += ((config_len + memcnt(config_home, ',', config_len)\n                    + NVIM_SIZE + 1\n                    + !after_pathsep(config_home, config_home + config_len)) * 2\n                   + AFTER_SIZE + 1);\n    }\n  }\n  if (vimruntime != NULL) {\n    vimruntime_len = strlen(vimruntime);\n    if (vimruntime_len != 0) {\n      rtp_size += vimruntime_len + memcnt(vimruntime, ',', vimruntime_len) + 1;\n    }\n  }\n  rtp_size += compute_double_colon_len(data_dirs, NVIM_SIZE + 1 + SITE_SIZE + 1,\n                                       AFTER_SIZE + 1);\n  rtp_size += compute_double_colon_len(config_dirs, NVIM_SIZE + 1,\n                                       AFTER_SIZE + 1);\n  if (rtp_size == 0) {\n    return;\n  }\n  char *const rtp = xmalloc(rtp_size);\n  char *rtp_cur = rtp;\n  rtp_cur = add_dir(rtp_cur, config_home, config_len, true, NULL, 0, NULL, 0);\n  rtp_cur = add_colon_dirs(rtp_cur, config_dirs, NULL, 0, NULL, 0, true);\n  rtp_cur = add_dir(rtp_cur, data_home, data_len, true, \"site\", SITE_SIZE,\n                    NULL, 0);\n  rtp_cur = add_colon_dirs(rtp_cur, data_dirs, \"site\", SITE_SIZE, NULL, 0,\n                           true);\n  rtp_cur = add_dir(rtp_cur, vimruntime, vimruntime_len, false, NULL, 0,\n                    NULL, 0);\n  rtp_cur = add_colon_dirs(rtp_cur, data_dirs, \"site\", SITE_SIZE,\n                           \"after\", AFTER_SIZE, false);\n  rtp_cur = add_dir(rtp_cur, data_home, data_len, true, \"site\", SITE_SIZE,\n                    \"after\", AFTER_SIZE);\n  rtp_cur = add_colon_dirs(rtp_cur, config_dirs, \"after\", AFTER_SIZE, NULL, 0,\n                           false);\n  rtp_cur = add_dir(rtp_cur, config_home, config_len, true,\n                    \"after\", AFTER_SIZE, NULL, 0);\n  // Strip trailing comma.\n  rtp_cur[-1] = NUL;\n  assert((size_t) (rtp_cur - rtp) == rtp_size);\n#undef SITE_SIZE\n#undef AFTER_SIZE\n  set_string_default(\"runtimepath\", rtp, true);\n  // Make a copy of 'rtp' for 'packpath'\n  set_string_default(\"packpath\", rtp, false);\n  xfree(data_dirs);\n  xfree(config_dirs);\n  xfree(data_home);\n  xfree(config_home);\n  xfree(vimruntime);\n}\n\n#undef NVIM_SIZE\n\n/*\n * Initialize the options, first part.\n *\n * Called only once from main(), just after creating the first buffer.\n */\nvoid set_init_1(void)\n{\n  int opt_idx;\n\n  langmap_init();\n\n  /* Be nocompatible */\n  p_cp = FALSE;\n\n  /*\n   * Find default value for 'shell' option.\n   * Don't use it if it is empty.\n   */\n  {\n    const char *shell = os_getenv(\"SHELL\");\n    if (shell != NULL) {\n      set_string_default(\"sh\", (char *) shell, false);\n    }\n  }\n\n  /*\n   * Set the default for 'backupskip' to include environment variables for\n   * temp files.\n   */\n  {\n# ifdef UNIX\n    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n    int len;\n    garray_T ga;\n\n    ga_init(&ga, 1, 100);\n    for (size_t n = 0; n < ARRAY_SIZE(names); ++n) {\n      bool mustfree = true;\n      char *p;\n# ifdef UNIX\n      if (*names[n] == NUL) {\n        p = \"/tmp\";\n        mustfree = false;\n      }\n      else\n# endif\n      p = vim_getenv(names[n]);\n      if (p != NULL && *p != NUL) {\n        // First time count the NUL, otherwise count the ','.\n        len = (int)strlen(p) + 3;\n        ga_grow(&ga, len);\n        if (!GA_EMPTY(&ga))\n          STRCAT(ga.ga_data, \",\");\n        STRCAT(ga.ga_data, p);\n        add_pathsep(ga.ga_data);\n        STRCAT(ga.ga_data, \"*\");\n        ga.ga_len += len;\n      }\n      if(mustfree) {\n        xfree(p);\n      }\n    }\n    if (ga.ga_data != NULL) {\n      set_string_default(\"bsk\", ga.ga_data, true);\n    }\n  }\n\n  /*\n   * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory\n   */\n  opt_idx = findoption((char_u *)\"maxmemtot\");\n  if (opt_idx >= 0) {\n    {\n      /* Use half of amount of memory available to Vim. */\n      /* If too much to fit in uintptr_t, get uintptr_t max */\n      uint64_t available_kib = os_get_total_mem_kib();\n      uintptr_t n = available_kib / 2 > UINTPTR_MAX\n                    ? UINTPTR_MAX\n                    : (uintptr_t)(available_kib /2);\n      options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n      opt_idx = findoption((char_u *)\"maxmem\");\n      if (opt_idx >= 0) {\n        options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n      }\n    }\n  }\n\n\n  {\n    char_u  *cdpath;\n    char_u  *buf;\n    int i;\n    int j;\n\n    /* Initialize the 'cdpath' option's default value. */\n    cdpath = (char_u *)vim_getenv(\"CDPATH\");\n    if (cdpath != NULL) {\n      buf = xmalloc(2 * STRLEN(cdpath) + 2);\n      {\n        buf[0] = ',';               /* start with \",\", current dir first */\n        j = 1;\n        for (i = 0; cdpath[i] != NUL; ++i) {\n          if (vim_ispathlistsep(cdpath[i]))\n            buf[j++] = ',';\n          else {\n            if (cdpath[i] == ' ' || cdpath[i] == ',')\n              buf[j++] = '\\\\';\n            buf[j++] = cdpath[i];\n          }\n        }\n        buf[j] = NUL;\n        opt_idx = findoption((char_u *)\"cdpath\");\n        if (opt_idx >= 0) {\n          options[opt_idx].def_val[VI_DEFAULT] = buf;\n          options[opt_idx].flags |= P_DEF_ALLOCED;\n        } else\n          xfree(buf);           /* cannot happen */\n      }\n      xfree(cdpath);\n    }\n  }\n\n#if defined(MSWIN) || defined(MAC)\n  /* Set print encoding on platforms that don't default to latin1 */\n  set_string_default(\"printencoding\", \"hp-roman8\", false);\n#endif\n\n  // 'printexpr' must be allocated to be able to evaluate it.\n  set_string_default(\"printexpr\",\n#ifdef UNIX\n                     \"system(['lpr'] \"\n                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"\n                            \"+ [v:fname_in])\"\n                     \". delete(v:fname_in)\"\n                     \"+ v:shell_error\",\n#elif defined(MSWIN)\n                     \"system(['copy', v:fname_in, \"\n                             \"empty(&printdevice)?'LPT1':&printdevice])\"\n                     \". delete(v:fname_in)\",\n#else\n                     \"\",\n#endif\n                     false);\n\n  char *backupdir = stdpaths_user_data_subpath(\"backup\", 0, true);\n  const size_t backupdir_len = strlen(backupdir);\n  backupdir = xrealloc(backupdir, backupdir_len + 3);\n  memmove(backupdir + 2, backupdir, backupdir_len + 1);\n  memmove(backupdir, \".,\", 2);\n  set_string_default(\"viewdir\", stdpaths_user_data_subpath(\"view\", 0, true),\n                     true);\n  set_string_default(\"backupdir\", backupdir, true);\n  set_string_default(\"directory\", stdpaths_user_data_subpath(\"swap\", 2, true),\n                     true);\n  set_string_default(\"undodir\", stdpaths_user_data_subpath(\"undo\", 0, true),\n                     true);\n  // Set default for &runtimepath. All necessary expansions are performed in\n  // this function.\n  set_runtimepath_default();\n\n  /*\n   * Set all the options (except the terminal options) to their default\n   * value.  Also set the global value for local options.\n   */\n  set_options_default(0);\n\n\n  curbuf->b_p_initialized = true;\n  curbuf->b_p_ar = -1;          /* no local 'autoread' value */\n  curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n  check_buf_options(curbuf);\n  check_win_options(curwin);\n  check_options();\n\n  /* Set all options to their Vim default */\n  set_options_default(OPT_FREE);\n\n  // set 'laststatus'\n  last_status(false);\n\n  /* Must be before option_expand(), because that one needs vim_isIDc() */\n  didset_options();\n\n  // Use the current chartab for the generic chartab. This is not in\n  // didset_options() because it only depends on 'encoding'.\n  init_spell_chartab();\n\n  /*\n   * Expand environment variables and things like \"~\" for the defaults.\n   * If option_expand() returns non-NULL the variable is expanded.  This can\n   * only happen for non-indirect options.\n   * Also set the default to the expanded value, so \":set\" does not list\n   * them.\n   * Don't set the P_ALLOCED flag, because we don't want to free the\n   * default.\n   */\n  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {\n    if (options[opt_idx].flags & P_NO_DEF_EXP) {\n      continue;\n    }\n    char *p;\n    if ((options[opt_idx].flags & P_GETTEXT)\n        && options[opt_idx].var != NULL) {\n      p = _(*(char **)options[opt_idx].var);\n    } else {\n      p = (char *) option_expand(opt_idx, NULL);\n    }\n    if (p != NULL) {\n      p = xstrdup(p);\n      *(char **)options[opt_idx].var = p;\n      /* VIMEXP\n       * Defaults for all expanded options are currently the same for Vi\n       * and Vim.  When this changes, add some code here!  Also need to\n       * split P_DEF_ALLOCED in two.\n       */\n      if (options[opt_idx].flags & P_DEF_ALLOCED)\n        xfree(options[opt_idx].def_val[VI_DEFAULT]);\n      options[opt_idx].def_val[VI_DEFAULT] = (char_u *) p;\n      options[opt_idx].flags |= P_DEF_ALLOCED;\n    }\n  }\n\n  save_file_ff(curbuf);         /* Buffer is unchanged */\n\n  /* Detect use of mlterm.\n   * Mlterm is a terminal emulator akin to xterm that has some special\n   * abilities (bidi namely).\n   * NOTE: mlterm's author is being asked to 'set' a variable\n   *       instead of an environment variable due to inheritance.\n   */\n  if (os_env_exists(\"MLTERM\"))\n    set_option_value((char_u *)\"tbidi\", 1L, NULL, 0);\n\n  didset_options2();\n\n  // enc_locale() will try to find the encoding of the current locale.\n  // This will be used when 'default' is used as encoding specifier\n  // in 'fileencodings'\n  char_u *p = enc_locale();\n  if (p == NULL) {\n      // use utf-8 as 'default' if locale encoding can't be detected.\n      p = vim_strsave((char_u *)\"utf-8\");\n  }\n  fenc_default = p;\n\n#ifdef HAVE_WORKING_LIBINTL\n  // GNU gettext 0.10.37 supports this feature: set the codeset used for\n  // translated messages independently from the current locale.\n  (void)bind_textdomain_codeset(PROJECT_NAME, (char *)p_enc);\n#endif\n\n  /* Set the default for 'helplang'. */\n  set_helplang_default(get_mess_lang());\n}\n\n/*\n * Set an option to its default value.\n * This does not take care of side effects!\n */\nstatic void \nset_option_default (\n    int opt_idx,\n    int opt_flags,                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */\n    int compatible                 /* use Vi default value */\n)\n{\n  char_u      *varp;            /* pointer to variable for current option */\n  int dvi;                      /* index in def_val[] */\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n  varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n  uint32_t flags = options[opt_idx].flags;\n  if (varp != NULL) {       /* skip hidden option, nothing to do for it */\n    dvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n    if (flags & P_STRING) {\n      /* Use set_string_option_direct() for local options to handle\n       * freeing and allocating the value. */\n      if (options[opt_idx].indir != PV_NONE)\n        set_string_option_direct(NULL, opt_idx,\n            options[opt_idx].def_val[dvi], opt_flags, 0);\n      else {\n        if ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))\n          free_string_option(*(char_u **)(varp));\n        *(char_u **)varp = options[opt_idx].def_val[dvi];\n        options[opt_idx].flags &= ~P_ALLOCED;\n      }\n    } else if (flags & P_NUM)   {\n      if (options[opt_idx].indir == PV_SCROLL)\n        win_comp_scroll(curwin);\n      else {\n        *(long *)varp = (long)options[opt_idx].def_val[dvi];\n        /* May also set global value for local option. */\n        if (both)\n          *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n            *(long *)varp;\n      }\n    } else {  /* P_BOOL */\n      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val[dvi];\n#ifdef UNIX\n      /* 'modeline' defaults to off for root */\n      if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)\n        *(int *)varp = FALSE;\n#endif\n      /* May also set global value for local option. */\n      if (both)\n        *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n          *(int *)varp;\n    }\n\n    /* The default value is not insecure. */\n    uint32_t *flagsp = insecure_flag(opt_idx, opt_flags);\n    *flagsp = *flagsp & ~P_INSECURE;\n  }\n\n  set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n}\n\n/*\n * Set all options (except terminal options) to their default value.\n */\nstatic void \nset_options_default (\n    int opt_flags                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  for (int i = 0; options[i].fullname; i++) {\n    if (!(options[i].flags & P_NODEFAULT)) {\n      set_option_default(i, opt_flags, p_cp);\n    }\n  }\n\n  /* The 'scroll' option must be computed for all windows. */\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    win_comp_scroll(wp);\n  }\n\n  parse_cino(curbuf);\n}\n\n/// Set the Vi-default value of a string option.\n/// Used for 'sh', 'backupskip' and 'term'.\n///\n/// @param name The name of the option\n/// @param val The value of the option\n/// @param allocated If true, do not copy default as it was already allocated.\nstatic void set_string_default(const char *name, char *val, bool allocated)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int opt_idx = findoption((char_u *)name);\n  if (opt_idx >= 0) {\n    if (options[opt_idx].flags & P_DEF_ALLOCED) {\n      xfree(options[opt_idx].def_val[VI_DEFAULT]);\n    }\n\n    options[opt_idx].def_val[VI_DEFAULT] = (char_u *) (\n        allocated\n        ? (char_u *) val\n        : (char_u *) xstrdup(val));\n    options[opt_idx].flags |= P_DEF_ALLOCED;\n  }\n}\n\n/*\n * Set the Vi-default value of a number option.\n * Used for 'lines' and 'columns'.\n */\nvoid set_number_default(char *name, long val)\n{\n  int opt_idx;\n\n  opt_idx = findoption((char_u *)name);\n  if (opt_idx >= 0)\n    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)val;\n}\n\n#if defined(EXITFREE)\n/*\n * Free all options.\n */\nvoid free_all_options(void)\n{\n  int i;\n\n  for (i = 0; options[i].fullname; i++) {\n    if (options[i].indir == PV_NONE) {\n      /* global option: free value and default value. */\n      if (options[i].flags & P_ALLOCED && options[i].var != NULL)\n        free_string_option(*(char_u **)options[i].var);\n      if (options[i].flags & P_DEF_ALLOCED)\n        free_string_option(options[i].def_val[VI_DEFAULT]);\n    } else if (options[i].var != VAR_WIN\n               && (options[i].flags & P_STRING))\n      /* buffer-local option: free global value */\n      free_string_option(*(char_u **)options[i].var);\n  }\n}\n\n#endif\n\n\n/*\n * Initialize the options, part two: After getting Rows and Columns and\n * setting 'term'.\n */\nvoid set_init_2(void)\n{\n  int idx;\n\n  /*\n   * 'scroll' defaults to half the window height. Note that this default is\n   * wrong when the window height changes.\n   */\n  set_number_default(\"scroll\", Rows / 2);\n  idx = findoption((char_u *)\"scroll\");\n  if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n    set_option_default(idx, OPT_LOCAL, p_cp);\n  comp_col();\n\n  /*\n   * 'window' is only for backwards compatibility with Vi.\n   * Default is Rows - 1.\n   */\n  if (!option_was_set((char_u *)\"window\"))\n    p_window = Rows - 1;\n  set_number_default(\"window\", Rows - 1);\n  parse_shape_opt(SHAPE_CURSOR);   /* set cursor shapes from 'guicursor' */\n  (void)parse_printoptions();       /* parse 'printoptions' default value */\n}\n\n/*\n * Initialize the options, part three: After reading the .vimrc\n */\nvoid set_init_3(void)\n{\n  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n  // This is done after other initializations, where 'shell' might have been\n  // set, but only if they have not been set before.\n  int idx_srr;\n  int do_srr;\n  int idx_sp;\n  int do_sp;\n\n  idx_srr = findoption((char_u *)\"srr\");\n  if (idx_srr < 0)\n    do_srr = FALSE;\n  else\n    do_srr = !(options[idx_srr].flags & P_WAS_SET);\n  idx_sp = findoption((char_u *)\"sp\");\n  if (idx_sp < 0)\n    do_sp = FALSE;\n  else\n    do_sp = !(options[idx_sp].flags & P_WAS_SET);\n\n  size_t len = 0;\n  char_u *p = (char_u *)invocation_path_tail(p_sh, &len);\n  p = vim_strnsave(p, len);\n\n  {\n    /*\n     * Default for p_sp is \"| tee\", for p_srr is \">\".\n     * For known shells it is changed here to include stderr.\n     */\n    if (       fnamecmp(p, \"csh\") == 0\n               || fnamecmp(p, \"tcsh\") == 0\n               ) {\n      if (do_sp) {\n        p_sp = (char_u *)\"|& tee\";\n        options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n      }\n      if (do_srr) {\n        p_srr = (char_u *)\">&\";\n        options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n      }\n    } else if (       fnamecmp(p, \"sh\") == 0\n                      || fnamecmp(p, \"ksh\") == 0\n                      || fnamecmp(p, \"mksh\") == 0\n                      || fnamecmp(p, \"pdksh\") == 0\n                      || fnamecmp(p, \"zsh\") == 0\n                      || fnamecmp(p, \"zsh-beta\") == 0\n                      || fnamecmp(p, \"bash\") == 0\n                      || fnamecmp(p, \"fish\") == 0\n                      ) {\n      if (do_sp) {\n        p_sp = (char_u *)\"2>&1| tee\";\n        options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n      }\n      if (do_srr) {\n        p_srr = (char_u *)\">%s 2>&1\";\n        options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n      }\n    }\n    xfree(p);\n  }\n\n  if (bufempty()) {\n    int idx_ffs = findoption((char_u *)\"ffs\");\n\n    // Apply the first entry of 'fileformats' to the initial buffer.\n    if (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET)) {\n      set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n  }\n\n  set_title_defaults();\n}\n\n/*\n * When 'helplang' is still at its default value, set it to \"lang\".\n * Only the first two characters of \"lang\" are used.\n */\nvoid set_helplang_default(const char *lang)\n{\n  int idx;\n\n  if (lang == NULL || STRLEN(lang) < 2)         /* safety check */\n    return;\n  idx = findoption((char_u *)\"hlg\");\n  if (idx >= 0 && !(options[idx].flags & P_WAS_SET)) {\n    if (options[idx].flags & P_ALLOCED)\n      free_string_option(p_hlg);\n    p_hlg = (char_u *)xstrdup(lang);\n    /* zh_CN becomes \"cn\", zh_TW becomes \"tw\". */\n    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5) {\n      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);\n      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);\n    }\n    p_hlg[2] = NUL;\n    options[idx].flags |= P_ALLOCED;\n  }\n}\n\n\n/*\n * 'title' and 'icon' only default to true if they have not been set or reset\n * in .vimrc and we can read the old value.\n * When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n * they can be reset.  This reduces startup time when using X on a remote\n * machine.\n */\nvoid set_title_defaults(void)\n{\n  int idx1;\n\n  /*\n   * If GUI is (going to be) used, we can always set the window title and\n   * icon name.  Saves a bit of time, because the X11 display server does\n   * not need to be contacted.\n   */\n  idx1 = findoption((char_u *)\"title\");\n  if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET)) {\n    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;\n    p_title = 0;\n  }\n  idx1 = findoption((char_u *)\"icon\");\n  if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET)) {\n    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;\n    p_icon = 0;\n  }\n}\n\n/*\n * Parse 'arg' for option settings.\n *\n * 'arg' may be IObuff, but only when no errors can be present and option\n * does not need to be expanded with option_expand().\n * \"opt_flags\":\n * 0 for \":set\"\n * OPT_GLOBAL   for \":setglobal\"\n * OPT_LOCAL    for \":setlocal\" and a modeline\n * OPT_MODELINE for a modeline\n * OPT_WINONLY  to only set window-local options\n * OPT_NOWIN\tto skip setting window-local options\n *\n * returns FAIL if an error is detected, OK otherwise\n */\nint \ndo_set (\n    char_u *arg,               /* option string (may be written to!) */\n    int opt_flags\n)\n{\n  int opt_idx;\n  char_u      *errmsg;\n  char_u errbuf[80];\n  char_u      *startarg;\n  int prefix;           /* 1: nothing, 0: \"no\", 2: \"inv\" in front of name */\n  char_u nextchar;                  /* next non-white char after option name */\n  int afterchar;                    /* character just after option name */\n  int len;\n  int i;\n  long value;\n  int key;\n  uint32_t flags;                   /* flags for current option */\n  char_u      *varp = NULL;         /* pointer to variable for current option */\n  int did_show = FALSE;             /* already showed one value */\n  int adding;                       /* \"opt+=arg\" */\n  int prepending;                   /* \"opt^=arg\" */\n  int removing;                     /* \"opt-=arg\" */\n  int cp_val = 0;\n\n  if (*arg == NUL) {\n    showoptions(0, opt_flags);\n    did_show = TRUE;\n    goto theend;\n  }\n\n  while (*arg != NUL) {         /* loop to process all options */\n    errmsg = NULL;\n    startarg = arg;             /* remember for error message */\n\n    if (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n        && !(opt_flags & OPT_MODELINE)) {\n      /*\n       * \":set all\"  show all options.\n       * \":set all&\" set all options to their default value.\n       */\n      arg += 3;\n      if (*arg == '&') {\n        arg++;\n        // Only for :set command set global value of local options.\n        set_options_default(OPT_FREE | opt_flags);\n        didset_options();\n        didset_options2();\n        redraw_all_later(CLEAR);\n      } else {\n        showoptions(1, opt_flags);\n        did_show = TRUE;\n      }\n    } else if (STRNCMP(arg, \"termcap\",\n                   7) == 0 && !(opt_flags & OPT_MODELINE)) {\n      did_show = TRUE;\n      arg += 7;\n    } else {\n      prefix = 1;\n      if (STRNCMP(arg, \"no\", 2) == 0) {\n        prefix = 0;\n        arg += 2;\n      } else if (STRNCMP(arg, \"inv\", 3) == 0) {\n        prefix = 2;\n        arg += 3;\n      }\n\n      /* find end of name */\n      key = 0;\n      if (*arg == '<') {\n        opt_idx = -1;\n        /* look out for <t_>;> */\n        if (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])\n          len = 5;\n        else {\n          len = 1;\n          while (arg[len] != NUL && arg[len] != '>')\n            ++len;\n        }\n        if (arg[len] != '>') {\n          errmsg = e_invarg;\n          goto skip;\n        }\n        if (arg[1] == 't' && arg[2] == '_') {  // could be term code\n          opt_idx = findoption_len(arg + 1, (size_t) (len - 1));\n        }\n        len++;\n        if (opt_idx == -1) {\n          key = find_key_option(arg + 1);\n        }\n      } else {\n        len = 0;\n        // The two characters after \"t_\" may not be alphanumeric.\n        if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3]) {\n          len = 4;\n        } else {\n          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {\n            len++;\n          }\n        }\n        opt_idx = findoption_len(arg, (size_t) len);\n        if (opt_idx == -1) {\n          key = find_key_option(arg);\n        }\n      }\n\n      /* remember character after option name */\n      afterchar = arg[len];\n\n      /* skip white space, allow \":set ai  ?\" */\n      while (ascii_iswhite(arg[len]))\n        ++len;\n\n      adding = FALSE;\n      prepending = FALSE;\n      removing = FALSE;\n      if (arg[len] != NUL && arg[len + 1] == '=') {\n        if (arg[len] == '+') {\n          adding = TRUE;                        /* \"+=\" */\n          ++len;\n        } else if (arg[len] == '^') {\n          prepending = TRUE;                    /* \"^=\" */\n          ++len;\n        } else if (arg[len] == '-') {\n          removing = TRUE;                      /* \"-=\" */\n          ++len;\n        }\n      }\n      nextchar = arg[len];\n\n      if (opt_idx == -1 && key == 0) {          /* found a mismatch: skip */\n        errmsg = (char_u *)N_(\"E518: Unknown option\");\n        goto skip;\n      }\n\n      if (opt_idx >= 0) {\n        if (options[opt_idx].var == NULL) {         /* hidden option: skip */\n          /* Only give an error message when requesting the value of\n           * a hidden option, ignore setting it. */\n          if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n              && (!(options[opt_idx].flags & P_BOOL)\n                  || nextchar == '?'))\n            errmsg = (char_u *)_(e_unsupportedoption);\n          goto skip;\n        }\n\n        flags = options[opt_idx].flags;\n        varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n      } else {\n        flags = P_STRING;\n      }\n\n      /* Skip all options that are not window-local (used when showing\n       * an already loaded buffer in a window). */\n      if ((opt_flags & OPT_WINONLY)\n          && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n        goto skip;\n\n      /* Skip all options that are window-local (used for :vimgrep). */\n      if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n          && options[opt_idx].var == VAR_WIN)\n        goto skip;\n\n      /* Disallow changing some options from modelines. */\n      if (opt_flags & OPT_MODELINE) {\n        if (flags & (P_SECURE | P_NO_ML)) {\n          errmsg = (char_u *)_(\"E520: Not allowed in a modeline\");\n          goto skip;\n        }\n        /* In diff mode some options are overruled.  This avoids that\n         * 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n         * \"wrap\" gets set. */\n        if (curwin->w_p_diff\n            && opt_idx >= 0              /* shut up coverity warning */\n            && (options[opt_idx].indir == PV_FDM\n                || options[opt_idx].indir == PV_WRAP))\n          goto skip;\n      }\n\n      /* Disallow changing some options in the sandbox */\n      if (sandbox != 0 && (flags & P_SECURE)) {\n        errmsg = (char_u *)_(e_sandbox);\n        goto skip;\n      }\n\n      if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL) {\n        arg += len;\n        cp_val = p_cp;\n        if (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i') {\n          if (arg[3] == 'm') {          /* \"opt&vim\": set to Vim default */\n            cp_val = FALSE;\n            arg += 3;\n          } else {                    /* \"opt&vi\": set to Vi default */\n            cp_val = TRUE;\n            arg += 2;\n          }\n        }\n        if (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n            && arg[1] != NUL && !ascii_iswhite(arg[1])) {\n          errmsg = e_trailing;\n          goto skip;\n        }\n      }\n\n      /*\n       * allow '=' and ':' as MSDOS command.com allows only one\n       * '=' character per \"set\" command line. grrr. (jw)\n       */\n      if (nextchar == '?'\n          || (prefix == 1\n              && vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n              && !(flags & P_BOOL))) {\n        /*\n         * print value\n         */\n        if (did_show)\n          msg_putchar('\\n');                /* cursor below last one */\n        else {\n          gotocmdline(TRUE);                /* cursor at status line */\n          did_show = TRUE;                  /* remember that we did a line */\n        }\n        if (opt_idx >= 0) {\n          showoneopt(&options[opt_idx], opt_flags);\n          if (p_verbose > 0) {\n            /* Mention where the option was last set. */\n            if (varp == options[opt_idx].var)\n              last_set_msg(options[opt_idx].scriptID);\n            else if ((int)options[opt_idx].indir & PV_WIN)\n              last_set_msg(curwin->w_p_scriptID[\n                    (int)options[opt_idx].indir & PV_MASK]);\n            else if ((int)options[opt_idx].indir & PV_BUF)\n              last_set_msg(curbuf->b_p_scriptID[\n                    (int)options[opt_idx].indir & PV_MASK]);\n          }\n        } else {\n          errmsg = (char_u *)N_(\"E846: Key code not set\");\n          goto skip;\n        }\n        if (nextchar != '?'\n            && nextchar != NUL && !ascii_iswhite(afterchar))\n          errmsg = e_trailing;\n      } else {\n        if (flags & P_BOOL) {                       /* boolean */\n          if (nextchar == '=' || nextchar == ':') {\n            errmsg = e_invarg;\n            goto skip;\n          }\n\n          /*\n           * \":set opt!\": invert\n           * \":set opt&\": reset to default value\n           * \":set opt<\": reset to global value\n           */\n          if (nextchar == '!')\n            value = *(int *)(varp) ^ 1;\n          else if (nextchar == '&')\n            value = (int)(intptr_t)options[opt_idx].def_val[\n              ((flags & P_VI_DEF) || cp_val)\n              ?  VI_DEFAULT : VIM_DEFAULT];\n          else if (nextchar == '<') {\n            /* For 'autoread' -1 means to use global value. */\n            if ((int *)varp == &curbuf->b_p_ar\n                && opt_flags == OPT_LOCAL)\n              value = -1;\n            else\n              value = *(int *)get_varp_scope(&(options[opt_idx]),\n                  OPT_GLOBAL);\n          } else {\n            /*\n             * \":set invopt\": invert\n             * \":set opt\" or \":set noopt\": set or reset\n             */\n            if (nextchar != NUL && !ascii_iswhite(afterchar)) {\n              errmsg = e_trailing;\n              goto skip;\n            }\n            if (prefix == 2)                    /* inv */\n              value = *(int *)(varp) ^ 1;\n            else\n              value = prefix;\n          }\n\n          errmsg = set_bool_option(opt_idx, varp, (int)value,\n              opt_flags);\n        } else {                                  /* numeric or string */\n          if (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n              || prefix != 1) {\n            errmsg = e_invarg;\n            goto skip;\n          }\n\n          if (flags & P_NUM) {                      /* numeric */\n            /*\n             * Different ways to set a number option:\n             * &\t    set to default value\n             * <\t    set to global value\n             * <xx>\t    accept special key codes for 'wildchar'\n             * c\t    accept any non-digit for 'wildchar'\n             * [-]0-9   set number\n             * other    error\n             */\n            ++arg;\n            if (nextchar == '&')\n              value = (long)options[opt_idx].def_val[\n                ((flags & P_VI_DEF) || cp_val)\n                ?  VI_DEFAULT : VIM_DEFAULT];\n            else if (nextchar == '<') {\n              /* For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n               * use the global value. */\n              if ((long *)varp == &curbuf->b_p_ul\n                  && opt_flags == OPT_LOCAL)\n                value = NO_LOCAL_UNDOLEVEL;\n              else\n                value = *(long *)get_varp_scope(\n                    &(options[opt_idx]), OPT_GLOBAL);\n            } else if (((long *)varp == &p_wc\n                        || (long *)varp == &p_wcm)\n                       && (*arg == '<'\n                           || *arg == '^'\n                           || ((!arg[1] || ascii_iswhite(arg[1]))\n                               && !ascii_isdigit(*arg)))) {\n              value = string_to_key(arg);\n              if (value == 0 && (long *)varp != &p_wcm) {\n                errmsg = e_invarg;\n                goto skip;\n              }\n            } else if (*arg == '-' || ascii_isdigit(*arg)) {\n              // Allow negative (for 'undolevels'), octal and\n              // hex numbers.\n              vim_str2nr(arg, NULL, &i, STR2NR_ALL, &value, NULL, 0);\n              if (arg[i] != NUL && !ascii_iswhite(arg[i])) {\n                errmsg = e_invarg;\n                goto skip;\n              }\n            } else {\n              errmsg = (char_u *)N_(\"E521: Number required after =\");\n              goto skip;\n            }\n\n            if (adding)\n              value = *(long *)varp + value;\n            if (prepending)\n              value = *(long *)varp * value;\n            if (removing)\n              value = *(long *)varp - value;\n            errmsg = set_num_option(opt_idx, varp, value,\n                errbuf, sizeof(errbuf), opt_flags);\n          } else if (opt_idx >= 0) {                      /* string */\n            char_u      *save_arg = NULL;\n            char_u      *s = NULL;\n            char_u      *oldval = NULL;         // previous value if *varp\n            char_u      *newval;\n            char_u      *origval = NULL;\n            char *saved_origval = NULL;\n            unsigned newlen;\n            int comma;\n            int bs;\n            int new_value_alloced;                      /* new string option\n                                                           was allocated */\n\n            /* When using \":set opt=val\" for a global option\n             * with a local value the local value will be\n             * reset, use the global value here. */\n            if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n                && ((int)options[opt_idx].indir & PV_BOTH))\n              varp = options[opt_idx].var;\n\n            /* The old value is kept until we are sure that the\n             * new value is valid. */\n            oldval = *(char_u **)varp;\n            if (nextchar == '&') {              /* set to default val */\n              newval = options[opt_idx].def_val[\n                ((flags & P_VI_DEF) || cp_val)\n                ?  VI_DEFAULT : VIM_DEFAULT];\n              /* expand environment variables and ~ (since the\n               * default value was already expanded, only\n               * required when an environment variable was set\n               * later */\n              new_value_alloced = true;\n              if (newval == NULL) {\n                newval = empty_option;\n              } else if (!(options[opt_idx].flags | P_NO_DEF_EXP)) {\n                s = option_expand(opt_idx, newval);\n                if (s == NULL) {\n                  s = newval;\n                }\n                newval = vim_strsave(s);\n              } else {\n                newval = (char_u *)xstrdup((char *)newval);\n              }\n            } else if (nextchar == '<') {  // set to global val\n              newval = vim_strsave(*(char_u **)get_varp_scope(\n                      &(options[opt_idx]), OPT_GLOBAL));\n              new_value_alloced = TRUE;\n            } else {\n              ++arg;                    /* jump to after the '=' or ':' */\n\n              /*\n               * Set 'keywordprg' to \":help\" if an empty\n               * value was passed to :set by the user.\n               * Misuse errbuf[] for the resulting string.\n               */\n              if (varp == (char_u *)&p_kp\n                  && (*arg == NUL || *arg == ' ')) {\n                STRCPY(errbuf, \":help\");\n                save_arg = arg;\n                arg = errbuf;\n              }\n              /*\n               * Convert 'backspace' number to string, for\n               * adding, prepending and removing string.\n               */\n              else if (varp == (char_u *)&p_bs\n                       && ascii_isdigit(**(char_u **)varp)) {\n                i = getdigits_int((char_u **)varp);\n                switch (i) {\n                case 0:\n                  *(char_u **)varp = empty_option;\n                  break;\n                case 1:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol\");\n                  break;\n                case 2:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol,start\");\n                  break;\n                }\n                xfree(oldval);\n                oldval = *(char_u **)varp;\n              }\n              /*\n               * Convert 'whichwrap' number to string, for\n               * backwards compatibility with Vim 3.0.\n               * Misuse errbuf[] for the resulting string.\n               */\n              else if (varp == (char_u *)&p_ww\n                       && ascii_isdigit(*arg)) {\n                *errbuf = NUL;\n                i = getdigits_int(&arg);\n                if (i & 1)\n                  STRCAT(errbuf, \"b,\");\n                if (i & 2)\n                  STRCAT(errbuf, \"s,\");\n                if (i & 4)\n                  STRCAT(errbuf, \"h,l,\");\n                if (i & 8)\n                  STRCAT(errbuf, \"<,>,\");\n                if (i & 16)\n                  STRCAT(errbuf, \"[,],\");\n                if (*errbuf != NUL)                     /* remove trailing , */\n                  errbuf[STRLEN(errbuf) - 1] = NUL;\n                save_arg = arg;\n                arg = errbuf;\n              }\n              /*\n               * Remove '>' before 'dir' and 'bdir', for\n               * backwards compatibility with version 3.0\n               */\n              else if (  *arg == '>'\n                         && (varp == (char_u *)&p_dir\n                             || varp == (char_u *)&p_bdir)) {\n                ++arg;\n              }\n\n              /* When setting the local value of a global\n               * option, the old value may be the global value. */\n              if (((int)options[opt_idx].indir & PV_BOTH)\n                  && (opt_flags & OPT_LOCAL))\n                origval = *(char_u **)get_varp(\n                    &options[opt_idx]);\n              else\n                origval = oldval;\n\n              /*\n               * Copy the new string into allocated memory.\n               * Can't use set_string_option_direct(), because\n               * we need to remove the backslashes.\n               */\n              /* get a bit too much */\n              newlen = (unsigned)STRLEN(arg) + 1;\n              if (adding || prepending || removing)\n                newlen += (unsigned)STRLEN(origval) + 1;\n              newval = xmalloc(newlen);\n              s = newval;\n\n              /*\n               * Copy the string, skip over escaped chars.\n               * For WIN32 backslashes before normal\n               * file name characters are not removed, and keep\n               * backslash at start, for \"\\\\machine\\path\", but\n               * do remove it for \"\\\\\\\\machine\\\\path\".\n               * The reverse is found in ExpandOldSetting().\n               */\n              while (*arg && !ascii_iswhite(*arg)) {\n                if (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n                    && !((flags & P_EXPAND)\n                         && vim_isfilec(arg[1])\n                         && (arg[1] != '\\\\'\n                             || (s == newval\n                                 && arg[2] != '\\\\')))\n#endif\n                    )\n                  ++arg;                        /* remove backslash */\n                if (has_mbyte\n                    && (i = (*mb_ptr2len)(arg)) > 1) {\n                  /* copy multibyte char */\n                  memmove(s, arg, (size_t)i);\n                  arg += i;\n                  s += i;\n                } else\n                  *s++ = *arg++;\n              }\n              *s = NUL;\n\n              /*\n               * Expand environment variables and ~.\n               * Don't do it when adding without inserting a\n               * comma.\n               */\n              if (!(adding || prepending || removing)\n                  || (flags & P_COMMA)) {\n                s = option_expand(opt_idx, newval);\n                if (s != NULL) {\n                  xfree(newval);\n                  newlen = (unsigned)STRLEN(s) + 1;\n                  if (adding || prepending || removing)\n                    newlen += (unsigned)STRLEN(origval) + 1;\n                  newval = xmalloc(newlen);\n                  STRCPY(newval, s);\n                }\n              }\n\n              /* locate newval[] in origval[] when removing it\n               * and when adding to avoid duplicates */\n              i = 0;                    /* init for GCC */\n              if (removing || (flags & P_NODUP)) {\n                i = (int)STRLEN(newval);\n                bs = 0;\n                for (s = origval; *s; ++s) {\n                  if ((!(flags & P_COMMA)\n                       || s == origval\n                       || (s[-1] == ',' && !(bs & 1)))\n                      && STRNCMP(s, newval, i) == 0\n                      && (!(flags & P_COMMA)\n                          || s[i] == ','\n                          || s[i] == NUL)) {\n                    break;\n                  }\n                  // Count backslashes.  Only a comma with an even number of\n                  // backslashes or a single backslash preceded by a comma\n                  // before it is recognized as a separator\n                  if ((s > origval + 1 && s[-1] == '\\\\' && s[-2] != ',')\n                      || (s == origval + 1 && s[-1] == '\\\\')) {\n                    bs++;\n                  } else {\n                    bs = 0;\n                  }\n                }\n\n                // do not add if already there\n                if ((adding || prepending) && *s) {\n                  prepending = FALSE;\n                  adding = FALSE;\n                  STRCPY(newval, origval);\n                }\n              }\n\n              /* concatenate the two strings; add a ',' if\n               * needed */\n              if (adding || prepending) {\n                comma = ((flags & P_COMMA) && *origval != NUL\n                         && *newval != NUL);\n                if (adding) {\n                  i = (int)STRLEN(origval);\n                  // Strip a trailing comma, would get 2.\n                  if (comma && i > 1\n                      && (flags & P_ONECOMMA) == P_ONECOMMA\n                      && origval[i - 1] == ','\n                      && origval[i - 2] != '\\\\') {\n                    i--;\n                  }\n                  memmove(newval + i + comma, newval,\n                      STRLEN(newval) + 1);\n                  memmove(newval, origval, (size_t)i);\n                } else {\n                  i = (int)STRLEN(newval);\n                  STRMOVE(newval + i + comma, origval);\n                }\n                if (comma)\n                  newval[i] = ',';\n              }\n\n              /* Remove newval[] from origval[]. (Note: \"i\" has\n               * been set above and is used here). */\n              if (removing) {\n                STRCPY(newval, origval);\n                if (*s) {\n                  /* may need to remove a comma */\n                  if (flags & P_COMMA) {\n                    if (s == origval) {\n                      /* include comma after string */\n                      if (s[i] == ',')\n                        ++i;\n                    } else {\n                      /* include comma before string */\n                      --s;\n                      ++i;\n                    }\n                  }\n                  STRMOVE(newval + (s - origval), s + i);\n                }\n              }\n\n              if (flags & P_FLAGLIST) {\n                // Remove flags that appear twice.\n                for (s = newval; *s; s++) {\n                  // if options have P_FLAGLIST and P_ONECOMMA such as\n                  // 'whichwrap'\n                  if (flags & P_ONECOMMA) {\n                    if (*s != ',' && *(s + 1) == ','\n                        && vim_strchr(s + 2, *s) != NULL) {\n                      // Remove the duplicated value and the next comma.\n                      STRMOVE(s, s + 2);\n                      s -= 2;\n                    }\n                  } else {\n                    if ((!(flags & P_COMMA) || *s != ',')\n                        && vim_strchr(s + 1, *s) != NULL) {\n                      STRMOVE(s, s + 1);\n                      s--;\n                    }\n                  }\n                }\n              }\n\n              if (save_arg != NULL)                 /* number for 'whichwrap' */\n                arg = save_arg;\n              new_value_alloced = TRUE;\n            }\n\n            /* Set the new value. */\n            *(char_u **)(varp) = newval;\n\n            if (!starting && origval != NULL) {\n              // origval may be freed by\n              // did_set_string_option(), make a copy.\n              saved_origval = xstrdup((char *) origval);\n            }\n\n            /* Handle side effects, and set the global value for\n             * \":set\" on local options. */\n            errmsg = did_set_string_option(opt_idx, (char_u **)varp,\n                new_value_alloced, oldval, errbuf, opt_flags);\n\n            // If error detected, print the error message.\n            if (errmsg != NULL) {\n              xfree(saved_origval);\n              goto skip;\n            }\n\n            if (saved_origval != NULL) {\n              char buf_type[7];\n              vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                           (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n              set_vim_var_string(VV_OPTION_NEW, *(char **) varp, -1);\n              set_vim_var_string(VV_OPTION_OLD, saved_origval, -1);\n              set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n              apply_autocmds(EVENT_OPTIONSET,\n                             (char_u *)options[opt_idx].fullname,\n                             NULL, false, NULL);\n              reset_v_option_vars();\n              xfree(saved_origval);\n            }\n          } else {\n            // key code option(FIXME(tarruda): Show a warning or something\n            // similar)\n          }\n        }\n\n        if (opt_idx >= 0)\n          did_set_option(opt_idx, opt_flags,\n              !prepending && !adding && !removing);\n      }\n\nskip:\n      /*\n       * Advance to next argument.\n       * - skip until a blank found, taking care of backslashes\n       * - skip blanks\n       * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n       */\n      for (i = 0; i < 2; ++i) {\n        while (*arg != NUL && !ascii_iswhite(*arg))\n          if (*arg++ == '\\\\' && *arg != NUL)\n            ++arg;\n        arg = skipwhite(arg);\n        if (*arg != '=')\n          break;\n      }\n    }\n\n    if (errmsg != NULL) {\n      STRLCPY(IObuff, _(errmsg), IOSIZE);\n      i = (int)STRLEN(IObuff) + 2;\n      if (i + (arg - startarg) < IOSIZE) {\n        /* append the argument with the error */\n        STRCAT(IObuff, \": \");\n        assert(arg >= startarg);\n        memmove(IObuff + i, startarg, (size_t)(arg - startarg));\n        IObuff[i + (arg - startarg)] = NUL;\n      }\n      /* make sure all characters are printable */\n      trans_characters(IObuff, IOSIZE);\n\n      ++no_wait_return;         /* wait_return done later */\n      emsg(IObuff);             /* show error highlighted */\n      --no_wait_return;\n\n      return FAIL;\n    }\n\n    arg = skipwhite(arg);\n  }\n\ntheend:\n  if (silent_mode && did_show) {\n    /* After displaying option values in silent mode. */\n    silent_mode = FALSE;\n    info_message = TRUE;        /* use mch_msg(), not mch_errmsg() */\n    msg_putchar('\\n');\n    ui_flush();\n    silent_mode = TRUE;\n    info_message = FALSE;       /* use mch_msg(), not mch_errmsg() */\n  }\n\n  return OK;\n}\n\n/*\n * Call this when an option has been given a new value through a user command.\n * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\n */\nstatic void \ndid_set_option (\n    int opt_idx,\n    int opt_flags,              /* possibly with OPT_MODELINE */\n    int new_value              /* value was replaced completely */\n)\n{\n  options[opt_idx].flags |= P_WAS_SET;\n\n  /* When an option is set in the sandbox, from a modeline or in secure mode\n   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n   * flag. */\n  uint32_t *p = insecure_flag(opt_idx, opt_flags);\n  if (secure\n      || sandbox != 0\n      || (opt_flags & OPT_MODELINE))\n    *p = *p | P_INSECURE;\n  else if (new_value)\n    *p = *p & ~P_INSECURE;\n}\n\nstatic char_u *illegal_char(char_u *errbuf, int c)\n{\n  if (errbuf == NULL)\n    return (char_u *)\"\";\n  sprintf((char *)errbuf, _(\"E539: Illegal character <%s>\"),\n      (char *)transchar(c));\n  return errbuf;\n}\n\n/*\n * Convert a key name or string into a key value.\n * Used for 'wildchar' and 'cedit' options.\n */\nstatic int string_to_key(char_u *arg)\n{\n  if (*arg == '<')\n    return find_key_option(arg + 1);\n  if (*arg == '^')\n    return Ctrl_chr(arg[1]);\n  return *arg;\n}\n\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\nstatic char_u *check_cedit(void)\n{\n  int n;\n\n  if (*p_cedit == NUL)\n    cedit_key = -1;\n  else {\n    n = string_to_key(p_cedit);\n    if (vim_isprintc(n))\n      return e_invarg;\n    cedit_key = n;\n  }\n  return NULL;\n}\n\n/*\n * When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n * maketitle() to create and display it.\n * When switching the title or icon off, call ui_set_{icon,title}(NULL) to get\n * the old value back.\n */\nstatic void \ndid_set_title (\n    int icon                   /* Did set icon instead of title */\n)\n{\n  if (starting != NO_SCREEN) {\n    maketitle();\n    if (icon) {\n      if (!p_icon) {\n        ui_set_icon(NULL);\n      }\n    } else {\n      if (!p_title) {\n        ui_set_title(NULL);\n      }\n    }\n  }\n}\n\n/*\n * set_options_bin -  called when 'bin' changes value.\n */\nvoid \nset_options_bin (\n    int oldval,\n    int newval,\n    int opt_flags                  /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  /*\n   * The option values that are changed when 'bin' changes are\n   * copied when 'bin is set and restored when 'bin' is reset.\n   */\n  if (newval) {\n    if (!oldval) {              /* switched on */\n      if (!(opt_flags & OPT_GLOBAL)) {\n        curbuf->b_p_tw_nobin = curbuf->b_p_tw;\n        curbuf->b_p_wm_nobin = curbuf->b_p_wm;\n        curbuf->b_p_ml_nobin = curbuf->b_p_ml;\n        curbuf->b_p_et_nobin = curbuf->b_p_et;\n      }\n      if (!(opt_flags & OPT_LOCAL)) {\n        p_tw_nobin = p_tw;\n        p_wm_nobin = p_wm;\n        p_ml_nobin = p_ml;\n        p_et_nobin = p_et;\n      }\n    }\n\n    if (!(opt_flags & OPT_GLOBAL)) {\n      curbuf->b_p_tw = 0;       /* no automatic line wrap */\n      curbuf->b_p_wm = 0;       /* no automatic line wrap */\n      curbuf->b_p_ml = 0;       /* no modelines */\n      curbuf->b_p_et = 0;       /* no expandtab */\n    }\n    if (!(opt_flags & OPT_LOCAL)) {\n      p_tw = 0;\n      p_wm = 0;\n      p_ml = FALSE;\n      p_et = FALSE;\n      p_bin = TRUE;             /* needed when called for the \"-b\" argument */\n    }\n  } else if (oldval) {        /* switched off */\n    if (!(opt_flags & OPT_GLOBAL)) {\n      curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n      curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n      curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n      curbuf->b_p_et = curbuf->b_p_et_nobin;\n    }\n    if (!(opt_flags & OPT_LOCAL)) {\n      p_tw = p_tw_nobin;\n      p_wm = p_wm_nobin;\n      p_ml = p_ml_nobin;\n      p_et = p_et_nobin;\n    }\n  }\n}\n\n/*\n * Find the parameter represented by the given character (eg ', :, \", or /),\n * and return its associated value in the 'shada' string.\n * Only works for number parameters, not for 'r' or 'n'.\n * If the parameter is not specified in the string or there is no following\n * number, return -1.\n */\nint get_shada_parameter(int type)\n{\n  char_u  *p;\n\n  p = find_shada_parameter(type);\n  if (p != NULL && ascii_isdigit(*p))\n    return atoi((char *)p);\n  return -1;\n}\n\n/*\n * Find the parameter represented by the given character (eg ''', ':', '\"', or\n * '/') in the 'shada' option and return a pointer to the string after it.\n * Return NULL if the parameter is not specified in the string.\n */\nchar_u *find_shada_parameter(int type)\n{\n  char_u  *p;\n\n  for (p = p_shada; *p; ++p) {\n    if (*p == type)\n      return p + 1;\n    if (*p == 'n')                  /* 'n' is always the last one */\n      break;\n    p = vim_strchr(p, ',');         /* skip until next ',' */\n    if (p == NULL)                  /* hit the end without finding parameter */\n      break;\n  }\n  return NULL;\n}\n\n/*\n * Expand environment variables for some string options.\n * These string options cannot be indirect!\n * If \"val\" is NULL expand the current value of the option.\n * Return pointer to NameBuff, or NULL when not expanded.\n */\nstatic char_u *option_expand(int opt_idx, char_u *val)\n{\n  /* if option doesn't need expansion nothing to do */\n  if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)\n    return NULL;\n\n  if (val == NULL) {\n    val = *(char_u **)options[opt_idx].var;\n  }\n\n  // If val is longer than MAXPATHL no meaningful expansion can be done,\n  // expand_env() would truncate the string.\n  if (val == NULL || STRLEN(val) > MAXPATHL) {\n    return NULL;\n  }\n\n  /*\n   * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n   * Escape spaces when expanding 'tags', they are used to separate file\n   * names.\n   * For 'spellsuggest' expand after \"file:\".\n   */\n  expand_env_esc(val, NameBuff, MAXPATHL,\n      (char_u **)options[opt_idx].var == &p_tags, FALSE,\n      (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n      NULL);\n  if (STRCMP(NameBuff, val) == 0)     /* they are the same */\n    return NULL;\n\n  return NameBuff;\n}\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\nstatic void didset_options(void)\n{\n  /* initialize the table for 'iskeyword' et.al. */\n  (void)init_chartab();\n\n  (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true);\n  (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, true);\n  (void)opt_strings_flags(p_bo, p_bo_values, &bo_flags, true);\n  (void)opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true);\n  (void)opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true);\n  (void)opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true);\n  (void)opt_strings_flags(p_dy, p_dy_values, &dy_flags, true);\n  (void)opt_strings_flags(p_tc, p_tc_values, &tc_flags, false);\n  (void)opt_strings_flags(p_ve, p_ve_values, &ve_flags, true);\n  (void)spell_check_msm();\n  (void)spell_check_sps();\n  (void)compile_cap_prog(curwin->w_s);\n  (void)did_set_spell_option(true);\n  // set cedit_key\n  (void)check_cedit();\n  briopt_check(curwin);\n  // initialize the table for 'breakat'.\n  fill_breakat_flags();\n}\n\n// More side effects of setting options.\nstatic void didset_options2(void)\n{\n  // Initialize the highlight_attr[] table.\n  (void)highlight_changed();\n\n  // Parse default for 'clipboard'.\n  (void)opt_strings_flags(p_cb, p_cb_values, &cb_flags, true);\n\n  // Parse default for 'fillchars'.\n  (void)set_chars_option(&p_fcs);\n\n  // Parse default for 'listchars'.\n  (void)set_chars_option(&p_lcs);\n\n  // Parse default for 'wildmode'.\n  check_opt_wim();\n}\n\n/*\n * Check for string options that are NULL (normally only termcap options).\n */\nvoid check_options(void)\n{\n  int opt_idx;\n\n  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)\n    if ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)\n      check_string_option((char_u **)get_varp(&(options[opt_idx])));\n}\n\n/*\n * Check string options in a buffer for NULL value.\n */\nvoid check_buf_options(buf_T *buf)\n{\n  check_string_option(&buf->b_p_bh);\n  check_string_option(&buf->b_p_bt);\n  check_string_option(&buf->b_p_fenc);\n  check_string_option(&buf->b_p_ff);\n  check_string_option(&buf->b_p_def);\n  check_string_option(&buf->b_p_inc);\n  check_string_option(&buf->b_p_inex);\n  check_string_option(&buf->b_p_inde);\n  check_string_option(&buf->b_p_indk);\n  check_string_option(&buf->b_p_fex);\n  check_string_option(&buf->b_p_kp);\n  check_string_option(&buf->b_p_mps);\n  check_string_option(&buf->b_p_fo);\n  check_string_option(&buf->b_p_flp);\n  check_string_option(&buf->b_p_isk);\n  check_string_option(&buf->b_p_com);\n  check_string_option(&buf->b_p_cms);\n  check_string_option(&buf->b_p_nf);\n  check_string_option(&buf->b_p_qe);\n  check_string_option(&buf->b_p_syn);\n  check_string_option(&buf->b_s.b_syn_isk);\n  check_string_option(&buf->b_s.b_p_spc);\n  check_string_option(&buf->b_s.b_p_spf);\n  check_string_option(&buf->b_s.b_p_spl);\n  check_string_option(&buf->b_p_sua);\n  check_string_option(&buf->b_p_cink);\n  check_string_option(&buf->b_p_cino);\n  parse_cino(buf);\n  check_string_option(&buf->b_p_ft);\n  check_string_option(&buf->b_p_cinw);\n  check_string_option(&buf->b_p_cpt);\n  check_string_option(&buf->b_p_cfu);\n  check_string_option(&buf->b_p_ofu);\n  check_string_option(&buf->b_p_keymap);\n  check_string_option(&buf->b_p_gp);\n  check_string_option(&buf->b_p_mp);\n  check_string_option(&buf->b_p_efm);\n  check_string_option(&buf->b_p_ep);\n  check_string_option(&buf->b_p_path);\n  check_string_option(&buf->b_p_tags);\n  check_string_option(&buf->b_p_tc);\n  check_string_option(&buf->b_p_dict);\n  check_string_option(&buf->b_p_tsr);\n  check_string_option(&buf->b_p_lw);\n  check_string_option(&buf->b_p_bkc);\n}\n\n/*\n * Free the string allocated for an option.\n * Checks for the string being empty_option. This may happen if we're out of\n * memory, vim_strsave() returned NULL, which was replaced by empty_option by\n * check_options().\n * Does NOT check for P_ALLOCED flag!\n */\nvoid free_string_option(char_u *p)\n{\n  if (p != empty_option)\n    xfree(p);\n}\n\nvoid clear_string_option(char_u **pp)\n{\n  if (*pp != empty_option)\n    xfree(*pp);\n  *pp = empty_option;\n}\n\nstatic void check_string_option(char_u **pp)\n{\n  if (*pp == NULL)\n    *pp = empty_option;\n}\n\n/*\n * Return TRUE when option \"opt\" was set from a modeline or in secure mode.\n * Return FALSE when it wasn't.\n * Return -1 for an unknown option.\n */\nint was_set_insecurely(char_u *opt, int opt_flags)\n{\n  int idx = findoption(opt);\n\n  if (idx >= 0) {\n    uint32_t *flagp = insecure_flag(idx, opt_flags);\n    return (*flagp & P_INSECURE) != 0;\n  }\n  EMSG2(_(e_intern2), \"was_set_insecurely()\");\n  return -1;\n}\n\n/*\n * Get a pointer to the flags used for the P_INSECURE flag of option\n * \"opt_idx\".  For some local options a local flags field is used.\n */\nstatic uint32_t *insecure_flag(int opt_idx, int opt_flags)\n{\n  if (opt_flags & OPT_LOCAL)\n    switch ((int)options[opt_idx].indir) {\n    case PV_STL:        return &curwin->w_p_stl_flags;\n    case PV_FDE:        return &curwin->w_p_fde_flags;\n    case PV_FDT:        return &curwin->w_p_fdt_flags;\n    case PV_INDE:       return &curbuf->b_p_inde_flags;\n    case PV_FEX:        return &curbuf->b_p_fex_flags;\n    case PV_INEX:       return &curbuf->b_p_inex_flags;\n    }\n\n  /* Nothing special, return global flags field. */\n  return &options[opt_idx].flags;\n}\n\n\n/*\n * Redraw the window title and/or tab page text later.\n */\nstatic void redraw_titles(void) {\n  need_maketitle = TRUE;\n  redraw_tabline = TRUE;\n}\n\nstatic int shada_idx = -1;\n\n/*\n * Set a string option to a new value (without checking the effect).\n * The string is copied into allocated memory.\n * if (\"opt_idx\" == -1) \"name\" is used, otherwise \"opt_idx\" is used.\n * When \"set_sid\" is zero set the scriptID to current_SID.  When \"set_sid\" is\n * SID_NONE don't set the scriptID.  Otherwise set the scriptID to \"set_sid\".\n */\nvoid \nset_string_option_direct (\n    char_u *name,\n    int opt_idx,\n    char_u *val,\n    int opt_flags,                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */\n    int set_sid\n)\n{\n  char_u      *s;\n  char_u      **varp;\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n  int idx = opt_idx;\n\n  if (idx == -1) {              /* use name */\n    idx = findoption(name);\n    if (idx < 0) {      /* not found (should not happen) */\n      EMSG2(_(e_intern2), \"set_string_option_direct()\");\n      EMSG2(_(\"For option %s\"), name);\n      return;\n    }\n  }\n\n  if (options[idx].var == NULL)         /* can't set hidden option */\n    return;\n\n  assert((void *) options[idx].var != (void *) &p_shada);\n\n  s = vim_strsave(val);\n  {\n    varp = (char_u **)get_varp_scope(&(options[idx]),\n        both ? OPT_LOCAL : opt_flags);\n    if ((opt_flags & OPT_FREE) && (options[idx].flags & P_ALLOCED))\n      free_string_option(*varp);\n    *varp = s;\n\n    /* For buffer/window local option may also set the global value. */\n    if (both)\n      set_string_option_global(idx, varp);\n\n    options[idx].flags |= P_ALLOCED;\n\n    /* When setting both values of a global option with a local value,\n    * make the local value empty, so that the global value is used. */\n    if (((int)options[idx].indir & PV_BOTH) && both) {\n      free_string_option(*varp);\n      *varp = empty_option;\n    }\n    if (set_sid != SID_NONE)\n      set_option_scriptID_idx(idx, opt_flags,\n          set_sid == 0 ? current_SID : set_sid);\n  }\n}\n\n/*\n * Set global value for string option when it's a local option.\n */\nstatic void \nset_string_option_global (\n    int opt_idx,                    /* option index */\n    char_u **varp             /* pointer to option variable */\n)\n{\n  char_u      **p, *s;\n\n  /* the global value is always allocated */\n  if (options[opt_idx].var == VAR_WIN)\n    p = (char_u **)GLOBAL_WO(varp);\n  else\n    p = (char_u **)options[opt_idx].var;\n  if (options[opt_idx].indir != PV_NONE && p != varp) {\n    s = vim_strsave(*varp);\n    free_string_option(*p);\n    *p = s;\n  }\n}\n\n/// Set a string option to a new value, handling the effects\n///\n/// @param[in]  opt_idx  Option to set.\n/// @param[in]  value  New value.\n/// @param[in]  opt_flags  Option flags: expected to contain #OPT_LOCAL and/or\n///                        #OPT_GLOBAL.\n///\n/// @return NULL on success, error message on error.\nstatic char *set_string_option(const int opt_idx, const char *const value,\n                               const int opt_flags)\n  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (options[opt_idx].var == NULL) {  // don't set hidden option\n    return NULL;\n  }\n\n  char *const s = xstrdup(value);\n  char **const varp = (char **)get_varp_scope(\n      &(options[opt_idx]),\n      ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n       ? (((int)options[opt_idx].indir & PV_BOTH)\n          ? OPT_GLOBAL : OPT_LOCAL)\n       : opt_flags));\n  char *const oldval = *varp;\n  *varp = s;\n\n  char *const saved_oldval = (starting ? NULL : xstrdup(oldval));\n\n  char *const r = (char *)did_set_string_option(\n      opt_idx, (char_u **)varp, (int)true, (char_u *)oldval, NULL, opt_flags);\n  if (r == NULL) {\n    did_set_option(opt_idx, opt_flags, true);\n  }\n\n  // call autocommand after handling side effects\n  if (saved_oldval != NULL) {\n    char buf_type[7];\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, (char *)(*varp), -1);\n    set_vim_var_string(VV_OPTION_OLD, saved_oldval, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *)options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n    xfree(saved_oldval);\n  }\n\n  return r;\n}\n\n/*\n * Handle string options that need some action to perform when changed.\n * Returns NULL for success, or an error message for an error.\n */\nstatic char_u *\ndid_set_string_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u **varp,                     /* pointer to the option variable */\n    int new_value_alloced,                  /* new value was allocated */\n    char_u *oldval,                    /* previous value of the option */\n    char_u *errbuf,                    /* buffer for errors, or NULL */\n    int opt_flags                          /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  char_u      *errmsg = NULL;\n  char_u      *s, *p;\n  int did_chartab = FALSE;\n  char_u      **gvarp;\n  bool free_oldval = (options[opt_idx].flags & P_ALLOCED);\n\n  /* Get the global option to compare with, otherwise we would have to check\n   * two values for all local options. */\n  gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n  /* Disallow changing some options from secure mode */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    errmsg = e_secure;\n  }\n  /* Check for a \"normal\" file name in some options.  Disallow a path\n   * separator (slash and/or backslash), wildcards and characters that are\n   * often illegal in a file name. */\n  else if ((options[opt_idx].flags & P_NFNAME)\n           && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL) {\n    errmsg = e_invarg;\n  }\n  /* 'backupcopy' */\n  else if (gvarp == &p_bkc) {\n    char_u       *bkc   = p_bkc;\n    unsigned int *flags = &bkc_flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      bkc   = curbuf->b_p_bkc;\n      flags = &curbuf->b_bkc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *bkc == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else {\n      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {\n        errmsg = e_invarg;\n      }\n\n      if (((*flags & BKC_AUTO) != 0)\n          + ((*flags & BKC_YES) != 0)\n          + ((*flags & BKC_NO) != 0) != 1) {\n        // Must have exactly one of \"auto\", \"yes\"  and \"no\".\n        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);\n        errmsg = e_invarg;\n      }\n    }\n  }\n  /* 'backupext' and 'patchmode' */\n  else if (varp == &p_bex || varp == &p_pm) {\n    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n            *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n      errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n  }\n  /* 'breakindentopt' */\n  else if (varp == &curwin->w_p_briopt) {\n    if (briopt_check(curwin) == FAIL)\n      errmsg = e_invarg;\n  } else if (varp == &p_isi\n             || varp == &(curbuf->b_p_isk)\n             || varp == &p_isp\n             || varp == &p_isf) {\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    if (init_chartab() == FAIL) {\n      did_chartab = TRUE;           /* need to restore it below */\n      errmsg = e_invarg;            /* error in value */\n    }\n  }\n  /* 'helpfile' */\n  else if (varp == &p_hf) {\n    /* May compute new values for $VIM and $VIMRUNTIME */\n    if (didset_vim) {\n      vim_setenv(\"VIM\", \"\");\n      didset_vim = FALSE;\n    }\n    if (didset_vimruntime) {\n      vim_setenv(\"VIMRUNTIME\", \"\");\n      didset_vimruntime = FALSE;\n    }\n  }\n  /* 'colorcolumn' */\n  else if (varp == &curwin->w_p_cc)\n    errmsg = check_colorcolumn(curwin);\n\n  /* 'helplang' */\n  else if (varp == &p_hlg) {\n    /* Check for \"\", \"ab\", \"ab,cd\", etc. */\n    for (s = p_hlg; *s != NUL; s += 3) {\n      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL)) {\n        errmsg = e_invarg;\n        break;\n      }\n      if (s[2] == NUL)\n        break;\n    }\n  }\n  /* 'highlight' */\n  else if (varp == &p_hl) {\n    if (highlight_changed() == FAIL)\n      errmsg = e_invarg;        /* invalid flags */\n  }\n  /* 'nrformats' */\n  else if (gvarp == &p_nf) {\n    if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ssop) {  // 'sessionoptions'\n    if (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true) != OK)\n      errmsg = e_invarg;\n    if ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR)) {\n      /* Don't allow both \"sesdir\" and \"curdir\". */\n      (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, true);\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_vop) {  // 'viewoptions'\n    if (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'scrollopt' */\n  else if (varp == &p_sbo) {\n    if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ambw || (int *)varp == &p_emoji) {\n    // 'ambiwidth'\n    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {\n      errmsg = e_invarg;\n    } else if (set_chars_option(&p_lcs) != NULL) {\n      errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n    } else if (set_chars_option(&p_fcs) != NULL) {\n      errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n    }\n  }\n  /* 'background' */\n  else if (varp == &p_bg) {\n    if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK) {\n      int dark = (*p_bg == 'd');\n\n      init_highlight(FALSE, FALSE);\n\n      if (dark != (*p_bg == 'd')\n          && get_var_value((char_u *)\"g:colors_name\") != NULL) {\n        /* The color scheme must have set 'background' back to another\n         * value, that's not what we want here.  Disable the color\n         * scheme and set the colors again. */\n        do_unlet((char_u *)\"g:colors_name\", TRUE);\n        free_string_option(p_bg);\n        p_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n        check_string_option(&p_bg);\n        init_highlight(FALSE, FALSE);\n      }\n    } else\n      errmsg = e_invarg;\n  }\n  /* 'wildmode' */\n  else if (varp == &p_wim) {\n    if (check_opt_wim() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'wildoptions' */\n  else if (varp == &p_wop) {\n    if (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'winaltkeys' */\n  else if (varp == &p_wak) {\n    if (*p_wak == NUL\n        || check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'eventignore' */\n  else if (varp == &p_ei) {\n    if (check_ei() == FAIL)\n      errmsg = e_invarg;\n  /* 'encoding' and 'fileencoding' */\n  } else if (varp == &p_enc || gvarp == &p_fenc) {\n    if (gvarp == &p_fenc) {\n      if (!MODIFIABLE(curbuf) && opt_flags != OPT_GLOBAL) {\n        errmsg = e_modifiable;\n      } else if (vim_strchr(*varp, ',') != NULL) {\n        // No comma allowed in 'fileencoding'; catches confusing it\n        // with 'fileencodings'.\n        errmsg = e_invarg;\n      } else {\n        // May show a \"+\" in the title now.\n        redraw_titles();\n        // Add 'fileencoding' to the swap file.\n        ml_setflags(curbuf);\n      }\n    }\n\n    if (errmsg == NULL) {\n      /* canonize the value, so that STRCMP() can be used on it */\n      p = enc_canonize(*varp);\n      xfree(*varp);\n      *varp = p;\n      if (varp == &p_enc) {\n        // only encoding=utf-8 allowed\n        if (STRCMP(p_enc, \"utf-8\") != 0) {\n          errmsg = e_invarg;\n        }\n      }\n    }\n  } else if (varp == &p_penc) {\n    /* Canonize printencoding if VIM standard one */\n    p = enc_canonize(p_penc);\n    xfree(p_penc);\n    p_penc = p;\n  } else if (varp == &curbuf->b_p_keymap) {\n    /* load or unload key mapping tables */\n    errmsg = keymap_init();\n\n    if (errmsg == NULL) {\n      if (*curbuf->b_p_keymap != NUL) {\n        /* Installed a new keymap, switch on using it. */\n        curbuf->b_p_iminsert = B_IMODE_LMAP;\n        if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n          curbuf->b_p_imsearch = B_IMODE_LMAP;\n      } else {\n        /* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */\n        if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n          curbuf->b_p_iminsert = B_IMODE_NONE;\n        if (curbuf->b_p_imsearch == B_IMODE_LMAP)\n          curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n      }\n      if ((opt_flags & OPT_LOCAL) == 0) {\n        set_iminsert_global();\n        set_imsearch_global();\n      }\n      status_redraw_curbuf();\n    }\n  }\n  /* 'fileformat' */\n  else if (gvarp == &p_ff) {\n    if (!MODIFIABLE(curbuf) && !(opt_flags & OPT_GLOBAL))\n      errmsg = e_modifiable;\n    else if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n      errmsg = e_invarg;\n    else {\n      redraw_titles();\n      /* update flag in swap file */\n      ml_setflags(curbuf);\n      /* Redraw needed when switching to/from \"mac\": a CR in the text\n       * will be displayed differently. */\n      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n        redraw_curbuf_later(NOT_VALID);\n    }\n  }\n  /* 'fileformats' */\n  else if (varp == &p_ffs) {\n    if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK) {\n      errmsg = e_invarg;\n    }\n  }\n\n  /* 'matchpairs' */\n  else if (gvarp == &p_mps) {\n    if (has_mbyte) {\n      for (p = *varp; *p != NUL; ++p) {\n        int x2 = -1;\n        int x3 = -1;\n\n        if (*p != NUL)\n          p += mb_ptr2len(p);\n        if (*p != NUL)\n          x2 = *p++;\n        if (*p != NUL) {\n          x3 = mb_ptr2char(p);\n          p += mb_ptr2len(p);\n        }\n        if (x2 != ':' || x3 == -1 || (*p != NUL && *p != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (*p == NUL)\n          break;\n      }\n    } else {\n      /* Check for \"x:y,x:y\" */\n      for (p = *varp; *p != NUL; p += 4) {\n        if (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (p[3] == NUL)\n          break;\n      }\n    }\n  }\n  /* 'comments' */\n  else if (gvarp == &p_com) {\n    for (s = *varp; *s; ) {\n      while (*s && *s != ':') {\n        if (vim_strchr((char_u *)COM_ALL, *s) == NULL\n            && !ascii_isdigit(*s) && *s != '-') {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n        ++s;\n      }\n      if (*s++ == NUL)\n        errmsg = (char_u *)N_(\"E524: Missing colon\");\n      else if (*s == ',' || *s == NUL)\n        errmsg = (char_u *)N_(\"E525: Zero length string\");\n      if (errmsg != NULL)\n        break;\n      while (*s && *s != ',') {\n        if (*s == '\\\\' && s[1] != NUL)\n          ++s;\n        ++s;\n      }\n      s = skip_to_option_part(s);\n    }\n  }\n  /* 'listchars' */\n  else if (varp == &p_lcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'fillchars' */\n  else if (varp == &p_fcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'cedit' */\n  else if (varp == &p_cedit) {\n    errmsg = check_cedit();\n  }\n  /* 'verbosefile' */\n  else if (varp == &p_vfile) {\n    verbose_stop();\n    if (*p_vfile != NUL && verbose_open() == FAIL)\n      errmsg = e_invarg;\n  /* 'shada' */\n  } else if (varp == &p_shada) {\n    // TODO(ZyX-I): Remove this code in the future, alongside with &viminfo\n    //              option.\n    opt_idx = ((options[opt_idx].fullname[0] == 'v')\n               ? (shada_idx == -1\n                  ? ((shada_idx = findoption((char_u *) \"shada\")))\n                  : shada_idx)\n               : opt_idx);\n    for (s = p_shada; *s; ) {\n      /* Check it's a valid character */\n      if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*s == 'n') {          /* name is always last one */\n        break;\n      } else if (*s == 'r') { /* skip until next ',' */\n        while (*++s && *s != ',')\n          ;\n      } else if (*s == '%') {\n        /* optional number */\n        while (ascii_isdigit(*++s))\n          ;\n      } else if (*s == '!' || *s == 'h' || *s == 'c')\n        ++s;                    /* no extra chars */\n      else {                    /* must have a number */\n        while (ascii_isdigit(*++s))\n          ;\n\n        if (!ascii_isdigit(*(s - 1))) {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E526: Missing number after <%s>\"),\n                transchar_byte(*(s - 1)));\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n      if (*s == ',')\n        ++s;\n      else if (*s) {\n        if (errbuf != NULL)\n          errmsg = (char_u *)N_(\"E527: Missing comma\");\n        else\n          errmsg = (char_u *)\"\";\n        break;\n      }\n    }\n    if (*p_shada && errmsg == NULL && get_shada_parameter('\\'') < 0)\n      errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n  }\n  /* 'showbreak' */\n  else if (varp == &p_sbr) {\n    for (s = p_sbr; *s; ) {\n      if (ptr2cells(s) != 1)\n        errmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n      mb_ptr_adv(s);\n    }\n  }\n\n  /* 'guicursor' */\n  else if (varp == &p_guicursor)\n    errmsg = parse_shape_opt(SHAPE_CURSOR);\n\n  else if (varp == &p_popt)\n    errmsg = parse_printoptions();\n  else if (varp == &p_pmfn)\n    errmsg = parse_printmbfont();\n\n  /* 'langmap' */\n  else if (varp == &p_langmap)\n    langmap_set();\n\n  /* 'breakat' */\n  else if (varp == &p_breakat)\n    fill_breakat_flags();\n\n  /* 'titlestring' and 'iconstring' */\n  else if (varp == &p_titlestring || varp == &p_iconstring) {\n    int flagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n    /* NULL => statusline syntax */\n    if (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n      stl_syntax |= flagval;\n    else\n      stl_syntax &= ~flagval;\n    did_set_title(varp == &p_iconstring);\n\n  }\n\n  /* 'selection' */\n  else if (varp == &p_sel) {\n    if (*p_sel == NUL\n        || check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'selectmode' */\n  else if (varp == &p_slm) {\n    if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'keymodel' */\n  else if (varp == &p_km) {\n    if (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n      errmsg = e_invarg;\n    else {\n      km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n      km_startsel = (vim_strchr(p_km, 'a') != NULL);\n    }\n  }\n  /* 'mousemodel' */\n  else if (varp == &p_mousem) {\n    if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_swb) {  // 'switchbuf'\n    if (opt_strings_flags(p_swb, p_swb_values, &swb_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'debug' */\n  else if (varp == &p_debug) {\n    if (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_dy) {  // 'display'\n    if (opt_strings_flags(p_dy, p_dy_values, &dy_flags, true) != OK)\n      errmsg = e_invarg;\n    else\n      (void)init_chartab();\n\n  }\n  /* 'eadirection' */\n  else if (varp == &p_ead) {\n    if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_cb) {  // 'clipboard'\n    if (opt_strings_flags(p_cb, p_cb_values, &cb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &(curwin->w_s->b_p_spl)  // 'spell'\n             || varp == &(curwin->w_s->b_p_spf)) {\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    errmsg = did_set_spell_option(varp == &(curwin->w_s->b_p_spf));\n  }\n  /* When 'spellcapcheck' is set compile the regexp program. */\n  else if (varp == &(curwin->w_s->b_p_spc)) {\n    errmsg = compile_cap_prog(curwin->w_s);\n  }\n  /* 'spellsuggest' */\n  else if (varp == &p_sps) {\n    if (spell_check_sps() != OK)\n      errmsg = e_invarg;\n  }\n  /* 'mkspellmem' */\n  else if (varp == &p_msm) {\n    if (spell_check_msm() != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'bufhidden' is set, check for valid value. */\n  else if (gvarp == &p_bh) {\n    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'buftype' is set, check for valid value. */\n  else if (gvarp == &p_bt) {\n    if ((curbuf->terminal && curbuf->b_p_bt[0] != 't')\n        || (!curbuf->terminal && curbuf->b_p_bt[0] == 't')\n        || check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK) {\n      errmsg = e_invarg;\n    } else {\n      if (curwin->w_status_height) {\n        curwin->w_redr_status = TRUE;\n        redraw_later(VALID);\n      }\n      curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n      redraw_titles();\n    }\n  }\n  /* 'statusline' or 'rulerformat' */\n  else if (gvarp == &p_stl || varp == &p_ruf) {\n    int wid;\n\n    if (varp == &p_ruf)         /* reset ru_wid first */\n      ru_wid = 0;\n    s = *varp;\n    if (varp == &p_ruf && *s == '%') {\n      /* set ru_wid if 'ruf' starts with \"%99(\" */\n      if (*++s == '-')          /* ignore a '-' */\n        s++;\n      wid = getdigits_int(&s);\n      if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n        ru_wid = wid;\n      else\n        errmsg = check_stl_option(p_ruf);\n    }\n    /* check 'statusline' only if it doesn't start with \"%!\" */\n    else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n      errmsg = check_stl_option(s);\n    if (varp == &p_ruf && errmsg == NULL)\n      comp_col();\n  }\n  /* check if it is a valid value for 'complete' -- Acevedo */\n  else if (gvarp == &p_cpt) {\n    for (s = *varp; *s; ) {\n      while (*s == ',' || *s == ' ')\n        s++;\n      if (!*s)\n        break;\n      if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*++s != NUL && *s != ',' && *s != ' ') {\n        if (s[-1] == 'k' || s[-1] == 's') {\n          /* skip optional filename after 'k' and 's' */\n          while (*s && *s != ',' && *s != ' ') {\n            if (*s == '\\\\')\n              ++s;\n            ++s;\n          }\n        } else {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E535: Illegal character after <%c>\"),\n                *--s);\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n    }\n  }\n  /* 'completeopt' */\n  else if (varp == &p_cot) {\n    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      completeopt_was_set();\n    }\n  }\n  /* 'pastetoggle': translate key codes like in a mapping */\n  else if (varp == &p_pt) {\n    if (*p_pt) {\n      (void)replace_termcodes(p_pt, STRLEN(p_pt), &p, true, true, false,\n                              CPO_TO_CPO_FLAGS);\n      if (p != NULL) {\n        if (new_value_alloced)\n          free_string_option(p_pt);\n        p_pt = p;\n        new_value_alloced = TRUE;\n      }\n    }\n  }\n  /* 'backspace' */\n  else if (varp == &p_bs) {\n    if (ascii_isdigit(*p_bs)) {\n      if (*p_bs >'2' || p_bs[1] != NUL)\n        errmsg = e_invarg;\n    } else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_bo) {\n    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_tc) {  // 'tagcase'\n    unsigned int *flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      p = curbuf->b_p_tc;\n      flags = &curbuf->b_tc_flags;\n    } else {\n      p = p_tc;\n      flags = &tc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *p == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else if (*p == NUL\n               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_cmp) {  // 'casemap'\n    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'diffopt' */\n  else if (varp == &p_dip) {\n    if (diffopt_changed() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'foldmethod' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {\n    if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n        || *curwin->w_p_fdm == NUL)\n      errmsg = e_invarg;\n    else {\n      foldUpdateAll(curwin);\n      if (foldmethodIsDiff(curwin))\n        newFoldLevel();\n    }\n  }\n  /* 'foldexpr' */\n  else if (varp == &curwin->w_p_fde) {\n    if (foldmethodIsExpr(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'foldmarker' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {\n    p = vim_strchr(*varp, ',');\n    if (p == NULL)\n      errmsg = (char_u *)N_(\"E536: comma required\");\n    else if (p == *varp || p[1] == NUL)\n      errmsg = e_invarg;\n    else if (foldmethodIsMarker(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'commentstring' */\n  else if (gvarp == &p_cms) {\n    if (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n      errmsg = (char_u *)N_(\n                \"E537: 'commentstring' must be empty or contain %s\");\n  } else if (varp == &p_fdo) {  // 'foldopen'\n    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldclose' */\n  else if (varp == &p_fcl) {\n    if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldignore' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {\n    if (foldmethodIsIndent(curwin))\n      foldUpdateAll(curwin);\n  } else if (varp == &p_ve) {  // 'virtualedit'\n    if (opt_strings_flags(p_ve, p_ve_values, &ve_flags, true) != OK)\n      errmsg = e_invarg;\n    else if (STRCMP(p_ve, oldval) != 0) {\n      /* Recompute cursor position in case the new 've' setting\n       * changes something. */\n      validate_virtcol();\n      coladvance(curwin->w_virtcol);\n    }\n  } else if (varp == &p_csqf) {\n    if (p_csqf != NULL) {\n      p = p_csqf;\n      while (*p != NUL) {\n        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n            || p[1] == NUL\n            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n            || (p[2] != NUL && p[2] != ',')) {\n          errmsg = e_invarg;\n          break;\n        } else if (p[2] == NUL)\n          break;\n        else\n          p += 3;\n      }\n    }\n  }\n  /* 'cinoptions' */\n  else if (gvarp == &p_cino) {\n    /* TODO: recognize errors */\n    parse_cino(curbuf);\n  // inccommand\n  } else if (varp == &p_icm) {\n      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {\n        errmsg = e_invarg;\n      }\n  // Options that are a list of flags.\n  } else {\n    p = NULL;\n    if (varp == &p_ww)\n      p = (char_u *)WW_ALL;\n    if (varp == &p_shm)\n      p = (char_u *)SHM_ALL;\n    else if (varp == &(p_cpo))\n      p = (char_u *)CPO_VI;\n    else if (varp == &(curbuf->b_p_fo))\n      p = (char_u *)FO_ALL;\n    else if (varp == &curwin->w_p_cocu)\n      p = (char_u *)COCU_ALL;\n    else if (varp == &p_mouse) {\n      p = (char_u *)MOUSE_ALL;\n    }\n    if (p != NULL) {\n      for (s = *varp; *s; ++s)\n        if (vim_strchr(p, *s) == NULL) {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n    }\n  }\n\n  /*\n   * If error detected, restore the previous value.\n   */\n  if (errmsg != NULL) {\n    if (new_value_alloced)\n      free_string_option(*varp);\n    *varp = oldval;\n    /*\n     * When resetting some values, need to act on it.\n     */\n    if (did_chartab)\n      (void)init_chartab();\n    if (varp == &p_hl)\n      (void)highlight_changed();\n  } else {\n    /* Remember where the option was set. */\n    set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n    /*\n     * Free string options that are in allocated memory.\n     * Use \"free_oldval\", because recursiveness may change the flags under\n     * our fingers (esp. init_highlight()).\n     */\n    if (free_oldval)\n      free_string_option(oldval);\n    if (new_value_alloced)\n      options[opt_idx].flags |= P_ALLOCED;\n    else\n      options[opt_idx].flags &= ~P_ALLOCED;\n\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n        && ((int)options[opt_idx].indir & PV_BOTH)) {\n      /* global option with local value set to use global value; free\n       * the local value and make it empty */\n      p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n      free_string_option(*(char_u **)p);\n      *(char_u **)p = empty_option;\n    }\n    /* May set global value for local option. */\n    else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n      set_string_option_global(opt_idx, varp);\n\n    /*\n     * Trigger the autocommand only after setting the flags.\n     */\n    /* When 'syntax' is set, load the syntax of that name */\n    if (varp == &(curbuf->b_p_syn)) {\n      apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,\n          curbuf->b_fname, TRUE, curbuf);\n    } else if (varp == &(curbuf->b_p_ft)) {\n      /* 'filetype' is set, trigger the FileType autocommand */\n      did_filetype = TRUE;\n      apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,\n          curbuf->b_fname, TRUE, curbuf);\n    }\n    if (varp == &(curwin->w_s->b_p_spl)) {\n      char_u fname[200];\n      char_u      *q = curwin->w_s->b_p_spl;\n\n      /* Skip the first name if it is \"cjk\". */\n      if (STRNCMP(q, \"cjk,\", 4) == 0)\n        q += 4;\n\n      /*\n       * Source the spell/LANG.vim in 'runtimepath'.\n       * They could set 'spellcapcheck' depending on the language.\n       * Use the first name in 'spelllang' up to '_region' or\n       * '.encoding'.\n       */\n      for (p = q; *p != NUL; ++p)\n        if (vim_strchr((char_u *)\"_.,\", *p) != NULL)\n          break;\n      vim_snprintf((char *)fname, sizeof(fname), \"spell/%.*s.vim\",\n                   (int)(p - q), q);\n      source_runtime(fname, DIP_ALL);\n    }\n  }\n\n  if (varp == &p_mouse) {\n    if (*p_mouse == NUL) {\n      ui_mouse_off();\n    } else {\n      setmouse();  // in case 'mouse' changed\n    }\n  }\n\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}\n\n/*\n * Simple int comparison function for use with qsort()\n */\nstatic int int_cmp(const void *a, const void *b)\n{\n  return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\nchar_u *check_colorcolumn(win_T *wp)\n{\n  char_u      *s;\n  int col;\n  unsigned int count = 0;\n  int color_cols[256];\n  int j = 0;\n\n  if (wp->w_buffer == NULL)\n    return NULL;      /* buffer was closed */\n\n  for (s = wp->w_p_cc; *s != NUL && count < 255; ) {\n    if (*s == '-' || *s == '+') {\n      /* -N and +N: add to 'textwidth' */\n      col = (*s == '-') ? -1 : 1;\n      ++s;\n      if (!ascii_isdigit(*s))\n        return e_invarg;\n      col = col * getdigits_int(&s);\n      if (wp->w_buffer->b_p_tw == 0)\n        goto skip;          /* 'textwidth' not set, skip this item */\n      assert((col >= 0\n              && wp->w_buffer->b_p_tw <= INT_MAX - col\n              && wp->w_buffer->b_p_tw + col >= INT_MIN)\n             || (col < 0\n                 && wp->w_buffer->b_p_tw >= INT_MIN - col\n                 && wp->w_buffer->b_p_tw + col <= INT_MAX));\n      col += (int)wp->w_buffer->b_p_tw;\n      if (col < 0)\n        goto skip;\n    } else if (ascii_isdigit(*s))\n      col = getdigits_int(&s);\n    else\n      return e_invarg;\n    color_cols[count++] = col - 1;      /* 1-based to 0-based */\nskip:\n    if (*s == NUL)\n      break;\n    if (*s != ',')\n      return e_invarg;\n    if (*++s == NUL)\n      return e_invarg;        /* illegal trailing comma as in \"set cc=80,\" */\n  }\n\n  xfree(wp->w_p_cc_cols);\n  if (count == 0)\n    wp->w_p_cc_cols = NULL;\n  else {\n    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));\n    /* sort the columns for faster usage on screen redraw inside\n     * win_line() */\n    qsort(color_cols, count, sizeof(int), int_cmp);\n\n    for (unsigned int i = 0; i < count; ++i)\n      /* skip duplicates */\n      if (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n        wp->w_p_cc_cols[j++] = color_cols[i];\n    wp->w_p_cc_cols[j] = -1;        /* end marker */\n  }\n\n  return NULL;    /* no error */\n}\n\n/*\n * Handle setting 'listchars' or 'fillchars'.\n * Returns error message, NULL if it's OK.\n */\nstatic char_u *set_chars_option(char_u **varp)\n{\n  int round, i, len, entries;\n  char_u      *p, *s;\n  int c1, c2 = 0;\n  struct charstab {\n    int     *cp;\n    char    *name;\n  };\n  static struct charstab filltab[] =\n  {\n    {&fill_stl,     \"stl\"},\n    {&fill_stlnc,   \"stlnc\"},\n    {&fill_vert,    \"vert\"},\n    {&fill_fold,    \"fold\"},\n    {&fill_diff,    \"diff\"},\n  };\n  static struct charstab lcstab[] =\n  {\n    {&lcs_eol,      \"eol\"},\n    {&lcs_ext,      \"extends\"},\n    {&lcs_nbsp,     \"nbsp\"},\n    {&lcs_prec,     \"precedes\"},\n    {&lcs_space,    \"space\"},\n    {&lcs_tab2,     \"tab\"},\n    {&lcs_trail,    \"trail\"},\n    {&lcs_conceal,  \"conceal\"},\n  };\n  struct charstab *tab;\n\n  if (varp == &p_lcs) {\n    tab = lcstab;\n    entries = ARRAY_SIZE(lcstab);\n  } else {\n    tab = filltab;\n    entries = ARRAY_SIZE(filltab);\n  }\n\n  /* first round: check for valid value, second round: assign values */\n  for (round = 0; round <= 1; ++round) {\n    if (round > 0) {\n      /* After checking that the value is valid: set defaults: space for\n       * 'fillchars', NUL for 'listchars' */\n      for (i = 0; i < entries; ++i)\n        if (tab[i].cp != NULL)\n          *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');\n      if (varp == &p_lcs)\n        lcs_tab1 = NUL;\n      else\n        fill_diff = '-';\n    }\n    p = *varp;\n    while (*p) {\n      for (i = 0; i < entries; ++i) {\n        len = (int)STRLEN(tab[i].name);\n        if (STRNCMP(p, tab[i].name, len) == 0\n            && p[len] == ':'\n            && p[len + 1] != NUL) {\n          s = p + len + 1;\n          c1 = mb_ptr2char_adv(&s);\n          if (mb_char2cells(c1) > 1)\n            continue;\n          if (tab[i].cp == &lcs_tab2) {\n            if (*s == NUL)\n              continue;\n            c2 = mb_ptr2char_adv(&s);\n            if (mb_char2cells(c2) > 1)\n              continue;\n          }\n          if (*s == ',' || *s == NUL) {\n            if (round) {\n              if (tab[i].cp == &lcs_tab2) {\n                lcs_tab1 = c1;\n                lcs_tab2 = c2;\n              } else if (tab[i].cp != NULL)\n                *(tab[i].cp) = c1;\n\n            }\n            p = s;\n            break;\n          }\n        }\n      }\n\n      if (i == entries)\n        return e_invarg;\n      if (*p == ',')\n        ++p;\n    }\n  }\n\n  return NULL;          /* no error */\n}\n\n/*\n * Check validity of options with the 'statusline' format.\n * Return error message or NULL.\n */\nchar_u *check_stl_option(char_u *s)\n{\n  int itemcnt = 0;\n  int groupdepth = 0;\n  static char_u errbuf[80];\n\n  while (*s && itemcnt < STL_MAX_ITEM) {\n    /* Check for valid keys after % sequences */\n    while (*s && *s != '%')\n      s++;\n    if (!*s)\n      break;\n    s++;\n    if (*s != '%' && *s != ')') {\n      itemcnt++;\n    }\n    if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE) {\n      s++;\n      continue;\n    }\n    if (*s == ')') {\n      s++;\n      if (--groupdepth < 0)\n        break;\n      continue;\n    }\n    if (*s == '-')\n      s++;\n    while (ascii_isdigit(*s))\n      s++;\n    if (*s == STL_USER_HL)\n      continue;\n    if (*s == '.') {\n      s++;\n      while (*s && ascii_isdigit(*s))\n        s++;\n    }\n    if (*s == '(') {\n      groupdepth++;\n      continue;\n    }\n    if (vim_strchr(STL_ALL, *s) == NULL) {\n      return illegal_char(errbuf, *s);\n    }\n    if (*s == '{') {\n      s++;\n      while (*s != '}' && *s)\n        s++;\n      if (*s != '}')\n        return (char_u *)N_(\"E540: Unclosed expression sequence\");\n    }\n  }\n  if (itemcnt >= STL_MAX_ITEM)\n    return (char_u *)N_(\"E541: too many items\");\n  if (groupdepth != 0)\n    return (char_u *)N_(\"E542: unbalanced groups\");\n  return NULL;\n}\n\nstatic char_u *did_set_spell_option(bool is_spellfile)\n{\n  char_u  *errmsg = NULL;\n\n  if (is_spellfile) {\n    int l = (int)STRLEN(curwin->w_s->b_p_spf);\n    if (l > 0\n        && (l < 4 || STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0)) {\n      errmsg = e_invarg;\n    }\n  }\n\n  if (errmsg == NULL) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_buffer == curbuf && wp->w_p_spell) {\n        errmsg = did_set_spelllang(wp);\n        break;\n      }\n    }\n  }\n\n  return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\nstatic char_u *compile_cap_prog(synblock_T *synblock)\n{\n  regprog_T   *rp = synblock->b_cap_prog;\n  char_u      *re;\n\n  if (*synblock->b_p_spc == NUL)\n    synblock->b_cap_prog = NULL;\n  else {\n    /* Prepend a ^ so that we only match at one column */\n    re = concat_str((char_u *)\"^\", synblock->b_p_spc);\n    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n    xfree(re);\n    if (synblock->b_cap_prog == NULL) {\n      synblock->b_cap_prog = rp;         /* restore the previous program */\n      return e_invarg;\n    }\n  }\n\n  vim_regfree(rp);\n  return NULL;\n}\n\n/*\n * Set the scriptID for an option, taking care of setting the buffer- or\n * window-local value.\n */\nstatic void set_option_scriptID_idx(int opt_idx, int opt_flags, int id)\n{\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n  int indir = (int)options[opt_idx].indir;\n\n  /* Remember where the option was set.  For local options need to do that\n   * in the buffer or window structure. */\n  if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0)\n    options[opt_idx].scriptID = id;\n  if (both || (opt_flags & OPT_LOCAL)) {\n    if (indir & PV_BUF)\n      curbuf->b_p_scriptID[indir & PV_MASK] = id;\n    else if (indir & PV_WIN)\n      curwin->w_p_scriptID[indir & PV_MASK] = id;\n  }\n}\n\n/*\n * Set the value of a boolean option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\nstatic char_u *\nset_bool_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u *varp,                      /* pointer to the option variable */\n    int value,                              /* new value */\n    int opt_flags                          /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  int old_value = *(int *)varp;\n\n  /* Disallow changing some options from secure mode */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    return e_secure;\n  }\n\n  *(int *)varp = value;             /* set the new value */\n  /* Remember where the option was set. */\n  set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n\n\n  /* May set global value for local option. */\n  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n\n  // Ensure that options set to p_force_on cannot be disabled.\n  if ((int *)varp == &p_force_on && p_force_on == FALSE) {\n    p_force_on = TRUE;\n    return e_unsupportedoption;\n  }\n  // Ensure that options set to p_force_off cannot be enabled.\n  else if ((int *)varp == &p_force_off && p_force_off == TRUE) {\n    p_force_off = FALSE;\n    return e_unsupportedoption;\n  }\n  /* 'undofile' */\n  else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf) {\n    /* Only take action when the option was set. When reset we do not\n     * delete the undo file, the option may be set again without making\n     * any changes in between. */\n    if (curbuf->b_p_udf || p_udf) {\n      char_u hash[UNDO_HASH_SIZE];\n      buf_T       *save_curbuf = curbuf;\n\n      for (curbuf = firstbuf; curbuf != NULL; curbuf = curbuf->b_next) {\n        /* When 'undofile' is set globally: for every buffer, otherwise\n         * only for the current buffer: Try to read in the undofile,\n         * if one exists, the buffer wasn't changed and the buffer was\n         * loaded */\n        if ((curbuf == save_curbuf\n             || (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n            && !curbufIsChanged() && curbuf->b_ml.ml_mfp != NULL) {\n          u_compute_hash(hash);\n          u_read_undo(NULL, hash, curbuf->b_fname);\n        }\n      }\n      curbuf = save_curbuf;\n    }\n  } else if ((int *)varp == &curbuf->b_p_ro) {\n    /* when 'readonly' is reset globally, also reset readonlymode */\n    if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)\n      readonlymode = FALSE;\n\n    /* when 'readonly' is set may give W10 again */\n    if (curbuf->b_p_ro)\n      curbuf->b_did_warn = false;\n\n    redraw_titles();\n  }\n  /* when 'modifiable' is changed, redraw the window title */\n  else if ((int *)varp == &curbuf->b_p_ma) {\n    redraw_titles();\n  }\n  /* when 'endofline' is changed, redraw the window title */\n  else if ((int *)varp == &curbuf->b_p_eol) {\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_fixeol) {\n    // when 'fixeol' is changed, redraw the window title\n    redraw_titles();\n  }\n  /* when 'bomb' is changed, redraw the window title and tab page text */\n  else if ((int *)varp == &curbuf->b_p_bomb) {\n    redraw_titles();\n  }\n  /* when 'bin' is set also set some other options */\n  else if ((int *)varp == &curbuf->b_p_bin) {\n    set_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n    redraw_titles();\n  }\n  /* when 'buflisted' changes, trigger autocommands */\n  else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl) {\n    apply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n        NULL, NULL, TRUE, curbuf);\n  }\n  /* when 'swf' is set, create swapfile, when reset remove swapfile */\n  else if ((int *)varp == (int *)&curbuf->b_p_swf) {\n    if (curbuf->b_p_swf && p_uc)\n      ml_open_file(curbuf);                     /* create the swap file */\n    else\n      /* no need to reset curbuf->b_may_swap, ml_open_file() will check\n       * buf->b_p_swf */\n      mf_close_file(curbuf, true);              /* remove the swap file */\n  }\n  /* when 'terse' is set change 'shortmess' */\n  else if ((int *)varp == &p_terse) {\n    char_u  *p;\n\n    p = vim_strchr(p_shm, SHM_SEARCH);\n\n    /* insert 's' in p_shm */\n    if (p_terse && p == NULL) {\n      STRCPY(IObuff, p_shm);\n      STRCAT(IObuff, \"s\");\n      set_string_option_direct((char_u *)\"shm\", -1, IObuff, OPT_FREE, 0);\n    }\n    /* remove 's' from p_shm */\n    else if (!p_terse && p != NULL)\n      STRMOVE(p, p + 1);\n  }\n  /* when 'paste' is set or reset also change other options */\n  else if ((int *)varp == &p_paste) {\n    paste_option_changed();\n  }\n  /* when 'insertmode' is set from an autocommand need to do work here */\n  else if ((int *)varp == &p_im) {\n    if (p_im) {\n      if ((State & INSERT) == 0) {\n        need_start_insertmode = true;\n      }\n      stop_insert_mode = false;\n    } else if (old_value) {  // only reset if it was set previously\n      need_start_insertmode = false;\n      stop_insert_mode = true;\n      if (restart_edit != 0 && mode_displayed) {\n        clear_cmdline = true;  // remove \"(insert)\"\n      }\n      restart_edit = 0;\n    }\n  }\n  /* when 'ignorecase' is set or reset and 'hlsearch' is set, redraw */\n  else if ((int *)varp == &p_ic && p_hls) {\n    redraw_all_later(SOME_VALID);\n  }\n  /* when 'hlsearch' is set or reset: reset no_hlsearch */\n  else if ((int *)varp == &p_hls) {\n    SET_NO_HLSEARCH(FALSE);\n  }\n  /* when 'scrollbind' is set: snapshot the current position to avoid a jump\n   * at the end of normal_cmd() */\n  else if ((int *)varp == &curwin->w_p_scb) {\n    if (curwin->w_p_scb) {\n      do_check_scrollbind(FALSE);\n      curwin->w_scbind_pos = curwin->w_topline;\n    }\n  }\n  /* There can be only one window with 'previewwindow' set. */\n  else if ((int *)varp == &curwin->w_p_pvw) {\n    if (curwin->w_p_pvw) {\n      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {\n        if (win->w_p_pvw && win != curwin) {\n          curwin->w_p_pvw = FALSE;\n          return (char_u *)N_(\"E590: A preview window already exists\");\n        }\n      }\n    }\n  } else if (varp == (char_u *)&(curbuf->b_p_lisp)) {\n    // When 'lisp' option changes include/exclude '-' in\n    // keyword characters.\n    (void)buf_init_chartab(curbuf, false);          // ignore errors\n  } else if ((int *)varp == &p_title) {\n    // when 'title' changed, may need to change the title; same for 'icon'\n    did_set_title(false);\n  } else if ((int *)varp == &p_icon) {\n    did_set_title(true);\n  } else if ((int *)varp == &curbuf->b_changed) {\n    if (!value) {\n      save_file_ff(curbuf);             // Buffer is unchanged\n    }\n    redraw_titles();\n    modified_was_set = value;\n  }\n\n#ifdef BACKSLASH_IN_FILENAME\n  else if ((int *)varp == &p_ssl) {\n    if (p_ssl) {\n      psepc = '/';\n      psepcN = '\\\\';\n      pseps[0] = '/';\n    } else {\n      psepc = '\\\\';\n      psepcN = '/';\n      pseps[0] = '\\\\';\n    }\n\n    /* need to adjust the file name arguments and buffer names. */\n    buflist_slash_adjust();\n    alist_slash_adjust();\n    scriptnames_slash_adjust();\n  }\n#endif\n\n  /* If 'wrap' is set, set w_leftcol to zero. */\n  else if ((int *)varp == &curwin->w_p_wrap) {\n    if (curwin->w_p_wrap)\n      curwin->w_leftcol = 0;\n  } else if ((int *)varp == &p_ea) {\n    if (p_ea && !old_value) {\n      win_equal(curwin, false, 0);\n    }\n  } else if ((int *)varp == &p_acd) {\n    // Change directories when the 'acd' option is set now.\n    do_autochdir();\n  }\n  /* 'diff' */\n  else if ((int *)varp == &curwin->w_p_diff) {\n    /* May add or remove the buffer from the list of diff buffers. */\n    diff_buf_adjust(curwin);\n    if (foldmethodIsDiff(curwin))\n      foldUpdateAll(curwin);\n  }\n\n\n  /* 'spell' */\n  else if ((int *)varp == &curwin->w_p_spell) {\n    if (curwin->w_p_spell) {\n      char_u      *errmsg = did_set_spelllang(curwin);\n      if (errmsg != NULL)\n        EMSG(_(errmsg));\n    }\n  } else if ((int *)varp == &p_altkeymap) {\n    if (old_value != p_altkeymap) {\n      if (!p_altkeymap) {\n        p_hkmap = p_fkmap;\n        p_fkmap = 0;\n      } else {\n        p_fkmap = p_hkmap;\n        p_hkmap = 0;\n      }\n      (void)init_chartab();\n    }\n  }\n\n  /*\n   * In case some second language keymapping options have changed, check\n   * and correct the setting in a consistent way.\n   */\n\n  /*\n   * If hkmap or fkmap are set, reset Arabic keymapping.\n   */\n  if ((p_hkmap || p_fkmap) && p_altkeymap) {\n    p_altkeymap = p_fkmap;\n    curwin->w_p_arab = FALSE;\n    (void)init_chartab();\n  }\n\n  /*\n   * If hkmap set, reset Farsi keymapping.\n   */\n  if (p_hkmap && p_altkeymap) {\n    p_altkeymap = 0;\n    p_fkmap = 0;\n    curwin->w_p_arab = FALSE;\n    (void)init_chartab();\n  }\n\n  /*\n   * If fkmap set, reset Hebrew keymapping.\n   */\n  if (p_fkmap && !p_altkeymap) {\n    p_altkeymap = 1;\n    p_hkmap = 0;\n    curwin->w_p_arab = FALSE;\n    (void)init_chartab();\n  }\n\n  if ((int *)varp == &curwin->w_p_arab) {\n    if (curwin->w_p_arab) {\n      /*\n       * 'arabic' is set, handle various sub-settings.\n       */\n      if (!p_tbidi) {\n        /* set rightleft mode */\n        if (!curwin->w_p_rl) {\n          curwin->w_p_rl = TRUE;\n          changed_window_setting();\n        }\n\n        /* Enable Arabic shaping (major part of what Arabic requires) */\n        if (!p_arshape) {\n          p_arshape = TRUE;\n          redraw_later_clear();\n        }\n      }\n\n      /* Arabic requires a utf-8 encoding, inform the user if its not\n       * set. */\n      if (STRCMP(p_enc, \"utf-8\") != 0) {\n        static char *w_arabic = N_(\n            \"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n        msg_source(hl_attr(HLF_W));\n        MSG_ATTR(_(w_arabic), hl_attr(HLF_W));\n        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);\n      }\n\n      /* set 'delcombine' */\n      p_deco = TRUE;\n\n      /* Force-set the necessary keymap for arabic */\n      set_option_value((char_u *)\"keymap\", 0L, (char_u *)\"arabic\",\n          OPT_LOCAL);\n      p_altkeymap = 0;\n      p_hkmap = 0;\n      p_fkmap = 0;\n      (void)init_chartab();\n    } else {\n      /*\n       * 'arabic' is reset, handle various sub-settings.\n       */\n      if (!p_tbidi) {\n        /* reset rightleft mode */\n        if (curwin->w_p_rl) {\n          curwin->w_p_rl = FALSE;\n          changed_window_setting();\n        }\n\n        /* 'arabicshape' isn't reset, it is a global option and\n         * another window may still need it \"on\". */\n      }\n\n      /* 'delcombine' isn't reset, it is a global option and another\n       * window may still want it \"on\". */\n\n      /* Revert to the default keymap */\n      curbuf->b_p_iminsert = B_IMODE_NONE;\n      curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n    }\n  }\n\n\n  /*\n   * End of handling side effects for bool options.\n   */\n\n  // after handling side effects, call autocommand\n\n  options[opt_idx].flags |= P_WAS_SET;\n\n  if (!starting) {\n    char buf_old[2];\n    char buf_new[2];\n    char buf_type[7];\n    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), \"%d\",\n                 old_value ? true: false);\n    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), \"%d\",\n                 value ? true: false);\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *) options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n  }\n\n  comp_col();                       /* in case 'ruler' or 'showcmd' changed */\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n  check_redraw(options[opt_idx].flags);\n\n  return NULL;\n}\n\n/*\n * Set the value of a number option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\nstatic char_u *\nset_num_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u *varp,                      /* pointer to the option variable */\n    long value,                             /* new value */\n    char_u *errbuf,                    /* buffer for error messages */\n    size_t errbuflen,                       /* length of \"errbuf\" */\n    int opt_flags                          /* OPT_LOCAL, OPT_GLOBAL and\n                                           OPT_MODELINE */\n)\n{\n  char_u      *errmsg = NULL;\n  long old_value = *(long *)varp;\n  long old_Rows = Rows;                 /* remember old Rows */\n  long old_Columns = Columns;           /* remember old Columns */\n  long        *pp = (long *)varp;\n\n  /* Disallow changing some options from secure mode. */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    return e_secure;\n  }\n\n  *pp = value;\n  /* Remember where the option was set. */\n  set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n\n  if (curbuf->b_p_sw < 0) {\n    errmsg = e_positive;\n    curbuf->b_p_sw = curbuf->b_p_ts;\n  }\n\n  /*\n   * Number options that need some action when changed\n   */\n  if (pp == &p_wh || pp == &p_hh) {\n    if (p_wh < 1) {\n      errmsg = e_positive;\n      p_wh = 1;\n    }\n    if (p_wmh > p_wh) {\n      errmsg = e_winheight;\n      p_wh = p_wmh;\n    }\n    if (p_hh < 0) {\n      errmsg = e_positive;\n      p_hh = 0;\n    }\n\n    /* Change window height NOW */\n    if (lastwin != firstwin) {\n      if (pp == &p_wh && curwin->w_height < p_wh)\n        win_setheight((int)p_wh);\n      if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n        win_setheight((int)p_hh);\n    }\n  }\n  /* 'winminheight' */\n  else if (pp == &p_wmh) {\n    if (p_wmh < 0) {\n      errmsg = e_positive;\n      p_wmh = 0;\n    }\n    if (p_wmh > p_wh) {\n      errmsg = e_winheight;\n      p_wmh = p_wh;\n    }\n    win_setminheight();\n  } else if (pp == &p_wiw) {\n    if (p_wiw < 1) {\n      errmsg = e_positive;\n      p_wiw = 1;\n    }\n    if (p_wmw > p_wiw) {\n      errmsg = e_winwidth;\n      p_wiw = p_wmw;\n    }\n\n    /* Change window width NOW */\n    if (lastwin != firstwin && curwin->w_width < p_wiw)\n      win_setwidth((int)p_wiw);\n  }\n  /* 'winminwidth' */\n  else if (pp == &p_wmw) {\n    if (p_wmw < 0) {\n      errmsg = e_positive;\n      p_wmw = 0;\n    }\n    if (p_wmw > p_wiw) {\n      errmsg = e_winwidth;\n      p_wmw = p_wiw;\n    }\n    win_setminheight();\n  } else if (pp == &p_ls) {\n    /* (re)set last window status line */\n    last_status(false);\n  }\n  /* (re)set tab page line */\n  else if (pp == &p_stal) {\n    shell_new_rows();           /* recompute window positions and heights */\n  }\n  /* 'foldlevel' */\n  else if (pp == &curwin->w_p_fdl) {\n    if (curwin->w_p_fdl < 0)\n      curwin->w_p_fdl = 0;\n    newFoldLevel();\n  }\n  /* 'foldminlines' */\n  else if (pp == &curwin->w_p_fml) {\n    foldUpdateAll(curwin);\n  }\n  /* 'foldnestmax' */\n  else if (pp == &curwin->w_p_fdn) {\n    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'foldcolumn' */\n  else if (pp == &curwin->w_p_fdc) {\n    if (curwin->w_p_fdc < 0) {\n      errmsg = e_positive;\n      curwin->w_p_fdc = 0;\n    } else if (curwin->w_p_fdc > 12) {\n      errmsg = e_invarg;\n      curwin->w_p_fdc = 12;\n    }\n  // 'shiftwidth' or 'tabstop'\n  } else if (pp == &curbuf->b_p_sw || pp == (long *)&curbuf->b_p_ts) {\n    if (foldmethodIsIndent(curwin)) {\n      foldUpdateAll(curwin);\n    }\n    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n    // parse 'cinoptions'.\n    if (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0) {\n      parse_cino(curbuf);\n    }\n  }\n  /* 'maxcombine' */\n  else if (pp == &p_mco) {\n    if (p_mco > MAX_MCO)\n      p_mco = MAX_MCO;\n    else if (p_mco < 0)\n      p_mco = 0;\n    screenclear();          /* will re-allocate the screen */\n  } else if (pp == &curbuf->b_p_iminsert) {\n    if (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST) {\n      errmsg = e_invarg;\n      curbuf->b_p_iminsert = B_IMODE_NONE;\n    }\n    p_iminsert = curbuf->b_p_iminsert;\n    showmode();\n    /* Show/unshow value of 'keymap' in status lines. */\n    status_redraw_curbuf();\n  } else if (pp == &p_window) {\n    if (p_window < 1)\n      p_window = 1;\n    else if (p_window >= Rows)\n      p_window = Rows - 1;\n  } else if (pp == &curbuf->b_p_imsearch) {\n    if (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST) {\n      errmsg = e_invarg;\n      curbuf->b_p_imsearch = B_IMODE_NONE;\n    }\n    p_imsearch = curbuf->b_p_imsearch;\n  }\n  /* if 'titlelen' has changed, redraw the title */\n  else if (pp == &p_titlelen) {\n    if (p_titlelen < 0) {\n      errmsg = e_positive;\n      p_titlelen = 85;\n    }\n    if (starting != NO_SCREEN && old_value != p_titlelen)\n      need_maketitle = TRUE;\n  }\n  /* if p_ch changed value, change the command line height */\n  else if (pp == &p_ch) {\n    if (p_ch < 1) {\n      errmsg = e_positive;\n      p_ch = 1;\n    }\n    if (p_ch > Rows - min_rows() + 1)\n      p_ch = Rows - min_rows() + 1;\n\n    /* Only compute the new window layout when startup has been\n     * completed. Otherwise the frame sizes may be wrong. */\n    if (p_ch != old_value && full_screen\n        )\n      command_height();\n  }\n  /* when 'updatecount' changes from zero to non-zero, open swap files */\n  else if (pp == &p_uc) {\n    if (p_uc < 0) {\n      errmsg = e_positive;\n      p_uc = 100;\n    }\n    if (p_uc && !old_value)\n      ml_open_files();\n  } else if (pp == &curwin->w_p_cole) {\n    if (curwin->w_p_cole < 0) {\n      errmsg = e_positive;\n      curwin->w_p_cole = 0;\n    } else if (curwin->w_p_cole > 3) {\n      errmsg = e_invarg;\n      curwin->w_p_cole = 3;\n    }\n  }\n  /* sync undo before 'undolevels' changes */\n  else if (pp == &p_ul) {\n    /* use the old value, otherwise u_sync() may not work properly */\n    p_ul = old_value;\n    u_sync(TRUE);\n    p_ul = value;\n  } else if (pp == &curbuf->b_p_ul) {\n    /* use the old value, otherwise u_sync() may not work properly */\n    curbuf->b_p_ul = old_value;\n    u_sync(TRUE);\n    curbuf->b_p_ul = value;\n  }\n  /* 'numberwidth' must be positive */\n  else if (pp == &curwin->w_p_nuw) {\n    if (curwin->w_p_nuw < 1) {\n      errmsg = e_positive;\n      curwin->w_p_nuw = 1;\n    }\n    if (curwin->w_p_nuw > 10) {\n      errmsg = e_invarg;\n      curwin->w_p_nuw = 10;\n    }\n    curwin->w_nrwidth_line_count = 0;\n  } else if (pp == &curbuf->b_p_tw) {\n    if (curbuf->b_p_tw < 0) {\n      errmsg = e_positive;\n      curbuf->b_p_tw = 0;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, wp) {\n      check_colorcolumn(wp);\n    }\n\n  }\n\n  /*\n   * Check the bounds for numeric options here\n   */\n  if (Rows < min_rows() && full_screen) {\n    if (errbuf != NULL) {\n      vim_snprintf((char *)errbuf, errbuflen,\n          _(\"E593: Need at least %d lines\"), min_rows());\n      errmsg = errbuf;\n    }\n    Rows = min_rows();\n  }\n  if (Columns < MIN_COLUMNS && full_screen) {\n    if (errbuf != NULL) {\n      vim_snprintf((char *)errbuf, errbuflen,\n          _(\"E594: Need at least %d columns\"), MIN_COLUMNS);\n      errmsg = errbuf;\n    }\n    Columns = MIN_COLUMNS;\n  }\n  limit_screen_size();\n\n\n  /*\n   * If the screen (shell) height has been changed, assume it is the\n   * physical screenheight.\n   */\n  if (old_Rows != Rows || old_Columns != Columns) {\n    /* Changing the screen size is not allowed while updating the screen. */\n    if (updating_screen) {\n      *pp = old_value;\n    } else if (full_screen) {\n      screen_resize((int)Columns, (int)Rows);\n    } else {\n      /* Postpone the resizing; check the size and cmdline position for\n       * messages. */\n      check_shellsize();\n      if (cmdline_row > Rows - p_ch && Rows > p_ch) {\n        assert(p_ch >= 0 && Rows - p_ch <= INT_MAX);\n        cmdline_row = (int)(Rows - p_ch);\n      }\n    }\n    if (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n      p_window = Rows - 1;\n  }\n\n  if (curbuf->b_p_ts <= 0) {\n    errmsg = e_positive;\n    curbuf->b_p_ts = 8;\n  }\n  if (p_tm < 0) {\n    errmsg = e_positive;\n    p_tm = 0;\n  }\n  if ((curwin->w_p_scr <= 0\n       || (curwin->w_p_scr > curwin->w_height\n           && curwin->w_height > 0))\n      && full_screen) {\n    if (pp == &(curwin->w_p_scr)) {\n      if (curwin->w_p_scr != 0)\n        errmsg = e_scroll;\n      win_comp_scroll(curwin);\n    }\n    /* If 'scroll' became invalid because of a side effect silently adjust\n     * it. */\n    else if (curwin->w_p_scr <= 0)\n      curwin->w_p_scr = 1;\n    else     /* curwin->w_p_scr > curwin->w_height */\n      curwin->w_p_scr = curwin->w_height;\n  }\n  if (p_hi < 0) {\n    errmsg = e_positive;\n    p_hi = 0;\n  } else if (p_hi > 10000) {\n    errmsg = e_invarg;\n    p_hi = 10000;\n  }\n  if (p_re < 0 || p_re > 2) {\n    errmsg = e_invarg;\n    p_re = 0;\n  }\n  if (p_report < 0) {\n    errmsg = e_positive;\n    p_report = 1;\n  }\n  if ((p_sj < -100 || p_sj >= Rows) && full_screen) {\n    if (Rows != old_Rows)       /* Rows changed, just adjust p_sj */\n      p_sj = Rows / 2;\n    else {\n      errmsg = e_scroll;\n      p_sj = 1;\n    }\n  }\n  if (p_so < 0 && full_screen) {\n    errmsg = e_scroll;\n    p_so = 0;\n  }\n  if (p_siso < 0 && full_screen) {\n    errmsg = e_positive;\n    p_siso = 0;\n  }\n  if (p_cwh < 1) {\n    errmsg = e_positive;\n    p_cwh = 1;\n  }\n  if (p_ut < 0) {\n    errmsg = e_positive;\n    p_ut = 2000;\n  }\n  if (p_ss < 0) {\n    errmsg = e_positive;\n    p_ss = 0;\n  }\n\n  /* May set global value for local option. */\n  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n  options[opt_idx].flags |= P_WAS_SET;\n\n  if (!starting && errmsg == NULL) {\n    char buf_old[NUMBUFLEN];\n    char buf_new[NUMBUFLEN];\n    char buf_type[7];\n    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), \"%ld\", old_value);\n    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), \"%ld\", value);\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *) options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n  }\n\n  comp_col();                       /* in case 'columns' or 'ls' changed */\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}\n\n/*\n * Called after an option changed: check if something needs to be redrawn.\n */\nstatic void check_redraw(uint32_t flags)\n{\n  /* Careful: P_RCLR and P_RALL are a combination of other P_ flags */\n  bool doclear = (flags & P_RCLR) == P_RCLR;\n  bool all = ((flags & P_RALL) == P_RALL || doclear);\n\n  if ((flags & P_RSTAT) || all)         /* mark all status lines dirty */\n    status_redraw_all();\n\n  if ((flags & P_RBUF) || (flags & P_RWIN) || all)\n    changed_window_setting();\n  if (flags & P_RBUF)\n    redraw_curbuf_later(NOT_VALID);\n  if (doclear)\n    redraw_all_later(CLEAR);\n  else if (all)\n    redraw_all_later(NOT_VALID);\n}\n\n/// Find index for named option\n///\n/// @param[in]  arg  Option to find index for.\n/// @param[in]  len  Length of the option.\n///\n/// @return Index of the option or -1 if option was not found.\nint findoption_len(const char_u *const arg, const size_t len)\n{\n  char *s, *p;\n  static int quick_tab[27] = { 0, 0 };  // quick access table\n  int is_term_opt;\n\n  /*\n   * For first call: Initialize the quick-access table.\n   * It contains the index for the first option that starts with a certain\n   * letter.  There are 26 letters, plus the first \"t_\" option.\n   */\n  if (quick_tab[1] == 0) {\n    p = options[0].fullname;\n    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {\n      if (s[0] != p[0]) {\n        if (s[0] == 't' && s[1] == '_')\n          quick_tab[26] = i;\n        else\n          quick_tab[CharOrdLow(s[0])] = i;\n      }\n      p = s;\n    }\n  }\n\n  /*\n   * Check for name starting with an illegal character.\n   */\n  if (len == 0 || arg[0] < 'a' || arg[0] > 'z') {\n    return -1;\n  }\n\n  int opt_idx;\n  is_term_opt = (len > 2 && arg[0] == 't' && arg[1] == '_');\n  if (is_term_opt) {\n    opt_idx = quick_tab[26];\n  } else {\n    opt_idx = quick_tab[CharOrdLow(arg[0])];\n  }\n  // Match full name\n  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {\n    if (STRNCMP(arg, s, len) == 0 && s[len] == NUL) {\n      break;\n    }\n  }\n  if (s == NULL && !is_term_opt) {\n    opt_idx = quick_tab[CharOrdLow(arg[0])];\n    // Match short name\n    for (; options[opt_idx].fullname != NULL; opt_idx++) {\n      s = options[opt_idx].shortname;\n      if (s != NULL && STRNCMP(arg, s, len) == 0 && s[len] == NUL) {\n        break;\n      }\n      s = NULL;\n    }\n  }\n  if (s == NULL)\n    opt_idx = -1;\n  return opt_idx;\n}\n\nbool is_tty_option(char *name)\n{\n  return (name[0] == 't' && name[1] == '_') || !strcmp((char *)name, \"term\");\n}\n\n#define TCO_BUFFER_SIZE 8\nbool get_tty_option(char *name, char **value)\n{\n  if (!strcmp(name, \"t_Co\")) {\n    if (value) {\n      if (t_colors <= 1) {\n        *value = xstrdup(\"\");\n      } else {\n        *value = xmalloc(TCO_BUFFER_SIZE);\n        snprintf(*value, TCO_BUFFER_SIZE, \"%d\", t_colors);\n      }\n    }\n    return true;\n  }\n\n  if (!strcmp(name, \"term\") || !strcmp(name, \"ttytype\")) {\n    if (value) {\n      *value = xstrdup(\"nvim\");\n    }\n    return true;\n  }\n\n  if (is_tty_option(name)) {\n    if (value) {\n      // XXX: All other t_* options were removed in 3baba1e7.\n      *value = xstrdup(\"\");\n    }\n    return true;\n  }\n\n  return false;\n}\n\nbool set_tty_option(char *name, char *value)\n{\n  if (!strcmp(name, \"t_Co\")) {\n    int colors = atoi(value);\n\n    // Only reinitialize colors if t_Co value has really changed to\n    // avoid expensive reload of colorscheme if t_Co is set to the\n    // same value multiple times\n    if (colors != t_colors) {\n      t_colors = colors;\n      // We now have a different color setup, initialize it again.\n      init_highlight(TRUE, FALSE);\n    }\n\n    return true;\n  }\n\n  return is_tty_option(name) || !strcmp(name, \"term\")\n    || !strcmp(name, \"ttytype\");\n}\n\n/*\n * Find index for option 'arg'.\n * Return -1 if not found.\n */\nstatic int findoption(char_u *arg)\n{\n  return findoption_len(arg, STRLEN(arg));\n}\n\n/*\n * Get the value for an option.\n *\n * Returns:\n * Number or Toggle option: 1, *numval gets value.\n *\t     String option: 0, *stringval gets allocated string.\n * Hidden Number or Toggle option: -1.\n *\t     hidden String option: -2.\n *\t\t   unknown option: -3.\n */\nint \nget_option_value (\n    char_u *name,\n    long *numval,\n    char_u **stringval,            /* NULL when only checking existence */\n    int opt_flags\n)\n{\n  if (get_tty_option((char *)name, (char **)stringval)) {\n    return 0;\n  }\n\n  int opt_idx;\n  char_u      *varp;\n\n  opt_idx = findoption(name);\n  if (opt_idx < 0)                  /* unknown option */\n    return -3;\n\n  varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\n  if (options[opt_idx].flags & P_STRING) {\n    if (varp == NULL)                       /* hidden option */\n      return -2;\n    if (stringval != NULL) {\n      *stringval = vim_strsave(*(char_u **)(varp));\n    }\n    return 0;\n  }\n\n  if (varp == NULL)                 /* hidden option */\n    return -1;\n  if (options[opt_idx].flags & P_NUM)\n    *numval = *(long *)varp;\n  else {\n    /* Special case: 'modified' is b_changed, but we also want to consider\n     * it set when 'ff' or 'fenc' changed. */\n    if ((int *)varp == &curbuf->b_changed) {\n      *numval = curbufIsChanged();\n    } else {\n      *numval = *(int *)varp;\n    }\n  }\n  return 1;\n}\n\n// Returns the option attributes and its value. Unlike the above function it\n// will return either global value or local value of the option depending on\n// what was requested, but it will never return global value if it was\n// requested to return local one and vice versa. Neither it will return\n// buffer-local value if it was requested to return window-local one.\n//\n// Pretends that option is absent if it is not present in the requested scope\n// (i.e. has no global, window-local or buffer-local value depending on\n// opt_type). Uses\n//\n// Returned flags:\n//       0 hidden or unknown option, also option that does not have requested \n//         type (see SREQ_* in option_defs.h)\n//  see SOPT_* in option_defs.h for other flags\n//\n// Possible opt_type values: see SREQ_* in option_defs.h\nint get_option_value_strict(char *name,\n                            int64_t *numval,\n                            char **stringval,\n                            int opt_type,\n                            void *from)\n{\n  if (get_tty_option(name, stringval)) {\n    return SOPT_STRING | SOPT_GLOBAL;\n  }\n\n  char_u *varp = NULL;\n  vimoption_T *p;\n  int rv = 0;\n  int opt_idx = findoption((uint8_t *)name);\n  if (opt_idx < 0) {\n    return 0;\n  }\n\n  p = &(options[opt_idx]);\n\n  // Hidden option\n  if (p->var == NULL) {\n    return 0;\n  }\n\n  if (p->flags & P_BOOL) {\n    rv |= SOPT_BOOL;\n  } else if (p->flags & P_NUM) {\n    rv |= SOPT_NUM;\n  } else if (p->flags & P_STRING) {\n    rv |= SOPT_STRING;\n  }\n\n  if (p->indir == PV_NONE) {\n    if (opt_type == SREQ_GLOBAL)\n      rv |= SOPT_GLOBAL;\n    else\n      return 0; // Did not request global-only option\n  } else {\n    if (p->indir & PV_BOTH) {\n      rv |= SOPT_GLOBAL;\n    } else if (opt_type == SREQ_GLOBAL) {\n      return 0; // Requested global option\n    }\n\n    if (p->indir & PV_WIN) {\n      if (opt_type == SREQ_BUF) {\n        return 0; // Did not request window-local option\n      } else {\n        rv |= SOPT_WIN;\n      }\n    } else if (p->indir & PV_BUF) {\n      if (opt_type == SREQ_WIN) {\n        return 0; // Did not request buffer-local option\n      } else {\n        rv |= SOPT_BUF;\n      }\n    }\n  }\n\n  if (stringval == NULL) {\n    return rv;\n  }\n\n  if (opt_type == SREQ_GLOBAL) {\n    varp = p->var;\n  } else {\n    if (opt_type == SREQ_BUF) {\n      // Special case: 'modified' is b_changed, but we also want to\n      // consider it set when 'ff' or 'fenc' changed.\n      if (p->indir == PV_MOD) {\n        *numval = bufIsChanged((buf_T *) from);\n        varp = NULL;\n      } else {\n        aco_save_T\taco;\n        aucmd_prepbuf(&aco, (buf_T *) from);\n        varp = get_varp(p);\n        aucmd_restbuf(&aco);\n      }\n    } else if (opt_type == SREQ_WIN) {\n      win_T\t*save_curwin;\n      save_curwin = curwin;\n      curwin = (win_T *) from;\n      curbuf = curwin->w_buffer;\n      varp = get_varp(p);\n      curwin = save_curwin;\n      curbuf = curwin->w_buffer;\n    }\n\n    if (varp == p->var) {\n      return (rv | SOPT_UNSET);\n    }\n  }\n\n  if (varp != NULL) {\n    if (p->flags & P_STRING) {\n      *stringval = xstrdup(*(char **)(varp));\n    } else if (p->flags & P_NUM) {\n      *numval = *(long *) varp;\n    } else {\n      *numval = *(int *)varp;\n    }\n  }\n\n  return rv;\n}\n\n/*\n * Set the value of option \"name\".\n * Use \"string\" for string options, use \"number\" for other options.\n *\n * Returns NULL on success or error message on error.\n */\nchar_u *\nset_option_value (\n    char_u *name,\n    long number,\n    char_u *string,\n    int opt_flags                  /* OPT_LOCAL or 0 (both) */\n)\n{\n  if (set_tty_option((char *)name, (char *)string)) {\n    return NULL;\n  }\n\n  int opt_idx;\n  char_u      *varp;\n\n  opt_idx = findoption(name);\n  if (opt_idx < 0)\n    EMSG2(_(\"E355: Unknown option: %s\"), name);\n  else {\n    uint32_t flags = options[opt_idx].flags;\n    // Disallow changing some options in the sandbox\n    if (sandbox > 0 && (flags & P_SECURE)) {\n      EMSG(_(e_sandbox));\n      return NULL;\n    }\n    if (flags & P_STRING) {\n      const char *s = (const char *)string;\n      if (s == NULL) {\n        s = \"\";\n      }\n      return (char_u *)set_string_option(opt_idx, s, opt_flags);\n    } else {\n      varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n      if (varp != NULL) {       /* hidden option is not changed */\n        if (number == 0 && string != NULL) {\n          int idx;\n\n          // Either we are given a string or we are setting option\n          // to zero.\n          for (idx = 0; string[idx] == '0'; idx++) {}\n          if (string[idx] != NUL || idx == 0) {\n            // There's another character after zeros or the string\n            // is empty.  In both cases, we are trying to set a\n            // num option using a string.\n            EMSG3(_(\"E521: Number required: &%s = '%s'\"),\n                  name, string);\n            return NULL;  // do nothing as we hit an error\n          }\n        }\n        if (flags & P_NUM)\n          return set_num_option(opt_idx, varp, number,\n              NULL, 0, opt_flags);\n        else\n          return set_bool_option(opt_idx, varp, (int)number,\n              opt_flags);\n      }\n    }\n  }\n  return NULL;\n}\n\nchar_u *get_highlight_default(void)\n{\n  int i;\n\n  i = findoption((char_u *)\"hl\");\n  if (i >= 0)\n    return options[i].def_val[VI_DEFAULT];\n  return (char_u *)NULL;\n}\n\n/*\n * Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n */\nint find_key_option_len(const char_u *arg, size_t len)\n{\n  int key;\n  int modifiers;\n\n  // Don't use get_special_key_code() for t_xx, we don't want it to call\n  // add_termcap_entry().\n  if (len >= 4 && arg[0] == 't' && arg[1] == '_') {\n    key = TERMCAP2KEY(arg[2], arg[3]);\n  } else {\n    arg--;  // put arg at the '<'\n    modifiers = 0;\n    key = find_special_key(&arg, len + 1, &modifiers, true, true);\n    if (modifiers) {  // can't handle modifiers here\n      key = 0;\n    }\n  }\n  return key;\n}\n\nstatic int find_key_option(const char_u *arg)\n{\n  return find_key_option_len(arg, STRLEN(arg));\n}\n\n\n/*\n * if 'all' == 0: show changed options\n * if 'all' == 1: show all normal options\n */\nstatic void \nshowoptions (\n    int all,\n    int opt_flags                  /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  vimoption_T    *p;\n  int col;\n  char_u              *varp;\n  int item_count;\n  int run;\n  int row, rows;\n  int cols;\n  int i;\n  int len;\n\n#define INC 20\n#define GAP 3\n\n  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * PARAM_COUNT);\n\n  /* Highlight title */\n  if (all == 2)\n    MSG_PUTS_TITLE(_(\"\\n--- Terminal codes ---\"));\n  else if (opt_flags & OPT_GLOBAL)\n    MSG_PUTS_TITLE(_(\"\\n--- Global option values ---\"));\n  else if (opt_flags & OPT_LOCAL)\n    MSG_PUTS_TITLE(_(\"\\n--- Local option values ---\"));\n  else\n    MSG_PUTS_TITLE(_(\"\\n--- Options ---\"));\n\n  /*\n   * do the loop two times:\n   * 1. display the short items\n   * 2. display the long items (only strings and numbers)\n   */\n  for (run = 1; run <= 2 && !got_int; ++run) {\n    /*\n     * collect the items in items[]\n     */\n    item_count = 0;\n    for (p = &options[0]; p->fullname != NULL; p++) {\n      varp = NULL;\n      if (opt_flags != 0) {\n        if (p->indir != PV_NONE)\n          varp = get_varp_scope(p, opt_flags);\n      } else\n        varp = get_varp(p);\n      if (varp != NULL\n          && (all == 1 || (all == 0 && !optval_default(p, varp)))) {\n        if (p->flags & P_BOOL)\n          len = 1;                      /* a toggle option fits always */\n        else {\n          option_value2string(p, opt_flags);\n          len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n        }\n        if ((len <= INC - GAP && run == 1)\n            || (len > INC - GAP && run == 2)) {\n          items[item_count++] = p;\n        }\n      }\n    }\n\n    /*\n     * display the items\n     */\n    if (run == 1) {\n      assert(Columns <= LONG_MAX - GAP\n             && Columns + GAP >= LONG_MIN + 3\n             && (Columns + GAP - 3) / INC >= INT_MIN\n             && (Columns + GAP - 3) / INC <= INT_MAX);\n      cols = (int)((Columns + GAP - 3) / INC);\n      if (cols == 0)\n        cols = 1;\n      rows = (item_count + cols - 1) / cols;\n    } else      /* run == 2 */\n      rows = item_count;\n    for (row = 0; row < rows && !got_int; ++row) {\n      msg_putchar('\\n');                        /* go to next line */\n      if (got_int)                              /* 'q' typed in more */\n        break;\n      col = 0;\n      for (i = row; i < item_count; i += rows) {\n        msg_col = col;                          /* make columns */\n        showoneopt(items[i], opt_flags);\n        col += INC;\n      }\n      ui_flush();\n      os_breakcheck();\n    }\n  }\n  xfree(items);\n}\n\n/*\n * Return TRUE if option \"p\" has its default value.\n */\nstatic int optval_default(vimoption_T *p, char_u *varp)\n{\n  int dvi;\n\n  if (varp == NULL)\n    return TRUE;            /* hidden option is always at default */\n  dvi = ((p->flags & P_VI_DEF) || p_cp) ? VI_DEFAULT : VIM_DEFAULT;\n  if (p->flags & P_NUM)\n    return *(long *)varp == (long)p->def_val[dvi];\n  if (p->flags & P_BOOL)\n    return *(int *)varp == (int)(intptr_t)p->def_val[dvi];\n  /* P_STRING */\n  return STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0;\n}\n\n/*\n * showoneopt: show the value of one option\n * must not be called with a hidden option!\n */\nstatic void \nshowoneopt (\n    vimoption_T *p,\n    int opt_flags                          /* OPT_LOCAL or OPT_GLOBAL */\n)\n{\n  char_u      *varp;\n  int save_silent = silent_mode;\n\n  silent_mode = FALSE;\n  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */\n\n  varp = get_varp_scope(p, opt_flags);\n\n  // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n  if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n                              ? !curbufIsChanged() : !*(int *)varp)) {\n    MSG_PUTS(\"no\");\n  } else if ((p->flags & P_BOOL) && *(int *)varp < 0) {\n    MSG_PUTS(\"--\");\n  } else {\n    MSG_PUTS(\"  \");\n  }\n  MSG_PUTS(p->fullname);\n  if (!(p->flags & P_BOOL)) {\n    msg_putchar('=');\n    /* put value string in NameBuff */\n    option_value2string(p, opt_flags);\n    msg_outtrans(NameBuff);\n  }\n\n  silent_mode = save_silent;\n  info_message = FALSE;\n}\n\n/*\n * Write modified options as \":set\" commands to a file.\n *\n * There are three values for \"opt_flags\":\n * OPT_GLOBAL:\t\t   Write global option values and fresh values of\n *\t\t\t   buffer-local options (used for start of a session\n *\t\t\t   file).\n * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n *\t\t\t   curwin (used for a vimrc file).\n * OPT_LOCAL:\t\t   Write buffer-local option values for curbuf, fresh\n *\t\t\t   and local values for window-local options of\n *\t\t\t   curwin.  Local values are also written when at the\n *\t\t\t   default value, because a modeline or autocommand\n *\t\t\t   may have set them when doing \":edit file\" and the\n *\t\t\t   user has set them back at the default or fresh\n *\t\t\t   value.\n *\t\t\t   When \"local_only\" is TRUE, don't write fresh\n *\t\t\t   values, only local values (for \":mkview\").\n * (fresh value = value used for a new buffer or window for a local option).\n *\n * Return FAIL on error, OK otherwise.\n */\nint makeset(FILE *fd, int opt_flags, int local_only)\n{\n  vimoption_T    *p;\n  char_u              *varp;                    /* currently used value */\n  char_u              *varp_fresh;              /* local value */\n  char_u              *varp_local = NULL;       /* fresh value */\n  char                *cmd;\n  int round;\n  int pri;\n\n  /*\n   * Some options are never written:\n   * - Options that don't have a default (terminal name, columns, lines).\n   * - Terminal options.\n   * - Hidden options.\n   *\n   * Do the loop over \"options[]\" twice: once for options with the\n   * P_PRI_MKRC flag and once without.\n   */\n  for (pri = 1; pri >= 0; --pri) {\n    for (p = &options[0]; p->fullname; p++)\n      if (!(p->flags & P_NO_MKRC)\n          && ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0))) {\n        /* skip global option when only doing locals */\n        if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))\n          continue;\n\n        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc\n         * file, they are always buffer-specific. */\n        if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))\n          continue;\n\n        varp = get_varp_scope(p, opt_flags);\n        /* Hidden options are never written. */\n        if (!varp)\n          continue;\n        /* Global values are only written when not at the default value. */\n        if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp))\n          continue;\n\n        round = 2;\n        if (p->indir != PV_NONE) {\n          if (p->var == VAR_WIN) {\n            /* skip window-local option when only doing globals */\n            if (!(opt_flags & OPT_LOCAL))\n              continue;\n            /* When fresh value of window-local option is not at the\n             * default, need to write it too. */\n            if (!(opt_flags & OPT_GLOBAL) && !local_only) {\n              varp_fresh = get_varp_scope(p, OPT_GLOBAL);\n              if (!optval_default(p, varp_fresh)) {\n                round = 1;\n                varp_local = varp;\n                varp = varp_fresh;\n              }\n            }\n          }\n        }\n\n        /* Round 1: fresh value for window-local options.\n         * Round 2: other values */\n        for (; round <= 2; varp = varp_local, ++round) {\n          if (round == 1 || (opt_flags & OPT_GLOBAL))\n            cmd = \"set\";\n          else\n            cmd = \"setlocal\";\n\n          if (p->flags & P_BOOL) {\n            if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)\n              return FAIL;\n          } else if (p->flags & P_NUM) {\n            if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)\n              return FAIL;\n          } else {    /* P_STRING */\n            int do_endif = FALSE;\n\n            // Don't set 'syntax' and 'filetype' again if the value is\n            // already right, avoids reloading the syntax file.\n            if (p->indir == PV_SYN || p->indir == PV_FT) {\n              if (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n                          *(char_u **)(varp)) < 0\n                  || put_eol(fd) < 0) {\n                return FAIL;\n              }\n              do_endif = true;\n            }\n            if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n                    (p->flags & P_EXPAND) != 0) == FAIL)\n              return FAIL;\n            if (do_endif) {\n              if (put_line(fd, \"endif\") == FAIL)\n                return FAIL;\n            }\n          }\n        }\n      }\n  }\n  return OK;\n}\n\n/*\n * Generate set commands for the local fold options only.  Used when\n * 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\n */\nint makefoldset(FILE *fd)\n{\n  if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, FALSE) == FAIL\n      || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, FALSE)\n      == FAIL\n      || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, FALSE)\n      == FAIL\n      || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, FALSE)\n      == FAIL\n      || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n      || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n      || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n      || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n      )\n    return FAIL;\n\n  return OK;\n}\n\nstatic int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, int expand)\n{\n  char_u      *s;\n  char_u      *buf;\n\n  if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n    return FAIL;\n  if (*valuep != NULL) {\n    /* Output 'pastetoggle' as key names.  For other\n     * options some characters have to be escaped with\n     * CTRL-V or backslash */\n    if (valuep == &p_pt) {\n      s = *valuep;\n      while (*s != NUL)\n        if (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)\n          return FAIL;\n    } else if (expand) {\n      buf = xmalloc(MAXPATHL);\n      home_replace(NULL, *valuep, buf, MAXPATHL, FALSE);\n      if (put_escstr(fd, buf, 2) == FAIL) {\n        xfree(buf);\n        return FAIL;\n      }\n      xfree(buf);\n    } else if (put_escstr(fd, *valuep, 2) == FAIL)\n      return FAIL;\n  }\n  if (put_eol(fd) < 0)\n    return FAIL;\n  return OK;\n}\n\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)\n{\n  long wc;\n\n  if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n    return FAIL;\n  if (wc_use_keyname((char_u *)valuep, &wc)) {\n    /* print 'wildchar' and 'wildcharm' as a key name */\n    if (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)\n      return FAIL;\n  } else if (fprintf(fd, \"%\" PRId64, (int64_t)*valuep) < 0)\n    return FAIL;\n  if (put_eol(fd) < 0)\n    return FAIL;\n  return OK;\n}\n\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value)\n{\n  if (value < 0)        /* global/local option using global value */\n    return OK;\n  if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n      || put_eol(fd) < 0)\n    return FAIL;\n  return OK;\n}\n\n/*\n * Compute columns for ruler and shown command. 'sc_col' is also used to\n * decide what the maximum length of a message on the status line can be.\n * If there is a status line for the last window, 'sc_col' is independent\n * of 'ru_col'.\n */\n\n#define COL_RULER 17        /* columns needed by standard ruler */\n\nvoid comp_col(void)\n{\n  int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));\n\n  sc_col = 0;\n  ru_col = 0;\n  if (p_ru) {\n    ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;\n    /* no last status line, adjust sc_col */\n    if (!last_has_status)\n      sc_col = ru_col;\n  }\n  if (p_sc) {\n    sc_col += SHOWCMD_COLS;\n    if (!p_ru || last_has_status)           /* no need for separating space */\n      ++sc_col;\n  }\n  assert(sc_col >= 0\n         && INT_MIN + sc_col <= Columns\n         && Columns - sc_col <= INT_MAX);\n  sc_col = (int)(Columns - sc_col);\n  assert(ru_col >= 0\n         && INT_MIN + ru_col <= Columns\n         && Columns - ru_col <= INT_MAX);\n  ru_col = (int)(Columns - ru_col);\n  if (sc_col <= 0)              /* screen too narrow, will become a mess */\n    sc_col = 1;\n  if (ru_col <= 0)\n    ru_col = 1;\n}\n\n// Unset local option value, similar to \":set opt<\".\nvoid unset_global_local_option(char *name, void *from)\n{\n  vimoption_T *p;\n  buf_T *buf = (buf_T *)from;\n\n  int opt_idx = findoption((uint8_t *)name);\n  if (opt_idx < 0) {\n    EMSG2(_(\"E355: Unknown option: %s\"), name);\n    return;\n  }\n  p = &(options[opt_idx]);\n\n  switch ((int)p->indir)\n  {\n    // global option with local value: use local value if it's been set\n    case PV_EP:\n      clear_string_option(&buf->b_p_ep);\n      break;\n    case PV_KP:\n      clear_string_option(&buf->b_p_kp);\n      break;\n    case PV_PATH:\n      clear_string_option(&buf->b_p_path);\n      break;\n    case PV_AR:\n      buf->b_p_ar = -1;\n      break;\n    case PV_BKC:\n      clear_string_option(&buf->b_p_bkc);\n      buf->b_bkc_flags = 0;\n      break;\n    case PV_TAGS:\n      clear_string_option(&buf->b_p_tags);\n      break;\n    case PV_TC:\n      clear_string_option(&buf->b_p_tc);\n      buf->b_tc_flags = 0;\n      break;\n    case PV_DEF:\n      clear_string_option(&buf->b_p_def);\n      break;\n    case PV_INC:\n      clear_string_option(&buf->b_p_inc);\n      break;\n    case PV_DICT:\n      clear_string_option(&buf->b_p_dict);\n      break;\n    case PV_TSR:\n      clear_string_option(&buf->b_p_tsr);\n      break;\n    case PV_EFM:\n      clear_string_option(&buf->b_p_efm);\n      break;\n    case PV_GP:\n      clear_string_option(&buf->b_p_gp);\n      break;\n    case PV_MP:\n      clear_string_option(&buf->b_p_mp);\n      break;\n    case PV_STL:\n      clear_string_option(&((win_T *)from)->w_p_stl);\n      break;\n    case PV_UL:\n      buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n      break;\n    case PV_LW:\n      clear_string_option(&buf->b_p_lw);\n      break;\n  }\n}\n\n/*\n * Get pointer to option variable, depending on local or global scope.\n */\nstatic char_u *get_varp_scope(vimoption_T *p, int opt_flags)\n{\n  if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE) {\n    if (p->var == VAR_WIN)\n      return (char_u *)GLOBAL_WO(get_varp(p));\n    return p->var;\n  }\n  if ((opt_flags & OPT_LOCAL) && ((int)p->indir & PV_BOTH)) {\n    switch ((int)p->indir) {\n    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n    }\n    return NULL;     /* \"cannot happen\" */\n  }\n  return get_varp(p);\n}\n\n/*\n * Get pointer to option variable.\n */\nstatic char_u *get_varp(vimoption_T *p)\n{\n  /* hidden option, always return NULL */\n  if (p->var == NULL)\n    return NULL;\n\n  switch ((int)p->indir) {\n  case PV_NONE:   return p->var;\n\n  /* global option with local value: use local value if it's been set */\n  case PV_EP:     return *curbuf->b_p_ep != NUL\n           ? (char_u *)&curbuf->b_p_ep : p->var;\n  case PV_KP:     return *curbuf->b_p_kp != NUL\n           ? (char_u *)&curbuf->b_p_kp : p->var;\n  case PV_PATH:   return *curbuf->b_p_path != NUL\n           ? (char_u *)&(curbuf->b_p_path) : p->var;\n  case PV_AR:     return curbuf->b_p_ar >= 0\n           ? (char_u *)&(curbuf->b_p_ar) : p->var;\n  case PV_TAGS:   return *curbuf->b_p_tags != NUL\n           ? (char_u *)&(curbuf->b_p_tags) : p->var;\n  case PV_TC:     return *curbuf->b_p_tc != NUL\n           ? (char_u *)&(curbuf->b_p_tc) : p->var;\n  case PV_BKC:    return *curbuf->b_p_bkc != NUL\n           ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n  case PV_DEF:    return *curbuf->b_p_def != NUL\n           ? (char_u *)&(curbuf->b_p_def) : p->var;\n  case PV_INC:    return *curbuf->b_p_inc != NUL\n           ? (char_u *)&(curbuf->b_p_inc) : p->var;\n  case PV_DICT:   return *curbuf->b_p_dict != NUL\n           ? (char_u *)&(curbuf->b_p_dict) : p->var;\n  case PV_TSR:    return *curbuf->b_p_tsr != NUL\n           ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n  case PV_EFM:    return *curbuf->b_p_efm != NUL\n           ? (char_u *)&(curbuf->b_p_efm) : p->var;\n  case PV_GP:     return *curbuf->b_p_gp != NUL\n           ? (char_u *)&(curbuf->b_p_gp) : p->var;\n  case PV_MP:     return *curbuf->b_p_mp != NUL\n           ? (char_u *)&(curbuf->b_p_mp) : p->var;\n  case PV_STL:    return *curwin->w_p_stl != NUL\n           ? (char_u *)&(curwin->w_p_stl) : p->var;\n  case PV_UL:     return curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n           ? (char_u *)&(curbuf->b_p_ul) : p->var;\n  case PV_LW:   return *curbuf->b_p_lw != NUL\n           ? (char_u *)&(curbuf->b_p_lw) : p->var;\n\n  case PV_ARAB:   return (char_u *)&(curwin->w_p_arab);\n  case PV_LIST:   return (char_u *)&(curwin->w_p_list);\n  case PV_SPELL:  return (char_u *)&(curwin->w_p_spell);\n  case PV_CUC:    return (char_u *)&(curwin->w_p_cuc);\n  case PV_CUL:    return (char_u *)&(curwin->w_p_cul);\n  case PV_CC:     return (char_u *)&(curwin->w_p_cc);\n  case PV_DIFF:   return (char_u *)&(curwin->w_p_diff);\n  case PV_FDC:    return (char_u *)&(curwin->w_p_fdc);\n  case PV_FEN:    return (char_u *)&(curwin->w_p_fen);\n  case PV_FDI:    return (char_u *)&(curwin->w_p_fdi);\n  case PV_FDL:    return (char_u *)&(curwin->w_p_fdl);\n  case PV_FDM:    return (char_u *)&(curwin->w_p_fdm);\n  case PV_FML:    return (char_u *)&(curwin->w_p_fml);\n  case PV_FDN:    return (char_u *)&(curwin->w_p_fdn);\n  case PV_FDE:    return (char_u *)&(curwin->w_p_fde);\n  case PV_FDT:    return (char_u *)&(curwin->w_p_fdt);\n  case PV_FMR:    return (char_u *)&(curwin->w_p_fmr);\n  case PV_NU:     return (char_u *)&(curwin->w_p_nu);\n  case PV_RNU:    return (char_u *)&(curwin->w_p_rnu);\n  case PV_NUW:    return (char_u *)&(curwin->w_p_nuw);\n  case PV_WFH:    return (char_u *)&(curwin->w_p_wfh);\n  case PV_WFW:    return (char_u *)&(curwin->w_p_wfw);\n  case PV_PVW:    return (char_u *)&(curwin->w_p_pvw);\n  case PV_RL:     return (char_u *)&(curwin->w_p_rl);\n  case PV_RLC:    return (char_u *)&(curwin->w_p_rlc);\n  case PV_SCROLL: return (char_u *)&(curwin->w_p_scr);\n  case PV_WRAP:   return (char_u *)&(curwin->w_p_wrap);\n  case PV_LBR:    return (char_u *)&(curwin->w_p_lbr);\n  case PV_BRI:    return (char_u *)&(curwin->w_p_bri);\n  case PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n  case PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n  case PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n  case PV_COCU:    return (char_u *)&(curwin->w_p_cocu);\n  case PV_COLE:    return (char_u *)&(curwin->w_p_cole);\n\n  case PV_AI:     return (char_u *)&(curbuf->b_p_ai);\n  case PV_BIN:    return (char_u *)&(curbuf->b_p_bin);\n  case PV_BOMB:   return (char_u *)&(curbuf->b_p_bomb);\n  case PV_BH:     return (char_u *)&(curbuf->b_p_bh);\n  case PV_BT:     return (char_u *)&(curbuf->b_p_bt);\n  case PV_BL:     return (char_u *)&(curbuf->b_p_bl);\n  case PV_CI:     return (char_u *)&(curbuf->b_p_ci);\n  case PV_CIN:    return (char_u *)&(curbuf->b_p_cin);\n  case PV_CINK:   return (char_u *)&(curbuf->b_p_cink);\n  case PV_CINO:   return (char_u *)&(curbuf->b_p_cino);\n  case PV_CINW:   return (char_u *)&(curbuf->b_p_cinw);\n  case PV_COM:    return (char_u *)&(curbuf->b_p_com);\n  case PV_CMS:    return (char_u *)&(curbuf->b_p_cms);\n  case PV_CPT:    return (char_u *)&(curbuf->b_p_cpt);\n  case PV_CFU:    return (char_u *)&(curbuf->b_p_cfu);\n  case PV_OFU:    return (char_u *)&(curbuf->b_p_ofu);\n  case PV_EOL:    return (char_u *)&(curbuf->b_p_eol);\n  case PV_FIXEOL: return (char_u *)&(curbuf->b_p_fixeol);\n  case PV_ET:     return (char_u *)&(curbuf->b_p_et);\n  case PV_FENC:   return (char_u *)&(curbuf->b_p_fenc);\n  case PV_FF:     return (char_u *)&(curbuf->b_p_ff);\n  case PV_FT:     return (char_u *)&(curbuf->b_p_ft);\n  case PV_FO:     return (char_u *)&(curbuf->b_p_fo);\n  case PV_FLP:    return (char_u *)&(curbuf->b_p_flp);\n  case PV_IMI:    return (char_u *)&(curbuf->b_p_iminsert);\n  case PV_IMS:    return (char_u *)&(curbuf->b_p_imsearch);\n  case PV_INF:    return (char_u *)&(curbuf->b_p_inf);\n  case PV_ISK:    return (char_u *)&(curbuf->b_p_isk);\n  case PV_INEX:   return (char_u *)&(curbuf->b_p_inex);\n  case PV_INDE:   return (char_u *)&(curbuf->b_p_inde);\n  case PV_INDK:   return (char_u *)&(curbuf->b_p_indk);\n  case PV_FEX:    return (char_u *)&(curbuf->b_p_fex);\n  case PV_LISP:   return (char_u *)&(curbuf->b_p_lisp);\n  case PV_ML:     return (char_u *)&(curbuf->b_p_ml);\n  case PV_MPS:    return (char_u *)&(curbuf->b_p_mps);\n  case PV_MA:     return (char_u *)&(curbuf->b_p_ma);\n  case PV_MOD:    return (char_u *)&(curbuf->b_changed);\n  case PV_NF:     return (char_u *)&(curbuf->b_p_nf);\n  case PV_PI:     return (char_u *)&(curbuf->b_p_pi);\n  case PV_QE:     return (char_u *)&(curbuf->b_p_qe);\n  case PV_RO:     return (char_u *)&(curbuf->b_p_ro);\n  case PV_SI:     return (char_u *)&(curbuf->b_p_si);\n  case PV_STS:    return (char_u *)&(curbuf->b_p_sts);\n  case PV_SUA:    return (char_u *)&(curbuf->b_p_sua);\n  case PV_SWF:    return (char_u *)&(curbuf->b_p_swf);\n  case PV_SMC:    return (char_u *)&(curbuf->b_p_smc);\n  case PV_SYN:    return (char_u *)&(curbuf->b_p_syn);\n  case PV_SPC:    return (char_u *)&(curwin->w_s->b_p_spc);\n  case PV_SPF:    return (char_u *)&(curwin->w_s->b_p_spf);\n  case PV_SPL:    return (char_u *)&(curwin->w_s->b_p_spl);\n  case PV_SW:     return (char_u *)&(curbuf->b_p_sw);\n  case PV_TS:     return (char_u *)&(curbuf->b_p_ts);\n  case PV_TW:     return (char_u *)&(curbuf->b_p_tw);\n  case PV_UDF:    return (char_u *)&(curbuf->b_p_udf);\n  case PV_WM:     return (char_u *)&(curbuf->b_p_wm);\n  case PV_KMAP:   return (char_u *)&(curbuf->b_p_keymap);\n  default:        EMSG(_(\"E356: get_varp ERROR\"));\n  }\n  /* always return a valid pointer to avoid a crash! */\n  return (char_u *)&(curbuf->b_p_wm);\n}\n\n/*\n * Get the value of 'equalprg', either the buffer-local one or the global one.\n */\nchar_u *get_equalprg(void)\n{\n  if (*curbuf->b_p_ep == NUL)\n    return p_ep;\n  return curbuf->b_p_ep;\n}\n\n/*\n * Copy options from one window to another.\n * Used when splitting a window.\n */\nvoid win_copy_options(win_T *wp_from, win_T *wp_to)\n{\n  copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n  copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n  /* Is this right? */\n  wp_to->w_farsi = wp_from->w_farsi;\n  briopt_check(wp_to);\n}\n\n/*\n * Copy the options from one winopt_T to another.\n * Doesn't free the old option values in \"to\", use clear_winopt() for that.\n * The 'scroll' option is not copied, because it depends on the window height.\n * The 'previewwindow' option is reset, there can be only one preview window.\n */\nvoid copy_winopt(winopt_T *from, winopt_T *to)\n{\n  to->wo_arab = from->wo_arab;\n  to->wo_list = from->wo_list;\n  to->wo_nu = from->wo_nu;\n  to->wo_rnu = from->wo_rnu;\n  to->wo_nuw = from->wo_nuw;\n  to->wo_rl  = from->wo_rl;\n  to->wo_rlc = vim_strsave(from->wo_rlc);\n  to->wo_stl = vim_strsave(from->wo_stl);\n  to->wo_wrap = from->wo_wrap;\n  to->wo_wrap_save = from->wo_wrap_save;\n  to->wo_lbr = from->wo_lbr;\n  to->wo_bri = from->wo_bri;\n  to->wo_briopt = vim_strsave(from->wo_briopt);\n  to->wo_scb = from->wo_scb;\n  to->wo_scb_save = from->wo_scb_save;\n  to->wo_crb = from->wo_crb;\n  to->wo_crb_save = from->wo_crb_save;\n  to->wo_spell = from->wo_spell;\n  to->wo_cuc = from->wo_cuc;\n  to->wo_cul = from->wo_cul;\n  to->wo_cc = vim_strsave(from->wo_cc);\n  to->wo_diff = from->wo_diff;\n  to->wo_diff_saved = from->wo_diff_saved;\n  to->wo_cocu = vim_strsave(from->wo_cocu);\n  to->wo_cole = from->wo_cole;\n  to->wo_fdc = from->wo_fdc;\n  to->wo_fdc_save = from->wo_fdc_save;\n  to->wo_fen = from->wo_fen;\n  to->wo_fen_save = from->wo_fen_save;\n  to->wo_fdi = vim_strsave(from->wo_fdi);\n  to->wo_fml = from->wo_fml;\n  to->wo_fdl = from->wo_fdl;\n  to->wo_fdl_save = from->wo_fdl_save;\n  to->wo_fdm = vim_strsave(from->wo_fdm);\n  to->wo_fdm_save = from->wo_diff_saved\n                    ? vim_strsave(from->wo_fdm_save) : empty_option;\n  to->wo_fdn = from->wo_fdn;\n  to->wo_fde = vim_strsave(from->wo_fde);\n  to->wo_fdt = vim_strsave(from->wo_fdt);\n  to->wo_fmr = vim_strsave(from->wo_fmr);\n  check_winopt(to);             /* don't want NULL pointers */\n}\n\n/*\n * Check string options in a window for a NULL value.\n */\nvoid check_win_options(win_T *win)\n{\n  check_winopt(&win->w_onebuf_opt);\n  check_winopt(&win->w_allbuf_opt);\n}\n\n/*\n * Check for NULL pointers in a winopt_T and replace them with empty_option.\n */\nstatic void check_winopt(winopt_T *wop)\n{\n  check_string_option(&wop->wo_fdi);\n  check_string_option(&wop->wo_fdm);\n  check_string_option(&wop->wo_fdm_save);\n  check_string_option(&wop->wo_fde);\n  check_string_option(&wop->wo_fdt);\n  check_string_option(&wop->wo_fmr);\n  check_string_option(&wop->wo_rlc);\n  check_string_option(&wop->wo_stl);\n  check_string_option(&wop->wo_cc);\n  check_string_option(&wop->wo_cocu);\n  check_string_option(&wop->wo_briopt);\n}\n\n/*\n * Free the allocated memory inside a winopt_T.\n */\nvoid clear_winopt(winopt_T *wop)\n{\n  clear_string_option(&wop->wo_fdi);\n  clear_string_option(&wop->wo_fdm);\n  clear_string_option(&wop->wo_fdm_save);\n  clear_string_option(&wop->wo_fde);\n  clear_string_option(&wop->wo_fdt);\n  clear_string_option(&wop->wo_fmr);\n  clear_string_option(&wop->wo_rlc);\n  clear_string_option(&wop->wo_stl);\n  clear_string_option(&wop->wo_cc);\n  clear_string_option(&wop->wo_cocu);\n  clear_string_option(&wop->wo_briopt);\n}\n\n/*\n * Copy global option values to local options for one buffer.\n * Used when creating a new buffer and sometimes when entering a buffer.\n * flags:\n * BCO_ENTER\tWe will enter the buf buffer.\n * BCO_ALWAYS\tAlways copy the options, but only set b_p_initialized when\n *\t\tappropriate.\n * BCO_NOHELP\tDon't copy the values to a help buffer.\n */\nvoid buf_copy_options(buf_T *buf, int flags)\n{\n  int should_copy = TRUE;\n  char_u      *save_p_isk = NULL;           /* init for GCC */\n  int dont_do_help;\n  int did_isk = FALSE;\n\n  /*\n   * Don't do anything if the buffer is invalid.\n   */\n  if (buf == NULL || !buf_valid(buf))\n    return;\n\n  /*\n   * Skip this when the option defaults have not been set yet.  Happens when\n   * main() allocates the first buffer.\n   */\n  if (p_cpo != NULL) {\n    /*\n     * Always copy when entering and 'cpo' contains 'S'.\n     * Don't copy when already initialized.\n     * Don't copy when 'cpo' contains 's' and not entering.\n     * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n     * yes\t  yes\t       X\t X\tTRUE\n     * yes\t  no\t      yes\t X\tFALSE\n     * no\t   X\t      yes\t X\tFALSE\n     *  X\t  no\t      no\tyes\tFALSE\n     *  X\t  no\t      no\tno\tTRUE\n     * no\t  yes\t      no\t X\tTRUE\n     */\n    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n        && (buf->b_p_initialized\n            || (!(flags & BCO_ENTER)\n                && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n      should_copy = FALSE;\n\n    if (should_copy || (flags & BCO_ALWAYS)) {\n      /* Don't copy the options specific to a help buffer when\n      * BCO_NOHELP is given or the options were initialized already\n      * (jumping back to a help file with CTRL-T or CTRL-O) */\n      dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n                     || buf->b_p_initialized;\n      if (dont_do_help) {               /* don't free b_p_isk */\n        save_p_isk = buf->b_p_isk;\n        buf->b_p_isk = NULL;\n      }\n      /*\n       * Always free the allocated strings.\n       * If not already initialized, set 'readonly' and copy 'fileformat'.\n       */\n      if (!buf->b_p_initialized) {\n        free_buf_options(buf, TRUE);\n        buf->b_p_ro = FALSE;                    /* don't copy readonly */\n        buf->b_p_fenc = vim_strsave(p_fenc);\n        buf->b_p_ff = vim_strsave(p_ff);\n        buf->b_p_bh = empty_option;\n        buf->b_p_bt = empty_option;\n      } else\n        free_buf_options(buf, FALSE);\n\n      buf->b_p_ai = p_ai;\n      buf->b_p_ai_nopaste = p_ai_nopaste;\n      buf->b_p_sw = p_sw;\n      buf->b_p_tw = p_tw;\n      buf->b_p_tw_nopaste = p_tw_nopaste;\n      buf->b_p_tw_nobin = p_tw_nobin;\n      buf->b_p_wm = p_wm;\n      buf->b_p_wm_nopaste = p_wm_nopaste;\n      buf->b_p_wm_nobin = p_wm_nobin;\n      buf->b_p_bin = p_bin;\n      buf->b_p_bomb = p_bomb;\n      buf->b_p_et = p_et;\n      buf->b_p_fixeol = p_fixeol;\n      buf->b_p_et_nobin = p_et_nobin;\n      buf->b_p_et_nopaste = p_et_nopaste;\n      buf->b_p_ml = p_ml;\n      buf->b_p_ml_nobin = p_ml_nobin;\n      buf->b_p_inf = p_inf;\n      buf->b_p_swf = p_swf;\n      buf->b_p_cpt = vim_strsave(p_cpt);\n      buf->b_p_cfu = vim_strsave(p_cfu);\n      buf->b_p_ofu = vim_strsave(p_ofu);\n      buf->b_p_sts = p_sts;\n      buf->b_p_sts_nopaste = p_sts_nopaste;\n      buf->b_p_com = vim_strsave(p_com);\n      buf->b_p_cms = vim_strsave(p_cms);\n      buf->b_p_fo = vim_strsave(p_fo);\n      buf->b_p_flp = vim_strsave(p_flp);\n      buf->b_p_nf = vim_strsave(p_nf);\n      buf->b_p_mps = vim_strsave(p_mps);\n      buf->b_p_si = p_si;\n      buf->b_p_ci = p_ci;\n      buf->b_p_cin = p_cin;\n      buf->b_p_cink = vim_strsave(p_cink);\n      buf->b_p_cino = vim_strsave(p_cino);\n      /* Don't copy 'filetype', it must be detected */\n      buf->b_p_ft = empty_option;\n      buf->b_p_pi = p_pi;\n      buf->b_p_cinw = vim_strsave(p_cinw);\n      buf->b_p_lisp = p_lisp;\n      /* Don't copy 'syntax', it must be set */\n      buf->b_p_syn = empty_option;\n      buf->b_p_smc = p_smc;\n      buf->b_s.b_syn_isk = empty_option;\n      buf->b_s.b_p_spc = vim_strsave(p_spc);\n      (void)compile_cap_prog(&buf->b_s);\n      buf->b_s.b_p_spf = vim_strsave(p_spf);\n      buf->b_s.b_p_spl = vim_strsave(p_spl);\n      buf->b_p_inde = vim_strsave(p_inde);\n      buf->b_p_indk = vim_strsave(p_indk);\n      buf->b_p_fex = vim_strsave(p_fex);\n      buf->b_p_sua = vim_strsave(p_sua);\n      buf->b_p_keymap = vim_strsave(p_keymap);\n      buf->b_kmap_state |= KEYMAP_INIT;\n      /* This isn't really an option, but copying the langmap and IME\n      * state from the current buffer is better than resetting it. */\n      buf->b_p_iminsert = p_iminsert;\n      buf->b_p_imsearch = p_imsearch;\n\n      /* options that are normally global but also have a local value\n       * are not copied, start using the global value */\n      buf->b_p_ar = -1;\n      buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n      buf->b_p_bkc = empty_option;\n      buf->b_bkc_flags = 0;\n      buf->b_p_gp = empty_option;\n      buf->b_p_mp = empty_option;\n      buf->b_p_efm = empty_option;\n      buf->b_p_ep = empty_option;\n      buf->b_p_kp = empty_option;\n      buf->b_p_path = empty_option;\n      buf->b_p_tags = empty_option;\n      buf->b_p_tc = empty_option;\n      buf->b_tc_flags = 0;\n      buf->b_p_def = empty_option;\n      buf->b_p_inc = empty_option;\n      buf->b_p_inex = vim_strsave(p_inex);\n      buf->b_p_dict = empty_option;\n      buf->b_p_tsr = empty_option;\n      buf->b_p_qe = vim_strsave(p_qe);\n      buf->b_p_udf = p_udf;\n      buf->b_p_lw = empty_option;\n\n      /*\n       * Don't copy the options set by ex_help(), use the saved values,\n       * when going from a help buffer to a non-help buffer.\n       * Don't touch these at all when BCO_NOHELP is used and going from\n       * or to a help buffer.\n       */\n      if (dont_do_help)\n        buf->b_p_isk = save_p_isk;\n      else {\n        buf->b_p_isk = vim_strsave(p_isk);\n        did_isk = true;\n        buf->b_p_ts = p_ts;\n        buf->b_help = false;\n        if (buf->b_p_bt[0] == 'h')\n          clear_string_option(&buf->b_p_bt);\n        buf->b_p_ma = p_ma;\n      }\n    }\n\n    /*\n     * When the options should be copied (ignoring BCO_ALWAYS), set the\n     * flag that indicates that the options have been initialized.\n     */\n    if (should_copy)\n      buf->b_p_initialized = true;\n  }\n\n  check_buf_options(buf);           /* make sure we don't have NULLs */\n  if (did_isk)\n    (void)buf_init_chartab(buf, FALSE);\n}\n\n/*\n * Reset the 'modifiable' option and its default value.\n */\nvoid reset_modifiable(void)\n{\n  int opt_idx;\n\n  curbuf->b_p_ma = FALSE;\n  p_ma = FALSE;\n  opt_idx = findoption((char_u *)\"ma\");\n  if (opt_idx >= 0)\n    options[opt_idx].def_val[VI_DEFAULT] = FALSE;\n}\n\n/*\n * Set the global value for 'iminsert' to the local value.\n */\nvoid set_iminsert_global(void)\n{\n  p_iminsert = curbuf->b_p_iminsert;\n}\n\n/*\n * Set the global value for 'imsearch' to the local value.\n */\nvoid set_imsearch_global(void)\n{\n  p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\nvoid \nset_context_in_set_cmd (\n    expand_T *xp,\n    char_u *arg,\n    int opt_flags                  /* OPT_GLOBAL and/or OPT_LOCAL */\n)\n{\n  char_u nextchar;\n  uint32_t flags = 0;           /* init for GCC */\n  int opt_idx = 0;              /* init for GCC */\n  char_u      *p;\n  char_u      *s;\n  int is_term_option = FALSE;\n  int key;\n\n  expand_option_flags = opt_flags;\n\n  xp->xp_context = EXPAND_SETTINGS;\n  if (*arg == NUL) {\n    xp->xp_pattern = arg;\n    return;\n  }\n  p = arg + STRLEN(arg) - 1;\n  if (*p == ' ' && *(p - 1) != '\\\\') {\n    xp->xp_pattern = p + 1;\n    return;\n  }\n  while (p > arg) {\n    s = p;\n    /* count number of backslashes before ' ' or ',' */\n    if (*p == ' ' || *p == ',') {\n      while (s > arg && *(s - 1) == '\\\\')\n        --s;\n    }\n    /* break at a space with an even number of backslashes */\n    if (*p == ' ' && ((p - s) & 1) == 0) {\n      ++p;\n      break;\n    }\n    --p;\n  }\n  if (STRNCMP(p, \"no\", 2) == 0) {\n    xp->xp_context = EXPAND_BOOL_SETTINGS;\n    p += 2;\n  }\n  if (STRNCMP(p, \"inv\", 3) == 0) {\n    xp->xp_context = EXPAND_BOOL_SETTINGS;\n    p += 3;\n  }\n  xp->xp_pattern = arg = p;\n  if (*arg == '<') {\n    while (*p != '>')\n      if (*p++ == NUL)              /* expand terminal option name */\n        return;\n    key = get_special_key_code(arg + 1);\n    if (key == 0) {                 /* unknown name */\n      xp->xp_context = EXPAND_NOTHING;\n      return;\n    }\n    nextchar = *++p;\n    is_term_option = TRUE;\n    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);\n    expand_option_name[3] = KEY2TERMCAP1(key);\n  } else {\n    if (p[0] == 't' && p[1] == '_') {\n      p += 2;\n      if (*p != NUL)\n        ++p;\n      if (*p == NUL)\n        return;                 /* expand option name */\n      nextchar = *++p;\n      is_term_option = TRUE;\n      expand_option_name[2] = p[-2];\n      expand_option_name[3] = p[-1];\n    } else {\n      /* Allow * wildcard */\n      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')\n        p++;\n      if (*p == NUL)\n        return;\n      nextchar = *p;\n      *p = NUL;\n      opt_idx = findoption(arg);\n      *p = nextchar;\n      if (opt_idx == -1 || options[opt_idx].var == NULL) {\n        xp->xp_context = EXPAND_NOTHING;\n        return;\n      }\n      flags = options[opt_idx].flags;\n      if (flags & P_BOOL) {\n        xp->xp_context = EXPAND_NOTHING;\n        return;\n      }\n    }\n  }\n  /* handle \"-=\" and \"+=\" */\n  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=') {\n    ++p;\n    nextchar = '=';\n  }\n  if ((nextchar != '=' && nextchar != ':')\n      || xp->xp_context == EXPAND_BOOL_SETTINGS) {\n    xp->xp_context = EXPAND_UNSUCCESSFUL;\n    return;\n  }\n  if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL) {\n    xp->xp_context = EXPAND_OLD_SETTING;\n    if (is_term_option)\n      expand_option_idx = -1;\n    else\n      expand_option_idx = opt_idx;\n    xp->xp_pattern = p + 1;\n    return;\n  }\n  xp->xp_context = EXPAND_NOTHING;\n  if (is_term_option || (flags & P_NUM))\n    return;\n\n  xp->xp_pattern = p + 1;\n\n  if (flags & P_EXPAND) {\n    p = options[opt_idx].var;\n    if (p == (char_u *)&p_bdir\n        || p == (char_u *)&p_dir\n        || p == (char_u *)&p_path\n        || p == (char_u *)&p_pp\n        || p == (char_u *)&p_rtp\n        || p == (char_u *)&p_cdpath\n        || p == (char_u *)&p_vdir\n        ) {\n      xp->xp_context = EXPAND_DIRECTORIES;\n      if (p == (char_u *)&p_path\n          || p == (char_u *)&p_cdpath\n          )\n        xp->xp_backslash = XP_BS_THREE;\n      else\n        xp->xp_backslash = XP_BS_ONE;\n    } else {\n      xp->xp_context = EXPAND_FILES;\n      /* for 'tags' need three backslashes for a space */\n      if (p == (char_u *)&p_tags)\n        xp->xp_backslash = XP_BS_THREE;\n      else\n        xp->xp_backslash = XP_BS_ONE;\n    }\n  }\n\n  /* For an option that is a list of file names, find the start of the\n   * last file name. */\n  for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p) {\n    /* count number of backslashes before ' ' or ',' */\n    if (*p == ' ' || *p == ',') {\n      s = p;\n      while (s > xp->xp_pattern && *(s - 1) == '\\\\')\n        --s;\n      if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n          || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0)) {\n        xp->xp_pattern = p + 1;\n        break;\n      }\n    }\n\n    /* for 'spellsuggest' start at \"file:\" */\n    if (options[opt_idx].var == (char_u *)&p_sps\n        && STRNCMP(p, \"file:\", 5) == 0) {\n      xp->xp_pattern = p + 5;\n      break;\n    }\n  }\n\n  return;\n}\n\nint ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)\n{\n  int num_normal = 0;  // Nr of matching non-term-code settings\n  int match;\n  int count = 0;\n  char_u      *str;\n  int loop;\n  static char *(names[]) = {\"all\", \"termcap\"};\n  int ic = regmatch->rm_ic;             /* remember the ignore-case flag */\n\n  /* do this loop twice:\n   * loop == 0: count the number of matching options\n   * loop == 1: copy the matching options into allocated memory\n   */\n  for (loop = 0; loop <= 1; ++loop) {\n    regmatch->rm_ic = ic;\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS) {\n      for (match = 0; match < (int)ARRAY_SIZE(names);\n           ++match)\n        if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0)) {\n          if (loop == 0)\n            num_normal++;\n          else\n            (*file)[count++] = vim_strsave((char_u *)names[match]);\n        }\n    }\n    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n         opt_idx++) {\n      if (options[opt_idx].var == NULL)\n        continue;\n      if (xp->xp_context == EXPAND_BOOL_SETTINGS\n          && !(options[opt_idx].flags & P_BOOL))\n        continue;\n      match = FALSE;\n      if (vim_regexec(regmatch, str, (colnr_T)0)\n          || (options[opt_idx].shortname != NULL\n              && vim_regexec(regmatch,\n                  (char_u *)options[opt_idx].shortname, (colnr_T)0))){\n        match = TRUE;\n      }\n\n      if (match) {\n        if (loop == 0) {\n          num_normal++;\n        } else\n          (*file)[count++] = vim_strsave(str);\n      }\n    }\n\n    if (loop == 0) {\n      if (num_normal > 0) {\n        *num_file = num_normal;\n      } else {\n        return OK;\n      }\n      *file = (char_u **)xmalloc((size_t)(*num_file) * sizeof(char_u *));\n    }\n  }\n  return OK;\n}\n\nvoid ExpandOldSetting(int *num_file, char_u ***file)\n{\n  char_u *var = NULL;\n\n  *num_file = 0;\n  *file = (char_u **)xmalloc(sizeof(char_u *));\n\n  /*\n   * For a terminal key code expand_option_idx is < 0.\n   */\n  if (expand_option_idx < 0) {\n    expand_option_idx = findoption(expand_option_name);\n  }\n\n  if (expand_option_idx >= 0) {\n    /* put string of option value in NameBuff */\n    option_value2string(&options[expand_option_idx], expand_option_flags);\n    var = NameBuff;\n  } else if (var == NULL)\n    var = (char_u *)\"\";\n\n  /* A backslash is required before some characters.  This is the reverse of\n   * what happens in do_set(). */\n  char_u *buf = vim_strsave_escaped(var, escape_chars);\n\n#ifdef BACKSLASH_IN_FILENAME\n  /* For MS-Windows et al. we don't double backslashes at the start and\n   * before a file name character. */\n  for (var = buf; *var != NUL; mb_ptr_adv(var))\n    if (var[0] == '\\\\' && var[1] == '\\\\'\n        && expand_option_idx >= 0\n        && (options[expand_option_idx].flags & P_EXPAND)\n        && vim_isfilec(var[2])\n        && (var[2] != '\\\\' || (var == buf && var[4] != '\\\\')))\n      STRMOVE(var, var + 1);\n#endif\n\n  *file[0] = buf;\n  *num_file = 1;\n}\n\n/*\n * Get the value for the numeric or string option *opp in a nice format into\n * NameBuff[].  Must not be called with a hidden option!\n */\nstatic void \noption_value2string (\n    vimoption_T *opp,\n    int opt_flags                          /* OPT_GLOBAL and/or OPT_LOCAL */\n)\n{\n  char_u      *varp;\n\n  varp = get_varp_scope(opp, opt_flags);\n\n  if (opp->flags & P_NUM) {\n    long wc = 0;\n\n    if (wc_use_keyname(varp, &wc)) {\n      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));\n    } else if (wc != 0) {\n      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));\n    } else {\n      snprintf((char *)NameBuff,\n               sizeof(NameBuff),\n               \"%\" PRId64,\n               (int64_t)*(long *)varp);\n    }\n  } else {  // P_STRING\n    varp = *(char_u **)(varp);\n    if (varp == NULL)                       /* just in case */\n      NameBuff[0] = NUL;\n    else if (opp->flags & P_EXPAND)\n      home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);\n    /* Translate 'pastetoggle' into special key names */\n    else if ((char_u **)opp->var == &p_pt)\n      str2specialbuf(p_pt, NameBuff, MAXPATHL);\n    else\n      STRLCPY(NameBuff, varp, MAXPATHL);\n  }\n}\n\n/*\n * Return TRUE if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n * printed as a keyname.\n * \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\n */\nstatic int wc_use_keyname(char_u *varp, long *wcp)\n{\n  if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm)) {\n    *wcp = *(long *)varp;\n    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)\n      return TRUE;\n  }\n  return FALSE;\n}\n\n/*\n * Any character has an equivalent 'langmap' character.  This is used for\n * keyboards that have a special language mode that sends characters above\n * 128 (although other characters can be translated too).  The \"to\" field is a\n * Vim command character.  This avoids having to switch the keyboard back to\n * ASCII mode when leaving Insert mode.\n *\n * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim\n * commands.\n * langmap_mapga.ga_data is a sorted table of langmap_entry_T. \n * This does the same as langmap_mapchar[] for characters >= 256.\n */\n/*\n * With multi-byte support use growarray for 'langmap' chars >= 256\n */\ntypedef struct {\n  int from;\n  int to;\n} langmap_entry_T;\n\nstatic garray_T langmap_mapga = GA_EMPTY_INIT_VALUE;\n\n/*\n * Search for an entry in \"langmap_mapga\" for \"from\".  If found set the \"to\"\n * field.  If not found insert a new entry at the appropriate location.\n */\nstatic void langmap_set_entry(int from, int to)\n{\n  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);\n  unsigned int a = 0;\n  assert(langmap_mapga.ga_len >= 0);\n  unsigned int b = (unsigned int)langmap_mapga.ga_len;\n\n  /* Do a binary search for an existing entry. */\n  while (a != b) {\n    unsigned int i = (a + b) / 2;\n    int d = entries[i].from - from;\n\n    if (d == 0) {\n      entries[i].to = to;\n      return;\n    }\n    if (d < 0)\n      a = i + 1;\n    else\n      b = i;\n  }\n\n  ga_grow(&langmap_mapga, 1);\n\n  /* insert new entry at position \"a\" */\n  entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;\n  memmove(entries + 1, entries,\n          ((unsigned int)langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));\n  ++langmap_mapga.ga_len;\n  entries[0].from = from;\n  entries[0].to = to;\n}\n\n/*\n * Apply 'langmap' to multi-byte character \"c\" and return the result.\n */\nint langmap_adjust_mb(int c)\n{\n  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);\n  int a = 0;\n  int b = langmap_mapga.ga_len;\n\n  while (a != b) {\n    int i = (a + b) / 2;\n    int d = entries[i].from - c;\n\n    if (d == 0)\n      return entries[i].to;        /* found matching entry */\n    if (d < 0)\n      a = i + 1;\n    else\n      b = i;\n  }\n  return c;    /* no entry found, return \"c\" unmodified */\n}\n\nstatic void langmap_init(void)\n{\n  for (int i = 0; i < 256; i++)\n    langmap_mapchar[i] = (char_u)i;      /* we init with a one-to-one map */\n  ga_init(&langmap_mapga, sizeof(langmap_entry_T), 8);\n}\n\n/*\n * Called when langmap option is set; the language map can be\n * changed at any time!\n */\nstatic void langmap_set(void)\n{\n  char_u  *p;\n  char_u  *p2;\n  int from, to;\n\n  ga_clear(&langmap_mapga);                 /* clear the previous map first */\n  langmap_init();                           /* back to one-to-one map */\n\n  for (p = p_langmap; p[0] != NUL; ) {\n    for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';\n         mb_ptr_adv(p2)) {\n      if (p2[0] == '\\\\' && p2[1] != NUL)\n        ++p2;\n    }\n    if (p2[0] == ';')\n      ++p2;                 /* abcd;ABCD form, p2 points to A */\n    else\n      p2 = NULL;            /* aAbBcCdD form, p2 is NULL */\n    while (p[0]) {\n      if (p[0] == ',') {\n        ++p;\n        break;\n      }\n      if (p[0] == '\\\\' && p[1] != NUL)\n        ++p;\n      from = (*mb_ptr2char)(p);\n      to = NUL;\n      if (p2 == NULL) {\n        mb_ptr_adv(p);\n        if (p[0] != ',') {\n          if (p[0] == '\\\\')\n            ++p;\n          to = (*mb_ptr2char)(p);\n        }\n      } else {\n        if (p2[0] != ',') {\n          if (p2[0] == '\\\\')\n            ++p2;\n          to = (*mb_ptr2char)(p2);\n        }\n      }\n      if (to == NUL) {\n        EMSG2(_(\"E357: 'langmap': Matching character missing for %s\"),\n            transchar(from));\n        return;\n      }\n\n      if (from >= 256)\n        langmap_set_entry(from, to);\n      else {\n        assert(to <= UCHAR_MAX);\n        langmap_mapchar[from & 255] = (char_u)to;\n      }\n\n      /* Advance to next pair */\n      mb_ptr_adv(p);\n      if (p2 != NULL) {\n        mb_ptr_adv(p2);\n        if (*p == ';') {\n          p = p2;\n          if (p[0] != NUL) {\n            if (p[0] != ',') {\n              EMSG2(_(\n                      \"E358: 'langmap': Extra characters after semicolon: %s\"),\n                  p);\n              return;\n            }\n            ++p;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\n/*\n * Return TRUE if format option 'x' is in effect.\n * Take care of no formatting when 'paste' is set.\n */\nint has_format_option(int x)\n{\n  if (p_paste)\n    return FALSE;\n  return vim_strchr(curbuf->b_p_fo, x) != NULL;\n}\n\n/// @returns true if \"x\" is present in 'shortmess' option, or\n/// 'shortmess' contains 'a' and \"x\" is present in SHM_ALL_ABBREVIATIONS.\nbool shortmess(int x)\n{\n  return (p_shm != NULL\n          && (vim_strchr(p_shm, x) != NULL\n              || (vim_strchr(p_shm, 'a') != NULL\n                  && vim_strchr((char_u *)SHM_ALL_ABBREVIATIONS, x) != NULL)));\n}\n\n/*\n * paste_option_changed() - Called after p_paste was set or reset.\n */\nstatic void paste_option_changed(void)\n{\n  static int old_p_paste = FALSE;\n  static int save_sm = 0;\n  static int save_sta = 0;\n  static int save_ru = 0;\n  static int save_ri = 0;\n  static int save_hkmap = 0;\n\n  if (p_paste) {\n    /*\n     * Paste switched from off to on.\n     * Save the current values, so they can be restored later.\n     */\n    if (!old_p_paste) {\n      /* save options for each buffer */\n      FOR_ALL_BUFFERS(buf) {\n        buf->b_p_tw_nopaste = buf->b_p_tw;\n        buf->b_p_wm_nopaste = buf->b_p_wm;\n        buf->b_p_sts_nopaste = buf->b_p_sts;\n        buf->b_p_ai_nopaste = buf->b_p_ai;\n        buf->b_p_et_nopaste = buf->b_p_et;\n      }\n\n      // save global options\n      save_sm = p_sm;\n      save_sta = p_sta;\n      save_ru = p_ru;\n      save_ri = p_ri;\n      save_hkmap = p_hkmap;\n      // save global values for local buffer options\n      p_ai_nopaste = p_ai;\n      p_et_nopaste = p_et;\n      p_sts_nopaste = p_sts;\n      p_tw_nopaste = p_tw;\n      p_wm_nopaste = p_wm;\n    }\n\n    // Always set the option values, also when 'paste' is set when it is\n    // already on.\n    // set options for each buffer\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_p_tw = 0;              // textwidth is 0\n      buf->b_p_wm = 0;              // wrapmargin is 0\n      buf->b_p_sts = 0;             // softtabstop is 0\n      buf->b_p_ai = 0;              // no auto-indent\n      buf->b_p_et = 0;              // no expandtab\n    }\n\n    // set global options\n    p_sm = 0;                       // no showmatch\n    p_sta = 0;                      // no smarttab\n    if (p_ru) {\n      status_redraw_all();          // redraw to remove the ruler\n    }\n    p_ru = 0;                       // no ruler\n    p_ri = 0;                       // no reverse insert\n    p_hkmap = 0;                    // no Hebrew keyboard\n    // set global values for local buffer options\n    p_tw = 0;\n    p_wm = 0;\n    p_sts = 0;\n    p_ai = 0;\n  }\n  /*\n   * Paste switched from on to off: Restore saved values.\n   */\n  else if (old_p_paste) {\n    /* restore options for each buffer */\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_p_tw = buf->b_p_tw_nopaste;\n      buf->b_p_wm = buf->b_p_wm_nopaste;\n      buf->b_p_sts = buf->b_p_sts_nopaste;\n      buf->b_p_ai = buf->b_p_ai_nopaste;\n      buf->b_p_et = buf->b_p_et_nopaste;\n    }\n\n    /* restore global options */\n    p_sm = save_sm;\n    p_sta = save_sta;\n    if (p_ru != save_ru) {\n      status_redraw_all();          // redraw to draw the ruler\n    }\n    p_ru = save_ru;\n    p_ri = save_ri;\n    p_hkmap = save_hkmap;\n    // set global values for local buffer options\n    p_ai = p_ai_nopaste;\n    p_et = p_et_nopaste;\n    p_sts = p_sts_nopaste;\n    p_tw = p_tw_nopaste;\n    p_wm = p_wm_nopaste;\n  }\n\n  old_p_paste = p_paste;\n}\n\n/// vimrc_found() - Called when a vimrc or \"VIMINIT\" has been found.\n///\n/// Set the values for options that didn't get set yet to the Vim defaults.\n/// When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\nvoid vimrc_found(char_u *fname, char_u *envname)\n{\n  char_u      *p;\n\n  if (fname != NULL) {\n    p = (char_u *)vim_getenv((char *)envname);\n    if (p == NULL) {\n      /* Set $MYVIMRC to the first vimrc file found. */\n      p = (char_u *)FullName_save((char *)fname, FALSE);\n      if (p != NULL) {\n        vim_setenv((char *)envname, (char *)p);\n        xfree(p);\n      }\n    } else {\n      xfree(p);\n    }\n  }\n}\n\n/*\n * Return TRUE when option \"name\" has been set.\n * Only works correctly for global options.\n */\nint option_was_set(char_u *name)\n{\n  int idx;\n\n  idx = findoption(name);\n  if (idx < 0)          /* unknown option */\n    return FALSE;\n  if (options[idx].flags & P_WAS_SET)\n    return TRUE;\n  return FALSE;\n}\n\n/*\n * fill_breakat_flags() -- called when 'breakat' changes value.\n */\nstatic void fill_breakat_flags(void)\n{\n  char_u      *p;\n  int i;\n\n  for (i = 0; i < 256; i++)\n    breakat_flags[i] = FALSE;\n\n  if (p_breakat != NULL)\n    for (p = p_breakat; *p; p++)\n      breakat_flags[*p] = TRUE;\n}\n\n/*\n * Check an option that can be a range of string values.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\nstatic int check_opt_strings(\n    char_u *val,\n    char **values,\n    int list                   /* when TRUE: accept a list of values */\n)\n{\n  return opt_strings_flags(val, values, NULL, list);\n}\n\n/*\n * Handle an option that can be a range of string values.\n * Set a flag in \"*flagp\" for each string present.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\nstatic int opt_strings_flags(\n    char_u *val,             /* new value */\n    char **values,           /* array of valid string values */\n    unsigned *flagp,\n    bool list                /* when TRUE: accept a list of values */\n)\n{\n  unsigned int new_flags = 0;\n\n  while (*val) {\n    for (unsigned int i = 0;; ++i) {\n      if (values[i] == NULL)            /* val not found in values[] */\n        return FAIL;\n\n      size_t len = STRLEN(values[i]);\n      if (STRNCMP(values[i], val, len) == 0\n          && ((list && val[len] == ',') || val[len] == NUL)) {\n        val += len + (val[len] == ',');\n        assert(i < sizeof(1U) * 8);\n        new_flags |= (1U << i);\n        break;                  /* check next item in val list */\n      }\n    }\n  }\n  if (flagp != NULL)\n    *flagp = new_flags;\n\n  return OK;\n}\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\nstatic int check_opt_wim(void)\n{\n  char_u new_wim_flags[4];\n  char_u      *p;\n  int i;\n  int idx = 0;\n\n  for (i = 0; i < 4; ++i)\n    new_wim_flags[i] = 0;\n\n  for (p = p_wim; *p; ++p) {\n    for (i = 0; ASCII_ISALPHA(p[i]); ++i)\n      ;\n    if (p[i] != NUL && p[i] != ',' && p[i] != ':')\n      return FAIL;\n    if (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n      new_wim_flags[idx] |= WIM_LONGEST;\n    else if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n      new_wim_flags[idx] |= WIM_FULL;\n    else if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n      new_wim_flags[idx] |= WIM_LIST;\n    else\n      return FAIL;\n    p += i;\n    if (*p == NUL)\n      break;\n    if (*p == ',') {\n      if (idx == 3)\n        return FAIL;\n      ++idx;\n    }\n  }\n\n  /* fill remaining entries with last flag */\n  while (idx < 3) {\n    new_wim_flags[idx + 1] = new_wim_flags[idx];\n    ++idx;\n  }\n\n  /* only when there are no errors, wim_flags[] is changed */\n  for (i = 0; i < 4; ++i)\n    wim_flags[i] = new_wim_flags[i];\n  return OK;\n}\n\n/*\n * Check if backspacing over something is allowed.\n * The parameter what is one of the following: whatBS_INDENT, BS_EOL \n * or BS_START\n */\nbool can_bs(int what)\n{\n  switch (*p_bs) {\n  case '2':       return TRUE;\n  case '1':       return what != BS_START;\n  case '0':       return FALSE;\n  }\n  return vim_strchr(p_bs, what) != NULL;\n}\n\n/*\n * Save the current values of 'fileformat' and 'fileencoding', so that we know\n * the file must be considered changed when the value is different.\n */\nvoid save_file_ff(buf_T *buf)\n{\n  buf->b_start_ffc = *buf->b_p_ff;\n  buf->b_start_eol = buf->b_p_eol;\n  buf->b_start_bomb = buf->b_p_bomb;\n\n  /* Only use free/alloc when necessary, they take time. */\n  if (buf->b_start_fenc == NULL\n      || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0) {\n    xfree(buf->b_start_fenc);\n    buf->b_start_fenc = vim_strsave(buf->b_p_fenc);\n  }\n}\n\n/*\n * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value\n * from when editing started (save_file_ff() called).\n * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was\n * changed and 'binary' is not set.\n * Also when 'endofline' was changed and 'fixeol' is not set.\n * When \"ignore_empty\" is true don't consider a new, empty buffer to be\n * changed.\n */\nbool file_ff_differs(buf_T *buf, bool ignore_empty)\n{\n  /* In a buffer that was never loaded the options are not valid. */\n  if (buf->b_flags & BF_NEVERLOADED)\n    return FALSE;\n  if (ignore_empty\n      && (buf->b_flags & BF_NEW)\n      && buf->b_ml.ml_line_count == 1\n      && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)\n    return FALSE;\n  if (buf->b_start_ffc != *buf->b_p_ff)\n    return true;\n  if ((buf->b_p_bin || !buf->b_p_fixeol) && buf->b_start_eol != buf->b_p_eol)\n    return true;\n  if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)\n    return TRUE;\n  if (buf->b_start_fenc == NULL)\n    return *buf->b_p_fenc != NUL;\n  return STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0;\n}\n\n/*\n * return OK if \"p\" is a valid fileformat name, FAIL otherwise.\n */\nint check_ff_value(char_u *p)\n{\n  return check_opt_strings(p, p_ff_values, FALSE);\n}\n\n/*\n * Return the effective shiftwidth value for current buffer, using the\n * 'tabstop' value when 'shiftwidth' is zero.\n */\nint get_sw_value(buf_T *buf)\n{\n  long result = buf->b_p_sw ? buf->b_p_sw : buf->b_p_ts;\n  assert(result >= 0 && result <= INT_MAX);\n  return (int)result;\n}\n\n// Return the effective softtabstop value for the current buffer,\n// using the effective shiftwidth  value when 'softtabstop' is negative.\nint get_sts_value(void)\n{\n  long result = curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n  assert(result >= 0 && result <= INT_MAX);\n  return (int)result;\n}\n\n/*\n * Check matchpairs option for \"*initc\".\n * If there is a match set \"*initc\" to the matching character and \"*findc\" to\n * the opposite character.  Set \"*backwards\" to the direction.\n * When \"switchit\" is TRUE swap the direction.\n */\nvoid find_mps_values(int *initc, int *findc, int *backwards, int switchit)\n{\n  char_u      *ptr;\n\n  ptr = curbuf->b_p_mps;\n  while (*ptr != NUL) {\n    if (has_mbyte) {\n      char_u *prev;\n\n      if (mb_ptr2char(ptr) == *initc) {\n        if (switchit) {\n          *findc = *initc;\n          *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n          *backwards = TRUE;\n        } else {\n          *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n          *backwards = FALSE;\n        }\n        return;\n      }\n      prev = ptr;\n      ptr += mb_ptr2len(ptr) + 1;\n      if (mb_ptr2char(ptr) == *initc) {\n        if (switchit) {\n          *findc = *initc;\n          *initc = mb_ptr2char(prev);\n          *backwards = FALSE;\n        } else {\n          *findc = mb_ptr2char(prev);\n          *backwards = TRUE;\n        }\n        return;\n      }\n      ptr += mb_ptr2len(ptr);\n    } else {\n      if (*ptr == *initc) {\n        if (switchit) {\n          *backwards = TRUE;\n          *findc = *initc;\n          *initc = ptr[2];\n        } else {\n          *backwards = FALSE;\n          *findc = ptr[2];\n        }\n        return;\n      }\n      ptr += 2;\n      if (*ptr == *initc) {\n        if (switchit) {\n          *backwards = FALSE;\n          *findc = *initc;\n          *initc = ptr[-2];\n        } else {\n          *backwards = TRUE;\n          *findc =  ptr[-2];\n        }\n        return;\n      }\n      ++ptr;\n    }\n    if (*ptr == ',')\n      ++ptr;\n  }\n}\n\n/// This is called when 'breakindentopt' is changed and when a window is\n/// initialized\nstatic bool briopt_check(win_T *wp)\n{\n  int bri_shift = 0;\n  int bri_min = 20;\n  bool bri_sbr = false;\n\n  char_u *p = wp->w_p_briopt;\n  while (*p != NUL)\n  {\n    if (STRNCMP(p, \"shift:\", 6) == 0\n        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))\n    {\n      p += 6;\n      bri_shift = getdigits_int(&p);\n    }\n    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))\n    {\n      p += 4;\n      bri_min = getdigits_int(&p);\n    }\n    else if (STRNCMP(p, \"sbr\", 3) == 0)\n    {\n      p += 3;\n      bri_sbr = true;\n    }\n    if (*p != ',' && *p != NUL)\n      return false;\n    if (*p == ',')\n      ++p;\n  }\n\n  wp->w_p_brishift = bri_shift;\n  wp->w_p_brimin   = bri_min;\n  wp->w_p_brisbr   = bri_sbr;\n\n  return true;\n}\n\n/// Get the local or global value of 'backupcopy'.\n///\n/// @param buf The buffer.\nunsigned int get_bkc_value(buf_T *buf)\n{\n  return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.\nint get_fileformat(buf_T *buf)\n{\n  int c = *buf->b_p_ff;\n\n  if (buf->b_p_bin || c == 'u') {\n    return EOL_UNIX;\n  }\n  if (c == 'm') {\n    return EOL_MAC;\n  }\n  return EOL_DOS;\n}\n\n/// Like get_fileformat(), but override 'fileformat' with \"p\" for \"++opt=val\"\n/// argument.\n///\n/// @param eap  can be NULL!\nint get_fileformat_force(buf_T *buf, exarg_T *eap)\n{\n  int c;\n\n  if (eap != NULL && eap->force_ff != 0) {\n    c = eap->cmd[eap->force_ff];\n  } else {\n    if ((eap != NULL && eap->force_bin != 0)\n        ? (eap->force_bin == FORCE_BIN) : buf->b_p_bin) {\n      return EOL_UNIX;\n    }\n    c = *buf->b_p_ff;\n  }\n  if (c == 'u') {\n    return EOL_UNIX;\n  }\n  if (c == 'm') {\n    return EOL_MAC;\n  }\n  return EOL_DOS;\n}\n\n/// Return the default fileformat from 'fileformats'.\nint default_fileformat(void)\n{\n  switch (*p_ffs) {\n  case 'm':   return EOL_MAC;\n  case 'd':   return EOL_DOS;\n  }\n  return EOL_UNIX;\n}\n\n/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.\n///\n/// Sets 'fileformat'.\n///\n/// @param eol_style End-of-line style.\n/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL\nvoid set_fileformat(int eol_style, int opt_flags)\n{\n  char *p = NULL;\n\n  switch (eol_style) {\n      case EOL_UNIX:\n          p = FF_UNIX;\n          break;\n      case EOL_MAC:\n          p = FF_MAC;\n          break;\n      case EOL_DOS:\n          p = FF_DOS;\n          break;\n  }\n\n  // p is NULL if \"eol_style\" is EOL_UNKNOWN.\n  if (p != NULL) {\n    set_string_option_direct((char_u *)\"ff\",\n                             -1,\n                             (char_u *)p,\n                             OPT_FREE | opt_flags,\n                             0);\n  }\n\n  // This may cause the buffer to become (un)modified.\n  check_status(curbuf);\n  redraw_tabline = true;\n  need_maketitle = true;  // Set window title later.\n}\n\n/// Skip to next part of an option argument: Skip space and comma.\nchar_u *skip_to_option_part(char_u *p)\n{\n  if (*p == ',') {\n    p++;\n  }\n  while (*p == ' ') {\n    p++;\n  }\n  return p;\n}\n\n/// Isolate one part of a string option separated by `sep_chars`.\n///\n/// @param[in,out]  option    advanced to the next part\n/// @param[in,out]  buf       copy of the isolated part\n/// @param[in]      maxlen    length of `buf`\n/// @param[in]      sep_chars chars that separate the option parts\n///\n/// @return length of `*option`\nsize_t copy_option_part(char_u **option, char_u *buf, size_t maxlen,\n                        char *sep_chars)\n{\n  size_t len = 0;\n  char_u  *p = *option;\n\n  // skip '.' at start of option part, for 'suffixes'\n  if (*p == '.') {\n    buf[len++] = *p++;\n  }\n  while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL) {\n    // Skip backslash before a separator character and space.\n    if (p[0] == '\\\\' && vim_strchr((char_u *)sep_chars, p[1]) != NULL) {\n      p++;\n    }\n    if (len < maxlen - 1) {\n      buf[len++] = *p;\n    }\n    p++;\n  }\n  buf[len] = NUL;\n\n  if (*p != NUL && *p != ',') {  // skip non-standard separator\n    p++;\n  }\n  p = skip_to_option_part(p);    // p points to next file name\n\n  *option = p;\n  return len;\n}\n\n/// Return TRUE when 'shell' has \"csh\" in the tail.\nint csh_like_shell(void)\n{\n  return strstr((char *)path_tail(p_sh), \"csh\") != NULL;\n}\n\n", "\" Test for options\n\nfunction! Test_whichwrap()\n  set whichwrap=b,s\n  call assert_equal('b,s', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap&\nendfunction\n\nfunction! Test_options()\n  let caught = 'ok'\n  try\n    options\n  catch\n    let caught = v:throwpoint . \"\\n\" . v:exception\n  endtry\n  call assert_equal('ok', caught)\n\n  \" close option-window\n  close\nendfunction\n\nfunction! Test_path_keep_commas()\n  \" Test that changing 'path' keeps two commas.\n  set path=foo,,bar\n  set path-=bar\n  set path+=bar\n  call assert_equal('foo,,bar', &path)\n\n  set path&\nendfunction\n"], "fixing_code": ["/*\n * Code to handle user-settable options. This is all pretty much table-\n * driven. Checklist for adding a new option:\n * - Put it in the options array below (copy an existing entry).\n * - For a global option: Add a variable for it in option_defs.h.\n * - For a buffer or window local option:\n *   - Add a PV_XX entry to the enum below.\n *   - Add a variable to the window or buffer struct in buffer_defs.h.\n *   - For a window option, add some code to copy_winopt().\n *   - For a buffer option, add some code to buf_copy_options().\n *   - For a buffer string option, add code to check_buf_options().\n * - If it's a numeric option, add any necessary bounds checks to do_set().\n * - If it's a list of flags, add some code in do_set(), search for WW_ALL.\n * - When adding an option with expansion (P_EXPAND), but with a different\n *   default for Vi and Vim (no P_VI_DEF), add some code at VIMEXP.\n * - Add documentation!  One line in doc/help.txt, full description in\n *   options.txt, and any other related places.\n * - Add an entry in runtime/optwin.vim.\n * When making changes:\n * - Adjust the help for the option in doc/option.txt.\n */\n\n#define IN_OPTION_C\n#include <assert.h>\n#include <inttypes.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/ascii.h\"\n#include \"nvim/edit.h\"\n#include \"nvim/option.h\"\n#include \"nvim/buffer.h\"\n#include \"nvim/charset.h\"\n#include \"nvim/cursor.h\"\n#include \"nvim/diff.h\"\n#include \"nvim/digraph.h\"\n#include \"nvim/eval.h\"\n#include \"nvim/ex_cmds2.h\"\n#include \"nvim/ex_docmd.h\"\n#include \"nvim/ex_getln.h\"\n#include \"nvim/fileio.h\"\n#include \"nvim/fold.h\"\n#include \"nvim/getchar.h\"\n#include \"nvim/hardcopy.h\"\n#include \"nvim/indent_c.h\"\n#include \"nvim/mbyte.h\"\n#include \"nvim/memfile.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n#include \"nvim/misc1.h\"\n#include \"nvim/keymap.h\"\n#include \"nvim/garray.h\"\n#include \"nvim/cursor_shape.h\"\n#include \"nvim/move.h\"\n#include \"nvim/mouse.h\"\n#include \"nvim/normal.h\"\n#include \"nvim/os_unix.h\"\n#include \"nvim/path.h\"\n#include \"nvim/regexp.h\"\n#include \"nvim/screen.h\"\n#include \"nvim/spell.h\"\n#include \"nvim/strings.h\"\n#include \"nvim/syntax.h\"\n#include \"nvim/ui.h\"\n#include \"nvim/undo.h\"\n#include \"nvim/window.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/input.h\"\n\n/*\n * The options that are local to a window or buffer have \"indir\" set to one of\n * these values.  Special values:\n * PV_NONE: global option.\n * PV_WIN is added: window-local option\n * PV_BUF is added: buffer-local option\n * PV_BOTH is added: global option which also has a local value.\n */\n#define PV_BOTH 0x1000\n#define PV_WIN  0x2000\n#define PV_BUF  0x4000\n#define PV_MASK 0x0fff\n#define OPT_WIN(x)  (idopt_T)(PV_WIN + (int)(x))\n#define OPT_BUF(x)  (idopt_T)(PV_BUF + (int)(x))\n#define OPT_BOTH(x) (idopt_T)(PV_BOTH + (int)(x))\n\n\n/* WV_ and BV_ values get typecasted to this for the \"indir\" field */\ntypedef enum {\n  PV_NONE = 0,\n  PV_MAXVAL = 0xffff      /* to avoid warnings for value out of range */\n} idopt_T;\n\n/*\n * Options local to a window have a value local to a buffer and global to all\n * buffers.  Indicate this by setting \"var\" to VAR_WIN.\n */\n#define VAR_WIN ((char_u *)-1)\n\n/*\n * These are the global values for options which are also local to a buffer.\n * Only to be used in option.c!\n */\nstatic int p_ai;\nstatic int p_bin;\nstatic int p_bomb;\nstatic char_u   *p_bh;\nstatic char_u   *p_bt;\nstatic int p_bl;\nstatic int p_ci;\nstatic int p_cin;\nstatic char_u   *p_cink;\nstatic char_u   *p_cino;\nstatic char_u   *p_cinw;\nstatic char_u   *p_com;\nstatic char_u   *p_cms;\nstatic char_u   *p_cpt;\nstatic char_u   *p_cfu;\nstatic char_u   *p_ofu;\nstatic int p_eol;\nstatic int p_fixeol;\nstatic int p_et;\nstatic char_u   *p_fenc;\nstatic char_u   *p_ff;\nstatic char_u   *p_fo;\nstatic char_u   *p_flp;\nstatic char_u   *p_ft;\nstatic long p_iminsert;\nstatic long p_imsearch;\nstatic char_u   *p_inex;\nstatic char_u   *p_inde;\nstatic char_u   *p_indk;\nstatic char_u   *p_fex;\nstatic int p_inf;\nstatic char_u   *p_isk;\nstatic int p_lisp;\nstatic int p_ml;\nstatic int p_ma;\nstatic int p_mod;\nstatic char_u   *p_mps;\nstatic char_u   *p_nf;\nstatic int p_pi;\nstatic char_u   *p_qe;\nstatic int p_ro;\nstatic int p_si;\nstatic long p_sts;\nstatic char_u   *p_sua;\nstatic long p_sw;\nstatic int p_swf;\nstatic long p_smc;\nstatic char_u   *p_syn;\nstatic char_u   *p_spc;\nstatic char_u   *p_spf;\nstatic char_u   *p_spl;\nstatic long p_ts;\nstatic long p_tw;\nstatic int p_udf;\nstatic long p_wm;\nstatic char_u   *p_keymap;\n\n/* Saved values for when 'bin' is set. */\nstatic int p_et_nobin;\nstatic int p_ml_nobin;\nstatic long p_tw_nobin;\nstatic long p_wm_nobin;\n\n// Saved values for when 'paste' is set.\nstatic int p_ai_nopaste;\nstatic int p_et_nopaste;\nstatic long p_sts_nopaste;\nstatic long p_tw_nopaste;\nstatic long p_wm_nopaste;\n\ntypedef struct vimoption {\n  char        *fullname;        /* full option name */\n  char        *shortname;       /* permissible abbreviation */\n  uint32_t flags;               /* see below */\n  char_u      *var;             /* global option: pointer to variable;\n                                * window-local option: VAR_WIN;\n                                * buffer-local option: global value */\n  idopt_T indir;                /* global option: PV_NONE;\n                                 * local option: indirect option index */\n  char_u      *def_val[2];      /* default values for variable (vi and vim) */\n  scid_T scriptID;              /* script in which the option was last set */\n# define SCRIPTID_INIT , 0\n} vimoption_T;\n\n#define VI_DEFAULT  0       /* def_val[VI_DEFAULT] is Vi default value */\n#define VIM_DEFAULT 1       /* def_val[VIM_DEFAULT] is Vim default value */\n\n/*\n * Flags\n */\n#define P_BOOL          0x01U    /* the option is boolean */\n#define P_NUM           0x02U    /* the option is numeric */\n#define P_STRING        0x04U    /* the option is a string */\n#define P_ALLOCED       0x08U    /* the string option is in allocated memory,\n                                    must use free_string_option() when\n                                    assigning new value. Not set if default is\n                                    the same. */\n#define P_EXPAND        0x10U    /* environment expansion.  NOTE: P_EXPAND can\n                                    never be used for local or hidden options */\n#define P_NODEFAULT     0x40U    /* don't set to default value */\n#define P_DEF_ALLOCED   0x80U    /* default value is in allocated memory, must\n                                    use free() when assigning new value */\n#define P_WAS_SET       0x100U   /* option has been set/reset */\n#define P_NO_MKRC       0x200U   /* don't include in :mkvimrc output */\n#define P_VI_DEF        0x400U   /* Use Vi default for Vim */\n#define P_VIM           0x800U   /* Vim option */\n\n/* when option changed, what to display: */\n#define P_RSTAT         0x1000U  /* redraw status lines */\n#define P_RWIN          0x2000U  /* redraw current window */\n#define P_RBUF          0x4000U  /* redraw current buffer */\n#define P_RALL          0x6000U  /* redraw all windows */\n#define P_RCLR          0x7000U  /* clear and redraw all */\n\n#define P_COMMA         0x8000U    ///< comma separated list\n#define P_ONECOMMA      0x18000U   ///< P_COMMA and cannot have two consecutive\n                                   ///< commas\n#define P_NODUP         0x20000U   ///< don't allow duplicate strings\n#define P_FLAGLIST      0x40000U   ///< list of single-char flags\n\n#define P_SECURE        0x80000U   ///< cannot change in modeline or secure mode\n#define P_GETTEXT       0x100000U  ///< expand default value with _()\n#define P_NOGLOB        0x200000U  ///< do not use local value for global vimrc\n#define P_NFNAME        0x400000U  ///< only normal file name chars allowed\n#define P_INSECURE      0x800000U  ///< option was set from a modeline\n#define P_PRI_MKRC     0x1000000U  ///< priority for :mkvimrc (setting option\n                                   ///< has side effects)\n#define P_NO_ML        0x2000000U  ///< not allowed in modeline\n#define P_CURSWANT     0x4000000U  ///< update curswant required; not needed\n                                   ///< when there is a redraw flag\n#define P_NO_DEF_EXP   0x8000000U  ///< Do not expand default value.\n\n#define HIGHLIGHT_INIT \\\n  \"8:SpecialKey,~:EndOfBuffer,z:TermCursor,Z:TermCursorNC,@:NonText,\" \\\n  \"d:Directory,e:ErrorMsg,i:IncSearch,l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,\" \\\n  \"N:CursorLineNr,r:Question,s:StatusLine,S:StatusLineNC,c:VertSplit,t:Title,\" \\\n  \"v:Visual,w:WarningMsg,W:WildMenu,f:Folded,F:FoldColumn,\" \\\n  \"A:DiffAdd,C:DiffChange,D:DiffDelete,T:DiffText,>:SignColumn,-:Conceal,\" \\\n  \"B:SpellBad,P:SpellCap,R:SpellRare,L:SpellLocal,+:Pmenu,=:PmenuSel,\" \\\n  \"x:PmenuSbar,X:PmenuThumb,*:TabLine,#:TabLineSel,_:TabLineFill,\" \\\n  \"!:CursorColumn,.:CursorLine,o:ColorColumn,q:QuickFixLine\"\n\n/*\n * options[] is initialized here.\n * The order of the options MUST be alphabetic for \":set all\" and findoption().\n * All option names MUST start with a lowercase letter (for findoption()).\n * Exception: \"t_\" options are at the end.\n * The options with a NULL variable are 'hidden': a set command for them is\n * ignored and they are not printed.\n */\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"options.generated.h\"\n#endif\n\n#define PARAM_COUNT ARRAY_SIZE(options)\n\nstatic char *(p_ambw_values[]) =      { \"single\", \"double\", NULL };\nstatic char *(p_bg_values[]) =        { \"light\", \"dark\", NULL };\nstatic char *(p_nf_values[]) =        { \"bin\", \"octal\", \"hex\", \"alpha\", NULL };\nstatic char *(p_ff_values[]) =        { FF_UNIX, FF_DOS, FF_MAC, NULL };\nstatic char *(p_wop_values[]) =       { \"tagfile\", NULL };\nstatic char *(p_wak_values[]) =       { \"yes\", \"menu\", \"no\", NULL };\nstatic char *(p_mousem_values[]) =    { \"extend\", \"popup\", \"popup_setpos\",\n                                        \"mac\", NULL };\nstatic char *(p_sel_values[]) =       { \"inclusive\", \"exclusive\", \"old\", NULL };\nstatic char *(p_slm_values[]) =       { \"mouse\", \"key\", \"cmd\", NULL };\nstatic char *(p_km_values[]) =        { \"startsel\", \"stopsel\", NULL };\nstatic char *(p_scbopt_values[]) =    { \"ver\", \"hor\", \"jump\", NULL };\nstatic char *(p_debug_values[]) =     { \"msg\", \"throw\", \"beep\", NULL };\nstatic char *(p_ead_values[]) =       { \"both\", \"ver\", \"hor\", NULL };\nstatic char *(p_buftype_values[]) =   { \"nofile\", \"nowrite\", \"quickfix\",\n                                        \"help\", \"acwrite\", \"terminal\", NULL };\n\nstatic char *(p_bufhidden_values[]) = { \"hide\", \"unload\", \"delete\",\n                                        \"wipe\", NULL };\nstatic char *(p_bs_values[]) =        { \"indent\", \"eol\", \"start\", NULL };\nstatic char *(p_fdm_values[]) =       { \"manual\", \"expr\", \"marker\", \"indent\",\n                                        \"syntax\",  \"diff\", NULL };\nstatic char *(p_fcl_values[]) =       { \"all\", NULL };\nstatic char *(p_cot_values[]) =       { \"menu\", \"menuone\", \"longest\", \"preview\",\n                                        \"noinsert\", \"noselect\", NULL };\nstatic char *(p_icm_values[]) =       { \"nosplit\", \"split\", NULL };\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"option.c.generated.h\"\n#endif\n\n/// Append string with escaped commas\nstatic char *strcpy_comma_escaped(char *dest, const char *src, const size_t len)\n  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  size_t shift = 0;\n  for (size_t i = 0; i < len; i++) {\n    if (src[i] == ',') {\n      dest[i + shift++] = '\\\\';\n    }\n    dest[i + shift] = src[i];\n  }\n  return &dest[len + shift];\n}\n\n/// Compute length of a colon-separated value, doubled and with some suffixes\n///\n/// @param[in]  val  Colon-separated array value.\n/// @param[in]  common_suf_len  Length of the common suffix which is appended to\n///                             each item in the array, twice.\n/// @param[in]  single_suf_len  Length of the suffix which is appended to each\n///                             item in the array once.\n///\n/// @return Length of the comma-separated string array that contains each item\n///         in the original array twice with suffixes with given length\n///         (common_suf is present after each new item, single_suf is present\n///         after half of the new items) and with commas after each item, commas\n///         inside the values are escaped.\nstatic inline size_t compute_double_colon_len(const char *const val,\n                                              const size_t common_suf_len,\n                                              const size_t single_suf_len)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_PURE\n{\n  if (val == NULL || *val == NUL) {\n    return 0;\n  }\n  size_t ret = 0;\n  const void *iter = NULL;\n  do {\n    size_t dir_len;\n    const char *dir;\n    iter = vim_colon_env_iter(val, iter, &dir, &dir_len);\n    if (dir != NULL && dir_len > 0) {\n      ret += ((dir_len + memcnt(dir, ',', dir_len) + common_suf_len\n               + !after_pathsep(dir, dir + dir_len)) * 2\n              + single_suf_len);\n    }\n  } while (iter != NULL);\n  return ret;\n}\n\n#define NVIM_SIZE (sizeof(\"nvim\") - 1)\n\n/// Add directories to a comma-separated array from a colon-separated one\n///\n/// Commas are escaped in process. To each item PATHSEP \"nvim\" is appended in\n/// addition to suf1 and suf2.\n///\n/// @param[in,out]  dest  Destination comma-separated array.\n/// @param[in]  val  Source colon-separated array.\n/// @param[in]  suf1  If not NULL, suffix appended to destination. Prior to it\n///                   directory separator is appended. Suffix must not contain\n///                   commas.\n/// @param[in]  len1  Length of the suf1.\n/// @param[in]  suf2  If not NULL, another suffix appended to destination. Again\n///                   with directory separator behind. Suffix must not contain\n///                   commas.\n/// @param[in]  len2  Length of the suf2.\n/// @param[in]  forward  If true, iterate over val in forward direction.\n///                      Otherwise in reverse.\n///\n/// @return (dest + appended_characters_length)\nstatic inline char *add_colon_dirs(char *dest, const char *const val,\n                                   const char *const suf1, const size_t len1,\n                                   const char *const suf2, const size_t len2,\n                                   const bool forward)\n  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ARG(1)\n{\n  if (val == NULL || *val == NUL) {\n    return dest;\n  }\n  const void *iter = NULL;\n  do {\n    size_t dir_len;\n    const char *dir;\n    iter = (forward ? vim_colon_env_iter : vim_colon_env_iter_rev)(\n        val, iter, &dir, &dir_len);\n    if (dir != NULL && dir_len > 0) {\n      dest = strcpy_comma_escaped(dest, dir, dir_len);\n      if (!after_pathsep(dest - 1, dest)) {\n        *dest++ = PATHSEP;\n      }\n      memmove(dest, \"nvim\", NVIM_SIZE);\n      dest += NVIM_SIZE;\n      if (suf1 != NULL) {\n        *dest++ = PATHSEP;\n        memmove(dest, suf1, len1);\n        dest += len1;\n        if (suf2 != NULL) {\n          *dest++ = PATHSEP;\n          memmove(dest, suf2, len2);\n          dest += len2;\n        }\n      }\n      *dest++ = ',';\n    }\n  } while (iter != NULL);\n  return dest;\n}\n\n/// Add directory to a comma-separated list of directories\n///\n/// In the added directory comma is escaped.\n///\n/// @param[in,out]  dest  Destination comma-separated array.\n/// @param[in]  dir  Directory to append.\n/// @param[in]  append_nvim  If true, append \"nvim\" as the very first suffix.\n/// @param[in]  suf1  If not NULL, suffix appended to destination. Prior to it\n///                   directory separator is appended. Suffix must not contain\n///                   commas.\n/// @param[in]  len1  Length of the suf1.\n/// @param[in]  suf2  If not NULL, another suffix appended to destination. Again\n///                   with directory separator behind. Suffix must not contain\n///                   commas.\n/// @param[in]  len2  Length of the suf2.\n/// @param[in]  forward  If true, iterate over val in forward direction.\n///                      Otherwise in reverse.\n///\n/// @return (dest + appended_characters_length)\nstatic inline char *add_dir(char *dest, const char *const dir,\n                            const size_t dir_len, const bool append_nvim,\n                            const char *const suf1, const size_t len1,\n                            const char *const suf2, const size_t len2)\n  FUNC_ATTR_NONNULL_RET FUNC_ATTR_NONNULL_ARG(1) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (dir == NULL || dir_len == 0) {\n    return dest;\n  }\n  dest = strcpy_comma_escaped(dest, dir, dir_len);\n  if (append_nvim) {\n    if (!after_pathsep(dest - 1, dest)) {\n      *dest++ = PATHSEP;\n    }\n    memmove(dest, \"nvim\", NVIM_SIZE);\n    dest += NVIM_SIZE;\n    if (suf1 != NULL) {\n      *dest++ = PATHSEP;\n      memmove(dest, suf1, len1);\n      dest += len1;\n      if (suf2 != NULL) {\n        *dest++ = PATHSEP;\n        memmove(dest, suf2, len2);\n        dest += len2;\n      }\n    }\n  }\n  *dest++ = ',';\n  return dest;\n}\n\n/// Set &runtimepath to default value\nstatic void set_runtimepath_default(void)\n{\n  size_t rtp_size = 0;\n  char *const data_home = stdpaths_get_xdg_var(kXDGDataHome);\n  char *const config_home = stdpaths_get_xdg_var(kXDGConfigHome);\n  char *const vimruntime = vim_getenv(\"VIMRUNTIME\");\n  char *const data_dirs = stdpaths_get_xdg_var(kXDGDataDirs);\n  char *const config_dirs = stdpaths_get_xdg_var(kXDGConfigDirs);\n#define SITE_SIZE (sizeof(\"site\") - 1)\n#define AFTER_SIZE (sizeof(\"after\") - 1)\n  size_t data_len = 0;\n  size_t config_len = 0;\n  size_t vimruntime_len = 0;\n  if (data_home != NULL) {\n    data_len = strlen(data_home);\n    if (data_len != 0) {\n      rtp_size += ((data_len + memcnt(data_home, ',', data_len)\n                    + NVIM_SIZE + 1 + SITE_SIZE + 1\n                    + !after_pathsep(data_home, data_home + data_len)) * 2\n                   + AFTER_SIZE + 1);\n    }\n  }\n  if (config_home != NULL) {\n    config_len = strlen(config_home);\n    if (config_len != 0) {\n      rtp_size += ((config_len + memcnt(config_home, ',', config_len)\n                    + NVIM_SIZE + 1\n                    + !after_pathsep(config_home, config_home + config_len)) * 2\n                   + AFTER_SIZE + 1);\n    }\n  }\n  if (vimruntime != NULL) {\n    vimruntime_len = strlen(vimruntime);\n    if (vimruntime_len != 0) {\n      rtp_size += vimruntime_len + memcnt(vimruntime, ',', vimruntime_len) + 1;\n    }\n  }\n  rtp_size += compute_double_colon_len(data_dirs, NVIM_SIZE + 1 + SITE_SIZE + 1,\n                                       AFTER_SIZE + 1);\n  rtp_size += compute_double_colon_len(config_dirs, NVIM_SIZE + 1,\n                                       AFTER_SIZE + 1);\n  if (rtp_size == 0) {\n    return;\n  }\n  char *const rtp = xmalloc(rtp_size);\n  char *rtp_cur = rtp;\n  rtp_cur = add_dir(rtp_cur, config_home, config_len, true, NULL, 0, NULL, 0);\n  rtp_cur = add_colon_dirs(rtp_cur, config_dirs, NULL, 0, NULL, 0, true);\n  rtp_cur = add_dir(rtp_cur, data_home, data_len, true, \"site\", SITE_SIZE,\n                    NULL, 0);\n  rtp_cur = add_colon_dirs(rtp_cur, data_dirs, \"site\", SITE_SIZE, NULL, 0,\n                           true);\n  rtp_cur = add_dir(rtp_cur, vimruntime, vimruntime_len, false, NULL, 0,\n                    NULL, 0);\n  rtp_cur = add_colon_dirs(rtp_cur, data_dirs, \"site\", SITE_SIZE,\n                           \"after\", AFTER_SIZE, false);\n  rtp_cur = add_dir(rtp_cur, data_home, data_len, true, \"site\", SITE_SIZE,\n                    \"after\", AFTER_SIZE);\n  rtp_cur = add_colon_dirs(rtp_cur, config_dirs, \"after\", AFTER_SIZE, NULL, 0,\n                           false);\n  rtp_cur = add_dir(rtp_cur, config_home, config_len, true,\n                    \"after\", AFTER_SIZE, NULL, 0);\n  // Strip trailing comma.\n  rtp_cur[-1] = NUL;\n  assert((size_t) (rtp_cur - rtp) == rtp_size);\n#undef SITE_SIZE\n#undef AFTER_SIZE\n  set_string_default(\"runtimepath\", rtp, true);\n  // Make a copy of 'rtp' for 'packpath'\n  set_string_default(\"packpath\", rtp, false);\n  xfree(data_dirs);\n  xfree(config_dirs);\n  xfree(data_home);\n  xfree(config_home);\n  xfree(vimruntime);\n}\n\n#undef NVIM_SIZE\n\n/*\n * Initialize the options, first part.\n *\n * Called only once from main(), just after creating the first buffer.\n */\nvoid set_init_1(void)\n{\n  int opt_idx;\n\n  langmap_init();\n\n  /* Be nocompatible */\n  p_cp = FALSE;\n\n  /*\n   * Find default value for 'shell' option.\n   * Don't use it if it is empty.\n   */\n  {\n    const char *shell = os_getenv(\"SHELL\");\n    if (shell != NULL) {\n      set_string_default(\"sh\", (char *) shell, false);\n    }\n  }\n\n  /*\n   * Set the default for 'backupskip' to include environment variables for\n   * temp files.\n   */\n  {\n# ifdef UNIX\n    static char     *(names[4]) = {\"\", \"TMPDIR\", \"TEMP\", \"TMP\"};\n# else\n    static char     *(names[3]) = {\"TMPDIR\", \"TEMP\", \"TMP\"};\n# endif\n    int len;\n    garray_T ga;\n\n    ga_init(&ga, 1, 100);\n    for (size_t n = 0; n < ARRAY_SIZE(names); ++n) {\n      bool mustfree = true;\n      char *p;\n# ifdef UNIX\n      if (*names[n] == NUL) {\n        p = \"/tmp\";\n        mustfree = false;\n      }\n      else\n# endif\n      p = vim_getenv(names[n]);\n      if (p != NULL && *p != NUL) {\n        // First time count the NUL, otherwise count the ','.\n        len = (int)strlen(p) + 3;\n        ga_grow(&ga, len);\n        if (!GA_EMPTY(&ga))\n          STRCAT(ga.ga_data, \",\");\n        STRCAT(ga.ga_data, p);\n        add_pathsep(ga.ga_data);\n        STRCAT(ga.ga_data, \"*\");\n        ga.ga_len += len;\n      }\n      if(mustfree) {\n        xfree(p);\n      }\n    }\n    if (ga.ga_data != NULL) {\n      set_string_default(\"bsk\", ga.ga_data, true);\n    }\n  }\n\n  /*\n   * 'maxmemtot' and 'maxmem' may have to be adjusted for available memory\n   */\n  opt_idx = findoption((char_u *)\"maxmemtot\");\n  if (opt_idx >= 0) {\n    {\n      /* Use half of amount of memory available to Vim. */\n      /* If too much to fit in uintptr_t, get uintptr_t max */\n      uint64_t available_kib = os_get_total_mem_kib();\n      uintptr_t n = available_kib / 2 > UINTPTR_MAX\n                    ? UINTPTR_MAX\n                    : (uintptr_t)(available_kib /2);\n      options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n      opt_idx = findoption((char_u *)\"maxmem\");\n      if (opt_idx >= 0) {\n        options[opt_idx].def_val[VI_DEFAULT] = (char_u *)n;\n      }\n    }\n  }\n\n\n  {\n    char_u  *cdpath;\n    char_u  *buf;\n    int i;\n    int j;\n\n    /* Initialize the 'cdpath' option's default value. */\n    cdpath = (char_u *)vim_getenv(\"CDPATH\");\n    if (cdpath != NULL) {\n      buf = xmalloc(2 * STRLEN(cdpath) + 2);\n      {\n        buf[0] = ',';               /* start with \",\", current dir first */\n        j = 1;\n        for (i = 0; cdpath[i] != NUL; ++i) {\n          if (vim_ispathlistsep(cdpath[i]))\n            buf[j++] = ',';\n          else {\n            if (cdpath[i] == ' ' || cdpath[i] == ',')\n              buf[j++] = '\\\\';\n            buf[j++] = cdpath[i];\n          }\n        }\n        buf[j] = NUL;\n        opt_idx = findoption((char_u *)\"cdpath\");\n        if (opt_idx >= 0) {\n          options[opt_idx].def_val[VI_DEFAULT] = buf;\n          options[opt_idx].flags |= P_DEF_ALLOCED;\n        } else\n          xfree(buf);           /* cannot happen */\n      }\n      xfree(cdpath);\n    }\n  }\n\n#if defined(MSWIN) || defined(MAC)\n  /* Set print encoding on platforms that don't default to latin1 */\n  set_string_default(\"printencoding\", \"hp-roman8\", false);\n#endif\n\n  // 'printexpr' must be allocated to be able to evaluate it.\n  set_string_default(\"printexpr\",\n#ifdef UNIX\n                     \"system(['lpr'] \"\n                            \"+ (empty(&printdevice)?[]:['-P', &printdevice]) \"\n                            \"+ [v:fname_in])\"\n                     \". delete(v:fname_in)\"\n                     \"+ v:shell_error\",\n#elif defined(MSWIN)\n                     \"system(['copy', v:fname_in, \"\n                             \"empty(&printdevice)?'LPT1':&printdevice])\"\n                     \". delete(v:fname_in)\",\n#else\n                     \"\",\n#endif\n                     false);\n\n  char *backupdir = stdpaths_user_data_subpath(\"backup\", 0, true);\n  const size_t backupdir_len = strlen(backupdir);\n  backupdir = xrealloc(backupdir, backupdir_len + 3);\n  memmove(backupdir + 2, backupdir, backupdir_len + 1);\n  memmove(backupdir, \".,\", 2);\n  set_string_default(\"viewdir\", stdpaths_user_data_subpath(\"view\", 0, true),\n                     true);\n  set_string_default(\"backupdir\", backupdir, true);\n  set_string_default(\"directory\", stdpaths_user_data_subpath(\"swap\", 2, true),\n                     true);\n  set_string_default(\"undodir\", stdpaths_user_data_subpath(\"undo\", 0, true),\n                     true);\n  // Set default for &runtimepath. All necessary expansions are performed in\n  // this function.\n  set_runtimepath_default();\n\n  /*\n   * Set all the options (except the terminal options) to their default\n   * value.  Also set the global value for local options.\n   */\n  set_options_default(0);\n\n\n  curbuf->b_p_initialized = true;\n  curbuf->b_p_ar = -1;          /* no local 'autoread' value */\n  curbuf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n  check_buf_options(curbuf);\n  check_win_options(curwin);\n  check_options();\n\n  /* Set all options to their Vim default */\n  set_options_default(OPT_FREE);\n\n  // set 'laststatus'\n  last_status(false);\n\n  /* Must be before option_expand(), because that one needs vim_isIDc() */\n  didset_options();\n\n  // Use the current chartab for the generic chartab. This is not in\n  // didset_options() because it only depends on 'encoding'.\n  init_spell_chartab();\n\n  /*\n   * Expand environment variables and things like \"~\" for the defaults.\n   * If option_expand() returns non-NULL the variable is expanded.  This can\n   * only happen for non-indirect options.\n   * Also set the default to the expanded value, so \":set\" does not list\n   * them.\n   * Don't set the P_ALLOCED flag, because we don't want to free the\n   * default.\n   */\n  for (opt_idx = 0; options[opt_idx].fullname; opt_idx++) {\n    if (options[opt_idx].flags & P_NO_DEF_EXP) {\n      continue;\n    }\n    char *p;\n    if ((options[opt_idx].flags & P_GETTEXT)\n        && options[opt_idx].var != NULL) {\n      p = _(*(char **)options[opt_idx].var);\n    } else {\n      p = (char *) option_expand(opt_idx, NULL);\n    }\n    if (p != NULL) {\n      p = xstrdup(p);\n      *(char **)options[opt_idx].var = p;\n      /* VIMEXP\n       * Defaults for all expanded options are currently the same for Vi\n       * and Vim.  When this changes, add some code here!  Also need to\n       * split P_DEF_ALLOCED in two.\n       */\n      if (options[opt_idx].flags & P_DEF_ALLOCED)\n        xfree(options[opt_idx].def_val[VI_DEFAULT]);\n      options[opt_idx].def_val[VI_DEFAULT] = (char_u *) p;\n      options[opt_idx].flags |= P_DEF_ALLOCED;\n    }\n  }\n\n  save_file_ff(curbuf);         /* Buffer is unchanged */\n\n  /* Detect use of mlterm.\n   * Mlterm is a terminal emulator akin to xterm that has some special\n   * abilities (bidi namely).\n   * NOTE: mlterm's author is being asked to 'set' a variable\n   *       instead of an environment variable due to inheritance.\n   */\n  if (os_env_exists(\"MLTERM\"))\n    set_option_value((char_u *)\"tbidi\", 1L, NULL, 0);\n\n  didset_options2();\n\n  // enc_locale() will try to find the encoding of the current locale.\n  // This will be used when 'default' is used as encoding specifier\n  // in 'fileencodings'\n  char_u *p = enc_locale();\n  if (p == NULL) {\n      // use utf-8 as 'default' if locale encoding can't be detected.\n      p = vim_strsave((char_u *)\"utf-8\");\n  }\n  fenc_default = p;\n\n#ifdef HAVE_WORKING_LIBINTL\n  // GNU gettext 0.10.37 supports this feature: set the codeset used for\n  // translated messages independently from the current locale.\n  (void)bind_textdomain_codeset(PROJECT_NAME, (char *)p_enc);\n#endif\n\n  /* Set the default for 'helplang'. */\n  set_helplang_default(get_mess_lang());\n}\n\n/*\n * Set an option to its default value.\n * This does not take care of side effects!\n */\nstatic void \nset_option_default (\n    int opt_idx,\n    int opt_flags,                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */\n    int compatible                 /* use Vi default value */\n)\n{\n  char_u      *varp;            /* pointer to variable for current option */\n  int dvi;                      /* index in def_val[] */\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n\n  varp = get_varp_scope(&(options[opt_idx]), both ? OPT_LOCAL : opt_flags);\n  uint32_t flags = options[opt_idx].flags;\n  if (varp != NULL) {       /* skip hidden option, nothing to do for it */\n    dvi = ((flags & P_VI_DEF) || compatible) ? VI_DEFAULT : VIM_DEFAULT;\n    if (flags & P_STRING) {\n      /* Use set_string_option_direct() for local options to handle\n       * freeing and allocating the value. */\n      if (options[opt_idx].indir != PV_NONE)\n        set_string_option_direct(NULL, opt_idx,\n            options[opt_idx].def_val[dvi], opt_flags, 0);\n      else {\n        if ((opt_flags & OPT_FREE) && (flags & P_ALLOCED))\n          free_string_option(*(char_u **)(varp));\n        *(char_u **)varp = options[opt_idx].def_val[dvi];\n        options[opt_idx].flags &= ~P_ALLOCED;\n      }\n    } else if (flags & P_NUM)   {\n      if (options[opt_idx].indir == PV_SCROLL)\n        win_comp_scroll(curwin);\n      else {\n        *(long *)varp = (long)options[opt_idx].def_val[dvi];\n        /* May also set global value for local option. */\n        if (both)\n          *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n            *(long *)varp;\n      }\n    } else {  /* P_BOOL */\n      *(int *)varp = (int)(intptr_t)options[opt_idx].def_val[dvi];\n#ifdef UNIX\n      /* 'modeline' defaults to off for root */\n      if (options[opt_idx].indir == PV_ML && getuid() == ROOT_UID)\n        *(int *)varp = FALSE;\n#endif\n      /* May also set global value for local option. */\n      if (both)\n        *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) =\n          *(int *)varp;\n    }\n\n    /* The default value is not insecure. */\n    uint32_t *flagsp = insecure_flag(opt_idx, opt_flags);\n    *flagsp = *flagsp & ~P_INSECURE;\n  }\n\n  set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n}\n\n/*\n * Set all options (except terminal options) to their default value.\n */\nstatic void \nset_options_default (\n    int opt_flags                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  for (int i = 0; options[i].fullname; i++) {\n    if (!(options[i].flags & P_NODEFAULT)) {\n      set_option_default(i, opt_flags, p_cp);\n    }\n  }\n\n  /* The 'scroll' option must be computed for all windows. */\n  FOR_ALL_TAB_WINDOWS(tp, wp) {\n    win_comp_scroll(wp);\n  }\n\n  parse_cino(curbuf);\n}\n\n/// Set the Vi-default value of a string option.\n/// Used for 'sh', 'backupskip' and 'term'.\n///\n/// @param name The name of the option\n/// @param val The value of the option\n/// @param allocated If true, do not copy default as it was already allocated.\nstatic void set_string_default(const char *name, char *val, bool allocated)\n  FUNC_ATTR_NONNULL_ALL\n{\n  int opt_idx = findoption((char_u *)name);\n  if (opt_idx >= 0) {\n    if (options[opt_idx].flags & P_DEF_ALLOCED) {\n      xfree(options[opt_idx].def_val[VI_DEFAULT]);\n    }\n\n    options[opt_idx].def_val[VI_DEFAULT] = (char_u *) (\n        allocated\n        ? (char_u *) val\n        : (char_u *) xstrdup(val));\n    options[opt_idx].flags |= P_DEF_ALLOCED;\n  }\n}\n\n/*\n * Set the Vi-default value of a number option.\n * Used for 'lines' and 'columns'.\n */\nvoid set_number_default(char *name, long val)\n{\n  int opt_idx;\n\n  opt_idx = findoption((char_u *)name);\n  if (opt_idx >= 0)\n    options[opt_idx].def_val[VI_DEFAULT] = (char_u *)val;\n}\n\n#if defined(EXITFREE)\n/*\n * Free all options.\n */\nvoid free_all_options(void)\n{\n  int i;\n\n  for (i = 0; options[i].fullname; i++) {\n    if (options[i].indir == PV_NONE) {\n      /* global option: free value and default value. */\n      if (options[i].flags & P_ALLOCED && options[i].var != NULL)\n        free_string_option(*(char_u **)options[i].var);\n      if (options[i].flags & P_DEF_ALLOCED)\n        free_string_option(options[i].def_val[VI_DEFAULT]);\n    } else if (options[i].var != VAR_WIN\n               && (options[i].flags & P_STRING))\n      /* buffer-local option: free global value */\n      free_string_option(*(char_u **)options[i].var);\n  }\n}\n\n#endif\n\n\n/*\n * Initialize the options, part two: After getting Rows and Columns and\n * setting 'term'.\n */\nvoid set_init_2(void)\n{\n  int idx;\n\n  /*\n   * 'scroll' defaults to half the window height. Note that this default is\n   * wrong when the window height changes.\n   */\n  set_number_default(\"scroll\", Rows / 2);\n  idx = findoption((char_u *)\"scroll\");\n  if (idx >= 0 && !(options[idx].flags & P_WAS_SET))\n    set_option_default(idx, OPT_LOCAL, p_cp);\n  comp_col();\n\n  /*\n   * 'window' is only for backwards compatibility with Vi.\n   * Default is Rows - 1.\n   */\n  if (!option_was_set((char_u *)\"window\"))\n    p_window = Rows - 1;\n  set_number_default(\"window\", Rows - 1);\n  parse_shape_opt(SHAPE_CURSOR);   /* set cursor shapes from 'guicursor' */\n  (void)parse_printoptions();       /* parse 'printoptions' default value */\n}\n\n/*\n * Initialize the options, part three: After reading the .vimrc\n */\nvoid set_init_3(void)\n{\n  // Set 'shellpipe' and 'shellredir', depending on the 'shell' option.\n  // This is done after other initializations, where 'shell' might have been\n  // set, but only if they have not been set before.\n  int idx_srr;\n  int do_srr;\n  int idx_sp;\n  int do_sp;\n\n  idx_srr = findoption((char_u *)\"srr\");\n  if (idx_srr < 0)\n    do_srr = FALSE;\n  else\n    do_srr = !(options[idx_srr].flags & P_WAS_SET);\n  idx_sp = findoption((char_u *)\"sp\");\n  if (idx_sp < 0)\n    do_sp = FALSE;\n  else\n    do_sp = !(options[idx_sp].flags & P_WAS_SET);\n\n  size_t len = 0;\n  char_u *p = (char_u *)invocation_path_tail(p_sh, &len);\n  p = vim_strnsave(p, len);\n\n  {\n    /*\n     * Default for p_sp is \"| tee\", for p_srr is \">\".\n     * For known shells it is changed here to include stderr.\n     */\n    if (       fnamecmp(p, \"csh\") == 0\n               || fnamecmp(p, \"tcsh\") == 0\n               ) {\n      if (do_sp) {\n        p_sp = (char_u *)\"|& tee\";\n        options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n      }\n      if (do_srr) {\n        p_srr = (char_u *)\">&\";\n        options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n      }\n    } else if (       fnamecmp(p, \"sh\") == 0\n                      || fnamecmp(p, \"ksh\") == 0\n                      || fnamecmp(p, \"mksh\") == 0\n                      || fnamecmp(p, \"pdksh\") == 0\n                      || fnamecmp(p, \"zsh\") == 0\n                      || fnamecmp(p, \"zsh-beta\") == 0\n                      || fnamecmp(p, \"bash\") == 0\n                      || fnamecmp(p, \"fish\") == 0\n                      ) {\n      if (do_sp) {\n        p_sp = (char_u *)\"2>&1| tee\";\n        options[idx_sp].def_val[VI_DEFAULT] = p_sp;\n      }\n      if (do_srr) {\n        p_srr = (char_u *)\">%s 2>&1\";\n        options[idx_srr].def_val[VI_DEFAULT] = p_srr;\n      }\n    }\n    xfree(p);\n  }\n\n  if (bufempty()) {\n    int idx_ffs = findoption((char_u *)\"ffs\");\n\n    // Apply the first entry of 'fileformats' to the initial buffer.\n    if (idx_ffs >= 0 && (options[idx_ffs].flags & P_WAS_SET)) {\n      set_fileformat(default_fileformat(), OPT_LOCAL);\n    }\n  }\n\n  set_title_defaults();\n}\n\n/*\n * When 'helplang' is still at its default value, set it to \"lang\".\n * Only the first two characters of \"lang\" are used.\n */\nvoid set_helplang_default(const char *lang)\n{\n  int idx;\n\n  if (lang == NULL || STRLEN(lang) < 2)         /* safety check */\n    return;\n  idx = findoption((char_u *)\"hlg\");\n  if (idx >= 0 && !(options[idx].flags & P_WAS_SET)) {\n    if (options[idx].flags & P_ALLOCED)\n      free_string_option(p_hlg);\n    p_hlg = (char_u *)xstrdup(lang);\n    /* zh_CN becomes \"cn\", zh_TW becomes \"tw\". */\n    if (STRNICMP(p_hlg, \"zh_\", 3) == 0 && STRLEN(p_hlg) >= 5) {\n      p_hlg[0] = (char_u)TOLOWER_ASC(p_hlg[3]);\n      p_hlg[1] = (char_u)TOLOWER_ASC(p_hlg[4]);\n    }\n    p_hlg[2] = NUL;\n    options[idx].flags |= P_ALLOCED;\n  }\n}\n\n\n/*\n * 'title' and 'icon' only default to true if they have not been set or reset\n * in .vimrc and we can read the old value.\n * When 'title' and 'icon' have been reset in .vimrc, we won't even check if\n * they can be reset.  This reduces startup time when using X on a remote\n * machine.\n */\nvoid set_title_defaults(void)\n{\n  int idx1;\n\n  /*\n   * If GUI is (going to be) used, we can always set the window title and\n   * icon name.  Saves a bit of time, because the X11 display server does\n   * not need to be contacted.\n   */\n  idx1 = findoption((char_u *)\"title\");\n  if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET)) {\n    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;\n    p_title = 0;\n  }\n  idx1 = findoption((char_u *)\"icon\");\n  if (idx1 >= 0 && !(options[idx1].flags & P_WAS_SET)) {\n    options[idx1].def_val[VI_DEFAULT] = (char_u *)(intptr_t)0;\n    p_icon = 0;\n  }\n}\n\n/*\n * Parse 'arg' for option settings.\n *\n * 'arg' may be IObuff, but only when no errors can be present and option\n * does not need to be expanded with option_expand().\n * \"opt_flags\":\n * 0 for \":set\"\n * OPT_GLOBAL   for \":setglobal\"\n * OPT_LOCAL    for \":setlocal\" and a modeline\n * OPT_MODELINE for a modeline\n * OPT_WINONLY  to only set window-local options\n * OPT_NOWIN\tto skip setting window-local options\n *\n * returns FAIL if an error is detected, OK otherwise\n */\nint \ndo_set (\n    char_u *arg,               /* option string (may be written to!) */\n    int opt_flags\n)\n{\n  int opt_idx;\n  char_u      *errmsg;\n  char_u errbuf[80];\n  char_u      *startarg;\n  int prefix;           /* 1: nothing, 0: \"no\", 2: \"inv\" in front of name */\n  char_u nextchar;                  /* next non-white char after option name */\n  int afterchar;                    /* character just after option name */\n  int len;\n  int i;\n  long value;\n  int key;\n  uint32_t flags;                   /* flags for current option */\n  char_u      *varp = NULL;         /* pointer to variable for current option */\n  int did_show = FALSE;             /* already showed one value */\n  int adding;                       /* \"opt+=arg\" */\n  int prepending;                   /* \"opt^=arg\" */\n  int removing;                     /* \"opt-=arg\" */\n  int cp_val = 0;\n\n  if (*arg == NUL) {\n    showoptions(0, opt_flags);\n    did_show = TRUE;\n    goto theend;\n  }\n\n  while (*arg != NUL) {         /* loop to process all options */\n    errmsg = NULL;\n    startarg = arg;             /* remember for error message */\n\n    if (STRNCMP(arg, \"all\", 3) == 0 && !isalpha(arg[3])\n        && !(opt_flags & OPT_MODELINE)) {\n      /*\n       * \":set all\"  show all options.\n       * \":set all&\" set all options to their default value.\n       */\n      arg += 3;\n      if (*arg == '&') {\n        arg++;\n        // Only for :set command set global value of local options.\n        set_options_default(OPT_FREE | opt_flags);\n        didset_options();\n        didset_options2();\n        redraw_all_later(CLEAR);\n      } else {\n        showoptions(1, opt_flags);\n        did_show = TRUE;\n      }\n    } else if (STRNCMP(arg, \"termcap\",\n                   7) == 0 && !(opt_flags & OPT_MODELINE)) {\n      did_show = TRUE;\n      arg += 7;\n    } else {\n      prefix = 1;\n      if (STRNCMP(arg, \"no\", 2) == 0) {\n        prefix = 0;\n        arg += 2;\n      } else if (STRNCMP(arg, \"inv\", 3) == 0) {\n        prefix = 2;\n        arg += 3;\n      }\n\n      /* find end of name */\n      key = 0;\n      if (*arg == '<') {\n        opt_idx = -1;\n        /* look out for <t_>;> */\n        if (arg[1] == 't' && arg[2] == '_' && arg[3] && arg[4])\n          len = 5;\n        else {\n          len = 1;\n          while (arg[len] != NUL && arg[len] != '>')\n            ++len;\n        }\n        if (arg[len] != '>') {\n          errmsg = e_invarg;\n          goto skip;\n        }\n        if (arg[1] == 't' && arg[2] == '_') {  // could be term code\n          opt_idx = findoption_len(arg + 1, (size_t) (len - 1));\n        }\n        len++;\n        if (opt_idx == -1) {\n          key = find_key_option(arg + 1);\n        }\n      } else {\n        len = 0;\n        // The two characters after \"t_\" may not be alphanumeric.\n        if (arg[0] == 't' && arg[1] == '_' && arg[2] && arg[3]) {\n          len = 4;\n        } else {\n          while (ASCII_ISALNUM(arg[len]) || arg[len] == '_') {\n            len++;\n          }\n        }\n        opt_idx = findoption_len(arg, (size_t) len);\n        if (opt_idx == -1) {\n          key = find_key_option(arg);\n        }\n      }\n\n      /* remember character after option name */\n      afterchar = arg[len];\n\n      /* skip white space, allow \":set ai  ?\" */\n      while (ascii_iswhite(arg[len]))\n        ++len;\n\n      adding = FALSE;\n      prepending = FALSE;\n      removing = FALSE;\n      if (arg[len] != NUL && arg[len + 1] == '=') {\n        if (arg[len] == '+') {\n          adding = TRUE;                        /* \"+=\" */\n          ++len;\n        } else if (arg[len] == '^') {\n          prepending = TRUE;                    /* \"^=\" */\n          ++len;\n        } else if (arg[len] == '-') {\n          removing = TRUE;                      /* \"-=\" */\n          ++len;\n        }\n      }\n      nextchar = arg[len];\n\n      if (opt_idx == -1 && key == 0) {          /* found a mismatch: skip */\n        errmsg = (char_u *)N_(\"E518: Unknown option\");\n        goto skip;\n      }\n\n      if (opt_idx >= 0) {\n        if (options[opt_idx].var == NULL) {         /* hidden option: skip */\n          /* Only give an error message when requesting the value of\n           * a hidden option, ignore setting it. */\n          if (vim_strchr((char_u *)\"=:!&<\", nextchar) == NULL\n              && (!(options[opt_idx].flags & P_BOOL)\n                  || nextchar == '?'))\n            errmsg = (char_u *)_(e_unsupportedoption);\n          goto skip;\n        }\n\n        flags = options[opt_idx].flags;\n        varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n      } else {\n        flags = P_STRING;\n      }\n\n      /* Skip all options that are not window-local (used when showing\n       * an already loaded buffer in a window). */\n      if ((opt_flags & OPT_WINONLY)\n          && (opt_idx < 0 || options[opt_idx].var != VAR_WIN))\n        goto skip;\n\n      /* Skip all options that are window-local (used for :vimgrep). */\n      if ((opt_flags & OPT_NOWIN) && opt_idx >= 0\n          && options[opt_idx].var == VAR_WIN)\n        goto skip;\n\n      /* Disallow changing some options from modelines. */\n      if (opt_flags & OPT_MODELINE) {\n        if (flags & (P_SECURE | P_NO_ML)) {\n          errmsg = (char_u *)_(\"E520: Not allowed in a modeline\");\n          goto skip;\n        }\n        /* In diff mode some options are overruled.  This avoids that\n         * 'foldmethod' becomes \"marker\" instead of \"diff\" and that\n         * \"wrap\" gets set. */\n        if (curwin->w_p_diff\n            && opt_idx >= 0              /* shut up coverity warning */\n            && (options[opt_idx].indir == PV_FDM\n                || options[opt_idx].indir == PV_WRAP))\n          goto skip;\n      }\n\n      /* Disallow changing some options in the sandbox */\n      if (sandbox != 0 && (flags & P_SECURE)) {\n        errmsg = (char_u *)_(e_sandbox);\n        goto skip;\n      }\n\n      if (vim_strchr((char_u *)\"?=:!&<\", nextchar) != NULL) {\n        arg += len;\n        cp_val = p_cp;\n        if (nextchar == '&' && arg[1] == 'v' && arg[2] == 'i') {\n          if (arg[3] == 'm') {          /* \"opt&vim\": set to Vim default */\n            cp_val = FALSE;\n            arg += 3;\n          } else {                    /* \"opt&vi\": set to Vi default */\n            cp_val = TRUE;\n            arg += 2;\n          }\n        }\n        if (vim_strchr((char_u *)\"?!&<\", nextchar) != NULL\n            && arg[1] != NUL && !ascii_iswhite(arg[1])) {\n          errmsg = e_trailing;\n          goto skip;\n        }\n      }\n\n      /*\n       * allow '=' and ':' as MSDOS command.com allows only one\n       * '=' character per \"set\" command line. grrr. (jw)\n       */\n      if (nextchar == '?'\n          || (prefix == 1\n              && vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n              && !(flags & P_BOOL))) {\n        /*\n         * print value\n         */\n        if (did_show)\n          msg_putchar('\\n');                /* cursor below last one */\n        else {\n          gotocmdline(TRUE);                /* cursor at status line */\n          did_show = TRUE;                  /* remember that we did a line */\n        }\n        if (opt_idx >= 0) {\n          showoneopt(&options[opt_idx], opt_flags);\n          if (p_verbose > 0) {\n            /* Mention where the option was last set. */\n            if (varp == options[opt_idx].var)\n              last_set_msg(options[opt_idx].scriptID);\n            else if ((int)options[opt_idx].indir & PV_WIN)\n              last_set_msg(curwin->w_p_scriptID[\n                    (int)options[opt_idx].indir & PV_MASK]);\n            else if ((int)options[opt_idx].indir & PV_BUF)\n              last_set_msg(curbuf->b_p_scriptID[\n                    (int)options[opt_idx].indir & PV_MASK]);\n          }\n        } else {\n          errmsg = (char_u *)N_(\"E846: Key code not set\");\n          goto skip;\n        }\n        if (nextchar != '?'\n            && nextchar != NUL && !ascii_iswhite(afterchar))\n          errmsg = e_trailing;\n      } else {\n        if (flags & P_BOOL) {                       /* boolean */\n          if (nextchar == '=' || nextchar == ':') {\n            errmsg = e_invarg;\n            goto skip;\n          }\n\n          /*\n           * \":set opt!\": invert\n           * \":set opt&\": reset to default value\n           * \":set opt<\": reset to global value\n           */\n          if (nextchar == '!')\n            value = *(int *)(varp) ^ 1;\n          else if (nextchar == '&')\n            value = (int)(intptr_t)options[opt_idx].def_val[\n              ((flags & P_VI_DEF) || cp_val)\n              ?  VI_DEFAULT : VIM_DEFAULT];\n          else if (nextchar == '<') {\n            /* For 'autoread' -1 means to use global value. */\n            if ((int *)varp == &curbuf->b_p_ar\n                && opt_flags == OPT_LOCAL)\n              value = -1;\n            else\n              value = *(int *)get_varp_scope(&(options[opt_idx]),\n                  OPT_GLOBAL);\n          } else {\n            /*\n             * \":set invopt\": invert\n             * \":set opt\" or \":set noopt\": set or reset\n             */\n            if (nextchar != NUL && !ascii_iswhite(afterchar)) {\n              errmsg = e_trailing;\n              goto skip;\n            }\n            if (prefix == 2)                    /* inv */\n              value = *(int *)(varp) ^ 1;\n            else\n              value = prefix;\n          }\n\n          errmsg = set_bool_option(opt_idx, varp, (int)value,\n              opt_flags);\n        } else {                                  /* numeric or string */\n          if (vim_strchr((char_u *)\"=:&<\", nextchar) == NULL\n              || prefix != 1) {\n            errmsg = e_invarg;\n            goto skip;\n          }\n\n          if (flags & P_NUM) {                      /* numeric */\n            /*\n             * Different ways to set a number option:\n             * &\t    set to default value\n             * <\t    set to global value\n             * <xx>\t    accept special key codes for 'wildchar'\n             * c\t    accept any non-digit for 'wildchar'\n             * [-]0-9   set number\n             * other    error\n             */\n            ++arg;\n            if (nextchar == '&')\n              value = (long)options[opt_idx].def_val[\n                ((flags & P_VI_DEF) || cp_val)\n                ?  VI_DEFAULT : VIM_DEFAULT];\n            else if (nextchar == '<') {\n              /* For 'undolevels' NO_LOCAL_UNDOLEVEL means to\n               * use the global value. */\n              if ((long *)varp == &curbuf->b_p_ul\n                  && opt_flags == OPT_LOCAL)\n                value = NO_LOCAL_UNDOLEVEL;\n              else\n                value = *(long *)get_varp_scope(\n                    &(options[opt_idx]), OPT_GLOBAL);\n            } else if (((long *)varp == &p_wc\n                        || (long *)varp == &p_wcm)\n                       && (*arg == '<'\n                           || *arg == '^'\n                           || ((!arg[1] || ascii_iswhite(arg[1]))\n                               && !ascii_isdigit(*arg)))) {\n              value = string_to_key(arg);\n              if (value == 0 && (long *)varp != &p_wcm) {\n                errmsg = e_invarg;\n                goto skip;\n              }\n            } else if (*arg == '-' || ascii_isdigit(*arg)) {\n              // Allow negative (for 'undolevels'), octal and\n              // hex numbers.\n              vim_str2nr(arg, NULL, &i, STR2NR_ALL, &value, NULL, 0);\n              if (arg[i] != NUL && !ascii_iswhite(arg[i])) {\n                errmsg = e_invarg;\n                goto skip;\n              }\n            } else {\n              errmsg = (char_u *)N_(\"E521: Number required after =\");\n              goto skip;\n            }\n\n            if (adding)\n              value = *(long *)varp + value;\n            if (prepending)\n              value = *(long *)varp * value;\n            if (removing)\n              value = *(long *)varp - value;\n            errmsg = set_num_option(opt_idx, varp, value,\n                errbuf, sizeof(errbuf), opt_flags);\n          } else if (opt_idx >= 0) {                      /* string */\n            char_u      *save_arg = NULL;\n            char_u      *s = NULL;\n            char_u      *oldval = NULL;         // previous value if *varp\n            char_u      *newval;\n            char_u      *origval = NULL;\n            char *saved_origval = NULL;\n            unsigned newlen;\n            int comma;\n            int bs;\n            int new_value_alloced;                      /* new string option\n                                                           was allocated */\n\n            /* When using \":set opt=val\" for a global option\n             * with a local value the local value will be\n             * reset, use the global value here. */\n            if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n                && ((int)options[opt_idx].indir & PV_BOTH))\n              varp = options[opt_idx].var;\n\n            /* The old value is kept until we are sure that the\n             * new value is valid. */\n            oldval = *(char_u **)varp;\n            if (nextchar == '&') {              /* set to default val */\n              newval = options[opt_idx].def_val[\n                ((flags & P_VI_DEF) || cp_val)\n                ?  VI_DEFAULT : VIM_DEFAULT];\n              /* expand environment variables and ~ (since the\n               * default value was already expanded, only\n               * required when an environment variable was set\n               * later */\n              new_value_alloced = true;\n              if (newval == NULL) {\n                newval = empty_option;\n              } else if (!(options[opt_idx].flags | P_NO_DEF_EXP)) {\n                s = option_expand(opt_idx, newval);\n                if (s == NULL) {\n                  s = newval;\n                }\n                newval = vim_strsave(s);\n              } else {\n                newval = (char_u *)xstrdup((char *)newval);\n              }\n            } else if (nextchar == '<') {  // set to global val\n              newval = vim_strsave(*(char_u **)get_varp_scope(\n                      &(options[opt_idx]), OPT_GLOBAL));\n              new_value_alloced = TRUE;\n            } else {\n              ++arg;                    /* jump to after the '=' or ':' */\n\n              /*\n               * Set 'keywordprg' to \":help\" if an empty\n               * value was passed to :set by the user.\n               * Misuse errbuf[] for the resulting string.\n               */\n              if (varp == (char_u *)&p_kp\n                  && (*arg == NUL || *arg == ' ')) {\n                STRCPY(errbuf, \":help\");\n                save_arg = arg;\n                arg = errbuf;\n              }\n              /*\n               * Convert 'backspace' number to string, for\n               * adding, prepending and removing string.\n               */\n              else if (varp == (char_u *)&p_bs\n                       && ascii_isdigit(**(char_u **)varp)) {\n                i = getdigits_int((char_u **)varp);\n                switch (i) {\n                case 0:\n                  *(char_u **)varp = empty_option;\n                  break;\n                case 1:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol\");\n                  break;\n                case 2:\n                  *(char_u **)varp = vim_strsave(\n                      (char_u *)\"indent,eol,start\");\n                  break;\n                }\n                xfree(oldval);\n                oldval = *(char_u **)varp;\n              }\n              /*\n               * Convert 'whichwrap' number to string, for\n               * backwards compatibility with Vim 3.0.\n               * Misuse errbuf[] for the resulting string.\n               */\n              else if (varp == (char_u *)&p_ww\n                       && ascii_isdigit(*arg)) {\n                *errbuf = NUL;\n                i = getdigits_int(&arg);\n                if (i & 1)\n                  STRCAT(errbuf, \"b,\");\n                if (i & 2)\n                  STRCAT(errbuf, \"s,\");\n                if (i & 4)\n                  STRCAT(errbuf, \"h,l,\");\n                if (i & 8)\n                  STRCAT(errbuf, \"<,>,\");\n                if (i & 16)\n                  STRCAT(errbuf, \"[,],\");\n                if (*errbuf != NUL)                     /* remove trailing , */\n                  errbuf[STRLEN(errbuf) - 1] = NUL;\n                save_arg = arg;\n                arg = errbuf;\n              }\n              /*\n               * Remove '>' before 'dir' and 'bdir', for\n               * backwards compatibility with version 3.0\n               */\n              else if (  *arg == '>'\n                         && (varp == (char_u *)&p_dir\n                             || varp == (char_u *)&p_bdir)) {\n                ++arg;\n              }\n\n              /* When setting the local value of a global\n               * option, the old value may be the global value. */\n              if (((int)options[opt_idx].indir & PV_BOTH)\n                  && (opt_flags & OPT_LOCAL))\n                origval = *(char_u **)get_varp(\n                    &options[opt_idx]);\n              else\n                origval = oldval;\n\n              /*\n               * Copy the new string into allocated memory.\n               * Can't use set_string_option_direct(), because\n               * we need to remove the backslashes.\n               */\n              /* get a bit too much */\n              newlen = (unsigned)STRLEN(arg) + 1;\n              if (adding || prepending || removing)\n                newlen += (unsigned)STRLEN(origval) + 1;\n              newval = xmalloc(newlen);\n              s = newval;\n\n              /*\n               * Copy the string, skip over escaped chars.\n               * For WIN32 backslashes before normal\n               * file name characters are not removed, and keep\n               * backslash at start, for \"\\\\machine\\path\", but\n               * do remove it for \"\\\\\\\\machine\\\\path\".\n               * The reverse is found in ExpandOldSetting().\n               */\n              while (*arg && !ascii_iswhite(*arg)) {\n                if (*arg == '\\\\' && arg[1] != NUL\n#ifdef BACKSLASH_IN_FILENAME\n                    && !((flags & P_EXPAND)\n                         && vim_isfilec(arg[1])\n                         && (arg[1] != '\\\\'\n                             || (s == newval\n                                 && arg[2] != '\\\\')))\n#endif\n                    )\n                  ++arg;                        /* remove backslash */\n                if (has_mbyte\n                    && (i = (*mb_ptr2len)(arg)) > 1) {\n                  /* copy multibyte char */\n                  memmove(s, arg, (size_t)i);\n                  arg += i;\n                  s += i;\n                } else\n                  *s++ = *arg++;\n              }\n              *s = NUL;\n\n              /*\n               * Expand environment variables and ~.\n               * Don't do it when adding without inserting a\n               * comma.\n               */\n              if (!(adding || prepending || removing)\n                  || (flags & P_COMMA)) {\n                s = option_expand(opt_idx, newval);\n                if (s != NULL) {\n                  xfree(newval);\n                  newlen = (unsigned)STRLEN(s) + 1;\n                  if (adding || prepending || removing)\n                    newlen += (unsigned)STRLEN(origval) + 1;\n                  newval = xmalloc(newlen);\n                  STRCPY(newval, s);\n                }\n              }\n\n              /* locate newval[] in origval[] when removing it\n               * and when adding to avoid duplicates */\n              i = 0;                    /* init for GCC */\n              if (removing || (flags & P_NODUP)) {\n                i = (int)STRLEN(newval);\n                bs = 0;\n                for (s = origval; *s; ++s) {\n                  if ((!(flags & P_COMMA)\n                       || s == origval\n                       || (s[-1] == ',' && !(bs & 1)))\n                      && STRNCMP(s, newval, i) == 0\n                      && (!(flags & P_COMMA)\n                          || s[i] == ','\n                          || s[i] == NUL)) {\n                    break;\n                  }\n                  // Count backslashes.  Only a comma with an even number of\n                  // backslashes or a single backslash preceded by a comma\n                  // before it is recognized as a separator\n                  if ((s > origval + 1 && s[-1] == '\\\\' && s[-2] != ',')\n                      || (s == origval + 1 && s[-1] == '\\\\')) {\n                    bs++;\n                  } else {\n                    bs = 0;\n                  }\n                }\n\n                // do not add if already there\n                if ((adding || prepending) && *s) {\n                  prepending = FALSE;\n                  adding = FALSE;\n                  STRCPY(newval, origval);\n                }\n              }\n\n              /* concatenate the two strings; add a ',' if\n               * needed */\n              if (adding || prepending) {\n                comma = ((flags & P_COMMA) && *origval != NUL\n                         && *newval != NUL);\n                if (adding) {\n                  i = (int)STRLEN(origval);\n                  // Strip a trailing comma, would get 2.\n                  if (comma && i > 1\n                      && (flags & P_ONECOMMA) == P_ONECOMMA\n                      && origval[i - 1] == ','\n                      && origval[i - 2] != '\\\\') {\n                    i--;\n                  }\n                  memmove(newval + i + comma, newval,\n                      STRLEN(newval) + 1);\n                  memmove(newval, origval, (size_t)i);\n                } else {\n                  i = (int)STRLEN(newval);\n                  STRMOVE(newval + i + comma, origval);\n                }\n                if (comma)\n                  newval[i] = ',';\n              }\n\n              /* Remove newval[] from origval[]. (Note: \"i\" has\n               * been set above and is used here). */\n              if (removing) {\n                STRCPY(newval, origval);\n                if (*s) {\n                  /* may need to remove a comma */\n                  if (flags & P_COMMA) {\n                    if (s == origval) {\n                      /* include comma after string */\n                      if (s[i] == ',')\n                        ++i;\n                    } else {\n                      /* include comma before string */\n                      --s;\n                      ++i;\n                    }\n                  }\n                  STRMOVE(newval + (s - origval), s + i);\n                }\n              }\n\n              if (flags & P_FLAGLIST) {\n                // Remove flags that appear twice.\n                for (s = newval; *s; s++) {\n                  // if options have P_FLAGLIST and P_ONECOMMA such as\n                  // 'whichwrap'\n                  if (flags & P_ONECOMMA) {\n                    if (*s != ',' && *(s + 1) == ','\n                        && vim_strchr(s + 2, *s) != NULL) {\n                      // Remove the duplicated value and the next comma.\n                      STRMOVE(s, s + 2);\n                      s -= 2;\n                    }\n                  } else {\n                    if ((!(flags & P_COMMA) || *s != ',')\n                        && vim_strchr(s + 1, *s) != NULL) {\n                      STRMOVE(s, s + 1);\n                      s--;\n                    }\n                  }\n                }\n              }\n\n              if (save_arg != NULL)                 /* number for 'whichwrap' */\n                arg = save_arg;\n              new_value_alloced = TRUE;\n            }\n\n            /* Set the new value. */\n            *(char_u **)(varp) = newval;\n\n            if (!starting && origval != NULL) {\n              // origval may be freed by\n              // did_set_string_option(), make a copy.\n              saved_origval = xstrdup((char *) origval);\n            }\n\n            /* Handle side effects, and set the global value for\n             * \":set\" on local options. */\n            errmsg = did_set_string_option(opt_idx, (char_u **)varp,\n                new_value_alloced, oldval, errbuf, opt_flags);\n\n            // If error detected, print the error message.\n            if (errmsg != NULL) {\n              xfree(saved_origval);\n              goto skip;\n            }\n\n            if (saved_origval != NULL) {\n              char buf_type[7];\n              vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                           (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n              set_vim_var_string(VV_OPTION_NEW, *(char **) varp, -1);\n              set_vim_var_string(VV_OPTION_OLD, saved_origval, -1);\n              set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n              apply_autocmds(EVENT_OPTIONSET,\n                             (char_u *)options[opt_idx].fullname,\n                             NULL, false, NULL);\n              reset_v_option_vars();\n              xfree(saved_origval);\n            }\n          } else {\n            // key code option(FIXME(tarruda): Show a warning or something\n            // similar)\n          }\n        }\n\n        if (opt_idx >= 0)\n          did_set_option(opt_idx, opt_flags,\n              !prepending && !adding && !removing);\n      }\n\nskip:\n      /*\n       * Advance to next argument.\n       * - skip until a blank found, taking care of backslashes\n       * - skip blanks\n       * - skip one \"=val\" argument (for hidden options \":set gfn =xx\")\n       */\n      for (i = 0; i < 2; ++i) {\n        while (*arg != NUL && !ascii_iswhite(*arg))\n          if (*arg++ == '\\\\' && *arg != NUL)\n            ++arg;\n        arg = skipwhite(arg);\n        if (*arg != '=')\n          break;\n      }\n    }\n\n    if (errmsg != NULL) {\n      STRLCPY(IObuff, _(errmsg), IOSIZE);\n      i = (int)STRLEN(IObuff) + 2;\n      if (i + (arg - startarg) < IOSIZE) {\n        /* append the argument with the error */\n        STRCAT(IObuff, \": \");\n        assert(arg >= startarg);\n        memmove(IObuff + i, startarg, (size_t)(arg - startarg));\n        IObuff[i + (arg - startarg)] = NUL;\n      }\n      /* make sure all characters are printable */\n      trans_characters(IObuff, IOSIZE);\n\n      ++no_wait_return;         /* wait_return done later */\n      emsg(IObuff);             /* show error highlighted */\n      --no_wait_return;\n\n      return FAIL;\n    }\n\n    arg = skipwhite(arg);\n  }\n\ntheend:\n  if (silent_mode && did_show) {\n    /* After displaying option values in silent mode. */\n    silent_mode = FALSE;\n    info_message = TRUE;        /* use mch_msg(), not mch_errmsg() */\n    msg_putchar('\\n');\n    ui_flush();\n    silent_mode = TRUE;\n    info_message = FALSE;       /* use mch_msg(), not mch_errmsg() */\n  }\n\n  return OK;\n}\n\n/*\n * Call this when an option has been given a new value through a user command.\n * Sets the P_WAS_SET flag and takes care of the P_INSECURE flag.\n */\nstatic void \ndid_set_option (\n    int opt_idx,\n    int opt_flags,              /* possibly with OPT_MODELINE */\n    int new_value              /* value was replaced completely */\n)\n{\n  options[opt_idx].flags |= P_WAS_SET;\n\n  /* When an option is set in the sandbox, from a modeline or in secure mode\n   * set the P_INSECURE flag.  Otherwise, if a new value is stored reset the\n   * flag. */\n  uint32_t *p = insecure_flag(opt_idx, opt_flags);\n  if (secure\n      || sandbox != 0\n      || (opt_flags & OPT_MODELINE))\n    *p = *p | P_INSECURE;\n  else if (new_value)\n    *p = *p & ~P_INSECURE;\n}\n\nstatic char_u *illegal_char(char_u *errbuf, int c)\n{\n  if (errbuf == NULL)\n    return (char_u *)\"\";\n  sprintf((char *)errbuf, _(\"E539: Illegal character <%s>\"),\n      (char *)transchar(c));\n  return errbuf;\n}\n\n/*\n * Convert a key name or string into a key value.\n * Used for 'wildchar' and 'cedit' options.\n */\nstatic int string_to_key(char_u *arg)\n{\n  if (*arg == '<')\n    return find_key_option(arg + 1);\n  if (*arg == '^')\n    return Ctrl_chr(arg[1]);\n  return *arg;\n}\n\n/*\n * Check value of 'cedit' and set cedit_key.\n * Returns NULL if value is OK, error message otherwise.\n */\nstatic char_u *check_cedit(void)\n{\n  int n;\n\n  if (*p_cedit == NUL)\n    cedit_key = -1;\n  else {\n    n = string_to_key(p_cedit);\n    if (vim_isprintc(n))\n      return e_invarg;\n    cedit_key = n;\n  }\n  return NULL;\n}\n\n/*\n * When changing 'title', 'titlestring', 'icon' or 'iconstring', call\n * maketitle() to create and display it.\n * When switching the title or icon off, call ui_set_{icon,title}(NULL) to get\n * the old value back.\n */\nstatic void \ndid_set_title (\n    int icon                   /* Did set icon instead of title */\n)\n{\n  if (starting != NO_SCREEN) {\n    maketitle();\n    if (icon) {\n      if (!p_icon) {\n        ui_set_icon(NULL);\n      }\n    } else {\n      if (!p_title) {\n        ui_set_title(NULL);\n      }\n    }\n  }\n}\n\n/*\n * set_options_bin -  called when 'bin' changes value.\n */\nvoid \nset_options_bin (\n    int oldval,\n    int newval,\n    int opt_flags                  /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  /*\n   * The option values that are changed when 'bin' changes are\n   * copied when 'bin is set and restored when 'bin' is reset.\n   */\n  if (newval) {\n    if (!oldval) {              /* switched on */\n      if (!(opt_flags & OPT_GLOBAL)) {\n        curbuf->b_p_tw_nobin = curbuf->b_p_tw;\n        curbuf->b_p_wm_nobin = curbuf->b_p_wm;\n        curbuf->b_p_ml_nobin = curbuf->b_p_ml;\n        curbuf->b_p_et_nobin = curbuf->b_p_et;\n      }\n      if (!(opt_flags & OPT_LOCAL)) {\n        p_tw_nobin = p_tw;\n        p_wm_nobin = p_wm;\n        p_ml_nobin = p_ml;\n        p_et_nobin = p_et;\n      }\n    }\n\n    if (!(opt_flags & OPT_GLOBAL)) {\n      curbuf->b_p_tw = 0;       /* no automatic line wrap */\n      curbuf->b_p_wm = 0;       /* no automatic line wrap */\n      curbuf->b_p_ml = 0;       /* no modelines */\n      curbuf->b_p_et = 0;       /* no expandtab */\n    }\n    if (!(opt_flags & OPT_LOCAL)) {\n      p_tw = 0;\n      p_wm = 0;\n      p_ml = FALSE;\n      p_et = FALSE;\n      p_bin = TRUE;             /* needed when called for the \"-b\" argument */\n    }\n  } else if (oldval) {        /* switched off */\n    if (!(opt_flags & OPT_GLOBAL)) {\n      curbuf->b_p_tw = curbuf->b_p_tw_nobin;\n      curbuf->b_p_wm = curbuf->b_p_wm_nobin;\n      curbuf->b_p_ml = curbuf->b_p_ml_nobin;\n      curbuf->b_p_et = curbuf->b_p_et_nobin;\n    }\n    if (!(opt_flags & OPT_LOCAL)) {\n      p_tw = p_tw_nobin;\n      p_wm = p_wm_nobin;\n      p_ml = p_ml_nobin;\n      p_et = p_et_nobin;\n    }\n  }\n}\n\n/*\n * Find the parameter represented by the given character (eg ', :, \", or /),\n * and return its associated value in the 'shada' string.\n * Only works for number parameters, not for 'r' or 'n'.\n * If the parameter is not specified in the string or there is no following\n * number, return -1.\n */\nint get_shada_parameter(int type)\n{\n  char_u  *p;\n\n  p = find_shada_parameter(type);\n  if (p != NULL && ascii_isdigit(*p))\n    return atoi((char *)p);\n  return -1;\n}\n\n/*\n * Find the parameter represented by the given character (eg ''', ':', '\"', or\n * '/') in the 'shada' option and return a pointer to the string after it.\n * Return NULL if the parameter is not specified in the string.\n */\nchar_u *find_shada_parameter(int type)\n{\n  char_u  *p;\n\n  for (p = p_shada; *p; ++p) {\n    if (*p == type)\n      return p + 1;\n    if (*p == 'n')                  /* 'n' is always the last one */\n      break;\n    p = vim_strchr(p, ',');         /* skip until next ',' */\n    if (p == NULL)                  /* hit the end without finding parameter */\n      break;\n  }\n  return NULL;\n}\n\n/*\n * Expand environment variables for some string options.\n * These string options cannot be indirect!\n * If \"val\" is NULL expand the current value of the option.\n * Return pointer to NameBuff, or NULL when not expanded.\n */\nstatic char_u *option_expand(int opt_idx, char_u *val)\n{\n  /* if option doesn't need expansion nothing to do */\n  if (!(options[opt_idx].flags & P_EXPAND) || options[opt_idx].var == NULL)\n    return NULL;\n\n  if (val == NULL) {\n    val = *(char_u **)options[opt_idx].var;\n  }\n\n  // If val is longer than MAXPATHL no meaningful expansion can be done,\n  // expand_env() would truncate the string.\n  if (val == NULL || STRLEN(val) > MAXPATHL) {\n    return NULL;\n  }\n\n  /*\n   * Expanding this with NameBuff, expand_env() must not be passed IObuff.\n   * Escape spaces when expanding 'tags', they are used to separate file\n   * names.\n   * For 'spellsuggest' expand after \"file:\".\n   */\n  expand_env_esc(val, NameBuff, MAXPATHL,\n      (char_u **)options[opt_idx].var == &p_tags, FALSE,\n      (char_u **)options[opt_idx].var == &p_sps ? (char_u *)\"file:\" :\n      NULL);\n  if (STRCMP(NameBuff, val) == 0)     /* they are the same */\n    return NULL;\n\n  return NameBuff;\n}\n\n/*\n * After setting various option values: recompute variables that depend on\n * option values.\n */\nstatic void didset_options(void)\n{\n  /* initialize the table for 'iskeyword' et.al. */\n  (void)init_chartab();\n\n  (void)opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true);\n  (void)opt_strings_flags(p_bkc, p_bkc_values, &bkc_flags, true);\n  (void)opt_strings_flags(p_bo, p_bo_values, &bo_flags, true);\n  (void)opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true);\n  (void)opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true);\n  (void)opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true);\n  (void)opt_strings_flags(p_dy, p_dy_values, &dy_flags, true);\n  (void)opt_strings_flags(p_tc, p_tc_values, &tc_flags, false);\n  (void)opt_strings_flags(p_ve, p_ve_values, &ve_flags, true);\n  (void)spell_check_msm();\n  (void)spell_check_sps();\n  (void)compile_cap_prog(curwin->w_s);\n  (void)did_set_spell_option(true);\n  // set cedit_key\n  (void)check_cedit();\n  briopt_check(curwin);\n  // initialize the table for 'breakat'.\n  fill_breakat_flags();\n}\n\n// More side effects of setting options.\nstatic void didset_options2(void)\n{\n  // Initialize the highlight_attr[] table.\n  (void)highlight_changed();\n\n  // Parse default for 'clipboard'.\n  (void)opt_strings_flags(p_cb, p_cb_values, &cb_flags, true);\n\n  // Parse default for 'fillchars'.\n  (void)set_chars_option(&p_fcs);\n\n  // Parse default for 'listchars'.\n  (void)set_chars_option(&p_lcs);\n\n  // Parse default for 'wildmode'.\n  check_opt_wim();\n}\n\n/*\n * Check for string options that are NULL (normally only termcap options).\n */\nvoid check_options(void)\n{\n  int opt_idx;\n\n  for (opt_idx = 0; options[opt_idx].fullname != NULL; opt_idx++)\n    if ((options[opt_idx].flags & P_STRING) && options[opt_idx].var != NULL)\n      check_string_option((char_u **)get_varp(&(options[opt_idx])));\n}\n\n/*\n * Check string options in a buffer for NULL value.\n */\nvoid check_buf_options(buf_T *buf)\n{\n  check_string_option(&buf->b_p_bh);\n  check_string_option(&buf->b_p_bt);\n  check_string_option(&buf->b_p_fenc);\n  check_string_option(&buf->b_p_ff);\n  check_string_option(&buf->b_p_def);\n  check_string_option(&buf->b_p_inc);\n  check_string_option(&buf->b_p_inex);\n  check_string_option(&buf->b_p_inde);\n  check_string_option(&buf->b_p_indk);\n  check_string_option(&buf->b_p_fex);\n  check_string_option(&buf->b_p_kp);\n  check_string_option(&buf->b_p_mps);\n  check_string_option(&buf->b_p_fo);\n  check_string_option(&buf->b_p_flp);\n  check_string_option(&buf->b_p_isk);\n  check_string_option(&buf->b_p_com);\n  check_string_option(&buf->b_p_cms);\n  check_string_option(&buf->b_p_nf);\n  check_string_option(&buf->b_p_qe);\n  check_string_option(&buf->b_p_syn);\n  check_string_option(&buf->b_s.b_syn_isk);\n  check_string_option(&buf->b_s.b_p_spc);\n  check_string_option(&buf->b_s.b_p_spf);\n  check_string_option(&buf->b_s.b_p_spl);\n  check_string_option(&buf->b_p_sua);\n  check_string_option(&buf->b_p_cink);\n  check_string_option(&buf->b_p_cino);\n  parse_cino(buf);\n  check_string_option(&buf->b_p_ft);\n  check_string_option(&buf->b_p_cinw);\n  check_string_option(&buf->b_p_cpt);\n  check_string_option(&buf->b_p_cfu);\n  check_string_option(&buf->b_p_ofu);\n  check_string_option(&buf->b_p_keymap);\n  check_string_option(&buf->b_p_gp);\n  check_string_option(&buf->b_p_mp);\n  check_string_option(&buf->b_p_efm);\n  check_string_option(&buf->b_p_ep);\n  check_string_option(&buf->b_p_path);\n  check_string_option(&buf->b_p_tags);\n  check_string_option(&buf->b_p_tc);\n  check_string_option(&buf->b_p_dict);\n  check_string_option(&buf->b_p_tsr);\n  check_string_option(&buf->b_p_lw);\n  check_string_option(&buf->b_p_bkc);\n}\n\n/*\n * Free the string allocated for an option.\n * Checks for the string being empty_option. This may happen if we're out of\n * memory, vim_strsave() returned NULL, which was replaced by empty_option by\n * check_options().\n * Does NOT check for P_ALLOCED flag!\n */\nvoid free_string_option(char_u *p)\n{\n  if (p != empty_option)\n    xfree(p);\n}\n\nvoid clear_string_option(char_u **pp)\n{\n  if (*pp != empty_option)\n    xfree(*pp);\n  *pp = empty_option;\n}\n\nstatic void check_string_option(char_u **pp)\n{\n  if (*pp == NULL)\n    *pp = empty_option;\n}\n\n/*\n * Return TRUE when option \"opt\" was set from a modeline or in secure mode.\n * Return FALSE when it wasn't.\n * Return -1 for an unknown option.\n */\nint was_set_insecurely(char_u *opt, int opt_flags)\n{\n  int idx = findoption(opt);\n\n  if (idx >= 0) {\n    uint32_t *flagp = insecure_flag(idx, opt_flags);\n    return (*flagp & P_INSECURE) != 0;\n  }\n  EMSG2(_(e_intern2), \"was_set_insecurely()\");\n  return -1;\n}\n\n/*\n * Get a pointer to the flags used for the P_INSECURE flag of option\n * \"opt_idx\".  For some local options a local flags field is used.\n */\nstatic uint32_t *insecure_flag(int opt_idx, int opt_flags)\n{\n  if (opt_flags & OPT_LOCAL)\n    switch ((int)options[opt_idx].indir) {\n    case PV_STL:        return &curwin->w_p_stl_flags;\n    case PV_FDE:        return &curwin->w_p_fde_flags;\n    case PV_FDT:        return &curwin->w_p_fdt_flags;\n    case PV_INDE:       return &curbuf->b_p_inde_flags;\n    case PV_FEX:        return &curbuf->b_p_fex_flags;\n    case PV_INEX:       return &curbuf->b_p_inex_flags;\n    }\n\n  /* Nothing special, return global flags field. */\n  return &options[opt_idx].flags;\n}\n\n\n/*\n * Redraw the window title and/or tab page text later.\n */\nstatic void redraw_titles(void) {\n  need_maketitle = TRUE;\n  redraw_tabline = TRUE;\n}\n\nstatic int shada_idx = -1;\n\n/*\n * Set a string option to a new value (without checking the effect).\n * The string is copied into allocated memory.\n * if (\"opt_idx\" == -1) \"name\" is used, otherwise \"opt_idx\" is used.\n * When \"set_sid\" is zero set the scriptID to current_SID.  When \"set_sid\" is\n * SID_NONE don't set the scriptID.  Otherwise set the scriptID to \"set_sid\".\n */\nvoid \nset_string_option_direct (\n    char_u *name,\n    int opt_idx,\n    char_u *val,\n    int opt_flags,                  /* OPT_FREE, OPT_LOCAL and/or OPT_GLOBAL */\n    int set_sid\n)\n{\n  char_u      *s;\n  char_u      **varp;\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n  int idx = opt_idx;\n\n  if (idx == -1) {              /* use name */\n    idx = findoption(name);\n    if (idx < 0) {      /* not found (should not happen) */\n      EMSG2(_(e_intern2), \"set_string_option_direct()\");\n      EMSG2(_(\"For option %s\"), name);\n      return;\n    }\n  }\n\n  if (options[idx].var == NULL)         /* can't set hidden option */\n    return;\n\n  assert((void *) options[idx].var != (void *) &p_shada);\n\n  s = vim_strsave(val);\n  {\n    varp = (char_u **)get_varp_scope(&(options[idx]),\n        both ? OPT_LOCAL : opt_flags);\n    if ((opt_flags & OPT_FREE) && (options[idx].flags & P_ALLOCED))\n      free_string_option(*varp);\n    *varp = s;\n\n    /* For buffer/window local option may also set the global value. */\n    if (both)\n      set_string_option_global(idx, varp);\n\n    options[idx].flags |= P_ALLOCED;\n\n    /* When setting both values of a global option with a local value,\n    * make the local value empty, so that the global value is used. */\n    if (((int)options[idx].indir & PV_BOTH) && both) {\n      free_string_option(*varp);\n      *varp = empty_option;\n    }\n    if (set_sid != SID_NONE)\n      set_option_scriptID_idx(idx, opt_flags,\n          set_sid == 0 ? current_SID : set_sid);\n  }\n}\n\n/*\n * Set global value for string option when it's a local option.\n */\nstatic void \nset_string_option_global (\n    int opt_idx,                    /* option index */\n    char_u **varp             /* pointer to option variable */\n)\n{\n  char_u      **p, *s;\n\n  /* the global value is always allocated */\n  if (options[opt_idx].var == VAR_WIN)\n    p = (char_u **)GLOBAL_WO(varp);\n  else\n    p = (char_u **)options[opt_idx].var;\n  if (options[opt_idx].indir != PV_NONE && p != varp) {\n    s = vim_strsave(*varp);\n    free_string_option(*p);\n    *p = s;\n  }\n}\n\n/// Set a string option to a new value, handling the effects\n///\n/// @param[in]  opt_idx  Option to set.\n/// @param[in]  value  New value.\n/// @param[in]  opt_flags  Option flags: expected to contain #OPT_LOCAL and/or\n///                        #OPT_GLOBAL.\n///\n/// @return NULL on success, error message on error.\nstatic char *set_string_option(const int opt_idx, const char *const value,\n                               const int opt_flags)\n  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_WARN_UNUSED_RESULT\n{\n  if (options[opt_idx].var == NULL) {  // don't set hidden option\n    return NULL;\n  }\n\n  char *const s = xstrdup(value);\n  char **const varp = (char **)get_varp_scope(\n      &(options[opt_idx]),\n      ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n       ? (((int)options[opt_idx].indir & PV_BOTH)\n          ? OPT_GLOBAL : OPT_LOCAL)\n       : opt_flags));\n  char *const oldval = *varp;\n  *varp = s;\n\n  char *const saved_oldval = (starting ? NULL : xstrdup(oldval));\n\n  char *const r = (char *)did_set_string_option(\n      opt_idx, (char_u **)varp, (int)true, (char_u *)oldval, NULL, opt_flags);\n  if (r == NULL) {\n    did_set_option(opt_idx, opt_flags, true);\n  }\n\n  // call autocommand after handling side effects\n  if (saved_oldval != NULL) {\n    char buf_type[7];\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, (char *)(*varp), -1);\n    set_vim_var_string(VV_OPTION_OLD, saved_oldval, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *)options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n    xfree(saved_oldval);\n  }\n\n  return r;\n}\n\n/// Return true if \"val\" is a valid 'filetype' name.\n/// Also used for 'syntax' and 'keymap'.\nstatic bool valid_filetype(char_u *val)\n{\n  for (char_u *s = val; *s != NUL; s++) {\n    if (!ASCII_ISALNUM(*s) && vim_strchr((char_u *)\".-_\", *s) == NULL) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/*\n * Handle string options that need some action to perform when changed.\n * Returns NULL for success, or an error message for an error.\n */\nstatic char_u *\ndid_set_string_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u **varp,                     /* pointer to the option variable */\n    int new_value_alloced,                  /* new value was allocated */\n    char_u *oldval,                    /* previous value of the option */\n    char_u *errbuf,                    /* buffer for errors, or NULL */\n    int opt_flags                          /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  char_u      *errmsg = NULL;\n  char_u      *s, *p;\n  int did_chartab = FALSE;\n  char_u      **gvarp;\n  bool free_oldval = (options[opt_idx].flags & P_ALLOCED);\n\n  /* Get the global option to compare with, otherwise we would have to check\n   * two values for all local options. */\n  gvarp = (char_u **)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);\n\n  /* Disallow changing some options from secure mode */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    errmsg = e_secure;\n  }\n  /* Check for a \"normal\" file name in some options.  Disallow a path\n   * separator (slash and/or backslash), wildcards and characters that are\n   * often illegal in a file name. */\n  else if ((options[opt_idx].flags & P_NFNAME)\n           && vim_strpbrk(*varp, (char_u *)\"/\\\\*?[|<>\") != NULL) {\n    errmsg = e_invarg;\n  }\n  /* 'backupcopy' */\n  else if (gvarp == &p_bkc) {\n    char_u       *bkc   = p_bkc;\n    unsigned int *flags = &bkc_flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      bkc   = curbuf->b_p_bkc;\n      flags = &curbuf->b_bkc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *bkc == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else {\n      if (opt_strings_flags(bkc, p_bkc_values, flags, true) != OK) {\n        errmsg = e_invarg;\n      }\n\n      if (((*flags & BKC_AUTO) != 0)\n          + ((*flags & BKC_YES) != 0)\n          + ((*flags & BKC_NO) != 0) != 1) {\n        // Must have exactly one of \"auto\", \"yes\"  and \"no\".\n        (void)opt_strings_flags(oldval, p_bkc_values, flags, true);\n        errmsg = e_invarg;\n      }\n    }\n  }\n  /* 'backupext' and 'patchmode' */\n  else if (varp == &p_bex || varp == &p_pm) {\n    if (STRCMP(*p_bex == '.' ? p_bex + 1 : p_bex,\n            *p_pm == '.' ? p_pm + 1 : p_pm) == 0)\n      errmsg = (char_u *)N_(\"E589: 'backupext' and 'patchmode' are equal\");\n  }\n  /* 'breakindentopt' */\n  else if (varp == &curwin->w_p_briopt) {\n    if (briopt_check(curwin) == FAIL)\n      errmsg = e_invarg;\n  } else if (varp == &p_isi\n             || varp == &(curbuf->b_p_isk)\n             || varp == &p_isp\n             || varp == &p_isf) {\n    // 'isident', 'iskeyword', 'isprint or 'isfname' option: refill g_chartab[]\n    // If the new option is invalid, use old value.  'lisp' option: refill\n    // g_chartab[] for '-' char\n    if (init_chartab() == FAIL) {\n      did_chartab = TRUE;           /* need to restore it below */\n      errmsg = e_invarg;            /* error in value */\n    }\n  }\n  /* 'helpfile' */\n  else if (varp == &p_hf) {\n    /* May compute new values for $VIM and $VIMRUNTIME */\n    if (didset_vim) {\n      vim_setenv(\"VIM\", \"\");\n      didset_vim = FALSE;\n    }\n    if (didset_vimruntime) {\n      vim_setenv(\"VIMRUNTIME\", \"\");\n      didset_vimruntime = FALSE;\n    }\n  }\n  /* 'colorcolumn' */\n  else if (varp == &curwin->w_p_cc)\n    errmsg = check_colorcolumn(curwin);\n\n  /* 'helplang' */\n  else if (varp == &p_hlg) {\n    /* Check for \"\", \"ab\", \"ab,cd\", etc. */\n    for (s = p_hlg; *s != NUL; s += 3) {\n      if (s[1] == NUL || ((s[2] != ',' || s[3] == NUL) && s[2] != NUL)) {\n        errmsg = e_invarg;\n        break;\n      }\n      if (s[2] == NUL)\n        break;\n    }\n  }\n  /* 'highlight' */\n  else if (varp == &p_hl) {\n    if (highlight_changed() == FAIL)\n      errmsg = e_invarg;        /* invalid flags */\n  }\n  /* 'nrformats' */\n  else if (gvarp == &p_nf) {\n    if (check_opt_strings(*varp, p_nf_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ssop) {  // 'sessionoptions'\n    if (opt_strings_flags(p_ssop, p_ssop_values, &ssop_flags, true) != OK)\n      errmsg = e_invarg;\n    if ((ssop_flags & SSOP_CURDIR) && (ssop_flags & SSOP_SESDIR)) {\n      /* Don't allow both \"sesdir\" and \"curdir\". */\n      (void)opt_strings_flags(oldval, p_ssop_values, &ssop_flags, true);\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_vop) {  // 'viewoptions'\n    if (opt_strings_flags(p_vop, p_ssop_values, &vop_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'scrollopt' */\n  else if (varp == &p_sbo) {\n    if (check_opt_strings(p_sbo, p_scbopt_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_ambw || (int *)varp == &p_emoji) {\n    // 'ambiwidth'\n    if (check_opt_strings(p_ambw, p_ambw_values, false) != OK) {\n      errmsg = e_invarg;\n    } else if (set_chars_option(&p_lcs) != NULL) {\n      errmsg = (char_u *)_(\"E834: Conflicts with value of 'listchars'\");\n    } else if (set_chars_option(&p_fcs) != NULL) {\n      errmsg = (char_u *)_(\"E835: Conflicts with value of 'fillchars'\");\n    }\n  }\n  /* 'background' */\n  else if (varp == &p_bg) {\n    if (check_opt_strings(p_bg, p_bg_values, FALSE) == OK) {\n      int dark = (*p_bg == 'd');\n\n      init_highlight(FALSE, FALSE);\n\n      if (dark != (*p_bg == 'd')\n          && get_var_value((char_u *)\"g:colors_name\") != NULL) {\n        /* The color scheme must have set 'background' back to another\n         * value, that's not what we want here.  Disable the color\n         * scheme and set the colors again. */\n        do_unlet((char_u *)\"g:colors_name\", TRUE);\n        free_string_option(p_bg);\n        p_bg = vim_strsave((char_u *)(dark ? \"dark\" : \"light\"));\n        check_string_option(&p_bg);\n        init_highlight(FALSE, FALSE);\n      }\n    } else\n      errmsg = e_invarg;\n  }\n  /* 'wildmode' */\n  else if (varp == &p_wim) {\n    if (check_opt_wim() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'wildoptions' */\n  else if (varp == &p_wop) {\n    if (check_opt_strings(p_wop, p_wop_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'winaltkeys' */\n  else if (varp == &p_wak) {\n    if (*p_wak == NUL\n        || check_opt_strings(p_wak, p_wak_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'eventignore' */\n  else if (varp == &p_ei) {\n    if (check_ei() == FAIL)\n      errmsg = e_invarg;\n  /* 'encoding' and 'fileencoding' */\n  } else if (varp == &p_enc || gvarp == &p_fenc) {\n    if (gvarp == &p_fenc) {\n      if (!MODIFIABLE(curbuf) && opt_flags != OPT_GLOBAL) {\n        errmsg = e_modifiable;\n      } else if (vim_strchr(*varp, ',') != NULL) {\n        // No comma allowed in 'fileencoding'; catches confusing it\n        // with 'fileencodings'.\n        errmsg = e_invarg;\n      } else {\n        // May show a \"+\" in the title now.\n        redraw_titles();\n        // Add 'fileencoding' to the swap file.\n        ml_setflags(curbuf);\n      }\n    }\n\n    if (errmsg == NULL) {\n      /* canonize the value, so that STRCMP() can be used on it */\n      p = enc_canonize(*varp);\n      xfree(*varp);\n      *varp = p;\n      if (varp == &p_enc) {\n        // only encoding=utf-8 allowed\n        if (STRCMP(p_enc, \"utf-8\") != 0) {\n          errmsg = e_invarg;\n        }\n      }\n    }\n  } else if (varp == &p_penc) {\n    /* Canonize printencoding if VIM standard one */\n    p = enc_canonize(p_penc);\n    xfree(p_penc);\n    p_penc = p;\n  } else if (varp == &curbuf->b_p_keymap) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    } else {\n      // load or unload key mapping tables\n      errmsg = keymap_init();\n    }\n\n    if (errmsg == NULL) {\n      if (*curbuf->b_p_keymap != NUL) {\n        /* Installed a new keymap, switch on using it. */\n        curbuf->b_p_iminsert = B_IMODE_LMAP;\n        if (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n          curbuf->b_p_imsearch = B_IMODE_LMAP;\n      } else {\n        /* Cleared the keymap, may reset 'iminsert' and 'imsearch'. */\n        if (curbuf->b_p_iminsert == B_IMODE_LMAP)\n          curbuf->b_p_iminsert = B_IMODE_NONE;\n        if (curbuf->b_p_imsearch == B_IMODE_LMAP)\n          curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n      }\n      if ((opt_flags & OPT_LOCAL) == 0) {\n        set_iminsert_global();\n        set_imsearch_global();\n      }\n      status_redraw_curbuf();\n    }\n  }\n  /* 'fileformat' */\n  else if (gvarp == &p_ff) {\n    if (!MODIFIABLE(curbuf) && !(opt_flags & OPT_GLOBAL))\n      errmsg = e_modifiable;\n    else if (check_opt_strings(*varp, p_ff_values, FALSE) != OK)\n      errmsg = e_invarg;\n    else {\n      redraw_titles();\n      /* update flag in swap file */\n      ml_setflags(curbuf);\n      /* Redraw needed when switching to/from \"mac\": a CR in the text\n       * will be displayed differently. */\n      if (get_fileformat(curbuf) == EOL_MAC || *oldval == 'm')\n        redraw_curbuf_later(NOT_VALID);\n    }\n  }\n  /* 'fileformats' */\n  else if (varp == &p_ffs) {\n    if (check_opt_strings(p_ffs, p_ff_values, TRUE) != OK) {\n      errmsg = e_invarg;\n    }\n  }\n\n  /* 'matchpairs' */\n  else if (gvarp == &p_mps) {\n    if (has_mbyte) {\n      for (p = *varp; *p != NUL; ++p) {\n        int x2 = -1;\n        int x3 = -1;\n\n        if (*p != NUL)\n          p += mb_ptr2len(p);\n        if (*p != NUL)\n          x2 = *p++;\n        if (*p != NUL) {\n          x3 = mb_ptr2char(p);\n          p += mb_ptr2len(p);\n        }\n        if (x2 != ':' || x3 == -1 || (*p != NUL && *p != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (*p == NUL)\n          break;\n      }\n    } else {\n      /* Check for \"x:y,x:y\" */\n      for (p = *varp; *p != NUL; p += 4) {\n        if (p[1] != ':' || p[2] == NUL || (p[3] != NUL && p[3] != ',')) {\n          errmsg = e_invarg;\n          break;\n        }\n        if (p[3] == NUL)\n          break;\n      }\n    }\n  }\n  /* 'comments' */\n  else if (gvarp == &p_com) {\n    for (s = *varp; *s; ) {\n      while (*s && *s != ':') {\n        if (vim_strchr((char_u *)COM_ALL, *s) == NULL\n            && !ascii_isdigit(*s) && *s != '-') {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n        ++s;\n      }\n      if (*s++ == NUL)\n        errmsg = (char_u *)N_(\"E524: Missing colon\");\n      else if (*s == ',' || *s == NUL)\n        errmsg = (char_u *)N_(\"E525: Zero length string\");\n      if (errmsg != NULL)\n        break;\n      while (*s && *s != ',') {\n        if (*s == '\\\\' && s[1] != NUL)\n          ++s;\n        ++s;\n      }\n      s = skip_to_option_part(s);\n    }\n  }\n  /* 'listchars' */\n  else if (varp == &p_lcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'fillchars' */\n  else if (varp == &p_fcs) {\n    errmsg = set_chars_option(varp);\n  }\n  /* 'cedit' */\n  else if (varp == &p_cedit) {\n    errmsg = check_cedit();\n  }\n  /* 'verbosefile' */\n  else if (varp == &p_vfile) {\n    verbose_stop();\n    if (*p_vfile != NUL && verbose_open() == FAIL)\n      errmsg = e_invarg;\n  /* 'shada' */\n  } else if (varp == &p_shada) {\n    // TODO(ZyX-I): Remove this code in the future, alongside with &viminfo\n    //              option.\n    opt_idx = ((options[opt_idx].fullname[0] == 'v')\n               ? (shada_idx == -1\n                  ? ((shada_idx = findoption((char_u *) \"shada\")))\n                  : shada_idx)\n               : opt_idx);\n    for (s = p_shada; *s; ) {\n      /* Check it's a valid character */\n      if (vim_strchr((char_u *)\"!\\\"%'/:<@cfhnrs\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*s == 'n') {          /* name is always last one */\n        break;\n      } else if (*s == 'r') { /* skip until next ',' */\n        while (*++s && *s != ',')\n          ;\n      } else if (*s == '%') {\n        /* optional number */\n        while (ascii_isdigit(*++s))\n          ;\n      } else if (*s == '!' || *s == 'h' || *s == 'c')\n        ++s;                    /* no extra chars */\n      else {                    /* must have a number */\n        while (ascii_isdigit(*++s))\n          ;\n\n        if (!ascii_isdigit(*(s - 1))) {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E526: Missing number after <%s>\"),\n                transchar_byte(*(s - 1)));\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n      if (*s == ',')\n        ++s;\n      else if (*s) {\n        if (errbuf != NULL)\n          errmsg = (char_u *)N_(\"E527: Missing comma\");\n        else\n          errmsg = (char_u *)\"\";\n        break;\n      }\n    }\n    if (*p_shada && errmsg == NULL && get_shada_parameter('\\'') < 0)\n      errmsg = (char_u *)N_(\"E528: Must specify a ' value\");\n  }\n  /* 'showbreak' */\n  else if (varp == &p_sbr) {\n    for (s = p_sbr; *s; ) {\n      if (ptr2cells(s) != 1)\n        errmsg = (char_u *)N_(\"E595: contains unprintable or wide character\");\n      mb_ptr_adv(s);\n    }\n  }\n\n  /* 'guicursor' */\n  else if (varp == &p_guicursor)\n    errmsg = parse_shape_opt(SHAPE_CURSOR);\n\n  else if (varp == &p_popt)\n    errmsg = parse_printoptions();\n  else if (varp == &p_pmfn)\n    errmsg = parse_printmbfont();\n\n  /* 'langmap' */\n  else if (varp == &p_langmap)\n    langmap_set();\n\n  /* 'breakat' */\n  else if (varp == &p_breakat)\n    fill_breakat_flags();\n\n  /* 'titlestring' and 'iconstring' */\n  else if (varp == &p_titlestring || varp == &p_iconstring) {\n    int flagval = (varp == &p_titlestring) ? STL_IN_TITLE : STL_IN_ICON;\n\n    /* NULL => statusline syntax */\n    if (vim_strchr(*varp, '%') && check_stl_option(*varp) == NULL)\n      stl_syntax |= flagval;\n    else\n      stl_syntax &= ~flagval;\n    did_set_title(varp == &p_iconstring);\n\n  }\n\n  /* 'selection' */\n  else if (varp == &p_sel) {\n    if (*p_sel == NUL\n        || check_opt_strings(p_sel, p_sel_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'selectmode' */\n  else if (varp == &p_slm) {\n    if (check_opt_strings(p_slm, p_slm_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'keymodel' */\n  else if (varp == &p_km) {\n    if (check_opt_strings(p_km, p_km_values, TRUE) != OK)\n      errmsg = e_invarg;\n    else {\n      km_stopsel = (vim_strchr(p_km, 'o') != NULL);\n      km_startsel = (vim_strchr(p_km, 'a') != NULL);\n    }\n  }\n  /* 'mousemodel' */\n  else if (varp == &p_mousem) {\n    if (check_opt_strings(p_mousem, p_mousem_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_swb) {  // 'switchbuf'\n    if (opt_strings_flags(p_swb, p_swb_values, &swb_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'debug' */\n  else if (varp == &p_debug) {\n    if (check_opt_strings(p_debug, p_debug_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_dy) {  // 'display'\n    if (opt_strings_flags(p_dy, p_dy_values, &dy_flags, true) != OK)\n      errmsg = e_invarg;\n    else\n      (void)init_chartab();\n\n  }\n  /* 'eadirection' */\n  else if (varp == &p_ead) {\n    if (check_opt_strings(p_ead, p_ead_values, FALSE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_cb) {  // 'clipboard'\n    if (opt_strings_flags(p_cb, p_cb_values, &cb_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &(curwin->w_s->b_p_spl)  // 'spell'\n             || varp == &(curwin->w_s->b_p_spf)) {\n    // When 'spelllang' or 'spellfile' is set and there is a window for this\n    // buffer in which 'spell' is set load the wordlists.\n    errmsg = did_set_spell_option(varp == &(curwin->w_s->b_p_spf));\n  }\n  /* When 'spellcapcheck' is set compile the regexp program. */\n  else if (varp == &(curwin->w_s->b_p_spc)) {\n    errmsg = compile_cap_prog(curwin->w_s);\n  }\n  /* 'spellsuggest' */\n  else if (varp == &p_sps) {\n    if (spell_check_sps() != OK)\n      errmsg = e_invarg;\n  }\n  /* 'mkspellmem' */\n  else if (varp == &p_msm) {\n    if (spell_check_msm() != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'bufhidden' is set, check for valid value. */\n  else if (gvarp == &p_bh) {\n    if (check_opt_strings(curbuf->b_p_bh, p_bufhidden_values, FALSE) != OK)\n      errmsg = e_invarg;\n  }\n  /* When 'buftype' is set, check for valid value. */\n  else if (gvarp == &p_bt) {\n    if ((curbuf->terminal && curbuf->b_p_bt[0] != 't')\n        || (!curbuf->terminal && curbuf->b_p_bt[0] == 't')\n        || check_opt_strings(curbuf->b_p_bt, p_buftype_values, FALSE) != OK) {\n      errmsg = e_invarg;\n    } else {\n      if (curwin->w_status_height) {\n        curwin->w_redr_status = TRUE;\n        redraw_later(VALID);\n      }\n      curbuf->b_help = (curbuf->b_p_bt[0] == 'h');\n      redraw_titles();\n    }\n  }\n  /* 'statusline' or 'rulerformat' */\n  else if (gvarp == &p_stl || varp == &p_ruf) {\n    int wid;\n\n    if (varp == &p_ruf)         /* reset ru_wid first */\n      ru_wid = 0;\n    s = *varp;\n    if (varp == &p_ruf && *s == '%') {\n      /* set ru_wid if 'ruf' starts with \"%99(\" */\n      if (*++s == '-')          /* ignore a '-' */\n        s++;\n      wid = getdigits_int(&s);\n      if (wid && *s == '(' && (errmsg = check_stl_option(p_ruf)) == NULL)\n        ru_wid = wid;\n      else\n        errmsg = check_stl_option(p_ruf);\n    }\n    /* check 'statusline' only if it doesn't start with \"%!\" */\n    else if (varp == &p_ruf || s[0] != '%' || s[1] != '!')\n      errmsg = check_stl_option(s);\n    if (varp == &p_ruf && errmsg == NULL)\n      comp_col();\n  }\n  /* check if it is a valid value for 'complete' -- Acevedo */\n  else if (gvarp == &p_cpt) {\n    for (s = *varp; *s; ) {\n      while (*s == ',' || *s == ' ')\n        s++;\n      if (!*s)\n        break;\n      if (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL) {\n        errmsg = illegal_char(errbuf, *s);\n        break;\n      }\n      if (*++s != NUL && *s != ',' && *s != ' ') {\n        if (s[-1] == 'k' || s[-1] == 's') {\n          /* skip optional filename after 'k' and 's' */\n          while (*s && *s != ',' && *s != ' ') {\n            if (*s == '\\\\')\n              ++s;\n            ++s;\n          }\n        } else {\n          if (errbuf != NULL) {\n            sprintf((char *)errbuf,\n                _(\"E535: Illegal character after <%c>\"),\n                *--s);\n            errmsg = errbuf;\n          } else\n            errmsg = (char_u *)\"\";\n          break;\n        }\n      }\n    }\n  }\n  /* 'completeopt' */\n  else if (varp == &p_cot) {\n    if (check_opt_strings(p_cot, p_cot_values, true) != OK) {\n      errmsg = e_invarg;\n    } else {\n      completeopt_was_set();\n    }\n  }\n  /* 'pastetoggle': translate key codes like in a mapping */\n  else if (varp == &p_pt) {\n    if (*p_pt) {\n      (void)replace_termcodes(p_pt, STRLEN(p_pt), &p, true, true, false,\n                              CPO_TO_CPO_FLAGS);\n      if (p != NULL) {\n        if (new_value_alloced)\n          free_string_option(p_pt);\n        p_pt = p;\n        new_value_alloced = TRUE;\n      }\n    }\n  }\n  /* 'backspace' */\n  else if (varp == &p_bs) {\n    if (ascii_isdigit(*p_bs)) {\n      if (*p_bs >'2' || p_bs[1] != NUL)\n        errmsg = e_invarg;\n    } else if (check_opt_strings(p_bs, p_bs_values, TRUE) != OK)\n      errmsg = e_invarg;\n  } else if (varp == &p_bo) {\n    if (opt_strings_flags(p_bo, p_bo_values, &bo_flags, true) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_tc) {  // 'tagcase'\n    unsigned int *flags;\n\n    if (opt_flags & OPT_LOCAL) {\n      p = curbuf->b_p_tc;\n      flags = &curbuf->b_tc_flags;\n    } else {\n      p = p_tc;\n      flags = &tc_flags;\n    }\n\n    if ((opt_flags & OPT_LOCAL) && *p == NUL) {\n      // make the local value empty: use the global value\n      *flags = 0;\n    } else if (*p == NUL\n               || opt_strings_flags(p, p_tc_values, flags, false) != OK) {\n      errmsg = e_invarg;\n    }\n  } else if (varp == &p_cmp) {  // 'casemap'\n    if (opt_strings_flags(p_cmp, p_cmp_values, &cmp_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'diffopt' */\n  else if (varp == &p_dip) {\n    if (diffopt_changed() == FAIL)\n      errmsg = e_invarg;\n  }\n  /* 'foldmethod' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdm) {\n    if (check_opt_strings(*varp, p_fdm_values, FALSE) != OK\n        || *curwin->w_p_fdm == NUL)\n      errmsg = e_invarg;\n    else {\n      foldUpdateAll(curwin);\n      if (foldmethodIsDiff(curwin))\n        newFoldLevel();\n    }\n  }\n  /* 'foldexpr' */\n  else if (varp == &curwin->w_p_fde) {\n    if (foldmethodIsExpr(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'foldmarker' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fmr) {\n    p = vim_strchr(*varp, ',');\n    if (p == NULL)\n      errmsg = (char_u *)N_(\"E536: comma required\");\n    else if (p == *varp || p[1] == NUL)\n      errmsg = e_invarg;\n    else if (foldmethodIsMarker(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'commentstring' */\n  else if (gvarp == &p_cms) {\n    if (**varp != NUL && strstr((char *)*varp, \"%s\") == NULL)\n      errmsg = (char_u *)N_(\n                \"E537: 'commentstring' must be empty or contain %s\");\n  } else if (varp == &p_fdo) {  // 'foldopen'\n    if (opt_strings_flags(p_fdo, p_fdo_values, &fdo_flags, true) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldclose' */\n  else if (varp == &p_fcl) {\n    if (check_opt_strings(p_fcl, p_fcl_values, TRUE) != OK)\n      errmsg = e_invarg;\n  }\n  /* 'foldignore' */\n  else if (gvarp == &curwin->w_allbuf_opt.wo_fdi) {\n    if (foldmethodIsIndent(curwin))\n      foldUpdateAll(curwin);\n  } else if (varp == &p_ve) {  // 'virtualedit'\n    if (opt_strings_flags(p_ve, p_ve_values, &ve_flags, true) != OK)\n      errmsg = e_invarg;\n    else if (STRCMP(p_ve, oldval) != 0) {\n      /* Recompute cursor position in case the new 've' setting\n       * changes something. */\n      validate_virtcol();\n      coladvance(curwin->w_virtcol);\n    }\n  } else if (varp == &p_csqf) {\n    if (p_csqf != NULL) {\n      p = p_csqf;\n      while (*p != NUL) {\n        if (vim_strchr((char_u *)CSQF_CMDS, *p) == NULL\n            || p[1] == NUL\n            || vim_strchr((char_u *)CSQF_FLAGS, p[1]) == NULL\n            || (p[2] != NUL && p[2] != ',')) {\n          errmsg = e_invarg;\n          break;\n        } else if (p[2] == NUL)\n          break;\n        else\n          p += 3;\n      }\n    }\n  }\n  /* 'cinoptions' */\n  else if (gvarp == &p_cino) {\n    /* TODO: recognize errors */\n    parse_cino(curbuf);\n  // inccommand\n  } else if (varp == &p_icm) {\n      if (check_opt_strings(p_icm, p_icm_values, false) != OK) {\n        errmsg = e_invarg;\n      }\n  } else if (gvarp == &p_ft) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    }\n  } else if (gvarp == &p_syn) {\n    if (!valid_filetype(*varp)) {\n      errmsg = e_invarg;\n    }\n  } else {\n    // Options that are a list of flags.\n    p = NULL;\n    if (varp == &p_ww)\n      p = (char_u *)WW_ALL;\n    if (varp == &p_shm)\n      p = (char_u *)SHM_ALL;\n    else if (varp == &(p_cpo))\n      p = (char_u *)CPO_VI;\n    else if (varp == &(curbuf->b_p_fo))\n      p = (char_u *)FO_ALL;\n    else if (varp == &curwin->w_p_cocu)\n      p = (char_u *)COCU_ALL;\n    else if (varp == &p_mouse) {\n      p = (char_u *)MOUSE_ALL;\n    }\n    if (p != NULL) {\n      for (s = *varp; *s; ++s)\n        if (vim_strchr(p, *s) == NULL) {\n          errmsg = illegal_char(errbuf, *s);\n          break;\n        }\n    }\n  }\n\n  /*\n   * If error detected, restore the previous value.\n   */\n  if (errmsg != NULL) {\n    if (new_value_alloced)\n      free_string_option(*varp);\n    *varp = oldval;\n    /*\n     * When resetting some values, need to act on it.\n     */\n    if (did_chartab)\n      (void)init_chartab();\n    if (varp == &p_hl)\n      (void)highlight_changed();\n  } else {\n    /* Remember where the option was set. */\n    set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n    /*\n     * Free string options that are in allocated memory.\n     * Use \"free_oldval\", because recursiveness may change the flags under\n     * our fingers (esp. init_highlight()).\n     */\n    if (free_oldval)\n      free_string_option(oldval);\n    if (new_value_alloced)\n      options[opt_idx].flags |= P_ALLOCED;\n    else\n      options[opt_idx].flags &= ~P_ALLOCED;\n\n    if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0\n        && ((int)options[opt_idx].indir & PV_BOTH)) {\n      /* global option with local value set to use global value; free\n       * the local value and make it empty */\n      p = get_varp_scope(&(options[opt_idx]), OPT_LOCAL);\n      free_string_option(*(char_u **)p);\n      *(char_u **)p = empty_option;\n    }\n    /* May set global value for local option. */\n    else if (!(opt_flags & OPT_LOCAL) && opt_flags != OPT_GLOBAL)\n      set_string_option_global(opt_idx, varp);\n\n    /*\n     * Trigger the autocommand only after setting the flags.\n     */\n    /* When 'syntax' is set, load the syntax of that name */\n    if (varp == &(curbuf->b_p_syn)) {\n      apply_autocmds(EVENT_SYNTAX, curbuf->b_p_syn,\n          curbuf->b_fname, TRUE, curbuf);\n    } else if (varp == &(curbuf->b_p_ft)) {\n      /* 'filetype' is set, trigger the FileType autocommand */\n      did_filetype = TRUE;\n      apply_autocmds(EVENT_FILETYPE, curbuf->b_p_ft,\n          curbuf->b_fname, TRUE, curbuf);\n    }\n    if (varp == &(curwin->w_s->b_p_spl)) {\n      char_u fname[200];\n      char_u      *q = curwin->w_s->b_p_spl;\n\n      /* Skip the first name if it is \"cjk\". */\n      if (STRNCMP(q, \"cjk,\", 4) == 0)\n        q += 4;\n\n      /*\n       * Source the spell/LANG.vim in 'runtimepath'.\n       * They could set 'spellcapcheck' depending on the language.\n       * Use the first name in 'spelllang' up to '_region' or\n       * '.encoding'.\n       */\n      for (p = q; *p != NUL; ++p)\n        if (vim_strchr((char_u *)\"_.,\", *p) != NULL)\n          break;\n      vim_snprintf((char *)fname, sizeof(fname), \"spell/%.*s.vim\",\n                   (int)(p - q), q);\n      source_runtime(fname, DIP_ALL);\n    }\n  }\n\n  if (varp == &p_mouse) {\n    if (*p_mouse == NUL) {\n      ui_mouse_off();\n    } else {\n      setmouse();  // in case 'mouse' changed\n    }\n  }\n\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}\n\n/*\n * Simple int comparison function for use with qsort()\n */\nstatic int int_cmp(const void *a, const void *b)\n{\n  return *(const int *)a - *(const int *)b;\n}\n\n/*\n * Handle setting 'colorcolumn' or 'textwidth' in window \"wp\".\n * Returns error message, NULL if it's OK.\n */\nchar_u *check_colorcolumn(win_T *wp)\n{\n  char_u      *s;\n  int col;\n  unsigned int count = 0;\n  int color_cols[256];\n  int j = 0;\n\n  if (wp->w_buffer == NULL)\n    return NULL;      /* buffer was closed */\n\n  for (s = wp->w_p_cc; *s != NUL && count < 255; ) {\n    if (*s == '-' || *s == '+') {\n      /* -N and +N: add to 'textwidth' */\n      col = (*s == '-') ? -1 : 1;\n      ++s;\n      if (!ascii_isdigit(*s))\n        return e_invarg;\n      col = col * getdigits_int(&s);\n      if (wp->w_buffer->b_p_tw == 0)\n        goto skip;          /* 'textwidth' not set, skip this item */\n      assert((col >= 0\n              && wp->w_buffer->b_p_tw <= INT_MAX - col\n              && wp->w_buffer->b_p_tw + col >= INT_MIN)\n             || (col < 0\n                 && wp->w_buffer->b_p_tw >= INT_MIN - col\n                 && wp->w_buffer->b_p_tw + col <= INT_MAX));\n      col += (int)wp->w_buffer->b_p_tw;\n      if (col < 0)\n        goto skip;\n    } else if (ascii_isdigit(*s))\n      col = getdigits_int(&s);\n    else\n      return e_invarg;\n    color_cols[count++] = col - 1;      /* 1-based to 0-based */\nskip:\n    if (*s == NUL)\n      break;\n    if (*s != ',')\n      return e_invarg;\n    if (*++s == NUL)\n      return e_invarg;        /* illegal trailing comma as in \"set cc=80,\" */\n  }\n\n  xfree(wp->w_p_cc_cols);\n  if (count == 0)\n    wp->w_p_cc_cols = NULL;\n  else {\n    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));\n    /* sort the columns for faster usage on screen redraw inside\n     * win_line() */\n    qsort(color_cols, count, sizeof(int), int_cmp);\n\n    for (unsigned int i = 0; i < count; ++i)\n      /* skip duplicates */\n      if (j == 0 || wp->w_p_cc_cols[j - 1] != color_cols[i])\n        wp->w_p_cc_cols[j++] = color_cols[i];\n    wp->w_p_cc_cols[j] = -1;        /* end marker */\n  }\n\n  return NULL;    /* no error */\n}\n\n/*\n * Handle setting 'listchars' or 'fillchars'.\n * Returns error message, NULL if it's OK.\n */\nstatic char_u *set_chars_option(char_u **varp)\n{\n  int round, i, len, entries;\n  char_u      *p, *s;\n  int c1, c2 = 0;\n  struct charstab {\n    int     *cp;\n    char    *name;\n  };\n  static struct charstab filltab[] =\n  {\n    {&fill_stl,     \"stl\"},\n    {&fill_stlnc,   \"stlnc\"},\n    {&fill_vert,    \"vert\"},\n    {&fill_fold,    \"fold\"},\n    {&fill_diff,    \"diff\"},\n  };\n  static struct charstab lcstab[] =\n  {\n    {&lcs_eol,      \"eol\"},\n    {&lcs_ext,      \"extends\"},\n    {&lcs_nbsp,     \"nbsp\"},\n    {&lcs_prec,     \"precedes\"},\n    {&lcs_space,    \"space\"},\n    {&lcs_tab2,     \"tab\"},\n    {&lcs_trail,    \"trail\"},\n    {&lcs_conceal,  \"conceal\"},\n  };\n  struct charstab *tab;\n\n  if (varp == &p_lcs) {\n    tab = lcstab;\n    entries = ARRAY_SIZE(lcstab);\n  } else {\n    tab = filltab;\n    entries = ARRAY_SIZE(filltab);\n  }\n\n  /* first round: check for valid value, second round: assign values */\n  for (round = 0; round <= 1; ++round) {\n    if (round > 0) {\n      /* After checking that the value is valid: set defaults: space for\n       * 'fillchars', NUL for 'listchars' */\n      for (i = 0; i < entries; ++i)\n        if (tab[i].cp != NULL)\n          *(tab[i].cp) = (varp == &p_lcs ? NUL : ' ');\n      if (varp == &p_lcs)\n        lcs_tab1 = NUL;\n      else\n        fill_diff = '-';\n    }\n    p = *varp;\n    while (*p) {\n      for (i = 0; i < entries; ++i) {\n        len = (int)STRLEN(tab[i].name);\n        if (STRNCMP(p, tab[i].name, len) == 0\n            && p[len] == ':'\n            && p[len + 1] != NUL) {\n          s = p + len + 1;\n          c1 = mb_ptr2char_adv(&s);\n          if (mb_char2cells(c1) > 1)\n            continue;\n          if (tab[i].cp == &lcs_tab2) {\n            if (*s == NUL)\n              continue;\n            c2 = mb_ptr2char_adv(&s);\n            if (mb_char2cells(c2) > 1)\n              continue;\n          }\n          if (*s == ',' || *s == NUL) {\n            if (round) {\n              if (tab[i].cp == &lcs_tab2) {\n                lcs_tab1 = c1;\n                lcs_tab2 = c2;\n              } else if (tab[i].cp != NULL)\n                *(tab[i].cp) = c1;\n\n            }\n            p = s;\n            break;\n          }\n        }\n      }\n\n      if (i == entries)\n        return e_invarg;\n      if (*p == ',')\n        ++p;\n    }\n  }\n\n  return NULL;          /* no error */\n}\n\n/*\n * Check validity of options with the 'statusline' format.\n * Return error message or NULL.\n */\nchar_u *check_stl_option(char_u *s)\n{\n  int itemcnt = 0;\n  int groupdepth = 0;\n  static char_u errbuf[80];\n\n  while (*s && itemcnt < STL_MAX_ITEM) {\n    /* Check for valid keys after % sequences */\n    while (*s && *s != '%')\n      s++;\n    if (!*s)\n      break;\n    s++;\n    if (*s != '%' && *s != ')') {\n      itemcnt++;\n    }\n    if (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE) {\n      s++;\n      continue;\n    }\n    if (*s == ')') {\n      s++;\n      if (--groupdepth < 0)\n        break;\n      continue;\n    }\n    if (*s == '-')\n      s++;\n    while (ascii_isdigit(*s))\n      s++;\n    if (*s == STL_USER_HL)\n      continue;\n    if (*s == '.') {\n      s++;\n      while (*s && ascii_isdigit(*s))\n        s++;\n    }\n    if (*s == '(') {\n      groupdepth++;\n      continue;\n    }\n    if (vim_strchr(STL_ALL, *s) == NULL) {\n      return illegal_char(errbuf, *s);\n    }\n    if (*s == '{') {\n      s++;\n      while (*s != '}' && *s)\n        s++;\n      if (*s != '}')\n        return (char_u *)N_(\"E540: Unclosed expression sequence\");\n    }\n  }\n  if (itemcnt >= STL_MAX_ITEM)\n    return (char_u *)N_(\"E541: too many items\");\n  if (groupdepth != 0)\n    return (char_u *)N_(\"E542: unbalanced groups\");\n  return NULL;\n}\n\nstatic char_u *did_set_spell_option(bool is_spellfile)\n{\n  char_u  *errmsg = NULL;\n\n  if (is_spellfile) {\n    int l = (int)STRLEN(curwin->w_s->b_p_spf);\n    if (l > 0\n        && (l < 4 || STRCMP(curwin->w_s->b_p_spf + l - 4, \".add\") != 0)) {\n      errmsg = e_invarg;\n    }\n  }\n\n  if (errmsg == NULL) {\n    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {\n      if (wp->w_buffer == curbuf && wp->w_p_spell) {\n        errmsg = did_set_spelllang(wp);\n        break;\n      }\n    }\n  }\n\n  return errmsg;\n}\n\n/*\n * Set curbuf->b_cap_prog to the regexp program for 'spellcapcheck'.\n * Return error message when failed, NULL when OK.\n */\nstatic char_u *compile_cap_prog(synblock_T *synblock)\n{\n  regprog_T   *rp = synblock->b_cap_prog;\n  char_u      *re;\n\n  if (*synblock->b_p_spc == NUL)\n    synblock->b_cap_prog = NULL;\n  else {\n    /* Prepend a ^ so that we only match at one column */\n    re = concat_str((char_u *)\"^\", synblock->b_p_spc);\n    synblock->b_cap_prog = vim_regcomp(re, RE_MAGIC);\n    xfree(re);\n    if (synblock->b_cap_prog == NULL) {\n      synblock->b_cap_prog = rp;         /* restore the previous program */\n      return e_invarg;\n    }\n  }\n\n  vim_regfree(rp);\n  return NULL;\n}\n\n/*\n * Set the scriptID for an option, taking care of setting the buffer- or\n * window-local value.\n */\nstatic void set_option_scriptID_idx(int opt_idx, int opt_flags, int id)\n{\n  int both = (opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0;\n  int indir = (int)options[opt_idx].indir;\n\n  /* Remember where the option was set.  For local options need to do that\n   * in the buffer or window structure. */\n  if (both || (opt_flags & OPT_GLOBAL) || (indir & (PV_BUF|PV_WIN)) == 0)\n    options[opt_idx].scriptID = id;\n  if (both || (opt_flags & OPT_LOCAL)) {\n    if (indir & PV_BUF)\n      curbuf->b_p_scriptID[indir & PV_MASK] = id;\n    else if (indir & PV_WIN)\n      curwin->w_p_scriptID[indir & PV_MASK] = id;\n  }\n}\n\n/*\n * Set the value of a boolean option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\nstatic char_u *\nset_bool_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u *varp,                      /* pointer to the option variable */\n    int value,                              /* new value */\n    int opt_flags                          /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  int old_value = *(int *)varp;\n\n  /* Disallow changing some options from secure mode */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    return e_secure;\n  }\n\n  *(int *)varp = value;             /* set the new value */\n  /* Remember where the option was set. */\n  set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n\n\n  /* May set global value for local option. */\n  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    *(int *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = value;\n\n  // Ensure that options set to p_force_on cannot be disabled.\n  if ((int *)varp == &p_force_on && p_force_on == FALSE) {\n    p_force_on = TRUE;\n    return e_unsupportedoption;\n  }\n  // Ensure that options set to p_force_off cannot be enabled.\n  else if ((int *)varp == &p_force_off && p_force_off == TRUE) {\n    p_force_off = FALSE;\n    return e_unsupportedoption;\n  }\n  /* 'undofile' */\n  else if ((int *)varp == &curbuf->b_p_udf || (int *)varp == &p_udf) {\n    /* Only take action when the option was set. When reset we do not\n     * delete the undo file, the option may be set again without making\n     * any changes in between. */\n    if (curbuf->b_p_udf || p_udf) {\n      char_u hash[UNDO_HASH_SIZE];\n      buf_T       *save_curbuf = curbuf;\n\n      for (curbuf = firstbuf; curbuf != NULL; curbuf = curbuf->b_next) {\n        /* When 'undofile' is set globally: for every buffer, otherwise\n         * only for the current buffer: Try to read in the undofile,\n         * if one exists, the buffer wasn't changed and the buffer was\n         * loaded */\n        if ((curbuf == save_curbuf\n             || (opt_flags & OPT_GLOBAL) || opt_flags == 0)\n            && !curbufIsChanged() && curbuf->b_ml.ml_mfp != NULL) {\n          u_compute_hash(hash);\n          u_read_undo(NULL, hash, curbuf->b_fname);\n        }\n      }\n      curbuf = save_curbuf;\n    }\n  } else if ((int *)varp == &curbuf->b_p_ro) {\n    /* when 'readonly' is reset globally, also reset readonlymode */\n    if (!curbuf->b_p_ro && (opt_flags & OPT_LOCAL) == 0)\n      readonlymode = FALSE;\n\n    /* when 'readonly' is set may give W10 again */\n    if (curbuf->b_p_ro)\n      curbuf->b_did_warn = false;\n\n    redraw_titles();\n  }\n  /* when 'modifiable' is changed, redraw the window title */\n  else if ((int *)varp == &curbuf->b_p_ma) {\n    redraw_titles();\n  }\n  /* when 'endofline' is changed, redraw the window title */\n  else if ((int *)varp == &curbuf->b_p_eol) {\n    redraw_titles();\n  } else if ((int *)varp == &curbuf->b_p_fixeol) {\n    // when 'fixeol' is changed, redraw the window title\n    redraw_titles();\n  }\n  /* when 'bomb' is changed, redraw the window title and tab page text */\n  else if ((int *)varp == &curbuf->b_p_bomb) {\n    redraw_titles();\n  }\n  /* when 'bin' is set also set some other options */\n  else if ((int *)varp == &curbuf->b_p_bin) {\n    set_options_bin(old_value, curbuf->b_p_bin, opt_flags);\n    redraw_titles();\n  }\n  /* when 'buflisted' changes, trigger autocommands */\n  else if ((int *)varp == &curbuf->b_p_bl && old_value != curbuf->b_p_bl) {\n    apply_autocmds(curbuf->b_p_bl ? EVENT_BUFADD : EVENT_BUFDELETE,\n        NULL, NULL, TRUE, curbuf);\n  }\n  /* when 'swf' is set, create swapfile, when reset remove swapfile */\n  else if ((int *)varp == (int *)&curbuf->b_p_swf) {\n    if (curbuf->b_p_swf && p_uc)\n      ml_open_file(curbuf);                     /* create the swap file */\n    else\n      /* no need to reset curbuf->b_may_swap, ml_open_file() will check\n       * buf->b_p_swf */\n      mf_close_file(curbuf, true);              /* remove the swap file */\n  }\n  /* when 'terse' is set change 'shortmess' */\n  else if ((int *)varp == &p_terse) {\n    char_u  *p;\n\n    p = vim_strchr(p_shm, SHM_SEARCH);\n\n    /* insert 's' in p_shm */\n    if (p_terse && p == NULL) {\n      STRCPY(IObuff, p_shm);\n      STRCAT(IObuff, \"s\");\n      set_string_option_direct((char_u *)\"shm\", -1, IObuff, OPT_FREE, 0);\n    }\n    /* remove 's' from p_shm */\n    else if (!p_terse && p != NULL)\n      STRMOVE(p, p + 1);\n  }\n  /* when 'paste' is set or reset also change other options */\n  else if ((int *)varp == &p_paste) {\n    paste_option_changed();\n  }\n  /* when 'insertmode' is set from an autocommand need to do work here */\n  else if ((int *)varp == &p_im) {\n    if (p_im) {\n      if ((State & INSERT) == 0) {\n        need_start_insertmode = true;\n      }\n      stop_insert_mode = false;\n    } else if (old_value) {  // only reset if it was set previously\n      need_start_insertmode = false;\n      stop_insert_mode = true;\n      if (restart_edit != 0 && mode_displayed) {\n        clear_cmdline = true;  // remove \"(insert)\"\n      }\n      restart_edit = 0;\n    }\n  }\n  /* when 'ignorecase' is set or reset and 'hlsearch' is set, redraw */\n  else if ((int *)varp == &p_ic && p_hls) {\n    redraw_all_later(SOME_VALID);\n  }\n  /* when 'hlsearch' is set or reset: reset no_hlsearch */\n  else if ((int *)varp == &p_hls) {\n    SET_NO_HLSEARCH(FALSE);\n  }\n  /* when 'scrollbind' is set: snapshot the current position to avoid a jump\n   * at the end of normal_cmd() */\n  else if ((int *)varp == &curwin->w_p_scb) {\n    if (curwin->w_p_scb) {\n      do_check_scrollbind(FALSE);\n      curwin->w_scbind_pos = curwin->w_topline;\n    }\n  }\n  /* There can be only one window with 'previewwindow' set. */\n  else if ((int *)varp == &curwin->w_p_pvw) {\n    if (curwin->w_p_pvw) {\n      FOR_ALL_WINDOWS_IN_TAB(win, curtab) {\n        if (win->w_p_pvw && win != curwin) {\n          curwin->w_p_pvw = FALSE;\n          return (char_u *)N_(\"E590: A preview window already exists\");\n        }\n      }\n    }\n  } else if (varp == (char_u *)&(curbuf->b_p_lisp)) {\n    // When 'lisp' option changes include/exclude '-' in\n    // keyword characters.\n    (void)buf_init_chartab(curbuf, false);          // ignore errors\n  } else if ((int *)varp == &p_title) {\n    // when 'title' changed, may need to change the title; same for 'icon'\n    did_set_title(false);\n  } else if ((int *)varp == &p_icon) {\n    did_set_title(true);\n  } else if ((int *)varp == &curbuf->b_changed) {\n    if (!value) {\n      save_file_ff(curbuf);             // Buffer is unchanged\n    }\n    redraw_titles();\n    modified_was_set = value;\n  }\n\n#ifdef BACKSLASH_IN_FILENAME\n  else if ((int *)varp == &p_ssl) {\n    if (p_ssl) {\n      psepc = '/';\n      psepcN = '\\\\';\n      pseps[0] = '/';\n    } else {\n      psepc = '\\\\';\n      psepcN = '/';\n      pseps[0] = '\\\\';\n    }\n\n    /* need to adjust the file name arguments and buffer names. */\n    buflist_slash_adjust();\n    alist_slash_adjust();\n    scriptnames_slash_adjust();\n  }\n#endif\n\n  /* If 'wrap' is set, set w_leftcol to zero. */\n  else if ((int *)varp == &curwin->w_p_wrap) {\n    if (curwin->w_p_wrap)\n      curwin->w_leftcol = 0;\n  } else if ((int *)varp == &p_ea) {\n    if (p_ea && !old_value) {\n      win_equal(curwin, false, 0);\n    }\n  } else if ((int *)varp == &p_acd) {\n    // Change directories when the 'acd' option is set now.\n    do_autochdir();\n  }\n  /* 'diff' */\n  else if ((int *)varp == &curwin->w_p_diff) {\n    /* May add or remove the buffer from the list of diff buffers. */\n    diff_buf_adjust(curwin);\n    if (foldmethodIsDiff(curwin))\n      foldUpdateAll(curwin);\n  }\n\n\n  /* 'spell' */\n  else if ((int *)varp == &curwin->w_p_spell) {\n    if (curwin->w_p_spell) {\n      char_u      *errmsg = did_set_spelllang(curwin);\n      if (errmsg != NULL)\n        EMSG(_(errmsg));\n    }\n  } else if ((int *)varp == &p_altkeymap) {\n    if (old_value != p_altkeymap) {\n      if (!p_altkeymap) {\n        p_hkmap = p_fkmap;\n        p_fkmap = 0;\n      } else {\n        p_fkmap = p_hkmap;\n        p_hkmap = 0;\n      }\n      (void)init_chartab();\n    }\n  }\n\n  /*\n   * In case some second language keymapping options have changed, check\n   * and correct the setting in a consistent way.\n   */\n\n  /*\n   * If hkmap or fkmap are set, reset Arabic keymapping.\n   */\n  if ((p_hkmap || p_fkmap) && p_altkeymap) {\n    p_altkeymap = p_fkmap;\n    curwin->w_p_arab = FALSE;\n    (void)init_chartab();\n  }\n\n  /*\n   * If hkmap set, reset Farsi keymapping.\n   */\n  if (p_hkmap && p_altkeymap) {\n    p_altkeymap = 0;\n    p_fkmap = 0;\n    curwin->w_p_arab = FALSE;\n    (void)init_chartab();\n  }\n\n  /*\n   * If fkmap set, reset Hebrew keymapping.\n   */\n  if (p_fkmap && !p_altkeymap) {\n    p_altkeymap = 1;\n    p_hkmap = 0;\n    curwin->w_p_arab = FALSE;\n    (void)init_chartab();\n  }\n\n  if ((int *)varp == &curwin->w_p_arab) {\n    if (curwin->w_p_arab) {\n      /*\n       * 'arabic' is set, handle various sub-settings.\n       */\n      if (!p_tbidi) {\n        /* set rightleft mode */\n        if (!curwin->w_p_rl) {\n          curwin->w_p_rl = TRUE;\n          changed_window_setting();\n        }\n\n        /* Enable Arabic shaping (major part of what Arabic requires) */\n        if (!p_arshape) {\n          p_arshape = TRUE;\n          redraw_later_clear();\n        }\n      }\n\n      /* Arabic requires a utf-8 encoding, inform the user if its not\n       * set. */\n      if (STRCMP(p_enc, \"utf-8\") != 0) {\n        static char *w_arabic = N_(\n            \"W17: Arabic requires UTF-8, do ':set encoding=utf-8'\");\n\n        msg_source(hl_attr(HLF_W));\n        MSG_ATTR(_(w_arabic), hl_attr(HLF_W));\n        set_vim_var_string(VV_WARNINGMSG, _(w_arabic), -1);\n      }\n\n      /* set 'delcombine' */\n      p_deco = TRUE;\n\n      /* Force-set the necessary keymap for arabic */\n      set_option_value((char_u *)\"keymap\", 0L, (char_u *)\"arabic\",\n          OPT_LOCAL);\n      p_altkeymap = 0;\n      p_hkmap = 0;\n      p_fkmap = 0;\n      (void)init_chartab();\n    } else {\n      /*\n       * 'arabic' is reset, handle various sub-settings.\n       */\n      if (!p_tbidi) {\n        /* reset rightleft mode */\n        if (curwin->w_p_rl) {\n          curwin->w_p_rl = FALSE;\n          changed_window_setting();\n        }\n\n        /* 'arabicshape' isn't reset, it is a global option and\n         * another window may still need it \"on\". */\n      }\n\n      /* 'delcombine' isn't reset, it is a global option and another\n       * window may still want it \"on\". */\n\n      /* Revert to the default keymap */\n      curbuf->b_p_iminsert = B_IMODE_NONE;\n      curbuf->b_p_imsearch = B_IMODE_USE_INSERT;\n    }\n  }\n\n\n  /*\n   * End of handling side effects for bool options.\n   */\n\n  // after handling side effects, call autocommand\n\n  options[opt_idx].flags |= P_WAS_SET;\n\n  if (!starting) {\n    char buf_old[2];\n    char buf_new[2];\n    char buf_type[7];\n    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), \"%d\",\n                 old_value ? true: false);\n    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), \"%d\",\n                 value ? true: false);\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *) options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n  }\n\n  comp_col();                       /* in case 'ruler' or 'showcmd' changed */\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n  check_redraw(options[opt_idx].flags);\n\n  return NULL;\n}\n\n/*\n * Set the value of a number option, and take care of side effects.\n * Returns NULL for success, or an error message for an error.\n */\nstatic char_u *\nset_num_option (\n    int opt_idx,                            /* index in options[] table */\n    char_u *varp,                      /* pointer to the option variable */\n    long value,                             /* new value */\n    char_u *errbuf,                    /* buffer for error messages */\n    size_t errbuflen,                       /* length of \"errbuf\" */\n    int opt_flags                          /* OPT_LOCAL, OPT_GLOBAL and\n                                           OPT_MODELINE */\n)\n{\n  char_u      *errmsg = NULL;\n  long old_value = *(long *)varp;\n  long old_Rows = Rows;                 /* remember old Rows */\n  long old_Columns = Columns;           /* remember old Columns */\n  long        *pp = (long *)varp;\n\n  /* Disallow changing some options from secure mode. */\n  if ((secure || sandbox != 0)\n      && (options[opt_idx].flags & P_SECURE)) {\n    return e_secure;\n  }\n\n  *pp = value;\n  /* Remember where the option was set. */\n  set_option_scriptID_idx(opt_idx, opt_flags, current_SID);\n\n  if (curbuf->b_p_sw < 0) {\n    errmsg = e_positive;\n    curbuf->b_p_sw = curbuf->b_p_ts;\n  }\n\n  /*\n   * Number options that need some action when changed\n   */\n  if (pp == &p_wh || pp == &p_hh) {\n    if (p_wh < 1) {\n      errmsg = e_positive;\n      p_wh = 1;\n    }\n    if (p_wmh > p_wh) {\n      errmsg = e_winheight;\n      p_wh = p_wmh;\n    }\n    if (p_hh < 0) {\n      errmsg = e_positive;\n      p_hh = 0;\n    }\n\n    /* Change window height NOW */\n    if (lastwin != firstwin) {\n      if (pp == &p_wh && curwin->w_height < p_wh)\n        win_setheight((int)p_wh);\n      if (pp == &p_hh && curbuf->b_help && curwin->w_height < p_hh)\n        win_setheight((int)p_hh);\n    }\n  }\n  /* 'winminheight' */\n  else if (pp == &p_wmh) {\n    if (p_wmh < 0) {\n      errmsg = e_positive;\n      p_wmh = 0;\n    }\n    if (p_wmh > p_wh) {\n      errmsg = e_winheight;\n      p_wmh = p_wh;\n    }\n    win_setminheight();\n  } else if (pp == &p_wiw) {\n    if (p_wiw < 1) {\n      errmsg = e_positive;\n      p_wiw = 1;\n    }\n    if (p_wmw > p_wiw) {\n      errmsg = e_winwidth;\n      p_wiw = p_wmw;\n    }\n\n    /* Change window width NOW */\n    if (lastwin != firstwin && curwin->w_width < p_wiw)\n      win_setwidth((int)p_wiw);\n  }\n  /* 'winminwidth' */\n  else if (pp == &p_wmw) {\n    if (p_wmw < 0) {\n      errmsg = e_positive;\n      p_wmw = 0;\n    }\n    if (p_wmw > p_wiw) {\n      errmsg = e_winwidth;\n      p_wmw = p_wiw;\n    }\n    win_setminheight();\n  } else if (pp == &p_ls) {\n    /* (re)set last window status line */\n    last_status(false);\n  }\n  /* (re)set tab page line */\n  else if (pp == &p_stal) {\n    shell_new_rows();           /* recompute window positions and heights */\n  }\n  /* 'foldlevel' */\n  else if (pp == &curwin->w_p_fdl) {\n    if (curwin->w_p_fdl < 0)\n      curwin->w_p_fdl = 0;\n    newFoldLevel();\n  }\n  /* 'foldminlines' */\n  else if (pp == &curwin->w_p_fml) {\n    foldUpdateAll(curwin);\n  }\n  /* 'foldnestmax' */\n  else if (pp == &curwin->w_p_fdn) {\n    if (foldmethodIsSyntax(curwin) || foldmethodIsIndent(curwin))\n      foldUpdateAll(curwin);\n  }\n  /* 'foldcolumn' */\n  else if (pp == &curwin->w_p_fdc) {\n    if (curwin->w_p_fdc < 0) {\n      errmsg = e_positive;\n      curwin->w_p_fdc = 0;\n    } else if (curwin->w_p_fdc > 12) {\n      errmsg = e_invarg;\n      curwin->w_p_fdc = 12;\n    }\n  // 'shiftwidth' or 'tabstop'\n  } else if (pp == &curbuf->b_p_sw || pp == (long *)&curbuf->b_p_ts) {\n    if (foldmethodIsIndent(curwin)) {\n      foldUpdateAll(curwin);\n    }\n    // When 'shiftwidth' changes, or it's zero and 'tabstop' changes:\n    // parse 'cinoptions'.\n    if (pp == &curbuf->b_p_sw || curbuf->b_p_sw == 0) {\n      parse_cino(curbuf);\n    }\n  }\n  /* 'maxcombine' */\n  else if (pp == &p_mco) {\n    if (p_mco > MAX_MCO)\n      p_mco = MAX_MCO;\n    else if (p_mco < 0)\n      p_mco = 0;\n    screenclear();          /* will re-allocate the screen */\n  } else if (pp == &curbuf->b_p_iminsert) {\n    if (curbuf->b_p_iminsert < 0 || curbuf->b_p_iminsert > B_IMODE_LAST) {\n      errmsg = e_invarg;\n      curbuf->b_p_iminsert = B_IMODE_NONE;\n    }\n    p_iminsert = curbuf->b_p_iminsert;\n    showmode();\n    /* Show/unshow value of 'keymap' in status lines. */\n    status_redraw_curbuf();\n  } else if (pp == &p_window) {\n    if (p_window < 1)\n      p_window = 1;\n    else if (p_window >= Rows)\n      p_window = Rows - 1;\n  } else if (pp == &curbuf->b_p_imsearch) {\n    if (curbuf->b_p_imsearch < -1 || curbuf->b_p_imsearch > B_IMODE_LAST) {\n      errmsg = e_invarg;\n      curbuf->b_p_imsearch = B_IMODE_NONE;\n    }\n    p_imsearch = curbuf->b_p_imsearch;\n  }\n  /* if 'titlelen' has changed, redraw the title */\n  else if (pp == &p_titlelen) {\n    if (p_titlelen < 0) {\n      errmsg = e_positive;\n      p_titlelen = 85;\n    }\n    if (starting != NO_SCREEN && old_value != p_titlelen)\n      need_maketitle = TRUE;\n  }\n  /* if p_ch changed value, change the command line height */\n  else if (pp == &p_ch) {\n    if (p_ch < 1) {\n      errmsg = e_positive;\n      p_ch = 1;\n    }\n    if (p_ch > Rows - min_rows() + 1)\n      p_ch = Rows - min_rows() + 1;\n\n    /* Only compute the new window layout when startup has been\n     * completed. Otherwise the frame sizes may be wrong. */\n    if (p_ch != old_value && full_screen\n        )\n      command_height();\n  }\n  /* when 'updatecount' changes from zero to non-zero, open swap files */\n  else if (pp == &p_uc) {\n    if (p_uc < 0) {\n      errmsg = e_positive;\n      p_uc = 100;\n    }\n    if (p_uc && !old_value)\n      ml_open_files();\n  } else if (pp == &curwin->w_p_cole) {\n    if (curwin->w_p_cole < 0) {\n      errmsg = e_positive;\n      curwin->w_p_cole = 0;\n    } else if (curwin->w_p_cole > 3) {\n      errmsg = e_invarg;\n      curwin->w_p_cole = 3;\n    }\n  }\n  /* sync undo before 'undolevels' changes */\n  else if (pp == &p_ul) {\n    /* use the old value, otherwise u_sync() may not work properly */\n    p_ul = old_value;\n    u_sync(TRUE);\n    p_ul = value;\n  } else if (pp == &curbuf->b_p_ul) {\n    /* use the old value, otherwise u_sync() may not work properly */\n    curbuf->b_p_ul = old_value;\n    u_sync(TRUE);\n    curbuf->b_p_ul = value;\n  }\n  /* 'numberwidth' must be positive */\n  else if (pp == &curwin->w_p_nuw) {\n    if (curwin->w_p_nuw < 1) {\n      errmsg = e_positive;\n      curwin->w_p_nuw = 1;\n    }\n    if (curwin->w_p_nuw > 10) {\n      errmsg = e_invarg;\n      curwin->w_p_nuw = 10;\n    }\n    curwin->w_nrwidth_line_count = 0;\n  } else if (pp == &curbuf->b_p_tw) {\n    if (curbuf->b_p_tw < 0) {\n      errmsg = e_positive;\n      curbuf->b_p_tw = 0;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, wp) {\n      check_colorcolumn(wp);\n    }\n\n  }\n\n  /*\n   * Check the bounds for numeric options here\n   */\n  if (Rows < min_rows() && full_screen) {\n    if (errbuf != NULL) {\n      vim_snprintf((char *)errbuf, errbuflen,\n          _(\"E593: Need at least %d lines\"), min_rows());\n      errmsg = errbuf;\n    }\n    Rows = min_rows();\n  }\n  if (Columns < MIN_COLUMNS && full_screen) {\n    if (errbuf != NULL) {\n      vim_snprintf((char *)errbuf, errbuflen,\n          _(\"E594: Need at least %d columns\"), MIN_COLUMNS);\n      errmsg = errbuf;\n    }\n    Columns = MIN_COLUMNS;\n  }\n  limit_screen_size();\n\n\n  /*\n   * If the screen (shell) height has been changed, assume it is the\n   * physical screenheight.\n   */\n  if (old_Rows != Rows || old_Columns != Columns) {\n    /* Changing the screen size is not allowed while updating the screen. */\n    if (updating_screen) {\n      *pp = old_value;\n    } else if (full_screen) {\n      screen_resize((int)Columns, (int)Rows);\n    } else {\n      /* Postpone the resizing; check the size and cmdline position for\n       * messages. */\n      check_shellsize();\n      if (cmdline_row > Rows - p_ch && Rows > p_ch) {\n        assert(p_ch >= 0 && Rows - p_ch <= INT_MAX);\n        cmdline_row = (int)(Rows - p_ch);\n      }\n    }\n    if (p_window >= Rows || !option_was_set((char_u *)\"window\"))\n      p_window = Rows - 1;\n  }\n\n  if (curbuf->b_p_ts <= 0) {\n    errmsg = e_positive;\n    curbuf->b_p_ts = 8;\n  }\n  if (p_tm < 0) {\n    errmsg = e_positive;\n    p_tm = 0;\n  }\n  if ((curwin->w_p_scr <= 0\n       || (curwin->w_p_scr > curwin->w_height\n           && curwin->w_height > 0))\n      && full_screen) {\n    if (pp == &(curwin->w_p_scr)) {\n      if (curwin->w_p_scr != 0)\n        errmsg = e_scroll;\n      win_comp_scroll(curwin);\n    }\n    /* If 'scroll' became invalid because of a side effect silently adjust\n     * it. */\n    else if (curwin->w_p_scr <= 0)\n      curwin->w_p_scr = 1;\n    else     /* curwin->w_p_scr > curwin->w_height */\n      curwin->w_p_scr = curwin->w_height;\n  }\n  if (p_hi < 0) {\n    errmsg = e_positive;\n    p_hi = 0;\n  } else if (p_hi > 10000) {\n    errmsg = e_invarg;\n    p_hi = 10000;\n  }\n  if (p_re < 0 || p_re > 2) {\n    errmsg = e_invarg;\n    p_re = 0;\n  }\n  if (p_report < 0) {\n    errmsg = e_positive;\n    p_report = 1;\n  }\n  if ((p_sj < -100 || p_sj >= Rows) && full_screen) {\n    if (Rows != old_Rows)       /* Rows changed, just adjust p_sj */\n      p_sj = Rows / 2;\n    else {\n      errmsg = e_scroll;\n      p_sj = 1;\n    }\n  }\n  if (p_so < 0 && full_screen) {\n    errmsg = e_scroll;\n    p_so = 0;\n  }\n  if (p_siso < 0 && full_screen) {\n    errmsg = e_positive;\n    p_siso = 0;\n  }\n  if (p_cwh < 1) {\n    errmsg = e_positive;\n    p_cwh = 1;\n  }\n  if (p_ut < 0) {\n    errmsg = e_positive;\n    p_ut = 2000;\n  }\n  if (p_ss < 0) {\n    errmsg = e_positive;\n    p_ss = 0;\n  }\n\n  /* May set global value for local option. */\n  if ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0)\n    *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL) = *pp;\n\n  options[opt_idx].flags |= P_WAS_SET;\n\n  if (!starting && errmsg == NULL) {\n    char buf_old[NUMBUFLEN];\n    char buf_new[NUMBUFLEN];\n    char buf_type[7];\n    vim_snprintf(buf_old, ARRAY_SIZE(buf_old), \"%ld\", old_value);\n    vim_snprintf(buf_new, ARRAY_SIZE(buf_new), \"%ld\", value);\n    vim_snprintf(buf_type, ARRAY_SIZE(buf_type), \"%s\",\n                 (opt_flags & OPT_LOCAL) ? \"local\" : \"global\");\n    set_vim_var_string(VV_OPTION_NEW, buf_new, -1);\n    set_vim_var_string(VV_OPTION_OLD, buf_old, -1);\n    set_vim_var_string(VV_OPTION_TYPE, buf_type, -1);\n    apply_autocmds(EVENT_OPTIONSET,\n                   (char_u *) options[opt_idx].fullname,\n                   NULL, false, NULL);\n    reset_v_option_vars();\n  }\n\n  comp_col();                       /* in case 'columns' or 'ls' changed */\n  if (curwin->w_curswant != MAXCOL\n      && (options[opt_idx].flags & (P_CURSWANT | P_RALL)) != 0)\n    curwin->w_set_curswant = TRUE;\n  check_redraw(options[opt_idx].flags);\n\n  return errmsg;\n}\n\n/*\n * Called after an option changed: check if something needs to be redrawn.\n */\nstatic void check_redraw(uint32_t flags)\n{\n  /* Careful: P_RCLR and P_RALL are a combination of other P_ flags */\n  bool doclear = (flags & P_RCLR) == P_RCLR;\n  bool all = ((flags & P_RALL) == P_RALL || doclear);\n\n  if ((flags & P_RSTAT) || all)         /* mark all status lines dirty */\n    status_redraw_all();\n\n  if ((flags & P_RBUF) || (flags & P_RWIN) || all)\n    changed_window_setting();\n  if (flags & P_RBUF)\n    redraw_curbuf_later(NOT_VALID);\n  if (doclear)\n    redraw_all_later(CLEAR);\n  else if (all)\n    redraw_all_later(NOT_VALID);\n}\n\n/// Find index for named option\n///\n/// @param[in]  arg  Option to find index for.\n/// @param[in]  len  Length of the option.\n///\n/// @return Index of the option or -1 if option was not found.\nint findoption_len(const char_u *const arg, const size_t len)\n{\n  char *s, *p;\n  static int quick_tab[27] = { 0, 0 };  // quick access table\n  int is_term_opt;\n\n  /*\n   * For first call: Initialize the quick-access table.\n   * It contains the index for the first option that starts with a certain\n   * letter.  There are 26 letters, plus the first \"t_\" option.\n   */\n  if (quick_tab[1] == 0) {\n    p = options[0].fullname;\n    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {\n      if (s[0] != p[0]) {\n        if (s[0] == 't' && s[1] == '_')\n          quick_tab[26] = i;\n        else\n          quick_tab[CharOrdLow(s[0])] = i;\n      }\n      p = s;\n    }\n  }\n\n  /*\n   * Check for name starting with an illegal character.\n   */\n  if (len == 0 || arg[0] < 'a' || arg[0] > 'z') {\n    return -1;\n  }\n\n  int opt_idx;\n  is_term_opt = (len > 2 && arg[0] == 't' && arg[1] == '_');\n  if (is_term_opt) {\n    opt_idx = quick_tab[26];\n  } else {\n    opt_idx = quick_tab[CharOrdLow(arg[0])];\n  }\n  // Match full name\n  for (; (s = options[opt_idx].fullname) != NULL; opt_idx++) {\n    if (STRNCMP(arg, s, len) == 0 && s[len] == NUL) {\n      break;\n    }\n  }\n  if (s == NULL && !is_term_opt) {\n    opt_idx = quick_tab[CharOrdLow(arg[0])];\n    // Match short name\n    for (; options[opt_idx].fullname != NULL; opt_idx++) {\n      s = options[opt_idx].shortname;\n      if (s != NULL && STRNCMP(arg, s, len) == 0 && s[len] == NUL) {\n        break;\n      }\n      s = NULL;\n    }\n  }\n  if (s == NULL)\n    opt_idx = -1;\n  return opt_idx;\n}\n\nbool is_tty_option(char *name)\n{\n  return (name[0] == 't' && name[1] == '_') || !strcmp((char *)name, \"term\");\n}\n\n#define TCO_BUFFER_SIZE 8\nbool get_tty_option(char *name, char **value)\n{\n  if (!strcmp(name, \"t_Co\")) {\n    if (value) {\n      if (t_colors <= 1) {\n        *value = xstrdup(\"\");\n      } else {\n        *value = xmalloc(TCO_BUFFER_SIZE);\n        snprintf(*value, TCO_BUFFER_SIZE, \"%d\", t_colors);\n      }\n    }\n    return true;\n  }\n\n  if (!strcmp(name, \"term\") || !strcmp(name, \"ttytype\")) {\n    if (value) {\n      *value = xstrdup(\"nvim\");\n    }\n    return true;\n  }\n\n  if (is_tty_option(name)) {\n    if (value) {\n      // XXX: All other t_* options were removed in 3baba1e7.\n      *value = xstrdup(\"\");\n    }\n    return true;\n  }\n\n  return false;\n}\n\nbool set_tty_option(char *name, char *value)\n{\n  if (!strcmp(name, \"t_Co\")) {\n    int colors = atoi(value);\n\n    // Only reinitialize colors if t_Co value has really changed to\n    // avoid expensive reload of colorscheme if t_Co is set to the\n    // same value multiple times\n    if (colors != t_colors) {\n      t_colors = colors;\n      // We now have a different color setup, initialize it again.\n      init_highlight(TRUE, FALSE);\n    }\n\n    return true;\n  }\n\n  return is_tty_option(name) || !strcmp(name, \"term\")\n    || !strcmp(name, \"ttytype\");\n}\n\n/*\n * Find index for option 'arg'.\n * Return -1 if not found.\n */\nstatic int findoption(char_u *arg)\n{\n  return findoption_len(arg, STRLEN(arg));\n}\n\n/*\n * Get the value for an option.\n *\n * Returns:\n * Number or Toggle option: 1, *numval gets value.\n *\t     String option: 0, *stringval gets allocated string.\n * Hidden Number or Toggle option: -1.\n *\t     hidden String option: -2.\n *\t\t   unknown option: -3.\n */\nint \nget_option_value (\n    char_u *name,\n    long *numval,\n    char_u **stringval,            /* NULL when only checking existence */\n    int opt_flags\n)\n{\n  if (get_tty_option((char *)name, (char **)stringval)) {\n    return 0;\n  }\n\n  int opt_idx;\n  char_u      *varp;\n\n  opt_idx = findoption(name);\n  if (opt_idx < 0)                  /* unknown option */\n    return -3;\n\n  varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\n  if (options[opt_idx].flags & P_STRING) {\n    if (varp == NULL)                       /* hidden option */\n      return -2;\n    if (stringval != NULL) {\n      *stringval = vim_strsave(*(char_u **)(varp));\n    }\n    return 0;\n  }\n\n  if (varp == NULL)                 /* hidden option */\n    return -1;\n  if (options[opt_idx].flags & P_NUM)\n    *numval = *(long *)varp;\n  else {\n    /* Special case: 'modified' is b_changed, but we also want to consider\n     * it set when 'ff' or 'fenc' changed. */\n    if ((int *)varp == &curbuf->b_changed) {\n      *numval = curbufIsChanged();\n    } else {\n      *numval = *(int *)varp;\n    }\n  }\n  return 1;\n}\n\n// Returns the option attributes and its value. Unlike the above function it\n// will return either global value or local value of the option depending on\n// what was requested, but it will never return global value if it was\n// requested to return local one and vice versa. Neither it will return\n// buffer-local value if it was requested to return window-local one.\n//\n// Pretends that option is absent if it is not present in the requested scope\n// (i.e. has no global, window-local or buffer-local value depending on\n// opt_type). Uses\n//\n// Returned flags:\n//       0 hidden or unknown option, also option that does not have requested \n//         type (see SREQ_* in option_defs.h)\n//  see SOPT_* in option_defs.h for other flags\n//\n// Possible opt_type values: see SREQ_* in option_defs.h\nint get_option_value_strict(char *name,\n                            int64_t *numval,\n                            char **stringval,\n                            int opt_type,\n                            void *from)\n{\n  if (get_tty_option(name, stringval)) {\n    return SOPT_STRING | SOPT_GLOBAL;\n  }\n\n  char_u *varp = NULL;\n  vimoption_T *p;\n  int rv = 0;\n  int opt_idx = findoption((uint8_t *)name);\n  if (opt_idx < 0) {\n    return 0;\n  }\n\n  p = &(options[opt_idx]);\n\n  // Hidden option\n  if (p->var == NULL) {\n    return 0;\n  }\n\n  if (p->flags & P_BOOL) {\n    rv |= SOPT_BOOL;\n  } else if (p->flags & P_NUM) {\n    rv |= SOPT_NUM;\n  } else if (p->flags & P_STRING) {\n    rv |= SOPT_STRING;\n  }\n\n  if (p->indir == PV_NONE) {\n    if (opt_type == SREQ_GLOBAL)\n      rv |= SOPT_GLOBAL;\n    else\n      return 0; // Did not request global-only option\n  } else {\n    if (p->indir & PV_BOTH) {\n      rv |= SOPT_GLOBAL;\n    } else if (opt_type == SREQ_GLOBAL) {\n      return 0; // Requested global option\n    }\n\n    if (p->indir & PV_WIN) {\n      if (opt_type == SREQ_BUF) {\n        return 0; // Did not request window-local option\n      } else {\n        rv |= SOPT_WIN;\n      }\n    } else if (p->indir & PV_BUF) {\n      if (opt_type == SREQ_WIN) {\n        return 0; // Did not request buffer-local option\n      } else {\n        rv |= SOPT_BUF;\n      }\n    }\n  }\n\n  if (stringval == NULL) {\n    return rv;\n  }\n\n  if (opt_type == SREQ_GLOBAL) {\n    varp = p->var;\n  } else {\n    if (opt_type == SREQ_BUF) {\n      // Special case: 'modified' is b_changed, but we also want to\n      // consider it set when 'ff' or 'fenc' changed.\n      if (p->indir == PV_MOD) {\n        *numval = bufIsChanged((buf_T *) from);\n        varp = NULL;\n      } else {\n        aco_save_T\taco;\n        aucmd_prepbuf(&aco, (buf_T *) from);\n        varp = get_varp(p);\n        aucmd_restbuf(&aco);\n      }\n    } else if (opt_type == SREQ_WIN) {\n      win_T\t*save_curwin;\n      save_curwin = curwin;\n      curwin = (win_T *) from;\n      curbuf = curwin->w_buffer;\n      varp = get_varp(p);\n      curwin = save_curwin;\n      curbuf = curwin->w_buffer;\n    }\n\n    if (varp == p->var) {\n      return (rv | SOPT_UNSET);\n    }\n  }\n\n  if (varp != NULL) {\n    if (p->flags & P_STRING) {\n      *stringval = xstrdup(*(char **)(varp));\n    } else if (p->flags & P_NUM) {\n      *numval = *(long *) varp;\n    } else {\n      *numval = *(int *)varp;\n    }\n  }\n\n  return rv;\n}\n\n/*\n * Set the value of option \"name\".\n * Use \"string\" for string options, use \"number\" for other options.\n *\n * Returns NULL on success or error message on error.\n */\nchar_u *\nset_option_value (\n    char_u *name,\n    long number,\n    char_u *string,\n    int opt_flags                  /* OPT_LOCAL or 0 (both) */\n)\n{\n  if (set_tty_option((char *)name, (char *)string)) {\n    return NULL;\n  }\n\n  int opt_idx;\n  char_u      *varp;\n\n  opt_idx = findoption(name);\n  if (opt_idx < 0)\n    EMSG2(_(\"E355: Unknown option: %s\"), name);\n  else {\n    uint32_t flags = options[opt_idx].flags;\n    // Disallow changing some options in the sandbox\n    if (sandbox > 0 && (flags & P_SECURE)) {\n      EMSG(_(e_sandbox));\n      return NULL;\n    }\n    if (flags & P_STRING) {\n      const char *s = (const char *)string;\n      if (s == NULL) {\n        s = \"\";\n      }\n      return (char_u *)set_string_option(opt_idx, s, opt_flags);\n    } else {\n      varp = get_varp_scope(&(options[opt_idx]), opt_flags);\n      if (varp != NULL) {       /* hidden option is not changed */\n        if (number == 0 && string != NULL) {\n          int idx;\n\n          // Either we are given a string or we are setting option\n          // to zero.\n          for (idx = 0; string[idx] == '0'; idx++) {}\n          if (string[idx] != NUL || idx == 0) {\n            // There's another character after zeros or the string\n            // is empty.  In both cases, we are trying to set a\n            // num option using a string.\n            EMSG3(_(\"E521: Number required: &%s = '%s'\"),\n                  name, string);\n            return NULL;  // do nothing as we hit an error\n          }\n        }\n        if (flags & P_NUM)\n          return set_num_option(opt_idx, varp, number,\n              NULL, 0, opt_flags);\n        else\n          return set_bool_option(opt_idx, varp, (int)number,\n              opt_flags);\n      }\n    }\n  }\n  return NULL;\n}\n\nchar_u *get_highlight_default(void)\n{\n  int i;\n\n  i = findoption((char_u *)\"hl\");\n  if (i >= 0)\n    return options[i].def_val[VI_DEFAULT];\n  return (char_u *)NULL;\n}\n\n/*\n * Translate a string like \"t_xx\", \"<t_xx>\" or \"<S-Tab>\" to a key number.\n */\nint find_key_option_len(const char_u *arg, size_t len)\n{\n  int key;\n  int modifiers;\n\n  // Don't use get_special_key_code() for t_xx, we don't want it to call\n  // add_termcap_entry().\n  if (len >= 4 && arg[0] == 't' && arg[1] == '_') {\n    key = TERMCAP2KEY(arg[2], arg[3]);\n  } else {\n    arg--;  // put arg at the '<'\n    modifiers = 0;\n    key = find_special_key(&arg, len + 1, &modifiers, true, true);\n    if (modifiers) {  // can't handle modifiers here\n      key = 0;\n    }\n  }\n  return key;\n}\n\nstatic int find_key_option(const char_u *arg)\n{\n  return find_key_option_len(arg, STRLEN(arg));\n}\n\n\n/*\n * if 'all' == 0: show changed options\n * if 'all' == 1: show all normal options\n */\nstatic void \nshowoptions (\n    int all,\n    int opt_flags                  /* OPT_LOCAL and/or OPT_GLOBAL */\n)\n{\n  vimoption_T    *p;\n  int col;\n  char_u              *varp;\n  int item_count;\n  int run;\n  int row, rows;\n  int cols;\n  int i;\n  int len;\n\n#define INC 20\n#define GAP 3\n\n  vimoption_T **items = xmalloc(sizeof(vimoption_T *) * PARAM_COUNT);\n\n  /* Highlight title */\n  if (all == 2)\n    MSG_PUTS_TITLE(_(\"\\n--- Terminal codes ---\"));\n  else if (opt_flags & OPT_GLOBAL)\n    MSG_PUTS_TITLE(_(\"\\n--- Global option values ---\"));\n  else if (opt_flags & OPT_LOCAL)\n    MSG_PUTS_TITLE(_(\"\\n--- Local option values ---\"));\n  else\n    MSG_PUTS_TITLE(_(\"\\n--- Options ---\"));\n\n  /*\n   * do the loop two times:\n   * 1. display the short items\n   * 2. display the long items (only strings and numbers)\n   */\n  for (run = 1; run <= 2 && !got_int; ++run) {\n    /*\n     * collect the items in items[]\n     */\n    item_count = 0;\n    for (p = &options[0]; p->fullname != NULL; p++) {\n      varp = NULL;\n      if (opt_flags != 0) {\n        if (p->indir != PV_NONE)\n          varp = get_varp_scope(p, opt_flags);\n      } else\n        varp = get_varp(p);\n      if (varp != NULL\n          && (all == 1 || (all == 0 && !optval_default(p, varp)))) {\n        if (p->flags & P_BOOL)\n          len = 1;                      /* a toggle option fits always */\n        else {\n          option_value2string(p, opt_flags);\n          len = (int)STRLEN(p->fullname) + vim_strsize(NameBuff) + 1;\n        }\n        if ((len <= INC - GAP && run == 1)\n            || (len > INC - GAP && run == 2)) {\n          items[item_count++] = p;\n        }\n      }\n    }\n\n    /*\n     * display the items\n     */\n    if (run == 1) {\n      assert(Columns <= LONG_MAX - GAP\n             && Columns + GAP >= LONG_MIN + 3\n             && (Columns + GAP - 3) / INC >= INT_MIN\n             && (Columns + GAP - 3) / INC <= INT_MAX);\n      cols = (int)((Columns + GAP - 3) / INC);\n      if (cols == 0)\n        cols = 1;\n      rows = (item_count + cols - 1) / cols;\n    } else      /* run == 2 */\n      rows = item_count;\n    for (row = 0; row < rows && !got_int; ++row) {\n      msg_putchar('\\n');                        /* go to next line */\n      if (got_int)                              /* 'q' typed in more */\n        break;\n      col = 0;\n      for (i = row; i < item_count; i += rows) {\n        msg_col = col;                          /* make columns */\n        showoneopt(items[i], opt_flags);\n        col += INC;\n      }\n      ui_flush();\n      os_breakcheck();\n    }\n  }\n  xfree(items);\n}\n\n/*\n * Return TRUE if option \"p\" has its default value.\n */\nstatic int optval_default(vimoption_T *p, char_u *varp)\n{\n  int dvi;\n\n  if (varp == NULL)\n    return TRUE;            /* hidden option is always at default */\n  dvi = ((p->flags & P_VI_DEF) || p_cp) ? VI_DEFAULT : VIM_DEFAULT;\n  if (p->flags & P_NUM)\n    return *(long *)varp == (long)p->def_val[dvi];\n  if (p->flags & P_BOOL)\n    return *(int *)varp == (int)(intptr_t)p->def_val[dvi];\n  /* P_STRING */\n  return STRCMP(*(char_u **)varp, p->def_val[dvi]) == 0;\n}\n\n/*\n * showoneopt: show the value of one option\n * must not be called with a hidden option!\n */\nstatic void \nshowoneopt (\n    vimoption_T *p,\n    int opt_flags                          /* OPT_LOCAL or OPT_GLOBAL */\n)\n{\n  char_u      *varp;\n  int save_silent = silent_mode;\n\n  silent_mode = FALSE;\n  info_message = TRUE;          /* use mch_msg(), not mch_errmsg() */\n\n  varp = get_varp_scope(p, opt_flags);\n\n  // for 'modified' we also need to check if 'ff' or 'fenc' changed.\n  if ((p->flags & P_BOOL) && ((int *)varp == &curbuf->b_changed\n                              ? !curbufIsChanged() : !*(int *)varp)) {\n    MSG_PUTS(\"no\");\n  } else if ((p->flags & P_BOOL) && *(int *)varp < 0) {\n    MSG_PUTS(\"--\");\n  } else {\n    MSG_PUTS(\"  \");\n  }\n  MSG_PUTS(p->fullname);\n  if (!(p->flags & P_BOOL)) {\n    msg_putchar('=');\n    /* put value string in NameBuff */\n    option_value2string(p, opt_flags);\n    msg_outtrans(NameBuff);\n  }\n\n  silent_mode = save_silent;\n  info_message = FALSE;\n}\n\n/*\n * Write modified options as \":set\" commands to a file.\n *\n * There are three values for \"opt_flags\":\n * OPT_GLOBAL:\t\t   Write global option values and fresh values of\n *\t\t\t   buffer-local options (used for start of a session\n *\t\t\t   file).\n * OPT_GLOBAL + OPT_LOCAL: Idem, add fresh values of window-local options for\n *\t\t\t   curwin (used for a vimrc file).\n * OPT_LOCAL:\t\t   Write buffer-local option values for curbuf, fresh\n *\t\t\t   and local values for window-local options of\n *\t\t\t   curwin.  Local values are also written when at the\n *\t\t\t   default value, because a modeline or autocommand\n *\t\t\t   may have set them when doing \":edit file\" and the\n *\t\t\t   user has set them back at the default or fresh\n *\t\t\t   value.\n *\t\t\t   When \"local_only\" is TRUE, don't write fresh\n *\t\t\t   values, only local values (for \":mkview\").\n * (fresh value = value used for a new buffer or window for a local option).\n *\n * Return FAIL on error, OK otherwise.\n */\nint makeset(FILE *fd, int opt_flags, int local_only)\n{\n  vimoption_T    *p;\n  char_u              *varp;                    /* currently used value */\n  char_u              *varp_fresh;              /* local value */\n  char_u              *varp_local = NULL;       /* fresh value */\n  char                *cmd;\n  int round;\n  int pri;\n\n  /*\n   * Some options are never written:\n   * - Options that don't have a default (terminal name, columns, lines).\n   * - Terminal options.\n   * - Hidden options.\n   *\n   * Do the loop over \"options[]\" twice: once for options with the\n   * P_PRI_MKRC flag and once without.\n   */\n  for (pri = 1; pri >= 0; --pri) {\n    for (p = &options[0]; p->fullname; p++)\n      if (!(p->flags & P_NO_MKRC)\n          && ((pri == 1) == ((p->flags & P_PRI_MKRC) != 0))) {\n        /* skip global option when only doing locals */\n        if (p->indir == PV_NONE && !(opt_flags & OPT_GLOBAL))\n          continue;\n\n        /* Do not store options like 'bufhidden' and 'syntax' in a vimrc\n         * file, they are always buffer-specific. */\n        if ((opt_flags & OPT_GLOBAL) && (p->flags & P_NOGLOB))\n          continue;\n\n        varp = get_varp_scope(p, opt_flags);\n        /* Hidden options are never written. */\n        if (!varp)\n          continue;\n        /* Global values are only written when not at the default value. */\n        if ((opt_flags & OPT_GLOBAL) && optval_default(p, varp))\n          continue;\n\n        round = 2;\n        if (p->indir != PV_NONE) {\n          if (p->var == VAR_WIN) {\n            /* skip window-local option when only doing globals */\n            if (!(opt_flags & OPT_LOCAL))\n              continue;\n            /* When fresh value of window-local option is not at the\n             * default, need to write it too. */\n            if (!(opt_flags & OPT_GLOBAL) && !local_only) {\n              varp_fresh = get_varp_scope(p, OPT_GLOBAL);\n              if (!optval_default(p, varp_fresh)) {\n                round = 1;\n                varp_local = varp;\n                varp = varp_fresh;\n              }\n            }\n          }\n        }\n\n        /* Round 1: fresh value for window-local options.\n         * Round 2: other values */\n        for (; round <= 2; varp = varp_local, ++round) {\n          if (round == 1 || (opt_flags & OPT_GLOBAL))\n            cmd = \"set\";\n          else\n            cmd = \"setlocal\";\n\n          if (p->flags & P_BOOL) {\n            if (put_setbool(fd, cmd, p->fullname, *(int *)varp) == FAIL)\n              return FAIL;\n          } else if (p->flags & P_NUM) {\n            if (put_setnum(fd, cmd, p->fullname, (long *)varp) == FAIL)\n              return FAIL;\n          } else {    /* P_STRING */\n            int do_endif = FALSE;\n\n            // Don't set 'syntax' and 'filetype' again if the value is\n            // already right, avoids reloading the syntax file.\n            if (p->indir == PV_SYN || p->indir == PV_FT) {\n              if (fprintf(fd, \"if &%s != '%s'\", p->fullname,\n                          *(char_u **)(varp)) < 0\n                  || put_eol(fd) < 0) {\n                return FAIL;\n              }\n              do_endif = true;\n            }\n            if (put_setstring(fd, cmd, p->fullname, (char_u **)varp,\n                    (p->flags & P_EXPAND) != 0) == FAIL)\n              return FAIL;\n            if (do_endif) {\n              if (put_line(fd, \"endif\") == FAIL)\n                return FAIL;\n            }\n          }\n        }\n      }\n  }\n  return OK;\n}\n\n/*\n * Generate set commands for the local fold options only.  Used when\n * 'sessionoptions' or 'viewoptions' contains \"folds\" but not \"options\".\n */\nint makefoldset(FILE *fd)\n{\n  if (put_setstring(fd, \"setlocal\", \"fdm\", &curwin->w_p_fdm, FALSE) == FAIL\n      || put_setstring(fd, \"setlocal\", \"fde\", &curwin->w_p_fde, FALSE)\n      == FAIL\n      || put_setstring(fd, \"setlocal\", \"fmr\", &curwin->w_p_fmr, FALSE)\n      == FAIL\n      || put_setstring(fd, \"setlocal\", \"fdi\", &curwin->w_p_fdi, FALSE)\n      == FAIL\n      || put_setnum(fd, \"setlocal\", \"fdl\", &curwin->w_p_fdl) == FAIL\n      || put_setnum(fd, \"setlocal\", \"fml\", &curwin->w_p_fml) == FAIL\n      || put_setnum(fd, \"setlocal\", \"fdn\", &curwin->w_p_fdn) == FAIL\n      || put_setbool(fd, \"setlocal\", \"fen\", curwin->w_p_fen) == FAIL\n      )\n    return FAIL;\n\n  return OK;\n}\n\nstatic int put_setstring(FILE *fd, char *cmd, char *name, char_u **valuep, int expand)\n{\n  char_u      *s;\n  char_u      *buf;\n\n  if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n    return FAIL;\n  if (*valuep != NULL) {\n    /* Output 'pastetoggle' as key names.  For other\n     * options some characters have to be escaped with\n     * CTRL-V or backslash */\n    if (valuep == &p_pt) {\n      s = *valuep;\n      while (*s != NUL)\n        if (put_escstr(fd, str2special(&s, FALSE), 2) == FAIL)\n          return FAIL;\n    } else if (expand) {\n      buf = xmalloc(MAXPATHL);\n      home_replace(NULL, *valuep, buf, MAXPATHL, FALSE);\n      if (put_escstr(fd, buf, 2) == FAIL) {\n        xfree(buf);\n        return FAIL;\n      }\n      xfree(buf);\n    } else if (put_escstr(fd, *valuep, 2) == FAIL)\n      return FAIL;\n  }\n  if (put_eol(fd) < 0)\n    return FAIL;\n  return OK;\n}\n\nstatic int put_setnum(FILE *fd, char *cmd, char *name, long *valuep)\n{\n  long wc;\n\n  if (fprintf(fd, \"%s %s=\", cmd, name) < 0)\n    return FAIL;\n  if (wc_use_keyname((char_u *)valuep, &wc)) {\n    /* print 'wildchar' and 'wildcharm' as a key name */\n    if (fputs((char *)get_special_key_name((int)wc, 0), fd) < 0)\n      return FAIL;\n  } else if (fprintf(fd, \"%\" PRId64, (int64_t)*valuep) < 0)\n    return FAIL;\n  if (put_eol(fd) < 0)\n    return FAIL;\n  return OK;\n}\n\nstatic int put_setbool(FILE *fd, char *cmd, char *name, int value)\n{\n  if (value < 0)        /* global/local option using global value */\n    return OK;\n  if (fprintf(fd, \"%s %s%s\", cmd, value ? \"\" : \"no\", name) < 0\n      || put_eol(fd) < 0)\n    return FAIL;\n  return OK;\n}\n\n/*\n * Compute columns for ruler and shown command. 'sc_col' is also used to\n * decide what the maximum length of a message on the status line can be.\n * If there is a status line for the last window, 'sc_col' is independent\n * of 'ru_col'.\n */\n\n#define COL_RULER 17        /* columns needed by standard ruler */\n\nvoid comp_col(void)\n{\n  int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));\n\n  sc_col = 0;\n  ru_col = 0;\n  if (p_ru) {\n    ru_col = (ru_wid ? ru_wid : COL_RULER) + 1;\n    /* no last status line, adjust sc_col */\n    if (!last_has_status)\n      sc_col = ru_col;\n  }\n  if (p_sc) {\n    sc_col += SHOWCMD_COLS;\n    if (!p_ru || last_has_status)           /* no need for separating space */\n      ++sc_col;\n  }\n  assert(sc_col >= 0\n         && INT_MIN + sc_col <= Columns\n         && Columns - sc_col <= INT_MAX);\n  sc_col = (int)(Columns - sc_col);\n  assert(ru_col >= 0\n         && INT_MIN + ru_col <= Columns\n         && Columns - ru_col <= INT_MAX);\n  ru_col = (int)(Columns - ru_col);\n  if (sc_col <= 0)              /* screen too narrow, will become a mess */\n    sc_col = 1;\n  if (ru_col <= 0)\n    ru_col = 1;\n}\n\n// Unset local option value, similar to \":set opt<\".\nvoid unset_global_local_option(char *name, void *from)\n{\n  vimoption_T *p;\n  buf_T *buf = (buf_T *)from;\n\n  int opt_idx = findoption((uint8_t *)name);\n  if (opt_idx < 0) {\n    EMSG2(_(\"E355: Unknown option: %s\"), name);\n    return;\n  }\n  p = &(options[opt_idx]);\n\n  switch ((int)p->indir)\n  {\n    // global option with local value: use local value if it's been set\n    case PV_EP:\n      clear_string_option(&buf->b_p_ep);\n      break;\n    case PV_KP:\n      clear_string_option(&buf->b_p_kp);\n      break;\n    case PV_PATH:\n      clear_string_option(&buf->b_p_path);\n      break;\n    case PV_AR:\n      buf->b_p_ar = -1;\n      break;\n    case PV_BKC:\n      clear_string_option(&buf->b_p_bkc);\n      buf->b_bkc_flags = 0;\n      break;\n    case PV_TAGS:\n      clear_string_option(&buf->b_p_tags);\n      break;\n    case PV_TC:\n      clear_string_option(&buf->b_p_tc);\n      buf->b_tc_flags = 0;\n      break;\n    case PV_DEF:\n      clear_string_option(&buf->b_p_def);\n      break;\n    case PV_INC:\n      clear_string_option(&buf->b_p_inc);\n      break;\n    case PV_DICT:\n      clear_string_option(&buf->b_p_dict);\n      break;\n    case PV_TSR:\n      clear_string_option(&buf->b_p_tsr);\n      break;\n    case PV_EFM:\n      clear_string_option(&buf->b_p_efm);\n      break;\n    case PV_GP:\n      clear_string_option(&buf->b_p_gp);\n      break;\n    case PV_MP:\n      clear_string_option(&buf->b_p_mp);\n      break;\n    case PV_STL:\n      clear_string_option(&((win_T *)from)->w_p_stl);\n      break;\n    case PV_UL:\n      buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n      break;\n    case PV_LW:\n      clear_string_option(&buf->b_p_lw);\n      break;\n  }\n}\n\n/*\n * Get pointer to option variable, depending on local or global scope.\n */\nstatic char_u *get_varp_scope(vimoption_T *p, int opt_flags)\n{\n  if ((opt_flags & OPT_GLOBAL) && p->indir != PV_NONE) {\n    if (p->var == VAR_WIN)\n      return (char_u *)GLOBAL_WO(get_varp(p));\n    return p->var;\n  }\n  if ((opt_flags & OPT_LOCAL) && ((int)p->indir & PV_BOTH)) {\n    switch ((int)p->indir) {\n    case PV_EFM:  return (char_u *)&(curbuf->b_p_efm);\n    case PV_GP:   return (char_u *)&(curbuf->b_p_gp);\n    case PV_MP:   return (char_u *)&(curbuf->b_p_mp);\n    case PV_EP:   return (char_u *)&(curbuf->b_p_ep);\n    case PV_KP:   return (char_u *)&(curbuf->b_p_kp);\n    case PV_PATH: return (char_u *)&(curbuf->b_p_path);\n    case PV_AR:   return (char_u *)&(curbuf->b_p_ar);\n    case PV_TAGS: return (char_u *)&(curbuf->b_p_tags);\n    case PV_TC:   return (char_u *)&(curbuf->b_p_tc);\n    case PV_DEF:  return (char_u *)&(curbuf->b_p_def);\n    case PV_INC:  return (char_u *)&(curbuf->b_p_inc);\n    case PV_DICT: return (char_u *)&(curbuf->b_p_dict);\n    case PV_TSR:  return (char_u *)&(curbuf->b_p_tsr);\n    case PV_STL:  return (char_u *)&(curwin->w_p_stl);\n    case PV_UL:   return (char_u *)&(curbuf->b_p_ul);\n    case PV_LW:   return (char_u *)&(curbuf->b_p_lw);\n    case PV_BKC:  return (char_u *)&(curbuf->b_p_bkc);\n    }\n    return NULL;     /* \"cannot happen\" */\n  }\n  return get_varp(p);\n}\n\n/*\n * Get pointer to option variable.\n */\nstatic char_u *get_varp(vimoption_T *p)\n{\n  /* hidden option, always return NULL */\n  if (p->var == NULL)\n    return NULL;\n\n  switch ((int)p->indir) {\n  case PV_NONE:   return p->var;\n\n  /* global option with local value: use local value if it's been set */\n  case PV_EP:     return *curbuf->b_p_ep != NUL\n           ? (char_u *)&curbuf->b_p_ep : p->var;\n  case PV_KP:     return *curbuf->b_p_kp != NUL\n           ? (char_u *)&curbuf->b_p_kp : p->var;\n  case PV_PATH:   return *curbuf->b_p_path != NUL\n           ? (char_u *)&(curbuf->b_p_path) : p->var;\n  case PV_AR:     return curbuf->b_p_ar >= 0\n           ? (char_u *)&(curbuf->b_p_ar) : p->var;\n  case PV_TAGS:   return *curbuf->b_p_tags != NUL\n           ? (char_u *)&(curbuf->b_p_tags) : p->var;\n  case PV_TC:     return *curbuf->b_p_tc != NUL\n           ? (char_u *)&(curbuf->b_p_tc) : p->var;\n  case PV_BKC:    return *curbuf->b_p_bkc != NUL\n           ? (char_u *)&(curbuf->b_p_bkc) : p->var;\n  case PV_DEF:    return *curbuf->b_p_def != NUL\n           ? (char_u *)&(curbuf->b_p_def) : p->var;\n  case PV_INC:    return *curbuf->b_p_inc != NUL\n           ? (char_u *)&(curbuf->b_p_inc) : p->var;\n  case PV_DICT:   return *curbuf->b_p_dict != NUL\n           ? (char_u *)&(curbuf->b_p_dict) : p->var;\n  case PV_TSR:    return *curbuf->b_p_tsr != NUL\n           ? (char_u *)&(curbuf->b_p_tsr) : p->var;\n  case PV_EFM:    return *curbuf->b_p_efm != NUL\n           ? (char_u *)&(curbuf->b_p_efm) : p->var;\n  case PV_GP:     return *curbuf->b_p_gp != NUL\n           ? (char_u *)&(curbuf->b_p_gp) : p->var;\n  case PV_MP:     return *curbuf->b_p_mp != NUL\n           ? (char_u *)&(curbuf->b_p_mp) : p->var;\n  case PV_STL:    return *curwin->w_p_stl != NUL\n           ? (char_u *)&(curwin->w_p_stl) : p->var;\n  case PV_UL:     return curbuf->b_p_ul != NO_LOCAL_UNDOLEVEL\n           ? (char_u *)&(curbuf->b_p_ul) : p->var;\n  case PV_LW:   return *curbuf->b_p_lw != NUL\n           ? (char_u *)&(curbuf->b_p_lw) : p->var;\n\n  case PV_ARAB:   return (char_u *)&(curwin->w_p_arab);\n  case PV_LIST:   return (char_u *)&(curwin->w_p_list);\n  case PV_SPELL:  return (char_u *)&(curwin->w_p_spell);\n  case PV_CUC:    return (char_u *)&(curwin->w_p_cuc);\n  case PV_CUL:    return (char_u *)&(curwin->w_p_cul);\n  case PV_CC:     return (char_u *)&(curwin->w_p_cc);\n  case PV_DIFF:   return (char_u *)&(curwin->w_p_diff);\n  case PV_FDC:    return (char_u *)&(curwin->w_p_fdc);\n  case PV_FEN:    return (char_u *)&(curwin->w_p_fen);\n  case PV_FDI:    return (char_u *)&(curwin->w_p_fdi);\n  case PV_FDL:    return (char_u *)&(curwin->w_p_fdl);\n  case PV_FDM:    return (char_u *)&(curwin->w_p_fdm);\n  case PV_FML:    return (char_u *)&(curwin->w_p_fml);\n  case PV_FDN:    return (char_u *)&(curwin->w_p_fdn);\n  case PV_FDE:    return (char_u *)&(curwin->w_p_fde);\n  case PV_FDT:    return (char_u *)&(curwin->w_p_fdt);\n  case PV_FMR:    return (char_u *)&(curwin->w_p_fmr);\n  case PV_NU:     return (char_u *)&(curwin->w_p_nu);\n  case PV_RNU:    return (char_u *)&(curwin->w_p_rnu);\n  case PV_NUW:    return (char_u *)&(curwin->w_p_nuw);\n  case PV_WFH:    return (char_u *)&(curwin->w_p_wfh);\n  case PV_WFW:    return (char_u *)&(curwin->w_p_wfw);\n  case PV_PVW:    return (char_u *)&(curwin->w_p_pvw);\n  case PV_RL:     return (char_u *)&(curwin->w_p_rl);\n  case PV_RLC:    return (char_u *)&(curwin->w_p_rlc);\n  case PV_SCROLL: return (char_u *)&(curwin->w_p_scr);\n  case PV_WRAP:   return (char_u *)&(curwin->w_p_wrap);\n  case PV_LBR:    return (char_u *)&(curwin->w_p_lbr);\n  case PV_BRI:    return (char_u *)&(curwin->w_p_bri);\n  case PV_BRIOPT: return (char_u *)&(curwin->w_p_briopt);\n  case PV_SCBIND: return (char_u *)&(curwin->w_p_scb);\n  case PV_CRBIND: return (char_u *)&(curwin->w_p_crb);\n  case PV_COCU:    return (char_u *)&(curwin->w_p_cocu);\n  case PV_COLE:    return (char_u *)&(curwin->w_p_cole);\n\n  case PV_AI:     return (char_u *)&(curbuf->b_p_ai);\n  case PV_BIN:    return (char_u *)&(curbuf->b_p_bin);\n  case PV_BOMB:   return (char_u *)&(curbuf->b_p_bomb);\n  case PV_BH:     return (char_u *)&(curbuf->b_p_bh);\n  case PV_BT:     return (char_u *)&(curbuf->b_p_bt);\n  case PV_BL:     return (char_u *)&(curbuf->b_p_bl);\n  case PV_CI:     return (char_u *)&(curbuf->b_p_ci);\n  case PV_CIN:    return (char_u *)&(curbuf->b_p_cin);\n  case PV_CINK:   return (char_u *)&(curbuf->b_p_cink);\n  case PV_CINO:   return (char_u *)&(curbuf->b_p_cino);\n  case PV_CINW:   return (char_u *)&(curbuf->b_p_cinw);\n  case PV_COM:    return (char_u *)&(curbuf->b_p_com);\n  case PV_CMS:    return (char_u *)&(curbuf->b_p_cms);\n  case PV_CPT:    return (char_u *)&(curbuf->b_p_cpt);\n  case PV_CFU:    return (char_u *)&(curbuf->b_p_cfu);\n  case PV_OFU:    return (char_u *)&(curbuf->b_p_ofu);\n  case PV_EOL:    return (char_u *)&(curbuf->b_p_eol);\n  case PV_FIXEOL: return (char_u *)&(curbuf->b_p_fixeol);\n  case PV_ET:     return (char_u *)&(curbuf->b_p_et);\n  case PV_FENC:   return (char_u *)&(curbuf->b_p_fenc);\n  case PV_FF:     return (char_u *)&(curbuf->b_p_ff);\n  case PV_FT:     return (char_u *)&(curbuf->b_p_ft);\n  case PV_FO:     return (char_u *)&(curbuf->b_p_fo);\n  case PV_FLP:    return (char_u *)&(curbuf->b_p_flp);\n  case PV_IMI:    return (char_u *)&(curbuf->b_p_iminsert);\n  case PV_IMS:    return (char_u *)&(curbuf->b_p_imsearch);\n  case PV_INF:    return (char_u *)&(curbuf->b_p_inf);\n  case PV_ISK:    return (char_u *)&(curbuf->b_p_isk);\n  case PV_INEX:   return (char_u *)&(curbuf->b_p_inex);\n  case PV_INDE:   return (char_u *)&(curbuf->b_p_inde);\n  case PV_INDK:   return (char_u *)&(curbuf->b_p_indk);\n  case PV_FEX:    return (char_u *)&(curbuf->b_p_fex);\n  case PV_LISP:   return (char_u *)&(curbuf->b_p_lisp);\n  case PV_ML:     return (char_u *)&(curbuf->b_p_ml);\n  case PV_MPS:    return (char_u *)&(curbuf->b_p_mps);\n  case PV_MA:     return (char_u *)&(curbuf->b_p_ma);\n  case PV_MOD:    return (char_u *)&(curbuf->b_changed);\n  case PV_NF:     return (char_u *)&(curbuf->b_p_nf);\n  case PV_PI:     return (char_u *)&(curbuf->b_p_pi);\n  case PV_QE:     return (char_u *)&(curbuf->b_p_qe);\n  case PV_RO:     return (char_u *)&(curbuf->b_p_ro);\n  case PV_SI:     return (char_u *)&(curbuf->b_p_si);\n  case PV_STS:    return (char_u *)&(curbuf->b_p_sts);\n  case PV_SUA:    return (char_u *)&(curbuf->b_p_sua);\n  case PV_SWF:    return (char_u *)&(curbuf->b_p_swf);\n  case PV_SMC:    return (char_u *)&(curbuf->b_p_smc);\n  case PV_SYN:    return (char_u *)&(curbuf->b_p_syn);\n  case PV_SPC:    return (char_u *)&(curwin->w_s->b_p_spc);\n  case PV_SPF:    return (char_u *)&(curwin->w_s->b_p_spf);\n  case PV_SPL:    return (char_u *)&(curwin->w_s->b_p_spl);\n  case PV_SW:     return (char_u *)&(curbuf->b_p_sw);\n  case PV_TS:     return (char_u *)&(curbuf->b_p_ts);\n  case PV_TW:     return (char_u *)&(curbuf->b_p_tw);\n  case PV_UDF:    return (char_u *)&(curbuf->b_p_udf);\n  case PV_WM:     return (char_u *)&(curbuf->b_p_wm);\n  case PV_KMAP:   return (char_u *)&(curbuf->b_p_keymap);\n  default:        EMSG(_(\"E356: get_varp ERROR\"));\n  }\n  /* always return a valid pointer to avoid a crash! */\n  return (char_u *)&(curbuf->b_p_wm);\n}\n\n/*\n * Get the value of 'equalprg', either the buffer-local one or the global one.\n */\nchar_u *get_equalprg(void)\n{\n  if (*curbuf->b_p_ep == NUL)\n    return p_ep;\n  return curbuf->b_p_ep;\n}\n\n/*\n * Copy options from one window to another.\n * Used when splitting a window.\n */\nvoid win_copy_options(win_T *wp_from, win_T *wp_to)\n{\n  copy_winopt(&wp_from->w_onebuf_opt, &wp_to->w_onebuf_opt);\n  copy_winopt(&wp_from->w_allbuf_opt, &wp_to->w_allbuf_opt);\n  /* Is this right? */\n  wp_to->w_farsi = wp_from->w_farsi;\n  briopt_check(wp_to);\n}\n\n/*\n * Copy the options from one winopt_T to another.\n * Doesn't free the old option values in \"to\", use clear_winopt() for that.\n * The 'scroll' option is not copied, because it depends on the window height.\n * The 'previewwindow' option is reset, there can be only one preview window.\n */\nvoid copy_winopt(winopt_T *from, winopt_T *to)\n{\n  to->wo_arab = from->wo_arab;\n  to->wo_list = from->wo_list;\n  to->wo_nu = from->wo_nu;\n  to->wo_rnu = from->wo_rnu;\n  to->wo_nuw = from->wo_nuw;\n  to->wo_rl  = from->wo_rl;\n  to->wo_rlc = vim_strsave(from->wo_rlc);\n  to->wo_stl = vim_strsave(from->wo_stl);\n  to->wo_wrap = from->wo_wrap;\n  to->wo_wrap_save = from->wo_wrap_save;\n  to->wo_lbr = from->wo_lbr;\n  to->wo_bri = from->wo_bri;\n  to->wo_briopt = vim_strsave(from->wo_briopt);\n  to->wo_scb = from->wo_scb;\n  to->wo_scb_save = from->wo_scb_save;\n  to->wo_crb = from->wo_crb;\n  to->wo_crb_save = from->wo_crb_save;\n  to->wo_spell = from->wo_spell;\n  to->wo_cuc = from->wo_cuc;\n  to->wo_cul = from->wo_cul;\n  to->wo_cc = vim_strsave(from->wo_cc);\n  to->wo_diff = from->wo_diff;\n  to->wo_diff_saved = from->wo_diff_saved;\n  to->wo_cocu = vim_strsave(from->wo_cocu);\n  to->wo_cole = from->wo_cole;\n  to->wo_fdc = from->wo_fdc;\n  to->wo_fdc_save = from->wo_fdc_save;\n  to->wo_fen = from->wo_fen;\n  to->wo_fen_save = from->wo_fen_save;\n  to->wo_fdi = vim_strsave(from->wo_fdi);\n  to->wo_fml = from->wo_fml;\n  to->wo_fdl = from->wo_fdl;\n  to->wo_fdl_save = from->wo_fdl_save;\n  to->wo_fdm = vim_strsave(from->wo_fdm);\n  to->wo_fdm_save = from->wo_diff_saved\n                    ? vim_strsave(from->wo_fdm_save) : empty_option;\n  to->wo_fdn = from->wo_fdn;\n  to->wo_fde = vim_strsave(from->wo_fde);\n  to->wo_fdt = vim_strsave(from->wo_fdt);\n  to->wo_fmr = vim_strsave(from->wo_fmr);\n  check_winopt(to);             /* don't want NULL pointers */\n}\n\n/*\n * Check string options in a window for a NULL value.\n */\nvoid check_win_options(win_T *win)\n{\n  check_winopt(&win->w_onebuf_opt);\n  check_winopt(&win->w_allbuf_opt);\n}\n\n/*\n * Check for NULL pointers in a winopt_T and replace them with empty_option.\n */\nstatic void check_winopt(winopt_T *wop)\n{\n  check_string_option(&wop->wo_fdi);\n  check_string_option(&wop->wo_fdm);\n  check_string_option(&wop->wo_fdm_save);\n  check_string_option(&wop->wo_fde);\n  check_string_option(&wop->wo_fdt);\n  check_string_option(&wop->wo_fmr);\n  check_string_option(&wop->wo_rlc);\n  check_string_option(&wop->wo_stl);\n  check_string_option(&wop->wo_cc);\n  check_string_option(&wop->wo_cocu);\n  check_string_option(&wop->wo_briopt);\n}\n\n/*\n * Free the allocated memory inside a winopt_T.\n */\nvoid clear_winopt(winopt_T *wop)\n{\n  clear_string_option(&wop->wo_fdi);\n  clear_string_option(&wop->wo_fdm);\n  clear_string_option(&wop->wo_fdm_save);\n  clear_string_option(&wop->wo_fde);\n  clear_string_option(&wop->wo_fdt);\n  clear_string_option(&wop->wo_fmr);\n  clear_string_option(&wop->wo_rlc);\n  clear_string_option(&wop->wo_stl);\n  clear_string_option(&wop->wo_cc);\n  clear_string_option(&wop->wo_cocu);\n  clear_string_option(&wop->wo_briopt);\n}\n\n/*\n * Copy global option values to local options for one buffer.\n * Used when creating a new buffer and sometimes when entering a buffer.\n * flags:\n * BCO_ENTER\tWe will enter the buf buffer.\n * BCO_ALWAYS\tAlways copy the options, but only set b_p_initialized when\n *\t\tappropriate.\n * BCO_NOHELP\tDon't copy the values to a help buffer.\n */\nvoid buf_copy_options(buf_T *buf, int flags)\n{\n  int should_copy = TRUE;\n  char_u      *save_p_isk = NULL;           /* init for GCC */\n  int dont_do_help;\n  int did_isk = FALSE;\n\n  /*\n   * Don't do anything if the buffer is invalid.\n   */\n  if (buf == NULL || !buf_valid(buf))\n    return;\n\n  /*\n   * Skip this when the option defaults have not been set yet.  Happens when\n   * main() allocates the first buffer.\n   */\n  if (p_cpo != NULL) {\n    /*\n     * Always copy when entering and 'cpo' contains 'S'.\n     * Don't copy when already initialized.\n     * Don't copy when 'cpo' contains 's' and not entering.\n     * 'S'\tBCO_ENTER  initialized\t's'  should_copy\n     * yes\t  yes\t       X\t X\tTRUE\n     * yes\t  no\t      yes\t X\tFALSE\n     * no\t   X\t      yes\t X\tFALSE\n     *  X\t  no\t      no\tyes\tFALSE\n     *  X\t  no\t      no\tno\tTRUE\n     * no\t  yes\t      no\t X\tTRUE\n     */\n    if ((vim_strchr(p_cpo, CPO_BUFOPTGLOB) == NULL || !(flags & BCO_ENTER))\n        && (buf->b_p_initialized\n            || (!(flags & BCO_ENTER)\n                && vim_strchr(p_cpo, CPO_BUFOPT) != NULL)))\n      should_copy = FALSE;\n\n    if (should_copy || (flags & BCO_ALWAYS)) {\n      /* Don't copy the options specific to a help buffer when\n      * BCO_NOHELP is given or the options were initialized already\n      * (jumping back to a help file with CTRL-T or CTRL-O) */\n      dont_do_help = ((flags & BCO_NOHELP) && buf->b_help)\n                     || buf->b_p_initialized;\n      if (dont_do_help) {               /* don't free b_p_isk */\n        save_p_isk = buf->b_p_isk;\n        buf->b_p_isk = NULL;\n      }\n      /*\n       * Always free the allocated strings.\n       * If not already initialized, set 'readonly' and copy 'fileformat'.\n       */\n      if (!buf->b_p_initialized) {\n        free_buf_options(buf, TRUE);\n        buf->b_p_ro = FALSE;                    /* don't copy readonly */\n        buf->b_p_fenc = vim_strsave(p_fenc);\n        buf->b_p_ff = vim_strsave(p_ff);\n        buf->b_p_bh = empty_option;\n        buf->b_p_bt = empty_option;\n      } else\n        free_buf_options(buf, FALSE);\n\n      buf->b_p_ai = p_ai;\n      buf->b_p_ai_nopaste = p_ai_nopaste;\n      buf->b_p_sw = p_sw;\n      buf->b_p_tw = p_tw;\n      buf->b_p_tw_nopaste = p_tw_nopaste;\n      buf->b_p_tw_nobin = p_tw_nobin;\n      buf->b_p_wm = p_wm;\n      buf->b_p_wm_nopaste = p_wm_nopaste;\n      buf->b_p_wm_nobin = p_wm_nobin;\n      buf->b_p_bin = p_bin;\n      buf->b_p_bomb = p_bomb;\n      buf->b_p_et = p_et;\n      buf->b_p_fixeol = p_fixeol;\n      buf->b_p_et_nobin = p_et_nobin;\n      buf->b_p_et_nopaste = p_et_nopaste;\n      buf->b_p_ml = p_ml;\n      buf->b_p_ml_nobin = p_ml_nobin;\n      buf->b_p_inf = p_inf;\n      buf->b_p_swf = p_swf;\n      buf->b_p_cpt = vim_strsave(p_cpt);\n      buf->b_p_cfu = vim_strsave(p_cfu);\n      buf->b_p_ofu = vim_strsave(p_ofu);\n      buf->b_p_sts = p_sts;\n      buf->b_p_sts_nopaste = p_sts_nopaste;\n      buf->b_p_com = vim_strsave(p_com);\n      buf->b_p_cms = vim_strsave(p_cms);\n      buf->b_p_fo = vim_strsave(p_fo);\n      buf->b_p_flp = vim_strsave(p_flp);\n      buf->b_p_nf = vim_strsave(p_nf);\n      buf->b_p_mps = vim_strsave(p_mps);\n      buf->b_p_si = p_si;\n      buf->b_p_ci = p_ci;\n      buf->b_p_cin = p_cin;\n      buf->b_p_cink = vim_strsave(p_cink);\n      buf->b_p_cino = vim_strsave(p_cino);\n      /* Don't copy 'filetype', it must be detected */\n      buf->b_p_ft = empty_option;\n      buf->b_p_pi = p_pi;\n      buf->b_p_cinw = vim_strsave(p_cinw);\n      buf->b_p_lisp = p_lisp;\n      /* Don't copy 'syntax', it must be set */\n      buf->b_p_syn = empty_option;\n      buf->b_p_smc = p_smc;\n      buf->b_s.b_syn_isk = empty_option;\n      buf->b_s.b_p_spc = vim_strsave(p_spc);\n      (void)compile_cap_prog(&buf->b_s);\n      buf->b_s.b_p_spf = vim_strsave(p_spf);\n      buf->b_s.b_p_spl = vim_strsave(p_spl);\n      buf->b_p_inde = vim_strsave(p_inde);\n      buf->b_p_indk = vim_strsave(p_indk);\n      buf->b_p_fex = vim_strsave(p_fex);\n      buf->b_p_sua = vim_strsave(p_sua);\n      buf->b_p_keymap = vim_strsave(p_keymap);\n      buf->b_kmap_state |= KEYMAP_INIT;\n      /* This isn't really an option, but copying the langmap and IME\n      * state from the current buffer is better than resetting it. */\n      buf->b_p_iminsert = p_iminsert;\n      buf->b_p_imsearch = p_imsearch;\n\n      /* options that are normally global but also have a local value\n       * are not copied, start using the global value */\n      buf->b_p_ar = -1;\n      buf->b_p_ul = NO_LOCAL_UNDOLEVEL;\n      buf->b_p_bkc = empty_option;\n      buf->b_bkc_flags = 0;\n      buf->b_p_gp = empty_option;\n      buf->b_p_mp = empty_option;\n      buf->b_p_efm = empty_option;\n      buf->b_p_ep = empty_option;\n      buf->b_p_kp = empty_option;\n      buf->b_p_path = empty_option;\n      buf->b_p_tags = empty_option;\n      buf->b_p_tc = empty_option;\n      buf->b_tc_flags = 0;\n      buf->b_p_def = empty_option;\n      buf->b_p_inc = empty_option;\n      buf->b_p_inex = vim_strsave(p_inex);\n      buf->b_p_dict = empty_option;\n      buf->b_p_tsr = empty_option;\n      buf->b_p_qe = vim_strsave(p_qe);\n      buf->b_p_udf = p_udf;\n      buf->b_p_lw = empty_option;\n\n      /*\n       * Don't copy the options set by ex_help(), use the saved values,\n       * when going from a help buffer to a non-help buffer.\n       * Don't touch these at all when BCO_NOHELP is used and going from\n       * or to a help buffer.\n       */\n      if (dont_do_help)\n        buf->b_p_isk = save_p_isk;\n      else {\n        buf->b_p_isk = vim_strsave(p_isk);\n        did_isk = true;\n        buf->b_p_ts = p_ts;\n        buf->b_help = false;\n        if (buf->b_p_bt[0] == 'h')\n          clear_string_option(&buf->b_p_bt);\n        buf->b_p_ma = p_ma;\n      }\n    }\n\n    /*\n     * When the options should be copied (ignoring BCO_ALWAYS), set the\n     * flag that indicates that the options have been initialized.\n     */\n    if (should_copy)\n      buf->b_p_initialized = true;\n  }\n\n  check_buf_options(buf);           /* make sure we don't have NULLs */\n  if (did_isk)\n    (void)buf_init_chartab(buf, FALSE);\n}\n\n/*\n * Reset the 'modifiable' option and its default value.\n */\nvoid reset_modifiable(void)\n{\n  int opt_idx;\n\n  curbuf->b_p_ma = FALSE;\n  p_ma = FALSE;\n  opt_idx = findoption((char_u *)\"ma\");\n  if (opt_idx >= 0)\n    options[opt_idx].def_val[VI_DEFAULT] = FALSE;\n}\n\n/*\n * Set the global value for 'iminsert' to the local value.\n */\nvoid set_iminsert_global(void)\n{\n  p_iminsert = curbuf->b_p_iminsert;\n}\n\n/*\n * Set the global value for 'imsearch' to the local value.\n */\nvoid set_imsearch_global(void)\n{\n  p_imsearch = curbuf->b_p_imsearch;\n}\n\nstatic int expand_option_idx = -1;\nstatic char_u expand_option_name[5] = {'t', '_', NUL, NUL, NUL};\nstatic int expand_option_flags = 0;\n\nvoid \nset_context_in_set_cmd (\n    expand_T *xp,\n    char_u *arg,\n    int opt_flags                  /* OPT_GLOBAL and/or OPT_LOCAL */\n)\n{\n  char_u nextchar;\n  uint32_t flags = 0;           /* init for GCC */\n  int opt_idx = 0;              /* init for GCC */\n  char_u      *p;\n  char_u      *s;\n  int is_term_option = FALSE;\n  int key;\n\n  expand_option_flags = opt_flags;\n\n  xp->xp_context = EXPAND_SETTINGS;\n  if (*arg == NUL) {\n    xp->xp_pattern = arg;\n    return;\n  }\n  p = arg + STRLEN(arg) - 1;\n  if (*p == ' ' && *(p - 1) != '\\\\') {\n    xp->xp_pattern = p + 1;\n    return;\n  }\n  while (p > arg) {\n    s = p;\n    /* count number of backslashes before ' ' or ',' */\n    if (*p == ' ' || *p == ',') {\n      while (s > arg && *(s - 1) == '\\\\')\n        --s;\n    }\n    /* break at a space with an even number of backslashes */\n    if (*p == ' ' && ((p - s) & 1) == 0) {\n      ++p;\n      break;\n    }\n    --p;\n  }\n  if (STRNCMP(p, \"no\", 2) == 0) {\n    xp->xp_context = EXPAND_BOOL_SETTINGS;\n    p += 2;\n  }\n  if (STRNCMP(p, \"inv\", 3) == 0) {\n    xp->xp_context = EXPAND_BOOL_SETTINGS;\n    p += 3;\n  }\n  xp->xp_pattern = arg = p;\n  if (*arg == '<') {\n    while (*p != '>')\n      if (*p++ == NUL)              /* expand terminal option name */\n        return;\n    key = get_special_key_code(arg + 1);\n    if (key == 0) {                 /* unknown name */\n      xp->xp_context = EXPAND_NOTHING;\n      return;\n    }\n    nextchar = *++p;\n    is_term_option = TRUE;\n    expand_option_name[2] = (char_u)KEY2TERMCAP0(key);\n    expand_option_name[3] = KEY2TERMCAP1(key);\n  } else {\n    if (p[0] == 't' && p[1] == '_') {\n      p += 2;\n      if (*p != NUL)\n        ++p;\n      if (*p == NUL)\n        return;                 /* expand option name */\n      nextchar = *++p;\n      is_term_option = TRUE;\n      expand_option_name[2] = p[-2];\n      expand_option_name[3] = p[-1];\n    } else {\n      /* Allow * wildcard */\n      while (ASCII_ISALNUM(*p) || *p == '_' || *p == '*')\n        p++;\n      if (*p == NUL)\n        return;\n      nextchar = *p;\n      *p = NUL;\n      opt_idx = findoption(arg);\n      *p = nextchar;\n      if (opt_idx == -1 || options[opt_idx].var == NULL) {\n        xp->xp_context = EXPAND_NOTHING;\n        return;\n      }\n      flags = options[opt_idx].flags;\n      if (flags & P_BOOL) {\n        xp->xp_context = EXPAND_NOTHING;\n        return;\n      }\n    }\n  }\n  /* handle \"-=\" and \"+=\" */\n  if ((nextchar == '-' || nextchar == '+' || nextchar == '^') && p[1] == '=') {\n    ++p;\n    nextchar = '=';\n  }\n  if ((nextchar != '=' && nextchar != ':')\n      || xp->xp_context == EXPAND_BOOL_SETTINGS) {\n    xp->xp_context = EXPAND_UNSUCCESSFUL;\n    return;\n  }\n  if (xp->xp_context != EXPAND_BOOL_SETTINGS && p[1] == NUL) {\n    xp->xp_context = EXPAND_OLD_SETTING;\n    if (is_term_option)\n      expand_option_idx = -1;\n    else\n      expand_option_idx = opt_idx;\n    xp->xp_pattern = p + 1;\n    return;\n  }\n  xp->xp_context = EXPAND_NOTHING;\n  if (is_term_option || (flags & P_NUM))\n    return;\n\n  xp->xp_pattern = p + 1;\n\n  if (flags & P_EXPAND) {\n    p = options[opt_idx].var;\n    if (p == (char_u *)&p_bdir\n        || p == (char_u *)&p_dir\n        || p == (char_u *)&p_path\n        || p == (char_u *)&p_pp\n        || p == (char_u *)&p_rtp\n        || p == (char_u *)&p_cdpath\n        || p == (char_u *)&p_vdir\n        ) {\n      xp->xp_context = EXPAND_DIRECTORIES;\n      if (p == (char_u *)&p_path\n          || p == (char_u *)&p_cdpath\n          )\n        xp->xp_backslash = XP_BS_THREE;\n      else\n        xp->xp_backslash = XP_BS_ONE;\n    } else {\n      xp->xp_context = EXPAND_FILES;\n      /* for 'tags' need three backslashes for a space */\n      if (p == (char_u *)&p_tags)\n        xp->xp_backslash = XP_BS_THREE;\n      else\n        xp->xp_backslash = XP_BS_ONE;\n    }\n  }\n\n  /* For an option that is a list of file names, find the start of the\n   * last file name. */\n  for (p = arg + STRLEN(arg) - 1; p > xp->xp_pattern; --p) {\n    /* count number of backslashes before ' ' or ',' */\n    if (*p == ' ' || *p == ',') {\n      s = p;\n      while (s > xp->xp_pattern && *(s - 1) == '\\\\')\n        --s;\n      if ((*p == ' ' && (xp->xp_backslash == XP_BS_THREE && (p - s) < 3))\n          || (*p == ',' && (flags & P_COMMA) && ((p - s) & 1) == 0)) {\n        xp->xp_pattern = p + 1;\n        break;\n      }\n    }\n\n    /* for 'spellsuggest' start at \"file:\" */\n    if (options[opt_idx].var == (char_u *)&p_sps\n        && STRNCMP(p, \"file:\", 5) == 0) {\n      xp->xp_pattern = p + 5;\n      break;\n    }\n  }\n\n  return;\n}\n\nint ExpandSettings(expand_T *xp, regmatch_T *regmatch, int *num_file, char_u ***file)\n{\n  int num_normal = 0;  // Nr of matching non-term-code settings\n  int match;\n  int count = 0;\n  char_u      *str;\n  int loop;\n  static char *(names[]) = {\"all\", \"termcap\"};\n  int ic = regmatch->rm_ic;             /* remember the ignore-case flag */\n\n  /* do this loop twice:\n   * loop == 0: count the number of matching options\n   * loop == 1: copy the matching options into allocated memory\n   */\n  for (loop = 0; loop <= 1; ++loop) {\n    regmatch->rm_ic = ic;\n    if (xp->xp_context != EXPAND_BOOL_SETTINGS) {\n      for (match = 0; match < (int)ARRAY_SIZE(names);\n           ++match)\n        if (vim_regexec(regmatch, (char_u *)names[match], (colnr_T)0)) {\n          if (loop == 0)\n            num_normal++;\n          else\n            (*file)[count++] = vim_strsave((char_u *)names[match]);\n        }\n    }\n    for (size_t opt_idx = 0; (str = (char_u *)options[opt_idx].fullname) != NULL;\n         opt_idx++) {\n      if (options[opt_idx].var == NULL)\n        continue;\n      if (xp->xp_context == EXPAND_BOOL_SETTINGS\n          && !(options[opt_idx].flags & P_BOOL))\n        continue;\n      match = FALSE;\n      if (vim_regexec(regmatch, str, (colnr_T)0)\n          || (options[opt_idx].shortname != NULL\n              && vim_regexec(regmatch,\n                  (char_u *)options[opt_idx].shortname, (colnr_T)0))){\n        match = TRUE;\n      }\n\n      if (match) {\n        if (loop == 0) {\n          num_normal++;\n        } else\n          (*file)[count++] = vim_strsave(str);\n      }\n    }\n\n    if (loop == 0) {\n      if (num_normal > 0) {\n        *num_file = num_normal;\n      } else {\n        return OK;\n      }\n      *file = (char_u **)xmalloc((size_t)(*num_file) * sizeof(char_u *));\n    }\n  }\n  return OK;\n}\n\nvoid ExpandOldSetting(int *num_file, char_u ***file)\n{\n  char_u *var = NULL;\n\n  *num_file = 0;\n  *file = (char_u **)xmalloc(sizeof(char_u *));\n\n  /*\n   * For a terminal key code expand_option_idx is < 0.\n   */\n  if (expand_option_idx < 0) {\n    expand_option_idx = findoption(expand_option_name);\n  }\n\n  if (expand_option_idx >= 0) {\n    /* put string of option value in NameBuff */\n    option_value2string(&options[expand_option_idx], expand_option_flags);\n    var = NameBuff;\n  } else if (var == NULL)\n    var = (char_u *)\"\";\n\n  /* A backslash is required before some characters.  This is the reverse of\n   * what happens in do_set(). */\n  char_u *buf = vim_strsave_escaped(var, escape_chars);\n\n#ifdef BACKSLASH_IN_FILENAME\n  /* For MS-Windows et al. we don't double backslashes at the start and\n   * before a file name character. */\n  for (var = buf; *var != NUL; mb_ptr_adv(var))\n    if (var[0] == '\\\\' && var[1] == '\\\\'\n        && expand_option_idx >= 0\n        && (options[expand_option_idx].flags & P_EXPAND)\n        && vim_isfilec(var[2])\n        && (var[2] != '\\\\' || (var == buf && var[4] != '\\\\')))\n      STRMOVE(var, var + 1);\n#endif\n\n  *file[0] = buf;\n  *num_file = 1;\n}\n\n/*\n * Get the value for the numeric or string option *opp in a nice format into\n * NameBuff[].  Must not be called with a hidden option!\n */\nstatic void \noption_value2string (\n    vimoption_T *opp,\n    int opt_flags                          /* OPT_GLOBAL and/or OPT_LOCAL */\n)\n{\n  char_u      *varp;\n\n  varp = get_varp_scope(opp, opt_flags);\n\n  if (opp->flags & P_NUM) {\n    long wc = 0;\n\n    if (wc_use_keyname(varp, &wc)) {\n      STRLCPY(NameBuff, get_special_key_name((int)wc, 0), sizeof(NameBuff));\n    } else if (wc != 0) {\n      STRLCPY(NameBuff, transchar((int)wc), sizeof(NameBuff));\n    } else {\n      snprintf((char *)NameBuff,\n               sizeof(NameBuff),\n               \"%\" PRId64,\n               (int64_t)*(long *)varp);\n    }\n  } else {  // P_STRING\n    varp = *(char_u **)(varp);\n    if (varp == NULL)                       /* just in case */\n      NameBuff[0] = NUL;\n    else if (opp->flags & P_EXPAND)\n      home_replace(NULL, varp, NameBuff, MAXPATHL, FALSE);\n    /* Translate 'pastetoggle' into special key names */\n    else if ((char_u **)opp->var == &p_pt)\n      str2specialbuf(p_pt, NameBuff, MAXPATHL);\n    else\n      STRLCPY(NameBuff, varp, MAXPATHL);\n  }\n}\n\n/*\n * Return TRUE if \"varp\" points to 'wildchar' or 'wildcharm' and it can be\n * printed as a keyname.\n * \"*wcp\" is set to the value of the option if it's 'wildchar' or 'wildcharm'.\n */\nstatic int wc_use_keyname(char_u *varp, long *wcp)\n{\n  if (((long *)varp == &p_wc) || ((long *)varp == &p_wcm)) {\n    *wcp = *(long *)varp;\n    if (IS_SPECIAL(*wcp) || find_special_key_in_table((int)*wcp) >= 0)\n      return TRUE;\n  }\n  return FALSE;\n}\n\n/*\n * Any character has an equivalent 'langmap' character.  This is used for\n * keyboards that have a special language mode that sends characters above\n * 128 (although other characters can be translated too).  The \"to\" field is a\n * Vim command character.  This avoids having to switch the keyboard back to\n * ASCII mode when leaving Insert mode.\n *\n * langmap_mapchar[] maps any of 256 chars to an ASCII char used for Vim\n * commands.\n * langmap_mapga.ga_data is a sorted table of langmap_entry_T. \n * This does the same as langmap_mapchar[] for characters >= 256.\n */\n/*\n * With multi-byte support use growarray for 'langmap' chars >= 256\n */\ntypedef struct {\n  int from;\n  int to;\n} langmap_entry_T;\n\nstatic garray_T langmap_mapga = GA_EMPTY_INIT_VALUE;\n\n/*\n * Search for an entry in \"langmap_mapga\" for \"from\".  If found set the \"to\"\n * field.  If not found insert a new entry at the appropriate location.\n */\nstatic void langmap_set_entry(int from, int to)\n{\n  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);\n  unsigned int a = 0;\n  assert(langmap_mapga.ga_len >= 0);\n  unsigned int b = (unsigned int)langmap_mapga.ga_len;\n\n  /* Do a binary search for an existing entry. */\n  while (a != b) {\n    unsigned int i = (a + b) / 2;\n    int d = entries[i].from - from;\n\n    if (d == 0) {\n      entries[i].to = to;\n      return;\n    }\n    if (d < 0)\n      a = i + 1;\n    else\n      b = i;\n  }\n\n  ga_grow(&langmap_mapga, 1);\n\n  /* insert new entry at position \"a\" */\n  entries = (langmap_entry_T *)(langmap_mapga.ga_data) + a;\n  memmove(entries + 1, entries,\n          ((unsigned int)langmap_mapga.ga_len - a) * sizeof(langmap_entry_T));\n  ++langmap_mapga.ga_len;\n  entries[0].from = from;\n  entries[0].to = to;\n}\n\n/*\n * Apply 'langmap' to multi-byte character \"c\" and return the result.\n */\nint langmap_adjust_mb(int c)\n{\n  langmap_entry_T *entries = (langmap_entry_T *)(langmap_mapga.ga_data);\n  int a = 0;\n  int b = langmap_mapga.ga_len;\n\n  while (a != b) {\n    int i = (a + b) / 2;\n    int d = entries[i].from - c;\n\n    if (d == 0)\n      return entries[i].to;        /* found matching entry */\n    if (d < 0)\n      a = i + 1;\n    else\n      b = i;\n  }\n  return c;    /* no entry found, return \"c\" unmodified */\n}\n\nstatic void langmap_init(void)\n{\n  for (int i = 0; i < 256; i++)\n    langmap_mapchar[i] = (char_u)i;      /* we init with a one-to-one map */\n  ga_init(&langmap_mapga, sizeof(langmap_entry_T), 8);\n}\n\n/*\n * Called when langmap option is set; the language map can be\n * changed at any time!\n */\nstatic void langmap_set(void)\n{\n  char_u  *p;\n  char_u  *p2;\n  int from, to;\n\n  ga_clear(&langmap_mapga);                 /* clear the previous map first */\n  langmap_init();                           /* back to one-to-one map */\n\n  for (p = p_langmap; p[0] != NUL; ) {\n    for (p2 = p; p2[0] != NUL && p2[0] != ',' && p2[0] != ';';\n         mb_ptr_adv(p2)) {\n      if (p2[0] == '\\\\' && p2[1] != NUL)\n        ++p2;\n    }\n    if (p2[0] == ';')\n      ++p2;                 /* abcd;ABCD form, p2 points to A */\n    else\n      p2 = NULL;            /* aAbBcCdD form, p2 is NULL */\n    while (p[0]) {\n      if (p[0] == ',') {\n        ++p;\n        break;\n      }\n      if (p[0] == '\\\\' && p[1] != NUL)\n        ++p;\n      from = (*mb_ptr2char)(p);\n      to = NUL;\n      if (p2 == NULL) {\n        mb_ptr_adv(p);\n        if (p[0] != ',') {\n          if (p[0] == '\\\\')\n            ++p;\n          to = (*mb_ptr2char)(p);\n        }\n      } else {\n        if (p2[0] != ',') {\n          if (p2[0] == '\\\\')\n            ++p2;\n          to = (*mb_ptr2char)(p2);\n        }\n      }\n      if (to == NUL) {\n        EMSG2(_(\"E357: 'langmap': Matching character missing for %s\"),\n            transchar(from));\n        return;\n      }\n\n      if (from >= 256)\n        langmap_set_entry(from, to);\n      else {\n        assert(to <= UCHAR_MAX);\n        langmap_mapchar[from & 255] = (char_u)to;\n      }\n\n      /* Advance to next pair */\n      mb_ptr_adv(p);\n      if (p2 != NULL) {\n        mb_ptr_adv(p2);\n        if (*p == ';') {\n          p = p2;\n          if (p[0] != NUL) {\n            if (p[0] != ',') {\n              EMSG2(_(\n                      \"E358: 'langmap': Extra characters after semicolon: %s\"),\n                  p);\n              return;\n            }\n            ++p;\n          }\n          break;\n        }\n      }\n    }\n  }\n}\n\n/*\n * Return TRUE if format option 'x' is in effect.\n * Take care of no formatting when 'paste' is set.\n */\nint has_format_option(int x)\n{\n  if (p_paste)\n    return FALSE;\n  return vim_strchr(curbuf->b_p_fo, x) != NULL;\n}\n\n/// @returns true if \"x\" is present in 'shortmess' option, or\n/// 'shortmess' contains 'a' and \"x\" is present in SHM_ALL_ABBREVIATIONS.\nbool shortmess(int x)\n{\n  return (p_shm != NULL\n          && (vim_strchr(p_shm, x) != NULL\n              || (vim_strchr(p_shm, 'a') != NULL\n                  && vim_strchr((char_u *)SHM_ALL_ABBREVIATIONS, x) != NULL)));\n}\n\n/*\n * paste_option_changed() - Called after p_paste was set or reset.\n */\nstatic void paste_option_changed(void)\n{\n  static int old_p_paste = FALSE;\n  static int save_sm = 0;\n  static int save_sta = 0;\n  static int save_ru = 0;\n  static int save_ri = 0;\n  static int save_hkmap = 0;\n\n  if (p_paste) {\n    /*\n     * Paste switched from off to on.\n     * Save the current values, so they can be restored later.\n     */\n    if (!old_p_paste) {\n      /* save options for each buffer */\n      FOR_ALL_BUFFERS(buf) {\n        buf->b_p_tw_nopaste = buf->b_p_tw;\n        buf->b_p_wm_nopaste = buf->b_p_wm;\n        buf->b_p_sts_nopaste = buf->b_p_sts;\n        buf->b_p_ai_nopaste = buf->b_p_ai;\n        buf->b_p_et_nopaste = buf->b_p_et;\n      }\n\n      // save global options\n      save_sm = p_sm;\n      save_sta = p_sta;\n      save_ru = p_ru;\n      save_ri = p_ri;\n      save_hkmap = p_hkmap;\n      // save global values for local buffer options\n      p_ai_nopaste = p_ai;\n      p_et_nopaste = p_et;\n      p_sts_nopaste = p_sts;\n      p_tw_nopaste = p_tw;\n      p_wm_nopaste = p_wm;\n    }\n\n    // Always set the option values, also when 'paste' is set when it is\n    // already on.\n    // set options for each buffer\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_p_tw = 0;              // textwidth is 0\n      buf->b_p_wm = 0;              // wrapmargin is 0\n      buf->b_p_sts = 0;             // softtabstop is 0\n      buf->b_p_ai = 0;              // no auto-indent\n      buf->b_p_et = 0;              // no expandtab\n    }\n\n    // set global options\n    p_sm = 0;                       // no showmatch\n    p_sta = 0;                      // no smarttab\n    if (p_ru) {\n      status_redraw_all();          // redraw to remove the ruler\n    }\n    p_ru = 0;                       // no ruler\n    p_ri = 0;                       // no reverse insert\n    p_hkmap = 0;                    // no Hebrew keyboard\n    // set global values for local buffer options\n    p_tw = 0;\n    p_wm = 0;\n    p_sts = 0;\n    p_ai = 0;\n  }\n  /*\n   * Paste switched from on to off: Restore saved values.\n   */\n  else if (old_p_paste) {\n    /* restore options for each buffer */\n    FOR_ALL_BUFFERS(buf) {\n      buf->b_p_tw = buf->b_p_tw_nopaste;\n      buf->b_p_wm = buf->b_p_wm_nopaste;\n      buf->b_p_sts = buf->b_p_sts_nopaste;\n      buf->b_p_ai = buf->b_p_ai_nopaste;\n      buf->b_p_et = buf->b_p_et_nopaste;\n    }\n\n    /* restore global options */\n    p_sm = save_sm;\n    p_sta = save_sta;\n    if (p_ru != save_ru) {\n      status_redraw_all();          // redraw to draw the ruler\n    }\n    p_ru = save_ru;\n    p_ri = save_ri;\n    p_hkmap = save_hkmap;\n    // set global values for local buffer options\n    p_ai = p_ai_nopaste;\n    p_et = p_et_nopaste;\n    p_sts = p_sts_nopaste;\n    p_tw = p_tw_nopaste;\n    p_wm = p_wm_nopaste;\n  }\n\n  old_p_paste = p_paste;\n}\n\n/// vimrc_found() - Called when a vimrc or \"VIMINIT\" has been found.\n///\n/// Set the values for options that didn't get set yet to the Vim defaults.\n/// When \"fname\" is not NULL, use it to set $\"envname\" when it wasn't set yet.\nvoid vimrc_found(char_u *fname, char_u *envname)\n{\n  char_u      *p;\n\n  if (fname != NULL) {\n    p = (char_u *)vim_getenv((char *)envname);\n    if (p == NULL) {\n      /* Set $MYVIMRC to the first vimrc file found. */\n      p = (char_u *)FullName_save((char *)fname, FALSE);\n      if (p != NULL) {\n        vim_setenv((char *)envname, (char *)p);\n        xfree(p);\n      }\n    } else {\n      xfree(p);\n    }\n  }\n}\n\n/*\n * Return TRUE when option \"name\" has been set.\n * Only works correctly for global options.\n */\nint option_was_set(char_u *name)\n{\n  int idx;\n\n  idx = findoption(name);\n  if (idx < 0)          /* unknown option */\n    return FALSE;\n  if (options[idx].flags & P_WAS_SET)\n    return TRUE;\n  return FALSE;\n}\n\n/*\n * fill_breakat_flags() -- called when 'breakat' changes value.\n */\nstatic void fill_breakat_flags(void)\n{\n  char_u      *p;\n  int i;\n\n  for (i = 0; i < 256; i++)\n    breakat_flags[i] = FALSE;\n\n  if (p_breakat != NULL)\n    for (p = p_breakat; *p; p++)\n      breakat_flags[*p] = TRUE;\n}\n\n/*\n * Check an option that can be a range of string values.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\nstatic int check_opt_strings(\n    char_u *val,\n    char **values,\n    int list                   /* when TRUE: accept a list of values */\n)\n{\n  return opt_strings_flags(val, values, NULL, list);\n}\n\n/*\n * Handle an option that can be a range of string values.\n * Set a flag in \"*flagp\" for each string present.\n *\n * Return OK for correct value, FAIL otherwise.\n * Empty is always OK.\n */\nstatic int opt_strings_flags(\n    char_u *val,             /* new value */\n    char **values,           /* array of valid string values */\n    unsigned *flagp,\n    bool list                /* when TRUE: accept a list of values */\n)\n{\n  unsigned int new_flags = 0;\n\n  while (*val) {\n    for (unsigned int i = 0;; ++i) {\n      if (values[i] == NULL)            /* val not found in values[] */\n        return FAIL;\n\n      size_t len = STRLEN(values[i]);\n      if (STRNCMP(values[i], val, len) == 0\n          && ((list && val[len] == ',') || val[len] == NUL)) {\n        val += len + (val[len] == ',');\n        assert(i < sizeof(1U) * 8);\n        new_flags |= (1U << i);\n        break;                  /* check next item in val list */\n      }\n    }\n  }\n  if (flagp != NULL)\n    *flagp = new_flags;\n\n  return OK;\n}\n\n/*\n * Read the 'wildmode' option, fill wim_flags[].\n */\nstatic int check_opt_wim(void)\n{\n  char_u new_wim_flags[4];\n  char_u      *p;\n  int i;\n  int idx = 0;\n\n  for (i = 0; i < 4; ++i)\n    new_wim_flags[i] = 0;\n\n  for (p = p_wim; *p; ++p) {\n    for (i = 0; ASCII_ISALPHA(p[i]); ++i)\n      ;\n    if (p[i] != NUL && p[i] != ',' && p[i] != ':')\n      return FAIL;\n    if (i == 7 && STRNCMP(p, \"longest\", 7) == 0)\n      new_wim_flags[idx] |= WIM_LONGEST;\n    else if (i == 4 && STRNCMP(p, \"full\", 4) == 0)\n      new_wim_flags[idx] |= WIM_FULL;\n    else if (i == 4 && STRNCMP(p, \"list\", 4) == 0)\n      new_wim_flags[idx] |= WIM_LIST;\n    else\n      return FAIL;\n    p += i;\n    if (*p == NUL)\n      break;\n    if (*p == ',') {\n      if (idx == 3)\n        return FAIL;\n      ++idx;\n    }\n  }\n\n  /* fill remaining entries with last flag */\n  while (idx < 3) {\n    new_wim_flags[idx + 1] = new_wim_flags[idx];\n    ++idx;\n  }\n\n  /* only when there are no errors, wim_flags[] is changed */\n  for (i = 0; i < 4; ++i)\n    wim_flags[i] = new_wim_flags[i];\n  return OK;\n}\n\n/*\n * Check if backspacing over something is allowed.\n * The parameter what is one of the following: whatBS_INDENT, BS_EOL \n * or BS_START\n */\nbool can_bs(int what)\n{\n  switch (*p_bs) {\n  case '2':       return TRUE;\n  case '1':       return what != BS_START;\n  case '0':       return FALSE;\n  }\n  return vim_strchr(p_bs, what) != NULL;\n}\n\n/*\n * Save the current values of 'fileformat' and 'fileencoding', so that we know\n * the file must be considered changed when the value is different.\n */\nvoid save_file_ff(buf_T *buf)\n{\n  buf->b_start_ffc = *buf->b_p_ff;\n  buf->b_start_eol = buf->b_p_eol;\n  buf->b_start_bomb = buf->b_p_bomb;\n\n  /* Only use free/alloc when necessary, they take time. */\n  if (buf->b_start_fenc == NULL\n      || STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0) {\n    xfree(buf->b_start_fenc);\n    buf->b_start_fenc = vim_strsave(buf->b_p_fenc);\n  }\n}\n\n/*\n * Return TRUE if 'fileformat' and/or 'fileencoding' has a different value\n * from when editing started (save_file_ff() called).\n * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was\n * changed and 'binary' is not set.\n * Also when 'endofline' was changed and 'fixeol' is not set.\n * When \"ignore_empty\" is true don't consider a new, empty buffer to be\n * changed.\n */\nbool file_ff_differs(buf_T *buf, bool ignore_empty)\n{\n  /* In a buffer that was never loaded the options are not valid. */\n  if (buf->b_flags & BF_NEVERLOADED)\n    return FALSE;\n  if (ignore_empty\n      && (buf->b_flags & BF_NEW)\n      && buf->b_ml.ml_line_count == 1\n      && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)\n    return FALSE;\n  if (buf->b_start_ffc != *buf->b_p_ff)\n    return true;\n  if ((buf->b_p_bin || !buf->b_p_fixeol) && buf->b_start_eol != buf->b_p_eol)\n    return true;\n  if (!buf->b_p_bin && buf->b_start_bomb != buf->b_p_bomb)\n    return TRUE;\n  if (buf->b_start_fenc == NULL)\n    return *buf->b_p_fenc != NUL;\n  return STRCMP(buf->b_start_fenc, buf->b_p_fenc) != 0;\n}\n\n/*\n * return OK if \"p\" is a valid fileformat name, FAIL otherwise.\n */\nint check_ff_value(char_u *p)\n{\n  return check_opt_strings(p, p_ff_values, FALSE);\n}\n\n/*\n * Return the effective shiftwidth value for current buffer, using the\n * 'tabstop' value when 'shiftwidth' is zero.\n */\nint get_sw_value(buf_T *buf)\n{\n  long result = buf->b_p_sw ? buf->b_p_sw : buf->b_p_ts;\n  assert(result >= 0 && result <= INT_MAX);\n  return (int)result;\n}\n\n// Return the effective softtabstop value for the current buffer,\n// using the effective shiftwidth  value when 'softtabstop' is negative.\nint get_sts_value(void)\n{\n  long result = curbuf->b_p_sts < 0 ? get_sw_value(curbuf) : curbuf->b_p_sts;\n  assert(result >= 0 && result <= INT_MAX);\n  return (int)result;\n}\n\n/*\n * Check matchpairs option for \"*initc\".\n * If there is a match set \"*initc\" to the matching character and \"*findc\" to\n * the opposite character.  Set \"*backwards\" to the direction.\n * When \"switchit\" is TRUE swap the direction.\n */\nvoid find_mps_values(int *initc, int *findc, int *backwards, int switchit)\n{\n  char_u      *ptr;\n\n  ptr = curbuf->b_p_mps;\n  while (*ptr != NUL) {\n    if (has_mbyte) {\n      char_u *prev;\n\n      if (mb_ptr2char(ptr) == *initc) {\n        if (switchit) {\n          *findc = *initc;\n          *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n          *backwards = TRUE;\n        } else {\n          *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n          *backwards = FALSE;\n        }\n        return;\n      }\n      prev = ptr;\n      ptr += mb_ptr2len(ptr) + 1;\n      if (mb_ptr2char(ptr) == *initc) {\n        if (switchit) {\n          *findc = *initc;\n          *initc = mb_ptr2char(prev);\n          *backwards = FALSE;\n        } else {\n          *findc = mb_ptr2char(prev);\n          *backwards = TRUE;\n        }\n        return;\n      }\n      ptr += mb_ptr2len(ptr);\n    } else {\n      if (*ptr == *initc) {\n        if (switchit) {\n          *backwards = TRUE;\n          *findc = *initc;\n          *initc = ptr[2];\n        } else {\n          *backwards = FALSE;\n          *findc = ptr[2];\n        }\n        return;\n      }\n      ptr += 2;\n      if (*ptr == *initc) {\n        if (switchit) {\n          *backwards = FALSE;\n          *findc = *initc;\n          *initc = ptr[-2];\n        } else {\n          *backwards = TRUE;\n          *findc =  ptr[-2];\n        }\n        return;\n      }\n      ++ptr;\n    }\n    if (*ptr == ',')\n      ++ptr;\n  }\n}\n\n/// This is called when 'breakindentopt' is changed and when a window is\n/// initialized\nstatic bool briopt_check(win_T *wp)\n{\n  int bri_shift = 0;\n  int bri_min = 20;\n  bool bri_sbr = false;\n\n  char_u *p = wp->w_p_briopt;\n  while (*p != NUL)\n  {\n    if (STRNCMP(p, \"shift:\", 6) == 0\n        && ((p[6] == '-' && ascii_isdigit(p[7])) || ascii_isdigit(p[6])))\n    {\n      p += 6;\n      bri_shift = getdigits_int(&p);\n    }\n    else if (STRNCMP(p, \"min:\", 4) == 0 && ascii_isdigit(p[4]))\n    {\n      p += 4;\n      bri_min = getdigits_int(&p);\n    }\n    else if (STRNCMP(p, \"sbr\", 3) == 0)\n    {\n      p += 3;\n      bri_sbr = true;\n    }\n    if (*p != ',' && *p != NUL)\n      return false;\n    if (*p == ',')\n      ++p;\n  }\n\n  wp->w_p_brishift = bri_shift;\n  wp->w_p_brimin   = bri_min;\n  wp->w_p_brisbr   = bri_sbr;\n\n  return true;\n}\n\n/// Get the local or global value of 'backupcopy'.\n///\n/// @param buf The buffer.\nunsigned int get_bkc_value(buf_T *buf)\n{\n  return buf->b_bkc_flags ? buf->b_bkc_flags : bkc_flags;\n}\n\n/// Return the current end-of-line type: EOL_DOS, EOL_UNIX or EOL_MAC.\nint get_fileformat(buf_T *buf)\n{\n  int c = *buf->b_p_ff;\n\n  if (buf->b_p_bin || c == 'u') {\n    return EOL_UNIX;\n  }\n  if (c == 'm') {\n    return EOL_MAC;\n  }\n  return EOL_DOS;\n}\n\n/// Like get_fileformat(), but override 'fileformat' with \"p\" for \"++opt=val\"\n/// argument.\n///\n/// @param eap  can be NULL!\nint get_fileformat_force(buf_T *buf, exarg_T *eap)\n{\n  int c;\n\n  if (eap != NULL && eap->force_ff != 0) {\n    c = eap->cmd[eap->force_ff];\n  } else {\n    if ((eap != NULL && eap->force_bin != 0)\n        ? (eap->force_bin == FORCE_BIN) : buf->b_p_bin) {\n      return EOL_UNIX;\n    }\n    c = *buf->b_p_ff;\n  }\n  if (c == 'u') {\n    return EOL_UNIX;\n  }\n  if (c == 'm') {\n    return EOL_MAC;\n  }\n  return EOL_DOS;\n}\n\n/// Return the default fileformat from 'fileformats'.\nint default_fileformat(void)\n{\n  switch (*p_ffs) {\n  case 'm':   return EOL_MAC;\n  case 'd':   return EOL_DOS;\n  }\n  return EOL_UNIX;\n}\n\n/// Set the current end-of-line type to EOL_UNIX, EOL_MAC, or EOL_DOS.\n///\n/// Sets 'fileformat'.\n///\n/// @param eol_style End-of-line style.\n/// @param opt_flags OPT_LOCAL and/or OPT_GLOBAL\nvoid set_fileformat(int eol_style, int opt_flags)\n{\n  char *p = NULL;\n\n  switch (eol_style) {\n      case EOL_UNIX:\n          p = FF_UNIX;\n          break;\n      case EOL_MAC:\n          p = FF_MAC;\n          break;\n      case EOL_DOS:\n          p = FF_DOS;\n          break;\n  }\n\n  // p is NULL if \"eol_style\" is EOL_UNKNOWN.\n  if (p != NULL) {\n    set_string_option_direct((char_u *)\"ff\",\n                             -1,\n                             (char_u *)p,\n                             OPT_FREE | opt_flags,\n                             0);\n  }\n\n  // This may cause the buffer to become (un)modified.\n  check_status(curbuf);\n  redraw_tabline = true;\n  need_maketitle = true;  // Set window title later.\n}\n\n/// Skip to next part of an option argument: Skip space and comma.\nchar_u *skip_to_option_part(char_u *p)\n{\n  if (*p == ',') {\n    p++;\n  }\n  while (*p == ' ') {\n    p++;\n  }\n  return p;\n}\n\n/// Isolate one part of a string option separated by `sep_chars`.\n///\n/// @param[in,out]  option    advanced to the next part\n/// @param[in,out]  buf       copy of the isolated part\n/// @param[in]      maxlen    length of `buf`\n/// @param[in]      sep_chars chars that separate the option parts\n///\n/// @return length of `*option`\nsize_t copy_option_part(char_u **option, char_u *buf, size_t maxlen,\n                        char *sep_chars)\n{\n  size_t len = 0;\n  char_u  *p = *option;\n\n  // skip '.' at start of option part, for 'suffixes'\n  if (*p == '.') {\n    buf[len++] = *p++;\n  }\n  while (*p != NUL && vim_strchr((char_u *)sep_chars, *p) == NULL) {\n    // Skip backslash before a separator character and space.\n    if (p[0] == '\\\\' && vim_strchr((char_u *)sep_chars, p[1]) != NULL) {\n      p++;\n    }\n    if (len < maxlen - 1) {\n      buf[len++] = *p;\n    }\n    p++;\n  }\n  buf[len] = NUL;\n\n  if (*p != NUL && *p != ',') {  // skip non-standard separator\n    p++;\n  }\n  p = skip_to_option_part(p);    // p points to next file name\n\n  *option = p;\n  return len;\n}\n\n/// Return TRUE when 'shell' has \"csh\" in the tail.\nint csh_like_shell(void)\n{\n  return strstr((char *)path_tail(p_sh), \"csh\") != NULL;\n}\n\n", "\" Test for options\n\nfunction! Test_whichwrap()\n  set whichwrap=b,s\n  call assert_equal('b,s', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap+=h,l\n  call assert_equal('b,s,h,l', &whichwrap)\n\n  set whichwrap&\nendfunction\n\nfunction! Test_options()\n  let caught = 'ok'\n  try\n    options\n  catch\n    let caught = v:throwpoint . \"\\n\" . v:exception\n  endtry\n  call assert_equal('ok', caught)\n\n  \" close option-window\n  close\nendfunction\n\nfunction! Test_path_keep_commas()\n  \" Test that changing 'path' keeps two commas.\n  set path=foo,,bar\n  set path-=bar\n  set path+=bar\n  call assert_equal('foo,,bar', &path)\n\n  set path&\nendfunction\n\nfunc Test_filetype_valid()\n  set ft=valid_name\n  call assert_equal(\"valid_name\", &filetype)\n  set ft=valid-name\n  call assert_equal(\"valid-name\", &filetype)\n\n  call assert_fails(\":set ft=wrong;name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set ft=wrong/name\", \"E474:\")\n  call assert_fails(\":set ft=wrong\\\\\\nname\", \"E474:\")\n  call assert_equal(\"valid-name\", &filetype)\n\n  exe \"set ft=trunc\\x00name\"\n  call assert_equal(\"trunc\", &filetype)\nendfunc\n\nfunc Test_syntax_valid()\n  set syn=valid_name\n  call assert_equal(\"valid_name\", &syntax)\n  set syn=valid-name\n  call assert_equal(\"valid-name\", &syntax)\n\n  call assert_fails(\":set syn=wrong;name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set syn=wrong/name\", \"E474:\")\n  call assert_fails(\":set syn=wrong\\\\\\nname\", \"E474:\")\n  call assert_equal(\"valid-name\", &syntax)\n\n  exe \"set syn=trunc\\x00name\"\n  call assert_equal(\"trunc\", &syntax)\nendfunc\n\nfunc Test_keymap_valid()\n  call assert_fails(\":set kmp=valid_name\", \"E544:\")\n  call assert_fails(\":set kmp=valid_name\", \"valid_name\")\n  call assert_fails(\":set kmp=valid-name\", \"E544:\")\n  call assert_fails(\":set kmp=valid-name\", \"valid-name\")\n\n  call assert_fails(\":set kmp=wrong;name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\\\\\name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\|name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong/name\", \"E474:\")\n  call assert_fails(\":set kmp=wrong\\\\\\nname\", \"E474:\")\n\n  call assert_fails(\":set kmp=trunc\\x00name\", \"E544:\")\n  call assert_fails(\":set kmp=trunc\\x00name\", \"trunc\")\nendfunc\n"], "filenames": ["src/nvim/option.c", "src/nvim/testdir/test_options.vim"], "buggy_code_start_loc": [2401, 40], "buggy_code_end_loc": [3122, 40], "fixing_code_start_loc": [2402, 41], "fixing_code_end_loc": [3147, 91], "type": "CWE-20", "message": "vim before patch 8.0.0056 does not properly validate values for the 'filetype', 'syntax' and 'keymap' options, which may result in the execution of arbitrary code if a file with a specially crafted modeline is opened.", "other": {"cve": {"id": "CVE-2016-1248", "sourceIdentifier": "security@debian.org", "published": "2016-11-23T15:59:00.137", "lastModified": "2017-07-28T01:29:00.423", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "vim before patch 8.0.0056 does not properly validate values for the 'filetype', 'syntax' and 'keymap' options, which may result in the execution of arbitrary code if a file with a specially crafted modeline is opened."}, {"lang": "es", "value": "vim en versiones anteriores a patch 8.0.0056 no valida correctamente los valores para las opciones 'filetype', 'syntax' y 'keymap', lo que puede resulta en la ejecuci\u00f3n de c\u00f3digo arbitrario si se abre un archivo con una l\u00ednea de modo especialmente manipulada."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.0055", "matchCriteriaId": "6C46FDA7-FFAC-47FC-844E-327A0F14E824"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://openwall.com/lists/oss-security/2016/11/22/20", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2972.html", "source": "security@debian.org"}, {"url": "http://www.debian.org/security/2016/dsa-3722", "source": "security@debian.org"}, {"url": "http://www.securityfocus.com/bid/94478", "source": "security@debian.org"}, {"url": "http://www.securitytracker.com/id/1037338", "source": "security@debian.org"}, {"url": "http://www.ubuntu.com/usn/USN-3139-1", "source": "security@debian.org"}, {"url": "https://anonscm.debian.org/cgit/pkg-vim/vim.git/tree/debian/changelog", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/neovim/neovim/commit/4fad66fbe637818b6b3d6bc5d21923ba72795040", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/vim/vim/commit/d0b5138ba4bccff8a744c99836041ef6322ed39a", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/vim/vim/releases/tag/v8.0.0056", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2016/11/msg00025.html", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-security-announce/2016/msg00305.html", "source": "security@debian.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201701-29", "source": "security@debian.org"}]}, "github_commit_url": "https://github.com/neovim/neovim/commit/4fad66fbe637818b6b3d6bc5d21923ba72795040"}}