{"buggy_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n\n\n//-----------------------------------------------------------------------------\n//\n//\t16-bit Huffman compression and decompression.\n//\n//\tThe source code in this file is derived from the 8-bit\n//\tHuffman compression and decompression routines written\n//\tby Christian Rouet for his PIZ image file format.\n//\n//-----------------------------------------------------------------------------\n\n#include <ImfHuf.h>\n#include <ImfInt64.h>\n#include \"ImfAutoArray.h\"\n#include \"ImfFastHuf.h\"\n#include \"Iex.h\"\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n\n\nusing namespace std;\nusing namespace IEX_NAMESPACE;\n#include \"ImfNamespace.h\"\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nnamespace {\n\n\nconst int HUF_ENCBITS = 16;\t\t\t// literal (value) bit length\nconst int HUF_DECBITS = 14;\t\t\t// decoding bit size (>= 8)\n\nconst int HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\t// encoding table size\nconst int HUF_DECSIZE =  1 << HUF_DECBITS;\t// decoding table size\nconst int HUF_DECMASK = HUF_DECSIZE - 1;\n\n\nstruct HufDec\n{\t\t\t\t// short code\t\tlong code\n\t\t\t\t//-------------------------------\n    int\t\tlen:8;\t\t// code length\t\t0\t \n    int\t\tlit:24;\t\t// lit\t\t\tp size\t \n    int\t*\tp;\t\t// 0\t\t\tlits\t \n};\n\n\nvoid\ninvalidNBits ()\n{\n    throw InputExc (\"Error in header for Huffman-encoded data \"\n\t\t    \"(invalid number of bits).\");\n}\n\n\nvoid\ntooMuchData ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(decoded data are longer than expected).\");\n}\n\n\nvoid\nnotEnoughData ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(decoded data are shorter than expected).\");\n}\n\n\nvoid\ninvalidCode ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(invalid code).\");\n}\n\n\nvoid\ninvalidTableSize ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(invalid code table size).\");\n}\n\n\nvoid\nunexpectedEndOfTable ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(unexpected end of code table data).\");\n}\n\n\nvoid\ntableTooLong ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(code table is longer than expected).\");\n}\n\n\nvoid\ninvalidTableEntry ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(invalid code table entry).\");\n}\n\n\ninline Int64\nhufLength (Int64 code)\n{\n    return code & 63;\n}\n\n\ninline Int64\nhufCode (Int64 code)\n{\n    return code >> 6;\n}\n\n\ninline void\noutputBits (int nBits, Int64 bits, Int64 &c, int &lc, char *&out)\n{\n    c <<= nBits;\n    lc += nBits;\n\n    c |= bits;\n\n    while (lc >= 8)\n\t*out++ = (c >> (lc -= 8));\n}\n\n\ninline Int64\ngetBits (int nBits, Int64 &c, int &lc, const char *&in)\n{\n    while (lc < nBits)\n    {\n\tc = (c << 8) | *(unsigned char *)(in++);\n\tlc += 8;\n    }\n\n    lc -= nBits;\n    return (c >> lc) & ((1 << nBits) - 1);\n}\n\n\n//\n// ENCODING TABLE BUILDING & (UN)PACKING\n//\n\n//\n// Build a \"canonical\" Huffman code table:\n//\t- for each (uncompressed) symbol, hcode contains the length\n//\t  of the corresponding code (in the compressed data)\n//\t- canonical codes are computed and stored in hcode\n//\t- the rules for constructing canonical codes are as follows:\n//\t  * shorter codes (if filled with zeroes to the right)\n//\t    have a numerically higher value than longer codes\n//\t  * for codes with the same length, numerical values\n//\t    increase with numerical symbol values\n//\t- because the canonical code table can be constructed from\n//\t  symbol lengths alone, the code table can be transmitted\n//\t  without sending the actual code values\n//\t- see http://www.compressconsult.com/huffman/\n//\n\n#if !defined (OPENEXR_IMF_HAVE_LARGE_STACK)\nvoid\nhufCanonicalCodeTable (Int64 *hcode)\n#else\nvoid\nhufCanonicalCodeTable (Int64 hcode[HUF_ENCSIZE])\n#endif\n{\n    Int64 n[59];\n\n    //\n    // For each i from 0 through 58, count the\n    // number of different codes of length i, and\n    // store the count in n[i].\n    //\n\n    for (int i = 0; i <= 58; ++i)\n\tn[i] = 0;\n\n    for (int i = 0; i < HUF_ENCSIZE; ++i)\n\tn[hcode[i]] += 1;\n\n    //\n    // For each i from 58 through 1, compute the\n    // numerically lowest code with length i, and\n    // store that code in n[i].\n    //\n\n    Int64 c = 0;\n\n    for (int i = 58; i > 0; --i)\n    {\n\tInt64 nc = ((c + n[i]) >> 1);\n\tn[i] = c;\n\tc = nc;\n    }\n\n    //\n    // hcode[i] contains the length, l, of the\n    // code for symbol i.  Assign the next available\n    // code of length l to the symbol and store both\n    // l and the code in hcode[i].\n    //\n\n    for (int i = 0; i < HUF_ENCSIZE; ++i)\n    {\n\tint l = hcode[i];\n\n\tif (l > 0)\n\t    hcode[i] = l | (n[l]++ << 6);\n    }\n}\n\n\n//\n// Compute Huffman codes (based on frq input) and store them in frq:\n//\t- code structure is : [63:lsb - 6:msb] | [5-0: bit length];\n//\t- max code length is 58 bits;\n//\t- codes outside the range [im-iM] have a null length (unused values);\n//\t- original frequencies are destroyed;\n//\t- encoding tables are used by hufEncode() and hufBuildDecTable();\n//\n// NB: The following code \"(*a == *b) && (a > b))\" was added to ensure\n//     elements in the heap with the same value are sorted by index.\n//     This is to ensure, the STL make_heap()/pop_heap()/push_heap() methods\n//     produced a resultant sorted heap that is identical across OSes.\n//\n\n\nstruct FHeapCompare\n{\n    bool operator () (Int64 *a, Int64 *b)\n    {\n        return ((*a > *b) || ((*a == *b) && (a > b)));\n    }\n};\n\n\nvoid\nhufBuildEncTable\n    (Int64*\tfrq,\t// io: input frequencies [HUF_ENCSIZE], output table\n     int*\tim,\t//  o: min frq index\n     int*\tiM)\t//  o: max frq index\n{\n    //\n    // This function assumes that when it is called, array frq\n    // indicates the frequency of all possible symbols in the data\n    // that are to be Huffman-encoded.  (frq[i] contains the number\n    // of occurrences of symbol i in the data.)\n    //\n    // The loop below does three things:\n    //\n    // 1) Finds the minimum and maximum indices that point\n    //    to non-zero entries in frq:\n    //\n    //     frq[im] != 0, and frq[i] == 0 for all i < im\n    //     frq[iM] != 0, and frq[i] == 0 for all i > iM\n    //\n    // 2) Fills array fHeap with pointers to all non-zero\n    //    entries in frq.\n    //\n    // 3) Initializes array hlink such that hlink[i] == i\n    //    for all array entries.\n    //\n\n    AutoArray <int, HUF_ENCSIZE> hlink;\n    AutoArray <Int64 *, HUF_ENCSIZE> fHeap;\n\n    *im = 0;\n\n    while (!frq[*im])\n\t(*im)++;\n\n    int nf = 0;\n\n    for (int i = *im; i < HUF_ENCSIZE; i++)\n    {\n\thlink[i] = i;\n\n\tif (frq[i])\n\t{\n\t    fHeap[nf] = &frq[i];\n\t    nf++;\n\t    *iM = i;\n\t}\n    }\n\n    //\n    // Add a pseudo-symbol, with a frequency count of 1, to frq;\n    // adjust the fHeap and hlink array accordingly.  Function\n    // hufEncode() uses the pseudo-symbol for run-length encoding.\n    //\n\n    (*iM)++;\n    frq[*iM] = 1;\n    fHeap[nf] = &frq[*iM];\n    nf++;\n\n    //\n    // Build an array, scode, such that scode[i] contains the number\n    // of bits assigned to symbol i.  Conceptually this is done by\n    // constructing a tree whose leaves are the symbols with non-zero\n    // frequency:\n    //\n    //     Make a heap that contains all symbols with a non-zero frequency,\n    //     with the least frequent symbol on top.\n    //\n    //     Repeat until only one symbol is left on the heap:\n    //\n    //         Take the two least frequent symbols off the top of the heap.\n    //         Create a new node that has first two nodes as children, and\n    //         whose frequency is the sum of the frequencies of the first\n    //         two nodes.  Put the new node back into the heap.\n    //\n    // The last node left on the heap is the root of the tree.  For each\n    // leaf node, the distance between the root and the leaf is the length\n    // of the code for the corresponding symbol.\n    //\n    // The loop below doesn't actually build the tree; instead we compute\n    // the distances of the leaves from the root on the fly.  When a new\n    // node is added to the heap, then that node's descendants are linked\n    // into a single linear list that starts at the new node, and the code\n    // lengths of the descendants (that is, their distance from the root\n    // of the tree) are incremented by one.\n    //\n\n    make_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\n    AutoArray <Int64, HUF_ENCSIZE> scode;\n    memset (scode, 0, sizeof (Int64) * HUF_ENCSIZE);\n\n    while (nf > 1)\n    {\n\t//\n\t// Find the indices, mm and m, of the two smallest non-zero frq\n\t// values in fHeap, add the smallest frq to the second-smallest\n\t// frq, and remove the smallest frq value from fHeap.\n\t//\n\n\tint mm = fHeap[0] - frq;\n\tpop_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\t--nf;\n\n\tint m = fHeap[0] - frq;\n\tpop_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\n\tfrq[m ] += frq[mm];\n\tpush_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\n\t//\n\t// The entries in scode are linked into lists with the\n\t// entries in hlink serving as \"next\" pointers and with\n\t// the end of a list marked by hlink[j] == j.\n\t//\n\t// Traverse the lists that start at scode[m] and scode[mm].\n\t// For each element visited, increment the length of the\n\t// corresponding code by one bit. (If we visit scode[j]\n\t// during the traversal, then the code for symbol j becomes\n\t// one bit longer.)\n\t//\n\t// Merge the lists that start at scode[m] and scode[mm]\n\t// into a single list that starts at scode[m].\n\t//\n\t\n\t//\n\t// Add a bit to all codes in the first list.\n\t//\n\n\tfor (int j = m; true; j = hlink[j])\n\t{\n\t    scode[j]++;\n\n\t    assert (scode[j] <= 58);\n\n\t    if (hlink[j] == j)\n\t    {\n\t\t//\n\t\t// Merge the two lists.\n\t\t//\n\n\t\thlink[j] = mm;\n\t\tbreak;\n\t    }\n\t}\n\n\t//\n\t// Add a bit to all codes in the second list\n\t//\n\n\tfor (int j = mm; true; j = hlink[j])\n\t{\n\t    scode[j]++;\n\n\t    assert (scode[j] <= 58);\n\n\t    if (hlink[j] == j)\n\t\tbreak;\n\t}\n    }\n\n    //\n    // Build a canonical Huffman code table, replacing the code\n    // lengths in scode with (code, code length) pairs.  Copy the\n    // code table from scode into frq.\n    //\n\n    hufCanonicalCodeTable (scode);\n    memcpy (frq, scode, sizeof (Int64) * HUF_ENCSIZE);\n}\n\n\n//\n// Pack an encoding table:\n//\t- only code lengths, not actual codes, are stored\n//\t- runs of zeroes are compressed as follows:\n//\n//\t  unpacked\t\tpacked\n//\t  --------------------------------\n//\t  1 zero\t\t0\t(6 bits)\n//\t  2 zeroes\t\t59\n//\t  3 zeroes\t\t60\n//\t  4 zeroes\t\t61\n//\t  5 zeroes\t\t62\n//\t  n zeroes (6 or more)\t63 n-6\t(6 + 8 bits)\n//\n\nconst int SHORT_ZEROCODE_RUN = 59;\nconst int LONG_ZEROCODE_RUN  = 63;\nconst int SHORTEST_LONG_RUN  = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\nconst int LONGEST_LONG_RUN   = 255 + SHORTEST_LONG_RUN;\n\n\nvoid\nhufPackEncTable\n    (const Int64*\thcode,\t\t// i : encoding table [HUF_ENCSIZE]\n     int\t\tim,\t\t// i : min hcode index\n     int\t\tiM,\t\t// i : max hcode index\n     char**\t\tpcode)\t\t//  o: ptr to packed table (updated)\n{\n    char *p = *pcode;\n    Int64 c = 0;\n    int lc = 0;\n\n    for (; im <= iM; im++)\n    {\n\tint l = hufLength (hcode[im]);\n\n\tif (l == 0)\n\t{\n\t    int zerun = 1;\n\n\t    while ((im < iM) && (zerun < LONGEST_LONG_RUN))\n\t    {\n\t\tif (hufLength (hcode[im+1]) > 0 )\t \n\t\t    break;\n\t\tim++;\n\t\tzerun++;\n\t    }\n\n\t    if (zerun >= 2)\n\t    {\n\t\tif (zerun >= SHORTEST_LONG_RUN)\n\t\t{\n\t\t    outputBits (6, LONG_ZEROCODE_RUN, c, lc, p);\n\t\t    outputBits (8, zerun - SHORTEST_LONG_RUN, c, lc, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    outputBits (6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p);\n\t\t}\n\t\tcontinue;\n\t    }\n\t}\n\n\toutputBits (6, l, c, lc, p);\n    }\n\n    if (lc > 0)\n\t*p++ = (unsigned char) (c << (8 - lc));\n\n    *pcode = p;\n}\n\n\n//\n// Unpack an encoding table packed by hufPackEncTable():\n//\n\nvoid\nhufUnpackEncTable\n    (const char**\tpcode,\t\t// io: ptr to packed table (updated)\n     int\t\tni,\t\t// i : input size (in bytes)\n     int\t\tim,\t\t// i : min hcode index\n     int\t\tiM,\t\t// i : max hcode index\n     Int64*\t\thcode)\t\t//  o: encoding table [HUF_ENCSIZE]\n{\n    memset (hcode, 0, sizeof (Int64) * HUF_ENCSIZE);\n\n    const char *p = *pcode;\n    Int64 c = 0;\n    int lc = 0;\n\n    for (; im <= iM; im++)\n    {\n\tif (p - *pcode > ni)\n\t    unexpectedEndOfTable();\n\n\tInt64 l = hcode[im] = getBits (6, c, lc, p); // code length\n\n\tif (l == (Int64) LONG_ZEROCODE_RUN)\n\t{\n\t    if (p - *pcode > ni)\n\t\tunexpectedEndOfTable();\n\n\t    int zerun = getBits (8, c, lc, p) + SHORTEST_LONG_RUN;\n\n\t    if (im + zerun > iM + 1)\n\t\ttableTooLong();\n\n\t    while (zerun--)\n\t\thcode[im++] = 0;\n\n\t    im--;\n\t}\n\telse if (l >= (Int64) SHORT_ZEROCODE_RUN)\n\t{\n\t    int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t    if (im + zerun > iM + 1)\n\t\ttableTooLong();\n\n\t    while (zerun--)\n\t\thcode[im++] = 0;\n\n\t    im--;\n\t}\n    }\n\n    *pcode = const_cast<char *>(p);\n\n    hufCanonicalCodeTable (hcode);\n}\n\n\n//\n// DECODING TABLE BUILDING\n//\n\n//\n// Clear a newly allocated decoding table so that it contains only zeroes.\n//\n\nvoid\nhufClearDecTable\n    (HufDec *\t\thdecod)\t\t// io: (allocated by caller)\n     \t\t\t\t\t//     decoding table [HUF_DECSIZE]\n{\n    memset (hdecod, 0, sizeof (HufDec) * HUF_DECSIZE);\n}\n\n\n//\n// Build a decoding hash table based on the encoding table hcode:\n//\t- short codes (<= HUF_DECBITS) are resolved with a single table access;\n//\t- long code entry allocations are not optimized, because long codes are\n//\t  unfrequent;\n//\t- decoding tables are used by hufDecode();\n//\n\nvoid\nhufBuildDecTable\n    (const Int64*\thcode,\t\t// i : encoding table\n     int\t\tim,\t\t// i : min index in hcode\n     int\t\tiM,\t\t// i : max index in hcode\n     HufDec *\t\thdecod)\t\t//  o: (allocated by caller)\n     \t\t\t\t\t//     decoding table [HUF_DECSIZE]\n{\n    //\n    // Init hashtable & loop on all codes.\n    // Assumes that hufClearDecTable(hdecod) has already been called.\n    //\n\n    for (; im <= iM; im++)\n    {\n\tInt64 c = hufCode (hcode[im]);\n\tint l = hufLength (hcode[im]);\n\n\tif (c >> l)\n\t{\n\t    //\n\t    // Error: c is supposed to be an l-bit code,\n\t    // but c contains a value that is greater\n\t    // than the largest l-bit number.\n\t    //\n\n\t    invalidTableEntry();\n\t}\n\n\tif (l > HUF_DECBITS)\n\t{\n\t    //\n\t    // Long code: add a secondary entry\n\t    //\n\n\t    HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));\n\n\t    if (pl->len)\n\t    {\n\t\t//\n\t\t// Error: a short code has already\n\t\t// been stored in table entry *pl.\n\t\t//\n\n\t\tinvalidTableEntry();\n\t    }\n\n\t    pl->lit++;\n\n\t    if (pl->p)\n\t    {\n\t\tint *p = pl->p;\n\t\tpl->p = new int [pl->lit];\n\n\t\tfor (int i = 0; i < pl->lit - 1; ++i)\n\t\t    pl->p[i] = p[i];\n\n\t\tdelete [] p;\n\t    }\n\t    else\n\t    {\n\t\tpl->p = new int [1];\n\t    }\n\n\t    pl->p[pl->lit - 1]= im;\n\t}\n\telse if (l)\n\t{\n\t    //\n\t    // Short code: init all primary entries\n\t    //\n\n\t    HufDec *pl = hdecod + (c << (HUF_DECBITS - l));\n\n\t    for (Int64 i = 1 << (HUF_DECBITS - l); i > 0; i--, pl++)\n\t    {\n\t\tif (pl->len || pl->p)\n\t\t{\n\t\t    //\n\t\t    // Error: a short code or a long code has\n\t\t    // already been stored in table entry *pl.\n\t\t    //\n\n\t\t    invalidTableEntry();\n\t\t}\n\n\t\tpl->len = l;\n\t\tpl->lit = im;\n\t    }\n\t}\n    }\n}\n\n\n//\n// Free the long code entries of a decoding table built by hufBuildDecTable()\n//\n\nvoid\nhufFreeDecTable (HufDec *hdecod)\t// io: Decoding table\n{\n    for (int i = 0; i < HUF_DECSIZE; i++)\n    {\n\tif (hdecod[i].p)\n\t{\n\t    delete [] hdecod[i].p;\n\t    hdecod[i].p = 0;\n\t}\n    }\n}\n\n\n//\n// ENCODING\n//\n\ninline void\noutputCode (Int64 code, Int64 &c, int &lc, char *&out)\n{\n    outputBits (hufLength (code), hufCode (code), c, lc, out);\n}\n\n\ninline void\nsendCode (Int64 sCode, int runCount, Int64 runCode,\n\t  Int64 &c, int &lc, char *&out)\n{\n    //\n    // Output a run of runCount instances of the symbol sCount.\n    // Output the symbols explicitly, or if that is shorter, output\n    // the sCode symbol once followed by a runCode symbol and runCount\n    // expressed as an 8-bit number.\n    //\n    \n    if (hufLength (sCode) + hufLength (runCode) + 8 <\n        hufLength (sCode) * runCount)\n    {\n\toutputCode (sCode, c, lc, out);\n\toutputCode (runCode, c, lc, out);\n\toutputBits (8, runCount, c, lc, out);\n    }\n    else\n    {\n\twhile (runCount-- >= 0)\n\t    outputCode (sCode, c, lc, out);\n    }\n}\n\n\n//\n// Encode (compress) ni values based on the Huffman encoding table hcode:\n//\n\nint\nhufEncode\t\t\t\t// return: output size (in bits)\n    (const Int64*  \t    hcode,\t// i : encoding table\n     const unsigned short*  in,\t\t// i : uncompressed input buffer\n     const int     \t    ni,\t\t// i : input buffer size (in bytes)\n     int           \t    rlc,\t// i : rl code\n     char*         \t    out)\t//  o: compressed output buffer\n{\n    char *outStart = out;\n    Int64 c = 0;\t// bits not yet written to out\n    int lc = 0;\t\t// number of valid bits in c (LSB)\n    int s = in[0];\n    int cs = 0;\n\n    //\n    // Loop on input values\n    //\n\n    for (int i = 1; i < ni; i++)\n    {\n\t//\n\t// Count same values or send code\n\t//\n\n\tif (s == in[i] && cs < 255)\n\t{\n\t    cs++;\n\t}\n\telse\n\t{\n\t    sendCode (hcode[s], cs, hcode[rlc], c, lc, out);\n\t    cs=0;\n\t}\n\n\ts = in[i];\n    }\n\n    //\n    // Send remaining code\n    //\n\n    sendCode (hcode[s], cs, hcode[rlc], c, lc, out);\n\n    if (lc)\n\t*out = (c << (8 - lc)) & 0xff;\n\n    return (out - outStart) * 8 + lc;\n}\n\n\n//\n// DECODING\n//\n\n//\n// In order to force the compiler to inline them,\n// getChar() and getCode() are implemented as macros\n// instead of \"inline\" functions.\n//\n\n#define getChar(c, lc, in)\t\t\t\\\n{\t\t\t\t\t\t\\\n    c = (c << 8) | *(unsigned char *)(in++);\t\\\n    lc += 8;\t\t\t\t\t\\\n}\n\n\n#define getCode(po, rlc, c, lc, in, out, ob, oe)\\\n{\t\t\t\t\t\t\\\n    if (po == rlc)\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n\tif (lc < 8)\t\t\t\t\\\n\t    getChar(c, lc, in);\t\t\t\\\n\t\t\t\t\t\t\\\n\tlc -= 8;\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tunsigned char cs = (c >> lc);\t\t\\\n\t\t\t\t\t\t\\\n\tif (out + cs > oe)\t\t\t\\\n\t    tooMuchData();\t\t\t\\\n\telse if (out - 1 < ob)\t\t\t\\\n\t    notEnoughData();\t\t\t\\\n\t\t\t\t\t\t\\\n\tunsigned short s = out[-1];\t\t\\\n\t\t\t\t\t\t\\\n\twhile (cs-- > 0)\t\t\t\\\n\t    *out++ = s;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n    else if (out < oe)\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n\t*out++ = po;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n\ttooMuchData();\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n}\n\n\n//\n// Decode (uncompress) ni bits based on encoding & decoding tables:\n//\n\nvoid\nhufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc < l && in < ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}\n\n\n#if !defined (OPENEXR_IMF_HAVE_LARGE_STACK)\nvoid\ncountFrequencies (Int64 *freq,\n\t\t  const unsigned short data[/*n*/],\n\t\t  int n)\n#else\nvoid\ncountFrequencies (Int64 freq[HUF_ENCSIZE],\n\t\t  const unsigned short data[/*n*/],\n\t\t  int n)\n#endif\n{\n    for (int i = 0; i < HUF_ENCSIZE; ++i)\n\tfreq[i] = 0;\n\n    for (int i = 0; i < n; ++i)\n\t++freq[data[i]];\n}\n\n\nvoid\nwriteUInt (char buf[4], unsigned int i)\n{\n    unsigned char *b = (unsigned char *) buf;\n\n    b[0] = i;\n    b[1] = i >> 8;\n    b[2] = i >> 16;\n    b[3] = i >> 24;\n}\n\n\nunsigned int\nreadUInt (const char buf[4])\n{\n    const unsigned char *b = (const unsigned char *) buf;\n\n    return ( b[0]        & 0x000000ff) |\n\t   ((b[1] <<  8) & 0x0000ff00) |\n\t   ((b[2] << 16) & 0x00ff0000) |\n\t   ((b[3] << 24) & 0xff000000);\n}\n\n} // namespace\n\n\n//\n// EXTERNAL INTERFACE\n//\n\n\nint\nhufCompress (const unsigned short raw[],\n\t     int nRaw,\n\t     char compressed[])\n{\n    if (nRaw == 0)\n\treturn 0;\n\n    AutoArray <Int64, HUF_ENCSIZE> freq;\n\n    countFrequencies (freq, raw, nRaw);\n\n    int im = 0;\n    int iM = 0;\n    hufBuildEncTable (freq, &im, &iM);\n\n    char *tableStart = compressed + 20;\n    char *tableEnd   = tableStart;\n    hufPackEncTable (freq, im, iM, &tableEnd);\n    int tableLength = tableEnd - tableStart;\n\n    char *dataStart = tableEnd;\n    int nBits = hufEncode (freq, raw, nRaw, iM, dataStart);\n    int dataLength = (nBits + 7) / 8;\n\n    writeUInt (compressed,      im);\n    writeUInt (compressed +  4, iM);\n    writeUInt (compressed +  8, tableLength);\n    writeUInt (compressed + 12, nBits);\n    writeUInt (compressed + 16, 0);\t// room for future extensions\n\n    return dataStart + dataLength - compressed;\n}\n\n\nvoid\nhufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    //\n    // need at least 20 bytes for header\n    //\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\n\treturn;\n    }\n\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    // int tableLength = readUInt (compressed + 8);\n    int nBits = readUInt (compressed + 12);\n\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n\n    const char *ptr = compressed + 20;\n\n    uint64_t nBytes = (static_cast<uint64_t>(nBits)+7) / 8 ;\n\n    if ( ptr + nBytes > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n\n    // \n    // Fast decoder needs at least 2x64-bits of compressed data, and\n    // needs to be run-able on this platform. Otherwise, fall back\n    // to the original decoder\n    //\n\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n\n        hufClearDecTable (hdec);\n\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n\n        hufFreeDecTable (hdec);\n    }\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n", "///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002-2012, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n#ifdef NDEBUG\n#    undef NDEBUG\n#endif\n\n#include <ImfHuf.h>\n#include \"ImathRandom.h\"\n#include <ImfArray.h>\n#include <iostream>\n#include <exception>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\nusing namespace OPENEXR_IMF_NAMESPACE;\nusing namespace std;\n\n\nnamespace {\n\nvoid\nfill1 (unsigned short data[/*n*/], int n, float bias, IMATH_NAMESPACE::Rand48 & rand48)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = (unsigned short)\n\t\t  (pow (rand48.nextf(), double(bias)) * (USHRT_MAX + 1));\n}\n\n\nvoid\nfill2 (unsigned short data[/*n*/], int n, int m, IMATH_NAMESPACE::Rand48 & rand48)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = 0;\n\n    for (int i = 0; i < m; ++i)\n\tdata[rand48.nexti() % n] = (unsigned short) (rand48.nextf() * (USHRT_MAX + 1));\n}\n\n\nvoid\nfill3 (unsigned short data[/*n*/], int n, int m)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = m;\n}\n\n\nvoid\nfill4 (unsigned short data[/*n*/], int n)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = i & USHRT_MAX;\n}\n\n\nvoid\nfill5 (unsigned short data[/*n*/], int n)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = 0;\n\n    int j = 0, k = 0;\n\n    for (int i = 0; i < n; ++i)\n    {\n\tdata[i] = j;\n\tj = j + k;\n\tk = k + 1;\n\n\tif (j > USHRT_MAX)\n\t    break;\n    }\n}\n\n\nvoid\ncompressUncompress (const unsigned short raw[], int n)\n{\n    Array <char> compressed (3 * n + 4 * 65536);\n    Array <unsigned short> uncompressed (n);\n\n    cout << \"compressing \" << flush;\n\n    int nCompressed = hufCompress (raw, n, compressed);\n\n    cout << \"uncompressing \" << flush;\n\n    hufUncompress (compressed, nCompressed, uncompressed, n);\n\n    cout << \"comparing: \" << flush;\n\n    for (int i = 0; i < n; ++i)\n\tassert (uncompressed[i] == raw[i]);\n\n    cout << sizeof (raw[0]) * n << \" bytes, compressed \" <<\n\t    nCompressed  << \" bytes\" << endl;\n}\n\nvoid\ncompressUncompressSubset(const unsigned short raw[], int n)\n{\n    // Test various subsets of the data set\n\n    Array <char> compressed (3 * n + 4 * 65536);\n    Array <unsigned short> uncompressed (n);\n\n    int maxOffset = 16;\n    if (n <= maxOffset) {\n        maxOffset = n-1;\n    }\n\n    for (int offset=1; offset<maxOffset; ++offset) {\n\n        int maxLength = n - offset;\n        int minLength = maxLength - 16;\n        if (minLength < 1) minLength = 1;\n\n        for (int length=minLength; length<=maxLength; ++length) {\n            cout << \"compressing \" << flush;\n\n            int nCompressed = hufCompress (raw + offset, length, compressed + offset);\n\n            cout << \"uncompressing \" << flush;\n\n            hufUncompress (compressed + offset, nCompressed, uncompressed + offset, length);\n\n            for (int i = 0; i < length; ++i)\n                assert (uncompressed[offset+i] == raw[offset+i]);\n\n            cout << sizeof (raw[0]) * length << \" bytes, compressed \" << nCompressed  << \" bytes \";\n            cout << \"(+\" << offset << \",-\" << n-offset-length << \")\" << endl;\n        }\n    }\n}\n\n\n\n//\n//  Check the hash is 'dekHash'.\n//  This check is intended to test for regressions\n//  in the hufCompress() result or difference results across OSes.\n// \n// The platform agnostic DEK hash of the huf compressed data for\n// the set of numbers generated by fill4() and fill5().\n// This DEK hash is determined from an aprior initial run of this\n// test noting its value from the assert message compressVerify().\n// \n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE 2013380646U\n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL4_N 213880353U\n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL5_N 2492982090U\n\nvoid\ncompressVerify (const unsigned short raw[], \n                int n,\n                const unsigned int dekHash)\n{\n    Array <char> compressed (3 * n + 4 * 65536);\n\n    int nCompressed = hufCompress (raw, n, compressed);\n    \n    //\n    // This hash algorithm proposed by Donald E. Knuth in \n    // The Art Of Computer Programming Volume 3,\n    // under the topic of sorting and search chapter 6.4. \n    //\n    unsigned int compressedHash = nCompressed;\n    const unsigned char* cptr = reinterpret_cast<const unsigned char*>( (const char*) compressed);\n    for (int i = 0; i < nCompressed; ++i)\n    {\n        compressedHash = \n            ((compressedHash << 5) ^ (compressedHash >> 27)) ^ (*cptr++);\n    }\n\n    cout << \"verifying compressed checksum hash = \" \n        << compressedHash << std::endl;\n\n    if (compressedHash != dekHash)\n    {\n       cout << \"hash verification failed. Got \" << compressedHash << \" expected \" << dekHash << std::endl;\n       const unsigned char* cptr = reinterpret_cast<const unsigned char*>( (const char*) compressed);\n       for(int i = 0 ; i < nCompressed ; ++i )\n       {\n           cout << std::hex << (0xFF & (int) (*cptr++));\n           if ( (i & 0xF) ==0 )\n           {\n              cout << '\\n';\n           }\n           else\n           {\n              cout << ' ';\n           }\n       }\n       cout << \"\\n\";\n    }\n\n    assert (compressedHash == dekHash);\n}\n\n\n} // namespace\n\n\nvoid\ntestHuf (const std::string&)\n{\n    try\n    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n\tconst int N = 1000000;\n\tArray <unsigned short> raw (N);\n\n\tfill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill2 (raw, N, 1, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill3 (raw, N, 0);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX - 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, USHRT_MAX + 1);\n        compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\tcompressUncompress (raw, USHRT_MAX + 1);\n\tcompressUncompressSubset (raw, USHRT_MAX + 1);\n\tfill4 (raw, N);\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, 0);\n\tcompressUncompress (raw, 0);\t// test small input data sets\n\tfill4 (raw, 1);\n\tcompressUncompress (raw, 1);\n\tfill4 (raw, 2);\n\tcompressUncompress (raw, 2);\n\tfill4 (raw, 3);\n\tcompressUncompress (raw, 3);\n\n\tfill5 (raw, N);\t\t\t// test run-length coding of code table\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {\n\tcerr << \"ERROR -- caught exception: \" << e.what() << endl;\n\tassert (false);\n    }\n}\n"], "fixing_code": ["///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n\n\n\n//-----------------------------------------------------------------------------\n//\n//\t16-bit Huffman compression and decompression.\n//\n//\tThe source code in this file is derived from the 8-bit\n//\tHuffman compression and decompression routines written\n//\tby Christian Rouet for his PIZ image file format.\n//\n//-----------------------------------------------------------------------------\n\n#include <ImfHuf.h>\n#include <ImfInt64.h>\n#include \"ImfAutoArray.h\"\n#include \"ImfFastHuf.h\"\n#include \"Iex.h\"\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n\n\nusing namespace std;\nusing namespace IEX_NAMESPACE;\n#include \"ImfNamespace.h\"\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_ENTER\n\nnamespace {\n\n\nconst int HUF_ENCBITS = 16;\t\t\t// literal (value) bit length\nconst int HUF_DECBITS = 14;\t\t\t// decoding bit size (>= 8)\n\nconst int HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\t// encoding table size\nconst int HUF_DECSIZE =  1 << HUF_DECBITS;\t// decoding table size\nconst int HUF_DECMASK = HUF_DECSIZE - 1;\n\n\nstruct HufDec\n{\t\t\t\t// short code\t\tlong code\n\t\t\t\t//-------------------------------\n    int\t\tlen:8;\t\t// code length\t\t0\t \n    int\t\tlit:24;\t\t// lit\t\t\tp size\t \n    int\t*\tp;\t\t// 0\t\t\tlits\t \n};\n\n\nvoid\ninvalidNBits ()\n{\n    throw InputExc (\"Error in header for Huffman-encoded data \"\n\t\t    \"(invalid number of bits).\");\n}\n\n\nvoid\ntooMuchData ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(decoded data are longer than expected).\");\n}\n\n\nvoid\nnotEnoughData ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(decoded data are shorter than expected).\");\n}\n\n\nvoid\ninvalidCode ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(invalid code).\");\n}\n\n\nvoid\ninvalidTableSize ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(invalid code table size).\");\n}\n\n\nvoid\nunexpectedEndOfTable ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(unexpected end of code table data).\");\n}\n\n\nvoid\ntableTooLong ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(code table is longer than expected).\");\n}\n\n\nvoid\ninvalidTableEntry ()\n{\n    throw InputExc (\"Error in Huffman-encoded data \"\n\t\t    \"(invalid code table entry).\");\n}\n\n\ninline Int64\nhufLength (Int64 code)\n{\n    return code & 63;\n}\n\n\ninline Int64\nhufCode (Int64 code)\n{\n    return code >> 6;\n}\n\n\ninline void\noutputBits (int nBits, Int64 bits, Int64 &c, int &lc, char *&out)\n{\n    c <<= nBits;\n    lc += nBits;\n\n    c |= bits;\n\n    while (lc >= 8)\n\t*out++ = (c >> (lc -= 8));\n}\n\n\ninline Int64\ngetBits (int nBits, Int64 &c, int &lc, const char *&in)\n{\n    while (lc < nBits)\n    {\n\tc = (c << 8) | *(unsigned char *)(in++);\n\tlc += 8;\n    }\n\n    lc -= nBits;\n    return (c >> lc) & ((1 << nBits) - 1);\n}\n\n\n//\n// ENCODING TABLE BUILDING & (UN)PACKING\n//\n\n//\n// Build a \"canonical\" Huffman code table:\n//\t- for each (uncompressed) symbol, hcode contains the length\n//\t  of the corresponding code (in the compressed data)\n//\t- canonical codes are computed and stored in hcode\n//\t- the rules for constructing canonical codes are as follows:\n//\t  * shorter codes (if filled with zeroes to the right)\n//\t    have a numerically higher value than longer codes\n//\t  * for codes with the same length, numerical values\n//\t    increase with numerical symbol values\n//\t- because the canonical code table can be constructed from\n//\t  symbol lengths alone, the code table can be transmitted\n//\t  without sending the actual code values\n//\t- see http://www.compressconsult.com/huffman/\n//\n\n#if !defined (OPENEXR_IMF_HAVE_LARGE_STACK)\nvoid\nhufCanonicalCodeTable (Int64 *hcode)\n#else\nvoid\nhufCanonicalCodeTable (Int64 hcode[HUF_ENCSIZE])\n#endif\n{\n    Int64 n[59];\n\n    //\n    // For each i from 0 through 58, count the\n    // number of different codes of length i, and\n    // store the count in n[i].\n    //\n\n    for (int i = 0; i <= 58; ++i)\n\tn[i] = 0;\n\n    for (int i = 0; i < HUF_ENCSIZE; ++i)\n\tn[hcode[i]] += 1;\n\n    //\n    // For each i from 58 through 1, compute the\n    // numerically lowest code with length i, and\n    // store that code in n[i].\n    //\n\n    Int64 c = 0;\n\n    for (int i = 58; i > 0; --i)\n    {\n\tInt64 nc = ((c + n[i]) >> 1);\n\tn[i] = c;\n\tc = nc;\n    }\n\n    //\n    // hcode[i] contains the length, l, of the\n    // code for symbol i.  Assign the next available\n    // code of length l to the symbol and store both\n    // l and the code in hcode[i].\n    //\n\n    for (int i = 0; i < HUF_ENCSIZE; ++i)\n    {\n\tint l = hcode[i];\n\n\tif (l > 0)\n\t    hcode[i] = l | (n[l]++ << 6);\n    }\n}\n\n\n//\n// Compute Huffman codes (based on frq input) and store them in frq:\n//\t- code structure is : [63:lsb - 6:msb] | [5-0: bit length];\n//\t- max code length is 58 bits;\n//\t- codes outside the range [im-iM] have a null length (unused values);\n//\t- original frequencies are destroyed;\n//\t- encoding tables are used by hufEncode() and hufBuildDecTable();\n//\n// NB: The following code \"(*a == *b) && (a > b))\" was added to ensure\n//     elements in the heap with the same value are sorted by index.\n//     This is to ensure, the STL make_heap()/pop_heap()/push_heap() methods\n//     produced a resultant sorted heap that is identical across OSes.\n//\n\n\nstruct FHeapCompare\n{\n    bool operator () (Int64 *a, Int64 *b)\n    {\n        return ((*a > *b) || ((*a == *b) && (a > b)));\n    }\n};\n\n\nvoid\nhufBuildEncTable\n    (Int64*\tfrq,\t// io: input frequencies [HUF_ENCSIZE], output table\n     int*\tim,\t//  o: min frq index\n     int*\tiM)\t//  o: max frq index\n{\n    //\n    // This function assumes that when it is called, array frq\n    // indicates the frequency of all possible symbols in the data\n    // that are to be Huffman-encoded.  (frq[i] contains the number\n    // of occurrences of symbol i in the data.)\n    //\n    // The loop below does three things:\n    //\n    // 1) Finds the minimum and maximum indices that point\n    //    to non-zero entries in frq:\n    //\n    //     frq[im] != 0, and frq[i] == 0 for all i < im\n    //     frq[iM] != 0, and frq[i] == 0 for all i > iM\n    //\n    // 2) Fills array fHeap with pointers to all non-zero\n    //    entries in frq.\n    //\n    // 3) Initializes array hlink such that hlink[i] == i\n    //    for all array entries.\n    //\n\n    AutoArray <int, HUF_ENCSIZE> hlink;\n    AutoArray <Int64 *, HUF_ENCSIZE> fHeap;\n\n    *im = 0;\n\n    while (!frq[*im])\n\t(*im)++;\n\n    int nf = 0;\n\n    for (int i = *im; i < HUF_ENCSIZE; i++)\n    {\n\thlink[i] = i;\n\n\tif (frq[i])\n\t{\n\t    fHeap[nf] = &frq[i];\n\t    nf++;\n\t    *iM = i;\n\t}\n    }\n\n    //\n    // Add a pseudo-symbol, with a frequency count of 1, to frq;\n    // adjust the fHeap and hlink array accordingly.  Function\n    // hufEncode() uses the pseudo-symbol for run-length encoding.\n    //\n\n    (*iM)++;\n    frq[*iM] = 1;\n    fHeap[nf] = &frq[*iM];\n    nf++;\n\n    //\n    // Build an array, scode, such that scode[i] contains the number\n    // of bits assigned to symbol i.  Conceptually this is done by\n    // constructing a tree whose leaves are the symbols with non-zero\n    // frequency:\n    //\n    //     Make a heap that contains all symbols with a non-zero frequency,\n    //     with the least frequent symbol on top.\n    //\n    //     Repeat until only one symbol is left on the heap:\n    //\n    //         Take the two least frequent symbols off the top of the heap.\n    //         Create a new node that has first two nodes as children, and\n    //         whose frequency is the sum of the frequencies of the first\n    //         two nodes.  Put the new node back into the heap.\n    //\n    // The last node left on the heap is the root of the tree.  For each\n    // leaf node, the distance between the root and the leaf is the length\n    // of the code for the corresponding symbol.\n    //\n    // The loop below doesn't actually build the tree; instead we compute\n    // the distances of the leaves from the root on the fly.  When a new\n    // node is added to the heap, then that node's descendants are linked\n    // into a single linear list that starts at the new node, and the code\n    // lengths of the descendants (that is, their distance from the root\n    // of the tree) are incremented by one.\n    //\n\n    make_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\n    AutoArray <Int64, HUF_ENCSIZE> scode;\n    memset (scode, 0, sizeof (Int64) * HUF_ENCSIZE);\n\n    while (nf > 1)\n    {\n\t//\n\t// Find the indices, mm and m, of the two smallest non-zero frq\n\t// values in fHeap, add the smallest frq to the second-smallest\n\t// frq, and remove the smallest frq value from fHeap.\n\t//\n\n\tint mm = fHeap[0] - frq;\n\tpop_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\t--nf;\n\n\tint m = fHeap[0] - frq;\n\tpop_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\n\tfrq[m ] += frq[mm];\n\tpush_heap (&fHeap[0], &fHeap[nf], FHeapCompare());\n\n\t//\n\t// The entries in scode are linked into lists with the\n\t// entries in hlink serving as \"next\" pointers and with\n\t// the end of a list marked by hlink[j] == j.\n\t//\n\t// Traverse the lists that start at scode[m] and scode[mm].\n\t// For each element visited, increment the length of the\n\t// corresponding code by one bit. (If we visit scode[j]\n\t// during the traversal, then the code for symbol j becomes\n\t// one bit longer.)\n\t//\n\t// Merge the lists that start at scode[m] and scode[mm]\n\t// into a single list that starts at scode[m].\n\t//\n\t\n\t//\n\t// Add a bit to all codes in the first list.\n\t//\n\n\tfor (int j = m; true; j = hlink[j])\n\t{\n\t    scode[j]++;\n\n\t    assert (scode[j] <= 58);\n\n\t    if (hlink[j] == j)\n\t    {\n\t\t//\n\t\t// Merge the two lists.\n\t\t//\n\n\t\thlink[j] = mm;\n\t\tbreak;\n\t    }\n\t}\n\n\t//\n\t// Add a bit to all codes in the second list\n\t//\n\n\tfor (int j = mm; true; j = hlink[j])\n\t{\n\t    scode[j]++;\n\n\t    assert (scode[j] <= 58);\n\n\t    if (hlink[j] == j)\n\t\tbreak;\n\t}\n    }\n\n    //\n    // Build a canonical Huffman code table, replacing the code\n    // lengths in scode with (code, code length) pairs.  Copy the\n    // code table from scode into frq.\n    //\n\n    hufCanonicalCodeTable (scode);\n    memcpy (frq, scode, sizeof (Int64) * HUF_ENCSIZE);\n}\n\n\n//\n// Pack an encoding table:\n//\t- only code lengths, not actual codes, are stored\n//\t- runs of zeroes are compressed as follows:\n//\n//\t  unpacked\t\tpacked\n//\t  --------------------------------\n//\t  1 zero\t\t0\t(6 bits)\n//\t  2 zeroes\t\t59\n//\t  3 zeroes\t\t60\n//\t  4 zeroes\t\t61\n//\t  5 zeroes\t\t62\n//\t  n zeroes (6 or more)\t63 n-6\t(6 + 8 bits)\n//\n\nconst int SHORT_ZEROCODE_RUN = 59;\nconst int LONG_ZEROCODE_RUN  = 63;\nconst int SHORTEST_LONG_RUN  = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\nconst int LONGEST_LONG_RUN   = 255 + SHORTEST_LONG_RUN;\n\n\nvoid\nhufPackEncTable\n    (const Int64*\thcode,\t\t// i : encoding table [HUF_ENCSIZE]\n     int\t\tim,\t\t// i : min hcode index\n     int\t\tiM,\t\t// i : max hcode index\n     char**\t\tpcode)\t\t//  o: ptr to packed table (updated)\n{\n    char *p = *pcode;\n    Int64 c = 0;\n    int lc = 0;\n\n    for (; im <= iM; im++)\n    {\n\tint l = hufLength (hcode[im]);\n\n\tif (l == 0)\n\t{\n\t    int zerun = 1;\n\n\t    while ((im < iM) && (zerun < LONGEST_LONG_RUN))\n\t    {\n\t\tif (hufLength (hcode[im+1]) > 0 )\t \n\t\t    break;\n\t\tim++;\n\t\tzerun++;\n\t    }\n\n\t    if (zerun >= 2)\n\t    {\n\t\tif (zerun >= SHORTEST_LONG_RUN)\n\t\t{\n\t\t    outputBits (6, LONG_ZEROCODE_RUN, c, lc, p);\n\t\t    outputBits (8, zerun - SHORTEST_LONG_RUN, c, lc, p);\n\t\t}\n\t\telse\n\t\t{\n\t\t    outputBits (6, SHORT_ZEROCODE_RUN + zerun - 2, c, lc, p);\n\t\t}\n\t\tcontinue;\n\t    }\n\t}\n\n\toutputBits (6, l, c, lc, p);\n    }\n\n    if (lc > 0)\n\t*p++ = (unsigned char) (c << (8 - lc));\n\n    *pcode = p;\n}\n\n\n//\n// Unpack an encoding table packed by hufPackEncTable():\n//\n\nvoid\nhufUnpackEncTable\n    (const char**\tpcode,\t\t// io: ptr to packed table (updated)\n     int\t\tni,\t\t// i : input size (in bytes)\n     int\t\tim,\t\t// i : min hcode index\n     int\t\tiM,\t\t// i : max hcode index\n     Int64*\t\thcode)\t\t//  o: encoding table [HUF_ENCSIZE]\n{\n    memset (hcode, 0, sizeof (Int64) * HUF_ENCSIZE);\n\n    const char *p = *pcode;\n    Int64 c = 0;\n    int lc = 0;\n\n    for (; im <= iM; im++)\n    {\n\tif (p - *pcode > ni)\n\t    unexpectedEndOfTable();\n\n\tInt64 l = hcode[im] = getBits (6, c, lc, p); // code length\n\n\tif (l == (Int64) LONG_ZEROCODE_RUN)\n\t{\n\t    if (p - *pcode > ni)\n\t\tunexpectedEndOfTable();\n\n\t    int zerun = getBits (8, c, lc, p) + SHORTEST_LONG_RUN;\n\n\t    if (im + zerun > iM + 1)\n\t\ttableTooLong();\n\n\t    while (zerun--)\n\t\thcode[im++] = 0;\n\n\t    im--;\n\t}\n\telse if (l >= (Int64) SHORT_ZEROCODE_RUN)\n\t{\n\t    int zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t    if (im + zerun > iM + 1)\n\t\ttableTooLong();\n\n\t    while (zerun--)\n\t\thcode[im++] = 0;\n\n\t    im--;\n\t}\n    }\n\n    *pcode = const_cast<char *>(p);\n\n    hufCanonicalCodeTable (hcode);\n}\n\n\n//\n// DECODING TABLE BUILDING\n//\n\n//\n// Clear a newly allocated decoding table so that it contains only zeroes.\n//\n\nvoid\nhufClearDecTable\n    (HufDec *\t\thdecod)\t\t// io: (allocated by caller)\n     \t\t\t\t\t//     decoding table [HUF_DECSIZE]\n{\n    memset (hdecod, 0, sizeof (HufDec) * HUF_DECSIZE);\n}\n\n\n//\n// Build a decoding hash table based on the encoding table hcode:\n//\t- short codes (<= HUF_DECBITS) are resolved with a single table access;\n//\t- long code entry allocations are not optimized, because long codes are\n//\t  unfrequent;\n//\t- decoding tables are used by hufDecode();\n//\n\nvoid\nhufBuildDecTable\n    (const Int64*\thcode,\t\t// i : encoding table\n     int\t\tim,\t\t// i : min index in hcode\n     int\t\tiM,\t\t// i : max index in hcode\n     HufDec *\t\thdecod)\t\t//  o: (allocated by caller)\n     \t\t\t\t\t//     decoding table [HUF_DECSIZE]\n{\n    //\n    // Init hashtable & loop on all codes.\n    // Assumes that hufClearDecTable(hdecod) has already been called.\n    //\n\n    for (; im <= iM; im++)\n    {\n\tInt64 c = hufCode (hcode[im]);\n\tint l = hufLength (hcode[im]);\n\n\tif (c >> l)\n\t{\n\t    //\n\t    // Error: c is supposed to be an l-bit code,\n\t    // but c contains a value that is greater\n\t    // than the largest l-bit number.\n\t    //\n\n\t    invalidTableEntry();\n\t}\n\n\tif (l > HUF_DECBITS)\n\t{\n\t    //\n\t    // Long code: add a secondary entry\n\t    //\n\n\t    HufDec *pl = hdecod + (c >> (l - HUF_DECBITS));\n\n\t    if (pl->len)\n\t    {\n\t\t//\n\t\t// Error: a short code has already\n\t\t// been stored in table entry *pl.\n\t\t//\n\n\t\tinvalidTableEntry();\n\t    }\n\n\t    pl->lit++;\n\n\t    if (pl->p)\n\t    {\n\t\tint *p = pl->p;\n\t\tpl->p = new int [pl->lit];\n\n\t\tfor (int i = 0; i < pl->lit - 1; ++i)\n\t\t    pl->p[i] = p[i];\n\n\t\tdelete [] p;\n\t    }\n\t    else\n\t    {\n\t\tpl->p = new int [1];\n\t    }\n\n\t    pl->p[pl->lit - 1]= im;\n\t}\n\telse if (l)\n\t{\n\t    //\n\t    // Short code: init all primary entries\n\t    //\n\n\t    HufDec *pl = hdecod + (c << (HUF_DECBITS - l));\n\n\t    for (Int64 i = 1 << (HUF_DECBITS - l); i > 0; i--, pl++)\n\t    {\n\t\tif (pl->len || pl->p)\n\t\t{\n\t\t    //\n\t\t    // Error: a short code or a long code has\n\t\t    // already been stored in table entry *pl.\n\t\t    //\n\n\t\t    invalidTableEntry();\n\t\t}\n\n\t\tpl->len = l;\n\t\tpl->lit = im;\n\t    }\n\t}\n    }\n}\n\n\n//\n// Free the long code entries of a decoding table built by hufBuildDecTable()\n//\n\nvoid\nhufFreeDecTable (HufDec *hdecod)\t// io: Decoding table\n{\n    for (int i = 0; i < HUF_DECSIZE; i++)\n    {\n\tif (hdecod[i].p)\n\t{\n\t    delete [] hdecod[i].p;\n\t    hdecod[i].p = 0;\n\t}\n    }\n}\n\n\n//\n// ENCODING\n//\n\ninline void\noutputCode (Int64 code, Int64 &c, int &lc, char *&out)\n{\n    outputBits (hufLength (code), hufCode (code), c, lc, out);\n}\n\n\ninline void\nsendCode (Int64 sCode, int runCount, Int64 runCode,\n\t  Int64 &c, int &lc, char *&out)\n{\n    //\n    // Output a run of runCount instances of the symbol sCount.\n    // Output the symbols explicitly, or if that is shorter, output\n    // the sCode symbol once followed by a runCode symbol and runCount\n    // expressed as an 8-bit number.\n    //\n    \n    if (hufLength (sCode) + hufLength (runCode) + 8 <\n        hufLength (sCode) * runCount)\n    {\n\toutputCode (sCode, c, lc, out);\n\toutputCode (runCode, c, lc, out);\n\toutputBits (8, runCount, c, lc, out);\n    }\n    else\n    {\n\twhile (runCount-- >= 0)\n\t    outputCode (sCode, c, lc, out);\n    }\n}\n\n\n//\n// Encode (compress) ni values based on the Huffman encoding table hcode:\n//\n\nint\nhufEncode\t\t\t\t// return: output size (in bits)\n    (const Int64*  \t    hcode,\t// i : encoding table\n     const unsigned short*  in,\t\t// i : uncompressed input buffer\n     const int     \t    ni,\t\t// i : input buffer size (in bytes)\n     int           \t    rlc,\t// i : rl code\n     char*         \t    out)\t//  o: compressed output buffer\n{\n    char *outStart = out;\n    Int64 c = 0;\t// bits not yet written to out\n    int lc = 0;\t\t// number of valid bits in c (LSB)\n    int s = in[0];\n    int cs = 0;\n\n    //\n    // Loop on input values\n    //\n\n    for (int i = 1; i < ni; i++)\n    {\n\t//\n\t// Count same values or send code\n\t//\n\n\tif (s == in[i] && cs < 255)\n\t{\n\t    cs++;\n\t}\n\telse\n\t{\n\t    sendCode (hcode[s], cs, hcode[rlc], c, lc, out);\n\t    cs=0;\n\t}\n\n\ts = in[i];\n    }\n\n    //\n    // Send remaining code\n    //\n\n    sendCode (hcode[s], cs, hcode[rlc], c, lc, out);\n\n    if (lc)\n\t*out = (c << (8 - lc)) & 0xff;\n\n    return (out - outStart) * 8 + lc;\n}\n\n\n//\n// DECODING\n//\n\n//\n// In order to force the compiler to inline them,\n// getChar() and getCode() are implemented as macros\n// instead of \"inline\" functions.\n//\n\n#define getChar(c, lc, in)\t\t\t\\\n{\t\t\t\t\t\t\\\n    c = (c << 8) | *(unsigned char *)(in++);\t\\\n    lc += 8;\t\t\t\t\t\\\n}\n\n\n#define getCode(po, rlc, c, lc, in, out, ob, oe)\\\n{\t\t\t\t\t\t\\\n    if (po == rlc)\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n\tif (lc < 8)\t\t\t\t\\\n\t    getChar(c, lc, in);\t\t\t\\\n\t\t\t\t\t\t\\\n\tlc -= 8;\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tunsigned char cs = (c >> lc);\t\t\\\n\t\t\t\t\t\t\\\n\tif (out + cs > oe)\t\t\t\\\n\t    tooMuchData();\t\t\t\\\n\telse if (out - 1 < ob)\t\t\t\\\n\t    notEnoughData();\t\t\t\\\n\t\t\t\t\t\t\\\n\tunsigned short s = out[-1];\t\t\\\n\t\t\t\t\t\t\\\n\twhile (cs-- > 0)\t\t\t\\\n\t    *out++ = s;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n    else if (out < oe)\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n\t*out++ = po;\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n    {\t\t\t\t\t\t\\\n\ttooMuchData();\t\t\t\t\\\n    }\t\t\t\t\t\t\\\n}\n\n\n//\n// Decode (uncompress) ni bits based on encoding & decoding tables:\n//\n\nvoid\nhufDecode\n    (const Int64 * \thcode,\t// i : encoding table\n     const HufDec * \thdecod,\t// i : decoding table\n     const char* \tin,\t// i : compressed input buffer\n     int\t\tni,\t// i : input size (in bits)\n     int\t\trlc,\t// i : run-length code\n     int\t\tno,\t// i : expected output size (in bytes)\n     unsigned short*\tout)\t//  o: uncompressed output buffer\n{\n    Int64 c = 0;\n    int lc = 0;\n    unsigned short * outb = out;\n    unsigned short * oe = out + no;\n    const char * ie = in + (ni + 7) / 8; // input byte size\n\n    //\n    // Loop on input bytes\n    //\n\n    while (in < ie)\n    {\n\tgetChar (c, lc, in);\n\n\t//\n\t// Access decoding table\n\t//\n\n\twhile (lc >= HUF_DECBITS)\n\t{\n\t    const HufDec pl = hdecod[(c >> (lc-HUF_DECBITS)) & HUF_DECMASK];\n\n\t    if (pl.len)\n\t    {\n\t\t//\n\t\t// Get short code\n\t\t//\n\n\t\tlc -= pl.len;\n\n\t\tif ( lc < 0 )\n\t\t{\n\t\t\tinvalidCode(); // code length too long\n\t\t}\n\t\tgetCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t    }\n\t    else\n\t    {\n\t\tif (!pl.p)\n\t\t    invalidCode(); // wrong code\n\n\t\t//\n\t\t// Search long code\n\t\t//\n\n\t\tint j;\n\n\t\tfor (j = 0; j < pl.lit; j++)\n\t\t{\n\t\t    int\tl = hufLength (hcode[pl.p[j]]);\n\n\t\t    while (lc < l && in < ie)\t// get more bits\n\t\t\tgetChar (c, lc, in);\n\n\t\t    if (lc >= l)\n\t\t    {\n\t\t\tif (hufCode (hcode[pl.p[j]]) ==\n\t\t\t\t((c >> (lc - l)) & ((Int64(1) << l) - 1)))\n\t\t\t{\n\t\t\t    //\n\t\t\t    // Found : get long code\n\t\t\t    //\n\n\t\t\t    lc -= l;\n\t\t\t    getCode (pl.p[j], rlc, c, lc, in, out, outb, oe);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\tif (j == pl.lit)\n\t\t    invalidCode(); // Not found\n\t    }\n\t}\n    }\n\n    //\n    // Get remaining (short) codes\n    //\n\n    int i = (8 - ni) & 7;\n    c >>= i;\n    lc -= i;\n\n    while (lc > 0)\n    {\n\tconst HufDec pl = hdecod[(c << (HUF_DECBITS - lc)) & HUF_DECMASK];\n\n\tif (pl.len)\n\t{\n\t    lc -= pl.len;\n            if ( lc < 0 )\n            {\n   \t        invalidCode(); // code length too long\n            }\n\t    getCode (pl.lit, rlc, c, lc, in, out, outb, oe);\n\t}\n\telse\n\t{\n\t    invalidCode(); // wrong (long) code\n\t}\n    }\n\n    if (out - outb != no)\n\tnotEnoughData ();\n}\n\n\n#if !defined (OPENEXR_IMF_HAVE_LARGE_STACK)\nvoid\ncountFrequencies (Int64 *freq,\n\t\t  const unsigned short data[/*n*/],\n\t\t  int n)\n#else\nvoid\ncountFrequencies (Int64 freq[HUF_ENCSIZE],\n\t\t  const unsigned short data[/*n*/],\n\t\t  int n)\n#endif\n{\n    for (int i = 0; i < HUF_ENCSIZE; ++i)\n\tfreq[i] = 0;\n\n    for (int i = 0; i < n; ++i)\n\t++freq[data[i]];\n}\n\n\nvoid\nwriteUInt (char buf[4], unsigned int i)\n{\n    unsigned char *b = (unsigned char *) buf;\n\n    b[0] = i;\n    b[1] = i >> 8;\n    b[2] = i >> 16;\n    b[3] = i >> 24;\n}\n\n\nunsigned int\nreadUInt (const char buf[4])\n{\n    const unsigned char *b = (const unsigned char *) buf;\n\n    return ( b[0]        & 0x000000ff) |\n\t   ((b[1] <<  8) & 0x0000ff00) |\n\t   ((b[2] << 16) & 0x00ff0000) |\n\t   ((b[3] << 24) & 0xff000000);\n}\n\n} // namespace\n\n\n//\n// EXTERNAL INTERFACE\n//\n\n\nint\nhufCompress (const unsigned short raw[],\n\t     int nRaw,\n\t     char compressed[])\n{\n    if (nRaw == 0)\n\treturn 0;\n\n    AutoArray <Int64, HUF_ENCSIZE> freq;\n\n    countFrequencies (freq, raw, nRaw);\n\n    int im = 0;\n    int iM = 0;\n    hufBuildEncTable (freq, &im, &iM);\n\n    char *tableStart = compressed + 20;\n    char *tableEnd   = tableStart;\n    hufPackEncTable (freq, im, iM, &tableEnd);\n    int tableLength = tableEnd - tableStart;\n\n    char *dataStart = tableEnd;\n    int nBits = hufEncode (freq, raw, nRaw, iM, dataStart);\n    int dataLength = (nBits + 7) / 8;\n\n    writeUInt (compressed,      im);\n    writeUInt (compressed +  4, iM);\n    writeUInt (compressed +  8, tableLength);\n    writeUInt (compressed + 12, nBits);\n    writeUInt (compressed + 16, 0);\t// room for future extensions\n\n    return dataStart + dataLength - compressed;\n}\n\n\nvoid\nhufUncompress (const char compressed[],\n\t       int nCompressed,\n\t       unsigned short raw[],\n\t       int nRaw)\n{\n    //\n    // need at least 20 bytes for header\n    //\n    if (nCompressed < 20 )\n    {\n\tif (nRaw != 0)\n\t    notEnoughData();\n\n\treturn;\n    }\n\n    int im = readUInt (compressed);\n    int iM = readUInt (compressed + 4);\n    // int tableLength = readUInt (compressed + 8);\n    int nBits = readUInt (compressed + 12);\n\n    if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE)\n\tinvalidTableSize();\n\n    const char *ptr = compressed + 20;\n\n    uint64_t nBytes = (static_cast<uint64_t>(nBits)+7) / 8 ;\n\n    if ( ptr + nBytes > compressed+nCompressed)\n    {\n        notEnoughData();\n        return;\n    }\n\n    // \n    // Fast decoder needs at least 2x64-bits of compressed data, and\n    // needs to be run-able on this platform. Otherwise, fall back\n    // to the original decoder\n    //\n\n    if (FastHufDecoder::enabled() && nBits > 128)\n    {\n        FastHufDecoder fhd (ptr, nCompressed - (ptr - compressed), im, iM, iM);\n        fhd.decode ((unsigned char*)ptr, nBits, raw, nRaw);\n    }\n    else\n    {\n        AutoArray <Int64, HUF_ENCSIZE> freq;\n        AutoArray <HufDec, HUF_DECSIZE> hdec;\n\n        hufClearDecTable (hdec);\n\n        hufUnpackEncTable (&ptr,\n                           nCompressed - (ptr - compressed),\n                           im,\n                           iM,\n                           freq);\n\n        try\n        {\n            if (nBits > 8 * (nCompressed - (ptr - compressed)))\n                invalidNBits();\n\n            hufBuildDecTable (freq, im, iM, hdec);\n            hufDecode (freq, hdec, ptr, nBits, iM, nRaw, raw);\n        }\n        catch (...)\n        {\n            hufFreeDecTable (hdec);\n            throw;\n        }\n\n        hufFreeDecTable (hdec);\n    }\n}\n\n\nOPENEXR_IMF_INTERNAL_NAMESPACE_SOURCE_EXIT\n", "///////////////////////////////////////////////////////////////////////////\n//\n// Copyright (c) 2002-2012, Industrial Light & Magic, a division of Lucas\n// Digital Ltd. LLC\n// \n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n// *       Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// *       Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// *       Neither the name of Industrial Light & Magic nor the names of\n// its contributors may be used to endorse or promote products derived\n// from this software without specific prior written permission. \n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n///////////////////////////////////////////////////////////////////////////\n\n#ifdef NDEBUG\n#    undef NDEBUG\n#endif\n\n#include <ImfHuf.h>\n#include \"ImathRandom.h\"\n#include <ImfArray.h>\n#include <iostream>\n#include <exception>\n#include <limits.h>\n#include <math.h>\n#include <stdlib.h>\n#include <assert.h>\n\n\nusing namespace OPENEXR_IMF_NAMESPACE;\nusing namespace std;\n\n\nnamespace {\n\nvoid\nfill1 (unsigned short data[/*n*/], int n, float bias, IMATH_NAMESPACE::Rand48 & rand48)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = (unsigned short)\n\t\t  (pow (rand48.nextf(), double(bias)) * (USHRT_MAX + 1));\n}\n\n\nvoid\nfill2 (unsigned short data[/*n*/], int n, int m, IMATH_NAMESPACE::Rand48 & rand48)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = 0;\n\n    for (int i = 0; i < m; ++i)\n\tdata[rand48.nexti() % n] = (unsigned short) (rand48.nextf() * (USHRT_MAX + 1));\n}\n\n\nvoid\nfill3 (unsigned short data[/*n*/], int n, int m)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = m;\n}\n\n\nvoid\nfill4 (unsigned short data[/*n*/], int n)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = i & USHRT_MAX;\n}\n\n\nvoid\nfill5 (unsigned short data[/*n*/], int n)\n{\n    for (int i = 0; i < n; ++i)\n\tdata[i] = 0;\n\n    int j = 0, k = 0;\n\n    for (int i = 0; i < n; ++i)\n    {\n\tdata[i] = j;\n\tj = j + k;\n\tk = k + 1;\n\n\tif (j > USHRT_MAX)\n\t    break;\n    }\n}\n\n\nvoid\ncompressUncompress (const unsigned short raw[], int n)\n{\n    Array <char> compressed (3 * n + 4 * 65536);\n    Array <unsigned short> uncompressed (n);\n\n    cout << \"compressing \" << flush;\n\n    int nCompressed = hufCompress (raw, n, compressed);\n\n    cout << \"uncompressing \" << flush;\n\n    hufUncompress (compressed, nCompressed, uncompressed, n);\n\n    cout << \"comparing: \" << flush;\n\n    for (int i = 0; i < n; ++i)\n\tassert (uncompressed[i] == raw[i]);\n\n    cout << sizeof (raw[0]) * n << \" bytes, compressed \" <<\n\t    nCompressed  << \" bytes\" << endl;\n}\n\nvoid\ncompressUncompressSubset(const unsigned short raw[], int n)\n{\n    // Test various subsets of the data set\n\n    Array <char> compressed (3 * n + 4 * 65536);\n    Array <unsigned short> uncompressed (n);\n\n    int maxOffset = 16;\n    if (n <= maxOffset) {\n        maxOffset = n-1;\n    }\n\n    for (int offset=1; offset<maxOffset; ++offset) {\n\n        int maxLength = n - offset;\n        int minLength = maxLength - 16;\n        if (minLength < 1) minLength = 1;\n\n        for (int length=minLength; length<=maxLength; ++length) {\n            cout << \"compressing \" << flush;\n\n            int nCompressed = hufCompress (raw + offset, length, compressed + offset);\n\n            cout << \"uncompressing \" << flush;\n\n            hufUncompress (compressed + offset, nCompressed, uncompressed + offset, length);\n\n            for (int i = 0; i < length; ++i)\n                assert (uncompressed[offset+i] == raw[offset+i]);\n\n            cout << sizeof (raw[0]) * length << \" bytes, compressed \" << nCompressed  << \" bytes \";\n            cout << \"(+\" << offset << \",-\" << n-offset-length << \")\" << endl;\n        }\n    }\n}\n\n\n\n//\n//  Check the hash is 'dekHash'.\n//  This check is intended to test for regressions\n//  in the hufCompress() result or difference results across OSes.\n// \n// The platform agnostic DEK hash of the huf compressed data for\n// the set of numbers generated by fill4() and fill5().\n// This DEK hash is determined from an aprior initial run of this\n// test noting its value from the assert message compressVerify().\n// \n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE 2013380646U\n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL4_N 213880353U\n#define  HUF_COMPRESS_DEK_HASH_FOR_FILL5_N 2492982090U\n\nvoid\ncompressVerify (const unsigned short raw[], \n                int n,\n                const unsigned int dekHash)\n{\n    Array <char> compressed (3 * n + 4 * 65536);\n\n    int nCompressed = hufCompress (raw, n, compressed);\n    \n    //\n    // This hash algorithm proposed by Donald E. Knuth in \n    // The Art Of Computer Programming Volume 3,\n    // under the topic of sorting and search chapter 6.4. \n    //\n    unsigned int compressedHash = nCompressed;\n    const unsigned char* cptr = reinterpret_cast<const unsigned char*>( (const char*) compressed);\n    for (int i = 0; i < nCompressed; ++i)\n    {\n        compressedHash = \n            ((compressedHash << 5) ^ (compressedHash >> 27)) ^ (*cptr++);\n    }\n\n    cout << \"verifying compressed checksum hash = \" \n        << compressedHash << std::endl;\n\n    if (compressedHash != dekHash)\n    {\n       cout << \"hash verification failed. Got \" << compressedHash << \" expected \" << dekHash << std::endl;\n       const unsigned char* cptr = reinterpret_cast<const unsigned char*>( (const char*) compressed);\n       for(int i = 0 ; i < nCompressed ; ++i )\n       {\n           cout << std::hex << (0xFF & (int) (*cptr++));\n           if ( (i & 0xF) ==0 )\n           {\n              cout << '\\n';\n           }\n           else\n           {\n              cout << ' ';\n           }\n       }\n       cout << \"\\n\";\n    }\n\n    assert (compressedHash == dekHash);\n}\n\n\n} // namespace\n\n\nvoid\ntestHuf (const std::string&)\n{\n    try\n    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n        //\n        // FastHufDecoder is used for more than 128 bits, so first test with fewer than 128 bits,\n        // then test FastHufDecoder\n        //\n        for (int pass = 0 ; pass < 2 ; ++pass)\n        {\n\n            int N = pass==0 ? 12 : 1000000;\n            Array <unsigned short> raw (N);\n\n            fill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 10, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 100, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 1000, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill2 (raw, N, 1, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 10, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 100, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 1000, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill3 (raw, N, 0);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, 1);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, USHRT_MAX - 1);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, USHRT_MAX);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            if (pass==1)\n            {\n                fill4 (raw, USHRT_MAX + 1);\n                compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\n                compressUncompress (raw, USHRT_MAX + 1);\n                compressUncompressSubset (raw, USHRT_MAX + 1);\n                fill4 (raw, N);\n                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n            }\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill4 (raw, 0);\n            compressUncompress (raw, 0);\t// test small input data sets\n            fill4 (raw, 1);\n            compressUncompress (raw, 1);\n            fill4 (raw, 2);\n            compressUncompress (raw, 2);\n            fill4 (raw, 3);\n            compressUncompress (raw, 3);\n\n            fill5 (raw, N);\t\t\t// test run-length coding of code table\n            if (pass==1)\n            {\n                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n            }\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n        }\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {\n\tcerr << \"ERROR -- caught exception: \" << e.what() << endl;\n\tassert (false);\n    }\n}\n"], "filenames": ["OpenEXR/IlmImf/ImfHuf.cpp", "OpenEXR/IlmImfTest/testHuf.cpp"], "buggy_code_start_loc": [912, 248], "buggy_code_end_loc": [969, 312], "fixing_code_start_loc": [913, 248], "fixing_code_end_loc": [979, 328], "type": "CWE-190", "message": "A flaw was found in OpenEXR's hufDecode functionality. This flaw allows an attacker who can pass a crafted file to be processed by OpenEXR, to trigger an undefined right shift error. The highest threat from this vulnerability is to system availability.", "other": {"cve": {"id": "CVE-2021-20304", "sourceIdentifier": "secalert@redhat.com", "published": "2022-08-23T16:15:09.087", "lastModified": "2022-12-07T02:23:42.380", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in OpenEXR's hufDecode functionality. This flaw allows an attacker who can pass a crafted file to be processed by OpenEXR, to trigger an undefined right shift error. The highest threat from this vulnerability is to system availability."}, {"lang": "es", "value": "Se ha encontrado un fallo en la funcionalidad hufDecode de OpenEXR. Este fallo permite a un atacante que pueda pasar un archivo dise\u00f1ado para ser procesado por OpenEXR, desencadenar un error de desplazamiento a la derecha no definido. La mayor amenaza de esta vulnerabilidad es la disponibilidad del sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "secalert@redhat.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openexr:openexr:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.5.7", "matchCriteriaId": "5AA57D0D-80D4-442D-8686-698527811EA4"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-20304", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=26229", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1939157", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/commit/51a92d67f53c08230734e74564c807043cbfe41e", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/AcademySoftwareFoundation/openexr/pull/849", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-31", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/AcademySoftwareFoundation/openexr/commit/51a92d67f53c08230734e74564c807043cbfe41e"}}