{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%         AAA   TTTTT  TTTTT  RRRR   IIIII  BBBB   U   U  TTTTT  EEEEE        %\n%        A   A    T      T    R   R    I    B   B  U   U    T    E            %\n%        AAAAA    T      T    RRRR     I    BBBB   U   U    T    EEE          %\n%        A   A    T      T    R R      I    B   B  U   U    T    E            %\n%        A   A    T      T    R  R   IIIII  BBBB    UUU     T    EEEEE        %\n%                                                                             %\n%                                                                             %\n%                    MagickCore Get / Set Image Attributes                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                October 2002                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/identify.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e B o u n d i n g B o x                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageBoundingBox() returns the bounding box of an image canvas.\n%\n%  The format of the GetImageBoundingBox method is:\n%\n%      RectangleInfo GetImageBoundingBox(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o bounds: Method GetImageBoundingBox returns the bounding box of an\n%      image canvas.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport RectangleInfo GetImageBoundingBox(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    target[3],\n    zero;\n\n  RectangleInfo\n    bounds;\n\n  register const Quantum\n    *r;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  bounds.width=0;\n  bounds.height=0;\n  bounds.x=(ssize_t) image->columns;\n  bounds.y=(ssize_t) image->rows;\n  GetPixelInfo(image,&target[0]);\n  image_view=AcquireVirtualCacheView(image,exception);\n  r=GetCacheViewVirtualPixels(image_view,0,0,1,1,exception);\n  if (r == (const Quantum *) NULL)\n    {\n      image_view=DestroyCacheView(image_view);\n      return(bounds);\n    }\n  GetPixelInfoPixel(image,r,&target[0]);\n  GetPixelInfo(image,&target[1]);\n  r=GetCacheViewVirtualPixels(image_view,(ssize_t) image->columns-1,0,1,1,\n    exception);\n  if (r != (const Quantum *) NULL)\n    GetPixelInfoPixel(image,r,&target[1]);\n  GetPixelInfo(image,&target[2]);\n  r=GetCacheViewVirtualPixels(image_view,0,(ssize_t) image->rows-1,1,1,\n    exception);\n  if (r != (const Quantum *) NULL)\n    GetPixelInfoPixel(image,r,&target[2]);\n  status=MagickTrue;\n  GetPixelInfo(image,&zero);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelInfo\n      pixel;\n\n    RectangleInfo\n      bounding_box;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#  pragma omp critical (MagickCore_GetImageBoundingBox)\n#endif\n    bounding_box=bounds;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    pixel=zero;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      GetPixelInfoPixel(image,p,&pixel);\n      if ((x < bounding_box.x) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[0]) == MagickFalse))\n        bounding_box.x=x;\n      if ((x > (ssize_t) bounding_box.width) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[1]) == MagickFalse))\n        bounding_box.width=(size_t) x;\n      if ((y < bounding_box.y) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[0]) == MagickFalse))\n        bounding_box.y=y;\n      if ((y > (ssize_t) bounding_box.height) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[2]) == MagickFalse))\n        bounding_box.height=(size_t) y;\n      p+=GetPixelChannels(image);\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#  pragma omp critical (MagickCore_GetImageBoundingBox)\n#endif\n    {\n      if (bounding_box.x < bounds.x)\n        bounds.x=bounding_box.x;\n      if (bounding_box.y < bounds.y)\n        bounds.y=bounding_box.y;\n      if (bounding_box.width > bounds.width)\n        bounds.width=bounding_box.width;\n      if (bounding_box.height > bounds.height)\n        bounds.height=bounding_box.height;\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  if ((bounds.width == 0) && (bounds.height == 0))\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n      \"GeometryDoesNotContainImage\",\"`%s'\",image->filename);\n  else\n    {\n      bounds.width-=(bounds.x-1);\n      bounds.height-=(bounds.y-1);\n    }\n  return(bounds);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e D e p t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageDepth() returns the depth of a particular image channel.\n%\n%  The format of the GetImageDepth method is:\n%\n%      size_t GetImageDepth(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport size_t GetImageDepth(const Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    *current_depth,\n    depth,\n    number_threads;\n\n  ssize_t\n    y;\n\n  /*\n    Compute image depth.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  current_depth=(size_t *) AcquireQuantumMemory(number_threads,\n    sizeof(*current_depth));\n  if (current_depth == (size_t *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) number_threads; i++)\n    current_depth[i]=1;\n  if ((image->storage_class == PseudoClass) &&\n      (image->alpha_trait == UndefinedPixelTrait))\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        if ((image->colors) > 256) \\\n          num_threads(GetMagickResourceLimit(ThreadResource))\n#endif\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)\n        {\n          MagickBooleanType\n            atDepth;\n\n          QuantumAny\n            range;\n\n          atDepth=MagickTrue;\n          range=GetQuantumRange(current_depth[id]);\n          if ((atDepth != MagickFalse) &&\n              (GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n            if (IsPixelAtDepth(image->colormap[i].red,range) == MagickFalse)\n              atDepth=MagickFalse;\n          if ((atDepth != MagickFalse) &&\n              (GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n            if (IsPixelAtDepth(image->colormap[i].green,range) == MagickFalse)\n              atDepth=MagickFalse;\n          if ((atDepth != MagickFalse) &&\n              (GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n            if (IsPixelAtDepth(image->colormap[i].blue,range) == MagickFalse)\n              atDepth=MagickFalse;\n          if ((atDepth != MagickFalse))\n            break;\n          current_depth[id]++;\n        }\n      }\n      depth=current_depth[0];\n      for (i=1; i < (ssize_t) number_threads; i++)\n        if (depth < current_depth[i])\n          depth=current_depth[i];\n      current_depth=(size_t *) RelinquishMagickMemory(current_depth);\n      return(depth);\n    }\n  image_view=AcquireVirtualCacheView(image,exception);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  if (QuantumRange <= MaxMap)\n    {\n      size_t\n        *depth_map;\n\n      /*\n        Scale pixels to desired (optimized with depth map).\n      */\n      depth_map=(size_t *) AcquireQuantumMemory(MaxMap+1,sizeof(*depth_map));\n      if (depth_map == (size_t *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      for (i=0; i <= (ssize_t) MaxMap; i++)\n      {\n        unsigned int\n          depth;\n\n        for (depth=1; depth < MAGICKCORE_QUANTUM_DEPTH; depth++)\n        {\n          Quantum\n            pixel;\n\n          QuantumAny\n            range;\n\n          range=GetQuantumRange(depth);\n          pixel=(Quantum) i;\n          if (pixel == ScaleAnyToQuantum(ScaleQuantumToAny(pixel,range),range))\n            break;\n        }\n        depth_map[i]=depth;\n      }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        register const Quantum\n          *magick_restrict p;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          continue;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          if (GetPixelReadMask(image,p) == 0)\n            {\n              p+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (channel == IndexPixelChannel) ||\n                (channel == ReadMaskPixelChannel) ||\n                (channel == MetaPixelChannel))\n              continue;\n            if (depth_map[ScaleQuantumToMap(p[i])] > current_depth[id])\n              current_depth[id]=depth_map[ScaleQuantumToMap(p[i])];\n          }\n          p+=GetPixelChannels(image);\n        }\n        if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      depth=current_depth[0];\n      for (i=1; i < (ssize_t) number_threads; i++)\n        if (depth < current_depth[i])\n          depth=current_depth[i];\n      depth_map=(size_t *) RelinquishMagickMemory(depth_map);\n      current_depth=(size_t *) RelinquishMagickMemory(current_depth);\n      return(depth);\n    }\n#endif\n  /*\n    Compute pixel depth.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      continue;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel\n          channel;\n\n        PixelTrait\n          traits;\n\n        channel=GetPixelChannelChannel(image,i);\n        traits=GetPixelChannelTraits(image,channel);\n        if ((traits == UndefinedPixelTrait) || (channel == IndexPixelChannel) ||\n            (channel == ReadMaskPixelChannel))\n          continue;\n        while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)\n        {\n          QuantumAny\n            range;\n\n          range=GetQuantumRange(current_depth[id]);\n          if (p[i] == ScaleAnyToQuantum(ScaleQuantumToAny(p[i],range),range))\n            break;\n          current_depth[id]++;\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  depth=current_depth[0];\n  for (i=1; i < (ssize_t) number_threads; i++)\n    if (depth < current_depth[i])\n      depth=current_depth[i];\n  current_depth=(size_t *) RelinquishMagickMemory(current_depth);\n  return(depth);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e Q u a n t u m D e p t h                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageQuantumDepth() returns the depth of the image rounded to a legal\n%  quantum depth: 8, 16, or 32.\n%\n%  The format of the GetImageQuantumDepth method is:\n%\n%      size_t GetImageQuantumDepth(const Image *image,\n%        const MagickBooleanType constrain)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o constrain: A value other than MagickFalse, constrains the depth to\n%      a maximum of MAGICKCORE_QUANTUM_DEPTH.\n%\n*/\nMagickExport size_t GetImageQuantumDepth(const Image *image,\n  const MagickBooleanType constrain)\n{\n  size_t\n    depth;\n\n  depth=image->depth;\n  if (depth <= 8)\n    depth=8;\n  else\n    if (depth <= 16)\n      depth=16;\n    else\n      if (depth <= 32)\n        depth=32;\n      else\n        if (depth <= 64)\n          depth=64;\n  if (constrain != MagickFalse)\n    depth=(size_t) MagickMin((double) depth,(double) MAGICKCORE_QUANTUM_DEPTH);\n  return(depth);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e T y p e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageType() returns the type of image:\n%\n%        Bilevel         Grayscale        GrayscaleMatte\n%        Palette         PaletteMatte     TrueColor\n%        TrueColorMatte  ColorSeparation  ColorSeparationMatte\n%\n%  The format of the GetImageType method is:\n%\n%      ImageType GetImageType(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport ImageType GetImageType(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->colorspace == CMYKColorspace)\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        return(ColorSeparationType);\n      return(ColorSeparationAlphaType);\n    }\n  if (IsImageMonochrome(image) != MagickFalse)\n    return(BilevelType);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(GrayscaleAlphaType);\n      return(GrayscaleType);\n    }\n  if (IsPaletteImage(image) != MagickFalse)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(PaletteAlphaType);\n      return(PaletteType);\n    }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    return(TrueColorAlphaType);\n  return(TrueColorType);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I d e n t i f y I m a g e G r a y                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IdentifyImageGray() returns grayscale if all the pixels in the image have\n%  the same red, green, and blue intensities, and bi-level is the intensity is\n%  either 0 or QuantumRange. Otherwise undefined is returned.\n%\n%  The format of the IdentifyImageGray method is:\n%\n%      ImageType IdentifyImageGray(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ImageType IdentifyImageGray(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  ImageType\n    type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->type == BilevelType) || (image->type == GrayscaleType) ||\n      (image->type == GrayscaleAlphaType))\n    return(image->type);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    return(UndefinedType);\n  type=BilevelType;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (IsPixelGray(image,p) == MagickFalse)\n        {\n          type=UndefinedType;\n          break;\n        }\n      if ((type == BilevelType) &&\n          (IsPixelMonochrome(image,p) == MagickFalse))\n        type=GrayscaleType;\n      p+=GetPixelChannels(image);\n    }\n    if (type == UndefinedType)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  if ((type == GrayscaleType) && (image->alpha_trait != UndefinedPixelTrait))\n    type=GrayscaleAlphaType;\n  return(type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I d e n t i f y I m a g e M o n o c h r o m e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IdentifyImageMonochrome() returns MagickTrue if all the pixels in the image\n%  have the same red, green, and blue intensities and the intensity is either\n%  0 or QuantumRange.\n%\n%  The format of the IdentifyImageMonochrome method is:\n%\n%      MagickBooleanType IdentifyImageMonochrome(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IdentifyImageMonochrome(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  ImageType\n    type;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->type == BilevelType)\n    return(MagickTrue);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    return(MagickFalse);\n  type=BilevelType;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (IsPixelMonochrome(image,p) == MagickFalse)\n        {\n          type=UndefinedType;\n          break;\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (type == UndefinedType)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (type == BilevelType)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I d e n t i f y I m a g e T y p e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IdentifyImageType() returns the potential type of image:\n%\n%        Bilevel         Grayscale        GrayscaleMatte\n%        Palette         PaletteMatte     TrueColor\n%        TrueColorMatte  ColorSeparation  ColorSeparationMatte\n%\n%  To ensure the image type matches its potential, use SetImageType():\n%\n%    (void) SetImageType(image,IdentifyImageType(image,exception),exception);\n%\n%  The format of the IdentifyImageType method is:\n%\n%      ImageType IdentifyImageType(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ImageType IdentifyImageType(const Image *image,\n  ExceptionInfo *exception)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->colorspace == CMYKColorspace)\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        return(ColorSeparationType);\n      return(ColorSeparationAlphaType);\n    }\n  if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n    return(BilevelType);\n  if (IdentifyImageGray(image,exception) != UndefinedType)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(GrayscaleAlphaType);\n      return(GrayscaleType);\n    }\n  if (IdentifyPaletteImage(image,exception) != MagickFalse)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(PaletteAlphaType);\n      return(PaletteType);\n    }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    return(TrueColorAlphaType);\n  return(TrueColorType);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e G r a y                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageGray() returns MagickTrue if the type of the image is grayscale or\n%  bi-level.\n%\n%  The format of the IsImageGray method is:\n%\n%      MagickBooleanType IsImageGray(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageGray(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if ((image->type == BilevelType) || (image->type == GrayscaleType) ||\n      (image->type == GrayscaleAlphaType))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s I m a g e M o n o c h r o m e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageMonochrome() returns MagickTrue if type of the image is bi-level.\n%\n%  The format of the IsImageMonochrome method is:\n%\n%      MagickBooleanType IsImageMonochrome(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageMonochrome(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type == BilevelType)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e O p a q u e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageOpaque() returns MagickTrue if none of the pixels in the image have\n%  an alpha value other than OpaqueAlpha (QuantumRange).\n%\n%  Will return true immediatally is alpha channel is not available.\n%\n%  The format of the IsImageOpaque method is:\n%\n%      MagickBooleanType IsImageOpaque(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IsImageOpaque(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Determine if image is opaque.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    return(MagickTrue);\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelAlpha(image,p) != OpaqueAlpha)\n        break;\n      p+=GetPixelChannels(image);\n    }\n    if (x < (ssize_t) image->columns)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e D e p t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageDepth() sets the depth of the image.\n%\n%  The format of the SetImageDepth method is:\n%\n%      MagickBooleanType SetImageDepth(Image *image,const size_t depth,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o depth: the image depth.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageDepth(Image *image,\n  const size_t depth,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (depth >= MAGICKCORE_QUANTUM_DEPTH)\n    {\n      image->depth=depth;\n      return(MagickTrue);\n    }\n  range=GetQuantumRange(depth);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,1,1)\n#endif\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].red=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].red),range),range);\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].green=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].green),range),range);\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].blue=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].blue),range),range);\n        if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].alpha=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].alpha),range),range);\n      }\n    }\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  if (QuantumRange <= MaxMap)\n    {\n      Quantum\n        *depth_map;\n\n      register ssize_t\n        i;\n\n      /*\n        Scale pixels to desired (optimized with depth map).\n      */\n      depth_map=(Quantum *) AcquireQuantumMemory(MaxMap+1,sizeof(*depth_map));\n      if (depth_map == (Quantum *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      for (i=0; i <= (ssize_t) MaxMap; i++)\n        depth_map[i]=ScaleAnyToQuantum(ScaleQuantumToAny((Quantum) i,range),\n          range);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (GetPixelReadMask(image,q) == 0)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel\n              channel;\n\n            PixelTrait\n              traits;\n\n            channel=GetPixelChannelChannel(image,i);\n            traits=GetPixelChannelTraits(image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (channel == IndexPixelChannel) ||\n                (channel == ReadMaskPixelChannel))\n              continue;\n            q[i]=depth_map[ScaleQuantumToMap(q[i])];\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          {\n            status=MagickFalse;\n            continue;\n          }\n      }\n      image_view=DestroyCacheView(image_view);\n      depth_map=(Quantum *) RelinquishMagickMemory(depth_map);\n      if (status != MagickFalse)\n        image->depth=depth;\n      return(status);\n    }\n#endif\n  /*\n    Scale pixels to desired depth.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel\n          channel;\n\n        PixelTrait\n          traits;\n\n        channel=GetPixelChannelChannel(image,i);\n        traits=GetPixelChannelTraits(image,channel);\n        if ((traits == UndefinedPixelTrait) || (channel == IndexPixelChannel) ||\n            (channel == ReadMaskPixelChannel))\n          continue;\n        q[i]=ScaleAnyToQuantum(ScaleQuantumToAny(ClampPixel(q[i]),range),range);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        continue;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status != MagickFalse)\n    image->depth=depth;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e T y p e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageType() sets the type of image.  Choose from these types:\n%\n%        Bilevel        Grayscale       GrayscaleMatte\n%        Palette        PaletteMatte    TrueColor\n%        TrueColorMatte ColorSeparation ColorSeparationMatte\n%        OptimizeType\n%\n%  The format of the SetImageType method is:\n%\n%      MagickBooleanType SetImageType(Image *image,const ImageType type,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: Image type.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageType(Image *image,const ImageType type,\n  ExceptionInfo *exception)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace,exception);\n          (void) NormalizeImage(image,exception);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->colors=2;\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleAlphaType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case PaletteBilevelAlphaType:\n    {\n      ChannelType\n        channel_mask;\n\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      channel_mask=SetImageChannelMask(image,AlphaChannel);\n      (void) BilevelImage(image,(double) QuantumRange/2.0,exception);\n      (void) SetImageChannelMask(image,channel_mask);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case TrueColorAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case ColorSeparationAlphaType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(status);\n  image->type=type;\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%         AAA   TTTTT  TTTTT  RRRR   IIIII  BBBB   U   U  TTTTT  EEEEE        %\n%        A   A    T      T    R   R    I    B   B  U   U    T    E            %\n%        AAAAA    T      T    RRRR     I    BBBB   U   U    T    EEE          %\n%        A   A    T      T    R R      I    B   B  U   U    T    E            %\n%        A   A    T      T    R  R   IIIII  BBBB    UUU     T    EEEEE        %\n%                                                                             %\n%                                                                             %\n%                    MagickCore Get / Set Image Attributes                    %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                October 2002                                 %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colormap.h\"\n#include \"MagickCore/colormap-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/draw-private.h\"\n#include \"MagickCore/effect.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/histogram.h\"\n#include \"MagickCore/identify.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/threshold.h\"\n#include \"MagickCore/transform.h\"\n#include \"MagickCore/utility.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e B o u n d i n g B o x                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageBoundingBox() returns the bounding box of an image canvas.\n%\n%  The format of the GetImageBoundingBox method is:\n%\n%      RectangleInfo GetImageBoundingBox(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o bounds: Method GetImageBoundingBox returns the bounding box of an\n%      image canvas.\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport RectangleInfo GetImageBoundingBox(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    target[3],\n    zero;\n\n  RectangleInfo\n    bounds;\n\n  register const Quantum\n    *r;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  bounds.width=0;\n  bounds.height=0;\n  bounds.x=(ssize_t) image->columns;\n  bounds.y=(ssize_t) image->rows;\n  GetPixelInfo(image,&target[0]);\n  image_view=AcquireVirtualCacheView(image,exception);\n  r=GetCacheViewVirtualPixels(image_view,0,0,1,1,exception);\n  if (r == (const Quantum *) NULL)\n    {\n      image_view=DestroyCacheView(image_view);\n      return(bounds);\n    }\n  GetPixelInfoPixel(image,r,&target[0]);\n  GetPixelInfo(image,&target[1]);\n  r=GetCacheViewVirtualPixels(image_view,(ssize_t) image->columns-1,0,1,1,\n    exception);\n  if (r != (const Quantum *) NULL)\n    GetPixelInfoPixel(image,r,&target[1]);\n  GetPixelInfo(image,&target[2]);\n  r=GetCacheViewVirtualPixels(image_view,0,(ssize_t) image->rows-1,1,1,\n    exception);\n  if (r != (const Quantum *) NULL)\n    GetPixelInfoPixel(image,r,&target[2]);\n  status=MagickTrue;\n  GetPixelInfo(image,&zero);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    PixelInfo\n      pixel;\n\n    RectangleInfo\n      bounding_box;\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#  pragma omp critical (MagickCore_GetImageBoundingBox)\n#endif\n    bounding_box=bounds;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    pixel=zero;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      GetPixelInfoPixel(image,p,&pixel);\n      if ((x < bounding_box.x) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[0]) == MagickFalse))\n        bounding_box.x=x;\n      if ((x > (ssize_t) bounding_box.width) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[1]) == MagickFalse))\n        bounding_box.width=(size_t) x;\n      if ((y < bounding_box.y) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[0]) == MagickFalse))\n        bounding_box.y=y;\n      if ((y > (ssize_t) bounding_box.height) &&\n          (IsFuzzyEquivalencePixelInfo(&pixel,&target[2]) == MagickFalse))\n        bounding_box.height=(size_t) y;\n      p+=GetPixelChannels(image);\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n#  pragma omp critical (MagickCore_GetImageBoundingBox)\n#endif\n    {\n      if (bounding_box.x < bounds.x)\n        bounds.x=bounding_box.x;\n      if (bounding_box.y < bounds.y)\n        bounds.y=bounding_box.y;\n      if (bounding_box.width > bounds.width)\n        bounds.width=bounding_box.width;\n      if (bounding_box.height > bounds.height)\n        bounds.height=bounding_box.height;\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  if ((bounds.width == 0) && (bounds.height == 0))\n    (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n      \"GeometryDoesNotContainImage\",\"`%s'\",image->filename);\n  else\n    {\n      bounds.width-=(bounds.x-1);\n      bounds.height-=(bounds.y-1);\n    }\n  return(bounds);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e D e p t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageDepth() returns the depth of a particular image channel.\n%\n%  The format of the GetImageDepth method is:\n%\n%      size_t GetImageDepth(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport size_t GetImageDepth(const Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  size_t\n    *current_depth,\n    depth,\n    number_threads;\n\n  ssize_t\n    y;\n\n  /*\n    Compute image depth.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  current_depth=(size_t *) AcquireQuantumMemory(number_threads,\n    sizeof(*current_depth));\n  if (current_depth == (size_t *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) number_threads; i++)\n    current_depth[i]=1;\n  if ((image->storage_class == PseudoClass) &&\n      (image->alpha_trait == UndefinedPixelTrait))\n    {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        if ((image->colors) > 256) \\\n          num_threads(GetMagickResourceLimit(ThreadResource))\n#endif\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)\n        {\n          MagickBooleanType\n            atDepth;\n\n          QuantumAny\n            range;\n\n          atDepth=MagickTrue;\n          range=GetQuantumRange(current_depth[id]);\n          if ((atDepth != MagickFalse) &&\n              (GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n            if (IsPixelAtDepth(image->colormap[i].red,range) == MagickFalse)\n              atDepth=MagickFalse;\n          if ((atDepth != MagickFalse) &&\n              (GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n            if (IsPixelAtDepth(image->colormap[i].green,range) == MagickFalse)\n              atDepth=MagickFalse;\n          if ((atDepth != MagickFalse) &&\n              (GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n            if (IsPixelAtDepth(image->colormap[i].blue,range) == MagickFalse)\n              atDepth=MagickFalse;\n          if ((atDepth != MagickFalse))\n            break;\n          current_depth[id]++;\n        }\n      }\n      depth=current_depth[0];\n      for (i=1; i < (ssize_t) number_threads; i++)\n        if (depth < current_depth[i])\n          depth=current_depth[i];\n      current_depth=(size_t *) RelinquishMagickMemory(current_depth);\n      return(depth);\n    }\n  image_view=AcquireVirtualCacheView(image,exception);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  if (QuantumRange <= MaxMap)\n    {\n      size_t\n        *depth_map;\n\n      /*\n        Scale pixels to desired (optimized with depth map).\n      */\n      depth_map=(size_t *) AcquireQuantumMemory(MaxMap+1,sizeof(*depth_map));\n      if (depth_map == (size_t *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      for (i=0; i <= (ssize_t) MaxMap; i++)\n      {\n        unsigned int\n          depth;\n\n        for (depth=1; depth < MAGICKCORE_QUANTUM_DEPTH; depth++)\n        {\n          Quantum\n            pixel;\n\n          QuantumAny\n            range;\n\n          range=GetQuantumRange(depth);\n          pixel=(Quantum) i;\n          if (pixel == ScaleAnyToQuantum(ScaleQuantumToAny(pixel,range),range))\n            break;\n        }\n        depth_map[i]=depth;\n      }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        register const Quantum\n          *magick_restrict p;\n\n        register ssize_t\n          x;\n\n        if (status == MagickFalse)\n          continue;\n        p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n        if (p == (const Quantum *) NULL)\n          continue;\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          if (GetPixelReadMask(image,p) == 0)\n            {\n              p+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel channel=GetPixelChannelChannel(image,i);\n            PixelTrait traits=GetPixelChannelTraits(image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (channel == IndexPixelChannel) ||\n                (channel == ReadMaskPixelChannel) ||\n                (channel == MetaPixelChannel))\n              continue;\n            if (depth_map[ScaleQuantumToMap(p[i])] > current_depth[id])\n              current_depth[id]=depth_map[ScaleQuantumToMap(p[i])];\n          }\n          p+=GetPixelChannels(image);\n        }\n        if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)\n          status=MagickFalse;\n      }\n      image_view=DestroyCacheView(image_view);\n      depth=current_depth[0];\n      for (i=1; i < (ssize_t) number_threads; i++)\n        if (depth < current_depth[i])\n          depth=current_depth[i];\n      depth_map=(size_t *) RelinquishMagickMemory(depth_map);\n      current_depth=(size_t *) RelinquishMagickMemory(current_depth);\n      return(depth);\n    }\n#endif\n  /*\n    Compute pixel depth.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      continue;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelReadMask(image,p) == 0)\n        {\n          p+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel\n          channel;\n\n        PixelTrait\n          traits;\n\n        channel=GetPixelChannelChannel(image,i);\n        traits=GetPixelChannelTraits(image,channel);\n        if ((traits == UndefinedPixelTrait) || (channel == IndexPixelChannel) ||\n            (channel == ReadMaskPixelChannel))\n          continue;\n        while (current_depth[id] < MAGICKCORE_QUANTUM_DEPTH)\n        {\n          QuantumAny\n            range;\n\n          range=GetQuantumRange(current_depth[id]);\n          if (p[i] == ScaleAnyToQuantum(ScaleQuantumToAny(p[i],range),range))\n            break;\n          current_depth[id]++;\n        }\n      }\n      p+=GetPixelChannels(image);\n    }\n    if (current_depth[id] == MAGICKCORE_QUANTUM_DEPTH)\n      status=MagickFalse;\n  }\n  image_view=DestroyCacheView(image_view);\n  depth=current_depth[0];\n  for (i=1; i < (ssize_t) number_threads; i++)\n    if (depth < current_depth[i])\n      depth=current_depth[i];\n  current_depth=(size_t *) RelinquishMagickMemory(current_depth);\n  return(depth);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e Q u a n t u m D e p t h                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageQuantumDepth() returns the depth of the image rounded to a legal\n%  quantum depth: 8, 16, or 32.\n%\n%  The format of the GetImageQuantumDepth method is:\n%\n%      size_t GetImageQuantumDepth(const Image *image,\n%        const MagickBooleanType constrain)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o constrain: A value other than MagickFalse, constrains the depth to\n%      a maximum of MAGICKCORE_QUANTUM_DEPTH.\n%\n*/\nMagickExport size_t GetImageQuantumDepth(const Image *image,\n  const MagickBooleanType constrain)\n{\n  size_t\n    depth;\n\n  depth=image->depth;\n  if (depth <= 8)\n    depth=8;\n  else\n    if (depth <= 16)\n      depth=16;\n    else\n      if (depth <= 32)\n        depth=32;\n      else\n        if (depth <= 64)\n          depth=64;\n  if (constrain != MagickFalse)\n    depth=(size_t) MagickMin((double) depth,(double) MAGICKCORE_QUANTUM_DEPTH);\n  return(depth);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e T y p e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageType() returns the type of image:\n%\n%        Bilevel         Grayscale        GrayscaleMatte\n%        Palette         PaletteMatte     TrueColor\n%        TrueColorMatte  ColorSeparation  ColorSeparationMatte\n%\n%  The format of the GetImageType method is:\n%\n%      ImageType GetImageType(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport ImageType GetImageType(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->colorspace == CMYKColorspace)\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        return(ColorSeparationType);\n      return(ColorSeparationAlphaType);\n    }\n  if (IsImageMonochrome(image) != MagickFalse)\n    return(BilevelType);\n  if (IsImageGray(image) != MagickFalse)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(GrayscaleAlphaType);\n      return(GrayscaleType);\n    }\n  if (IsPaletteImage(image) != MagickFalse)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(PaletteAlphaType);\n      return(PaletteType);\n    }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    return(TrueColorAlphaType);\n  return(TrueColorType);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I d e n t i f y I m a g e G r a y                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IdentifyImageGray() returns grayscale if all the pixels in the image have\n%  the same red, green, and blue intensities, and bi-level is the intensity is\n%  either 0 or QuantumRange. Otherwise undefined is returned.\n%\n%  The format of the IdentifyImageGray method is:\n%\n%      ImageType IdentifyImageGray(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ImageType IdentifyImageGray(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  ImageType\n    type;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->type == BilevelType) || (image->type == GrayscaleType) ||\n      (image->type == GrayscaleAlphaType))\n    return(image->type);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    return(UndefinedType);\n  type=BilevelType;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (IsPixelGray(image,p) == MagickFalse)\n        {\n          type=UndefinedType;\n          break;\n        }\n      if ((type == BilevelType) &&\n          (IsPixelMonochrome(image,p) == MagickFalse))\n        type=GrayscaleType;\n      p+=GetPixelChannels(image);\n    }\n    if (type == UndefinedType)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  if ((type == GrayscaleType) && (image->alpha_trait != UndefinedPixelTrait))\n    type=GrayscaleAlphaType;\n  return(type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I d e n t i f y I m a g e M o n o c h r o m e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IdentifyImageMonochrome() returns MagickTrue if all the pixels in the image\n%  have the same red, green, and blue intensities and the intensity is either\n%  0 or QuantumRange.\n%\n%  The format of the IdentifyImageMonochrome method is:\n%\n%      MagickBooleanType IdentifyImageMonochrome(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IdentifyImageMonochrome(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  ImageType\n    type;\n\n  register ssize_t\n    x;\n\n  register const Quantum\n    *p;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->type == BilevelType)\n    return(MagickTrue);\n  if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n    return(MagickFalse);\n  type=BilevelType;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (IsPixelMonochrome(image,p) == MagickFalse)\n        {\n          type=UndefinedType;\n          break;\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (type == UndefinedType)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  if (type == BilevelType)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I d e n t i f y I m a g e T y p e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IdentifyImageType() returns the potential type of image:\n%\n%        Bilevel         Grayscale        GrayscaleMatte\n%        Palette         PaletteMatte     TrueColor\n%        TrueColorMatte  ColorSeparation  ColorSeparationMatte\n%\n%  To ensure the image type matches its potential, use SetImageType():\n%\n%    (void) SetImageType(image,IdentifyImageType(image,exception),exception);\n%\n%  The format of the IdentifyImageType method is:\n%\n%      ImageType IdentifyImageType(const Image *image,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport ImageType IdentifyImageType(const Image *image,\n  ExceptionInfo *exception)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->colorspace == CMYKColorspace)\n    {\n      if (image->alpha_trait == UndefinedPixelTrait)\n        return(ColorSeparationType);\n      return(ColorSeparationAlphaType);\n    }\n  if (IdentifyImageMonochrome(image,exception) != MagickFalse)\n    return(BilevelType);\n  if (IdentifyImageGray(image,exception) != UndefinedType)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(GrayscaleAlphaType);\n      return(GrayscaleType);\n    }\n  if (IdentifyPaletteImage(image,exception) != MagickFalse)\n    {\n      if (image->alpha_trait != UndefinedPixelTrait)\n        return(PaletteAlphaType);\n      return(PaletteType);\n    }\n  if (image->alpha_trait != UndefinedPixelTrait)\n    return(TrueColorAlphaType);\n  return(TrueColorType);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e G r a y                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageGray() returns MagickTrue if the type of the image is grayscale or\n%  bi-level.\n%\n%  The format of the IsImageGray method is:\n%\n%      MagickBooleanType IsImageGray(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageGray(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if ((image->type == BilevelType) || (image->type == GrayscaleType) ||\n      (image->type == GrayscaleAlphaType))\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   I s I m a g e M o n o c h r o m e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageMonochrome() returns MagickTrue if type of the image is bi-level.\n%\n%  The format of the IsImageMonochrome method is:\n%\n%      MagickBooleanType IsImageMonochrome(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickBooleanType IsImageMonochrome(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->type == BilevelType)\n    return(MagickTrue);\n  return(MagickFalse);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I s I m a g e O p a q u e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  IsImageOpaque() returns MagickTrue if none of the pixels in the image have\n%  an alpha value other than OpaqueAlpha (QuantumRange).\n%\n%  Will return true immediatally is alpha channel is not available.\n%\n%  The format of the IsImageOpaque method is:\n%\n%      MagickBooleanType IsImageOpaque(const Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType IsImageOpaque(const Image *image,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Determine if image is opaque.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->alpha_trait == UndefinedPixelTrait)\n    return(MagickTrue);\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelAlpha(image,p) != OpaqueAlpha)\n        break;\n      p+=GetPixelChannels(image);\n    }\n    if (x < (ssize_t) image->columns)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  return(y < (ssize_t) image->rows ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e D e p t h                                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageDepth() sets the depth of the image.\n%\n%  The format of the SetImageDepth method is:\n%\n%      MagickBooleanType SetImageDepth(Image *image,const size_t depth,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o channel: the channel.\n%\n%    o depth: the image depth.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageDepth(Image *image,\n  const size_t depth,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  MagickBooleanType\n    status;\n\n  QuantumAny\n    range;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  if (depth >= MAGICKCORE_QUANTUM_DEPTH)\n    {\n      image->depth=depth;\n      return(MagickTrue);\n    }\n  range=GetQuantumRange(depth);\n  if (image->storage_class == PseudoClass)\n    {\n      register ssize_t\n        i;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,1,1)\n#endif\n      for (i=0; i < (ssize_t) image->colors; i++)\n      {\n        if ((GetPixelRedTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].red=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].red),range),range);\n        if ((GetPixelGreenTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].green=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].green),range),range);\n        if ((GetPixelBlueTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].blue=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].blue),range),range);\n        if ((GetPixelAlphaTraits(image) & UpdatePixelTrait) != 0)\n          image->colormap[i].alpha=(double) ScaleAnyToQuantum(ScaleQuantumToAny(\n            ClampPixel(image->colormap[i].alpha),range),range);\n      }\n    }\n  status=MagickTrue;\n  image_view=AcquireAuthenticCacheView(image,exception);\n#if !defined(MAGICKCORE_HDRI_SUPPORT)\n  if (QuantumRange <= MaxMap)\n    {\n      Quantum\n        *depth_map;\n\n      register ssize_t\n        i;\n\n      /*\n        Scale pixels to desired (optimized with depth map).\n      */\n      depth_map=(Quantum *) AcquireQuantumMemory(MaxMap+1,sizeof(*depth_map));\n      if (depth_map == (Quantum *) NULL)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n      for (i=0; i <= (ssize_t) MaxMap; i++)\n        depth_map[i]=ScaleAnyToQuantum(ScaleQuantumToAny((Quantum) i,range),\n          range);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        magick_threads(image,image,image->rows,1)\n#endif\n      for (y=0; y < (ssize_t) image->rows; y++)\n      {\n        register ssize_t\n          x;\n\n        register Quantum\n          *magick_restrict q;\n\n        if (status == MagickFalse)\n          continue;\n        q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          {\n            status=MagickFalse;\n            continue;\n          }\n        for (x=0; x < (ssize_t) image->columns; x++)\n        {\n          register ssize_t\n            i;\n\n          if (GetPixelReadMask(image,q) == 0)\n            {\n              q+=GetPixelChannels(image);\n              continue;\n            }\n          for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n          {\n            PixelChannel\n              channel;\n\n            PixelTrait\n              traits;\n\n            channel=GetPixelChannelChannel(image,i);\n            traits=GetPixelChannelTraits(image,channel);\n            if ((traits == UndefinedPixelTrait) ||\n                (channel == IndexPixelChannel) ||\n                (channel == ReadMaskPixelChannel))\n              continue;\n            q[i]=depth_map[ScaleQuantumToMap(q[i])];\n          }\n          q+=GetPixelChannels(image);\n        }\n        if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n          {\n            status=MagickFalse;\n            continue;\n          }\n      }\n      image_view=DestroyCacheView(image_view);\n      depth_map=(Quantum *) RelinquishMagickMemory(depth_map);\n      if (status != MagickFalse)\n        image->depth=depth;\n      return(status);\n    }\n#endif\n  /*\n    Scale pixels to desired depth.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    register Quantum\n      *magick_restrict q;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      if (GetPixelReadMask(image,q) == 0)\n        {\n          q+=GetPixelChannels(image);\n          continue;\n        }\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        PixelChannel\n          channel;\n\n        PixelTrait\n          traits;\n\n        channel=GetPixelChannelChannel(image,i);\n        traits=GetPixelChannelTraits(image,channel);\n        if ((traits == UndefinedPixelTrait) || (channel == IndexPixelChannel) ||\n            (channel == ReadMaskPixelChannel))\n          continue;\n        q[i]=ScaleAnyToQuantum(ScaleQuantumToAny(ClampPixel(q[i]),range),range);\n      }\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      {\n        status=MagickFalse;\n        continue;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status != MagickFalse)\n    image->depth=depth;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e T y p e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageType() sets the type of image.  Choose from these types:\n%\n%        Bilevel        Grayscale       GrayscaleMatte\n%        Palette        PaletteMatte    TrueColor\n%        TrueColorMatte ColorSeparation ColorSeparationMatte\n%        OptimizeType\n%\n%  The format of the SetImageType method is:\n%\n%      MagickBooleanType SetImageType(Image *image,const ImageType type,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o type: Image type.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SetImageType(Image *image,const ImageType type,\n  ExceptionInfo *exception)\n{\n  const char\n    *artifact;\n\n  ImageInfo\n    *image_info;\n\n  MagickBooleanType\n    status;\n\n  QuantizeInfo\n    *quantize_info;\n\n  assert(image != (Image *) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"...\");\n  assert(image->signature == MagickCoreSignature);\n  status=MagickTrue;\n  image_info=AcquireImageInfo();\n  image_info->dither=image->dither;\n  artifact=GetImageArtifact(image,\"dither\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"dither\",artifact);\n  switch (type)\n  {\n    case BilevelType:\n    {\n      if (SetImageMonochrome(image,exception) == MagickFalse)\n        {\n          status=TransformImageColorspace(image,GRAYColorspace,exception);\n          (void) NormalizeImage(image,exception);\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=2;\n          quantize_info->colorspace=GRAYColorspace;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      status=AcquireImageColormap(image,2,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case GrayscaleAlphaType:\n    {\n      if (SetImageGray(image,exception) == MagickFalse)\n        status=TransformImageColorspace(image,GRAYColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case PaletteType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if ((image->storage_class == DirectClass) || (image->colors > 256))\n        {\n          quantize_info=AcquireQuantizeInfo(image_info);\n          quantize_info->number_colors=256;\n          status=QuantizeImage(quantize_info,image,exception);\n          quantize_info=DestroyQuantizeInfo(quantize_info);\n        }\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case PaletteBilevelAlphaType:\n    {\n      ChannelType\n        channel_mask;\n\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      channel_mask=SetImageChannelMask(image,AlphaChannel);\n      (void) BilevelImage(image,(double) QuantumRange/2.0,exception);\n      (void) SetImageChannelMask(image,channel_mask);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case PaletteAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      quantize_info=AcquireQuantizeInfo(image_info);\n      quantize_info->colorspace=TransparentColorspace;\n      status=QuantizeImage(quantize_info,image,exception);\n      quantize_info=DestroyQuantizeInfo(quantize_info);\n      break;\n    }\n    case TrueColorType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case TrueColorAlphaType:\n    {\n      if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n        status=TransformImageColorspace(image,sRGBColorspace,exception);\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        (void) SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case ColorSeparationType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      image->alpha_trait=UndefinedPixelTrait;\n      break;\n    }\n    case ColorSeparationAlphaType:\n    {\n      if (image->colorspace != CMYKColorspace)\n        {\n          if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse)\n            status=TransformImageColorspace(image,sRGBColorspace,exception);\n          status=TransformImageColorspace(image,CMYKColorspace,exception);\n        }\n      if (image->storage_class != DirectClass)\n        status=SetImageStorageClass(image,DirectClass,exception);\n      if (image->alpha_trait == UndefinedPixelTrait)\n        status=SetImageAlphaChannel(image,OpaqueAlphaChannel,exception);\n      break;\n    }\n    case OptimizeType:\n    case UndefinedType:\n      break;\n  }\n  image_info=DestroyImageInfo(image_info);\n  if (status == MagickFalse)\n    return(status);\n  image->type=type;\n  return(MagickTrue);\n}\n"], "filenames": ["MagickCore/attribute.c"], "buggy_code_start_loc": [1280], "buggy_code_end_loc": [1281], "fixing_code_start_loc": [1280], "fixing_code_end_loc": [1281], "type": "CWE-416", "message": "magick/attribute.c in ImageMagick 7.0.3-2 allows remote attackers to cause a denial of service (use-after-free) via a crafted file.", "other": {"cve": {"id": "CVE-2016-7906", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-18T17:59:00.777", "lastModified": "2020-10-14T18:16:01.253", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "magick/attribute.c in ImageMagick 7.0.3-2 allows remote attackers to cause a denial of service (use-after-free) via a crafted file."}, {"lang": "es", "value": "magick/attribute.c en ImageMagick 7.0.3-2 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n) a trav\u00e9s de un archivo manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.3-2:*:*:*:*:*:*:*", "matchCriteriaId": "D391DECE-2408-4A8F-ACE6-F18028C422A3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.debian.org/security/2016/dsa-3726", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/02/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/10/02/3", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93271", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/90406972f108c4da71f998601b06abdc2ac6f06e", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/281", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201611-21", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/90406972f108c4da71f998601b06abdc2ac6f06e"}}