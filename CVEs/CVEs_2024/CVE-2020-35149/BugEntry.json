{"buggy_code": ["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Buffer = require('safe-buffer').Buffer;\nvar RegExpClone = require('regexp-clone');\n\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nvar clone = exports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return exports.cloneArray(obj, options);\n\n  if (obj.constructor) {\n    if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.id);\n    }\n\n    if (obj.constructor.name === 'ReadPreference') {\n      return new obj.constructor(obj.mode, clone(obj.tags, options));\n    }\n\n    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.value(true), obj.sub_type);\n    }\n\n    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n      return new obj.constructor(+obj);\n\n    if ('RegExp' === obj.constructor.name)\n      return RegExpClone(obj);\n\n    if ('Buffer' === obj.constructor.name)\n      return exports.cloneBuffer(obj);\n  }\n\n  if (isObject(obj))\n    return exports.cloneObject(obj, options);\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\n/*!\n * ignore\n */\n\nexports.cloneObject = function cloneObject(obj, options) {\n  var minimize = options && options.minimize;\n  var ret = {};\n  var hasKeys;\n  var val;\n  var k;\n\n  for (k in obj) {\n    val = clone(obj[k], options);\n\n    if (!minimize || ('undefined' !== typeof val)) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nexports.cloneArray = function cloneArray(arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps the given `callback` in a try/catch. If an error is\n * caught it will be thrown on nextTick.\n *\n * node-mongodb-native had a habit of state corruption when\n * an error was immediately thrown from within a collection\n * method (find, update, etc) callback.\n *\n * @param {Function} [callback]\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if ('function' !== typeof callback) return;\n  return function() {\n    // callbacks should always be fired on the next\n    // turn of the event loop. A side benefit is\n    // errors thrown from executing the callback\n    // will not cause drivers state to be corrupted\n    // which has historically been a problem.\n    var args = arguments;\n    soon(function() {\n      callback.apply(this, args);\n    });\n  };\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from) {\n  var keys = Object.keys(from),\n      i = keys.length,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      if (exports.isObject(from[key])) {\n        merge(to[key], from[key]);\n      } else {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.mergeClone = function mergeClone(to, from) {\n  var keys = Object.keys(from),\n      i = keys.length,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = clone(from[key]);\n    } else {\n      if (exports.isObject(from[key])) {\n        mergeClone(to[key], from[key]);\n      } else {\n        to[key] = clone(from[key]);\n      }\n    }\n  }\n};\n\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */\n\nexports.readPref = function readPref(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n\n\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */\n\nexports.readConcern = function readConcern(concern) {\n  if ('string' === typeof concern) {\n    switch (concern) {\n      case 'l':\n        concern = 'local';\n        break;\n      case 'a':\n        concern = 'available';\n        break;\n      case 'm':\n        concern = 'majority';\n        break;\n      case 'lz':\n        concern = 'linearizable';\n        break;\n      case 's':\n        concern = 'snapshot';\n        break;\n    }\n    concern = { level: concern };\n  }\n  return concern;\n};\n\n/**\n * Object.prototype.toString.call helper\n */\n\nvar _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n  return _toString.call(arg);\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */\n\nvar isObject = exports.isObject = function(arg) {\n  return '[object Object]' == exports.toString(arg);\n};\n\n/**\n * Determines if `arg` is an array.\n *\n * @param {Object}\n * @return {Boolean}\n * @see nodejs utils\n */\n\nexports.isArray = function(arg) {\n  return Array.isArray(arg) ||\n    'object' == typeof arg && '[object Array]' == exports.toString(arg);\n};\n\n/**\n * Object.keys helper\n */\n\nexports.keys = Object.keys || function(obj) {\n  var keys = [];\n  for (var k in obj) if (obj.hasOwnProperty(k)) {\n    keys.push(k);\n  }\n  return keys;\n};\n\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */\n\nexports.create = 'function' == typeof Object.create\n  ? Object.create\n  : create;\n\nfunction create(proto) {\n  if (arguments.length > 1) {\n    throw new Error('Adding properties is not supported');\n  }\n\n  function F() {}\n  F.prototype = proto;\n  return new F;\n}\n\n/**\n * inheritance\n */\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.prototype = exports.create(superCtor.prototype);\n  ctor.prototype.constructor = ctor;\n};\n\n/**\n * nextTick helper\n * compat with node 0.10 which behaves differently than previous versions\n */\n\nvar soon = exports.soon = 'function' == typeof setImmediate\n  ? setImmediate\n  : process.nextTick;\n\n/**\n * Clones the contents of a buffer.\n *\n * @param {Buffer} buff\n * @return {Buffer}\n */\n\nexports.cloneBuffer = function(buff) {\n  var dupe = Buffer.alloc(buff.length);\n  buff.copy(dupe, 0, 0, buff.length);\n  return dupe;\n};\n\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */\n\nexports.isArgumentsObject = function(v) {\n  return Object.prototype.toString.call(v) === '[object Arguments]';\n};\n", "'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar utils = require('../lib/utils');\nvar assert = require('assert');\nvar debug = require('debug');\n\nvar mongo;\ntry {\n  mongo = new require('mongodb');\n} catch (e) {\n  debug('mongo', 'cannot construct mongodb instance');\n}\n\ndescribe('lib/utils', function() {\n  describe('clone', function() {\n    it('clones constructors named ObjectId', function(done) {\n      function ObjectId(id) {\n        this.id = id;\n      }\n\n      var o1 = new ObjectId('1234');\n      var o2 = utils.clone(o1);\n      assert.ok(o2 instanceof ObjectId);\n\n      done();\n    });\n\n    it('clones constructors named ObjectID', function(done) {\n      function ObjectID(id) {\n        this.id = id;\n      }\n\n      var o1 = new ObjectID('1234');\n      var o2 = utils.clone(o1);\n\n      assert.ok(o2 instanceof ObjectID);\n      done();\n    });\n\n    it('does not clone constructors named ObjectIdd', function(done) {\n      function ObjectIdd(id) {\n        this.id = id;\n      }\n\n      var o1 = new ObjectIdd('1234');\n      var o2 = utils.clone(o1);\n      assert.ok(!(o2 instanceof ObjectIdd));\n\n      done();\n    });\n\n    it('optionally clones ObjectId constructors using its clone method', function(done) {\n      function ObjectID(id) {\n        this.id = id;\n        this.cloned = false;\n      }\n\n      ObjectID.prototype.clone = function() {\n        var ret = new ObjectID(this.id);\n        ret.cloned = true;\n        return ret;\n      };\n\n      var id = 1234;\n      var o1 = new ObjectID(id);\n      assert.equal(id, o1.id);\n      assert.equal(false, o1.cloned);\n\n      var o2 = utils.clone(o1);\n      assert.ok(o2 instanceof ObjectID);\n      assert.equal(id, o2.id);\n      assert.ok(o2.cloned);\n      done();\n    });\n\n    it('clones mongodb.ReadPreferences', function(done) {\n      if (!mongo) return done();\n\n      var tags = [\n        {dc: 'tag1'}\n      ];\n      var prefs = [\n        new mongo.ReadPreference('primary'),\n        new mongo.ReadPreference(mongo.ReadPreference.PRIMARY_PREFERRED),\n        new mongo.ReadPreference('secondary', tags)\n      ];\n\n      var prefsCloned = utils.clone(prefs);\n\n      for (var i = 0; i < prefsCloned.length; i++) {\n        assert.notEqual(prefs[i], prefsCloned[i]);\n        if (prefs[i].tags) {\n          assert.ok(prefsCloned[i].tags);\n          assert.notEqual(prefs[i].tags, prefsCloned[i].tags);\n          assert.notEqual(prefs[i].tags[0], prefsCloned[i].tags[0]);\n        } else {\n          assert.equal(prefsCloned[i].tags, null);\n        }\n      }\n\n      done();\n    });\n\n    it('clones mongodb.Binary', function(done) {\n      if (!mongo) return done();\n      var buf = Buffer.from('hi');\n      var binary = new mongo.Binary(buf, 2);\n      var clone = utils.clone(binary);\n      assert.equal(binary.sub_type, clone.sub_type);\n      assert.equal(String(binary.buffer), String(buf));\n      assert.ok(binary !== clone);\n      done();\n    });\n\n    it('handles objects with no constructor', function(done) {\n      var name = '335';\n\n      var o = Object.create(null);\n      o.name = name;\n\n      var clone;\n      assert.doesNotThrow(function() {\n        clone = utils.clone(o);\n      });\n\n      assert.equal(name, clone.name);\n      assert.ok(o != clone);\n      done();\n    });\n\n    it('handles buffers', function(done) {\n      var buff = Buffer.alloc(10);\n      buff.fill(1);\n      var clone = utils.clone(buff);\n\n      for (var i = 0; i < buff.length; i++) {\n        assert.equal(buff[i], clone[i]);\n      }\n\n      done();\n    });\n  });\n});\n"], "fixing_code": ["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Buffer = require('safe-buffer').Buffer;\nvar RegExpClone = require('regexp-clone');\n\nvar specialProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nvar clone = exports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return exports.cloneArray(obj, options);\n\n  if (obj.constructor) {\n    if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.id);\n    }\n\n    if (obj.constructor.name === 'ReadPreference') {\n      return new obj.constructor(obj.mode, clone(obj.tags, options));\n    }\n\n    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.value(true), obj.sub_type);\n    }\n\n    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n      return new obj.constructor(+obj);\n\n    if ('RegExp' === obj.constructor.name)\n      return RegExpClone(obj);\n\n    if ('Buffer' === obj.constructor.name)\n      return exports.cloneBuffer(obj);\n  }\n\n  if (isObject(obj))\n    return exports.cloneObject(obj, options);\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\n/*!\n * ignore\n */\n\nexports.cloneObject = function cloneObject(obj, options) {\n  var minimize = options && options.minimize;\n  var ret = {};\n  var hasKeys;\n  var val;\n  var k;\n\n  for (k in obj) {\n    // Not technically prototype pollution because this wouldn't merge properties\n    // onto `Object.prototype`, but avoid properties like __proto__ as a precaution.\n    if (specialProperties.indexOf(k) !== -1) {\n      continue;\n    }\n\n    val = clone(obj[k], options);\n\n    if (!minimize || ('undefined' !== typeof val)) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nexports.cloneArray = function cloneArray(arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps the given `callback` in a try/catch. If an error is\n * caught it will be thrown on nextTick.\n *\n * node-mongodb-native had a habit of state corruption when\n * an error was immediately thrown from within a collection\n * method (find, update, etc) callback.\n *\n * @param {Function} [callback]\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if ('function' !== typeof callback) return;\n  return function() {\n    // callbacks should always be fired on the next\n    // turn of the event loop. A side benefit is\n    // errors thrown from executing the callback\n    // will not cause drivers state to be corrupted\n    // which has historically been a problem.\n    var args = arguments;\n    soon(function() {\n      callback.apply(this, args);\n    });\n  };\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from) {\n  var keys = Object.keys(from),\n      i = keys.length,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    if (specialProperties.indexOf(key) !== -1) {\n      continue;\n    }\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      if (exports.isObject(from[key])) {\n        merge(to[key], from[key]);\n      } else {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.mergeClone = function mergeClone(to, from) {\n  var keys = Object.keys(from),\n      i = keys.length,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = clone(from[key]);\n    } else {\n      if (exports.isObject(from[key])) {\n        mergeClone(to[key], from[key]);\n      } else {\n        to[key] = clone(from[key]);\n      }\n    }\n  }\n};\n\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */\n\nexports.readPref = function readPref(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n\n\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */\n\nexports.readConcern = function readConcern(concern) {\n  if ('string' === typeof concern) {\n    switch (concern) {\n      case 'l':\n        concern = 'local';\n        break;\n      case 'a':\n        concern = 'available';\n        break;\n      case 'm':\n        concern = 'majority';\n        break;\n      case 'lz':\n        concern = 'linearizable';\n        break;\n      case 's':\n        concern = 'snapshot';\n        break;\n    }\n    concern = { level: concern };\n  }\n  return concern;\n};\n\n/**\n * Object.prototype.toString.call helper\n */\n\nvar _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n  return _toString.call(arg);\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */\n\nvar isObject = exports.isObject = function(arg) {\n  return '[object Object]' == exports.toString(arg);\n};\n\n/**\n * Determines if `arg` is an array.\n *\n * @param {Object}\n * @return {Boolean}\n * @see nodejs utils\n */\n\nexports.isArray = function(arg) {\n  return Array.isArray(arg) ||\n    'object' == typeof arg && '[object Array]' == exports.toString(arg);\n};\n\n/**\n * Object.keys helper\n */\n\nexports.keys = Object.keys || function(obj) {\n  var keys = [];\n  for (var k in obj) if (obj.hasOwnProperty(k)) {\n    keys.push(k);\n  }\n  return keys;\n};\n\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */\n\nexports.create = 'function' == typeof Object.create\n  ? Object.create\n  : create;\n\nfunction create(proto) {\n  if (arguments.length > 1) {\n    throw new Error('Adding properties is not supported');\n  }\n\n  function F() {}\n  F.prototype = proto;\n  return new F;\n}\n\n/**\n * inheritance\n */\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.prototype = exports.create(superCtor.prototype);\n  ctor.prototype.constructor = ctor;\n};\n\n/**\n * nextTick helper\n * compat with node 0.10 which behaves differently than previous versions\n */\n\nvar soon = exports.soon = 'function' == typeof setImmediate\n  ? setImmediate\n  : process.nextTick;\n\n/**\n * Clones the contents of a buffer.\n *\n * @param {Buffer} buff\n * @return {Buffer}\n */\n\nexports.cloneBuffer = function(buff) {\n  var dupe = Buffer.alloc(buff.length);\n  buff.copy(dupe, 0, 0, buff.length);\n  return dupe;\n};\n\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */\n\nexports.isArgumentsObject = function(v) {\n  return Object.prototype.toString.call(v) === '[object Arguments]';\n};\n", "'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar utils = require('../lib/utils');\nvar assert = require('assert');\nvar debug = require('debug');\n\nvar mongo;\ntry {\n  mongo = new require('mongodb');\n} catch (e) {\n  debug('mongo', 'cannot construct mongodb instance');\n}\n\ndescribe('lib/utils', function() {\n  describe('clone', function() {\n    it('clones constructors named ObjectId', function(done) {\n      function ObjectId(id) {\n        this.id = id;\n      }\n\n      var o1 = new ObjectId('1234');\n      var o2 = utils.clone(o1);\n      assert.ok(o2 instanceof ObjectId);\n\n      done();\n    });\n\n    it('clones constructors named ObjectID', function(done) {\n      function ObjectID(id) {\n        this.id = id;\n      }\n\n      var o1 = new ObjectID('1234');\n      var o2 = utils.clone(o1);\n\n      assert.ok(o2 instanceof ObjectID);\n      done();\n    });\n\n    it('does not clone constructors named ObjectIdd', function(done) {\n      function ObjectIdd(id) {\n        this.id = id;\n      }\n\n      var o1 = new ObjectIdd('1234');\n      var o2 = utils.clone(o1);\n      assert.ok(!(o2 instanceof ObjectIdd));\n\n      done();\n    });\n\n    it('optionally clones ObjectId constructors using its clone method', function(done) {\n      function ObjectID(id) {\n        this.id = id;\n        this.cloned = false;\n      }\n\n      ObjectID.prototype.clone = function() {\n        var ret = new ObjectID(this.id);\n        ret.cloned = true;\n        return ret;\n      };\n\n      var id = 1234;\n      var o1 = new ObjectID(id);\n      assert.equal(id, o1.id);\n      assert.equal(false, o1.cloned);\n\n      var o2 = utils.clone(o1);\n      assert.ok(o2 instanceof ObjectID);\n      assert.equal(id, o2.id);\n      assert.ok(o2.cloned);\n      done();\n    });\n\n    it('clones mongodb.ReadPreferences', function(done) {\n      if (!mongo) return done();\n\n      var tags = [\n        {dc: 'tag1'}\n      ];\n      var prefs = [\n        new mongo.ReadPreference('primary'),\n        new mongo.ReadPreference(mongo.ReadPreference.PRIMARY_PREFERRED),\n        new mongo.ReadPreference('secondary', tags)\n      ];\n\n      var prefsCloned = utils.clone(prefs);\n\n      for (var i = 0; i < prefsCloned.length; i++) {\n        assert.notEqual(prefs[i], prefsCloned[i]);\n        if (prefs[i].tags) {\n          assert.ok(prefsCloned[i].tags);\n          assert.notEqual(prefs[i].tags, prefsCloned[i].tags);\n          assert.notEqual(prefs[i].tags[0], prefsCloned[i].tags[0]);\n        } else {\n          assert.equal(prefsCloned[i].tags, null);\n        }\n      }\n\n      done();\n    });\n\n    it('clones mongodb.Binary', function(done) {\n      if (!mongo) return done();\n      var buf = Buffer.from('hi');\n      var binary = new mongo.Binary(buf, 2);\n      var clone = utils.clone(binary);\n      assert.equal(binary.sub_type, clone.sub_type);\n      assert.equal(String(binary.buffer), String(buf));\n      assert.ok(binary !== clone);\n      done();\n    });\n\n    it('handles objects with no constructor', function(done) {\n      var name = '335';\n\n      var o = Object.create(null);\n      o.name = name;\n\n      var clone;\n      assert.doesNotThrow(function() {\n        clone = utils.clone(o);\n      });\n\n      assert.equal(name, clone.name);\n      assert.ok(o != clone);\n      done();\n    });\n\n    it('handles buffers', function(done) {\n      var buff = Buffer.alloc(10);\n      buff.fill(1);\n      var clone = utils.clone(buff);\n\n      for (var i = 0; i < buff.length; i++) {\n        assert.equal(buff[i], clone[i]);\n      }\n\n      done();\n    });\n\n    it('skips __proto__', function() {\n      var payload = JSON.parse('{\"__proto__\": {\"polluted\": \"vulnerable\"}}');\n      var res = utils.clone(payload);\n\n      assert.strictEqual({}.polluted, void 0);\n      assert.strictEqual(res.__proto__, Object.prototype);\n    });\n  });\n\n  describe('merge', function() {\n    it('avoids prototype pollution', function() {\n      var payload = JSON.parse('{\"__proto__\": {\"polluted\": \"vulnerable\"}}');\n      var obj = {};\n      utils.merge(obj, payload);\n\n      assert.strictEqual({}.polluted, void 0);\n    });\n  });\n});\n"], "filenames": ["lib/utils.js", "test/utils.test.js"], "buggy_code_start_loc": [8, 142], "buggy_code_end_loc": [135, 142], "fixing_code_start_loc": [9, 143], "fixing_code_end_loc": [147, 161], "type": "NVD-CWE-noinfo", "message": "lib/utils.js in mquery before 3.2.3 allows a pollution attack because a special property (e.g., __proto__) can be copied during a merge or clone operation.", "other": {"cve": {"id": "CVE-2020-35149", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-11T19:15:12.887", "lastModified": "2020-12-14T21:12:17.593", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/utils.js in mquery before 3.2.3 allows a pollution attack because a special property (e.g., __proto__) can be copied during a merge or clone operation."}, {"lang": "es", "value": "En la biblioteca lib/utils.js en mquery versiones anteriores a 3.2.3, permite un ataque de contaminaci\u00f3n porque una propiedad especial (por ejemplo, __proto__) puede ser copiada durante una operaci\u00f3n de fusi\u00f3n o clonaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mquery_project:mquery:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.2.3", "matchCriteriaId": "EB1750B9-DBCB-4366-9F48-683888B57FCC"}]}]}], "references": [{"url": "https://github.com/aheckmann/mquery/commit/792e69fd0a7281a0300be5cade5a6d7c1d468ad4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/aheckmann/mquery/commit/792e69fd0a7281a0300be5cade5a6d7c1d468ad4"}}