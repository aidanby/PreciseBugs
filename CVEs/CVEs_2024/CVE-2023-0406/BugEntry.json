{"buggy_code": ["\"\"\"Identity related views.\"\"\"\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\n\nfrom modoboa.core.models import User\nfrom modoboa.lib.exceptions import BadRequest, PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom .. import signals\nfrom ..forms import AccountForm, AccountWizard\nfrom ..lib import get_identities\nfrom ..models import Domain, Mailbox\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\ndef _identities(request):\n    filters = {\n        fname: request.GET.get(fname, None)\n        for fname in [\"searchquery\", \"idtfilter\", \"grpfilter\"]\n    }\n    request.session[\"identities_filters\"] = filters\n    idents_list = get_identities(request.user, **filters)\n    sort_order, sort_dir = get_sort_order(request.GET, \"identity\",\n                                          [\"identity\", \"name_or_rcpt\", \"tags\"])\n    if sort_order in [\"identity\", \"name_or_rcpt\"]:\n        objects = sorted(idents_list, key=lambda o: getattr(o, sort_order),\n                         reverse=sort_dir == \"-\")\n    else:\n        objects = sorted(idents_list, key=lambda o: o.tags[0][\"label\"],\n                         reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False)\n    }\n    page = get_listing_page(objects, request.GET.get(\"page\", 1))\n    context[\"headers\"] = render_to_string(\n        \"admin/identity_headers.html\", {}, request)\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_table.html\", {\n                \"identities\": page.object_list\n            }, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_mailbox\")\ndef list_quotas(request):\n    from modoboa.lib.db_utils import db_type\n\n    sort_order, sort_dir = get_sort_order(request.GET, \"address\")\n    mboxes = Mailbox.objects.get_for_admin(\n        request.user, request.GET.get(\"searchquery\", None)\n    )\n    mboxes = mboxes.exclude(quota=0)\n    if sort_order in [\"address\", \"quota\"]:\n        mboxes = mboxes.order_by(\"%s%s\" % (sort_dir, sort_order))\n    elif sort_order in (\"quota_value__bytes\", \"quota_usage\"):\n        db_type = db_type()\n        if db_type == \"mysql\":\n            where = \"CONCAT(admin_mailbox.address,'@',admin_domain.name)\"\n        else:\n            where = \"admin_mailbox.address||'@'||admin_domain.name\"\n        if sort_order == \"quota_value__bytes\":\n            mboxes = mboxes.extra(\n                select={\"quota_value__bytes\": \"admin_quota.bytes\"},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n        else:\n            if db_type == \"postgres\":\n                select = (\n                    \"(admin_quota.bytes::float / (CAST(admin_mailbox.quota \"\n                    \"AS BIGINT) * 1048576)) * 100\"\n                )\n            else:\n                select = (\n                    \"(admin_quota.bytes * 1.0 / (admin_mailbox.quota \"\n                    \"* 1048576)) * 100\"\n                )\n            mboxes = mboxes.extra(\n                select={\"quota_usage\": select},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n    else:\n        raise BadRequest(_(\"Invalid request\"))\n    page = get_listing_page(mboxes, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/identities_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_quotas.html\", {\"mboxes\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\") or\n    u.has_perm(\"admin.add_mailbox\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the identity list.\"\"\"\n    if request.GET.get(\"objtype\", \"identity\") == \"identity\":\n        return _identities(request)\n    return list_quotas(request)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\n@ensure_csrf_cookie\ndef identities(request, tplname=\"admin/identities.html\"):\n    return render(request, tplname, {\n        \"selection\": \"identities\",\n        \"deflocation\": \"list/\"\n    })\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef accounts_list(request):\n    accs = User.objects.filter(is_superuser=False) \\\n        .exclude(groups__name=\"SimpleUsers\")\n    res = [a.username for a in accs.all()]\n    return render_to_json_response(res)\n\n\n@login_required\n@permission_required(\"core.add_user\")\n@reversion.create_revision()\ndef newaccount(request):\n    \"\"\"Create a new account.\"\"\"\n    return AccountWizard(request).process()\n\n\n@login_required\n@permission_required(\"core.change_user\")\n@reversion.create_revision()\ndef editaccount(request, pk):\n    account = User.objects.get(pk=pk)\n    if not request.user.can_access(account):\n        raise PermDeniedException\n    mb = account.mailbox if hasattr(account, \"mailbox\") else None\n\n    instances = {\n        \"general\": account, \"profile\": account, \"mail\": mb, \"perms\": account\n    }\n    results = signals.get_account_form_instances.send(\n        sender=\"editaccount\", user=request.user, account=account)\n    for result in results:\n        instances.update(result[1])\n    return AccountForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"core.delete_user\")\ndef delaccount(request, pk):\n    User.objects.get(pk=pk).delete()\n    return render_to_json_response(\n        ungettext(\"Account deleted\", \"Accounts deleted\", 1)\n    )\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\ndef remove_permission(request):\n    domid = request.GET.get(\"domid\", None)\n    daid = request.GET.get(\"daid\", None)\n    if domid is None or daid is None:\n        raise BadRequest(_(\"Invalid request\"))\n    try:\n        account = User.objects.get(pk=daid)\n        domain = Domain.objects.get(pk=domid)\n    except (User.DoesNotExist, Domain.DoesNotExist):\n        raise BadRequest(_(\"Invalid request\"))\n    if not request.user.can_access(account) or \\\n       not request.user.can_access(domain):\n        raise PermDeniedException\n    domain.remove_admin(account)\n    return render_to_json_response({})\n\n\nclass AccountDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Account.\"\"\"\n\n    model = User\n    permission_required = \"core.add_user\"\n    template_name = \"admin/account_detail.html\"\n\n    def has_permission(self):\n        \"\"\"Check object-level access.\"\"\"\n        result = super(AccountDetailView, self).has_permission()\n        if not result:\n            return result\n        return self.request.user.can_access(self.get_object())\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Add information to context.\"\"\"\n        context = super(AccountDetailView, self).get_context_data(**kwargs)\n        del context[\"user\"]\n        result = signals.extra_account_dashboard_widgets.send(\n            self.__class__, user=self.request.user, account=self.object)\n        context[\"templates\"] = {\"left\": [], \"right\": []}\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                context.update(widget[\"context\"])\n        if self.object.role in [\"Resellers\", \"DomainAdmins\"]:\n            context[\"domains\"] = Domain.objects.get_for_admin(self.object)\n        context[\"selection\"] = \"identities\"\n        return context\n"], "fixing_code": ["\"\"\"Identity related views.\"\"\"\n\nfrom reversion import revisions as reversion\n\nfrom django.contrib.auth import mixins as auth_mixins\nfrom django.contrib.auth.decorators import (\n    login_required, permission_required, user_passes_test\n)\nfrom django.shortcuts import render\nfrom django.template.loader import render_to_string\nfrom django.utils.translation import ugettext as _, ungettext\nfrom django.views import generic\nfrom django.views.decorators.csrf import ensure_csrf_cookie\nfrom django.views.decorators.http import require_http_methods\n\nfrom modoboa.core.models import User\nfrom modoboa.lib.exceptions import BadRequest, PermDeniedException\nfrom modoboa.lib.listing import get_listing_page, get_sort_order\nfrom modoboa.lib.web_utils import render_to_json_response\nfrom .. import signals\nfrom ..forms import AccountForm, AccountWizard\nfrom ..lib import get_identities\nfrom ..models import Domain, Mailbox\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\ndef _identities(request):\n    filters = {\n        fname: request.GET.get(fname, None)\n        for fname in [\"searchquery\", \"idtfilter\", \"grpfilter\"]\n    }\n    request.session[\"identities_filters\"] = filters\n    idents_list = get_identities(request.user, **filters)\n    sort_order, sort_dir = get_sort_order(request.GET, \"identity\",\n                                          [\"identity\", \"name_or_rcpt\", \"tags\"])\n    if sort_order in [\"identity\", \"name_or_rcpt\"]:\n        objects = sorted(idents_list, key=lambda o: getattr(o, sort_order),\n                         reverse=sort_dir == \"-\")\n    else:\n        objects = sorted(idents_list, key=lambda o: o.tags[0][\"label\"],\n                         reverse=sort_dir == \"-\")\n    context = {\n        \"handle_mailboxes\": request.localconfig.parameters.get_value(\n            \"handle_mailboxes\", raise_exception=False)\n    }\n    page = get_listing_page(objects, request.GET.get(\"page\", 1))\n    context[\"headers\"] = render_to_string(\n        \"admin/identity_headers.html\", {}, request)\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_table.html\", {\n                \"identities\": page.object_list\n            }, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@permission_required(\"admin.add_mailbox\")\ndef list_quotas(request):\n    from modoboa.lib.db_utils import db_type\n\n    sort_order, sort_dir = get_sort_order(request.GET, \"address\")\n    mboxes = Mailbox.objects.get_for_admin(\n        request.user, request.GET.get(\"searchquery\", None)\n    )\n    mboxes = mboxes.exclude(quota=0)\n    if sort_order in [\"address\", \"quota\"]:\n        mboxes = mboxes.order_by(\"%s%s\" % (sort_dir, sort_order))\n    elif sort_order in (\"quota_value__bytes\", \"quota_usage\"):\n        db_type = db_type()\n        if db_type == \"mysql\":\n            where = \"CONCAT(admin_mailbox.address,'@',admin_domain.name)\"\n        else:\n            where = \"admin_mailbox.address||'@'||admin_domain.name\"\n        if sort_order == \"quota_value__bytes\":\n            mboxes = mboxes.extra(\n                select={\"quota_value__bytes\": \"admin_quota.bytes\"},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n        else:\n            if db_type == \"postgres\":\n                select = (\n                    \"(admin_quota.bytes::float / (CAST(admin_mailbox.quota \"\n                    \"AS BIGINT) * 1048576)) * 100\"\n                )\n            else:\n                select = (\n                    \"(admin_quota.bytes * 1.0 / (admin_mailbox.quota \"\n                    \"* 1048576)) * 100\"\n                )\n            mboxes = mboxes.extra(\n                select={\"quota_usage\": select},\n                where=[\"admin_quota.username=%s\" % where],\n                tables=[\"admin_quota\", \"admin_domain\"],\n                order_by=[\"%s%s\" % (sort_dir, sort_order)]\n            )\n    else:\n        raise BadRequest(_(\"Invalid request\"))\n    page = get_listing_page(mboxes, request.GET.get(\"page\", 1))\n    context = {\n        \"headers\": render_to_string(\n            \"admin/identities_quota_headers.html\", {}, request\n        )\n    }\n    if page is None:\n        context[\"length\"] = 0\n    else:\n        context[\"rows\"] = render_to_string(\n            \"admin/identities_quotas.html\", {\"mboxes\": page}, request\n        )\n        context[\"pages\"] = [page.number]\n    return render_to_json_response(context)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\") or\n    u.has_perm(\"admin.add_mailbox\")\n)\ndef get_next_page(request):\n    \"\"\"Return the next page of the identity list.\"\"\"\n    if request.GET.get(\"objtype\", \"identity\") == \"identity\":\n        return _identities(request)\n    return list_quotas(request)\n\n\n@login_required\n@user_passes_test(\n    lambda u: u.has_perm(\"core.add_user\") or\n    u.has_perm(\"admin.add_alias\")\n)\n@ensure_csrf_cookie\ndef identities(request, tplname=\"admin/identities.html\"):\n    return render(request, tplname, {\n        \"selection\": \"identities\",\n        \"deflocation\": \"list/\"\n    })\n\n\n@login_required\n@permission_required(\"core.add_user\")\ndef accounts_list(request):\n    accs = User.objects.filter(is_superuser=False) \\\n        .exclude(groups__name=\"SimpleUsers\")\n    res = [a.username for a in accs.all()]\n    return render_to_json_response(res)\n\n\n@login_required\n@permission_required(\"core.add_user\")\n@reversion.create_revision()\ndef newaccount(request):\n    \"\"\"Create a new account.\"\"\"\n    return AccountWizard(request).process()\n\n\n@login_required\n@permission_required(\"core.change_user\")\n@reversion.create_revision()\ndef editaccount(request, pk):\n    account = User.objects.get(pk=pk)\n    if not request.user.can_access(account):\n        raise PermDeniedException\n    mb = account.mailbox if hasattr(account, \"mailbox\") else None\n\n    instances = {\n        \"general\": account, \"profile\": account, \"mail\": mb, \"perms\": account\n    }\n    results = signals.get_account_form_instances.send(\n        sender=\"editaccount\", user=request.user, account=account)\n    for result in results:\n        instances.update(result[1])\n    return AccountForm(request, instances=instances).process()\n\n\n@login_required\n@permission_required(\"core.delete_user\")\n@require_http_methods([\"POST\"])\ndef delaccount(request, pk):\n    User.objects.get(pk=pk).delete()\n    return render_to_json_response(\n        ungettext(\"Account deleted\", \"Accounts deleted\", 1)\n    )\n\n\n@login_required\n@permission_required(\"admin.add_domain\")\ndef remove_permission(request):\n    domid = request.GET.get(\"domid\", None)\n    daid = request.GET.get(\"daid\", None)\n    if domid is None or daid is None:\n        raise BadRequest(_(\"Invalid request\"))\n    try:\n        account = User.objects.get(pk=daid)\n        domain = Domain.objects.get(pk=domid)\n    except (User.DoesNotExist, Domain.DoesNotExist):\n        raise BadRequest(_(\"Invalid request\"))\n    if not request.user.can_access(account) or \\\n       not request.user.can_access(domain):\n        raise PermDeniedException\n    domain.remove_admin(account)\n    return render_to_json_response({})\n\n\nclass AccountDetailView(\n        auth_mixins.PermissionRequiredMixin, generic.DetailView):\n    \"\"\"DetailView for Account.\"\"\"\n\n    model = User\n    permission_required = \"core.add_user\"\n    template_name = \"admin/account_detail.html\"\n\n    def has_permission(self):\n        \"\"\"Check object-level access.\"\"\"\n        result = super(AccountDetailView, self).has_permission()\n        if not result:\n            return result\n        return self.request.user.can_access(self.get_object())\n\n    def get_context_data(self, **kwargs):\n        \"\"\"Add information to context.\"\"\"\n        context = super(AccountDetailView, self).get_context_data(**kwargs)\n        del context[\"user\"]\n        result = signals.extra_account_dashboard_widgets.send(\n            self.__class__, user=self.request.user, account=self.object)\n        context[\"templates\"] = {\"left\": [], \"right\": []}\n        for _receiver, widgets in result:\n            for widget in widgets:\n                context[\"templates\"][widget[\"column\"]].append(\n                    widget[\"template\"])\n                context.update(widget[\"context\"])\n        if self.object.role in [\"Resellers\", \"DomainAdmins\"]:\n            context[\"domains\"] = Domain.objects.get_for_admin(self.object)\n        context[\"selection\"] = \"identities\"\n        return context\n"], "filenames": ["modoboa/admin/views/identity.py"], "buggy_code_start_loc": [13], "buggy_code_end_loc": [187], "fixing_code_start_loc": [14], "fixing_code_end_loc": [190], "type": "CWE-352", "message": "Cross-Site Request Forgery (CSRF) in GitHub repository modoboa/modoboa prior to 2.0.4.", "other": {"cve": {"id": "CVE-2023-0406", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-19T18:15:15.437", "lastModified": "2023-01-27T15:00:10.163", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-Site Request Forgery (CSRF) in GitHub repository modoboa/modoboa prior to 2.0.4."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:modoboa:modoboa:*:*:*:*:*:modoboa:*:*", "versionEndExcluding": "2.0.4", "matchCriteriaId": "4781FBB6-EAE1-4AF9-A51F-5BEE3E8DFA16"}]}]}], "references": [{"url": "https://github.com/modoboa/modoboa/commit/7f0573e917227686d2cc127be1364e2908740807", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/d7007f76-3dbc-48a7-a2fb-377040fe100c", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/modoboa/modoboa/commit/7f0573e917227686d2cc127be1364e2908740807"}}