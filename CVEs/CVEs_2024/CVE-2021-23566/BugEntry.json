{"buggy_code": ["let crypto = require('crypto')\n\nlet { urlAlphabet } = require('./url-alphabet')\n\n// It is best to make fewer, larger requests to the crypto module to\n// avoid system call overhead. So, random numbers are generated in a\n// pool. The pool is a Buffer that is larger than the initial random\n// request size by this multiplier. The pool is enlarged if subsequent\n// requests exceed the maximum buffer size.\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\n\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\n\nlet random = bytes => {\n  fillPool(bytes)\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n  let step = Math.ceil((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (let i = 0; i < step; i++)`.\n      let i = step\n      while (i--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  fillPool(size)\n  let id = ''\n  // We are reading directly from the random pool to avoid creating new array\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n\nmodule.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n", "global.crypto = {\n  getRandomValues(array) {\n    for (let i = 0; i < array.length; i++) {\n      array[i] = Math.floor(Math.random() * 256)\n    }\n    return array\n  }\n}\n\nlet browser = require('../index.browser.js')\nlet node = require('../index.js')\n\nfor (let type of ['node', 'browser']) {\n  describe(`${type}`, () => {\n    let { nanoid, customAlphabet, customRandom, random, urlAlphabet } =\n      type === 'node' ? node : browser\n\n    describe('nanoid', () => {\n      it('generates URL-friendly IDs', () => {\n        for (let i = 0; i < 100; i++) {\n          let id = nanoid()\n          expect(id).toHaveLength(21)\n          expect(typeof id).toBe('string')\n          for (let char of id) {\n            expect(urlAlphabet).toContain(char)\n          }\n        }\n      })\n\n      it('changes ID length', () => {\n        expect(nanoid(10)).toHaveLength(10)\n      })\n\n      it('accepts string', () => {\n        expect(nanoid('10')).toHaveLength(10)\n      })\n\n      it('has no collisions', () => {\n        let used = {}\n        for (let i = 0; i < 50 * 1000; i++) {\n          let id = nanoid()\n          expect(used[id]).toBeUndefined()\n          used[id] = true\n        }\n      })\n\n      it('has flat distribution', () => {\n        let COUNT = 100 * 1000\n        let LENGTH = nanoid().length\n\n        let chars = {}\n        for (let i = 0; i < COUNT; i++) {\n          let id = nanoid()\n          for (let char of id) {\n            if (!chars[char]) chars[char] = 0\n            chars[char] += 1\n          }\n        }\n\n        expect(Object.keys(chars)).toHaveLength(urlAlphabet.length)\n\n        let max = 0\n        let min = Number.MAX_SAFE_INTEGER\n        for (let k in chars) {\n          let distribution = (chars[k] * urlAlphabet.length) / (COUNT * LENGTH)\n          if (distribution > max) max = distribution\n          if (distribution < min) min = distribution\n        }\n        expect(max - min).toBeLessThanOrEqual(0.05)\n      })\n    })\n\n    describe('customAlphabet', () => {\n      it('has options', () => {\n        let nanoidA = customAlphabet('a', 5)\n        expect(nanoidA()).toBe('aaaaa')\n      })\n\n      it('has flat distribution', () => {\n        let COUNT = 50 * 1000\n        let LENGTH = 30\n        let ALPHABET = 'abcdefghijklmnopqrstuvwxyz'\n        let nanoid2 = customAlphabet(ALPHABET, LENGTH)\n\n        let chars = {}\n        for (let i = 0; i < COUNT; i++) {\n          let id = nanoid2()\n          for (let char of id) {\n            if (!chars[char]) chars[char] = 0\n            chars[char] += 1\n          }\n        }\n\n        expect(Object.keys(chars)).toHaveLength(ALPHABET.length)\n\n        let max = 0\n        let min = Number.MAX_SAFE_INTEGER\n        for (let k in chars) {\n          let distribution = (chars[k] * ALPHABET.length) / (COUNT * LENGTH)\n          if (distribution > max) max = distribution\n          if (distribution < min) min = distribution\n        }\n        expect(max - min).toBeLessThanOrEqual(0.05)\n      })\n    })\n\n    describe('customRandom', () => {\n      it('supports generator', () => {\n        let sequence = [2, 255, 3, 7, 7, 7, 7, 7, 0, 1]\n        function fakeRandom(size) {\n          let bytes = []\n          for (let i = 0; i < size; i += sequence.length) {\n            bytes = bytes.concat(sequence.slice(0, size - i))\n          }\n          return bytes\n        }\n        let nanoid4 = customRandom('abcde', 4, fakeRandom)\n        let nanoid18 = customRandom('abcde', 18, fakeRandom)\n        expect(nanoid4()).toBe('adca')\n        expect(nanoid18()).toBe('cbadcbadcbadcbadcc')\n      })\n    })\n\n    describe('urlAlphabet', () => {\n      it('is string', () => {\n        expect(typeof urlAlphabet).toBe('string')\n      })\n\n      it('has no duplicates', () => {\n        for (let i = 0; i < urlAlphabet.length; i++) {\n          expect(urlAlphabet.lastIndexOf(urlAlphabet[i])).toEqual(i)\n        }\n      })\n    })\n\n    describe('random', () => {\n      it('generates small random buffers', () => {\n        expect(random(10)).toHaveLength(10)\n      })\n\n      it('generates random buffers', () => {\n        let numbers = {}\n        let bytes = random(10000)\n        expect(bytes).toHaveLength(10000)\n        for (let byte of bytes) {\n          if (!numbers[byte]) numbers[byte] = 0\n          numbers[byte] += 1\n          expect(typeof byte).toBe('number')\n          expect(byte).toBeLessThanOrEqual(255)\n          expect(byte).toBeGreaterThanOrEqual(0)\n        }\n      })\n    })\n  })\n}\n"], "fixing_code": ["let crypto = require('crypto')\n\nlet { urlAlphabet } = require('./url-alphabet')\n\n// It is best to make fewer, larger requests to the crypto module to\n// avoid system call overhead. So, random numbers are generated in a\n// pool. The pool is a Buffer that is larger than the initial random\n// request size by this multiplier. The pool is enlarged if subsequent\n// requests exceed the maximum buffer size.\nconst POOL_SIZE_MULTIPLIER = 128\nlet pool, poolOffset\n\nlet fillPool = bytes => {\n  if (!pool || pool.length < bytes) {\n    pool = Buffer.allocUnsafe(bytes * POOL_SIZE_MULTIPLIER)\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  } else if (poolOffset + bytes > pool.length) {\n    crypto.randomFillSync(pool)\n    poolOffset = 0\n  }\n  poolOffset += bytes\n}\n\nlet random = bytes => {\n  // `-=` convert `bytes` to number to prevent `valueOf` abusing\n  fillPool((bytes -= 0))\n  return pool.subarray(poolOffset - bytes, poolOffset)\n}\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  let mask = (2 << (31 - Math.clz32((alphabet.length - 1) | 1))) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n  let step = Math.ceil((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (let i = 0; i < step; i++)`.\n      let i = step\n      while (i--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[i] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  // `-=` convert `size` to number to prevent `valueOf` abusing\n  fillPool((size -= 0))\n  let id = ''\n  // We are reading directly from the random pool to avoid creating new array\n  for (let i = poolOffset - size; i < poolOffset; i++) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    id += urlAlphabet[pool[i] & 63]\n  }\n  return id\n}\n\nmodule.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n", "global.crypto = {\n  getRandomValues(array) {\n    for (let i = 0; i < array.length; i++) {\n      array[i] = Math.floor(Math.random() * 256)\n    }\n    return array\n  }\n}\n\nlet browser = require('../index.browser.js')\nlet node = require('../index.js')\n\nfor (let type of ['node', 'browser']) {\n  describe(`${type}`, () => {\n    let { nanoid, customAlphabet, customRandom, random, urlAlphabet } =\n      type === 'node' ? node : browser\n\n    describe('nanoid', () => {\n      it('generates URL-friendly IDs', () => {\n        for (let i = 0; i < 100; i++) {\n          let id = nanoid()\n          expect(id).toHaveLength(21)\n          expect(typeof id).toBe('string')\n          for (let char of id) {\n            expect(urlAlphabet).toContain(char)\n          }\n        }\n      })\n\n      it('changes ID length', () => {\n        expect(nanoid(10)).toHaveLength(10)\n      })\n\n      it('accepts string', () => {\n        expect(nanoid('10')).toHaveLength(10)\n      })\n\n      it('has no collisions', () => {\n        let used = {}\n        for (let i = 0; i < 50 * 1000; i++) {\n          let id = nanoid()\n          expect(used[id]).toBeUndefined()\n          used[id] = true\n        }\n      })\n\n      it('has flat distribution', () => {\n        let COUNT = 100 * 1000\n        let LENGTH = nanoid().length\n\n        let chars = {}\n        for (let i = 0; i < COUNT; i++) {\n          let id = nanoid()\n          for (let char of id) {\n            if (!chars[char]) chars[char] = 0\n            chars[char] += 1\n          }\n        }\n\n        expect(Object.keys(chars)).toHaveLength(urlAlphabet.length)\n\n        let max = 0\n        let min = Number.MAX_SAFE_INTEGER\n        for (let k in chars) {\n          let distribution = (chars[k] * urlAlphabet.length) / (COUNT * LENGTH)\n          if (distribution > max) max = distribution\n          if (distribution < min) min = distribution\n        }\n        expect(max - min).toBeLessThanOrEqual(0.05)\n      })\n    })\n\n    describe('customAlphabet', () => {\n      it('has options', () => {\n        let nanoidA = customAlphabet('a', 5)\n        expect(nanoidA()).toBe('aaaaa')\n      })\n\n      it('has flat distribution', () => {\n        let COUNT = 50 * 1000\n        let LENGTH = 30\n        let ALPHABET = 'abcdefghijklmnopqrstuvwxyz'\n        let nanoid2 = customAlphabet(ALPHABET, LENGTH)\n\n        let chars = {}\n        for (let i = 0; i < COUNT; i++) {\n          let id = nanoid2()\n          for (let char of id) {\n            if (!chars[char]) chars[char] = 0\n            chars[char] += 1\n          }\n        }\n\n        expect(Object.keys(chars)).toHaveLength(ALPHABET.length)\n\n        let max = 0\n        let min = Number.MAX_SAFE_INTEGER\n        for (let k in chars) {\n          let distribution = (chars[k] * ALPHABET.length) / (COUNT * LENGTH)\n          if (distribution > max) max = distribution\n          if (distribution < min) min = distribution\n        }\n        expect(max - min).toBeLessThanOrEqual(0.05)\n      })\n    })\n\n    describe('customRandom', () => {\n      it('supports generator', () => {\n        let sequence = [2, 255, 3, 7, 7, 7, 7, 7, 0, 1]\n        function fakeRandom(size) {\n          let bytes = []\n          for (let i = 0; i < size; i += sequence.length) {\n            bytes = bytes.concat(sequence.slice(0, size - i))\n          }\n          return bytes\n        }\n        let nanoid4 = customRandom('abcde', 4, fakeRandom)\n        let nanoid18 = customRandom('abcde', 18, fakeRandom)\n        expect(nanoid4()).toBe('adca')\n        expect(nanoid18()).toBe('cbadcbadcbadcbadcc')\n      })\n    })\n\n    describe('urlAlphabet', () => {\n      it('is string', () => {\n        expect(typeof urlAlphabet).toBe('string')\n      })\n\n      it('has no duplicates', () => {\n        for (let i = 0; i < urlAlphabet.length; i++) {\n          expect(urlAlphabet.lastIndexOf(urlAlphabet[i])).toEqual(i)\n        }\n      })\n    })\n\n    describe('random', () => {\n      it('generates small random buffers', () => {\n        expect(random(10)).toHaveLength(10)\n      })\n\n      it('generates random buffers', () => {\n        let numbers = {}\n        let bytes = random(10000)\n        expect(bytes).toHaveLength(10000)\n        for (let byte of bytes) {\n          if (!numbers[byte]) numbers[byte] = 0\n          numbers[byte] += 1\n          expect(typeof byte).toBe('number')\n          expect(byte).toBeLessThanOrEqual(255)\n          expect(byte).toBeGreaterThanOrEqual(0)\n        }\n      })\n    })\n\n    if (type === 'node') {\n      describe('proxy number', () => {\n        it('prevent collision', () => {\n          let makeProxyNumberToReproducePreviousID = () => {\n            let step = 0\n            return {\n              valueOf() {\n                // \"if (!pool || pool.length < bytes) {\"\n                if (step === 0) {\n                  step++\n                  return 0\n                }\n                // \"} else if (poolOffset + bytes > pool.length) {\"\n                if (step === 1) {\n                  step++\n                  return -Infinity\n                }\n                // \"poolOffset += bytes\"\n                if (step === 2) {\n                  step++\n                  return 0\n                }\n\n                return 21\n              }\n            }\n          }\n\n          let ID1 = nanoid()\n          let ID2 = nanoid(makeProxyNumberToReproducePreviousID())\n\n          expect(ID1).not.toBe(ID2)\n        })\n      })\n    }\n  })\n}\n"], "filenames": ["index.js", "test/index.test.js"], "buggy_code_start_loc": [26, 153], "buggy_code_end_loc": [69, 153], "fixing_code_start_loc": [26, 154], "fixing_code_end_loc": [71, 190], "type": "CWE-704", "message": "The package nanoid from 3.0.0 and before 3.1.31 are vulnerable to Information Exposure via the valueOf() function which allows to reproduce the last id generated.", "other": {"cve": {"id": "CVE-2021-23566", "sourceIdentifier": "report@snyk.io", "published": "2022-01-14T20:15:10.093", "lastModified": "2022-07-12T17:42:04.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package nanoid from 3.0.0 and before 3.1.31 are vulnerable to Information Exposure via the valueOf() function which allows to reproduce the last id generated."}, {"lang": "es", "value": "El paquete nanoid desde la versi\u00f3n 3.0.0 y antes de la versi\u00f3n 3.1.31, es vulnerable a una Exposici\u00f3n de Informaci\u00f3n por medio de la funci\u00f3n valueOf() que permite reproducir el \u00faltimo id generado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-704"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nanoid_project:nanoid:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.1.31", "matchCriteriaId": "6264B90E-B9A3-4BA7-9CF8-88C3994317BA"}]}]}], "references": [{"url": "https://gist.github.com/artalar/bc6d1eb9a3477d15d2772e876169a444", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/ai/nanoid/commit/2b7bd9332bc49b6330c7ddb08e5c661833db2575", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ai/nanoid/pull/328", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-2332550", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-NANOID-2332193", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ai/nanoid/commit/2b7bd9332bc49b6330c7ddb08e5c661833db2575"}}