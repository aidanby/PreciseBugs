{"buggy_code": ["\"\"\"Classes for manipulating bytestreams containing values that may be fixed-\nor variable-size.\n\"\"\"\n\nimport abc\nimport enum\nimport io\nimport struct\nimport types\nimport typing\nimport warnings\n\nfrom openssh_key import utils\n\n\nclass PascalStyleFormatInstruction(enum.Enum):\n    \"\"\"Format instructions for variable-length values that may appear in a\n    :py:class:`PascalStyleByteStream` representing an OpenSSH key, per\n    `RFC 4251 <https://tools.ietf.org/html/rfc4251#section-5>`_.\n    \"\"\"\n    BYTES = bytes\n    \"\"\"\n    A Python :py:class:`bytes`.\n    \"\"\"\n\n    STRING = str\n    \"\"\"\n    A Python :py:class:`str`.\n    \"\"\"\n\n    MPINT = int\n    \"\"\"\n    A big-endian, signed :py:class:`int` value.\n    \"\"\"\n\n\nclass PascalStyleFormatInstructionStringLengthSize(typing.NamedTuple):\n    \"\"\"A format instruction for a variable-length value, and the size,\n    in bytes, of the unsigned ``int`` prefix describing the value's length\n    in bytes.\n\n    Example:\n        Reading ``b'\\\\x00\\\\x00\\\\x03abc'`` with a\n        :any:`format_instruction` of\n        :any:`PascalStyleFormatInstruction.STRING` and a\n        :any:`string_length_size` of ``3`` yields a ``str``, viz.\n        ``'abc'``.\n    \"\"\"\n    format_instruction: PascalStyleFormatInstruction\n    \"\"\"The format instruction.\n    \"\"\"\n    string_length_size: int\n    \"\"\"The size of the length prefix.\n    \"\"\"\n\n\nFormatInstructionsDict = typing.Mapping[\n    str,\n    typing.Union[\n        str,\n        PascalStyleFormatInstruction,\n        PascalStyleFormatInstructionStringLengthSize\n    ]\n]\n\n\nValuesDict = typing.Mapping[\n    str,\n    typing.Any\n]\n\n\nclass PascalStyleByteStream(io.BytesIO):\n    \"\"\"Methods on :py:class:`io.BytesIO` that allow reading and writing values\n    either as ``struct`` values, or as Pascal-style values: variable-length\n    ``bytes``, ``str``, or variable-precision ``int`` values prefixed by the\n    length of such variable-length value.\n    \"\"\"\n\n    @staticmethod\n    def get_openssh_default_string_length_size() -> int:\n        \"\"\"\n        The value 4, the size in bytes used by OpenSSH for the ``int`` preceding\n        a variable-length value that indicates the length of the latter.\n        \"\"\"\n        return 4\n\n    OPENSSH_DEFAULT_STRING_LENGTH_SIZE = utils.readonly_static_property(\n        get_openssh_default_string_length_size\n    )\n    \"\"\"\n    The value 4, the size in bytes used by OpenSSH for the ``int`` preceding\n    a variable-length value that indicates the length of the latter.\n    \"\"\"\n\n    def read_from_format_instruction(\n        self,\n        format_instruction: typing.Union[str, PascalStyleFormatInstruction],\n        string_length_size: typing.Optional[int] = None\n    ) -> typing.Any:\n        \"\"\"Reads a value from the underlying bytestream according to a format\n        instruction.\n\n        Args:\n            format_instruction\n                A format instruction; either a ``struct``\n                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,\n                or a :any:`PascalStyleFormatInstruction`.\n            string_length_size\n                If ``format_instruction`` is a\n                :any:`PascalStyleFormatInstruction`, the size in bytes of the\n                ``int`` preceding the variable-length value that indicates the\n                length of the latter. Ignored otherwise. The default is 4,\n                which OpenSSH uses for encoding keys.\n\n        Returns:\n            The read value. If ``format_instruction`` is a ``struct``\n            format string, the value unpacked using\n            :py:func:`struct.unpack`; if ``format_instruction``\n            is a :any:`PascalStyleFormatInstruction`, the value converted\n            to the corresponding class.\n\n        Raises:\n            EOFError: The underlying bytestream does not contain enough bytes\n                to read a complete value according to ``format_instruction``.\n            ValueError: ``string_length_size`` is nonpositive.\n        \"\"\"\n        if string_length_size is None:\n            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE\n        if isinstance(format_instruction, str):\n            calcsize = struct.calcsize(format_instruction)\n            read_bytes = self.read_fixed_bytes(calcsize)\n            read_unpack = struct.unpack(format_instruction, read_bytes)\n            if len(read_unpack) == 1:\n                return read_unpack[0]\n            return read_unpack\n        elif isinstance(format_instruction, PascalStyleFormatInstruction):\n            read_bytes = self.read_pascal_bytes(string_length_size)\n            if format_instruction == PascalStyleFormatInstruction.BYTES:\n                return read_bytes\n            elif format_instruction == PascalStyleFormatInstruction.STRING:\n                return read_bytes.decode()\n            elif format_instruction == PascalStyleFormatInstruction.MPINT:\n                return int.from_bytes(\n                    read_bytes,\n                    byteorder='big',\n                    signed=True\n                )\n        raise NotImplementedError()\n\n    def read_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict\n    ) -> ValuesDict:\n        \"\"\"Reads values from the underlying bytestream according to a\n        :py:class:`typing.Mapping` of format instructions.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n\n        Returns:\n            A :py:class:`typing.Mapping` of value names to read values, as\n            per :any:`read_from_format_instruction`.\n\n        Raises:\n            EOFError: The underlying bytestream does not contain enough bytes\n                to read a complete value for one of the format instructions in\n                ``format_instructions_dict``.\n        \"\"\"\n        return {\n            k: (\n                self.read_from_format_instruction(\n                    format_instruction.format_instruction,\n                    format_instruction.string_length_size\n                ) if isinstance(\n                    format_instruction,\n                    PascalStyleFormatInstructionStringLengthSize\n                )\n                else self.read_from_format_instruction(format_instruction)\n            )\n            for k, format_instruction in format_instructions_dict.items()\n        }\n\n    def read_repeatedly_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict\n    ) -> typing.List[typing.Any]:\n        \"\"\"Reads values repeatedly as per\n        :any:`read_from_format_instructions_dict` until the stream is\n        exhausted.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n\n        Returns:\n            A :py:class:`typing.List` of :py:class:`typing.Mapping` of value\n            names to read values.\n\n        Raises:\n            EOFError: The underlying bytestream does not contain enough bytes\n                to read a complete value for one of the format instructions in\n                ``format_instructions_dict``.\n        \"\"\"\n        if len(format_instructions_dict) == 0:\n            raise ValueError('format_instructions_dict cannot be empty')\n        l = []\n        while True:\n            try:\n                l.append(\n                    self.read_from_format_instructions_dict(\n                        format_instructions_dict\n                    )\n                )\n            except EOFError as e:\n                if len(e.args[0]) == 0:\n                    return l\n                raise\n\n    def read_fixed_bytes(self, num_bytes: int) -> bytes:\n        \"\"\"Reads a fixed number of bytes from the underlying bytestream.\n\n        Args:\n            num_bytes\n                The number of bytes to read.\n\n        Returns:\n            The read bytes.\n\n        Raises:\n            EOFError: Fewer than ``num_bytes`` bytes remained in the\n                underlying bytestream.\n        \"\"\"\n        read_bytes = self.read(num_bytes)\n        if len(read_bytes) < num_bytes:\n            raise EOFError(read_bytes)\n        return read_bytes\n\n    def read_pascal_bytes(self, string_length_size: int) -> bytes:\n        \"\"\"Reads a Pascal-style byte string from the underlying bytestream,\n        given the size of the length prefix.\n\n        Args:\n            string_length_size\n                The size of the big-endian unsigned ``int`` prefix that\n                indicates the length of the byte string to read.\n\n        Returns:\n            The read byte string.\n\n        Raises:\n            EOFError: Fewer than ``string_length_size`` bytes remained in the\n                underlying bytestream, or the length prefix exceeds the number\n                of bytes remaining in the underlying bytestream.\n            ValueError: ``string_length_size`` is nonpositive.\n        \"\"\"\n        if string_length_size <= 0:\n            raise ValueError('string_length_size must be positive')\n        length = int.from_bytes(\n            self.read_fixed_bytes(string_length_size),\n            byteorder='big'\n        )\n        return self.read_fixed_bytes(length)\n\n    def write_from_format_instruction(\n        self,\n        format_instruction: typing.Union[str, PascalStyleFormatInstruction],\n        value: typing.Any,\n        string_length_size: typing.Optional[int] = None\n    ) -> None:\n        \"\"\"Writes a value to the underlying bytestream according to a format\n        instruction.\n\n        Args:\n            format_instruction\n                A format instruction; either a ``struct``\n                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,\n                or a :any:`PascalStyleFormatInstruction`.\n            value\n                The value to write.\n            string_length_size\n                If ``format_instruction`` is a\n                :any:`PascalStyleFormatInstruction`, the size in bytes of the\n                ``int`` preceding the variable-length value that indicates the\n                length of the latter. Ignored otherwise. The default is 4,\n                which OpenSSH uses for encoding keys.\n        \"\"\"\n        if string_length_size is None:\n            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE\n        write_bytes = None\n        if isinstance(format_instruction, str):\n            write_bytes = struct.pack(format_instruction, value)\n        elif isinstance(format_instruction, PascalStyleFormatInstruction):\n            if format_instruction == PascalStyleFormatInstruction.BYTES:\n                if not isinstance(value, bytes):\n                    raise ValueError(\n                        'value must be a bytes instance for bytes '\n                        'format instruction'\n                    )\n                write_bytes = value\n            elif format_instruction == PascalStyleFormatInstruction.STRING:\n                if not isinstance(value, str):\n                    raise ValueError(\n                        'value must be a str instance for string '\n                        'format instruction'\n                    )\n                write_bytes = value.encode()\n            elif format_instruction == PascalStyleFormatInstruction.MPINT:\n                if not isinstance(value, int):\n                    raise ValueError(\n                        'value must be an int instance for mpint '\n                        'format instruction'\n                    )\n                write_bytes = value.to_bytes(\n                    length=(value.bit_length() + (8 if value > 0 else 7)) // 8,\n                    byteorder='big',\n                    signed=True\n                )\n            else:\n                raise NotImplementedError()\n            write_bytes_len_bytes = len(write_bytes).to_bytes(\n                length=string_length_size,\n                byteorder='big',\n                signed=False\n            )\n            write_bytes = write_bytes_len_bytes + write_bytes\n        else:\n            raise NotImplementedError()\n        self.write(write_bytes)\n\n    def write_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict,\n        values_dict: ValuesDict\n    ) -> None:\n        \"\"\"Writes values to the underlying bytestream according to a\n        :py:class:`typing.Mapping` of format instructions.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n            values_dict\n                A :py:class:`typing.Mapping` of value names to values to\n                be written.\n\n        Raises:\n            KeyError: ``values_dict`` does not contain a key that is\n                contained in ``format_instructions_dict``.\n        \"\"\"\n        for k, format_instruction in format_instructions_dict.items():\n            if isinstance(\n                format_instruction,\n                PascalStyleFormatInstructionStringLengthSize\n            ):\n                self.write_from_format_instruction(\n                    format_instruction.format_instruction,\n                    values_dict[k],\n                    format_instruction.string_length_size\n                )\n            else:\n                self.write_from_format_instruction(\n                    format_instruction,\n                    values_dict[k]\n                )\n\n    def write_repeatedly_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict,\n        values_dicts: typing.Sequence[ValuesDict]\n    ) -> None:\n        \"\"\"Writes a list of values to the underlying bytestream as per\n        :any:`write_from_format_instructions_dict`.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n            values_dicts\n                A :py:class:`typing.List` of :py:class:`typing.Mapping`\n                of value names to values to be written.\n\n        Raises:\n            KeyError: One of the ``values_dicts`` does not contain a key that is\n                contained in ``format_instructions_dict``.\n        \"\"\"\n        for values_dict in values_dicts:\n            self.write_from_format_instructions_dict(\n                format_instructions_dict,\n                values_dict\n            )\n\n    @staticmethod\n    def check_dict_matches_format_instructions_dict(\n        target_dict: ValuesDict,\n        format_instructions_dict: FormatInstructionsDict\n    ) -> None:\n        \"\"\"Checks whether a given set of values can validly be passed to\n        :any:`write_from_format_instructions_dict` for given format\n        instructions.\n\n        Args:\n            target_dict\n                A :py:class:`typing.Mapping` of value names to values to\n                be checked.\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n\n        Raises:\n            UserWarning: A key is missing from ``target_dict`` that is present\n                in ``format_instructions_dict``, or the type or struct size of\n                a value for a key in ``target_dict`` does not match that\n                proscribed for that key in ``format_instructions_dict``.\n        \"\"\"\n        for k, v in format_instructions_dict.items():\n            if k not in target_dict:\n                warnings.warn(k + ' missing')\n            elif isinstance(v, str):\n                try:\n                    struct.pack(v, target_dict[k])\n                except struct.error:\n                    warnings.warn(\n                        k + ' should be formatted as ' + v\n                    )\n            elif isinstance(v, PascalStyleFormatInstruction):\n                if not isinstance(target_dict[k], v.value):\n                    warnings.warn(\n                        k + ' should be of class ' + str(v.value.__name__)\n                    )\n            elif isinstance(v, PascalStyleFormatInstructionStringLengthSize):\n                if not isinstance(target_dict[k], v.format_instruction.value):\n                    warnings.warn(\n                        k + ' should be of class ' +\n                            str(v.format_instruction.value.__name__)\n                    )\n            else:\n                raise NotImplementedError()\n\n\nclass PascalStyleDict(utils.BaseDict, abc.ABC):\n    def __init__(self, params: ValuesDict):\n        super().__init__(params)\n        self.check_params_are_valid()\n\n    __FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[FormatInstructionsDict] = {}\n\n    @classmethod\n    @abc.abstractmethod\n    def get_format_instructions_dict(cls) -> FormatInstructionsDict:\n        return types.MappingProxyType(\n            PascalStyleDict.__FORMAT_INSTRUCTIONS_DICT\n        )\n\n    FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(\n        get_format_instructions_dict\n    )\n\n    def check_params_are_valid(self) -> None:\n        PascalStyleByteStream.check_dict_matches_format_instructions_dict(\n            self.data,\n            self.FORMAT_INSTRUCTIONS_DICT\n        )\n"], "fixing_code": ["\"\"\"Classes for manipulating bytestreams containing values that may be fixed-\nor variable-size.\n\"\"\"\n\nimport abc\nimport enum\nimport io\nimport struct\nimport types\nimport typing\nimport warnings\n\nfrom openssh_key import utils\n\n\nclass PascalStyleFormatInstruction(enum.Enum):\n    \"\"\"Format instructions for variable-length values that may appear in a\n    :py:class:`PascalStyleByteStream` representing an OpenSSH key, per\n    `RFC 4251 <https://tools.ietf.org/html/rfc4251#section-5>`_.\n    \"\"\"\n    BYTES = bytes\n    \"\"\"\n    A Python :py:class:`bytes`.\n    \"\"\"\n\n    STRING = str\n    \"\"\"\n    A Python :py:class:`str`.\n    \"\"\"\n\n    MPINT = int\n    \"\"\"\n    A big-endian, signed :py:class:`int` value.\n    \"\"\"\n\n\nclass PascalStyleFormatInstructionStringLengthSize(typing.NamedTuple):\n    \"\"\"A format instruction for a variable-length value, and the size,\n    in bytes, of the unsigned ``int`` prefix describing the value's length\n    in bytes.\n\n    Example:\n        Reading ``b'\\\\x00\\\\x00\\\\x03abc'`` with a\n        :any:`format_instruction` of\n        :any:`PascalStyleFormatInstruction.STRING` and a\n        :any:`string_length_size` of ``3`` yields a ``str``, viz.\n        ``'abc'``.\n    \"\"\"\n    format_instruction: PascalStyleFormatInstruction\n    \"\"\"The format instruction.\n    \"\"\"\n    string_length_size: int\n    \"\"\"The size of the length prefix.\n    \"\"\"\n\n\nFormatInstructionsDict = typing.Mapping[\n    str,\n    typing.Union[\n        str,\n        PascalStyleFormatInstruction,\n        PascalStyleFormatInstructionStringLengthSize\n    ]\n]\n\n\nValuesDict = typing.Mapping[\n    str,\n    typing.Any\n]\n\n\nclass PascalStyleByteStream(io.BytesIO):\n    \"\"\"Methods on :py:class:`io.BytesIO` that allow reading and writing values\n    either as ``struct`` values, or as Pascal-style values: variable-length\n    ``bytes``, ``str``, or variable-precision ``int`` values prefixed by the\n    length of such variable-length value.\n    \"\"\"\n\n    @staticmethod\n    def get_openssh_default_string_length_size() -> int:\n        \"\"\"\n        The value 4, the size in bytes used by OpenSSH for the ``int`` preceding\n        a variable-length value that indicates the length of the latter.\n        \"\"\"\n        return 4\n\n    OPENSSH_DEFAULT_STRING_LENGTH_SIZE = utils.readonly_static_property(\n        get_openssh_default_string_length_size\n    )\n    \"\"\"\n    The value 4, the size in bytes used by OpenSSH for the ``int`` preceding\n    a variable-length value that indicates the length of the latter.\n    \"\"\"\n\n    def read_from_format_instruction(\n        self,\n        format_instruction: typing.Union[str, PascalStyleFormatInstruction],\n        string_length_size: typing.Optional[int] = None\n    ) -> typing.Any:\n        \"\"\"Reads a value from the underlying bytestream according to a format\n        instruction.\n\n        Args:\n            format_instruction\n                A format instruction; either a ``struct``\n                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,\n                or a :any:`PascalStyleFormatInstruction`.\n            string_length_size\n                If ``format_instruction`` is a\n                :any:`PascalStyleFormatInstruction`, the size in bytes of the\n                ``int`` preceding the variable-length value that indicates the\n                length of the latter. Ignored otherwise. The default is 4,\n                which OpenSSH uses for encoding keys.\n\n        Returns:\n            The read value. If ``format_instruction`` is a ``struct``\n            format string, the value unpacked using\n            :py:func:`struct.unpack`; if ``format_instruction``\n            is a :any:`PascalStyleFormatInstruction`, the value converted\n            to the corresponding class.\n\n        Raises:\n            EOFError: The underlying bytestream does not contain enough bytes\n                to read a complete value according to ``format_instruction``.\n            ValueError: ``string_length_size`` is nonpositive.\n        \"\"\"\n        if string_length_size is None:\n            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE\n        if isinstance(format_instruction, str):\n            calcsize = struct.calcsize(format_instruction)\n            read_bytes = self.read_fixed_bytes(calcsize)\n            read_unpack = struct.unpack(format_instruction, read_bytes)\n            if len(read_unpack) == 1:\n                return read_unpack[0]\n            return read_unpack\n        elif isinstance(format_instruction, PascalStyleFormatInstruction):\n            read_bytes = self.read_pascal_bytes(string_length_size)\n            if format_instruction == PascalStyleFormatInstruction.BYTES:\n                return read_bytes\n            elif format_instruction == PascalStyleFormatInstruction.STRING:\n                return read_bytes.decode()\n            elif format_instruction == PascalStyleFormatInstruction.MPINT:\n                return int.from_bytes(\n                    read_bytes,\n                    byteorder='big',\n                    signed=True\n                )\n        raise NotImplementedError()\n\n    def read_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict\n    ) -> ValuesDict:\n        \"\"\"Reads values from the underlying bytestream according to a\n        :py:class:`typing.Mapping` of format instructions.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n\n        Returns:\n            A :py:class:`typing.Mapping` of value names to read values, as\n            per :any:`read_from_format_instruction`.\n\n        Raises:\n            EOFError: The underlying bytestream does not contain enough bytes\n                to read a complete value for one of the format instructions in\n                ``format_instructions_dict``.\n        \"\"\"\n        return {\n            k: (\n                self.read_from_format_instruction(\n                    format_instruction.format_instruction,\n                    format_instruction.string_length_size\n                ) if isinstance(\n                    format_instruction,\n                    PascalStyleFormatInstructionStringLengthSize\n                )\n                else self.read_from_format_instruction(format_instruction)\n            )\n            for k, format_instruction in format_instructions_dict.items()\n        }\n\n    def read_repeatedly_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict\n    ) -> typing.List[typing.Any]:\n        \"\"\"Reads values repeatedly as per\n        :any:`read_from_format_instructions_dict` until the stream is\n        exhausted.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n\n        Returns:\n            A :py:class:`typing.List` of :py:class:`typing.Mapping` of value\n            names to read values.\n\n        Raises:\n            EOFError: The underlying bytestream does not contain enough bytes\n                to read a complete value for one of the format instructions in\n                ``format_instructions_dict``.\n        \"\"\"\n        if len(format_instructions_dict) == 0:\n            raise ValueError('format_instructions_dict cannot be empty')\n        l = []\n        while True:\n            try:\n                l.append(\n                    self.read_from_format_instructions_dict(\n                        format_instructions_dict\n                    )\n                )\n            except EOFError as e:\n                if len(e.args[0]) == 0:\n                    return l\n                raise\n\n    def read_fixed_bytes(self, num_bytes: int) -> bytes:\n        \"\"\"Reads a fixed number of bytes from the underlying bytestream.\n\n        Args:\n            num_bytes\n                The number of bytes to read.\n\n        Returns:\n            The read bytes.\n\n        Raises:\n            EOFError: Fewer than ``num_bytes`` bytes remained in the\n                underlying bytestream.\n        \"\"\"\n        read_bytes = self.read(num_bytes)\n        if len(read_bytes) < num_bytes:\n            raise EOFError(\"Fewer than 'num_bytes' bytes remaining in the \"\n                    \"underlying bytestream\")\n        return read_bytes\n\n    def read_pascal_bytes(self, string_length_size: int) -> bytes:\n        \"\"\"Reads a Pascal-style byte string from the underlying bytestream,\n        given the size of the length prefix.\n\n        Args:\n            string_length_size\n                The size of the big-endian unsigned ``int`` prefix that\n                indicates the length of the byte string to read.\n\n        Returns:\n            The read byte string.\n\n        Raises:\n            EOFError: Fewer than ``string_length_size`` bytes remained in the\n                underlying bytestream, or the length prefix exceeds the number\n                of bytes remaining in the underlying bytestream.\n            ValueError: ``string_length_size`` is nonpositive.\n        \"\"\"\n        if string_length_size <= 0:\n            raise ValueError('string_length_size must be positive')\n        length = int.from_bytes(\n            self.read_fixed_bytes(string_length_size),\n            byteorder='big'\n        )\n        return self.read_fixed_bytes(length)\n\n    def write_from_format_instruction(\n        self,\n        format_instruction: typing.Union[str, PascalStyleFormatInstruction],\n        value: typing.Any,\n        string_length_size: typing.Optional[int] = None\n    ) -> None:\n        \"\"\"Writes a value to the underlying bytestream according to a format\n        instruction.\n\n        Args:\n            format_instruction\n                A format instruction; either a ``struct``\n                `format string <https://docs.python.org/3/library/struct.html#format-strings>`_,\n                or a :any:`PascalStyleFormatInstruction`.\n            value\n                The value to write.\n            string_length_size\n                If ``format_instruction`` is a\n                :any:`PascalStyleFormatInstruction`, the size in bytes of the\n                ``int`` preceding the variable-length value that indicates the\n                length of the latter. Ignored otherwise. The default is 4,\n                which OpenSSH uses for encoding keys.\n        \"\"\"\n        if string_length_size is None:\n            string_length_size = PascalStyleByteStream.OPENSSH_DEFAULT_STRING_LENGTH_SIZE\n        write_bytes = None\n        if isinstance(format_instruction, str):\n            write_bytes = struct.pack(format_instruction, value)\n        elif isinstance(format_instruction, PascalStyleFormatInstruction):\n            if format_instruction == PascalStyleFormatInstruction.BYTES:\n                if not isinstance(value, bytes):\n                    raise ValueError(\n                        'value must be a bytes instance for bytes '\n                        'format instruction'\n                    )\n                write_bytes = value\n            elif format_instruction == PascalStyleFormatInstruction.STRING:\n                if not isinstance(value, str):\n                    raise ValueError(\n                        'value must be a str instance for string '\n                        'format instruction'\n                    )\n                write_bytes = value.encode()\n            elif format_instruction == PascalStyleFormatInstruction.MPINT:\n                if not isinstance(value, int):\n                    raise ValueError(\n                        'value must be an int instance for mpint '\n                        'format instruction'\n                    )\n                write_bytes = value.to_bytes(\n                    length=(value.bit_length() + (8 if value > 0 else 7)) // 8,\n                    byteorder='big',\n                    signed=True\n                )\n            else:\n                raise NotImplementedError()\n            write_bytes_len_bytes = len(write_bytes).to_bytes(\n                length=string_length_size,\n                byteorder='big',\n                signed=False\n            )\n            write_bytes = write_bytes_len_bytes + write_bytes\n        else:\n            raise NotImplementedError()\n        self.write(write_bytes)\n\n    def write_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict,\n        values_dict: ValuesDict\n    ) -> None:\n        \"\"\"Writes values to the underlying bytestream according to a\n        :py:class:`typing.Mapping` of format instructions.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n            values_dict\n                A :py:class:`typing.Mapping` of value names to values to\n                be written.\n\n        Raises:\n            KeyError: ``values_dict`` does not contain a key that is\n                contained in ``format_instructions_dict``.\n        \"\"\"\n        for k, format_instruction in format_instructions_dict.items():\n            if isinstance(\n                format_instruction,\n                PascalStyleFormatInstructionStringLengthSize\n            ):\n                self.write_from_format_instruction(\n                    format_instruction.format_instruction,\n                    values_dict[k],\n                    format_instruction.string_length_size\n                )\n            else:\n                self.write_from_format_instruction(\n                    format_instruction,\n                    values_dict[k]\n                )\n\n    def write_repeatedly_from_format_instructions_dict(\n        self,\n        format_instructions_dict: FormatInstructionsDict,\n        values_dicts: typing.Sequence[ValuesDict]\n    ) -> None:\n        \"\"\"Writes a list of values to the underlying bytestream as per\n        :any:`write_from_format_instructions_dict`.\n\n        Args:\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n            values_dicts\n                A :py:class:`typing.List` of :py:class:`typing.Mapping`\n                of value names to values to be written.\n\n        Raises:\n            KeyError: One of the ``values_dicts`` does not contain a key that is\n                contained in ``format_instructions_dict``.\n        \"\"\"\n        for values_dict in values_dicts:\n            self.write_from_format_instructions_dict(\n                format_instructions_dict,\n                values_dict\n            )\n\n    @staticmethod\n    def check_dict_matches_format_instructions_dict(\n        target_dict: ValuesDict,\n        format_instructions_dict: FormatInstructionsDict\n    ) -> None:\n        \"\"\"Checks whether a given set of values can validly be passed to\n        :any:`write_from_format_instructions_dict` for given format\n        instructions.\n\n        Args:\n            target_dict\n                A :py:class:`typing.Mapping` of value names to values to\n                be checked.\n            format_instructions_dict\n                A :py:class:`typing.Mapping` of value names to format\n                instructions.\n\n        Raises:\n            UserWarning: A key is missing from ``target_dict`` that is present\n                in ``format_instructions_dict``, or the type or struct size of\n                a value for a key in ``target_dict`` does not match that\n                proscribed for that key in ``format_instructions_dict``.\n        \"\"\"\n        for k, v in format_instructions_dict.items():\n            if k not in target_dict:\n                warnings.warn(k + ' missing')\n            elif isinstance(v, str):\n                try:\n                    struct.pack(v, target_dict[k])\n                except struct.error:\n                    warnings.warn(\n                        k + ' should be formatted as ' + v\n                    )\n            elif isinstance(v, PascalStyleFormatInstruction):\n                if not isinstance(target_dict[k], v.value):\n                    warnings.warn(\n                        k + ' should be of class ' + str(v.value.__name__)\n                    )\n            elif isinstance(v, PascalStyleFormatInstructionStringLengthSize):\n                if not isinstance(target_dict[k], v.format_instruction.value):\n                    warnings.warn(\n                        k + ' should be of class ' +\n                            str(v.format_instruction.value.__name__)\n                    )\n            else:\n                raise NotImplementedError()\n\n\nclass PascalStyleDict(utils.BaseDict, abc.ABC):\n    def __init__(self, params: ValuesDict):\n        super().__init__(params)\n        self.check_params_are_valid()\n\n    __FORMAT_INSTRUCTIONS_DICT: typing.ClassVar[FormatInstructionsDict] = {}\n\n    @classmethod\n    @abc.abstractmethod\n    def get_format_instructions_dict(cls) -> FormatInstructionsDict:\n        return types.MappingProxyType(\n            PascalStyleDict.__FORMAT_INSTRUCTIONS_DICT\n        )\n\n    FORMAT_INSTRUCTIONS_DICT = utils.readonly_static_property(\n        get_format_instructions_dict\n    )\n\n    def check_params_are_valid(self) -> None:\n        PascalStyleByteStream.check_dict_matches_format_instructions_dict(\n            self.data,\n            self.FORMAT_INSTRUCTIONS_DICT\n        )\n"], "filenames": ["openssh_key/pascal_style_byte_stream.py"], "buggy_code_start_loc": [239], "buggy_code_end_loc": [240], "fixing_code_start_loc": [239], "fixing_code_end_loc": [241], "type": "CWE-209", "message": "openssh_key_parser is an open source Python package providing utilities to parse and pack OpenSSH private and public key files. In versions prior to 0.0.6 if a field of a key is shorter than it is declared to be, the parser raises an error with a message containing the raw field value. An attacker able to modify the declared length of a key's sensitive field can thus expose the raw value of that field. Users are advised to upgrade to version 0.0.6, which no longer includes the raw field value in the error message. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-31124", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-06T18:15:19.290", "lastModified": "2022-07-14T14:22:04.957", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "openssh_key_parser is an open source Python package providing utilities to parse and pack OpenSSH private and public key files. In versions prior to 0.0.6 if a field of a key is shorter than it is declared to be, the parser raises an error with a message containing the raw field value. An attacker able to modify the declared length of a key's sensitive field can thus expose the raw value of that field. Users are advised to upgrade to version 0.0.6, which no longer includes the raw field value in the error message. There are no known workarounds for this issue."}, {"lang": "es", "value": "openssh_key_parser es un paquete de c\u00f3digo abierto de Python que proporciona utilidades para analizar y empaquetar archivos de clave p\u00fablica y privada de OpenSSH. En versiones anteriores a 0.0.6, si un campo de una clave es m\u00e1s corto de lo que se declara, el analizador genera un error con un mensaje que contiene el valor del campo en bruto. Un atacante capaz de modificar la longitud declarada del campo confidencial de una clave puede as\u00ed exponer el valor bruto de ese campo. Es recomendado a usuarios actualizar a versi\u00f3n 0.0.6, que ya no incluye el valor bruto del campo en el mensaje de error. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-209"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-209"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openssh_key_parser_project:openssh_key_parser:*:*:*:*:*:python:*:*", "versionEndExcluding": "0.0.6", "matchCriteriaId": "EBB0728B-4846-443F-B4E1-4FF1A0A615C1"}]}]}], "references": [{"url": "https://github.com/scottcwang/openssh_key_parser/commit/26e0a471e9fdb23e635bc3014cf4cbd2323a08d3", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/scottcwang/openssh_key_parser/commit/274447f91b4037b7050ae634879b657554523b39", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/scottcwang/openssh_key_parser/commit/d5b53b4b7e76c5b666fc657019dbf864fb04076c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/scottcwang/openssh_key_parser/pull/5", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/scottcwang/openssh_key_parser/security/advisories/GHSA-hm37-9xh2-q499", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/scottcwang/openssh_key_parser/commit/26e0a471e9fdb23e635bc3014cf4cbd2323a08d3"}}