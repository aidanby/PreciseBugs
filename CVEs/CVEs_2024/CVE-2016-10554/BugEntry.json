{"buggy_code": ["var SqlString = exports;\n\nSqlString.escapeId = function (val, forbidQualified) {\n  if (forbidQualified) {\n    return '`' + val.replace(/`/g, '``') + '`';\n  }\n  return '`' + val.replace(/`/g, '``').replace(/\\./g, '`.`') + '`';\n};\n\nSqlString.escape = function(val, stringifyObjects, timeZone, dialect) {\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n\n  switch (typeof val) {\n    case 'boolean': return (val) ? 'true' : 'false';\n    case 'number': return val+'';\n  }\n\n  if (val instanceof Date) {\n    val = SqlString.dateToString(val, timeZone || \"Z\");\n  }\n\n  if (Buffer.isBuffer(val)) {\n    return SqlString.bufferToString(val);\n  }\n\n  if (Array.isArray(val)) {\n    return SqlString.arrayToList(val, timeZone);\n  }\n\n  if (typeof val === 'object') {\n    if (stringifyObjects) {\n      val = val.toString();\n    } else {\n      return SqlString.objectToValues(val, timeZone);\n    }\n  }\n\n  if (dialect == \"postgres\") {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\\\'\\\"\\x1a]/g, function(s) {\n      switch(s) {\n        case \"\\0\": return \"\\\\0\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\x1a\": return \"\\\\Z\";\n        default: return \"\\\\\"+s;\n      }\n    });\n  }\n  return \"'\"+val+\"'\";\n};\n\nSqlString.arrayToList = function(array, timeZone) {\n  return array.map(function(v) {\n    if (Array.isArray(v)) return '(' + SqlString.arrayToList(v) + ')';\n    return SqlString.escape(v, true, timeZone);\n  }).join(', ');\n};\n\nSqlString.format = function(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  return sql.replace(/\\?/g, function(match) {\n    if (!values.length) {\n      return match;\n    }\n\n    return SqlString.escape(values.shift(), false, timeZone, dialect);\n  });\n};\n\nSqlString.dateToString = function(date, timeZone) {\n  var dt = new Date(date);\n\n  if (timeZone != 'local') {\n    var tz = convertTimezone(timeZone);\n\n    dt.setTime(dt.getTime() + (dt.getTimezoneOffset() * 60000));\n    if (tz !== false) {\n      dt.setTime(dt.getTime() + (tz * 60000));\n    }\n  }\n\n  var year   = dt.getFullYear();\n  var month  = zeroPad(dt.getMonth() + 1);\n  var day    = zeroPad(dt.getDate());\n  var hour   = zeroPad(dt.getHours());\n  var minute = zeroPad(dt.getMinutes());\n  var second = zeroPad(dt.getSeconds());\n\n  return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;\n};\n\nSqlString.bufferToString = function(buffer) {\n  var hex = '';\n  try {\n    hex = buffer.toString('hex');\n  } catch (err) {\n    // node v0.4.x does not support hex / throws unknown encoding error\n    for (var i = 0; i < buffer.length; i++) {\n      var byte = buffer[i];\n      hex += zeroPad(byte.toString(16));\n    }\n  }\n\n  return \"X'\" + hex+ \"'\";\n};\n\nSqlString.objectToValues = function(object, timeZone) {\n  var values = [];\n  for (var key in object) {\n    var value = object[key];\n    if(typeof value === 'function') {\n      continue;\n    }\n\n    values.push(this.escapeId(key) + ' = ' + SqlString.escape(value, true, timeZone));\n  }\n\n  return values.join(', ');\n};\n\nfunction zeroPad(number) {\n  return (number < 10) ? '0' + number : number;\n}\n\nfunction convertTimezone(tz) {\n  if (tz == \"Z\") return 0;\n\n  var m = tz.match(/([\\+\\-\\s])(\\d\\d):?(\\d\\d)?/);\n  if (m) {\n    return (m[1] == '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;\n  }\n  return false;\n}\n"], "fixing_code": ["var SqlString = exports;\n\nSqlString.escapeId = function (val, forbidQualified) {\n  if (forbidQualified) {\n    return '`' + val.replace(/`/g, '``') + '`';\n  }\n  return '`' + val.replace(/`/g, '``').replace(/\\./g, '`.`') + '`';\n};\n\nSqlString.escape = function(val, stringifyObjects, timeZone, dialect) {\n  if (val === undefined || val === null) {\n    return 'NULL';\n  }\n\n  switch (typeof val) {\n    case 'boolean': return (val) ? 'true' : 'false';\n    case 'number': return val+'';\n  }\n\n  if (val instanceof Date) {\n    val = SqlString.dateToString(val, timeZone || \"Z\");\n  }\n\n  if (Buffer.isBuffer(val)) {\n    return SqlString.bufferToString(val);\n  }\n\n  if (Array.isArray(val)) {\n    return SqlString.arrayToList(val, timeZone);\n  }\n\n  if (typeof val === 'object') {\n    if (stringifyObjects) {\n      val = val.toString();\n    } else {\n      return SqlString.objectToValues(val, timeZone);\n    }\n  }\n\n  if (dialect === \"postgres\" || dialect === \"sqlite\") {\n    // http://www.postgresql.org/docs/8.2/static/sql-syntax-lexical.html#SQL-SYNTAX-STRINGS\n    // http://stackoverflow.com/q/603572/130598\n    val = val.replace(/'/g, \"''\");\n  } else {\n    val = val.replace(/[\\0\\n\\r\\b\\t\\\\\\'\\\"\\x1a]/g, function(s) {\n      switch(s) {\n        case \"\\0\": return \"\\\\0\";\n        case \"\\n\": return \"\\\\n\";\n        case \"\\r\": return \"\\\\r\";\n        case \"\\b\": return \"\\\\b\";\n        case \"\\t\": return \"\\\\t\";\n        case \"\\x1a\": return \"\\\\Z\";\n        default: return \"\\\\\"+s;\n      }\n    });\n  }\n  return \"'\"+val+\"'\";\n};\n\nSqlString.arrayToList = function(array, timeZone) {\n  return array.map(function(v) {\n    if (Array.isArray(v)) return '(' + SqlString.arrayToList(v) + ')';\n    return SqlString.escape(v, true, timeZone);\n  }).join(', ');\n};\n\nSqlString.format = function(sql, values, timeZone, dialect) {\n  values = [].concat(values);\n\n  return sql.replace(/\\?/g, function(match) {\n    if (!values.length) {\n      return match;\n    }\n\n    return SqlString.escape(values.shift(), false, timeZone, dialect);\n  });\n};\n\nSqlString.dateToString = function(date, timeZone) {\n  var dt = new Date(date);\n\n  if (timeZone != 'local') {\n    var tz = convertTimezone(timeZone);\n\n    dt.setTime(dt.getTime() + (dt.getTimezoneOffset() * 60000));\n    if (tz !== false) {\n      dt.setTime(dt.getTime() + (tz * 60000));\n    }\n  }\n\n  var year   = dt.getFullYear();\n  var month  = zeroPad(dt.getMonth() + 1);\n  var day    = zeroPad(dt.getDate());\n  var hour   = zeroPad(dt.getHours());\n  var minute = zeroPad(dt.getMinutes());\n  var second = zeroPad(dt.getSeconds());\n\n  return year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second;\n};\n\nSqlString.bufferToString = function(buffer) {\n  var hex = '';\n  try {\n    hex = buffer.toString('hex');\n  } catch (err) {\n    // node v0.4.x does not support hex / throws unknown encoding error\n    for (var i = 0; i < buffer.length; i++) {\n      var byte = buffer[i];\n      hex += zeroPad(byte.toString(16));\n    }\n  }\n\n  return \"X'\" + hex+ \"'\";\n};\n\nSqlString.objectToValues = function(object, timeZone) {\n  var values = [];\n  for (var key in object) {\n    var value = object[key];\n    if(typeof value === 'function') {\n      continue;\n    }\n\n    values.push(this.escapeId(key) + ' = ' + SqlString.escape(value, true, timeZone));\n  }\n\n  return values.join(', ');\n};\n\nfunction zeroPad(number) {\n  return (number < 10) ? '0' + number : number;\n}\n\nfunction convertTimezone(tz) {\n  if (tz == \"Z\") return 0;\n\n  var m = tz.match(/([\\+\\-\\s])(\\d\\d):?(\\d\\d)?/);\n  if (m) {\n    return (m[1] == '-' ? -1 : 1) * (parseInt(m[2], 10) + ((m[3] ? parseInt(m[3], 10) : 0) / 60)) * 60;\n  }\n  return false;\n}\n"], "filenames": ["lib/sql-string.js"], "buggy_code_start_loc": [40], "buggy_code_end_loc": [41], "fixing_code_start_loc": [40], "fixing_code_end_loc": [43], "type": "CWE-89", "message": "sequelize is an Object-relational mapping, or a middleman to convert things from Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server into usable data for NodeJS. Before version 1.7.0-alpha3, sequelize defaulted SQLite to use MySQL backslash escaping, even though SQLite uses Postgres escaping.", "other": {"cve": {"id": "CVE-2016-10554", "sourceIdentifier": "support@hackerone.com", "published": "2018-05-31T20:29:02.017", "lastModified": "2019-10-09T23:16:46.167", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "sequelize is an Object-relational mapping, or a middleman to convert things from Postgres, MySQL, MariaDB, SQLite and Microsoft SQL Server into usable data for NodeJS. Before version 1.7.0-alpha3, sequelize defaulted SQLite to use MySQL backslash escaping, even though SQLite uses Postgres escaping."}, {"lang": "es", "value": "sequelize es un mapeo objeto-relacional, o un \"middleman\", para convertir cosas de Postgres, MySQL, MariaDB, SQLite y Microsoft SQL Server en datos usables para NodeJS. En versiones anteriores a la 1.7.0-alpha3, sequelize hace que SQLite emplee el escapado de barras diagonales de MySQL, aunque SQLite emplea el escapado de Postgres."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sequelizejs:sequelize:*:*:*:*:*:node.js:*:*", "versionEndIncluding": "1.6.0", "matchCriteriaId": "7EC9F2CF-7A7F-4E10-91CB-5209CBBCBD87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sequelizejs:sequelize:1.7.0:alpha1:*:*:*:node.js:*:*", "matchCriteriaId": "633BEB5E-F7A7-4B9A-9D63-0DFC31A2E967"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sequelizejs:sequelize:1.7.0:alpha2:*:*:*:node.js:*:*", "matchCriteriaId": "4F6B120D-EF8F-4B24-980E-DE6392DACD0A"}]}]}], "references": [{"url": "https://github.com/sequelize/sequelize/commit/c876192aa6ce1f67e22b26a4d175b8478615f42d", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/113", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sequelize/sequelize/commit/c876192aa6ce1f67e22b26a4d175b8478615f42d"}}