{"buggy_code": ["package jwt\n\nimport (\n\t\"crypto\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"hash\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\n//Algorithm is used to sign and validate a token.\ntype Algorithm struct {\n\tsigningHash hash.Hash\n\talgorithm   string\n}\n\n// NewHeader returns a new Header object.\nfunc (a *Algorithm) NewHeader() *Header {\n\treturn &Header{\n\t\tTyp: \"JWT\",\n\t\tAlg: a.algorithm,\n\t}\n}\n\nfunc (a *Algorithm) sum(data []byte) []byte {\n\treturn a.signingHash.Sum(data)\n}\n\nfunc (a *Algorithm) reset() {\n\ta.signingHash.Reset()\n}\n\nfunc (a *Algorithm) write(data []byte) (int, error) {\n\treturn a.signingHash.Write(data)\n}\n\n// Sign signs the token with the given hash, and key\nfunc (a *Algorithm) Sign(unsignedToken string) (string, error) {\n\t_, err := a.write([]byte(unsignedToken))\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"Unable to write to HMAC-SHA256\")\n\t}\n\n\tencodedToken := base64.RawURLEncoding.EncodeToString(a.sum(nil))\n\ta.reset()\n\n\treturn encodedToken, nil\n}\n\n// Encode returns an encoded JWT token from a header, payload, and secret\nfunc (a *Algorithm) Encode(payload *Claims) (string, error) {\n\theader := a.NewHeader()\n\n\tjsonTokenHeader, err := json.Marshal(header)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"unable to marshal header\")\n\t}\n\n\tb64TokenHeader := base64.RawURLEncoding.EncodeToString(jsonTokenHeader)\n\n\tjsonTokenPayload, err := json.Marshal(payload.claimsMap)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"unable to marshal payload\")\n\t}\n\n\tb64TokenPayload := base64.RawURLEncoding.EncodeToString(jsonTokenPayload)\n\n\tunsignedSignature := b64TokenHeader + \".\" + b64TokenPayload\n\n\tsignature, err := a.Sign(unsignedSignature)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"unable to sign token\")\n\t}\n\tb64Signature := base64.RawURLEncoding.EncodeToString([]byte(signature))\n\n\ttoken := b64TokenHeader + \".\" + b64TokenPayload + \".\" + b64Signature\n\n\treturn token, nil\n}\n\n// Decode returns a map representing the token's claims. DOESN'T validate the claims though.\nfunc (a *Algorithm) Decode(encoded string) (*Claims, error) {\n\tencryptedComponents := strings.Split(encoded, \".\")\n\n\tb64Payload := encryptedComponents[1]\n\n\tvar claims map[string]interface{}\n\tpayload, err := base64.RawURLEncoding.DecodeString(b64Payload)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to decode base64 payload\")\n\t}\n\n\tif err := json.Unmarshal(payload, &claims); err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to unmarshal payload json\")\n\t}\n\n\treturn &Claims{\n\t\tclaimsMap: claims,\n\t}, nil\n}\n\n// Validate verifies a tokens validity. It returns nil if it is valid, and an error if invalid.\nfunc (a *Algorithm) Validate(encoded string) error {\n\tclaims, err := a.Decode(encoded)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := a.validateSignature(encoded); err != nil {\n\t\treturn errors.Wrap(err, \"failed to validate signature\")\n\t}\n\n\tif err := a.validateExp(claims); err != nil {\n\t\treturn errors.Wrap(err, \"failed to validate exp\")\n\t}\n\n\tif err := a.validateNbf(claims); err != nil {\n\t\treturn errors.Wrap(err, \"failed to validate nbf\")\n\t}\n\n\treturn nil\n}\n\nfunc (a *Algorithm) validateSignature(encoded string) error {\n\tencryptedComponents := strings.Split(encoded, \".\")\n\n\tb64Header := encryptedComponents[0]\n\tb64Payload := encryptedComponents[1]\n\tb64Signature := encryptedComponents[2]\n\n\tunsignedAttempt := b64Header + \".\" + b64Payload\n\tsignedAttempt, err := a.Sign(unsignedAttempt)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"unable to sign token for validation\")\n\t}\n\n\tb64SignedAttempt := base64.RawURLEncoding.EncodeToString([]byte(signedAttempt))\n\n\tif strings.Compare(b64Signature, b64SignedAttempt) != 0 {\n\t\treturn errors.New(\"invalid signature\")\n\t}\n\n\treturn nil\n}\n\n\nfunc (a *Algorithm) validateExp(claims *Claims) error {\n\tif claims.HasClaim(\"exp\") {\n\t\texp, err := claims.GetTime(\"exp\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif exp.Before(time.Now()) {\n\t\t\treturn errors.New(\"token has expired\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a *Algorithm) validateNbf(claims *Claims) error {\n\tif claims.HasClaim(\"nbf\") {\n\t\tnbf, err := claims.GetTime(\"nbf\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif nbf.After(time.Now()) {\n\t\t\treturn errors.New(\"token isn't valid yet\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//HmacSha256 returns the SingingMethod for HMAC with SHA256\nfunc HmacSha256(key string) Algorithm {\n\treturn Algorithm{\n\t\talgorithm:   \"HS256\",\n\t\tsigningHash: hmac.New(sha256.New, []byte(key)),\n\t}\n}\n\n//HmacSha512 returns the SigningMethod for HMAC with SHA512\nfunc HmacSha512(key string) Algorithm {\n\treturn Algorithm{\n\t\talgorithm:   \"HS512\",\n\t\tsigningHash: hmac.New(sha512.New, []byte(key)),\n\t}\n}\n\n//HmacSha384 returns the SigningMethod for HMAC with SHA384\nfunc HmacSha384(key string) Algorithm {\n\treturn Algorithm{\n\t\talgorithm:   \"HS384\",\n\t\tsigningHash: hmac.New(crypto.SHA384.New, []byte(key)),\n\t}\n}\n"], "fixing_code": ["package jwt\n\nimport (\n\t\"crypto\"\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"crypto/sha512\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"hash\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\n//Algorithm is used to sign and validate a token.\ntype Algorithm struct {\n\tsigningHash hash.Hash\n\talgorithm   string\n}\n\n// NewHeader returns a new Header object.\nfunc (a *Algorithm) NewHeader() *Header {\n\treturn &Header{\n\t\tTyp: \"JWT\",\n\t\tAlg: a.algorithm,\n\t}\n}\n\nfunc (a *Algorithm) sum(data []byte) []byte {\n\treturn a.signingHash.Sum(data)\n}\n\nfunc (a *Algorithm) reset() {\n\ta.signingHash.Reset()\n}\n\nfunc (a *Algorithm) write(data []byte) (int, error) {\n\treturn a.signingHash.Write(data)\n}\n\n// Sign signs the token with the given hash, and key\nfunc (a *Algorithm) Sign(unsignedToken string) (string, error) {\n\t_, err := a.write([]byte(unsignedToken))\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"Unable to write to HMAC-SHA256\")\n\t}\n\n\tencodedToken := base64.RawURLEncoding.EncodeToString(a.sum(nil))\n\ta.reset()\n\n\treturn encodedToken, nil\n}\n\n// Encode returns an encoded JWT token from a header, payload, and secret\nfunc (a *Algorithm) Encode(payload *Claims) (string, error) {\n\theader := a.NewHeader()\n\n\tjsonTokenHeader, err := json.Marshal(header)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"unable to marshal header\")\n\t}\n\n\tb64TokenHeader := base64.RawURLEncoding.EncodeToString(jsonTokenHeader)\n\n\tjsonTokenPayload, err := json.Marshal(payload.claimsMap)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"unable to marshal payload\")\n\t}\n\n\tb64TokenPayload := base64.RawURLEncoding.EncodeToString(jsonTokenPayload)\n\n\tunsignedSignature := b64TokenHeader + \".\" + b64TokenPayload\n\n\tsignature, err := a.Sign(unsignedSignature)\n\tif err != nil {\n\t\treturn \"\", errors.Wrap(err, \"unable to sign token\")\n\t}\n\tb64Signature := base64.RawURLEncoding.EncodeToString([]byte(signature))\n\n\ttoken := b64TokenHeader + \".\" + b64TokenPayload + \".\" + b64Signature\n\n\treturn token, nil\n}\n\n// Decode returns a map representing the token's claims. DOESN'T validate the claims though.\nfunc (a *Algorithm) Decode(encoded string) (*Claims, error) {\n\tencryptedComponents := strings.Split(encoded, \".\")\n\n\tb64Payload := encryptedComponents[1]\n\n\tvar claims map[string]interface{}\n\tpayload, err := base64.RawURLEncoding.DecodeString(b64Payload)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to decode base64 payload\")\n\t}\n\n\tif err := json.Unmarshal(payload, &claims); err != nil {\n\t\treturn nil, errors.Wrap(err, \"unable to unmarshal payload json\")\n\t}\n\n\treturn &Claims{\n\t\tclaimsMap: claims,\n\t}, nil\n}\n\n// Validate verifies a tokens validity. It returns nil if it is valid, and an error if invalid.\nfunc (a *Algorithm) Validate(encoded string) error {\n\tclaims, err := a.Decode(encoded)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := a.validateSignature(encoded); err != nil {\n\t\treturn errors.Wrap(err, \"failed to validate signature\")\n\t}\n\n\tif err := a.validateExp(claims); err != nil {\n\t\treturn errors.Wrap(err, \"failed to validate exp\")\n\t}\n\n\tif err := a.validateNbf(claims); err != nil {\n\t\treturn errors.Wrap(err, \"failed to validate nbf\")\n\t}\n\n\treturn nil\n}\n\nfunc (a *Algorithm) validateSignature(encoded string) error {\n\tencryptedComponents := strings.Split(encoded, \".\")\n\n\tb64Header := encryptedComponents[0]\n\tb64Payload := encryptedComponents[1]\n\tb64Signature := encryptedComponents[2]\n\n\tunsignedAttempt := b64Header + \".\" + b64Payload\n\tsignedAttempt, err := a.Sign(unsignedAttempt)\n\tif err != nil {\n\t\treturn errors.Wrap(err, \"unable to sign token for validation\")\n\t}\n\n\tb64SignedAttempt := base64.RawURLEncoding.EncodeToString([]byte(signedAttempt))\n\n\tif !hmac.Equal([]byte(b64Signature), []byte(b64SignedAttempt)) {\n\t\treturn errors.New(\"invalid signature\")\n\t}\n\n\treturn nil\n}\n\n\nfunc (a *Algorithm) validateExp(claims *Claims) error {\n\tif claims.HasClaim(\"exp\") {\n\t\texp, err := claims.GetTime(\"exp\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif exp.Before(time.Now()) {\n\t\t\treturn errors.New(\"token has expired\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (a *Algorithm) validateNbf(claims *Claims) error {\n\tif claims.HasClaim(\"nbf\") {\n\t\tnbf, err := claims.GetTime(\"nbf\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif nbf.After(time.Now()) {\n\t\t\treturn errors.New(\"token isn't valid yet\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n//HmacSha256 returns the SingingMethod for HMAC with SHA256\nfunc HmacSha256(key string) Algorithm {\n\treturn Algorithm{\n\t\talgorithm:   \"HS256\",\n\t\tsigningHash: hmac.New(sha256.New, []byte(key)),\n\t}\n}\n\n//HmacSha512 returns the SigningMethod for HMAC with SHA512\nfunc HmacSha512(key string) Algorithm {\n\treturn Algorithm{\n\t\talgorithm:   \"HS512\",\n\t\tsigningHash: hmac.New(sha512.New, []byte(key)),\n\t}\n}\n\n//HmacSha384 returns the SigningMethod for HMAC with SHA384\nfunc HmacSha384(key string) Algorithm {\n\treturn Algorithm{\n\t\talgorithm:   \"HS384\",\n\t\tsigningHash: hmac.New(crypto.SHA384.New, []byte(key)),\n\t}\n}\n"], "filenames": ["algorithms.go"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [146], "fixing_code_start_loc": [145], "fixing_code_end_loc": [146], "type": "CWE-668", "message": "Token validation methods are susceptible to a timing side-channel during HMAC comparison. With a large enough number of requests over a low latency connection, an attacker may use this to determine the expected HMAC.", "other": {"cve": {"id": "CVE-2015-10004", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:10.947", "lastModified": "2023-01-06T15:39:43.393", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Token validation methods are susceptible to a timing side-channel during HMAC comparison. With a large enough number of requests over a low latency connection, an attacker may use this to determine the expected HMAC."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:json_web_token_project:json_web_token:-:*:*:*:*:go:*:*", "matchCriteriaId": "7D52A34D-2AF5-4373-8B69-4A4AC8A7711D"}]}]}], "references": [{"url": "https://github.com/robbert229/jwt/commit/ca1404ee6e83fcbafb66b09ed0d543850a15b654", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/robbert229/jwt/issues/12", "source": "security@golang.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0023", "source": "security@golang.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/robbert229/jwt/commit/ca1404ee6e83fcbafb66b09ed0d543850a15b654"}}