{"buggy_code": ["/*\n * Copyright (c) 2019 HAW Hamburg\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @ingroup     sys_clif\n * @{\n *\n * @file\n * @brief       CoRE Link format encoding and decoding library implementation\n *\n * @author      Leandro Lanzieri <leandro.lanzieri@haw-hamburg.de>\n * @}\n */\n\n#include <assert.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"clif.h\"\n#include \"clif_internal.h\"\n\n#define ENABLE_DEBUG 0\n#include \"debug.h\"\n\n/* returns the correspondent attribute string */\nstatic const char *_attr_to_str[] = {\n    [CLIF_ATTR_ANCHOR]    = LF_ATTR_ANCHOR,\n    [CLIF_ATTR_REL]       = LF_ATTR_REL_TYPE,\n    [CLIF_ATTR_LANG]      = LF_ATTR_LANG,\n    [CLIF_ATTR_MEDIA]     = LF_ATTR_MEDIA,\n    [CLIF_ATTR_TITLE]     = LF_ATTR_TITLE,\n    [CLIF_ATTR_TITLE_EXT] = LF_ATTR_TITLE_EXT,\n    [CLIF_ATTR_TYPE]      = LF_ATTR_TYPE,\n    [CLIF_ATTR_RT]        = LF_ATTR_RES_TYPE,\n    [CLIF_ATTR_IF]        = LF_ATTR_IF_DESC,\n    [CLIF_ATTR_SZ]        = LF_ATTR_SIZE,\n    [CLIF_ATTR_CT]        = LF_ATTR_CT,\n    [CLIF_ATTR_OBS]       = LF_ATTR_OBS\n};\n\n/* returns the correspondent attribute string size */\nstatic const unsigned _attr_to_size[] = {\n    [CLIF_ATTR_ANCHOR]    = LF_ATTR_ANCHOR_S,\n    [CLIF_ATTR_REL]       = LF_ATTR_REL_TYPE_S,\n    [CLIF_ATTR_LANG]      = LF_ATTR_LANG_S,\n    [CLIF_ATTR_MEDIA]     = LF_ATTR_MEDIA_S,\n    [CLIF_ATTR_TITLE]     = LF_ATTR_TITLE_S,\n    [CLIF_ATTR_TITLE_EXT] = LF_ATTR_TITLE_EXT_S,\n    [CLIF_ATTR_TYPE]      = LF_ATTR_TYPE_S,\n    [CLIF_ATTR_RT]        = LF_ATTR_RES_TYPE_S,\n    [CLIF_ATTR_IF]        = LF_ATTR_IF_DESC_S,\n    [CLIF_ATTR_SZ]        = LF_ATTR_SIZE_S,\n    [CLIF_ATTR_CT]        = LF_ATTR_CT_S,\n    [CLIF_ATTR_OBS]       = LF_ATTR_OBS_S\n};\n\n/* do not count extension attr type */\n#define ATTRS_NUMOF ARRAY_SIZE(_attr_to_str)\n\nssize_t clif_decode_link(clif_t *link, clif_attr_t *attrs, unsigned attrs_len,\n                         const char *buf, size_t maxlen)\n{\n\n    assert(buf);\n    assert(link);\n\n    char *pos;\n    const char *end = buf + maxlen;\n    clif_attr_t _dummy_attr;\n\n    ssize_t size = clif_get_target(buf, maxlen, &pos);\n    if (size < 0) {\n        return CLIF_NOT_FOUND;\n    }\n    link->target = pos;\n    link->target_len = size;\n    link->attrs_len = 0;\n    link->attrs = attrs;\n    pos += size + 1; /* escape the '>' */\n\n    DEBUG(\"Found target (%u): %.*s\\n\", (unsigned)size, (unsigned)size,\n          link->target);\n\n    /* if there is no attr array iterate over the buffer, if not until all\n     * the array is used */\n    while ((!attrs && pos < end) || (attrs && link->attrs_len < attrs_len)) {\n        clif_attr_t *attr = attrs ? &attrs[link->attrs_len] : &_dummy_attr;\n        size = clif_get_attr(pos, end - pos, attr);\n        if (size < 0) {\n            break;\n        }\n        pos += size;\n        link->attrs_len++;\n    }\n\n    return pos - buf;\n}\n\nssize_t clif_encode_link(const clif_t *link, char *buf, size_t maxlen)\n{\n    assert(link);\n    size_t pos = 0;\n    ssize_t res = 0;\n\n    res = clif_add_target(link->target, buf, maxlen);\n    if (res < 0) {\n        return res;\n    }\n    pos += res;\n\n    for (unsigned i = 0; i < link->attrs_len; i++) {\n        res = clif_add_attr(&link->attrs[i], buf ? &buf[pos] : NULL,\n                             maxlen - pos);\n        if (res <= 0) {\n            return res;\n        }\n        pos += res;\n    }\n    return pos;\n}\n\nssize_t clif_add_target(const char *target, char *buf, size_t maxlen)\n{\n    assert(target);\n\n    size_t pos = 0;\n    size_t target_len = strlen(target);\n\n    if (!buf) {\n        return target_len + 2; /* size after adding '<' and '>' */\n    }\n\n    if ((target_len + 2) > maxlen) {\n        return CLIF_NO_SPACE;\n    }\n\n    buf[pos++] = LF_PATH_BEGIN_C;\n\n    memcpy(&buf[pos], target, target_len);\n    pos += target_len;\n\n    buf[pos++] = LF_PATH_END_C;\n\n    return pos;\n}\n\nssize_t clif_add_link_separator(char *buf, size_t maxlen)\n{\n    if (!buf) {\n        return 1;\n    }\n\n    if (maxlen < 1) {\n        return CLIF_NO_SPACE;\n    }\n\n    *buf = LF_LINK_SEPARATOR_C;\n    return 1;\n}\n\nssize_t clif_add_attr(clif_attr_t *attr, char *buf, size_t maxlen)\n{\n    assert(attr);\n    assert(attr->key);\n\n    /* if no length given, calculate it */\n    if (!attr->key_len) {\n        attr->key_len = strlen(attr->key);\n    }\n\n    /* count attr name size and separator ';' */\n    size_t req_space = attr->key_len + 1;\n    size_t pos = 0;\n    int quoted = strcmp(attr->key, LF_ATTR_SIZE) ? 1 : 0;\n\n    if (attr->value) {\n        if (!attr->value_len) {\n            attr->value_len = strlen(attr->value);\n        }\n        /* count also '=' */\n        req_space += attr->value_len +  1;\n    }\n\n    if (quoted) {\n        req_space += 2;\n    }\n\n    if (!buf) {\n        return req_space;\n    }\n\n    if (req_space > maxlen) {\n        return CLIF_NO_SPACE;\n    }\n\n    /* add attribute separator ';' */\n    buf[pos++] = LF_ATTR_SEPARATOR_C;\n\n    /* add attribute name */\n    memcpy(&buf[pos], attr->key, attr->key_len);\n    pos += attr->key_len;\n\n    /* add attribute value if defined */\n    if (attr->value) {\n        buf[pos++] = LF_ATTR_VAL_SEPARATOR_C;\n\n        if (quoted) {\n            buf[pos++] = '\"';\n        }\n\n        memcpy(&buf[pos], attr->value, attr->value_len);\n        pos += attr->value_len;\n\n        if (quoted) {\n            buf[pos++] = '\"';\n        }\n    }\n\n    return pos;\n}\n\nssize_t clif_get_target(const char *input, size_t input_len, char **output)\n{\n    assert(input);\n    char *target_end;\n\n    *output = memchr(input, LF_PATH_BEGIN_C, input_len);\n    if (!*output) {\n        DEBUG(\"Path start not found\\n\");\n        return CLIF_NOT_FOUND;\n    }\n    *output += 1;\n\n    target_end = memchr(*output, LF_PATH_END_C, (input + input_len) - *output);\n    if (!target_end) {\n        DEBUG(\"Path end not found\\n\");\n        return CLIF_NOT_FOUND;\n    }\n    ssize_t res = target_end - *output;\n    return res;\n}\n\nssize_t clif_get_attr(const char *input, size_t input_len, clif_attr_t *attr)\n{\n    assert(input);\n    assert(attr);\n    const char *pos = input;\n    const char *end = input + input_len;\n    bool quoted = false;\n    bool scan_value = false;\n\n    /* initialize attr */\n    attr->value = NULL;\n    attr->key = NULL;\n\n    /* an attribute should start with the separator */\n    if (*pos != LF_ATTR_SEPARATOR_C) {\n        DEBUG(\"Attribute should start with separator, found %c\\n\", *pos);\n        return CLIF_NOT_FOUND;\n    }\n    pos++;\n    attr->key = pos;\n\n    /* iterate over key */\n    while (pos < end) {\n        if (*pos == LF_ATTR_SEPARATOR_C || *pos == LF_LINK_SEPARATOR_C) {\n            /* key ends, no value */\n            attr->key_len = pos - attr->key;\n            break;\n        }\n        if (*pos == LF_ATTR_VAL_SEPARATOR_C) {\n            /* key ends, has value */\n            attr->key_len = pos - attr->key;\n            /* check if the value is quoted and prepare pointer for value scan */\n            pos++;\n            if (*pos == '\"') {\n                quoted = true;\n                pos++;\n            }\n            attr->value = (char *)pos;\n            scan_value = true;\n            break;\n        }\n        pos++;\n    }\n\n    if (scan_value) {\n        /* iterate over value */\n        while (pos < end) {\n            if (quoted) {\n                if (*pos == '\"' && *(pos - 1) != '\\\\') {\n                    /* found unescaped quote */\n                    attr->value_len = pos - attr->value;\n                    pos++;\n                    break;\n                }\n            }\n            else {\n                if (*pos == LF_ATTR_SEPARATOR_C || *pos == LF_LINK_SEPARATOR_C) {\n                    /* value ends */\n                    attr->value_len = pos - attr->value;\n                    break;\n                }\n            }\n            pos++;\n        }\n    }\n    else {\n        /* buffer exhausted and no special character found, calculate length of\n        * attribute and exit */\n        attr->key_len = pos - attr->key;\n    }\n\n    return pos - input;\n}\n\nssize_t clif_attr_type_to_str(clif_attr_type_t type, const char **str)\n{\n    if (type < ATTRS_NUMOF) {\n        *str = _attr_to_str[type];\n        return _attr_to_size[type];\n    }\n    return CLIF_NOT_FOUND;\n}\n\nclif_attr_type_t clif_get_attr_type(const char *input, size_t input_len)\n{\n    assert(input);\n    assert(input_len > 0);\n    clif_attr_type_t ret = CLIF_ATTR_EXT;\n    for (unsigned i = 0; i < ATTRS_NUMOF; i++) {\n        if (input_len == _attr_to_size[i] &&\n            !strncmp(input, _attr_to_str[i], input_len)) {\n            ret = i;\n            break;\n        }\n    }\n    return ret;\n}\n\nint clif_init_attr(clif_attr_t *attr, clif_attr_type_t type)\n{\n    assert(attr);\n    attr->key_len = clif_attr_type_to_str(type, &attr->key);\n    return attr->key_len > 0 ? 0 : CLIF_NOT_FOUND;\n}\n", "/*\n* Copyright (C) 2019 HAW Hamburg\n*\n* This file is subject to the terms and conditions of the GNU Lesser\n* General Public License v2.1. See the file LICENSE in the top level\n* directory for more details.\n*/\n\n#include <string.h>\n#include \"embUnit.h\"\n#include \"tests-clif.h\"\n\n#include \"clif.h\"\n\n#ifdef TESTS_CLIF_PRINT\n#include <stdio.h>\nstatic void _print_attr(clif_attr_t *attr)\n{\n    if (attr->key) {\n        printf(\"-- Attr: \");\n        printf(\"%.*s\", attr->key_len, attr->key);\n        if (attr->value) {\n            printf(\" = %.*s\\n\", attr->value_len, attr->value);\n        }\n        else {\n            puts(\"\");\n        }\n    }\n}\n#endif /* TESTS_CLIF_PRINT */\n\n#define _STR_LEN(s) (sizeof(s)-1)\n#define _NEW_ATTR(k, v) { .key = k, .key_len = _STR_LEN(k), .value = v, \\\n                          .value_len = _STR_LEN(v) }\n#define _NEW_ATTR_NO_VAL(k) { .key = k, .key_len = _STR_LEN(k), .value_len = 0 }\n\n/**\n * @brief Compares two link format attributes\n *\n * @param[in] p1 first attribute to compare\n * @param[in] p2 second attribute to compare\n *\n * @return 0 if attributes are equal\n * @return 1 otherwise\n */\nstatic unsigned _compare_attrs(clif_attr_t *p1, clif_attr_t *p2)\n{\n    unsigned result = 1;\n    int res;\n\n    if (p1->key_len != p2->key_len) {\n        goto out;\n    }\n\n    if (strncmp(p1->key, p2->key, p1->key_len)) {\n        goto out;\n    }\n\n    if (!p1->value && !p2->value) {\n        goto success_out;\n    }\n\n    if (!p1->value || !p2->value || (p1->value_len != p2->value_len)) {\n        goto out;\n    }\n\n    res = strncmp(p1->value, p2->value, p1->value_len);\n    if (res != 0) {\n        goto out;\n    }\nsuccess_out:\n    result = 0;\nout:\n    return result;\n}\n\n/* This also tests the functions `clif_add_target` and\n * `clif_add_attr`. */\nstatic void test_clif_encode_links(void)\n{\n    const char exp_string[] = \"</sensor/temp>;rt=\\\"temperature\\\";if=\\\"sensor\\\",\"\n                              \"</node/info>,</node/ep>;ct=\\\"40\\\"\";\n    clif_attr_t attrs[] = {\n        { .key = \"rt\", .value = \"temperature\" },\n        { .key = \"if\", .value = \"sensor\" },\n        { .key = \"ct\", .value = \"40\" }\n    };\n\n    clif_t links[] = {\n        { .target = \"/sensor/temp\", .attrs = attrs, .attrs_len = 2 },\n        { .target = \"/node/info\", .attrs_len = 0 },\n        { .target = \"/node/ep\", .attrs = &attrs[2], .attrs_len = 1 }\n    };\n\n    const size_t exp_size = sizeof(exp_string) - 1;\n    char output[sizeof(exp_string) + 1];\n    size_t pos = 0;\n    ssize_t res = 0;\n\n    /* first test with NULL output to check the needed bytes */\n    res = clif_encode_link(&links[0], NULL, 0);\n    pos += res;\n\n    for (unsigned i = 1; i < ARRAY_SIZE(links); i++) {\n        res = clif_add_link_separator(NULL, 0);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n\n        res = clif_encode_link(&links[i],NULL, 0);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n    }\n\n    TEST_ASSERT_EQUAL_INT(exp_size, pos);\n\n    /* now actually encode the links */\n    pos = 0;\n    res = clif_encode_link(&links[0], output, sizeof(output));\n    pos += res;\n\n    for (unsigned i = 1; i < ARRAY_SIZE(links); i++) {\n        res = clif_add_link_separator(&output[pos], sizeof(output) - pos);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n\n        res = clif_encode_link(&links[i], &output[pos], sizeof(output) - pos);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n    }\n    output[pos++] = '\\0';\n\n#ifdef TESTS_CLIF_PRINT\n    puts(\"\\n========================================\");\n    puts(\"[Test: encode_links]\");\n    puts(\"---------------------\");\n    printf(\"Encoded links: %s\\n\", output);\n#endif\n\n    TEST_ASSERT_EQUAL_STRING(exp_string, output);\n    TEST_ASSERT_EQUAL_INT(exp_size, pos - 1); /* do not count '\\0' */\n}\n\n/* This also tests the functions `clif_get_target` and `clif_get_attr` */\nstatic void test_clif_decode_links(void)\n{\n    /* string to decode */\n    char input_string[] = \"</sensors>;ct=40;title=\\\"\\\\\\\"Sensor\\\\\\\" Index, collection\\\",\"\n                          \"</sensors/temp>;rt=\\\"temperature-c\\\";if=\\\"sensor\\\",\"\n                          \"</sensors/light>;rt=\\\"light-lux\\\";if=sensor,\"\n                          \"<http://www.example.com/sensors/t123>;\"\n                          \"anchor=\\\"/sensors/temp\\\";rel=\\\"describedby\\\";sz=1234,\"\n                          \"</t>;anchor=\\\"/sensors/temp\\\";rel=\\\"alternate\\\";a;s=\\\"This is \\\\\\\"escaped and has , \\\\\\\"\\\",\"\n                          \"</riot/board>,</riot/info>;obs\";\n\n    /* ordered expected types to be decoded */\n    clif_attr_type_t exp_types[] = {\n        CLIF_ATTR_CT, CLIF_ATTR_TITLE, CLIF_ATTR_RT, CLIF_ATTR_IF,\n        CLIF_ATTR_RT, CLIF_ATTR_IF, CLIF_ATTR_ANCHOR, CLIF_ATTR_REL,\n        CLIF_ATTR_SZ, CLIF_ATTR_ANCHOR, CLIF_ATTR_REL, CLIF_ATTR_EXT,\n        CLIF_ATTR_EXT, CLIF_ATTR_OBS\n    };\n\n    /* ordered amount of expected attributes per link to be decoded */\n    unsigned exp_attr_numof[] = { 2, 2, 2, 3, 4, 0, 1 };\n\n    /* ordered expected attributes to be decoded */\n    clif_attr_t exp_attrs[] = {\n        _NEW_ATTR(\"ct\", \"40\"),\n        _NEW_ATTR(\"title\", \"\\\\\\\"Sensor\\\\\\\" Index, collection\"),\n        _NEW_ATTR(\"rt\", \"temperature-c\"),\n        _NEW_ATTR(\"if\", \"sensor\"),\n        _NEW_ATTR(\"rt\", \"light-lux\"),\n        _NEW_ATTR(\"if\", \"sensor\"),\n        _NEW_ATTR(\"anchor\", \"/sensors/temp\"),\n        _NEW_ATTR(\"rel\", \"describedby\"),\n        _NEW_ATTR(\"sz\", \"1234\"),\n        _NEW_ATTR(\"anchor\", \"/sensors/temp\"),\n        _NEW_ATTR(\"rel\", \"alternate\"),\n        _NEW_ATTR_NO_VAL(\"a\"),\n        _NEW_ATTR(\"s\", \"This is \\\\\\\"escaped and has , \\\\\\\"\"),\n        _NEW_ATTR_NO_VAL(\"obs\"),\n    };\n\n    /* ordered expected targets to be decoded */\n    const char *exp_targets[] = {\n        \"/sensors\", \"/sensors/temp\", \"/sensors/light\",\n        \"http://www.example.com/sensors/t123\", \"/t\", \"/riot/board\", \"/riot/info\"\n    };\n\n    const unsigned exp_links_numof = ARRAY_SIZE(exp_targets);\n    const unsigned exp_attrs_numof = ARRAY_SIZE(exp_attrs);\n    const size_t input_len = sizeof(input_string) - 1;\n\n    clif_t out_link;\n    char *pos = input_string;\n    unsigned links_numof = 0;\n\n    /* first test without attributes array, to test the expected attributes\n     * functionality */\n    do {\n        ssize_t res = clif_decode_link(&out_link, NULL, 0, pos,\n                                       input_len - (pos - input_string));\n        if (res < 0) {\n            break;\n        }\n        pos += res;\n\n        /* check expected target */\n        TEST_ASSERT(!strncmp(exp_targets[links_numof], out_link.target, out_link.target_len));\n\n        /* check expected amount of attributes */\n        TEST_ASSERT_EQUAL_INT(exp_attr_numof[links_numof], out_link.attrs_len);\n        links_numof++;\n    } while (pos < input_string + sizeof(input_string));\n\n#ifdef TESTS_CLIF_PRINT\n    puts(\"\\n========================================\");\n    puts(\"[Test: decode_links]\");\n    printf(\"- Amount of decoded links: %u\\n\", links_numof);\n#endif\n    TEST_ASSERT(exp_links_numof == links_numof);\n\n    /* now decode again but saving the attributes */\n    clif_attr_t out_attrs[ARRAY_SIZE(exp_attrs)];\n    pos = input_string;\n    unsigned attrs_numof = 0;\n    do {\n        ssize_t res = clif_decode_link(&out_link, &out_attrs[attrs_numof],\n                                       exp_attrs_numof - attrs_numof, pos,\n                                       input_len - (pos - input_string));\n\n        if (res < 0) {\n            break;\n        }\n        pos += res;\n#ifdef TESTS_CLIF_PRINT\n        puts(\"---------------------\");\n        puts(\"New link:\");\n        printf(\"- Target: %.*s\\n\", out_link.target_len, out_link.target);\n        printf(\"- Number of attributes: %d\\n\", out_link.attrs_len);\n#endif\n\n        for (unsigned i = 0; i < out_link.attrs_len; i++) {\n#ifdef TESTS_CLIF_PRINT\n            _print_attr(&out_link.attrs[i]);\n#endif\n            /* compare the attribute structure with the expected one */\n            TEST_ASSERT(!_compare_attrs(&out_link.attrs[i],\n                                         &exp_attrs[attrs_numof]));\n            clif_attr_type_t type = clif_get_attr_type(out_link.attrs[i].key,\n                                                         out_link.attrs[i].key_len);\n\n            /* check that the returned type is the expected one */\n            TEST_ASSERT_EQUAL_INT(exp_types[attrs_numof], type);\n\n            /* test type to string conversion */\n            const char *t;\n            if (clif_attr_type_to_str(type, &t) < 0) {\n                t = NULL;\n            }\n            TEST_ASSERT_EQUAL_STRING(type == CLIF_ATTR_EXT ?\n                                     NULL : exp_attrs[attrs_numof].key, t);\n            attrs_numof++;\n        }\n    } while (pos < input_string + sizeof(input_string));\n    TEST_ASSERT_EQUAL_INT(exp_attrs_numof, attrs_numof);\n}\n\nTest *tests_clif_tests(void)\n{\n    EMB_UNIT_TESTFIXTURES(fixtures) {\n        new_TestFixture(test_clif_encode_links),\n        new_TestFixture(test_clif_decode_links)\n    };\n\n    EMB_UNIT_TESTCALLER(clif_tests, NULL, NULL, fixtures);\n\n    return (Test *)&clif_tests;\n}\n\nvoid tests_clif(void)\n{\n    TESTS_RUN(tests_clif_tests());\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2019 HAW Hamburg\n *\n * This file is subject to the terms and conditions of the GNU Lesser\n * General Public License v2.1. See the file LICENSE in the top level\n * directory for more details.\n */\n\n/**\n * @ingroup     sys_clif\n * @{\n *\n * @file\n * @brief       CoRE Link format encoding and decoding library implementation\n *\n * @author      Leandro Lanzieri <leandro.lanzieri@haw-hamburg.de>\n * @}\n */\n\n#include <assert.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"clif.h\"\n#include \"clif_internal.h\"\n\n#define ENABLE_DEBUG 0\n#include \"debug.h\"\n\n/* returns the correspondent attribute string */\nstatic const char *_attr_to_str[] = {\n    [CLIF_ATTR_ANCHOR]    = LF_ATTR_ANCHOR,\n    [CLIF_ATTR_REL]       = LF_ATTR_REL_TYPE,\n    [CLIF_ATTR_LANG]      = LF_ATTR_LANG,\n    [CLIF_ATTR_MEDIA]     = LF_ATTR_MEDIA,\n    [CLIF_ATTR_TITLE]     = LF_ATTR_TITLE,\n    [CLIF_ATTR_TITLE_EXT] = LF_ATTR_TITLE_EXT,\n    [CLIF_ATTR_TYPE]      = LF_ATTR_TYPE,\n    [CLIF_ATTR_RT]        = LF_ATTR_RES_TYPE,\n    [CLIF_ATTR_IF]        = LF_ATTR_IF_DESC,\n    [CLIF_ATTR_SZ]        = LF_ATTR_SIZE,\n    [CLIF_ATTR_CT]        = LF_ATTR_CT,\n    [CLIF_ATTR_OBS]       = LF_ATTR_OBS\n};\n\n/* returns the correspondent attribute string size */\nstatic const unsigned _attr_to_size[] = {\n    [CLIF_ATTR_ANCHOR]    = LF_ATTR_ANCHOR_S,\n    [CLIF_ATTR_REL]       = LF_ATTR_REL_TYPE_S,\n    [CLIF_ATTR_LANG]      = LF_ATTR_LANG_S,\n    [CLIF_ATTR_MEDIA]     = LF_ATTR_MEDIA_S,\n    [CLIF_ATTR_TITLE]     = LF_ATTR_TITLE_S,\n    [CLIF_ATTR_TITLE_EXT] = LF_ATTR_TITLE_EXT_S,\n    [CLIF_ATTR_TYPE]      = LF_ATTR_TYPE_S,\n    [CLIF_ATTR_RT]        = LF_ATTR_RES_TYPE_S,\n    [CLIF_ATTR_IF]        = LF_ATTR_IF_DESC_S,\n    [CLIF_ATTR_SZ]        = LF_ATTR_SIZE_S,\n    [CLIF_ATTR_CT]        = LF_ATTR_CT_S,\n    [CLIF_ATTR_OBS]       = LF_ATTR_OBS_S\n};\n\n/* do not count extension attr type */\n#define ATTRS_NUMOF ARRAY_SIZE(_attr_to_str)\n\nssize_t clif_decode_link(clif_t *link, clif_attr_t *attrs, unsigned attrs_len,\n                         const char *buf, size_t maxlen)\n{\n\n    assert(buf);\n    assert(link);\n\n    char *pos;\n    const char *end = buf + maxlen;\n    clif_attr_t _dummy_attr;\n\n    ssize_t size = clif_get_target(buf, maxlen, &pos);\n    if (size < 0) {\n        return CLIF_NOT_FOUND;\n    }\n    link->target = pos;\n    link->target_len = size;\n    link->attrs_len = 0;\n    link->attrs = attrs;\n    pos += size + 1; /* escape the '>' */\n\n    DEBUG(\"Found target (%u): %.*s\\n\", (unsigned)size, (unsigned)size,\n          link->target);\n\n    /* if there is no attr array iterate over the buffer, if not until all\n     * the array is used */\n    while ((!attrs && pos < end) || (attrs && link->attrs_len < attrs_len)) {\n        clif_attr_t *attr = attrs ? &attrs[link->attrs_len] : &_dummy_attr;\n        size = clif_get_attr(pos, end - pos, attr);\n        if (size < 0) {\n            break;\n        }\n        pos += size;\n        link->attrs_len++;\n    }\n\n    return pos - buf;\n}\n\nssize_t clif_encode_link(const clif_t *link, char *buf, size_t maxlen)\n{\n    assert(link);\n    size_t pos = 0;\n    ssize_t res = 0;\n\n    res = clif_add_target(link->target, buf, maxlen);\n    if (res < 0) {\n        return res;\n    }\n    pos += res;\n\n    for (unsigned i = 0; i < link->attrs_len; i++) {\n        res = clif_add_attr(&link->attrs[i], buf ? &buf[pos] : NULL,\n                             maxlen - pos);\n        if (res <= 0) {\n            return res;\n        }\n        pos += res;\n    }\n    return pos;\n}\n\nssize_t clif_add_target(const char *target, char *buf, size_t maxlen)\n{\n    assert(target);\n\n    size_t pos = 0;\n    size_t target_len = strlen(target);\n\n    if (!buf) {\n        return target_len + 2; /* size after adding '<' and '>' */\n    }\n\n    if ((target_len + 2) > maxlen) {\n        return CLIF_NO_SPACE;\n    }\n\n    buf[pos++] = LF_PATH_BEGIN_C;\n\n    memcpy(&buf[pos], target, target_len);\n    pos += target_len;\n\n    buf[pos++] = LF_PATH_END_C;\n\n    return pos;\n}\n\nssize_t clif_add_link_separator(char *buf, size_t maxlen)\n{\n    if (!buf) {\n        return 1;\n    }\n\n    if (maxlen < 1) {\n        return CLIF_NO_SPACE;\n    }\n\n    *buf = LF_LINK_SEPARATOR_C;\n    return 1;\n}\n\nssize_t clif_add_attr(clif_attr_t *attr, char *buf, size_t maxlen)\n{\n    assert(attr);\n    assert(attr->key);\n\n    /* if no length given, calculate it */\n    if (!attr->key_len) {\n        attr->key_len = strlen(attr->key);\n    }\n\n    /* count attr name size and separator ';' */\n    size_t req_space = attr->key_len + 1;\n    size_t pos = 0;\n    int quoted = strcmp(attr->key, LF_ATTR_SIZE) ? 1 : 0;\n\n    if (attr->value) {\n        if (!attr->value_len) {\n            attr->value_len = strlen(attr->value);\n        }\n        /* count also '=' */\n        req_space += attr->value_len +  1;\n    }\n\n    if (quoted) {\n        req_space += 2;\n    }\n\n    if (!buf) {\n        return req_space;\n    }\n\n    if (req_space > maxlen) {\n        return CLIF_NO_SPACE;\n    }\n\n    /* add attribute separator ';' */\n    buf[pos++] = LF_ATTR_SEPARATOR_C;\n\n    /* add attribute name */\n    memcpy(&buf[pos], attr->key, attr->key_len);\n    pos += attr->key_len;\n\n    /* add attribute value if defined */\n    if (attr->value) {\n        buf[pos++] = LF_ATTR_VAL_SEPARATOR_C;\n\n        if (quoted) {\n            buf[pos++] = '\"';\n        }\n\n        memcpy(&buf[pos], attr->value, attr->value_len);\n        pos += attr->value_len;\n\n        if (quoted) {\n            buf[pos++] = '\"';\n        }\n    }\n\n    return pos;\n}\n\nssize_t clif_get_target(const char *input, size_t input_len, char **output)\n{\n    assert(input);\n    char *target_end;\n\n    *output = memchr(input, LF_PATH_BEGIN_C, input_len);\n    if (!*output) {\n        DEBUG(\"Path start not found\\n\");\n        return CLIF_NOT_FOUND;\n    }\n    *output += 1;\n\n    target_end = memchr(*output, LF_PATH_END_C, (input + input_len) - *output);\n    if (!target_end) {\n        DEBUG(\"Path end not found\\n\");\n        return CLIF_NOT_FOUND;\n    }\n    ssize_t res = target_end - *output;\n    return res;\n}\n\nssize_t clif_get_attr(const char *input, size_t input_len, clif_attr_t *attr)\n{\n    assert(input);\n    assert(attr);\n    const char *pos = input;\n    const char *end = input + input_len;\n    bool quoted = false;\n    bool scan_value = false;\n\n    /* initialize attr */\n    attr->value = NULL;\n    attr->key = NULL;\n\n    /* an attribute should start with the separator */\n    if (*pos != LF_ATTR_SEPARATOR_C) {\n        DEBUG(\"Attribute should start with separator, found %c\\n\", *pos);\n        return CLIF_NOT_FOUND;\n    }\n    pos++;\n    attr->key = pos;\n\n    /* iterate over key */\n    while (pos < end) {\n        if (*pos == LF_ATTR_SEPARATOR_C || *pos == LF_LINK_SEPARATOR_C) {\n            /* key ends, no value */\n            attr->key_len = pos - attr->key;\n            break;\n        }\n        if (*pos == LF_ATTR_VAL_SEPARATOR_C) {\n            /* key ends, has value */\n            attr->key_len = pos - attr->key;\n            /* check if the value is quoted and prepare pointer for value scan */\n            pos++;\n            if (pos == end) {\n                break;\n            }\n            else if (*pos == '\"') {\n                quoted = true;\n                pos++;\n            }\n            attr->value = (char *)pos;\n            scan_value = true;\n            break;\n        }\n        pos++;\n    }\n\n    if (scan_value) {\n        /* iterate over value */\n        while (pos < end) {\n            if (quoted) {\n                if (*pos == '\"' && *(pos - 1) != '\\\\') {\n                    /* found unescaped quote */\n                    attr->value_len = pos - attr->value;\n                    pos++;\n                    break;\n                }\n            }\n            else {\n                if (*pos == LF_ATTR_SEPARATOR_C || *pos == LF_LINK_SEPARATOR_C) {\n                    /* value ends */\n                    attr->value_len = pos - attr->value;\n                    break;\n                }\n            }\n            pos++;\n        }\n    }\n    else {\n        /* buffer exhausted and no special character found, calculate length of\n        * attribute and exit */\n        attr->key_len = pos - attr->key;\n    }\n\n    return pos - input;\n}\n\nssize_t clif_attr_type_to_str(clif_attr_type_t type, const char **str)\n{\n    if (type < ATTRS_NUMOF) {\n        *str = _attr_to_str[type];\n        return _attr_to_size[type];\n    }\n    return CLIF_NOT_FOUND;\n}\n\nclif_attr_type_t clif_get_attr_type(const char *input, size_t input_len)\n{\n    assert(input);\n    assert(input_len > 0);\n    clif_attr_type_t ret = CLIF_ATTR_EXT;\n    for (unsigned i = 0; i < ATTRS_NUMOF; i++) {\n        if (input_len == _attr_to_size[i] &&\n            !strncmp(input, _attr_to_str[i], input_len)) {\n            ret = i;\n            break;\n        }\n    }\n    return ret;\n}\n\nint clif_init_attr(clif_attr_t *attr, clif_attr_type_t type)\n{\n    assert(attr);\n    attr->key_len = clif_attr_type_to_str(type, &attr->key);\n    return attr->key_len > 0 ? 0 : CLIF_NOT_FOUND;\n}\n", "/*\n* Copyright (C) 2019 HAW Hamburg\n*\n* This file is subject to the terms and conditions of the GNU Lesser\n* General Public License v2.1. See the file LICENSE in the top level\n* directory for more details.\n*/\n\n#include <string.h>\n#include \"embUnit.h\"\n#include \"tests-clif.h\"\n\n#include \"clif.h\"\n\n#ifdef TESTS_CLIF_PRINT\n#include <stdio.h>\nstatic void _print_attr(clif_attr_t *attr)\n{\n    if (attr->key) {\n        printf(\"-- Attr: \");\n        printf(\"%.*s\", attr->key_len, attr->key);\n        if (attr->value) {\n            printf(\" = %.*s\\n\", attr->value_len, attr->value);\n        }\n        else {\n            puts(\"\");\n        }\n    }\n}\n#endif /* TESTS_CLIF_PRINT */\n\n#define _STR_LEN(s) (sizeof(s)-1)\n#define _NEW_ATTR(k, v) { .key = k, .key_len = _STR_LEN(k), .value = v, \\\n                          .value_len = _STR_LEN(v) }\n#define _NEW_ATTR_NO_VAL(k) { .key = k, .key_len = _STR_LEN(k), .value_len = 0 }\n\n/**\n * @brief Compares two link format attributes\n *\n * @param[in] p1 first attribute to compare\n * @param[in] p2 second attribute to compare\n *\n * @return 0 if attributes are equal\n * @return 1 otherwise\n */\nstatic unsigned _compare_attrs(clif_attr_t *p1, clif_attr_t *p2)\n{\n    unsigned result = 1;\n    int res;\n\n    if (p1->key_len != p2->key_len) {\n        goto out;\n    }\n\n    if (strncmp(p1->key, p2->key, p1->key_len)) {\n        goto out;\n    }\n\n    if (!p1->value && !p2->value) {\n        goto success_out;\n    }\n\n    if (!p1->value || !p2->value || (p1->value_len != p2->value_len)) {\n        goto out;\n    }\n\n    res = strncmp(p1->value, p2->value, p1->value_len);\n    if (res != 0) {\n        goto out;\n    }\nsuccess_out:\n    result = 0;\nout:\n    return result;\n}\n\n/* This also tests the functions `clif_add_target` and\n * `clif_add_attr`. */\nstatic void test_clif_encode_links(void)\n{\n    const char exp_string[] = \"</sensor/temp>;rt=\\\"temperature\\\";if=\\\"sensor\\\",\"\n                              \"</node/info>,</node/ep>;ct=\\\"40\\\"\";\n    clif_attr_t attrs[] = {\n        { .key = \"rt\", .value = \"temperature\" },\n        { .key = \"if\", .value = \"sensor\" },\n        { .key = \"ct\", .value = \"40\" }\n    };\n\n    clif_t links[] = {\n        { .target = \"/sensor/temp\", .attrs = attrs, .attrs_len = 2 },\n        { .target = \"/node/info\", .attrs_len = 0 },\n        { .target = \"/node/ep\", .attrs = &attrs[2], .attrs_len = 1 }\n    };\n\n    const size_t exp_size = sizeof(exp_string) - 1;\n    char output[sizeof(exp_string) + 1];\n    size_t pos = 0;\n    ssize_t res = 0;\n\n    /* first test with NULL output to check the needed bytes */\n    res = clif_encode_link(&links[0], NULL, 0);\n    pos += res;\n\n    for (unsigned i = 1; i < ARRAY_SIZE(links); i++) {\n        res = clif_add_link_separator(NULL, 0);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n\n        res = clif_encode_link(&links[i],NULL, 0);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n    }\n\n    TEST_ASSERT_EQUAL_INT(exp_size, pos);\n\n    /* now actually encode the links */\n    pos = 0;\n    res = clif_encode_link(&links[0], output, sizeof(output));\n    pos += res;\n\n    for (unsigned i = 1; i < ARRAY_SIZE(links); i++) {\n        res = clif_add_link_separator(&output[pos], sizeof(output) - pos);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n\n        res = clif_encode_link(&links[i], &output[pos], sizeof(output) - pos);\n        if (res <= 0) {\n            break;\n        }\n        pos += res;\n    }\n    output[pos++] = '\\0';\n\n#ifdef TESTS_CLIF_PRINT\n    puts(\"\\n========================================\");\n    puts(\"[Test: encode_links]\");\n    puts(\"---------------------\");\n    printf(\"Encoded links: %s\\n\", output);\n#endif\n\n    TEST_ASSERT_EQUAL_STRING(exp_string, output);\n    TEST_ASSERT_EQUAL_INT(exp_size, pos - 1); /* do not count '\\0' */\n}\n\n/* This also tests the functions `clif_get_target` and `clif_get_attr` */\nstatic void test_clif_decode_links(void)\n{\n    /* string to decode */\n    char input_string[] = \"</sensors>;ct=40;title=\\\"\\\\\\\"Sensor\\\\\\\" Index, collection\\\",\"\n                          \"</sensors/temp>;rt=\\\"temperature-c\\\";if=\\\"sensor\\\",\"\n                          \"</sensors/light>;rt=\\\"light-lux\\\";if=sensor,\"\n                          \"<http://www.example.com/sensors/t123>;\"\n                          \"anchor=\\\"/sensors/temp\\\";rel=\\\"describedby\\\";sz=1234,\"\n                          \"</t>;anchor=\\\"/sensors/temp\\\";rel=\\\"alternate\\\";a;s=\\\"This is \\\\\\\"escaped and has , \\\\\\\"\\\",\"\n                          \"</riot/board>,</riot/info>;obs\";\n\n    /* ordered expected types to be decoded */\n    clif_attr_type_t exp_types[] = {\n        CLIF_ATTR_CT, CLIF_ATTR_TITLE, CLIF_ATTR_RT, CLIF_ATTR_IF,\n        CLIF_ATTR_RT, CLIF_ATTR_IF, CLIF_ATTR_ANCHOR, CLIF_ATTR_REL,\n        CLIF_ATTR_SZ, CLIF_ATTR_ANCHOR, CLIF_ATTR_REL, CLIF_ATTR_EXT,\n        CLIF_ATTR_EXT, CLIF_ATTR_OBS\n    };\n\n    /* ordered amount of expected attributes per link to be decoded */\n    unsigned exp_attr_numof[] = { 2, 2, 2, 3, 4, 0, 1 };\n\n    /* ordered expected attributes to be decoded */\n    clif_attr_t exp_attrs[] = {\n        _NEW_ATTR(\"ct\", \"40\"),\n        _NEW_ATTR(\"title\", \"\\\\\\\"Sensor\\\\\\\" Index, collection\"),\n        _NEW_ATTR(\"rt\", \"temperature-c\"),\n        _NEW_ATTR(\"if\", \"sensor\"),\n        _NEW_ATTR(\"rt\", \"light-lux\"),\n        _NEW_ATTR(\"if\", \"sensor\"),\n        _NEW_ATTR(\"anchor\", \"/sensors/temp\"),\n        _NEW_ATTR(\"rel\", \"describedby\"),\n        _NEW_ATTR(\"sz\", \"1234\"),\n        _NEW_ATTR(\"anchor\", \"/sensors/temp\"),\n        _NEW_ATTR(\"rel\", \"alternate\"),\n        _NEW_ATTR_NO_VAL(\"a\"),\n        _NEW_ATTR(\"s\", \"This is \\\\\\\"escaped and has , \\\\\\\"\"),\n        _NEW_ATTR_NO_VAL(\"obs\"),\n    };\n\n    /* ordered expected targets to be decoded */\n    const char *exp_targets[] = {\n        \"/sensors\", \"/sensors/temp\", \"/sensors/light\",\n        \"http://www.example.com/sensors/t123\", \"/t\", \"/riot/board\", \"/riot/info\"\n    };\n\n    const unsigned exp_links_numof = ARRAY_SIZE(exp_targets);\n    const unsigned exp_attrs_numof = ARRAY_SIZE(exp_attrs);\n    const size_t input_len = sizeof(input_string) - 1;\n\n    clif_t out_link;\n    char *pos = input_string;\n    unsigned links_numof = 0;\n\n    /* first test without attributes array, to test the expected attributes\n     * functionality */\n    do {\n        ssize_t res = clif_decode_link(&out_link, NULL, 0, pos,\n                                       input_len - (pos - input_string));\n        if (res < 0) {\n            break;\n        }\n        pos += res;\n\n        /* check expected target */\n        TEST_ASSERT(!strncmp(exp_targets[links_numof], out_link.target, out_link.target_len));\n\n        /* check expected amount of attributes */\n        TEST_ASSERT_EQUAL_INT(exp_attr_numof[links_numof], out_link.attrs_len);\n        links_numof++;\n    } while (pos < input_string + sizeof(input_string));\n\n#ifdef TESTS_CLIF_PRINT\n    puts(\"\\n========================================\");\n    puts(\"[Test: decode_links]\");\n    printf(\"- Amount of decoded links: %u\\n\", links_numof);\n#endif\n    TEST_ASSERT(exp_links_numof == links_numof);\n\n    /* now decode again but saving the attributes */\n    clif_attr_t out_attrs[ARRAY_SIZE(exp_attrs)];\n    pos = input_string;\n    unsigned attrs_numof = 0;\n    do {\n        ssize_t res = clif_decode_link(&out_link, &out_attrs[attrs_numof],\n                                       exp_attrs_numof - attrs_numof, pos,\n                                       input_len - (pos - input_string));\n\n        if (res < 0) {\n            break;\n        }\n        pos += res;\n#ifdef TESTS_CLIF_PRINT\n        puts(\"---------------------\");\n        puts(\"New link:\");\n        printf(\"- Target: %.*s\\n\", out_link.target_len, out_link.target);\n        printf(\"- Number of attributes: %d\\n\", out_link.attrs_len);\n#endif\n\n        for (unsigned i = 0; i < out_link.attrs_len; i++) {\n#ifdef TESTS_CLIF_PRINT\n            _print_attr(&out_link.attrs[i]);\n#endif\n            /* compare the attribute structure with the expected one */\n            TEST_ASSERT(!_compare_attrs(&out_link.attrs[i],\n                                         &exp_attrs[attrs_numof]));\n            clif_attr_type_t type = clif_get_attr_type(out_link.attrs[i].key,\n                                                         out_link.attrs[i].key_len);\n\n            /* check that the returned type is the expected one */\n            TEST_ASSERT_EQUAL_INT(exp_types[attrs_numof], type);\n\n            /* test type to string conversion */\n            const char *t;\n            if (clif_attr_type_to_str(type, &t) < 0) {\n                t = NULL;\n            }\n            TEST_ASSERT_EQUAL_STRING(type == CLIF_ATTR_EXT ?\n                                     NULL : exp_attrs[attrs_numof].key, t);\n            attrs_numof++;\n        }\n    } while (pos < input_string + sizeof(input_string));\n    TEST_ASSERT_EQUAL_INT(exp_attrs_numof, attrs_numof);\n}\n\nstatic void test_clif_get_attr_missing_value(void)\n{\n    clif_attr_t attr;\n    char *input = \";ct=\";\n\n    /* Used to result in a spatial memory safety violation.\n     * See: https://github.com/RIOT-OS/RIOT/pull/15945 */\n    int r = clif_get_attr(input, strlen(input), &attr);\n    TEST_ASSERT_EQUAL_INT(strlen(input), r);\n}\n\nTest *tests_clif_tests(void)\n{\n    EMB_UNIT_TESTFIXTURES(fixtures) {\n        new_TestFixture(test_clif_encode_links),\n        new_TestFixture(test_clif_decode_links),\n        new_TestFixture(test_clif_get_attr_missing_value),\n    };\n\n    EMB_UNIT_TESTCALLER(clif_tests, NULL, NULL, fixtures);\n\n    return (Test *)&clif_tests;\n}\n\nvoid tests_clif(void)\n{\n    TESTS_RUN(tests_clif_tests());\n}\n"], "filenames": ["sys/clif/clif.c", "tests/unittests/tests-clif/tests-clif.c"], "buggy_code_start_loc": [281, 276], "buggy_code_end_loc": [282, 282], "fixing_code_start_loc": [281, 277], "fixing_code_end_loc": [285, 294], "type": "CWE-120", "message": "RIOT-OS 2021.01 before commit 609c9ada34da5546cffb632a98b7ba157c112658 contains a buffer overflow that could allow attackers to obtain sensitive information.", "other": {"cve": {"id": "CVE-2021-31661", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-18T22:15:11.903", "lastModified": "2021-06-22T15:46:38.890", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "RIOT-OS 2021.01 before commit 609c9ada34da5546cffb632a98b7ba157c112658 contains a buffer overflow that could allow attackers to obtain sensitive information."}, {"lang": "es", "value": "RIOT-OS 2021.01 anterior al commit 609c9ada34da5546cffb632a98b7ba157c112658, contiene un desbordamiento de b\u00fafer que podr\u00eda permitir a atacantes obtener informaci\u00f3n confidencial"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:riot-os:riot:2021.01:-:*:*:*:*:*:*", "matchCriteriaId": "21164D26-DC7F-423B-9832-2C4C494307E0"}]}]}], "references": [{"url": "https://github.com/RIOT-OS/RIOT/commit/609c9ada34da5546cffb632a98b7ba157c112658", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/RIOT-OS/RIOT/pull/15945", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/RIOT-OS/RIOT/commit/609c9ada34da5546cffb632a98b7ba157c112658"}}