{"buggy_code": ["# Changelog\n\n## v0.13\n\n### Bug Fixes\n\n- Fix `slice` support by making it a configurable option\n\n## v0.12\n\n### New Features\n\n- Allow setting which **Systemd Slice** users' services should belong to.\n  This lets admins set policy for all JupyterHub users in one go.\n  [Thanks to [@mariusvniekerk](https://github.com/mariusvniekerk)]\n\n### Bug Fixes\n\n- Handle failed units that need reset.\n  [thanks to [@RohitK89](https://github.com/RohitK89)]\n- Fix bug in cleaning up services from a previously running\n  JupyterHub. [thanks to [@minrk](https://github.com/minrk)]\n\n## v0.11\n\n### New Features\n\n- **Username templates** let you map jupyterhub usernames to different system usernames. Extremely\n  useful for prefixing usernames to prevent collisions.\n\n### Bug fixes\n\n- Users' home directories now properly read from pwd database, rather than assumed to be under `/home`.\n  Thanks to [@cpainterwakefield](https://github.com/cpainterwakefield) for reporting & suggested PR!\n\n## v0.10\n\n### Breaking changes\n\n- `use_sudo` option is no longer supported. It offered questionable security,\n  and complicated the code unnecessarily. If 'securely run as normal user with\n  sudo' is a required feature, we can re-implement it securely later.\n- If a path in `readonly_paths` does not exist, spawning user will now fail.\n\n### New features\n\n- **Dynamic users** support, creating users as required with their own\n  persistent homes with systemd's [dynamic users](http://0pointer.net/blog/dynamic-users-with-systemd.html)\n  feature. Useful for using with tmpnb.\n- **Add additional properties** to the user's systemd unit with `unit_extra_properties`.\n  Thanks to [@kfix](https://github.com/kfix) for most of the work!\n\n### Bug fixes\n\n- If a user's notebook server service is already running, kill it before\n  attempting to start a new one. [GitHub Issue](https://github.com/jupyterhub/systemdspawner/issues/7)\n\n### Dependency changes\n\n- Python 3.5 is the minimum supported Python version.\n- JupyterHub 0.9 is the minimum supported JupyterHub version.\n- Tornado 5.0 is the minimum supported Tornado version.\n", "from setuptools import setup\n\nsetup(\n    name='jupyterhub-systemdspawner',\n    version='0.14',\n    description='JupyterHub Spawner using systemd for resource isolation',\n    long_description='See https://github.com/jupyterhub/systemdspawner for more info',\n    url='https://github.com/jupyterhub/systemdspawner',\n    author='Yuvi Panda',\n    author_email='yuvipanda@gmail.com',\n    license='3 Clause BSD',\n    packages=['systemdspawner'],\n    entry_points={\n        'jupyterhub.spawners': [\n            'systemdspawner = systemdspawner:SystemdSpawner',\n        ],\n    },\n    install_requires=[\n        'jupyterhub>=0.9',\n        'tornado>=5.0'\n    ],\n)\n", "\"\"\"\nSystemd service utilities.\n\nContains functions to start, stop & poll systemd services.\nProbably not very useful outside this spawner.\n\"\"\"\nimport asyncio\nimport shlex\n\n\nasync def start_transient_service(\n    unit_name,\n    cmd,\n    args,\n    working_dir,\n    environment_variables=None,\n    properties=None,\n    uid=None,\n    gid=None,\n    slice=None,\n):\n    \"\"\"\n    Start a systemd transient service with given paramters\n    \"\"\"\n\n    run_cmd = [\n        'systemd-run',\n        '--unit', unit_name,\n    ]\n\n    if properties:\n        for key, value in properties.items():\n            if isinstance(value, list):\n                run_cmd += ['--property={}={}'.format(key, v) for v in value]\n            else:\n                # A string!\n                run_cmd.append('--property={}={}'.format(key, value))\n\n    if environment_variables:\n        run_cmd += [\n            '--setenv={}={}'.format(key, value)\n            for key, value in environment_variables.items()\n        ]\n\n    # Explicitly check if uid / gid are not None, since 0 is valid value for both\n    if uid is not None:\n        run_cmd += ['--uid', str(uid)]\n\n    if gid is not None:\n        run_cmd += ['--gid', str(gid)]\n\n    if slice is not None:\n        run_cmd += ['--slice={}'.format(slice)]\n    \n    # We unfortunately have to resort to doing cd with bash, since WorkingDirectory property\n    # of systemd units can't be set for transient units via systemd-run until systemd v227.\n    # Centos 7 has systemd 219, and will probably never upgrade - so we need to support them.\n    run_cmd += [\n        '/bin/bash',\n        '-c',\n        \"cd {wd} && exec {cmd} {args}\".format(\n            wd=shlex.quote(working_dir),\n            cmd=' '.join([shlex.quote(c) for c in cmd]),\n            args=' '.join([shlex.quote(a) for a in args])\n        )\n    ]\n\n    proc = await asyncio.create_subprocess_exec(*run_cmd)\n\n    return await proc.wait()\n\n\nasync def service_running(unit_name):\n    \"\"\"\n    Return true if service with given name is running (active).\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'is-active',\n        unit_name,\n        # hide stdout, but don't capture stderr at all\n        stdout=asyncio.subprocess.DEVNULL\n    )\n    ret = await proc.wait()\n\n    return ret == 0\n\n\nasync def service_failed(unit_name):\n    \"\"\"\n    Return true if service with given name is in a failed state.\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'is-failed',\n        unit_name,\n        # hide stdout, but don't capture stderr at all\n        stdout=asyncio.subprocess.DEVNULL\n    )\n    ret = await proc.wait()\n\n    return ret == 0\n\n\nasync def stop_service(unit_name):\n    \"\"\"\n    Stop service with given name.\n\n    Throws CalledProcessError if stopping fails\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'stop',\n        unit_name\n    )\n    await proc.wait()\n\n\nasync def reset_service(unit_name):\n    \"\"\"\n    Reset service with given name.\n\n    Throws CalledProcessError if resetting fails\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'reset-failed',\n        unit_name\n    )\n    await proc.wait()\n", "\"\"\"\nTest systemd wrapper utilities.\n\nMust run as root.\n\"\"\"\nimport tempfile\nfrom systemdspawner import systemd\nimport pytest\nimport asyncio\nimport os\nimport time\n\n\n@pytest.mark.asyncio\nasync def test_simple_start():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    await systemd.start_transient_service(\n        unit_name,\n        ['sleep'],\n        ['2000'],\n        working_dir='/'\n    )\n\n    assert await systemd.service_running(unit_name)\n\n    await systemd.stop_service(unit_name)\n\n    assert not await systemd.service_running(unit_name)\n\n\n@pytest.mark.asyncio\nasync def test_service_failed_reset():\n    \"\"\"\n    Test service_failed and reset_service\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    # Running a service with an invalid UID makes it enter a failed state\n    await systemd.start_transient_service(\n        unit_name,\n        ['sleep'],\n        ['2000'],\n        working_dir='/systemdspawner-unittest-does-not-exist'\n    )\n\n    await asyncio.sleep(0.1)\n\n    assert await systemd.service_failed(unit_name)\n\n    await systemd.reset_service(unit_name)\n\n    assert not await systemd.service_failed(unit_name)\n\n\n@pytest.mark.asyncio\nasync def test_service_running_fail():\n    \"\"\"\n    Test service_running failing when there's no service.\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n\n    assert not await systemd.service_running(unit_name)\n\n\n@pytest.mark.asyncio\nasync def test_env_setting():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'env > {}/env'.format(d)],\n            working_dir='/',\n            environment_variables={\n                'TESTING_SYSTEMD_ENV_1': 'TEST_1',\n                'TESTING_SYSTEMD_ENV_2': 'TEST_2'\n            }\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n        with open(os.path.join(d, 'env')) as f:\n            text = f.read()\n            assert 'TESTING_SYSTEMD_ENV_1=TEST_1' in text\n            assert 'TESTING_SYSTEMD_ENV_2=TEST_2' in text\n\n\n@pytest.mark.asyncio\nasync def test_workdir():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > {}/pwd'.format(d)],\n            working_dir=d,\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n \n        with open(os.path.join(d, 'pwd')) as f:\n            text = f.read().strip()\n            assert text == d\n\n\n@pytest.mark.asyncio\nasync def test_slice():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > {}/pwd; sleep 10;'.format(d)],\n            working_dir=d,\n            slice='user.slice',\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n\n        proc = await asyncio.create_subprocess_exec(\n            *['systemctl', 'status', unit_name],\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE)\n\n        stdout, stderr = await proc.communicate()\n        assert b'user.slice' in stdout\n\n\n@pytest.mark.asyncio\nasync def test_properties_string():\n    \"\"\"\n    Test that setting string properties works\n\n    - Make a temporary directory\n    - Bind mount temporary directory to /bind-test\n    - Start process in /bind-test, write to current-directory/pwd the working directory\n    - Read it from the *temporary* directory, verify it is /bind-test\n\n    This validates the Bind Mount is working, and hence properties are working.\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > pwd'.format(d)],\n            working_dir='/bind-test',\n            properties={\n                'BindPaths': '{}:/bind-test'.format(d)\n            }\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n        with open(os.path.join(d, 'pwd')) as f:\n            text = f.read().strip()\n            assert text == '/bind-test'\n\n\n@pytest.mark.asyncio\nasync def test_properties_list():\n    \"\"\"\n    Test setting multiple values for a property\n\n    - Make a temporary directory\n    - Before starting process, run two mkdir commands to create a nested\n      directory. These commands must be run in order by systemd, otherewise\n      they will fail. This validates that ordering behavior is preserved.\n    - Start a process in temporary directory\n    - Write current directory to nested directory created in ExecPreStart\n\n    This validates multiple ordered ExcePreStart calls are working, and hence\n    properties with lists as values are working.\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > test-1/test-2/pwd'],\n            working_dir=d,\n            properties={\n                \"ExecStartPre\": [\n                    f\"/bin/mkdir -p {d}/test-1/test-2\",\n                ],\n            },\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n        with open(os.path.join(d, 'test-1', 'test-2', 'pwd')) as f:\n            text = f.read().strip()\n            assert text == d\n\n\n@pytest.mark.asyncio\nasync def test_uid_gid():\n    \"\"\"\n    Test setting uid and gid\n\n    - Make a temporary directory\n    - Run service as uid 65534 (nobody) and gid 0 (root)\n    - Verify the output of the 'id' command\n\n    This validates that setting uid sets uid, gid sets the gid\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        os.chmod(d, 0o777)\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'id > id'],\n            working_dir=d,\n            uid=65534,\n            gid=0\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.2)\n        with open(os.path.join(d, 'id')) as f:\n            text = f.read().strip()\n            assert text == 'uid=65534(nobody) gid=0(root) groups=0(root)'\n"], "fixing_code": ["# Changelog\n\n## v0.15\n\nFixes vulnerability [GHSA-cg54-gpgr-4rm6](https://github.com/jupyterhub/systemdspawner/security/advisories/GHSA-cg54-gpgr-4rm6) affecting all previous releases.\n\n- Use EnvironmentFile to pass environment variables to units.\n\n## v0.14\n\n- define entrypoints for JupyterHub spawner configuration\n- Fixes for CentOS 7\n\n## v0.13\n\n### Bug Fixes\n\n- Fix `slice` support by making it a configurable option\n\n## v0.12\n\n### New Features\n\n- Allow setting which **Systemd Slice** users' services should belong to.\n  This lets admins set policy for all JupyterHub users in one go.\n  [Thanks to [@mariusvniekerk](https://github.com/mariusvniekerk)]\n\n### Bug Fixes\n\n- Handle failed units that need reset.\n  [thanks to [@RohitK89](https://github.com/RohitK89)]\n- Fix bug in cleaning up services from a previously running\n  JupyterHub. [thanks to [@minrk](https://github.com/minrk)]\n\n## v0.11\n\n### New Features\n\n- **Username templates** let you map jupyterhub usernames to different system usernames. Extremely\n  useful for prefixing usernames to prevent collisions.\n\n### Bug fixes\n\n- Users' home directories now properly read from pwd database, rather than assumed to be under `/home`.\n  Thanks to [@cpainterwakefield](https://github.com/cpainterwakefield) for reporting & suggested PR!\n\n## v0.10\n\n### Breaking changes\n\n- `use_sudo` option is no longer supported. It offered questionable security,\n  and complicated the code unnecessarily. If 'securely run as normal user with\n  sudo' is a required feature, we can re-implement it securely later.\n- If a path in `readonly_paths` does not exist, spawning user will now fail.\n\n### New features\n\n- **Dynamic users** support, creating users as required with their own\n  persistent homes with systemd's [dynamic users](http://0pointer.net/blog/dynamic-users-with-systemd.html)\n  feature. Useful for using with tmpnb.\n- **Add additional properties** to the user's systemd unit with `unit_extra_properties`.\n  Thanks to [@kfix](https://github.com/kfix) for most of the work!\n\n### Bug fixes\n\n- If a user's notebook server service is already running, kill it before\n  attempting to start a new one. [GitHub Issue](https://github.com/jupyterhub/systemdspawner/issues/7)\n\n### Dependency changes\n\n- Python 3.5 is the minimum supported Python version.\n- JupyterHub 0.9 is the minimum supported JupyterHub version.\n- Tornado 5.0 is the minimum supported Tornado version.\n", "from setuptools import setup\n\nsetup(\n    name='jupyterhub-systemdspawner',\n    version='0.15.0',\n    description='JupyterHub Spawner using systemd for resource isolation',\n    long_description='See https://github.com/jupyterhub/systemdspawner for more info',\n    url='https://github.com/jupyterhub/systemdspawner',\n    author='Yuvi Panda',\n    author_email='yuvipanda@gmail.com',\n    license='3 Clause BSD',\n    packages=['systemdspawner'],\n    entry_points={\n        'jupyterhub.spawners': [\n            'systemdspawner = systemdspawner:SystemdSpawner',\n        ],\n    },\n    install_requires=[\n        'jupyterhub>=0.9',\n        'tornado>=5.0'\n    ],\n)\n", "\"\"\"\nSystemd service utilities.\n\nContains functions to start, stop & poll systemd services.\nProbably not very useful outside this spawner.\n\"\"\"\n\nimport asyncio\nimport os\nimport re\nimport shlex\nimport warnings\n\n# light validation of environment variable keys\nenv_pat = re.compile(\"[A-Za-z_]+\")\n\nRUN_ROOT = \"/run\"\n\ndef ensure_environment_directory(environment_file_directory):\n    \"\"\"Ensure directory for environment files exists and is private\"\"\"\n    # ensure directory exists\n    os.makedirs(environment_file_directory, mode=0o700, exist_ok=True)\n    # validate permissions\n    mode = os.stat(environment_file_directory).st_mode\n    if mode & 0o077:\n        warnings.warn(\n            f\"Fixing permissions on environment directory {environment_file_directory}: {oct(mode)}\",\n            RuntimeWarning,\n        )\n        os.chmod(environment_file_directory, 0o700)\n    else:\n        return\n    # Check again after supposedly fixing.\n    # Some filesystems can have weird issues, preventing this from having desired effect\n    mode = os.stat(environment_file_directory).st_mode\n    if mode & 0o077:\n        warnings.warn(\n            f\"Bad permissions on environment directory {environment_file_directory}: {oct(mode)}\",\n            RuntimeWarning,\n        )\n\n\ndef make_environment_file(environment_file_directory, unit_name, environment_variables):\n    \"\"\"Make a systemd environment file\n\n    - ensures environment directory exists and is private\n    - writes private environment file\n    - returns path to created environment file\n    \"\"\"\n    ensure_environment_directory(environment_file_directory)\n    env_file = os.path.join(environment_file_directory, f\"{unit_name}.env\")\n    env_lines = []\n    for key, value in sorted(environment_variables.items()):\n        assert env_pat.match(key), f\"{key} not a valid environment variable\"\n        env_lines.append(f\"{key}={shlex.quote(value)}\")\n    env_lines.append(\"\")  # trailing newline\n    with open(env_file, mode=\"w\") as f:\n        # make the file itself private as well\n        os.fchmod(f.fileno(), 0o400)\n        f.write(\"\\n\".join(env_lines))\n\n    return env_file\n\n\nasync def start_transient_service(\n    unit_name,\n    cmd,\n    args,\n    working_dir,\n    environment_variables=None,\n    properties=None,\n    uid=None,\n    gid=None,\n    slice=None,\n):\n    \"\"\"\n    Start a systemd transient service with given parameters\n    \"\"\"\n\n    run_cmd = [\n        'systemd-run',\n        '--unit', unit_name,\n    ]\n\n    if properties is None:\n        properties = {}\n    else:\n        properties = properties.copy()\n\n    # ensure there is a runtime directory where we can put our env file\n    # If already set, can be space-separated list of paths\n    runtime_directories = properties.setdefault(\"RuntimeDirectory\", unit_name).split()\n\n    # runtime directories are always resolved relative to `/run`\n    # grab the first item, if more than one\n    runtime_dir = os.path.join(RUN_ROOT, runtime_directories[0])\n    # make runtime directories private by default\n    properties.setdefault(\"RuntimeDirectoryMode\", \"700\")\n    # preserve runtime directories across restarts\n    # allows `systemctl restart` to load the env\n    properties.setdefault(\"RuntimeDirectoryPreserve\", \"restart\")\n\n    if properties:\n        for key, value in properties.items():\n            if isinstance(value, list):\n                run_cmd += ['--property={}={}'.format(key, v) for v in value]\n            else:\n                # A string!\n                run_cmd.append('--property={}={}'.format(key, value))\n\n    if environment_variables:\n        environment_file = make_environment_file(\n            runtime_dir, unit_name, environment_variables\n        )\n        run_cmd.append(f\"--property=EnvironmentFile={environment_file}\")\n\n    # Explicitly check if uid / gid are not None, since 0 is valid value for both\n    if uid is not None:\n        run_cmd += ['--uid', str(uid)]\n\n    if gid is not None:\n        run_cmd += ['--gid', str(gid)]\n\n    if slice is not None:\n        run_cmd += ['--slice={}'.format(slice)]\n\n    # We unfortunately have to resort to doing cd with bash, since WorkingDirectory property\n    # of systemd units can't be set for transient units via systemd-run until systemd v227.\n    # Centos 7 has systemd 219, and will probably never upgrade - so we need to support them.\n    run_cmd += [\n        '/bin/bash',\n        '-c',\n        \"cd {wd} && exec {cmd} {args}\".format(\n            wd=shlex.quote(working_dir),\n            cmd=' '.join([shlex.quote(c) for c in cmd]),\n            args=' '.join([shlex.quote(a) for a in args])\n        )\n    ]\n\n    proc = await asyncio.create_subprocess_exec(*run_cmd)\n\n    return await proc.wait()\n\n\nasync def service_running(unit_name):\n    \"\"\"\n    Return true if service with given name is running (active).\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'is-active',\n        unit_name,\n        # hide stdout, but don't capture stderr at all\n        stdout=asyncio.subprocess.DEVNULL\n    )\n    ret = await proc.wait()\n\n    return ret == 0\n\n\nasync def service_failed(unit_name):\n    \"\"\"\n    Return true if service with given name is in a failed state.\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'is-failed',\n        unit_name,\n        # hide stdout, but don't capture stderr at all\n        stdout=asyncio.subprocess.DEVNULL\n    )\n    ret = await proc.wait()\n\n    return ret == 0\n\n\nasync def stop_service(unit_name):\n    \"\"\"\n    Stop service with given name.\n\n    Throws CalledProcessError if stopping fails\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'stop',\n        unit_name\n    )\n    await proc.wait()\n\n\nasync def reset_service(unit_name):\n    \"\"\"\n    Reset service with given name.\n\n    Throws CalledProcessError if resetting fails\n    \"\"\"\n    proc = await asyncio.create_subprocess_exec(\n        'systemctl',\n        'reset-failed',\n        unit_name\n    )\n    await proc.wait()\n", "\"\"\"\nTest systemd wrapper utilities.\n\nMust run as root.\n\"\"\"\nimport tempfile\nfrom systemdspawner import systemd\nimport pytest\nimport asyncio\nimport os\nimport time\n\n\n@pytest.mark.asyncio\nasync def test_simple_start():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    await systemd.start_transient_service(\n        unit_name,\n        ['sleep'],\n        ['2000'],\n        working_dir='/'\n    )\n\n    assert await systemd.service_running(unit_name)\n\n    await systemd.stop_service(unit_name)\n\n    assert not await systemd.service_running(unit_name)\n\n\n@pytest.mark.asyncio\nasync def test_service_failed_reset():\n    \"\"\"\n    Test service_failed and reset_service\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    # Running a service with an invalid UID makes it enter a failed state\n    await systemd.start_transient_service(\n        unit_name,\n        ['sleep'],\n        ['2000'],\n        working_dir='/systemdspawner-unittest-does-not-exist'\n    )\n\n    await asyncio.sleep(0.1)\n\n    assert await systemd.service_failed(unit_name)\n\n    await systemd.reset_service(unit_name)\n\n    assert not await systemd.service_failed(unit_name)\n\n\n@pytest.mark.asyncio\nasync def test_service_running_fail():\n    \"\"\"\n    Test service_running failing when there's no service.\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n\n    assert not await systemd.service_running(unit_name)\n\n\n@pytest.mark.asyncio\nasync def test_env_setting():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    with tempfile.TemporaryDirectory() as d:\n        os.chmod(d, 0o777)\n        await systemd.start_transient_service(\n            unit_name,\n            [\"/bin/bash\"],\n            [\"-c\", \"pwd; ls -la {0}; env > ./env; sleep 3\".format(d)],\n            working_dir=d,\n            environment_variables={\n                \"TESTING_SYSTEMD_ENV_1\": \"TEST 1\",\n                \"TESTING_SYSTEMD_ENV_2\": \"TEST 2\",\n            },\n            # set user to ensure we are testing permission issues\n            properties={\n                \"User\": \"65534\",\n            },\n        )\n        env_dir = os.path.join(systemd.RUN_ROOT, unit_name)\n        assert os.path.isdir(env_dir)\n        assert (os.stat(env_dir).st_mode & 0o777) == 0o700\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n        assert await systemd.service_running(unit_name)\n\n        env_file = os.path.join(env_dir, f\"{unit_name}.env\")\n        assert os.path.exists(env_file)\n        assert (os.stat(env_file).st_mode & 0o777) == 0o400\n        # verify that the env had the desired effect\n        with open(os.path.join(d, 'env')) as f:\n            text = f.read()\n            assert \"TESTING_SYSTEMD_ENV_1=TEST 1\" in text\n            assert \"TESTING_SYSTEMD_ENV_2=TEST 2\" in text\n\n        await systemd.stop_service(unit_name)\n        assert not await systemd.service_running(unit_name)\n        # systemd cleans up env file\n        assert not os.path.exists(env_file)\n\n\n@pytest.mark.asyncio\nasync def test_workdir():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > {}/pwd'.format(d)],\n            working_dir=d,\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n \n        with open(os.path.join(d, 'pwd')) as f:\n            text = f.read().strip()\n            assert text == d\n\n\n@pytest.mark.asyncio\nasync def test_slice():\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > {}/pwd; sleep 10;'.format(d)],\n            working_dir=d,\n            slice='user.slice',\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n\n        proc = await asyncio.create_subprocess_exec(\n            *['systemctl', 'status', unit_name],\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE)\n\n        stdout, stderr = await proc.communicate()\n        assert b'user.slice' in stdout\n\n\n@pytest.mark.asyncio\nasync def test_properties_string():\n    \"\"\"\n    Test that setting string properties works\n\n    - Make a temporary directory\n    - Bind mount temporary directory to /bind-test\n    - Start process in /bind-test, write to current-directory/pwd the working directory\n    - Read it from the *temporary* directory, verify it is /bind-test\n\n    This validates the Bind Mount is working, and hence properties are working.\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > pwd'.format(d)],\n            working_dir='/bind-test',\n            properties={\n                'BindPaths': '{}:/bind-test'.format(d)\n            }\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n        with open(os.path.join(d, 'pwd')) as f:\n            text = f.read().strip()\n            assert text == '/bind-test'\n\n\n@pytest.mark.asyncio\nasync def test_properties_list():\n    \"\"\"\n    Test setting multiple values for a property\n\n    - Make a temporary directory\n    - Before starting process, run two mkdir commands to create a nested\n      directory. These commands must be run in order by systemd, otherewise\n      they will fail. This validates that ordering behavior is preserved.\n    - Start a process in temporary directory\n    - Write current directory to nested directory created in ExecPreStart\n\n    This validates multiple ordered ExcePreStart calls are working, and hence\n    properties with lists as values are working.\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'pwd > test-1/test-2/pwd'],\n            working_dir=d,\n            properties={\n                \"ExecStartPre\": [\n                    f\"/bin/mkdir -p {d}/test-1/test-2\",\n                ],\n            },\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.1)\n        with open(os.path.join(d, 'test-1', 'test-2', 'pwd')) as f:\n            text = f.read().strip()\n            assert text == d\n\n\n@pytest.mark.asyncio\nasync def test_uid_gid():\n    \"\"\"\n    Test setting uid and gid\n\n    - Make a temporary directory\n    - Run service as uid 65534 (nobody) and gid 0 (root)\n    - Verify the output of the 'id' command\n\n    This validates that setting uid sets uid, gid sets the gid\n    \"\"\"\n    unit_name = 'systemdspawner-unittest-' + str(time.time())\n    _, env_filename = tempfile.mkstemp()\n    with tempfile.TemporaryDirectory() as d:\n        os.chmod(d, 0o777)\n        await systemd.start_transient_service(\n            unit_name,\n            ['/bin/bash'],\n            ['-c', 'id > id'],\n            working_dir=d,\n            uid=65534,\n            gid=0\n        )\n\n        # Wait a tiny bit for the systemd unit to complete running\n        await asyncio.sleep(0.2)\n        with open(os.path.join(d, 'id')) as f:\n            text = f.read().strip()\n            assert text == 'uid=65534(nobody) gid=0(root) groups=0(root)'\n"], "filenames": ["CHANGELOG.md", "setup.py", "systemdspawner/systemd.py", "tests/test_systemd.py"], "buggy_code_start_loc": [1, 5, 6, 68], "buggy_code_end_loc": [1, 6, 55, 85], "fixing_code_start_loc": [2, 5, 7, 68], "fixing_code_end_loc": [13, 6, 127, 104], "type": "CWE-668", "message": "jupyterhub-systemdspawner enables JupyterHub to spawn single-user notebook servers using systemd. In jupyterhub-systemdspawner before version 0.15 user API tokens issued to single-user servers are specified in the environment of systemd units. These tokens are incorrectly accessible to all users. In particular, the-littlest-jupyterhub is affected, which uses systemdspawner by default. This is patched in jupyterhub-systemdspawner v0.15", "other": {"cve": {"id": "CVE-2020-26261", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-09T17:15:30.603", "lastModified": "2020-12-10T21:46:28.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "jupyterhub-systemdspawner enables JupyterHub to spawn single-user notebook servers using systemd. In jupyterhub-systemdspawner before version 0.15 user API tokens issued to single-user servers are specified in the environment of systemd units. These tokens are incorrectly accessible to all users. In particular, the-littlest-jupyterhub is affected, which uses systemdspawner by default. This is patched in jupyterhub-systemdspawner v0.15"}, {"lang": "es", "value": "jupyterhub-systemdspawner permite que JupyterHub genere servidores de port\u00e1tiles de un solo usuario utilizando systemd.&#xa0;En jupyterhub-systemdspawner, versiones anteriores a 0.15, los tokens de la API de usuario emitidos a servidores de un solo usuario son especificados en el entorno de las unidades systemd.&#xa0;Estos tokens son incorrectamente accesibles para todos los usuarios.&#xa0;En particular, est\u00e1 afectado the-littlest-jupyterhub, que usa systemdspawner por defecto.&#xa0;Esto est\u00e1 parcheado en jupyterhub-systemdspawner versi\u00f3n v0.15"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 5.8}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.9, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.5, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jupyterhub:systemdspawner:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.15", "matchCriteriaId": "175655AE-2247-4426-8AE8-0AD5532FBC50"}]}]}], "references": [{"url": "https://github.com/jupyterhub/systemdspawner/blob/master/CHANGELOG.md#v015", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/jupyterhub/systemdspawner/commit/a4d08fd2ade1cfd0ef2c29dc221e649345f23580", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jupyterhub/systemdspawner/security/advisories/GHSA-cg54-gpgr-4rm6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://pypi.org/project/jupyterhub-systemdspawner/", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jupyterhub/systemdspawner/commit/a4d08fd2ade1cfd0ef2c29dc221e649345f23580"}}