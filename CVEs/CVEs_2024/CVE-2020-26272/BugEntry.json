{"buggy_code": ["# IpcMainEvent Object extends `Event`\n\n* `frameId` Integer - The ID of the renderer frame that sent this message\n* `returnValue` any - Set this to the value to be returned in a synchronous message\n* `sender` WebContents - Returns the `webContents` that sent the message\n* `ports` MessagePortMain[] - A list of MessagePorts that were transferred with this message\n* `reply` Function - A function that will send an IPC message to the renderer frame that sent the original message that you are currently handling.  You should use this method to \"reply\" to the sent message in order to guarantee the reply will go to the correct process and frame.\n  * `channel` String\n  * `...args` any[]\n", "# IpcMainInvokeEvent Object extends `Event`\n\n* `frameId` Integer - The ID of the renderer frame that sent this message\n* `sender` WebContents - Returns the `webContents` that sent the message\n", "# webContents\n\n> Render and control web pages.\n\nProcess: [Main](../glossary.md#main-process)\n\n`webContents` is an [EventEmitter][event-emitter].\nIt is responsible for rendering and controlling a web page and is a property of\nthe [`BrowserWindow`](browser-window.md) object. An example of accessing the\n`webContents` object:\n\n```javascript\nconst { BrowserWindow } = require('electron')\n\nconst win = new BrowserWindow({ width: 800, height: 1500 })\nwin.loadURL('http://github.com')\n\nconst contents = win.webContents\nconsole.log(contents)\n```\n\n## Methods\n\nThese methods can be accessed from the `webContents` module:\n\n```javascript\nconst { webContents } = require('electron')\nconsole.log(webContents)\n```\n\n### `webContents.getAllWebContents()`\n\nReturns `WebContents[]` - An array of all `WebContents` instances. This will contain web contents\nfor all windows, webviews, opened devtools, and devtools extension background pages.\n\n### `webContents.getFocusedWebContents()`\n\nReturns `WebContents` - The web contents that is focused in this application, otherwise\nreturns `null`.\n\n### `webContents.fromId(id)`\n\n* `id` Integer\n\nReturns `WebContents` | undefined - A WebContents instance with the given ID, or\n`undefined` if there is no WebContents associated with the given ID.\n\n## Class: WebContents\n\n> Render and control the contents of a BrowserWindow instance.\n\nProcess: [Main](../glossary.md#main-process)\n\n### Instance Events\n\n#### Event: 'did-finish-load'\n\nEmitted when the navigation is done, i.e. the spinner of the tab has stopped\nspinning, and the `onload` event was dispatched.\n\n#### Event: 'did-fail-load'\n\nReturns:\n\n* `event` Event\n* `errorCode` Integer\n* `errorDescription` String\n* `validatedURL` String\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nThis event is like `did-finish-load` but emitted when the load failed.\nThe full list of error codes and their meaning is available [here](https://source.chromium.org/chromium/chromium/src/+/master:net/base/net_error_list.h).\n\n#### Event: 'did-fail-provisional-load'\n\nReturns:\n\n* `event` Event\n* `errorCode` Integer\n* `errorDescription` String\n* `validatedURL` String\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nThis event is like `did-fail-load` but emitted when the load was cancelled\n(e.g. `window.stop()` was invoked).\n\n#### Event: 'did-frame-finish-load'\n\nReturns:\n\n* `event` Event\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when a frame has done navigation.\n\n#### Event: 'did-start-loading'\n\nCorresponds to the points in time when the spinner of the tab started spinning.\n\n#### Event: 'did-stop-loading'\n\nCorresponds to the points in time when the spinner of the tab stopped spinning.\n\n#### Event: 'dom-ready'\n\nReturns:\n\n* `event` Event\n\nEmitted when the document in the given frame is loaded.\n\n#### Event: 'page-title-updated'\n\nReturns:\n\n* `event` Event\n* `title` String\n* `explicitSet` Boolean\n\nFired when page title is set during navigation. `explicitSet` is false when\ntitle is synthesized from file url.\n\n#### Event: 'page-favicon-updated'\n\nReturns:\n\n* `event` Event\n* `favicons` String[] - Array of URLs.\n\nEmitted when page receives favicon urls.\n\n#### Event: 'new-window' _Deprecated_\n\nReturns:\n\n* `event` NewWindowWebContentsEvent\n* `url` String\n* `frameName` String\n* `disposition` String - Can be `default`, `foreground-tab`, `background-tab`,\n  `new-window`, `save-to-disk` and `other`.\n* `options` BrowserWindowConstructorOptions - The options which will be used for creating the new\n  [`BrowserWindow`](browser-window.md).\n* `additionalFeatures` String[] - The non-standard features (features not handled\n  by Chromium or Electron) given to `window.open()`.\n* `referrer` [Referrer](structures/referrer.md) - The referrer that will be\n  passed to the new window. May or may not result in the `Referer` header being\n  sent, depending on the referrer policy.\n* `postBody` [PostBody](structures/post-body.md) (optional) - The post data that\n  will be sent to the new window, along with the appropriate headers that will\n  be set. If no post data is to be sent, the value will be `null`. Only defined\n  when the window is being created by a form that set `target=_blank`.\n\nDeprecated in favor of [`webContents.setWindowOpenHandler`](web-contents.md#contentssetwindowopenhandlerhandler).\n\nEmitted when the page requests to open a new window for a `url`. It could be\nrequested by `window.open` or an external link like `<a target='_blank'>`.\n\nBy default a new `BrowserWindow` will be created for the `url`.\n\nCalling `event.preventDefault()` will prevent Electron from automatically creating a\nnew [`BrowserWindow`](browser-window.md). If you call `event.preventDefault()` and manually create a new\n[`BrowserWindow`](browser-window.md) then you must set `event.newGuest` to reference the new [`BrowserWindow`](browser-window.md)\ninstance, failing to do so may result in unexpected behavior. For example:\n\n```javascript\nmyBrowserWindow.webContents.on('new-window', (event, url, frameName, disposition, options, additionalFeatures, referrer, postBody) => {\n  event.preventDefault()\n  const win = new BrowserWindow({\n    webContents: options.webContents, // use existing webContents if provided\n    show: false\n  })\n  win.once('ready-to-show', () => win.show())\n  if (!options.webContents) {\n    const loadOptions = {\n      httpReferrer: referrer\n    }\n    if (postBody != null) {\n      const { data, contentType, boundary } = postBody\n      loadOptions.postData = postBody.data\n      loadOptions.extraHeaders = `content-type: ${contentType}; boundary=${boundary}`\n    }\n\n    win.loadURL(url, loadOptions) // existing webContents will be navigated automatically\n  }\n  event.newGuest = win\n})\n```\n\n#### Event: 'did-create-window'\n\nReturns:\n\n* `window` BrowserWindow\n* `details` Object\n  * `url` String - URL for the created window.\n  * `frameName` String - Name given to the created window in the\n     `window.open()` call.\n  * `options` BrowserWindowConstructorOptions - The options used to create the\n    BrowserWindow. They are merged in increasing precedence: options inherited\n    from the parent, parsed options from the `features` string from\n    `window.open()`, and options given by\n    [`webContents.setWindowOpenHandler`](web-contents.md#contentssetwindowopenhandlerhandler).\n    Unrecognized options are not filtered out.\n  * `additionalFeatures` String[] - The non-standard features (features not\n    handled Chromium or Electron) _Deprecated_\n  * `referrer` [Referrer](structures/referrer.md) - The referrer that will be\n    passed to the new window. May or may not result in the `Referer` header\n    being sent, depending on the referrer policy.\n  * `postBody` [PostBody](structures/post-body.md) (optional) - The post data\n    that will be sent to the new window, along with the appropriate headers\n    that will be set. If no post data is to be sent, the value will be `null`.\n    Only defined when the window is being created by a form that set\n    `target=_blank`.\n  * `disposition` String - Can be `default`, `foreground-tab`,\n    `background-tab`, `new-window`, `save-to-disk` and `other`.\n\nEmitted _after_ successful creation of a window via `window.open` in the renderer.\nNot emitted if the creation of the window is canceled from\n[`webContents.setWindowOpenHandler`](web-contents.md#contentssetwindowopenhandlerhandler).\n\nSee [`window.open()`](window-open.md) for more details and how to use this in conjunction with `webContents.setWindowOpenHandler`.\n\n#### Event: 'will-navigate'\n\nReturns:\n\n* `event` Event\n* `url` String\n\nEmitted when a user or the page wants to start navigation. It can happen when\nthe `window.location` object is changed or a user clicks a link in the page.\n\nThis event will not emit when the navigation is started programmatically with\nAPIs like `webContents.loadURL` and `webContents.back`.\n\nIt is also not emitted for in-page navigations, such as clicking anchor links\nor updating the `window.location.hash`. Use `did-navigate-in-page` event for\nthis purpose.\n\nCalling `event.preventDefault()` will prevent the navigation.\n\n#### Event: 'did-start-navigation'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isInPlace` Boolean\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when any frame (including main) starts navigating. `isInPlace` will be\n`true` for in-page navigations.\n\n#### Event: 'will-redirect'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isInPlace` Boolean\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted as a server side redirect occurs during navigation.  For example a 302\nredirect.\n\nThis event will be emitted after `did-start-navigation` and always before the\n`did-redirect-navigation` event for the same navigation.\n\nCalling `event.preventDefault()` will prevent the navigation (not just the\nredirect).\n\n#### Event: 'did-redirect-navigation'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isInPlace` Boolean\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted after a server side redirect occurs during navigation.  For example a 302\nredirect.\n\nThis event cannot be prevented, if you want to prevent redirects you should\ncheckout out the `will-redirect` event above.\n\n#### Event: 'did-navigate'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `httpResponseCode` Integer - -1 for non HTTP navigations\n* `httpStatusText` String - empty for non HTTP navigations\n\nEmitted when a main frame navigation is done.\n\nThis event is not emitted for in-page navigations, such as clicking anchor links\nor updating the `window.location.hash`. Use `did-navigate-in-page` event for\nthis purpose.\n\n#### Event: 'did-frame-navigate'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `httpResponseCode` Integer - -1 for non HTTP navigations\n* `httpStatusText` String - empty for non HTTP navigations,\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when any frame navigation is done.\n\nThis event is not emitted for in-page navigations, such as clicking anchor links\nor updating the `window.location.hash`. Use `did-navigate-in-page` event for\nthis purpose.\n\n#### Event: 'did-navigate-in-page'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when an in-page navigation happened in any frame.\n\nWhen in-page navigation happens, the page URL changes but does not cause\nnavigation outside of the page. Examples of this occurring are when anchor links\nare clicked or when the DOM `hashchange` event is triggered.\n\n#### Event: 'will-prevent-unload'\n\nReturns:\n\n* `event` Event\n\nEmitted when a `beforeunload` event handler is attempting to cancel a page unload.\n\nCalling `event.preventDefault()` will ignore the `beforeunload` event handler\nand allow the page to be unloaded.\n\n```javascript\nconst { BrowserWindow, dialog } = require('electron')\nconst win = new BrowserWindow({ width: 800, height: 600 })\nwin.webContents.on('will-prevent-unload', (event) => {\n  const choice = dialog.showMessageBoxSync(win, {\n    type: 'question',\n    buttons: ['Leave', 'Stay'],\n    title: 'Do you want to leave this site?',\n    message: 'Changes you made may not be saved.',\n    defaultId: 0,\n    cancelId: 1\n  })\n  const leave = (choice === 0)\n  if (leave) {\n    event.preventDefault()\n  }\n})\n```\n\n#### Event: 'crashed' _Deprecated_\n\nReturns:\n\n* `event` Event\n* `killed` Boolean\n\nEmitted when the renderer process crashes or is killed.\n\n**Deprecated:** This event is superceded by the `render-process-gone` event\nwhich contains more information about why the render process disappeared. It\nisn't always because it crashed.  The `killed` boolean can be replaced by\nchecking `reason === 'killed'` when you switch to that event.\n\n#### Event: 'render-process-gone'\n\nReturns:\n\n* `event` Event\n* `details` Object\n  * `reason` String - The reason the render process is gone.  Possible values:\n    * `clean-exit` - Process exited with an exit code of zero\n    * `abnormal-exit` - Process exited with a non-zero exit code\n    * `killed` - Process was sent a SIGTERM or otherwise killed externally\n    * `crashed` - Process crashed\n    * `oom` - Process ran out of memory\n    * `launch-failed` - Process never successfully launched\n    * `integrity-failure` - Windows code integrity checks failed\n\nEmitted when the renderer process unexpectedly disappears.  This is normally\nbecause it was crashed or killed.\n\n#### Event: 'unresponsive'\n\nEmitted when the web page becomes unresponsive.\n\n#### Event: 'responsive'\n\nEmitted when the unresponsive web page becomes responsive again.\n\n#### Event: 'plugin-crashed'\n\nReturns:\n\n* `event` Event\n* `name` String\n* `version` String\n\nEmitted when a plugin process has crashed.\n\n#### Event: 'destroyed'\n\nEmitted when `webContents` is destroyed.\n\n#### Event: 'before-input-event'\n\nReturns:\n\n* `event` Event\n* `input` Object - Input properties.\n  * `type` String - Either `keyUp` or `keyDown`.\n  * `key` String - Equivalent to [KeyboardEvent.key][keyboardevent].\n  * `code` String - Equivalent to [KeyboardEvent.code][keyboardevent].\n  * `isAutoRepeat` Boolean - Equivalent to [KeyboardEvent.repeat][keyboardevent].\n  * `isComposing` Boolean - Equivalent to [KeyboardEvent.isComposing][keyboardevent].\n  * `shift` Boolean - Equivalent to [KeyboardEvent.shiftKey][keyboardevent].\n  * `control` Boolean - Equivalent to [KeyboardEvent.controlKey][keyboardevent].\n  * `alt` Boolean - Equivalent to [KeyboardEvent.altKey][keyboardevent].\n  * `meta` Boolean - Equivalent to [KeyboardEvent.metaKey][keyboardevent].\n\nEmitted before dispatching the `keydown` and `keyup` events in the page.\nCalling `event.preventDefault` will prevent the page `keydown`/`keyup` events\nand the menu shortcuts.\n\nTo only prevent the menu shortcuts, use\n[`setIgnoreMenuShortcuts`](#contentssetignoremenushortcutsignore):\n\n```javascript\nconst { BrowserWindow } = require('electron')\n\nconst win = new BrowserWindow({ width: 800, height: 600 })\n\nwin.webContents.on('before-input-event', (event, input) => {\n  // For example, only enable application menu keyboard shortcuts when\n  // Ctrl/Cmd are down.\n  win.webContents.setIgnoreMenuShortcuts(!input.control && !input.meta)\n})\n```\n\n#### Event: 'enter-html-full-screen'\n\nEmitted when the window enters a full-screen state triggered by HTML API.\n\n#### Event: 'leave-html-full-screen'\n\nEmitted when the window leaves a full-screen state triggered by HTML API.\n\n#### Event: 'zoom-changed'\n\nReturns:\n\n* `event` Event\n* `zoomDirection` String - Can be `in` or `out`.\n\nEmitted when the user is requesting to change the zoom level using the mouse wheel.\n\n#### Event: 'devtools-opened'\n\nEmitted when DevTools is opened.\n\n#### Event: 'devtools-closed'\n\nEmitted when DevTools is closed.\n\n#### Event: 'devtools-focused'\n\nEmitted when DevTools is focused / opened.\n\n#### Event: 'certificate-error'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `error` String - The error code.\n* `certificate` [Certificate](structures/certificate.md)\n* `callback` Function\n  * `isTrusted` Boolean - Indicates whether the certificate can be considered trusted.\n\nEmitted when failed to verify the `certificate` for `url`.\n\nThe usage is the same with [the `certificate-error` event of\n`app`](app.md#event-certificate-error).\n\n#### Event: 'select-client-certificate'\n\nReturns:\n\n* `event` Event\n* `url` URL\n* `certificateList` [Certificate[]](structures/certificate.md)\n* `callback` Function\n  * `certificate` [Certificate](structures/certificate.md) - Must be a certificate from the given list.\n\nEmitted when a client certificate is requested.\n\nThe usage is the same with [the `select-client-certificate` event of\n`app`](app.md#event-select-client-certificate).\n\n#### Event: 'login'\n\nReturns:\n\n* `event` Event\n* `authenticationResponseDetails` Object\n  * `url` URL\n* `authInfo` Object\n  * `isProxy` Boolean\n  * `scheme` String\n  * `host` String\n  * `port` Integer\n  * `realm` String\n* `callback` Function\n  * `username` String (optional)\n  * `password` String (optional)\n\nEmitted when `webContents` wants to do basic auth.\n\nThe usage is the same with [the `login` event of `app`](app.md#event-login).\n\n#### Event: 'found-in-page'\n\nReturns:\n\n* `event` Event\n* `result` Object\n  * `requestId` Integer\n  * `activeMatchOrdinal` Integer - Position of the active match.\n  * `matches` Integer - Number of Matches.\n  * `selectionArea` Rectangle - Coordinates of first match region.\n  * `finalUpdate` Boolean\n\nEmitted when a result is available for\n[`webContents.findInPage`] request.\n\n#### Event: 'media-started-playing'\n\nEmitted when media starts playing.\n\n#### Event: 'media-paused'\n\nEmitted when media is paused or done playing.\n\n#### Event: 'did-change-theme-color'\n\nReturns:\n\n* `event` Event\n* `color` (String | null) - Theme color is in format of '#rrggbb'. It is `null` when no theme color is set.\n\nEmitted when a page's theme color changes. This is usually due to encountering\na meta tag:\n\n```html\n<meta name='theme-color' content='#ff0000'>\n```\n\n#### Event: 'update-target-url'\n\nReturns:\n\n* `event` Event\n* `url` String\n\nEmitted when mouse moves over a link or the keyboard moves the focus to a link.\n\n#### Event: 'cursor-changed'\n\nReturns:\n\n* `event` Event\n* `type` String\n* `image` [NativeImage](native-image.md) (optional)\n* `scale` Float (optional) - scaling factor for the custom cursor.\n* `size` [Size](structures/size.md) (optional) - the size of the `image`.\n* `hotspot` [Point](structures/point.md) (optional) - coordinates of the custom cursor's hotspot.\n\nEmitted when the cursor's type changes. The `type` parameter can be `default`,\n`crosshair`, `pointer`, `text`, `wait`, `help`, `e-resize`, `n-resize`,\n`ne-resize`, `nw-resize`, `s-resize`, `se-resize`, `sw-resize`, `w-resize`,\n`ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`, `col-resize`,\n`row-resize`, `m-panning`, `e-panning`, `n-panning`, `ne-panning`, `nw-panning`,\n`s-panning`, `se-panning`, `sw-panning`, `w-panning`, `move`, `vertical-text`,\n`cell`, `context-menu`, `alias`, `progress`, `nodrop`, `copy`, `none`,\n`not-allowed`, `zoom-in`, `zoom-out`, `grab`, `grabbing` or `custom`.\n\nIf the `type` parameter is `custom`, the `image` parameter will hold the custom\ncursor image in a [`NativeImage`](native-image.md), and `scale`, `size` and `hotspot` will hold\nadditional information about the custom cursor.\n\n#### Event: 'context-menu'\n\nReturns:\n\n* `event` Event\n* `params` Object\n  * `x` Integer - x coordinate.\n  * `y` Integer - y coordinate.\n  * `linkURL` String - URL of the link that encloses the node the context menu\n    was invoked on.\n  * `linkText` String - Text associated with the link. May be an empty\n    string if the contents of the link are an image.\n  * `pageURL` String - URL of the top level page that the context menu was\n    invoked on.\n  * `frameURL` String - URL of the subframe that the context menu was invoked\n    on.\n  * `srcURL` String - Source URL for the element that the context menu\n    was invoked on. Elements with source URLs are images, audio and video.\n  * `mediaType` String - Type of the node the context menu was invoked on. Can\n    be `none`, `image`, `audio`, `video`, `canvas`, `file` or `plugin`.\n  * `hasImageContents` Boolean - Whether the context menu was invoked on an image\n    which has non-empty contents.\n  * `isEditable` Boolean - Whether the context is editable.\n  * `selectionText` String - Text of the selection that the context menu was\n    invoked on.\n  * `titleText` String - Title or alt text of the selection that the context\n    was invoked on.\n  * `misspelledWord` String - The misspelled word under the cursor, if any.\n  * `dictionarySuggestions` String[] - An array of suggested words to show the\n    user to replace the `misspelledWord`.  Only available if there is a misspelled\n    word and spellchecker is enabled.\n  * `frameCharset` String - The character encoding of the frame on which the\n    menu was invoked.\n  * `inputFieldType` String - If the context menu was invoked on an input\n    field, the type of that field. Possible values are `none`, `plainText`,\n    `password`, `other`.\n  * `menuSourceType` String - Input source that invoked the context menu.\n    Can be `none`, `mouse`, `keyboard`, `touch` or `touchMenu`.\n  * `mediaFlags` Object - The flags for the media element the context menu was\n    invoked on.\n    * `inError` Boolean - Whether the media element has crashed.\n    * `isPaused` Boolean - Whether the media element is paused.\n    * `isMuted` Boolean - Whether the media element is muted.\n    * `hasAudio` Boolean - Whether the media element has audio.\n    * `isLooping` Boolean - Whether the media element is looping.\n    * `isControlsVisible` Boolean - Whether the media element's controls are\n      visible.\n    * `canToggleControls` Boolean - Whether the media element's controls are\n      toggleable.\n    * `canRotate` Boolean - Whether the media element can be rotated.\n  * `editFlags` Object - These flags indicate whether the renderer believes it\n    is able to perform the corresponding action.\n    * `canUndo` Boolean - Whether the renderer believes it can undo.\n    * `canRedo` Boolean - Whether the renderer believes it can redo.\n    * `canCut` Boolean - Whether the renderer believes it can cut.\n    * `canCopy` Boolean - Whether the renderer believes it can copy\n    * `canPaste` Boolean - Whether the renderer believes it can paste.\n    * `canDelete` Boolean - Whether the renderer believes it can delete.\n    * `canSelectAll` Boolean - Whether the renderer believes it can select all.\n\nEmitted when there is a new context menu that needs to be handled.\n\n#### Event: 'select-bluetooth-device'\n\nReturns:\n\n* `event` Event\n* `devices` [BluetoothDevice[]](structures/bluetooth-device.md)\n* `callback` Function\n  * `deviceId` String\n\nEmitted when bluetooth device needs to be selected on call to\n`navigator.bluetooth.requestDevice`. To use `navigator.bluetooth` api\n`webBluetooth` should be enabled. If `event.preventDefault` is not called,\nfirst available device will be selected. `callback` should be called with\n`deviceId` to be selected, passing empty string to `callback` will\ncancel the request.\n\n```javascript\nconst { app, BrowserWindow } = require('electron')\n\nlet win = null\napp.commandLine.appendSwitch('enable-experimental-web-platform-features')\n\napp.whenReady().then(() => {\n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.webContents.on('select-bluetooth-device', (event, deviceList, callback) => {\n    event.preventDefault()\n    const result = deviceList.find((device) => {\n      return device.deviceName === 'test'\n    })\n    if (!result) {\n      callback('')\n    } else {\n      callback(result.deviceId)\n    }\n  })\n})\n```\n\n#### Event: 'paint'\n\nReturns:\n\n* `event` Event\n* `dirtyRect` [Rectangle](structures/rectangle.md)\n* `image` [NativeImage](native-image.md) - The image data of the whole frame.\n\nEmitted when a new frame is generated. Only the dirty area is passed in the\nbuffer.\n\n```javascript\nconst { BrowserWindow } = require('electron')\n\nconst win = new BrowserWindow({ webPreferences: { offscreen: true } })\nwin.webContents.on('paint', (event, dirty, image) => {\n  // updateBitmap(dirty, image.getBitmap())\n})\nwin.loadURL('http://github.com')\n```\n\n#### Event: 'devtools-reload-page'\n\nEmitted when the devtools window instructs the webContents to reload\n\n#### Event: 'will-attach-webview'\n\nReturns:\n\n* `event` Event\n* `webPreferences` WebPreferences - The web preferences that will be used by the guest\n  page. This object can be modified to adjust the preferences for the guest\n  page.\n* `params` Record<string, string> - The other `<webview>` parameters such as the `src` URL.\n  This object can be modified to adjust the parameters of the guest page.\n\nEmitted when a `<webview>`'s web contents is being attached to this web\ncontents. Calling `event.preventDefault()` will destroy the guest page.\n\nThis event can be used to configure `webPreferences` for the `webContents`\nof a `<webview>` before it's loaded, and provides the ability to set settings\nthat can't be set via `<webview>` attributes.\n\n**Note:** The specified `preload` script option will appear as `preloadURL`\n(not `preload`) in the `webPreferences` object emitted with this event.\n\n#### Event: 'did-attach-webview'\n\nReturns:\n\n* `event` Event\n* `webContents` WebContents - The guest web contents that is used by the\n  `<webview>`.\n\nEmitted when a `<webview>` has been attached to this web contents.\n\n#### Event: 'console-message'\n\nReturns:\n\n* `event` Event\n* `level` Integer - The log level, from 0 to 3. In order it matches `verbose`, `info`, `warning` and `error`.\n* `message` String - The actual console message\n* `line` Integer - The line number of the source that triggered this console message\n* `sourceId` String\n\nEmitted when the associated window logs a console message.\n\n#### Event: 'preload-error'\n\nReturns:\n\n* `event` Event\n* `preloadPath` String\n* `error` Error\n\nEmitted when the preload script `preloadPath` throws an unhandled exception `error`.\n\n#### Event: 'ipc-message'\n\nReturns:\n\n* `event` Event\n* `channel` String\n* `...args` any[]\n\nEmitted when the renderer process sends an asynchronous message via `ipcRenderer.send()`.\n\n#### Event: 'ipc-message-sync'\n\nReturns:\n\n* `event` Event\n* `channel` String\n* `...args` any[]\n\nEmitted when the renderer process sends a synchronous message via `ipcRenderer.sendSync()`.\n\n#### Event: 'desktop-capturer-get-sources'\n\nReturns:\n\n* `event` Event\n\nEmitted when `desktopCapturer.getSources()` is called in the renderer process.\nCalling `event.preventDefault()` will make it return empty sources.\n\n#### Event: 'remote-require' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n* `moduleName` String\n\nEmitted when `remote.require()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the module from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-global' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n* `globalName` String\n\nEmitted when `remote.getGlobal()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the global from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-builtin' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n* `moduleName` String\n\nEmitted when `remote.getBuiltin()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the module from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-current-window' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n\nEmitted when `remote.getCurrentWindow()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the object from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-current-web-contents' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n\nEmitted when `remote.getCurrentWebContents()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the object from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'preferred-size-changed'\n\nReturns:\n\n* `event` Event\n* `preferredSize` [Size](structures/size.md) - The minimum size needed to\n  contain the layout of the document\u2014without requiring scrolling.\n\nEmitted when the `WebContents` preferred size has changed.\n\nThis event will only be emitted when `enablePreferredSizeMode` is set to `true`\nin `webPreferences`.\n\n### Instance Methods\n\n#### `contents.loadURL(url[, options])`\n\n* `url` String\n* `options` Object (optional)\n  * `httpReferrer` (String | [Referrer](structures/referrer.md)) (optional) - An HTTP Referrer url.\n  * `userAgent` String (optional) - A user agent originating the request.\n  * `extraHeaders` String (optional) - Extra headers separated by \"\\n\".\n  * `postData` ([UploadRawData[]](structures/upload-raw-data.md) | [UploadFile[]](structures/upload-file.md)) (optional)\n  * `baseURLForDataURL` String (optional) - Base url (with trailing path separator) for files to be loaded by the data url. This is needed only if the specified `url` is a data url and needs to load other files.\n\nReturns `Promise<void>` - the promise will resolve when the page has finished loading\n(see [`did-finish-load`](web-contents.md#event-did-finish-load)), and rejects\nif the page fails to load (see\n[`did-fail-load`](web-contents.md#event-did-fail-load)). A noop rejection handler is already attached, which avoids unhandled rejection errors.\n\nLoads the `url` in the window. The `url` must contain the protocol prefix,\ne.g. the `http://` or `file://`. If the load should bypass http cache then\nuse the `pragma` header to achieve it.\n\n```javascript\nconst { webContents } = require('electron')\nconst options = { extraHeaders: 'pragma: no-cache\\n' }\nwebContents.loadURL('https://github.com', options)\n```\n\n#### `contents.loadFile(filePath[, options])`\n\n* `filePath` String\n* `options` Object (optional)\n  * `query` Record<String, String> (optional) - Passed to `url.format()`.\n  * `search` String (optional) - Passed to `url.format()`.\n  * `hash` String (optional) - Passed to `url.format()`.\n\nReturns `Promise<void>` - the promise will resolve when the page has finished loading\n(see [`did-finish-load`](web-contents.md#event-did-finish-load)), and rejects\nif the page fails to load (see [`did-fail-load`](web-contents.md#event-did-fail-load)).\n\nLoads the given file in the window, `filePath` should be a path to\nan HTML file relative to the root of your application.  For instance\nan app structure like this:\n\n```sh\n| root\n| - package.json\n| - src\n|   - main.js\n|   - index.html\n```\n\nWould require code like this\n\n```js\nwin.loadFile('src/index.html')\n```\n\n#### `contents.downloadURL(url)`\n\n* `url` String\n\nInitiates a download of the resource at `url` without navigating. The\n`will-download` event of `session` will be triggered.\n\n#### `contents.getURL()`\n\nReturns `String` - The URL of the current web page.\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('http://github.com').then(() => {\n  const currentURL = win.webContents.getURL()\n  console.log(currentURL)\n})\n```\n\n#### `contents.getTitle()`\n\nReturns `String` - The title of the current web page.\n\n#### `contents.isDestroyed()`\n\nReturns `Boolean` - Whether the web page is destroyed.\n\n#### `contents.focus()`\n\nFocuses the web page.\n\n#### `contents.isFocused()`\n\nReturns `Boolean` - Whether the web page is focused.\n\n#### `contents.isLoading()`\n\nReturns `Boolean` - Whether web page is still loading resources.\n\n#### `contents.isLoadingMainFrame()`\n\nReturns `Boolean` - Whether the main frame (and not just iframes or frames within it) is\nstill loading.\n\n#### `contents.isWaitingForResponse()`\n\nReturns `Boolean` - Whether the web page is waiting for a first-response from the main\nresource of the page.\n\n#### `contents.stop()`\n\nStops any pending navigation.\n\n#### `contents.reload()`\n\nReloads the current web page.\n\n#### `contents.reloadIgnoringCache()`\n\nReloads current page and ignores cache.\n\n#### `contents.canGoBack()`\n\nReturns `Boolean` - Whether the browser can go back to previous web page.\n\n#### `contents.canGoForward()`\n\nReturns `Boolean` - Whether the browser can go forward to next web page.\n\n#### `contents.canGoToOffset(offset)`\n\n* `offset` Integer\n\nReturns `Boolean` - Whether the web page can go to `offset`.\n\n#### `contents.clearHistory()`\n\nClears the navigation history.\n\n#### `contents.goBack()`\n\nMakes the browser go back a web page.\n\n#### `contents.goForward()`\n\nMakes the browser go forward a web page.\n\n#### `contents.goToIndex(index)`\n\n* `index` Integer\n\nNavigates browser to the specified absolute web page index.\n\n#### `contents.goToOffset(offset)`\n\n* `offset` Integer\n\nNavigates to the specified offset from the \"current entry\".\n\n#### `contents.isCrashed()`\n\nReturns `Boolean` - Whether the renderer process has crashed.\n\n#### `contents.forcefullyCrashRenderer()`\n\nForcefully terminates the renderer process that is currently hosting this\n`webContents`. This will cause the `render-process-gone` event to be emitted\nwith the `reason=killed || reason=crashed`. Please note that some webContents share renderer\nprocesses and therefore calling this method may also crash the host process\nfor other webContents as well.\n\nCalling `reload()` immediately after calling this\nmethod will force the reload to occur in a new process. This should be used\nwhen this process is unstable or unusable, for instance in order to recover\nfrom the `unresponsive` event.\n\n```js\ncontents.on('unresponsive', async () => {\n  const { response } = await dialog.showMessageBox({\n    message: 'App X has become unresponsive',\n    title: 'Do you want to try forcefully reloading the app?',\n    buttons: ['OK', 'Cancel'],\n    cancelId: 1\n  })\n  if (response === 0) {\n    contents.forcefullyCrashRenderer()\n    contents.reload()\n  }\n})\n```\n\n#### `contents.setUserAgent(userAgent)`\n\n* `userAgent` String\n\nOverrides the user agent for this web page.\n\n#### `contents.getUserAgent()`\n\nReturns `String` - The user agent for this web page.\n\n#### `contents.insertCSS(css[, options])`\n\n* `css` String\n* `options` Object (optional)\n  * `cssOrigin` String (optional) - Can be either 'user' or 'author'; Specifying 'user' enables you to prevent websites from overriding the CSS you insert. Default is 'author'.\n\nReturns `Promise<String>` - A promise that resolves with a key for the inserted CSS that can later be used to remove the CSS via `contents.removeInsertedCSS(key)`.\n\nInjects CSS into the current web page and returns a unique key for the inserted\nstylesheet.\n\n```js\ncontents.on('did-finish-load', () => {\n  contents.insertCSS('html, body { background-color: #f00; }')\n})\n```\n\n#### `contents.removeInsertedCSS(key)`\n\n* `key` String\n\nReturns `Promise<void>` - Resolves if the removal was successful.\n\nRemoves the inserted CSS from the current web page. The stylesheet is identified\nby its key, which is returned from `contents.insertCSS(css)`.\n\n```js\ncontents.on('did-finish-load', async () => {\n  const key = await contents.insertCSS('html, body { background-color: #f00; }')\n  contents.removeInsertedCSS(key)\n})\n```\n\n#### `contents.executeJavaScript(code[, userGesture])`\n\n* `code` String\n* `userGesture` Boolean (optional) - Default is `false`.\n\nReturns `Promise<any>` - A promise that resolves with the result of the executed code\nor is rejected if the result of the code is a rejected promise.\n\nEvaluates `code` in page.\n\nIn the browser window some HTML APIs like `requestFullScreen` can only be\ninvoked by a gesture from the user. Setting `userGesture` to `true` will remove\nthis limitation.\n\nCode execution will be suspended until web page stop loading.\n\n```js\ncontents.executeJavaScript('fetch(\"https://jsonplaceholder.typicode.com/users/1\").then(resp => resp.json())', true)\n  .then((result) => {\n    console.log(result) // Will be the JSON object from the fetch call\n  })\n```\n\n#### `contents.executeJavaScriptInIsolatedWorld(worldId, scripts[, userGesture])`\n\n* `worldId` Integer - The ID of the world to run the javascript in, `0` is the default world, `999` is the world used by Electron's `contextIsolation` feature.  You can provide any integer here.\n* `scripts` [WebSource[]](structures/web-source.md)\n* `userGesture` Boolean (optional) - Default is `false`.\n\nReturns `Promise<any>` - A promise that resolves with the result of the executed code\nor is rejected if the result of the code is a rejected promise.\n\nWorks like `executeJavaScript` but evaluates `scripts` in an isolated context.\n\n#### `contents.setIgnoreMenuShortcuts(ignore)`\n\n* `ignore` Boolean\n\nIgnore application menu shortcuts while this web contents is focused.\n\n#### `contents.setWindowOpenHandler(handler)`\n\n* `handler` Function<{action: 'deny'} | {action: 'allow', overrideBrowserWindowOptions?: BrowserWindowConstructorOptions}>\n  * `details` Object\n    * `url` String - The _resolved_ version of the URL passed to `window.open()`. e.g. opening a window with `window.open('foo')` will yield something like `https://the-origin/the/current/path/foo`.\n    * `frameName` String - Name of the window provided in `window.open()`\n    * `features` String - Comma separated list of window features provided to `window.open()`.\n  Returns `{action: 'deny'} | {action: 'allow', overrideBrowserWindowOptions?: BrowserWindowConstructorOptions}` - `deny` cancels the creation of the new\n  window. `allow` will allow the new window to be created. Specifying `overrideBrowserWindowOptions` allows customization of the created window.\n  Returning an unrecognized value such as a null, undefined, or an object\n  without a recognized 'action' value will result in a console error and have\n  the same effect as returning `{action: 'deny'}`.\n\nCalled before creating a window when `window.open()` is called from the\nrenderer. See [`window.open()`](window-open.md) for more details and how to use this in conjunction with `did-create-window`.\n\n#### `contents.setAudioMuted(muted)`\n\n* `muted` Boolean\n\nMute the audio on the current web page.\n\n#### `contents.isAudioMuted()`\n\nReturns `Boolean` - Whether this page has been muted.\n\n#### `contents.isCurrentlyAudible()`\n\nReturns `Boolean` - Whether audio is currently playing.\n\n#### `contents.setZoomFactor(factor)`\n\n* `factor` Double - Zoom factor; default is 1.0.\n\nChanges the zoom factor to the specified factor. Zoom factor is\nzoom percent divided by 100, so 300% = 3.0.\n\nThe factor must be greater than 0.0.\n\n#### `contents.getZoomFactor()`\n\nReturns `Number` - the current zoom factor.\n\n#### `contents.setZoomLevel(level)`\n\n* `level` Number - Zoom level.\n\nChanges the zoom level to the specified level. The original size is 0 and each\nincrement above or below represents zooming 20% larger or smaller to default\nlimits of 300% and 50% of original size, respectively. The formula for this is\n`scale := 1.2 ^ level`.\n\n> **NOTE**: The zoom policy at the Chromium level is same-origin, meaning that the\n> zoom level for a specific domain propagates across all instances of windows with\n> the same domain. Differentiating the window URLs will make zoom work per-window.\n\n#### `contents.getZoomLevel()`\n\nReturns `Number` - the current zoom level.\n\n#### `contents.setVisualZoomLevelLimits(minimumLevel, maximumLevel)`\n\n* `minimumLevel` Number\n* `maximumLevel` Number\n\nReturns `Promise<void>`\n\nSets the maximum and minimum pinch-to-zoom level.\n\n> **NOTE**: Visual zoom is disabled by default in Electron. To re-enable it, call:\n>\n> ```js\n> contents.setVisualZoomLevelLimits(1, 3)\n> ```\n\n#### `contents.undo()`\n\nExecutes the editing command `undo` in web page.\n\n#### `contents.redo()`\n\nExecutes the editing command `redo` in web page.\n\n#### `contents.cut()`\n\nExecutes the editing command `cut` in web page.\n\n#### `contents.copy()`\n\nExecutes the editing command `copy` in web page.\n\n#### `contents.copyImageAt(x, y)`\n\n* `x` Integer\n* `y` Integer\n\nCopy the image at the given position to the clipboard.\n\n#### `contents.paste()`\n\nExecutes the editing command `paste` in web page.\n\n#### `contents.pasteAndMatchStyle()`\n\nExecutes the editing command `pasteAndMatchStyle` in web page.\n\n#### `contents.delete()`\n\nExecutes the editing command `delete` in web page.\n\n#### `contents.selectAll()`\n\nExecutes the editing command `selectAll` in web page.\n\n#### `contents.unselect()`\n\nExecutes the editing command `unselect` in web page.\n\n#### `contents.replace(text)`\n\n* `text` String\n\nExecutes the editing command `replace` in web page.\n\n#### `contents.replaceMisspelling(text)`\n\n* `text` String\n\nExecutes the editing command `replaceMisspelling` in web page.\n\n#### `contents.insertText(text)`\n\n* `text` String\n\nReturns `Promise<void>`\n\nInserts `text` to the focused element.\n\n#### `contents.findInPage(text[, options])`\n\n* `text` String - Content to be searched, must not be empty.\n* `options` Object (optional)\n  * `forward` Boolean (optional) - Whether to search forward or backward, defaults to `true`.\n  * `findNext` Boolean (optional) - Whether the operation is first request or a follow up,\n    defaults to `false`.\n  * `matchCase` Boolean (optional) - Whether search should be case-sensitive,\n    defaults to `false`.\n\nReturns `Integer` - The request id used for the request.\n\nStarts a request to find all matches for the `text` in the web page. The result of the request\ncan be obtained by subscribing to [`found-in-page`](web-contents.md#event-found-in-page) event.\n\n#### `contents.stopFindInPage(action)`\n\n* `action` String - Specifies the action to take place when ending\n  [`webContents.findInPage`] request.\n  * `clearSelection` - Clear the selection.\n  * `keepSelection` - Translate the selection into a normal selection.\n  * `activateSelection` - Focus and click the selection node.\n\nStops any `findInPage` request for the `webContents` with the provided `action`.\n\n```javascript\nconst { webContents } = require('electron')\nwebContents.on('found-in-page', (event, result) => {\n  if (result.finalUpdate) webContents.stopFindInPage('clearSelection')\n})\n\nconst requestId = webContents.findInPage('api')\nconsole.log(requestId)\n```\n\n#### `contents.capturePage([rect])`\n\n* `rect` [Rectangle](structures/rectangle.md) (optional) - The area of the page to be captured.\n\nReturns `Promise<NativeImage>` - Resolves with a [NativeImage](native-image.md)\n\nCaptures a snapshot of the page within `rect`. Omitting `rect` will capture the whole visible page.\n\n#### `contents.isBeingCaptured()`\n\nReturns `Boolean` - Whether this page is being captured. It returns true when the capturer count\nis large then 0.\n\n#### `contents.incrementCapturerCount([size, stayHidden])`\n\n* `size` [Size](structures/size.md) (optional) - The preferred size for the capturer.\n* `stayHidden` Boolean (optional) -  Keep the page hidden instead of visible.\n\nIncrease the capturer count by one. The page is considered visible when its browser window is\nhidden and the capturer count is non-zero. If you would like the page to stay hidden, you should ensure that `stayHidden` is set to true.\n\nThis also affects the Page Visibility API.\n\n#### `contents.decrementCapturerCount([stayHidden])`\n\n* `stayHidden` Boolean (optional) -  Keep the page in hidden state instead of visible.\n\nDecrease the capturer count by one. The page will be set to hidden or occluded state when its\nbrowser window is hidden or occluded and the capturer count reaches zero. If you want to\ndecrease the hidden capturer count instead you should set `stayHidden` to true.\n\n#### `contents.getPrinters()`\n\nGet the system printer list.\n\nReturns [`PrinterInfo[]`](structures/printer-info.md)\n\n#### `contents.print([options], [callback])`\n\n* `options` Object (optional)\n  * `silent` Boolean (optional) - Don't ask user for print settings. Default is `false`.\n  * `printBackground` Boolean (optional) - Prints the background color and image of\n    the web page. Default is `false`.\n  * `deviceName` String (optional) - Set the printer device name to use. Must be the system-defined name and not the 'friendly' name, e.g 'Brother_QL_820NWB' and not 'Brother QL-820NWB'.\n  * `color` Boolean (optional) - Set whether the printed web page will be in color or grayscale. Default is `true`.\n  * `margins` Object (optional)\n    * `marginType` String (optional) - Can be `default`, `none`, `printableArea`, or `custom`. If `custom` is chosen, you will also need to specify `top`, `bottom`, `left`, and `right`.\n    * `top` Number (optional) - The top margin of the printed web page, in pixels.\n    * `bottom` Number (optional) - The bottom margin of the printed web page, in pixels.\n    * `left` Number (optional) - The left margin of the printed web page, in pixels.\n    * `right` Number (optional) - The right margin of the printed web page, in pixels.\n  * `landscape` Boolean (optional) - Whether the web page should be printed in landscape mode. Default is `false`.\n  * `scaleFactor` Number (optional) - The scale factor of the web page.\n  * `pagesPerSheet` Number (optional) - The number of pages to print per page sheet.\n  * `collate` Boolean (optional) - Whether the web page should be collated.\n  * `copies` Number (optional) - The number of copies of the web page to print.\n  * `pageRanges` Object[]  (optional) - The page range to print. On macOS, only one range is honored.\n    * `from` Number - Index of the first page to print (0-based).\n    * `to` Number - Index of the last page to print (inclusive) (0-based).\n  * `duplexMode` String (optional) - Set the duplex mode of the printed web page. Can be `simplex`, `shortEdge`, or `longEdge`.\n  * `dpi` Record<string, number> (optional)\n    * `horizontal` Number (optional) - The horizontal dpi.\n    * `vertical` Number (optional) - The vertical dpi.\n  * `header` String (optional) - String to be printed as page header.\n  * `footer` String (optional) - String to be printed as page footer.\n  * `pageSize` String | Size (optional) - Specify page size of the printed document. Can be `A3`,\n  `A4`, `A5`, `Legal`, `Letter`, `Tabloid` or an Object containing `height`.\n* `callback` Function (optional)\n  * `success` Boolean - Indicates success of the print call.\n  * `failureReason` String - Error description called back if the print fails.\n\nWhen a custom `pageSize` is passed, Chromium attempts to validate platform specific minimum values for `width_microns` and `height_microns`. Width and height must both be minimum 353 microns but may be higher on some operating systems.\n\nPrints window's web page. When `silent` is set to `true`, Electron will pick\nthe system's default printer if `deviceName` is empty and the default settings for printing.\n\nUse `page-break-before: always;` CSS style to force to print to a new page.\n\nExample usage:\n\n```js\nconst options = {\n  silent: true,\n  deviceName: 'My-Printer',\n  pageRanges: [{\n    from: 0,\n    to: 1\n  }]\n}\nwin.webContents.print(options, (success, errorType) => {\n  if (!success) console.log(errorType)\n})\n```\n\n#### `contents.printToPDF(options)`\n\n* `options` Object\n  * `headerFooter` Record<string, string> (optional) - the header and footer for the PDF.\n    * `title` String - The title for the PDF header.\n    * `url` String - the url for the PDF footer.\n  * `landscape` Boolean (optional) - `true` for landscape, `false` for portrait.\n  * `marginsType` Integer (optional) - Specifies the type of margins to use. Uses 0 for\n    default margin, 1 for no margin, and 2 for minimum margin.\n  * `scaleFactor` Number (optional) - The scale factor of the web page. Can range from 0 to 100.\n  * `pageRanges` Record<string, number> (optional) - The page range to print.\n    * `from` Number - Index of the first page to print (0-based).\n    * `to` Number - Index of the last page to print (inclusive) (0-based).\n  * `pageSize` String | Size (optional) - Specify page size of the generated PDF. Can be `A3`,\n  `A4`, `A5`, `Legal`, `Letter`, `Tabloid` or an Object containing `height` and `width` in microns.\n  * `printBackground` Boolean (optional) - Whether to print CSS backgrounds.\n  * `printSelectionOnly` Boolean (optional) - Whether to print selection only.\n\nReturns `Promise<Buffer>` - Resolves with the generated PDF data.\n\nPrints window's web page as PDF with Chromium's preview printing custom\nsettings.\n\nThe `landscape` will be ignored if `@page` CSS at-rule is used in the web page.\n\nBy default, an empty `options` will be regarded as:\n\n```javascript\n{\n  marginsType: 0,\n  printBackground: false,\n  printSelectionOnly: false,\n  landscape: false,\n  pageSize: 'A4',\n  scaleFactor: 100\n}\n```\n\nUse `page-break-before: always;` CSS style to force to print to a new page.\n\nAn example of `webContents.printToPDF`:\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\nconst win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('http://github.com')\n\nwin.webContents.on('did-finish-load', () => {\n  // Use default printing options\n  win.webContents.printToPDF({}).then(data => {\n    const pdfPath = path.join(os.homedir(), 'Desktop', 'temp.pdf')\n    fs.writeFile(pdfPath, data, (error) => {\n      if (error) throw error\n      console.log(`Wrote PDF successfully to ${pdfPath}`)\n    })\n  }).catch(error => {\n    console.log(`Failed to write PDF to ${pdfPath}: `, error)\n  })\n})\n```\n\n#### `contents.addWorkSpace(path)`\n\n* `path` String\n\nAdds the specified path to DevTools workspace. Must be used after DevTools\ncreation:\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow()\nwin.webContents.on('devtools-opened', () => {\n  win.webContents.addWorkSpace(__dirname)\n})\n```\n\n#### `contents.removeWorkSpace(path)`\n\n* `path` String\n\nRemoves the specified path from DevTools workspace.\n\n#### `contents.setDevToolsWebContents(devToolsWebContents)`\n\n* `devToolsWebContents` WebContents\n\nUses the `devToolsWebContents` as the target `WebContents` to show devtools.\n\nThe `devToolsWebContents` must not have done any navigation, and it should not\nbe used for other purposes after the call.\n\nBy default Electron manages the devtools by creating an internal `WebContents`\nwith native view, which developers have very limited control of. With the\n`setDevToolsWebContents` method, developers can use any `WebContents` to show\nthe devtools in it, including `BrowserWindow`, `BrowserView` and `<webview>`\ntag.\n\nNote that closing the devtools does not destroy the `devToolsWebContents`, it\nis caller's responsibility to destroy `devToolsWebContents`.\n\nAn example of showing devtools in a `<webview>` tag:\n\n```html\n<html>\n<head>\n  <style type=\"text/css\">\n    * { margin: 0; }\n    #browser { height: 70%; }\n    #devtools { height: 30%; }\n  </style>\n</head>\n<body>\n  <webview id=\"browser\" src=\"https://github.com\"></webview>\n  <webview id=\"devtools\" src=\"about:blank\"></webview>\n  <script>\n    const { ipcRenderer } = require('electron')\n    const emittedOnce = (element, eventName) => new Promise(resolve => {\n      element.addEventListener(eventName, event => resolve(event), { once: true })\n    })\n    const browserView = document.getElementById('browser')\n    const devtoolsView = document.getElementById('devtools')\n    const browserReady = emittedOnce(browserView, 'dom-ready')\n    const devtoolsReady = emittedOnce(devtoolsView, 'dom-ready')\n    Promise.all([browserReady, devtoolsReady]).then(() => {\n      const targetId = browserView.getWebContentsId()\n      const devtoolsId = devtoolsView.getWebContentsId()\n      ipcRenderer.send('open-devtools', targetId, devtoolsId)\n    })\n  </script>\n</body>\n</html>\n```\n\n```js\n// Main process\nconst { ipcMain, webContents } = require('electron')\nipcMain.on('open-devtools', (event, targetContentsId, devtoolsContentsId) => {\n  const target = webContents.fromId(targetContentsId)\n  const devtools = webContents.fromId(devtoolsContentsId)\n  target.setDevToolsWebContents(devtools)\n  target.openDevTools()\n})\n```\n\nAn example of showing devtools in a `BrowserWindow`:\n\n```js\nconst { app, BrowserWindow } = require('electron')\n\nlet win = null\nlet devtools = null\n\napp.whenReady().then(() => {\n  win = new BrowserWindow()\n  devtools = new BrowserWindow()\n  win.loadURL('https://github.com')\n  win.webContents.setDevToolsWebContents(devtools.webContents)\n  win.webContents.openDevTools({ mode: 'detach' })\n})\n```\n\n#### `contents.openDevTools([options])`\n\n* `options` Object (optional)\n  * `mode` String - Opens the devtools with specified dock state, can be\n    `right`, `bottom`, `undocked`, `detach`. Defaults to last used dock state.\n    In `undocked` mode it's possible to dock back. In `detach` mode it's not.\n  * `activate` Boolean (optional) - Whether to bring the opened devtools window\n    to the foreground. The default is `true`.\n\nOpens the devtools.\n\nWhen `contents` is a `<webview>` tag, the `mode` would be `detach` by default,\nexplicitly passing an empty `mode` can force using last used dock state.\n\n#### `contents.closeDevTools()`\n\nCloses the devtools.\n\n#### `contents.isDevToolsOpened()`\n\nReturns `Boolean` - Whether the devtools is opened.\n\n#### `contents.isDevToolsFocused()`\n\nReturns `Boolean` - Whether the devtools view is focused .\n\n#### `contents.toggleDevTools()`\n\nToggles the developer tools.\n\n#### `contents.inspectElement(x, y)`\n\n* `x` Integer\n* `y` Integer\n\nStarts inspecting element at position (`x`, `y`).\n\n#### `contents.inspectSharedWorker()`\n\nOpens the developer tools for the shared worker context.\n\n#### `contents.inspectSharedWorkerById(workerId)`\n\n* `workerId` String\n\nInspects the shared worker based on its ID.\n\n#### `contents.getAllSharedWorkers()`\n\nReturns [`SharedWorkerInfo[]`](structures/shared-worker-info.md) - Information about all Shared Workers.\n\n#### `contents.inspectServiceWorker()`\n\nOpens the developer tools for the service worker context.\n\n#### `contents.send(channel, ...args)`\n\n* `channel` String\n* `...args` any[]\n\nSend an asynchronous message to the renderer process via `channel`, along with\narguments. Arguments will be serialized with the [Structured Clone\nAlgorithm][SCA], just like [`postMessage`][], so prototype chains will not be\nincluded. Sending Functions, Promises, Symbols, WeakMaps, or WeakSets will\nthrow an exception.\n\n> **NOTE**: Sending non-standard JavaScript types such as DOM objects or\n> special Electron objects is deprecated, and will begin throwing an exception\n> starting with Electron 9.\n\nThe renderer process can handle the message by listening to `channel` with the\n[`ipcRenderer`](ipc-renderer.md) module.\n\nAn example of sending messages from the main process to the renderer process:\n\n```javascript\n// In the main process.\nconst { app, BrowserWindow } = require('electron')\nlet win = null\n\napp.whenReady().then(() => {\n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n})\n```\n\n```html\n<!-- index.html -->\n<html>\n<body>\n  <script>\n    require('electron').ipcRenderer.on('ping', (event, message) => {\n      console.log(message) // Prints 'whoooooooh!'\n    })\n  </script>\n</body>\n</html>\n```\n\n#### `contents.sendToFrame(frameId, channel, ...args)`\n\n* `frameId` Integer\n* `channel` String\n* `...args` any[]\n\nSend an asynchronous message to a specific frame in a renderer process via\n`channel`, along with arguments. Arguments will be serialized with the\n[Structured Clone Algorithm][SCA], just like [`postMessage`][], so prototype\nchains will not be included. Sending Functions, Promises, Symbols, WeakMaps, or\nWeakSets will throw an exception.\n\n> **NOTE**: Sending non-standard JavaScript types such as DOM objects or\n> special Electron objects is deprecated, and will begin throwing an exception\n> starting with Electron 9.\n\nThe renderer process can handle the message by listening to `channel` with the\n[`ipcRenderer`](ipc-renderer.md) module.\n\nIf you want to get the `frameId` of a given renderer context you should use\nthe `webFrame.routingId` value.  E.g.\n\n```js\n// In a renderer process\nconsole.log('My frameId is:', require('electron').webFrame.routingId)\n```\n\nYou can also read `frameId` from all incoming IPC messages in the main process.\n\n```js\n// In the main process\nipcMain.on('ping', (event) => {\n  console.info('Message came from frameId:', event.frameId)\n})\n```\n\n#### `contents.postMessage(channel, message, [transfer])`\n\n* `channel` String\n* `message` any\n* `transfer` MessagePortMain[] (optional)\n\nSend a message to the renderer process, optionally transferring ownership of\nzero or more [`MessagePortMain`][] objects.\n\nThe transferred `MessagePortMain` objects will be available in the renderer\nprocess by accessing the `ports` property of the emitted event. When they\narrive in the renderer, they will be native DOM `MessagePort` objects.\n\nFor example:\n\n```js\n// Main process\nconst { port1, port2 } = new MessageChannelMain()\nwebContents.postMessage('port', { message: 'hello' }, [port1])\n\n// Renderer process\nipcRenderer.on('port', (e, msg) => {\n  const [port] = e.ports\n  // ...\n})\n```\n\n#### `contents.enableDeviceEmulation(parameters)`\n\n* `parameters` Object\n  * `screenPosition` String - Specify the screen type to emulate\n      (default: `desktop`):\n    * `desktop` - Desktop screen type.\n    * `mobile` - Mobile screen type.\n  * `screenSize` [Size](structures/size.md) - Set the emulated screen size (screenPosition == mobile).\n  * `viewPosition` [Point](structures/point.md) - Position the view on the screen\n      (screenPosition == mobile) (default: `{ x: 0, y: 0 }`).\n  * `deviceScaleFactor` Integer - Set the device scale factor (if zero defaults to\n      original device scale factor) (default: `0`).\n  * `viewSize` [Size](structures/size.md) - Set the emulated view size (empty means no override)\n  * `scale` Float - Scale of emulated view inside available space (not in fit to\n      view mode) (default: `1`).\n\nEnable device emulation with the given parameters.\n\n#### `contents.disableDeviceEmulation()`\n\nDisable device emulation enabled by `webContents.enableDeviceEmulation`.\n\n#### `contents.sendInputEvent(inputEvent)`\n\n* `inputEvent` [MouseInputEvent](structures/mouse-input-event.md) | [MouseWheelInputEvent](structures/mouse-wheel-input-event.md) | [KeyboardInputEvent](structures/keyboard-input-event.md)\n\nSends an input `event` to the page.\n**Note:** The [`BrowserWindow`](browser-window.md) containing the contents needs to be focused for\n`sendInputEvent()` to work.\n\n#### `contents.beginFrameSubscription([onlyDirty ,]callback)`\n\n* `onlyDirty` Boolean (optional) - Defaults to `false`.\n* `callback` Function\n  * `image` [NativeImage](native-image.md)\n  * `dirtyRect` [Rectangle](structures/rectangle.md)\n\nBegin subscribing for presentation events and captured frames, the `callback`\nwill be called with `callback(image, dirtyRect)` when there is a presentation\nevent.\n\nThe `image` is an instance of [NativeImage](native-image.md) that stores the\ncaptured frame.\n\nThe `dirtyRect` is an object with `x, y, width, height` properties that\ndescribes which part of the page was repainted. If `onlyDirty` is set to\n`true`, `image` will only contain the repainted area. `onlyDirty` defaults to\n`false`.\n\n#### `contents.endFrameSubscription()`\n\nEnd subscribing for frame presentation events.\n\n#### `contents.startDrag(item)`\n\n* `item` Object\n  * `file` String[] | String - The path(s) to the file(s) being dragged.\n  * `icon` [NativeImage](native-image.md) | String - The image must be\n    non-empty on macOS.\n\nSets the `item` as dragging item for current drag-drop operation, `file` is the\nabsolute path of the file to be dragged, and `icon` is the image showing under\nthe cursor when dragging.\n\n#### `contents.savePage(fullPath, saveType)`\n\n* `fullPath` String - The full file path.\n* `saveType` String - Specify the save type.\n  * `HTMLOnly` - Save only the HTML of the page.\n  * `HTMLComplete` - Save complete-html page.\n  * `MHTML` - Save complete-html page as MHTML.\n\nReturns `Promise<void>` - resolves if the page is saved.\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow()\n\nwin.loadURL('https://github.com')\n\nwin.webContents.on('did-finish-load', async () => {\n  win.webContents.savePage('/tmp/test.html', 'HTMLComplete').then(() => {\n    console.log('Page was saved successfully.')\n  }).catch(err => {\n    console.log(err)\n  })\n})\n```\n\n#### `contents.showDefinitionForSelection()` _macOS_\n\nShows pop-up dictionary that searches the selected word on the page.\n\n#### `contents.isOffscreen()`\n\nReturns `Boolean` - Indicates whether *offscreen rendering* is enabled.\n\n#### `contents.startPainting()`\n\nIf *offscreen rendering* is enabled and not painting, start painting.\n\n#### `contents.stopPainting()`\n\nIf *offscreen rendering* is enabled and painting, stop painting.\n\n#### `contents.isPainting()`\n\nReturns `Boolean` - If *offscreen rendering* is enabled returns whether it is currently painting.\n\n#### `contents.setFrameRate(fps)`\n\n* `fps` Integer\n\nIf *offscreen rendering* is enabled sets the frame rate to the specified number.\nOnly values between 1 and 240 are accepted.\n\n#### `contents.getFrameRate()`\n\nReturns `Integer` - If *offscreen rendering* is enabled returns the current frame rate.\n\n#### `contents.invalidate()`\n\nSchedules a full repaint of the window this web contents is in.\n\nIf *offscreen rendering* is enabled invalidates the frame and generates a new\none through the `'paint'` event.\n\n#### `contents.getWebRTCIPHandlingPolicy()`\n\nReturns `String` - Returns the WebRTC IP Handling Policy.\n\n#### `contents.setWebRTCIPHandlingPolicy(policy)`\n\n* `policy` String - Specify the WebRTC IP Handling Policy.\n  * `default` - Exposes user's public and local IPs. This is the default\n  behavior. When this policy is used, WebRTC has the right to enumerate all\n  interfaces and bind them to discover public interfaces.\n  * `default_public_interface_only` - Exposes user's public IP, but does not\n  expose user's local IP. When this policy is used, WebRTC should only use the\n  default route used by http. This doesn't expose any local addresses.\n  * `default_public_and_private_interfaces` - Exposes user's public and local\n  IPs. When this policy is used, WebRTC should only use the default route used\n  by http. This also exposes the associated default private address. Default\n  route is the route chosen by the OS on a multi-homed endpoint.\n  * `disable_non_proxied_udp` - Does not expose public or local IPs. When this\n  policy is used, WebRTC should only use TCP to contact peers or servers unless\n  the proxy server supports UDP.\n\nSetting the WebRTC IP handling policy allows you to control which IPs are\nexposed via WebRTC. See [BrowserLeaks](https://browserleaks.com/webrtc) for\nmore details.\n\n#### `contents.getOSProcessId()`\n\nReturns `Integer` - The operating system `pid` of the associated renderer\nprocess.\n\n#### `contents.getProcessId()`\n\nReturns `Integer` - The Chromium internal `pid` of the associated renderer. Can\nbe compared to the `frameProcessId` passed by frame specific navigation events\n(e.g. `did-frame-navigate`)\n\n#### `contents.takeHeapSnapshot(filePath)`\n\n* `filePath` String - Path to the output file.\n\nReturns `Promise<void>` - Indicates whether the snapshot has been created successfully.\n\nTakes a V8 heap snapshot and saves it to `filePath`.\n\n#### `contents.getBackgroundThrottling()`\n\nReturns `Boolean` - whether or not this WebContents will throttle animations and timers\nwhen the page becomes backgrounded. This also affects the Page Visibility API.\n\n#### `contents.setBackgroundThrottling(allowed)`\n\n* `allowed` Boolean\n\nControls whether or not this WebContents will throttle animations and timers\nwhen the page becomes backgrounded. This also affects the Page Visibility API.\n\n#### `contents.getType()`\n\nReturns `String` - the type of the webContent. Can be `backgroundPage`, `window`, `browserView`, `remote`, `webview` or `offscreen`.\n\n### Instance Properties\n\n#### `contents.audioMuted`\n\nA `Boolean` property that determines whether this page is muted.\n\n#### `contents.userAgent`\n\nA `String` property that determines the user agent for this web page.\n\n#### `contents.zoomLevel`\n\nA `Number` property that determines the zoom level for this web contents.\n\nThe original size is 0 and each increment above or below represents zooming 20% larger or smaller to default limits of 300% and 50% of original size, respectively. The formula for this is `scale := 1.2 ^ level`.\n\n#### `contents.zoomFactor`\n\nA `Number` property that determines the zoom factor for this web contents.\n\nThe zoom factor is the zoom percent divided by 100, so 300% = 3.0.\n\n#### `contents.frameRate`\n\nAn `Integer` property that sets the frame rate of the web contents to the specified number.\nOnly values between 1 and 240 are accepted.\n\nOnly applicable if *offscreen rendering* is enabled.\n\n#### `contents.id` _Readonly_\n\nA `Integer` representing the unique ID of this WebContents. Each ID is unique among all `WebContents` instances of the entire Electron application.\n\n#### `contents.session` _Readonly_\n\nA [`Session`](session.md) used by this webContents.\n\n#### `contents.hostWebContents` _Readonly_\n\nA [`WebContents`](web-contents.md) instance that might own this `WebContents`.\n\n#### `contents.devToolsWebContents` _Readonly_\n\nA `WebContents | null` property that represents the of DevTools `WebContents` associated with a given `WebContents`.\n\n**Note:** Users should never store this object because it may become `null`\nwhen the DevTools has been closed.\n\n#### `contents.debugger` _Readonly_\n\nA [`Debugger`](debugger.md) instance for this webContents.\n\n[keyboardevent]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent\n[event-emitter]: https://nodejs.org/api/events.html#events_class_eventemitter\n[SCA]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n[`postMessage`]: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n\n#### `contents.backgroundThrottling`\n\nA `Boolean` property that determines whether or not this WebContents will throttle animations and timers\nwhen the page becomes backgrounded. This also affects the Page Visibility API.\n\n#### `contents.mainFrame` _Readonly_\n\nA [`WebFrameMain`](web-frame-main.md) property that represents the top frame of the page's frame hierarchy.\n", "import { app, ipcMain, session, deprecate, BrowserWindowConstructorOptions } from 'electron/main';\nimport type { MenuItem, MenuItemConstructorOptions, LoadURLOptions } from 'electron/main';\n\nimport * as url from 'url';\nimport * as path from 'path';\nimport { openGuestWindow, makeWebPreferences } from '@electron/internal/browser/guest-window-manager';\nimport { NavigationController } from '@electron/internal/browser/navigation-controller';\nimport { ipcMainInternal } from '@electron/internal/browser/ipc-main-internal';\nimport * as ipcMainUtils from '@electron/internal/browser/ipc-main-internal-utils';\nimport { MessagePortMain } from '@electron/internal/browser/message-port-main';\nimport { IPC_MESSAGES } from '@electron/internal/common/ipc-messages';\n\n// session is not used here, the purpose is to make sure session is initalized\n// before the webContents module.\n// eslint-disable-next-line\nsession\n\nlet nextId = 0;\nconst getNextId = function () {\n  return ++nextId;\n};\n\ntype PostData = LoadURLOptions['postData']\n\n/* eslint-disable camelcase */\ntype MediaSize = {\n  name: string,\n  custom_display_name: string,\n  height_microns: number,\n  width_microns: number,\n  is_default?: 'true',\n}\n/* eslint-enable camelcase */\n\n// Stock page sizes\nconst PDFPageSizes: Record<string, MediaSize> = {\n  A5: {\n    custom_display_name: 'A5',\n    height_microns: 210000,\n    name: 'ISO_A5',\n    width_microns: 148000\n  },\n  A4: {\n    custom_display_name: 'A4',\n    height_microns: 297000,\n    name: 'ISO_A4',\n    is_default: 'true',\n    width_microns: 210000\n  },\n  A3: {\n    custom_display_name: 'A3',\n    height_microns: 420000,\n    name: 'ISO_A3',\n    width_microns: 297000\n  },\n  Legal: {\n    custom_display_name: 'Legal',\n    height_microns: 355600,\n    name: 'NA_LEGAL',\n    width_microns: 215900\n  },\n  Letter: {\n    custom_display_name: 'Letter',\n    height_microns: 279400,\n    name: 'NA_LETTER',\n    width_microns: 215900\n  },\n  Tabloid: {\n    height_microns: 431800,\n    name: 'NA_LEDGER',\n    width_microns: 279400,\n    custom_display_name: 'Tabloid'\n  }\n};\n\n// The minimum micron size Chromium accepts is that where:\n// Per printing/units.h:\n//  * kMicronsPerInch - Length of an inch in 0.001mm unit.\n//  * kPointsPerInch - Length of an inch in CSS's 1pt unit.\n//\n// Formula: (kPointsPerInch / kMicronsPerInch) * size >= 1\n//\n// Practically, this means microns need to be > 352 microns.\n// We therefore need to verify this or it will silently fail.\nconst isValidCustomPageSize = (width: number, height: number) => {\n  return [width, height].every(x => x > 352);\n};\n\n// Default printing setting\nconst defaultPrintingSetting = {\n  // Customizable.\n  pageRange: [] as {from: number, to: number}[],\n  mediaSize: {} as MediaSize,\n  landscape: false,\n  headerFooterEnabled: false,\n  marginsType: 0,\n  scaleFactor: 100,\n  shouldPrintBackgrounds: false,\n  shouldPrintSelectionOnly: false,\n  // Non-customizable.\n  printWithCloudPrint: false,\n  printWithPrivet: false,\n  printWithExtension: false,\n  pagesPerSheet: 1,\n  isFirstRequest: false,\n  previewUIID: 0,\n  previewModifiable: true,\n  printToPDF: true,\n  deviceName: 'Save as PDF',\n  generateDraftData: true,\n  dpiHorizontal: 72,\n  dpiVertical: 72,\n  rasterizePDF: false,\n  duplex: 0,\n  copies: 1,\n  // 2 = color - see ColorModel in //printing/print_job_constants.h\n  color: 2,\n  collate: true,\n  printerType: 2,\n  title: undefined as string | undefined,\n  url: undefined as string | undefined\n};\n\n// JavaScript implementations of WebContents.\nconst binding = process._linkedBinding('electron_browser_web_contents');\nconst printing = process._linkedBinding('electron_browser_printing');\nconst { WebContents } = binding as { WebContents: { prototype: Electron.WebContents } };\n\nWebContents.prototype.send = function (channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  }\n\n  return this._send(false /* internal */, channel, args);\n};\n\nWebContents.prototype.postMessage = function (...args) {\n  if (Array.isArray(args[2])) {\n    args[2] = args[2].map(o => o instanceof MessagePortMain ? o._internalPort : o);\n  }\n  this._postMessage(...args);\n};\n\nWebContents.prototype._sendInternal = function (channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  }\n\n  return this._send(true /* internal */, channel, args);\n};\nWebContents.prototype.sendToFrame = function (frameId, channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  } else if (typeof frameId !== 'number') {\n    throw new Error('Missing required frameId argument');\n  }\n\n  return this._sendToFrame(false /* internal */, frameId, channel, args);\n};\nWebContents.prototype._sendToFrameInternal = function (frameId, channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  } else if (typeof frameId !== 'number') {\n    throw new Error('Missing required frameId argument');\n  }\n\n  return this._sendToFrame(true /* internal */, frameId, channel, args);\n};\n\n// Following methods are mapped to webFrame.\nconst webFrameMethods = [\n  'insertCSS',\n  'insertText',\n  'removeInsertedCSS',\n  'setVisualZoomLevelLimits'\n] as ('insertCSS' | 'insertText' | 'removeInsertedCSS' | 'setVisualZoomLevelLimits')[];\n\nfor (const method of webFrameMethods) {\n  WebContents.prototype[method] = function (...args: any[]): Promise<any> {\n    return ipcMainUtils.invokeInWebContents(this, IPC_MESSAGES.RENDERER_WEB_FRAME_METHOD, method, ...args);\n  };\n}\n\nconst waitTillCanExecuteJavaScript = async (webContents: Electron.WebContents) => {\n  if (webContents.getURL() && !webContents.isLoadingMainFrame()) return;\n\n  return new Promise((resolve) => {\n    webContents.once('did-stop-loading', () => {\n      resolve();\n    });\n  });\n};\n\n// Make sure WebContents::executeJavaScript would run the code only when the\n// WebContents has been loaded.\nWebContents.prototype.executeJavaScript = async function (code, hasUserGesture) {\n  await waitTillCanExecuteJavaScript(this);\n  return ipcMainUtils.invokeInWebContents(this, IPC_MESSAGES.RENDERER_WEB_FRAME_METHOD, 'executeJavaScript', String(code), !!hasUserGesture);\n};\nWebContents.prototype.executeJavaScriptInIsolatedWorld = async function (worldId, code, hasUserGesture) {\n  await waitTillCanExecuteJavaScript(this);\n  return ipcMainUtils.invokeInWebContents(this, IPC_MESSAGES.RENDERER_WEB_FRAME_METHOD, 'executeJavaScriptInIsolatedWorld', worldId, code, !!hasUserGesture);\n};\n\n// Translate the options of printToPDF.\n\nlet pendingPromise: Promise<any> | undefined;\nWebContents.prototype.printToPDF = async function (options) {\n  const printSettings = {\n    ...defaultPrintingSetting,\n    requestID: getNextId()\n  };\n\n  if (options.landscape !== undefined) {\n    if (typeof options.landscape !== 'boolean') {\n      const error = new Error('landscape must be a Boolean');\n      return Promise.reject(error);\n    }\n    printSettings.landscape = options.landscape;\n  }\n\n  if (options.scaleFactor !== undefined) {\n    if (typeof options.scaleFactor !== 'number') {\n      const error = new Error('scaleFactor must be a Number');\n      return Promise.reject(error);\n    }\n    printSettings.scaleFactor = options.scaleFactor;\n  }\n\n  if (options.marginsType !== undefined) {\n    if (typeof options.marginsType !== 'number') {\n      const error = new Error('marginsType must be a Number');\n      return Promise.reject(error);\n    }\n    printSettings.marginsType = options.marginsType;\n  }\n\n  if (options.printSelectionOnly !== undefined) {\n    if (typeof options.printSelectionOnly !== 'boolean') {\n      const error = new Error('printSelectionOnly must be a Boolean');\n      return Promise.reject(error);\n    }\n    printSettings.shouldPrintSelectionOnly = options.printSelectionOnly;\n  }\n\n  if (options.printBackground !== undefined) {\n    if (typeof options.printBackground !== 'boolean') {\n      const error = new Error('printBackground must be a Boolean');\n      return Promise.reject(error);\n    }\n    printSettings.shouldPrintBackgrounds = options.printBackground;\n  }\n\n  if (options.pageRanges !== undefined) {\n    const pageRanges = options.pageRanges;\n    if (!Object.prototype.hasOwnProperty.call(pageRanges, 'from') || !Object.prototype.hasOwnProperty.call(pageRanges, 'to')) {\n      const error = new Error('pageRanges must be an Object with \\'from\\' and \\'to\\' properties');\n      return Promise.reject(error);\n    }\n\n    if (typeof pageRanges.from !== 'number') {\n      const error = new Error('pageRanges.from must be a Number');\n      return Promise.reject(error);\n    }\n\n    if (typeof pageRanges.to !== 'number') {\n      const error = new Error('pageRanges.to must be a Number');\n      return Promise.reject(error);\n    }\n\n    // Chromium uses 1-based page ranges, so increment each by 1.\n    printSettings.pageRange = [{\n      from: pageRanges.from + 1,\n      to: pageRanges.to + 1\n    }];\n  }\n\n  if (options.headerFooter !== undefined) {\n    const headerFooter = options.headerFooter;\n    printSettings.headerFooterEnabled = true;\n    if (typeof headerFooter === 'object') {\n      if (!headerFooter.url || !headerFooter.title) {\n        const error = new Error('url and title properties are required for headerFooter');\n        return Promise.reject(error);\n      }\n      if (typeof headerFooter.title !== 'string') {\n        const error = new Error('headerFooter.title must be a String');\n        return Promise.reject(error);\n      }\n      printSettings.title = headerFooter.title;\n\n      if (typeof headerFooter.url !== 'string') {\n        const error = new Error('headerFooter.url must be a String');\n        return Promise.reject(error);\n      }\n      printSettings.url = headerFooter.url;\n    } else {\n      const error = new Error('headerFooter must be an Object');\n      return Promise.reject(error);\n    }\n  }\n\n  // Optionally set size for PDF.\n  if (options.pageSize !== undefined) {\n    const pageSize = options.pageSize;\n    if (typeof pageSize === 'object') {\n      if (!pageSize.height || !pageSize.width) {\n        const error = new Error('height and width properties are required for pageSize');\n        return Promise.reject(error);\n      }\n\n      // Dimensions in Microns - 1 meter = 10^6 microns\n      const height = Math.ceil(pageSize.height);\n      const width = Math.ceil(pageSize.width);\n      if (!isValidCustomPageSize(width, height)) {\n        const error = new Error('height and width properties must be minimum 352 microns.');\n        return Promise.reject(error);\n      }\n\n      printSettings.mediaSize = {\n        name: 'CUSTOM',\n        custom_display_name: 'Custom',\n        height_microns: height,\n        width_microns: width\n      };\n    } else if (Object.prototype.hasOwnProperty.call(PDFPageSizes, pageSize)) {\n      printSettings.mediaSize = PDFPageSizes[pageSize];\n    } else {\n      const error = new Error(`Unsupported pageSize: ${pageSize}`);\n      return Promise.reject(error);\n    }\n  } else {\n    printSettings.mediaSize = PDFPageSizes.A4;\n  }\n\n  // Chromium expects this in a 0-100 range number, not as float\n  printSettings.scaleFactor = Math.ceil(printSettings.scaleFactor) % 100;\n  // PrinterType enum from //printing/print_job_constants.h\n  printSettings.printerType = 2;\n  if (this._printToPDF) {\n    if (pendingPromise) {\n      pendingPromise = pendingPromise.then(() => this._printToPDF(printSettings));\n    } else {\n      pendingPromise = this._printToPDF(printSettings);\n    }\n    return pendingPromise;\n  } else {\n    const error = new Error('Printing feature is disabled');\n    return Promise.reject(error);\n  }\n};\n\nWebContents.prototype.print = function (options = {}, callback) {\n  // TODO(codebytere): deduplicate argument sanitization by moving rest of\n  // print param logic into new file shared between printToPDF and print\n  if (typeof options === 'object') {\n    // Optionally set size for PDF.\n    if (options.pageSize !== undefined) {\n      const pageSize = options.pageSize;\n      if (typeof pageSize === 'object') {\n        if (!pageSize.height || !pageSize.width) {\n          throw new Error('height and width properties are required for pageSize');\n        }\n\n        // Dimensions in Microns - 1 meter = 10^6 microns\n        const height = Math.ceil(pageSize.height);\n        const width = Math.ceil(pageSize.width);\n        if (!isValidCustomPageSize(width, height)) {\n          throw new Error('height and width properties must be minimum 352 microns.');\n        }\n\n        (options as any).mediaSize = {\n          name: 'CUSTOM',\n          custom_display_name: 'Custom',\n          height_microns: height,\n          width_microns: width\n        };\n      } else if (PDFPageSizes[pageSize]) {\n        (options as any).mediaSize = PDFPageSizes[pageSize];\n      } else {\n        throw new Error(`Unsupported pageSize: ${pageSize}`);\n      }\n    }\n  }\n\n  if (this._print) {\n    if (callback) {\n      this._print(options, callback);\n    } else {\n      this._print(options);\n    }\n  } else {\n    console.error('Error: Printing feature is disabled.');\n  }\n};\n\nWebContents.prototype.getPrinters = function () {\n  // TODO(nornagon): this API has nothing to do with WebContents and should be\n  // moved.\n  if (printing.getPrinterList) {\n    return printing.getPrinterList();\n  } else {\n    console.error('Error: Printing feature is disabled.');\n    return [];\n  }\n};\n\nWebContents.prototype.loadFile = function (filePath, options = {}) {\n  if (typeof filePath !== 'string') {\n    throw new Error('Must pass filePath as a string');\n  }\n  const { query, search, hash } = options;\n\n  return this.loadURL(url.format({\n    protocol: 'file',\n    slashes: true,\n    pathname: path.resolve(app.getAppPath(), filePath),\n    query,\n    search,\n    hash\n  }));\n};\n\nWebContents.prototype.setWindowOpenHandler = function (handler: (details: Electron.HandlerDetails) => ({action: 'allow'} | {action: 'deny', overrideBrowserWindowOptions?: BrowserWindowConstructorOptions})) {\n  this._windowOpenHandler = handler;\n};\n\nWebContents.prototype._callWindowOpenHandler = function (event: any, url: string, frameName: string, rawFeatures: string): BrowserWindowConstructorOptions | null {\n  if (!this._windowOpenHandler) {\n    return null;\n  }\n  const response = this._windowOpenHandler({ url, frameName, features: rawFeatures });\n\n  if (typeof response !== 'object') {\n    event.preventDefault();\n    console.error(`The window open handler response must be an object, but was instead of type '${typeof response}'.`);\n    return null;\n  }\n\n  if (response === null) {\n    event.preventDefault();\n    console.error('The window open handler response must be an object, but was instead null.');\n    return null;\n  }\n\n  if (response.action === 'deny') {\n    event.preventDefault();\n    return null;\n  } else if (response.action === 'allow') {\n    if (typeof response.overrideBrowserWindowOptions === 'object' && response.overrideBrowserWindowOptions !== null) { return response.overrideBrowserWindowOptions; } else { return {}; }\n  } else {\n    event.preventDefault();\n    console.error('The window open handler response must be an object with an \\'action\\' property of \\'allow\\' or \\'deny\\'.');\n    return null;\n  }\n};\n\nconst addReplyToEvent = (event: any) => {\n  event.reply = (...args: any[]) => {\n    event.sender.sendToFrame(event.frameId, ...args);\n  };\n};\n\nconst addReturnValueToEvent = (event: any) => {\n  Object.defineProperty(event, 'returnValue', {\n    set: (value) => event.sendReply(value),\n    get: () => {}\n  });\n};\n\nconst commandLine = process._linkedBinding('electron_common_command_line');\nconst environment = process._linkedBinding('electron_common_environment');\n\nconst loggingEnabled = () => {\n  return environment.hasVar('ELECTRON_ENABLE_LOGGING') || commandLine.hasSwitch('enable-logging');\n};\n\n// Add JavaScript wrappers for WebContents class.\nWebContents.prototype._init = function () {\n  // The navigation controller.\n  const navigationController = new NavigationController(this);\n  this.loadURL = navigationController.loadURL.bind(navigationController);\n  this.getURL = navigationController.getURL.bind(navigationController);\n  this.stop = navigationController.stop.bind(navigationController);\n  this.reload = navigationController.reload.bind(navigationController);\n  this.reloadIgnoringCache = navigationController.reloadIgnoringCache.bind(navigationController);\n  this.canGoBack = navigationController.canGoBack.bind(navigationController);\n  this.canGoForward = navigationController.canGoForward.bind(navigationController);\n  this.canGoToIndex = navigationController.canGoToIndex.bind(navigationController);\n  this.canGoToOffset = navigationController.canGoToOffset.bind(navigationController);\n  this.clearHistory = navigationController.clearHistory.bind(navigationController);\n  this.goBack = navigationController.goBack.bind(navigationController);\n  this.goForward = navigationController.goForward.bind(navigationController);\n  this.goToIndex = navigationController.goToIndex.bind(navigationController);\n  this.goToOffset = navigationController.goToOffset.bind(navigationController);\n  this.getActiveIndex = navigationController.getActiveIndex.bind(navigationController);\n  this.length = navigationController.length.bind(navigationController);\n\n  this._windowOpenHandler = null;\n\n  // Every remote callback from renderer process would add a listener to the\n  // render-view-deleted event, so ignore the listeners warning.\n  this.setMaxListeners(0);\n\n  // Dispatch IPC messages to the ipc module.\n  this.on('-ipc-message' as any, function (this: Electron.WebContents, event: any, internal: boolean, channel: string, args: any[]) {\n    if (internal) {\n      ipcMainInternal.emit(channel, event, ...args);\n    } else {\n      addReplyToEvent(event);\n      this.emit('ipc-message', event, channel, ...args);\n      ipcMain.emit(channel, event, ...args);\n    }\n  });\n\n  this.on('-ipc-invoke' as any, function (event: any, internal: boolean, channel: string, args: any[]) {\n    event._reply = (result: any) => event.sendReply({ result });\n    event._throw = (error: Error) => {\n      console.error(`Error occurred in handler for '${channel}':`, error);\n      event.sendReply({ error: error.toString() });\n    };\n    const target = internal ? ipcMainInternal : ipcMain;\n    if ((target as any)._invokeHandlers.has(channel)) {\n      (target as any)._invokeHandlers.get(channel)(event, ...args);\n    } else {\n      event._throw(`No handler registered for '${channel}'`);\n    }\n  });\n\n  this.on('-ipc-message-sync' as any, function (this: Electron.WebContents, event: any, internal: boolean, channel: string, args: any[]) {\n    addReturnValueToEvent(event);\n    if (internal) {\n      ipcMainInternal.emit(channel, event, ...args);\n    } else {\n      addReplyToEvent(event);\n      this.emit('ipc-message-sync', event, channel, ...args);\n      ipcMain.emit(channel, event, ...args);\n    }\n  });\n\n  this.on('-ipc-ports' as any, function (event: any, internal: boolean, channel: string, message: any, ports: any[]) {\n    event.ports = ports.map(p => new MessagePortMain(p));\n    ipcMain.emit(channel, event, message);\n  });\n\n  // Handle context menu action request from pepper plugin.\n  this.on('pepper-context-menu' as any, function (event: any, params: {x: number, y: number, menu: Array<(MenuItemConstructorOptions) | (MenuItem)>}, callback: () => void) {\n    // Access Menu via electron.Menu to prevent circular require.\n    const menu = require('electron').Menu.buildFromTemplate(params.menu);\n    menu.popup({\n      window: event.sender.getOwnerBrowserWindow(),\n      x: params.x,\n      y: params.y,\n      callback\n    });\n  });\n\n  this.on('crashed', (event, ...args) => {\n    app.emit('renderer-process-crashed', event, this, ...args);\n  });\n\n  this.on('render-process-gone', (event, details) => {\n    app.emit('render-process-gone', event, this, details);\n\n    // Log out a hint to help users better debug renderer crashes.\n    if (loggingEnabled()) {\n      console.info(`Renderer process ${details.reason} - see https://www.electronjs.org/docs/tutorial/application-debugging for potential debugging information.`);\n    }\n  });\n\n  // The devtools requests the webContents to reload.\n  this.on('devtools-reload-page', function (this: Electron.WebContents) {\n    this.reload();\n  });\n\n  if (this.getType() !== 'remote') {\n    // Make new windows requested by links behave like \"window.open\".\n    this.on('-new-window' as any, (event: any, url: string, frameName: string, disposition: string,\n      rawFeatures: string, referrer: any, postData: PostData) => {\n      openGuestWindow({\n        event,\n        embedder: event.sender,\n        disposition,\n        referrer,\n        postData,\n        overrideBrowserWindowOptions: {},\n        windowOpenArgs: {\n          url,\n          frameName,\n          features: rawFeatures\n        }\n      });\n    });\n\n    let windowOpenOverriddenOptions: BrowserWindowConstructorOptions | null = null;\n    this.on('-will-add-new-contents' as any, (event: any, url: string, frameName: string, rawFeatures: string) => {\n      windowOpenOverriddenOptions = this._callWindowOpenHandler(event, url, frameName, rawFeatures);\n      if (!event.defaultPrevented) {\n        const secureOverrideWebPreferences = windowOpenOverriddenOptions ? {\n          // Allow setting of backgroundColor as a webPreference even though\n          // it's technically a BrowserWindowConstructorOptions option because\n          // we need to access it in the renderer at init time.\n          backgroundColor: windowOpenOverriddenOptions.backgroundColor,\n          ...windowOpenOverriddenOptions.webPreferences\n        } : undefined;\n        this._setNextChildWebPreferences(\n          makeWebPreferences({ embedder: event.sender, secureOverrideWebPreferences })\n        );\n      }\n    });\n\n    // Create a new browser window for the native implementation of\n    // \"window.open\", used in sandbox and nativeWindowOpen mode.\n    this.on('-add-new-contents' as any, (event: any, webContents: Electron.WebContents, disposition: string,\n      _userGesture: boolean, _left: number, _top: number, _width: number, _height: number, url: string, frameName: string,\n      referrer: Electron.Referrer, rawFeatures: string, postData: PostData) => {\n      const overriddenOptions = windowOpenOverriddenOptions || undefined;\n      windowOpenOverriddenOptions = null;\n\n      if ((disposition !== 'foreground-tab' && disposition !== 'new-window' &&\n           disposition !== 'background-tab')) {\n        event.preventDefault();\n        return;\n      }\n\n      openGuestWindow({\n        event,\n        embedder: event.sender,\n        guest: webContents,\n        overrideBrowserWindowOptions: overriddenOptions,\n        disposition,\n        referrer,\n        postData,\n        windowOpenArgs: {\n          url,\n          frameName,\n          features: rawFeatures\n        }\n      });\n    });\n\n    const prefs = this.getWebPreferences() || {};\n    if (prefs.webviewTag && prefs.contextIsolation) {\n      deprecate.log('Security Warning: A WebContents was just created with both webviewTag and contextIsolation enabled.  This combination is fundamentally less secure and effectively bypasses the protections of contextIsolation.  We strongly recommend you move away from webviews to OOPIF or BrowserView in order for your app to be more secure');\n    }\n  }\n\n  this.on('login', (event, ...args) => {\n    app.emit('login', event, this, ...args);\n  });\n\n  this.on('ready-to-show' as any, () => {\n    const owner = this.getOwnerBrowserWindow();\n    if (owner && !owner.isDestroyed()) {\n      process.nextTick(() => {\n        owner.emit('ready-to-show');\n      });\n    }\n  });\n\n  const event = process._linkedBinding('electron_browser_event').createEmpty();\n  app.emit('web-contents-created', event, this);\n\n  // Properties\n\n  Object.defineProperty(this, 'audioMuted', {\n    get: () => this.isAudioMuted(),\n    set: (muted) => this.setAudioMuted(muted)\n  });\n\n  Object.defineProperty(this, 'userAgent', {\n    get: () => this.getUserAgent(),\n    set: (agent) => this.setUserAgent(agent)\n  });\n\n  Object.defineProperty(this, 'zoomLevel', {\n    get: () => this.getZoomLevel(),\n    set: (level) => this.setZoomLevel(level)\n  });\n\n  Object.defineProperty(this, 'zoomFactor', {\n    get: () => this.getZoomFactor(),\n    set: (factor) => this.setZoomFactor(factor)\n  });\n\n  Object.defineProperty(this, 'frameRate', {\n    get: () => this.getFrameRate(),\n    set: (rate) => this.setFrameRate(rate)\n  });\n\n  Object.defineProperty(this, 'backgroundThrottling', {\n    get: () => this.getBackgroundThrottling(),\n    set: (allowed) => this.setBackgroundThrottling(allowed)\n  });\n};\n\n// Public APIs.\nexport function create (options = {}): Electron.WebContents {\n  return new (WebContents as any)(options);\n}\n\nexport function fromId (id: string) {\n  return binding.fromId(id);\n}\n\nexport function getFocusedWebContents () {\n  let focused = null;\n  for (const contents of binding.getAllWebContents()) {\n    if (!contents.isFocused()) continue;\n    if (focused == null) focused = contents;\n    // Return webview web contents which may be embedded inside another\n    // web contents that is also reporting as focused\n    if (contents.getType() === 'webview') return contents;\n  }\n  return focused;\n}\nexport function getAllWebContents () {\n  return binding.getAllWebContents();\n}\n", "import * as electron from 'electron/main';\nimport { EventEmitter } from 'events';\nimport objectsRegistry from '@electron/internal/browser/remote/objects-registry';\nimport { ipcMainInternal } from '@electron/internal/browser/ipc-main-internal';\nimport { isPromise, isSerializableObject, deserialize, serialize } from '@electron/internal/common/type-utils';\nimport type { MetaTypeFromRenderer, ObjectMember, MetaType, ObjProtoDescriptor } from '@electron/internal/common/remote/types';\nimport { IPC_MESSAGES } from '@electron/internal/common/remote/ipc-messages';\n\nconst v8Util = process._linkedBinding('electron_common_v8_util');\nconst eventBinding = process._linkedBinding('electron_browser_event');\nconst features = process._linkedBinding('electron_common_features');\n\nif (!features.isRemoteModuleEnabled()) {\n  throw new Error('remote module is disabled');\n}\n\n// The internal properties of Function.\nconst FUNCTION_PROPERTIES = [\n  'length', 'name', 'arguments', 'caller', 'prototype'\n];\n\ntype RendererFunctionId = [string, number] // [contextId, funcId]\ntype FinalizerInfo = { id: RendererFunctionId, webContents: electron.WebContents, frameId: number };\ntype CallIntoRenderer = (...args: any[]) => void\n\n// The remote functions in renderer processes.\nconst rendererFunctionCache = new Map<string, WeakRef<CallIntoRenderer>>();\n// eslint-disable-next-line no-undef\nconst finalizationRegistry = new FinalizationRegistry((fi: FinalizerInfo) => {\n  const mapKey = fi.id[0] + '~' + fi.id[1];\n  const ref = rendererFunctionCache.get(mapKey);\n  if (ref !== undefined && ref.deref() === undefined) {\n    rendererFunctionCache.delete(mapKey);\n    if (!fi.webContents.isDestroyed()) { fi.webContents._sendToFrameInternal(fi.frameId, IPC_MESSAGES.RENDERER_RELEASE_CALLBACK, fi.id[0], fi.id[1]); }\n  }\n});\n\nfunction getCachedRendererFunction (id: RendererFunctionId): CallIntoRenderer | undefined {\n  const mapKey = id[0] + '~' + id[1];\n  const ref = rendererFunctionCache.get(mapKey);\n  if (ref !== undefined) {\n    const deref = ref.deref();\n    if (deref !== undefined) return deref;\n  }\n}\nfunction setCachedRendererFunction (id: RendererFunctionId, wc: electron.WebContents, frameId: number, value: CallIntoRenderer) {\n  // eslint-disable-next-line no-undef\n  const wr = new WeakRef<CallIntoRenderer>(value);\n  const mapKey = id[0] + '~' + id[1];\n  rendererFunctionCache.set(mapKey, wr);\n  finalizationRegistry.register(value, {\n    id,\n    webContents: wc,\n    frameId\n  } as FinalizerInfo);\n  return value;\n}\n\nconst locationInfo = new WeakMap<Object, string>();\n\n// Return the description of object's members:\nconst getObjectMembers = function (object: any): ObjectMember[] {\n  let names = Object.getOwnPropertyNames(object);\n  // For Function, we should not override following properties even though they\n  // are \"own\" properties.\n  if (typeof object === 'function') {\n    names = names.filter((name) => {\n      return !FUNCTION_PROPERTIES.includes(name);\n    });\n  }\n  // Map properties to descriptors.\n  return names.map((name) => {\n    const descriptor = Object.getOwnPropertyDescriptor(object, name)!;\n    let type: ObjectMember['type'];\n    let writable = false;\n    if (descriptor.get === undefined && typeof object[name] === 'function') {\n      type = 'method';\n    } else {\n      if (descriptor.set || descriptor.writable) writable = true;\n      type = 'get';\n    }\n    return { name, enumerable: descriptor.enumerable, writable, type };\n  });\n};\n\n// Return the description of object's prototype.\nconst getObjectPrototype = function (object: any): ObjProtoDescriptor {\n  const proto = Object.getPrototypeOf(object);\n  if (proto === null || proto === Object.prototype) return null;\n  return {\n    members: getObjectMembers(proto),\n    proto: getObjectPrototype(proto)\n  };\n};\n\n// Convert a real value into meta data.\nconst valueToMeta = function (sender: electron.WebContents, contextId: string, value: any, optimizeSimpleObject = false): MetaType {\n  // Determine the type of value.\n  let type: MetaType['type'];\n\n  switch (typeof value) {\n    case 'object':\n      // Recognize certain types of objects.\n      if (value instanceof Buffer) {\n        type = 'buffer';\n      } else if (value && value.constructor && value.constructor.name === 'NativeImage') {\n        type = 'nativeimage';\n      } else if (Array.isArray(value)) {\n        type = 'array';\n      } else if (value instanceof Error) {\n        type = 'error';\n      } else if (isSerializableObject(value)) {\n        type = 'value';\n      } else if (isPromise(value)) {\n        type = 'promise';\n      } else if (Object.prototype.hasOwnProperty.call(value, 'callee') && value.length != null) {\n        // Treat the arguments object as array.\n        type = 'array';\n      } else if (optimizeSimpleObject && v8Util.getHiddenValue(value, 'simple')) {\n        // Treat simple objects as value.\n        type = 'value';\n      } else {\n        type = 'object';\n      }\n      break;\n    case 'function':\n      type = 'function';\n      break;\n    default:\n      type = 'value';\n      break;\n  }\n\n  // Fill the meta object according to value's type.\n  if (type === 'array') {\n    return {\n      type,\n      members: value.map((el: any) => valueToMeta(sender, contextId, el, optimizeSimpleObject))\n    };\n  } else if (type === 'nativeimage') {\n    return { type, value: serialize(value) };\n  } else if (type === 'object' || type === 'function') {\n    return {\n      type,\n      name: value.constructor ? value.constructor.name : '',\n      // Reference the original value if it's an object, because when it's\n      // passed to renderer we would assume the renderer keeps a reference of\n      // it.\n      id: objectsRegistry.add(sender, contextId, value),\n      members: getObjectMembers(value),\n      proto: getObjectPrototype(value)\n    };\n  } else if (type === 'buffer') {\n    return { type, value };\n  } else if (type === 'promise') {\n    // Add default handler to prevent unhandled rejections in main process\n    // Instead they should appear in the renderer process\n    value.then(function () {}, function () {});\n\n    return {\n      type,\n      then: valueToMeta(sender, contextId, function (onFulfilled: Function, onRejected: Function) {\n        value.then(onFulfilled, onRejected);\n      })\n    };\n  } else if (type === 'error') {\n    return {\n      type,\n      value,\n      members: Object.keys(value).map(name => ({\n        name,\n        value: valueToMeta(sender, contextId, value[name])\n      }))\n    };\n  } else {\n    return {\n      type: 'value',\n      value\n    };\n  }\n};\n\nconst throwRPCError = function (message: string) {\n  const error = new Error(message) as Error & {code: string, errno: number};\n  error.code = 'EBADRPC';\n  error.errno = -72;\n  throw error;\n};\n\nconst removeRemoteListenersAndLogWarning = (sender: any, callIntoRenderer: (...args: any[]) => void) => {\n  const location = locationInfo.get(callIntoRenderer);\n  let message = 'Attempting to call a function in a renderer window that has been closed or released.' +\n    `\\nFunction provided here: ${location}`;\n\n  if (sender instanceof EventEmitter) {\n    const remoteEvents = sender.eventNames().filter((eventName) => {\n      return sender.listeners(eventName).includes(callIntoRenderer);\n    });\n\n    if (remoteEvents.length > 0) {\n      message += `\\nRemote event names: ${remoteEvents.join(', ')}`;\n      remoteEvents.forEach((eventName) => {\n        sender.removeListener(eventName as any, callIntoRenderer);\n      });\n    }\n  }\n\n  console.warn(message);\n};\n\nconst fakeConstructor = (constructor: Function, name: string) =>\n  new Proxy(Object, {\n    get (target, prop, receiver) {\n      if (prop === 'name') {\n        return name;\n      } else {\n        return Reflect.get(target, prop, receiver);\n      }\n    }\n  });\n\n// Convert array of meta data from renderer into array of real values.\nconst unwrapArgs = function (sender: electron.WebContents, frameId: number, contextId: string, args: any[]) {\n  const metaToValue = function (meta: MetaTypeFromRenderer): any {\n    switch (meta.type) {\n      case 'nativeimage':\n        return deserialize(meta.value);\n      case 'value':\n        return meta.value;\n      case 'remote-object':\n        return objectsRegistry.get(meta.id);\n      case 'array':\n        return unwrapArgs(sender, frameId, contextId, meta.value);\n      case 'buffer':\n        return Buffer.from(meta.value.buffer, meta.value.byteOffset, meta.value.byteLength);\n      case 'promise':\n        return Promise.resolve({\n          then: metaToValue(meta.then)\n        });\n      case 'object': {\n        const ret: any = meta.name !== 'Object' ? Object.create({\n          constructor: fakeConstructor(Object, meta.name)\n        }) : {};\n\n        for (const { name, value } of meta.members) {\n          ret[name] = metaToValue(value);\n        }\n        return ret;\n      }\n      case 'function-with-return-value': {\n        const returnValue = metaToValue(meta.value);\n        return function () {\n          return returnValue;\n        };\n      }\n      case 'function': {\n        // Merge contextId and meta.id, since meta.id can be the same in\n        // different webContents.\n        const objectId: [string, number] = [contextId, meta.id];\n\n        // Cache the callbacks in renderer.\n        const cachedFunction = getCachedRendererFunction(objectId);\n        if (cachedFunction !== undefined) { return cachedFunction; }\n\n        const callIntoRenderer = function (this: any, ...args: any[]) {\n          let succeed = false;\n          if (!sender.isDestroyed()) {\n            succeed = sender._sendToFrameInternal(frameId, IPC_MESSAGES.RENDERER_CALLBACK, contextId, meta.id, valueToMeta(sender, contextId, args));\n          }\n          if (!succeed) {\n            removeRemoteListenersAndLogWarning(this, callIntoRenderer);\n          }\n        };\n        locationInfo.set(callIntoRenderer, meta.location);\n        Object.defineProperty(callIntoRenderer, 'length', { value: meta.length });\n\n        setCachedRendererFunction(objectId, sender, frameId, callIntoRenderer);\n        return callIntoRenderer;\n      }\n      default:\n        throw new TypeError(`Unknown type: ${(meta as any).type}`);\n    }\n  };\n  return args.map(metaToValue);\n};\n\nconst isRemoteModuleEnabledImpl = function (contents: electron.WebContents) {\n  const webPreferences = contents.getLastWebPreferences() || {};\n  return webPreferences.enableRemoteModule != null ? !!webPreferences.enableRemoteModule : false;\n};\n\nconst isRemoteModuleEnabledCache = new WeakMap();\n\nexport const isRemoteModuleEnabled = function (contents: electron.WebContents) {\n  if (!isRemoteModuleEnabledCache.has(contents)) {\n    isRemoteModuleEnabledCache.set(contents, isRemoteModuleEnabledImpl(contents));\n  }\n\n  return isRemoteModuleEnabledCache.get(contents);\n};\n\nconst handleRemoteCommand = function (channel: string, handler: (event: ElectronInternal.IpcMainInternalEvent, contextId: string, ...args: any[]) => void) {\n  ipcMainInternal.on(channel, (event, contextId: string, ...args: any[]) => {\n    let returnValue;\n    if (!isRemoteModuleEnabled(event.sender)) {\n      event.returnValue = null;\n      return;\n    }\n\n    try {\n      returnValue = handler(event, contextId, ...args);\n    } catch (error) {\n      returnValue = {\n        type: 'exception',\n        value: valueToMeta(event.sender, contextId, error)\n      };\n    }\n\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n    }\n  });\n};\n\nconst emitCustomEvent = function (contents: electron.WebContents, eventName: string, ...args: any[]) {\n  const event = eventBinding.createWithSender(contents);\n\n  electron.app.emit(eventName, event, contents, ...args);\n  contents.emit(eventName, event, ...args);\n\n  return event;\n};\n\nconst logStack = function (contents: electron.WebContents, code: string, stack: string | undefined) {\n  if (stack) {\n    console.warn(`WebContents (${contents.id}): ${code}`, stack);\n  }\n};\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_WRONG_CONTEXT_ERROR, function (event, contextId, passedContextId, id) {\n  const objectId: [string, number] = [passedContextId, id];\n  const cachedFunction = getCachedRendererFunction(objectId);\n  if (cachedFunction === undefined) {\n    // Do nothing if the error has already been reported before.\n    return;\n  }\n  removeRemoteListenersAndLogWarning(event.sender, cachedFunction);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_REQUIRE, function (event, contextId, moduleName, stack) {\n  logStack(event.sender, `remote.require('${moduleName}')`, stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-require', moduleName);\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.require('${moduleName}')`);\n    } else {\n      customEvent.returnValue = (process as any).mainModule.require(moduleName);\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_BUILTIN, function (event, contextId, moduleName, stack) {\n  logStack(event.sender, `remote.getBuiltin('${moduleName}')`, stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-builtin', moduleName);\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getBuiltin('${moduleName}')`);\n    } else {\n      customEvent.returnValue = (electron as any)[moduleName];\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_GLOBAL, function (event, contextId, globalName, stack) {\n  logStack(event.sender, `remote.getGlobal('${globalName}')`, stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-global', globalName);\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getGlobal('${globalName}')`);\n    } else {\n      customEvent.returnValue = (global as any)[globalName];\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_CURRENT_WINDOW, function (event, contextId, stack) {\n  logStack(event.sender, 'remote.getCurrentWindow()', stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-current-window');\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error('Blocked remote.getCurrentWindow()');\n    } else {\n      customEvent.returnValue = event.sender.getOwnerBrowserWindow();\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_CURRENT_WEB_CONTENTS, function (event, contextId, stack) {\n  logStack(event.sender, 'remote.getCurrentWebContents()', stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-current-web-contents');\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error('Blocked remote.getCurrentWebContents()');\n    } else {\n      customEvent.returnValue = event.sender;\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_CONSTRUCTOR, function (event, contextId, id, args) {\n  args = unwrapArgs(event.sender, event.frameId, contextId, args);\n  const constructor = objectsRegistry.get(id);\n\n  if (constructor == null) {\n    throwRPCError(`Cannot call constructor on missing remote object ${id}`);\n  }\n\n  return valueToMeta(event.sender, contextId, new constructor(...args));\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_FUNCTION_CALL, function (event, contextId, id, args) {\n  args = unwrapArgs(event.sender, event.frameId, contextId, args);\n  const func = objectsRegistry.get(id);\n\n  if (func == null) {\n    throwRPCError(`Cannot call function on missing remote object ${id}`);\n  }\n\n  try {\n    return valueToMeta(event.sender, contextId, func(...args), true);\n  } catch (error) {\n    const err = new Error(`Could not call remote function '${func.name || 'anonymous'}'. Check that the function signature is correct. Underlying error: ${error.message}\\nUnderlying stack: ${error.stack}\\n`);\n    (err as any).cause = error;\n    throw err;\n  }\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_CONSTRUCTOR, function (event, contextId, id, method, args) {\n  args = unwrapArgs(event.sender, event.frameId, contextId, args);\n  const object = objectsRegistry.get(id);\n\n  if (object == null) {\n    throwRPCError(`Cannot call constructor '${method}' on missing remote object ${id}`);\n  }\n\n  return valueToMeta(event.sender, contextId, new object[method](...args));\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_CALL, function (event, contextId, id, method, args) {\n  args = unwrapArgs(event.sender, event.frameId, contextId, args);\n  const object = objectsRegistry.get(id);\n\n  if (object == null) {\n    throwRPCError(`Cannot call method '${method}' on missing remote object ${id}`);\n  }\n\n  try {\n    return valueToMeta(event.sender, contextId, object[method](...args), true);\n  } catch (error) {\n    const err = new Error(`Could not call remote method '${method}'. Check that the method signature is correct. Underlying error: ${error.message}\\nUnderlying stack: ${error.stack}\\n`);\n    (err as any).cause = error;\n    throw err;\n  }\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_SET, function (event, contextId, id, name, args) {\n  args = unwrapArgs(event.sender, event.frameId, contextId, args);\n  const obj = objectsRegistry.get(id);\n\n  if (obj == null) {\n    throwRPCError(`Cannot set property '${name}' on missing remote object ${id}`);\n  }\n\n  obj[name] = args[0];\n  return null;\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_GET, function (event, contextId, id, name) {\n  const obj = objectsRegistry.get(id);\n\n  if (obj == null) {\n    throwRPCError(`Cannot get property '${name}' on missing remote object ${id}`);\n  }\n\n  return valueToMeta(event.sender, contextId, obj[name]);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_DEREFERENCE, function (event, contextId, id) {\n  objectsRegistry.remove(event.sender, contextId, id);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_CONTEXT_RELEASE, (event, contextId) => {\n  objectsRegistry.clear(event.sender, contextId);\n});\n", "// Copyright (c) 2014 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"base/containers/id_map.h\"\n#include \"base/files/file_util.h\"\n#include \"base/json/json_reader.h\"\n#include \"base/no_destructor.h\"\n#include \"base/optional.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"base/task/current_thread.h\"\n#include \"base/task/post_task.h\"\n#include \"base/task/thread_pool.h\"\n#include \"base/threading/scoped_blocking_call.h\"\n#include \"base/threading/sequenced_task_runner_handle.h\"\n#include \"base/threading/thread_restrictions.h\"\n#include \"base/threading/thread_task_runner_handle.h\"\n#include \"base/values.h\"\n#include \"chrome/browser/browser_process.h\"\n#include \"chrome/browser/ssl/security_state_tab_helper.h\"\n#include \"chrome/common/pref_names.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"components/prefs/scoped_user_pref_update.h\"\n#include \"components/security_state/content/content_utils.h\"\n#include \"components/security_state/core/security_state.h\"\n#include \"content/browser/renderer_host/frame_tree_node.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_frame_host_manager.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_impl.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_view_base.h\"  // nogncheck\n#include \"content/public/browser/child_process_security_policy.h\"\n#include \"content/public/browser/context_menu_params.h\"\n#include \"content/public/browser/download_request_utils.h\"\n#include \"content/public/browser/favicon_status.h\"\n#include \"content/public/browser/file_select_listener.h\"\n#include \"content/public/browser/native_web_keyboard_event.h\"\n#include \"content/public/browser/navigation_details.h\"\n#include \"content/public/browser/navigation_entry.h\"\n#include \"content/public/browser/navigation_handle.h\"\n#include \"content/public/browser/plugin_service.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/render_process_host.h\"\n#include \"content/public/browser/render_view_host.h\"\n#include \"content/public/browser/render_widget_host.h\"\n#include \"content/public/browser/render_widget_host_view.h\"\n#include \"content/public/browser/security_style_explanation.h\"\n#include \"content/public/browser/security_style_explanations.h\"\n#include \"content/public/browser/service_worker_context.h\"\n#include \"content/public/browser/site_instance.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/common/referrer_type_converters.h\"\n#include \"content/public/common/webplugininfo.h\"\n#include \"electron/buildflags/buildflags.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"gin/arguments.h\"\n#include \"gin/data_object_builder.h\"\n#include \"gin/handle.h\"\n#include \"gin/object_template_builder.h\"\n#include \"gin/wrappable.h\"\n#include \"mojo/public/cpp/bindings/associated_remote.h\"\n#include \"mojo/public/cpp/bindings/pending_receiver.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#include \"mojo/public/cpp/system/platform_handle.h\"\n#include \"ppapi/buildflags/buildflags.h\"\n#include \"printing/buildflags/buildflags.h\"\n#include \"shell/browser/api/electron_api_browser_window.h\"\n#include \"shell/browser/api/electron_api_debugger.h\"\n#include \"shell/browser/api/electron_api_session.h\"\n#include \"shell/browser/api/electron_api_web_frame_main.h\"\n#include \"shell/browser/api/message_port.h\"\n#include \"shell/browser/browser.h\"\n#include \"shell/browser/child_web_contents_tracker.h\"\n#include \"shell/browser/electron_autofill_driver_factory.h\"\n#include \"shell/browser/electron_browser_client.h\"\n#include \"shell/browser/electron_browser_context.h\"\n#include \"shell/browser/electron_browser_main_parts.h\"\n#include \"shell/browser/electron_javascript_dialog_manager.h\"\n#include \"shell/browser/electron_navigation_throttle.h\"\n#include \"shell/browser/lib/bluetooth_chooser.h\"\n#include \"shell/browser/native_window.h\"\n#include \"shell/browser/session_preferences.h\"\n#include \"shell/browser/ui/drag_util.h\"\n#include \"shell/browser/ui/file_dialog.h\"\n#include \"shell/browser/ui/inspectable_web_contents.h\"\n#include \"shell/browser/ui/inspectable_web_contents_view.h\"\n#include \"shell/browser/web_contents_permission_helper.h\"\n#include \"shell/browser/web_contents_preferences.h\"\n#include \"shell/browser/web_contents_zoom_controller.h\"\n#include \"shell/browser/web_dialog_helper.h\"\n#include \"shell/browser/web_view_guest_delegate.h\"\n#include \"shell/common/api/electron_api_native_image.h\"\n#include \"shell/common/color_util.h\"\n#include \"shell/common/electron_constants.h\"\n#include \"shell/common/gin_converters/base_converter.h\"\n#include \"shell/common/gin_converters/blink_converter.h\"\n#include \"shell/common/gin_converters/callback_converter.h\"\n#include \"shell/common/gin_converters/content_converter.h\"\n#include \"shell/common/gin_converters/file_path_converter.h\"\n#include \"shell/common/gin_converters/frame_converter.h\"\n#include \"shell/common/gin_converters/gfx_converter.h\"\n#include \"shell/common/gin_converters/gurl_converter.h\"\n#include \"shell/common/gin_converters/image_converter.h\"\n#include \"shell/common/gin_converters/net_converter.h\"\n#include \"shell/common/gin_converters/value_converter.h\"\n#include \"shell/common/gin_helper/dictionary.h\"\n#include \"shell/common/gin_helper/object_template_builder.h\"\n#include \"shell/common/language_util.h\"\n#include \"shell/common/mouse_util.h\"\n#include \"shell/common/node_includes.h\"\n#include \"shell/common/options_switches.h\"\n#include \"shell/common/v8_value_serializer.h\"\n#include \"storage/browser/file_system/isolated_context.h\"\n#include \"third_party/blink/public/common/associated_interfaces/associated_interface_provider.h\"\n#include \"third_party/blink/public/common/input/web_input_event.h\"\n#include \"third_party/blink/public/common/messaging/transferable_message_mojom_traits.h\"\n#include \"third_party/blink/public/common/page/page_zoom.h\"\n#include \"third_party/blink/public/mojom/frame/find_in_page.mojom.h\"\n#include \"third_party/blink/public/mojom/frame/fullscreen.mojom.h\"\n#include \"third_party/blink/public/mojom/messaging/transferable_message.mojom.h\"\n#include \"third_party/blink/public/mojom/renderer_preferences.mojom.h\"\n#include \"ui/base/cursor/cursor.h\"\n#include \"ui/base/cursor/mojom/cursor_type.mojom-shared.h\"\n#include \"ui/display/screen.h\"\n#include \"ui/events/base_event_utils.h\"\n\n#if BUILDFLAG(ENABLE_OSR)\n#include \"shell/browser/osr/osr_render_widget_host_view.h\"\n#include \"shell/browser/osr/osr_web_contents_view.h\"\n#endif\n\n#if !defined(OS_MAC)\n#include \"ui/aura/window.h\"\n#else\n#include \"ui/base/cocoa/defaults_utils.h\"\n#endif\n\n#if defined(OS_LINUX)\n#include \"ui/views/linux_ui/linux_ui.h\"\n#endif\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n#include \"ui/gfx/font_render_params.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n#include \"extensions/browser/script_executor.h\"\n#include \"extensions/browser/view_type_utils.h\"\n#include \"shell/browser/extensions/electron_extension_web_contents_observer.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PRINTING)\n#include \"chrome/browser/printing/print_view_manager_basic.h\"\n#include \"components/printing/browser/print_manager_utils.h\"\n#include \"printing/backend/print_backend.h\"  // nogncheck\n#include \"printing/mojom/print.mojom.h\"\n#include \"shell/browser/printing/print_preview_message_handler.h\"\n\n#if defined(OS_WIN)\n#include \"printing/backend/win_helper.h\"\n#endif\n#endif\n\n#if BUILDFLAG(ENABLE_COLOR_CHOOSER)\n#include \"chrome/browser/ui/color_chooser.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PICTURE_IN_PICTURE)\n#include \"chrome/browser/picture_in_picture/picture_in_picture_window_manager.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PDF_VIEWER)\n#include \"components/pdf/browser/pdf_web_contents_helper.h\"  // nogncheck\n#include \"shell/browser/electron_pdf_web_contents_helper_client.h\"\n#endif\n\n#ifndef MAS_BUILD\n#include \"chrome/browser/hang_monitor/hang_crash_dump.h\"  // nogncheck\n#endif\n\nnamespace gin {\n\n#if BUILDFLAG(ENABLE_PRINTING)\ntemplate <>\nstruct Converter<printing::mojom::MarginType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::mojom::MarginType* out) {\n    std::string type;\n    if (ConvertFromV8(isolate, val, &type)) {\n      if (type == \"default\") {\n        *out = printing::mojom::MarginType::kDefaultMargins;\n        return true;\n      }\n      if (type == \"none\") {\n        *out = printing::mojom::MarginType::kNoMargins;\n        return true;\n      }\n      if (type == \"printableArea\") {\n        *out = printing::mojom::MarginType::kPrintableAreaMargins;\n        return true;\n      }\n      if (type == \"custom\") {\n        *out = printing::mojom::MarginType::kCustomMargins;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\ntemplate <>\nstruct Converter<printing::mojom::DuplexMode> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::mojom::DuplexMode* out) {\n    std::string mode;\n    if (ConvertFromV8(isolate, val, &mode)) {\n      if (mode == \"simplex\") {\n        *out = printing::mojom::DuplexMode::kSimplex;\n        return true;\n      }\n      if (mode == \"longEdge\") {\n        *out = printing::mojom::DuplexMode::kLongEdge;\n        return true;\n      }\n      if (mode == \"shortEdge\") {\n        *out = printing::mojom::DuplexMode::kShortEdge;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n#endif\n\ntemplate <>\nstruct Converter<WindowOpenDisposition> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   WindowOpenDisposition val) {\n    std::string disposition = \"other\";\n    switch (val) {\n      case WindowOpenDisposition::CURRENT_TAB:\n        disposition = \"default\";\n        break;\n      case WindowOpenDisposition::NEW_FOREGROUND_TAB:\n        disposition = \"foreground-tab\";\n        break;\n      case WindowOpenDisposition::NEW_BACKGROUND_TAB:\n        disposition = \"background-tab\";\n        break;\n      case WindowOpenDisposition::NEW_POPUP:\n      case WindowOpenDisposition::NEW_WINDOW:\n        disposition = \"new-window\";\n        break;\n      case WindowOpenDisposition::SAVE_TO_DISK:\n        disposition = \"save-to-disk\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, disposition);\n  }\n};\n\ntemplate <>\nstruct Converter<content::SavePageType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     content::SavePageType* out) {\n    std::string save_type;\n    if (!ConvertFromV8(isolate, val, &save_type))\n      return false;\n    save_type = base::ToLowerASCII(save_type);\n    if (save_type == \"htmlonly\") {\n      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;\n    } else if (save_type == \"htmlcomplete\") {\n      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;\n    } else if (save_type == \"mhtml\") {\n      *out = content::SAVE_PAGE_TYPE_AS_MHTML;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<electron::api::WebContents::Type> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   electron::api::WebContents::Type val) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    switch (val) {\n      case Type::kBackgroundPage:\n        type = \"backgroundPage\";\n        break;\n      case Type::kBrowserWindow:\n        type = \"window\";\n        break;\n      case Type::kBrowserView:\n        type = \"browserView\";\n        break;\n      case Type::kRemote:\n        type = \"remote\";\n        break;\n      case Type::kWebView:\n        type = \"webview\";\n        break;\n      case Type::kOffScreen:\n        type = \"offscreen\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, type);\n  }\n\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     electron::api::WebContents::Type* out) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    if (!ConvertFromV8(isolate, val, &type))\n      return false;\n    if (type == \"backgroundPage\") {\n      *out = Type::kBackgroundPage;\n    } else if (type == \"browserView\") {\n      *out = Type::kBrowserView;\n    } else if (type == \"webview\") {\n      *out = Type::kWebView;\n#if BUILDFLAG(ENABLE_OSR)\n    } else if (type == \"offscreen\") {\n      *out = Type::kOffScreen;\n#endif\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<scoped_refptr<content::DevToolsAgentHost>> {\n  static v8::Local<v8::Value> ToV8(\n      v8::Isolate* isolate,\n      const scoped_refptr<content::DevToolsAgentHost>& val) {\n    gin_helper::Dictionary dict(isolate, v8::Object::New(isolate));\n    dict.Set(\"id\", val->GetId());\n    dict.Set(\"url\", val->GetURL().spec());\n    return dict.GetHandle();\n  }\n};\n\n}  // namespace gin\n\nnamespace electron {\n\nnamespace api {\n\nnamespace {\n\nbase::IDMap<WebContents*>& GetAllWebContents() {\n  static base::NoDestructor<base::IDMap<WebContents*>> s_all_web_contents;\n  return *s_all_web_contents;\n}\n\n// Called when CapturePage is done.\nvoid OnCapturePageDone(gin_helper::Promise<gfx::Image> promise,\n                       const SkBitmap& bitmap) {\n  // Hack to enable transparency in captured image\n  promise.Resolve(gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nbase::Optional<base::TimeDelta> GetCursorBlinkInterval() {\n#if defined(OS_MAC)\n  base::TimeDelta interval;\n  if (ui::TextInsertionCaretBlinkPeriod(&interval))\n    return interval;\n#elif defined(OS_LINUX)\n  if (auto* linux_ui = views::LinuxUI::instance())\n    return linux_ui->GetCursorBlinkInterval();\n#elif defined(OS_WIN)\n  const auto system_msec = ::GetCaretBlinkTime();\n  if (system_msec != 0) {\n    return (system_msec == INFINITE)\n               ? base::TimeDelta()\n               : base::TimeDelta::FromMilliseconds(system_msec);\n  }\n#endif\n  return base::nullopt;\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\n// This will return false if no printer with the provided device_name can be\n// found on the network. We need to check this because Chromium does not do\n// sanity checking of device_name validity and so will crash on invalid names.\nbool IsDeviceNameValid(const base::string16& device_name) {\n#if defined(OS_MAC)\n  base::ScopedCFTypeRef<CFStringRef> new_printer_id(\n      base::SysUTF16ToCFStringRef(device_name));\n  PMPrinter new_printer = PMPrinterCreateFromPrinterID(new_printer_id.get());\n  bool printer_exists = new_printer != nullptr;\n  PMRelease(new_printer);\n  return printer_exists;\n#elif defined(OS_WIN)\n  printing::ScopedPrinterHandle printer;\n  return printer.OpenPrinterWithName(device_name.c_str());\n#endif\n  return true;\n}\n\nbase::string16 GetDefaultPrinterAsync() {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n\n  scoped_refptr<printing::PrintBackend> print_backend =\n      printing::PrintBackend::CreateInstance(\n          g_browser_process->GetApplicationLocale());\n  std::string printer_name = print_backend->GetDefaultPrinterName();\n\n  // Some devices won't have a default printer, so we should\n  // also check for existing printers and pick the first\n  // one should it exist.\n  if (printer_name.empty()) {\n    printing::PrinterList printers;\n    print_backend->EnumeratePrinters(&printers);\n    if (!printers.empty())\n      printer_name = printers.front().printer_name;\n  }\n  return base::UTF8ToUTF16(printer_name);\n}\n#endif\n\nstruct UserDataLink : public base::SupportsUserData::Data {\n  explicit UserDataLink(base::WeakPtr<WebContents> contents)\n      : web_contents(contents) {}\n\n  base::WeakPtr<WebContents> web_contents;\n};\nconst void* kElectronApiWebContentsKey = &kElectronApiWebContentsKey;\n\nconst char kRootName[] = \"<root>\";\n\nstruct FileSystem {\n  FileSystem() = default;\n  FileSystem(const std::string& type,\n             const std::string& file_system_name,\n             const std::string& root_url,\n             const std::string& file_system_path)\n      : type(type),\n        file_system_name(file_system_name),\n        root_url(root_url),\n        file_system_path(file_system_path) {}\n\n  std::string type;\n  std::string file_system_name;\n  std::string root_url;\n  std::string file_system_path;\n};\n\nstd::string RegisterFileSystem(content::WebContents* web_contents,\n                               const base::FilePath& path) {\n  auto* isolated_context = storage::IsolatedContext::GetInstance();\n  std::string root_name(kRootName);\n  storage::IsolatedContext::ScopedFSHandle file_system =\n      isolated_context->RegisterFileSystemForPath(\n          storage::kFileSystemTypeNativeLocal, std::string(), path, &root_name);\n\n  content::ChildProcessSecurityPolicy* policy =\n      content::ChildProcessSecurityPolicy::GetInstance();\n  content::RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  int renderer_id = render_view_host->GetProcess()->GetID();\n  policy->GrantReadFileSystem(renderer_id, file_system.id());\n  policy->GrantWriteFileSystem(renderer_id, file_system.id());\n  policy->GrantCreateFileForFileSystem(renderer_id, file_system.id());\n  policy->GrantDeleteFromFileSystem(renderer_id, file_system.id());\n\n  if (!policy->CanReadFile(renderer_id, path))\n    policy->GrantReadFile(renderer_id, path);\n\n  return file_system.id();\n}\n\nFileSystem CreateFileSystemStruct(content::WebContents* web_contents,\n                                  const std::string& file_system_id,\n                                  const std::string& file_system_path,\n                                  const std::string& type) {\n  const GURL origin = web_contents->GetURL().GetOrigin();\n  std::string file_system_name =\n      storage::GetIsolatedFileSystemName(origin, file_system_id);\n  std::string root_url = storage::GetIsolatedFileSystemRootURIString(\n      origin, file_system_id, kRootName);\n  return FileSystem(type, file_system_name, root_url, file_system_path);\n}\n\nstd::unique_ptr<base::DictionaryValue> CreateFileSystemValue(\n    const FileSystem& file_system) {\n  std::unique_ptr<base::DictionaryValue> file_system_value(\n      new base::DictionaryValue());\n  file_system_value->SetString(\"type\", file_system.type);\n  file_system_value->SetString(\"fileSystemName\", file_system.file_system_name);\n  file_system_value->SetString(\"rootURL\", file_system.root_url);\n  file_system_value->SetString(\"fileSystemPath\", file_system.file_system_path);\n  return file_system_value;\n}\n\nvoid WriteToFile(const base::FilePath& path, const std::string& content) {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::WILL_BLOCK);\n  DCHECK(!path.empty());\n\n  base::WriteFile(path, content.data(), content.size());\n}\n\nvoid AppendToFile(const base::FilePath& path, const std::string& content) {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::WILL_BLOCK);\n  DCHECK(!path.empty());\n\n  base::AppendToFile(path, content.data(), content.size());\n}\n\nPrefService* GetPrefService(content::WebContents* web_contents) {\n  auto* context = web_contents->GetBrowserContext();\n  return static_cast<electron::ElectronBrowserContext*>(context)->prefs();\n}\n\nstd::map<std::string, std::string> GetAddedFileSystemPaths(\n    content::WebContents* web_contents) {\n  auto* pref_service = GetPrefService(web_contents);\n  const base::DictionaryValue* file_system_paths_value =\n      pref_service->GetDictionary(prefs::kDevToolsFileSystemPaths);\n  std::map<std::string, std::string> result;\n  if (file_system_paths_value) {\n    base::DictionaryValue::Iterator it(*file_system_paths_value);\n    for (; !it.IsAtEnd(); it.Advance()) {\n      std::string type =\n          it.value().is_string() ? it.value().GetString() : std::string();\n      result[it.key()] = type;\n    }\n  }\n  return result;\n}\n\nbool IsDevToolsFileSystemAdded(content::WebContents* web_contents,\n                               const std::string& file_system_path) {\n  auto file_system_paths = GetAddedFileSystemPaths(web_contents);\n  return file_system_paths.find(file_system_path) != file_system_paths.end();\n}\n\n}  // namespace\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n\nWebContents::Type GetTypeFromViewType(extensions::ViewType view_type) {\n  switch (view_type) {\n    case extensions::VIEW_TYPE_EXTENSION_BACKGROUND_PAGE:\n      return WebContents::Type::kBackgroundPage;\n\n    case extensions::VIEW_TYPE_APP_WINDOW:\n    case extensions::VIEW_TYPE_COMPONENT:\n    case extensions::VIEW_TYPE_EXTENSION_DIALOG:\n    case extensions::VIEW_TYPE_EXTENSION_POPUP:\n    case extensions::VIEW_TYPE_BACKGROUND_CONTENTS:\n    case extensions::VIEW_TYPE_EXTENSION_GUEST:\n    case extensions::VIEW_TYPE_TAB_CONTENTS:\n    case extensions::VIEW_TYPE_INVALID:\n      return WebContents::Type::kRemote;\n  }\n}\n\n#endif\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         content::WebContents* web_contents)\n    : content::WebContentsObserver(web_contents),\n      type_(Type::kRemote),\n      id_(GetAllWebContents().Add(this)),\n      devtools_file_system_indexer_(new DevToolsFileSystemIndexer),\n      file_task_runner_(\n          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()})),\n      weak_factory_(this) {\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  // WebContents created by extension host will have valid ViewType set.\n  extensions::ViewType view_type = extensions::GetViewType(web_contents);\n  if (view_type != extensions::VIEW_TYPE_INVALID) {\n    InitWithExtensionView(isolate, web_contents, view_type);\n  }\n\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents);\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents));\n#endif\n\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n\n  web_contents->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                         GetBrowserContext()->GetUserAgent()),\n                                     false);\n  web_contents->SetUserData(kElectronApiWebContentsKey,\n                            std::make_unique<UserDataLink>(GetWeakPtr()));\n  InitZoomController(web_contents, gin::Dictionary::CreateEmpty(isolate));\n\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         std::unique_ptr<content::WebContents> web_contents,\n                         Type type)\n    : content::WebContentsObserver(web_contents.get()),\n      type_(type),\n      id_(GetAllWebContents().Add(this)),\n      devtools_file_system_indexer_(new DevToolsFileSystemIndexer),\n      file_task_runner_(\n          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()})),\n      weak_factory_(this) {\n  DCHECK(type != Type::kRemote)\n      << \"Can't take ownership of a remote WebContents\";\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session,\n                            gin::Dictionary::CreateEmpty(isolate));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         const gin_helper::Dictionary& options)\n    : id_(GetAllWebContents().Add(this)),\n      devtools_file_system_indexer_(new DevToolsFileSystemIndexer),\n      file_task_runner_(\n          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()})),\n      weak_factory_(this) {\n  // Read options.\n  options.Get(\"backgroundThrottling\", &background_throttling_);\n\n  // Get type\n  options.Get(\"type\", &type_);\n\n#if BUILDFLAG(ENABLE_OSR)\n  bool b = false;\n  if (options.Get(options::kOffscreen, &b) && b)\n    type_ = Type::kOffScreen;\n#endif\n\n  // Init embedder earlier\n  options.Get(\"embedder\", &embedder_);\n\n  // Whether to enable DevTools.\n  options.Get(\"devTools\", &enable_devtools_);\n\n  // BrowserViews are not attached to a window initially so they should start\n  // off as hidden. This is also important for compositor recycling. See:\n  // https://github.com/electron/electron/pull/21372\n  initially_shown_ = type_ != Type::kBrowserView;\n  options.Get(options::kShow, &initially_shown_);\n\n  // Obtain the session.\n  std::string partition;\n  gin::Handle<api::Session> session;\n  if (options.Get(\"session\", &session) && !session.IsEmpty()) {\n  } else if (options.Get(\"partition\", &partition)) {\n    session = Session::FromPartition(isolate, partition);\n  } else {\n    // Use the default session if not specified.\n    session = Session::FromPartition(isolate, \"\");\n  }\n  session_.Reset(isolate, session.ToV8());\n\n  std::unique_ptr<content::WebContents> web_contents;\n  if (IsGuest()) {\n    scoped_refptr<content::SiteInstance> site_instance =\n        content::SiteInstance::CreateForURL(session->browser_context(),\n                                            GURL(\"chrome-guest://fake-host\"));\n    content::WebContents::CreateParams params(session->browser_context(),\n                                              site_instance);\n    guest_delegate_ =\n        std::make_unique<WebViewGuestDelegate>(embedder_->web_contents(), this);\n    params.guest_delegate = guest_delegate_.get();\n\n#if BUILDFLAG(ENABLE_OSR)\n    if (embedder_ && embedder_->IsOffScreen()) {\n      auto* view = new OffScreenWebContentsView(\n          false,\n          base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n      params.view = view;\n      params.delegate_view = view;\n\n      web_contents = content::WebContents::Create(params);\n      view->SetWebContents(web_contents.get());\n    } else {\n#endif\n      web_contents = content::WebContents::Create(params);\n#if BUILDFLAG(ENABLE_OSR)\n    }\n  } else if (IsOffScreen()) {\n    bool transparent = false;\n    options.Get(\"transparent\", &transparent);\n\n    content::WebContents::CreateParams params(session->browser_context());\n    auto* view = new OffScreenWebContentsView(\n        transparent,\n        base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n    params.view = view;\n    params.delegate_view = view;\n\n    web_contents = content::WebContents::Create(params);\n    view->SetWebContents(web_contents.get());\n#endif\n  } else {\n    content::WebContents::CreateParams params(session->browser_context());\n    params.initially_hidden = !initially_shown_;\n    web_contents = content::WebContents::Create(params);\n  }\n\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session, options);\n}\n\nvoid WebContents::InitZoomController(content::WebContents* web_contents,\n                                     const gin_helper::Dictionary& options) {\n  WebContentsZoomController::CreateForWebContents(web_contents);\n  zoom_controller_ = WebContentsZoomController::FromWebContents(web_contents);\n  double zoom_factor;\n  if (options.Get(options::kZoomFactor, &zoom_factor))\n    zoom_controller_->SetDefaultZoomFactor(zoom_factor);\n}\n\nvoid WebContents::InitWithSessionAndOptions(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> owned_web_contents,\n    gin::Handle<api::Session> session,\n    const gin_helper::Dictionary& options) {\n  Observe(owned_web_contents.get());\n  // TODO(zcbenz): Make InitWithWebContents take unique_ptr.\n  // At the time of writing we are going through a refactoring and I don't want\n  // to make other people's work harder.\n  InitWithWebContents(owned_web_contents.release(), session->browser_context(),\n                      IsGuest());\n\n  inspectable_web_contents_->GetView()->SetDelegate(this);\n\n  auto* prefs = web_contents()->GetMutableRendererPrefs();\n\n  // Collect preferred languages from OS and browser process. accept_languages\n  // effects HTTP header, navigator.languages, and CJK fallback font selection.\n  //\n  // Note that an application locale set to the browser process might be\n  // different with the one set to the preference list.\n  // (e.g. overridden with --lang)\n  std::string accept_languages =\n      g_browser_process->GetApplicationLocale() + \",\";\n  for (auto const& language : electron::GetPreferredLanguages()) {\n    if (language == g_browser_process->GetApplicationLocale())\n      continue;\n    accept_languages += language + \",\";\n  }\n  accept_languages.pop_back();\n  prefs->accept_languages = accept_languages;\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n  // Update font settings.\n  static const base::NoDestructor<gfx::FontRenderParams> params(\n      gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr));\n  prefs->should_antialias_text = params->antialiasing;\n  prefs->use_subpixel_positioning = params->subpixel_positioning;\n  prefs->hinting = params->hinting;\n  prefs->use_autohinter = params->autohinter;\n  prefs->use_bitmaps = params->use_bitmaps;\n  prefs->subpixel_rendering = params->subpixel_rendering;\n#endif\n\n  // Honor the system's cursor blink rate settings\n  if (auto interval = GetCursorBlinkInterval())\n    prefs->caret_blink_interval = *interval;\n\n  // Save the preferences in C++.\n  // If there's already a WebContentsPreferences object, we created it as part\n  // of the webContents.setWindowOpenHandler path, so don't overwrite it.\n  if (!WebContentsPreferences::From(web_contents())) {\n    new WebContentsPreferences(web_contents(), options);\n  }\n  // Trigger re-calculation of webkit prefs.\n  web_contents()->NotifyPreferencesChanged();\n\n  WebContentsPermissionHelper::CreateForWebContents(web_contents());\n  SecurityStateTabHelper::CreateForWebContents(web_contents());\n  InitZoomController(web_contents(), options);\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents());\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents()));\n#endif\n\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n  AutofillDriverFactory::CreateForWebContents(web_contents());\n\n  web_contents()->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                           GetBrowserContext()->GetUserAgent()),\n                                       false);\n\n  if (IsGuest()) {\n    NativeWindow* owner_window = nullptr;\n    if (embedder_) {\n      // New WebContents's owner_window is the embedder's owner_window.\n      auto* relay =\n          NativeWindowRelay::FromWebContents(embedder_->web_contents());\n      if (relay)\n        owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n  }\n\n  web_contents()->SetUserData(kElectronApiWebContentsKey,\n                              std::make_unique<UserDataLink>(GetWeakPtr()));\n}\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\nvoid WebContents::InitWithExtensionView(v8::Isolate* isolate,\n                                        content::WebContents* web_contents,\n                                        extensions::ViewType view_type) {\n  // Must reassign type prior to calling `Init`.\n  type_ = GetTypeFromViewType(view_type);\n  if (GetType() == Type::kRemote)\n    return;\n\n  // Allow toggling DevTools for background pages\n  Observe(web_contents);\n  InitWithWebContents(web_contents, GetBrowserContext(), IsGuest());\n  inspectable_web_contents_->GetView()->SetDelegate(this);\n  SecurityStateTabHelper::CreateForWebContents(web_contents);\n}\n#endif\n\nvoid WebContents::InitWithWebContents(content::WebContents* web_contents,\n                                      ElectronBrowserContext* browser_context,\n                                      bool is_guest) {\n  browser_context_ = browser_context;\n  web_contents->SetDelegate(this);\n\n#if BUILDFLAG(ENABLE_PRINTING)\n  PrintPreviewMessageHandler::CreateForWebContents(web_contents);\n  printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n  printing::CreateCompositeClientIfNeeded(web_contents,\n                                          browser_context->GetUserAgent());\n#endif\n\n#if BUILDFLAG(ENABLE_PDF_VIEWER)\n  pdf::PDFWebContentsHelper::CreateForWebContentsWithClient(\n      web_contents, std::make_unique<ElectronPDFWebContentsHelperClient>());\n#endif\n\n  // Determine whether the WebContents is offscreen.\n  auto* web_preferences = WebContentsPreferences::From(web_contents);\n  offscreen_ =\n      web_preferences && web_preferences->IsEnabled(options::kOffscreen);\n\n  // Create InspectableWebContents.\n  inspectable_web_contents_.reset(new InspectableWebContents(\n      web_contents, browser_context->prefs(), is_guest));\n  inspectable_web_contents_->SetDelegate(this);\n}\n\nWebContents::~WebContents() {\n  MarkDestroyed();\n  // The destroy() is called.\n  if (inspectable_web_contents_) {\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n    if (type_ == Type::kBackgroundPage) {\n      // Background pages are owned by extensions::ExtensionHost\n      inspectable_web_contents_->ReleaseWebContents();\n    }\n#endif\n\n    inspectable_web_contents_->GetView()->SetDelegate(nullptr);\n\n    if (web_contents()) {\n      RenderViewDeleted(web_contents()->GetRenderViewHost());\n    }\n\n    if (type_ == Type::kBrowserWindow && owner_window()) {\n      // For BrowserWindow we should close the window and clean up everything\n      // before WebContents is destroyed.\n      for (ExtendedWebContentsObserver& observer : observers_)\n        observer.OnCloseContents();\n      // BrowserWindow destroys WebContents asynchronously, manually emit the\n      // destroyed event here.\n      WebContentsDestroyed();\n    } else if (Browser::Get()->is_shutting_down()) {\n      // Destroy WebContents directly when app is shutting down.\n      DestroyWebContents(false /* async */);\n    } else {\n      // Destroy WebContents asynchronously unless app is shutting down,\n      // because destroy() might be called inside WebContents's event handler.\n      bool is_browser_view = type_ == Type::kBrowserView;\n      DestroyWebContents(!(IsGuest() || is_browser_view) /* async */);\n      // The WebContentsDestroyed will not be called automatically because we\n      // destroy the webContents in the next tick. So we have to manually\n      // call it here to make sure \"destroyed\" event is emitted.\n      WebContentsDestroyed();\n    }\n  }\n}\n\nvoid WebContents::DestroyWebContents(bool async) {\n  // This event is only for internal use, which is emitted when WebContents is\n  // being destroyed.\n  Emit(\"will-destroy\");\n  ResetManagedWebContents(async);\n}\n\nbool WebContents::DidAddMessageToConsole(\n    content::WebContents* source,\n    blink::mojom::ConsoleMessageLevel level,\n    const base::string16& message,\n    int32_t line_no,\n    const base::string16& source_id) {\n  return Emit(\"console-message\", static_cast<int32_t>(level), message, line_no,\n              source_id);\n}\n\nvoid WebContents::OnCreateWindow(\n    const GURL& target_url,\n    const content::Referrer& referrer,\n    const std::string& frame_name,\n    WindowOpenDisposition disposition,\n    const std::string& features,\n    const scoped_refptr<network::ResourceRequestBody>& body) {\n  Emit(\"-new-window\", target_url, frame_name, disposition, features, referrer,\n       body);\n}\n\nvoid WebContents::WebContentsCreatedWithFullParams(\n    content::WebContents* source_contents,\n    int opener_render_process_id,\n    int opener_render_frame_id,\n    const content::mojom::CreateNewWindowParams& params,\n    content::WebContents* new_contents) {\n  ChildWebContentsTracker::CreateForWebContents(new_contents);\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents);\n  tracker->url = params.target_url;\n  tracker->frame_name = params.frame_name;\n  tracker->referrer = params.referrer.To<content::Referrer>();\n  tracker->raw_features = params.raw_features;\n  tracker->body = params.body;\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n\n  gin_helper::Dictionary dict;\n  gin::ConvertFromV8(isolate, pending_child_web_preferences_.Get(isolate),\n                     &dict);\n  pending_child_web_preferences_.Reset();\n\n  // Associate the preferences passed in via `setWindowOpenHandler` with the\n  // content::WebContents that was just created for the child window. These\n  // preferences will be picked up by the RenderWidgetHost via its call to the\n  // delegate's OverrideWebkitPrefs.\n  new WebContentsPreferences(new_contents, dict);\n}\n\nbool WebContents::IsWebContentsCreationOverridden(\n    content::SiteInstance* source_site_instance,\n    content::mojom::WindowContainerType window_container_type,\n    const GURL& opener_url,\n    const content::mojom::CreateNewWindowParams& params) {\n  bool default_prevented = Emit(\"-will-add-new-contents\", params.target_url,\n                                params.frame_name, params.raw_features);\n  // If the app prevented the default, redirect to CreateCustomWebContents,\n  // which always returns nullptr, which will result in the window open being\n  // prevented (window.open() will return null in the renderer).\n  return default_prevented;\n}\n\nvoid WebContents::SetNextChildWebPreferences(\n    const gin_helper::Dictionary preferences) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  // Store these prefs for when Chrome calls WebContentsCreatedWithFullParams\n  // with the new child contents.\n  pending_child_web_preferences_.Reset(isolate, preferences.GetHandle());\n}\n\ncontent::WebContents* WebContents::CreateCustomWebContents(\n    content::RenderFrameHost* opener,\n    content::SiteInstance* source_site_instance,\n    bool is_new_browsing_instance,\n    const GURL& opener_url,\n    const std::string& frame_name,\n    const GURL& target_url,\n    const std::string& partition_id,\n    content::SessionStorageNamespace* session_storage_namespace) {\n  return nullptr;\n}\n\nvoid WebContents::AddNewContents(\n    content::WebContents* source,\n    std::unique_ptr<content::WebContents> new_contents,\n    const GURL& target_url,\n    WindowOpenDisposition disposition,\n    const gfx::Rect& initial_rect,\n    bool user_gesture,\n    bool* was_blocked) {\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents.get());\n  DCHECK(tracker);\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  auto api_web_contents =\n      CreateAndTake(isolate, std::move(new_contents), Type::kBrowserWindow);\n  if (Emit(\"-add-new-contents\", api_web_contents, disposition, user_gesture,\n           initial_rect.x(), initial_rect.y(), initial_rect.width(),\n           initial_rect.height(), tracker->url, tracker->frame_name,\n           tracker->referrer, tracker->raw_features, tracker->body)) {\n    api_web_contents->DestroyWebContents(false /* async */);\n  }\n}\n\ncontent::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  auto weak_this = GetWeakPtr();\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n\n  if (!weak_this)\n    return nullptr;\n\n  content::NavigationController::LoadURLParams load_url_params(params.url);\n  load_url_params.referrer = params.referrer;\n  load_url_params.transition_type = params.transition;\n  load_url_params.extra_headers = params.extra_headers;\n  load_url_params.should_replace_current_entry =\n      params.should_replace_current_entry;\n  load_url_params.is_renderer_initiated = params.is_renderer_initiated;\n  load_url_params.started_from_context_menu = params.started_from_context_menu;\n  load_url_params.initiator_origin = params.initiator_origin;\n  load_url_params.source_site_instance = params.source_site_instance;\n  load_url_params.frame_tree_node_id = params.frame_tree_node_id;\n  load_url_params.redirect_chain = params.redirect_chain;\n  load_url_params.has_user_gesture = params.user_gesture;\n  load_url_params.blob_url_loader_factory = params.blob_url_loader_factory;\n  load_url_params.href_translate = params.href_translate;\n  load_url_params.reload_type = params.reload_type;\n\n  if (params.post_data) {\n    load_url_params.load_type =\n        content::NavigationController::LOAD_TYPE_HTTP_POST;\n    load_url_params.post_data = params.post_data;\n  }\n\n  source->GetController().LoadURLWithParams(load_url_params);\n  return source;\n}\n\nvoid WebContents::BeforeUnloadFired(content::WebContents* tab,\n                                    bool proceed,\n                                    bool* proceed_to_fire_unload) {\n  if (type_ == Type::kBrowserWindow || type_ == Type::kOffScreen)\n    *proceed_to_fire_unload = proceed;\n  else\n    *proceed_to_fire_unload = true;\n  // Note that Chromium does not emit this for navigations.\n  Emit(\"before-unload-fired\", proceed);\n}\n\nvoid WebContents::SetContentsBounds(content::WebContents* source,\n                                    const gfx::Rect& rect) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnSetContentBounds(rect);\n}\n\nvoid WebContents::CloseContents(content::WebContents* source) {\n  Emit(\"close\");\n\n  auto* autofill_driver_factory =\n      AutofillDriverFactory::FromWebContents(web_contents());\n  if (autofill_driver_factory) {\n    autofill_driver_factory->CloseAllPopups();\n  }\n\n  if (inspectable_web_contents_)\n    inspectable_web_contents_->GetView()->SetDelegate(nullptr);\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnCloseContents();\n}\n\nvoid WebContents::ActivateContents(content::WebContents* source) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnActivateContents();\n}\n\nvoid WebContents::UpdateTargetURL(content::WebContents* source,\n                                  const GURL& url) {\n  Emit(\"update-target-url\", url);\n}\n\nbool WebContents::HandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (type_ == Type::kWebView && embedder_) {\n    // Send the unhandled keyboard events back to the embedder.\n    return embedder_->HandleKeyboardEvent(source, event);\n  } else {\n    return PlatformHandleKeyboardEvent(source, event);\n  }\n}\n\n#if !defined(OS_MAC)\n// NOTE: The macOS version of this function is found in\n// electron_api_web_contents_mac.mm, as it requires calling into objective-C\n// code.\nbool WebContents::PlatformHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  // Escape exits tabbed fullscreen mode.\n  if (event.windows_key_code == ui::VKEY_ESCAPE && is_html_fullscreen()) {\n    ExitFullscreenModeForTab(source);\n    return true;\n  }\n\n  // Check if the webContents has preferences and to ignore shortcuts\n  auto* web_preferences = WebContentsPreferences::From(source);\n  if (web_preferences &&\n      web_preferences->IsEnabled(\"ignoreMenuShortcuts\", false))\n    return false;\n\n  // Let the NativeWindow handle other parts.\n  if (owner_window()) {\n    owner_window()->HandleKeyboardEvent(source, event);\n    return true;\n  }\n\n  return false;\n}\n#endif\n\ncontent::KeyboardEventProcessingResult WebContents::PreHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (event.GetType() == blink::WebInputEvent::Type::kRawKeyDown ||\n      event.GetType() == blink::WebInputEvent::Type::kKeyUp) {\n    bool prevent_default = Emit(\"before-input-event\", event);\n    if (prevent_default) {\n      return content::KeyboardEventProcessingResult::HANDLED;\n    }\n  }\n\n  return content::KeyboardEventProcessingResult::NOT_HANDLED;\n}\n\nvoid WebContents::ContentsZoomChange(bool zoom_in) {\n  Emit(\"zoom-changed\", zoom_in ? \"in\" : \"out\");\n}\n\nvoid WebContents::EnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options) {\n  auto* source = content::WebContents::FromRenderFrameHost(requesting_frame);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(source);\n  auto callback =\n      base::BindRepeating(&WebContents::OnEnterFullscreenModeForTab,\n                          base::Unretained(this), requesting_frame, options);\n  permission_helper->RequestFullscreenPermission(callback);\n}\n\nvoid WebContents::OnEnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options,\n    bool allowed) {\n  if (!allowed)\n    return;\n  if (!owner_window_)\n    return;\n  auto* source = content::WebContents::FromRenderFrameHost(requesting_frame);\n  if (IsFullscreenForTabOrPending(source)) {\n    DCHECK_EQ(fullscreen_frame_, source->GetFocusedFrame());\n    return;\n  }\n  SetHtmlApiFullscreen(true);\n  owner_window_->NotifyWindowEnterHtmlFullScreen();\n\n  if (native_fullscreen_) {\n    // Explicitly trigger a view resize, as the size is not actually changing if\n    // the browser is fullscreened, too.\n    source->GetRenderViewHost()->GetWidget()->SynchronizeVisualProperties();\n  }\n  Emit(\"enter-html-full-screen\");\n}\n\nvoid WebContents::ExitFullscreenModeForTab(content::WebContents* source) {\n  if (!owner_window_)\n    return;\n  SetHtmlApiFullscreen(false);\n  owner_window_->NotifyWindowLeaveHtmlFullScreen();\n\n  if (native_fullscreen_) {\n    // Explicitly trigger a view resize, as the size is not actually changing if\n    // the browser is fullscreened, too. Chrome does this indirectly from\n    // `chrome/browser/ui/exclusive_access/fullscreen_controller.cc`.\n    source->GetRenderViewHost()->GetWidget()->SynchronizeVisualProperties();\n  }\n  Emit(\"leave-html-full-screen\");\n}\n\nvoid WebContents::RendererUnresponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host,\n    base::RepeatingClosure hang_monitor_restarter) {\n  Emit(\"unresponsive\");\n}\n\nvoid WebContents::RendererResponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host) {\n  Emit(\"responsive\");\n}\n\nbool WebContents::HandleContextMenu(content::RenderFrameHost* render_frame_host,\n                                    const content::ContextMenuParams& params) {\n  if (params.custom_context.is_pepper_menu) {\n    Emit(\"pepper-context-menu\", std::make_pair(params, web_contents()),\n         base::BindOnce(&content::WebContents::NotifyContextMenuClosed,\n                        base::Unretained(web_contents()),\n                        params.custom_context));\n  } else {\n    Emit(\"context-menu\", std::make_pair(params, web_contents()));\n  }\n\n  return true;\n}\n\nbool WebContents::OnGoToEntryOffset(int offset) {\n  GoToOffset(offset);\n  return false;\n}\n\nvoid WebContents::FindReply(content::WebContents* web_contents,\n                            int request_id,\n                            int number_of_matches,\n                            const gfx::Rect& selection_rect,\n                            int active_match_ordinal,\n                            bool final_update) {\n  if (!final_update)\n    return;\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  gin_helper::Dictionary result = gin::Dictionary::CreateEmpty(isolate);\n  result.Set(\"requestId\", request_id);\n  result.Set(\"matches\", number_of_matches);\n  result.Set(\"selectionArea\", selection_rect);\n  result.Set(\"activeMatchOrdinal\", active_match_ordinal);\n  result.Set(\"finalUpdate\", final_update);  // Deprecate after 2.0\n  Emit(\"found-in-page\", result.GetHandle());\n}\n\nbool WebContents::CheckMediaAccessPermission(\n    content::RenderFrameHost* render_frame_host,\n    const GURL& security_origin,\n    blink::mojom::MediaStreamType type) {\n  auto* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  return permission_helper->CheckMediaAccessPermission(security_origin, type);\n}\n\nvoid WebContents::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    content::MediaResponseCallback callback) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestMediaAccessPermission(request, std::move(callback));\n}\n\nvoid WebContents::RequestToLockMouse(content::WebContents* web_contents,\n                                     bool user_gesture,\n                                     bool last_unlocked_by_target) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestPointerLockPermission(user_gesture);\n}\n\ncontent::JavaScriptDialogManager* WebContents::GetJavaScriptDialogManager(\n    content::WebContents* source) {\n  if (!dialog_manager_)\n    dialog_manager_ = std::make_unique<ElectronJavaScriptDialogManager>();\n\n  return dialog_manager_.get();\n}\n\nvoid WebContents::OnAudioStateChanged(bool audible) {\n  Emit(\"-audio-state-changed\", audible);\n}\n\nvoid WebContents::BeforeUnloadFired(bool proceed,\n                                    const base::TimeTicks& proceed_time) {\n  // Do nothing, we override this method just to avoid compilation error since\n  // there are two virtual functions named BeforeUnloadFired.\n}\n\nvoid WebContents::RenderViewCreated(content::RenderViewHost* render_view_host) {\n  if (!background_throttling_)\n    render_view_host->SetSchedulerThrottling(false);\n}\n\nvoid WebContents::RenderFrameCreated(\n    content::RenderFrameHost* render_frame_host) {\n  auto* rwhv = render_frame_host->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (rwh_impl)\n    rwh_impl->disable_hidden_ = !background_throttling_;\n}\n\nvoid WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {\n  // This event is necessary for tracking any states with respect to\n  // intermediate render view hosts aka speculative render view hosts. Currently\n  // used by object-registry.js to ref count remote objects.\n  Emit(\"render-view-deleted\", render_view_host->GetProcess()->GetID());\n\n  if (web_contents()->GetRenderViewHost() == render_view_host) {\n    // When the RVH that has been deleted is the current RVH it means that the\n    // the web contents are being closed. This is communicated by this event.\n    // Currently tracked by guest-window-manager.ts to destroy the\n    // BrowserWindow.\n    Emit(\"current-render-view-deleted\",\n         render_view_host->GetProcess()->GetID());\n  }\n}\n\nvoid WebContents::RenderProcessGone(base::TerminationStatus status) {\n  Emit(\"crashed\", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  gin_helper::Dictionary details = gin_helper::Dictionary::CreateEmpty(isolate);\n  details.Set(\"reason\", status);\n  Emit(\"render-process-gone\", details);\n}\n\nvoid WebContents::PluginCrashed(const base::FilePath& plugin_path,\n                                base::ProcessId plugin_pid) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  content::WebPluginInfo info;\n  auto* plugin_service = content::PluginService::GetInstance();\n  plugin_service->GetPluginInfoByPath(plugin_path, &info);\n  Emit(\"plugin-crashed\", info.name, info.version);\n#endif  // BUILDFLAG(ENABLE_PLUGINS)\n}\n\nvoid WebContents::MediaStartedPlaying(const MediaPlayerInfo& video_type,\n                                      const content::MediaPlayerId& id) {\n  Emit(\"media-started-playing\");\n}\n\nvoid WebContents::MediaStoppedPlaying(\n    const MediaPlayerInfo& video_type,\n    const content::MediaPlayerId& id,\n    content::WebContentsObserver::MediaStoppedReason reason) {\n  Emit(\"media-paused\");\n}\n\nvoid WebContents::DidChangeThemeColor() {\n  auto theme_color = web_contents()->GetThemeColor();\n  if (theme_color) {\n    Emit(\"did-change-theme-color\", electron::ToRGBHex(theme_color.value()));\n  } else {\n    Emit(\"did-change-theme-color\", nullptr);\n  }\n}\n\nvoid WebContents::OnInterfaceRequestFromFrame(\n    content::RenderFrameHost* render_frame_host,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle* interface_pipe) {\n  registry_.TryBindInterface(interface_name, interface_pipe, render_frame_host);\n}\n\nvoid WebContents::DidAcquireFullscreen(content::RenderFrameHost* rfh) {\n  set_fullscreen_frame(rfh);\n}\n\nvoid WebContents::DOMContentLoaded(\n    content::RenderFrameHost* render_frame_host) {\n  if (!render_frame_host->GetParent())\n    Emit(\"dom-ready\");\n}\n\nvoid WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,\n                                const GURL& validated_url) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  auto weak_this = GetWeakPtr();\n  Emit(\"did-frame-finish-load\", is_main_frame, frame_process_id,\n       frame_routing_id);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // Emit() triggers JS which can call destroy() on |this|. It's not safe to\n  // assume that |this| points to valid memory at this point.\n  if (is_main_frame && weak_this)\n    Emit(\"did-finish-load\");\n}\n\nvoid WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,\n                              const GURL& url,\n                              int error_code) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  Emit(\"did-fail-load\", error_code, \"\", url, is_main_frame, frame_process_id,\n       frame_routing_id);\n}\n\nvoid WebContents::DidStartLoading() {\n  Emit(\"did-start-loading\");\n}\n\nvoid WebContents::DidStopLoading() {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (web_preferences &&\n      web_preferences->IsEnabled(options::kEnablePreferredSizeMode))\n    web_contents()->GetRenderViewHost()->EnablePreferredSizeMode();\n\n  Emit(\"did-stop-loading\");\n}\n\nbool WebContents::EmitNavigationEvent(\n    const std::string& event,\n    content::NavigationHandle* navigation_handle) {\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  int frame_tree_node_id = navigation_handle->GetFrameTreeNodeId();\n  content::FrameTreeNode* frame_tree_node =\n      content::FrameTreeNode::GloballyFindByID(frame_tree_node_id);\n  content::RenderFrameHostManager* render_manager =\n      frame_tree_node->render_manager();\n  content::RenderFrameHost* frame_host = nullptr;\n  if (render_manager) {\n    frame_host = render_manager->speculative_frame_host();\n    if (!frame_host)\n      frame_host = render_manager->current_frame_host();\n  }\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  bool is_same_document = navigation_handle->IsSameDocument();\n  auto url = navigation_handle->GetURL();\n  return Emit(event, url, is_same_document, is_main_frame, frame_process_id,\n              frame_routing_id);\n}\n\nvoid WebContents::BindElectronBrowser(\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver,\n    content::RenderFrameHost* render_frame_host) {\n  auto id = receivers_.Add(this, std::move(receiver), render_frame_host);\n  frame_to_receivers_map_[render_frame_host].push_back(id);\n}\n\nvoid WebContents::OnElectronBrowserConnectionError() {\n  auto receiver_id = receivers_.current_receiver();\n  auto* frame_host = receivers_.current_context();\n  base::Erase(frame_to_receivers_map_[frame_host], receiver_id);\n}\n\nvoid WebContents::Message(bool internal,\n                          const std::string& channel,\n                          blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Message\", \"channel\", channel);\n  // webContents.emit('-ipc-message', new Event(), internal, channel,\n  // arguments);\n  EmitWithSender(\"-ipc-message\", receivers_.current_context(), InvokeCallback(),\n                 internal, channel, std::move(arguments));\n}\n\nvoid WebContents::Invoke(bool internal,\n                         const std::string& channel,\n                         blink::CloneableMessage arguments,\n                         InvokeCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Invoke\", \"channel\", channel);\n  // webContents.emit('-ipc-invoke', new Event(), internal, channel, arguments);\n  EmitWithSender(\"-ipc-invoke\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::OnFirstNonEmptyLayout() {\n  if (receivers_.current_context() == web_contents()->GetMainFrame()) {\n    Emit(\"ready-to-show\");\n  }\n}\n\nvoid WebContents::ReceivePostMessage(const std::string& channel,\n                                     blink::TransferableMessage message) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  auto wrapped_ports =\n      MessagePort::EntanglePorts(isolate, std::move(message.ports));\n  v8::Local<v8::Value> message_value =\n      electron::DeserializeV8Value(isolate, message);\n  EmitWithSender(\"-ipc-ports\", receivers_.current_context(), InvokeCallback(),\n                 false, channel, message_value, std::move(wrapped_ports));\n}\n\nvoid WebContents::PostMessage(const std::string& channel,\n                              v8::Local<v8::Value> message_value,\n                              base::Optional<v8::Local<v8::Value>> transfer) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::TransferableMessage transferable_message;\n  if (!electron::SerializeV8Value(isolate, message_value,\n                                  &transferable_message)) {\n    // SerializeV8Value sets an exception.\n    return;\n  }\n\n  std::vector<gin::Handle<MessagePort>> wrapped_ports;\n  if (transfer) {\n    if (!gin::ConvertFromV8(isolate, *transfer, &wrapped_ports)) {\n      isolate->ThrowException(v8::Exception::Error(\n          gin::StringToV8(isolate, \"Invalid value for transfer\")));\n      return;\n    }\n  }\n\n  bool threw_exception = false;\n  transferable_message.ports =\n      MessagePort::DisentanglePorts(isolate, wrapped_ports, &threw_exception);\n  if (threw_exception)\n    return;\n\n  content::RenderFrameHost* frame_host = web_contents()->GetMainFrame();\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->ReceivePostMessage(channel,\n                                        std::move(transferable_message));\n}\n\nvoid WebContents::MessageSync(bool internal,\n                              const std::string& channel,\n                              blink::CloneableMessage arguments,\n                              MessageSyncCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageSync\", \"channel\", channel);\n  // webContents.emit('-ipc-message-sync', new Event(sender, message), internal,\n  // channel, arguments);\n  EmitWithSender(\"-ipc-message-sync\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::MessageTo(bool internal,\n                            int32_t web_contents_id,\n                            const std::string& channel,\n                            blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageTo\", \"channel\", channel);\n  auto* web_contents = FromID(web_contents_id);\n\n  if (web_contents) {\n    web_contents->SendIPCMessageWithSender(internal, channel,\n                                           std::move(arguments), ID());\n  }\n}\n\nvoid WebContents::MessageHost(const std::string& channel,\n                              blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageHost\", \"channel\", channel);\n  // webContents.emit('ipc-message-host', new Event(), channel, args);\n  EmitWithSender(\"ipc-message-host\", receivers_.current_context(),\n                 InvokeCallback(), channel, std::move(arguments));\n}\n\nvoid WebContents::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnDraggableRegionsUpdated(regions);\n}\n\nvoid WebContents::RenderFrameDeleted(\n    content::RenderFrameHost* render_frame_host) {\n  // A WebFrameMain can outlive its RenderFrameHost so we need to mark it as\n  // disposed to prevent access to it.\n  WebFrameMain::RenderFrameDeleted(render_frame_host);\n\n  // A RenderFrameHost can be destroyed before the related Mojo binding is\n  // closed, which can result in Mojo calls being sent for RenderFrameHosts\n  // that no longer exist. To prevent this from happening, when a\n  // RenderFrameHost goes away, we close all the bindings related to that\n  // frame.\n  auto it = frame_to_receivers_map_.find(render_frame_host);\n  if (it == frame_to_receivers_map_.end())\n    return;\n  for (auto id : it->second)\n    receivers_.Remove(id);\n  frame_to_receivers_map_.erase(it);\n}\n\nvoid WebContents::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-start-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidRedirectNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-redirect-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->HasCommitted())\n    return;\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  content::RenderFrameHost* frame_host =\n      navigation_handle->GetRenderFrameHost();\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  if (!navigation_handle->IsErrorPage()) {\n    // FIXME: All the Emit() calls below could potentially result in |this|\n    // being destroyed (by JS listening for the event and calling\n    // webContents.destroy()).\n    auto url = navigation_handle->GetURL();\n    bool is_same_document = navigation_handle->IsSameDocument();\n    if (is_same_document) {\n      Emit(\"did-navigate-in-page\", url, is_main_frame, frame_process_id,\n           frame_routing_id);\n    } else {\n      const net::HttpResponseHeaders* http_response =\n          navigation_handle->GetResponseHeaders();\n      std::string http_status_text;\n      int http_response_code = -1;\n      if (http_response) {\n        http_status_text = http_response->GetStatusText();\n        http_response_code = http_response->response_code();\n      }\n      Emit(\"did-frame-navigate\", url, http_response_code, http_status_text,\n           is_main_frame, frame_process_id, frame_routing_id);\n      if (is_main_frame) {\n        Emit(\"did-navigate\", url, http_response_code, http_status_text);\n      }\n    }\n    if (IsGuest())\n      Emit(\"load-commit\", url, is_main_frame);\n  } else {\n    auto url = navigation_handle->GetURL();\n    int code = navigation_handle->GetNetErrorCode();\n    auto description = net::ErrorToShortString(code);\n    Emit(\"did-fail-provisional-load\", code, description, url, is_main_frame,\n         frame_process_id, frame_routing_id);\n\n    // Do not emit \"did-fail-load\" for canceled requests.\n    if (code != net::ERR_ABORTED)\n      Emit(\"did-fail-load\", code, description, url, is_main_frame,\n           frame_process_id, frame_routing_id);\n  }\n}\n\nvoid WebContents::TitleWasSet(content::NavigationEntry* entry) {\n  base::string16 final_title;\n  bool explicit_set = true;\n  if (entry) {\n    auto title = entry->GetTitle();\n    auto url = entry->GetURL();\n    if (url.SchemeIsFile() && title.empty()) {\n      final_title = base::UTF8ToUTF16(url.ExtractFileName());\n      explicit_set = false;\n    } else {\n      final_title = title;\n    }\n  }\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnPageTitleUpdated(final_title, explicit_set);\n  Emit(\"page-title-updated\", final_title, explicit_set);\n}\n\nvoid WebContents::DidUpdateFaviconURL(\n    content::RenderFrameHost* render_frame_host,\n    const std::vector<blink::mojom::FaviconURLPtr>& urls) {\n  std::set<GURL> unique_urls;\n  for (const auto& iter : urls) {\n    if (iter->icon_type != blink::mojom::FaviconIconType::kFavicon)\n      continue;\n    const GURL& url = iter->icon_url;\n    if (url.is_valid())\n      unique_urls.insert(url);\n  }\n  Emit(\"page-favicon-updated\", unique_urls);\n}\n\nvoid WebContents::DevToolsReloadPage() {\n  Emit(\"devtools-reload-page\");\n}\n\nvoid WebContents::DevToolsFocused() {\n  Emit(\"devtools-focused\");\n}\n\nvoid WebContents::DevToolsOpened() {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  DCHECK(inspectable_web_contents_);\n  auto handle = FromOrCreate(\n      isolate, inspectable_web_contents_->GetDevToolsWebContents());\n  devtools_web_contents_.Reset(isolate, handle.ToV8());\n\n  // Set inspected tabID.\n  base::Value tab_id(ID());\n  inspectable_web_contents_->CallClientFunction(\"DevToolsAPI.setInspectedTabId\",\n                                                &tab_id, nullptr, nullptr);\n\n  // Inherit owner window in devtools when it doesn't have one.\n  auto* devtools = inspectable_web_contents_->GetDevToolsWebContents();\n  bool has_window = devtools->GetUserData(NativeWindowRelay::UserDataKey());\n  if (owner_window() && !has_window)\n    handle->SetOwnerWindow(devtools, owner_window());\n\n  Emit(\"devtools-opened\");\n}\n\nvoid WebContents::DevToolsClosed() {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  devtools_web_contents_.Reset();\n\n  Emit(\"devtools-closed\");\n}\n\nvoid WebContents::DevToolsResized() {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnDevToolsResized();\n}\n\nbool WebContents::OnMessageReceived(const IPC::Message& message) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(WebContents, message)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  return handled;\n}\n\nvoid WebContents::SetOwnerWindow(NativeWindow* owner_window) {\n  SetOwnerWindow(GetWebContents(), owner_window);\n}\n\nvoid WebContents::SetOwnerWindow(content::WebContents* web_contents,\n                                 NativeWindow* owner_window) {\n  if (owner_window) {\n    owner_window_ = owner_window->GetWeakPtr();\n    NativeWindowRelay::CreateForWebContents(web_contents,\n                                            owner_window->GetWeakPtr());\n  } else {\n    owner_window_ = nullptr;\n    web_contents->RemoveUserData(NativeWindowRelay::UserDataKey());\n  }\n#if BUILDFLAG(ENABLE_OSR)\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetNativeWindow(owner_window);\n#endif\n}\n\nvoid WebContents::ResetManagedWebContents(bool async) {\n  if (async) {\n    // Browser context should be destroyed only after the WebContents,\n    // this is guaranteed in the sync mode by the order of declaration,\n    // in the async version we maintain a reference until the WebContents\n    // is destroyed.\n    // //electron/patches/chromium/content_browser_main_loop.patch\n    // is required to get the right quit closure for the main message loop.\n    base::ThreadTaskRunnerHandle::Get()->DeleteSoon(\n        FROM_HERE, inspectable_web_contents_.release());\n  } else {\n    inspectable_web_contents_.reset();\n  }\n}\n\ncontent::WebContents* WebContents::GetWebContents() const {\n  if (!inspectable_web_contents_)\n    return nullptr;\n  return inspectable_web_contents_->GetWebContents();\n}\n\ncontent::WebContents* WebContents::GetDevToolsWebContents() const {\n  if (!inspectable_web_contents_)\n    return nullptr;\n  return inspectable_web_contents_->GetDevToolsWebContents();\n}\n\nvoid WebContents::MarkDestroyed() {\n  if (GetAllWebContents().Lookup(id_))\n    GetAllWebContents().Remove(id_);\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope scope(isolate);\n  v8::Local<v8::Object> wrapper;\n  if (!GetWrapper(isolate).ToLocal(&wrapper))\n    return;\n  wrapper->SetAlignedPointerInInternalField(0, nullptr);\n}\n\n// There are three ways of destroying a webContents:\n// 1. call webContents.destroy();\n// 2. garbage collection;\n// 3. user closes the window of webContents;\n// 4. the embedder detaches the frame.\n// For webview only #4 will happen, for BrowserWindow both #1 and #3 may\n// happen. The #2 should never happen for webContents, because webview is\n// managed by GuestViewManager, and BrowserWindow's webContents is managed\n// by api::BrowserWindow.\n// For #1, the destructor will do the cleanup work and we only need to make\n// sure \"destroyed\" event is emitted. For #3, the content::WebContents will\n// be destroyed on close, and WebContentsDestroyed would be called for it, so\n// we need to make sure the api::WebContents is also deleted.\n// For #4, the WebContents will be destroyed by embedder.\nvoid WebContents::WebContentsDestroyed() {\n  // Give chance for guest delegate to cleanup its observers\n  // since the native class is only destroyed in the next tick.\n  if (guest_delegate_)\n    guest_delegate_->WillDestroy();\n\n  // Cleanup relationships with other parts.\n\n  // We can not call Destroy here because we need to call Emit first, but we\n  // also do not want any method to be used, so just mark as destroyed here.\n  MarkDestroyed();\n\n  Emit(\"destroyed\");\n\n  // For guest view based on OOPIF, the WebContents is released by the embedder\n  // frame, and we need to clear the reference to the memory.\n  if (IsGuest() && inspectable_web_contents_) {\n    inspectable_web_contents_->ReleaseWebContents();\n    ResetManagedWebContents(false);\n  }\n\n  // Destroy the native class in next tick.\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::BindOnce(\n                     [](base::WeakPtr<WebContents> wc) {\n                       if (wc)\n                         delete wc.get();\n                     },\n                     GetWeakPtr()));\n}\n\nvoid WebContents::NavigationEntryCommitted(\n    const content::LoadCommittedDetails& details) {\n  Emit(\"navigation-entry-committed\", details.entry->GetURL(),\n       details.is_same_document, details.did_replace_entry);\n}\n\nbool WebContents::GetBackgroundThrottling() const {\n  return background_throttling_;\n}\n\nvoid WebContents::SetBackgroundThrottling(bool allowed) {\n  background_throttling_ = allowed;\n\n  auto* rfh = web_contents()->GetMainFrame();\n  if (!rfh)\n    return;\n\n  auto* rwhv = rfh->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (!rwh_impl)\n    return;\n\n  rwh_impl->disable_hidden_ = !background_throttling_;\n  web_contents()->GetRenderViewHost()->SetSchedulerThrottling(allowed);\n\n  if (rwh_impl->is_hidden()) {\n    rwh_impl->WasShown({});\n  }\n}\n\nint WebContents::GetProcessID() const {\n  return web_contents()->GetMainFrame()->GetProcess()->GetID();\n}\n\nbase::ProcessId WebContents::GetOSProcessID() const {\n  base::ProcessHandle process_handle =\n      web_contents()->GetMainFrame()->GetProcess()->GetProcess().Handle();\n  return base::GetProcId(process_handle);\n}\n\nWebContents::Type WebContents::GetType() const {\n  return type_;\n}\n\nbool WebContents::Equal(const WebContents* web_contents) const {\n  return ID() == web_contents->ID();\n}\n\nvoid WebContents::LoadURL(const GURL& url,\n                          const gin_helper::Dictionary& options) {\n  if (!url.is_valid() || url.spec().size() > url::kMaxURLChars) {\n    Emit(\"did-fail-load\", static_cast<int>(net::ERR_INVALID_URL),\n         net::ErrorToShortString(net::ERR_INVALID_URL),\n         url.possibly_invalid_spec(), true);\n    return;\n  }\n\n  content::NavigationController::LoadURLParams params(url);\n\n  if (!options.Get(\"httpReferrer\", &params.referrer)) {\n    GURL http_referrer;\n    if (options.Get(\"httpReferrer\", &http_referrer))\n      params.referrer =\n          content::Referrer(http_referrer.GetAsReferrer(),\n                            network::mojom::ReferrerPolicy::kDefault);\n  }\n\n  std::string user_agent;\n  if (options.Get(\"userAgent\", &user_agent))\n    web_contents()->SetUserAgentOverride(\n        blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n\n  std::string extra_headers;\n  if (options.Get(\"extraHeaders\", &extra_headers))\n    params.extra_headers = extra_headers;\n\n  scoped_refptr<network::ResourceRequestBody> body;\n  if (options.Get(\"postData\", &body)) {\n    params.post_data = body;\n    params.load_type = content::NavigationController::LOAD_TYPE_HTTP_POST;\n  }\n\n  GURL base_url_for_data_url;\n  if (options.Get(\"baseURLForDataURL\", &base_url_for_data_url)) {\n    params.base_url_for_data_url = base_url_for_data_url;\n    params.load_type = content::NavigationController::LOAD_TYPE_DATA;\n  }\n\n  bool reload_ignoring_cache = false;\n  if (options.Get(\"reloadIgnoringCache\", &reload_ignoring_cache) &&\n      reload_ignoring_cache) {\n    params.reload_type = content::ReloadType::BYPASSING_CACHE;\n  }\n\n  // Calling LoadURLWithParams() can trigger JS which destroys |this|.\n  auto weak_this = GetWeakPtr();\n\n  // Required to make beforeunload handler work.\n  NotifyUserActivation();\n\n  params.transition_type = ui::PAGE_TRANSITION_TYPED;\n  params.should_clear_history_list = true;\n  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;\n  // Discord non-committed entries to ensure that we don't re-use a pending\n  // entry\n  web_contents()->GetController().DiscardNonCommittedEntries();\n  web_contents()->GetController().LoadURLWithParams(params);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // LoadURLWithParams() triggers JS events which can call destroy() on |this|.\n  // It's not safe to assume that |this| points to valid memory at this point.\n  if (!weak_this)\n    return;\n\n  // Set the background color of RenderWidgetHostView.\n  // We have to call it right after LoadURL because the RenderViewHost is only\n  // created after loading a page.\n  auto* const view = weak_this->web_contents()->GetRenderWidgetHostView();\n  if (view) {\n    auto* web_preferences = WebContentsPreferences::From(web_contents());\n    std::string color_name;\n    if (web_preferences->GetPreference(options::kBackgroundColor,\n                                       &color_name)) {\n      view->SetBackgroundColor(ParseHexColor(color_name));\n    } else {\n      view->SetBackgroundColor(SK_ColorTRANSPARENT);\n    }\n  }\n}\n\nvoid WebContents::DownloadURL(const GURL& url) {\n  auto* browser_context = web_contents()->GetBrowserContext();\n  auto* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  std::unique_ptr<download::DownloadUrlParameters> download_params(\n      content::DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(\n          web_contents(), url, MISSING_TRAFFIC_ANNOTATION));\n  download_manager->DownloadUrl(std::move(download_params));\n}\n\nGURL WebContents::GetURL() const {\n  return web_contents()->GetURL();\n}\n\nbase::string16 WebContents::GetTitle() const {\n  return web_contents()->GetTitle();\n}\n\nbool WebContents::IsLoading() const {\n  return web_contents()->IsLoading();\n}\n\nbool WebContents::IsLoadingMainFrame() const {\n  return web_contents()->IsLoadingToDifferentDocument();\n}\n\nbool WebContents::IsWaitingForResponse() const {\n  return web_contents()->IsWaitingForResponse();\n}\n\nvoid WebContents::Stop() {\n  web_contents()->Stop();\n}\n\nvoid WebContents::GoBack() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoBack();\n}\n\nvoid WebContents::GoForward() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoForward();\n}\n\nvoid WebContents::GoToOffset(int offset) {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoToOffset(offset);\n}\n\nconst std::string WebContents::GetWebRTCIPHandlingPolicy() const {\n  return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;\n}\n\nvoid WebContents::SetWebRTCIPHandlingPolicy(\n    const std::string& webrtc_ip_handling_policy) {\n  if (GetWebRTCIPHandlingPolicy() == webrtc_ip_handling_policy)\n    return;\n  web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy =\n      webrtc_ip_handling_policy;\n\n  web_contents()->SyncRendererPrefs();\n}\n\nbool WebContents::IsCrashed() const {\n  return web_contents()->IsCrashed();\n}\n\nvoid WebContents::ForcefullyCrashRenderer() {\n  content::RenderWidgetHostView* view =\n      web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return;\n\n  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();\n  if (!rwh)\n    return;\n\n  content::RenderProcessHost* rph = rwh->GetProcess();\n  if (rph) {\n#if defined(OS_LINUX) || defined(OS_CHROMEOS)\n    // A generic |CrashDumpHungChildProcess()| is not implemented for Linux.\n    // Instead we send an explicit IPC to crash on the renderer's IO thread.\n    rph->ForceCrash();\n#else\n    // Try to generate a crash report for the hung process.\n#ifndef MAS_BUILD\n    CrashDumpHungChildProcess(rph->GetProcess().Handle());\n#endif\n    rph->Shutdown(content::RESULT_CODE_HUNG);\n#endif\n  }\n}\n\nvoid WebContents::SetUserAgent(const std::string& user_agent) {\n  web_contents()->SetUserAgentOverride(\n      blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n}\n\nstd::string WebContents::GetUserAgent() {\n  return web_contents()->GetUserAgentOverride().ua_string_override;\n}\n\nv8::Local<v8::Promise> WebContents::SavePage(\n    const base::FilePath& full_file_path,\n    const content::SavePageType& save_type) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  gin_helper::Promise<void> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  auto* handler = new SavePageHandler(web_contents(), std::move(promise));\n  handler->Handle(full_file_path, save_type);\n\n  return handle;\n}\n\nvoid WebContents::OpenDevTools(gin::Arguments* args) {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  std::string state;\n  if (type_ == Type::kWebView || type_ == Type::kBackgroundPage ||\n      !owner_window()) {\n    state = \"detach\";\n  }\n  bool activate = true;\n  if (args && args->Length() == 1) {\n    gin_helper::Dictionary options;\n    if (args->GetNext(&options)) {\n      options.Get(\"mode\", &state);\n      options.Get(\"activate\", &activate);\n    }\n  }\n\n  DCHECK(inspectable_web_contents_);\n  inspectable_web_contents_->SetDockState(state);\n  inspectable_web_contents_->ShowDevTools(activate);\n}\n\nvoid WebContents::CloseDevTools() {\n  if (type_ == Type::kRemote)\n    return;\n\n  DCHECK(inspectable_web_contents_);\n  inspectable_web_contents_->CloseDevTools();\n}\n\nbool WebContents::IsDevToolsOpened() {\n  if (type_ == Type::kRemote)\n    return false;\n\n  DCHECK(inspectable_web_contents_);\n  return inspectable_web_contents_->IsDevToolsViewShowing();\n}\n\nbool WebContents::IsDevToolsFocused() {\n  if (type_ == Type::kRemote)\n    return false;\n\n  DCHECK(inspectable_web_contents_);\n  return inspectable_web_contents_->GetView()->IsDevToolsViewFocused();\n}\n\nvoid WebContents::EnableDeviceEmulation(\n    const blink::DeviceEmulationParams& params) {\n  if (type_ == Type::kRemote)\n    return;\n\n  DCHECK(web_contents());\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host_impl =\n        frame_host ? static_cast<content::RenderWidgetHostImpl*>(\n                         frame_host->GetView()->GetRenderWidgetHost())\n                   : nullptr;\n    if (widget_host_impl) {\n      auto& frame_widget = widget_host_impl->GetAssociatedFrameWidget();\n      frame_widget->EnableDeviceEmulation(params);\n    }\n  }\n}\n\nvoid WebContents::DisableDeviceEmulation() {\n  if (type_ == Type::kRemote)\n    return;\n\n  DCHECK(web_contents());\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host_impl =\n        frame_host ? static_cast<content::RenderWidgetHostImpl*>(\n                         frame_host->GetView()->GetRenderWidgetHost())\n                   : nullptr;\n    if (widget_host_impl) {\n      auto& frame_widget = widget_host_impl->GetAssociatedFrameWidget();\n      frame_widget->DisableDeviceEmulation();\n    }\n  }\n}\n\nvoid WebContents::ToggleDevTools() {\n  if (IsDevToolsOpened())\n    CloseDevTools();\n  else\n    OpenDevTools(nullptr);\n}\n\nvoid WebContents::InspectElement(int x, int y) {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  DCHECK(inspectable_web_contents_);\n  if (!inspectable_web_contents_->GetDevToolsWebContents())\n    OpenDevTools(nullptr);\n  inspectable_web_contents_->InspectElement(x, y);\n}\n\nvoid WebContents::InspectSharedWorkerById(const std::string& workerId) {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      if (agent_host->GetId() == workerId) {\n        OpenDevTools(nullptr);\n        inspectable_web_contents_->AttachTo(agent_host);\n        break;\n      }\n    }\n  }\n}\n\nstd::vector<scoped_refptr<content::DevToolsAgentHost>>\nWebContents::GetAllSharedWorkers() {\n  std::vector<scoped_refptr<content::DevToolsAgentHost>> shared_workers;\n\n  if (type_ == Type::kRemote)\n    return shared_workers;\n\n  if (!enable_devtools_)\n    return shared_workers;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      shared_workers.push_back(agent_host);\n    }\n  }\n  return shared_workers;\n}\n\nvoid WebContents::InspectSharedWorker() {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      OpenDevTools(nullptr);\n      inspectable_web_contents_->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::InspectServiceWorker() {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeServiceWorker) {\n      OpenDevTools(nullptr);\n      inspectable_web_contents_->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::SetIgnoreMenuShortcuts(bool ignore) {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  DCHECK(web_preferences);\n  web_preferences->preference()->SetKey(\"ignoreMenuShortcuts\",\n                                        base::Value(ignore));\n}\n\nvoid WebContents::SetAudioMuted(bool muted) {\n  web_contents()->SetAudioMuted(muted);\n}\n\nbool WebContents::IsAudioMuted() {\n  return web_contents()->IsAudioMuted();\n}\n\nbool WebContents::IsCurrentlyAudible() {\n  return web_contents()->IsCurrentlyAudible();\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\nvoid WebContents::OnGetDefaultPrinter(\n    base::Value print_settings,\n    printing::CompletionCallback print_callback,\n    base::string16 device_name,\n    bool silent,\n    base::string16 default_printer) {\n  // The content::WebContents might be already deleted at this point, and the\n  // PrintViewManagerBasic class does not do null check.\n  if (!web_contents()) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"failed\");\n    return;\n  }\n\n  base::string16 printer_name =\n      device_name.empty() ? default_printer : device_name;\n\n  // If there are no valid printers available on the network, we bail.\n  if (printer_name.empty() || !IsDeviceNameValid(printer_name)) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"no valid printers available\");\n    return;\n  }\n\n  print_settings.SetStringKey(printing::kSettingDeviceName, printer_name);\n\n  auto* print_view_manager =\n      printing::PrintViewManagerBasic::FromWebContents(web_contents());\n  auto* focused_frame = web_contents()->GetFocusedFrame();\n  auto* rfh = focused_frame && focused_frame->HasSelection()\n                  ? focused_frame\n                  : web_contents()->GetMainFrame();\n\n  print_view_manager->PrintNow(rfh, silent, std::move(print_settings),\n                               std::move(print_callback));\n}\n\nvoid WebContents::Print(gin::Arguments* args) {\n  gin_helper::Dictionary options =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  base::Value settings(base::Value::Type::DICTIONARY);\n\n  if (args->Length() >= 1 && !args->GetNext(&options)) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"webContents.print(): Invalid print settings specified.\");\n    return;\n  }\n\n  printing::CompletionCallback callback;\n  if (args->Length() == 2 && !args->GetNext(&callback)) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"webContents.print(): Invalid optional callback provided.\");\n    return;\n  }\n\n  // Set optional silent printing\n  bool silent = false;\n  options.Get(\"silent\", &silent);\n\n  bool print_background = false;\n  options.Get(\"printBackground\", &print_background);\n  settings.SetBoolKey(printing::kSettingShouldPrintBackgrounds,\n                      print_background);\n\n  // Set custom margin settings\n  gin_helper::Dictionary margins =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  if (options.Get(\"margins\", &margins)) {\n    printing::mojom::MarginType margin_type =\n        printing::mojom::MarginType::kDefaultMargins;\n    margins.Get(\"marginType\", &margin_type);\n    settings.SetIntKey(printing::kSettingMarginsType,\n                       static_cast<int>(margin_type));\n\n    if (margin_type == printing::mojom::MarginType::kCustomMargins) {\n      base::Value custom_margins(base::Value::Type::DICTIONARY);\n      int top = 0;\n      margins.Get(\"top\", &top);\n      custom_margins.SetIntKey(printing::kSettingMarginTop, top);\n      int bottom = 0;\n      margins.Get(\"bottom\", &bottom);\n      custom_margins.SetIntKey(printing::kSettingMarginBottom, bottom);\n      int left = 0;\n      margins.Get(\"left\", &left);\n      custom_margins.SetIntKey(printing::kSettingMarginLeft, left);\n      int right = 0;\n      margins.Get(\"right\", &right);\n      custom_margins.SetIntKey(printing::kSettingMarginRight, right);\n      settings.SetPath(printing::kSettingMarginsCustom,\n                       std::move(custom_margins));\n    }\n  } else {\n    settings.SetIntKey(\n        printing::kSettingMarginsType,\n        static_cast<int>(printing::mojom::MarginType::kDefaultMargins));\n  }\n\n  // Set whether to print color or greyscale\n  bool print_color = true;\n  options.Get(\"color\", &print_color);\n  auto const color_model = print_color ? printing::mojom::ColorModel::kColor\n                                       : printing::mojom::ColorModel::kGray;\n  settings.SetIntKey(printing::kSettingColor, static_cast<int>(color_model));\n\n  // Is the orientation landscape or portrait.\n  bool landscape = false;\n  options.Get(\"landscape\", &landscape);\n  settings.SetBoolKey(printing::kSettingLandscape, landscape);\n\n  // We set the default to the system's default printer and only update\n  // if at the Chromium level if the user overrides.\n  // Printer device name as opened by the OS.\n  base::string16 device_name;\n  options.Get(\"deviceName\", &device_name);\n  if (!device_name.empty() && !IsDeviceNameValid(device_name)) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"webContents.print(): Invalid deviceName provided.\");\n    return;\n  }\n\n  int scale_factor = 100;\n  options.Get(\"scaleFactor\", &scale_factor);\n  settings.SetIntKey(printing::kSettingScaleFactor, scale_factor);\n\n  int pages_per_sheet = 1;\n  options.Get(\"pagesPerSheet\", &pages_per_sheet);\n  settings.SetIntKey(printing::kSettingPagesPerSheet, pages_per_sheet);\n\n  // True if the user wants to print with collate.\n  bool collate = true;\n  options.Get(\"collate\", &collate);\n  settings.SetBoolKey(printing::kSettingCollate, collate);\n\n  // The number of individual copies to print\n  int copies = 1;\n  options.Get(\"copies\", &copies);\n  settings.SetIntKey(printing::kSettingCopies, copies);\n\n  // Strings to be printed as headers and footers if requested by the user.\n  std::string header;\n  options.Get(\"header\", &header);\n  std::string footer;\n  options.Get(\"footer\", &footer);\n\n  if (!(header.empty() && footer.empty())) {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, true);\n\n    settings.SetStringKey(printing::kSettingHeaderFooterTitle, header);\n    settings.SetStringKey(printing::kSettingHeaderFooterURL, footer);\n  } else {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, false);\n  }\n\n  // We don't want to allow the user to enable these settings\n  // but we need to set them or a CHECK is hit.\n  settings.SetIntKey(printing::kSettingPrinterType,\n                     static_cast<int>(printing::PrinterType::kLocal));\n  settings.SetBoolKey(printing::kSettingShouldPrintSelectionOnly, false);\n  settings.SetBoolKey(printing::kSettingRasterizePdf, false);\n\n  // Set custom page ranges to print\n  std::vector<gin_helper::Dictionary> page_ranges;\n  if (options.Get(\"pageRanges\", &page_ranges)) {\n    base::Value page_range_list(base::Value::Type::LIST);\n    for (auto& range : page_ranges) {\n      int from, to;\n      if (range.Get(\"from\", &from) && range.Get(\"to\", &to)) {\n        base::Value range(base::Value::Type::DICTIONARY);\n        // Chromium uses 1-based page ranges, so increment each by 1.\n        range.SetIntKey(printing::kSettingPageRangeFrom, from + 1);\n        range.SetIntKey(printing::kSettingPageRangeTo, to + 1);\n        page_range_list.Append(std::move(range));\n      } else {\n        continue;\n      }\n    }\n    if (!page_range_list.GetList().empty())\n      settings.SetPath(printing::kSettingPageRange, std::move(page_range_list));\n  }\n\n  // Duplex type user wants to use.\n  printing::mojom::DuplexMode duplex_mode =\n      printing::mojom::DuplexMode::kSimplex;\n  options.Get(\"duplexMode\", &duplex_mode);\n  settings.SetIntKey(printing::kSettingDuplexMode,\n                     static_cast<int>(duplex_mode));\n\n  // We've already done necessary parameter sanitization at the\n  // JS level, so we can simply pass this through.\n  base::Value media_size(base::Value::Type::DICTIONARY);\n  if (options.Get(\"mediaSize\", &media_size))\n    settings.SetKey(printing::kSettingMediaSize, std::move(media_size));\n\n  // Set custom dots per inch (dpi)\n  gin_helper::Dictionary dpi_settings;\n  int dpi = 72;\n  if (options.Get(\"dpi\", &dpi_settings)) {\n    int horizontal = 72;\n    dpi_settings.Get(\"horizontal\", &horizontal);\n    settings.SetIntKey(printing::kSettingDpiHorizontal, horizontal);\n    int vertical = 72;\n    dpi_settings.Get(\"vertical\", &vertical);\n    settings.SetIntKey(printing::kSettingDpiVertical, vertical);\n  } else {\n    settings.SetIntKey(printing::kSettingDpiHorizontal, dpi);\n    settings.SetIntKey(printing::kSettingDpiVertical, dpi);\n  }\n\n  base::ThreadPool::PostTaskAndReplyWithResult(\n      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},\n      base::BindOnce(&GetDefaultPrinterAsync),\n      base::BindOnce(&WebContents::OnGetDefaultPrinter,\n                     weak_factory_.GetWeakPtr(), std::move(settings),\n                     std::move(callback), device_name, silent));\n}\n\nv8::Local<v8::Promise> WebContents::PrintToPDF(base::DictionaryValue settings) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  gin_helper::Promise<v8::Local<v8::Value>> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  PrintPreviewMessageHandler::FromWebContents(web_contents())\n      ->PrintToPDF(std::move(settings), std::move(promise));\n  return handle;\n}\n#endif\n\nvoid WebContents::AddWorkSpace(gin::Arguments* args,\n                               const base::FilePath& path) {\n  if (path.empty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsAddFileSystem(std::string(), path);\n}\n\nvoid WebContents::RemoveWorkSpace(gin::Arguments* args,\n                                  const base::FilePath& path) {\n  if (path.empty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsRemoveFileSystem(path);\n}\n\nvoid WebContents::Undo() {\n  web_contents()->Undo();\n}\n\nvoid WebContents::Redo() {\n  web_contents()->Redo();\n}\n\nvoid WebContents::Cut() {\n  web_contents()->Cut();\n}\n\nvoid WebContents::Copy() {\n  web_contents()->Copy();\n}\n\nvoid WebContents::Paste() {\n  web_contents()->Paste();\n}\n\nvoid WebContents::PasteAndMatchStyle() {\n  web_contents()->PasteAndMatchStyle();\n}\n\nvoid WebContents::Delete() {\n  web_contents()->Delete();\n}\n\nvoid WebContents::SelectAll() {\n  web_contents()->SelectAll();\n}\n\nvoid WebContents::Unselect() {\n  web_contents()->CollapseSelection();\n}\n\nvoid WebContents::Replace(const base::string16& word) {\n  web_contents()->Replace(word);\n}\n\nvoid WebContents::ReplaceMisspelling(const base::string16& word) {\n  web_contents()->ReplaceMisspelling(word);\n}\n\nuint32_t WebContents::FindInPage(gin::Arguments* args) {\n  base::string16 search_text;\n  if (!args->GetNext(&search_text) || search_text.empty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"Must provide a non-empty search content\");\n    return 0;\n  }\n\n  uint32_t request_id = ++find_in_page_request_id_;\n  gin_helper::Dictionary dict;\n  auto options = blink::mojom::FindOptions::New();\n  if (args->GetNext(&dict)) {\n    dict.Get(\"forward\", &options->forward);\n    dict.Get(\"matchCase\", &options->match_case);\n    dict.Get(\"findNext\", &options->new_session);\n  }\n\n  web_contents()->Find(request_id, search_text, std::move(options));\n  return request_id;\n}\n\nvoid WebContents::StopFindInPage(content::StopFindAction action) {\n  web_contents()->StopFinding(action);\n}\n\nvoid WebContents::ShowDefinitionForSelection() {\n#if defined(OS_MAC)\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (view)\n    view->ShowDefinitionForSelection();\n#endif\n}\n\nvoid WebContents::CopyImageAt(int x, int y) {\n  auto* const host = web_contents()->GetMainFrame();\n  if (host)\n    host->CopyImageAt(x, y);\n}\n\nvoid WebContents::Focus() {\n  // Focusing on WebContents does not automatically focus the window on macOS\n  // and Linux, do it manually to match the behavior on Windows.\n#if defined(OS_MAC) || defined(OS_LINUX)\n  if (owner_window())\n    owner_window()->Focus(true);\n#endif\n  web_contents()->Focus();\n}\n\n#if !defined(OS_MAC)\nbool WebContents::IsFocused() const {\n  auto* view = web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return false;\n\n  if (GetType() != Type::kBackgroundPage) {\n    auto* window = web_contents()->GetNativeView()->GetToplevelWindow();\n    if (window && !window->IsVisible())\n      return false;\n  }\n\n  return view->HasFocus();\n}\n#endif\n\nbool WebContents::SendIPCMessage(bool internal,\n                                 const std::string& channel,\n                                 v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  return SendIPCMessageWithSender(internal, channel, std::move(message));\n}\n\nbool WebContents::SendIPCMessageWithSender(bool internal,\n                                           const std::string& channel,\n                                           blink::CloneableMessage args,\n                                           int32_t sender_id) {\n  auto* frame_host = web_contents()->GetMainFrame();\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(args), sender_id);\n  return true;\n}\n\nbool WebContents::SendIPCMessageToFrame(bool internal,\n                                        int32_t frame_id,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  auto frames = web_contents()->GetAllFrames();\n  auto iter = std::find_if(frames.begin(), frames.end(), [frame_id](auto* f) {\n    return f->GetRoutingID() == frame_id;\n  });\n  if (iter == frames.end())\n    return false;\n  if (!(*iter)->IsRenderFrameLive())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  (*iter)->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 /* sender_id */);\n  return true;\n}\n\nvoid WebContents::SendInputEvent(v8::Isolate* isolate,\n                                 v8::Local<v8::Value> input_event) {\n  content::RenderWidgetHostView* view =\n      web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return;\n\n  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();\n  blink::WebInputEvent::Type type =\n      gin::GetWebInputEventType(isolate, input_event);\n  if (blink::WebInputEvent::IsMouseEventType(type)) {\n    blink::WebMouseEvent mouse_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseEvent(mouse_event);\n#endif\n      } else {\n        rwh->ForwardMouseEvent(mouse_event);\n      }\n      return;\n    }\n  } else if (blink::WebInputEvent::IsKeyboardEventType(type)) {\n    content::NativeWebKeyboardEvent keyboard_event(\n        blink::WebKeyboardEvent::Type::kRawKeyDown,\n        blink::WebInputEvent::Modifiers::kNoModifiers, ui::EventTimeForNow());\n    if (gin::ConvertFromV8(isolate, input_event, &keyboard_event)) {\n      rwh->ForwardKeyboardEvent(keyboard_event);\n      return;\n    }\n  } else if (type == blink::WebInputEvent::Type::kMouseWheel) {\n    blink::WebMouseWheelEvent mouse_wheel_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseWheelEvent(\n            mouse_wheel_event);\n#endif\n      } else {\n        // Chromium expects phase info in wheel events (and applies a\n        // DCHECK to verify it). See: https://crbug.com/756524.\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseBegan;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n\n        // Send a synthetic wheel event with phaseEnded to finish scrolling.\n        mouse_wheel_event.has_synthetic_phase = true;\n        mouse_wheel_event.delta_x = 0;\n        mouse_wheel_event.delta_y = 0;\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseEnded;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kEventNonBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n      }\n      return;\n    }\n  }\n\n  isolate->ThrowException(\n      v8::Exception::Error(gin::StringToV8(isolate, \"Invalid event object\")));\n}\n\nvoid WebContents::BeginFrameSubscription(gin::Arguments* args) {\n  bool only_dirty = false;\n  FrameSubscriber::FrameCaptureCallback callback;\n\n  if (args->Length() > 1) {\n    if (!args->GetNext(&only_dirty)) {\n      args->ThrowError();\n      return;\n    }\n  }\n  if (!args->GetNext(&callback)) {\n    args->ThrowError();\n    return;\n  }\n\n  frame_subscriber_ =\n      std::make_unique<FrameSubscriber>(web_contents(), callback, only_dirty);\n}\n\nvoid WebContents::EndFrameSubscription() {\n  frame_subscriber_.reset();\n}\n\nvoid WebContents::StartDrag(const gin_helper::Dictionary& item,\n                            gin::Arguments* args) {\n  base::FilePath file;\n  std::vector<base::FilePath> files;\n  if (!item.Get(\"files\", &files) && item.Get(\"file\", &file)) {\n    files.push_back(file);\n  }\n\n  gin::Handle<NativeImage> icon;\n  if (!item.Get(\"icon\", &icon) || icon->image().IsEmpty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"Must specify non-empty 'icon' option\");\n    return;\n  }\n\n  // Start dragging.\n  if (!files.empty()) {\n    base::CurrentThread::ScopedNestableTaskAllower allow;\n    DragFileItems(files, icon->image(), web_contents()->GetNativeView());\n  } else {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"Must specify either 'file' or 'files' option\");\n  }\n}\n\nv8::Local<v8::Promise> WebContents::CapturePage(gin::Arguments* args) {\n  gfx::Rect rect;\n  gin_helper::Promise<gfx::Image> promise(args->isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  // get rect arguments if they exist\n  args->GetNext(&rect);\n\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (!view) {\n    promise.Resolve(gfx::Image());\n    return handle;\n  }\n\n  // Capture full page if user doesn't specify a |rect|.\n  const gfx::Size view_size =\n      rect.IsEmpty() ? view->GetViewBounds().size() : rect.size();\n\n  // By default, the requested bitmap size is the view size in screen\n  // coordinates.  However, if there's more pixel detail available on the\n  // current system, increase the requested bitmap size to capture it all.\n  gfx::Size bitmap_size = view_size;\n  const gfx::NativeView native_view = view->GetNativeView();\n  const float scale = display::Screen::GetScreen()\n                          ->GetDisplayNearestView(native_view)\n                          .device_scale_factor();\n  if (scale > 1.0f)\n    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);\n\n  view->CopyFromSurface(gfx::Rect(rect.origin(), view_size), bitmap_size,\n                        base::BindOnce(&OnCapturePageDone, std::move(promise)));\n  return handle;\n}\n\nvoid WebContents::IncrementCapturerCount(gin::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->IncrementCapturerCount(size, stay_hidden);\n}\n\nvoid WebContents::DecrementCapturerCount(gin::Arguments* args) {\n  bool stay_hidden = false;\n\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->DecrementCapturerCount(stay_hidden);\n}\n\nbool WebContents::IsBeingCaptured() {\n  return web_contents()->IsBeingCaptured();\n}\n\nvoid WebContents::OnCursorChanged(const content::WebCursor& webcursor) {\n  const ui::Cursor& cursor = webcursor.cursor();\n\n  if (cursor.type() == ui::mojom::CursorType::kCustom) {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor),\n         gfx::Image::CreateFrom1xBitmap(cursor.custom_bitmap()),\n         cursor.image_scale_factor(),\n         gfx::Size(cursor.custom_bitmap().width(),\n                   cursor.custom_bitmap().height()),\n         cursor.custom_hotspot());\n  } else {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor));\n  }\n}\n\nbool WebContents::IsGuest() const {\n  return type_ == Type::kWebView;\n}\n\nvoid WebContents::AttachToIframe(content::WebContents* embedder_web_contents,\n                                 int embedder_frame_id) {\n  if (guest_delegate_)\n    guest_delegate_->AttachToIframe(embedder_web_contents, embedder_frame_id);\n}\n\nbool WebContents::IsOffScreen() const {\n#if BUILDFLAG(ENABLE_OSR)\n  return type_ == Type::kOffScreen;\n#else\n  return false;\n#endif\n}\n\n#if BUILDFLAG(ENABLE_OSR)\nvoid WebContents::OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap) {\n  Emit(\"paint\", dirty_rect, gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nvoid WebContents::StartPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(true);\n}\n\nvoid WebContents::StopPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(false);\n}\n\nbool WebContents::IsPainting() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv && osr_wcv->IsPainting();\n}\n\nvoid WebContents::SetFrameRate(int frame_rate) {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetFrameRate(frame_rate);\n}\n\nint WebContents::GetFrameRate() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv ? osr_wcv->GetFrameRate() : 0;\n}\n#endif\n\nvoid WebContents::Invalidate() {\n  if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n    auto* osr_rwhv = GetOffScreenRenderWidgetHostView();\n    if (osr_rwhv)\n      osr_rwhv->Invalidate();\n#endif\n  } else {\n    auto* const window = owner_window();\n    if (window)\n      window->Invalidate();\n  }\n}\n\ngfx::Size WebContents::GetSizeForNewRenderView(content::WebContents* wc) {\n  if (IsOffScreen() && wc == web_contents()) {\n    auto* relay = NativeWindowRelay::FromWebContents(web_contents());\n    if (relay) {\n      auto* owner_window = relay->GetNativeWindow();\n      return owner_window ? owner_window->GetSize() : gfx::Size();\n    }\n  }\n\n  return gfx::Size();\n}\n\nvoid WebContents::SetZoomLevel(double level) {\n  zoom_controller_->SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomLevel() const {\n  return zoom_controller_->GetZoomLevel();\n}\n\nvoid WebContents::SetZoomFactor(gin_helper::ErrorThrower thrower,\n                                double factor) {\n  if (factor < std::numeric_limits<double>::epsilon()) {\n    thrower.ThrowError(\"'zoomFactor' must be a double greater than 0.0\");\n    return;\n  }\n\n  auto level = blink::PageZoomFactorToZoomLevel(factor);\n  SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomFactor() const {\n  auto level = GetZoomLevel();\n  return blink::PageZoomLevelToZoomFactor(level);\n}\n\nvoid WebContents::SetTemporaryZoomLevel(double level) {\n  zoom_controller_->SetTemporaryZoomLevel(level);\n}\n\nvoid WebContents::DoGetZoomLevel(DoGetZoomLevelCallback callback) {\n  std::move(callback).Run(GetZoomLevel());\n}\n\nstd::vector<base::FilePath> WebContents::GetPreloadPaths() const {\n  auto result = SessionPreferences::GetValidPreloads(GetBrowserContext());\n\n  if (auto* web_preferences = WebContentsPreferences::From(web_contents())) {\n    base::FilePath preload;\n    if (web_preferences->GetPreloadPath(&preload)) {\n      result.emplace_back(preload);\n    }\n  }\n\n  return result;\n}\n\nv8::Local<v8::Value> WebContents::GetWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->preference());\n}\n\nv8::Local<v8::Value> WebContents::GetLastWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->last_preference());\n}\n\nv8::Local<v8::Value> WebContents::GetOwnerBrowserWindow(\n    v8::Isolate* isolate) const {\n  if (owner_window())\n    return BrowserWindow::From(isolate, owner_window());\n  else\n    return v8::Null(isolate);\n}\n\nv8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {\n  return v8::Local<v8::Value>::New(isolate, session_);\n}\n\ncontent::WebContents* WebContents::HostWebContents() const {\n  if (!embedder_)\n    return nullptr;\n  return embedder_->web_contents();\n}\n\nvoid WebContents::SetEmbedder(const WebContents* embedder) {\n  if (embedder) {\n    NativeWindow* owner_window = nullptr;\n    auto* relay = NativeWindowRelay::FromWebContents(embedder->web_contents());\n    if (relay) {\n      owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n\n    content::RenderWidgetHostView* rwhv =\n        web_contents()->GetRenderWidgetHostView();\n    if (rwhv) {\n      rwhv->Hide();\n      rwhv->Show();\n    }\n  }\n}\n\nvoid WebContents::SetDevToolsWebContents(const WebContents* devtools) {\n  if (inspectable_web_contents_)\n    inspectable_web_contents_->SetDevToolsWebContents(devtools->web_contents());\n}\n\nv8::Local<v8::Value> WebContents::GetNativeView(v8::Isolate* isolate) const {\n  gfx::NativeView ptr = web_contents()->GetNativeView();\n  auto buffer = node::Buffer::Copy(isolate, reinterpret_cast<char*>(&ptr),\n                                   sizeof(gfx::NativeView));\n  if (buffer.IsEmpty())\n    return v8::Null(isolate);\n  else\n    return buffer.ToLocalChecked();\n}\n\nv8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {\n  if (devtools_web_contents_.IsEmpty())\n    return v8::Null(isolate);\n  else\n    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);\n}\n\nv8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {\n  if (debugger_.IsEmpty()) {\n    auto handle = electron::api::Debugger::Create(isolate, web_contents());\n    debugger_.Reset(isolate, handle.ToV8());\n  }\n  return v8::Local<v8::Value>::New(isolate, debugger_);\n}\n\nbool WebContents::WasInitiallyShown() {\n  return initially_shown_;\n}\n\ncontent::RenderFrameHost* WebContents::MainFrame() {\n  return web_contents()->GetMainFrame();\n}\n\nvoid WebContents::GrantOriginAccess(const GURL& url) {\n  content::ChildProcessSecurityPolicy::GetInstance()->GrantCommitOrigin(\n      web_contents()->GetMainFrame()->GetProcess()->GetID(),\n      url::Origin::Create(url));\n}\n\nvoid WebContents::NotifyUserActivation() {\n  auto* frame = web_contents()->GetMainFrame();\n  if (!frame)\n    return;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> renderer;\n  frame->GetRemoteAssociatedInterfaces()->GetInterface(&renderer);\n  renderer->NotifyUserActivation();\n}\n\nv8::Local<v8::Promise> WebContents::TakeHeapSnapshot(\n    v8::Isolate* isolate,\n    const base::FilePath& file_path) {\n  gin_helper::Promise<void> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  base::File file(file_path,\n                  base::File::FLAG_CREATE_ALWAYS | base::File::FLAG_WRITE);\n  if (!file.IsValid()) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (!frame_host) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  // This dance with `base::Owned` is to ensure that the interface stays alive\n  // until the callback is called. Otherwise it would be closed at the end of\n  // this function.\n  auto electron_renderer =\n      std::make_unique<mojo::AssociatedRemote<mojom::ElectronRenderer>>();\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(\n      electron_renderer.get());\n  auto* raw_ptr = electron_renderer.get();\n  (*raw_ptr)->TakeHeapSnapshot(\n      mojo::WrapPlatformFile(base::ScopedPlatformFile(file.TakePlatformFile())),\n      base::BindOnce(\n          [](mojo::AssociatedRemote<mojom::ElectronRenderer>* ep,\n             gin_helper::Promise<void> promise, bool success) {\n            if (success) {\n              promise.Resolve();\n            } else {\n              promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n            }\n          },\n          base::Owned(std::move(electron_renderer)), std::move(promise)));\n  return handle;\n}\n\nvoid WebContents::UpdatePreferredSize(content::WebContents* web_contents,\n                                      const gfx::Size& pref_size) {\n  Emit(\"preferred-size-changed\", pref_size);\n}\n\nbool WebContents::CanOverscrollContent() {\n  return false;\n}\n\ncontent::ColorChooser* WebContents::OpenColorChooser(\n    content::WebContents* web_contents,\n    SkColor color,\n    const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions) {\n#if BUILDFLAG(ENABLE_COLOR_CHOOSER)\n  return chrome::ShowColorChooser(web_contents, color);\n#else\n  return nullptr;\n#endif\n}\n\nvoid WebContents::RunFileChooser(\n    content::RenderFrameHost* render_frame_host,\n    scoped_refptr<content::FileSelectListener> listener,\n    const blink::mojom::FileChooserParams& params) {\n  if (!web_dialog_helper_)\n    web_dialog_helper_ =\n        std::make_unique<WebDialogHelper>(owner_window(), offscreen_);\n  web_dialog_helper_->RunFileChooser(render_frame_host, std::move(listener),\n                                     params);\n}\n\nvoid WebContents::EnumerateDirectory(\n    content::WebContents* guest,\n    scoped_refptr<content::FileSelectListener> listener,\n    const base::FilePath& path) {\n  if (!web_dialog_helper_)\n    web_dialog_helper_ =\n        std::make_unique<WebDialogHelper>(owner_window(), offscreen_);\n  web_dialog_helper_->EnumerateDirectory(guest, std::move(listener), path);\n}\n\nbool WebContents::IsFullscreenForTabOrPending(\n    const content::WebContents* source) {\n  return html_fullscreen_;\n}\n\nblink::SecurityStyle WebContents::GetSecurityStyle(\n    content::WebContents* web_contents,\n    content::SecurityStyleExplanations* security_style_explanations) {\n  SecurityStateTabHelper* helper =\n      SecurityStateTabHelper::FromWebContents(web_contents);\n  DCHECK(helper);\n  return security_state::GetSecurityStyle(helper->GetSecurityLevel(),\n                                          *helper->GetVisibleSecurityState(),\n                                          security_style_explanations);\n}\n\nbool WebContents::TakeFocus(content::WebContents* source, bool reverse) {\n  if (source && source->GetOutermostWebContents() == source) {\n    // If this is the outermost web contents and the user has tabbed or\n    // shift + tabbed through all the elements, reset the focus back to\n    // the first or last element so that it doesn't stay in the body.\n    source->FocusThroughTabTraversal(reverse);\n    return true;\n  }\n\n  return false;\n}\n\ncontent::PictureInPictureResult WebContents::EnterPictureInPicture(\n    content::WebContents* web_contents,\n    const viz::SurfaceId& surface_id,\n    const gfx::Size& natural_size) {\n#if BUILDFLAG(ENABLE_PICTURE_IN_PICTURE)\n  return PictureInPictureWindowManager::GetInstance()->EnterPictureInPicture(\n      web_contents, surface_id, natural_size);\n#else\n  return content::PictureInPictureResult::kNotSupported;\n#endif\n}\n\nvoid WebContents::ExitPictureInPicture() {\n#if BUILDFLAG(ENABLE_PICTURE_IN_PICTURE)\n  PictureInPictureWindowManager::GetInstance()->ExitPictureInPicture();\n#endif\n}\n\nvoid WebContents::DevToolsSaveToFile(const std::string& url,\n                                     const std::string& content,\n                                     bool save_as) {\n  base::FilePath path;\n  auto it = saved_files_.find(url);\n  if (it != saved_files_.end() && !save_as) {\n    path = it->second;\n  } else {\n    file_dialog::DialogSettings settings;\n    settings.parent_window = owner_window();\n    settings.force_detached = offscreen_;\n    settings.title = url;\n    settings.default_path = base::FilePath::FromUTF8Unsafe(url);\n    if (!file_dialog::ShowSaveDialogSync(settings, &path)) {\n      base::Value url_value(url);\n      inspectable_web_contents_->CallClientFunction(\n          \"DevToolsAPI.canceledSaveURL\", &url_value, nullptr, nullptr);\n      return;\n    }\n  }\n\n  saved_files_[url] = path;\n  // Notify DevTools.\n  base::Value url_value(url);\n  base::Value file_system_path_value(path.AsUTF8Unsafe());\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.savedURL\", &url_value, &file_system_path_value, nullptr);\n  file_task_runner_->PostTask(FROM_HERE,\n                              base::BindOnce(&WriteToFile, path, content));\n}\n\nvoid WebContents::DevToolsAppendToFile(const std::string& url,\n                                       const std::string& content) {\n  auto it = saved_files_.find(url);\n  if (it == saved_files_.end())\n    return;\n\n  // Notify DevTools.\n  base::Value url_value(url);\n  inspectable_web_contents_->CallClientFunction(\"DevToolsAPI.appendedToURL\",\n                                                &url_value, nullptr, nullptr);\n  file_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&AppendToFile, it->second, content));\n}\n\nvoid WebContents::DevToolsRequestFileSystems() {\n  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());\n  if (file_system_paths.empty()) {\n    base::ListValue empty_file_system_value;\n    inspectable_web_contents_->CallClientFunction(\n        \"DevToolsAPI.fileSystemsLoaded\", &empty_file_system_value, nullptr,\n        nullptr);\n    return;\n  }\n\n  std::vector<FileSystem> file_systems;\n  for (const auto& file_system_path : file_system_paths) {\n    base::FilePath path =\n        base::FilePath::FromUTF8Unsafe(file_system_path.first);\n    std::string file_system_id =\n        RegisterFileSystem(GetDevToolsWebContents(), path);\n    FileSystem file_system =\n        CreateFileSystemStruct(GetDevToolsWebContents(), file_system_id,\n                               file_system_path.first, file_system_path.second);\n    file_systems.push_back(file_system);\n  }\n\n  base::ListValue file_system_value;\n  for (const auto& file_system : file_systems)\n    file_system_value.Append(CreateFileSystemValue(file_system));\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.fileSystemsLoaded\", &file_system_value, nullptr, nullptr);\n}\n\nvoid WebContents::DevToolsAddFileSystem(\n    const std::string& type,\n    const base::FilePath& file_system_path) {\n  base::FilePath path = file_system_path;\n  if (path.empty()) {\n    std::vector<base::FilePath> paths;\n    file_dialog::DialogSettings settings;\n    settings.parent_window = owner_window();\n    settings.force_detached = offscreen_;\n    settings.properties = file_dialog::OPEN_DIALOG_OPEN_DIRECTORY;\n    if (!file_dialog::ShowOpenDialogSync(settings, &paths))\n      return;\n\n    path = paths[0];\n  }\n\n  std::string file_system_id =\n      RegisterFileSystem(GetDevToolsWebContents(), path);\n  if (IsDevToolsFileSystemAdded(GetDevToolsWebContents(), path.AsUTF8Unsafe()))\n    return;\n\n  FileSystem file_system = CreateFileSystemStruct(\n      GetDevToolsWebContents(), file_system_id, path.AsUTF8Unsafe(), type);\n  std::unique_ptr<base::DictionaryValue> file_system_value(\n      CreateFileSystemValue(file_system));\n\n  auto* pref_service = GetPrefService(GetDevToolsWebContents());\n  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);\n  update.Get()->SetWithoutPathExpansion(path.AsUTF8Unsafe(),\n                                        std::make_unique<base::Value>(type));\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.fileSystemAdded\", nullptr, file_system_value.get(), nullptr);\n}\n\nvoid WebContents::DevToolsRemoveFileSystem(\n    const base::FilePath& file_system_path) {\n  if (!inspectable_web_contents_)\n    return;\n\n  std::string path = file_system_path.AsUTF8Unsafe();\n  storage::IsolatedContext::GetInstance()->RevokeFileSystemByPath(\n      file_system_path);\n\n  auto* pref_service = GetPrefService(GetDevToolsWebContents());\n  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);\n  update.Get()->RemoveWithoutPathExpansion(path, nullptr);\n\n  base::Value file_system_path_value(path);\n  inspectable_web_contents_->CallClientFunction(\"DevToolsAPI.fileSystemRemoved\",\n                                                &file_system_path_value,\n                                                nullptr, nullptr);\n}\n\nvoid WebContents::DevToolsIndexPath(\n    int request_id,\n    const std::string& file_system_path,\n    const std::string& excluded_folders_message) {\n  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {\n    OnDevToolsIndexingDone(request_id, file_system_path);\n    return;\n  }\n  if (devtools_indexing_jobs_.count(request_id) != 0)\n    return;\n  std::vector<std::string> excluded_folders;\n  std::unique_ptr<base::Value> parsed_excluded_folders =\n      base::JSONReader::ReadDeprecated(excluded_folders_message);\n  if (parsed_excluded_folders && parsed_excluded_folders->is_list()) {\n    for (const base::Value& folder_path : parsed_excluded_folders->GetList()) {\n      if (folder_path.is_string())\n        excluded_folders.push_back(folder_path.GetString());\n    }\n  }\n  devtools_indexing_jobs_[request_id] =\n      scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>(\n          devtools_file_system_indexer_->IndexPath(\n              file_system_path, excluded_folders,\n              base::BindRepeating(\n                  &WebContents::OnDevToolsIndexingWorkCalculated,\n                  weak_factory_.GetWeakPtr(), request_id, file_system_path),\n              base::BindRepeating(&WebContents::OnDevToolsIndexingWorked,\n                                  weak_factory_.GetWeakPtr(), request_id,\n                                  file_system_path),\n              base::BindRepeating(&WebContents::OnDevToolsIndexingDone,\n                                  weak_factory_.GetWeakPtr(), request_id,\n                                  file_system_path)));\n}\n\nvoid WebContents::DevToolsStopIndexing(int request_id) {\n  auto it = devtools_indexing_jobs_.find(request_id);\n  if (it == devtools_indexing_jobs_.end())\n    return;\n  it->second->Stop();\n  devtools_indexing_jobs_.erase(it);\n}\n\nvoid WebContents::DevToolsSearchInPath(int request_id,\n                                       const std::string& file_system_path,\n                                       const std::string& query) {\n  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {\n    OnDevToolsSearchCompleted(request_id, file_system_path,\n                              std::vector<std::string>());\n    return;\n  }\n  devtools_file_system_indexer_->SearchInPath(\n      file_system_path, query,\n      base::BindRepeating(&WebContents::OnDevToolsSearchCompleted,\n                          weak_factory_.GetWeakPtr(), request_id,\n                          file_system_path));\n}\n\n#if defined(TOOLKIT_VIEWS) && !defined(OS_MAC)\ngfx::ImageSkia WebContents::GetDevToolsWindowIcon() {\n  if (!owner_window())\n    return gfx::ImageSkia();\n  return owner_window()->GetWindowAppIcon();\n}\n#endif\n\n#if defined(OS_LINUX)\nvoid WebContents::GetDevToolsWindowWMClass(std::string* name,\n                                           std::string* class_name) {\n  *class_name = Browser::Get()->GetName();\n  *name = base::ToLowerASCII(*class_name);\n}\n#endif\n\nvoid WebContents::OnDevToolsIndexingWorkCalculated(\n    int request_id,\n    const std::string& file_system_path,\n    int total_work) {\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  base::Value total_work_value(total_work);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.indexingTotalWorkCalculated\", &request_id_value,\n      &file_system_path_value, &total_work_value);\n}\n\nvoid WebContents::OnDevToolsIndexingWorked(int request_id,\n                                           const std::string& file_system_path,\n                                           int worked) {\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  base::Value worked_value(worked);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.indexingWorked\", &request_id_value, &file_system_path_value,\n      &worked_value);\n}\n\nvoid WebContents::OnDevToolsIndexingDone(int request_id,\n                                         const std::string& file_system_path) {\n  devtools_indexing_jobs_.erase(request_id);\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.indexingDone\", &request_id_value, &file_system_path_value,\n      nullptr);\n}\n\nvoid WebContents::OnDevToolsSearchCompleted(\n    int request_id,\n    const std::string& file_system_path,\n    const std::vector<std::string>& file_paths) {\n  base::ListValue file_paths_value;\n  for (const auto& file_path : file_paths) {\n    file_paths_value.AppendString(file_path);\n  }\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.searchCompleted\", &request_id_value, &file_system_path_value,\n      &file_paths_value);\n}\n\nvoid WebContents::SetHtmlApiFullscreen(bool enter_fullscreen) {\n  // Window is already in fullscreen mode, save the state.\n  if (enter_fullscreen && owner_window_->IsFullscreen()) {\n    native_fullscreen_ = true;\n    html_fullscreen_ = true;\n    return;\n  }\n\n  // Exit html fullscreen state but not window's fullscreen mode.\n  if (!enter_fullscreen && native_fullscreen_) {\n    html_fullscreen_ = false;\n    return;\n  }\n\n  // Set fullscreen on window if allowed.\n  auto* web_preferences = WebContentsPreferences::From(GetWebContents());\n  bool html_fullscreenable =\n      web_preferences ? !web_preferences->IsEnabled(\n                            options::kDisableHtmlFullscreenWindowResize)\n                      : true;\n\n  if (html_fullscreenable) {\n    owner_window_->SetFullScreen(enter_fullscreen);\n  }\n\n  html_fullscreen_ = enter_fullscreen;\n  native_fullscreen_ = false;\n}\n\n// static\nv8::Local<v8::ObjectTemplate> WebContents::FillObjectTemplate(\n    v8::Isolate* isolate,\n    v8::Local<v8::ObjectTemplate> templ) {\n  gin::InvokerOptions options;\n  options.holder_is_first_argument = true;\n  options.holder_type = \"WebContents\";\n  templ->Set(\n      gin::StringToSymbol(isolate, \"isDestroyed\"),\n      gin::CreateFunctionTemplate(\n          isolate, base::BindRepeating(&gin_helper::Destroyable::IsDestroyed),\n          options));\n  templ->Set(\n      gin::StringToSymbol(isolate, \"destroy\"),\n      gin::CreateFunctionTemplate(\n          isolate, base::BindRepeating([](gin::Handle<WebContents> handle) {\n            delete handle.get();\n          }),\n          options));\n  // We use gin_helper::ObjectTemplateBuilder instead of\n  // gin::ObjectTemplateBuilder here to handle the fact that WebContents is\n  // destroyable.\n  return gin_helper::ObjectTemplateBuilder(isolate, templ)\n      .SetMethod(\"getBackgroundThrottling\",\n                 &WebContents::GetBackgroundThrottling)\n      .SetMethod(\"setBackgroundThrottling\",\n                 &WebContents::SetBackgroundThrottling)\n      .SetMethod(\"getProcessId\", &WebContents::GetProcessID)\n      .SetMethod(\"getOSProcessId\", &WebContents::GetOSProcessID)\n      .SetMethod(\"equal\", &WebContents::Equal)\n      .SetMethod(\"_loadURL\", &WebContents::LoadURL)\n      .SetMethod(\"downloadURL\", &WebContents::DownloadURL)\n      .SetMethod(\"_getURL\", &WebContents::GetURL)\n      .SetMethod(\"getTitle\", &WebContents::GetTitle)\n      .SetMethod(\"isLoading\", &WebContents::IsLoading)\n      .SetMethod(\"isLoadingMainFrame\", &WebContents::IsLoadingMainFrame)\n      .SetMethod(\"isWaitingForResponse\", &WebContents::IsWaitingForResponse)\n      .SetMethod(\"_stop\", &WebContents::Stop)\n      .SetMethod(\"_goBack\", &WebContents::GoBack)\n      .SetMethod(\"_goForward\", &WebContents::GoForward)\n      .SetMethod(\"_goToOffset\", &WebContents::GoToOffset)\n      .SetMethod(\"isCrashed\", &WebContents::IsCrashed)\n      .SetMethod(\"forcefullyCrashRenderer\",\n                 &WebContents::ForcefullyCrashRenderer)\n      .SetMethod(\"setUserAgent\", &WebContents::SetUserAgent)\n      .SetMethod(\"getUserAgent\", &WebContents::GetUserAgent)\n      .SetMethod(\"savePage\", &WebContents::SavePage)\n      .SetMethod(\"openDevTools\", &WebContents::OpenDevTools)\n      .SetMethod(\"closeDevTools\", &WebContents::CloseDevTools)\n      .SetMethod(\"isDevToolsOpened\", &WebContents::IsDevToolsOpened)\n      .SetMethod(\"isDevToolsFocused\", &WebContents::IsDevToolsFocused)\n      .SetMethod(\"enableDeviceEmulation\", &WebContents::EnableDeviceEmulation)\n      .SetMethod(\"disableDeviceEmulation\", &WebContents::DisableDeviceEmulation)\n      .SetMethod(\"toggleDevTools\", &WebContents::ToggleDevTools)\n      .SetMethod(\"inspectElement\", &WebContents::InspectElement)\n      .SetMethod(\"setIgnoreMenuShortcuts\", &WebContents::SetIgnoreMenuShortcuts)\n      .SetMethod(\"setAudioMuted\", &WebContents::SetAudioMuted)\n      .SetMethod(\"isAudioMuted\", &WebContents::IsAudioMuted)\n      .SetMethod(\"isCurrentlyAudible\", &WebContents::IsCurrentlyAudible)\n      .SetMethod(\"undo\", &WebContents::Undo)\n      .SetMethod(\"redo\", &WebContents::Redo)\n      .SetMethod(\"cut\", &WebContents::Cut)\n      .SetMethod(\"copy\", &WebContents::Copy)\n      .SetMethod(\"paste\", &WebContents::Paste)\n      .SetMethod(\"pasteAndMatchStyle\", &WebContents::PasteAndMatchStyle)\n      .SetMethod(\"delete\", &WebContents::Delete)\n      .SetMethod(\"selectAll\", &WebContents::SelectAll)\n      .SetMethod(\"unselect\", &WebContents::Unselect)\n      .SetMethod(\"replace\", &WebContents::Replace)\n      .SetMethod(\"replaceMisspelling\", &WebContents::ReplaceMisspelling)\n      .SetMethod(\"findInPage\", &WebContents::FindInPage)\n      .SetMethod(\"stopFindInPage\", &WebContents::StopFindInPage)\n      .SetMethod(\"focus\", &WebContents::Focus)\n      .SetMethod(\"isFocused\", &WebContents::IsFocused)\n      .SetMethod(\"_send\", &WebContents::SendIPCMessage)\n      .SetMethod(\"_postMessage\", &WebContents::PostMessage)\n      .SetMethod(\"_sendToFrame\", &WebContents::SendIPCMessageToFrame)\n      .SetMethod(\"sendInputEvent\", &WebContents::SendInputEvent)\n      .SetMethod(\"beginFrameSubscription\", &WebContents::BeginFrameSubscription)\n      .SetMethod(\"endFrameSubscription\", &WebContents::EndFrameSubscription)\n      .SetMethod(\"startDrag\", &WebContents::StartDrag)\n      .SetMethod(\"attachToIframe\", &WebContents::AttachToIframe)\n      .SetMethod(\"detachFromOuterFrame\", &WebContents::DetachFromOuterFrame)\n      .SetMethod(\"isOffscreen\", &WebContents::IsOffScreen)\n#if BUILDFLAG(ENABLE_OSR)\n      .SetMethod(\"startPainting\", &WebContents::StartPainting)\n      .SetMethod(\"stopPainting\", &WebContents::StopPainting)\n      .SetMethod(\"isPainting\", &WebContents::IsPainting)\n      .SetMethod(\"setFrameRate\", &WebContents::SetFrameRate)\n      .SetMethod(\"getFrameRate\", &WebContents::GetFrameRate)\n#endif\n      .SetMethod(\"invalidate\", &WebContents::Invalidate)\n      .SetMethod(\"setZoomLevel\", &WebContents::SetZoomLevel)\n      .SetMethod(\"getZoomLevel\", &WebContents::GetZoomLevel)\n      .SetMethod(\"setZoomFactor\", &WebContents::SetZoomFactor)\n      .SetMethod(\"getZoomFactor\", &WebContents::GetZoomFactor)\n      .SetMethod(\"getType\", &WebContents::GetType)\n      .SetMethod(\"_getPreloadPaths\", &WebContents::GetPreloadPaths)\n      .SetMethod(\"getWebPreferences\", &WebContents::GetWebPreferences)\n      .SetMethod(\"getLastWebPreferences\", &WebContents::GetLastWebPreferences)\n      .SetMethod(\"getOwnerBrowserWindow\", &WebContents::GetOwnerBrowserWindow)\n      .SetMethod(\"inspectServiceWorker\", &WebContents::InspectServiceWorker)\n      .SetMethod(\"inspectSharedWorker\", &WebContents::InspectSharedWorker)\n      .SetMethod(\"inspectSharedWorkerById\",\n                 &WebContents::InspectSharedWorkerById)\n      .SetMethod(\"getAllSharedWorkers\", &WebContents::GetAllSharedWorkers)\n#if BUILDFLAG(ENABLE_PRINTING)\n      .SetMethod(\"_print\", &WebContents::Print)\n      .SetMethod(\"_printToPDF\", &WebContents::PrintToPDF)\n#endif\n      .SetMethod(\"_setNextChildWebPreferences\",\n                 &WebContents::SetNextChildWebPreferences)\n      .SetMethod(\"addWorkSpace\", &WebContents::AddWorkSpace)\n      .SetMethod(\"removeWorkSpace\", &WebContents::RemoveWorkSpace)\n      .SetMethod(\"showDefinitionForSelection\",\n                 &WebContents::ShowDefinitionForSelection)\n      .SetMethod(\"copyImageAt\", &WebContents::CopyImageAt)\n      .SetMethod(\"capturePage\", &WebContents::CapturePage)\n      .SetMethod(\"setEmbedder\", &WebContents::SetEmbedder)\n      .SetMethod(\"setDevToolsWebContents\", &WebContents::SetDevToolsWebContents)\n      .SetMethod(\"getNativeView\", &WebContents::GetNativeView)\n      .SetMethod(\"incrementCapturerCount\", &WebContents::IncrementCapturerCount)\n      .SetMethod(\"decrementCapturerCount\", &WebContents::DecrementCapturerCount)\n      .SetMethod(\"isBeingCaptured\", &WebContents::IsBeingCaptured)\n      .SetMethod(\"setWebRTCIPHandlingPolicy\",\n                 &WebContents::SetWebRTCIPHandlingPolicy)\n      .SetMethod(\"getWebRTCIPHandlingPolicy\",\n                 &WebContents::GetWebRTCIPHandlingPolicy)\n      .SetMethod(\"_grantOriginAccess\", &WebContents::GrantOriginAccess)\n      .SetMethod(\"takeHeapSnapshot\", &WebContents::TakeHeapSnapshot)\n      .SetProperty(\"id\", &WebContents::ID)\n      .SetProperty(\"session\", &WebContents::Session)\n      .SetProperty(\"hostWebContents\", &WebContents::HostWebContents)\n      .SetProperty(\"devToolsWebContents\", &WebContents::DevToolsWebContents)\n      .SetProperty(\"debugger\", &WebContents::Debugger)\n      .SetProperty(\"_initiallyShown\", &WebContents::WasInitiallyShown)\n      .SetProperty(\"mainFrame\", &WebContents::MainFrame)\n      .Build();\n}\n\nconst char* WebContents::GetTypeName() {\n  return \"WebContents\";\n}\n\nElectronBrowserContext* WebContents::GetBrowserContext() const {\n  return static_cast<ElectronBrowserContext*>(\n      web_contents()->GetBrowserContext());\n}\n\n// static\ngin::Handle<WebContents> WebContents::New(\n    v8::Isolate* isolate,\n    const gin_helper::Dictionary& options) {\n  gin::Handle<WebContents> handle =\n      gin::CreateHandle(isolate, new WebContents(isolate, options));\n  gin_helper::CallMethod(isolate, handle.get(), \"_init\");\n  return handle;\n}\n\n// static\ngin::Handle<WebContents> WebContents::CreateAndTake(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> web_contents,\n    Type type) {\n  gin::Handle<WebContents> handle = gin::CreateHandle(\n      isolate, new WebContents(isolate, std::move(web_contents), type));\n  gin_helper::CallMethod(isolate, handle.get(), \"_init\");\n  return handle;\n}\n\n// static\nWebContents* WebContents::From(content::WebContents* web_contents) {\n  if (!web_contents)\n    return nullptr;\n  auto* data = static_cast<UserDataLink*>(\n      web_contents->GetUserData(kElectronApiWebContentsKey));\n  return data ? data->web_contents.get() : nullptr;\n}\n\n// static\ngin::Handle<WebContents> WebContents::FromOrCreate(\n    v8::Isolate* isolate,\n    content::WebContents* web_contents) {\n  WebContents* api_web_contents = From(web_contents);\n  if (!api_web_contents) {\n    api_web_contents = new WebContents(isolate, web_contents);\n    gin_helper::CallMethod(isolate, api_web_contents, \"_init\");\n  }\n  return gin::CreateHandle(isolate, api_web_contents);\n}\n\n// static\nWebContents* WebContents::FromID(int32_t id) {\n  return GetAllWebContents().Lookup(id);\n}\n\n// static\ngin::WrapperInfo WebContents::kWrapperInfo = {gin::kEmbedderNativeGin};\n\n}  // namespace api\n\n}  // namespace electron\n\nnamespace {\n\nusing electron::api::GetAllWebContents;\nusing electron::api::WebContents;\n\ngin::Handle<WebContents> WebContentsFromID(v8::Isolate* isolate, int32_t id) {\n  WebContents* contents = WebContents::FromID(id);\n  return contents ? gin::CreateHandle(isolate, contents)\n                  : gin::Handle<WebContents>();\n}\n\nstd::vector<gin::Handle<WebContents>> GetAllWebContentsAsV8(\n    v8::Isolate* isolate) {\n  std::vector<gin::Handle<WebContents>> list;\n  for (auto iter = base::IDMap<WebContents*>::iterator(&GetAllWebContents());\n       !iter.IsAtEnd(); iter.Advance()) {\n    list.push_back(gin::CreateHandle(isolate, iter.GetCurrentValue()));\n  }\n  return list;\n}\n\nvoid Initialize(v8::Local<v8::Object> exports,\n                v8::Local<v8::Value> unused,\n                v8::Local<v8::Context> context,\n                void* priv) {\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary dict(isolate, exports);\n  dict.Set(\"WebContents\", WebContents::GetConstructor(context));\n  dict.SetMethod(\"fromId\", &WebContentsFromID);\n  dict.SetMethod(\"getAllWebContents\", &GetAllWebContentsAsV8);\n}\n\n}  // namespace\n\nNODE_LINKED_MODULE_CONTEXT_AWARE(electron_browser_web_contents, Initialize)\n", "// Copyright (c) 2014 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#ifndef SHELL_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_\n#define SHELL_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_\n\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"base/memory/weak_ptr.h\"\n#include \"base/observer_list.h\"\n#include \"base/observer_list_types.h\"\n#include \"chrome/browser/devtools/devtools_file_system_indexer.h\"\n#include \"content/common/cursors/webcursor.h\"\n#include \"content/common/frame.mojom.h\"\n#include \"content/public/browser/devtools_agent_host.h\"\n#include \"content/public/browser/keyboard_event_processing_result.h\"\n#include \"content/public/browser/render_widget_host.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/browser/web_contents_delegate.h\"\n#include \"content/public/browser/web_contents_observer.h\"\n#include \"electron/buildflags/buildflags.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"gin/handle.h\"\n#include \"gin/wrappable.h\"\n#include \"mojo/public/cpp/bindings/receiver_set.h\"\n#include \"printing/buildflags/buildflags.h\"\n#include \"services/service_manager/public/cpp/binder_registry.h\"\n#include \"shell/browser/api/frame_subscriber.h\"\n#include \"shell/browser/api/save_page_handler.h\"\n#include \"shell/browser/event_emitter_mixin.h\"\n#include \"shell/browser/extended_web_contents_observer.h\"\n#include \"shell/browser/ui/inspectable_web_contents.h\"\n#include \"shell/browser/ui/inspectable_web_contents_delegate.h\"\n#include \"shell/browser/ui/inspectable_web_contents_view_delegate.h\"\n#include \"shell/common/gin_helper/cleaned_up_at_exit.h\"\n#include \"shell/common/gin_helper/constructible.h\"\n#include \"shell/common/gin_helper/error_thrower.h\"\n#include \"ui/gfx/image/image.h\"\n\n#if BUILDFLAG(ENABLE_PRINTING)\n#include \"chrome/browser/printing/print_view_manager_basic.h\"\n#include \"components/printing/common/print_messages.h\"\n#include \"shell/browser/printing/print_preview_message_handler.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n#include \"extensions/common/view_type.h\"\n\nnamespace extensions {\nclass ScriptExecutor;\n}\n#endif\n\nnamespace blink {\nstruct DeviceEmulationParams;\n}\n\nnamespace gin_helper {\nclass Dictionary;\n}\n\nnamespace network {\nclass ResourceRequestBody;\n}\n\nnamespace gin {\nclass Arguments;\n}\n\nnamespace electron {\n\nclass ElectronBrowserContext;\nclass ElectronJavaScriptDialogManager;\nclass InspectableWebContents;\nclass WebContentsZoomController;\nclass WebViewGuestDelegate;\nclass FrameSubscriber;\nclass WebDialogHelper;\nclass NativeWindow;\n\n#if BUILDFLAG(ENABLE_OSR)\nclass OffScreenRenderWidgetHostView;\nclass OffScreenWebContentsView;\n#endif\n\nnamespace api {\n\n// Wrapper around the content::WebContents.\nclass WebContents : public gin::Wrappable<WebContents>,\n                    public gin_helper::EventEmitterMixin<WebContents>,\n                    public gin_helper::Constructible<WebContents>,\n                    public gin_helper::CleanedUpAtExit,\n                    public content::WebContentsObserver,\n                    public content::WebContentsDelegate,\n                    public InspectableWebContentsDelegate,\n                    public InspectableWebContentsViewDelegate,\n                    public mojom::ElectronBrowser {\n public:\n  enum class Type {\n    kBackgroundPage,  // An extension background page.\n    kBrowserWindow,   // Used by BrowserWindow.\n    kBrowserView,     // Used by BrowserView.\n    kRemote,          // Thin wrap around an existing WebContents.\n    kWebView,         // Used by <webview>.\n    kOffScreen,       // Used for offscreen rendering\n  };\n\n  // Create a new WebContents and return the V8 wrapper of it.\n  static gin::Handle<WebContents> New(v8::Isolate* isolate,\n                                      const gin_helper::Dictionary& options);\n\n  // Create a new V8 wrapper for an existing |web_content|.\n  //\n  // The lifetime of |web_contents| will be managed by this class.\n  static gin::Handle<WebContents> CreateAndTake(\n      v8::Isolate* isolate,\n      std::unique_ptr<content::WebContents> web_contents,\n      Type type);\n\n  // Get the api::WebContents associated with |web_contents|. Returns nullptr\n  // if there is no associated wrapper.\n  static WebContents* From(content::WebContents* web_contents);\n  static WebContents* FromID(int32_t id);\n\n  // Get the V8 wrapper of the |web_contents|, or create one if not existed.\n  //\n  // The lifetime of |web_contents| is NOT managed by this class, and the type\n  // of this wrapper is always REMOTE.\n  static gin::Handle<WebContents> FromOrCreate(\n      v8::Isolate* isolate,\n      content::WebContents* web_contents);\n\n  // gin::Wrappable\n  static gin::WrapperInfo kWrapperInfo;\n  static v8::Local<v8::ObjectTemplate> FillObjectTemplate(\n      v8::Isolate*,\n      v8::Local<v8::ObjectTemplate>);\n  const char* GetTypeName() override;\n\n  base::WeakPtr<WebContents> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }\n\n  // Destroy the managed content::WebContents instance.\n  //\n  // Note: The |async| should only be |true| when users are expecting to use the\n  // webContents immediately after the call. Always pass |false| if you are not\n  // sure.\n  // See https://github.com/electron/electron/issues/8930.\n  //\n  // Note: When destroying a webContents member inside a destructor, the |async|\n  // should always be |false|, otherwise the destroy task might be delayed after\n  // normal shutdown procedure, resulting in an assertion.\n  // The normal pattern for calling this method in destructor is:\n  // api_web_contents_->DestroyWebContents(!Browser::Get()->is_shutting_down())\n  // See https://github.com/electron/electron/issues/15133.\n  void DestroyWebContents(bool async);\n\n  bool GetBackgroundThrottling() const;\n  void SetBackgroundThrottling(bool allowed);\n  int GetProcessID() const;\n  base::ProcessId GetOSProcessID() const;\n  Type GetType() const;\n  bool Equal(const WebContents* web_contents) const;\n  void LoadURL(const GURL& url, const gin_helper::Dictionary& options);\n  void DownloadURL(const GURL& url);\n  GURL GetURL() const;\n  base::string16 GetTitle() const;\n  bool IsLoading() const;\n  bool IsLoadingMainFrame() const;\n  bool IsWaitingForResponse() const;\n  void Stop();\n  void ReloadIgnoringCache();\n  void GoBack();\n  void GoForward();\n  void GoToOffset(int offset);\n  const std::string GetWebRTCIPHandlingPolicy() const;\n  void SetWebRTCIPHandlingPolicy(const std::string& webrtc_ip_handling_policy);\n  bool IsCrashed() const;\n  void ForcefullyCrashRenderer();\n  void SetUserAgent(const std::string& user_agent);\n  std::string GetUserAgent();\n  void InsertCSS(const std::string& css);\n  v8::Local<v8::Promise> SavePage(const base::FilePath& full_file_path,\n                                  const content::SavePageType& save_type);\n  void OpenDevTools(gin::Arguments* args);\n  void CloseDevTools();\n  bool IsDevToolsOpened();\n  bool IsDevToolsFocused();\n  void ToggleDevTools();\n  void EnableDeviceEmulation(const blink::DeviceEmulationParams& params);\n  void DisableDeviceEmulation();\n  void InspectElement(int x, int y);\n  void InspectSharedWorker();\n  void InspectSharedWorkerById(const std::string& workerId);\n  std::vector<scoped_refptr<content::DevToolsAgentHost>> GetAllSharedWorkers();\n  void InspectServiceWorker();\n  void SetIgnoreMenuShortcuts(bool ignore);\n  void SetAudioMuted(bool muted);\n  bool IsAudioMuted();\n  bool IsCurrentlyAudible();\n  void SetEmbedder(const WebContents* embedder);\n  void SetDevToolsWebContents(const WebContents* devtools);\n  v8::Local<v8::Value> GetNativeView(v8::Isolate* isolate) const;\n  void IncrementCapturerCount(gin::Arguments* args);\n  void DecrementCapturerCount(gin::Arguments* args);\n  bool IsBeingCaptured();\n\n#if BUILDFLAG(ENABLE_PRINTING)\n  void OnGetDefaultPrinter(base::Value print_settings,\n                           printing::CompletionCallback print_callback,\n                           base::string16 device_name,\n                           bool silent,\n                           base::string16 default_printer);\n  void Print(gin::Arguments* args);\n  // Print current page as PDF.\n  v8::Local<v8::Promise> PrintToPDF(base::DictionaryValue settings);\n#endif\n\n  void SetNextChildWebPreferences(const gin_helper::Dictionary);\n\n  // DevTools workspace api.\n  void AddWorkSpace(gin::Arguments* args, const base::FilePath& path);\n  void RemoveWorkSpace(gin::Arguments* args, const base::FilePath& path);\n\n  // Editing commands.\n  void Undo();\n  void Redo();\n  void Cut();\n  void Copy();\n  void Paste();\n  void PasteAndMatchStyle();\n  void Delete();\n  void SelectAll();\n  void Unselect();\n  void Replace(const base::string16& word);\n  void ReplaceMisspelling(const base::string16& word);\n  uint32_t FindInPage(gin::Arguments* args);\n  void StopFindInPage(content::StopFindAction action);\n  void ShowDefinitionForSelection();\n  void CopyImageAt(int x, int y);\n\n  // Focus.\n  void Focus();\n  bool IsFocused() const;\n\n  // Send messages to browser.\n  bool SendIPCMessage(bool internal,\n                      const std::string& channel,\n                      v8::Local<v8::Value> args);\n\n  bool SendIPCMessageWithSender(bool internal,\n                                const std::string& channel,\n                                blink::CloneableMessage args,\n                                int32_t sender_id = 0);\n\n  bool SendIPCMessageToFrame(bool internal,\n                             int32_t frame_id,\n                             const std::string& channel,\n                             v8::Local<v8::Value> args);\n\n  void PostMessage(const std::string& channel,\n                   v8::Local<v8::Value> message,\n                   base::Optional<v8::Local<v8::Value>> transfer);\n\n  // Send WebInputEvent to the page.\n  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);\n\n  // Subscribe to the frame updates.\n  void BeginFrameSubscription(gin::Arguments* args);\n  void EndFrameSubscription();\n\n  // Dragging native items.\n  void StartDrag(const gin_helper::Dictionary& item, gin::Arguments* args);\n\n  // Captures the page with |rect|, |callback| would be called when capturing is\n  // done.\n  v8::Local<v8::Promise> CapturePage(gin::Arguments* args);\n\n  // Methods for creating <webview>.\n  bool IsGuest() const;\n  void AttachToIframe(content::WebContents* embedder_web_contents,\n                      int embedder_frame_id);\n  void DetachFromOuterFrame();\n\n  // Methods for offscreen rendering\n  bool IsOffScreen() const;\n#if BUILDFLAG(ENABLE_OSR)\n  void OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap);\n  void StartPainting();\n  void StopPainting();\n  bool IsPainting() const;\n  void SetFrameRate(int frame_rate);\n  int GetFrameRate() const;\n#endif\n  void Invalidate();\n  gfx::Size GetSizeForNewRenderView(content::WebContents*) override;\n\n  // Methods for zoom handling.\n  void SetZoomLevel(double level);\n  double GetZoomLevel() const;\n  void SetZoomFactor(gin_helper::ErrorThrower thrower, double factor);\n  double GetZoomFactor() const;\n\n  // Callback triggered on permission response.\n  void OnEnterFullscreenModeForTab(\n      content::RenderFrameHost* requesting_frame,\n      const blink::mojom::FullscreenOptions& options,\n      bool allowed);\n\n  // Create window with the given disposition.\n  void OnCreateWindow(const GURL& target_url,\n                      const content::Referrer& referrer,\n                      const std::string& frame_name,\n                      WindowOpenDisposition disposition,\n                      const std::string& features,\n                      const scoped_refptr<network::ResourceRequestBody>& body);\n\n  // Returns the preload script path of current WebContents.\n  std::vector<base::FilePath> GetPreloadPaths() const;\n\n  // Returns the web preferences of current WebContents.\n  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate) const;\n  v8::Local<v8::Value> GetLastWebPreferences(v8::Isolate* isolate) const;\n\n  // Returns the owner window.\n  v8::Local<v8::Value> GetOwnerBrowserWindow(v8::Isolate* isolate) const;\n\n  // Grants the child process the capability to access URLs with the origin of\n  // the specified URL.\n  void GrantOriginAccess(const GURL& url);\n\n  // Notifies the web page that there is user interaction.\n  void NotifyUserActivation();\n\n  v8::Local<v8::Promise> TakeHeapSnapshot(v8::Isolate* isolate,\n                                          const base::FilePath& file_path);\n\n  // Properties.\n  int32_t ID() const { return id_; }\n  v8::Local<v8::Value> Session(v8::Isolate* isolate);\n  content::WebContents* HostWebContents() const;\n  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);\n  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);\n  bool WasInitiallyShown();\n  content::RenderFrameHost* MainFrame();\n\n  WebContentsZoomController* GetZoomController() { return zoom_controller_; }\n\n  void AddObserver(ExtendedWebContentsObserver* obs) {\n    observers_.AddObserver(obs);\n  }\n  void RemoveObserver(ExtendedWebContentsObserver* obs) {\n    // Trying to remove from an empty collection leads to an access violation\n    if (observers_.might_have_observers())\n      observers_.RemoveObserver(obs);\n  }\n\n  bool EmitNavigationEvent(const std::string& event,\n                           content::NavigationHandle* navigation_handle);\n\n  // this.emit(name, new Event(sender, message), args...);\n  template <typename... Args>\n  bool EmitWithSender(base::StringPiece name,\n                      content::RenderFrameHost* sender,\n                      electron::mojom::ElectronBrowser::InvokeCallback callback,\n                      Args&&... args) {\n    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n    v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Object> wrapper;\n    if (!GetWrapper(isolate).ToLocal(&wrapper))\n      return false;\n    v8::Local<v8::Object> event = gin_helper::internal::CreateNativeEvent(\n        isolate, wrapper, sender, std::move(callback));\n    return EmitCustomEvent(name, event, std::forward<Args>(args)...);\n  }\n\n  void MarkDestroyed();\n\n  WebContents* embedder() { return embedder_; }\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ScriptExecutor* script_executor() {\n    return script_executor_.get();\n  }\n#endif\n\n  // Set the window as owner window.\n  void SetOwnerWindow(NativeWindow* owner_window);\n  void SetOwnerWindow(content::WebContents* web_contents,\n                      NativeWindow* owner_window);\n\n  // Returns the WebContents managed by this delegate.\n  content::WebContents* GetWebContents() const;\n\n  // Returns the WebContents of devtools.\n  content::WebContents* GetDevToolsWebContents() const;\n\n  InspectableWebContents* inspectable_web_contents() const {\n    return inspectable_web_contents_.get();\n  }\n\n  NativeWindow* owner_window() const { return owner_window_.get(); }\n\n  bool is_html_fullscreen() const { return html_fullscreen_; }\n\n  void set_fullscreen_frame(content::RenderFrameHost* rfh) {\n    fullscreen_frame_ = rfh;\n  }\n\n private:\n  // Does not manage lifetime of |web_contents|.\n  WebContents(v8::Isolate* isolate, content::WebContents* web_contents);\n  // Takes over ownership of |web_contents|.\n  WebContents(v8::Isolate* isolate,\n              std::unique_ptr<content::WebContents> web_contents,\n              Type type);\n  // Creates a new content::WebContents.\n  WebContents(v8::Isolate* isolate, const gin_helper::Dictionary& options);\n  ~WebContents() override;\n\n  // Creates a InspectableWebContents object and takes ownership of\n  // |web_contents|.\n  void InitWithWebContents(content::WebContents* web_contents,\n                           ElectronBrowserContext* browser_context,\n                           bool is_guest);\n\n  void InitWithSessionAndOptions(\n      v8::Isolate* isolate,\n      std::unique_ptr<content::WebContents> web_contents,\n      gin::Handle<class Session> session,\n      const gin_helper::Dictionary& options);\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  void InitWithExtensionView(v8::Isolate* isolate,\n                             content::WebContents* web_contents,\n                             extensions::ViewType view_type);\n#endif\n\n  // content::WebContentsDelegate:\n  bool DidAddMessageToConsole(content::WebContents* source,\n                              blink::mojom::ConsoleMessageLevel level,\n                              const base::string16& message,\n                              int32_t line_no,\n                              const base::string16& source_id) override;\n  bool IsWebContentsCreationOverridden(\n      content::SiteInstance* source_site_instance,\n      content::mojom::WindowContainerType window_container_type,\n      const GURL& opener_url,\n      const content::mojom::CreateNewWindowParams& params) override;\n  content::WebContents* CreateCustomWebContents(\n      content::RenderFrameHost* opener,\n      content::SiteInstance* source_site_instance,\n      bool is_new_browsing_instance,\n      const GURL& opener_url,\n      const std::string& frame_name,\n      const GURL& target_url,\n      const std::string& partition_id,\n      content::SessionStorageNamespace* session_storage_namespace) override;\n  void WebContentsCreatedWithFullParams(\n      content::WebContents* source_contents,\n      int opener_render_process_id,\n      int opener_render_frame_id,\n      const content::mojom::CreateNewWindowParams& params,\n      content::WebContents* new_contents) override;\n  void AddNewContents(content::WebContents* source,\n                      std::unique_ptr<content::WebContents> new_contents,\n                      const GURL& target_url,\n                      WindowOpenDisposition disposition,\n                      const gfx::Rect& initial_rect,\n                      bool user_gesture,\n                      bool* was_blocked) override;\n  content::WebContents* OpenURLFromTab(\n      content::WebContents* source,\n      const content::OpenURLParams& params) override;\n  void BeforeUnloadFired(content::WebContents* tab,\n                         bool proceed,\n                         bool* proceed_to_fire_unload) override;\n  void SetContentsBounds(content::WebContents* source,\n                         const gfx::Rect& pos) override;\n  void CloseContents(content::WebContents* source) override;\n  void ActivateContents(content::WebContents* contents) override;\n  void UpdateTargetURL(content::WebContents* source, const GURL& url) override;\n  bool HandleKeyboardEvent(\n      content::WebContents* source,\n      const content::NativeWebKeyboardEvent& event) override;\n  bool PlatformHandleKeyboardEvent(\n      content::WebContents* source,\n      const content::NativeWebKeyboardEvent& event);\n  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(\n      content::WebContents* source,\n      const content::NativeWebKeyboardEvent& event) override;\n  void ContentsZoomChange(bool zoom_in) override;\n  void EnterFullscreenModeForTab(\n      content::RenderFrameHost* requesting_frame,\n      const blink::mojom::FullscreenOptions& options) override;\n  void ExitFullscreenModeForTab(content::WebContents* source) override;\n  void RendererUnresponsive(\n      content::WebContents* source,\n      content::RenderWidgetHost* render_widget_host,\n      base::RepeatingClosure hang_monitor_restarter) override;\n  void RendererResponsive(\n      content::WebContents* source,\n      content::RenderWidgetHost* render_widget_host) override;\n  bool HandleContextMenu(content::RenderFrameHost* render_frame_host,\n                         const content::ContextMenuParams& params) override;\n  bool OnGoToEntryOffset(int offset) override;\n  void FindReply(content::WebContents* web_contents,\n                 int request_id,\n                 int number_of_matches,\n                 const gfx::Rect& selection_rect,\n                 int active_match_ordinal,\n                 bool final_update) override;\n  bool CheckMediaAccessPermission(content::RenderFrameHost* render_frame_host,\n                                  const GURL& security_origin,\n                                  blink::mojom::MediaStreamType type) override;\n  void RequestMediaAccessPermission(\n      content::WebContents* web_contents,\n      const content::MediaStreamRequest& request,\n      content::MediaResponseCallback callback) override;\n  void RequestToLockMouse(content::WebContents* web_contents,\n                          bool user_gesture,\n                          bool last_unlocked_by_target) override;\n  content::JavaScriptDialogManager* GetJavaScriptDialogManager(\n      content::WebContents* source) override;\n  void OnAudioStateChanged(bool audible) override;\n  void UpdatePreferredSize(content::WebContents* web_contents,\n                           const gfx::Size& pref_size) override;\n\n  // content::WebContentsObserver:\n  void BeforeUnloadFired(bool proceed,\n                         const base::TimeTicks& proceed_time) override;\n  void RenderViewCreated(content::RenderViewHost* render_view_host) override;\n  void RenderFrameCreated(content::RenderFrameHost* render_frame_host) override;\n  void RenderViewDeleted(content::RenderViewHost*) override;\n  void RenderProcessGone(base::TerminationStatus status) override;\n  void RenderFrameDeleted(content::RenderFrameHost* render_frame_host) override;\n  void DOMContentLoaded(content::RenderFrameHost* render_frame_host) override;\n  void DidFinishLoad(content::RenderFrameHost* render_frame_host,\n                     const GURL& validated_url) override;\n  void DidFailLoad(content::RenderFrameHost* render_frame_host,\n                   const GURL& validated_url,\n                   int error_code) override;\n  void DidStartLoading() override;\n  void DidStopLoading() override;\n  void DidStartNavigation(\n      content::NavigationHandle* navigation_handle) override;\n  void DidRedirectNavigation(\n      content::NavigationHandle* navigation_handle) override;\n  void DidFinishNavigation(\n      content::NavigationHandle* navigation_handle) override;\n  bool OnMessageReceived(const IPC::Message& message) override;\n  void WebContentsDestroyed() override;\n  void NavigationEntryCommitted(\n      const content::LoadCommittedDetails& load_details) override;\n  void TitleWasSet(content::NavigationEntry* entry) override;\n  void DidUpdateFaviconURL(\n      content::RenderFrameHost* render_frame_host,\n      const std::vector<blink::mojom::FaviconURLPtr>& urls) override;\n  void PluginCrashed(const base::FilePath& plugin_path,\n                     base::ProcessId plugin_pid) override;\n  void MediaStartedPlaying(const MediaPlayerInfo& video_type,\n                           const content::MediaPlayerId& id) override;\n  void MediaStoppedPlaying(\n      const MediaPlayerInfo& video_type,\n      const content::MediaPlayerId& id,\n      content::WebContentsObserver::MediaStoppedReason reason) override;\n  void DidChangeThemeColor() override;\n  void OnInterfaceRequestFromFrame(\n      content::RenderFrameHost* render_frame_host,\n      const std::string& interface_name,\n      mojo::ScopedMessagePipeHandle* interface_pipe) override;\n  void OnCursorChanged(const content::WebCursor& cursor) override;\n  void DidAcquireFullscreen(content::RenderFrameHost* rfh) override;\n\n  // InspectableWebContentsDelegate:\n  void DevToolsReloadPage() override;\n\n  // InspectableWebContentsViewDelegate:\n  void DevToolsFocused() override;\n  void DevToolsOpened() override;\n  void DevToolsClosed() override;\n  void DevToolsResized() override;\n\n  ElectronBrowserContext* GetBrowserContext() const;\n\n  // Binds the given request for the ElectronBrowser API. When the\n  // RenderFrameHost is destroyed, all related bindings will be removed.\n  void BindElectronBrowser(\n      mojo::PendingReceiver<mojom::ElectronBrowser> receiver,\n      content::RenderFrameHost* render_frame_host);\n  void OnElectronBrowserConnectionError();\n\n#if BUILDFLAG(ENABLE_OSR)\n  OffScreenWebContentsView* GetOffScreenWebContentsView() const;\n  OffScreenRenderWidgetHostView* GetOffScreenRenderWidgetHostView() const;\n#endif\n\n  // mojom::ElectronBrowser\n  void Message(bool internal,\n               const std::string& channel,\n               blink::CloneableMessage arguments) override;\n  void Invoke(bool internal,\n              const std::string& channel,\n              blink::CloneableMessage arguments,\n              InvokeCallback callback) override;\n  void OnFirstNonEmptyLayout() override;\n  void ReceivePostMessage(const std::string& channel,\n                          blink::TransferableMessage message) override;\n  void MessageSync(bool internal,\n                   const std::string& channel,\n                   blink::CloneableMessage arguments,\n                   MessageSyncCallback callback) override;\n  void MessageTo(bool internal,\n                 int32_t web_contents_id,\n                 const std::string& channel,\n                 blink::CloneableMessage arguments) override;\n  void MessageHost(const std::string& channel,\n                   blink::CloneableMessage arguments) override;\n  void UpdateDraggableRegions(\n      std::vector<mojom::DraggableRegionPtr> regions) override;\n  void SetTemporaryZoomLevel(double level) override;\n  void DoGetZoomLevel(DoGetZoomLevelCallback callback) override;\n\n  // Called when received a synchronous message from renderer to\n  // get the zoom level.\n  void OnGetZoomLevel(content::RenderFrameHost* frame_host,\n                      IPC::Message* reply_msg);\n\n  void InitZoomController(content::WebContents* web_contents,\n                          const gin_helper::Dictionary& options);\n\n  // content::WebContentsDelegate:\n  bool CanOverscrollContent() override;\n  content::ColorChooser* OpenColorChooser(\n      content::WebContents* web_contents,\n      SkColor color,\n      const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions)\n      override;\n  void RunFileChooser(content::RenderFrameHost* render_frame_host,\n                      scoped_refptr<content::FileSelectListener> listener,\n                      const blink::mojom::FileChooserParams& params) override;\n  void EnumerateDirectory(content::WebContents* web_contents,\n                          scoped_refptr<content::FileSelectListener> listener,\n                          const base::FilePath& path) override;\n  bool IsFullscreenForTabOrPending(const content::WebContents* source) override;\n  blink::SecurityStyle GetSecurityStyle(\n      content::WebContents* web_contents,\n      content::SecurityStyleExplanations* explanations) override;\n  bool TakeFocus(content::WebContents* source, bool reverse) override;\n  content::PictureInPictureResult EnterPictureInPicture(\n      content::WebContents* web_contents,\n      const viz::SurfaceId&,\n      const gfx::Size& natural_size) override;\n  void ExitPictureInPicture() override;\n\n  // InspectableWebContentsDelegate:\n  void DevToolsSaveToFile(const std::string& url,\n                          const std::string& content,\n                          bool save_as) override;\n  void DevToolsAppendToFile(const std::string& url,\n                            const std::string& content) override;\n  void DevToolsRequestFileSystems() override;\n  void DevToolsAddFileSystem(const std::string& type,\n                             const base::FilePath& file_system_path) override;\n  void DevToolsRemoveFileSystem(\n      const base::FilePath& file_system_path) override;\n  void DevToolsIndexPath(int request_id,\n                         const std::string& file_system_path,\n                         const std::string& excluded_folders_message) override;\n  void DevToolsStopIndexing(int request_id) override;\n  void DevToolsSearchInPath(int request_id,\n                            const std::string& file_system_path,\n                            const std::string& query) override;\n\n  // InspectableWebContentsViewDelegate:\n#if defined(TOOLKIT_VIEWS) && !defined(OS_MAC)\n  gfx::ImageSkia GetDevToolsWindowIcon() override;\n#endif\n#if defined(OS_LINUX)\n  void GetDevToolsWindowWMClass(std::string* name,\n                                std::string* class_name) override;\n#endif\n\n  // Destroy the managed InspectableWebContents object.\n  void ResetManagedWebContents(bool async);\n\n  // DevTools index event callbacks.\n  void OnDevToolsIndexingWorkCalculated(int request_id,\n                                        const std::string& file_system_path,\n                                        int total_work);\n  void OnDevToolsIndexingWorked(int request_id,\n                                const std::string& file_system_path,\n                                int worked);\n  void OnDevToolsIndexingDone(int request_id,\n                              const std::string& file_system_path);\n  void OnDevToolsSearchCompleted(int request_id,\n                                 const std::string& file_system_path,\n                                 const std::vector<std::string>& file_paths);\n\n  // Set fullscreen mode triggered by html api.\n  void SetHtmlApiFullscreen(bool enter_fullscreen);\n\n  v8::Global<v8::Value> session_;\n  v8::Global<v8::Value> devtools_web_contents_;\n  v8::Global<v8::Value> debugger_;\n\n  std::unique_ptr<ElectronJavaScriptDialogManager> dialog_manager_;\n  std::unique_ptr<WebViewGuestDelegate> guest_delegate_;\n  std::unique_ptr<FrameSubscriber> frame_subscriber_;\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  std::unique_ptr<extensions::ScriptExecutor> script_executor_;\n#endif\n\n  // The host webcontents that may contain this webcontents.\n  WebContents* embedder_ = nullptr;\n\n  // The zoom controller for this webContents.\n  WebContentsZoomController* zoom_controller_ = nullptr;\n\n  // The type of current WebContents.\n  Type type_ = Type::kBrowserWindow;\n\n  int32_t id_;\n\n  // Request id used for findInPage request.\n  uint32_t find_in_page_request_id_ = 0;\n\n  // Whether background throttling is disabled.\n  bool background_throttling_ = true;\n\n  // Whether to enable devtools.\n  bool enable_devtools_ = true;\n\n  // Observers of this WebContents.\n  base::ObserverList<ExtendedWebContentsObserver> observers_;\n\n  v8::Global<v8::Value> pending_child_web_preferences_;\n\n  bool initially_shown_ = true;\n\n  // The window that this WebContents belongs to.\n  base::WeakPtr<NativeWindow> owner_window_;\n\n  bool offscreen_ = false;\n\n  // Whether window is fullscreened by HTML5 api.\n  bool html_fullscreen_ = false;\n\n  // Whether window is fullscreened by window api.\n  bool native_fullscreen_ = false;\n\n  // UI related helper classes.\n  std::unique_ptr<WebDialogHelper> web_dialog_helper_;\n\n  scoped_refptr<DevToolsFileSystemIndexer> devtools_file_system_indexer_;\n\n  ElectronBrowserContext* browser_context_;\n\n  // The stored InspectableWebContents object.\n  // Notice that inspectable_web_contents_ must be placed after\n  // dialog_manager_, so we can make sure inspectable_web_contents_ is\n  // destroyed before dialog_manager_, otherwise a crash would happen.\n  std::unique_ptr<InspectableWebContents> inspectable_web_contents_;\n\n  // Maps url to file path, used by the file requests sent from devtools.\n  typedef std::map<std::string, base::FilePath> PathsMap;\n  PathsMap saved_files_;\n\n  // Map id to index job, used for file system indexing requests from devtools.\n  typedef std::\n      map<int, scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>>\n          DevToolsIndexingJobsMap;\n  DevToolsIndexingJobsMap devtools_indexing_jobs_;\n\n  scoped_refptr<base::SequencedTaskRunner> file_task_runner_;\n\n  // Stores the frame thats currently in fullscreen, nullptr if there is none.\n  content::RenderFrameHost* fullscreen_frame_ = nullptr;\n\n  service_manager::BinderRegistryWithArgs<content::RenderFrameHost*> registry_;\n  mojo::ReceiverSet<mojom::ElectronBrowser, content::RenderFrameHost*>\n      receivers_;\n  std::map<content::RenderFrameHost*, std::vector<mojo::ReceiverId>>\n      frame_to_receivers_map_;\n\n  base::WeakPtrFactory<WebContents> weak_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(WebContents);\n};\n\n}  // namespace api\n\n}  // namespace electron\n\n#endif  // SHELL_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_\n", "// Copyright (c) 2019 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/common/gin_helper/event_emitter.h\"\n\n#include \"content/public/browser/render_frame_host.h\"\n#include \"shell/browser/api/event.h\"\n#include \"shell/common/gin_helper/dictionary.h\"\n#include \"shell/common/gin_helper/object_template_builder.h\"\n\nnamespace gin_helper {\n\nnamespace internal {\n\nnamespace {\n\nv8::Persistent<v8::ObjectTemplate> event_template;\n\nvoid PreventDefault(gin_helper::Arguments* args) {\n  Dictionary self;\n  if (args->GetHolder(&self))\n    self.Set(\"defaultPrevented\", true);\n}\n\n}  // namespace\n\nv8::Local<v8::Object> CreateEvent(v8::Isolate* isolate,\n                                  v8::Local<v8::Object> sender,\n                                  v8::Local<v8::Object> custom_event) {\n  if (event_template.IsEmpty()) {\n    event_template.Reset(\n        isolate,\n        ObjectTemplateBuilder(isolate, v8::ObjectTemplate::New(isolate))\n            .SetMethod(\"preventDefault\", &PreventDefault)\n            .Build());\n  }\n\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  CHECK(!context.IsEmpty());\n  v8::Local<v8::Object> event =\n      v8::Local<v8::ObjectTemplate>::New(isolate, event_template)\n          ->NewInstance(context)\n          .ToLocalChecked();\n  if (!sender.IsEmpty())\n    Dictionary(isolate, event).Set(\"sender\", sender);\n  if (!custom_event.IsEmpty())\n    event->SetPrototype(context, custom_event).IsJust();\n  return event;\n}\n\nv8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame)\n    dict.Set(\"frameId\", frame->GetRoutingID());\n  return event;\n}\n\n}  // namespace internal\n\n}  // namespace gin_helper\n", "import { expect } from 'chai';\nimport * as path from 'path';\nimport * as cp from 'child_process';\nimport { closeAllWindows } from './window-helpers';\nimport { emittedOnce } from './events-helpers';\nimport { ipcMain, BrowserWindow } from 'electron/main';\n\ndescribe('ipc main module', () => {\n  const fixtures = path.join(__dirname, 'fixtures');\n\n  afterEach(closeAllWindows);\n\n  describe('ipc.sendSync', () => {\n    afterEach(() => { ipcMain.removeAllListeners('send-sync-message'); });\n\n    it('does not crash when reply is not sent and browser is destroyed', (done) => {\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      ipcMain.once('send-sync-message', (event) => {\n        event.returnValue = null;\n        done();\n      });\n      w.loadFile(path.join(fixtures, 'api', 'send-sync-message.html'));\n    });\n\n    it('does not crash when reply is sent by multiple listeners', (done) => {\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      ipcMain.on('send-sync-message', (event) => {\n        event.returnValue = null;\n      });\n      ipcMain.on('send-sync-message', (event) => {\n        event.returnValue = null;\n        done();\n      });\n      w.loadFile(path.join(fixtures, 'api', 'send-sync-message.html'));\n    });\n  });\n\n  describe('ipcMain.on', () => {\n    it('is not used for internals', async () => {\n      const appPath = path.join(fixtures, 'api', 'ipc-main-listeners');\n      const electronPath = process.execPath;\n      const appProcess = cp.spawn(electronPath, [appPath]);\n\n      let output = '';\n      appProcess.stdout.on('data', (data) => { output += data; });\n\n      await emittedOnce(appProcess.stdout, 'end');\n\n      output = JSON.parse(output);\n      expect(output).to.deep.equal(['error']);\n    });\n  });\n});\n", "[\n  [\n    \"top=5,left=10,resizable=no\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"top\": 5,\n      \"left\": 10,\n      \"resizable\": false,\n      \"x\": 10,\n      \"y\": 5,\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"zoomFactor=2,resizable=0,x=0,y=10\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"resizable\": false,\n      \"x\": 0,\n      \"y\": 10,\n      \"webPreferences\": {\n        \"zoomFactor\": \"2\",\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"backgroundColor=gray,webPreferences=0,x=100,y=100\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"backgroundColor\": \"gray\",\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\",\n        \"backgroundColor\": \"gray\"\n      },\n      \"x\": 100,\n      \"y\": 100,\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"x=50,y=20,title=sup\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"sup\",\n      \"width\": 800,\n      \"height\": 600,\n      \"x\": 50,\n      \"y\": 20,\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"show=false,top=1,left=1\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": false,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"top\": 1,\n      \"left\": 1,\n      \"x\": 1,\n      \"y\": 1,\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ]\n]", "import { BrowserWindow } from 'electron';\nimport { writeFileSync, readFileSync } from 'fs';\nimport { resolve } from 'path';\nimport { expect, assert } from 'chai';\nimport { closeAllWindows } from './window-helpers';\nconst { emittedOnce } = require('./events-helpers');\n\nfunction genSnapshot (browserWindow: BrowserWindow, features: string) {\n  return new Promise((resolve) => {\n    browserWindow.webContents.on('new-window', (...args: any[]) => {\n      resolve([features, ...args]);\n    });\n    browserWindow.webContents.executeJavaScript(`window.open('about:blank', 'frame name', '${features}') && true`);\n  });\n}\n\ndescribe('new-window event', () => {\n  const testConfig = {\n    native: {\n      snapshotFileName: 'native-window-open.snapshot.txt',\n      browserWindowOptions: {\n        show: false,\n        width: 200,\n        title: 'cool',\n        backgroundColor: 'blue',\n        focusable: false,\n        webPreferences: {\n          nativeWindowOpen: true,\n          sandbox: true\n        }\n      }\n    },\n    proxy: {\n      snapshotFileName: 'proxy-window-open.snapshot.txt',\n      browserWindowOptions: {\n        show: false\n      }\n    }\n  };\n\n  for (const testName of Object.keys(testConfig) as (keyof typeof testConfig)[]) {\n    const { snapshotFileName, browserWindowOptions } = testConfig[testName];\n\n    describe(`for ${testName} window opening`, () => {\n      const snapshotFile = resolve(__dirname, 'fixtures', 'snapshots', snapshotFileName);\n      let browserWindow: BrowserWindow;\n      let existingSnapshots: any[];\n\n      before(() => {\n        existingSnapshots = parseSnapshots(readFileSync(snapshotFile, { encoding: 'utf8' }));\n      });\n\n      beforeEach((done) => {\n        browserWindow = new BrowserWindow(browserWindowOptions);\n        browserWindow.loadURL('about:blank');\n        browserWindow.on('ready-to-show', () => { done(); });\n      });\n\n      afterEach(closeAllWindows);\n\n      const newSnapshots: any[] = [];\n      [\n        'top=5,left=10,resizable=no',\n        'zoomFactor=2,resizable=0,x=0,y=10',\n        'backgroundColor=gray,webPreferences=0,x=100,y=100',\n        'x=50,y=20,title=sup',\n        'show=false,top=1,left=1'\n      ].forEach((features, index) => {\n        /**\n         * ATTN: If this test is failing, you likely just need to change\n         * `shouldOverwriteSnapshot` to true and then evaluate the snapshot diff\n         * to see if the change is harmless.\n         */\n        it(`matches snapshot for ${features}`, async () => {\n          const newSnapshot = await genSnapshot(browserWindow, features);\n          newSnapshots.push(newSnapshot);\n          // TODO: The output when these fail could be friendlier.\n          expect(stringifySnapshots(newSnapshot)).to.equal(stringifySnapshots(existingSnapshots[index]));\n        });\n      });\n\n      after(() => {\n        const shouldOverwriteSnapshot = false;\n        if (shouldOverwriteSnapshot) writeFileSync(snapshotFile, stringifySnapshots(newSnapshots, true));\n      });\n    });\n  }\n});\n\ndescribe('webContents.setWindowOpenHandler', () => {\n  const testConfig = {\n    native: {\n      browserWindowOptions: {\n        show: false,\n        webPreferences: {\n          nativeWindowOpen: true\n        }\n      }\n    },\n    proxy: {\n      browserWindowOptions: {\n        show: false,\n        webPreferences: {\n          nativeWindowOpen: false\n        }\n      }\n    }\n  };\n\n  for (const testName of Object.keys(testConfig) as (keyof typeof testConfig)[]) {\n    let browserWindow: BrowserWindow;\n    const { browserWindowOptions } = testConfig[testName];\n\n    describe(testName, () => {\n      beforeEach((done) => {\n        browserWindow = new BrowserWindow(browserWindowOptions);\n        browserWindow.loadURL('about:blank');\n        browserWindow.on('ready-to-show', () => { browserWindow.show(); done(); });\n      });\n\n      afterEach(closeAllWindows);\n\n      it('does not fire window creation events if an override returns action: deny', (done) => {\n        browserWindow.webContents.setWindowOpenHandler(() => ({ action: 'deny' }));\n        browserWindow.webContents.on('new-window', () => {\n          assert.fail('new-window should not to be called with an overridden window.open');\n        });\n\n        browserWindow.webContents.on('did-create-window', () => {\n          assert.fail('did-create-window should not to be called with an overridden window.open');\n        });\n\n        browserWindow.webContents.executeJavaScript(\"window.open('about:blank') && true\");\n\n        setTimeout(() => {\n          done();\n        }, 500);\n      });\n\n      it('fires handler with correct params', (done) => {\n        const testFrameName = 'test-frame-name';\n        const testFeatures = 'top=10&left=10&something-unknown';\n        const testUrl = 'app://does-not-exist/';\n        browserWindow.webContents.setWindowOpenHandler(({ url, frameName, features }) => {\n          expect(url).to.equal(testUrl);\n          expect(frameName).to.equal(testFrameName);\n          expect(features).to.equal(testFeatures);\n          done();\n          return { action: 'deny' };\n        });\n\n        browserWindow.webContents.executeJavaScript(`window.open('${testUrl}', '${testFrameName}', '${testFeatures}') && true`);\n      });\n\n      it('does fire window creation events if an override returns action: allow', async () => {\n        browserWindow.webContents.setWindowOpenHandler(() => ({ action: 'allow' }));\n\n        setImmediate(() => {\n          browserWindow.webContents.executeJavaScript(\"window.open('about:blank') && true\");\n        });\n\n        await Promise.all([\n          emittedOnce(browserWindow.webContents, 'did-create-window'),\n          emittedOnce(browserWindow.webContents, 'new-window')\n        ]);\n      });\n\n      it('can change webPreferences of child windows', (done) => {\n        browserWindow.webContents.setWindowOpenHandler(() => ({ action: 'allow', overrideBrowserWindowOptions: { webPreferences: { defaultFontSize: 30 } } }));\n\n        browserWindow.webContents.on('did-create-window', async (childWindow) => {\n          await childWindow.webContents.executeJavaScript(\"document.write('hello')\");\n          const size = await childWindow.webContents.executeJavaScript(\"getComputedStyle(document.querySelector('body')).fontSize\");\n          expect(size).to.equal('30px');\n          done();\n        });\n\n        browserWindow.webContents.executeJavaScript(\"window.open('about:blank') && true\");\n      });\n    });\n  }\n});\n\nfunction stringifySnapshots (snapshots: any, pretty = false) {\n  return JSON.stringify(snapshots, (key, value) => {\n    if (['sender', 'webContents'].includes(key)) {\n      return '[WebContents]';\n    }\n    if (key === 'openerId' && typeof value === 'number') {\n      return 'placeholder-opener-id';\n    }\n    if (key === 'returnValue') {\n      return 'placeholder-guest-contents-id';\n    }\n    return value;\n  }, pretty ? 2 : undefined);\n}\n\nfunction parseSnapshots (snapshotsJson: string) {\n  return JSON.parse(snapshotsJson, (key, value) => {\n    if (key === 'openerId' && value === 'placeholder-opener-id') return 1;\n    return value;\n  });\n}\n", "/// <reference path=\"../electron.d.ts\" />\n\n/**\n * This file augments the Electron TS namespace with the internal APIs\n * that are not documented but are used by Electron internally\n */\n\ndeclare namespace Electron {\n  enum ProcessType {\n    browser = 'browser',\n    renderer = 'renderer',\n    worker = 'worker'\n  }\n\n  interface App {\n    _setDefaultAppPaths(packagePath: string | null): void;\n    setVersion(version: string): void;\n    setDesktopName(name: string): void;\n    setAppPath(path: string | null): void;\n  }\n\n  type TouchBarItemType = NonNullable<Electron.TouchBarConstructorOptions['items']>[0];\n\n  interface BaseWindow {\n    _init(): void;\n  }\n\n  interface BrowserWindow {\n    _init(): void;\n    _touchBar: Electron.TouchBar | null;\n    _setTouchBarItems: (items: TouchBarItemType[]) => void;\n    _setEscapeTouchBarItem: (item: TouchBarItemType | {}) => void;\n    _refreshTouchBarItem: (itemID: string) => void;\n    frameName: string;\n    on(event: '-touch-bar-interaction', listener: (event: Event, itemID: string, details: any) => void): this;\n    removeListener(event: '-touch-bar-interaction', listener: (event: Event, itemID: string, details: any) => void): this;\n  }\n\n  interface ContextBridge {\n    internalContextBridge: {\n      contextIsolationEnabled: boolean;\n      overrideGlobalValueFromIsolatedWorld(keys: string[], value: any): void;\n      overrideGlobalValueWithDynamicPropsFromIsolatedWorld(keys: string[], value: any): void;\n      overrideGlobalPropertyFromIsolatedWorld(keys: string[], getter: Function, setter?: Function): void;\n      isInMainWorld(): boolean;\n    }\n  }\n\n  interface TouchBar {\n    _removeFromWindow: (win: BrowserWindow) => void;\n  }\n\n  interface WebContents {\n    _getURL(): string;\n    _loadURL(url: string, options: ElectronInternal.LoadURLOptions): void;\n    _stop(): void;\n    _goBack(): void;\n    _goForward(): void;\n    _goToOffset(offset: number): void;\n    getOwnerBrowserWindow(): Electron.BrowserWindow;\n    getWebPreferences(): Electron.WebPreferences;\n    getLastWebPreferences(): Electron.WebPreferences;\n    _getPreloadPaths(): string[];\n    equal(other: WebContents): boolean;\n    _initiallyShown: boolean;\n    browserWindowOptions: BrowserWindowConstructorOptions;\n    _windowOpenHandler: ((opts: {url: string, frameName: string, features: string}) => any) | null;\n    _callWindowOpenHandler(event: any, url: string, frameName: string, rawFeatures: string): Electron.BrowserWindowConstructorOptions | null;\n    _setNextChildWebPreferences(prefs: Partial<Electron.BrowserWindowConstructorOptions['webPreferences']> & Pick<Electron.BrowserWindowConstructorOptions, 'backgroundColor'>): void;\n    _send(internal: boolean, channel: string, args: any): boolean;\n    _sendToFrame(internal: boolean, frameId: number, channel: string, args: any): boolean;\n    _sendToFrameInternal(frameId: number, channel: string, ...args: any[]): boolean;\n    _postMessage(channel: string, message: any, transfer?: any[]): void;\n    _sendInternal(channel: string, ...args: any[]): void;\n    _printToPDF(options: any): Promise<Buffer>;\n    _print(options: any, callback?: (success: boolean, failureReason: string) => void): void;\n    _getPrinters(): Electron.PrinterInfo[];\n    _init(): void;\n    canGoToIndex(index: number): boolean;\n    getActiveIndex(): number;\n    length(): number;\n    destroy(): void;\n    // <webview>\n    attachToIframe(embedderWebContents: Electron.WebContents, embedderFrameId: number): void;\n    detachFromOuterFrame(): void;\n    setEmbedder(embedder: Electron.WebContents): void;\n    attachParams?: Record<string, any>;\n    viewInstanceId: number;\n  }\n\n  interface WebFrame {\n    getWebFrameId(window: Window): number;\n    allowGuestViewElementDefinition(window: Window, context: any): void;\n  }\n\n  interface WebPreferences {\n    guestInstanceId?: number;\n    openerId?: number;\n    disablePopups?: boolean;\n    preloadURL?: string;\n    embedder?: Electron.WebContents;\n    type?: 'backgroundPage' | 'window' | 'browserView' | 'remote' | 'webview' | 'offscreen';\n  }\n\n  interface Menu {\n    _init(): void;\n    _isCommandIdChecked(id: string): boolean;\n    _isCommandIdEnabled(id: string): boolean;\n    _shouldCommandIdWorkWhenHidden(id: string): boolean;\n    _isCommandIdVisible(id: string): boolean;\n    _getAcceleratorForCommandId(id: string, useDefaultAccelerator: boolean): Accelerator | undefined;\n    _shouldRegisterAcceleratorForCommandId(id: string): boolean;\n    _getSharingItemForCommandId(id: string): SharingItem | null;\n    _callMenuWillShow(): void;\n    _executeCommand(event: any, id: number): void;\n    _menuWillShow(): void;\n    commandsMap: Record<string, MenuItem>;\n    groupsMap: Record<string, {\n      checked: boolean;\n    }[]>;\n    getItemCount(): number;\n    popupAt(window: BaseWindow, x: number, y: number, positioning: number, callback: () => void): void;\n    closePopupAt(id: number): void;\n    setSublabel(index: number, label: string): void;\n    setToolTip(index: number, tooltip: string): void;\n    setIcon(index: number, image: string | NativeImage): void;\n    setRole(index: number, role: string): void;\n    insertItem(index: number, commandId: number, label: string): void;\n    insertCheckItem(index: number, commandId: number, label: string): void;\n    insertRadioItem(index: number, commandId: number, label: string, groupId: number): void;\n    insertSeparator(index: number): void;\n    insertSubMenu(index: number, commandId: number, label: string, submenu?: Menu): void;\n    delegate?: any;\n    getAcceleratorTextAt(index: number): string;\n  }\n\n  interface MenuItem {\n    overrideReadOnlyProperty(property: string, value: any): void;\n    groupId: number;\n    getDefaultRoleAccelerator(): Accelerator | undefined;\n    getCheckStatus(): boolean;\n    acceleratorWorksWhenHidden?: boolean;\n  }\n\n  interface IpcMainInvokeEvent {\n    _reply(value: any): void;\n    _throw(error: Error): void;\n  }\n\n  const deprecate: ElectronInternal.DeprecationUtil;\n\n  namespace Main {\n    const deprecate: ElectronInternal.DeprecationUtil;\n  }\n\n  class View {}\n\n  // Experimental views API\n  class BaseWindow {\n    constructor(args: {show: boolean})\n    setContentView(view: View): void\n    static fromId(id: number): BaseWindow;\n    static getAllWindows(): BaseWindow[];\n    isFocused(): boolean;\n    static getFocusedWindow(): BaseWindow | undefined;\n    setMenu(menu: Menu): void;\n  }\n  class WebContentsView {\n    constructor(options: BrowserWindowConstructorOptions)\n  }\n\n  // Deprecated / undocumented BrowserWindow methods\n  interface BrowserWindow {\n    getURL(): string;\n    send(channel: string, ...args: any[]): void;\n    openDevTools(options?: Electron.OpenDevToolsOptions): void;\n    closeDevTools(): void;\n    isDevToolsOpened(): void;\n    isDevToolsFocused(): void;\n    toggleDevTools(): void;\n    inspectElement(x: number, y: number): void;\n    inspectSharedWorker(): void;\n    inspectServiceWorker(): void;\n    getBackgroundThrottling(): void;\n    setBackgroundThrottling(allowed: boolean): void;\n  }\n\n  namespace Main {\n    class BaseWindow extends Electron.BaseWindow {}\n    class View extends Electron.View {}\n    class WebContentsView extends Electron.WebContentsView {}\n  }\n}\n\ndeclare namespace ElectronInternal {\n  type DeprecationHandler = (message: string) => void;\n  interface DeprecationUtil {\n    warnOnce(oldName: string, newName?: string): () => void;\n    setHandler(handler: DeprecationHandler | null): void;\n    getHandler(): DeprecationHandler | null;\n    warn(oldName: string, newName: string): void;\n    log(message: string): void;\n    removeFunction<T extends Function>(fn: T, removedName: string): T;\n    renameFunction<T extends Function>(fn: T, newName: string): T;\n    event(emitter: NodeJS.EventEmitter, oldName: string, newName: string): void;\n    removeProperty<T, K extends (keyof T & string)>(object: T, propertyName: K, onlyForValues?: any[]): T;\n    renameProperty<T, K extends (keyof T & string)>(object: T, oldName: string, newName: K): T;\n    moveAPI<T extends Function>(fn: T, oldUsage: string, newUsage: string): T;\n  }\n\n  interface DesktopCapturer {\n    startHandling(captureWindow: boolean, captureScreen: boolean, thumbnailSize: Electron.Size, fetchWindowIcons: boolean): void;\n    _onerror?: (error: string) => void;\n    _onfinished?: (sources: Electron.DesktopCapturerSource[], fetchWindowIcons: boolean) => void;\n  }\n\n  interface GetSourcesOptions {\n    captureWindow: boolean;\n    captureScreen: boolean;\n    thumbnailSize: Electron.Size;\n    fetchWindowIcons: boolean;\n  }\n\n  interface GetSourcesResult {\n    id: string;\n    name: string;\n    thumbnail: Electron.NativeImage;\n    display_id: string;\n    appIcon: Electron.NativeImage | null;\n  }\n\n  interface IpcRendererInternal extends Electron.IpcRenderer {\n    invoke<T>(channel: string, ...args: any[]): Promise<T>;\n    onMessageFromMain(channel: string, listener: (event: Electron.IpcRendererEvent, ...args: any[]) => void): this;\n    onceMessageFromMain(channel: string, listener: (event: Electron.IpcRendererEvent, ...args: any[]) => void): this;\n  }\n\n  // Internal IPC has _replyInternal and NO reply method\n  interface IpcMainInternalEvent extends Omit<Electron.IpcMainEvent, 'reply'> {\n  }\n\n  interface IpcMainInternal extends NodeJS.EventEmitter {\n    handle(channel: string, listener: (event: Electron.IpcMainInvokeEvent, ...args: any[]) => Promise<any> | any): void;\n    on(channel: string, listener: (event: IpcMainInternalEvent, ...args: any[]) => void): this;\n    once(channel: string, listener: (event: IpcMainInternalEvent, ...args: any[]) => void): this;\n  }\n\n  interface LoadURLOptions extends Electron.LoadURLOptions {\n    reloadIgnoringCache?: boolean;\n  }\n\n  type ModuleLoader = () => any;\n\n  interface ModuleEntry {\n    name: string;\n    private?: boolean;\n    loader: ModuleLoader;\n  }\n\n  interface WebFrameResizeEvent extends WebViewEvent {\n    newWidth: number;\n    newHeight: number;\n  }\n\n  interface WebViewEvent extends Event {\n    url: string;\n    isMainFrame: boolean;\n  }\n\n  class WebViewElement extends HTMLElement {\n    static observedAttributes: Array<string>;\n\n    public contentWindow: Window;\n\n    public connectedCallback?(): void;\n    public attributeChangedCallback?(): void;\n    public disconnectedCallback?(): void;\n\n    // Created in web-view-impl\n    public getWebContentsId(): number;\n    public capturePage(rect?: Electron.Rectangle): Promise<Electron.NativeImage>;\n  }\n\n  class WebContents extends Electron.WebContents {\n    static create(opts: Electron.WebPreferences): Electron.WebContents;\n  }\n}\n\ndeclare namespace Chrome {\n  namespace Tabs {\n    // https://developer.chrome.com/extensions/tabs#method-executeScript\n    interface ExecuteScriptDetails {\n      code?: string;\n      file?: string;\n      allFrames?: boolean;\n      frameId?: number;\n      matchAboutBlank?: boolean;\n      runAt?: 'document-start' | 'document-end' | 'document_idle';\n      cssOrigin: 'author' | 'user';\n    }\n\n    type ExecuteScriptCallback = (result: Array<any>) => void;\n\n    // https://developer.chrome.com/extensions/tabs#method-sendMessage\n    interface SendMessageDetails {\n      frameId?: number;\n    }\n\n    type SendMessageCallback = (result: any) => void;\n  }\n}\n\ninterface Global extends NodeJS.Global {\n  require: NodeRequire;\n  module: NodeModule;\n  __filename: string;\n  __dirname: string;\n}\n"], "fixing_code": ["# IpcMainEvent Object extends `Event`\n\n* `processId` Integer - The internal ID of the renderer process that sent this message\n* `frameId` Integer - The ID of the renderer frame that sent this message\n* `returnValue` any - Set this to the value to be returned in a synchronous message\n* `sender` WebContents - Returns the `webContents` that sent the message\n* `ports` MessagePortMain[] - A list of MessagePorts that were transferred with this message\n* `reply` Function - A function that will send an IPC message to the renderer frame that sent the original message that you are currently handling.  You should use this method to \"reply\" to the sent message in order to guarantee the reply will go to the correct process and frame.\n  * `channel` String\n  * `...args` any[]\n", "# IpcMainInvokeEvent Object extends `Event`\n\n* `processId` Integer - The internal ID of the renderer process that sent this message\n* `frameId` Integer - The ID of the renderer frame that sent this message\n* `sender` WebContents - Returns the `webContents` that sent the message\n", "# webContents\n\n> Render and control web pages.\n\nProcess: [Main](../glossary.md#main-process)\n\n`webContents` is an [EventEmitter][event-emitter].\nIt is responsible for rendering and controlling a web page and is a property of\nthe [`BrowserWindow`](browser-window.md) object. An example of accessing the\n`webContents` object:\n\n```javascript\nconst { BrowserWindow } = require('electron')\n\nconst win = new BrowserWindow({ width: 800, height: 1500 })\nwin.loadURL('http://github.com')\n\nconst contents = win.webContents\nconsole.log(contents)\n```\n\n## Methods\n\nThese methods can be accessed from the `webContents` module:\n\n```javascript\nconst { webContents } = require('electron')\nconsole.log(webContents)\n```\n\n### `webContents.getAllWebContents()`\n\nReturns `WebContents[]` - An array of all `WebContents` instances. This will contain web contents\nfor all windows, webviews, opened devtools, and devtools extension background pages.\n\n### `webContents.getFocusedWebContents()`\n\nReturns `WebContents` - The web contents that is focused in this application, otherwise\nreturns `null`.\n\n### `webContents.fromId(id)`\n\n* `id` Integer\n\nReturns `WebContents` | undefined - A WebContents instance with the given ID, or\n`undefined` if there is no WebContents associated with the given ID.\n\n## Class: WebContents\n\n> Render and control the contents of a BrowserWindow instance.\n\nProcess: [Main](../glossary.md#main-process)\n\n### Instance Events\n\n#### Event: 'did-finish-load'\n\nEmitted when the navigation is done, i.e. the spinner of the tab has stopped\nspinning, and the `onload` event was dispatched.\n\n#### Event: 'did-fail-load'\n\nReturns:\n\n* `event` Event\n* `errorCode` Integer\n* `errorDescription` String\n* `validatedURL` String\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nThis event is like `did-finish-load` but emitted when the load failed.\nThe full list of error codes and their meaning is available [here](https://source.chromium.org/chromium/chromium/src/+/master:net/base/net_error_list.h).\n\n#### Event: 'did-fail-provisional-load'\n\nReturns:\n\n* `event` Event\n* `errorCode` Integer\n* `errorDescription` String\n* `validatedURL` String\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nThis event is like `did-fail-load` but emitted when the load was cancelled\n(e.g. `window.stop()` was invoked).\n\n#### Event: 'did-frame-finish-load'\n\nReturns:\n\n* `event` Event\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when a frame has done navigation.\n\n#### Event: 'did-start-loading'\n\nCorresponds to the points in time when the spinner of the tab started spinning.\n\n#### Event: 'did-stop-loading'\n\nCorresponds to the points in time when the spinner of the tab stopped spinning.\n\n#### Event: 'dom-ready'\n\nReturns:\n\n* `event` Event\n\nEmitted when the document in the given frame is loaded.\n\n#### Event: 'page-title-updated'\n\nReturns:\n\n* `event` Event\n* `title` String\n* `explicitSet` Boolean\n\nFired when page title is set during navigation. `explicitSet` is false when\ntitle is synthesized from file url.\n\n#### Event: 'page-favicon-updated'\n\nReturns:\n\n* `event` Event\n* `favicons` String[] - Array of URLs.\n\nEmitted when page receives favicon urls.\n\n#### Event: 'new-window' _Deprecated_\n\nReturns:\n\n* `event` NewWindowWebContentsEvent\n* `url` String\n* `frameName` String\n* `disposition` String - Can be `default`, `foreground-tab`, `background-tab`,\n  `new-window`, `save-to-disk` and `other`.\n* `options` BrowserWindowConstructorOptions - The options which will be used for creating the new\n  [`BrowserWindow`](browser-window.md).\n* `additionalFeatures` String[] - The non-standard features (features not handled\n  by Chromium or Electron) given to `window.open()`.\n* `referrer` [Referrer](structures/referrer.md) - The referrer that will be\n  passed to the new window. May or may not result in the `Referer` header being\n  sent, depending on the referrer policy.\n* `postBody` [PostBody](structures/post-body.md) (optional) - The post data that\n  will be sent to the new window, along with the appropriate headers that will\n  be set. If no post data is to be sent, the value will be `null`. Only defined\n  when the window is being created by a form that set `target=_blank`.\n\nDeprecated in favor of [`webContents.setWindowOpenHandler`](web-contents.md#contentssetwindowopenhandlerhandler).\n\nEmitted when the page requests to open a new window for a `url`. It could be\nrequested by `window.open` or an external link like `<a target='_blank'>`.\n\nBy default a new `BrowserWindow` will be created for the `url`.\n\nCalling `event.preventDefault()` will prevent Electron from automatically creating a\nnew [`BrowserWindow`](browser-window.md). If you call `event.preventDefault()` and manually create a new\n[`BrowserWindow`](browser-window.md) then you must set `event.newGuest` to reference the new [`BrowserWindow`](browser-window.md)\ninstance, failing to do so may result in unexpected behavior. For example:\n\n```javascript\nmyBrowserWindow.webContents.on('new-window', (event, url, frameName, disposition, options, additionalFeatures, referrer, postBody) => {\n  event.preventDefault()\n  const win = new BrowserWindow({\n    webContents: options.webContents, // use existing webContents if provided\n    show: false\n  })\n  win.once('ready-to-show', () => win.show())\n  if (!options.webContents) {\n    const loadOptions = {\n      httpReferrer: referrer\n    }\n    if (postBody != null) {\n      const { data, contentType, boundary } = postBody\n      loadOptions.postData = postBody.data\n      loadOptions.extraHeaders = `content-type: ${contentType}; boundary=${boundary}`\n    }\n\n    win.loadURL(url, loadOptions) // existing webContents will be navigated automatically\n  }\n  event.newGuest = win\n})\n```\n\n#### Event: 'did-create-window'\n\nReturns:\n\n* `window` BrowserWindow\n* `details` Object\n  * `url` String - URL for the created window.\n  * `frameName` String - Name given to the created window in the\n     `window.open()` call.\n  * `options` BrowserWindowConstructorOptions - The options used to create the\n    BrowserWindow. They are merged in increasing precedence: options inherited\n    from the parent, parsed options from the `features` string from\n    `window.open()`, and options given by\n    [`webContents.setWindowOpenHandler`](web-contents.md#contentssetwindowopenhandlerhandler).\n    Unrecognized options are not filtered out.\n  * `additionalFeatures` String[] - The non-standard features (features not\n    handled Chromium or Electron) _Deprecated_\n  * `referrer` [Referrer](structures/referrer.md) - The referrer that will be\n    passed to the new window. May or may not result in the `Referer` header\n    being sent, depending on the referrer policy.\n  * `postBody` [PostBody](structures/post-body.md) (optional) - The post data\n    that will be sent to the new window, along with the appropriate headers\n    that will be set. If no post data is to be sent, the value will be `null`.\n    Only defined when the window is being created by a form that set\n    `target=_blank`.\n  * `disposition` String - Can be `default`, `foreground-tab`,\n    `background-tab`, `new-window`, `save-to-disk` and `other`.\n\nEmitted _after_ successful creation of a window via `window.open` in the renderer.\nNot emitted if the creation of the window is canceled from\n[`webContents.setWindowOpenHandler`](web-contents.md#contentssetwindowopenhandlerhandler).\n\nSee [`window.open()`](window-open.md) for more details and how to use this in conjunction with `webContents.setWindowOpenHandler`.\n\n#### Event: 'will-navigate'\n\nReturns:\n\n* `event` Event\n* `url` String\n\nEmitted when a user or the page wants to start navigation. It can happen when\nthe `window.location` object is changed or a user clicks a link in the page.\n\nThis event will not emit when the navigation is started programmatically with\nAPIs like `webContents.loadURL` and `webContents.back`.\n\nIt is also not emitted for in-page navigations, such as clicking anchor links\nor updating the `window.location.hash`. Use `did-navigate-in-page` event for\nthis purpose.\n\nCalling `event.preventDefault()` will prevent the navigation.\n\n#### Event: 'did-start-navigation'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isInPlace` Boolean\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when any frame (including main) starts navigating. `isInPlace` will be\n`true` for in-page navigations.\n\n#### Event: 'will-redirect'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isInPlace` Boolean\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted as a server side redirect occurs during navigation.  For example a 302\nredirect.\n\nThis event will be emitted after `did-start-navigation` and always before the\n`did-redirect-navigation` event for the same navigation.\n\nCalling `event.preventDefault()` will prevent the navigation (not just the\nredirect).\n\n#### Event: 'did-redirect-navigation'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isInPlace` Boolean\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted after a server side redirect occurs during navigation.  For example a 302\nredirect.\n\nThis event cannot be prevented, if you want to prevent redirects you should\ncheckout out the `will-redirect` event above.\n\n#### Event: 'did-navigate'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `httpResponseCode` Integer - -1 for non HTTP navigations\n* `httpStatusText` String - empty for non HTTP navigations\n\nEmitted when a main frame navigation is done.\n\nThis event is not emitted for in-page navigations, such as clicking anchor links\nor updating the `window.location.hash`. Use `did-navigate-in-page` event for\nthis purpose.\n\n#### Event: 'did-frame-navigate'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `httpResponseCode` Integer - -1 for non HTTP navigations\n* `httpStatusText` String - empty for non HTTP navigations,\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when any frame navigation is done.\n\nThis event is not emitted for in-page navigations, such as clicking anchor links\nor updating the `window.location.hash`. Use `did-navigate-in-page` event for\nthis purpose.\n\n#### Event: 'did-navigate-in-page'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `isMainFrame` Boolean\n* `frameProcessId` Integer\n* `frameRoutingId` Integer\n\nEmitted when an in-page navigation happened in any frame.\n\nWhen in-page navigation happens, the page URL changes but does not cause\nnavigation outside of the page. Examples of this occurring are when anchor links\nare clicked or when the DOM `hashchange` event is triggered.\n\n#### Event: 'will-prevent-unload'\n\nReturns:\n\n* `event` Event\n\nEmitted when a `beforeunload` event handler is attempting to cancel a page unload.\n\nCalling `event.preventDefault()` will ignore the `beforeunload` event handler\nand allow the page to be unloaded.\n\n```javascript\nconst { BrowserWindow, dialog } = require('electron')\nconst win = new BrowserWindow({ width: 800, height: 600 })\nwin.webContents.on('will-prevent-unload', (event) => {\n  const choice = dialog.showMessageBoxSync(win, {\n    type: 'question',\n    buttons: ['Leave', 'Stay'],\n    title: 'Do you want to leave this site?',\n    message: 'Changes you made may not be saved.',\n    defaultId: 0,\n    cancelId: 1\n  })\n  const leave = (choice === 0)\n  if (leave) {\n    event.preventDefault()\n  }\n})\n```\n\n#### Event: 'crashed' _Deprecated_\n\nReturns:\n\n* `event` Event\n* `killed` Boolean\n\nEmitted when the renderer process crashes or is killed.\n\n**Deprecated:** This event is superceded by the `render-process-gone` event\nwhich contains more information about why the render process disappeared. It\nisn't always because it crashed.  The `killed` boolean can be replaced by\nchecking `reason === 'killed'` when you switch to that event.\n\n#### Event: 'render-process-gone'\n\nReturns:\n\n* `event` Event\n* `details` Object\n  * `reason` String - The reason the render process is gone.  Possible values:\n    * `clean-exit` - Process exited with an exit code of zero\n    * `abnormal-exit` - Process exited with a non-zero exit code\n    * `killed` - Process was sent a SIGTERM or otherwise killed externally\n    * `crashed` - Process crashed\n    * `oom` - Process ran out of memory\n    * `launch-failed` - Process never successfully launched\n    * `integrity-failure` - Windows code integrity checks failed\n\nEmitted when the renderer process unexpectedly disappears.  This is normally\nbecause it was crashed or killed.\n\n#### Event: 'unresponsive'\n\nEmitted when the web page becomes unresponsive.\n\n#### Event: 'responsive'\n\nEmitted when the unresponsive web page becomes responsive again.\n\n#### Event: 'plugin-crashed'\n\nReturns:\n\n* `event` Event\n* `name` String\n* `version` String\n\nEmitted when a plugin process has crashed.\n\n#### Event: 'destroyed'\n\nEmitted when `webContents` is destroyed.\n\n#### Event: 'before-input-event'\n\nReturns:\n\n* `event` Event\n* `input` Object - Input properties.\n  * `type` String - Either `keyUp` or `keyDown`.\n  * `key` String - Equivalent to [KeyboardEvent.key][keyboardevent].\n  * `code` String - Equivalent to [KeyboardEvent.code][keyboardevent].\n  * `isAutoRepeat` Boolean - Equivalent to [KeyboardEvent.repeat][keyboardevent].\n  * `isComposing` Boolean - Equivalent to [KeyboardEvent.isComposing][keyboardevent].\n  * `shift` Boolean - Equivalent to [KeyboardEvent.shiftKey][keyboardevent].\n  * `control` Boolean - Equivalent to [KeyboardEvent.controlKey][keyboardevent].\n  * `alt` Boolean - Equivalent to [KeyboardEvent.altKey][keyboardevent].\n  * `meta` Boolean - Equivalent to [KeyboardEvent.metaKey][keyboardevent].\n\nEmitted before dispatching the `keydown` and `keyup` events in the page.\nCalling `event.preventDefault` will prevent the page `keydown`/`keyup` events\nand the menu shortcuts.\n\nTo only prevent the menu shortcuts, use\n[`setIgnoreMenuShortcuts`](#contentssetignoremenushortcutsignore):\n\n```javascript\nconst { BrowserWindow } = require('electron')\n\nconst win = new BrowserWindow({ width: 800, height: 600 })\n\nwin.webContents.on('before-input-event', (event, input) => {\n  // For example, only enable application menu keyboard shortcuts when\n  // Ctrl/Cmd are down.\n  win.webContents.setIgnoreMenuShortcuts(!input.control && !input.meta)\n})\n```\n\n#### Event: 'enter-html-full-screen'\n\nEmitted when the window enters a full-screen state triggered by HTML API.\n\n#### Event: 'leave-html-full-screen'\n\nEmitted when the window leaves a full-screen state triggered by HTML API.\n\n#### Event: 'zoom-changed'\n\nReturns:\n\n* `event` Event\n* `zoomDirection` String - Can be `in` or `out`.\n\nEmitted when the user is requesting to change the zoom level using the mouse wheel.\n\n#### Event: 'devtools-opened'\n\nEmitted when DevTools is opened.\n\n#### Event: 'devtools-closed'\n\nEmitted when DevTools is closed.\n\n#### Event: 'devtools-focused'\n\nEmitted when DevTools is focused / opened.\n\n#### Event: 'certificate-error'\n\nReturns:\n\n* `event` Event\n* `url` String\n* `error` String - The error code.\n* `certificate` [Certificate](structures/certificate.md)\n* `callback` Function\n  * `isTrusted` Boolean - Indicates whether the certificate can be considered trusted.\n\nEmitted when failed to verify the `certificate` for `url`.\n\nThe usage is the same with [the `certificate-error` event of\n`app`](app.md#event-certificate-error).\n\n#### Event: 'select-client-certificate'\n\nReturns:\n\n* `event` Event\n* `url` URL\n* `certificateList` [Certificate[]](structures/certificate.md)\n* `callback` Function\n  * `certificate` [Certificate](structures/certificate.md) - Must be a certificate from the given list.\n\nEmitted when a client certificate is requested.\n\nThe usage is the same with [the `select-client-certificate` event of\n`app`](app.md#event-select-client-certificate).\n\n#### Event: 'login'\n\nReturns:\n\n* `event` Event\n* `authenticationResponseDetails` Object\n  * `url` URL\n* `authInfo` Object\n  * `isProxy` Boolean\n  * `scheme` String\n  * `host` String\n  * `port` Integer\n  * `realm` String\n* `callback` Function\n  * `username` String (optional)\n  * `password` String (optional)\n\nEmitted when `webContents` wants to do basic auth.\n\nThe usage is the same with [the `login` event of `app`](app.md#event-login).\n\n#### Event: 'found-in-page'\n\nReturns:\n\n* `event` Event\n* `result` Object\n  * `requestId` Integer\n  * `activeMatchOrdinal` Integer - Position of the active match.\n  * `matches` Integer - Number of Matches.\n  * `selectionArea` Rectangle - Coordinates of first match region.\n  * `finalUpdate` Boolean\n\nEmitted when a result is available for\n[`webContents.findInPage`] request.\n\n#### Event: 'media-started-playing'\n\nEmitted when media starts playing.\n\n#### Event: 'media-paused'\n\nEmitted when media is paused or done playing.\n\n#### Event: 'did-change-theme-color'\n\nReturns:\n\n* `event` Event\n* `color` (String | null) - Theme color is in format of '#rrggbb'. It is `null` when no theme color is set.\n\nEmitted when a page's theme color changes. This is usually due to encountering\na meta tag:\n\n```html\n<meta name='theme-color' content='#ff0000'>\n```\n\n#### Event: 'update-target-url'\n\nReturns:\n\n* `event` Event\n* `url` String\n\nEmitted when mouse moves over a link or the keyboard moves the focus to a link.\n\n#### Event: 'cursor-changed'\n\nReturns:\n\n* `event` Event\n* `type` String\n* `image` [NativeImage](native-image.md) (optional)\n* `scale` Float (optional) - scaling factor for the custom cursor.\n* `size` [Size](structures/size.md) (optional) - the size of the `image`.\n* `hotspot` [Point](structures/point.md) (optional) - coordinates of the custom cursor's hotspot.\n\nEmitted when the cursor's type changes. The `type` parameter can be `default`,\n`crosshair`, `pointer`, `text`, `wait`, `help`, `e-resize`, `n-resize`,\n`ne-resize`, `nw-resize`, `s-resize`, `se-resize`, `sw-resize`, `w-resize`,\n`ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`, `col-resize`,\n`row-resize`, `m-panning`, `e-panning`, `n-panning`, `ne-panning`, `nw-panning`,\n`s-panning`, `se-panning`, `sw-panning`, `w-panning`, `move`, `vertical-text`,\n`cell`, `context-menu`, `alias`, `progress`, `nodrop`, `copy`, `none`,\n`not-allowed`, `zoom-in`, `zoom-out`, `grab`, `grabbing` or `custom`.\n\nIf the `type` parameter is `custom`, the `image` parameter will hold the custom\ncursor image in a [`NativeImage`](native-image.md), and `scale`, `size` and `hotspot` will hold\nadditional information about the custom cursor.\n\n#### Event: 'context-menu'\n\nReturns:\n\n* `event` Event\n* `params` Object\n  * `x` Integer - x coordinate.\n  * `y` Integer - y coordinate.\n  * `linkURL` String - URL of the link that encloses the node the context menu\n    was invoked on.\n  * `linkText` String - Text associated with the link. May be an empty\n    string if the contents of the link are an image.\n  * `pageURL` String - URL of the top level page that the context menu was\n    invoked on.\n  * `frameURL` String - URL of the subframe that the context menu was invoked\n    on.\n  * `srcURL` String - Source URL for the element that the context menu\n    was invoked on. Elements with source URLs are images, audio and video.\n  * `mediaType` String - Type of the node the context menu was invoked on. Can\n    be `none`, `image`, `audio`, `video`, `canvas`, `file` or `plugin`.\n  * `hasImageContents` Boolean - Whether the context menu was invoked on an image\n    which has non-empty contents.\n  * `isEditable` Boolean - Whether the context is editable.\n  * `selectionText` String - Text of the selection that the context menu was\n    invoked on.\n  * `titleText` String - Title or alt text of the selection that the context\n    was invoked on.\n  * `misspelledWord` String - The misspelled word under the cursor, if any.\n  * `dictionarySuggestions` String[] - An array of suggested words to show the\n    user to replace the `misspelledWord`.  Only available if there is a misspelled\n    word and spellchecker is enabled.\n  * `frameCharset` String - The character encoding of the frame on which the\n    menu was invoked.\n  * `inputFieldType` String - If the context menu was invoked on an input\n    field, the type of that field. Possible values are `none`, `plainText`,\n    `password`, `other`.\n  * `menuSourceType` String - Input source that invoked the context menu.\n    Can be `none`, `mouse`, `keyboard`, `touch` or `touchMenu`.\n  * `mediaFlags` Object - The flags for the media element the context menu was\n    invoked on.\n    * `inError` Boolean - Whether the media element has crashed.\n    * `isPaused` Boolean - Whether the media element is paused.\n    * `isMuted` Boolean - Whether the media element is muted.\n    * `hasAudio` Boolean - Whether the media element has audio.\n    * `isLooping` Boolean - Whether the media element is looping.\n    * `isControlsVisible` Boolean - Whether the media element's controls are\n      visible.\n    * `canToggleControls` Boolean - Whether the media element's controls are\n      toggleable.\n    * `canRotate` Boolean - Whether the media element can be rotated.\n  * `editFlags` Object - These flags indicate whether the renderer believes it\n    is able to perform the corresponding action.\n    * `canUndo` Boolean - Whether the renderer believes it can undo.\n    * `canRedo` Boolean - Whether the renderer believes it can redo.\n    * `canCut` Boolean - Whether the renderer believes it can cut.\n    * `canCopy` Boolean - Whether the renderer believes it can copy\n    * `canPaste` Boolean - Whether the renderer believes it can paste.\n    * `canDelete` Boolean - Whether the renderer believes it can delete.\n    * `canSelectAll` Boolean - Whether the renderer believes it can select all.\n\nEmitted when there is a new context menu that needs to be handled.\n\n#### Event: 'select-bluetooth-device'\n\nReturns:\n\n* `event` Event\n* `devices` [BluetoothDevice[]](structures/bluetooth-device.md)\n* `callback` Function\n  * `deviceId` String\n\nEmitted when bluetooth device needs to be selected on call to\n`navigator.bluetooth.requestDevice`. To use `navigator.bluetooth` api\n`webBluetooth` should be enabled. If `event.preventDefault` is not called,\nfirst available device will be selected. `callback` should be called with\n`deviceId` to be selected, passing empty string to `callback` will\ncancel the request.\n\n```javascript\nconst { app, BrowserWindow } = require('electron')\n\nlet win = null\napp.commandLine.appendSwitch('enable-experimental-web-platform-features')\n\napp.whenReady().then(() => {\n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.webContents.on('select-bluetooth-device', (event, deviceList, callback) => {\n    event.preventDefault()\n    const result = deviceList.find((device) => {\n      return device.deviceName === 'test'\n    })\n    if (!result) {\n      callback('')\n    } else {\n      callback(result.deviceId)\n    }\n  })\n})\n```\n\n#### Event: 'paint'\n\nReturns:\n\n* `event` Event\n* `dirtyRect` [Rectangle](structures/rectangle.md)\n* `image` [NativeImage](native-image.md) - The image data of the whole frame.\n\nEmitted when a new frame is generated. Only the dirty area is passed in the\nbuffer.\n\n```javascript\nconst { BrowserWindow } = require('electron')\n\nconst win = new BrowserWindow({ webPreferences: { offscreen: true } })\nwin.webContents.on('paint', (event, dirty, image) => {\n  // updateBitmap(dirty, image.getBitmap())\n})\nwin.loadURL('http://github.com')\n```\n\n#### Event: 'devtools-reload-page'\n\nEmitted when the devtools window instructs the webContents to reload\n\n#### Event: 'will-attach-webview'\n\nReturns:\n\n* `event` Event\n* `webPreferences` WebPreferences - The web preferences that will be used by the guest\n  page. This object can be modified to adjust the preferences for the guest\n  page.\n* `params` Record<string, string> - The other `<webview>` parameters such as the `src` URL.\n  This object can be modified to adjust the parameters of the guest page.\n\nEmitted when a `<webview>`'s web contents is being attached to this web\ncontents. Calling `event.preventDefault()` will destroy the guest page.\n\nThis event can be used to configure `webPreferences` for the `webContents`\nof a `<webview>` before it's loaded, and provides the ability to set settings\nthat can't be set via `<webview>` attributes.\n\n**Note:** The specified `preload` script option will appear as `preloadURL`\n(not `preload`) in the `webPreferences` object emitted with this event.\n\n#### Event: 'did-attach-webview'\n\nReturns:\n\n* `event` Event\n* `webContents` WebContents - The guest web contents that is used by the\n  `<webview>`.\n\nEmitted when a `<webview>` has been attached to this web contents.\n\n#### Event: 'console-message'\n\nReturns:\n\n* `event` Event\n* `level` Integer - The log level, from 0 to 3. In order it matches `verbose`, `info`, `warning` and `error`.\n* `message` String - The actual console message\n* `line` Integer - The line number of the source that triggered this console message\n* `sourceId` String\n\nEmitted when the associated window logs a console message.\n\n#### Event: 'preload-error'\n\nReturns:\n\n* `event` Event\n* `preloadPath` String\n* `error` Error\n\nEmitted when the preload script `preloadPath` throws an unhandled exception `error`.\n\n#### Event: 'ipc-message'\n\nReturns:\n\n* `event` Event\n* `channel` String\n* `...args` any[]\n\nEmitted when the renderer process sends an asynchronous message via `ipcRenderer.send()`.\n\n#### Event: 'ipc-message-sync'\n\nReturns:\n\n* `event` Event\n* `channel` String\n* `...args` any[]\n\nEmitted when the renderer process sends a synchronous message via `ipcRenderer.sendSync()`.\n\n#### Event: 'desktop-capturer-get-sources'\n\nReturns:\n\n* `event` Event\n\nEmitted when `desktopCapturer.getSources()` is called in the renderer process.\nCalling `event.preventDefault()` will make it return empty sources.\n\n#### Event: 'remote-require' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n* `moduleName` String\n\nEmitted when `remote.require()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the module from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-global' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n* `globalName` String\n\nEmitted when `remote.getGlobal()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the global from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-builtin' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n* `moduleName` String\n\nEmitted when `remote.getBuiltin()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the module from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-current-window' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n\nEmitted when `remote.getCurrentWindow()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the object from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'remote-get-current-web-contents' _Deprecated_\n\nReturns:\n\n* `event` IpcMainEvent\n\nEmitted when `remote.getCurrentWebContents()` is called in the renderer process.\nCalling `event.preventDefault()` will prevent the object from being returned.\nCustom value can be returned by setting `event.returnValue`.\n\n#### Event: 'preferred-size-changed'\n\nReturns:\n\n* `event` Event\n* `preferredSize` [Size](structures/size.md) - The minimum size needed to\n  contain the layout of the document\u2014without requiring scrolling.\n\nEmitted when the `WebContents` preferred size has changed.\n\nThis event will only be emitted when `enablePreferredSizeMode` is set to `true`\nin `webPreferences`.\n\n### Instance Methods\n\n#### `contents.loadURL(url[, options])`\n\n* `url` String\n* `options` Object (optional)\n  * `httpReferrer` (String | [Referrer](structures/referrer.md)) (optional) - An HTTP Referrer url.\n  * `userAgent` String (optional) - A user agent originating the request.\n  * `extraHeaders` String (optional) - Extra headers separated by \"\\n\".\n  * `postData` ([UploadRawData[]](structures/upload-raw-data.md) | [UploadFile[]](structures/upload-file.md)) (optional)\n  * `baseURLForDataURL` String (optional) - Base url (with trailing path separator) for files to be loaded by the data url. This is needed only if the specified `url` is a data url and needs to load other files.\n\nReturns `Promise<void>` - the promise will resolve when the page has finished loading\n(see [`did-finish-load`](web-contents.md#event-did-finish-load)), and rejects\nif the page fails to load (see\n[`did-fail-load`](web-contents.md#event-did-fail-load)). A noop rejection handler is already attached, which avoids unhandled rejection errors.\n\nLoads the `url` in the window. The `url` must contain the protocol prefix,\ne.g. the `http://` or `file://`. If the load should bypass http cache then\nuse the `pragma` header to achieve it.\n\n```javascript\nconst { webContents } = require('electron')\nconst options = { extraHeaders: 'pragma: no-cache\\n' }\nwebContents.loadURL('https://github.com', options)\n```\n\n#### `contents.loadFile(filePath[, options])`\n\n* `filePath` String\n* `options` Object (optional)\n  * `query` Record<String, String> (optional) - Passed to `url.format()`.\n  * `search` String (optional) - Passed to `url.format()`.\n  * `hash` String (optional) - Passed to `url.format()`.\n\nReturns `Promise<void>` - the promise will resolve when the page has finished loading\n(see [`did-finish-load`](web-contents.md#event-did-finish-load)), and rejects\nif the page fails to load (see [`did-fail-load`](web-contents.md#event-did-fail-load)).\n\nLoads the given file in the window, `filePath` should be a path to\nan HTML file relative to the root of your application.  For instance\nan app structure like this:\n\n```sh\n| root\n| - package.json\n| - src\n|   - main.js\n|   - index.html\n```\n\nWould require code like this\n\n```js\nwin.loadFile('src/index.html')\n```\n\n#### `contents.downloadURL(url)`\n\n* `url` String\n\nInitiates a download of the resource at `url` without navigating. The\n`will-download` event of `session` will be triggered.\n\n#### `contents.getURL()`\n\nReturns `String` - The URL of the current web page.\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('http://github.com').then(() => {\n  const currentURL = win.webContents.getURL()\n  console.log(currentURL)\n})\n```\n\n#### `contents.getTitle()`\n\nReturns `String` - The title of the current web page.\n\n#### `contents.isDestroyed()`\n\nReturns `Boolean` - Whether the web page is destroyed.\n\n#### `contents.focus()`\n\nFocuses the web page.\n\n#### `contents.isFocused()`\n\nReturns `Boolean` - Whether the web page is focused.\n\n#### `contents.isLoading()`\n\nReturns `Boolean` - Whether web page is still loading resources.\n\n#### `contents.isLoadingMainFrame()`\n\nReturns `Boolean` - Whether the main frame (and not just iframes or frames within it) is\nstill loading.\n\n#### `contents.isWaitingForResponse()`\n\nReturns `Boolean` - Whether the web page is waiting for a first-response from the main\nresource of the page.\n\n#### `contents.stop()`\n\nStops any pending navigation.\n\n#### `contents.reload()`\n\nReloads the current web page.\n\n#### `contents.reloadIgnoringCache()`\n\nReloads current page and ignores cache.\n\n#### `contents.canGoBack()`\n\nReturns `Boolean` - Whether the browser can go back to previous web page.\n\n#### `contents.canGoForward()`\n\nReturns `Boolean` - Whether the browser can go forward to next web page.\n\n#### `contents.canGoToOffset(offset)`\n\n* `offset` Integer\n\nReturns `Boolean` - Whether the web page can go to `offset`.\n\n#### `contents.clearHistory()`\n\nClears the navigation history.\n\n#### `contents.goBack()`\n\nMakes the browser go back a web page.\n\n#### `contents.goForward()`\n\nMakes the browser go forward a web page.\n\n#### `contents.goToIndex(index)`\n\n* `index` Integer\n\nNavigates browser to the specified absolute web page index.\n\n#### `contents.goToOffset(offset)`\n\n* `offset` Integer\n\nNavigates to the specified offset from the \"current entry\".\n\n#### `contents.isCrashed()`\n\nReturns `Boolean` - Whether the renderer process has crashed.\n\n#### `contents.forcefullyCrashRenderer()`\n\nForcefully terminates the renderer process that is currently hosting this\n`webContents`. This will cause the `render-process-gone` event to be emitted\nwith the `reason=killed || reason=crashed`. Please note that some webContents share renderer\nprocesses and therefore calling this method may also crash the host process\nfor other webContents as well.\n\nCalling `reload()` immediately after calling this\nmethod will force the reload to occur in a new process. This should be used\nwhen this process is unstable or unusable, for instance in order to recover\nfrom the `unresponsive` event.\n\n```js\ncontents.on('unresponsive', async () => {\n  const { response } = await dialog.showMessageBox({\n    message: 'App X has become unresponsive',\n    title: 'Do you want to try forcefully reloading the app?',\n    buttons: ['OK', 'Cancel'],\n    cancelId: 1\n  })\n  if (response === 0) {\n    contents.forcefullyCrashRenderer()\n    contents.reload()\n  }\n})\n```\n\n#### `contents.setUserAgent(userAgent)`\n\n* `userAgent` String\n\nOverrides the user agent for this web page.\n\n#### `contents.getUserAgent()`\n\nReturns `String` - The user agent for this web page.\n\n#### `contents.insertCSS(css[, options])`\n\n* `css` String\n* `options` Object (optional)\n  * `cssOrigin` String (optional) - Can be either 'user' or 'author'; Specifying 'user' enables you to prevent websites from overriding the CSS you insert. Default is 'author'.\n\nReturns `Promise<String>` - A promise that resolves with a key for the inserted CSS that can later be used to remove the CSS via `contents.removeInsertedCSS(key)`.\n\nInjects CSS into the current web page and returns a unique key for the inserted\nstylesheet.\n\n```js\ncontents.on('did-finish-load', () => {\n  contents.insertCSS('html, body { background-color: #f00; }')\n})\n```\n\n#### `contents.removeInsertedCSS(key)`\n\n* `key` String\n\nReturns `Promise<void>` - Resolves if the removal was successful.\n\nRemoves the inserted CSS from the current web page. The stylesheet is identified\nby its key, which is returned from `contents.insertCSS(css)`.\n\n```js\ncontents.on('did-finish-load', async () => {\n  const key = await contents.insertCSS('html, body { background-color: #f00; }')\n  contents.removeInsertedCSS(key)\n})\n```\n\n#### `contents.executeJavaScript(code[, userGesture])`\n\n* `code` String\n* `userGesture` Boolean (optional) - Default is `false`.\n\nReturns `Promise<any>` - A promise that resolves with the result of the executed code\nor is rejected if the result of the code is a rejected promise.\n\nEvaluates `code` in page.\n\nIn the browser window some HTML APIs like `requestFullScreen` can only be\ninvoked by a gesture from the user. Setting `userGesture` to `true` will remove\nthis limitation.\n\nCode execution will be suspended until web page stop loading.\n\n```js\ncontents.executeJavaScript('fetch(\"https://jsonplaceholder.typicode.com/users/1\").then(resp => resp.json())', true)\n  .then((result) => {\n    console.log(result) // Will be the JSON object from the fetch call\n  })\n```\n\n#### `contents.executeJavaScriptInIsolatedWorld(worldId, scripts[, userGesture])`\n\n* `worldId` Integer - The ID of the world to run the javascript in, `0` is the default world, `999` is the world used by Electron's `contextIsolation` feature.  You can provide any integer here.\n* `scripts` [WebSource[]](structures/web-source.md)\n* `userGesture` Boolean (optional) - Default is `false`.\n\nReturns `Promise<any>` - A promise that resolves with the result of the executed code\nor is rejected if the result of the code is a rejected promise.\n\nWorks like `executeJavaScript` but evaluates `scripts` in an isolated context.\n\n#### `contents.setIgnoreMenuShortcuts(ignore)`\n\n* `ignore` Boolean\n\nIgnore application menu shortcuts while this web contents is focused.\n\n#### `contents.setWindowOpenHandler(handler)`\n\n* `handler` Function<{action: 'deny'} | {action: 'allow', overrideBrowserWindowOptions?: BrowserWindowConstructorOptions}>\n  * `details` Object\n    * `url` String - The _resolved_ version of the URL passed to `window.open()`. e.g. opening a window with `window.open('foo')` will yield something like `https://the-origin/the/current/path/foo`.\n    * `frameName` String - Name of the window provided in `window.open()`\n    * `features` String - Comma separated list of window features provided to `window.open()`.\n  Returns `{action: 'deny'} | {action: 'allow', overrideBrowserWindowOptions?: BrowserWindowConstructorOptions}` - `deny` cancels the creation of the new\n  window. `allow` will allow the new window to be created. Specifying `overrideBrowserWindowOptions` allows customization of the created window.\n  Returning an unrecognized value such as a null, undefined, or an object\n  without a recognized 'action' value will result in a console error and have\n  the same effect as returning `{action: 'deny'}`.\n\nCalled before creating a window when `window.open()` is called from the\nrenderer. See [`window.open()`](window-open.md) for more details and how to use this in conjunction with `did-create-window`.\n\n#### `contents.setAudioMuted(muted)`\n\n* `muted` Boolean\n\nMute the audio on the current web page.\n\n#### `contents.isAudioMuted()`\n\nReturns `Boolean` - Whether this page has been muted.\n\n#### `contents.isCurrentlyAudible()`\n\nReturns `Boolean` - Whether audio is currently playing.\n\n#### `contents.setZoomFactor(factor)`\n\n* `factor` Double - Zoom factor; default is 1.0.\n\nChanges the zoom factor to the specified factor. Zoom factor is\nzoom percent divided by 100, so 300% = 3.0.\n\nThe factor must be greater than 0.0.\n\n#### `contents.getZoomFactor()`\n\nReturns `Number` - the current zoom factor.\n\n#### `contents.setZoomLevel(level)`\n\n* `level` Number - Zoom level.\n\nChanges the zoom level to the specified level. The original size is 0 and each\nincrement above or below represents zooming 20% larger or smaller to default\nlimits of 300% and 50% of original size, respectively. The formula for this is\n`scale := 1.2 ^ level`.\n\n> **NOTE**: The zoom policy at the Chromium level is same-origin, meaning that the\n> zoom level for a specific domain propagates across all instances of windows with\n> the same domain. Differentiating the window URLs will make zoom work per-window.\n\n#### `contents.getZoomLevel()`\n\nReturns `Number` - the current zoom level.\n\n#### `contents.setVisualZoomLevelLimits(minimumLevel, maximumLevel)`\n\n* `minimumLevel` Number\n* `maximumLevel` Number\n\nReturns `Promise<void>`\n\nSets the maximum and minimum pinch-to-zoom level.\n\n> **NOTE**: Visual zoom is disabled by default in Electron. To re-enable it, call:\n>\n> ```js\n> contents.setVisualZoomLevelLimits(1, 3)\n> ```\n\n#### `contents.undo()`\n\nExecutes the editing command `undo` in web page.\n\n#### `contents.redo()`\n\nExecutes the editing command `redo` in web page.\n\n#### `contents.cut()`\n\nExecutes the editing command `cut` in web page.\n\n#### `contents.copy()`\n\nExecutes the editing command `copy` in web page.\n\n#### `contents.copyImageAt(x, y)`\n\n* `x` Integer\n* `y` Integer\n\nCopy the image at the given position to the clipboard.\n\n#### `contents.paste()`\n\nExecutes the editing command `paste` in web page.\n\n#### `contents.pasteAndMatchStyle()`\n\nExecutes the editing command `pasteAndMatchStyle` in web page.\n\n#### `contents.delete()`\n\nExecutes the editing command `delete` in web page.\n\n#### `contents.selectAll()`\n\nExecutes the editing command `selectAll` in web page.\n\n#### `contents.unselect()`\n\nExecutes the editing command `unselect` in web page.\n\n#### `contents.replace(text)`\n\n* `text` String\n\nExecutes the editing command `replace` in web page.\n\n#### `contents.replaceMisspelling(text)`\n\n* `text` String\n\nExecutes the editing command `replaceMisspelling` in web page.\n\n#### `contents.insertText(text)`\n\n* `text` String\n\nReturns `Promise<void>`\n\nInserts `text` to the focused element.\n\n#### `contents.findInPage(text[, options])`\n\n* `text` String - Content to be searched, must not be empty.\n* `options` Object (optional)\n  * `forward` Boolean (optional) - Whether to search forward or backward, defaults to `true`.\n  * `findNext` Boolean (optional) - Whether the operation is first request or a follow up,\n    defaults to `false`.\n  * `matchCase` Boolean (optional) - Whether search should be case-sensitive,\n    defaults to `false`.\n\nReturns `Integer` - The request id used for the request.\n\nStarts a request to find all matches for the `text` in the web page. The result of the request\ncan be obtained by subscribing to [`found-in-page`](web-contents.md#event-found-in-page) event.\n\n#### `contents.stopFindInPage(action)`\n\n* `action` String - Specifies the action to take place when ending\n  [`webContents.findInPage`] request.\n  * `clearSelection` - Clear the selection.\n  * `keepSelection` - Translate the selection into a normal selection.\n  * `activateSelection` - Focus and click the selection node.\n\nStops any `findInPage` request for the `webContents` with the provided `action`.\n\n```javascript\nconst { webContents } = require('electron')\nwebContents.on('found-in-page', (event, result) => {\n  if (result.finalUpdate) webContents.stopFindInPage('clearSelection')\n})\n\nconst requestId = webContents.findInPage('api')\nconsole.log(requestId)\n```\n\n#### `contents.capturePage([rect])`\n\n* `rect` [Rectangle](structures/rectangle.md) (optional) - The area of the page to be captured.\n\nReturns `Promise<NativeImage>` - Resolves with a [NativeImage](native-image.md)\n\nCaptures a snapshot of the page within `rect`. Omitting `rect` will capture the whole visible page.\n\n#### `contents.isBeingCaptured()`\n\nReturns `Boolean` - Whether this page is being captured. It returns true when the capturer count\nis large then 0.\n\n#### `contents.incrementCapturerCount([size, stayHidden])`\n\n* `size` [Size](structures/size.md) (optional) - The preferred size for the capturer.\n* `stayHidden` Boolean (optional) -  Keep the page hidden instead of visible.\n\nIncrease the capturer count by one. The page is considered visible when its browser window is\nhidden and the capturer count is non-zero. If you would like the page to stay hidden, you should ensure that `stayHidden` is set to true.\n\nThis also affects the Page Visibility API.\n\n#### `contents.decrementCapturerCount([stayHidden])`\n\n* `stayHidden` Boolean (optional) -  Keep the page in hidden state instead of visible.\n\nDecrease the capturer count by one. The page will be set to hidden or occluded state when its\nbrowser window is hidden or occluded and the capturer count reaches zero. If you want to\ndecrease the hidden capturer count instead you should set `stayHidden` to true.\n\n#### `contents.getPrinters()`\n\nGet the system printer list.\n\nReturns [`PrinterInfo[]`](structures/printer-info.md)\n\n#### `contents.print([options], [callback])`\n\n* `options` Object (optional)\n  * `silent` Boolean (optional) - Don't ask user for print settings. Default is `false`.\n  * `printBackground` Boolean (optional) - Prints the background color and image of\n    the web page. Default is `false`.\n  * `deviceName` String (optional) - Set the printer device name to use. Must be the system-defined name and not the 'friendly' name, e.g 'Brother_QL_820NWB' and not 'Brother QL-820NWB'.\n  * `color` Boolean (optional) - Set whether the printed web page will be in color or grayscale. Default is `true`.\n  * `margins` Object (optional)\n    * `marginType` String (optional) - Can be `default`, `none`, `printableArea`, or `custom`. If `custom` is chosen, you will also need to specify `top`, `bottom`, `left`, and `right`.\n    * `top` Number (optional) - The top margin of the printed web page, in pixels.\n    * `bottom` Number (optional) - The bottom margin of the printed web page, in pixels.\n    * `left` Number (optional) - The left margin of the printed web page, in pixels.\n    * `right` Number (optional) - The right margin of the printed web page, in pixels.\n  * `landscape` Boolean (optional) - Whether the web page should be printed in landscape mode. Default is `false`.\n  * `scaleFactor` Number (optional) - The scale factor of the web page.\n  * `pagesPerSheet` Number (optional) - The number of pages to print per page sheet.\n  * `collate` Boolean (optional) - Whether the web page should be collated.\n  * `copies` Number (optional) - The number of copies of the web page to print.\n  * `pageRanges` Object[]  (optional) - The page range to print. On macOS, only one range is honored.\n    * `from` Number - Index of the first page to print (0-based).\n    * `to` Number - Index of the last page to print (inclusive) (0-based).\n  * `duplexMode` String (optional) - Set the duplex mode of the printed web page. Can be `simplex`, `shortEdge`, or `longEdge`.\n  * `dpi` Record<string, number> (optional)\n    * `horizontal` Number (optional) - The horizontal dpi.\n    * `vertical` Number (optional) - The vertical dpi.\n  * `header` String (optional) - String to be printed as page header.\n  * `footer` String (optional) - String to be printed as page footer.\n  * `pageSize` String | Size (optional) - Specify page size of the printed document. Can be `A3`,\n  `A4`, `A5`, `Legal`, `Letter`, `Tabloid` or an Object containing `height`.\n* `callback` Function (optional)\n  * `success` Boolean - Indicates success of the print call.\n  * `failureReason` String - Error description called back if the print fails.\n\nWhen a custom `pageSize` is passed, Chromium attempts to validate platform specific minimum values for `width_microns` and `height_microns`. Width and height must both be minimum 353 microns but may be higher on some operating systems.\n\nPrints window's web page. When `silent` is set to `true`, Electron will pick\nthe system's default printer if `deviceName` is empty and the default settings for printing.\n\nUse `page-break-before: always;` CSS style to force to print to a new page.\n\nExample usage:\n\n```js\nconst options = {\n  silent: true,\n  deviceName: 'My-Printer',\n  pageRanges: [{\n    from: 0,\n    to: 1\n  }]\n}\nwin.webContents.print(options, (success, errorType) => {\n  if (!success) console.log(errorType)\n})\n```\n\n#### `contents.printToPDF(options)`\n\n* `options` Object\n  * `headerFooter` Record<string, string> (optional) - the header and footer for the PDF.\n    * `title` String - The title for the PDF header.\n    * `url` String - the url for the PDF footer.\n  * `landscape` Boolean (optional) - `true` for landscape, `false` for portrait.\n  * `marginsType` Integer (optional) - Specifies the type of margins to use. Uses 0 for\n    default margin, 1 for no margin, and 2 for minimum margin.\n  * `scaleFactor` Number (optional) - The scale factor of the web page. Can range from 0 to 100.\n  * `pageRanges` Record<string, number> (optional) - The page range to print.\n    * `from` Number - Index of the first page to print (0-based).\n    * `to` Number - Index of the last page to print (inclusive) (0-based).\n  * `pageSize` String | Size (optional) - Specify page size of the generated PDF. Can be `A3`,\n  `A4`, `A5`, `Legal`, `Letter`, `Tabloid` or an Object containing `height` and `width` in microns.\n  * `printBackground` Boolean (optional) - Whether to print CSS backgrounds.\n  * `printSelectionOnly` Boolean (optional) - Whether to print selection only.\n\nReturns `Promise<Buffer>` - Resolves with the generated PDF data.\n\nPrints window's web page as PDF with Chromium's preview printing custom\nsettings.\n\nThe `landscape` will be ignored if `@page` CSS at-rule is used in the web page.\n\nBy default, an empty `options` will be regarded as:\n\n```javascript\n{\n  marginsType: 0,\n  printBackground: false,\n  printSelectionOnly: false,\n  landscape: false,\n  pageSize: 'A4',\n  scaleFactor: 100\n}\n```\n\nUse `page-break-before: always;` CSS style to force to print to a new page.\n\nAn example of `webContents.printToPDF`:\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\nconst win = new BrowserWindow({ width: 800, height: 600 })\nwin.loadURL('http://github.com')\n\nwin.webContents.on('did-finish-load', () => {\n  // Use default printing options\n  win.webContents.printToPDF({}).then(data => {\n    const pdfPath = path.join(os.homedir(), 'Desktop', 'temp.pdf')\n    fs.writeFile(pdfPath, data, (error) => {\n      if (error) throw error\n      console.log(`Wrote PDF successfully to ${pdfPath}`)\n    })\n  }).catch(error => {\n    console.log(`Failed to write PDF to ${pdfPath}: `, error)\n  })\n})\n```\n\n#### `contents.addWorkSpace(path)`\n\n* `path` String\n\nAdds the specified path to DevTools workspace. Must be used after DevTools\ncreation:\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow()\nwin.webContents.on('devtools-opened', () => {\n  win.webContents.addWorkSpace(__dirname)\n})\n```\n\n#### `contents.removeWorkSpace(path)`\n\n* `path` String\n\nRemoves the specified path from DevTools workspace.\n\n#### `contents.setDevToolsWebContents(devToolsWebContents)`\n\n* `devToolsWebContents` WebContents\n\nUses the `devToolsWebContents` as the target `WebContents` to show devtools.\n\nThe `devToolsWebContents` must not have done any navigation, and it should not\nbe used for other purposes after the call.\n\nBy default Electron manages the devtools by creating an internal `WebContents`\nwith native view, which developers have very limited control of. With the\n`setDevToolsWebContents` method, developers can use any `WebContents` to show\nthe devtools in it, including `BrowserWindow`, `BrowserView` and `<webview>`\ntag.\n\nNote that closing the devtools does not destroy the `devToolsWebContents`, it\nis caller's responsibility to destroy `devToolsWebContents`.\n\nAn example of showing devtools in a `<webview>` tag:\n\n```html\n<html>\n<head>\n  <style type=\"text/css\">\n    * { margin: 0; }\n    #browser { height: 70%; }\n    #devtools { height: 30%; }\n  </style>\n</head>\n<body>\n  <webview id=\"browser\" src=\"https://github.com\"></webview>\n  <webview id=\"devtools\" src=\"about:blank\"></webview>\n  <script>\n    const { ipcRenderer } = require('electron')\n    const emittedOnce = (element, eventName) => new Promise(resolve => {\n      element.addEventListener(eventName, event => resolve(event), { once: true })\n    })\n    const browserView = document.getElementById('browser')\n    const devtoolsView = document.getElementById('devtools')\n    const browserReady = emittedOnce(browserView, 'dom-ready')\n    const devtoolsReady = emittedOnce(devtoolsView, 'dom-ready')\n    Promise.all([browserReady, devtoolsReady]).then(() => {\n      const targetId = browserView.getWebContentsId()\n      const devtoolsId = devtoolsView.getWebContentsId()\n      ipcRenderer.send('open-devtools', targetId, devtoolsId)\n    })\n  </script>\n</body>\n</html>\n```\n\n```js\n// Main process\nconst { ipcMain, webContents } = require('electron')\nipcMain.on('open-devtools', (event, targetContentsId, devtoolsContentsId) => {\n  const target = webContents.fromId(targetContentsId)\n  const devtools = webContents.fromId(devtoolsContentsId)\n  target.setDevToolsWebContents(devtools)\n  target.openDevTools()\n})\n```\n\nAn example of showing devtools in a `BrowserWindow`:\n\n```js\nconst { app, BrowserWindow } = require('electron')\n\nlet win = null\nlet devtools = null\n\napp.whenReady().then(() => {\n  win = new BrowserWindow()\n  devtools = new BrowserWindow()\n  win.loadURL('https://github.com')\n  win.webContents.setDevToolsWebContents(devtools.webContents)\n  win.webContents.openDevTools({ mode: 'detach' })\n})\n```\n\n#### `contents.openDevTools([options])`\n\n* `options` Object (optional)\n  * `mode` String - Opens the devtools with specified dock state, can be\n    `right`, `bottom`, `undocked`, `detach`. Defaults to last used dock state.\n    In `undocked` mode it's possible to dock back. In `detach` mode it's not.\n  * `activate` Boolean (optional) - Whether to bring the opened devtools window\n    to the foreground. The default is `true`.\n\nOpens the devtools.\n\nWhen `contents` is a `<webview>` tag, the `mode` would be `detach` by default,\nexplicitly passing an empty `mode` can force using last used dock state.\n\n#### `contents.closeDevTools()`\n\nCloses the devtools.\n\n#### `contents.isDevToolsOpened()`\n\nReturns `Boolean` - Whether the devtools is opened.\n\n#### `contents.isDevToolsFocused()`\n\nReturns `Boolean` - Whether the devtools view is focused .\n\n#### `contents.toggleDevTools()`\n\nToggles the developer tools.\n\n#### `contents.inspectElement(x, y)`\n\n* `x` Integer\n* `y` Integer\n\nStarts inspecting element at position (`x`, `y`).\n\n#### `contents.inspectSharedWorker()`\n\nOpens the developer tools for the shared worker context.\n\n#### `contents.inspectSharedWorkerById(workerId)`\n\n* `workerId` String\n\nInspects the shared worker based on its ID.\n\n#### `contents.getAllSharedWorkers()`\n\nReturns [`SharedWorkerInfo[]`](structures/shared-worker-info.md) - Information about all Shared Workers.\n\n#### `contents.inspectServiceWorker()`\n\nOpens the developer tools for the service worker context.\n\n#### `contents.send(channel, ...args)`\n\n* `channel` String\n* `...args` any[]\n\nSend an asynchronous message to the renderer process via `channel`, along with\narguments. Arguments will be serialized with the [Structured Clone\nAlgorithm][SCA], just like [`postMessage`][], so prototype chains will not be\nincluded. Sending Functions, Promises, Symbols, WeakMaps, or WeakSets will\nthrow an exception.\n\n> **NOTE**: Sending non-standard JavaScript types such as DOM objects or\n> special Electron objects is deprecated, and will begin throwing an exception\n> starting with Electron 9.\n\nThe renderer process can handle the message by listening to `channel` with the\n[`ipcRenderer`](ipc-renderer.md) module.\n\nAn example of sending messages from the main process to the renderer process:\n\n```javascript\n// In the main process.\nconst { app, BrowserWindow } = require('electron')\nlet win = null\n\napp.whenReady().then(() => {\n  win = new BrowserWindow({ width: 800, height: 600 })\n  win.loadURL(`file://${__dirname}/index.html`)\n  win.webContents.on('did-finish-load', () => {\n    win.webContents.send('ping', 'whoooooooh!')\n  })\n})\n```\n\n```html\n<!-- index.html -->\n<html>\n<body>\n  <script>\n    require('electron').ipcRenderer.on('ping', (event, message) => {\n      console.log(message) // Prints 'whoooooooh!'\n    })\n  </script>\n</body>\n</html>\n```\n\n#### `contents.sendToFrame(frameId, channel, ...args)`\n\n* `frameId` Integer | [number, number]\n* `channel` String\n* `...args` any[]\n\nSend an asynchronous message to a specific frame in a renderer process via\n`channel`, along with arguments. Arguments will be serialized with the\n[Structured Clone Algorithm][SCA], just like [`postMessage`][], so prototype\nchains will not be included. Sending Functions, Promises, Symbols, WeakMaps, or\nWeakSets will throw an exception.\n\n> **NOTE**: Sending non-standard JavaScript types such as DOM objects or\n> special Electron objects is deprecated, and will begin throwing an exception\n> starting with Electron 9.\n\nThe renderer process can handle the message by listening to `channel` with the\n[`ipcRenderer`](ipc-renderer.md) module.\n\nIf you want to get the `frameId` of a given renderer context you should use\nthe `webFrame.routingId` value.  E.g.\n\n```js\n// In a renderer process\nconsole.log('My frameId is:', require('electron').webFrame.routingId)\n```\n\nYou can also read `frameId` from all incoming IPC messages in the main process.\n\n```js\n// In the main process\nipcMain.on('ping', (event) => {\n  console.info('Message came from frameId:', event.frameId)\n})\n```\n\n#### `contents.postMessage(channel, message, [transfer])`\n\n* `channel` String\n* `message` any\n* `transfer` MessagePortMain[] (optional)\n\nSend a message to the renderer process, optionally transferring ownership of\nzero or more [`MessagePortMain`][] objects.\n\nThe transferred `MessagePortMain` objects will be available in the renderer\nprocess by accessing the `ports` property of the emitted event. When they\narrive in the renderer, they will be native DOM `MessagePort` objects.\n\nFor example:\n\n```js\n// Main process\nconst { port1, port2 } = new MessageChannelMain()\nwebContents.postMessage('port', { message: 'hello' }, [port1])\n\n// Renderer process\nipcRenderer.on('port', (e, msg) => {\n  const [port] = e.ports\n  // ...\n})\n```\n\n#### `contents.enableDeviceEmulation(parameters)`\n\n* `parameters` Object\n  * `screenPosition` String - Specify the screen type to emulate\n      (default: `desktop`):\n    * `desktop` - Desktop screen type.\n    * `mobile` - Mobile screen type.\n  * `screenSize` [Size](structures/size.md) - Set the emulated screen size (screenPosition == mobile).\n  * `viewPosition` [Point](structures/point.md) - Position the view on the screen\n      (screenPosition == mobile) (default: `{ x: 0, y: 0 }`).\n  * `deviceScaleFactor` Integer - Set the device scale factor (if zero defaults to\n      original device scale factor) (default: `0`).\n  * `viewSize` [Size](structures/size.md) - Set the emulated view size (empty means no override)\n  * `scale` Float - Scale of emulated view inside available space (not in fit to\n      view mode) (default: `1`).\n\nEnable device emulation with the given parameters.\n\n#### `contents.disableDeviceEmulation()`\n\nDisable device emulation enabled by `webContents.enableDeviceEmulation`.\n\n#### `contents.sendInputEvent(inputEvent)`\n\n* `inputEvent` [MouseInputEvent](structures/mouse-input-event.md) | [MouseWheelInputEvent](structures/mouse-wheel-input-event.md) | [KeyboardInputEvent](structures/keyboard-input-event.md)\n\nSends an input `event` to the page.\n**Note:** The [`BrowserWindow`](browser-window.md) containing the contents needs to be focused for\n`sendInputEvent()` to work.\n\n#### `contents.beginFrameSubscription([onlyDirty ,]callback)`\n\n* `onlyDirty` Boolean (optional) - Defaults to `false`.\n* `callback` Function\n  * `image` [NativeImage](native-image.md)\n  * `dirtyRect` [Rectangle](structures/rectangle.md)\n\nBegin subscribing for presentation events and captured frames, the `callback`\nwill be called with `callback(image, dirtyRect)` when there is a presentation\nevent.\n\nThe `image` is an instance of [NativeImage](native-image.md) that stores the\ncaptured frame.\n\nThe `dirtyRect` is an object with `x, y, width, height` properties that\ndescribes which part of the page was repainted. If `onlyDirty` is set to\n`true`, `image` will only contain the repainted area. `onlyDirty` defaults to\n`false`.\n\n#### `contents.endFrameSubscription()`\n\nEnd subscribing for frame presentation events.\n\n#### `contents.startDrag(item)`\n\n* `item` Object\n  * `file` String[] | String - The path(s) to the file(s) being dragged.\n  * `icon` [NativeImage](native-image.md) | String - The image must be\n    non-empty on macOS.\n\nSets the `item` as dragging item for current drag-drop operation, `file` is the\nabsolute path of the file to be dragged, and `icon` is the image showing under\nthe cursor when dragging.\n\n#### `contents.savePage(fullPath, saveType)`\n\n* `fullPath` String - The full file path.\n* `saveType` String - Specify the save type.\n  * `HTMLOnly` - Save only the HTML of the page.\n  * `HTMLComplete` - Save complete-html page.\n  * `MHTML` - Save complete-html page as MHTML.\n\nReturns `Promise<void>` - resolves if the page is saved.\n\n```javascript\nconst { BrowserWindow } = require('electron')\nconst win = new BrowserWindow()\n\nwin.loadURL('https://github.com')\n\nwin.webContents.on('did-finish-load', async () => {\n  win.webContents.savePage('/tmp/test.html', 'HTMLComplete').then(() => {\n    console.log('Page was saved successfully.')\n  }).catch(err => {\n    console.log(err)\n  })\n})\n```\n\n#### `contents.showDefinitionForSelection()` _macOS_\n\nShows pop-up dictionary that searches the selected word on the page.\n\n#### `contents.isOffscreen()`\n\nReturns `Boolean` - Indicates whether *offscreen rendering* is enabled.\n\n#### `contents.startPainting()`\n\nIf *offscreen rendering* is enabled and not painting, start painting.\n\n#### `contents.stopPainting()`\n\nIf *offscreen rendering* is enabled and painting, stop painting.\n\n#### `contents.isPainting()`\n\nReturns `Boolean` - If *offscreen rendering* is enabled returns whether it is currently painting.\n\n#### `contents.setFrameRate(fps)`\n\n* `fps` Integer\n\nIf *offscreen rendering* is enabled sets the frame rate to the specified number.\nOnly values between 1 and 240 are accepted.\n\n#### `contents.getFrameRate()`\n\nReturns `Integer` - If *offscreen rendering* is enabled returns the current frame rate.\n\n#### `contents.invalidate()`\n\nSchedules a full repaint of the window this web contents is in.\n\nIf *offscreen rendering* is enabled invalidates the frame and generates a new\none through the `'paint'` event.\n\n#### `contents.getWebRTCIPHandlingPolicy()`\n\nReturns `String` - Returns the WebRTC IP Handling Policy.\n\n#### `contents.setWebRTCIPHandlingPolicy(policy)`\n\n* `policy` String - Specify the WebRTC IP Handling Policy.\n  * `default` - Exposes user's public and local IPs. This is the default\n  behavior. When this policy is used, WebRTC has the right to enumerate all\n  interfaces and bind them to discover public interfaces.\n  * `default_public_interface_only` - Exposes user's public IP, but does not\n  expose user's local IP. When this policy is used, WebRTC should only use the\n  default route used by http. This doesn't expose any local addresses.\n  * `default_public_and_private_interfaces` - Exposes user's public and local\n  IPs. When this policy is used, WebRTC should only use the default route used\n  by http. This also exposes the associated default private address. Default\n  route is the route chosen by the OS on a multi-homed endpoint.\n  * `disable_non_proxied_udp` - Does not expose public or local IPs. When this\n  policy is used, WebRTC should only use TCP to contact peers or servers unless\n  the proxy server supports UDP.\n\nSetting the WebRTC IP handling policy allows you to control which IPs are\nexposed via WebRTC. See [BrowserLeaks](https://browserleaks.com/webrtc) for\nmore details.\n\n#### `contents.getOSProcessId()`\n\nReturns `Integer` - The operating system `pid` of the associated renderer\nprocess.\n\n#### `contents.getProcessId()`\n\nReturns `Integer` - The Chromium internal `pid` of the associated renderer. Can\nbe compared to the `frameProcessId` passed by frame specific navigation events\n(e.g. `did-frame-navigate`)\n\n#### `contents.takeHeapSnapshot(filePath)`\n\n* `filePath` String - Path to the output file.\n\nReturns `Promise<void>` - Indicates whether the snapshot has been created successfully.\n\nTakes a V8 heap snapshot and saves it to `filePath`.\n\n#### `contents.getBackgroundThrottling()`\n\nReturns `Boolean` - whether or not this WebContents will throttle animations and timers\nwhen the page becomes backgrounded. This also affects the Page Visibility API.\n\n#### `contents.setBackgroundThrottling(allowed)`\n\n* `allowed` Boolean\n\nControls whether or not this WebContents will throttle animations and timers\nwhen the page becomes backgrounded. This also affects the Page Visibility API.\n\n#### `contents.getType()`\n\nReturns `String` - the type of the webContent. Can be `backgroundPage`, `window`, `browserView`, `remote`, `webview` or `offscreen`.\n\n### Instance Properties\n\n#### `contents.audioMuted`\n\nA `Boolean` property that determines whether this page is muted.\n\n#### `contents.userAgent`\n\nA `String` property that determines the user agent for this web page.\n\n#### `contents.zoomLevel`\n\nA `Number` property that determines the zoom level for this web contents.\n\nThe original size is 0 and each increment above or below represents zooming 20% larger or smaller to default limits of 300% and 50% of original size, respectively. The formula for this is `scale := 1.2 ^ level`.\n\n#### `contents.zoomFactor`\n\nA `Number` property that determines the zoom factor for this web contents.\n\nThe zoom factor is the zoom percent divided by 100, so 300% = 3.0.\n\n#### `contents.frameRate`\n\nAn `Integer` property that sets the frame rate of the web contents to the specified number.\nOnly values between 1 and 240 are accepted.\n\nOnly applicable if *offscreen rendering* is enabled.\n\n#### `contents.id` _Readonly_\n\nA `Integer` representing the unique ID of this WebContents. Each ID is unique among all `WebContents` instances of the entire Electron application.\n\n#### `contents.session` _Readonly_\n\nA [`Session`](session.md) used by this webContents.\n\n#### `contents.hostWebContents` _Readonly_\n\nA [`WebContents`](web-contents.md) instance that might own this `WebContents`.\n\n#### `contents.devToolsWebContents` _Readonly_\n\nA `WebContents | null` property that represents the of DevTools `WebContents` associated with a given `WebContents`.\n\n**Note:** Users should never store this object because it may become `null`\nwhen the DevTools has been closed.\n\n#### `contents.debugger` _Readonly_\n\nA [`Debugger`](debugger.md) instance for this webContents.\n\n[keyboardevent]: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent\n[event-emitter]: https://nodejs.org/api/events.html#events_class_eventemitter\n[SCA]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm\n[`postMessage`]: https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n\n#### `contents.backgroundThrottling`\n\nA `Boolean` property that determines whether or not this WebContents will throttle animations and timers\nwhen the page becomes backgrounded. This also affects the Page Visibility API.\n\n#### `contents.mainFrame` _Readonly_\n\nA [`WebFrameMain`](web-frame-main.md) property that represents the top frame of the page's frame hierarchy.\n", "import { app, ipcMain, session, deprecate, BrowserWindowConstructorOptions } from 'electron/main';\nimport type { MenuItem, MenuItemConstructorOptions, LoadURLOptions } from 'electron/main';\n\nimport * as url from 'url';\nimport * as path from 'path';\nimport { openGuestWindow, makeWebPreferences } from '@electron/internal/browser/guest-window-manager';\nimport { NavigationController } from '@electron/internal/browser/navigation-controller';\nimport { ipcMainInternal } from '@electron/internal/browser/ipc-main-internal';\nimport * as ipcMainUtils from '@electron/internal/browser/ipc-main-internal-utils';\nimport { MessagePortMain } from '@electron/internal/browser/message-port-main';\nimport { IPC_MESSAGES } from '@electron/internal/common/ipc-messages';\n\n// session is not used here, the purpose is to make sure session is initalized\n// before the webContents module.\n// eslint-disable-next-line\nsession\n\nlet nextId = 0;\nconst getNextId = function () {\n  return ++nextId;\n};\n\ntype PostData = LoadURLOptions['postData']\n\n/* eslint-disable camelcase */\ntype MediaSize = {\n  name: string,\n  custom_display_name: string,\n  height_microns: number,\n  width_microns: number,\n  is_default?: 'true',\n}\n/* eslint-enable camelcase */\n\n// Stock page sizes\nconst PDFPageSizes: Record<string, MediaSize> = {\n  A5: {\n    custom_display_name: 'A5',\n    height_microns: 210000,\n    name: 'ISO_A5',\n    width_microns: 148000\n  },\n  A4: {\n    custom_display_name: 'A4',\n    height_microns: 297000,\n    name: 'ISO_A4',\n    is_default: 'true',\n    width_microns: 210000\n  },\n  A3: {\n    custom_display_name: 'A3',\n    height_microns: 420000,\n    name: 'ISO_A3',\n    width_microns: 297000\n  },\n  Legal: {\n    custom_display_name: 'Legal',\n    height_microns: 355600,\n    name: 'NA_LEGAL',\n    width_microns: 215900\n  },\n  Letter: {\n    custom_display_name: 'Letter',\n    height_microns: 279400,\n    name: 'NA_LETTER',\n    width_microns: 215900\n  },\n  Tabloid: {\n    height_microns: 431800,\n    name: 'NA_LEDGER',\n    width_microns: 279400,\n    custom_display_name: 'Tabloid'\n  }\n};\n\n// The minimum micron size Chromium accepts is that where:\n// Per printing/units.h:\n//  * kMicronsPerInch - Length of an inch in 0.001mm unit.\n//  * kPointsPerInch - Length of an inch in CSS's 1pt unit.\n//\n// Formula: (kPointsPerInch / kMicronsPerInch) * size >= 1\n//\n// Practically, this means microns need to be > 352 microns.\n// We therefore need to verify this or it will silently fail.\nconst isValidCustomPageSize = (width: number, height: number) => {\n  return [width, height].every(x => x > 352);\n};\n\n// Default printing setting\nconst defaultPrintingSetting = {\n  // Customizable.\n  pageRange: [] as {from: number, to: number}[],\n  mediaSize: {} as MediaSize,\n  landscape: false,\n  headerFooterEnabled: false,\n  marginsType: 0,\n  scaleFactor: 100,\n  shouldPrintBackgrounds: false,\n  shouldPrintSelectionOnly: false,\n  // Non-customizable.\n  printWithCloudPrint: false,\n  printWithPrivet: false,\n  printWithExtension: false,\n  pagesPerSheet: 1,\n  isFirstRequest: false,\n  previewUIID: 0,\n  previewModifiable: true,\n  printToPDF: true,\n  deviceName: 'Save as PDF',\n  generateDraftData: true,\n  dpiHorizontal: 72,\n  dpiVertical: 72,\n  rasterizePDF: false,\n  duplex: 0,\n  copies: 1,\n  // 2 = color - see ColorModel in //printing/print_job_constants.h\n  color: 2,\n  collate: true,\n  printerType: 2,\n  title: undefined as string | undefined,\n  url: undefined as string | undefined\n};\n\n// JavaScript implementations of WebContents.\nconst binding = process._linkedBinding('electron_browser_web_contents');\nconst printing = process._linkedBinding('electron_browser_printing');\nconst { WebContents } = binding as { WebContents: { prototype: Electron.WebContents } };\n\nWebContents.prototype.send = function (channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  }\n\n  return this._send(false /* internal */, channel, args);\n};\n\nWebContents.prototype.postMessage = function (...args) {\n  if (Array.isArray(args[2])) {\n    args[2] = args[2].map(o => o instanceof MessagePortMain ? o._internalPort : o);\n  }\n  this._postMessage(...args);\n};\n\nWebContents.prototype._sendInternal = function (channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  }\n\n  return this._send(true /* internal */, channel, args);\n};\nWebContents.prototype.sendToFrame = function (frame, channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  } else if (!(typeof frame === 'number' || Array.isArray(frame))) {\n    throw new Error('Missing required frame argument (must be number or array)');\n  }\n\n  return this._sendToFrame(false /* internal */, frame, channel, args);\n};\nWebContents.prototype._sendToFrameInternal = function (frame, channel, ...args) {\n  if (typeof channel !== 'string') {\n    throw new Error('Missing required channel argument');\n  } else if (!(typeof frame === 'number' || Array.isArray(frame))) {\n    throw new Error('Missing required frame argument (must be number or array)');\n  }\n\n  return this._sendToFrame(true /* internal */, frame, channel, args);\n};\n\n// Following methods are mapped to webFrame.\nconst webFrameMethods = [\n  'insertCSS',\n  'insertText',\n  'removeInsertedCSS',\n  'setVisualZoomLevelLimits'\n] as ('insertCSS' | 'insertText' | 'removeInsertedCSS' | 'setVisualZoomLevelLimits')[];\n\nfor (const method of webFrameMethods) {\n  WebContents.prototype[method] = function (...args: any[]): Promise<any> {\n    return ipcMainUtils.invokeInWebContents(this, IPC_MESSAGES.RENDERER_WEB_FRAME_METHOD, method, ...args);\n  };\n}\n\nconst waitTillCanExecuteJavaScript = async (webContents: Electron.WebContents) => {\n  if (webContents.getURL() && !webContents.isLoadingMainFrame()) return;\n\n  return new Promise((resolve) => {\n    webContents.once('did-stop-loading', () => {\n      resolve();\n    });\n  });\n};\n\n// Make sure WebContents::executeJavaScript would run the code only when the\n// WebContents has been loaded.\nWebContents.prototype.executeJavaScript = async function (code, hasUserGesture) {\n  await waitTillCanExecuteJavaScript(this);\n  return ipcMainUtils.invokeInWebContents(this, IPC_MESSAGES.RENDERER_WEB_FRAME_METHOD, 'executeJavaScript', String(code), !!hasUserGesture);\n};\nWebContents.prototype.executeJavaScriptInIsolatedWorld = async function (worldId, code, hasUserGesture) {\n  await waitTillCanExecuteJavaScript(this);\n  return ipcMainUtils.invokeInWebContents(this, IPC_MESSAGES.RENDERER_WEB_FRAME_METHOD, 'executeJavaScriptInIsolatedWorld', worldId, code, !!hasUserGesture);\n};\n\n// Translate the options of printToPDF.\n\nlet pendingPromise: Promise<any> | undefined;\nWebContents.prototype.printToPDF = async function (options) {\n  const printSettings = {\n    ...defaultPrintingSetting,\n    requestID: getNextId()\n  };\n\n  if (options.landscape !== undefined) {\n    if (typeof options.landscape !== 'boolean') {\n      const error = new Error('landscape must be a Boolean');\n      return Promise.reject(error);\n    }\n    printSettings.landscape = options.landscape;\n  }\n\n  if (options.scaleFactor !== undefined) {\n    if (typeof options.scaleFactor !== 'number') {\n      const error = new Error('scaleFactor must be a Number');\n      return Promise.reject(error);\n    }\n    printSettings.scaleFactor = options.scaleFactor;\n  }\n\n  if (options.marginsType !== undefined) {\n    if (typeof options.marginsType !== 'number') {\n      const error = new Error('marginsType must be a Number');\n      return Promise.reject(error);\n    }\n    printSettings.marginsType = options.marginsType;\n  }\n\n  if (options.printSelectionOnly !== undefined) {\n    if (typeof options.printSelectionOnly !== 'boolean') {\n      const error = new Error('printSelectionOnly must be a Boolean');\n      return Promise.reject(error);\n    }\n    printSettings.shouldPrintSelectionOnly = options.printSelectionOnly;\n  }\n\n  if (options.printBackground !== undefined) {\n    if (typeof options.printBackground !== 'boolean') {\n      const error = new Error('printBackground must be a Boolean');\n      return Promise.reject(error);\n    }\n    printSettings.shouldPrintBackgrounds = options.printBackground;\n  }\n\n  if (options.pageRanges !== undefined) {\n    const pageRanges = options.pageRanges;\n    if (!Object.prototype.hasOwnProperty.call(pageRanges, 'from') || !Object.prototype.hasOwnProperty.call(pageRanges, 'to')) {\n      const error = new Error('pageRanges must be an Object with \\'from\\' and \\'to\\' properties');\n      return Promise.reject(error);\n    }\n\n    if (typeof pageRanges.from !== 'number') {\n      const error = new Error('pageRanges.from must be a Number');\n      return Promise.reject(error);\n    }\n\n    if (typeof pageRanges.to !== 'number') {\n      const error = new Error('pageRanges.to must be a Number');\n      return Promise.reject(error);\n    }\n\n    // Chromium uses 1-based page ranges, so increment each by 1.\n    printSettings.pageRange = [{\n      from: pageRanges.from + 1,\n      to: pageRanges.to + 1\n    }];\n  }\n\n  if (options.headerFooter !== undefined) {\n    const headerFooter = options.headerFooter;\n    printSettings.headerFooterEnabled = true;\n    if (typeof headerFooter === 'object') {\n      if (!headerFooter.url || !headerFooter.title) {\n        const error = new Error('url and title properties are required for headerFooter');\n        return Promise.reject(error);\n      }\n      if (typeof headerFooter.title !== 'string') {\n        const error = new Error('headerFooter.title must be a String');\n        return Promise.reject(error);\n      }\n      printSettings.title = headerFooter.title;\n\n      if (typeof headerFooter.url !== 'string') {\n        const error = new Error('headerFooter.url must be a String');\n        return Promise.reject(error);\n      }\n      printSettings.url = headerFooter.url;\n    } else {\n      const error = new Error('headerFooter must be an Object');\n      return Promise.reject(error);\n    }\n  }\n\n  // Optionally set size for PDF.\n  if (options.pageSize !== undefined) {\n    const pageSize = options.pageSize;\n    if (typeof pageSize === 'object') {\n      if (!pageSize.height || !pageSize.width) {\n        const error = new Error('height and width properties are required for pageSize');\n        return Promise.reject(error);\n      }\n\n      // Dimensions in Microns - 1 meter = 10^6 microns\n      const height = Math.ceil(pageSize.height);\n      const width = Math.ceil(pageSize.width);\n      if (!isValidCustomPageSize(width, height)) {\n        const error = new Error('height and width properties must be minimum 352 microns.');\n        return Promise.reject(error);\n      }\n\n      printSettings.mediaSize = {\n        name: 'CUSTOM',\n        custom_display_name: 'Custom',\n        height_microns: height,\n        width_microns: width\n      };\n    } else if (Object.prototype.hasOwnProperty.call(PDFPageSizes, pageSize)) {\n      printSettings.mediaSize = PDFPageSizes[pageSize];\n    } else {\n      const error = new Error(`Unsupported pageSize: ${pageSize}`);\n      return Promise.reject(error);\n    }\n  } else {\n    printSettings.mediaSize = PDFPageSizes.A4;\n  }\n\n  // Chromium expects this in a 0-100 range number, not as float\n  printSettings.scaleFactor = Math.ceil(printSettings.scaleFactor) % 100;\n  // PrinterType enum from //printing/print_job_constants.h\n  printSettings.printerType = 2;\n  if (this._printToPDF) {\n    if (pendingPromise) {\n      pendingPromise = pendingPromise.then(() => this._printToPDF(printSettings));\n    } else {\n      pendingPromise = this._printToPDF(printSettings);\n    }\n    return pendingPromise;\n  } else {\n    const error = new Error('Printing feature is disabled');\n    return Promise.reject(error);\n  }\n};\n\nWebContents.prototype.print = function (options = {}, callback) {\n  // TODO(codebytere): deduplicate argument sanitization by moving rest of\n  // print param logic into new file shared between printToPDF and print\n  if (typeof options === 'object') {\n    // Optionally set size for PDF.\n    if (options.pageSize !== undefined) {\n      const pageSize = options.pageSize;\n      if (typeof pageSize === 'object') {\n        if (!pageSize.height || !pageSize.width) {\n          throw new Error('height and width properties are required for pageSize');\n        }\n\n        // Dimensions in Microns - 1 meter = 10^6 microns\n        const height = Math.ceil(pageSize.height);\n        const width = Math.ceil(pageSize.width);\n        if (!isValidCustomPageSize(width, height)) {\n          throw new Error('height and width properties must be minimum 352 microns.');\n        }\n\n        (options as any).mediaSize = {\n          name: 'CUSTOM',\n          custom_display_name: 'Custom',\n          height_microns: height,\n          width_microns: width\n        };\n      } else if (PDFPageSizes[pageSize]) {\n        (options as any).mediaSize = PDFPageSizes[pageSize];\n      } else {\n        throw new Error(`Unsupported pageSize: ${pageSize}`);\n      }\n    }\n  }\n\n  if (this._print) {\n    if (callback) {\n      this._print(options, callback);\n    } else {\n      this._print(options);\n    }\n  } else {\n    console.error('Error: Printing feature is disabled.');\n  }\n};\n\nWebContents.prototype.getPrinters = function () {\n  // TODO(nornagon): this API has nothing to do with WebContents and should be\n  // moved.\n  if (printing.getPrinterList) {\n    return printing.getPrinterList();\n  } else {\n    console.error('Error: Printing feature is disabled.');\n    return [];\n  }\n};\n\nWebContents.prototype.loadFile = function (filePath, options = {}) {\n  if (typeof filePath !== 'string') {\n    throw new Error('Must pass filePath as a string');\n  }\n  const { query, search, hash } = options;\n\n  return this.loadURL(url.format({\n    protocol: 'file',\n    slashes: true,\n    pathname: path.resolve(app.getAppPath(), filePath),\n    query,\n    search,\n    hash\n  }));\n};\n\nWebContents.prototype.setWindowOpenHandler = function (handler: (details: Electron.HandlerDetails) => ({action: 'allow'} | {action: 'deny', overrideBrowserWindowOptions?: BrowserWindowConstructorOptions})) {\n  this._windowOpenHandler = handler;\n};\n\nWebContents.prototype._callWindowOpenHandler = function (event: any, url: string, frameName: string, rawFeatures: string): BrowserWindowConstructorOptions | null {\n  if (!this._windowOpenHandler) {\n    return null;\n  }\n  const response = this._windowOpenHandler({ url, frameName, features: rawFeatures });\n\n  if (typeof response !== 'object') {\n    event.preventDefault();\n    console.error(`The window open handler response must be an object, but was instead of type '${typeof response}'.`);\n    return null;\n  }\n\n  if (response === null) {\n    event.preventDefault();\n    console.error('The window open handler response must be an object, but was instead null.');\n    return null;\n  }\n\n  if (response.action === 'deny') {\n    event.preventDefault();\n    return null;\n  } else if (response.action === 'allow') {\n    if (typeof response.overrideBrowserWindowOptions === 'object' && response.overrideBrowserWindowOptions !== null) { return response.overrideBrowserWindowOptions; } else { return {}; }\n  } else {\n    event.preventDefault();\n    console.error('The window open handler response must be an object with an \\'action\\' property of \\'allow\\' or \\'deny\\'.');\n    return null;\n  }\n};\n\nconst addReplyToEvent = (event: any) => {\n  const { processId, frameId } = event;\n  event.reply = (...args: any[]) => {\n    event.sender.sendToFrame([processId, frameId], ...args);\n  };\n};\n\nconst addReturnValueToEvent = (event: any) => {\n  Object.defineProperty(event, 'returnValue', {\n    set: (value) => event.sendReply(value),\n    get: () => {}\n  });\n};\n\nconst commandLine = process._linkedBinding('electron_common_command_line');\nconst environment = process._linkedBinding('electron_common_environment');\n\nconst loggingEnabled = () => {\n  return environment.hasVar('ELECTRON_ENABLE_LOGGING') || commandLine.hasSwitch('enable-logging');\n};\n\n// Add JavaScript wrappers for WebContents class.\nWebContents.prototype._init = function () {\n  // The navigation controller.\n  const navigationController = new NavigationController(this);\n  this.loadURL = navigationController.loadURL.bind(navigationController);\n  this.getURL = navigationController.getURL.bind(navigationController);\n  this.stop = navigationController.stop.bind(navigationController);\n  this.reload = navigationController.reload.bind(navigationController);\n  this.reloadIgnoringCache = navigationController.reloadIgnoringCache.bind(navigationController);\n  this.canGoBack = navigationController.canGoBack.bind(navigationController);\n  this.canGoForward = navigationController.canGoForward.bind(navigationController);\n  this.canGoToIndex = navigationController.canGoToIndex.bind(navigationController);\n  this.canGoToOffset = navigationController.canGoToOffset.bind(navigationController);\n  this.clearHistory = navigationController.clearHistory.bind(navigationController);\n  this.goBack = navigationController.goBack.bind(navigationController);\n  this.goForward = navigationController.goForward.bind(navigationController);\n  this.goToIndex = navigationController.goToIndex.bind(navigationController);\n  this.goToOffset = navigationController.goToOffset.bind(navigationController);\n  this.getActiveIndex = navigationController.getActiveIndex.bind(navigationController);\n  this.length = navigationController.length.bind(navigationController);\n\n  this._windowOpenHandler = null;\n\n  // Every remote callback from renderer process would add a listener to the\n  // render-view-deleted event, so ignore the listeners warning.\n  this.setMaxListeners(0);\n\n  // Dispatch IPC messages to the ipc module.\n  this.on('-ipc-message' as any, function (this: Electron.WebContents, event: any, internal: boolean, channel: string, args: any[]) {\n    if (internal) {\n      ipcMainInternal.emit(channel, event, ...args);\n    } else {\n      addReplyToEvent(event);\n      this.emit('ipc-message', event, channel, ...args);\n      ipcMain.emit(channel, event, ...args);\n    }\n  });\n\n  this.on('-ipc-invoke' as any, function (event: any, internal: boolean, channel: string, args: any[]) {\n    event._reply = (result: any) => event.sendReply({ result });\n    event._throw = (error: Error) => {\n      console.error(`Error occurred in handler for '${channel}':`, error);\n      event.sendReply({ error: error.toString() });\n    };\n    const target = internal ? ipcMainInternal : ipcMain;\n    if ((target as any)._invokeHandlers.has(channel)) {\n      (target as any)._invokeHandlers.get(channel)(event, ...args);\n    } else {\n      event._throw(`No handler registered for '${channel}'`);\n    }\n  });\n\n  this.on('-ipc-message-sync' as any, function (this: Electron.WebContents, event: any, internal: boolean, channel: string, args: any[]) {\n    addReturnValueToEvent(event);\n    if (internal) {\n      ipcMainInternal.emit(channel, event, ...args);\n    } else {\n      addReplyToEvent(event);\n      this.emit('ipc-message-sync', event, channel, ...args);\n      ipcMain.emit(channel, event, ...args);\n    }\n  });\n\n  this.on('-ipc-ports' as any, function (event: any, internal: boolean, channel: string, message: any, ports: any[]) {\n    event.ports = ports.map(p => new MessagePortMain(p));\n    ipcMain.emit(channel, event, message);\n  });\n\n  // Handle context menu action request from pepper plugin.\n  this.on('pepper-context-menu' as any, function (event: any, params: {x: number, y: number, menu: Array<(MenuItemConstructorOptions) | (MenuItem)>}, callback: () => void) {\n    // Access Menu via electron.Menu to prevent circular require.\n    const menu = require('electron').Menu.buildFromTemplate(params.menu);\n    menu.popup({\n      window: event.sender.getOwnerBrowserWindow(),\n      x: params.x,\n      y: params.y,\n      callback\n    });\n  });\n\n  this.on('crashed', (event, ...args) => {\n    app.emit('renderer-process-crashed', event, this, ...args);\n  });\n\n  this.on('render-process-gone', (event, details) => {\n    app.emit('render-process-gone', event, this, details);\n\n    // Log out a hint to help users better debug renderer crashes.\n    if (loggingEnabled()) {\n      console.info(`Renderer process ${details.reason} - see https://www.electronjs.org/docs/tutorial/application-debugging for potential debugging information.`);\n    }\n  });\n\n  // The devtools requests the webContents to reload.\n  this.on('devtools-reload-page', function (this: Electron.WebContents) {\n    this.reload();\n  });\n\n  if (this.getType() !== 'remote') {\n    // Make new windows requested by links behave like \"window.open\".\n    this.on('-new-window' as any, (event: any, url: string, frameName: string, disposition: string,\n      rawFeatures: string, referrer: any, postData: PostData) => {\n      openGuestWindow({\n        event,\n        embedder: event.sender,\n        disposition,\n        referrer,\n        postData,\n        overrideBrowserWindowOptions: {},\n        windowOpenArgs: {\n          url,\n          frameName,\n          features: rawFeatures\n        }\n      });\n    });\n\n    let windowOpenOverriddenOptions: BrowserWindowConstructorOptions | null = null;\n    this.on('-will-add-new-contents' as any, (event: any, url: string, frameName: string, rawFeatures: string) => {\n      windowOpenOverriddenOptions = this._callWindowOpenHandler(event, url, frameName, rawFeatures);\n      if (!event.defaultPrevented) {\n        const secureOverrideWebPreferences = windowOpenOverriddenOptions ? {\n          // Allow setting of backgroundColor as a webPreference even though\n          // it's technically a BrowserWindowConstructorOptions option because\n          // we need to access it in the renderer at init time.\n          backgroundColor: windowOpenOverriddenOptions.backgroundColor,\n          ...windowOpenOverriddenOptions.webPreferences\n        } : undefined;\n        this._setNextChildWebPreferences(\n          makeWebPreferences({ embedder: event.sender, secureOverrideWebPreferences })\n        );\n      }\n    });\n\n    // Create a new browser window for the native implementation of\n    // \"window.open\", used in sandbox and nativeWindowOpen mode.\n    this.on('-add-new-contents' as any, (event: any, webContents: Electron.WebContents, disposition: string,\n      _userGesture: boolean, _left: number, _top: number, _width: number, _height: number, url: string, frameName: string,\n      referrer: Electron.Referrer, rawFeatures: string, postData: PostData) => {\n      const overriddenOptions = windowOpenOverriddenOptions || undefined;\n      windowOpenOverriddenOptions = null;\n\n      if ((disposition !== 'foreground-tab' && disposition !== 'new-window' &&\n           disposition !== 'background-tab')) {\n        event.preventDefault();\n        return;\n      }\n\n      openGuestWindow({\n        event,\n        embedder: event.sender,\n        guest: webContents,\n        overrideBrowserWindowOptions: overriddenOptions,\n        disposition,\n        referrer,\n        postData,\n        windowOpenArgs: {\n          url,\n          frameName,\n          features: rawFeatures\n        }\n      });\n    });\n\n    const prefs = this.getWebPreferences() || {};\n    if (prefs.webviewTag && prefs.contextIsolation) {\n      deprecate.log('Security Warning: A WebContents was just created with both webviewTag and contextIsolation enabled.  This combination is fundamentally less secure and effectively bypasses the protections of contextIsolation.  We strongly recommend you move away from webviews to OOPIF or BrowserView in order for your app to be more secure');\n    }\n  }\n\n  this.on('login', (event, ...args) => {\n    app.emit('login', event, this, ...args);\n  });\n\n  this.on('ready-to-show' as any, () => {\n    const owner = this.getOwnerBrowserWindow();\n    if (owner && !owner.isDestroyed()) {\n      process.nextTick(() => {\n        owner.emit('ready-to-show');\n      });\n    }\n  });\n\n  const event = process._linkedBinding('electron_browser_event').createEmpty();\n  app.emit('web-contents-created', event, this);\n\n  // Properties\n\n  Object.defineProperty(this, 'audioMuted', {\n    get: () => this.isAudioMuted(),\n    set: (muted) => this.setAudioMuted(muted)\n  });\n\n  Object.defineProperty(this, 'userAgent', {\n    get: () => this.getUserAgent(),\n    set: (agent) => this.setUserAgent(agent)\n  });\n\n  Object.defineProperty(this, 'zoomLevel', {\n    get: () => this.getZoomLevel(),\n    set: (level) => this.setZoomLevel(level)\n  });\n\n  Object.defineProperty(this, 'zoomFactor', {\n    get: () => this.getZoomFactor(),\n    set: (factor) => this.setZoomFactor(factor)\n  });\n\n  Object.defineProperty(this, 'frameRate', {\n    get: () => this.getFrameRate(),\n    set: (rate) => this.setFrameRate(rate)\n  });\n\n  Object.defineProperty(this, 'backgroundThrottling', {\n    get: () => this.getBackgroundThrottling(),\n    set: (allowed) => this.setBackgroundThrottling(allowed)\n  });\n};\n\n// Public APIs.\nexport function create (options = {}): Electron.WebContents {\n  return new (WebContents as any)(options);\n}\n\nexport function fromId (id: string) {\n  return binding.fromId(id);\n}\n\nexport function getFocusedWebContents () {\n  let focused = null;\n  for (const contents of binding.getAllWebContents()) {\n    if (!contents.isFocused()) continue;\n    if (focused == null) focused = contents;\n    // Return webview web contents which may be embedded inside another\n    // web contents that is also reporting as focused\n    if (contents.getType() === 'webview') return contents;\n  }\n  return focused;\n}\nexport function getAllWebContents () {\n  return binding.getAllWebContents();\n}\n", "import * as electron from 'electron/main';\nimport { EventEmitter } from 'events';\nimport objectsRegistry from '@electron/internal/browser/remote/objects-registry';\nimport { ipcMainInternal } from '@electron/internal/browser/ipc-main-internal';\nimport { isPromise, isSerializableObject, deserialize, serialize } from '@electron/internal/common/type-utils';\nimport type { MetaTypeFromRenderer, ObjectMember, MetaType, ObjProtoDescriptor } from '@electron/internal/common/remote/types';\nimport { IPC_MESSAGES } from '@electron/internal/common/remote/ipc-messages';\n\nconst v8Util = process._linkedBinding('electron_common_v8_util');\nconst eventBinding = process._linkedBinding('electron_browser_event');\nconst features = process._linkedBinding('electron_common_features');\n\nif (!features.isRemoteModuleEnabled()) {\n  throw new Error('remote module is disabled');\n}\n\n// The internal properties of Function.\nconst FUNCTION_PROPERTIES = [\n  'length', 'name', 'arguments', 'caller', 'prototype'\n];\n\ntype RendererFunctionId = [string, number] // [contextId, funcId]\ntype FinalizerInfo = { id: RendererFunctionId, webContents: electron.WebContents, frameId: [number, number] };\ntype CallIntoRenderer = (...args: any[]) => void\n\n// The remote functions in renderer processes.\nconst rendererFunctionCache = new Map<string, WeakRef<CallIntoRenderer>>();\n// eslint-disable-next-line no-undef\nconst finalizationRegistry = new FinalizationRegistry((fi: FinalizerInfo) => {\n  const mapKey = fi.id[0] + '~' + fi.id[1];\n  const ref = rendererFunctionCache.get(mapKey);\n  if (ref !== undefined && ref.deref() === undefined) {\n    rendererFunctionCache.delete(mapKey);\n    if (!fi.webContents.isDestroyed()) { fi.webContents._sendToFrameInternal(fi.frameId, IPC_MESSAGES.RENDERER_RELEASE_CALLBACK, fi.id[0], fi.id[1]); }\n  }\n});\n\nfunction getCachedRendererFunction (id: RendererFunctionId): CallIntoRenderer | undefined {\n  const mapKey = id[0] + '~' + id[1];\n  const ref = rendererFunctionCache.get(mapKey);\n  if (ref !== undefined) {\n    const deref = ref.deref();\n    if (deref !== undefined) return deref;\n  }\n}\nfunction setCachedRendererFunction (id: RendererFunctionId, wc: electron.WebContents, frameId: [number, number], value: CallIntoRenderer) {\n  // eslint-disable-next-line no-undef\n  const wr = new WeakRef<CallIntoRenderer>(value);\n  const mapKey = id[0] + '~' + id[1];\n  rendererFunctionCache.set(mapKey, wr);\n  finalizationRegistry.register(value, {\n    id,\n    webContents: wc,\n    frameId\n  } as FinalizerInfo);\n  return value;\n}\n\nconst locationInfo = new WeakMap<Object, string>();\n\n// Return the description of object's members:\nconst getObjectMembers = function (object: any): ObjectMember[] {\n  let names = Object.getOwnPropertyNames(object);\n  // For Function, we should not override following properties even though they\n  // are \"own\" properties.\n  if (typeof object === 'function') {\n    names = names.filter((name) => {\n      return !FUNCTION_PROPERTIES.includes(name);\n    });\n  }\n  // Map properties to descriptors.\n  return names.map((name) => {\n    const descriptor = Object.getOwnPropertyDescriptor(object, name)!;\n    let type: ObjectMember['type'];\n    let writable = false;\n    if (descriptor.get === undefined && typeof object[name] === 'function') {\n      type = 'method';\n    } else {\n      if (descriptor.set || descriptor.writable) writable = true;\n      type = 'get';\n    }\n    return { name, enumerable: descriptor.enumerable, writable, type };\n  });\n};\n\n// Return the description of object's prototype.\nconst getObjectPrototype = function (object: any): ObjProtoDescriptor {\n  const proto = Object.getPrototypeOf(object);\n  if (proto === null || proto === Object.prototype) return null;\n  return {\n    members: getObjectMembers(proto),\n    proto: getObjectPrototype(proto)\n  };\n};\n\n// Convert a real value into meta data.\nconst valueToMeta = function (sender: electron.WebContents, contextId: string, value: any, optimizeSimpleObject = false): MetaType {\n  // Determine the type of value.\n  let type: MetaType['type'];\n\n  switch (typeof value) {\n    case 'object':\n      // Recognize certain types of objects.\n      if (value instanceof Buffer) {\n        type = 'buffer';\n      } else if (value && value.constructor && value.constructor.name === 'NativeImage') {\n        type = 'nativeimage';\n      } else if (Array.isArray(value)) {\n        type = 'array';\n      } else if (value instanceof Error) {\n        type = 'error';\n      } else if (isSerializableObject(value)) {\n        type = 'value';\n      } else if (isPromise(value)) {\n        type = 'promise';\n      } else if (Object.prototype.hasOwnProperty.call(value, 'callee') && value.length != null) {\n        // Treat the arguments object as array.\n        type = 'array';\n      } else if (optimizeSimpleObject && v8Util.getHiddenValue(value, 'simple')) {\n        // Treat simple objects as value.\n        type = 'value';\n      } else {\n        type = 'object';\n      }\n      break;\n    case 'function':\n      type = 'function';\n      break;\n    default:\n      type = 'value';\n      break;\n  }\n\n  // Fill the meta object according to value's type.\n  if (type === 'array') {\n    return {\n      type,\n      members: value.map((el: any) => valueToMeta(sender, contextId, el, optimizeSimpleObject))\n    };\n  } else if (type === 'nativeimage') {\n    return { type, value: serialize(value) };\n  } else if (type === 'object' || type === 'function') {\n    return {\n      type,\n      name: value.constructor ? value.constructor.name : '',\n      // Reference the original value if it's an object, because when it's\n      // passed to renderer we would assume the renderer keeps a reference of\n      // it.\n      id: objectsRegistry.add(sender, contextId, value),\n      members: getObjectMembers(value),\n      proto: getObjectPrototype(value)\n    };\n  } else if (type === 'buffer') {\n    return { type, value };\n  } else if (type === 'promise') {\n    // Add default handler to prevent unhandled rejections in main process\n    // Instead they should appear in the renderer process\n    value.then(function () {}, function () {});\n\n    return {\n      type,\n      then: valueToMeta(sender, contextId, function (onFulfilled: Function, onRejected: Function) {\n        value.then(onFulfilled, onRejected);\n      })\n    };\n  } else if (type === 'error') {\n    return {\n      type,\n      value,\n      members: Object.keys(value).map(name => ({\n        name,\n        value: valueToMeta(sender, contextId, value[name])\n      }))\n    };\n  } else {\n    return {\n      type: 'value',\n      value\n    };\n  }\n};\n\nconst throwRPCError = function (message: string) {\n  const error = new Error(message) as Error & {code: string, errno: number};\n  error.code = 'EBADRPC';\n  error.errno = -72;\n  throw error;\n};\n\nconst removeRemoteListenersAndLogWarning = (sender: any, callIntoRenderer: (...args: any[]) => void) => {\n  const location = locationInfo.get(callIntoRenderer);\n  let message = 'Attempting to call a function in a renderer window that has been closed or released.' +\n    `\\nFunction provided here: ${location}`;\n\n  if (sender instanceof EventEmitter) {\n    const remoteEvents = sender.eventNames().filter((eventName) => {\n      return sender.listeners(eventName).includes(callIntoRenderer);\n    });\n\n    if (remoteEvents.length > 0) {\n      message += `\\nRemote event names: ${remoteEvents.join(', ')}`;\n      remoteEvents.forEach((eventName) => {\n        sender.removeListener(eventName as any, callIntoRenderer);\n      });\n    }\n  }\n\n  console.warn(message);\n};\n\nconst fakeConstructor = (constructor: Function, name: string) =>\n  new Proxy(Object, {\n    get (target, prop, receiver) {\n      if (prop === 'name') {\n        return name;\n      } else {\n        return Reflect.get(target, prop, receiver);\n      }\n    }\n  });\n\n// Convert array of meta data from renderer into array of real values.\nconst unwrapArgs = function (sender: electron.WebContents, frameId: [number, number], contextId: string, args: any[]) {\n  const metaToValue = function (meta: MetaTypeFromRenderer): any {\n    switch (meta.type) {\n      case 'nativeimage':\n        return deserialize(meta.value);\n      case 'value':\n        return meta.value;\n      case 'remote-object':\n        return objectsRegistry.get(meta.id);\n      case 'array':\n        return unwrapArgs(sender, frameId, contextId, meta.value);\n      case 'buffer':\n        return Buffer.from(meta.value.buffer, meta.value.byteOffset, meta.value.byteLength);\n      case 'promise':\n        return Promise.resolve({\n          then: metaToValue(meta.then)\n        });\n      case 'object': {\n        const ret: any = meta.name !== 'Object' ? Object.create({\n          constructor: fakeConstructor(Object, meta.name)\n        }) : {};\n\n        for (const { name, value } of meta.members) {\n          ret[name] = metaToValue(value);\n        }\n        return ret;\n      }\n      case 'function-with-return-value': {\n        const returnValue = metaToValue(meta.value);\n        return function () {\n          return returnValue;\n        };\n      }\n      case 'function': {\n        // Merge contextId and meta.id, since meta.id can be the same in\n        // different webContents.\n        const objectId: [string, number] = [contextId, meta.id];\n\n        // Cache the callbacks in renderer.\n        const cachedFunction = getCachedRendererFunction(objectId);\n        if (cachedFunction !== undefined) { return cachedFunction; }\n\n        const callIntoRenderer = function (this: any, ...args: any[]) {\n          let succeed = false;\n          if (!sender.isDestroyed()) {\n            succeed = sender._sendToFrameInternal(frameId, IPC_MESSAGES.RENDERER_CALLBACK, contextId, meta.id, valueToMeta(sender, contextId, args));\n          }\n          if (!succeed) {\n            removeRemoteListenersAndLogWarning(this, callIntoRenderer);\n          }\n        };\n        locationInfo.set(callIntoRenderer, meta.location);\n        Object.defineProperty(callIntoRenderer, 'length', { value: meta.length });\n\n        setCachedRendererFunction(objectId, sender, frameId, callIntoRenderer);\n        return callIntoRenderer;\n      }\n      default:\n        throw new TypeError(`Unknown type: ${(meta as any).type}`);\n    }\n  };\n  return args.map(metaToValue);\n};\n\nconst isRemoteModuleEnabledImpl = function (contents: electron.WebContents) {\n  const webPreferences = contents.getLastWebPreferences() || {};\n  return webPreferences.enableRemoteModule != null ? !!webPreferences.enableRemoteModule : false;\n};\n\nconst isRemoteModuleEnabledCache = new WeakMap();\n\nexport const isRemoteModuleEnabled = function (contents: electron.WebContents) {\n  if (!isRemoteModuleEnabledCache.has(contents)) {\n    isRemoteModuleEnabledCache.set(contents, isRemoteModuleEnabledImpl(contents));\n  }\n\n  return isRemoteModuleEnabledCache.get(contents);\n};\n\nconst handleRemoteCommand = function (channel: string, handler: (event: ElectronInternal.IpcMainInternalEvent, contextId: string, ...args: any[]) => void) {\n  ipcMainInternal.on(channel, (event, contextId: string, ...args: any[]) => {\n    let returnValue;\n    if (!isRemoteModuleEnabled(event.sender)) {\n      event.returnValue = null;\n      return;\n    }\n\n    try {\n      returnValue = handler(event, contextId, ...args);\n    } catch (error) {\n      returnValue = {\n        type: 'exception',\n        value: valueToMeta(event.sender, contextId, error)\n      };\n    }\n\n    if (returnValue !== undefined) {\n      event.returnValue = returnValue;\n    }\n  });\n};\n\nconst emitCustomEvent = function (contents: electron.WebContents, eventName: string, ...args: any[]) {\n  const event = eventBinding.createWithSender(contents);\n\n  electron.app.emit(eventName, event, contents, ...args);\n  contents.emit(eventName, event, ...args);\n\n  return event;\n};\n\nconst logStack = function (contents: electron.WebContents, code: string, stack: string | undefined) {\n  if (stack) {\n    console.warn(`WebContents (${contents.id}): ${code}`, stack);\n  }\n};\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_WRONG_CONTEXT_ERROR, function (event, contextId, passedContextId, id) {\n  const objectId: [string, number] = [passedContextId, id];\n  const cachedFunction = getCachedRendererFunction(objectId);\n  if (cachedFunction === undefined) {\n    // Do nothing if the error has already been reported before.\n    return;\n  }\n  removeRemoteListenersAndLogWarning(event.sender, cachedFunction);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_REQUIRE, function (event, contextId, moduleName, stack) {\n  logStack(event.sender, `remote.require('${moduleName}')`, stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-require', moduleName);\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.require('${moduleName}')`);\n    } else {\n      customEvent.returnValue = (process as any).mainModule.require(moduleName);\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_BUILTIN, function (event, contextId, moduleName, stack) {\n  logStack(event.sender, `remote.getBuiltin('${moduleName}')`, stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-builtin', moduleName);\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getBuiltin('${moduleName}')`);\n    } else {\n      customEvent.returnValue = (electron as any)[moduleName];\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_GLOBAL, function (event, contextId, globalName, stack) {\n  logStack(event.sender, `remote.getGlobal('${globalName}')`, stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-global', globalName);\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error(`Blocked remote.getGlobal('${globalName}')`);\n    } else {\n      customEvent.returnValue = (global as any)[globalName];\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_CURRENT_WINDOW, function (event, contextId, stack) {\n  logStack(event.sender, 'remote.getCurrentWindow()', stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-current-window');\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error('Blocked remote.getCurrentWindow()');\n    } else {\n      customEvent.returnValue = event.sender.getOwnerBrowserWindow();\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_GET_CURRENT_WEB_CONTENTS, function (event, contextId, stack) {\n  logStack(event.sender, 'remote.getCurrentWebContents()', stack);\n  const customEvent = emitCustomEvent(event.sender, 'remote-get-current-web-contents');\n\n  if (customEvent.returnValue === undefined) {\n    if (customEvent.defaultPrevented) {\n      throw new Error('Blocked remote.getCurrentWebContents()');\n    } else {\n      customEvent.returnValue = event.sender;\n    }\n  }\n\n  return valueToMeta(event.sender, contextId, customEvent.returnValue);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_CONSTRUCTOR, function (event, contextId, id, args) {\n  args = unwrapArgs(event.sender, [event.processId, event.frameId], contextId, args);\n  const constructor = objectsRegistry.get(id);\n\n  if (constructor == null) {\n    throwRPCError(`Cannot call constructor on missing remote object ${id}`);\n  }\n\n  return valueToMeta(event.sender, contextId, new constructor(...args));\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_FUNCTION_CALL, function (event, contextId, id, args) {\n  args = unwrapArgs(event.sender, [event.processId, event.frameId], contextId, args);\n  const func = objectsRegistry.get(id);\n\n  if (func == null) {\n    throwRPCError(`Cannot call function on missing remote object ${id}`);\n  }\n\n  try {\n    return valueToMeta(event.sender, contextId, func(...args), true);\n  } catch (error) {\n    const err = new Error(`Could not call remote function '${func.name || 'anonymous'}'. Check that the function signature is correct. Underlying error: ${error.message}\\nUnderlying stack: ${error.stack}\\n`);\n    (err as any).cause = error;\n    throw err;\n  }\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_CONSTRUCTOR, function (event, contextId, id, method, args) {\n  args = unwrapArgs(event.sender, [event.processId, event.frameId], contextId, args);\n  const object = objectsRegistry.get(id);\n\n  if (object == null) {\n    throwRPCError(`Cannot call constructor '${method}' on missing remote object ${id}`);\n  }\n\n  return valueToMeta(event.sender, contextId, new object[method](...args));\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_CALL, function (event, contextId, id, method, args) {\n  args = unwrapArgs(event.sender, [event.processId, event.frameId], contextId, args);\n  const object = objectsRegistry.get(id);\n\n  if (object == null) {\n    throwRPCError(`Cannot call method '${method}' on missing remote object ${id}`);\n  }\n\n  try {\n    return valueToMeta(event.sender, contextId, object[method](...args), true);\n  } catch (error) {\n    const err = new Error(`Could not call remote method '${method}'. Check that the method signature is correct. Underlying error: ${error.message}\\nUnderlying stack: ${error.stack}\\n`);\n    (err as any).cause = error;\n    throw err;\n  }\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_SET, function (event, contextId, id, name, args) {\n  args = unwrapArgs(event.sender, [event.processId, event.frameId], contextId, args);\n  const obj = objectsRegistry.get(id);\n\n  if (obj == null) {\n    throwRPCError(`Cannot set property '${name}' on missing remote object ${id}`);\n  }\n\n  obj[name] = args[0];\n  return null;\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_MEMBER_GET, function (event, contextId, id, name) {\n  const obj = objectsRegistry.get(id);\n\n  if (obj == null) {\n    throwRPCError(`Cannot get property '${name}' on missing remote object ${id}`);\n  }\n\n  return valueToMeta(event.sender, contextId, obj[name]);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_DEREFERENCE, function (event, contextId, id) {\n  objectsRegistry.remove(event.sender, contextId, id);\n});\n\nhandleRemoteCommand(IPC_MESSAGES.BROWSER_CONTEXT_RELEASE, (event, contextId) => {\n  objectsRegistry.clear(event.sender, contextId);\n});\n", "// Copyright (c) 2014 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/browser/api/electron_api_web_contents.h\"\n\n#include <limits>\n#include <memory>\n#include <set>\n#include <string>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#include \"base/containers/id_map.h\"\n#include \"base/files/file_util.h\"\n#include \"base/json/json_reader.h\"\n#include \"base/no_destructor.h\"\n#include \"base/optional.h\"\n#include \"base/strings/utf_string_conversions.h\"\n#include \"base/task/current_thread.h\"\n#include \"base/task/post_task.h\"\n#include \"base/task/thread_pool.h\"\n#include \"base/threading/scoped_blocking_call.h\"\n#include \"base/threading/sequenced_task_runner_handle.h\"\n#include \"base/threading/thread_restrictions.h\"\n#include \"base/threading/thread_task_runner_handle.h\"\n#include \"base/values.h\"\n#include \"chrome/browser/browser_process.h\"\n#include \"chrome/browser/ssl/security_state_tab_helper.h\"\n#include \"chrome/common/pref_names.h\"\n#include \"components/prefs/pref_service.h\"\n#include \"components/prefs/scoped_user_pref_update.h\"\n#include \"components/security_state/content/content_utils.h\"\n#include \"components/security_state/core/security_state.h\"\n#include \"content/browser/renderer_host/frame_tree_node.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_frame_host_manager.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_impl.h\"  // nogncheck\n#include \"content/browser/renderer_host/render_widget_host_view_base.h\"  // nogncheck\n#include \"content/public/browser/child_process_security_policy.h\"\n#include \"content/public/browser/context_menu_params.h\"\n#include \"content/public/browser/download_request_utils.h\"\n#include \"content/public/browser/favicon_status.h\"\n#include \"content/public/browser/file_select_listener.h\"\n#include \"content/public/browser/native_web_keyboard_event.h\"\n#include \"content/public/browser/navigation_details.h\"\n#include \"content/public/browser/navigation_entry.h\"\n#include \"content/public/browser/navigation_handle.h\"\n#include \"content/public/browser/plugin_service.h\"\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/render_process_host.h\"\n#include \"content/public/browser/render_view_host.h\"\n#include \"content/public/browser/render_widget_host.h\"\n#include \"content/public/browser/render_widget_host_view.h\"\n#include \"content/public/browser/security_style_explanation.h\"\n#include \"content/public/browser/security_style_explanations.h\"\n#include \"content/public/browser/service_worker_context.h\"\n#include \"content/public/browser/site_instance.h\"\n#include \"content/public/browser/storage_partition.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/common/referrer_type_converters.h\"\n#include \"content/public/common/webplugininfo.h\"\n#include \"electron/buildflags/buildflags.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"gin/arguments.h\"\n#include \"gin/data_object_builder.h\"\n#include \"gin/handle.h\"\n#include \"gin/object_template_builder.h\"\n#include \"gin/wrappable.h\"\n#include \"mojo/public/cpp/bindings/associated_remote.h\"\n#include \"mojo/public/cpp/bindings/pending_receiver.h\"\n#include \"mojo/public/cpp/bindings/remote.h\"\n#include \"mojo/public/cpp/system/platform_handle.h\"\n#include \"ppapi/buildflags/buildflags.h\"\n#include \"printing/buildflags/buildflags.h\"\n#include \"shell/browser/api/electron_api_browser_window.h\"\n#include \"shell/browser/api/electron_api_debugger.h\"\n#include \"shell/browser/api/electron_api_session.h\"\n#include \"shell/browser/api/electron_api_web_frame_main.h\"\n#include \"shell/browser/api/message_port.h\"\n#include \"shell/browser/browser.h\"\n#include \"shell/browser/child_web_contents_tracker.h\"\n#include \"shell/browser/electron_autofill_driver_factory.h\"\n#include \"shell/browser/electron_browser_client.h\"\n#include \"shell/browser/electron_browser_context.h\"\n#include \"shell/browser/electron_browser_main_parts.h\"\n#include \"shell/browser/electron_javascript_dialog_manager.h\"\n#include \"shell/browser/electron_navigation_throttle.h\"\n#include \"shell/browser/lib/bluetooth_chooser.h\"\n#include \"shell/browser/native_window.h\"\n#include \"shell/browser/session_preferences.h\"\n#include \"shell/browser/ui/drag_util.h\"\n#include \"shell/browser/ui/file_dialog.h\"\n#include \"shell/browser/ui/inspectable_web_contents.h\"\n#include \"shell/browser/ui/inspectable_web_contents_view.h\"\n#include \"shell/browser/web_contents_permission_helper.h\"\n#include \"shell/browser/web_contents_preferences.h\"\n#include \"shell/browser/web_contents_zoom_controller.h\"\n#include \"shell/browser/web_dialog_helper.h\"\n#include \"shell/browser/web_view_guest_delegate.h\"\n#include \"shell/common/api/electron_api_native_image.h\"\n#include \"shell/common/color_util.h\"\n#include \"shell/common/electron_constants.h\"\n#include \"shell/common/gin_converters/base_converter.h\"\n#include \"shell/common/gin_converters/blink_converter.h\"\n#include \"shell/common/gin_converters/callback_converter.h\"\n#include \"shell/common/gin_converters/content_converter.h\"\n#include \"shell/common/gin_converters/file_path_converter.h\"\n#include \"shell/common/gin_converters/frame_converter.h\"\n#include \"shell/common/gin_converters/gfx_converter.h\"\n#include \"shell/common/gin_converters/gurl_converter.h\"\n#include \"shell/common/gin_converters/image_converter.h\"\n#include \"shell/common/gin_converters/net_converter.h\"\n#include \"shell/common/gin_converters/value_converter.h\"\n#include \"shell/common/gin_helper/dictionary.h\"\n#include \"shell/common/gin_helper/object_template_builder.h\"\n#include \"shell/common/language_util.h\"\n#include \"shell/common/mouse_util.h\"\n#include \"shell/common/node_includes.h\"\n#include \"shell/common/options_switches.h\"\n#include \"shell/common/v8_value_serializer.h\"\n#include \"storage/browser/file_system/isolated_context.h\"\n#include \"third_party/blink/public/common/associated_interfaces/associated_interface_provider.h\"\n#include \"third_party/blink/public/common/input/web_input_event.h\"\n#include \"third_party/blink/public/common/messaging/transferable_message_mojom_traits.h\"\n#include \"third_party/blink/public/common/page/page_zoom.h\"\n#include \"third_party/blink/public/mojom/frame/find_in_page.mojom.h\"\n#include \"third_party/blink/public/mojom/frame/fullscreen.mojom.h\"\n#include \"third_party/blink/public/mojom/messaging/transferable_message.mojom.h\"\n#include \"third_party/blink/public/mojom/renderer_preferences.mojom.h\"\n#include \"ui/base/cursor/cursor.h\"\n#include \"ui/base/cursor/mojom/cursor_type.mojom-shared.h\"\n#include \"ui/display/screen.h\"\n#include \"ui/events/base_event_utils.h\"\n\n#if BUILDFLAG(ENABLE_OSR)\n#include \"shell/browser/osr/osr_render_widget_host_view.h\"\n#include \"shell/browser/osr/osr_web_contents_view.h\"\n#endif\n\n#if !defined(OS_MAC)\n#include \"ui/aura/window.h\"\n#else\n#include \"ui/base/cocoa/defaults_utils.h\"\n#endif\n\n#if defined(OS_LINUX)\n#include \"ui/views/linux_ui/linux_ui.h\"\n#endif\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n#include \"ui/gfx/font_render_params.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n#include \"extensions/browser/script_executor.h\"\n#include \"extensions/browser/view_type_utils.h\"\n#include \"shell/browser/extensions/electron_extension_web_contents_observer.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PRINTING)\n#include \"chrome/browser/printing/print_view_manager_basic.h\"\n#include \"components/printing/browser/print_manager_utils.h\"\n#include \"printing/backend/print_backend.h\"  // nogncheck\n#include \"printing/mojom/print.mojom.h\"\n#include \"shell/browser/printing/print_preview_message_handler.h\"\n\n#if defined(OS_WIN)\n#include \"printing/backend/win_helper.h\"\n#endif\n#endif\n\n#if BUILDFLAG(ENABLE_COLOR_CHOOSER)\n#include \"chrome/browser/ui/color_chooser.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PICTURE_IN_PICTURE)\n#include \"chrome/browser/picture_in_picture/picture_in_picture_window_manager.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_PDF_VIEWER)\n#include \"components/pdf/browser/pdf_web_contents_helper.h\"  // nogncheck\n#include \"shell/browser/electron_pdf_web_contents_helper_client.h\"\n#endif\n\n#ifndef MAS_BUILD\n#include \"chrome/browser/hang_monitor/hang_crash_dump.h\"  // nogncheck\n#endif\n\nnamespace gin {\n\n#if BUILDFLAG(ENABLE_PRINTING)\ntemplate <>\nstruct Converter<printing::mojom::MarginType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::mojom::MarginType* out) {\n    std::string type;\n    if (ConvertFromV8(isolate, val, &type)) {\n      if (type == \"default\") {\n        *out = printing::mojom::MarginType::kDefaultMargins;\n        return true;\n      }\n      if (type == \"none\") {\n        *out = printing::mojom::MarginType::kNoMargins;\n        return true;\n      }\n      if (type == \"printableArea\") {\n        *out = printing::mojom::MarginType::kPrintableAreaMargins;\n        return true;\n      }\n      if (type == \"custom\") {\n        *out = printing::mojom::MarginType::kCustomMargins;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\ntemplate <>\nstruct Converter<printing::mojom::DuplexMode> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     printing::mojom::DuplexMode* out) {\n    std::string mode;\n    if (ConvertFromV8(isolate, val, &mode)) {\n      if (mode == \"simplex\") {\n        *out = printing::mojom::DuplexMode::kSimplex;\n        return true;\n      }\n      if (mode == \"longEdge\") {\n        *out = printing::mojom::DuplexMode::kLongEdge;\n        return true;\n      }\n      if (mode == \"shortEdge\") {\n        *out = printing::mojom::DuplexMode::kShortEdge;\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n#endif\n\ntemplate <>\nstruct Converter<WindowOpenDisposition> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   WindowOpenDisposition val) {\n    std::string disposition = \"other\";\n    switch (val) {\n      case WindowOpenDisposition::CURRENT_TAB:\n        disposition = \"default\";\n        break;\n      case WindowOpenDisposition::NEW_FOREGROUND_TAB:\n        disposition = \"foreground-tab\";\n        break;\n      case WindowOpenDisposition::NEW_BACKGROUND_TAB:\n        disposition = \"background-tab\";\n        break;\n      case WindowOpenDisposition::NEW_POPUP:\n      case WindowOpenDisposition::NEW_WINDOW:\n        disposition = \"new-window\";\n        break;\n      case WindowOpenDisposition::SAVE_TO_DISK:\n        disposition = \"save-to-disk\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, disposition);\n  }\n};\n\ntemplate <>\nstruct Converter<content::SavePageType> {\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     content::SavePageType* out) {\n    std::string save_type;\n    if (!ConvertFromV8(isolate, val, &save_type))\n      return false;\n    save_type = base::ToLowerASCII(save_type);\n    if (save_type == \"htmlonly\") {\n      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;\n    } else if (save_type == \"htmlcomplete\") {\n      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;\n    } else if (save_type == \"mhtml\") {\n      *out = content::SAVE_PAGE_TYPE_AS_MHTML;\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<electron::api::WebContents::Type> {\n  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,\n                                   electron::api::WebContents::Type val) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    switch (val) {\n      case Type::kBackgroundPage:\n        type = \"backgroundPage\";\n        break;\n      case Type::kBrowserWindow:\n        type = \"window\";\n        break;\n      case Type::kBrowserView:\n        type = \"browserView\";\n        break;\n      case Type::kRemote:\n        type = \"remote\";\n        break;\n      case Type::kWebView:\n        type = \"webview\";\n        break;\n      case Type::kOffScreen:\n        type = \"offscreen\";\n        break;\n      default:\n        break;\n    }\n    return gin::ConvertToV8(isolate, type);\n  }\n\n  static bool FromV8(v8::Isolate* isolate,\n                     v8::Local<v8::Value> val,\n                     electron::api::WebContents::Type* out) {\n    using Type = electron::api::WebContents::Type;\n    std::string type;\n    if (!ConvertFromV8(isolate, val, &type))\n      return false;\n    if (type == \"backgroundPage\") {\n      *out = Type::kBackgroundPage;\n    } else if (type == \"browserView\") {\n      *out = Type::kBrowserView;\n    } else if (type == \"webview\") {\n      *out = Type::kWebView;\n#if BUILDFLAG(ENABLE_OSR)\n    } else if (type == \"offscreen\") {\n      *out = Type::kOffScreen;\n#endif\n    } else {\n      return false;\n    }\n    return true;\n  }\n};\n\ntemplate <>\nstruct Converter<scoped_refptr<content::DevToolsAgentHost>> {\n  static v8::Local<v8::Value> ToV8(\n      v8::Isolate* isolate,\n      const scoped_refptr<content::DevToolsAgentHost>& val) {\n    gin_helper::Dictionary dict(isolate, v8::Object::New(isolate));\n    dict.Set(\"id\", val->GetId());\n    dict.Set(\"url\", val->GetURL().spec());\n    return dict.GetHandle();\n  }\n};\n\n}  // namespace gin\n\nnamespace electron {\n\nnamespace api {\n\nnamespace {\n\nbase::IDMap<WebContents*>& GetAllWebContents() {\n  static base::NoDestructor<base::IDMap<WebContents*>> s_all_web_contents;\n  return *s_all_web_contents;\n}\n\n// Called when CapturePage is done.\nvoid OnCapturePageDone(gin_helper::Promise<gfx::Image> promise,\n                       const SkBitmap& bitmap) {\n  // Hack to enable transparency in captured image\n  promise.Resolve(gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nbase::Optional<base::TimeDelta> GetCursorBlinkInterval() {\n#if defined(OS_MAC)\n  base::TimeDelta interval;\n  if (ui::TextInsertionCaretBlinkPeriod(&interval))\n    return interval;\n#elif defined(OS_LINUX)\n  if (auto* linux_ui = views::LinuxUI::instance())\n    return linux_ui->GetCursorBlinkInterval();\n#elif defined(OS_WIN)\n  const auto system_msec = ::GetCaretBlinkTime();\n  if (system_msec != 0) {\n    return (system_msec == INFINITE)\n               ? base::TimeDelta()\n               : base::TimeDelta::FromMilliseconds(system_msec);\n  }\n#endif\n  return base::nullopt;\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\n// This will return false if no printer with the provided device_name can be\n// found on the network. We need to check this because Chromium does not do\n// sanity checking of device_name validity and so will crash on invalid names.\nbool IsDeviceNameValid(const base::string16& device_name) {\n#if defined(OS_MAC)\n  base::ScopedCFTypeRef<CFStringRef> new_printer_id(\n      base::SysUTF16ToCFStringRef(device_name));\n  PMPrinter new_printer = PMPrinterCreateFromPrinterID(new_printer_id.get());\n  bool printer_exists = new_printer != nullptr;\n  PMRelease(new_printer);\n  return printer_exists;\n#elif defined(OS_WIN)\n  printing::ScopedPrinterHandle printer;\n  return printer.OpenPrinterWithName(device_name.c_str());\n#endif\n  return true;\n}\n\nbase::string16 GetDefaultPrinterAsync() {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::MAY_BLOCK);\n\n  scoped_refptr<printing::PrintBackend> print_backend =\n      printing::PrintBackend::CreateInstance(\n          g_browser_process->GetApplicationLocale());\n  std::string printer_name = print_backend->GetDefaultPrinterName();\n\n  // Some devices won't have a default printer, so we should\n  // also check for existing printers and pick the first\n  // one should it exist.\n  if (printer_name.empty()) {\n    printing::PrinterList printers;\n    print_backend->EnumeratePrinters(&printers);\n    if (!printers.empty())\n      printer_name = printers.front().printer_name;\n  }\n  return base::UTF8ToUTF16(printer_name);\n}\n#endif\n\nstruct UserDataLink : public base::SupportsUserData::Data {\n  explicit UserDataLink(base::WeakPtr<WebContents> contents)\n      : web_contents(contents) {}\n\n  base::WeakPtr<WebContents> web_contents;\n};\nconst void* kElectronApiWebContentsKey = &kElectronApiWebContentsKey;\n\nconst char kRootName[] = \"<root>\";\n\nstruct FileSystem {\n  FileSystem() = default;\n  FileSystem(const std::string& type,\n             const std::string& file_system_name,\n             const std::string& root_url,\n             const std::string& file_system_path)\n      : type(type),\n        file_system_name(file_system_name),\n        root_url(root_url),\n        file_system_path(file_system_path) {}\n\n  std::string type;\n  std::string file_system_name;\n  std::string root_url;\n  std::string file_system_path;\n};\n\nstd::string RegisterFileSystem(content::WebContents* web_contents,\n                               const base::FilePath& path) {\n  auto* isolated_context = storage::IsolatedContext::GetInstance();\n  std::string root_name(kRootName);\n  storage::IsolatedContext::ScopedFSHandle file_system =\n      isolated_context->RegisterFileSystemForPath(\n          storage::kFileSystemTypeNativeLocal, std::string(), path, &root_name);\n\n  content::ChildProcessSecurityPolicy* policy =\n      content::ChildProcessSecurityPolicy::GetInstance();\n  content::RenderViewHost* render_view_host = web_contents->GetRenderViewHost();\n  int renderer_id = render_view_host->GetProcess()->GetID();\n  policy->GrantReadFileSystem(renderer_id, file_system.id());\n  policy->GrantWriteFileSystem(renderer_id, file_system.id());\n  policy->GrantCreateFileForFileSystem(renderer_id, file_system.id());\n  policy->GrantDeleteFromFileSystem(renderer_id, file_system.id());\n\n  if (!policy->CanReadFile(renderer_id, path))\n    policy->GrantReadFile(renderer_id, path);\n\n  return file_system.id();\n}\n\nFileSystem CreateFileSystemStruct(content::WebContents* web_contents,\n                                  const std::string& file_system_id,\n                                  const std::string& file_system_path,\n                                  const std::string& type) {\n  const GURL origin = web_contents->GetURL().GetOrigin();\n  std::string file_system_name =\n      storage::GetIsolatedFileSystemName(origin, file_system_id);\n  std::string root_url = storage::GetIsolatedFileSystemRootURIString(\n      origin, file_system_id, kRootName);\n  return FileSystem(type, file_system_name, root_url, file_system_path);\n}\n\nstd::unique_ptr<base::DictionaryValue> CreateFileSystemValue(\n    const FileSystem& file_system) {\n  std::unique_ptr<base::DictionaryValue> file_system_value(\n      new base::DictionaryValue());\n  file_system_value->SetString(\"type\", file_system.type);\n  file_system_value->SetString(\"fileSystemName\", file_system.file_system_name);\n  file_system_value->SetString(\"rootURL\", file_system.root_url);\n  file_system_value->SetString(\"fileSystemPath\", file_system.file_system_path);\n  return file_system_value;\n}\n\nvoid WriteToFile(const base::FilePath& path, const std::string& content) {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::WILL_BLOCK);\n  DCHECK(!path.empty());\n\n  base::WriteFile(path, content.data(), content.size());\n}\n\nvoid AppendToFile(const base::FilePath& path, const std::string& content) {\n  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,\n                                                base::BlockingType::WILL_BLOCK);\n  DCHECK(!path.empty());\n\n  base::AppendToFile(path, content.data(), content.size());\n}\n\nPrefService* GetPrefService(content::WebContents* web_contents) {\n  auto* context = web_contents->GetBrowserContext();\n  return static_cast<electron::ElectronBrowserContext*>(context)->prefs();\n}\n\nstd::map<std::string, std::string> GetAddedFileSystemPaths(\n    content::WebContents* web_contents) {\n  auto* pref_service = GetPrefService(web_contents);\n  const base::DictionaryValue* file_system_paths_value =\n      pref_service->GetDictionary(prefs::kDevToolsFileSystemPaths);\n  std::map<std::string, std::string> result;\n  if (file_system_paths_value) {\n    base::DictionaryValue::Iterator it(*file_system_paths_value);\n    for (; !it.IsAtEnd(); it.Advance()) {\n      std::string type =\n          it.value().is_string() ? it.value().GetString() : std::string();\n      result[it.key()] = type;\n    }\n  }\n  return result;\n}\n\nbool IsDevToolsFileSystemAdded(content::WebContents* web_contents,\n                               const std::string& file_system_path) {\n  auto file_system_paths = GetAddedFileSystemPaths(web_contents);\n  return file_system_paths.find(file_system_path) != file_system_paths.end();\n}\n\n}  // namespace\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n\nWebContents::Type GetTypeFromViewType(extensions::ViewType view_type) {\n  switch (view_type) {\n    case extensions::VIEW_TYPE_EXTENSION_BACKGROUND_PAGE:\n      return WebContents::Type::kBackgroundPage;\n\n    case extensions::VIEW_TYPE_APP_WINDOW:\n    case extensions::VIEW_TYPE_COMPONENT:\n    case extensions::VIEW_TYPE_EXTENSION_DIALOG:\n    case extensions::VIEW_TYPE_EXTENSION_POPUP:\n    case extensions::VIEW_TYPE_BACKGROUND_CONTENTS:\n    case extensions::VIEW_TYPE_EXTENSION_GUEST:\n    case extensions::VIEW_TYPE_TAB_CONTENTS:\n    case extensions::VIEW_TYPE_INVALID:\n      return WebContents::Type::kRemote;\n  }\n}\n\n#endif\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         content::WebContents* web_contents)\n    : content::WebContentsObserver(web_contents),\n      type_(Type::kRemote),\n      id_(GetAllWebContents().Add(this)),\n      devtools_file_system_indexer_(new DevToolsFileSystemIndexer),\n      file_task_runner_(\n          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()})),\n      weak_factory_(this) {\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  // WebContents created by extension host will have valid ViewType set.\n  extensions::ViewType view_type = extensions::GetViewType(web_contents);\n  if (view_type != extensions::VIEW_TYPE_INVALID) {\n    InitWithExtensionView(isolate, web_contents, view_type);\n  }\n\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents);\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents));\n#endif\n\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n\n  web_contents->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                         GetBrowserContext()->GetUserAgent()),\n                                     false);\n  web_contents->SetUserData(kElectronApiWebContentsKey,\n                            std::make_unique<UserDataLink>(GetWeakPtr()));\n  InitZoomController(web_contents, gin::Dictionary::CreateEmpty(isolate));\n\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         std::unique_ptr<content::WebContents> web_contents,\n                         Type type)\n    : content::WebContentsObserver(web_contents.get()),\n      type_(type),\n      id_(GetAllWebContents().Add(this)),\n      devtools_file_system_indexer_(new DevToolsFileSystemIndexer),\n      file_task_runner_(\n          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()})),\n      weak_factory_(this) {\n  DCHECK(type != Type::kRemote)\n      << \"Can't take ownership of a remote WebContents\";\n  auto session = Session::CreateFrom(isolate, GetBrowserContext());\n  session_.Reset(isolate, session.ToV8());\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session,\n                            gin::Dictionary::CreateEmpty(isolate));\n}\n\nWebContents::WebContents(v8::Isolate* isolate,\n                         const gin_helper::Dictionary& options)\n    : id_(GetAllWebContents().Add(this)),\n      devtools_file_system_indexer_(new DevToolsFileSystemIndexer),\n      file_task_runner_(\n          base::ThreadPool::CreateSequencedTaskRunner({base::MayBlock()})),\n      weak_factory_(this) {\n  // Read options.\n  options.Get(\"backgroundThrottling\", &background_throttling_);\n\n  // Get type\n  options.Get(\"type\", &type_);\n\n#if BUILDFLAG(ENABLE_OSR)\n  bool b = false;\n  if (options.Get(options::kOffscreen, &b) && b)\n    type_ = Type::kOffScreen;\n#endif\n\n  // Init embedder earlier\n  options.Get(\"embedder\", &embedder_);\n\n  // Whether to enable DevTools.\n  options.Get(\"devTools\", &enable_devtools_);\n\n  // BrowserViews are not attached to a window initially so they should start\n  // off as hidden. This is also important for compositor recycling. See:\n  // https://github.com/electron/electron/pull/21372\n  initially_shown_ = type_ != Type::kBrowserView;\n  options.Get(options::kShow, &initially_shown_);\n\n  // Obtain the session.\n  std::string partition;\n  gin::Handle<api::Session> session;\n  if (options.Get(\"session\", &session) && !session.IsEmpty()) {\n  } else if (options.Get(\"partition\", &partition)) {\n    session = Session::FromPartition(isolate, partition);\n  } else {\n    // Use the default session if not specified.\n    session = Session::FromPartition(isolate, \"\");\n  }\n  session_.Reset(isolate, session.ToV8());\n\n  std::unique_ptr<content::WebContents> web_contents;\n  if (IsGuest()) {\n    scoped_refptr<content::SiteInstance> site_instance =\n        content::SiteInstance::CreateForURL(session->browser_context(),\n                                            GURL(\"chrome-guest://fake-host\"));\n    content::WebContents::CreateParams params(session->browser_context(),\n                                              site_instance);\n    guest_delegate_ =\n        std::make_unique<WebViewGuestDelegate>(embedder_->web_contents(), this);\n    params.guest_delegate = guest_delegate_.get();\n\n#if BUILDFLAG(ENABLE_OSR)\n    if (embedder_ && embedder_->IsOffScreen()) {\n      auto* view = new OffScreenWebContentsView(\n          false,\n          base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n      params.view = view;\n      params.delegate_view = view;\n\n      web_contents = content::WebContents::Create(params);\n      view->SetWebContents(web_contents.get());\n    } else {\n#endif\n      web_contents = content::WebContents::Create(params);\n#if BUILDFLAG(ENABLE_OSR)\n    }\n  } else if (IsOffScreen()) {\n    bool transparent = false;\n    options.Get(\"transparent\", &transparent);\n\n    content::WebContents::CreateParams params(session->browser_context());\n    auto* view = new OffScreenWebContentsView(\n        transparent,\n        base::BindRepeating(&WebContents::OnPaint, base::Unretained(this)));\n    params.view = view;\n    params.delegate_view = view;\n\n    web_contents = content::WebContents::Create(params);\n    view->SetWebContents(web_contents.get());\n#endif\n  } else {\n    content::WebContents::CreateParams params(session->browser_context());\n    params.initially_hidden = !initially_shown_;\n    web_contents = content::WebContents::Create(params);\n  }\n\n  InitWithSessionAndOptions(isolate, std::move(web_contents), session, options);\n}\n\nvoid WebContents::InitZoomController(content::WebContents* web_contents,\n                                     const gin_helper::Dictionary& options) {\n  WebContentsZoomController::CreateForWebContents(web_contents);\n  zoom_controller_ = WebContentsZoomController::FromWebContents(web_contents);\n  double zoom_factor;\n  if (options.Get(options::kZoomFactor, &zoom_factor))\n    zoom_controller_->SetDefaultZoomFactor(zoom_factor);\n}\n\nvoid WebContents::InitWithSessionAndOptions(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> owned_web_contents,\n    gin::Handle<api::Session> session,\n    const gin_helper::Dictionary& options) {\n  Observe(owned_web_contents.get());\n  // TODO(zcbenz): Make InitWithWebContents take unique_ptr.\n  // At the time of writing we are going through a refactoring and I don't want\n  // to make other people's work harder.\n  InitWithWebContents(owned_web_contents.release(), session->browser_context(),\n                      IsGuest());\n\n  inspectable_web_contents_->GetView()->SetDelegate(this);\n\n  auto* prefs = web_contents()->GetMutableRendererPrefs();\n\n  // Collect preferred languages from OS and browser process. accept_languages\n  // effects HTTP header, navigator.languages, and CJK fallback font selection.\n  //\n  // Note that an application locale set to the browser process might be\n  // different with the one set to the preference list.\n  // (e.g. overridden with --lang)\n  std::string accept_languages =\n      g_browser_process->GetApplicationLocale() + \",\";\n  for (auto const& language : electron::GetPreferredLanguages()) {\n    if (language == g_browser_process->GetApplicationLocale())\n      continue;\n    accept_languages += language + \",\";\n  }\n  accept_languages.pop_back();\n  prefs->accept_languages = accept_languages;\n\n#if defined(OS_LINUX) || defined(OS_WIN)\n  // Update font settings.\n  static const base::NoDestructor<gfx::FontRenderParams> params(\n      gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr));\n  prefs->should_antialias_text = params->antialiasing;\n  prefs->use_subpixel_positioning = params->subpixel_positioning;\n  prefs->hinting = params->hinting;\n  prefs->use_autohinter = params->autohinter;\n  prefs->use_bitmaps = params->use_bitmaps;\n  prefs->subpixel_rendering = params->subpixel_rendering;\n#endif\n\n  // Honor the system's cursor blink rate settings\n  if (auto interval = GetCursorBlinkInterval())\n    prefs->caret_blink_interval = *interval;\n\n  // Save the preferences in C++.\n  // If there's already a WebContentsPreferences object, we created it as part\n  // of the webContents.setWindowOpenHandler path, so don't overwrite it.\n  if (!WebContentsPreferences::From(web_contents())) {\n    new WebContentsPreferences(web_contents(), options);\n  }\n  // Trigger re-calculation of webkit prefs.\n  web_contents()->NotifyPreferencesChanged();\n\n  WebContentsPermissionHelper::CreateForWebContents(web_contents());\n  SecurityStateTabHelper::CreateForWebContents(web_contents());\n  InitZoomController(web_contents(), options);\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ElectronExtensionWebContentsObserver::CreateForWebContents(\n      web_contents());\n  script_executor_.reset(new extensions::ScriptExecutor(web_contents()));\n#endif\n\n  registry_.AddInterface(base::BindRepeating(&WebContents::BindElectronBrowser,\n                                             base::Unretained(this)));\n  receivers_.set_disconnect_handler(base::BindRepeating(\n      &WebContents::OnElectronBrowserConnectionError, base::Unretained(this)));\n  AutofillDriverFactory::CreateForWebContents(web_contents());\n\n  web_contents()->SetUserAgentOverride(blink::UserAgentOverride::UserAgentOnly(\n                                           GetBrowserContext()->GetUserAgent()),\n                                       false);\n\n  if (IsGuest()) {\n    NativeWindow* owner_window = nullptr;\n    if (embedder_) {\n      // New WebContents's owner_window is the embedder's owner_window.\n      auto* relay =\n          NativeWindowRelay::FromWebContents(embedder_->web_contents());\n      if (relay)\n        owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n  }\n\n  web_contents()->SetUserData(kElectronApiWebContentsKey,\n                              std::make_unique<UserDataLink>(GetWeakPtr()));\n}\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\nvoid WebContents::InitWithExtensionView(v8::Isolate* isolate,\n                                        content::WebContents* web_contents,\n                                        extensions::ViewType view_type) {\n  // Must reassign type prior to calling `Init`.\n  type_ = GetTypeFromViewType(view_type);\n  if (GetType() == Type::kRemote)\n    return;\n\n  // Allow toggling DevTools for background pages\n  Observe(web_contents);\n  InitWithWebContents(web_contents, GetBrowserContext(), IsGuest());\n  inspectable_web_contents_->GetView()->SetDelegate(this);\n  SecurityStateTabHelper::CreateForWebContents(web_contents);\n}\n#endif\n\nvoid WebContents::InitWithWebContents(content::WebContents* web_contents,\n                                      ElectronBrowserContext* browser_context,\n                                      bool is_guest) {\n  browser_context_ = browser_context;\n  web_contents->SetDelegate(this);\n\n#if BUILDFLAG(ENABLE_PRINTING)\n  PrintPreviewMessageHandler::CreateForWebContents(web_contents);\n  printing::PrintViewManagerBasic::CreateForWebContents(web_contents);\n  printing::CreateCompositeClientIfNeeded(web_contents,\n                                          browser_context->GetUserAgent());\n#endif\n\n#if BUILDFLAG(ENABLE_PDF_VIEWER)\n  pdf::PDFWebContentsHelper::CreateForWebContentsWithClient(\n      web_contents, std::make_unique<ElectronPDFWebContentsHelperClient>());\n#endif\n\n  // Determine whether the WebContents is offscreen.\n  auto* web_preferences = WebContentsPreferences::From(web_contents);\n  offscreen_ =\n      web_preferences && web_preferences->IsEnabled(options::kOffscreen);\n\n  // Create InspectableWebContents.\n  inspectable_web_contents_.reset(new InspectableWebContents(\n      web_contents, browser_context->prefs(), is_guest));\n  inspectable_web_contents_->SetDelegate(this);\n}\n\nWebContents::~WebContents() {\n  MarkDestroyed();\n  // The destroy() is called.\n  if (inspectable_web_contents_) {\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n    if (type_ == Type::kBackgroundPage) {\n      // Background pages are owned by extensions::ExtensionHost\n      inspectable_web_contents_->ReleaseWebContents();\n    }\n#endif\n\n    inspectable_web_contents_->GetView()->SetDelegate(nullptr);\n\n    if (web_contents()) {\n      RenderViewDeleted(web_contents()->GetRenderViewHost());\n    }\n\n    if (type_ == Type::kBrowserWindow && owner_window()) {\n      // For BrowserWindow we should close the window and clean up everything\n      // before WebContents is destroyed.\n      for (ExtendedWebContentsObserver& observer : observers_)\n        observer.OnCloseContents();\n      // BrowserWindow destroys WebContents asynchronously, manually emit the\n      // destroyed event here.\n      WebContentsDestroyed();\n    } else if (Browser::Get()->is_shutting_down()) {\n      // Destroy WebContents directly when app is shutting down.\n      DestroyWebContents(false /* async */);\n    } else {\n      // Destroy WebContents asynchronously unless app is shutting down,\n      // because destroy() might be called inside WebContents's event handler.\n      bool is_browser_view = type_ == Type::kBrowserView;\n      DestroyWebContents(!(IsGuest() || is_browser_view) /* async */);\n      // The WebContentsDestroyed will not be called automatically because we\n      // destroy the webContents in the next tick. So we have to manually\n      // call it here to make sure \"destroyed\" event is emitted.\n      WebContentsDestroyed();\n    }\n  }\n}\n\nvoid WebContents::DestroyWebContents(bool async) {\n  // This event is only for internal use, which is emitted when WebContents is\n  // being destroyed.\n  Emit(\"will-destroy\");\n  ResetManagedWebContents(async);\n}\n\nbool WebContents::DidAddMessageToConsole(\n    content::WebContents* source,\n    blink::mojom::ConsoleMessageLevel level,\n    const base::string16& message,\n    int32_t line_no,\n    const base::string16& source_id) {\n  return Emit(\"console-message\", static_cast<int32_t>(level), message, line_no,\n              source_id);\n}\n\nvoid WebContents::OnCreateWindow(\n    const GURL& target_url,\n    const content::Referrer& referrer,\n    const std::string& frame_name,\n    WindowOpenDisposition disposition,\n    const std::string& features,\n    const scoped_refptr<network::ResourceRequestBody>& body) {\n  Emit(\"-new-window\", target_url, frame_name, disposition, features, referrer,\n       body);\n}\n\nvoid WebContents::WebContentsCreatedWithFullParams(\n    content::WebContents* source_contents,\n    int opener_render_process_id,\n    int opener_render_frame_id,\n    const content::mojom::CreateNewWindowParams& params,\n    content::WebContents* new_contents) {\n  ChildWebContentsTracker::CreateForWebContents(new_contents);\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents);\n  tracker->url = params.target_url;\n  tracker->frame_name = params.frame_name;\n  tracker->referrer = params.referrer.To<content::Referrer>();\n  tracker->raw_features = params.raw_features;\n  tracker->body = params.body;\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n\n  gin_helper::Dictionary dict;\n  gin::ConvertFromV8(isolate, pending_child_web_preferences_.Get(isolate),\n                     &dict);\n  pending_child_web_preferences_.Reset();\n\n  // Associate the preferences passed in via `setWindowOpenHandler` with the\n  // content::WebContents that was just created for the child window. These\n  // preferences will be picked up by the RenderWidgetHost via its call to the\n  // delegate's OverrideWebkitPrefs.\n  new WebContentsPreferences(new_contents, dict);\n}\n\nbool WebContents::IsWebContentsCreationOverridden(\n    content::SiteInstance* source_site_instance,\n    content::mojom::WindowContainerType window_container_type,\n    const GURL& opener_url,\n    const content::mojom::CreateNewWindowParams& params) {\n  bool default_prevented = Emit(\"-will-add-new-contents\", params.target_url,\n                                params.frame_name, params.raw_features);\n  // If the app prevented the default, redirect to CreateCustomWebContents,\n  // which always returns nullptr, which will result in the window open being\n  // prevented (window.open() will return null in the renderer).\n  return default_prevented;\n}\n\nvoid WebContents::SetNextChildWebPreferences(\n    const gin_helper::Dictionary preferences) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  // Store these prefs for when Chrome calls WebContentsCreatedWithFullParams\n  // with the new child contents.\n  pending_child_web_preferences_.Reset(isolate, preferences.GetHandle());\n}\n\ncontent::WebContents* WebContents::CreateCustomWebContents(\n    content::RenderFrameHost* opener,\n    content::SiteInstance* source_site_instance,\n    bool is_new_browsing_instance,\n    const GURL& opener_url,\n    const std::string& frame_name,\n    const GURL& target_url,\n    const std::string& partition_id,\n    content::SessionStorageNamespace* session_storage_namespace) {\n  return nullptr;\n}\n\nvoid WebContents::AddNewContents(\n    content::WebContents* source,\n    std::unique_ptr<content::WebContents> new_contents,\n    const GURL& target_url,\n    WindowOpenDisposition disposition,\n    const gfx::Rect& initial_rect,\n    bool user_gesture,\n    bool* was_blocked) {\n  auto* tracker = ChildWebContentsTracker::FromWebContents(new_contents.get());\n  DCHECK(tracker);\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  auto api_web_contents =\n      CreateAndTake(isolate, std::move(new_contents), Type::kBrowserWindow);\n  if (Emit(\"-add-new-contents\", api_web_contents, disposition, user_gesture,\n           initial_rect.x(), initial_rect.y(), initial_rect.width(),\n           initial_rect.height(), tracker->url, tracker->frame_name,\n           tracker->referrer, tracker->raw_features, tracker->body)) {\n    api_web_contents->DestroyWebContents(false /* async */);\n  }\n}\n\ncontent::WebContents* WebContents::OpenURLFromTab(\n    content::WebContents* source,\n    const content::OpenURLParams& params) {\n  auto weak_this = GetWeakPtr();\n  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {\n    Emit(\"-new-window\", params.url, \"\", params.disposition, \"\", params.referrer,\n         params.post_data);\n    return nullptr;\n  }\n\n  if (!weak_this)\n    return nullptr;\n\n  content::NavigationController::LoadURLParams load_url_params(params.url);\n  load_url_params.referrer = params.referrer;\n  load_url_params.transition_type = params.transition;\n  load_url_params.extra_headers = params.extra_headers;\n  load_url_params.should_replace_current_entry =\n      params.should_replace_current_entry;\n  load_url_params.is_renderer_initiated = params.is_renderer_initiated;\n  load_url_params.started_from_context_menu = params.started_from_context_menu;\n  load_url_params.initiator_origin = params.initiator_origin;\n  load_url_params.source_site_instance = params.source_site_instance;\n  load_url_params.frame_tree_node_id = params.frame_tree_node_id;\n  load_url_params.redirect_chain = params.redirect_chain;\n  load_url_params.has_user_gesture = params.user_gesture;\n  load_url_params.blob_url_loader_factory = params.blob_url_loader_factory;\n  load_url_params.href_translate = params.href_translate;\n  load_url_params.reload_type = params.reload_type;\n\n  if (params.post_data) {\n    load_url_params.load_type =\n        content::NavigationController::LOAD_TYPE_HTTP_POST;\n    load_url_params.post_data = params.post_data;\n  }\n\n  source->GetController().LoadURLWithParams(load_url_params);\n  return source;\n}\n\nvoid WebContents::BeforeUnloadFired(content::WebContents* tab,\n                                    bool proceed,\n                                    bool* proceed_to_fire_unload) {\n  if (type_ == Type::kBrowserWindow || type_ == Type::kOffScreen)\n    *proceed_to_fire_unload = proceed;\n  else\n    *proceed_to_fire_unload = true;\n  // Note that Chromium does not emit this for navigations.\n  Emit(\"before-unload-fired\", proceed);\n}\n\nvoid WebContents::SetContentsBounds(content::WebContents* source,\n                                    const gfx::Rect& rect) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnSetContentBounds(rect);\n}\n\nvoid WebContents::CloseContents(content::WebContents* source) {\n  Emit(\"close\");\n\n  auto* autofill_driver_factory =\n      AutofillDriverFactory::FromWebContents(web_contents());\n  if (autofill_driver_factory) {\n    autofill_driver_factory->CloseAllPopups();\n  }\n\n  if (inspectable_web_contents_)\n    inspectable_web_contents_->GetView()->SetDelegate(nullptr);\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnCloseContents();\n}\n\nvoid WebContents::ActivateContents(content::WebContents* source) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnActivateContents();\n}\n\nvoid WebContents::UpdateTargetURL(content::WebContents* source,\n                                  const GURL& url) {\n  Emit(\"update-target-url\", url);\n}\n\nbool WebContents::HandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (type_ == Type::kWebView && embedder_) {\n    // Send the unhandled keyboard events back to the embedder.\n    return embedder_->HandleKeyboardEvent(source, event);\n  } else {\n    return PlatformHandleKeyboardEvent(source, event);\n  }\n}\n\n#if !defined(OS_MAC)\n// NOTE: The macOS version of this function is found in\n// electron_api_web_contents_mac.mm, as it requires calling into objective-C\n// code.\nbool WebContents::PlatformHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  // Escape exits tabbed fullscreen mode.\n  if (event.windows_key_code == ui::VKEY_ESCAPE && is_html_fullscreen()) {\n    ExitFullscreenModeForTab(source);\n    return true;\n  }\n\n  // Check if the webContents has preferences and to ignore shortcuts\n  auto* web_preferences = WebContentsPreferences::From(source);\n  if (web_preferences &&\n      web_preferences->IsEnabled(\"ignoreMenuShortcuts\", false))\n    return false;\n\n  // Let the NativeWindow handle other parts.\n  if (owner_window()) {\n    owner_window()->HandleKeyboardEvent(source, event);\n    return true;\n  }\n\n  return false;\n}\n#endif\n\ncontent::KeyboardEventProcessingResult WebContents::PreHandleKeyboardEvent(\n    content::WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (event.GetType() == blink::WebInputEvent::Type::kRawKeyDown ||\n      event.GetType() == blink::WebInputEvent::Type::kKeyUp) {\n    bool prevent_default = Emit(\"before-input-event\", event);\n    if (prevent_default) {\n      return content::KeyboardEventProcessingResult::HANDLED;\n    }\n  }\n\n  return content::KeyboardEventProcessingResult::NOT_HANDLED;\n}\n\nvoid WebContents::ContentsZoomChange(bool zoom_in) {\n  Emit(\"zoom-changed\", zoom_in ? \"in\" : \"out\");\n}\n\nvoid WebContents::EnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options) {\n  auto* source = content::WebContents::FromRenderFrameHost(requesting_frame);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(source);\n  auto callback =\n      base::BindRepeating(&WebContents::OnEnterFullscreenModeForTab,\n                          base::Unretained(this), requesting_frame, options);\n  permission_helper->RequestFullscreenPermission(callback);\n}\n\nvoid WebContents::OnEnterFullscreenModeForTab(\n    content::RenderFrameHost* requesting_frame,\n    const blink::mojom::FullscreenOptions& options,\n    bool allowed) {\n  if (!allowed)\n    return;\n  if (!owner_window_)\n    return;\n  auto* source = content::WebContents::FromRenderFrameHost(requesting_frame);\n  if (IsFullscreenForTabOrPending(source)) {\n    DCHECK_EQ(fullscreen_frame_, source->GetFocusedFrame());\n    return;\n  }\n  SetHtmlApiFullscreen(true);\n  owner_window_->NotifyWindowEnterHtmlFullScreen();\n\n  if (native_fullscreen_) {\n    // Explicitly trigger a view resize, as the size is not actually changing if\n    // the browser is fullscreened, too.\n    source->GetRenderViewHost()->GetWidget()->SynchronizeVisualProperties();\n  }\n  Emit(\"enter-html-full-screen\");\n}\n\nvoid WebContents::ExitFullscreenModeForTab(content::WebContents* source) {\n  if (!owner_window_)\n    return;\n  SetHtmlApiFullscreen(false);\n  owner_window_->NotifyWindowLeaveHtmlFullScreen();\n\n  if (native_fullscreen_) {\n    // Explicitly trigger a view resize, as the size is not actually changing if\n    // the browser is fullscreened, too. Chrome does this indirectly from\n    // `chrome/browser/ui/exclusive_access/fullscreen_controller.cc`.\n    source->GetRenderViewHost()->GetWidget()->SynchronizeVisualProperties();\n  }\n  Emit(\"leave-html-full-screen\");\n}\n\nvoid WebContents::RendererUnresponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host,\n    base::RepeatingClosure hang_monitor_restarter) {\n  Emit(\"unresponsive\");\n}\n\nvoid WebContents::RendererResponsive(\n    content::WebContents* source,\n    content::RenderWidgetHost* render_widget_host) {\n  Emit(\"responsive\");\n}\n\nbool WebContents::HandleContextMenu(content::RenderFrameHost* render_frame_host,\n                                    const content::ContextMenuParams& params) {\n  if (params.custom_context.is_pepper_menu) {\n    Emit(\"pepper-context-menu\", std::make_pair(params, web_contents()),\n         base::BindOnce(&content::WebContents::NotifyContextMenuClosed,\n                        base::Unretained(web_contents()),\n                        params.custom_context));\n  } else {\n    Emit(\"context-menu\", std::make_pair(params, web_contents()));\n  }\n\n  return true;\n}\n\nbool WebContents::OnGoToEntryOffset(int offset) {\n  GoToOffset(offset);\n  return false;\n}\n\nvoid WebContents::FindReply(content::WebContents* web_contents,\n                            int request_id,\n                            int number_of_matches,\n                            const gfx::Rect& selection_rect,\n                            int active_match_ordinal,\n                            bool final_update) {\n  if (!final_update)\n    return;\n\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  gin_helper::Dictionary result = gin::Dictionary::CreateEmpty(isolate);\n  result.Set(\"requestId\", request_id);\n  result.Set(\"matches\", number_of_matches);\n  result.Set(\"selectionArea\", selection_rect);\n  result.Set(\"activeMatchOrdinal\", active_match_ordinal);\n  result.Set(\"finalUpdate\", final_update);  // Deprecate after 2.0\n  Emit(\"found-in-page\", result.GetHandle());\n}\n\nbool WebContents::CheckMediaAccessPermission(\n    content::RenderFrameHost* render_frame_host,\n    const GURL& security_origin,\n    blink::mojom::MediaStreamType type) {\n  auto* web_contents =\n      content::WebContents::FromRenderFrameHost(render_frame_host);\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  return permission_helper->CheckMediaAccessPermission(security_origin, type);\n}\n\nvoid WebContents::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    content::MediaResponseCallback callback) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestMediaAccessPermission(request, std::move(callback));\n}\n\nvoid WebContents::RequestToLockMouse(content::WebContents* web_contents,\n                                     bool user_gesture,\n                                     bool last_unlocked_by_target) {\n  auto* permission_helper =\n      WebContentsPermissionHelper::FromWebContents(web_contents);\n  permission_helper->RequestPointerLockPermission(user_gesture);\n}\n\ncontent::JavaScriptDialogManager* WebContents::GetJavaScriptDialogManager(\n    content::WebContents* source) {\n  if (!dialog_manager_)\n    dialog_manager_ = std::make_unique<ElectronJavaScriptDialogManager>();\n\n  return dialog_manager_.get();\n}\n\nvoid WebContents::OnAudioStateChanged(bool audible) {\n  Emit(\"-audio-state-changed\", audible);\n}\n\nvoid WebContents::BeforeUnloadFired(bool proceed,\n                                    const base::TimeTicks& proceed_time) {\n  // Do nothing, we override this method just to avoid compilation error since\n  // there are two virtual functions named BeforeUnloadFired.\n}\n\nvoid WebContents::RenderViewCreated(content::RenderViewHost* render_view_host) {\n  if (!background_throttling_)\n    render_view_host->SetSchedulerThrottling(false);\n}\n\nvoid WebContents::RenderFrameCreated(\n    content::RenderFrameHost* render_frame_host) {\n  auto* rwhv = render_frame_host->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (rwh_impl)\n    rwh_impl->disable_hidden_ = !background_throttling_;\n}\n\nvoid WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {\n  // This event is necessary for tracking any states with respect to\n  // intermediate render view hosts aka speculative render view hosts. Currently\n  // used by object-registry.js to ref count remote objects.\n  Emit(\"render-view-deleted\", render_view_host->GetProcess()->GetID());\n\n  if (web_contents()->GetRenderViewHost() == render_view_host) {\n    // When the RVH that has been deleted is the current RVH it means that the\n    // the web contents are being closed. This is communicated by this event.\n    // Currently tracked by guest-window-manager.ts to destroy the\n    // BrowserWindow.\n    Emit(\"current-render-view-deleted\",\n         render_view_host->GetProcess()->GetID());\n  }\n}\n\nvoid WebContents::RenderProcessGone(base::TerminationStatus status) {\n  Emit(\"crashed\", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  gin_helper::Dictionary details = gin_helper::Dictionary::CreateEmpty(isolate);\n  details.Set(\"reason\", status);\n  Emit(\"render-process-gone\", details);\n}\n\nvoid WebContents::PluginCrashed(const base::FilePath& plugin_path,\n                                base::ProcessId plugin_pid) {\n#if BUILDFLAG(ENABLE_PLUGINS)\n  content::WebPluginInfo info;\n  auto* plugin_service = content::PluginService::GetInstance();\n  plugin_service->GetPluginInfoByPath(plugin_path, &info);\n  Emit(\"plugin-crashed\", info.name, info.version);\n#endif  // BUILDFLAG(ENABLE_PLUGINS)\n}\n\nvoid WebContents::MediaStartedPlaying(const MediaPlayerInfo& video_type,\n                                      const content::MediaPlayerId& id) {\n  Emit(\"media-started-playing\");\n}\n\nvoid WebContents::MediaStoppedPlaying(\n    const MediaPlayerInfo& video_type,\n    const content::MediaPlayerId& id,\n    content::WebContentsObserver::MediaStoppedReason reason) {\n  Emit(\"media-paused\");\n}\n\nvoid WebContents::DidChangeThemeColor() {\n  auto theme_color = web_contents()->GetThemeColor();\n  if (theme_color) {\n    Emit(\"did-change-theme-color\", electron::ToRGBHex(theme_color.value()));\n  } else {\n    Emit(\"did-change-theme-color\", nullptr);\n  }\n}\n\nvoid WebContents::OnInterfaceRequestFromFrame(\n    content::RenderFrameHost* render_frame_host,\n    const std::string& interface_name,\n    mojo::ScopedMessagePipeHandle* interface_pipe) {\n  registry_.TryBindInterface(interface_name, interface_pipe, render_frame_host);\n}\n\nvoid WebContents::DidAcquireFullscreen(content::RenderFrameHost* rfh) {\n  set_fullscreen_frame(rfh);\n}\n\nvoid WebContents::DOMContentLoaded(\n    content::RenderFrameHost* render_frame_host) {\n  if (!render_frame_host->GetParent())\n    Emit(\"dom-ready\");\n}\n\nvoid WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,\n                                const GURL& validated_url) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  auto weak_this = GetWeakPtr();\n  Emit(\"did-frame-finish-load\", is_main_frame, frame_process_id,\n       frame_routing_id);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // Emit() triggers JS which can call destroy() on |this|. It's not safe to\n  // assume that |this| points to valid memory at this point.\n  if (is_main_frame && weak_this)\n    Emit(\"did-finish-load\");\n}\n\nvoid WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,\n                              const GURL& url,\n                              int error_code) {\n  bool is_main_frame = !render_frame_host->GetParent();\n  int frame_process_id = render_frame_host->GetProcess()->GetID();\n  int frame_routing_id = render_frame_host->GetRoutingID();\n  Emit(\"did-fail-load\", error_code, \"\", url, is_main_frame, frame_process_id,\n       frame_routing_id);\n}\n\nvoid WebContents::DidStartLoading() {\n  Emit(\"did-start-loading\");\n}\n\nvoid WebContents::DidStopLoading() {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (web_preferences &&\n      web_preferences->IsEnabled(options::kEnablePreferredSizeMode))\n    web_contents()->GetRenderViewHost()->EnablePreferredSizeMode();\n\n  Emit(\"did-stop-loading\");\n}\n\nbool WebContents::EmitNavigationEvent(\n    const std::string& event,\n    content::NavigationHandle* navigation_handle) {\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  int frame_tree_node_id = navigation_handle->GetFrameTreeNodeId();\n  content::FrameTreeNode* frame_tree_node =\n      content::FrameTreeNode::GloballyFindByID(frame_tree_node_id);\n  content::RenderFrameHostManager* render_manager =\n      frame_tree_node->render_manager();\n  content::RenderFrameHost* frame_host = nullptr;\n  if (render_manager) {\n    frame_host = render_manager->speculative_frame_host();\n    if (!frame_host)\n      frame_host = render_manager->current_frame_host();\n  }\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  bool is_same_document = navigation_handle->IsSameDocument();\n  auto url = navigation_handle->GetURL();\n  return Emit(event, url, is_same_document, is_main_frame, frame_process_id,\n              frame_routing_id);\n}\n\nvoid WebContents::BindElectronBrowser(\n    mojo::PendingReceiver<mojom::ElectronBrowser> receiver,\n    content::RenderFrameHost* render_frame_host) {\n  auto id = receivers_.Add(this, std::move(receiver), render_frame_host);\n  frame_to_receivers_map_[render_frame_host].push_back(id);\n}\n\nvoid WebContents::OnElectronBrowserConnectionError() {\n  auto receiver_id = receivers_.current_receiver();\n  auto* frame_host = receivers_.current_context();\n  base::Erase(frame_to_receivers_map_[frame_host], receiver_id);\n}\n\nvoid WebContents::Message(bool internal,\n                          const std::string& channel,\n                          blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Message\", \"channel\", channel);\n  // webContents.emit('-ipc-message', new Event(), internal, channel,\n  // arguments);\n  EmitWithSender(\"-ipc-message\", receivers_.current_context(), InvokeCallback(),\n                 internal, channel, std::move(arguments));\n}\n\nvoid WebContents::Invoke(bool internal,\n                         const std::string& channel,\n                         blink::CloneableMessage arguments,\n                         InvokeCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::Invoke\", \"channel\", channel);\n  // webContents.emit('-ipc-invoke', new Event(), internal, channel, arguments);\n  EmitWithSender(\"-ipc-invoke\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::OnFirstNonEmptyLayout() {\n  if (receivers_.current_context() == web_contents()->GetMainFrame()) {\n    Emit(\"ready-to-show\");\n  }\n}\n\nvoid WebContents::ReceivePostMessage(const std::string& channel,\n                                     blink::TransferableMessage message) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  auto wrapped_ports =\n      MessagePort::EntanglePorts(isolate, std::move(message.ports));\n  v8::Local<v8::Value> message_value =\n      electron::DeserializeV8Value(isolate, message);\n  EmitWithSender(\"-ipc-ports\", receivers_.current_context(), InvokeCallback(),\n                 false, channel, message_value, std::move(wrapped_ports));\n}\n\nvoid WebContents::PostMessage(const std::string& channel,\n                              v8::Local<v8::Value> message_value,\n                              base::Optional<v8::Local<v8::Value>> transfer) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::TransferableMessage transferable_message;\n  if (!electron::SerializeV8Value(isolate, message_value,\n                                  &transferable_message)) {\n    // SerializeV8Value sets an exception.\n    return;\n  }\n\n  std::vector<gin::Handle<MessagePort>> wrapped_ports;\n  if (transfer) {\n    if (!gin::ConvertFromV8(isolate, *transfer, &wrapped_ports)) {\n      isolate->ThrowException(v8::Exception::Error(\n          gin::StringToV8(isolate, \"Invalid value for transfer\")));\n      return;\n    }\n  }\n\n  bool threw_exception = false;\n  transferable_message.ports =\n      MessagePort::DisentanglePorts(isolate, wrapped_ports, &threw_exception);\n  if (threw_exception)\n    return;\n\n  content::RenderFrameHost* frame_host = web_contents()->GetMainFrame();\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->ReceivePostMessage(channel,\n                                        std::move(transferable_message));\n}\n\nvoid WebContents::MessageSync(bool internal,\n                              const std::string& channel,\n                              blink::CloneableMessage arguments,\n                              MessageSyncCallback callback) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageSync\", \"channel\", channel);\n  // webContents.emit('-ipc-message-sync', new Event(sender, message), internal,\n  // channel, arguments);\n  EmitWithSender(\"-ipc-message-sync\", receivers_.current_context(),\n                 std::move(callback), internal, channel, std::move(arguments));\n}\n\nvoid WebContents::MessageTo(bool internal,\n                            int32_t web_contents_id,\n                            const std::string& channel,\n                            blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageTo\", \"channel\", channel);\n  auto* web_contents = FromID(web_contents_id);\n\n  if (web_contents) {\n    web_contents->SendIPCMessageWithSender(internal, channel,\n                                           std::move(arguments), ID());\n  }\n}\n\nvoid WebContents::MessageHost(const std::string& channel,\n                              blink::CloneableMessage arguments) {\n  TRACE_EVENT1(\"electron\", \"WebContents::MessageHost\", \"channel\", channel);\n  // webContents.emit('ipc-message-host', new Event(), channel, args);\n  EmitWithSender(\"ipc-message-host\", receivers_.current_context(),\n                 InvokeCallback(), channel, std::move(arguments));\n}\n\nvoid WebContents::UpdateDraggableRegions(\n    std::vector<mojom::DraggableRegionPtr> regions) {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnDraggableRegionsUpdated(regions);\n}\n\nvoid WebContents::RenderFrameDeleted(\n    content::RenderFrameHost* render_frame_host) {\n  // A WebFrameMain can outlive its RenderFrameHost so we need to mark it as\n  // disposed to prevent access to it.\n  WebFrameMain::RenderFrameDeleted(render_frame_host);\n\n  // A RenderFrameHost can be destroyed before the related Mojo binding is\n  // closed, which can result in Mojo calls being sent for RenderFrameHosts\n  // that no longer exist. To prevent this from happening, when a\n  // RenderFrameHost goes away, we close all the bindings related to that\n  // frame.\n  auto it = frame_to_receivers_map_.find(render_frame_host);\n  if (it == frame_to_receivers_map_.end())\n    return;\n  for (auto id : it->second)\n    receivers_.Remove(id);\n  frame_to_receivers_map_.erase(it);\n}\n\nvoid WebContents::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-start-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidRedirectNavigation(\n    content::NavigationHandle* navigation_handle) {\n  EmitNavigationEvent(\"did-redirect-navigation\", navigation_handle);\n}\n\nvoid WebContents::DidFinishNavigation(\n    content::NavigationHandle* navigation_handle) {\n  if (!navigation_handle->HasCommitted())\n    return;\n  bool is_main_frame = navigation_handle->IsInMainFrame();\n  content::RenderFrameHost* frame_host =\n      navigation_handle->GetRenderFrameHost();\n  int frame_process_id = -1, frame_routing_id = -1;\n  if (frame_host) {\n    frame_process_id = frame_host->GetProcess()->GetID();\n    frame_routing_id = frame_host->GetRoutingID();\n  }\n  if (!navigation_handle->IsErrorPage()) {\n    // FIXME: All the Emit() calls below could potentially result in |this|\n    // being destroyed (by JS listening for the event and calling\n    // webContents.destroy()).\n    auto url = navigation_handle->GetURL();\n    bool is_same_document = navigation_handle->IsSameDocument();\n    if (is_same_document) {\n      Emit(\"did-navigate-in-page\", url, is_main_frame, frame_process_id,\n           frame_routing_id);\n    } else {\n      const net::HttpResponseHeaders* http_response =\n          navigation_handle->GetResponseHeaders();\n      std::string http_status_text;\n      int http_response_code = -1;\n      if (http_response) {\n        http_status_text = http_response->GetStatusText();\n        http_response_code = http_response->response_code();\n      }\n      Emit(\"did-frame-navigate\", url, http_response_code, http_status_text,\n           is_main_frame, frame_process_id, frame_routing_id);\n      if (is_main_frame) {\n        Emit(\"did-navigate\", url, http_response_code, http_status_text);\n      }\n    }\n    if (IsGuest())\n      Emit(\"load-commit\", url, is_main_frame);\n  } else {\n    auto url = navigation_handle->GetURL();\n    int code = navigation_handle->GetNetErrorCode();\n    auto description = net::ErrorToShortString(code);\n    Emit(\"did-fail-provisional-load\", code, description, url, is_main_frame,\n         frame_process_id, frame_routing_id);\n\n    // Do not emit \"did-fail-load\" for canceled requests.\n    if (code != net::ERR_ABORTED)\n      Emit(\"did-fail-load\", code, description, url, is_main_frame,\n           frame_process_id, frame_routing_id);\n  }\n}\n\nvoid WebContents::TitleWasSet(content::NavigationEntry* entry) {\n  base::string16 final_title;\n  bool explicit_set = true;\n  if (entry) {\n    auto title = entry->GetTitle();\n    auto url = entry->GetURL();\n    if (url.SchemeIsFile() && title.empty()) {\n      final_title = base::UTF8ToUTF16(url.ExtractFileName());\n      explicit_set = false;\n    } else {\n      final_title = title;\n    }\n  }\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnPageTitleUpdated(final_title, explicit_set);\n  Emit(\"page-title-updated\", final_title, explicit_set);\n}\n\nvoid WebContents::DidUpdateFaviconURL(\n    content::RenderFrameHost* render_frame_host,\n    const std::vector<blink::mojom::FaviconURLPtr>& urls) {\n  std::set<GURL> unique_urls;\n  for (const auto& iter : urls) {\n    if (iter->icon_type != blink::mojom::FaviconIconType::kFavicon)\n      continue;\n    const GURL& url = iter->icon_url;\n    if (url.is_valid())\n      unique_urls.insert(url);\n  }\n  Emit(\"page-favicon-updated\", unique_urls);\n}\n\nvoid WebContents::DevToolsReloadPage() {\n  Emit(\"devtools-reload-page\");\n}\n\nvoid WebContents::DevToolsFocused() {\n  Emit(\"devtools-focused\");\n}\n\nvoid WebContents::DevToolsOpened() {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  DCHECK(inspectable_web_contents_);\n  auto handle = FromOrCreate(\n      isolate, inspectable_web_contents_->GetDevToolsWebContents());\n  devtools_web_contents_.Reset(isolate, handle.ToV8());\n\n  // Set inspected tabID.\n  base::Value tab_id(ID());\n  inspectable_web_contents_->CallClientFunction(\"DevToolsAPI.setInspectedTabId\",\n                                                &tab_id, nullptr, nullptr);\n\n  // Inherit owner window in devtools when it doesn't have one.\n  auto* devtools = inspectable_web_contents_->GetDevToolsWebContents();\n  bool has_window = devtools->GetUserData(NativeWindowRelay::UserDataKey());\n  if (owner_window() && !has_window)\n    handle->SetOwnerWindow(devtools, owner_window());\n\n  Emit(\"devtools-opened\");\n}\n\nvoid WebContents::DevToolsClosed() {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::Locker locker(isolate);\n  v8::HandleScope handle_scope(isolate);\n  devtools_web_contents_.Reset();\n\n  Emit(\"devtools-closed\");\n}\n\nvoid WebContents::DevToolsResized() {\n  for (ExtendedWebContentsObserver& observer : observers_)\n    observer.OnDevToolsResized();\n}\n\nbool WebContents::OnMessageReceived(const IPC::Message& message) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(WebContents, message)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n\n  return handled;\n}\n\nvoid WebContents::SetOwnerWindow(NativeWindow* owner_window) {\n  SetOwnerWindow(GetWebContents(), owner_window);\n}\n\nvoid WebContents::SetOwnerWindow(content::WebContents* web_contents,\n                                 NativeWindow* owner_window) {\n  if (owner_window) {\n    owner_window_ = owner_window->GetWeakPtr();\n    NativeWindowRelay::CreateForWebContents(web_contents,\n                                            owner_window->GetWeakPtr());\n  } else {\n    owner_window_ = nullptr;\n    web_contents->RemoveUserData(NativeWindowRelay::UserDataKey());\n  }\n#if BUILDFLAG(ENABLE_OSR)\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetNativeWindow(owner_window);\n#endif\n}\n\nvoid WebContents::ResetManagedWebContents(bool async) {\n  if (async) {\n    // Browser context should be destroyed only after the WebContents,\n    // this is guaranteed in the sync mode by the order of declaration,\n    // in the async version we maintain a reference until the WebContents\n    // is destroyed.\n    // //electron/patches/chromium/content_browser_main_loop.patch\n    // is required to get the right quit closure for the main message loop.\n    base::ThreadTaskRunnerHandle::Get()->DeleteSoon(\n        FROM_HERE, inspectable_web_contents_.release());\n  } else {\n    inspectable_web_contents_.reset();\n  }\n}\n\ncontent::WebContents* WebContents::GetWebContents() const {\n  if (!inspectable_web_contents_)\n    return nullptr;\n  return inspectable_web_contents_->GetWebContents();\n}\n\ncontent::WebContents* WebContents::GetDevToolsWebContents() const {\n  if (!inspectable_web_contents_)\n    return nullptr;\n  return inspectable_web_contents_->GetDevToolsWebContents();\n}\n\nvoid WebContents::MarkDestroyed() {\n  if (GetAllWebContents().Lookup(id_))\n    GetAllWebContents().Remove(id_);\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  v8::HandleScope scope(isolate);\n  v8::Local<v8::Object> wrapper;\n  if (!GetWrapper(isolate).ToLocal(&wrapper))\n    return;\n  wrapper->SetAlignedPointerInInternalField(0, nullptr);\n}\n\n// There are three ways of destroying a webContents:\n// 1. call webContents.destroy();\n// 2. garbage collection;\n// 3. user closes the window of webContents;\n// 4. the embedder detaches the frame.\n// For webview only #4 will happen, for BrowserWindow both #1 and #3 may\n// happen. The #2 should never happen for webContents, because webview is\n// managed by GuestViewManager, and BrowserWindow's webContents is managed\n// by api::BrowserWindow.\n// For #1, the destructor will do the cleanup work and we only need to make\n// sure \"destroyed\" event is emitted. For #3, the content::WebContents will\n// be destroyed on close, and WebContentsDestroyed would be called for it, so\n// we need to make sure the api::WebContents is also deleted.\n// For #4, the WebContents will be destroyed by embedder.\nvoid WebContents::WebContentsDestroyed() {\n  // Give chance for guest delegate to cleanup its observers\n  // since the native class is only destroyed in the next tick.\n  if (guest_delegate_)\n    guest_delegate_->WillDestroy();\n\n  // Cleanup relationships with other parts.\n\n  // We can not call Destroy here because we need to call Emit first, but we\n  // also do not want any method to be used, so just mark as destroyed here.\n  MarkDestroyed();\n\n  Emit(\"destroyed\");\n\n  // For guest view based on OOPIF, the WebContents is released by the embedder\n  // frame, and we need to clear the reference to the memory.\n  if (IsGuest() && inspectable_web_contents_) {\n    inspectable_web_contents_->ReleaseWebContents();\n    ResetManagedWebContents(false);\n  }\n\n  // Destroy the native class in next tick.\n  base::ThreadTaskRunnerHandle::Get()->PostTask(\n      FROM_HERE, base::BindOnce(\n                     [](base::WeakPtr<WebContents> wc) {\n                       if (wc)\n                         delete wc.get();\n                     },\n                     GetWeakPtr()));\n}\n\nvoid WebContents::NavigationEntryCommitted(\n    const content::LoadCommittedDetails& details) {\n  Emit(\"navigation-entry-committed\", details.entry->GetURL(),\n       details.is_same_document, details.did_replace_entry);\n}\n\nbool WebContents::GetBackgroundThrottling() const {\n  return background_throttling_;\n}\n\nvoid WebContents::SetBackgroundThrottling(bool allowed) {\n  background_throttling_ = allowed;\n\n  auto* rfh = web_contents()->GetMainFrame();\n  if (!rfh)\n    return;\n\n  auto* rwhv = rfh->GetView();\n  if (!rwhv)\n    return;\n\n  auto* rwh_impl =\n      static_cast<content::RenderWidgetHostImpl*>(rwhv->GetRenderWidgetHost());\n  if (!rwh_impl)\n    return;\n\n  rwh_impl->disable_hidden_ = !background_throttling_;\n  web_contents()->GetRenderViewHost()->SetSchedulerThrottling(allowed);\n\n  if (rwh_impl->is_hidden()) {\n    rwh_impl->WasShown({});\n  }\n}\n\nint WebContents::GetProcessID() const {\n  return web_contents()->GetMainFrame()->GetProcess()->GetID();\n}\n\nbase::ProcessId WebContents::GetOSProcessID() const {\n  base::ProcessHandle process_handle =\n      web_contents()->GetMainFrame()->GetProcess()->GetProcess().Handle();\n  return base::GetProcId(process_handle);\n}\n\nWebContents::Type WebContents::GetType() const {\n  return type_;\n}\n\nbool WebContents::Equal(const WebContents* web_contents) const {\n  return ID() == web_contents->ID();\n}\n\nvoid WebContents::LoadURL(const GURL& url,\n                          const gin_helper::Dictionary& options) {\n  if (!url.is_valid() || url.spec().size() > url::kMaxURLChars) {\n    Emit(\"did-fail-load\", static_cast<int>(net::ERR_INVALID_URL),\n         net::ErrorToShortString(net::ERR_INVALID_URL),\n         url.possibly_invalid_spec(), true);\n    return;\n  }\n\n  content::NavigationController::LoadURLParams params(url);\n\n  if (!options.Get(\"httpReferrer\", &params.referrer)) {\n    GURL http_referrer;\n    if (options.Get(\"httpReferrer\", &http_referrer))\n      params.referrer =\n          content::Referrer(http_referrer.GetAsReferrer(),\n                            network::mojom::ReferrerPolicy::kDefault);\n  }\n\n  std::string user_agent;\n  if (options.Get(\"userAgent\", &user_agent))\n    web_contents()->SetUserAgentOverride(\n        blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n\n  std::string extra_headers;\n  if (options.Get(\"extraHeaders\", &extra_headers))\n    params.extra_headers = extra_headers;\n\n  scoped_refptr<network::ResourceRequestBody> body;\n  if (options.Get(\"postData\", &body)) {\n    params.post_data = body;\n    params.load_type = content::NavigationController::LOAD_TYPE_HTTP_POST;\n  }\n\n  GURL base_url_for_data_url;\n  if (options.Get(\"baseURLForDataURL\", &base_url_for_data_url)) {\n    params.base_url_for_data_url = base_url_for_data_url;\n    params.load_type = content::NavigationController::LOAD_TYPE_DATA;\n  }\n\n  bool reload_ignoring_cache = false;\n  if (options.Get(\"reloadIgnoringCache\", &reload_ignoring_cache) &&\n      reload_ignoring_cache) {\n    params.reload_type = content::ReloadType::BYPASSING_CACHE;\n  }\n\n  // Calling LoadURLWithParams() can trigger JS which destroys |this|.\n  auto weak_this = GetWeakPtr();\n\n  // Required to make beforeunload handler work.\n  NotifyUserActivation();\n\n  params.transition_type = ui::PAGE_TRANSITION_TYPED;\n  params.should_clear_history_list = true;\n  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;\n  // Discord non-committed entries to ensure that we don't re-use a pending\n  // entry\n  web_contents()->GetController().DiscardNonCommittedEntries();\n  web_contents()->GetController().LoadURLWithParams(params);\n\n  // \u26a0\ufe0fWARNING!\u26a0\ufe0f\n  // LoadURLWithParams() triggers JS events which can call destroy() on |this|.\n  // It's not safe to assume that |this| points to valid memory at this point.\n  if (!weak_this)\n    return;\n\n  // Set the background color of RenderWidgetHostView.\n  // We have to call it right after LoadURL because the RenderViewHost is only\n  // created after loading a page.\n  auto* const view = weak_this->web_contents()->GetRenderWidgetHostView();\n  if (view) {\n    auto* web_preferences = WebContentsPreferences::From(web_contents());\n    std::string color_name;\n    if (web_preferences->GetPreference(options::kBackgroundColor,\n                                       &color_name)) {\n      view->SetBackgroundColor(ParseHexColor(color_name));\n    } else {\n      view->SetBackgroundColor(SK_ColorTRANSPARENT);\n    }\n  }\n}\n\nvoid WebContents::DownloadURL(const GURL& url) {\n  auto* browser_context = web_contents()->GetBrowserContext();\n  auto* download_manager =\n      content::BrowserContext::GetDownloadManager(browser_context);\n  std::unique_ptr<download::DownloadUrlParameters> download_params(\n      content::DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(\n          web_contents(), url, MISSING_TRAFFIC_ANNOTATION));\n  download_manager->DownloadUrl(std::move(download_params));\n}\n\nGURL WebContents::GetURL() const {\n  return web_contents()->GetURL();\n}\n\nbase::string16 WebContents::GetTitle() const {\n  return web_contents()->GetTitle();\n}\n\nbool WebContents::IsLoading() const {\n  return web_contents()->IsLoading();\n}\n\nbool WebContents::IsLoadingMainFrame() const {\n  return web_contents()->IsLoadingToDifferentDocument();\n}\n\nbool WebContents::IsWaitingForResponse() const {\n  return web_contents()->IsWaitingForResponse();\n}\n\nvoid WebContents::Stop() {\n  web_contents()->Stop();\n}\n\nvoid WebContents::GoBack() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoBack();\n}\n\nvoid WebContents::GoForward() {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoForward();\n}\n\nvoid WebContents::GoToOffset(int offset) {\n  if (!ElectronBrowserClient::Get()->CanUseCustomSiteInstance()) {\n    electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();\n  }\n  web_contents()->GetController().GoToOffset(offset);\n}\n\nconst std::string WebContents::GetWebRTCIPHandlingPolicy() const {\n  return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;\n}\n\nvoid WebContents::SetWebRTCIPHandlingPolicy(\n    const std::string& webrtc_ip_handling_policy) {\n  if (GetWebRTCIPHandlingPolicy() == webrtc_ip_handling_policy)\n    return;\n  web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy =\n      webrtc_ip_handling_policy;\n\n  web_contents()->SyncRendererPrefs();\n}\n\nbool WebContents::IsCrashed() const {\n  return web_contents()->IsCrashed();\n}\n\nvoid WebContents::ForcefullyCrashRenderer() {\n  content::RenderWidgetHostView* view =\n      web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return;\n\n  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();\n  if (!rwh)\n    return;\n\n  content::RenderProcessHost* rph = rwh->GetProcess();\n  if (rph) {\n#if defined(OS_LINUX) || defined(OS_CHROMEOS)\n    // A generic |CrashDumpHungChildProcess()| is not implemented for Linux.\n    // Instead we send an explicit IPC to crash on the renderer's IO thread.\n    rph->ForceCrash();\n#else\n    // Try to generate a crash report for the hung process.\n#ifndef MAS_BUILD\n    CrashDumpHungChildProcess(rph->GetProcess().Handle());\n#endif\n    rph->Shutdown(content::RESULT_CODE_HUNG);\n#endif\n  }\n}\n\nvoid WebContents::SetUserAgent(const std::string& user_agent) {\n  web_contents()->SetUserAgentOverride(\n      blink::UserAgentOverride::UserAgentOnly(user_agent), false);\n}\n\nstd::string WebContents::GetUserAgent() {\n  return web_contents()->GetUserAgentOverride().ua_string_override;\n}\n\nv8::Local<v8::Promise> WebContents::SavePage(\n    const base::FilePath& full_file_path,\n    const content::SavePageType& save_type) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  gin_helper::Promise<void> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  auto* handler = new SavePageHandler(web_contents(), std::move(promise));\n  handler->Handle(full_file_path, save_type);\n\n  return handle;\n}\n\nvoid WebContents::OpenDevTools(gin::Arguments* args) {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  std::string state;\n  if (type_ == Type::kWebView || type_ == Type::kBackgroundPage ||\n      !owner_window()) {\n    state = \"detach\";\n  }\n  bool activate = true;\n  if (args && args->Length() == 1) {\n    gin_helper::Dictionary options;\n    if (args->GetNext(&options)) {\n      options.Get(\"mode\", &state);\n      options.Get(\"activate\", &activate);\n    }\n  }\n\n  DCHECK(inspectable_web_contents_);\n  inspectable_web_contents_->SetDockState(state);\n  inspectable_web_contents_->ShowDevTools(activate);\n}\n\nvoid WebContents::CloseDevTools() {\n  if (type_ == Type::kRemote)\n    return;\n\n  DCHECK(inspectable_web_contents_);\n  inspectable_web_contents_->CloseDevTools();\n}\n\nbool WebContents::IsDevToolsOpened() {\n  if (type_ == Type::kRemote)\n    return false;\n\n  DCHECK(inspectable_web_contents_);\n  return inspectable_web_contents_->IsDevToolsViewShowing();\n}\n\nbool WebContents::IsDevToolsFocused() {\n  if (type_ == Type::kRemote)\n    return false;\n\n  DCHECK(inspectable_web_contents_);\n  return inspectable_web_contents_->GetView()->IsDevToolsViewFocused();\n}\n\nvoid WebContents::EnableDeviceEmulation(\n    const blink::DeviceEmulationParams& params) {\n  if (type_ == Type::kRemote)\n    return;\n\n  DCHECK(web_contents());\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host_impl =\n        frame_host ? static_cast<content::RenderWidgetHostImpl*>(\n                         frame_host->GetView()->GetRenderWidgetHost())\n                   : nullptr;\n    if (widget_host_impl) {\n      auto& frame_widget = widget_host_impl->GetAssociatedFrameWidget();\n      frame_widget->EnableDeviceEmulation(params);\n    }\n  }\n}\n\nvoid WebContents::DisableDeviceEmulation() {\n  if (type_ == Type::kRemote)\n    return;\n\n  DCHECK(web_contents());\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (frame_host) {\n    auto* widget_host_impl =\n        frame_host ? static_cast<content::RenderWidgetHostImpl*>(\n                         frame_host->GetView()->GetRenderWidgetHost())\n                   : nullptr;\n    if (widget_host_impl) {\n      auto& frame_widget = widget_host_impl->GetAssociatedFrameWidget();\n      frame_widget->DisableDeviceEmulation();\n    }\n  }\n}\n\nvoid WebContents::ToggleDevTools() {\n  if (IsDevToolsOpened())\n    CloseDevTools();\n  else\n    OpenDevTools(nullptr);\n}\n\nvoid WebContents::InspectElement(int x, int y) {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  DCHECK(inspectable_web_contents_);\n  if (!inspectable_web_contents_->GetDevToolsWebContents())\n    OpenDevTools(nullptr);\n  inspectable_web_contents_->InspectElement(x, y);\n}\n\nvoid WebContents::InspectSharedWorkerById(const std::string& workerId) {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      if (agent_host->GetId() == workerId) {\n        OpenDevTools(nullptr);\n        inspectable_web_contents_->AttachTo(agent_host);\n        break;\n      }\n    }\n  }\n}\n\nstd::vector<scoped_refptr<content::DevToolsAgentHost>>\nWebContents::GetAllSharedWorkers() {\n  std::vector<scoped_refptr<content::DevToolsAgentHost>> shared_workers;\n\n  if (type_ == Type::kRemote)\n    return shared_workers;\n\n  if (!enable_devtools_)\n    return shared_workers;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      shared_workers.push_back(agent_host);\n    }\n  }\n  return shared_workers;\n}\n\nvoid WebContents::InspectSharedWorker() {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeSharedWorker) {\n      OpenDevTools(nullptr);\n      inspectable_web_contents_->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::InspectServiceWorker() {\n  if (type_ == Type::kRemote)\n    return;\n\n  if (!enable_devtools_)\n    return;\n\n  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {\n    if (agent_host->GetType() ==\n        content::DevToolsAgentHost::kTypeServiceWorker) {\n      OpenDevTools(nullptr);\n      inspectable_web_contents_->AttachTo(agent_host);\n      break;\n    }\n  }\n}\n\nvoid WebContents::SetIgnoreMenuShortcuts(bool ignore) {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  DCHECK(web_preferences);\n  web_preferences->preference()->SetKey(\"ignoreMenuShortcuts\",\n                                        base::Value(ignore));\n}\n\nvoid WebContents::SetAudioMuted(bool muted) {\n  web_contents()->SetAudioMuted(muted);\n}\n\nbool WebContents::IsAudioMuted() {\n  return web_contents()->IsAudioMuted();\n}\n\nbool WebContents::IsCurrentlyAudible() {\n  return web_contents()->IsCurrentlyAudible();\n}\n\n#if BUILDFLAG(ENABLE_PRINTING)\nvoid WebContents::OnGetDefaultPrinter(\n    base::Value print_settings,\n    printing::CompletionCallback print_callback,\n    base::string16 device_name,\n    bool silent,\n    base::string16 default_printer) {\n  // The content::WebContents might be already deleted at this point, and the\n  // PrintViewManagerBasic class does not do null check.\n  if (!web_contents()) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"failed\");\n    return;\n  }\n\n  base::string16 printer_name =\n      device_name.empty() ? default_printer : device_name;\n\n  // If there are no valid printers available on the network, we bail.\n  if (printer_name.empty() || !IsDeviceNameValid(printer_name)) {\n    if (print_callback)\n      std::move(print_callback).Run(false, \"no valid printers available\");\n    return;\n  }\n\n  print_settings.SetStringKey(printing::kSettingDeviceName, printer_name);\n\n  auto* print_view_manager =\n      printing::PrintViewManagerBasic::FromWebContents(web_contents());\n  auto* focused_frame = web_contents()->GetFocusedFrame();\n  auto* rfh = focused_frame && focused_frame->HasSelection()\n                  ? focused_frame\n                  : web_contents()->GetMainFrame();\n\n  print_view_manager->PrintNow(rfh, silent, std::move(print_settings),\n                               std::move(print_callback));\n}\n\nvoid WebContents::Print(gin::Arguments* args) {\n  gin_helper::Dictionary options =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  base::Value settings(base::Value::Type::DICTIONARY);\n\n  if (args->Length() >= 1 && !args->GetNext(&options)) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"webContents.print(): Invalid print settings specified.\");\n    return;\n  }\n\n  printing::CompletionCallback callback;\n  if (args->Length() == 2 && !args->GetNext(&callback)) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"webContents.print(): Invalid optional callback provided.\");\n    return;\n  }\n\n  // Set optional silent printing\n  bool silent = false;\n  options.Get(\"silent\", &silent);\n\n  bool print_background = false;\n  options.Get(\"printBackground\", &print_background);\n  settings.SetBoolKey(printing::kSettingShouldPrintBackgrounds,\n                      print_background);\n\n  // Set custom margin settings\n  gin_helper::Dictionary margins =\n      gin::Dictionary::CreateEmpty(args->isolate());\n  if (options.Get(\"margins\", &margins)) {\n    printing::mojom::MarginType margin_type =\n        printing::mojom::MarginType::kDefaultMargins;\n    margins.Get(\"marginType\", &margin_type);\n    settings.SetIntKey(printing::kSettingMarginsType,\n                       static_cast<int>(margin_type));\n\n    if (margin_type == printing::mojom::MarginType::kCustomMargins) {\n      base::Value custom_margins(base::Value::Type::DICTIONARY);\n      int top = 0;\n      margins.Get(\"top\", &top);\n      custom_margins.SetIntKey(printing::kSettingMarginTop, top);\n      int bottom = 0;\n      margins.Get(\"bottom\", &bottom);\n      custom_margins.SetIntKey(printing::kSettingMarginBottom, bottom);\n      int left = 0;\n      margins.Get(\"left\", &left);\n      custom_margins.SetIntKey(printing::kSettingMarginLeft, left);\n      int right = 0;\n      margins.Get(\"right\", &right);\n      custom_margins.SetIntKey(printing::kSettingMarginRight, right);\n      settings.SetPath(printing::kSettingMarginsCustom,\n                       std::move(custom_margins));\n    }\n  } else {\n    settings.SetIntKey(\n        printing::kSettingMarginsType,\n        static_cast<int>(printing::mojom::MarginType::kDefaultMargins));\n  }\n\n  // Set whether to print color or greyscale\n  bool print_color = true;\n  options.Get(\"color\", &print_color);\n  auto const color_model = print_color ? printing::mojom::ColorModel::kColor\n                                       : printing::mojom::ColorModel::kGray;\n  settings.SetIntKey(printing::kSettingColor, static_cast<int>(color_model));\n\n  // Is the orientation landscape or portrait.\n  bool landscape = false;\n  options.Get(\"landscape\", &landscape);\n  settings.SetBoolKey(printing::kSettingLandscape, landscape);\n\n  // We set the default to the system's default printer and only update\n  // if at the Chromium level if the user overrides.\n  // Printer device name as opened by the OS.\n  base::string16 device_name;\n  options.Get(\"deviceName\", &device_name);\n  if (!device_name.empty() && !IsDeviceNameValid(device_name)) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"webContents.print(): Invalid deviceName provided.\");\n    return;\n  }\n\n  int scale_factor = 100;\n  options.Get(\"scaleFactor\", &scale_factor);\n  settings.SetIntKey(printing::kSettingScaleFactor, scale_factor);\n\n  int pages_per_sheet = 1;\n  options.Get(\"pagesPerSheet\", &pages_per_sheet);\n  settings.SetIntKey(printing::kSettingPagesPerSheet, pages_per_sheet);\n\n  // True if the user wants to print with collate.\n  bool collate = true;\n  options.Get(\"collate\", &collate);\n  settings.SetBoolKey(printing::kSettingCollate, collate);\n\n  // The number of individual copies to print\n  int copies = 1;\n  options.Get(\"copies\", &copies);\n  settings.SetIntKey(printing::kSettingCopies, copies);\n\n  // Strings to be printed as headers and footers if requested by the user.\n  std::string header;\n  options.Get(\"header\", &header);\n  std::string footer;\n  options.Get(\"footer\", &footer);\n\n  if (!(header.empty() && footer.empty())) {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, true);\n\n    settings.SetStringKey(printing::kSettingHeaderFooterTitle, header);\n    settings.SetStringKey(printing::kSettingHeaderFooterURL, footer);\n  } else {\n    settings.SetBoolKey(printing::kSettingHeaderFooterEnabled, false);\n  }\n\n  // We don't want to allow the user to enable these settings\n  // but we need to set them or a CHECK is hit.\n  settings.SetIntKey(printing::kSettingPrinterType,\n                     static_cast<int>(printing::PrinterType::kLocal));\n  settings.SetBoolKey(printing::kSettingShouldPrintSelectionOnly, false);\n  settings.SetBoolKey(printing::kSettingRasterizePdf, false);\n\n  // Set custom page ranges to print\n  std::vector<gin_helper::Dictionary> page_ranges;\n  if (options.Get(\"pageRanges\", &page_ranges)) {\n    base::Value page_range_list(base::Value::Type::LIST);\n    for (auto& range : page_ranges) {\n      int from, to;\n      if (range.Get(\"from\", &from) && range.Get(\"to\", &to)) {\n        base::Value range(base::Value::Type::DICTIONARY);\n        // Chromium uses 1-based page ranges, so increment each by 1.\n        range.SetIntKey(printing::kSettingPageRangeFrom, from + 1);\n        range.SetIntKey(printing::kSettingPageRangeTo, to + 1);\n        page_range_list.Append(std::move(range));\n      } else {\n        continue;\n      }\n    }\n    if (!page_range_list.GetList().empty())\n      settings.SetPath(printing::kSettingPageRange, std::move(page_range_list));\n  }\n\n  // Duplex type user wants to use.\n  printing::mojom::DuplexMode duplex_mode =\n      printing::mojom::DuplexMode::kSimplex;\n  options.Get(\"duplexMode\", &duplex_mode);\n  settings.SetIntKey(printing::kSettingDuplexMode,\n                     static_cast<int>(duplex_mode));\n\n  // We've already done necessary parameter sanitization at the\n  // JS level, so we can simply pass this through.\n  base::Value media_size(base::Value::Type::DICTIONARY);\n  if (options.Get(\"mediaSize\", &media_size))\n    settings.SetKey(printing::kSettingMediaSize, std::move(media_size));\n\n  // Set custom dots per inch (dpi)\n  gin_helper::Dictionary dpi_settings;\n  int dpi = 72;\n  if (options.Get(\"dpi\", &dpi_settings)) {\n    int horizontal = 72;\n    dpi_settings.Get(\"horizontal\", &horizontal);\n    settings.SetIntKey(printing::kSettingDpiHorizontal, horizontal);\n    int vertical = 72;\n    dpi_settings.Get(\"vertical\", &vertical);\n    settings.SetIntKey(printing::kSettingDpiVertical, vertical);\n  } else {\n    settings.SetIntKey(printing::kSettingDpiHorizontal, dpi);\n    settings.SetIntKey(printing::kSettingDpiVertical, dpi);\n  }\n\n  base::ThreadPool::PostTaskAndReplyWithResult(\n      FROM_HERE, {base::MayBlock(), base::TaskPriority::USER_BLOCKING},\n      base::BindOnce(&GetDefaultPrinterAsync),\n      base::BindOnce(&WebContents::OnGetDefaultPrinter,\n                     weak_factory_.GetWeakPtr(), std::move(settings),\n                     std::move(callback), device_name, silent));\n}\n\nv8::Local<v8::Promise> WebContents::PrintToPDF(base::DictionaryValue settings) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  gin_helper::Promise<v8::Local<v8::Value>> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n  PrintPreviewMessageHandler::FromWebContents(web_contents())\n      ->PrintToPDF(std::move(settings), std::move(promise));\n  return handle;\n}\n#endif\n\nvoid WebContents::AddWorkSpace(gin::Arguments* args,\n                               const base::FilePath& path) {\n  if (path.empty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsAddFileSystem(std::string(), path);\n}\n\nvoid WebContents::RemoveWorkSpace(gin::Arguments* args,\n                                  const base::FilePath& path) {\n  if (path.empty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"path cannot be empty\");\n    return;\n  }\n  DevToolsRemoveFileSystem(path);\n}\n\nvoid WebContents::Undo() {\n  web_contents()->Undo();\n}\n\nvoid WebContents::Redo() {\n  web_contents()->Redo();\n}\n\nvoid WebContents::Cut() {\n  web_contents()->Cut();\n}\n\nvoid WebContents::Copy() {\n  web_contents()->Copy();\n}\n\nvoid WebContents::Paste() {\n  web_contents()->Paste();\n}\n\nvoid WebContents::PasteAndMatchStyle() {\n  web_contents()->PasteAndMatchStyle();\n}\n\nvoid WebContents::Delete() {\n  web_contents()->Delete();\n}\n\nvoid WebContents::SelectAll() {\n  web_contents()->SelectAll();\n}\n\nvoid WebContents::Unselect() {\n  web_contents()->CollapseSelection();\n}\n\nvoid WebContents::Replace(const base::string16& word) {\n  web_contents()->Replace(word);\n}\n\nvoid WebContents::ReplaceMisspelling(const base::string16& word) {\n  web_contents()->ReplaceMisspelling(word);\n}\n\nuint32_t WebContents::FindInPage(gin::Arguments* args) {\n  base::string16 search_text;\n  if (!args->GetNext(&search_text) || search_text.empty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"Must provide a non-empty search content\");\n    return 0;\n  }\n\n  uint32_t request_id = ++find_in_page_request_id_;\n  gin_helper::Dictionary dict;\n  auto options = blink::mojom::FindOptions::New();\n  if (args->GetNext(&dict)) {\n    dict.Get(\"forward\", &options->forward);\n    dict.Get(\"matchCase\", &options->match_case);\n    dict.Get(\"findNext\", &options->new_session);\n  }\n\n  web_contents()->Find(request_id, search_text, std::move(options));\n  return request_id;\n}\n\nvoid WebContents::StopFindInPage(content::StopFindAction action) {\n  web_contents()->StopFinding(action);\n}\n\nvoid WebContents::ShowDefinitionForSelection() {\n#if defined(OS_MAC)\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (view)\n    view->ShowDefinitionForSelection();\n#endif\n}\n\nvoid WebContents::CopyImageAt(int x, int y) {\n  auto* const host = web_contents()->GetMainFrame();\n  if (host)\n    host->CopyImageAt(x, y);\n}\n\nvoid WebContents::Focus() {\n  // Focusing on WebContents does not automatically focus the window on macOS\n  // and Linux, do it manually to match the behavior on Windows.\n#if defined(OS_MAC) || defined(OS_LINUX)\n  if (owner_window())\n    owner_window()->Focus(true);\n#endif\n  web_contents()->Focus();\n}\n\n#if !defined(OS_MAC)\nbool WebContents::IsFocused() const {\n  auto* view = web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return false;\n\n  if (GetType() != Type::kBackgroundPage) {\n    auto* window = web_contents()->GetNativeView()->GetToplevelWindow();\n    if (window && !window->IsVisible())\n      return false;\n  }\n\n  return view->HasFocus();\n}\n#endif\n\nbool WebContents::SendIPCMessage(bool internal,\n                                 const std::string& channel,\n                                 v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  return SendIPCMessageWithSender(internal, channel, std::move(message));\n}\n\nbool WebContents::SendIPCMessageWithSender(bool internal,\n                                           const std::string& channel,\n                                           blink::CloneableMessage args,\n                                           int32_t sender_id) {\n  auto* frame_host = web_contents()->GetMainFrame();\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(args), sender_id);\n  return true;\n}\n\nbool WebContents::SendIPCMessageToFrame(bool internal,\n                                        v8::Local<v8::Value> frame,\n                                        const std::string& channel,\n                                        v8::Local<v8::Value> args) {\n  v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n  blink::CloneableMessage message;\n  if (!gin::ConvertFromV8(isolate, args, &message)) {\n    isolate->ThrowException(v8::Exception::Error(\n        gin::StringToV8(isolate, \"Failed to serialize arguments\")));\n    return false;\n  }\n  int32_t frame_id;\n  int32_t process_id;\n  if (gin::ConvertFromV8(isolate, frame, &frame_id)) {\n    process_id = web_contents()->GetMainFrame()->GetProcess()->GetID();\n  } else {\n    std::vector<int32_t> id_pair;\n    if (gin::ConvertFromV8(isolate, frame, &id_pair) && id_pair.size() == 2) {\n      process_id = id_pair[0];\n      frame_id = id_pair[1];\n    } else {\n      isolate->ThrowException(v8::Exception::Error(gin::StringToV8(\n          isolate,\n          \"frameId must be a number or a pair of [processId, frameId]\")));\n      return false;\n    }\n  }\n\n  auto* rfh = content::RenderFrameHost::FromID(process_id, frame_id);\n  if (!rfh || !rfh->IsRenderFrameLive() ||\n      content::WebContents::FromRenderFrameHost(rfh) != web_contents())\n    return false;\n\n  mojo::AssociatedRemote<mojom::ElectronRenderer> electron_renderer;\n  rfh->GetRemoteAssociatedInterfaces()->GetInterface(&electron_renderer);\n  electron_renderer->Message(internal, channel, std::move(message),\n                             0 /* sender_id */);\n  return true;\n}\n\nvoid WebContents::SendInputEvent(v8::Isolate* isolate,\n                                 v8::Local<v8::Value> input_event) {\n  content::RenderWidgetHostView* view =\n      web_contents()->GetRenderWidgetHostView();\n  if (!view)\n    return;\n\n  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();\n  blink::WebInputEvent::Type type =\n      gin::GetWebInputEventType(isolate, input_event);\n  if (blink::WebInputEvent::IsMouseEventType(type)) {\n    blink::WebMouseEvent mouse_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseEvent(mouse_event);\n#endif\n      } else {\n        rwh->ForwardMouseEvent(mouse_event);\n      }\n      return;\n    }\n  } else if (blink::WebInputEvent::IsKeyboardEventType(type)) {\n    content::NativeWebKeyboardEvent keyboard_event(\n        blink::WebKeyboardEvent::Type::kRawKeyDown,\n        blink::WebInputEvent::Modifiers::kNoModifiers, ui::EventTimeForNow());\n    if (gin::ConvertFromV8(isolate, input_event, &keyboard_event)) {\n      rwh->ForwardKeyboardEvent(keyboard_event);\n      return;\n    }\n  } else if (type == blink::WebInputEvent::Type::kMouseWheel) {\n    blink::WebMouseWheelEvent mouse_wheel_event;\n    if (gin::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {\n      if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n        GetOffScreenRenderWidgetHostView()->SendMouseWheelEvent(\n            mouse_wheel_event);\n#endif\n      } else {\n        // Chromium expects phase info in wheel events (and applies a\n        // DCHECK to verify it). See: https://crbug.com/756524.\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseBegan;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n\n        // Send a synthetic wheel event with phaseEnded to finish scrolling.\n        mouse_wheel_event.has_synthetic_phase = true;\n        mouse_wheel_event.delta_x = 0;\n        mouse_wheel_event.delta_y = 0;\n        mouse_wheel_event.phase = blink::WebMouseWheelEvent::kPhaseEnded;\n        mouse_wheel_event.dispatch_type =\n            blink::WebInputEvent::DispatchType::kEventNonBlocking;\n        rwh->ForwardWheelEvent(mouse_wheel_event);\n      }\n      return;\n    }\n  }\n\n  isolate->ThrowException(\n      v8::Exception::Error(gin::StringToV8(isolate, \"Invalid event object\")));\n}\n\nvoid WebContents::BeginFrameSubscription(gin::Arguments* args) {\n  bool only_dirty = false;\n  FrameSubscriber::FrameCaptureCallback callback;\n\n  if (args->Length() > 1) {\n    if (!args->GetNext(&only_dirty)) {\n      args->ThrowError();\n      return;\n    }\n  }\n  if (!args->GetNext(&callback)) {\n    args->ThrowError();\n    return;\n  }\n\n  frame_subscriber_ =\n      std::make_unique<FrameSubscriber>(web_contents(), callback, only_dirty);\n}\n\nvoid WebContents::EndFrameSubscription() {\n  frame_subscriber_.reset();\n}\n\nvoid WebContents::StartDrag(const gin_helper::Dictionary& item,\n                            gin::Arguments* args) {\n  base::FilePath file;\n  std::vector<base::FilePath> files;\n  if (!item.Get(\"files\", &files) && item.Get(\"file\", &file)) {\n    files.push_back(file);\n  }\n\n  gin::Handle<NativeImage> icon;\n  if (!item.Get(\"icon\", &icon) || icon->image().IsEmpty()) {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"Must specify non-empty 'icon' option\");\n    return;\n  }\n\n  // Start dragging.\n  if (!files.empty()) {\n    base::CurrentThread::ScopedNestableTaskAllower allow;\n    DragFileItems(files, icon->image(), web_contents()->GetNativeView());\n  } else {\n    gin_helper::ErrorThrower(args->isolate())\n        .ThrowError(\"Must specify either 'file' or 'files' option\");\n  }\n}\n\nv8::Local<v8::Promise> WebContents::CapturePage(gin::Arguments* args) {\n  gfx::Rect rect;\n  gin_helper::Promise<gfx::Image> promise(args->isolate());\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  // get rect arguments if they exist\n  args->GetNext(&rect);\n\n  auto* const view = web_contents()->GetRenderWidgetHostView();\n  if (!view) {\n    promise.Resolve(gfx::Image());\n    return handle;\n  }\n\n  // Capture full page if user doesn't specify a |rect|.\n  const gfx::Size view_size =\n      rect.IsEmpty() ? view->GetViewBounds().size() : rect.size();\n\n  // By default, the requested bitmap size is the view size in screen\n  // coordinates.  However, if there's more pixel detail available on the\n  // current system, increase the requested bitmap size to capture it all.\n  gfx::Size bitmap_size = view_size;\n  const gfx::NativeView native_view = view->GetNativeView();\n  const float scale = display::Screen::GetScreen()\n                          ->GetDisplayNearestView(native_view)\n                          .device_scale_factor();\n  if (scale > 1.0f)\n    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);\n\n  view->CopyFromSurface(gfx::Rect(rect.origin(), view_size), bitmap_size,\n                        base::BindOnce(&OnCapturePageDone, std::move(promise)));\n  return handle;\n}\n\nvoid WebContents::IncrementCapturerCount(gin::Arguments* args) {\n  gfx::Size size;\n  bool stay_hidden = false;\n\n  // get size arguments if they exist\n  args->GetNext(&size);\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->IncrementCapturerCount(size, stay_hidden);\n}\n\nvoid WebContents::DecrementCapturerCount(gin::Arguments* args) {\n  bool stay_hidden = false;\n\n  // get stayHidden arguments if they exist\n  args->GetNext(&stay_hidden);\n\n  web_contents()->DecrementCapturerCount(stay_hidden);\n}\n\nbool WebContents::IsBeingCaptured() {\n  return web_contents()->IsBeingCaptured();\n}\n\nvoid WebContents::OnCursorChanged(const content::WebCursor& webcursor) {\n  const ui::Cursor& cursor = webcursor.cursor();\n\n  if (cursor.type() == ui::mojom::CursorType::kCustom) {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor),\n         gfx::Image::CreateFrom1xBitmap(cursor.custom_bitmap()),\n         cursor.image_scale_factor(),\n         gfx::Size(cursor.custom_bitmap().width(),\n                   cursor.custom_bitmap().height()),\n         cursor.custom_hotspot());\n  } else {\n    Emit(\"cursor-changed\", CursorTypeToString(cursor));\n  }\n}\n\nbool WebContents::IsGuest() const {\n  return type_ == Type::kWebView;\n}\n\nvoid WebContents::AttachToIframe(content::WebContents* embedder_web_contents,\n                                 int embedder_frame_id) {\n  if (guest_delegate_)\n    guest_delegate_->AttachToIframe(embedder_web_contents, embedder_frame_id);\n}\n\nbool WebContents::IsOffScreen() const {\n#if BUILDFLAG(ENABLE_OSR)\n  return type_ == Type::kOffScreen;\n#else\n  return false;\n#endif\n}\n\n#if BUILDFLAG(ENABLE_OSR)\nvoid WebContents::OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap) {\n  Emit(\"paint\", dirty_rect, gfx::Image::CreateFrom1xBitmap(bitmap));\n}\n\nvoid WebContents::StartPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(true);\n}\n\nvoid WebContents::StopPainting() {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetPainting(false);\n}\n\nbool WebContents::IsPainting() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv && osr_wcv->IsPainting();\n}\n\nvoid WebContents::SetFrameRate(int frame_rate) {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  if (osr_wcv)\n    osr_wcv->SetFrameRate(frame_rate);\n}\n\nint WebContents::GetFrameRate() const {\n  auto* osr_wcv = GetOffScreenWebContentsView();\n  return osr_wcv ? osr_wcv->GetFrameRate() : 0;\n}\n#endif\n\nvoid WebContents::Invalidate() {\n  if (IsOffScreen()) {\n#if BUILDFLAG(ENABLE_OSR)\n    auto* osr_rwhv = GetOffScreenRenderWidgetHostView();\n    if (osr_rwhv)\n      osr_rwhv->Invalidate();\n#endif\n  } else {\n    auto* const window = owner_window();\n    if (window)\n      window->Invalidate();\n  }\n}\n\ngfx::Size WebContents::GetSizeForNewRenderView(content::WebContents* wc) {\n  if (IsOffScreen() && wc == web_contents()) {\n    auto* relay = NativeWindowRelay::FromWebContents(web_contents());\n    if (relay) {\n      auto* owner_window = relay->GetNativeWindow();\n      return owner_window ? owner_window->GetSize() : gfx::Size();\n    }\n  }\n\n  return gfx::Size();\n}\n\nvoid WebContents::SetZoomLevel(double level) {\n  zoom_controller_->SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomLevel() const {\n  return zoom_controller_->GetZoomLevel();\n}\n\nvoid WebContents::SetZoomFactor(gin_helper::ErrorThrower thrower,\n                                double factor) {\n  if (factor < std::numeric_limits<double>::epsilon()) {\n    thrower.ThrowError(\"'zoomFactor' must be a double greater than 0.0\");\n    return;\n  }\n\n  auto level = blink::PageZoomFactorToZoomLevel(factor);\n  SetZoomLevel(level);\n}\n\ndouble WebContents::GetZoomFactor() const {\n  auto level = GetZoomLevel();\n  return blink::PageZoomLevelToZoomFactor(level);\n}\n\nvoid WebContents::SetTemporaryZoomLevel(double level) {\n  zoom_controller_->SetTemporaryZoomLevel(level);\n}\n\nvoid WebContents::DoGetZoomLevel(DoGetZoomLevelCallback callback) {\n  std::move(callback).Run(GetZoomLevel());\n}\n\nstd::vector<base::FilePath> WebContents::GetPreloadPaths() const {\n  auto result = SessionPreferences::GetValidPreloads(GetBrowserContext());\n\n  if (auto* web_preferences = WebContentsPreferences::From(web_contents())) {\n    base::FilePath preload;\n    if (web_preferences->GetPreloadPath(&preload)) {\n      result.emplace_back(preload);\n    }\n  }\n\n  return result;\n}\n\nv8::Local<v8::Value> WebContents::GetWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->preference());\n}\n\nv8::Local<v8::Value> WebContents::GetLastWebPreferences(\n    v8::Isolate* isolate) const {\n  auto* web_preferences = WebContentsPreferences::From(web_contents());\n  if (!web_preferences)\n    return v8::Null(isolate);\n  return gin::ConvertToV8(isolate, *web_preferences->last_preference());\n}\n\nv8::Local<v8::Value> WebContents::GetOwnerBrowserWindow(\n    v8::Isolate* isolate) const {\n  if (owner_window())\n    return BrowserWindow::From(isolate, owner_window());\n  else\n    return v8::Null(isolate);\n}\n\nv8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {\n  return v8::Local<v8::Value>::New(isolate, session_);\n}\n\ncontent::WebContents* WebContents::HostWebContents() const {\n  if (!embedder_)\n    return nullptr;\n  return embedder_->web_contents();\n}\n\nvoid WebContents::SetEmbedder(const WebContents* embedder) {\n  if (embedder) {\n    NativeWindow* owner_window = nullptr;\n    auto* relay = NativeWindowRelay::FromWebContents(embedder->web_contents());\n    if (relay) {\n      owner_window = relay->GetNativeWindow();\n    }\n    if (owner_window)\n      SetOwnerWindow(owner_window);\n\n    content::RenderWidgetHostView* rwhv =\n        web_contents()->GetRenderWidgetHostView();\n    if (rwhv) {\n      rwhv->Hide();\n      rwhv->Show();\n    }\n  }\n}\n\nvoid WebContents::SetDevToolsWebContents(const WebContents* devtools) {\n  if (inspectable_web_contents_)\n    inspectable_web_contents_->SetDevToolsWebContents(devtools->web_contents());\n}\n\nv8::Local<v8::Value> WebContents::GetNativeView(v8::Isolate* isolate) const {\n  gfx::NativeView ptr = web_contents()->GetNativeView();\n  auto buffer = node::Buffer::Copy(isolate, reinterpret_cast<char*>(&ptr),\n                                   sizeof(gfx::NativeView));\n  if (buffer.IsEmpty())\n    return v8::Null(isolate);\n  else\n    return buffer.ToLocalChecked();\n}\n\nv8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {\n  if (devtools_web_contents_.IsEmpty())\n    return v8::Null(isolate);\n  else\n    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);\n}\n\nv8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {\n  if (debugger_.IsEmpty()) {\n    auto handle = electron::api::Debugger::Create(isolate, web_contents());\n    debugger_.Reset(isolate, handle.ToV8());\n  }\n  return v8::Local<v8::Value>::New(isolate, debugger_);\n}\n\nbool WebContents::WasInitiallyShown() {\n  return initially_shown_;\n}\n\ncontent::RenderFrameHost* WebContents::MainFrame() {\n  return web_contents()->GetMainFrame();\n}\n\nvoid WebContents::GrantOriginAccess(const GURL& url) {\n  content::ChildProcessSecurityPolicy::GetInstance()->GrantCommitOrigin(\n      web_contents()->GetMainFrame()->GetProcess()->GetID(),\n      url::Origin::Create(url));\n}\n\nvoid WebContents::NotifyUserActivation() {\n  auto* frame = web_contents()->GetMainFrame();\n  if (!frame)\n    return;\n  mojo::AssociatedRemote<mojom::ElectronRenderer> renderer;\n  frame->GetRemoteAssociatedInterfaces()->GetInterface(&renderer);\n  renderer->NotifyUserActivation();\n}\n\nv8::Local<v8::Promise> WebContents::TakeHeapSnapshot(\n    v8::Isolate* isolate,\n    const base::FilePath& file_path) {\n  gin_helper::Promise<void> promise(isolate);\n  v8::Local<v8::Promise> handle = promise.GetHandle();\n\n  base::ThreadRestrictions::ScopedAllowIO allow_io;\n  base::File file(file_path,\n                  base::File::FLAG_CREATE_ALWAYS | base::File::FLAG_WRITE);\n  if (!file.IsValid()) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  auto* frame_host = web_contents()->GetMainFrame();\n  if (!frame_host) {\n    promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n    return handle;\n  }\n\n  // This dance with `base::Owned` is to ensure that the interface stays alive\n  // until the callback is called. Otherwise it would be closed at the end of\n  // this function.\n  auto electron_renderer =\n      std::make_unique<mojo::AssociatedRemote<mojom::ElectronRenderer>>();\n  frame_host->GetRemoteAssociatedInterfaces()->GetInterface(\n      electron_renderer.get());\n  auto* raw_ptr = electron_renderer.get();\n  (*raw_ptr)->TakeHeapSnapshot(\n      mojo::WrapPlatformFile(base::ScopedPlatformFile(file.TakePlatformFile())),\n      base::BindOnce(\n          [](mojo::AssociatedRemote<mojom::ElectronRenderer>* ep,\n             gin_helper::Promise<void> promise, bool success) {\n            if (success) {\n              promise.Resolve();\n            } else {\n              promise.RejectWithErrorMessage(\"takeHeapSnapshot failed\");\n            }\n          },\n          base::Owned(std::move(electron_renderer)), std::move(promise)));\n  return handle;\n}\n\nvoid WebContents::UpdatePreferredSize(content::WebContents* web_contents,\n                                      const gfx::Size& pref_size) {\n  Emit(\"preferred-size-changed\", pref_size);\n}\n\nbool WebContents::CanOverscrollContent() {\n  return false;\n}\n\ncontent::ColorChooser* WebContents::OpenColorChooser(\n    content::WebContents* web_contents,\n    SkColor color,\n    const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions) {\n#if BUILDFLAG(ENABLE_COLOR_CHOOSER)\n  return chrome::ShowColorChooser(web_contents, color);\n#else\n  return nullptr;\n#endif\n}\n\nvoid WebContents::RunFileChooser(\n    content::RenderFrameHost* render_frame_host,\n    scoped_refptr<content::FileSelectListener> listener,\n    const blink::mojom::FileChooserParams& params) {\n  if (!web_dialog_helper_)\n    web_dialog_helper_ =\n        std::make_unique<WebDialogHelper>(owner_window(), offscreen_);\n  web_dialog_helper_->RunFileChooser(render_frame_host, std::move(listener),\n                                     params);\n}\n\nvoid WebContents::EnumerateDirectory(\n    content::WebContents* guest,\n    scoped_refptr<content::FileSelectListener> listener,\n    const base::FilePath& path) {\n  if (!web_dialog_helper_)\n    web_dialog_helper_ =\n        std::make_unique<WebDialogHelper>(owner_window(), offscreen_);\n  web_dialog_helper_->EnumerateDirectory(guest, std::move(listener), path);\n}\n\nbool WebContents::IsFullscreenForTabOrPending(\n    const content::WebContents* source) {\n  return html_fullscreen_;\n}\n\nblink::SecurityStyle WebContents::GetSecurityStyle(\n    content::WebContents* web_contents,\n    content::SecurityStyleExplanations* security_style_explanations) {\n  SecurityStateTabHelper* helper =\n      SecurityStateTabHelper::FromWebContents(web_contents);\n  DCHECK(helper);\n  return security_state::GetSecurityStyle(helper->GetSecurityLevel(),\n                                          *helper->GetVisibleSecurityState(),\n                                          security_style_explanations);\n}\n\nbool WebContents::TakeFocus(content::WebContents* source, bool reverse) {\n  if (source && source->GetOutermostWebContents() == source) {\n    // If this is the outermost web contents and the user has tabbed or\n    // shift + tabbed through all the elements, reset the focus back to\n    // the first or last element so that it doesn't stay in the body.\n    source->FocusThroughTabTraversal(reverse);\n    return true;\n  }\n\n  return false;\n}\n\ncontent::PictureInPictureResult WebContents::EnterPictureInPicture(\n    content::WebContents* web_contents,\n    const viz::SurfaceId& surface_id,\n    const gfx::Size& natural_size) {\n#if BUILDFLAG(ENABLE_PICTURE_IN_PICTURE)\n  return PictureInPictureWindowManager::GetInstance()->EnterPictureInPicture(\n      web_contents, surface_id, natural_size);\n#else\n  return content::PictureInPictureResult::kNotSupported;\n#endif\n}\n\nvoid WebContents::ExitPictureInPicture() {\n#if BUILDFLAG(ENABLE_PICTURE_IN_PICTURE)\n  PictureInPictureWindowManager::GetInstance()->ExitPictureInPicture();\n#endif\n}\n\nvoid WebContents::DevToolsSaveToFile(const std::string& url,\n                                     const std::string& content,\n                                     bool save_as) {\n  base::FilePath path;\n  auto it = saved_files_.find(url);\n  if (it != saved_files_.end() && !save_as) {\n    path = it->second;\n  } else {\n    file_dialog::DialogSettings settings;\n    settings.parent_window = owner_window();\n    settings.force_detached = offscreen_;\n    settings.title = url;\n    settings.default_path = base::FilePath::FromUTF8Unsafe(url);\n    if (!file_dialog::ShowSaveDialogSync(settings, &path)) {\n      base::Value url_value(url);\n      inspectable_web_contents_->CallClientFunction(\n          \"DevToolsAPI.canceledSaveURL\", &url_value, nullptr, nullptr);\n      return;\n    }\n  }\n\n  saved_files_[url] = path;\n  // Notify DevTools.\n  base::Value url_value(url);\n  base::Value file_system_path_value(path.AsUTF8Unsafe());\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.savedURL\", &url_value, &file_system_path_value, nullptr);\n  file_task_runner_->PostTask(FROM_HERE,\n                              base::BindOnce(&WriteToFile, path, content));\n}\n\nvoid WebContents::DevToolsAppendToFile(const std::string& url,\n                                       const std::string& content) {\n  auto it = saved_files_.find(url);\n  if (it == saved_files_.end())\n    return;\n\n  // Notify DevTools.\n  base::Value url_value(url);\n  inspectable_web_contents_->CallClientFunction(\"DevToolsAPI.appendedToURL\",\n                                                &url_value, nullptr, nullptr);\n  file_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&AppendToFile, it->second, content));\n}\n\nvoid WebContents::DevToolsRequestFileSystems() {\n  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());\n  if (file_system_paths.empty()) {\n    base::ListValue empty_file_system_value;\n    inspectable_web_contents_->CallClientFunction(\n        \"DevToolsAPI.fileSystemsLoaded\", &empty_file_system_value, nullptr,\n        nullptr);\n    return;\n  }\n\n  std::vector<FileSystem> file_systems;\n  for (const auto& file_system_path : file_system_paths) {\n    base::FilePath path =\n        base::FilePath::FromUTF8Unsafe(file_system_path.first);\n    std::string file_system_id =\n        RegisterFileSystem(GetDevToolsWebContents(), path);\n    FileSystem file_system =\n        CreateFileSystemStruct(GetDevToolsWebContents(), file_system_id,\n                               file_system_path.first, file_system_path.second);\n    file_systems.push_back(file_system);\n  }\n\n  base::ListValue file_system_value;\n  for (const auto& file_system : file_systems)\n    file_system_value.Append(CreateFileSystemValue(file_system));\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.fileSystemsLoaded\", &file_system_value, nullptr, nullptr);\n}\n\nvoid WebContents::DevToolsAddFileSystem(\n    const std::string& type,\n    const base::FilePath& file_system_path) {\n  base::FilePath path = file_system_path;\n  if (path.empty()) {\n    std::vector<base::FilePath> paths;\n    file_dialog::DialogSettings settings;\n    settings.parent_window = owner_window();\n    settings.force_detached = offscreen_;\n    settings.properties = file_dialog::OPEN_DIALOG_OPEN_DIRECTORY;\n    if (!file_dialog::ShowOpenDialogSync(settings, &paths))\n      return;\n\n    path = paths[0];\n  }\n\n  std::string file_system_id =\n      RegisterFileSystem(GetDevToolsWebContents(), path);\n  if (IsDevToolsFileSystemAdded(GetDevToolsWebContents(), path.AsUTF8Unsafe()))\n    return;\n\n  FileSystem file_system = CreateFileSystemStruct(\n      GetDevToolsWebContents(), file_system_id, path.AsUTF8Unsafe(), type);\n  std::unique_ptr<base::DictionaryValue> file_system_value(\n      CreateFileSystemValue(file_system));\n\n  auto* pref_service = GetPrefService(GetDevToolsWebContents());\n  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);\n  update.Get()->SetWithoutPathExpansion(path.AsUTF8Unsafe(),\n                                        std::make_unique<base::Value>(type));\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.fileSystemAdded\", nullptr, file_system_value.get(), nullptr);\n}\n\nvoid WebContents::DevToolsRemoveFileSystem(\n    const base::FilePath& file_system_path) {\n  if (!inspectable_web_contents_)\n    return;\n\n  std::string path = file_system_path.AsUTF8Unsafe();\n  storage::IsolatedContext::GetInstance()->RevokeFileSystemByPath(\n      file_system_path);\n\n  auto* pref_service = GetPrefService(GetDevToolsWebContents());\n  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);\n  update.Get()->RemoveWithoutPathExpansion(path, nullptr);\n\n  base::Value file_system_path_value(path);\n  inspectable_web_contents_->CallClientFunction(\"DevToolsAPI.fileSystemRemoved\",\n                                                &file_system_path_value,\n                                                nullptr, nullptr);\n}\n\nvoid WebContents::DevToolsIndexPath(\n    int request_id,\n    const std::string& file_system_path,\n    const std::string& excluded_folders_message) {\n  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {\n    OnDevToolsIndexingDone(request_id, file_system_path);\n    return;\n  }\n  if (devtools_indexing_jobs_.count(request_id) != 0)\n    return;\n  std::vector<std::string> excluded_folders;\n  std::unique_ptr<base::Value> parsed_excluded_folders =\n      base::JSONReader::ReadDeprecated(excluded_folders_message);\n  if (parsed_excluded_folders && parsed_excluded_folders->is_list()) {\n    for (const base::Value& folder_path : parsed_excluded_folders->GetList()) {\n      if (folder_path.is_string())\n        excluded_folders.push_back(folder_path.GetString());\n    }\n  }\n  devtools_indexing_jobs_[request_id] =\n      scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>(\n          devtools_file_system_indexer_->IndexPath(\n              file_system_path, excluded_folders,\n              base::BindRepeating(\n                  &WebContents::OnDevToolsIndexingWorkCalculated,\n                  weak_factory_.GetWeakPtr(), request_id, file_system_path),\n              base::BindRepeating(&WebContents::OnDevToolsIndexingWorked,\n                                  weak_factory_.GetWeakPtr(), request_id,\n                                  file_system_path),\n              base::BindRepeating(&WebContents::OnDevToolsIndexingDone,\n                                  weak_factory_.GetWeakPtr(), request_id,\n                                  file_system_path)));\n}\n\nvoid WebContents::DevToolsStopIndexing(int request_id) {\n  auto it = devtools_indexing_jobs_.find(request_id);\n  if (it == devtools_indexing_jobs_.end())\n    return;\n  it->second->Stop();\n  devtools_indexing_jobs_.erase(it);\n}\n\nvoid WebContents::DevToolsSearchInPath(int request_id,\n                                       const std::string& file_system_path,\n                                       const std::string& query) {\n  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {\n    OnDevToolsSearchCompleted(request_id, file_system_path,\n                              std::vector<std::string>());\n    return;\n  }\n  devtools_file_system_indexer_->SearchInPath(\n      file_system_path, query,\n      base::BindRepeating(&WebContents::OnDevToolsSearchCompleted,\n                          weak_factory_.GetWeakPtr(), request_id,\n                          file_system_path));\n}\n\n#if defined(TOOLKIT_VIEWS) && !defined(OS_MAC)\ngfx::ImageSkia WebContents::GetDevToolsWindowIcon() {\n  if (!owner_window())\n    return gfx::ImageSkia();\n  return owner_window()->GetWindowAppIcon();\n}\n#endif\n\n#if defined(OS_LINUX)\nvoid WebContents::GetDevToolsWindowWMClass(std::string* name,\n                                           std::string* class_name) {\n  *class_name = Browser::Get()->GetName();\n  *name = base::ToLowerASCII(*class_name);\n}\n#endif\n\nvoid WebContents::OnDevToolsIndexingWorkCalculated(\n    int request_id,\n    const std::string& file_system_path,\n    int total_work) {\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  base::Value total_work_value(total_work);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.indexingTotalWorkCalculated\", &request_id_value,\n      &file_system_path_value, &total_work_value);\n}\n\nvoid WebContents::OnDevToolsIndexingWorked(int request_id,\n                                           const std::string& file_system_path,\n                                           int worked) {\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  base::Value worked_value(worked);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.indexingWorked\", &request_id_value, &file_system_path_value,\n      &worked_value);\n}\n\nvoid WebContents::OnDevToolsIndexingDone(int request_id,\n                                         const std::string& file_system_path) {\n  devtools_indexing_jobs_.erase(request_id);\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.indexingDone\", &request_id_value, &file_system_path_value,\n      nullptr);\n}\n\nvoid WebContents::OnDevToolsSearchCompleted(\n    int request_id,\n    const std::string& file_system_path,\n    const std::vector<std::string>& file_paths) {\n  base::ListValue file_paths_value;\n  for (const auto& file_path : file_paths) {\n    file_paths_value.AppendString(file_path);\n  }\n  base::Value request_id_value(request_id);\n  base::Value file_system_path_value(file_system_path);\n  inspectable_web_contents_->CallClientFunction(\n      \"DevToolsAPI.searchCompleted\", &request_id_value, &file_system_path_value,\n      &file_paths_value);\n}\n\nvoid WebContents::SetHtmlApiFullscreen(bool enter_fullscreen) {\n  // Window is already in fullscreen mode, save the state.\n  if (enter_fullscreen && owner_window_->IsFullscreen()) {\n    native_fullscreen_ = true;\n    html_fullscreen_ = true;\n    return;\n  }\n\n  // Exit html fullscreen state but not window's fullscreen mode.\n  if (!enter_fullscreen && native_fullscreen_) {\n    html_fullscreen_ = false;\n    return;\n  }\n\n  // Set fullscreen on window if allowed.\n  auto* web_preferences = WebContentsPreferences::From(GetWebContents());\n  bool html_fullscreenable =\n      web_preferences ? !web_preferences->IsEnabled(\n                            options::kDisableHtmlFullscreenWindowResize)\n                      : true;\n\n  if (html_fullscreenable) {\n    owner_window_->SetFullScreen(enter_fullscreen);\n  }\n\n  html_fullscreen_ = enter_fullscreen;\n  native_fullscreen_ = false;\n}\n\n// static\nv8::Local<v8::ObjectTemplate> WebContents::FillObjectTemplate(\n    v8::Isolate* isolate,\n    v8::Local<v8::ObjectTemplate> templ) {\n  gin::InvokerOptions options;\n  options.holder_is_first_argument = true;\n  options.holder_type = \"WebContents\";\n  templ->Set(\n      gin::StringToSymbol(isolate, \"isDestroyed\"),\n      gin::CreateFunctionTemplate(\n          isolate, base::BindRepeating(&gin_helper::Destroyable::IsDestroyed),\n          options));\n  templ->Set(\n      gin::StringToSymbol(isolate, \"destroy\"),\n      gin::CreateFunctionTemplate(\n          isolate, base::BindRepeating([](gin::Handle<WebContents> handle) {\n            delete handle.get();\n          }),\n          options));\n  // We use gin_helper::ObjectTemplateBuilder instead of\n  // gin::ObjectTemplateBuilder here to handle the fact that WebContents is\n  // destroyable.\n  return gin_helper::ObjectTemplateBuilder(isolate, templ)\n      .SetMethod(\"getBackgroundThrottling\",\n                 &WebContents::GetBackgroundThrottling)\n      .SetMethod(\"setBackgroundThrottling\",\n                 &WebContents::SetBackgroundThrottling)\n      .SetMethod(\"getProcessId\", &WebContents::GetProcessID)\n      .SetMethod(\"getOSProcessId\", &WebContents::GetOSProcessID)\n      .SetMethod(\"equal\", &WebContents::Equal)\n      .SetMethod(\"_loadURL\", &WebContents::LoadURL)\n      .SetMethod(\"downloadURL\", &WebContents::DownloadURL)\n      .SetMethod(\"_getURL\", &WebContents::GetURL)\n      .SetMethod(\"getTitle\", &WebContents::GetTitle)\n      .SetMethod(\"isLoading\", &WebContents::IsLoading)\n      .SetMethod(\"isLoadingMainFrame\", &WebContents::IsLoadingMainFrame)\n      .SetMethod(\"isWaitingForResponse\", &WebContents::IsWaitingForResponse)\n      .SetMethod(\"_stop\", &WebContents::Stop)\n      .SetMethod(\"_goBack\", &WebContents::GoBack)\n      .SetMethod(\"_goForward\", &WebContents::GoForward)\n      .SetMethod(\"_goToOffset\", &WebContents::GoToOffset)\n      .SetMethod(\"isCrashed\", &WebContents::IsCrashed)\n      .SetMethod(\"forcefullyCrashRenderer\",\n                 &WebContents::ForcefullyCrashRenderer)\n      .SetMethod(\"setUserAgent\", &WebContents::SetUserAgent)\n      .SetMethod(\"getUserAgent\", &WebContents::GetUserAgent)\n      .SetMethod(\"savePage\", &WebContents::SavePage)\n      .SetMethod(\"openDevTools\", &WebContents::OpenDevTools)\n      .SetMethod(\"closeDevTools\", &WebContents::CloseDevTools)\n      .SetMethod(\"isDevToolsOpened\", &WebContents::IsDevToolsOpened)\n      .SetMethod(\"isDevToolsFocused\", &WebContents::IsDevToolsFocused)\n      .SetMethod(\"enableDeviceEmulation\", &WebContents::EnableDeviceEmulation)\n      .SetMethod(\"disableDeviceEmulation\", &WebContents::DisableDeviceEmulation)\n      .SetMethod(\"toggleDevTools\", &WebContents::ToggleDevTools)\n      .SetMethod(\"inspectElement\", &WebContents::InspectElement)\n      .SetMethod(\"setIgnoreMenuShortcuts\", &WebContents::SetIgnoreMenuShortcuts)\n      .SetMethod(\"setAudioMuted\", &WebContents::SetAudioMuted)\n      .SetMethod(\"isAudioMuted\", &WebContents::IsAudioMuted)\n      .SetMethod(\"isCurrentlyAudible\", &WebContents::IsCurrentlyAudible)\n      .SetMethod(\"undo\", &WebContents::Undo)\n      .SetMethod(\"redo\", &WebContents::Redo)\n      .SetMethod(\"cut\", &WebContents::Cut)\n      .SetMethod(\"copy\", &WebContents::Copy)\n      .SetMethod(\"paste\", &WebContents::Paste)\n      .SetMethod(\"pasteAndMatchStyle\", &WebContents::PasteAndMatchStyle)\n      .SetMethod(\"delete\", &WebContents::Delete)\n      .SetMethod(\"selectAll\", &WebContents::SelectAll)\n      .SetMethod(\"unselect\", &WebContents::Unselect)\n      .SetMethod(\"replace\", &WebContents::Replace)\n      .SetMethod(\"replaceMisspelling\", &WebContents::ReplaceMisspelling)\n      .SetMethod(\"findInPage\", &WebContents::FindInPage)\n      .SetMethod(\"stopFindInPage\", &WebContents::StopFindInPage)\n      .SetMethod(\"focus\", &WebContents::Focus)\n      .SetMethod(\"isFocused\", &WebContents::IsFocused)\n      .SetMethod(\"_send\", &WebContents::SendIPCMessage)\n      .SetMethod(\"_postMessage\", &WebContents::PostMessage)\n      .SetMethod(\"_sendToFrame\", &WebContents::SendIPCMessageToFrame)\n      .SetMethod(\"sendInputEvent\", &WebContents::SendInputEvent)\n      .SetMethod(\"beginFrameSubscription\", &WebContents::BeginFrameSubscription)\n      .SetMethod(\"endFrameSubscription\", &WebContents::EndFrameSubscription)\n      .SetMethod(\"startDrag\", &WebContents::StartDrag)\n      .SetMethod(\"attachToIframe\", &WebContents::AttachToIframe)\n      .SetMethod(\"detachFromOuterFrame\", &WebContents::DetachFromOuterFrame)\n      .SetMethod(\"isOffscreen\", &WebContents::IsOffScreen)\n#if BUILDFLAG(ENABLE_OSR)\n      .SetMethod(\"startPainting\", &WebContents::StartPainting)\n      .SetMethod(\"stopPainting\", &WebContents::StopPainting)\n      .SetMethod(\"isPainting\", &WebContents::IsPainting)\n      .SetMethod(\"setFrameRate\", &WebContents::SetFrameRate)\n      .SetMethod(\"getFrameRate\", &WebContents::GetFrameRate)\n#endif\n      .SetMethod(\"invalidate\", &WebContents::Invalidate)\n      .SetMethod(\"setZoomLevel\", &WebContents::SetZoomLevel)\n      .SetMethod(\"getZoomLevel\", &WebContents::GetZoomLevel)\n      .SetMethod(\"setZoomFactor\", &WebContents::SetZoomFactor)\n      .SetMethod(\"getZoomFactor\", &WebContents::GetZoomFactor)\n      .SetMethod(\"getType\", &WebContents::GetType)\n      .SetMethod(\"_getPreloadPaths\", &WebContents::GetPreloadPaths)\n      .SetMethod(\"getWebPreferences\", &WebContents::GetWebPreferences)\n      .SetMethod(\"getLastWebPreferences\", &WebContents::GetLastWebPreferences)\n      .SetMethod(\"getOwnerBrowserWindow\", &WebContents::GetOwnerBrowserWindow)\n      .SetMethod(\"inspectServiceWorker\", &WebContents::InspectServiceWorker)\n      .SetMethod(\"inspectSharedWorker\", &WebContents::InspectSharedWorker)\n      .SetMethod(\"inspectSharedWorkerById\",\n                 &WebContents::InspectSharedWorkerById)\n      .SetMethod(\"getAllSharedWorkers\", &WebContents::GetAllSharedWorkers)\n#if BUILDFLAG(ENABLE_PRINTING)\n      .SetMethod(\"_print\", &WebContents::Print)\n      .SetMethod(\"_printToPDF\", &WebContents::PrintToPDF)\n#endif\n      .SetMethod(\"_setNextChildWebPreferences\",\n                 &WebContents::SetNextChildWebPreferences)\n      .SetMethod(\"addWorkSpace\", &WebContents::AddWorkSpace)\n      .SetMethod(\"removeWorkSpace\", &WebContents::RemoveWorkSpace)\n      .SetMethod(\"showDefinitionForSelection\",\n                 &WebContents::ShowDefinitionForSelection)\n      .SetMethod(\"copyImageAt\", &WebContents::CopyImageAt)\n      .SetMethod(\"capturePage\", &WebContents::CapturePage)\n      .SetMethod(\"setEmbedder\", &WebContents::SetEmbedder)\n      .SetMethod(\"setDevToolsWebContents\", &WebContents::SetDevToolsWebContents)\n      .SetMethod(\"getNativeView\", &WebContents::GetNativeView)\n      .SetMethod(\"incrementCapturerCount\", &WebContents::IncrementCapturerCount)\n      .SetMethod(\"decrementCapturerCount\", &WebContents::DecrementCapturerCount)\n      .SetMethod(\"isBeingCaptured\", &WebContents::IsBeingCaptured)\n      .SetMethod(\"setWebRTCIPHandlingPolicy\",\n                 &WebContents::SetWebRTCIPHandlingPolicy)\n      .SetMethod(\"getWebRTCIPHandlingPolicy\",\n                 &WebContents::GetWebRTCIPHandlingPolicy)\n      .SetMethod(\"_grantOriginAccess\", &WebContents::GrantOriginAccess)\n      .SetMethod(\"takeHeapSnapshot\", &WebContents::TakeHeapSnapshot)\n      .SetProperty(\"id\", &WebContents::ID)\n      .SetProperty(\"session\", &WebContents::Session)\n      .SetProperty(\"hostWebContents\", &WebContents::HostWebContents)\n      .SetProperty(\"devToolsWebContents\", &WebContents::DevToolsWebContents)\n      .SetProperty(\"debugger\", &WebContents::Debugger)\n      .SetProperty(\"_initiallyShown\", &WebContents::WasInitiallyShown)\n      .SetProperty(\"mainFrame\", &WebContents::MainFrame)\n      .Build();\n}\n\nconst char* WebContents::GetTypeName() {\n  return \"WebContents\";\n}\n\nElectronBrowserContext* WebContents::GetBrowserContext() const {\n  return static_cast<ElectronBrowserContext*>(\n      web_contents()->GetBrowserContext());\n}\n\n// static\ngin::Handle<WebContents> WebContents::New(\n    v8::Isolate* isolate,\n    const gin_helper::Dictionary& options) {\n  gin::Handle<WebContents> handle =\n      gin::CreateHandle(isolate, new WebContents(isolate, options));\n  gin_helper::CallMethod(isolate, handle.get(), \"_init\");\n  return handle;\n}\n\n// static\ngin::Handle<WebContents> WebContents::CreateAndTake(\n    v8::Isolate* isolate,\n    std::unique_ptr<content::WebContents> web_contents,\n    Type type) {\n  gin::Handle<WebContents> handle = gin::CreateHandle(\n      isolate, new WebContents(isolate, std::move(web_contents), type));\n  gin_helper::CallMethod(isolate, handle.get(), \"_init\");\n  return handle;\n}\n\n// static\nWebContents* WebContents::From(content::WebContents* web_contents) {\n  if (!web_contents)\n    return nullptr;\n  auto* data = static_cast<UserDataLink*>(\n      web_contents->GetUserData(kElectronApiWebContentsKey));\n  return data ? data->web_contents.get() : nullptr;\n}\n\n// static\ngin::Handle<WebContents> WebContents::FromOrCreate(\n    v8::Isolate* isolate,\n    content::WebContents* web_contents) {\n  WebContents* api_web_contents = From(web_contents);\n  if (!api_web_contents) {\n    api_web_contents = new WebContents(isolate, web_contents);\n    gin_helper::CallMethod(isolate, api_web_contents, \"_init\");\n  }\n  return gin::CreateHandle(isolate, api_web_contents);\n}\n\n// static\nWebContents* WebContents::FromID(int32_t id) {\n  return GetAllWebContents().Lookup(id);\n}\n\n// static\ngin::WrapperInfo WebContents::kWrapperInfo = {gin::kEmbedderNativeGin};\n\n}  // namespace api\n\n}  // namespace electron\n\nnamespace {\n\nusing electron::api::GetAllWebContents;\nusing electron::api::WebContents;\n\ngin::Handle<WebContents> WebContentsFromID(v8::Isolate* isolate, int32_t id) {\n  WebContents* contents = WebContents::FromID(id);\n  return contents ? gin::CreateHandle(isolate, contents)\n                  : gin::Handle<WebContents>();\n}\n\nstd::vector<gin::Handle<WebContents>> GetAllWebContentsAsV8(\n    v8::Isolate* isolate) {\n  std::vector<gin::Handle<WebContents>> list;\n  for (auto iter = base::IDMap<WebContents*>::iterator(&GetAllWebContents());\n       !iter.IsAtEnd(); iter.Advance()) {\n    list.push_back(gin::CreateHandle(isolate, iter.GetCurrentValue()));\n  }\n  return list;\n}\n\nvoid Initialize(v8::Local<v8::Object> exports,\n                v8::Local<v8::Value> unused,\n                v8::Local<v8::Context> context,\n                void* priv) {\n  v8::Isolate* isolate = context->GetIsolate();\n  gin_helper::Dictionary dict(isolate, exports);\n  dict.Set(\"WebContents\", WebContents::GetConstructor(context));\n  dict.SetMethod(\"fromId\", &WebContentsFromID);\n  dict.SetMethod(\"getAllWebContents\", &GetAllWebContentsAsV8);\n}\n\n}  // namespace\n\nNODE_LINKED_MODULE_CONTEXT_AWARE(electron_browser_web_contents, Initialize)\n", "// Copyright (c) 2014 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#ifndef SHELL_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_\n#define SHELL_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_\n\n#include <map>\n#include <memory>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"base/memory/weak_ptr.h\"\n#include \"base/observer_list.h\"\n#include \"base/observer_list_types.h\"\n#include \"chrome/browser/devtools/devtools_file_system_indexer.h\"\n#include \"content/common/cursors/webcursor.h\"\n#include \"content/common/frame.mojom.h\"\n#include \"content/public/browser/devtools_agent_host.h\"\n#include \"content/public/browser/keyboard_event_processing_result.h\"\n#include \"content/public/browser/render_widget_host.h\"\n#include \"content/public/browser/web_contents.h\"\n#include \"content/public/browser/web_contents_delegate.h\"\n#include \"content/public/browser/web_contents_observer.h\"\n#include \"electron/buildflags/buildflags.h\"\n#include \"electron/shell/common/api/api.mojom.h\"\n#include \"gin/handle.h\"\n#include \"gin/wrappable.h\"\n#include \"mojo/public/cpp/bindings/receiver_set.h\"\n#include \"printing/buildflags/buildflags.h\"\n#include \"services/service_manager/public/cpp/binder_registry.h\"\n#include \"shell/browser/api/frame_subscriber.h\"\n#include \"shell/browser/api/save_page_handler.h\"\n#include \"shell/browser/event_emitter_mixin.h\"\n#include \"shell/browser/extended_web_contents_observer.h\"\n#include \"shell/browser/ui/inspectable_web_contents.h\"\n#include \"shell/browser/ui/inspectable_web_contents_delegate.h\"\n#include \"shell/browser/ui/inspectable_web_contents_view_delegate.h\"\n#include \"shell/common/gin_helper/cleaned_up_at_exit.h\"\n#include \"shell/common/gin_helper/constructible.h\"\n#include \"shell/common/gin_helper/error_thrower.h\"\n#include \"ui/gfx/image/image.h\"\n\n#if BUILDFLAG(ENABLE_PRINTING)\n#include \"chrome/browser/printing/print_view_manager_basic.h\"\n#include \"components/printing/common/print_messages.h\"\n#include \"shell/browser/printing/print_preview_message_handler.h\"\n#endif\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n#include \"extensions/common/view_type.h\"\n\nnamespace extensions {\nclass ScriptExecutor;\n}\n#endif\n\nnamespace blink {\nstruct DeviceEmulationParams;\n}\n\nnamespace gin_helper {\nclass Dictionary;\n}\n\nnamespace network {\nclass ResourceRequestBody;\n}\n\nnamespace gin {\nclass Arguments;\n}\n\nnamespace electron {\n\nclass ElectronBrowserContext;\nclass ElectronJavaScriptDialogManager;\nclass InspectableWebContents;\nclass WebContentsZoomController;\nclass WebViewGuestDelegate;\nclass FrameSubscriber;\nclass WebDialogHelper;\nclass NativeWindow;\n\n#if BUILDFLAG(ENABLE_OSR)\nclass OffScreenRenderWidgetHostView;\nclass OffScreenWebContentsView;\n#endif\n\nnamespace api {\n\n// Wrapper around the content::WebContents.\nclass WebContents : public gin::Wrappable<WebContents>,\n                    public gin_helper::EventEmitterMixin<WebContents>,\n                    public gin_helper::Constructible<WebContents>,\n                    public gin_helper::CleanedUpAtExit,\n                    public content::WebContentsObserver,\n                    public content::WebContentsDelegate,\n                    public InspectableWebContentsDelegate,\n                    public InspectableWebContentsViewDelegate,\n                    public mojom::ElectronBrowser {\n public:\n  enum class Type {\n    kBackgroundPage,  // An extension background page.\n    kBrowserWindow,   // Used by BrowserWindow.\n    kBrowserView,     // Used by BrowserView.\n    kRemote,          // Thin wrap around an existing WebContents.\n    kWebView,         // Used by <webview>.\n    kOffScreen,       // Used for offscreen rendering\n  };\n\n  // Create a new WebContents and return the V8 wrapper of it.\n  static gin::Handle<WebContents> New(v8::Isolate* isolate,\n                                      const gin_helper::Dictionary& options);\n\n  // Create a new V8 wrapper for an existing |web_content|.\n  //\n  // The lifetime of |web_contents| will be managed by this class.\n  static gin::Handle<WebContents> CreateAndTake(\n      v8::Isolate* isolate,\n      std::unique_ptr<content::WebContents> web_contents,\n      Type type);\n\n  // Get the api::WebContents associated with |web_contents|. Returns nullptr\n  // if there is no associated wrapper.\n  static WebContents* From(content::WebContents* web_contents);\n  static WebContents* FromID(int32_t id);\n\n  // Get the V8 wrapper of the |web_contents|, or create one if not existed.\n  //\n  // The lifetime of |web_contents| is NOT managed by this class, and the type\n  // of this wrapper is always REMOTE.\n  static gin::Handle<WebContents> FromOrCreate(\n      v8::Isolate* isolate,\n      content::WebContents* web_contents);\n\n  // gin::Wrappable\n  static gin::WrapperInfo kWrapperInfo;\n  static v8::Local<v8::ObjectTemplate> FillObjectTemplate(\n      v8::Isolate*,\n      v8::Local<v8::ObjectTemplate>);\n  const char* GetTypeName() override;\n\n  base::WeakPtr<WebContents> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }\n\n  // Destroy the managed content::WebContents instance.\n  //\n  // Note: The |async| should only be |true| when users are expecting to use the\n  // webContents immediately after the call. Always pass |false| if you are not\n  // sure.\n  // See https://github.com/electron/electron/issues/8930.\n  //\n  // Note: When destroying a webContents member inside a destructor, the |async|\n  // should always be |false|, otherwise the destroy task might be delayed after\n  // normal shutdown procedure, resulting in an assertion.\n  // The normal pattern for calling this method in destructor is:\n  // api_web_contents_->DestroyWebContents(!Browser::Get()->is_shutting_down())\n  // See https://github.com/electron/electron/issues/15133.\n  void DestroyWebContents(bool async);\n\n  bool GetBackgroundThrottling() const;\n  void SetBackgroundThrottling(bool allowed);\n  int GetProcessID() const;\n  base::ProcessId GetOSProcessID() const;\n  Type GetType() const;\n  bool Equal(const WebContents* web_contents) const;\n  void LoadURL(const GURL& url, const gin_helper::Dictionary& options);\n  void DownloadURL(const GURL& url);\n  GURL GetURL() const;\n  base::string16 GetTitle() const;\n  bool IsLoading() const;\n  bool IsLoadingMainFrame() const;\n  bool IsWaitingForResponse() const;\n  void Stop();\n  void ReloadIgnoringCache();\n  void GoBack();\n  void GoForward();\n  void GoToOffset(int offset);\n  const std::string GetWebRTCIPHandlingPolicy() const;\n  void SetWebRTCIPHandlingPolicy(const std::string& webrtc_ip_handling_policy);\n  bool IsCrashed() const;\n  void ForcefullyCrashRenderer();\n  void SetUserAgent(const std::string& user_agent);\n  std::string GetUserAgent();\n  void InsertCSS(const std::string& css);\n  v8::Local<v8::Promise> SavePage(const base::FilePath& full_file_path,\n                                  const content::SavePageType& save_type);\n  void OpenDevTools(gin::Arguments* args);\n  void CloseDevTools();\n  bool IsDevToolsOpened();\n  bool IsDevToolsFocused();\n  void ToggleDevTools();\n  void EnableDeviceEmulation(const blink::DeviceEmulationParams& params);\n  void DisableDeviceEmulation();\n  void InspectElement(int x, int y);\n  void InspectSharedWorker();\n  void InspectSharedWorkerById(const std::string& workerId);\n  std::vector<scoped_refptr<content::DevToolsAgentHost>> GetAllSharedWorkers();\n  void InspectServiceWorker();\n  void SetIgnoreMenuShortcuts(bool ignore);\n  void SetAudioMuted(bool muted);\n  bool IsAudioMuted();\n  bool IsCurrentlyAudible();\n  void SetEmbedder(const WebContents* embedder);\n  void SetDevToolsWebContents(const WebContents* devtools);\n  v8::Local<v8::Value> GetNativeView(v8::Isolate* isolate) const;\n  void IncrementCapturerCount(gin::Arguments* args);\n  void DecrementCapturerCount(gin::Arguments* args);\n  bool IsBeingCaptured();\n\n#if BUILDFLAG(ENABLE_PRINTING)\n  void OnGetDefaultPrinter(base::Value print_settings,\n                           printing::CompletionCallback print_callback,\n                           base::string16 device_name,\n                           bool silent,\n                           base::string16 default_printer);\n  void Print(gin::Arguments* args);\n  // Print current page as PDF.\n  v8::Local<v8::Promise> PrintToPDF(base::DictionaryValue settings);\n#endif\n\n  void SetNextChildWebPreferences(const gin_helper::Dictionary);\n\n  // DevTools workspace api.\n  void AddWorkSpace(gin::Arguments* args, const base::FilePath& path);\n  void RemoveWorkSpace(gin::Arguments* args, const base::FilePath& path);\n\n  // Editing commands.\n  void Undo();\n  void Redo();\n  void Cut();\n  void Copy();\n  void Paste();\n  void PasteAndMatchStyle();\n  void Delete();\n  void SelectAll();\n  void Unselect();\n  void Replace(const base::string16& word);\n  void ReplaceMisspelling(const base::string16& word);\n  uint32_t FindInPage(gin::Arguments* args);\n  void StopFindInPage(content::StopFindAction action);\n  void ShowDefinitionForSelection();\n  void CopyImageAt(int x, int y);\n\n  // Focus.\n  void Focus();\n  bool IsFocused() const;\n\n  // Send messages to browser.\n  bool SendIPCMessage(bool internal,\n                      const std::string& channel,\n                      v8::Local<v8::Value> args);\n\n  bool SendIPCMessageWithSender(bool internal,\n                                const std::string& channel,\n                                blink::CloneableMessage args,\n                                int32_t sender_id = 0);\n\n  bool SendIPCMessageToFrame(bool internal,\n                             v8::Local<v8::Value> frame,\n                             const std::string& channel,\n                             v8::Local<v8::Value> args);\n\n  void PostMessage(const std::string& channel,\n                   v8::Local<v8::Value> message,\n                   base::Optional<v8::Local<v8::Value>> transfer);\n\n  // Send WebInputEvent to the page.\n  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);\n\n  // Subscribe to the frame updates.\n  void BeginFrameSubscription(gin::Arguments* args);\n  void EndFrameSubscription();\n\n  // Dragging native items.\n  void StartDrag(const gin_helper::Dictionary& item, gin::Arguments* args);\n\n  // Captures the page with |rect|, |callback| would be called when capturing is\n  // done.\n  v8::Local<v8::Promise> CapturePage(gin::Arguments* args);\n\n  // Methods for creating <webview>.\n  bool IsGuest() const;\n  void AttachToIframe(content::WebContents* embedder_web_contents,\n                      int embedder_frame_id);\n  void DetachFromOuterFrame();\n\n  // Methods for offscreen rendering\n  bool IsOffScreen() const;\n#if BUILDFLAG(ENABLE_OSR)\n  void OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap);\n  void StartPainting();\n  void StopPainting();\n  bool IsPainting() const;\n  void SetFrameRate(int frame_rate);\n  int GetFrameRate() const;\n#endif\n  void Invalidate();\n  gfx::Size GetSizeForNewRenderView(content::WebContents*) override;\n\n  // Methods for zoom handling.\n  void SetZoomLevel(double level);\n  double GetZoomLevel() const;\n  void SetZoomFactor(gin_helper::ErrorThrower thrower, double factor);\n  double GetZoomFactor() const;\n\n  // Callback triggered on permission response.\n  void OnEnterFullscreenModeForTab(\n      content::RenderFrameHost* requesting_frame,\n      const blink::mojom::FullscreenOptions& options,\n      bool allowed);\n\n  // Create window with the given disposition.\n  void OnCreateWindow(const GURL& target_url,\n                      const content::Referrer& referrer,\n                      const std::string& frame_name,\n                      WindowOpenDisposition disposition,\n                      const std::string& features,\n                      const scoped_refptr<network::ResourceRequestBody>& body);\n\n  // Returns the preload script path of current WebContents.\n  std::vector<base::FilePath> GetPreloadPaths() const;\n\n  // Returns the web preferences of current WebContents.\n  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate) const;\n  v8::Local<v8::Value> GetLastWebPreferences(v8::Isolate* isolate) const;\n\n  // Returns the owner window.\n  v8::Local<v8::Value> GetOwnerBrowserWindow(v8::Isolate* isolate) const;\n\n  // Grants the child process the capability to access URLs with the origin of\n  // the specified URL.\n  void GrantOriginAccess(const GURL& url);\n\n  // Notifies the web page that there is user interaction.\n  void NotifyUserActivation();\n\n  v8::Local<v8::Promise> TakeHeapSnapshot(v8::Isolate* isolate,\n                                          const base::FilePath& file_path);\n\n  // Properties.\n  int32_t ID() const { return id_; }\n  v8::Local<v8::Value> Session(v8::Isolate* isolate);\n  content::WebContents* HostWebContents() const;\n  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);\n  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);\n  bool WasInitiallyShown();\n  content::RenderFrameHost* MainFrame();\n\n  WebContentsZoomController* GetZoomController() { return zoom_controller_; }\n\n  void AddObserver(ExtendedWebContentsObserver* obs) {\n    observers_.AddObserver(obs);\n  }\n  void RemoveObserver(ExtendedWebContentsObserver* obs) {\n    // Trying to remove from an empty collection leads to an access violation\n    if (observers_.might_have_observers())\n      observers_.RemoveObserver(obs);\n  }\n\n  bool EmitNavigationEvent(const std::string& event,\n                           content::NavigationHandle* navigation_handle);\n\n  // this.emit(name, new Event(sender, message), args...);\n  template <typename... Args>\n  bool EmitWithSender(base::StringPiece name,\n                      content::RenderFrameHost* sender,\n                      electron::mojom::ElectronBrowser::InvokeCallback callback,\n                      Args&&... args) {\n    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n    v8::Isolate* isolate = JavascriptEnvironment::GetIsolate();\n    v8::HandleScope handle_scope(isolate);\n    v8::Local<v8::Object> wrapper;\n    if (!GetWrapper(isolate).ToLocal(&wrapper))\n      return false;\n    v8::Local<v8::Object> event = gin_helper::internal::CreateNativeEvent(\n        isolate, wrapper, sender, std::move(callback));\n    return EmitCustomEvent(name, event, std::forward<Args>(args)...);\n  }\n\n  void MarkDestroyed();\n\n  WebContents* embedder() { return embedder_; }\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  extensions::ScriptExecutor* script_executor() {\n    return script_executor_.get();\n  }\n#endif\n\n  // Set the window as owner window.\n  void SetOwnerWindow(NativeWindow* owner_window);\n  void SetOwnerWindow(content::WebContents* web_contents,\n                      NativeWindow* owner_window);\n\n  // Returns the WebContents managed by this delegate.\n  content::WebContents* GetWebContents() const;\n\n  // Returns the WebContents of devtools.\n  content::WebContents* GetDevToolsWebContents() const;\n\n  InspectableWebContents* inspectable_web_contents() const {\n    return inspectable_web_contents_.get();\n  }\n\n  NativeWindow* owner_window() const { return owner_window_.get(); }\n\n  bool is_html_fullscreen() const { return html_fullscreen_; }\n\n  void set_fullscreen_frame(content::RenderFrameHost* rfh) {\n    fullscreen_frame_ = rfh;\n  }\n\n private:\n  // Does not manage lifetime of |web_contents|.\n  WebContents(v8::Isolate* isolate, content::WebContents* web_contents);\n  // Takes over ownership of |web_contents|.\n  WebContents(v8::Isolate* isolate,\n              std::unique_ptr<content::WebContents> web_contents,\n              Type type);\n  // Creates a new content::WebContents.\n  WebContents(v8::Isolate* isolate, const gin_helper::Dictionary& options);\n  ~WebContents() override;\n\n  // Creates a InspectableWebContents object and takes ownership of\n  // |web_contents|.\n  void InitWithWebContents(content::WebContents* web_contents,\n                           ElectronBrowserContext* browser_context,\n                           bool is_guest);\n\n  void InitWithSessionAndOptions(\n      v8::Isolate* isolate,\n      std::unique_ptr<content::WebContents> web_contents,\n      gin::Handle<class Session> session,\n      const gin_helper::Dictionary& options);\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  void InitWithExtensionView(v8::Isolate* isolate,\n                             content::WebContents* web_contents,\n                             extensions::ViewType view_type);\n#endif\n\n  // content::WebContentsDelegate:\n  bool DidAddMessageToConsole(content::WebContents* source,\n                              blink::mojom::ConsoleMessageLevel level,\n                              const base::string16& message,\n                              int32_t line_no,\n                              const base::string16& source_id) override;\n  bool IsWebContentsCreationOverridden(\n      content::SiteInstance* source_site_instance,\n      content::mojom::WindowContainerType window_container_type,\n      const GURL& opener_url,\n      const content::mojom::CreateNewWindowParams& params) override;\n  content::WebContents* CreateCustomWebContents(\n      content::RenderFrameHost* opener,\n      content::SiteInstance* source_site_instance,\n      bool is_new_browsing_instance,\n      const GURL& opener_url,\n      const std::string& frame_name,\n      const GURL& target_url,\n      const std::string& partition_id,\n      content::SessionStorageNamespace* session_storage_namespace) override;\n  void WebContentsCreatedWithFullParams(\n      content::WebContents* source_contents,\n      int opener_render_process_id,\n      int opener_render_frame_id,\n      const content::mojom::CreateNewWindowParams& params,\n      content::WebContents* new_contents) override;\n  void AddNewContents(content::WebContents* source,\n                      std::unique_ptr<content::WebContents> new_contents,\n                      const GURL& target_url,\n                      WindowOpenDisposition disposition,\n                      const gfx::Rect& initial_rect,\n                      bool user_gesture,\n                      bool* was_blocked) override;\n  content::WebContents* OpenURLFromTab(\n      content::WebContents* source,\n      const content::OpenURLParams& params) override;\n  void BeforeUnloadFired(content::WebContents* tab,\n                         bool proceed,\n                         bool* proceed_to_fire_unload) override;\n  void SetContentsBounds(content::WebContents* source,\n                         const gfx::Rect& pos) override;\n  void CloseContents(content::WebContents* source) override;\n  void ActivateContents(content::WebContents* contents) override;\n  void UpdateTargetURL(content::WebContents* source, const GURL& url) override;\n  bool HandleKeyboardEvent(\n      content::WebContents* source,\n      const content::NativeWebKeyboardEvent& event) override;\n  bool PlatformHandleKeyboardEvent(\n      content::WebContents* source,\n      const content::NativeWebKeyboardEvent& event);\n  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(\n      content::WebContents* source,\n      const content::NativeWebKeyboardEvent& event) override;\n  void ContentsZoomChange(bool zoom_in) override;\n  void EnterFullscreenModeForTab(\n      content::RenderFrameHost* requesting_frame,\n      const blink::mojom::FullscreenOptions& options) override;\n  void ExitFullscreenModeForTab(content::WebContents* source) override;\n  void RendererUnresponsive(\n      content::WebContents* source,\n      content::RenderWidgetHost* render_widget_host,\n      base::RepeatingClosure hang_monitor_restarter) override;\n  void RendererResponsive(\n      content::WebContents* source,\n      content::RenderWidgetHost* render_widget_host) override;\n  bool HandleContextMenu(content::RenderFrameHost* render_frame_host,\n                         const content::ContextMenuParams& params) override;\n  bool OnGoToEntryOffset(int offset) override;\n  void FindReply(content::WebContents* web_contents,\n                 int request_id,\n                 int number_of_matches,\n                 const gfx::Rect& selection_rect,\n                 int active_match_ordinal,\n                 bool final_update) override;\n  bool CheckMediaAccessPermission(content::RenderFrameHost* render_frame_host,\n                                  const GURL& security_origin,\n                                  blink::mojom::MediaStreamType type) override;\n  void RequestMediaAccessPermission(\n      content::WebContents* web_contents,\n      const content::MediaStreamRequest& request,\n      content::MediaResponseCallback callback) override;\n  void RequestToLockMouse(content::WebContents* web_contents,\n                          bool user_gesture,\n                          bool last_unlocked_by_target) override;\n  content::JavaScriptDialogManager* GetJavaScriptDialogManager(\n      content::WebContents* source) override;\n  void OnAudioStateChanged(bool audible) override;\n  void UpdatePreferredSize(content::WebContents* web_contents,\n                           const gfx::Size& pref_size) override;\n\n  // content::WebContentsObserver:\n  void BeforeUnloadFired(bool proceed,\n                         const base::TimeTicks& proceed_time) override;\n  void RenderViewCreated(content::RenderViewHost* render_view_host) override;\n  void RenderFrameCreated(content::RenderFrameHost* render_frame_host) override;\n  void RenderViewDeleted(content::RenderViewHost*) override;\n  void RenderProcessGone(base::TerminationStatus status) override;\n  void RenderFrameDeleted(content::RenderFrameHost* render_frame_host) override;\n  void DOMContentLoaded(content::RenderFrameHost* render_frame_host) override;\n  void DidFinishLoad(content::RenderFrameHost* render_frame_host,\n                     const GURL& validated_url) override;\n  void DidFailLoad(content::RenderFrameHost* render_frame_host,\n                   const GURL& validated_url,\n                   int error_code) override;\n  void DidStartLoading() override;\n  void DidStopLoading() override;\n  void DidStartNavigation(\n      content::NavigationHandle* navigation_handle) override;\n  void DidRedirectNavigation(\n      content::NavigationHandle* navigation_handle) override;\n  void DidFinishNavigation(\n      content::NavigationHandle* navigation_handle) override;\n  bool OnMessageReceived(const IPC::Message& message) override;\n  void WebContentsDestroyed() override;\n  void NavigationEntryCommitted(\n      const content::LoadCommittedDetails& load_details) override;\n  void TitleWasSet(content::NavigationEntry* entry) override;\n  void DidUpdateFaviconURL(\n      content::RenderFrameHost* render_frame_host,\n      const std::vector<blink::mojom::FaviconURLPtr>& urls) override;\n  void PluginCrashed(const base::FilePath& plugin_path,\n                     base::ProcessId plugin_pid) override;\n  void MediaStartedPlaying(const MediaPlayerInfo& video_type,\n                           const content::MediaPlayerId& id) override;\n  void MediaStoppedPlaying(\n      const MediaPlayerInfo& video_type,\n      const content::MediaPlayerId& id,\n      content::WebContentsObserver::MediaStoppedReason reason) override;\n  void DidChangeThemeColor() override;\n  void OnInterfaceRequestFromFrame(\n      content::RenderFrameHost* render_frame_host,\n      const std::string& interface_name,\n      mojo::ScopedMessagePipeHandle* interface_pipe) override;\n  void OnCursorChanged(const content::WebCursor& cursor) override;\n  void DidAcquireFullscreen(content::RenderFrameHost* rfh) override;\n\n  // InspectableWebContentsDelegate:\n  void DevToolsReloadPage() override;\n\n  // InspectableWebContentsViewDelegate:\n  void DevToolsFocused() override;\n  void DevToolsOpened() override;\n  void DevToolsClosed() override;\n  void DevToolsResized() override;\n\n  ElectronBrowserContext* GetBrowserContext() const;\n\n  // Binds the given request for the ElectronBrowser API. When the\n  // RenderFrameHost is destroyed, all related bindings will be removed.\n  void BindElectronBrowser(\n      mojo::PendingReceiver<mojom::ElectronBrowser> receiver,\n      content::RenderFrameHost* render_frame_host);\n  void OnElectronBrowserConnectionError();\n\n#if BUILDFLAG(ENABLE_OSR)\n  OffScreenWebContentsView* GetOffScreenWebContentsView() const;\n  OffScreenRenderWidgetHostView* GetOffScreenRenderWidgetHostView() const;\n#endif\n\n  // mojom::ElectronBrowser\n  void Message(bool internal,\n               const std::string& channel,\n               blink::CloneableMessage arguments) override;\n  void Invoke(bool internal,\n              const std::string& channel,\n              blink::CloneableMessage arguments,\n              InvokeCallback callback) override;\n  void OnFirstNonEmptyLayout() override;\n  void ReceivePostMessage(const std::string& channel,\n                          blink::TransferableMessage message) override;\n  void MessageSync(bool internal,\n                   const std::string& channel,\n                   blink::CloneableMessage arguments,\n                   MessageSyncCallback callback) override;\n  void MessageTo(bool internal,\n                 int32_t web_contents_id,\n                 const std::string& channel,\n                 blink::CloneableMessage arguments) override;\n  void MessageHost(const std::string& channel,\n                   blink::CloneableMessage arguments) override;\n  void UpdateDraggableRegions(\n      std::vector<mojom::DraggableRegionPtr> regions) override;\n  void SetTemporaryZoomLevel(double level) override;\n  void DoGetZoomLevel(DoGetZoomLevelCallback callback) override;\n\n  // Called when received a synchronous message from renderer to\n  // get the zoom level.\n  void OnGetZoomLevel(content::RenderFrameHost* frame_host,\n                      IPC::Message* reply_msg);\n\n  void InitZoomController(content::WebContents* web_contents,\n                          const gin_helper::Dictionary& options);\n\n  // content::WebContentsDelegate:\n  bool CanOverscrollContent() override;\n  content::ColorChooser* OpenColorChooser(\n      content::WebContents* web_contents,\n      SkColor color,\n      const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions)\n      override;\n  void RunFileChooser(content::RenderFrameHost* render_frame_host,\n                      scoped_refptr<content::FileSelectListener> listener,\n                      const blink::mojom::FileChooserParams& params) override;\n  void EnumerateDirectory(content::WebContents* web_contents,\n                          scoped_refptr<content::FileSelectListener> listener,\n                          const base::FilePath& path) override;\n  bool IsFullscreenForTabOrPending(const content::WebContents* source) override;\n  blink::SecurityStyle GetSecurityStyle(\n      content::WebContents* web_contents,\n      content::SecurityStyleExplanations* explanations) override;\n  bool TakeFocus(content::WebContents* source, bool reverse) override;\n  content::PictureInPictureResult EnterPictureInPicture(\n      content::WebContents* web_contents,\n      const viz::SurfaceId&,\n      const gfx::Size& natural_size) override;\n  void ExitPictureInPicture() override;\n\n  // InspectableWebContentsDelegate:\n  void DevToolsSaveToFile(const std::string& url,\n                          const std::string& content,\n                          bool save_as) override;\n  void DevToolsAppendToFile(const std::string& url,\n                            const std::string& content) override;\n  void DevToolsRequestFileSystems() override;\n  void DevToolsAddFileSystem(const std::string& type,\n                             const base::FilePath& file_system_path) override;\n  void DevToolsRemoveFileSystem(\n      const base::FilePath& file_system_path) override;\n  void DevToolsIndexPath(int request_id,\n                         const std::string& file_system_path,\n                         const std::string& excluded_folders_message) override;\n  void DevToolsStopIndexing(int request_id) override;\n  void DevToolsSearchInPath(int request_id,\n                            const std::string& file_system_path,\n                            const std::string& query) override;\n\n  // InspectableWebContentsViewDelegate:\n#if defined(TOOLKIT_VIEWS) && !defined(OS_MAC)\n  gfx::ImageSkia GetDevToolsWindowIcon() override;\n#endif\n#if defined(OS_LINUX)\n  void GetDevToolsWindowWMClass(std::string* name,\n                                std::string* class_name) override;\n#endif\n\n  // Destroy the managed InspectableWebContents object.\n  void ResetManagedWebContents(bool async);\n\n  // DevTools index event callbacks.\n  void OnDevToolsIndexingWorkCalculated(int request_id,\n                                        const std::string& file_system_path,\n                                        int total_work);\n  void OnDevToolsIndexingWorked(int request_id,\n                                const std::string& file_system_path,\n                                int worked);\n  void OnDevToolsIndexingDone(int request_id,\n                              const std::string& file_system_path);\n  void OnDevToolsSearchCompleted(int request_id,\n                                 const std::string& file_system_path,\n                                 const std::vector<std::string>& file_paths);\n\n  // Set fullscreen mode triggered by html api.\n  void SetHtmlApiFullscreen(bool enter_fullscreen);\n\n  v8::Global<v8::Value> session_;\n  v8::Global<v8::Value> devtools_web_contents_;\n  v8::Global<v8::Value> debugger_;\n\n  std::unique_ptr<ElectronJavaScriptDialogManager> dialog_manager_;\n  std::unique_ptr<WebViewGuestDelegate> guest_delegate_;\n  std::unique_ptr<FrameSubscriber> frame_subscriber_;\n\n#if BUILDFLAG(ENABLE_ELECTRON_EXTENSIONS)\n  std::unique_ptr<extensions::ScriptExecutor> script_executor_;\n#endif\n\n  // The host webcontents that may contain this webcontents.\n  WebContents* embedder_ = nullptr;\n\n  // The zoom controller for this webContents.\n  WebContentsZoomController* zoom_controller_ = nullptr;\n\n  // The type of current WebContents.\n  Type type_ = Type::kBrowserWindow;\n\n  int32_t id_;\n\n  // Request id used for findInPage request.\n  uint32_t find_in_page_request_id_ = 0;\n\n  // Whether background throttling is disabled.\n  bool background_throttling_ = true;\n\n  // Whether to enable devtools.\n  bool enable_devtools_ = true;\n\n  // Observers of this WebContents.\n  base::ObserverList<ExtendedWebContentsObserver> observers_;\n\n  v8::Global<v8::Value> pending_child_web_preferences_;\n\n  bool initially_shown_ = true;\n\n  // The window that this WebContents belongs to.\n  base::WeakPtr<NativeWindow> owner_window_;\n\n  bool offscreen_ = false;\n\n  // Whether window is fullscreened by HTML5 api.\n  bool html_fullscreen_ = false;\n\n  // Whether window is fullscreened by window api.\n  bool native_fullscreen_ = false;\n\n  // UI related helper classes.\n  std::unique_ptr<WebDialogHelper> web_dialog_helper_;\n\n  scoped_refptr<DevToolsFileSystemIndexer> devtools_file_system_indexer_;\n\n  ElectronBrowserContext* browser_context_;\n\n  // The stored InspectableWebContents object.\n  // Notice that inspectable_web_contents_ must be placed after\n  // dialog_manager_, so we can make sure inspectable_web_contents_ is\n  // destroyed before dialog_manager_, otherwise a crash would happen.\n  std::unique_ptr<InspectableWebContents> inspectable_web_contents_;\n\n  // Maps url to file path, used by the file requests sent from devtools.\n  typedef std::map<std::string, base::FilePath> PathsMap;\n  PathsMap saved_files_;\n\n  // Map id to index job, used for file system indexing requests from devtools.\n  typedef std::\n      map<int, scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>>\n          DevToolsIndexingJobsMap;\n  DevToolsIndexingJobsMap devtools_indexing_jobs_;\n\n  scoped_refptr<base::SequencedTaskRunner> file_task_runner_;\n\n  // Stores the frame thats currently in fullscreen, nullptr if there is none.\n  content::RenderFrameHost* fullscreen_frame_ = nullptr;\n\n  service_manager::BinderRegistryWithArgs<content::RenderFrameHost*> registry_;\n  mojo::ReceiverSet<mojom::ElectronBrowser, content::RenderFrameHost*>\n      receivers_;\n  std::map<content::RenderFrameHost*, std::vector<mojo::ReceiverId>>\n      frame_to_receivers_map_;\n\n  base::WeakPtrFactory<WebContents> weak_factory_;\n\n  DISALLOW_COPY_AND_ASSIGN(WebContents);\n};\n\n}  // namespace api\n\n}  // namespace electron\n\n#endif  // SHELL_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_\n", "// Copyright (c) 2019 GitHub, Inc.\n// Use of this source code is governed by the MIT license that can be\n// found in the LICENSE file.\n\n#include \"shell/common/gin_helper/event_emitter.h\"\n\n#include \"content/public/browser/render_frame_host.h\"\n#include \"content/public/browser/render_process_host.h\"\n#include \"shell/browser/api/event.h\"\n#include \"shell/common/gin_helper/dictionary.h\"\n#include \"shell/common/gin_helper/object_template_builder.h\"\n\nnamespace gin_helper {\n\nnamespace internal {\n\nnamespace {\n\nv8::Persistent<v8::ObjectTemplate> event_template;\n\nvoid PreventDefault(gin_helper::Arguments* args) {\n  Dictionary self;\n  if (args->GetHolder(&self))\n    self.Set(\"defaultPrevented\", true);\n}\n\n}  // namespace\n\nv8::Local<v8::Object> CreateEvent(v8::Isolate* isolate,\n                                  v8::Local<v8::Object> sender,\n                                  v8::Local<v8::Object> custom_event) {\n  if (event_template.IsEmpty()) {\n    event_template.Reset(\n        isolate,\n        ObjectTemplateBuilder(isolate, v8::ObjectTemplate::New(isolate))\n            .SetMethod(\"preventDefault\", &PreventDefault)\n            .Build());\n  }\n\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n  CHECK(!context.IsEmpty());\n  v8::Local<v8::Object> event =\n      v8::Local<v8::ObjectTemplate>::New(isolate, event_template)\n          ->NewInstance(context)\n          .ToLocalChecked();\n  if (!sender.IsEmpty())\n    Dictionary(isolate, event).Set(\"sender\", sender);\n  if (!custom_event.IsEmpty())\n    event->SetPrototype(context, custom_event).IsJust();\n  return event;\n}\n\nv8::Local<v8::Object> CreateNativeEvent(\n    v8::Isolate* isolate,\n    v8::Local<v8::Object> sender,\n    content::RenderFrameHost* frame,\n    electron::mojom::ElectronBrowser::MessageSyncCallback callback) {\n  v8::Local<v8::Object> event;\n  if (frame && callback) {\n    gin::Handle<Event> native_event = Event::Create(isolate);\n    native_event->SetCallback(std::move(callback));\n    event = v8::Local<v8::Object>::Cast(native_event.ToV8());\n  } else {\n    // No need to create native event if we do not need to send reply.\n    event = CreateEvent(isolate);\n  }\n\n  Dictionary dict(isolate, event);\n  dict.Set(\"sender\", sender);\n  // Should always set frameId even when callback is null.\n  if (frame) {\n    dict.Set(\"frameId\", frame->GetRoutingID());\n    dict.Set(\"processId\", frame->GetProcess()->GetID());\n  }\n  return event;\n}\n\n}  // namespace internal\n\n}  // namespace gin_helper\n", "import { expect } from 'chai';\nimport * as path from 'path';\nimport * as cp from 'child_process';\nimport { closeAllWindows } from './window-helpers';\nimport { emittedOnce } from './events-helpers';\nimport { defer } from './spec-helpers';\nimport { ipcMain, BrowserWindow } from 'electron/main';\n\ndescribe('ipc main module', () => {\n  const fixtures = path.join(__dirname, 'fixtures');\n\n  afterEach(closeAllWindows);\n\n  describe('ipc.sendSync', () => {\n    afterEach(() => { ipcMain.removeAllListeners('send-sync-message'); });\n\n    it('does not crash when reply is not sent and browser is destroyed', (done) => {\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      ipcMain.once('send-sync-message', (event) => {\n        event.returnValue = null;\n        done();\n      });\n      w.loadFile(path.join(fixtures, 'api', 'send-sync-message.html'));\n    });\n\n    it('does not crash when reply is sent by multiple listeners', (done) => {\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      ipcMain.on('send-sync-message', (event) => {\n        event.returnValue = null;\n      });\n      ipcMain.on('send-sync-message', (event) => {\n        event.returnValue = null;\n        done();\n      });\n      w.loadFile(path.join(fixtures, 'api', 'send-sync-message.html'));\n    });\n  });\n\n  describe('ipcMain.on', () => {\n    it('is not used for internals', async () => {\n      const appPath = path.join(fixtures, 'api', 'ipc-main-listeners');\n      const electronPath = process.execPath;\n      const appProcess = cp.spawn(electronPath, [appPath]);\n\n      let output = '';\n      appProcess.stdout.on('data', (data) => { output += data; });\n\n      await emittedOnce(appProcess.stdout, 'end');\n\n      output = JSON.parse(output);\n      expect(output).to.deep.equal(['error']);\n    });\n\n    it('can be replied to', async () => {\n      ipcMain.on('test-echo', (e, arg) => {\n        e.reply('test-echo', arg);\n      });\n      defer(() => {\n        ipcMain.removeAllListeners('test-echo');\n      });\n\n      const w = new BrowserWindow({\n        show: false,\n        webPreferences: {\n          nodeIntegration: true\n        }\n      });\n      w.loadURL('about:blank');\n      const v = await w.webContents.executeJavaScript(`new Promise((resolve, reject) => {\n        const { ipcRenderer } = require('electron')\n        ipcRenderer.send('test-echo', 'hello')\n        ipcRenderer.on('test-echo', (e, v) => {\n          resolve(v)\n        })\n      })`);\n      expect(v).to.equal('hello');\n    });\n  });\n});\n", "[\n  [\n    \"top=5,left=10,resizable=no\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1,\n      \"processId\": \"placeholder-process-id\"\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"top\": 5,\n      \"left\": 10,\n      \"resizable\": false,\n      \"x\": 10,\n      \"y\": 5,\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"zoomFactor=2,resizable=0,x=0,y=10\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1,\n      \"processId\": \"placeholder-process-id\"\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"resizable\": false,\n      \"x\": 0,\n      \"y\": 10,\n      \"webPreferences\": {\n        \"zoomFactor\": \"2\",\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"backgroundColor=gray,webPreferences=0,x=100,y=100\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1,\n      \"processId\": \"placeholder-process-id\"\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"backgroundColor\": \"gray\",\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\",\n        \"backgroundColor\": \"gray\"\n      },\n      \"x\": 100,\n      \"y\": 100,\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"x=50,y=20,title=sup\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1,\n      \"processId\": \"placeholder-process-id\"\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": true,\n      \"title\": \"sup\",\n      \"width\": 800,\n      \"height\": 600,\n      \"x\": 50,\n      \"y\": 20,\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ],\n  [\n    \"show=false,top=1,left=1\",\n    {\n      \"sender\": \"[WebContents]\",\n      \"frameId\": 1,\n      \"processId\": \"placeholder-process-id\"\n    },\n    \"about:blank\",\n    \"frame name\",\n    \"new-window\",\n    {\n      \"show\": false,\n      \"title\": \"frame name\",\n      \"width\": 800,\n      \"height\": 600,\n      \"top\": 1,\n      \"left\": 1,\n      \"x\": 1,\n      \"y\": 1,\n      \"webPreferences\": {\n        \"nodeIntegration\": false,\n        \"webviewTag\": false,\n        \"nodeIntegrationInSubFrames\": false,\n        \"openerId\": \"placeholder-opener-id\"\n      },\n      \"webContents\": \"[WebContents]\"\n    },\n    [],\n    {\n      \"url\": \"\",\n      \"policy\": \"default\"\n    },\n    null\n  ]\n]", "import { BrowserWindow } from 'electron';\nimport { writeFileSync, readFileSync } from 'fs';\nimport { resolve } from 'path';\nimport { expect, assert } from 'chai';\nimport { closeAllWindows } from './window-helpers';\nconst { emittedOnce } = require('./events-helpers');\n\nfunction genSnapshot (browserWindow: BrowserWindow, features: string) {\n  return new Promise((resolve) => {\n    browserWindow.webContents.on('new-window', (...args: any[]) => {\n      resolve([features, ...args]);\n    });\n    browserWindow.webContents.executeJavaScript(`window.open('about:blank', 'frame name', '${features}') && true`);\n  });\n}\n\ndescribe('new-window event', () => {\n  const testConfig = {\n    native: {\n      snapshotFileName: 'native-window-open.snapshot.txt',\n      browserWindowOptions: {\n        show: false,\n        width: 200,\n        title: 'cool',\n        backgroundColor: 'blue',\n        focusable: false,\n        webPreferences: {\n          nativeWindowOpen: true,\n          sandbox: true\n        }\n      }\n    },\n    proxy: {\n      snapshotFileName: 'proxy-window-open.snapshot.txt',\n      browserWindowOptions: {\n        show: false\n      }\n    }\n  };\n\n  for (const testName of Object.keys(testConfig) as (keyof typeof testConfig)[]) {\n    const { snapshotFileName, browserWindowOptions } = testConfig[testName];\n\n    describe(`for ${testName} window opening`, () => {\n      const snapshotFile = resolve(__dirname, 'fixtures', 'snapshots', snapshotFileName);\n      let browserWindow: BrowserWindow;\n      let existingSnapshots: any[];\n\n      before(() => {\n        existingSnapshots = parseSnapshots(readFileSync(snapshotFile, { encoding: 'utf8' }));\n      });\n\n      beforeEach((done) => {\n        browserWindow = new BrowserWindow(browserWindowOptions);\n        browserWindow.loadURL('about:blank');\n        browserWindow.on('ready-to-show', () => { done(); });\n      });\n\n      afterEach(closeAllWindows);\n\n      const newSnapshots: any[] = [];\n      [\n        'top=5,left=10,resizable=no',\n        'zoomFactor=2,resizable=0,x=0,y=10',\n        'backgroundColor=gray,webPreferences=0,x=100,y=100',\n        'x=50,y=20,title=sup',\n        'show=false,top=1,left=1'\n      ].forEach((features, index) => {\n        /**\n         * ATTN: If this test is failing, you likely just need to change\n         * `shouldOverwriteSnapshot` to true and then evaluate the snapshot diff\n         * to see if the change is harmless.\n         */\n        it(`matches snapshot for ${features}`, async () => {\n          const newSnapshot = await genSnapshot(browserWindow, features);\n          newSnapshots.push(newSnapshot);\n          // TODO: The output when these fail could be friendlier.\n          expect(stringifySnapshots(newSnapshot)).to.equal(stringifySnapshots(existingSnapshots[index]));\n        });\n      });\n\n      after(() => {\n        const shouldOverwriteSnapshot = false;\n        if (shouldOverwriteSnapshot) writeFileSync(snapshotFile, stringifySnapshots(newSnapshots, true));\n      });\n    });\n  }\n});\n\ndescribe('webContents.setWindowOpenHandler', () => {\n  const testConfig = {\n    native: {\n      browserWindowOptions: {\n        show: false,\n        webPreferences: {\n          nativeWindowOpen: true\n        }\n      }\n    },\n    proxy: {\n      browserWindowOptions: {\n        show: false,\n        webPreferences: {\n          nativeWindowOpen: false\n        }\n      }\n    }\n  };\n\n  for (const testName of Object.keys(testConfig) as (keyof typeof testConfig)[]) {\n    let browserWindow: BrowserWindow;\n    const { browserWindowOptions } = testConfig[testName];\n\n    describe(testName, () => {\n      beforeEach((done) => {\n        browserWindow = new BrowserWindow(browserWindowOptions);\n        browserWindow.loadURL('about:blank');\n        browserWindow.on('ready-to-show', () => { browserWindow.show(); done(); });\n      });\n\n      afterEach(closeAllWindows);\n\n      it('does not fire window creation events if an override returns action: deny', (done) => {\n        browserWindow.webContents.setWindowOpenHandler(() => ({ action: 'deny' }));\n        browserWindow.webContents.on('new-window', () => {\n          assert.fail('new-window should not to be called with an overridden window.open');\n        });\n\n        browserWindow.webContents.on('did-create-window', () => {\n          assert.fail('did-create-window should not to be called with an overridden window.open');\n        });\n\n        browserWindow.webContents.executeJavaScript(\"window.open('about:blank') && true\");\n\n        setTimeout(() => {\n          done();\n        }, 500);\n      });\n\n      it('fires handler with correct params', (done) => {\n        const testFrameName = 'test-frame-name';\n        const testFeatures = 'top=10&left=10&something-unknown';\n        const testUrl = 'app://does-not-exist/';\n        browserWindow.webContents.setWindowOpenHandler(({ url, frameName, features }) => {\n          expect(url).to.equal(testUrl);\n          expect(frameName).to.equal(testFrameName);\n          expect(features).to.equal(testFeatures);\n          done();\n          return { action: 'deny' };\n        });\n\n        browserWindow.webContents.executeJavaScript(`window.open('${testUrl}', '${testFrameName}', '${testFeatures}') && true`);\n      });\n\n      it('does fire window creation events if an override returns action: allow', async () => {\n        browserWindow.webContents.setWindowOpenHandler(() => ({ action: 'allow' }));\n\n        setImmediate(() => {\n          browserWindow.webContents.executeJavaScript(\"window.open('about:blank') && true\");\n        });\n\n        await Promise.all([\n          emittedOnce(browserWindow.webContents, 'did-create-window'),\n          emittedOnce(browserWindow.webContents, 'new-window')\n        ]);\n      });\n\n      it('can change webPreferences of child windows', (done) => {\n        browserWindow.webContents.setWindowOpenHandler(() => ({ action: 'allow', overrideBrowserWindowOptions: { webPreferences: { defaultFontSize: 30 } } }));\n\n        browserWindow.webContents.on('did-create-window', async (childWindow) => {\n          await childWindow.webContents.executeJavaScript(\"document.write('hello')\");\n          const size = await childWindow.webContents.executeJavaScript(\"getComputedStyle(document.querySelector('body')).fontSize\");\n          expect(size).to.equal('30px');\n          done();\n        });\n\n        browserWindow.webContents.executeJavaScript(\"window.open('about:blank') && true\");\n      });\n    });\n  }\n});\n\nfunction stringifySnapshots (snapshots: any, pretty = false) {\n  return JSON.stringify(snapshots, (key, value) => {\n    if (['sender', 'webContents'].includes(key)) {\n      return '[WebContents]';\n    }\n    if (key === 'openerId' && typeof value === 'number') {\n      return 'placeholder-opener-id';\n    }\n    if (key === 'processId' && typeof value === 'number') {\n      return 'placeholder-process-id';\n    }\n    if (key === 'returnValue') {\n      return 'placeholder-guest-contents-id';\n    }\n    return value;\n  }, pretty ? 2 : undefined);\n}\n\nfunction parseSnapshots (snapshotsJson: string) {\n  return JSON.parse(snapshotsJson, (key, value) => {\n    if (key === 'openerId' && value === 'placeholder-opener-id') return 1;\n    return value;\n  });\n}\n", "/// <reference path=\"../electron.d.ts\" />\n\n/**\n * This file augments the Electron TS namespace with the internal APIs\n * that are not documented but are used by Electron internally\n */\n\ndeclare namespace Electron {\n  enum ProcessType {\n    browser = 'browser',\n    renderer = 'renderer',\n    worker = 'worker'\n  }\n\n  interface App {\n    _setDefaultAppPaths(packagePath: string | null): void;\n    setVersion(version: string): void;\n    setDesktopName(name: string): void;\n    setAppPath(path: string | null): void;\n  }\n\n  type TouchBarItemType = NonNullable<Electron.TouchBarConstructorOptions['items']>[0];\n\n  interface BaseWindow {\n    _init(): void;\n  }\n\n  interface BrowserWindow {\n    _init(): void;\n    _touchBar: Electron.TouchBar | null;\n    _setTouchBarItems: (items: TouchBarItemType[]) => void;\n    _setEscapeTouchBarItem: (item: TouchBarItemType | {}) => void;\n    _refreshTouchBarItem: (itemID: string) => void;\n    frameName: string;\n    on(event: '-touch-bar-interaction', listener: (event: Event, itemID: string, details: any) => void): this;\n    removeListener(event: '-touch-bar-interaction', listener: (event: Event, itemID: string, details: any) => void): this;\n  }\n\n  interface ContextBridge {\n    internalContextBridge: {\n      contextIsolationEnabled: boolean;\n      overrideGlobalValueFromIsolatedWorld(keys: string[], value: any): void;\n      overrideGlobalValueWithDynamicPropsFromIsolatedWorld(keys: string[], value: any): void;\n      overrideGlobalPropertyFromIsolatedWorld(keys: string[], getter: Function, setter?: Function): void;\n      isInMainWorld(): boolean;\n    }\n  }\n\n  interface TouchBar {\n    _removeFromWindow: (win: BrowserWindow) => void;\n  }\n\n  interface WebContents {\n    _getURL(): string;\n    _loadURL(url: string, options: ElectronInternal.LoadURLOptions): void;\n    _stop(): void;\n    _goBack(): void;\n    _goForward(): void;\n    _goToOffset(offset: number): void;\n    getOwnerBrowserWindow(): Electron.BrowserWindow;\n    getWebPreferences(): Electron.WebPreferences;\n    getLastWebPreferences(): Electron.WebPreferences;\n    _getPreloadPaths(): string[];\n    equal(other: WebContents): boolean;\n    _initiallyShown: boolean;\n    browserWindowOptions: BrowserWindowConstructorOptions;\n    _windowOpenHandler: ((opts: {url: string, frameName: string, features: string}) => any) | null;\n    _callWindowOpenHandler(event: any, url: string, frameName: string, rawFeatures: string): Electron.BrowserWindowConstructorOptions | null;\n    _setNextChildWebPreferences(prefs: Partial<Electron.BrowserWindowConstructorOptions['webPreferences']> & Pick<Electron.BrowserWindowConstructorOptions, 'backgroundColor'>): void;\n    _send(internal: boolean, channel: string, args: any): boolean;\n    _sendToFrame(internal: boolean, frameId: number | [number, number], channel: string, args: any): boolean;\n    _sendToFrameInternal(frameId: number | [number, number], channel: string, ...args: any[]): boolean;\n    _postMessage(channel: string, message: any, transfer?: any[]): void;\n    _sendInternal(channel: string, ...args: any[]): void;\n    _printToPDF(options: any): Promise<Buffer>;\n    _print(options: any, callback?: (success: boolean, failureReason: string) => void): void;\n    _getPrinters(): Electron.PrinterInfo[];\n    _init(): void;\n    canGoToIndex(index: number): boolean;\n    getActiveIndex(): number;\n    length(): number;\n    destroy(): void;\n    // <webview>\n    attachToIframe(embedderWebContents: Electron.WebContents, embedderFrameId: number): void;\n    detachFromOuterFrame(): void;\n    setEmbedder(embedder: Electron.WebContents): void;\n    attachParams?: Record<string, any>;\n    viewInstanceId: number;\n  }\n\n  interface WebFrame {\n    getWebFrameId(window: Window): number;\n    allowGuestViewElementDefinition(window: Window, context: any): void;\n  }\n\n  interface WebPreferences {\n    guestInstanceId?: number;\n    openerId?: number;\n    disablePopups?: boolean;\n    preloadURL?: string;\n    embedder?: Electron.WebContents;\n    type?: 'backgroundPage' | 'window' | 'browserView' | 'remote' | 'webview' | 'offscreen';\n  }\n\n  interface Menu {\n    _init(): void;\n    _isCommandIdChecked(id: string): boolean;\n    _isCommandIdEnabled(id: string): boolean;\n    _shouldCommandIdWorkWhenHidden(id: string): boolean;\n    _isCommandIdVisible(id: string): boolean;\n    _getAcceleratorForCommandId(id: string, useDefaultAccelerator: boolean): Accelerator | undefined;\n    _shouldRegisterAcceleratorForCommandId(id: string): boolean;\n    _getSharingItemForCommandId(id: string): SharingItem | null;\n    _callMenuWillShow(): void;\n    _executeCommand(event: any, id: number): void;\n    _menuWillShow(): void;\n    commandsMap: Record<string, MenuItem>;\n    groupsMap: Record<string, {\n      checked: boolean;\n    }[]>;\n    getItemCount(): number;\n    popupAt(window: BaseWindow, x: number, y: number, positioning: number, callback: () => void): void;\n    closePopupAt(id: number): void;\n    setSublabel(index: number, label: string): void;\n    setToolTip(index: number, tooltip: string): void;\n    setIcon(index: number, image: string | NativeImage): void;\n    setRole(index: number, role: string): void;\n    insertItem(index: number, commandId: number, label: string): void;\n    insertCheckItem(index: number, commandId: number, label: string): void;\n    insertRadioItem(index: number, commandId: number, label: string, groupId: number): void;\n    insertSeparator(index: number): void;\n    insertSubMenu(index: number, commandId: number, label: string, submenu?: Menu): void;\n    delegate?: any;\n    getAcceleratorTextAt(index: number): string;\n  }\n\n  interface MenuItem {\n    overrideReadOnlyProperty(property: string, value: any): void;\n    groupId: number;\n    getDefaultRoleAccelerator(): Accelerator | undefined;\n    getCheckStatus(): boolean;\n    acceleratorWorksWhenHidden?: boolean;\n  }\n\n  interface IpcMainInvokeEvent {\n    _reply(value: any): void;\n    _throw(error: Error): void;\n  }\n\n  const deprecate: ElectronInternal.DeprecationUtil;\n\n  namespace Main {\n    const deprecate: ElectronInternal.DeprecationUtil;\n  }\n\n  class View {}\n\n  // Experimental views API\n  class BaseWindow {\n    constructor(args: {show: boolean})\n    setContentView(view: View): void\n    static fromId(id: number): BaseWindow;\n    static getAllWindows(): BaseWindow[];\n    isFocused(): boolean;\n    static getFocusedWindow(): BaseWindow | undefined;\n    setMenu(menu: Menu): void;\n  }\n  class WebContentsView {\n    constructor(options: BrowserWindowConstructorOptions)\n  }\n\n  // Deprecated / undocumented BrowserWindow methods\n  interface BrowserWindow {\n    getURL(): string;\n    send(channel: string, ...args: any[]): void;\n    openDevTools(options?: Electron.OpenDevToolsOptions): void;\n    closeDevTools(): void;\n    isDevToolsOpened(): void;\n    isDevToolsFocused(): void;\n    toggleDevTools(): void;\n    inspectElement(x: number, y: number): void;\n    inspectSharedWorker(): void;\n    inspectServiceWorker(): void;\n    getBackgroundThrottling(): void;\n    setBackgroundThrottling(allowed: boolean): void;\n  }\n\n  namespace Main {\n    class BaseWindow extends Electron.BaseWindow {}\n    class View extends Electron.View {}\n    class WebContentsView extends Electron.WebContentsView {}\n  }\n}\n\ndeclare namespace ElectronInternal {\n  type DeprecationHandler = (message: string) => void;\n  interface DeprecationUtil {\n    warnOnce(oldName: string, newName?: string): () => void;\n    setHandler(handler: DeprecationHandler | null): void;\n    getHandler(): DeprecationHandler | null;\n    warn(oldName: string, newName: string): void;\n    log(message: string): void;\n    removeFunction<T extends Function>(fn: T, removedName: string): T;\n    renameFunction<T extends Function>(fn: T, newName: string): T;\n    event(emitter: NodeJS.EventEmitter, oldName: string, newName: string): void;\n    removeProperty<T, K extends (keyof T & string)>(object: T, propertyName: K, onlyForValues?: any[]): T;\n    renameProperty<T, K extends (keyof T & string)>(object: T, oldName: string, newName: K): T;\n    moveAPI<T extends Function>(fn: T, oldUsage: string, newUsage: string): T;\n  }\n\n  interface DesktopCapturer {\n    startHandling(captureWindow: boolean, captureScreen: boolean, thumbnailSize: Electron.Size, fetchWindowIcons: boolean): void;\n    _onerror?: (error: string) => void;\n    _onfinished?: (sources: Electron.DesktopCapturerSource[], fetchWindowIcons: boolean) => void;\n  }\n\n  interface GetSourcesOptions {\n    captureWindow: boolean;\n    captureScreen: boolean;\n    thumbnailSize: Electron.Size;\n    fetchWindowIcons: boolean;\n  }\n\n  interface GetSourcesResult {\n    id: string;\n    name: string;\n    thumbnail: Electron.NativeImage;\n    display_id: string;\n    appIcon: Electron.NativeImage | null;\n  }\n\n  interface IpcRendererInternal extends Electron.IpcRenderer {\n    invoke<T>(channel: string, ...args: any[]): Promise<T>;\n    onMessageFromMain(channel: string, listener: (event: Electron.IpcRendererEvent, ...args: any[]) => void): this;\n    onceMessageFromMain(channel: string, listener: (event: Electron.IpcRendererEvent, ...args: any[]) => void): this;\n  }\n\n  // Internal IPC has _replyInternal and NO reply method\n  interface IpcMainInternalEvent extends Omit<Electron.IpcMainEvent, 'reply'> {\n  }\n\n  interface IpcMainInternal extends NodeJS.EventEmitter {\n    handle(channel: string, listener: (event: Electron.IpcMainInvokeEvent, ...args: any[]) => Promise<any> | any): void;\n    on(channel: string, listener: (event: IpcMainInternalEvent, ...args: any[]) => void): this;\n    once(channel: string, listener: (event: IpcMainInternalEvent, ...args: any[]) => void): this;\n  }\n\n  interface LoadURLOptions extends Electron.LoadURLOptions {\n    reloadIgnoringCache?: boolean;\n  }\n\n  type ModuleLoader = () => any;\n\n  interface ModuleEntry {\n    name: string;\n    private?: boolean;\n    loader: ModuleLoader;\n  }\n\n  interface WebFrameResizeEvent extends WebViewEvent {\n    newWidth: number;\n    newHeight: number;\n  }\n\n  interface WebViewEvent extends Event {\n    url: string;\n    isMainFrame: boolean;\n  }\n\n  class WebViewElement extends HTMLElement {\n    static observedAttributes: Array<string>;\n\n    public contentWindow: Window;\n\n    public connectedCallback?(): void;\n    public attributeChangedCallback?(): void;\n    public disconnectedCallback?(): void;\n\n    // Created in web-view-impl\n    public getWebContentsId(): number;\n    public capturePage(rect?: Electron.Rectangle): Promise<Electron.NativeImage>;\n  }\n\n  class WebContents extends Electron.WebContents {\n    static create(opts: Electron.WebPreferences): Electron.WebContents;\n  }\n}\n\ndeclare namespace Chrome {\n  namespace Tabs {\n    // https://developer.chrome.com/extensions/tabs#method-executeScript\n    interface ExecuteScriptDetails {\n      code?: string;\n      file?: string;\n      allFrames?: boolean;\n      frameId?: number;\n      matchAboutBlank?: boolean;\n      runAt?: 'document-start' | 'document-end' | 'document_idle';\n      cssOrigin: 'author' | 'user';\n    }\n\n    type ExecuteScriptCallback = (result: Array<any>) => void;\n\n    // https://developer.chrome.com/extensions/tabs#method-sendMessage\n    interface SendMessageDetails {\n      frameId?: number;\n    }\n\n    type SendMessageCallback = (result: any) => void;\n  }\n}\n\ninterface Global extends NodeJS.Global {\n  require: NodeRequire;\n  module: NodeModule;\n  __filename: string;\n  __dirname: string;\n}\n"], "filenames": ["docs/api/structures/ipc-main-event.md", "docs/api/structures/ipc-main-invoke-event.md", "docs/api/web-contents.md", "lib/browser/api/web-contents.ts", "lib/browser/remote/server.ts", "shell/browser/api/electron_api_web_contents.cc", "shell/browser/api/electron_api_web_contents.h", "shell/common/gin_helper/event_emitter.cc", "spec-main/api-ipc-main-spec.ts", "spec-main/fixtures/snapshots/proxy-window-open.snapshot.txt", "spec-main/guest-window-manager-spec.ts", "typings/internal-electron.d.ts"], "buggy_code_start_loc": [2, 2, 1699, 151, 23, 2711, 261, 7, 5, 6, 191, 71], "buggy_code_end_loc": [2, 2, 1700, 461, 483, 2732, 262, 71, 61, 138, 191, 73], "fixing_code_start_loc": [3, 3, 1699, 151, 23, 2711, 261, 8, 6, 6, 192, 71], "fixing_code_end_loc": [4, 4, 1700, 462, 483, 2745, 262, 75, 88, 143, 195, 73], "type": "CWE-668", "message": "The Electron framework lets you write cross-platform desktop applications using JavaScript, HTML and CSS. In affected versions of Electron IPC messages sent from the main process to a subframe in the renderer process, through webContents.sendToFrame, event.reply or when using the remote module, can in some cases be delivered to the wrong frame. If your app uses remote, calls webContents.sendToFrame, or calls event.reply in an IPC message handler then it is impacted by this issue. This has been fixed in versions 9.4.0, 10.2.0, 11.1.0, and 12.0.0-beta.9. There are no workarounds for this issue.", "other": {"cve": {"id": "CVE-2020-26272", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-28T19:15:13.003", "lastModified": "2021-02-04T19:03:18.437", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Electron framework lets you write cross-platform desktop applications using JavaScript, HTML and CSS. In affected versions of Electron IPC messages sent from the main process to a subframe in the renderer process, through webContents.sendToFrame, event.reply or when using the remote module, can in some cases be delivered to the wrong frame. If your app uses remote, calls webContents.sendToFrame, or calls event.reply in an IPC message handler then it is impacted by this issue. This has been fixed in versions 9.4.0, 10.2.0, 11.1.0, and 12.0.0-beta.9. There are no workarounds for this issue."}, {"lang": "es", "value": "El framework Electron le permite escribir aplicaciones de escritorio multiplataforma usando JavaScript, HTML y CSS.&#xa0;En las versiones afectadas de Electron IPC, los mensajes enviados desde el proceso principal a una subtrama en el proceso de renderizado, por medio de webContents.sendToFrame, event.reply o cuando se usa el m\u00f3dulo remoto, en algunos casos pueden enviarse a la trama incorrecta.&#xa0;Si su aplicaci\u00f3n usa remoto, llama a webContents.sendToFrame, o llama a event.reply en un manejador de mensajes de IPC, entonces se ve afectado por este problema.&#xa0;Esto se ha corregido en las versiones 9.4.0, 10.2.0, 11.1.0 y 12.0.0-beta.9.&#xa0;No existen soluciones para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.0.0", "versionEndExcluding": "9.4.0", "matchCriteriaId": "BD8DEA8B-C7B1-4255-8EB4-60EF9660CB6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.0.0", "versionEndExcluding": "10.2.0", "matchCriteriaId": "0FDE1D62-9F3E-41E3-8C5D-C5A200A280A4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.0.0", "versionEndExcluding": "11.1.0", "matchCriteriaId": "01855BDD-98F7-4577-AA6D-B1776EAF9AA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "FB793B7F-1C9D-445D-A849-CB28577CA760"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "0C340AA9-8D81-4927-9447-DFCF0DD385AC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "D8DF366B-644E-4C43-9DF1-37F1ADD36532"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "BAC64CED-4F36-4667-B909-4265DDEBDA3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta13:*:*:*:*:*:*", "matchCriteriaId": "17574861-A808-406A-9B0D-403AD99EA160"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta14:*:*:*:*:*:*", "matchCriteriaId": "79CB734A-05B3-4388-BD8F-ECD3FD699D87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta15:*:*:*:*:*:*", "matchCriteriaId": "7E0E7E72-B138-4E09-BEE0-219643377314"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta16:*:*:*:*:*:*", "matchCriteriaId": "B19F82AA-3660-4AC5-920E-7E36534ADF36"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta17:*:*:*:*:*:*", "matchCriteriaId": "29850E51-1EB9-4E9E-9AAC-ACAC12CDCAB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta18:*:*:*:*:*:*", "matchCriteriaId": "84544C05-24A7-4CDE-B6E1-EC05B6CD9836"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta19:*:*:*:*:*:*", "matchCriteriaId": "A8AF3443-F01C-407F-BEE2-A8E601A09211"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "F962D5DC-C4EE-42C0-9BA8-C17B5ADAE178"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta20:*:*:*:*:*:*", "matchCriteriaId": "EB7A193D-7B1F-45F0-B385-DE8C75D7088D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta21:*:*:*:*:*:*", "matchCriteriaId": "B8453EF9-E063-4398-A637-E70AEA0FC4D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta22:*:*:*:*:*:*", "matchCriteriaId": "3FFBA70C-CEBE-425D-ABF7-4FF070BE1DCD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta23:*:*:*:*:*:*", "matchCriteriaId": "A66951CF-8088-4A74-9E40-1145B3695C0E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta24:*:*:*:*:*:*", "matchCriteriaId": "C4A7E569-0B63-4458-93A9-DC1BF3F708C3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "4BFFB27D-B11F-4F5B-8624-27042F8A664A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "AF67CE0D-79D8-4CCC-8152-6989D681B618"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "965FE481-DC51-4123-B47A-4825E7231B33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "AAC42DF7-3344-4C5C-B01A-B24F7C7FA47A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "5CA4015A-6D70-490E-AEFD-1C64F582F9DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "72B0EAB3-F11C-42B3-8F4A-3D4B652A2740"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:9.0.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "F2F409DE-D2A1-49A6-AA57-D735F4B07D29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "325AEE66-5BB3-4317-904C-CAEF33DA34F9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "FD4B098E-D71A-4770-8A80-75FFCDE5E3A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "D31F3B77-B1FA-4AF6-B78B-3591F0C34A7A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "9A888965-E6AF-4514-83FE-9BFD098A601B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta13:*:*:*:*:*:*", "matchCriteriaId": "D3C4D65F-592A-4BB6-8C76-2157AB4C2B21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta14:*:*:*:*:*:*", "matchCriteriaId": "94ECDC48-11AC-45AA-9A4D-E24DB7713799"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta15:*:*:*:*:*:*", "matchCriteriaId": "806D6913-2852-406A-AF46-E5C7FE62C739"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta17:*:*:*:*:*:*", "matchCriteriaId": "7E63CACD-F4D7-42C5-97AC-295FEF4DEDCB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta19:*:*:*:*:*:*", "matchCriteriaId": "24071397-1BE9-42BC-8BE4-AA3E898BE02B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "B72266CF-A2BE-4C6A-B7AB-9110C2672758"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta20:*:*:*:*:*:*", "matchCriteriaId": "747441F0-DD8C-47FD-B13C-6FEAFE79A160"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta21:*:*:*:*:*:*", "matchCriteriaId": "DEFD1B8C-7777-42C1-BE27-1BC54CF7C65E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta23:*:*:*:*:*:*", "matchCriteriaId": "8DB5AC65-DCFA-4549-B08B-77AAAAC9248E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta24:*:*:*:*:*:*", "matchCriteriaId": "3DB704A9-DD31-400E-A4EE-1A32D0D415D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta25:*:*:*:*:*:*", "matchCriteriaId": "FE4B1A04-EBB1-4C3E-9CE0-5CD487F27303"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "782AD115-2503-4663-9DBC-64DC82C363CE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "C75A9CD8-0E3B-44CF-A828-A5DDD6EBD8B6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "9655B40F-53E5-4F7D-8D8D-85FCFDC3B1FE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "2419A888-4BF2-4548-8ACA-9550B276247E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "353F51BC-7627-48C3-AFBD-E287D7FC9DF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "95FE3E21-1A8A-45D6-B797-903F4D24A460"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:10.0.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "BECA8D37-A00D-4CBA-9195-DAFA9CFE951D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "6B056B81-3764-49FB-A3C3-EA9B3FB763D5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta10:*:*:*:*:*:*", "matchCriteriaId": "FA231DB9-14E3-4BF4-88B6-3AE122993CC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta11:*:*:*:*:*:*", "matchCriteriaId": "D3101022-9B4D-4ABC-8D9A-1B8C74265567"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta12:*:*:*:*:*:*", "matchCriteriaId": "CB419AE9-5DFA-41D9-AB2C-C3CF18F1F08A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta13:*:*:*:*:*:*", "matchCriteriaId": "94A9223E-5B13-4A02-B16D-B6C7612745A3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta14:*:*:*:*:*:*", "matchCriteriaId": "BD90D1EB-DE25-4333-9029-CA8908271264"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta15:*:*:*:*:*:*", "matchCriteriaId": "3DED187D-2AE5-491C-94DE-5C44616DFE12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta16:*:*:*:*:*:*", "matchCriteriaId": "980768C9-026E-4E03-AFE9-17C53B94D8FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta17:*:*:*:*:*:*", "matchCriteriaId": "75049DEC-3563-47AA-9D2A-90C4879D2B03"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta18:*:*:*:*:*:*", "matchCriteriaId": "C5643422-9C2C-4493-A9F1-370945A817C5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta19:*:*:*:*:*:*", "matchCriteriaId": "3108EE52-D993-4CDC-9BD3-2C206F49F61D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta20:*:*:*:*:*:*", "matchCriteriaId": "3B194A32-4E7C-49E8-8C01-929FA26F7DF9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta21:*:*:*:*:*:*", "matchCriteriaId": "0E07C2F2-1219-45BD-89B6-FB41D4A418F3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta22:*:*:*:*:*:*", "matchCriteriaId": "E44904CE-4107-44E0-8EEC-212B2F5CE561"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta23:*:*:*:*:*:*", "matchCriteriaId": "E88A6487-3293-4C46-BE5E-03BA641E0238"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "17001FC8-E8BF-4FB3-B619-598AEBEB3351"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "C662DF3F-FB51-4B87-9133-528B921599E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "F91CE004-5775-4A85-AE15-79928DC4F8F7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "A50A9FEF-50D9-4A6E-A232-6F652D606A8D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "EB9F6591-69DB-4777-9BB8-80E2EB7692BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "C4948E6E-916D-48BE-B238-95936BED449B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:11.0.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "B6CCA15C-7957-4220-A3AB-085D503FF0C6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "7FA70916-C875-466C-8FDE-21E2464E6780"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "7EDDB343-462D-4459-8F91-AF746399017D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "9A030AF7-8CEB-4C9B-AF89-08B30510813E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "6F63EB74-D040-4965-8987-6550559A9A31"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "66D5722B-D0DD-439D-B3F8-F5810B26F5A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "72ED1AF8-FB97-4B42-BB4D-43294E5D3B0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "6C743A41-E619-402A-AEDA-2994DC69B3C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:electronjs:electron:12.0.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "103E66D7-6EF4-4E5E-BFAD-9F223E2F10A3"}]}]}], "references": [{"url": "https://github.com/electron/electron/commit/07a1c2a3e5845901f7e2eda9506695be58edc73c", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/electron/electron/pull/26875", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/electron/electron/releases/tag/v9.4.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/electron/electron/security/advisories/GHSA-hvf8-h2qh-37m9", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.electronjs.org/releases/stable?version=9#9.4.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/electron/electron/commit/07a1c2a3e5845901f7e2eda9506695be58edc73c"}}