{"buggy_code": ["/*\nBSD 2-Clause License\n\nCopyright (c) 2018, lynnl\n\nCleaned up and refactored for r2 in 2021 - 2022: condret\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <r_util.h>\n\nstatic void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}\n\nR_API RRBTree *r_crbtree_new(RRBFree freefn) {\n\tRRBTree *tree = R_NEW0 (RRBTree);\n\tif (tree) {\n\t\ttree->free = freefn;\n\t}\n\treturn tree;\n}\n\nR_API void r_crbtree_clear(RRBTree *tree) {\n\tr_return_if_fail (tree);\n\tRRBNode *iter = tree->root, *save = NULL;\n\n\t// Rotate away the left links into a linked list so that\n\t// we can perform iterative destruction of the rbtree\n\twhile (iter) {\n\t\tif (!iter->link[0]) {\n\t\t\tsave = iter->link[1];\n\t\t\tif (tree->free) {\n\t\t\t\ttree->free (iter->data);\n\t\t\t}\n\t\t\tfree (iter);\n\t\t\ttree->size--;\n\t\t} else {\n\t\t\tsave = iter->link[0];\n\t\t\t_set_link (iter, save->link[1], 0);\n\t\t\t_set_link (save, iter, 1);\n\t\t}\n\t\titer = save;\n\t}\n\ttree->root = NULL;\n}\n\nR_API void r_crbtree_free(RRBTree *tree) {\n\tif (!tree) {\n\t\treturn;\n\t}\n\tr_crbtree_clear (tree);\n\tfree (tree);\n}\n\nR_API RRBNode *r_crbtree_find_node(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\n\tRRBNode *iter = tree->root;\n\twhile (iter) {\n\t\tconst int dir = cmp (data, iter->data, user);\n\t\tif (!dir) {\n\t\t\treturn iter;\n\t\t}\n\t\titer = iter->link[dir > 0];\n\t}\n\treturn NULL;\n}\n\nR_API void *r_crbtree_find(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\tRRBNode *node = r_crbtree_find_node (tree, data, cmp, user);\n\treturn node ? node->data : NULL;\n}\n\nstatic RRBNode *_node_new(void *data, RRBNode *parent) {\n\tRRBNode *node = R_NEW0 (RRBNode);\n\tr_return_val_if_fail (node, NULL);\n\n\tnode->red = 1;\n\tnode->data = data;\n\tnode->parent = parent;\n\n\treturn node;\n}\n\n#define IS_RED(n) ((n) && (n)->red == 1)\n\nstatic RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t// save is new parent of root and root is parent of save's previous child\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\n\troot->red = 1;\n\tsave->red = 0;\n\n\treturn save;\n}\n\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\n}\n\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (tree->root == NULL) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (tree->root == NULL) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}\n\nstatic void _exchange_nodes(RRBNode *node_a, RRBNode *node_b) {\n\tif (!node_a || !node_b) {\n\t\treturn;\n\t}\n\tRRBNode node_a_tmp, node_b_tmp;\n\tmemcpy (&node_a_tmp, node_a, sizeof (RRBNode));\n\tmemcpy (&node_b_tmp, node_b, sizeof (RRBNode));\n\tnode_a->link[0] = node_b_tmp.link[0];\n\tnode_a->link[1] = node_b_tmp.link[1];\n\tnode_a->red = node_b_tmp.red;\n\tnode_b->link[0] = node_a_tmp.link[0];\n\tnode_b->link[1] = node_a_tmp.link[1];\n\tnode_b->red = node_a_tmp.red;\n\tif (node_a->parent == node_b->parent) {\n\t\tif (node_a->parent) {\n\t\t\tif (node_a->parent->link[0] == node_a) {\n\t\t\t\tnode_a->parent->link[0] = node_b;\n\t\t\t\tnode_a->parent->link[1] = node_a;\n\t\t\t} else {\n\t\t\t\tnode_a->parent->link[1] = node_b;\n\t\t\t\tnode_a->parent->link[0] = node_a;\n\t\t\t}\n\t\t}\n\t\tif (node_a->link[0]) {\n\t\t\tnode_a->link[0]->parent = node_a;\n\t\t}\n\t\tif (node_a->link[1]) {\n\t\t\tnode_a->link[1]->parent = node_a;\n\t\t}\n\t\tif (node_b->link[0]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\tif (node_b->link[1]) {\n\t\t\tnode_b->link[1]->parent = node_b;\n\t\t}\n\t\treturn;\n\t}\n\tRRBNode *parent_a = node_a->parent;\n\tRRBNode *parent_b = node_b->parent;\n\tif (parent_a) {\n\t\tif (parent_a->link[0] == node_a) {\n\t\t\tparent_a->link[0] = node_b;\n\t\t} else {\n\t\t\tparent_a->link[1] = node_b;\n\t\t}\n\t}\n\tnode_b->parent = parent_a;\n\tif (parent_b) {\n\t\tif (parent_b->link[0] == node_b) {\n\t\t\tparent_b->link[0] = node_a;\n\t\t} else {\n\t\t\tparent_b->link[1] = node_a;\n\t\t}\n\t}\n\tnode_a->parent = parent_b;\n\tif (node_a->link[0]) {\n\t\tnode_a->link[0]->parent = node_a;\n\t}\n\tif (node_a->link[1]) {\n\t\tnode_a->link[1]->parent = node_a;\n\t}\n\tif (node_b->link[0]) {\n\t\tnode_b->link[0]->parent = node_b;\n\t}\n\tif (node_b->link[1]) {\n\t\tnode_b->link[1]->parent = node_b;\n\t}\n}\n\n// remove data from the tree, without freeing it\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tRRBNode *found = NULL;\n\tint dir = 1, last;\n\n\t_set_link (q, tree->root, 1);\n\n\t/* Find in-order predecessor */\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0 && !found) {\n\t\t\tfound = q;\n\t\t}\n\n\t\tdir = (bool)(dir > 0);\n\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t\tp = p->link[last];\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\t/* Color flip */\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tsibling->red = 1;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ensure correct coloring */\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t\tg->link[dir2]->link[0]->red = 0;\n\t\t\t\t\tg->link[dir2]->link[1]->red = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid *ret = NULL;\n\t/* Replace and remove if found */\n\tif (found) {\n\t\t_set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);\n\t\tif (q != found) {\n\t\t\tq->link[0] = NULL;\n\t\t\tq->link[1] = NULL;\n\t\t\tq->parent = NULL;\n\t\t\t_exchange_nodes (found, q);\n\t\t}\n\t\tret = found->data;\n\t\tfree (found);\n\t\ttree->size--;\n\t}\n\n\t/* Update root node */\n\ttree->root = head.link[1];\n\tif (tree->root) {\n\t\ttree->root->red = 0;\n\t\ttree->root->parent = NULL;\n\t} else {\n\t\tr_return_val_if_fail (tree->size == 0, NULL);\n\t}\n\treturn ret;\n}\n\nR_API bool r_crbtree_delete(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, false);\n\tdata = r_crbtree_take (tree, data, cmp, user);\n\tif (tree->free) {\n\t\ttree->free (data);\n\t}\n\treturn !!data;\n}\n\nR_API RRBNode *r_crbtree_first_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[0]) {\n\t\tnode = node->link[0];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_crbtree_last_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[1]) {\n\t\tnode = node->link[1];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_rbnode_next(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[1]) {\n\t\tnode = node->link[1];\n\t\twhile (node->link[0]) {\n\t\t\tnode = node->link[0];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[1] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n\nR_API RRBNode *r_rbnode_prev(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[0]) {\n\t\tnode = node->link[0];\n\t\twhile (node->link[1]) {\n\t\t\tnode = node->link[1];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[0] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n"], "fixing_code": ["/*\nBSD 2-Clause License\n\nCopyright (c) 2018, lynnl\n\nCleaned up and refactored for r2 in 2021 - 2022: condret\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <r_util.h>\n\nstatic void _set_link(RRBNode *parent, RRBNode *child, const int dir) {\n\tif (parent) {\n\t\tparent->link[dir] = child;\n\t}\n\tif (child) {\n\t\tchild->parent = parent;\n\t}\n}\n\nR_API RRBTree *r_crbtree_new(RRBFree freefn) {\n\tRRBTree *tree = R_NEW0 (RRBTree);\n\tif (tree) {\n\t\ttree->free = freefn;\n\t}\n\treturn tree;\n}\n\nR_API void r_crbtree_clear(RRBTree *tree) {\n\tr_return_if_fail (tree);\n\tRRBNode *iter = tree->root, *save = NULL;\n\n\t// Rotate away the left links into a linked list so that\n\t// we can perform iterative destruction of the rbtree\n\twhile (iter) {\n\t\tif (!iter->link[0]) {\n\t\t\tsave = iter->link[1];\n\t\t\tif (tree->free) {\n\t\t\t\ttree->free (iter->data);\n\t\t\t}\n\t\t\tfree (iter);\n\t\t\ttree->size--;\n\t\t} else {\n\t\t\tsave = iter->link[0];\n\t\t\t_set_link (iter, save->link[1], 0);\n\t\t\t_set_link (save, iter, 1);\n\t\t}\n\t\titer = save;\n\t}\n\ttree->root = NULL;\n}\n\nR_API void r_crbtree_free(RRBTree *tree) {\n\tif (!tree) {\n\t\treturn;\n\t}\n\tr_crbtree_clear (tree);\n\tfree (tree);\n}\n\nR_API RRBNode *r_crbtree_find_node(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\n\tRRBNode *iter = tree->root;\n\twhile (iter) {\n\t\tconst int dir = cmp (data, iter->data, user);\n\t\tif (!dir) {\n\t\t\treturn iter;\n\t\t}\n\t\titer = iter->link[dir > 0];\n\t}\n\treturn NULL;\n}\n\nR_API void *r_crbtree_find(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && cmp, NULL);\n\tRRBNode *node = r_crbtree_find_node (tree, data, cmp, user);\n\treturn node ? node->data : NULL;\n}\n\nstatic RRBNode *_node_new(void *data, RRBNode *parent) {\n\tRRBNode *node = R_NEW0 (RRBNode);\n\tr_return_val_if_fail (node, NULL);\n\n\tnode->red = 1;\n\tnode->data = data;\n\tnode->parent = parent;\n\n\treturn node;\n}\n\n#define IS_RED(n) ((n) && (n)->red == 1)\n\nstatic RRBNode *_rot_once(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t// save is new parent of root and root is parent of save's previous child\n\tRRBNode *save = root->link[!dir];\n\t_set_link (root, save->link[dir], !dir);\n\t_set_link (save, root, dir);\n\n\troot->red = 1;\n\tsave->red = 0;\n\n\treturn save;\n}\n\nstatic RRBNode *_rot_twice(RRBNode *root, int dir) {\n\tr_return_val_if_fail (root, NULL);\n\n\t_set_link (root, _rot_once (root->link[!dir], !dir), !dir);\n\treturn _rot_once (root, dir);\n}\n\nR_API bool r_crbtree_insert(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && cmp, false);\n\tbool inserted = false;\n\n\tif (!tree->root) {\n\t\ttree->root = _node_new (data, NULL);\n\t\tif (!tree->root) {\n\t\t\treturn false;\n\t\t}\n\t\tinserted = true;\n\t\tgoto out_exit;\n\t}\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *g = NULL, *parent = &head; /* Grandparent & parent */\n\tRRBNode *p = NULL, *q = tree->root; /* Iterator & parent */\n\tint dir = 0, last = 0; /* Directions */\n\n\t_set_link (parent, q, 1);\n\n\tfor (;;) {\n\t\tif (!q) {\n\t\t\t/* Insert a node at first null link(also set its parent link) */\n\t\t\tq = _node_new (data, p);\n\t\t\tif (!q) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tp->link[dir] = q;\n\t\t\tinserted = true;\n\t\t} else if (IS_RED (q->link[0]) && IS_RED (q->link[1])) {\n\t\t\t/* Simple red violation: color flip */\n\t\t\tq->red = 1;\n\t\t\tq->link[0]->red = 0;\n\t\t\tq->link[1]->red = 0;\n\t\t}\n\n\t\tif (IS_RED (q) && IS_RED (p)) {\n#if 0\n\t\t\t// coverity error, parent is never null\n\t\t\t/* Hard red violation: rotate */\n\t\t\tif (!parent) {\n\t\t\t\treturn false;\n\t\t\t}\n#endif\n\t\t\tint dir2 = parent->link[1] == g;\n\t\t\tif (q == p->link[last]) {\n\t\t\t\t_set_link (parent, _rot_once (g, !last), dir2);\n\t\t\t} else {\n\t\t\t\t_set_link (parent, _rot_twice (g, !last), dir2);\n\t\t\t}\n\t\t}\n\n\t\tif (inserted) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast = dir;\n\t\tdir = cmp (data, q->data, user) >= 0;\n\n\t\tif (g) {\n\t\t\tparent = g;\n\t\t}\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\t}\n\n\t/* Update root(it may different due to root rotation) */\n\ttree->root = head.link[1];\n\nout_exit:\n\t/* Invariant: root is black */\n\ttree->root->red = 0;\n\ttree->root->parent = NULL;\n\tif (inserted) {\n\t\ttree->size++;\n\t}\n\n\treturn inserted;\n}\n\nstatic void _exchange_nodes(RRBNode *node_a, RRBNode *node_b) {\n\tif (!node_a || !node_b) {\n\t\treturn;\n\t}\n\tRRBNode node_a_tmp, node_b_tmp;\n\tmemcpy (&node_a_tmp, node_a, sizeof (RRBNode));\n\tmemcpy (&node_b_tmp, node_b, sizeof (RRBNode));\n\tnode_a->link[0] = node_b_tmp.link[0];\n\tnode_a->link[1] = node_b_tmp.link[1];\n\tnode_a->red = node_b_tmp.red;\n\tnode_b->link[0] = node_a_tmp.link[0];\n\tnode_b->link[1] = node_a_tmp.link[1];\n\tnode_b->red = node_a_tmp.red;\n\tif (node_a->parent == node_b->parent) {\n\t\tif (node_a->parent) {\n\t\t\tif (node_a->parent->link[0] == node_a) {\n\t\t\t\tnode_a->parent->link[0] = node_b;\n\t\t\t\tnode_a->parent->link[1] = node_a;\n\t\t\t} else {\n\t\t\t\tnode_a->parent->link[1] = node_b;\n\t\t\t\tnode_a->parent->link[0] = node_a;\n\t\t\t}\n\t\t}\n\t\tif (node_a->link[0]) {\n\t\t\tnode_a->link[0]->parent = node_a;\n\t\t}\n\t\tif (node_a->link[1]) {\n\t\t\tnode_a->link[1]->parent = node_a;\n\t\t}\n\t\tif (node_b->link[0]) {\n\t\t\tnode_b->link[0]->parent = node_b;\n\t\t}\n\t\tif (node_b->link[1]) {\n\t\t\tnode_b->link[1]->parent = node_b;\n\t\t}\n\t\treturn;\n\t}\n\tRRBNode *parent_a = node_a->parent;\n\tRRBNode *parent_b = node_b->parent;\n\tif (parent_a) {\n\t\tif (parent_a->link[0] == node_a) {\n\t\t\tparent_a->link[0] = node_b;\n\t\t} else {\n\t\t\tparent_a->link[1] = node_b;\n\t\t}\n\t}\n\tnode_b->parent = parent_a;\n\tif (parent_b) {\n\t\tif (parent_b->link[0] == node_b) {\n\t\t\tparent_b->link[0] = node_a;\n\t\t} else {\n\t\t\tparent_b->link[1] = node_a;\n\t\t}\n\t}\n\tnode_a->parent = parent_b;\n\tif (node_a->link[0]) {\n\t\tnode_a->link[0]->parent = node_a;\n\t}\n\tif (node_a->link[1]) {\n\t\tnode_a->link[1]->parent = node_a;\n\t}\n\tif (node_b->link[0]) {\n\t\tnode_b->link[0]->parent = node_b;\n\t}\n\tif (node_b->link[1]) {\n\t\tnode_b->link[1]->parent = node_b;\n\t}\n}\n\n// remove data from the tree, without freeing it\nR_API void *r_crbtree_take(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, NULL);\n\n\tRRBNode head; /* Fake tree root */\n\tmemset (&head, 0, sizeof (RRBNode));\n\tRRBNode *q = &head, *p = NULL, *g = NULL;\n\tRRBNode *found = NULL;\n\tint dir = 1, last;\n\n\t_set_link (q, tree->root, 1);\n\n\t/* Find in-order predecessor */\n\twhile (q->link[dir]) {\n\t\tlast = dir;\n\n\t\tg = p;\n\t\tp = q;\n\t\tq = q->link[dir];\n\n\t\tdir = cmp (data, q->data, user);\n\t\tif (dir == 0 && !found) {\n\t\t\tfound = q;\n\t\t}\n\n\t\tdir = (bool)(dir > 0);\n\n\t\tif (IS_RED (q) || IS_RED (q->link[dir])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (IS_RED (q->link[!dir])) {\n\t\t\t_set_link (p, _rot_once (q, dir), last);\n\t\t\tp = p->link[last];\n\t\t} else {\n\t\t\tRRBNode *sibling = p->link[!last];\n\t\t\tif (sibling) {\n\t\t\t\tif (!IS_RED (sibling->link[!last]) && !IS_RED (sibling->link[last])) {\n\t\t\t\t\t/* Color flip */\n\t\t\t\t\tp->red = 0;\n\t\t\t\t\tsibling->red = 1;\n\t\t\t\t\tq->red = 1;\n\t\t\t\t} else if (g) {\n\t\t\t\t\tint dir2 = (bool)(g->link[1] == p);\n\n\t\t\t\t\tif (IS_RED (sibling->link[last])) {\n\t\t\t\t\t\t_set_link (g, _rot_twice (p, last), dir2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_set_link (g, _rot_once (p, last), dir2);\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Ensure correct coloring */\n\t\t\t\t\tq->red = g->link[dir2]->red = 1;\n\t\t\t\t\tg->link[dir2]->link[0]->red = 0;\n\t\t\t\t\tg->link[dir2]->link[1]->red = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid *ret = NULL;\n\t/* Replace and remove if found */\n\tif (found) {\n\t\t_set_link (p, q->link[q->link[0] == NULL], p->link[1] == q);\n\t\tif (q != found) {\n\t\t\tq->link[0] = NULL;\n\t\t\tq->link[1] = NULL;\n\t\t\tq->parent = NULL;\n\t\t\t_exchange_nodes (found, q);\n\t\t}\n\t\tret = found->data;\n\t\tfree (found);\n\t\ttree->size--;\n\t}\n\n\t/* Update root node */\n\ttree->root = head.link[1];\n\tif (tree->root) {\n\t\ttree->root->red = 0;\n\t\ttree->root->parent = NULL;\n\t} else {\n\t\tr_return_val_if_fail (tree->size == 0, NULL);\n\t}\n\treturn ret;\n}\n\nR_API bool r_crbtree_delete(RRBTree *tree, void *data, RRBComparator cmp, void *user) {\n\tr_return_val_if_fail (tree && data && tree->size && tree->root && cmp, false);\n\tdata = r_crbtree_take (tree, data, cmp, user);\n\tif (tree->free) {\n\t\ttree->free (data);\n\t}\n\treturn !!data;\n}\n\nR_API RRBNode *r_crbtree_first_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[0]) {\n\t\tnode = node->link[0];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_crbtree_last_node(RRBTree *tree) {\n\tr_return_val_if_fail (tree, NULL);\n\tif (!tree->root) {\n\t\t// empty tree\n\t\treturn NULL;\n\t}\n\tRRBNode *node = tree->root;\n\twhile (node->link[1]) {\n\t\tnode = node->link[1];\n\t}\n\treturn node;\n}\n\nR_API RRBNode *r_rbnode_next(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[1]) {\n\t\tnode = node->link[1];\n\t\twhile (node->link[0]) {\n\t\t\tnode = node->link[0];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[1] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n\nR_API RRBNode *r_rbnode_prev(RRBNode *node) {\n\tr_return_val_if_fail (node, NULL);\n\tif (node->link[0]) {\n\t\tnode = node->link[0];\n\t\twhile (node->link[1]) {\n\t\t\tnode = node->link[1];\n\t\t}\n\t\treturn node;\n\t}\n\tRRBNode *parent = node->parent;\n\twhile (parent && parent->link[0] == node) {\n\t\tnode = parent;\n\t\tparent = node->parent;\n\t}\n\treturn parent;\n}\n"], "filenames": ["libr/util/new_rbtree.c"], "buggy_code_start_loc": [141], "buggy_code_end_loc": [144], "fixing_code_start_loc": [141], "fixing_code_end_loc": [144], "type": "CWE-416", "message": "heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.7.0. This vulnerability is capable of inducing denial of service.", "other": {"cve": {"id": "CVE-2022-1444", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-23T22:15:07.657", "lastModified": "2022-05-04T15:22:32.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "heap-use-after-free in GitHub repository radareorg/radare2 prior to 5.7.0. This vulnerability is capable of inducing denial of service."}, {"lang": "es", "value": "Un uso de memoria previamente liberada en el repositorio GitHub radareorg/radare2 versiones anteriores a 5.7.0. Esta vulnerabilidad es capaz de inducir una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.7.0", "matchCriteriaId": "A79BEA4D-5D5F-4593-B2CA-0CA4C22C1C0A"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b438a940-f8a4-4872-b030-59bdd1ab72aa", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/14189710859c27981adb4c2c2aed2863c1859ec5"}}