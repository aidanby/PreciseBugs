{"buggy_code": ["/* Copyright (C) 2001-2020 Artifex Software, Inc.\n   All Rights Reserved.\n\n   This software is provided AS-IS with no warranty, either express or\n   implied.\n\n   This software is distributed under license and may not be copied,\n   modified or distributed except as expressly authorized under the terms\n   of the license contained in the file LICENSE in this distribution.\n\n   Refer to licensing information at http://www.artifex.com or contact\n   Artifex Software, Inc.,  1305 Grant Avenue - Suite 200, Novato,\n   CA 94945, U.S.A., +1(415)492-9861, for further information.\n*/\n\n\n/* String operators */\n#include \"memory_.h\"\n#include \"ghost.h\"\n#include \"gsutil.h\"\n#include \"ialloc.h\"\n#include \"iname.h\"\n#include \"ivmspace.h\"\n#include \"oper.h\"\n#include \"store.h\"\n\n/* The generic operators (copy, get, put, getinterval, putinterval, */\n/* length, and forall) are implemented in zgeneric.c. */\n\n/* <int> .bytestring <bytestring> */\nstatic int\nzbytestring(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    byte *sbody;\n    uint size;\n\n    check_int_leu(*op, max_int);\n    size = (uint)op->value.intval;\n    sbody = ialloc_bytes(size, \".bytestring\");\n    if (sbody == 0)\n        return_error(gs_error_VMerror);\n    make_astruct(op, a_all | icurrent_space, sbody);\n    memset(sbody, 0, size);\n    return 0;\n}\n\n/* <int> string <string> */\nint\nzstring(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    byte *sbody;\n    uint size;\n\n    check_type(*op, t_integer);\n    if (op->value.intval < 0 )\n        return_error(gs_error_rangecheck);\n    if (op->value.intval > max_string_size )\n        return_error(gs_error_limitcheck); /* to match Distiller */\n    size = op->value.intval;\n    sbody = ialloc_string(size, \"string\");\n    if (sbody == 0)\n        return_error(gs_error_VMerror);\n    make_string(op, a_all | icurrent_space, size, sbody);\n    memset(sbody, 0, size);\n    return 0;\n}\n\n/* <name> .namestring <string> */\nstatic int\nznamestring(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n\n    check_type(*op, t_name);\n    name_string_ref(imemory, op, op);\n    return 0;\n}\n\n/* <string> <pattern> anchorsearch <post> <match> -true- */\n/* <string> <pattern> anchorsearch <string> -false- */\nstatic int\nzanchorsearch(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n\n    check_read_type(*op, t_string);\n    check_read_type(*op1, t_string);\n    if (size <= r_size(op1) && !memcmp(op1->value.bytes, op->value.bytes, size)) {\n        os_ptr op0 = op;\n\n        push(1);\n        *op0 = *op1;\n        r_set_size(op0, size);\n        op1->value.bytes += size;\n        r_dec_size(op1, size);\n        make_true(op);\n    } else\n        make_false(op);\n    return 0;\n}\n\n/* <string> <pattern> (r)search <post> <match> <pre> -true- */\n/* <string> <pattern> (r)search <string> -false- */\nstatic int\nsearch_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\n    r_set_size(op, size);\n    push(2);\n    op[-1] = *op1;\n    r_set_size(op - 1, ptr - op[-1].value.bytes);\n    op1->value.bytes = ptr + size;\n    r_set_size(op1, count + (!forward ? (size - 1) : 0));\n    make_true(op);\n    return 0;\n}\n\n/* Search from the start of the string */\nstatic int\nzsearch(i_ctx_t *i_ctx_p)\n{\n    return search_impl(i_ctx_p, true);\n}\n\n/* Search from the end of the string */\nstatic int\nzrsearch(i_ctx_t *i_ctx_p)\n{\n    return search_impl(i_ctx_p, false);\n}\n\n/* <string> <charstring> .stringbreak <int|null> */\nstatic int\nzstringbreak(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint i, j;\n\n    check_read_type(op[-1], t_string);\n    check_read_type(*op, t_string);\n    /* We can't use strpbrk here, because C doesn't allow nulls in strings. */\n    for (i = 0; i < r_size(op - 1); ++i)\n        for (j = 0; j < r_size(op); ++j)\n            if (op[-1].value.const_bytes[i] == op->value.const_bytes[j]) {\n                make_int(op - 1, i);\n                goto done;\n            }\n    make_null(op - 1);\n done:\n    pop(1);\n    return 0;\n}\n\n/* <obj> <pattern> .stringmatch <bool> */\nstatic int\nzstringmatch(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    bool result;\n\n    check_read_type(*op, t_string);\n    switch (r_type(op1)) {\n        case t_string:\n            check_read(*op1);\n            goto cmp;\n        case t_name:\n            name_string_ref(imemory, op1, op1);\t/* can't fail */\ncmp:\n            result = string_match(op1->value.const_bytes, r_size(op1),\n                                  op->value.const_bytes, r_size(op),\n                                  NULL);\n            break;\n        default:\n            result = (r_size(op) == 1 && *op->value.bytes == '*');\n    }\n    make_bool(op1, result);\n    pop(1);\n    return 0;\n}\n\n/* ------ Initialization procedure ------ */\n\nconst op_def zstring_op_defs[] =\n{\n    {\"1.bytestring\", zbytestring},\n    {\"2anchorsearch\", zanchorsearch},\n    {\"1.namestring\", znamestring},\n    {\"2search\", zsearch},\n    {\"2rsearch\", zrsearch},\n    {\"1string\", zstring},\n    {\"2.stringbreak\", zstringbreak},\n    {\"2.stringmatch\", zstringmatch},\n    op_def_end(0)\n};\n"], "fixing_code": ["/* Copyright (C) 2001-2020 Artifex Software, Inc.\n   All Rights Reserved.\n\n   This software is provided AS-IS with no warranty, either express or\n   implied.\n\n   This software is distributed under license and may not be copied,\n   modified or distributed except as expressly authorized under the terms\n   of the license contained in the file LICENSE in this distribution.\n\n   Refer to licensing information at http://www.artifex.com or contact\n   Artifex Software, Inc.,  1305 Grant Avenue - Suite 200, Novato,\n   CA 94945, U.S.A., +1(415)492-9861, for further information.\n*/\n\n\n/* String operators */\n#include \"memory_.h\"\n#include \"ghost.h\"\n#include \"gsutil.h\"\n#include \"ialloc.h\"\n#include \"iname.h\"\n#include \"ivmspace.h\"\n#include \"oper.h\"\n#include \"store.h\"\n\n/* The generic operators (copy, get, put, getinterval, putinterval, */\n/* length, and forall) are implemented in zgeneric.c. */\n\n/* <int> .bytestring <bytestring> */\nstatic int\nzbytestring(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    byte *sbody;\n    uint size;\n\n    check_int_leu(*op, max_int);\n    size = (uint)op->value.intval;\n    sbody = ialloc_bytes(size, \".bytestring\");\n    if (sbody == 0)\n        return_error(gs_error_VMerror);\n    make_astruct(op, a_all | icurrent_space, sbody);\n    memset(sbody, 0, size);\n    return 0;\n}\n\n/* <int> string <string> */\nint\nzstring(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    byte *sbody;\n    uint size;\n\n    check_type(*op, t_integer);\n    if (op->value.intval < 0 )\n        return_error(gs_error_rangecheck);\n    if (op->value.intval > max_string_size )\n        return_error(gs_error_limitcheck); /* to match Distiller */\n    size = op->value.intval;\n    sbody = ialloc_string(size, \"string\");\n    if (sbody == 0)\n        return_error(gs_error_VMerror);\n    make_string(op, a_all | icurrent_space, size, sbody);\n    memset(sbody, 0, size);\n    return 0;\n}\n\n/* <name> .namestring <string> */\nstatic int\nznamestring(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n\n    check_type(*op, t_name);\n    name_string_ref(imemory, op, op);\n    return 0;\n}\n\n/* <string> <pattern> anchorsearch <post> <match> -true- */\n/* <string> <pattern> anchorsearch <string> -false- */\nstatic int\nzanchorsearch(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n\n    check_read_type(*op, t_string);\n    check_read_type(*op1, t_string);\n    if (size <= r_size(op1) && !memcmp(op1->value.bytes, op->value.bytes, size)) {\n        os_ptr op0 = op;\n\n        push(1);\n        *op0 = *op1;\n        r_set_size(op0, size);\n        op1->value.bytes += size;\n        r_dec_size(op1, size);\n        make_true(op);\n    } else\n        make_false(op);\n    return 0;\n}\n\n/* <string> <pattern> (r)search <post> <match> <pre> -true- */\n/* <string> <pattern> (r)search <string> -false- */\nstatic int\nsearch_impl(i_ctx_t *i_ctx_p, bool forward)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    uint size = r_size(op);\n    uint count;\n    byte *pat;\n    byte *ptr;\n    byte ch;\n    int incr = forward ? 1 : -1;\n\n    check_read_type(*op1, t_string);\n    check_read_type(*op, t_string);\n    if (size > r_size(op1)) {\t/* can't match */\n        make_false(op);\n        return 0;\n    }\n    count = r_size(op1) - size;\n    ptr = op1->value.bytes;\n    if (size == 0)\n        goto found;\n    if (!forward)\n        ptr += count;\n    pat = op->value.bytes;\n    ch = pat[0];\n    do {\n        if (*ptr == ch && (size == 1 || !memcmp(ptr, pat, size)))\n            goto found;\n        ptr += incr;\n    }\n    while (count--);\n    /* No match */\n    make_false(op);\n    return 0;\nfound:\n    op->tas.type_attrs = op1->tas.type_attrs;\n    op->value.bytes = ptr;\t\t\t\t/* match */\n    op->tas.rsize = size;\t\t\t\t/* match */\n    push(2);\n    op[-1] = *op1;\t\t\t\t\t/* pre */\n    op[-3].value.bytes = ptr + size;\t\t\t/* post */\n    if (forward) {\n        op[-1].tas.rsize = ptr - op[-1].value.bytes;\t/* pre */\n        op[-3].tas.rsize = count;\t\t\t/* post */\n    } else {\n        op[-1].tas.rsize = count;\t\t\t/* pre */\n        op[-3].tas.rsize -= count + size;\t\t/* post */\n    }\n    make_true(op);\n    return 0;\n}\n\n/* Search from the start of the string */\nstatic int\nzsearch(i_ctx_t *i_ctx_p)\n{\n    return search_impl(i_ctx_p, true);\n}\n\n/* Search from the end of the string */\nstatic int\nzrsearch(i_ctx_t *i_ctx_p)\n{\n    return search_impl(i_ctx_p, false);\n}\n\n/* <string> <charstring> .stringbreak <int|null> */\nstatic int\nzstringbreak(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    uint i, j;\n\n    check_read_type(op[-1], t_string);\n    check_read_type(*op, t_string);\n    /* We can't use strpbrk here, because C doesn't allow nulls in strings. */\n    for (i = 0; i < r_size(op - 1); ++i)\n        for (j = 0; j < r_size(op); ++j)\n            if (op[-1].value.const_bytes[i] == op->value.const_bytes[j]) {\n                make_int(op - 1, i);\n                goto done;\n            }\n    make_null(op - 1);\n done:\n    pop(1);\n    return 0;\n}\n\n/* <obj> <pattern> .stringmatch <bool> */\nstatic int\nzstringmatch(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    os_ptr op1 = op - 1;\n    bool result;\n\n    check_read_type(*op, t_string);\n    switch (r_type(op1)) {\n        case t_string:\n            check_read(*op1);\n            goto cmp;\n        case t_name:\n            name_string_ref(imemory, op1, op1);\t/* can't fail */\ncmp:\n            result = string_match(op1->value.const_bytes, r_size(op1),\n                                  op->value.const_bytes, r_size(op),\n                                  NULL);\n            break;\n        default:\n            result = (r_size(op) == 1 && *op->value.bytes == '*');\n    }\n    make_bool(op1, result);\n    pop(1);\n    return 0;\n}\n\n/* ------ Initialization procedure ------ */\n\nconst op_def zstring_op_defs[] =\n{\n    {\"1.bytestring\", zbytestring},\n    {\"2anchorsearch\", zanchorsearch},\n    {\"1.namestring\", znamestring},\n    {\"2search\", zsearch},\n    {\"2rsearch\", zrsearch},\n    {\"1string\", zstring},\n    {\"2.stringbreak\", zstringbreak},\n    {\"2.stringmatch\", zstringmatch},\n    op_def_end(0)\n};\n"], "filenames": ["psi/zstring.c"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [152], "fixing_code_start_loc": [145], "fixing_code_end_loc": [157], "type": "CWE-191", "message": "A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b.", "other": {"cve": {"id": "CVE-2020-15900", "sourceIdentifier": "cve@mitre.org", "published": "2020-07-28T16:15:12.840", "lastModified": "2022-04-27T16:28:15.963", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A memory corruption issue was found in Artifex Ghostscript 9.50 and 9.52. Use of a non-standard PostScript operator can allow overriding of file access controls. The 'rsearch' calculation for the 'post' size resulted in a size that was too large, and could underflow to max uint32_t. This was fixed in commit 5d499272b95a6b890a1397e11d20937de000d31b."}, {"lang": "es", "value": "Se encontr\u00f3 un problema de corrupci\u00f3n de memoria en Artifex Ghostscript versiones 9.50 y 9.52. El uso de un operador PostScript no est\u00e1ndar puede permitir la anulaci\u00f3n de los controles de acceso de archivos. El c\u00e1lculo de \"rsearch\" para el tama\u00f1o de \"post\" result\u00f3 en un tama\u00f1o que era demasiado grande y podr\u00eda llegar a un m\u00e1ximo de uint32_t. Esto se corrigi\u00f3 en commit 5d499272b95a6b890a1397e11d20937de000d31b"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-191"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:artifex:ghostscript:9.50:*:*:*:*:*:*:*", "matchCriteriaId": "089333A5-72AA-4E68-8A8E-81876AAC9DD3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:artifex:ghostscript:9.52:*:*:*:*:*:*:*", "matchCriteriaId": "BF20A2FF-98ED-45EF-9263-D915D7A1953D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://git.ghostscript.com/?p=ghostpdl.git;a=log", "source": "cve@mitre.org", "tags": ["Mailing List", "Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-08/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-08/msg00006.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://artifex.com/security-advisories/CVE-2020-15900", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=5d499272b95a6b890a1397e11d20937de000d31b", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ArtifexSoftware/ghostpdl/commits/master/psi/zstring.c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202008-20", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4445-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/5d499272b95a6b890a1397e11d20937de000d31b"}}