{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n */\n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"nfs4session.h\"\n#include \"nfs4idmap.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_CLIENT\n\n/*\n * Get a unique NFSv4.0 callback identifier which will be used\n * by the V4.0 callback service to lookup the nfs_client struct\n */\nstatic int nfs_get_cb_ident_idr(struct nfs_client *clp, int minorversion)\n{\n\tint ret = 0;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (clp->rpc_ops->version != 4 || minorversion != 0)\n\t\treturn ret;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&nn->nfs_client_lock);\n\tret = idr_alloc(&nn->cb_ident_idr, clp, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0)\n\t\tclp->cl_cb_ident = ret;\n\tspin_unlock(&nn->nfs_client_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Per auth flavor data server rpc clients\n */\nstruct nfs4_ds_server {\n\tstruct list_head\tlist;   /* ds_clp->cl_ds_clients */\n\tstruct rpc_clnt\t\t*rpc_clnt;\n};\n\n/**\n * nfs4_find_ds_client - Common lookup case for DS I/O\n * @ds_clp: pointer to the DS's nfs_client\n * @flavor: rpc auth flavour to match\n */\nstatic struct nfs4_ds_server *\nnfs4_find_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\n{\n\tstruct nfs4_ds_server *dss;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dss, &ds_clp->cl_ds_clients, list) {\n\t\tif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tdss = NULL;\nout:\n\trcu_read_unlock();\n\treturn dss;\n}\n\nstatic struct nfs4_ds_server *\nnfs4_add_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor,\n\t\t\t   struct nfs4_ds_server *new)\n{\n\tstruct nfs4_ds_server *dss;\n\n\tspin_lock(&ds_clp->cl_lock);\n\tlist_for_each_entry(dss, &ds_clp->cl_ds_clients, list) {\n\t\tif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tif (new)\n\t\tlist_add_rcu(&new->list, &ds_clp->cl_ds_clients);\n\tdss = new;\nout:\n\tspin_unlock(&ds_clp->cl_lock); /* need some lock to protect list */\n\treturn dss;\n}\n\nstatic struct nfs4_ds_server *\nnfs4_alloc_ds_server(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\n{\n\tstruct nfs4_ds_server *dss;\n\n\tdss = kmalloc(sizeof(*dss), GFP_NOFS);\n\tif (dss == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdss->rpc_clnt = rpc_clone_client_set_auth(ds_clp->cl_rpcclient, flavor);\n\tif (IS_ERR(dss->rpc_clnt)) {\n\t\tint err = PTR_ERR(dss->rpc_clnt);\n\t\tkfree (dss);\n\t\treturn ERR_PTR(err);\n\t}\n\tINIT_LIST_HEAD(&dss->list);\n\n\treturn dss;\n}\n\nstatic void\nnfs4_free_ds_server(struct nfs4_ds_server *dss)\n{\n\trpc_release_client(dss->rpc_clnt);\n\tkfree(dss);\n}\n\n/**\n * nfs4_find_or_create_ds_client - Find or create a DS rpc client\n * @ds_clp: pointer to the DS's nfs_client\n * @inode: pointer to the inode\n *\n * Find or create a DS rpc client with th MDS server rpc client auth flavor\n * in the nfs_client cl_ds_clients list.\n */\nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}\nEXPORT_SYMBOL_GPL(nfs4_find_or_create_ds_client);\n\nstatic void\nnfs4_shutdown_ds_clients(struct nfs_client *clp)\n{\n\tstruct nfs4_ds_server *dss;\n\n\twhile (!list_empty(&clp->cl_ds_clients)) {\n\t\tdss = list_entry(clp->cl_ds_clients.next,\n\t\t\t\t\tstruct nfs4_ds_server, list);\n\t\tlist_del(&dss->list);\n\t\trpc_shutdown_client(dss->rpc_clnt);\n\t\tkfree (dss);\n\t}\n}\n\nstatic void\nnfs4_cleanup_callback(struct nfs_client *clp)\n{\n\tstruct nfs4_copy_state *cp_state;\n\n\twhile (!list_empty(&clp->pending_cb_stateids)) {\n\t\tcp_state = list_entry(clp->pending_cb_stateids.next,\n\t\t\t\t\tstruct nfs4_copy_state, copies);\n\t\tlist_del(&cp_state->copies);\n\t\tkfree(cp_state);\n\t}\n}\n\nvoid nfs41_shutdown_client(struct nfs_client *clp)\n{\n\tif (nfs4_has_session(clp)) {\n\t\tnfs4_cleanup_callback(clp);\n\t\tnfs4_shutdown_ds_clients(clp);\n\t\tnfs4_destroy_session(clp->cl_session);\n\t\tnfs4_destroy_clientid(clp);\n\t}\n\n}\n#endif\t/* CONFIG_NFS_V4_1 */\n\nvoid nfs40_shutdown_client(struct nfs_client *clp)\n{\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_shutdown_slot_table(clp->cl_slot_tbl);\n\t\tkfree(clp->cl_slot_tbl);\n\t}\n}\n\nstruct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tint err;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\treturn clp;\n\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}\n\n/*\n * Destroy the NFS4 callback service\n */\nstatic void nfs4_destroy_callback(struct nfs_client *clp)\n{\n\tif (__test_and_clear_bit(NFS_CS_CALLBACK, &clp->cl_res_state))\n\t\tnfs_callback_down(clp->cl_mvops->minor_version, clp->cl_net);\n}\n\nstatic void nfs4_shutdown_client(struct nfs_client *clp)\n{\n\tif (__test_and_clear_bit(NFS_CS_RENEWD, &clp->cl_res_state))\n\t\tnfs4_kill_renewd(clp);\n\tclp->cl_mvops->shutdown_client(clp);\n\tnfs4_destroy_callback(clp);\n\tif (__test_and_clear_bit(NFS_CS_IDMAP, &clp->cl_res_state))\n\t\tnfs_idmap_delete(clp);\n\n\trpc_destroy_wait_queue(&clp->cl_rpcwaitq);\n\tkfree(clp->cl_serverowner);\n\tkfree(clp->cl_serverscope);\n\tkfree(clp->cl_implid);\n\tkfree(clp->cl_owner_id);\n}\n\nvoid nfs4_free_client(struct nfs_client *clp)\n{\n\tnfs4_shutdown_client(clp);\n\tnfs_free_client(clp);\n}\n\n/*\n * Initialize the NFS4 callback service\n */\nstatic int nfs4_init_callback(struct nfs_client *clp)\n{\n\tstruct rpc_xprt *xprt;\n\tint error;\n\n\txprt = rcu_dereference_raw(clp->cl_rpcclient->cl_xprt);\n\n\tif (nfs4_has_session(clp)) {\n\t\terror = xprt_setup_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = nfs_callback_up(clp->cl_mvops->minor_version, xprt);\n\tif (error < 0) {\n\t\tdprintk(\"%s: failed to start callback. Error = %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\t__set_bit(NFS_CS_CALLBACK, &clp->cl_res_state);\n\n\treturn 0;\n}\n\n/**\n * nfs40_init_client - nfs_client initialization tasks for NFSv4.0\n * @clp: nfs_client to initialize\n *\n * Returns zero on success, or a negative errno if some error occurred.\n */\nint nfs40_init_client(struct nfs_client *clp)\n{\n\tstruct nfs4_slot_table *tbl;\n\tint ret;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_NOFS);\n\tif (tbl == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nfs4_setup_slot_table(tbl, NFS4_MAX_SLOT_TABLE,\n\t\t\t\t\t\"NFSv4.0 transport Slot table\");\n\tif (ret) {\n\t\tkfree(tbl);\n\t\treturn ret;\n\t}\n\n\tclp->cl_slot_tbl = tbl;\n\treturn 0;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\n/**\n * nfs41_init_client - nfs_client initialization tasks for NFSv4.1+\n * @clp: nfs_client to initialize\n *\n * Returns zero on success, or a negative errno if some error occurred.\n */\nint nfs41_init_client(struct nfs_client *clp)\n{\n\tstruct nfs4_session *session = NULL;\n\n\t/*\n\t * Create the session and mark it expired.\n\t * When a SEQUENCE operation encounters the expired session\n\t * it will do session recovery to initialize it.\n\t */\n\tsession = nfs4_alloc_session(clp);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tclp->cl_session = session;\n\n\t/*\n\t * The create session reply races with the server back\n\t * channel probe. Mark the client NFS_CS_SESSION_INITING\n\t * so that the client back channel can find the\n\t * nfs_client struct\n\t */\n\tnfs_mark_client_ready(clp, NFS_CS_SESSION_INITING);\n\treturn 0;\n}\n\n#endif\t/* CONFIG_NFS_V4_1 */\n\n/*\n * Initialize the minor version specific parts of an NFS4 client record\n */\nstatic int nfs4_init_client_minor_version(struct nfs_client *clp)\n{\n\tint ret;\n\n\tret = clp->cl_mvops->init_client(clp);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_init_callback(clp);\n}\n\n/**\n * nfs4_init_client - Initialise an NFS4 client record\n *\n * @clp: nfs_client to initialise\n * @cl_init: pointer to nfs_client_initdata\n *\n * Returns pointer to an NFS client, or an ERR_PTR value.\n */\nstruct nfs_client *nfs4_init_client(struct nfs_client *clp,\n\t\t\t\t    const struct nfs_client_initdata *cl_init)\n{\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tconst char *ip_addr = cl_init->ip_addr;\n\tstruct nfs_client *old;\n\tint error;\n\n\tif (clp->cl_cons_state == NFS_CS_READY)\n\t\t/* the client is initialised already */\n\t\treturn clp;\n\n\t/* Check NFS protocol revision and initialize RPC op vector */\n\tclp->rpc_ops = &nfs_v4_clientops;\n\n\tif (clp->cl_minorversion != 0)\n\t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);\n\t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);\n\t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);\n\n\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);\n\tif (error == -EINVAL)\n\t\terror = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);\n\tif (error < 0)\n\t\tgoto error;\n\n\t/* If no clientaddr= option was specified, find a usable cb address */\n\tif (ip_addr == NULL) {\n\t\tstruct sockaddr_storage cb_addr;\n\t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;\n\n\t\terror = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));\n\t\tif (error < 0)\n\t\t\tgoto error;\n\t\terror = rpc_ntop(sap, buf, sizeof(buf));\n\t\tif (error < 0)\n\t\t\tgoto error;\n\t\tip_addr = (const char *)buf;\n\t}\n\tstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));\n\n\terror = nfs_idmap_new(clp);\n\tif (error < 0) {\n\t\tdprintk(\"%s: failed to create idmapper. Error = %d\\n\",\n\t\t\t__func__, error);\n\t\tgoto error;\n\t}\n\t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);\n\n\terror = nfs4_init_client_minor_version(clp);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs4_discover_server_trunking(clp, &old);\n\tif (error < 0)\n\t\tgoto error;\n\n\tif (clp != old) {\n\t\tclp->cl_preserve_clid = true;\n\t\t/*\n\t\t * Mark the client as having failed initialization so other\n\t\t * processes walking the nfs_client_list in nfs_match_client()\n\t\t * won't try to use it.\n\t\t */\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t}\n\tclear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);\n\tnfs_put_client(clp);\n\treturn old;\n\nerror:\n\tnfs_mark_client_ready(clp, error);\n\tnfs_put_client(clp);\n\treturn ERR_PTR(error);\n}\n\n/*\n * SETCLIENTID just did a callback update with the callback ident in\n * \"drop,\" but server trunking discovery claims \"drop\" and \"keep\" are\n * actually the same server.  Swap the callback IDs so that \"keep\"\n * will continue to use the callback ident the server now knows about,\n * and so that \"keep\"'s original callback ident is destroyed when\n * \"drop\" is freed.\n */\nstatic void nfs4_swap_callback_idents(struct nfs_client *keep,\n\t\t\t\t      struct nfs_client *drop)\n{\n\tstruct nfs_net *nn = net_generic(keep->cl_net, nfs_net_id);\n\tunsigned int save = keep->cl_cb_ident;\n\n\tif (keep->cl_cb_ident == drop->cl_cb_ident)\n\t\treturn;\n\n\tdprintk(\"%s: keeping callback ident %u and dropping ident %u\\n\",\n\t\t__func__, keep->cl_cb_ident, drop->cl_cb_ident);\n\n\tspin_lock(&nn->nfs_client_lock);\n\n\tidr_replace(&nn->cb_ident_idr, keep, drop->cl_cb_ident);\n\tkeep->cl_cb_ident = drop->cl_cb_ident;\n\n\tidr_replace(&nn->cb_ident_idr, drop, save);\n\tdrop->cl_cb_ident = save;\n\n\tspin_unlock(&nn->nfs_client_lock);\n}\n\nstatic bool nfs4_match_client_owner_id(const struct nfs_client *clp1,\n\t\tconst struct nfs_client *clp2)\n{\n\tif (clp1->cl_owner_id == NULL || clp2->cl_owner_id == NULL)\n\t\treturn true;\n\treturn strcmp(clp1->cl_owner_id, clp2->cl_owner_id) == 0;\n}\n\nstatic bool nfs4_same_verifier(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn memcmp(v1->data, v2->data, sizeof(v1->data)) == 0;\n}\n\nstatic int nfs4_match_client(struct nfs_client  *pos,  struct nfs_client *new,\n\t\t\t     struct nfs_client **prev, struct nfs_net *nn)\n{\n\tint status;\n\n\tif (pos->rpc_ops != new->rpc_ops)\n\t\treturn 1;\n\n\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\treturn 1;\n\n\t/* If \"pos\" isn't marked ready, we can't trust the\n\t * remaining fields in \"pos\", especially the client\n\t * ID and serverowner fields.  Wait for CREATE_SESSION\n\t * to finish. */\n\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\trefcount_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(*prev);\n\t\t*prev = pos;\n\n\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\tspin_lock(&nn->nfs_client_lock);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\treturn 1;\n\n\tif (pos->cl_clientid != new->cl_clientid)\n\t\treturn 1;\n\n\t/* NFSv4.1 always uses the uniform string, however someone\n\t * might switch the uniquifier string on us.\n\t */\n\tif (!nfs4_match_client_owner_id(pos, new))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * nfs40_walk_client_list - Find server that recognizes a client ID\n *\n * @new: nfs_client with client ID to test\n * @result: OUT: found nfs_client, or new\n * @cred: credential to use for trunking test\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status.\n * If zero is returned, an nfs_client pointer is planted in \"result.\"\n *\n * NB: nfs40_walk_client_list() relies on the new nfs_client being\n *     the last nfs_client on the list.\n */\nint nfs40_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   const struct cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid\t= new->cl_clientid,\n\t\t.confirm\t= new->cl_confirm,\n\t};\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tstatus = nfs4_match_client(pos, new, &prev, nn);\n\t\tif (status < 0)\n\t\t\tgoto out_unlock;\n\t\tif (status != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We just sent a new SETCLIENTID, which should have\n\t\t * caused the server to return a new cl_confirm.  So if\n\t\t * cl_confirm is the same, then this is a different\n\t\t * server that just returned the same cl_confirm by\n\t\t * coincidence:\n\t\t */\n\t\tif ((new != pos) && nfs4_same_verifier(&pos->cl_confirm,\n\t\t\t\t\t\t       &new->cl_confirm))\n\t\t\tcontinue;\n\t\t/*\n\t\t * But if the cl_confirm's are different, then the only\n\t\t * way that a SETCLIENTID_CONFIRM to pos can succeed is\n\t\t * if new and pos point to the same server:\n\t\t */\nfound:\n\t\trefcount_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(prev);\n\t\tprev = pos;\n\n\t\tstatus = nfs4_proc_setclientid_confirm(pos, &clid, cred);\n\t\tswitch (status) {\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnfs4_swap_callback_idents(pos, new);\n\t\t\tpos->cl_confirm = new->cl_confirm;\n\t\t\tnfs_mark_client_ready(pos, NFS_CS_READY);\n\n\t\t\tprev = NULL;\n\t\t\t*result = pos;\n\t\t\tgoto out;\n\t\tcase -ERESTARTSYS:\n\t\tcase -ETIMEDOUT:\n\t\t\t/* The callback path may have been inadvertently\n\t\t\t * changed. Schedule recovery!\n\t\t\t */\n\t\t\tnfs4_schedule_path_down_recovery(pos);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&nn->nfs_client_lock);\n\t}\nout_unlock:\n\tspin_unlock(&nn->nfs_client_lock);\n\n\t/* No match found. The server lost our clientid */\nout:\n\tnfs_put_client(prev);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Returns true if the server major ids match\n */\nbool\nnfs4_check_serverowner_major_id(struct nfs41_server_owner *o1,\n\t\t\t\tstruct nfs41_server_owner *o2)\n{\n\tif (o1->major_id_sz != o2->major_id_sz)\n\t\treturn false;\n\treturn memcmp(o1->major_id, o2->major_id, o1->major_id_sz) == 0;\n}\n\n/*\n * Returns true if the server scopes match\n */\nstatic bool\nnfs4_check_server_scope(struct nfs41_server_scope *s1,\n\t\t\tstruct nfs41_server_scope *s2)\n{\n\tif (s1->server_scope_sz != s2->server_scope_sz)\n\t\treturn false;\n\treturn memcmp(s1->server_scope, s2->server_scope,\n\t\t\t\t\ts1->server_scope_sz) == 0;\n}\n\n/**\n * nfs4_detect_session_trunking - Checks for session trunking.\n * @clp:    original mount nfs_client\n * @res:    result structure from an exchange_id using the original mount\n *          nfs_client with a new multi_addr transport\n * @xprt:   pointer to the transport to add.\n *\n * Called after a successful EXCHANGE_ID on a multi-addr connection.\n * Upon success, add the transport.\n *\n * Returns zero on success, otherwise -EINVAL\n *\n * Note: since the exchange_id for the new multi_addr transport uses the\n * same nfs_client from the original mount, the cl_owner_id is reused,\n * so eir_clientowner is the same.\n */\nint nfs4_detect_session_trunking(struct nfs_client *clp,\n\t\t\t\t struct nfs41_exchange_id_res *res,\n\t\t\t\t struct rpc_xprt *xprt)\n{\n\t/* Check eir_clientid */\n\tif (clp->cl_clientid != res->clientid)\n\t\tgoto out_err;\n\n\t/* Check eir_server_owner so_major_id */\n\tif (!nfs4_check_serverowner_major_id(clp->cl_serverowner,\n\t\t\t\t\t     res->server_owner))\n\t\tgoto out_err;\n\n\t/* Check eir_server_owner so_minor_id */\n\tif (clp->cl_serverowner->minor_id != res->server_owner->minor_id)\n\t\tgoto out_err;\n\n\t/* Check eir_server_scope */\n\tif (!nfs4_check_server_scope(clp->cl_serverscope, res->server_scope))\n\t\tgoto out_err;\n\n\tpr_info(\"NFS:  %s: Session trunking succeeded for %s\\n\",\n\t\tclp->cl_hostname,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\treturn 0;\nout_err:\n\tpr_info(\"NFS:  %s: Session trunking failed for %s\\n\", clp->cl_hostname,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\treturn -EINVAL;\n}\n\n/**\n * nfs41_walk_client_list - Find nfs_client that matches a client/server owner\n *\n * @new: nfs_client with client ID to test\n * @result: OUT: found nfs_client, or new\n * @cred: credential to use for trunking test\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status.\n * If zero is returned, an nfs_client pointer is planted in \"result.\"\n *\n * NB: nfs41_walk_client_list() relies on the new nfs_client being\n *     the last nfs_client on the list.\n */\nint nfs41_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   const struct cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tstatus = nfs4_match_client(pos, new, &prev, nn);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t\tif (status != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that session trunking is just a special subcase of\n\t\t * client id trunking. In either case, we want to fall back\n\t\t * to using the existing nfs_client.\n\t\t */\n\t\tif (!nfs4_check_serverowner_major_id(pos->cl_serverowner,\n\t\t\t\t\t\t     new->cl_serverowner))\n\t\t\tcontinue;\n\nfound:\n\t\trefcount_inc(&pos->cl_count);\n\t\t*result = pos;\n\t\tstatus = 0;\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&nn->nfs_client_lock);\n\tnfs_put_client(prev);\n\treturn status;\n}\n#endif\t/* CONFIG_NFS_V4_1 */\n\nstatic void nfs4_destroy_server(struct nfs_server *server)\n{\n\tLIST_HEAD(freeme);\n\n\tnfs_server_return_all_delegations(server);\n\tunset_pnfs_layoutdriver(server);\n\tnfs4_purge_state_owners(server, &freeme);\n\tnfs4_free_state_owners(&freeme);\n}\n\n/*\n * NFSv4.0 callback thread helper\n *\n * Find a client by callback identifier\n */\nstruct nfs_client *\nnfs4_find_client_ident(struct net *net, int cb_ident)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tclp = idr_find(&nn->cb_ident_idr, cb_ident);\n\tif (clp)\n\t\trefcount_inc(&clp->cl_count);\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn clp;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/* Common match routine for v4.0 and v4.1 callback services */\nstatic bool nfs4_cb_match_client(const struct sockaddr *addr,\n\t\tstruct nfs_client *clp, u32 minorversion)\n{\n\tstruct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;\n\n\t/* Don't match clients that failed to initialise */\n\tif (!(clp->cl_cons_state == NFS_CS_READY ||\n\t    clp->cl_cons_state == NFS_CS_SESSION_INITING))\n\t\treturn false;\n\n\tsmp_rmb();\n\n\t/* Match the version and minorversion */\n\tif (clp->rpc_ops->version != 4 ||\n\t    clp->cl_minorversion != minorversion)\n\t\treturn false;\n\n\t/* Match only the IP address, not the port number */\n\treturn rpc_cmp_addr(addr, clap);\n}\n\n/*\n * NFSv4.1 callback thread helper\n * For CB_COMPOUND calls, find a client by IP address, protocol version,\n * minorversion, and sessionID\n *\n * Returns NULL if no such client\n */\nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {\n\t\tif (!nfs4_cb_match_client(addr, clp, minorversion))\n\t\t\tcontinue;\n\n\t\tif (!nfs4_has_session(clp))\n\t\t\tcontinue;\n\n\t\t/* Match sessionid*/\n\t\tif (memcmp(clp->cl_session->sess_id.data,\n\t\t    sid->data, NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\trefcount_inc(&clp->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\t\treturn clp;\n\t}\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn NULL;\n}\n\n#else /* CONFIG_NFS_V4_1 */\n\nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\treturn NULL;\n}\n#endif /* CONFIG_NFS_V4_1 */\n\n/*\n * Set up an NFS4 client\n */\nstatic int nfs4_set_client(struct nfs_server *server,\n\t\tconst char *hostname,\n\t\tconst struct sockaddr *addr,\n\t\tconst size_t addrlen,\n\t\tconst char *ip_addr,\n\t\tint proto, const struct rpc_timeout *timeparms,\n\t\tu32 minorversion, unsigned int nconnect,\n\t\tstruct net *net)\n{\n\tstruct nfs_client_initdata cl_init = {\n\t\t.hostname = hostname,\n\t\t.addr = addr,\n\t\t.addrlen = addrlen,\n\t\t.ip_addr = ip_addr,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = proto,\n\t\t.minorversion = minorversion,\n\t\t.net = net,\n\t\t.timeparms = timeparms,\n\t\t.cred = server->cred,\n\t};\n\tstruct nfs_client *clp;\n\n\tif (minorversion == 0)\n\t\t__set_bit(NFS_CS_REUSEPORT, &cl_init.init_flags);\n\tif (proto == XPRT_TRANSPORT_TCP)\n\t\tcl_init.nconnect = nconnect;\n\n\tif (server->flags & NFS_MOUNT_NORESVPORT)\n\t\t__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\tif (server->options & NFS_OPTION_MIGRATION)\n\t\t__set_bit(NFS_CS_MIGRATION, &cl_init.init_flags);\n\tif (test_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status))\n\t\t__set_bit(NFS_CS_TSM_POSSIBLE, &cl_init.init_flags);\n\tserver->port = rpc_get_port(addr);\n\n\t/* Allocate or find a client reference we can use */\n\tclp = nfs_get_client(&cl_init);\n\tif (IS_ERR(clp))\n\t\treturn PTR_ERR(clp);\n\n\tif (server->nfs_client == clp) {\n\t\tnfs_put_client(clp);\n\t\treturn -ELOOP;\n\t}\n\n\t/*\n\t * Query for the lease time on clientid setup or renewal\n\t *\n\t * Note that this will be set on nfs_clients that were created\n\t * only for the DS role and did not set this bit, but now will\n\t * serve a dual role.\n\t */\n\tset_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state);\n\n\tserver->nfs_client = clp;\n\treturn 0;\n}\n\n/*\n * Set up a pNFS Data Server client.\n *\n * Return any existing nfs_client that matches server address,port,version\n * and minorversion.\n *\n * For a new nfs_client, use a soft mount (default), a low retrans and a\n * low timeout interval so that if a connection is lost, we retry through\n * the MDS.\n */\nstruct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,\n\t\tconst struct sockaddr *ds_addr, int ds_addrlen,\n\t\tint ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,\n\t\tu32 minor_version)\n{\n\tstruct rpc_timeout ds_timeout;\n\tstruct nfs_client *mds_clp = mds_srv->nfs_client;\n\tstruct nfs_client_initdata cl_init = {\n\t\t.addr = ds_addr,\n\t\t.addrlen = ds_addrlen,\n\t\t.nodename = mds_clp->cl_rpcclient->cl_nodename,\n\t\t.ip_addr = mds_clp->cl_ipaddr,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = ds_proto,\n\t\t.minorversion = minor_version,\n\t\t.net = mds_clp->cl_net,\n\t\t.timeparms = &ds_timeout,\n\t\t.cred = mds_srv->cred,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\n\tif (rpc_ntop(ds_addr, buf, sizeof(buf)) <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tcl_init.hostname = buf;\n\n\tif (mds_clp->cl_nconnect > 1 && ds_proto == XPRT_TRANSPORT_TCP)\n\t\tcl_init.nconnect = mds_clp->cl_nconnect;\n\n\tif (mds_srv->flags & NFS_MOUNT_NORESVPORT)\n\t\t__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\n\t/*\n\t * Set an authflavor equual to the MDS value. Use the MDS nfs_client\n\t * cl_ipaddr so as to use the same EXCHANGE_ID co_ownerid as the MDS\n\t * (section 13.1 RFC 5661).\n\t */\n\tnfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);\n\treturn nfs_get_client(&cl_init);\n}\nEXPORT_SYMBOL_GPL(nfs4_set_ds_client);\n\n/*\n * Session has been established, and the client marked ready.\n * Limit the mount rsize, wsize and dtsize using negotiated fore\n * channel attributes.\n */\nstatic void nfs4_session_limit_rwsize(struct nfs_server *server)\n{\n#ifdef CONFIG_NFS_V4_1\n\tstruct nfs4_session *sess;\n\tu32 server_resp_sz;\n\tu32 server_rqst_sz;\n\n\tif (!nfs4_has_session(server->nfs_client))\n\t\treturn;\n\tsess = server->nfs_client->cl_session;\n\tserver_resp_sz = sess->fc_attrs.max_resp_sz - nfs41_maxread_overhead;\n\tserver_rqst_sz = sess->fc_attrs.max_rqst_sz - nfs41_maxwrite_overhead;\n\n\tif (server->dtsize > server_resp_sz)\n\t\tserver->dtsize = server_resp_sz;\n\tif (server->rsize > server_resp_sz)\n\t\tserver->rsize = server_resp_sz;\n\tif (server->wsize > server_rqst_sz)\n\t\tserver->wsize = server_rqst_sz;\n#endif /* CONFIG_NFS_V4_1 */\n}\n\n/*\n * Limit xattr sizes using the channel attributes.\n */\nstatic void nfs4_session_limit_xasize(struct nfs_server *server)\n{\n#ifdef CONFIG_NFS_V4_2\n\tstruct nfs4_session *sess;\n\tu32 server_gxa_sz;\n\tu32 server_sxa_sz;\n\tu32 server_lxa_sz;\n\n\tif (!nfs4_has_session(server->nfs_client))\n\t\treturn;\n\n\tsess = server->nfs_client->cl_session;\n\n\tserver_gxa_sz = sess->fc_attrs.max_resp_sz - nfs42_maxgetxattr_overhead;\n\tserver_sxa_sz = sess->fc_attrs.max_rqst_sz - nfs42_maxsetxattr_overhead;\n\tserver_lxa_sz = sess->fc_attrs.max_resp_sz -\n\t    nfs42_maxlistxattrs_overhead;\n\n\tif (server->gxasize > server_gxa_sz)\n\t\tserver->gxasize = server_gxa_sz;\n\tif (server->sxasize > server_sxa_sz)\n\t\tserver->sxasize = server_sxa_sz;\n\tif (server->lxasize > server_lxa_sz)\n\t\tserver->lxasize = server_lxa_sz;\n#endif\n}\n\nstatic int nfs4_server_common_setup(struct nfs_server *server,\n\t\tstruct nfs_fh *mntfh, bool auth_probe)\n{\n\tstruct nfs_fattr *fattr;\n\tint error;\n\n\t/* data servers support only a subset of NFSv4.1 */\n\tif (is_ds_only_client(server->nfs_client))\n\t\treturn -EPROTONOSUPPORT;\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\treturn -ENOMEM;\n\n\t/* We must ensure the session is initialised first */\n\terror = nfs4_init_session(server->nfs_client);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/* Set the basic capabilities */\n\tserver->caps |= server->nfs_client->cl_mvops->init_caps;\n\tif (server->flags & NFS_MOUNT_NORDIRPLUS)\n\t\t\tserver->caps &= ~NFS_CAP_READDIRPLUS;\n\tif (server->nfs_client->cl_proto == XPRT_TRANSPORT_RDMA)\n\t\tserver->caps &= ~NFS_CAP_READ_PLUS;\n\t/*\n\t * Don't use NFS uid/gid mapping if we're using AUTH_SYS or lower\n\t * authentication.\n\t */\n\tif (nfs4_disable_idmapping &&\n\t\t\tserver->client->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\tserver->caps |= NFS_CAP_UIDGID_NOMAP;\n\n\n\t/* Probe the root fh to retrieve its FSID and filehandle */\n\terror = nfs4_get_rootfh(server, mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto out;\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t\t(unsigned long long) server->fsid.major,\n\t\t\t(unsigned long long) server->fsid.minor);\n\tnfs_display_fhandle(mntfh, \"Pseudo-fs root FH\");\n\n\terror = nfs_probe_fsinfo(server, mntfh, fattr);\n\tif (error < 0)\n\t\tgoto out;\n\n\tnfs4_session_limit_rwsize(server);\n\tnfs4_session_limit_xasize(server);\n\n\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n\t\tserver->namelen = NFS4_MAXNAMLEN;\n\n\tnfs_server_insert_lists(server);\n\tserver->mount_time = jiffies;\n\tserver->destroy = nfs4_destroy_server;\nout:\n\tnfs_free_fattr(fattr);\n\treturn error;\n}\n\n/*\n * Create a version 4 volume record\n */\nstatic int nfs4_init_server(struct nfs_server *server, struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct rpc_timeout timeparms;\n\tint error;\n\n\tnfs_init_timeout_values(&timeparms, ctx->nfs_server.protocol,\n\t\t\t\tctx->timeo, ctx->retrans);\n\n\t/* Initialise the client representation from the mount data */\n\tserver->flags = ctx->flags;\n\tserver->options = ctx->options;\n\tserver->auth_info = ctx->auth_info;\n\n\t/* Use the first specified auth flavor. If this flavor isn't\n\t * allowed by the server, use the SECINFO path to try the\n\t * other specified flavors */\n\tif (ctx->auth_info.flavor_len >= 1)\n\t\tctx->selected_flavor = ctx->auth_info.flavors[0];\n\telse\n\t\tctx->selected_flavor = RPC_AUTH_UNIX;\n\n\t/* Get a client record */\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server.address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tctx->client_address,\n\t\t\t\tctx->nfs_server.protocol,\n\t\t\t\t&timeparms,\n\t\t\t\tctx->minorversion,\n\t\t\t\tctx->nfs_server.nconnect,\n\t\t\t\tfc->net_ns);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (ctx->rsize)\n\t\tserver->rsize = nfs_block_size(ctx->rsize, NULL);\n\tif (ctx->wsize)\n\t\tserver->wsize = nfs_block_size(ctx->wsize, NULL);\n\n\tserver->acregmin = ctx->acregmin * HZ;\n\tserver->acregmax = ctx->acregmax * HZ;\n\tserver->acdirmin = ctx->acdirmin * HZ;\n\tserver->acdirmax = ctx->acdirmax * HZ;\n\tserver->port     = ctx->nfs_server.port;\n\n\treturn nfs_init_server_rpcclient(server, &timeparms,\n\t\t\t\t\t ctx->selected_flavor);\n}\n\n/*\n * Create a version 4 volume record\n * - keyed on server and FSID\n */\nstruct nfs_server *nfs4_create_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_server *server;\n\tbool auth_probe;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tserver->cred = get_cred(fc->cred);\n\n\tauth_probe = ctx->auth_info.flavor_len < 1;\n\n\t/* set up the general RPC client */\n\terror = nfs4_init_server(server, fc);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs4_server_common_setup(server, ctx->mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto error;\n\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\n\n/*\n * Create an NFS4 referral server record\n */\nstruct nfs_server *nfs4_create_referral_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_client *parent_client;\n\tstruct nfs_server *server, *parent_server;\n\tbool auth_probe;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_server = NFS_SB(ctx->clone_data.sb);\n\tparent_client = parent_server->nfs_client;\n\n\tserver->cred = get_cred(parent_server->cred);\n\n\t/* Initialise the client representation from the parent server */\n\tnfs_server_copy_userdata(server, parent_server);\n\n\t/* Get a client representation */\n#if IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA)\n\trpc_set_port(&ctx->nfs_server.address, NFS_RDMA_PORT);\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server.address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tparent_client->cl_ipaddr,\n\t\t\t\tXPRT_TRANSPORT_RDMA,\n\t\t\t\tparent_server->client->cl_timeout,\n\t\t\t\tparent_client->cl_mvops->minor_version,\n\t\t\t\tparent_client->cl_nconnect,\n\t\t\t\tparent_client->cl_net);\n\tif (!error)\n\t\tgoto init_server;\n#endif\t/* IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA) */\n\n\trpc_set_port(&ctx->nfs_server.address, NFS_PORT);\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server.address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tparent_client->cl_ipaddr,\n\t\t\t\tXPRT_TRANSPORT_TCP,\n\t\t\t\tparent_server->client->cl_timeout,\n\t\t\t\tparent_client->cl_mvops->minor_version,\n\t\t\t\tparent_client->cl_nconnect,\n\t\t\t\tparent_client->cl_net);\n\tif (error < 0)\n\t\tgoto error;\n\n#if IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA)\ninit_server:\n#endif\n\terror = nfs_init_server_rpcclient(server, parent_server->client->cl_timeout,\n\t\t\t\t\t  ctx->selected_flavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tauth_probe = parent_server->auth_info.flavor_len < 1;\n\n\terror = nfs4_server_common_setup(server, ctx->mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto error;\n\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\n\n/*\n * Grab the destination's particulars, including lease expiry time.\n *\n * Returns zero if probe succeeded and retrieved FSID matches the FSID\n * we have cached.\n */\nstatic int nfs_probe_destination(struct nfs_server *server)\n{\n\tstruct inode *inode = d_inode(server->super->s_root);\n\tstruct nfs_fattr *fattr;\n\tint error;\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Sanity: the probe won't work if the destination server\n\t * does not recognize the migrated FH. */\n\terror = nfs_probe_fsinfo(server, NFS_FH(inode), fattr);\n\n\tnfs_free_fattr(fattr);\n\treturn error;\n}\n\n/**\n * nfs4_update_server - Move an nfs_server to a different nfs_client\n *\n * @server: represents FSID to be moved\n * @hostname: new end-point's hostname\n * @sap: new end-point's socket address\n * @salen: size of \"sap\"\n * @net: net namespace\n *\n * The nfs_server must be quiescent before this function is invoked.\n * Either its session is drained (NFSv4.1+), or its transport is\n * plugged and drained (NFSv4.0).\n *\n * Returns zero on success, or a negative errno value.\n */\nint nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t       struct sockaddr *sap, size_t salen, struct net *net)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct xprt_create xargs = {\n\t\t.ident\t\t= clp->cl_proto,\n\t\t.net\t\t= net,\n\t\t.dstaddr\t= sap,\n\t\t.addrlen\t= salen,\n\t\t.servername\t= hostname,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *localaddr = (struct sockaddr *)&address;\n\tint error;\n\n\terror = rpc_switch_client_transport(clnt, &xargs, clnt->cl_timeout);\n\tif (error != 0)\n\t\treturn error;\n\n\terror = rpc_localaddr(clnt, localaddr, sizeof(address));\n\tif (error != 0)\n\t\treturn error;\n\n\tif (rpc_ntop(localaddr, buf, sizeof(buf)) == 0)\n\t\treturn -EAFNOSUPPORT;\n\n\tnfs_server_remove_lists(server);\n\tset_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\n\terror = nfs4_set_client(server, hostname, sap, salen, buf,\n\t\t\t\tclp->cl_proto, clnt->cl_timeout,\n\t\t\t\tclp->cl_minorversion,\n\t\t\t\tclp->cl_nconnect, net);\n\tclear_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\n\tif (error != 0) {\n\t\tnfs_server_insert_lists(server);\n\t\treturn error;\n\t}\n\tnfs_put_client(clp);\n\n\tif (server->nfs_client->cl_hostname == NULL)\n\t\tserver->nfs_client->cl_hostname = kstrdup(hostname, GFP_KERNEL);\n\tnfs_server_insert_lists(server);\n\n\treturn nfs_probe_destination(server);\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (C) 2006 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n */\n#include <linux/module.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs_mount.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/auth.h>\n#include <linux/sunrpc/xprt.h>\n#include <linux/sunrpc/bc_xprt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include \"internal.h\"\n#include \"callback.h\"\n#include \"delegation.h\"\n#include \"nfs4session.h\"\n#include \"nfs4idmap.h\"\n#include \"pnfs.h\"\n#include \"netns.h\"\n\n#define NFSDBG_FACILITY\t\tNFSDBG_CLIENT\n\n/*\n * Get a unique NFSv4.0 callback identifier which will be used\n * by the V4.0 callback service to lookup the nfs_client struct\n */\nstatic int nfs_get_cb_ident_idr(struct nfs_client *clp, int minorversion)\n{\n\tint ret = 0;\n\tstruct nfs_net *nn = net_generic(clp->cl_net, nfs_net_id);\n\n\tif (clp->rpc_ops->version != 4 || minorversion != 0)\n\t\treturn ret;\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&nn->nfs_client_lock);\n\tret = idr_alloc(&nn->cb_ident_idr, clp, 1, 0, GFP_NOWAIT);\n\tif (ret >= 0)\n\t\tclp->cl_cb_ident = ret;\n\tspin_unlock(&nn->nfs_client_lock);\n\tidr_preload_end();\n\treturn ret < 0 ? ret : 0;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Per auth flavor data server rpc clients\n */\nstruct nfs4_ds_server {\n\tstruct list_head\tlist;   /* ds_clp->cl_ds_clients */\n\tstruct rpc_clnt\t\t*rpc_clnt;\n};\n\n/**\n * nfs4_find_ds_client - Common lookup case for DS I/O\n * @ds_clp: pointer to the DS's nfs_client\n * @flavor: rpc auth flavour to match\n */\nstatic struct nfs4_ds_server *\nnfs4_find_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\n{\n\tstruct nfs4_ds_server *dss;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dss, &ds_clp->cl_ds_clients, list) {\n\t\tif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tdss = NULL;\nout:\n\trcu_read_unlock();\n\treturn dss;\n}\n\nstatic struct nfs4_ds_server *\nnfs4_add_ds_client(struct nfs_client *ds_clp, rpc_authflavor_t flavor,\n\t\t\t   struct nfs4_ds_server *new)\n{\n\tstruct nfs4_ds_server *dss;\n\n\tspin_lock(&ds_clp->cl_lock);\n\tlist_for_each_entry(dss, &ds_clp->cl_ds_clients, list) {\n\t\tif (dss->rpc_clnt->cl_auth->au_flavor != flavor)\n\t\t\tcontinue;\n\t\tgoto out;\n\t}\n\tif (new)\n\t\tlist_add_rcu(&new->list, &ds_clp->cl_ds_clients);\n\tdss = new;\nout:\n\tspin_unlock(&ds_clp->cl_lock); /* need some lock to protect list */\n\treturn dss;\n}\n\nstatic struct nfs4_ds_server *\nnfs4_alloc_ds_server(struct nfs_client *ds_clp, rpc_authflavor_t flavor)\n{\n\tstruct nfs4_ds_server *dss;\n\n\tdss = kmalloc(sizeof(*dss), GFP_NOFS);\n\tif (dss == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdss->rpc_clnt = rpc_clone_client_set_auth(ds_clp->cl_rpcclient, flavor);\n\tif (IS_ERR(dss->rpc_clnt)) {\n\t\tint err = PTR_ERR(dss->rpc_clnt);\n\t\tkfree (dss);\n\t\treturn ERR_PTR(err);\n\t}\n\tINIT_LIST_HEAD(&dss->list);\n\n\treturn dss;\n}\n\nstatic void\nnfs4_free_ds_server(struct nfs4_ds_server *dss)\n{\n\trpc_release_client(dss->rpc_clnt);\n\tkfree(dss);\n}\n\n/**\n * nfs4_find_or_create_ds_client - Find or create a DS rpc client\n * @ds_clp: pointer to the DS's nfs_client\n * @inode: pointer to the inode\n *\n * Find or create a DS rpc client with th MDS server rpc client auth flavor\n * in the nfs_client cl_ds_clients list.\n */\nstruct rpc_clnt *\nnfs4_find_or_create_ds_client(struct nfs_client *ds_clp, struct inode *inode)\n{\n\tstruct nfs4_ds_server *dss, *new;\n\trpc_authflavor_t flavor = NFS_SERVER(inode)->client->cl_auth->au_flavor;\n\n\tdss = nfs4_find_ds_client(ds_clp, flavor);\n\tif (dss != NULL)\n\t\tgoto out;\n\tnew = nfs4_alloc_ds_server(ds_clp, flavor);\n\tif (IS_ERR(new))\n\t\treturn ERR_CAST(new);\n\tdss = nfs4_add_ds_client(ds_clp, flavor, new);\n\tif (dss != new)\n\t\tnfs4_free_ds_server(new);\nout:\n\treturn dss->rpc_clnt;\n}\nEXPORT_SYMBOL_GPL(nfs4_find_or_create_ds_client);\n\nstatic void\nnfs4_shutdown_ds_clients(struct nfs_client *clp)\n{\n\tstruct nfs4_ds_server *dss;\n\n\twhile (!list_empty(&clp->cl_ds_clients)) {\n\t\tdss = list_entry(clp->cl_ds_clients.next,\n\t\t\t\t\tstruct nfs4_ds_server, list);\n\t\tlist_del(&dss->list);\n\t\trpc_shutdown_client(dss->rpc_clnt);\n\t\tkfree (dss);\n\t}\n}\n\nstatic void\nnfs4_cleanup_callback(struct nfs_client *clp)\n{\n\tstruct nfs4_copy_state *cp_state;\n\n\twhile (!list_empty(&clp->pending_cb_stateids)) {\n\t\tcp_state = list_entry(clp->pending_cb_stateids.next,\n\t\t\t\t\tstruct nfs4_copy_state, copies);\n\t\tlist_del(&cp_state->copies);\n\t\tkfree(cp_state);\n\t}\n}\n\nvoid nfs41_shutdown_client(struct nfs_client *clp)\n{\n\tif (nfs4_has_session(clp)) {\n\t\tnfs4_cleanup_callback(clp);\n\t\tnfs4_shutdown_ds_clients(clp);\n\t\tnfs4_destroy_session(clp->cl_session);\n\t\tnfs4_destroy_clientid(clp);\n\t}\n\n}\n#endif\t/* CONFIG_NFS_V4_1 */\n\nvoid nfs40_shutdown_client(struct nfs_client *clp)\n{\n\tif (clp->cl_slot_tbl) {\n\t\tnfs4_shutdown_slot_table(clp->cl_slot_tbl);\n\t\tkfree(clp->cl_slot_tbl);\n\t}\n}\n\nstruct nfs_client *nfs4_alloc_client(const struct nfs_client_initdata *cl_init)\n{\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tconst char *ip_addr = cl_init->ip_addr;\n\tstruct nfs_client *clp = nfs_alloc_client(cl_init);\n\tint err;\n\n\tif (IS_ERR(clp))\n\t\treturn clp;\n\n\terr = nfs_get_cb_ident_idr(clp, cl_init->minorversion);\n\tif (err)\n\t\tgoto error;\n\n\tif (cl_init->minorversion > NFS4_MAX_MINOR_VERSION) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tspin_lock_init(&clp->cl_lock);\n\tINIT_DELAYED_WORK(&clp->cl_renewd, nfs4_renew_state);\n\tINIT_LIST_HEAD(&clp->cl_ds_clients);\n\trpc_init_wait_queue(&clp->cl_rpcwaitq, \"NFS client\");\n\tclp->cl_state = 1 << NFS4CLNT_LEASE_EXPIRED;\n\tclp->cl_mvops = nfs_v4_minor_ops[cl_init->minorversion];\n\tclp->cl_mig_gen = 1;\n#if IS_ENABLED(CONFIG_NFS_V4_1)\n\tinit_waitqueue_head(&clp->cl_lock_waitq);\n#endif\n\tINIT_LIST_HEAD(&clp->pending_cb_stateids);\n\n\tif (cl_init->minorversion != 0)\n\t\t__set_bit(NFS_CS_INFINITE_SLOTS, &clp->cl_flags);\n\t__set_bit(NFS_CS_DISCRTRY, &clp->cl_flags);\n\t__set_bit(NFS_CS_NO_RETRANS_TIMEOUT, &clp->cl_flags);\n\n\t/*\n\t * Set up the connection to the server before we add add to the\n\t * global list.\n\t */\n\terr = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_GSS_KRB5I);\n\tif (err == -EINVAL)\n\t\terr = nfs_create_rpc_client(clp, cl_init, RPC_AUTH_UNIX);\n\tif (err < 0)\n\t\tgoto error;\n\n\t/* If no clientaddr= option was specified, find a usable cb address */\n\tif (ip_addr == NULL) {\n\t\tstruct sockaddr_storage cb_addr;\n\t\tstruct sockaddr *sap = (struct sockaddr *)&cb_addr;\n\n\t\terr = rpc_localaddr(clp->cl_rpcclient, sap, sizeof(cb_addr));\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\terr = rpc_ntop(sap, buf, sizeof(buf));\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tip_addr = (const char *)buf;\n\t}\n\tstrlcpy(clp->cl_ipaddr, ip_addr, sizeof(clp->cl_ipaddr));\n\n\terr = nfs_idmap_new(clp);\n\tif (err < 0) {\n\t\tdprintk(\"%s: failed to create idmapper. Error = %d\\n\",\n\t\t\t__func__, err);\n\t\tgoto error;\n\t}\n\t__set_bit(NFS_CS_IDMAP, &clp->cl_res_state);\n\treturn clp;\n\nerror:\n\tnfs_free_client(clp);\n\treturn ERR_PTR(err);\n}\n\n/*\n * Destroy the NFS4 callback service\n */\nstatic void nfs4_destroy_callback(struct nfs_client *clp)\n{\n\tif (__test_and_clear_bit(NFS_CS_CALLBACK, &clp->cl_res_state))\n\t\tnfs_callback_down(clp->cl_mvops->minor_version, clp->cl_net);\n}\n\nstatic void nfs4_shutdown_client(struct nfs_client *clp)\n{\n\tif (__test_and_clear_bit(NFS_CS_RENEWD, &clp->cl_res_state))\n\t\tnfs4_kill_renewd(clp);\n\tclp->cl_mvops->shutdown_client(clp);\n\tnfs4_destroy_callback(clp);\n\tif (__test_and_clear_bit(NFS_CS_IDMAP, &clp->cl_res_state))\n\t\tnfs_idmap_delete(clp);\n\n\trpc_destroy_wait_queue(&clp->cl_rpcwaitq);\n\tkfree(clp->cl_serverowner);\n\tkfree(clp->cl_serverscope);\n\tkfree(clp->cl_implid);\n\tkfree(clp->cl_owner_id);\n}\n\nvoid nfs4_free_client(struct nfs_client *clp)\n{\n\tnfs4_shutdown_client(clp);\n\tnfs_free_client(clp);\n}\n\n/*\n * Initialize the NFS4 callback service\n */\nstatic int nfs4_init_callback(struct nfs_client *clp)\n{\n\tstruct rpc_xprt *xprt;\n\tint error;\n\n\txprt = rcu_dereference_raw(clp->cl_rpcclient->cl_xprt);\n\n\tif (nfs4_has_session(clp)) {\n\t\terror = xprt_setup_backchannel(xprt, NFS41_BC_MIN_CALLBACKS);\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = nfs_callback_up(clp->cl_mvops->minor_version, xprt);\n\tif (error < 0) {\n\t\tdprintk(\"%s: failed to start callback. Error = %d\\n\",\n\t\t\t__func__, error);\n\t\treturn error;\n\t}\n\t__set_bit(NFS_CS_CALLBACK, &clp->cl_res_state);\n\n\treturn 0;\n}\n\n/**\n * nfs40_init_client - nfs_client initialization tasks for NFSv4.0\n * @clp: nfs_client to initialize\n *\n * Returns zero on success, or a negative errno if some error occurred.\n */\nint nfs40_init_client(struct nfs_client *clp)\n{\n\tstruct nfs4_slot_table *tbl;\n\tint ret;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_NOFS);\n\tif (tbl == NULL)\n\t\treturn -ENOMEM;\n\n\tret = nfs4_setup_slot_table(tbl, NFS4_MAX_SLOT_TABLE,\n\t\t\t\t\t\"NFSv4.0 transport Slot table\");\n\tif (ret) {\n\t\tkfree(tbl);\n\t\treturn ret;\n\t}\n\n\tclp->cl_slot_tbl = tbl;\n\treturn 0;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n\n/**\n * nfs41_init_client - nfs_client initialization tasks for NFSv4.1+\n * @clp: nfs_client to initialize\n *\n * Returns zero on success, or a negative errno if some error occurred.\n */\nint nfs41_init_client(struct nfs_client *clp)\n{\n\tstruct nfs4_session *session = NULL;\n\n\t/*\n\t * Create the session and mark it expired.\n\t * When a SEQUENCE operation encounters the expired session\n\t * it will do session recovery to initialize it.\n\t */\n\tsession = nfs4_alloc_session(clp);\n\tif (!session)\n\t\treturn -ENOMEM;\n\n\tclp->cl_session = session;\n\n\t/*\n\t * The create session reply races with the server back\n\t * channel probe. Mark the client NFS_CS_SESSION_INITING\n\t * so that the client back channel can find the\n\t * nfs_client struct\n\t */\n\tnfs_mark_client_ready(clp, NFS_CS_SESSION_INITING);\n\treturn 0;\n}\n\n#endif\t/* CONFIG_NFS_V4_1 */\n\n/*\n * Initialize the minor version specific parts of an NFS4 client record\n */\nstatic int nfs4_init_client_minor_version(struct nfs_client *clp)\n{\n\tint ret;\n\n\tret = clp->cl_mvops->init_client(clp);\n\tif (ret)\n\t\treturn ret;\n\treturn nfs4_init_callback(clp);\n}\n\n/**\n * nfs4_init_client - Initialise an NFS4 client record\n *\n * @clp: nfs_client to initialise\n * @cl_init: pointer to nfs_client_initdata\n *\n * Returns pointer to an NFS client, or an ERR_PTR value.\n */\nstruct nfs_client *nfs4_init_client(struct nfs_client *clp,\n\t\t\t\t    const struct nfs_client_initdata *cl_init)\n{\n\tstruct nfs_client *old;\n\tint error;\n\n\tif (clp->cl_cons_state == NFS_CS_READY)\n\t\t/* the client is initialised already */\n\t\treturn clp;\n\n\terror = nfs4_init_client_minor_version(clp);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs4_discover_server_trunking(clp, &old);\n\tif (error < 0)\n\t\tgoto error;\n\n\tif (clp != old) {\n\t\tclp->cl_preserve_clid = true;\n\t\t/*\n\t\t * Mark the client as having failed initialization so other\n\t\t * processes walking the nfs_client_list in nfs_match_client()\n\t\t * won't try to use it.\n\t\t */\n\t\tnfs_mark_client_ready(clp, -EPERM);\n\t}\n\tclear_bit(NFS_CS_TSM_POSSIBLE, &clp->cl_flags);\n\tnfs_put_client(clp);\n\treturn old;\n\nerror:\n\tnfs_mark_client_ready(clp, error);\n\tnfs_put_client(clp);\n\treturn ERR_PTR(error);\n}\n\n/*\n * SETCLIENTID just did a callback update with the callback ident in\n * \"drop,\" but server trunking discovery claims \"drop\" and \"keep\" are\n * actually the same server.  Swap the callback IDs so that \"keep\"\n * will continue to use the callback ident the server now knows about,\n * and so that \"keep\"'s original callback ident is destroyed when\n * \"drop\" is freed.\n */\nstatic void nfs4_swap_callback_idents(struct nfs_client *keep,\n\t\t\t\t      struct nfs_client *drop)\n{\n\tstruct nfs_net *nn = net_generic(keep->cl_net, nfs_net_id);\n\tunsigned int save = keep->cl_cb_ident;\n\n\tif (keep->cl_cb_ident == drop->cl_cb_ident)\n\t\treturn;\n\n\tdprintk(\"%s: keeping callback ident %u and dropping ident %u\\n\",\n\t\t__func__, keep->cl_cb_ident, drop->cl_cb_ident);\n\n\tspin_lock(&nn->nfs_client_lock);\n\n\tidr_replace(&nn->cb_ident_idr, keep, drop->cl_cb_ident);\n\tkeep->cl_cb_ident = drop->cl_cb_ident;\n\n\tidr_replace(&nn->cb_ident_idr, drop, save);\n\tdrop->cl_cb_ident = save;\n\n\tspin_unlock(&nn->nfs_client_lock);\n}\n\nstatic bool nfs4_match_client_owner_id(const struct nfs_client *clp1,\n\t\tconst struct nfs_client *clp2)\n{\n\tif (clp1->cl_owner_id == NULL || clp2->cl_owner_id == NULL)\n\t\treturn true;\n\treturn strcmp(clp1->cl_owner_id, clp2->cl_owner_id) == 0;\n}\n\nstatic bool nfs4_same_verifier(nfs4_verifier *v1, nfs4_verifier *v2)\n{\n\treturn memcmp(v1->data, v2->data, sizeof(v1->data)) == 0;\n}\n\nstatic int nfs4_match_client(struct nfs_client  *pos,  struct nfs_client *new,\n\t\t\t     struct nfs_client **prev, struct nfs_net *nn)\n{\n\tint status;\n\n\tif (pos->rpc_ops != new->rpc_ops)\n\t\treturn 1;\n\n\tif (pos->cl_minorversion != new->cl_minorversion)\n\t\treturn 1;\n\n\t/* If \"pos\" isn't marked ready, we can't trust the\n\t * remaining fields in \"pos\", especially the client\n\t * ID and serverowner fields.  Wait for CREATE_SESSION\n\t * to finish. */\n\tif (pos->cl_cons_state > NFS_CS_READY) {\n\t\trefcount_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(*prev);\n\t\t*prev = pos;\n\n\t\tstatus = nfs_wait_client_init_complete(pos);\n\t\tspin_lock(&nn->nfs_client_lock);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\tif (pos->cl_cons_state != NFS_CS_READY)\n\t\treturn 1;\n\n\tif (pos->cl_clientid != new->cl_clientid)\n\t\treturn 1;\n\n\t/* NFSv4.1 always uses the uniform string, however someone\n\t * might switch the uniquifier string on us.\n\t */\n\tif (!nfs4_match_client_owner_id(pos, new))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n/**\n * nfs40_walk_client_list - Find server that recognizes a client ID\n *\n * @new: nfs_client with client ID to test\n * @result: OUT: found nfs_client, or new\n * @cred: credential to use for trunking test\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status.\n * If zero is returned, an nfs_client pointer is planted in \"result.\"\n *\n * NB: nfs40_walk_client_list() relies on the new nfs_client being\n *     the last nfs_client on the list.\n */\nint nfs40_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   const struct cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tstruct nfs4_setclientid_res clid = {\n\t\t.clientid\t= new->cl_clientid,\n\t\t.confirm\t= new->cl_confirm,\n\t};\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tstatus = nfs4_match_client(pos, new, &prev, nn);\n\t\tif (status < 0)\n\t\t\tgoto out_unlock;\n\t\tif (status != 0)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We just sent a new SETCLIENTID, which should have\n\t\t * caused the server to return a new cl_confirm.  So if\n\t\t * cl_confirm is the same, then this is a different\n\t\t * server that just returned the same cl_confirm by\n\t\t * coincidence:\n\t\t */\n\t\tif ((new != pos) && nfs4_same_verifier(&pos->cl_confirm,\n\t\t\t\t\t\t       &new->cl_confirm))\n\t\t\tcontinue;\n\t\t/*\n\t\t * But if the cl_confirm's are different, then the only\n\t\t * way that a SETCLIENTID_CONFIRM to pos can succeed is\n\t\t * if new and pos point to the same server:\n\t\t */\nfound:\n\t\trefcount_inc(&pos->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\n\t\tnfs_put_client(prev);\n\t\tprev = pos;\n\n\t\tstatus = nfs4_proc_setclientid_confirm(pos, &clid, cred);\n\t\tswitch (status) {\n\t\tcase -NFS4ERR_STALE_CLIENTID:\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tnfs4_swap_callback_idents(pos, new);\n\t\t\tpos->cl_confirm = new->cl_confirm;\n\t\t\tnfs_mark_client_ready(pos, NFS_CS_READY);\n\n\t\t\tprev = NULL;\n\t\t\t*result = pos;\n\t\t\tgoto out;\n\t\tcase -ERESTARTSYS:\n\t\tcase -ETIMEDOUT:\n\t\t\t/* The callback path may have been inadvertently\n\t\t\t * changed. Schedule recovery!\n\t\t\t */\n\t\t\tnfs4_schedule_path_down_recovery(pos);\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock(&nn->nfs_client_lock);\n\t}\nout_unlock:\n\tspin_unlock(&nn->nfs_client_lock);\n\n\t/* No match found. The server lost our clientid */\nout:\n\tnfs_put_client(prev);\n\treturn status;\n}\n\n#ifdef CONFIG_NFS_V4_1\n/*\n * Returns true if the server major ids match\n */\nbool\nnfs4_check_serverowner_major_id(struct nfs41_server_owner *o1,\n\t\t\t\tstruct nfs41_server_owner *o2)\n{\n\tif (o1->major_id_sz != o2->major_id_sz)\n\t\treturn false;\n\treturn memcmp(o1->major_id, o2->major_id, o1->major_id_sz) == 0;\n}\n\n/*\n * Returns true if the server scopes match\n */\nstatic bool\nnfs4_check_server_scope(struct nfs41_server_scope *s1,\n\t\t\tstruct nfs41_server_scope *s2)\n{\n\tif (s1->server_scope_sz != s2->server_scope_sz)\n\t\treturn false;\n\treturn memcmp(s1->server_scope, s2->server_scope,\n\t\t\t\t\ts1->server_scope_sz) == 0;\n}\n\n/**\n * nfs4_detect_session_trunking - Checks for session trunking.\n * @clp:    original mount nfs_client\n * @res:    result structure from an exchange_id using the original mount\n *          nfs_client with a new multi_addr transport\n * @xprt:   pointer to the transport to add.\n *\n * Called after a successful EXCHANGE_ID on a multi-addr connection.\n * Upon success, add the transport.\n *\n * Returns zero on success, otherwise -EINVAL\n *\n * Note: since the exchange_id for the new multi_addr transport uses the\n * same nfs_client from the original mount, the cl_owner_id is reused,\n * so eir_clientowner is the same.\n */\nint nfs4_detect_session_trunking(struct nfs_client *clp,\n\t\t\t\t struct nfs41_exchange_id_res *res,\n\t\t\t\t struct rpc_xprt *xprt)\n{\n\t/* Check eir_clientid */\n\tif (clp->cl_clientid != res->clientid)\n\t\tgoto out_err;\n\n\t/* Check eir_server_owner so_major_id */\n\tif (!nfs4_check_serverowner_major_id(clp->cl_serverowner,\n\t\t\t\t\t     res->server_owner))\n\t\tgoto out_err;\n\n\t/* Check eir_server_owner so_minor_id */\n\tif (clp->cl_serverowner->minor_id != res->server_owner->minor_id)\n\t\tgoto out_err;\n\n\t/* Check eir_server_scope */\n\tif (!nfs4_check_server_scope(clp->cl_serverscope, res->server_scope))\n\t\tgoto out_err;\n\n\tpr_info(\"NFS:  %s: Session trunking succeeded for %s\\n\",\n\t\tclp->cl_hostname,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\treturn 0;\nout_err:\n\tpr_info(\"NFS:  %s: Session trunking failed for %s\\n\", clp->cl_hostname,\n\t\txprt->address_strings[RPC_DISPLAY_ADDR]);\n\n\treturn -EINVAL;\n}\n\n/**\n * nfs41_walk_client_list - Find nfs_client that matches a client/server owner\n *\n * @new: nfs_client with client ID to test\n * @result: OUT: found nfs_client, or new\n * @cred: credential to use for trunking test\n *\n * Returns zero, a negative errno, or a negative NFS4ERR status.\n * If zero is returned, an nfs_client pointer is planted in \"result.\"\n *\n * NB: nfs41_walk_client_list() relies on the new nfs_client being\n *     the last nfs_client on the list.\n */\nint nfs41_walk_client_list(struct nfs_client *new,\n\t\t\t   struct nfs_client **result,\n\t\t\t   const struct cred *cred)\n{\n\tstruct nfs_net *nn = net_generic(new->cl_net, nfs_net_id);\n\tstruct nfs_client *pos, *prev = NULL;\n\tint status = -NFS4ERR_STALE_CLIENTID;\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(pos, &nn->nfs_client_list, cl_share_link) {\n\n\t\tif (pos == new)\n\t\t\tgoto found;\n\n\t\tstatus = nfs4_match_client(pos, new, &prev, nn);\n\t\tif (status < 0)\n\t\t\tgoto out;\n\t\tif (status != 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Note that session trunking is just a special subcase of\n\t\t * client id trunking. In either case, we want to fall back\n\t\t * to using the existing nfs_client.\n\t\t */\n\t\tif (!nfs4_check_serverowner_major_id(pos->cl_serverowner,\n\t\t\t\t\t\t     new->cl_serverowner))\n\t\t\tcontinue;\n\nfound:\n\t\trefcount_inc(&pos->cl_count);\n\t\t*result = pos;\n\t\tstatus = 0;\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock(&nn->nfs_client_lock);\n\tnfs_put_client(prev);\n\treturn status;\n}\n#endif\t/* CONFIG_NFS_V4_1 */\n\nstatic void nfs4_destroy_server(struct nfs_server *server)\n{\n\tLIST_HEAD(freeme);\n\n\tnfs_server_return_all_delegations(server);\n\tunset_pnfs_layoutdriver(server);\n\tnfs4_purge_state_owners(server, &freeme);\n\tnfs4_free_state_owners(&freeme);\n}\n\n/*\n * NFSv4.0 callback thread helper\n *\n * Find a client by callback identifier\n */\nstruct nfs_client *\nnfs4_find_client_ident(struct net *net, int cb_ident)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tclp = idr_find(&nn->cb_ident_idr, cb_ident);\n\tif (clp)\n\t\trefcount_inc(&clp->cl_count);\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn clp;\n}\n\n#if defined(CONFIG_NFS_V4_1)\n/* Common match routine for v4.0 and v4.1 callback services */\nstatic bool nfs4_cb_match_client(const struct sockaddr *addr,\n\t\tstruct nfs_client *clp, u32 minorversion)\n{\n\tstruct sockaddr *clap = (struct sockaddr *)&clp->cl_addr;\n\n\t/* Don't match clients that failed to initialise */\n\tif (!(clp->cl_cons_state == NFS_CS_READY ||\n\t    clp->cl_cons_state == NFS_CS_SESSION_INITING))\n\t\treturn false;\n\n\tsmp_rmb();\n\n\t/* Match the version and minorversion */\n\tif (clp->rpc_ops->version != 4 ||\n\t    clp->cl_minorversion != minorversion)\n\t\treturn false;\n\n\t/* Match only the IP address, not the port number */\n\treturn rpc_cmp_addr(addr, clap);\n}\n\n/*\n * NFSv4.1 callback thread helper\n * For CB_COMPOUND calls, find a client by IP address, protocol version,\n * minorversion, and sessionID\n *\n * Returns NULL if no such client\n */\nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\tstruct nfs_client *clp;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\n\tspin_lock(&nn->nfs_client_lock);\n\tlist_for_each_entry(clp, &nn->nfs_client_list, cl_share_link) {\n\t\tif (!nfs4_cb_match_client(addr, clp, minorversion))\n\t\t\tcontinue;\n\n\t\tif (!nfs4_has_session(clp))\n\t\t\tcontinue;\n\n\t\t/* Match sessionid*/\n\t\tif (memcmp(clp->cl_session->sess_id.data,\n\t\t    sid->data, NFS4_MAX_SESSIONID_LEN) != 0)\n\t\t\tcontinue;\n\n\t\trefcount_inc(&clp->cl_count);\n\t\tspin_unlock(&nn->nfs_client_lock);\n\t\treturn clp;\n\t}\n\tspin_unlock(&nn->nfs_client_lock);\n\treturn NULL;\n}\n\n#else /* CONFIG_NFS_V4_1 */\n\nstruct nfs_client *\nnfs4_find_client_sessionid(struct net *net, const struct sockaddr *addr,\n\t\t\t   struct nfs4_sessionid *sid, u32 minorversion)\n{\n\treturn NULL;\n}\n#endif /* CONFIG_NFS_V4_1 */\n\n/*\n * Set up an NFS4 client\n */\nstatic int nfs4_set_client(struct nfs_server *server,\n\t\tconst char *hostname,\n\t\tconst struct sockaddr *addr,\n\t\tconst size_t addrlen,\n\t\tconst char *ip_addr,\n\t\tint proto, const struct rpc_timeout *timeparms,\n\t\tu32 minorversion, unsigned int nconnect,\n\t\tstruct net *net)\n{\n\tstruct nfs_client_initdata cl_init = {\n\t\t.hostname = hostname,\n\t\t.addr = addr,\n\t\t.addrlen = addrlen,\n\t\t.ip_addr = ip_addr,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = proto,\n\t\t.minorversion = minorversion,\n\t\t.net = net,\n\t\t.timeparms = timeparms,\n\t\t.cred = server->cred,\n\t};\n\tstruct nfs_client *clp;\n\n\tif (minorversion == 0)\n\t\t__set_bit(NFS_CS_REUSEPORT, &cl_init.init_flags);\n\tif (proto == XPRT_TRANSPORT_TCP)\n\t\tcl_init.nconnect = nconnect;\n\n\tif (server->flags & NFS_MOUNT_NORESVPORT)\n\t\t__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\tif (server->options & NFS_OPTION_MIGRATION)\n\t\t__set_bit(NFS_CS_MIGRATION, &cl_init.init_flags);\n\tif (test_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status))\n\t\t__set_bit(NFS_CS_TSM_POSSIBLE, &cl_init.init_flags);\n\tserver->port = rpc_get_port(addr);\n\n\t/* Allocate or find a client reference we can use */\n\tclp = nfs_get_client(&cl_init);\n\tif (IS_ERR(clp))\n\t\treturn PTR_ERR(clp);\n\n\tif (server->nfs_client == clp) {\n\t\tnfs_put_client(clp);\n\t\treturn -ELOOP;\n\t}\n\n\t/*\n\t * Query for the lease time on clientid setup or renewal\n\t *\n\t * Note that this will be set on nfs_clients that were created\n\t * only for the DS role and did not set this bit, but now will\n\t * serve a dual role.\n\t */\n\tset_bit(NFS_CS_CHECK_LEASE_TIME, &clp->cl_res_state);\n\n\tserver->nfs_client = clp;\n\treturn 0;\n}\n\n/*\n * Set up a pNFS Data Server client.\n *\n * Return any existing nfs_client that matches server address,port,version\n * and minorversion.\n *\n * For a new nfs_client, use a soft mount (default), a low retrans and a\n * low timeout interval so that if a connection is lost, we retry through\n * the MDS.\n */\nstruct nfs_client *nfs4_set_ds_client(struct nfs_server *mds_srv,\n\t\tconst struct sockaddr *ds_addr, int ds_addrlen,\n\t\tint ds_proto, unsigned int ds_timeo, unsigned int ds_retrans,\n\t\tu32 minor_version)\n{\n\tstruct rpc_timeout ds_timeout;\n\tstruct nfs_client *mds_clp = mds_srv->nfs_client;\n\tstruct nfs_client_initdata cl_init = {\n\t\t.addr = ds_addr,\n\t\t.addrlen = ds_addrlen,\n\t\t.nodename = mds_clp->cl_rpcclient->cl_nodename,\n\t\t.ip_addr = mds_clp->cl_ipaddr,\n\t\t.nfs_mod = &nfs_v4,\n\t\t.proto = ds_proto,\n\t\t.minorversion = minor_version,\n\t\t.net = mds_clp->cl_net,\n\t\t.timeparms = &ds_timeout,\n\t\t.cred = mds_srv->cred,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\n\tif (rpc_ntop(ds_addr, buf, sizeof(buf)) <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tcl_init.hostname = buf;\n\n\tif (mds_clp->cl_nconnect > 1 && ds_proto == XPRT_TRANSPORT_TCP)\n\t\tcl_init.nconnect = mds_clp->cl_nconnect;\n\n\tif (mds_srv->flags & NFS_MOUNT_NORESVPORT)\n\t\t__set_bit(NFS_CS_NORESVPORT, &cl_init.init_flags);\n\n\t/*\n\t * Set an authflavor equual to the MDS value. Use the MDS nfs_client\n\t * cl_ipaddr so as to use the same EXCHANGE_ID co_ownerid as the MDS\n\t * (section 13.1 RFC 5661).\n\t */\n\tnfs_init_timeout_values(&ds_timeout, ds_proto, ds_timeo, ds_retrans);\n\treturn nfs_get_client(&cl_init);\n}\nEXPORT_SYMBOL_GPL(nfs4_set_ds_client);\n\n/*\n * Session has been established, and the client marked ready.\n * Limit the mount rsize, wsize and dtsize using negotiated fore\n * channel attributes.\n */\nstatic void nfs4_session_limit_rwsize(struct nfs_server *server)\n{\n#ifdef CONFIG_NFS_V4_1\n\tstruct nfs4_session *sess;\n\tu32 server_resp_sz;\n\tu32 server_rqst_sz;\n\n\tif (!nfs4_has_session(server->nfs_client))\n\t\treturn;\n\tsess = server->nfs_client->cl_session;\n\tserver_resp_sz = sess->fc_attrs.max_resp_sz - nfs41_maxread_overhead;\n\tserver_rqst_sz = sess->fc_attrs.max_rqst_sz - nfs41_maxwrite_overhead;\n\n\tif (server->dtsize > server_resp_sz)\n\t\tserver->dtsize = server_resp_sz;\n\tif (server->rsize > server_resp_sz)\n\t\tserver->rsize = server_resp_sz;\n\tif (server->wsize > server_rqst_sz)\n\t\tserver->wsize = server_rqst_sz;\n#endif /* CONFIG_NFS_V4_1 */\n}\n\n/*\n * Limit xattr sizes using the channel attributes.\n */\nstatic void nfs4_session_limit_xasize(struct nfs_server *server)\n{\n#ifdef CONFIG_NFS_V4_2\n\tstruct nfs4_session *sess;\n\tu32 server_gxa_sz;\n\tu32 server_sxa_sz;\n\tu32 server_lxa_sz;\n\n\tif (!nfs4_has_session(server->nfs_client))\n\t\treturn;\n\n\tsess = server->nfs_client->cl_session;\n\n\tserver_gxa_sz = sess->fc_attrs.max_resp_sz - nfs42_maxgetxattr_overhead;\n\tserver_sxa_sz = sess->fc_attrs.max_rqst_sz - nfs42_maxsetxattr_overhead;\n\tserver_lxa_sz = sess->fc_attrs.max_resp_sz -\n\t    nfs42_maxlistxattrs_overhead;\n\n\tif (server->gxasize > server_gxa_sz)\n\t\tserver->gxasize = server_gxa_sz;\n\tif (server->sxasize > server_sxa_sz)\n\t\tserver->sxasize = server_sxa_sz;\n\tif (server->lxasize > server_lxa_sz)\n\t\tserver->lxasize = server_lxa_sz;\n#endif\n}\n\nstatic int nfs4_server_common_setup(struct nfs_server *server,\n\t\tstruct nfs_fh *mntfh, bool auth_probe)\n{\n\tstruct nfs_fattr *fattr;\n\tint error;\n\n\t/* data servers support only a subset of NFSv4.1 */\n\tif (is_ds_only_client(server->nfs_client))\n\t\treturn -EPROTONOSUPPORT;\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\treturn -ENOMEM;\n\n\t/* We must ensure the session is initialised first */\n\terror = nfs4_init_session(server->nfs_client);\n\tif (error < 0)\n\t\tgoto out;\n\n\t/* Set the basic capabilities */\n\tserver->caps |= server->nfs_client->cl_mvops->init_caps;\n\tif (server->flags & NFS_MOUNT_NORDIRPLUS)\n\t\t\tserver->caps &= ~NFS_CAP_READDIRPLUS;\n\tif (server->nfs_client->cl_proto == XPRT_TRANSPORT_RDMA)\n\t\tserver->caps &= ~NFS_CAP_READ_PLUS;\n\t/*\n\t * Don't use NFS uid/gid mapping if we're using AUTH_SYS or lower\n\t * authentication.\n\t */\n\tif (nfs4_disable_idmapping &&\n\t\t\tserver->client->cl_auth->au_flavor == RPC_AUTH_UNIX)\n\t\tserver->caps |= NFS_CAP_UIDGID_NOMAP;\n\n\n\t/* Probe the root fh to retrieve its FSID and filehandle */\n\terror = nfs4_get_rootfh(server, mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto out;\n\n\tdprintk(\"Server FSID: %llx:%llx\\n\",\n\t\t\t(unsigned long long) server->fsid.major,\n\t\t\t(unsigned long long) server->fsid.minor);\n\tnfs_display_fhandle(mntfh, \"Pseudo-fs root FH\");\n\n\terror = nfs_probe_fsinfo(server, mntfh, fattr);\n\tif (error < 0)\n\t\tgoto out;\n\n\tnfs4_session_limit_rwsize(server);\n\tnfs4_session_limit_xasize(server);\n\n\tif (server->namelen == 0 || server->namelen > NFS4_MAXNAMLEN)\n\t\tserver->namelen = NFS4_MAXNAMLEN;\n\n\tnfs_server_insert_lists(server);\n\tserver->mount_time = jiffies;\n\tserver->destroy = nfs4_destroy_server;\nout:\n\tnfs_free_fattr(fattr);\n\treturn error;\n}\n\n/*\n * Create a version 4 volume record\n */\nstatic int nfs4_init_server(struct nfs_server *server, struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct rpc_timeout timeparms;\n\tint error;\n\n\tnfs_init_timeout_values(&timeparms, ctx->nfs_server.protocol,\n\t\t\t\tctx->timeo, ctx->retrans);\n\n\t/* Initialise the client representation from the mount data */\n\tserver->flags = ctx->flags;\n\tserver->options = ctx->options;\n\tserver->auth_info = ctx->auth_info;\n\n\t/* Use the first specified auth flavor. If this flavor isn't\n\t * allowed by the server, use the SECINFO path to try the\n\t * other specified flavors */\n\tif (ctx->auth_info.flavor_len >= 1)\n\t\tctx->selected_flavor = ctx->auth_info.flavors[0];\n\telse\n\t\tctx->selected_flavor = RPC_AUTH_UNIX;\n\n\t/* Get a client record */\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server.address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tctx->client_address,\n\t\t\t\tctx->nfs_server.protocol,\n\t\t\t\t&timeparms,\n\t\t\t\tctx->minorversion,\n\t\t\t\tctx->nfs_server.nconnect,\n\t\t\t\tfc->net_ns);\n\tif (error < 0)\n\t\treturn error;\n\n\tif (ctx->rsize)\n\t\tserver->rsize = nfs_block_size(ctx->rsize, NULL);\n\tif (ctx->wsize)\n\t\tserver->wsize = nfs_block_size(ctx->wsize, NULL);\n\n\tserver->acregmin = ctx->acregmin * HZ;\n\tserver->acregmax = ctx->acregmax * HZ;\n\tserver->acdirmin = ctx->acdirmin * HZ;\n\tserver->acdirmax = ctx->acdirmax * HZ;\n\tserver->port     = ctx->nfs_server.port;\n\n\treturn nfs_init_server_rpcclient(server, &timeparms,\n\t\t\t\t\t ctx->selected_flavor);\n}\n\n/*\n * Create a version 4 volume record\n * - keyed on server and FSID\n */\nstruct nfs_server *nfs4_create_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_server *server;\n\tbool auth_probe;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tserver->cred = get_cred(fc->cred);\n\n\tauth_probe = ctx->auth_info.flavor_len < 1;\n\n\t/* set up the general RPC client */\n\terror = nfs4_init_server(server, fc);\n\tif (error < 0)\n\t\tgoto error;\n\n\terror = nfs4_server_common_setup(server, ctx->mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto error;\n\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\n\n/*\n * Create an NFS4 referral server record\n */\nstruct nfs_server *nfs4_create_referral_server(struct fs_context *fc)\n{\n\tstruct nfs_fs_context *ctx = nfs_fc2context(fc);\n\tstruct nfs_client *parent_client;\n\tstruct nfs_server *server, *parent_server;\n\tbool auth_probe;\n\tint error;\n\n\tserver = nfs_alloc_server();\n\tif (!server)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tparent_server = NFS_SB(ctx->clone_data.sb);\n\tparent_client = parent_server->nfs_client;\n\n\tserver->cred = get_cred(parent_server->cred);\n\n\t/* Initialise the client representation from the parent server */\n\tnfs_server_copy_userdata(server, parent_server);\n\n\t/* Get a client representation */\n#if IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA)\n\trpc_set_port(&ctx->nfs_server.address, NFS_RDMA_PORT);\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server.address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tparent_client->cl_ipaddr,\n\t\t\t\tXPRT_TRANSPORT_RDMA,\n\t\t\t\tparent_server->client->cl_timeout,\n\t\t\t\tparent_client->cl_mvops->minor_version,\n\t\t\t\tparent_client->cl_nconnect,\n\t\t\t\tparent_client->cl_net);\n\tif (!error)\n\t\tgoto init_server;\n#endif\t/* IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA) */\n\n\trpc_set_port(&ctx->nfs_server.address, NFS_PORT);\n\terror = nfs4_set_client(server,\n\t\t\t\tctx->nfs_server.hostname,\n\t\t\t\t&ctx->nfs_server.address,\n\t\t\t\tctx->nfs_server.addrlen,\n\t\t\t\tparent_client->cl_ipaddr,\n\t\t\t\tXPRT_TRANSPORT_TCP,\n\t\t\t\tparent_server->client->cl_timeout,\n\t\t\t\tparent_client->cl_mvops->minor_version,\n\t\t\t\tparent_client->cl_nconnect,\n\t\t\t\tparent_client->cl_net);\n\tif (error < 0)\n\t\tgoto error;\n\n#if IS_ENABLED(CONFIG_SUNRPC_XPRT_RDMA)\ninit_server:\n#endif\n\terror = nfs_init_server_rpcclient(server, parent_server->client->cl_timeout,\n\t\t\t\t\t  ctx->selected_flavor);\n\tif (error < 0)\n\t\tgoto error;\n\n\tauth_probe = parent_server->auth_info.flavor_len < 1;\n\n\terror = nfs4_server_common_setup(server, ctx->mntfh, auth_probe);\n\tif (error < 0)\n\t\tgoto error;\n\n\treturn server;\n\nerror:\n\tnfs_free_server(server);\n\treturn ERR_PTR(error);\n}\n\n/*\n * Grab the destination's particulars, including lease expiry time.\n *\n * Returns zero if probe succeeded and retrieved FSID matches the FSID\n * we have cached.\n */\nstatic int nfs_probe_destination(struct nfs_server *server)\n{\n\tstruct inode *inode = d_inode(server->super->s_root);\n\tstruct nfs_fattr *fattr;\n\tint error;\n\n\tfattr = nfs_alloc_fattr();\n\tif (fattr == NULL)\n\t\treturn -ENOMEM;\n\n\t/* Sanity: the probe won't work if the destination server\n\t * does not recognize the migrated FH. */\n\terror = nfs_probe_fsinfo(server, NFS_FH(inode), fattr);\n\n\tnfs_free_fattr(fattr);\n\treturn error;\n}\n\n/**\n * nfs4_update_server - Move an nfs_server to a different nfs_client\n *\n * @server: represents FSID to be moved\n * @hostname: new end-point's hostname\n * @sap: new end-point's socket address\n * @salen: size of \"sap\"\n * @net: net namespace\n *\n * The nfs_server must be quiescent before this function is invoked.\n * Either its session is drained (NFSv4.1+), or its transport is\n * plugged and drained (NFSv4.0).\n *\n * Returns zero on success, or a negative errno value.\n */\nint nfs4_update_server(struct nfs_server *server, const char *hostname,\n\t\t       struct sockaddr *sap, size_t salen, struct net *net)\n{\n\tstruct nfs_client *clp = server->nfs_client;\n\tstruct rpc_clnt *clnt = server->client;\n\tstruct xprt_create xargs = {\n\t\t.ident\t\t= clp->cl_proto,\n\t\t.net\t\t= net,\n\t\t.dstaddr\t= sap,\n\t\t.addrlen\t= salen,\n\t\t.servername\t= hostname,\n\t};\n\tchar buf[INET6_ADDRSTRLEN + 1];\n\tstruct sockaddr_storage address;\n\tstruct sockaddr *localaddr = (struct sockaddr *)&address;\n\tint error;\n\n\terror = rpc_switch_client_transport(clnt, &xargs, clnt->cl_timeout);\n\tif (error != 0)\n\t\treturn error;\n\n\terror = rpc_localaddr(clnt, localaddr, sizeof(address));\n\tif (error != 0)\n\t\treturn error;\n\n\tif (rpc_ntop(localaddr, buf, sizeof(buf)) == 0)\n\t\treturn -EAFNOSUPPORT;\n\n\tnfs_server_remove_lists(server);\n\tset_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\n\terror = nfs4_set_client(server, hostname, sap, salen, buf,\n\t\t\t\tclp->cl_proto, clnt->cl_timeout,\n\t\t\t\tclp->cl_minorversion,\n\t\t\t\tclp->cl_nconnect, net);\n\tclear_bit(NFS_MIG_TSM_POSSIBLE, &server->mig_status);\n\tif (error != 0) {\n\t\tnfs_server_insert_lists(server);\n\t\treturn error;\n\t}\n\tnfs_put_client(clp);\n\n\tif (server->nfs_client->cl_hostname == NULL)\n\t\tserver->nfs_client->cl_hostname = kstrdup(hostname, GFP_KERNEL);\n\tnfs_server_insert_lists(server);\n\n\treturn nfs_probe_destination(server);\n}\n"], "filenames": ["fs/nfs/nfs4client.c"], "buggy_code_start_loc": [199], "buggy_code_end_loc": [420], "fixing_code_start_loc": [200], "fixing_code_end_loc": [421], "type": "NVD-CWE-noinfo", "message": "fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection.", "other": {"cve": {"id": "CVE-2021-38199", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-08T20:15:07.073", "lastModified": "2021-12-21T12:54:21.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fs/nfs/nfs4client.c in the Linux kernel before 5.13.4 has incorrect connection-setup ordering, which allows operators of remote NFSv4 servers to cause a denial of service (hanging of mounts) by arranging for those servers to be unreachable during trunking detection."}, {"lang": "es", "value": "El archivo fs/nfs/nfs4client.c en el kernel de Linux versiones anteriores a 5.13.4, presenta un ordenamiento incorrecto de la configuraci\u00f3n de la conexi\u00f3n, que permite a operadores de servidores NFSv4 remotos causar una denegaci\u00f3n de servicio (cuelgue de montajes) al disponer de que esos servidores sean inalcanzables durante la detecci\u00f3n de trunking"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.13.4", "matchCriteriaId": "4C85356F-2C6C-4FB9-B0CA-949711182223"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:hci_bootstrap_os:-:*:*:*:*:*:*:*", "matchCriteriaId": "1C767AA1-88B7-48F0-9F31-A89D16DCD52C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_compute_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "AD7447BC-F315-4298-A822-549942FC118B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:hci_management_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "A3C19813-E823-456A-B1CE-EC0684CE1953"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:solidfire:-:*:*:*:*:*:*:*", "matchCriteriaId": "A6E9EF0C-AFA8-4F7B-9FDC-1E0F7C26E737"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:element_software:-:*:*:*:*:*:*:*", "matchCriteriaId": "85DF4B3F-4BBC-42B7-B729-096934523D63"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:hci_storage_node:-:*:*:*:*:*:*:*", "matchCriteriaId": "02DEB4FB-A21D-4CB1-B522-EEE5093E8521"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.13.4", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/dd99e9f98fbf423ff6d365b37a98e8879170f17c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/10/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00012.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210902-0010/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2021/dsa-4978", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/dd99e9f98fbf423ff6d365b37a98e8879170f17c"}}