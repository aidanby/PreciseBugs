{"buggy_code": ["/**\n * This file is part of alf.io.\n *\n * alf.io is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * alf.io is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage alfio.util;\n\nimport alfio.controller.api.support.TicketHelper;\nimport com.samskivert.mustache.Mustache;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.commonmark.Extension;\nimport org.commonmark.ext.gfm.tables.TablesExtension;\nimport org.commonmark.node.Link;\nimport org.commonmark.node.Node;\nimport org.commonmark.node.Text;\nimport org.commonmark.parser.Parser;\nimport org.commonmark.renderer.html.AttributeProvider;\nimport org.commonmark.renderer.html.HtmlRenderer;\nimport org.commonmark.renderer.text.TextContentRenderer;\nimport org.springframework.security.web.util.UrlUtils;\n\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\nimport static org.apache.commons.lang3.StringUtils.substring;\n\n/**\n * For formatting date in a mustache template.\n *\n * <p>\n * Syntax is: {{#format-date}}{{yourDate}} FORMAT locale:YOUR_LOCALE{{/format-date}}.\n * </p>\n * <p>\n * Where\n * </p>\n * <ul>\n * <li>yourDate has been formatted following the java.time.ZonedDateTime\n * <li>FORMAT is a format understood by {@link DateTimeFormatter}</li>\n * <li>optional: locale:YOUR_LOCALE you can define the locale</li>\n * </ul>\n */\n@Log4j2\npublic class MustacheCustomTag {\n\n    private MustacheCustomTag() {}\n\n    private static final Pattern ARG_PATTERN = Pattern.compile(\"\\\\[(.*?)]\");\n    private static final String LOCALE_LABEL = \"locale:\";\n\n    static final Mustache.Lambda FORMAT_DATE = (frag, out) -> {\n        String execution = frag.execute().trim();\n        ZonedDateTime d = ZonedDateTime.parse(substring(execution, 0, execution.indexOf(' ')));\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        if (p.getRight().isPresent()) {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft(), p.getRight().get()).format(d));\n        } else {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft()).format(d));\n        }\n    };\n\n    /**\n     * {{#render-markdown}}[markdown][.html|.text]{{/render-markdown}}\n     * The string must end with either .html or .text, otherwise Markdown won't be parsed\n     * e.g.\n     * {{#render-markdown}}(link)[description].html{{/render-markdown}} will produce HTML output\n     * {{#render-markdown}}(link)[description].text{{/render-markdown}} will produce text/plain output\n     */\n    static final Mustache.Lambda RENDER_MARKDOWN = (frag, out) -> {\n        String execution = frag.execute().strip();\n        if(execution.endsWith(\".html\")) {\n            out.write(renderToHtmlCommonmarkEscaped(StringUtils.removeEnd(execution, \".html\")));\n        } else if(execution.endsWith(\".text\")) {\n            out.write(renderToTextCommonmark(StringUtils.removeEnd(execution, \".text\")));\n        } else {\n            out.write(execution);\n        }\n    };\n\n    static final Mustache.Lambda COUNTRY_NAME = (frag, out) -> {\n        String execution = frag.execute().trim();\n        String code = substring(execution, 0, 2);\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        out.write(translateCountryCode(code, p.getRight().orElse(null)));\n    };\n\n    static String translateCountryCode(String code, Locale locale) {\n        Locale lang = locale != null ? locale : Locale.ENGLISH;\n        return Stream.concat(TicketHelper.getLocalizedCountries(lang).stream(), TicketHelper.getLocalizedCountriesForVat(lang).stream())\n            .filter(p -> p.getKey().equalsIgnoreCase(code))\n            .map(Pair::getValue)\n            .findFirst()\n            .orElse(code);\n    }\n\n    /**\n     * {{#additional-field-value}}[Prefix][name][suffix]{{/additional-field-value}}\n     * prefix is optional, unless a suffix is needed.\n     */\n    static final Function<Object, Mustache.Lambda> ADDITIONAL_FIELD_VALUE = obj -> (frag, out) -> {\n        if( !(obj instanceof Map) || ((Map<?,?>)obj).isEmpty()) {\n            log.warn(\"map not found or empty. Skipping additionalFieldValue tag\");\n            return;\n        }\n        Map<?, ?> fieldNamesAndValues = (Map<?, ?>) obj;\n        String execution = frag.execute().trim();\n        Matcher matcher = ARG_PATTERN.matcher(execution);\n        List<String> args = new ArrayList<>();\n        while(matcher.find()) {\n            args.add(matcher.group(1));\n        }\n        if(args.isEmpty()) {\n            return;\n        }\n        String name = args.get(args.size() > 1 ? 1 : 0);\n        String prefix = args.size() > 1 ? args.get(0) + \" \" : \"\";\n        String suffix = args.size() > 2 ? \" \"+args.get(2) : \"\";\n\n        if(fieldNamesAndValues.containsKey(name)) {\n            out.write(prefix + fieldNamesAndValues.get(name) + suffix);\n        }\n    };\n\n    private static Pair<String, Optional<Locale>> parseParams(String r) {\n\n        int indexLocale = r.indexOf(LOCALE_LABEL);\n        int end = Math.min(r.length(), indexLocale != -1 ? indexLocale : r.length());\n        String format = substring(r, r.indexOf(' '), end);\n\n        //\n        String[] res = r.split(\"\\\\s+\");\n        Optional<Locale> locale = Arrays.stream(res).filter(s -> s.startsWith(LOCALE_LABEL)).findFirst()\n                .map(l -> LocaleUtil.forLanguageTag(substring(l, LOCALE_LABEL.length())));\n        //\n\n        return Pair.of(format, locale);\n    }\n\n\n    private static final List<Extension> COMMONMARK_EXTENSIONS = List.of(TablesExtension.create());\n    private static final Parser COMMONMARK_PARSER = Parser.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final HtmlRenderer COMMONMARK_RENDERER = HtmlRenderer.builder().extensions(COMMONMARK_EXTENSIONS).attributeProviderFactory((ctx) -> new TargetBlankProvider()).build();\n    private static final TextContentRenderer COMMONMARK_TEXT_RENDERER = TextContentRenderer.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final ThreadLocal<String> A11Y_NEW_TAB_LABEL = new ThreadLocal<>();\n\n    //Open in a new window if the link contains an absolute url\n    private static class TargetBlankProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }\n    }\n    public static String renderToHtmlCommonmarkEscaped(String input) {\n        return renderToHtmlCommonmarkEscaped(input, null);\n    }\n\n    public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n        try {\n            A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);\n            Node document = COMMONMARK_PARSER.parse(StringEscapeUtils.escapeHtml4(input));\n            return COMMONMARK_RENDERER.render(document);\n        } finally {\n            A11Y_NEW_TAB_LABEL.remove();\n        }\n    }\n\n    public static String renderToTextCommonmark(String input) {\n        Node document = COMMONMARK_PARSER.parse(input);\n        return COMMONMARK_TEXT_RENDERER.render(document);\n    }\n}\n", "/**\n * This file is part of alf.io.\n *\n * alf.io is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * alf.io is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage alfio.util;\n\nimport com.samskivert.mustache.Template;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Collections;\nimport java.util.Locale;\n\nimport static alfio.util.MustacheCustomTag.ADDITIONAL_FIELD_VALUE;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\npublic class MustacheCustomTagTest {\n\n    private Template.Fragment fragment = Mockito.mock(Template.Fragment.class);\n    private Writer out = Mockito.mock(Writer.class);\n\n    @Test\n    public void translateCountryCode() {\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"GR\", null));\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"EL\", null));\n        assertEquals(\"Grecia\", MustacheCustomTag.translateCountryCode(\"EL\", Locale.ITALIAN));\n    }\n\n    @Test\n    public void additionalFieldValueMapIsEmptyOrNull() throws IOException {\n        ADDITIONAL_FIELD_VALUE.apply(Collections.emptyMap()).execute(fragment, out);\n        ADDITIONAL_FIELD_VALUE.apply(null).execute(fragment, out);\n        verifyNoMoreInteractions(fragment, out);\n    }\n\n    @Test\n    public void additionalFieldValueMapDoesNotContainValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[not-existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"test\", \"test\")).execute(fragment, out);\n        verifyNoMoreInteractions(out);\n    }\n\n    @Test\n    public void additionalFieldValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"existing value\");\n    }\n\n    @Test\n    public void additionalFieldValuePrefix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value\");\n    }\n\n    @Test\n    public void additionalFieldValueSuffix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing][suffix-]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value suffix-\");\n    }\n\n    @Test\n    public void testHtmlMarkDown() {\n        //by default we escape all html\n        assertEquals(\"<p>escape &lt;a href=&quot;http://test&quot;&gt;bla&lt;/a&gt; escape</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"escape <a href=\\\"http://test\\\">bla</a> escape\"));\n\n        //for relative link we don't add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"/test\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](/test) link\"));\n\n        //for absolute link we add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"http://test\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](http://test) link\"));\n    }\n}"], "fixing_code": ["/**\n * This file is part of alf.io.\n *\n * alf.io is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * alf.io is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage alfio.util;\n\nimport alfio.controller.api.support.TicketHelper;\nimport com.samskivert.mustache.Mustache;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.tuple.Pair;\nimport org.apache.commons.text.StringEscapeUtils;\nimport org.commonmark.Extension;\nimport org.commonmark.ext.gfm.tables.TablesExtension;\nimport org.commonmark.node.Link;\nimport org.commonmark.node.Node;\nimport org.commonmark.node.Text;\nimport org.commonmark.parser.Parser;\nimport org.commonmark.renderer.html.AttributeProvider;\nimport org.commonmark.renderer.html.HtmlRenderer;\nimport org.commonmark.renderer.text.TextContentRenderer;\nimport org.springframework.security.web.util.UrlUtils;\n\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\nimport static org.apache.commons.lang3.StringUtils.substring;\n\n/**\n * For formatting date in a mustache template.\n *\n * <p>\n * Syntax is: {{#format-date}}{{yourDate}} FORMAT locale:YOUR_LOCALE{{/format-date}}.\n * </p>\n * <p>\n * Where\n * </p>\n * <ul>\n * <li>yourDate has been formatted following the java.time.ZonedDateTime\n * <li>FORMAT is a format understood by {@link DateTimeFormatter}</li>\n * <li>optional: locale:YOUR_LOCALE you can define the locale</li>\n * </ul>\n */\n@Log4j2\npublic class MustacheCustomTag {\n\n    private MustacheCustomTag() {}\n\n    private static final Pattern ARG_PATTERN = Pattern.compile(\"\\\\[(.*?)]\");\n    private static final String LOCALE_LABEL = \"locale:\";\n\n    static final Mustache.Lambda FORMAT_DATE = (frag, out) -> {\n        String execution = frag.execute().trim();\n        ZonedDateTime d = ZonedDateTime.parse(substring(execution, 0, execution.indexOf(' ')));\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        if (p.getRight().isPresent()) {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft(), p.getRight().get()).format(d));\n        } else {\n            out.write(DateTimeFormatter.ofPattern(p.getLeft()).format(d));\n        }\n    };\n\n    /**\n     * {{#render-markdown}}[markdown][.html|.text]{{/render-markdown}}\n     * The string must end with either .html or .text, otherwise Markdown won't be parsed\n     * e.g.\n     * {{#render-markdown}}(link)[description].html{{/render-markdown}} will produce HTML output\n     * {{#render-markdown}}(link)[description].text{{/render-markdown}} will produce text/plain output\n     */\n    static final Mustache.Lambda RENDER_MARKDOWN = (frag, out) -> {\n        String execution = frag.execute().strip();\n        if(execution.endsWith(\".html\")) {\n            out.write(renderToHtmlCommonmarkEscaped(StringUtils.removeEnd(execution, \".html\")));\n        } else if(execution.endsWith(\".text\")) {\n            out.write(renderToTextCommonmark(StringUtils.removeEnd(execution, \".text\")));\n        } else {\n            out.write(execution);\n        }\n    };\n\n    static final Mustache.Lambda COUNTRY_NAME = (frag, out) -> {\n        String execution = frag.execute().trim();\n        String code = substring(execution, 0, 2);\n        Pair<String, Optional<Locale>> p = parseParams(execution);\n        out.write(translateCountryCode(code, p.getRight().orElse(null)));\n    };\n\n    static String translateCountryCode(String code, Locale locale) {\n        Locale lang = locale != null ? locale : Locale.ENGLISH;\n        return Stream.concat(TicketHelper.getLocalizedCountries(lang).stream(), TicketHelper.getLocalizedCountriesForVat(lang).stream())\n            .filter(p -> p.getKey().equalsIgnoreCase(code))\n            .map(Pair::getValue)\n            .findFirst()\n            .orElse(code);\n    }\n\n    /**\n     * {{#additional-field-value}}[Prefix][name][suffix]{{/additional-field-value}}\n     * prefix is optional, unless a suffix is needed.\n     */\n    static final Function<Object, Mustache.Lambda> ADDITIONAL_FIELD_VALUE = obj -> (frag, out) -> {\n        if( !(obj instanceof Map) || ((Map<?,?>)obj).isEmpty()) {\n            log.warn(\"map not found or empty. Skipping additionalFieldValue tag\");\n            return;\n        }\n        Map<?, ?> fieldNamesAndValues = (Map<?, ?>) obj;\n        String execution = frag.execute().trim();\n        Matcher matcher = ARG_PATTERN.matcher(execution);\n        List<String> args = new ArrayList<>();\n        while(matcher.find()) {\n            args.add(matcher.group(1));\n        }\n        if(args.isEmpty()) {\n            return;\n        }\n        String name = args.get(args.size() > 1 ? 1 : 0);\n        String prefix = args.size() > 1 ? args.get(0) + \" \" : \"\";\n        String suffix = args.size() > 2 ? \" \"+args.get(2) : \"\";\n\n        if(fieldNamesAndValues.containsKey(name)) {\n            out.write(prefix + fieldNamesAndValues.get(name) + suffix);\n        }\n    };\n\n    private static Pair<String, Optional<Locale>> parseParams(String r) {\n\n        int indexLocale = r.indexOf(LOCALE_LABEL);\n        int end = Math.min(r.length(), indexLocale != -1 ? indexLocale : r.length());\n        String format = substring(r, r.indexOf(' '), end);\n\n        //\n        String[] res = r.split(\"\\\\s+\");\n        Optional<Locale> locale = Arrays.stream(res).filter(s -> s.startsWith(LOCALE_LABEL)).findFirst()\n                .map(l -> LocaleUtil.forLanguageTag(substring(l, LOCALE_LABEL.length())));\n        //\n\n        return Pair.of(format, locale);\n    }\n\n\n    private static final List<Extension> COMMONMARK_EXTENSIONS = List.of(TablesExtension.create());\n    private static final Parser COMMONMARK_PARSER = Parser.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final HtmlRenderer COMMONMARK_RENDERER = HtmlRenderer.builder().extensions(COMMONMARK_EXTENSIONS).attributeProviderFactory((ctx) -> new TargetBlankProvider()).build();\n    private static final TextContentRenderer COMMONMARK_TEXT_RENDERER = TextContentRenderer.builder().extensions(COMMONMARK_EXTENSIONS).build();\n    private static final ThreadLocal<String> A11Y_NEW_TAB_LABEL = new ThreadLocal<>();\n\n    //Open in a new window if the link contains an absolute url\n    private static class TargetBlankProvider implements AttributeProvider {\n        @Override\n        public void setAttributes(Node node, String tagName, Map<String, String> attributes) {\n            if (node instanceof Link) {\n                Link l = (Link) node;\n                String destination = StringUtils.trimToEmpty(l.getDestination());\n                var scheme = getScheme(destination);\n                scheme.ifPresent(resolvedScheme -> {\n                    if (!Set.of(\"http\", \"https\").contains(resolvedScheme)) {\n                        log.info(\"User tried to set an url with scheme {}, only http/https are accepted, href has been removed\", resolvedScheme);\n                        attributes.remove(\"href\");\n                    }\n                });\n                if (UrlUtils.isAbsoluteUrl(destination)) {\n                    // accept only http or https protocols if we have an absolute link, else we override with an empty string\n                    attributes.put(\"target\", \"_blank\");\n                    attributes.put(\"rel\", \"nofollow noopener noreferrer\");\n                    var newTabLabel = A11Y_NEW_TAB_LABEL.get();\n                    if (newTabLabel != null) {\n                        attributes.put(\"aria-label\", ((Text)node.getFirstChild()).getLiteral() + \" \" + newTabLabel);\n                    }\n                }\n            }\n        }\n    }\n    public static String renderToHtmlCommonmarkEscaped(String input) {\n        return renderToHtmlCommonmarkEscaped(input, null);\n    }\n\n    /**\n     * return lowercase scheme if present\n     */\n    private static Optional<String> getScheme(String uri) {\n        var s = StringUtils.trimToEmpty(uri).toLowerCase(Locale.ROOT);\n        return s.indexOf(':') >= 0 ? Optional.of(StringUtils.substringBefore(s, ':')) : Optional.empty();\n    }\n\n    public static String renderToHtmlCommonmarkEscaped(String input, String localizedNewWindowLabel) {\n        try {\n            A11Y_NEW_TAB_LABEL.set(localizedNewWindowLabel);\n            Node document = COMMONMARK_PARSER.parse(StringEscapeUtils.escapeHtml4(input));\n            return COMMONMARK_RENDERER.render(document);\n        } finally {\n            A11Y_NEW_TAB_LABEL.remove();\n        }\n    }\n\n    public static String renderToTextCommonmark(String input) {\n        Node document = COMMONMARK_PARSER.parse(input);\n        return COMMONMARK_TEXT_RENDERER.render(document);\n    }\n}\n", "/**\n * This file is part of alf.io.\n *\n * alf.io is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * alf.io is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with alf.io.  If not, see <http://www.gnu.org/licenses/>.\n */\npackage alfio.util;\n\nimport com.samskivert.mustache.Template;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Collections;\nimport java.util.Locale;\n\nimport static alfio.util.MustacheCustomTag.ADDITIONAL_FIELD_VALUE;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.*;\n\npublic class MustacheCustomTagTest {\n\n    private Template.Fragment fragment = Mockito.mock(Template.Fragment.class);\n    private Writer out = Mockito.mock(Writer.class);\n\n    @Test\n    public void translateCountryCode() {\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"GR\", null));\n        assertEquals(\"Greece\", MustacheCustomTag.translateCountryCode(\"EL\", null));\n        assertEquals(\"Grecia\", MustacheCustomTag.translateCountryCode(\"EL\", Locale.ITALIAN));\n    }\n\n    @Test\n    public void additionalFieldValueMapIsEmptyOrNull() throws IOException {\n        ADDITIONAL_FIELD_VALUE.apply(Collections.emptyMap()).execute(fragment, out);\n        ADDITIONAL_FIELD_VALUE.apply(null).execute(fragment, out);\n        verifyNoMoreInteractions(fragment, out);\n    }\n\n    @Test\n    public void additionalFieldValueMapDoesNotContainValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[not-existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"test\", \"test\")).execute(fragment, out);\n        verifyNoMoreInteractions(out);\n    }\n\n    @Test\n    public void additionalFieldValue() throws IOException {\n        when(fragment.execute()).thenReturn(\"[existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"existing value\");\n    }\n\n    @Test\n    public void additionalFieldValuePrefix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value\");\n    }\n\n    @Test\n    public void additionalFieldValueSuffix() throws IOException {\n        when(fragment.execute()).thenReturn(\"[prefix!][existing][suffix-]\");\n        ADDITIONAL_FIELD_VALUE.apply(Collections.singletonMap(\"existing\", \"existing value\")).execute(fragment, out);\n        verify(out).write(\"prefix! existing value suffix-\");\n    }\n\n    @Test\n    public void testHtmlMarkDown() {\n        //by default we escape all html\n        assertEquals(\"<p>escape &lt;a href=&quot;http://test&quot;&gt;bla&lt;/a&gt; escape</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"escape <a href=\\\"http://test\\\">bla</a> escape\"));\n\n        //for relative link we don't add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"/test\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](/test) link\"));\n\n        //for absolute link we add target=\"_blank\"\n        assertEquals(\"<p>link <a href=\\\"http://test\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">bla</a> link</p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"link [bla](http://test) link\"));\n    }\n\n    @Test\n    public void acceptOnlyHttpOrHttpsProtocols() {\n        assertEquals(\"<p><a href=\\\"http://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](http://google.com)\"));\n        assertEquals(\"<p><a href=\\\"https://google.com\\\" target=\\\"_blank\\\" rel=\\\"nofollow noopener noreferrer\\\">google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](https://google.com)\"));\n        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](any:google.com)\"));\n        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](other:google.com)\"));\n        assertEquals(\"<p><a>google</a></p>\\n\", MustacheCustomTag.renderToHtmlCommonmarkEscaped(\"[google](protocols:/google.com)\"));\n    }\n}"], "filenames": ["src/main/java/alfio/util/MustacheCustomTag.java", "src/test/java/alfio/util/MustacheCustomTagTest.java"], "buggy_code_start_loc": [170, 89], "buggy_code_end_loc": [185, 89], "fixing_code_start_loc": [171, 90], "fixing_code_end_loc": [202, 99], "type": "CWE-79", "message": "Cross-site Scripting (XSS) - Stored in GitHub repository alfio-event/alf.io prior to Alf.io 2.0-M4-2301.", "other": {"cve": {"id": "CVE-2023-0301", "sourceIdentifier": "security@huntr.dev", "published": "2023-01-14T18:15:09.987", "lastModified": "2023-01-24T18:14:23.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site Scripting (XSS) - Stored in GitHub repository alfio-event/alf.io prior to Alf.io 2.0-M4-2301."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.4}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opencollective:alf.io:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0-m4-2301", "matchCriteriaId": "B9FB5ECA-1427-4BF0-B085-59F23FC93247"}]}]}], "references": [{"url": "https://github.com/alfio-event/alf.io/commit/21cb2866e5f58b4a2b4a2cb0066479bbb26f7b39", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/8a91e127-2903-4c6b-9a66-e4d2e30f8dec", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/alfio-event/alf.io/commit/21cb2866e5f58b4a2b4a2cb0066479bbb26f7b39"}}